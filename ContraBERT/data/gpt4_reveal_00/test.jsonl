{"code":"DVMuxContext* dv_init_mux(AVFormatContext* s)\n\n{\n\n    DVMuxContext *c;\n\n    AVStream *vst = NULL;\n\n    int i;\n\n\n\n    \/* we support at most 1 video and 2 audio streams *\/\n\n    if (s->nb_streams > 3)\n\n        return NULL;\n\n\n\n    c = av_mallocz(sizeof(DVMuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->n_ast = 0;\n\n    c->ast[0] = c->ast[1] = NULL;\n\n\n\n    \/* We have to sort out where audio and where video stream is *\/\n\n    for (i=0; i<s->nb_streams; i++) {\n\n         switch (s->streams[i]->codec->codec_type) {\n\n         case CODEC_TYPE_VIDEO:\n\n               vst = s->streams[i];\n\n               break;\n\n         case CODEC_TYPE_AUDIO:\n\n             c->ast[c->n_ast++] = s->streams[i];\n\n             break;\n\n         default:\n\n               goto bail_out;\n\n         }\n\n    }\n\n\n\n    \/* Some checks -- DV format is very picky about its incoming streams *\/\n\n    if (!vst || vst->codec->codec_id != CODEC_ID_DVVIDEO)\n\n        goto bail_out;\n\n    for (i=0; i<c->n_ast; i++) {\n\n        if (c->ast[i] && (c->ast[i]->codec->codec_id != CODEC_ID_PCM_S16LE ||\n\n                          c->ast[i]->codec->sample_rate != 48000 ||\n\n                          c->ast[i]->codec->channels != 2))\n\n            goto bail_out;\n\n    }\n\n    c->sys = dv_codec_profile(vst->codec);\n\n    if (!c->sys)\n\n        goto bail_out;\n\n\n\n    if((c->n_ast > 1) && (c->sys->n_difchan < 2)) {\n\n        \/* only 1 stereo pair is allowed in 25Mbps mode *\/\n\n        goto bail_out;\n\n    }\n\n\n\n    \/* Ok, everything seems to be in working order *\/\n\n    c->frames = 0;\n\n    c->has_audio = 0;\n\n    c->has_video = 0;\n\n    c->start_time = (time_t)s->timestamp;\n\n\n\n    for (i=0; i<c->n_ast; i++) {\n\n        if (c->ast[i] && av_fifo_init(&c->audio_data[i], 100*AVCODEC_MAX_AUDIO_FRAME_SIZE) < 0) {\n\n            while (i>0) {\n\n                i--;\n\n                av_fifo_free(&c->audio_data[i]);\n\n            }\n\n            goto bail_out;\n\n        }\n\n    }\n\n\n\n    return c;\n\n\n\nbail_out:\n\n    av_free(c);\n\n    return NULL;\n\n}\n","idx":"0008afc59c240271827d8a0fc747179da905050f","target":1}
{"code":"static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size, VMStateField *field) {\n    uint64_t *v = pv;\n    *v = (uint64_t)qemu_get_be32(f) & 0xFFFFFFFF;\n    return 0;\n}","idx":"08b277ac46da8b02e50cec455eca7cb2d12ffcf0","target":0}
{"code":"static void perf_lifecycle(void)\n\n{\n\n    Coroutine *coroutine;\n\n    unsigned int i, max;\n\n    double duration;\n\n\n\n    max = 1000000;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < max; i++) {\n\n        coroutine = qemu_coroutine_create(empty_coroutine);\n\n        qemu_coroutine_enter(coroutine, NULL);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Lifecycle %u iterations: %f s\\n\", max, duration);\n\n}\n","idx":"0b8b8753e4d94901627b3e86431230f2319215c4","target":1}
{"code":"static void virt_acpi_build_update(void* build_opaque) {\n    AcpiBuildState* build_state = build_opaque;\n    AcpiBuildTables tables;\n    \/*No state to update or already patched? Nothing to do.*\/\n    if (!build_state || build_state->patched) {\n        return;\n    }\n    build_state->patched = true;\n    acpi_build_tables_init(&tables);\n    virt_acpi_build(build_state->guest_info, &tables);\n    if (tables.table_data) {\n        acpi_ram_update(build_state->table_mr, tables.table_data);\n    }\n    if (tables.rsdp) {\n        acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n    }\n    if (tables.linker) {\n        acpi_ram_update(build_state->linker_mr, tables.linker);\n    }\n    acpi_build_tables_cleanup(&tables, true);\n}","idx":"0e9b9edae7bebfd31fdbead4ccbbce03876a7edd","target":0}
{"code":"static void encode_gray_bitstream(HYuvContext *s, int count){\n\n    int i;\n\n    \n\n    count\/=2;\n\n    if(s->flags&CODEC_FLAG_PASS1){\n\n        for(i=0; i<count; i++){\n\n            s->stats[0][ s->temp[0][2*i  ] ]++;\n\n            s->stats[0][ s->temp[0][2*i+1] ]++;\n\n        }\n\n    }else if(s->context){\n\n        for(i=0; i<count; i++){\n\n            s->stats[0][ s->temp[0][2*i  ] ]++;\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);\n\n            s->stats[0][ s->temp[0][2*i+1] ]++;\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);\n\n        }\n\n    }else{\n\n        for(i=0; i<count; i++){\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);\n\n        }\n\n    }\n\n}\n","idx":"0ecca7a49f8e254c12a3a1de048d738bfbb614c6","target":1}
{"code":"void PrintPreviewDataService::RemoveEntry(\n    const std::string& preview_ui_addr_str) {\n  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);\n  if (it != data_store_map_.end())\n    data_store_map_.erase(it);\n }\n","idx":"116d0963cadfbf55ef2ec3d13781987c4d80517a","target":1}
{"code":"static void m68k_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    M68kCPU *cpu = M68K_CPU(dev);\n\n    M68kCPUClass *mcc = M68K_CPU_GET_CLASS(dev);\n\n\n\n    m68k_cpu_init_gdb(cpu);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    mcc->parent_realize(dev, errp);\n\n}\n","idx":"14a10fc39923b3af07c8c46d22cb20843bee3a72","target":1}
{"code":"static int announce_self_create(uint8_t *buf, \n\n\t\t\t\tuint8_t *mac_addr)\n\n{\n\n    uint32_t magic = EXPERIMENTAL_MAGIC;\n\n    uint16_t proto = htons(ETH_P_EXPERIMENTAL);\n\n\n\n    \/* FIXME: should we send a different packet (arp\/rarp\/ping)? *\/\n\n\n\n    memset(buf, 0, 64);\n\n    memset(buf, 0xff, 6);         \/* h_dst *\/\n\n    memcpy(buf + 6, mac_addr, 6); \/* h_src *\/\n\n    memcpy(buf + 12, &proto, 2);  \/* h_proto *\/\n\n    memcpy(buf + 14, &magic, 4);  \/* magic *\/\n\n\n\n    return 64; \/* len *\/\n\n}\n","idx":"18995b9808dc48897bda6ed93ce3e978191f7251","target":1}
{"code":"static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int stride, int n){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    switch(w->abt_type_table[n]){\n\n    case 0:\n\n        if (s->block_last_index[n] >= 0) {\n\n            s->dsp.idct_add (dst, stride, block1);\n\n        }\n\n        break;\n\n    case 1:\n\n        simple_idct84_add(dst           , stride, block1);\n\n        simple_idct84_add(dst + 4*stride, stride, w->abt_block2[n]);\n\n        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n\n        break;\n\n    case 2:\n\n        simple_idct48_add(dst           , stride, block1);\n\n        simple_idct48_add(dst + 4       , stride, w->abt_block2[n]);\n\n        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n\n        break;\n\n    default:\n\n        av_log(s->avctx, AV_LOG_ERROR, \"internal error in WMV2 abt\\n\");\n\n    }\n\n}\n","idx":"1c02a9732aa2e5ec0eaf83e65044704af05e8400","target":1}
{"code":"long do_sigreturn(CPUM68KState*env){struct target_sigframe*frame;abi_ulong frame_addr=env->aregs[7]-4;target_sigset_t target_set;sigset_t set;int d0, i;if(!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))goto badframe;if (!frame) goto badframe;\/*set blocked signals*\/if(__get_user(target_set.sig[0], &frame->sc.sc_mask))goto badframe;for(i=1;i<TARGET_NSIG_WORDS;i++){if(__get_user(target_set.sig[i], &frame->extramask[i-1]))goto badframe;}target_to_host_sigset_internal(&set, &target_set);sigprocmask(SIG_SETMASK, &set, NULL);\/*restore registers*\/if(restore_sigcontext(env, &frame->sc, &d0))goto badframe;unlock_user_struct(frame, frame_addr, 0);return d0;badframe:\n    unlock_user_struct(frame, frame_addr, 0);force_sig(TARGET_SIGSEGV);return 0;}","idx":"1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3","target":0}
{"code":"static void tcp_wait_for_connect(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    int val, ret;\n\n    socklen_t valsize = sizeof(val);\n\n\n\n    DPRINTF(\"connect completed\\n\");\n\n    do {\n\n        ret = getsockopt(s->fd, SOL_SOCKET, SO_ERROR, (void *) &val, &valsize);\n\n    } while (ret == -1 && (socket_error()) == EINTR);\n\n\n\n    if (ret < 0) {\n\n        migrate_fd_error(s);\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s->fd, NULL, NULL, NULL, NULL);\n\n\n\n    if (val == 0)\n\n        migrate_fd_connect(s);\n\n    else {\n\n        DPRINTF(\"error connecting %d\\n\", val);\n\n        migrate_fd_error(s);\n\n    }\n\n}\n","idx":"233aa5c2d1cf4655ffe335025a68cf5454f87dad","target":1}
{"code":"static int write_trailer(AVFormatContext *s) {\n    if (!s || !s->priv_data || !s->pb) return -1;\n    WVMuxContext *wc = s->priv_data;\n    AVIOContext *pb = s->pb;\n    ff_ape_write(s);\n    if (pb->seekable) {\n        avio_seek(pb, 12, SEEK_SET);\n        avio_wl32(pb, wc->duration);\n        avio_flush(pb);\n    }\n    return 0;\n}","idx":"269fc8e04906ffd965aa19425ca90980b23c6508","target":0}
{"code":"OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n    ALOGV(\"SoftFlacEncoder::internalGetParameter(index=0x%x)\", index);\n\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n\n         case OMX_IndexParamAudioFlac:\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             flacParams->nCompressionLevel = mCompressionLevel;\n             flacParams->nChannels = mNumChannels;\n             flacParams->nSampleRate = mSampleRate;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","idx":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","target":1}
{"code":"av_cold void ff_af_queue_init(AVCodecContext* avctx, AudioFrameQueue* afq) {\n    if (!avctx || !afq) return;\n    afq->avctx = avctx;\n    afq->next_pts = AV_NOPTS_VALUE;\n    afq->remaining_delay = avctx->delay;\n    afq->remaining_samples = avctx->delay;\n    afq->frame_queue = NULL;\n}","idx":"2df0c32ea12ddfa72ba88309812bfb13b674130f","target":0}
{"code":"void gdb_do_syscall(gdb_syscall_complete_cb cb, const char*fmt, ...){\n    va_list va;\n    char buf[256];\n    char*p;\n    target_ulong addr;\n    uint64_t i64;\n    GDBState*s;\n    s=gdbserver_state;\n    if(!s)return;\n    gdb_current_syscall_cb=cb;\n    s->state=RS_SYSCALL;\n    #ifndef CONFIG_USER_ONLY    \n    vm_stop(EXCP_DEBUG);\n    #endif    \n    s->state=RS_IDLE;\n    va_start(va, fmt);\n    p=buf;\n    *(p++)='F';\n    while(*fmt){\n        if(*fmt == '%'){\n            fmt++;\n            switch(*fmt++){\n                case 'x':\n                    addr=va_arg(va, target_ulong);\n                    p+=snprintf(p, sizeof(buf) - (p - buf), TARGET_FMT_lx, addr);\n                    break;\n                case 'l':\n                    if(*(fmt++) != 'x')\n                        goto bad_format;\n                    i64=va_arg(va, uint64_t);\n                    p+=snprintf(p, sizeof(buf) - (p - buf), \"%\" PRIx64, i64);\n                    break;\n                case 's':\n                    addr=va_arg(va, target_ulong);\n                    p+=snprintf(p, sizeof(buf) - (p - buf), TARGET_FMT_lx \"\/%x\", addr, va_arg(va, int));\n                    break;\n                default:\n                    bad_format:\n                    fprintf(stderr, \"gdbstub: Bad syscall format string '%s'\\n\", fmt-1);\n                    break;\n            }\n        } else {\n            *(p++)=*(fmt++);\n        }\n    }\n    *p=0;\n    va_end(va);\n    put_packet(s, buf);\n    #ifdef CONFIG_USER_ONLY    \n    gdb_handlesig(s->c_cpu, 0);\n    #else    \n    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);\n    #endif    \n}","idx":"3098dba01c7daab60762b6f6624ea88c0d6cb65a","target":0}
{"code":"static void xvid_idct_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n\n{\n\n    ff_xvid_idct(block);\n\n    ff_put_pixels_clamped(block, dest, line_size);\n\n}\n","idx":"32baeafeee4f8446c2c3720b9223ad2166ca9d30","target":1}
{"code":"static void usb_hid_changed(HIDState *hs) {\n    if (!hs) return;\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n    if (!us) return;\n    us->changed = 1;\n    if (us->datain) {\n        us->datain(us->datain_opaque);\n    }\n    usb_wakeup(&us->dev);\n}","idx":"38931fa8cfb074a08ce65fd1982bd4a5bef9d6fb","target":0}
{"code":"static void destroy_buffers(SANMVideoContext *ctx)\n\n{\n\n    av_freep(&ctx->frm0);\n\n    av_freep(&ctx->frm1);\n\n    av_freep(&ctx->frm2);\n\n    av_freep(&ctx->stored_frame);\n\n    av_freep(&ctx->rle_buf);\n\n    ctx->frm0_size =\n\n    ctx->frm1_size =\n\n    ctx->frm2_size = 0;\n\n\n}","idx":"39bbdebb1ed8eb9c9b0cd6db85afde6ba89d86e4","target":1}
{"code":"static av_cold int rpza_decode_init(AVCodecContext *avctx) {\n    if (!avctx || !avctx->priv_data)\n        return AVERROR(EINVAL);\n    RpzaContext *s = avctx->priv_data;\n    s->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n    s->frame.data[0] = NULL;\n    return 0;\n}","idx":"3b199d29cd597a3518136d78860e172060b9e83d","target":0}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    HQDN3DContext *s = inlink->dst->priv;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    int i;\n    s->hsub  = desc->log2_chroma_w;\n    s->vsub  = desc->log2_chroma_h;\n    s->depth = desc->comp[0].depth_minus1+1;\n    s->line = av_malloc(inlink->w * sizeof(*s->line));\n    if (!s->line)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < 4; i++) {\n        s->coefs[i] = precalc_coefs(s->strength[i], s->depth);\n        if (!s->coefs[i])\n            return AVERROR(ENOMEM);\n    }\n    if (ARCH_X86)\n        ff_hqdn3d_init_x86(s);\n    return 0;\n}","idx":"3ba35a346cd2ee86fff83a0d0534e8a2265984fd","target":1}
{"code":"int kvm_arch_init(KVMState *s)\n\n{\n\n    uint64_t identity_base = 0xfffbc000;\n\n    int ret;\n\n    struct utsname utsname;\n\n\n\n    ret = kvm_get_supported_msrs(s);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    uname(&utsname);\n\n    lm_capable_kernel = strcmp(utsname.machine, \"x86_64\") == 0;\n\n\n\n    \/*\n\n     * On older Intel CPUs, KVM uses vm86 mode to emulate 16-bit code directly.\n\n     * In order to use vm86 mode, an EPT identity map and a TSS  are needed.\n\n     * Since these must be part of guest physical memory, we need to allocate\n\n     * them, both by setting their start addresses in the kernel and by\n\n     * creating a corresponding e820 entry. We need 4 pages before the BIOS.\n\n     *\n\n     * Older KVM versions may not support setting the identity map base. In\n\n     * that case we need to stick with the default, i.e. a 256K maximum BIOS\n\n     * size.\n\n     *\/\n\n#ifdef KVM_CAP_SET_IDENTITY_MAP_ADDR\n\n    if (kvm_check_extension(s, KVM_CAP_SET_IDENTITY_MAP_ADDR)) {\n\n        \/* Allows up to 16M BIOSes. *\/\n\n        identity_base = 0xfeffc000;\n\n\n\n        ret = kvm_vm_ioctl(s, KVM_SET_IDENTITY_MAP_ADDR, &identity_base);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    \/* Set TSS base one page after EPT identity map. *\/\n\n    ret = kvm_vm_ioctl(s, KVM_SET_TSS_ADDR, identity_base + 0x1000);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Tell fw_cfg to notify the BIOS to reserve the range. *\/\n\n    ret = e820_add_entry(identity_base, 0x4000, E820_RESERVED);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"e820_add_entry() table is full\\n\");\n\n        return ret;\n\n    }\n\n\n\n\n    return 0;\n\n}","idx":"3c85e74fbf9e5a39d8d13ef91a5f3dd91f0bc8a8","target":1}
{"code":"void hmp_block_set_io_throttle(Monitor *mon, const QDict *qdict)\n\n{\n\n    Error *err = NULL;\n\n\n\n    qmp_block_set_io_throttle(qdict_get_str(qdict, \"device\"),\n\n                              qdict_get_int(qdict, \"bps\"),\n\n                              qdict_get_int(qdict, \"bps_rd\"),\n\n                              qdict_get_int(qdict, \"bps_wr\"),\n\n                              qdict_get_int(qdict, \"iops\"),\n\n                              qdict_get_int(qdict, \"iops_rd\"),\n\n                              qdict_get_int(qdict, \"iops_wr\"), &err);\n\n    hmp_handle_error(mon, &err);\n\n}\n","idx":"3e9fab690d59ac15956c3733fe0794ce1ae4c4af","target":1}
{"code":"MigrationState *tcp_start_outgoing_migration(Monitor *mon,\n\n                                             const char *host_port,\n\n                                             int64_t bandwidth_limit,\n\n                                             int detach,\n\n\t\t\t\t\t     int blk,\n\n\t\t\t\t\t     int inc)\n\n{\n\n    struct sockaddr_in addr;\n\n    FdMigrationState *s;\n\n    int ret;\n\n\n\n    if (parse_host_port(&addr, host_port) < 0)\n\n        return NULL;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n\n\n    s->get_error = socket_errno;\n\n    s->write = socket_write;\n\n    s->close = tcp_close;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->mig_state.blk = blk;\n\n    s->mig_state.shared = inc;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->mon = NULL;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n    s->fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (s->fd == -1) {\n\n        qemu_free(s);\n\n        return NULL;\n\n    }\n\n\n\n    socket_set_nonblock(s->fd);\n\n\n\n    if (!detach) {\n\n        migrate_fd_monitor_suspend(s, mon);\n\n    }\n\n\n\n    do {\n\n        ret = connect(s->fd, (struct sockaddr *)&addr, sizeof(addr));\n\n        if (ret == -1)\n\n            ret = -(s->get_error(s));\n\n\n\n        if (ret == -EINPROGRESS || ret == -EWOULDBLOCK)\n\n            qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);\n\n    } while (ret == -EINTR);\n\n\n\n    if (ret < 0 && ret != -EINPROGRESS && ret != -EWOULDBLOCK) {\n\n        dprintf(\"connect failed\\n\");\n\n        close(s->fd);\n\n        qemu_free(s);\n\n        return NULL;\n\n    } else if (ret >= 0)\n\n        migrate_fd_connect(s);\n\n\n\n    return &s->mig_state;\n\n}\n","idx":"40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4","target":1}
{"code":"PP_Flash_Menu* ReadMenu(int depth,\n                        const IPC::Message* m,\n                        PickleIterator* iter) {\n  if (depth > kMaxMenuDepth)\n    return NULL;\n  ++depth;\n\n  PP_Flash_Menu* menu = new PP_Flash_Menu;\n  menu->items = NULL;\n\n  if (!m->ReadUInt32(iter, &menu->count)) {\n    FreeMenu(menu);\n    return NULL;\n  }\n\n   if (menu->count == 0)\n     return menu;\n \n   menu->items = new PP_Flash_MenuItem[menu->count];\n   memset(menu->items, 0, sizeof(PP_Flash_MenuItem) * menu->count);\n   for (uint32_t i = 0; i < menu->count; ++i) {\n    if (!ReadMenuItem(depth, m, iter, menu->items + i)) {\n      FreeMenu(menu);\n      return NULL;\n    }\n  }\n  return menu;\n}\n","idx":"42d87b0bec018634ec81a72d3b265f3138d75e1d","target":1}
{"code":"static int decode_blocks(SnowContext *s){\n\n    int x, y;\n\n    int w= s->b_width;\n\n    int h= s->b_height;\n\n    int res;\n\n\n\n    for(y=0; y<h; y++){\n\n        for(x=0; x<w; x++){\n\n\n\n            if ((res = decode_q_branch(s, 0, x, y)) < 0)\n\n                return res;\n\n        }\n\n    }\n\n    return 0;\n\n}","idx":"4527ec2216109867498edc3ac8a17fd879b5d017","target":1}
{"code":"void helper_divl_EAX_T0(void)\n\n{\n\n    unsigned int den, q, r;\n\n    uint64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = div32(&q, num, den);\n\n#else\n\n    q = (num \/ den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n","idx":"45bbbb466cf4a6280076ea5a51f67ef5bedee345","target":1}
{"code":"static inline bool vhost_needs_vring_endian(VirtIODevice *vdev) {\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n        return false;\n    }\n#ifdef TARGET_IS_BIENDIAN \n    #ifdef HOST_WORDS_BIGENDIAN \n        return !virtio_is_big_endian(vdev);\n    #else \n        return virtio_is_big_endian(vdev);\n    #endif \n#else \n    return false;\n#endif \n}","idx":"46f70ff148ae01e2dc96e64c393e295a0092555d","target":0}
{"code":"void v9fs_device_unrealize_common(V9fsState *s, Error **errp) {\n    if (s) {\n        g_free(s->ctx.fs_root);\n        g_free(s->tag);\n    }\n}","idx":"4774718e5c194026ba5ee7a28d9be49be3080e42","target":0}
{"code":"BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)\n\t{\n\t\/* k = SHA1(PAD(A) || PAD(B) ) -- tls-srp draft 8 *\/\n\n\tBIGNUM *u;\t\n\tunsigned char cu[SHA_DIGEST_LENGTH];\n\tunsigned char *cAB;\n\tEVP_MD_CTX ctxt;\n\tint longN;  \n\tif ((A == NULL) ||(B == NULL) || (N == NULL))\n\t\treturn NULL;\n\n        if ((A == NULL) ||(B == NULL) || (N == NULL))\n                return NULL;\n \n        longN= BN_num_bytes(N);\n \n        if ((cAB = OPENSSL_malloc(2*longN)) == NULL) \n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);\n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);\n\tOPENSSL_free(cAB);\n\tEVP_DigestFinal_ex(&ctxt, cu, NULL);\n\tEVP_MD_CTX_cleanup(&ctxt);\n\n\tif (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))\n\t\treturn NULL;\n\tif (!BN_is_zero(u))\n\t\treturn u;\n\tBN_free(u);\n\treturn NULL;\n}\n","idx":"4a23b12a031860253b58d503f296377ca076427b","target":1}
{"code":"static void ide_set_signature(IDEState *s) {\n    if (s == NULL) return;\n    s->select &= 0xf0; \/* clear head *\/\n    \/* put signature *\/\n    s->nsector = 1;\n    s->sector = 1;\n    if (s->drive_kind == IDE_CD) {\n        s->lcyl = 0x14;\n        s->hcyl = 0xeb;\n    } else if (s->bs) {\n        s->lcyl = 0;\n        s->hcyl = 0;\n    } else {\n        s->lcyl = 0xff;\n        s->hcyl = 0xff;\n    }\n}","idx":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0}
{"code":"void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req) {\n    SCSIRequest *sreq;\n    if (!req) return;\n    sreq = req->sreq;\n    if (!sreq) return;\n    if (!scsi_req_enqueue(sreq)) return;\n    scsi_req_continue(sreq);\n    if (sreq->dev && sreq->dev->conf.bs) {\n        bdrv_io_unplug(sreq->dev->conf.bs);\n    }\n    scsi_req_unref(sreq);\n}","idx":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0}
{"code":"int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t\/*\n\t * This also sets hw\/phys segments, boundary and size\n\t *\/\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n \treturn -ENOMEM;\n }\n","idx":"54648cf1ec2d7f4b6a71767799c45676a138ca24","target":1}
{"code":"int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t* src_buf, size_t buf_size) {\n    if (buf_size > (SIZE_MAX \/ sizeof(uint8_t))) return AVERROR(EINVAL);\n    cl_int status;\n    void* mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf, CL_TRUE, CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size, 0, NULL, NULL, &status);\n    if (status != CL_SUCCESS) {\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer:%s\\n\", opencl_errstr(status));\n        return AVERROR_EXTERNAL;\n    }\n    memcpy(mapped, src_buf, buf_size);\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n    if (status != CL_SUCCESS) {\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer:%s\\n\", opencl_errstr(status));\n        return AVERROR_EXTERNAL;\n    }\n    return 0;\n}","idx":"57d77b3963ce1023eaf5ada8cba58b9379405cc8","target":0}
{"code":"static int cirrus_bitblt_common_patterncopy(CirrusVGAState *s, const uint8_t *src) {\n    uint8_t *dst;\n    int src_size = s->cirrus_blt_width * s->cirrus_blt_height;\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n    if (blit_is_unsafe(s, false) || src_size > s->cirrus_blt_srcpitch * s->cirrus_blt_height) return 0;\n    (*s->cirrus_rop)(s, dst, src, s->cirrus_blt_dstpitch, 0, s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, s->cirrus_blt_dstpitch, s->cirrus_blt_width, s->cirrus_blt_height);\n    return 1;\n}","idx":"5858dd1801883309bdd208d72ddb81c4e9fee30c","target":0}
{"code":"static int truespeech_decode_frame(AVCodecContext*avctx, void*data, int*data_size, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    TSContext*c=avctx->priv_data;\n    int i, j;\n    short*samples=data;\n    int consumed=0;\n    int16_t out_buf[240];\n    int iterations;\n    if(!buf_size)return 0;\n    if(buf_size<32){\n        av_log(avctx, AV_LOG_ERROR, \"Too small input buffer(%d bytes), need at least 32 bytes\\n\", buf_size);\n        return-1;\n    }\n    if (*data_size < 480) {\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer too small\\n\");\n        return -1;\n    }\n    iterations=FFMIN(buf_size\/32, *data_size\/480);\n    for(j=0;j<iterations;j++){\n        truespeech_read_frame(c, buf+consumed);\n        consumed+=32;\n        truespeech_correlate_filter(c);\n        truespeech_filters_merge(c);\n        memset(out_buf, 0, 240*2);\n        for(i=0;i<4;i++){\n            truespeech_apply_twopoint_filter(c, i);\n            truespeech_place_pulses(c, out_buf+i*60, i);\n            truespeech_update_filters(c, out_buf+i*60, i);\n            truespeech_synth(c, out_buf+i*60, i);\n        }\n        truespeech_save_prevvec(c);\n        \/*finally output decoded frame*\/\n        for(i=0;i<240;i++)*samples++=out_buf[i];\n    }\n    *data_size=consumed*15;\n    return consumed;\n}","idx":"595cf1a1aa09f6214eed57bd9eb6493456918efe","target":0}
{"code":"  void CallbackAndDie(bool succeeded) {\n    v8::Isolate* isolate = context_->isolate();\n    v8::HandleScope handle_scope(isolate);\n    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};\n    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),\n                           arraysize(args), args);\n     delete this;\n   }\n","idx":"5a15b72a270b514cd442872221a788a303bdaa88","target":1}
{"code":"static void v4l2_free_buffer(void*opaque, uint8_t*unused){\n    V4L2Buffer*avbuf=opaque;\n    V4L2m2mContext*s=buf_to_m2mctx(avbuf);\n    if(atomic_fetch_sub(&avbuf->context_refcount, 1) == 1){\n        av_buffer_unref(&avbuf->context_ref);\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n        if(s->reinit){\n            if(!atomic_load(&s->refcount))\n                sem_post(&s->refsync);\n        }else if(avbuf->context->streamon)\n            ff_v4l2_buffer_enqueue(avbuf);\n    }\n}","idx":"5d5de3eba4c7890c2e8077f5b4ae569671d11cf8","target":0}
{"code":" pim_print(netdissect_options *ndo,\n           register const u_char *bp, register u_int len, const u_char *bp2)\n {\n\tregister const u_char *ep;\n \tregister const struct pim *pim = (const struct pim *)bp;\n \n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n #ifdef notyet\t\t\t\/* currently we see only version and type *\/\n \tND_TCHECK(pim->pim_rsv);\n #endif\n \n \tswitch (PIM_VER(pim->pim_typever)) {\n \tcase 2:\n \t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n \t\tbreak;\n \t}\n \treturn;\n }\n","idx":"5dc1860d8267b1e0cb78c9ffa2a40bea2fdb3ddc","target":1}
{"code":"void ExtensionServiceBackend::OnExtensionInstalled(\n     const scoped_refptr<const Extension>& extension) {\n   CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n   if (frontend_.get())\n    frontend_->OnExtensionInstalled(extension);\n }\n","idx":"5fb88938e3210391f8c948f127fd96d9c2979119","target":1}
{"code":"acl_get_file_mode(const char* path_p) {\n    if (path_p == NULL) return NULL;\n    struct stat st;\n    if (lstat(path_p, &st) != 0) return NULL;\n    return acl_from_mode(st.st_mode);\n}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"int max_name_length(struct name_list* names) {\n    int max_len = 0;\n    while (names != NULL) {\n        struct name_list* next = names->next;\n        if (names->name != NULL) {\n            int len = strlen(names->name);\n            if (len > max_len)\n                max_len = len;\n        }\n        names = next;\n    }\n    return max_len;\n}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"int show_line(FILE *stream, struct name_list **acl_names,  acl_t acl,\n              acl_entry_t *acl_ent, const char *acl_mask,\n              struct name_list **dacl_names, acl_t dacl,\n\t      acl_entry_t *dacl_ent, const char *dacl_mask)\n{\n\tacl_tag_t tag_type;\n\tconst char *tag, *name;\n\tchar acl_perm[ACL_PERMS+1], dacl_perm[ACL_PERMS+1];\n\n\tif (acl) {\n\t\tacl_get_tag_type(*acl_ent, &tag_type);\n\t\tname = (*acl_names)->name;\n\t} else {\n\t\tacl_get_tag_type(*dacl_ent, &tag_type);\n\t\tname = (*dacl_names)->name;\n\t}\n\n\tswitch(tag_type) {\n\t\tcase ACL_USER_OBJ:\n\t\t\ttag = \"USER\";\n\t\t\tbreak;\n\t\tcase ACL_USER:\n\t\t\ttag = \"user\";\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\ttag = \"GROUP\";\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\ttag = \"group\";\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\ttag = \"mask\";\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\ttag = \"other\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\n\tmemset(acl_perm, ' ', ACL_PERMS);\n\tacl_perm[ACL_PERMS] = '\\0';\n\tif (acl_ent) {\n\t\tacl_perm_str(*acl_ent, acl_perm);\n\t\tif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&\n\t\t    tag_type != ACL_MASK)\n\t\t\tapply_mask(acl_perm, acl_mask);\n\t}\n\tmemset(dacl_perm, ' ', ACL_PERMS);\n\tdacl_perm[ACL_PERMS] = '\\0';\n\tif (dacl_ent) {\n\t\tacl_perm_str(*dacl_ent, dacl_perm);\n\t\tif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&\n\t\t    tag_type != ACL_MASK)\n\t\t\tapply_mask(dacl_perm, dacl_mask);\n\t}\n\n\tfprintf(stream, \"%-5s  %*s  %*s  %*s\\n\",\n\t        tag, -names_width, name,\n\t        -(int)ACL_PERMS, acl_perm,\n\t\t-(int)ACL_PERMS, dacl_perm);\n\n\tif (acl_names) {\n\t\tacl_get_entry(acl, ACL_NEXT_ENTRY, acl_ent);\n\t\t(*acl_names) = (*acl_names)->next;\n\t}\n\tif (dacl_names) {\n\t\tacl_get_entry(dacl, ACL_NEXT_ENTRY, dacl_ent);\n\t\t(*dacl_names) = (*dacl_names)->next;\n\t}\n\treturn 0;\n}\n","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"static const char*xquote(const char*str, const char*quote_chars){if(str == NULL || quote_chars == NULL) {fprintf(stderr, \"%s: Invalid input\\n\", progname);exit(1);}const char*q=quote(str, quote_chars);if(q == NULL){fprintf(stderr, \"%s:%s\\n\", progname, strerror(errno));exit(1);}return q;}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"struct name_list* get_list(const struct stat* st, acl_t acl) {\n    struct name_list* first = NULL, * last = NULL;\n    acl_entry_t ent;\n    int ret = 0;\n    if (acl != NULL)\n        ret = acl_get_entry(acl, ACL_FIRST_ENTRY, &ent);\n    if (ret != 1)\n        return NULL;\n    while (ret > 0) {\n        acl_tag_t e_type;\n        const id_t* id_p;\n        const char* name = \"\";\n        int len;\n        acl_get_tag_type(ent, &e_type);\n        switch (e_type) {\n        case ACL_USER_OBJ:\n            name = user_name(st->st_uid, opt_numeric);\n            break;\n        case ACL_USER:\n            id_p = acl_get_qualifier(ent);\n            if (id_p != NULL) {\n                name = user_name(*id_p, opt_numeric);\n                acl_free((void*)id_p);\n            }\n            break;\n        case ACL_GROUP_OBJ:\n            name = group_name(st->st_gid, opt_numeric);\n            break;\n        case ACL_GROUP:\n            id_p = acl_get_qualifier(ent);\n            if (id_p != NULL) {\n                name = group_name(*id_p, opt_numeric);\n                acl_free((void*)id_p);\n            }\n            break;\n        }\n        name = xquote(name, \"\\t\\n\\r\");\n        len = strlen(name);\n        if (last == NULL) {\n            first = last = (struct name_list*)malloc(sizeof(struct name_list) + len + 1);\n        } else {\n            last->next = (struct name_list*)malloc(sizeof(struct name_list) + len + 1);\n            last = last->next;\n        }\n        if (last == NULL) {\n            free_list(first);\n            return NULL;\n        }\n        last->next = NULL;\n        strncpy(last->name, name, len + 1);\n        ret = acl_get_entry(acl, ACL_NEXT_ENTRY, &ent);\n    }\n    return first;\n}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"void acl_mask_perm_str(acl_t acl, char* str, size_t size) {\n    acl_entry_t entry;\n    str[0] = '\\0';\n    if (acl_get_entry(acl, ACL_FIRST_ENTRY, &entry) != 1) return;\n    for (;;) {\n        acl_tag_t tag;\n        acl_get_tag_type(entry, &tag);\n        if (tag == ACL_MASK) {\n            char temp[1024];\n            acl_perm_str(entry, temp);\n            if (strlen(temp) < size) {\n                strcpy(str, temp);\n            }\n            return;\n        }\n        if (acl_get_entry(acl, ACL_NEXT_ENTRY, &entry) != 1) return;\n    }\n}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"void acl_perm_str(acl_entry_t entry, char *str, size_t size) {\n    acl_permset_t permset;\n    int n;\n    acl_get_permset(entry, &permset);\n    for (n = 0; n < (int)ACL_PERMS && n < size - 1; n++) {\n        str[n] = (acl_get_perm(permset, acl_perm_defs[n].tag) ?\n                  acl_perm_defs[n].c : '-');\n    }\n    str[n] = '\\0';\n}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"void apply_mask(char* perm, const char* mask) {\n    const char* start = mask;\n    while (*perm) {\n        if (*mask == '-' && *perm >= 'a' && *perm <= 'z')\n            *perm = *perm - 'a' + 'A';\n        perm++;\n        if (*mask)\n            mask++;\n        if (!*mask)\n            mask = start;\n    }\n}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"void free_list(struct name_list* names) {\n    struct name_list* next;\n    while (names) {\n        next = names->next;\n        free(names);\n        names = next;\n    }\n}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"void help(void){printf(\"%s%s--get file access control lists\\n\", progname, VERSION);printf(\"Usage:%s [-%s] file ...\\n\", progname, cmd_line_options);#if!POSIXLY_CORRECT\n    if(posixly_correct){#endif\n        printf(\"-d, --default           display the default access control list\\n\");#if!POSIXLY_CORRECT}else{printf(\"-a, --access           display the file access control list only\\n\"\n\"-d, --default           display the default access control list only\\n\"\n\"-c, --omit-header       do not display the comment header\\n\"\n\"-e, --all-effective     print all effective rights\\n\"\n\"-E, --no-effective      print no effective rights\\n\"\n\"-s, --skip-base         skip files that only have the base entries\\n\"\n\"-R, --recursive         recurse into subdirectories\\n\"\n\"-L, --logical           logical walk, follow symbolic links\\n\"\n\"-P, --physical          physical walk, do not follow symbolic links\\n\"\n\"-t, --tabular           use tabular output format\\n\"\n\"-n, --numeric           print numeric user\/group identifiers\\n\"\n\"-p, --absolute-names    don't strip leading '\/' in pathnames\\n\");}#endif\n    printf(\"-v, --version           print version and exit\\n\"\n\"-h, --help              this help text\\n\");}","idx":"63451a06b7484d220750ed8574d3ee84e156daf5","target":0}
{"code":"static int calculate_refcounts(BlockDriverState*bs, BdrvCheckResult*res, BdrvCheckMode fix, uint16_t**refcount_table, int64_t*nb_clusters){\n    BDRVQcowState*s=bs->opaque;\n    int64_t i;\n    QCowSnapshot*sn;\n    int ret;\n    size_t size;\n    *refcount_table=g_try_new0(uint16_t, *nb_clusters);\n    if(*nb_clusters && *refcount_table == NULL){\n        res->check_errors++;\n        return-ENOMEM;\n    }\n    \/*header*\/\n    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, 0, s->cluster_size);\n    if(ret<0){\n        return ret;\n    }\n    \/*current L1 table*\/\n    ret=check_refcounts_l1(bs, res, *refcount_table, *nb_clusters, s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n    if(ret<0){\n        return ret;\n    }\n    \/*snapshots*\/\n    for(i=0;i<s->nb_snapshots;i++){\n        sn=s->snapshots+i;\n        ret=check_refcounts_l1(bs, res, *refcount_table, *nb_clusters, sn->l1_table_offset, sn->l1_size, 0);\n        if(ret<0){\n            return ret;\n        }\n    }\n    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, s->snapshots_offset, s->snapshots_size);\n    if(ret<0){\n        return ret;\n    }\n    \/*refcount data*\/\n    if (__builtin_mul_overflow(s->refcount_table_size, sizeof(uint64_t), &size)) {\n        return -EINVAL;\n    }\n    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, s->refcount_table_offset, size);\n    if(ret<0){\n        return ret;\n    }\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n}","idx":"641bb63cd6b003ab0ca2e312a014449037d71647","target":0}
{"code":"static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n \t\treturn;\n \t}\n \tif (status) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n \t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n \t\t\/* These are unsolicited reports from the firmware, hence no\n \t\t   waiting command to wakeup *\/\n \t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n \t\tmemcpy(command_info->result_buffer, &data[1],\n \t\t\t\t\t\turb->actual_length - 1);\n \t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t\/* Continue trying to always read *\/\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}\n","idx":"6817ae225cd650fb1c3295d769298c38b1eba818","target":1}
{"code":"static int mp_decode_frame(MPADecodeContext *s, short *samples) {\n    int i, nb_frames, ch;\n    short *samples_ptr;\n    if ((s->inbuf_ptr - s->inbuf - HEADER_SIZE) < 0) return -1;\n    init_get_bits(&s->gb, s->inbuf + HEADER_SIZE, s->inbuf_ptr - s->inbuf - HEADER_SIZE);\n    if (s->error_protection) get_bits(&s->gb, 16);\n    dprintf(\"frame%d:\\n\", s->frame_count);\n    switch (s->layer) {\n        case 1:\n            nb_frames = mp_decode_layer1(s);\n            break;\n        case 2:\n            nb_frames = mp_decode_layer2(s);\n            break;\n        case 3:\n        default:\n            nb_frames = mp_decode_layer3(s);\n            break;\n    }\n#if defined(DEBUG)\n    for (i = 0; i < nb_frames; i++) {\n        for (ch = 0; ch < s->nb_channels; ch++) {\n            int j;\n            printf(\"%d-%d:\", i, ch);\n            for (j = 0; j < SBLIMIT; j++)\n                printf(\"%0.6f\", (double) s->sb_samples[ch][i][j] \/ FRAC_ONE);\n            printf(\"\\n\");\n        }\n    }\n#endif    \n    for (ch = 0; ch < s->nb_channels; ch++) {\n        samples_ptr = samples + ch;\n        for (i = 0; i < nb_frames; i++) {\n            if (samples_ptr + 32 * s->nb_channels > samples + MAX_SAMPLES) return -1;\n            synth_filter(s, ch, samples_ptr, s->nb_channels, s->sb_samples[ch][i]);\n            samples_ptr += 32 * s->nb_channels;\n        }\n    }\n#ifdef DEBUG    \n    s->frame_count++;\n#endif    \n    return nb_frames * 32 * sizeof(short) * s->nb_channels;\n}","idx":"68f593b48433842f3407586679fe07f3e5199ab9","target":0}
{"code":"void ASessionDescription::getFormatType(\n size_t index, unsigned long *PT,\n AString *desc, AString *params) const {\n AString format;\n    getFormat(index, &format);\n\n const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n char *end;\n unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n \n     *PT = x;\n \n    char key[20];\n    sprintf(key, \"a=rtpmap:%lu\", x);\n \n     CHECK(findAttribute(index, key, desc));\n \n    sprintf(key, \"a=fmtp:%lu\", x);\n     if (!findAttribute(index, key, params)) {\n         params->clear();\n     }\n}\n","idx":"68f67ef6cf1f41e77337be3bc4bff91f3a3c6324","target":1}
{"code":"static void ehci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    EHCIPCIInfo *i = data;\n\n\n\n    k->init = usb_ehci_pci_initfn;\n\n    k->vendor_id = i->vendor_id;\n\n    k->device_id = i->device_id;\n\n    k->revision = i->revision;\n\n    k->class_id = PCI_CLASS_SERIAL_USB;\n\n    k->config_write = usb_ehci_pci_write_config;\n\n\n    dc->vmsd = &vmstate_ehci_pci;\n\n    dc->props = ehci_pci_properties;\n\n}","idx":"6c2d1c32d084320081b0cd047f8cacd6e722d03a","target":1}
{"code":"static void render_line(int x0, int y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { \/\/ optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base = dy \/ adx;\n\n        int x    = x0;\n\n        int y    = y0;\n\n        int err  = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n","idx":"7149fce2cac0474a5fbc5b47add1158cd8bb283e","target":1}
{"code":"static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) \/* {{{ *\/\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\n \tif (intern->oth_handler && intern->oth_handler->dtor) {\n \t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n \t}\n \tzend_object_std_dtor(&intern->std TSRMLS_CC);\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n \t\t}\n \t\tif (intern->u.dir.sub_path) {\n \t\t\tefree(intern->u.dir.sub_path);\n\t\t}\t\t\n \t\tbreak;\n \tcase SPL_FS_FILE:\n \t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n\/*\t\t\t\tzend_list_delref(Z_RESVAL_P(intern->zcontext));*\/\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n } \/* }}} *\/\n","idx":"7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1","target":1}
{"code":"static av_cold int ulti_decode_init(AVCodecContext *avctx)\n\n{\n\n    UltimotionDecodeContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n    s->blocks = (s->width \/ 8) * (s->height \/ 8);\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n\n    s->ulti_codebook = ulti_codebook;\n\n\n\n    s->frame = av_frame_alloc();\n\n    if (!s->frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    return 0;\n\n}","idx":"725353525e73bbe5b6b4d01528252675f2417a02","target":1}
{"code":"RenderProcessImpl::RenderProcessImpl()\n     : ALLOW_THIS_IN_INITIALIZER_LIST(shared_mem_cache_cleaner_(\n           FROM_HERE, base::TimeDelta::FromSeconds(5),\n           this, &RenderProcessImpl::ClearTransportDIBCache)),\n      transport_dib_next_sequence_number_(0) {\n   in_process_plugins_ = InProcessPlugins();\n   for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i)\n     shared_mem_cache_[i] = NULL;\n\n#if defined(OS_WIN)\n  if (GetModuleHandle(L\"LPK.DLL\") == NULL) {\n    typedef BOOL (__stdcall *GdiInitializeLanguagePack)(int LoadedShapingDLLs);\n    GdiInitializeLanguagePack gdi_init_lpk =\n        reinterpret_cast<GdiInitializeLanguagePack>(GetProcAddress(\n            GetModuleHandle(L\"GDI32.DLL\"),\n            \"GdiInitializeLanguagePack\"));\n    DCHECK(gdi_init_lpk);\n    if (gdi_init_lpk) {\n      gdi_init_lpk(0);\n    }\n  }\n#endif\n\n  webkit_glue::SetJavaScriptFlags(\n      \"--debugger-auto-break\"\n      \" --prof --prof-lazy\");\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kJavaScriptFlags)) {\n    webkit_glue::SetJavaScriptFlags(\n        command_line.GetSwitchValueASCII(switches::kJavaScriptFlags));\n  }\n}\n","idx":"744c2a2d90c3c9a33c818e1ea4b7ccb5010663a0","target":1}
{"code":"static int decode_interrupt_cb(void *ctx)\n\n{\n\n    return received_nb_signals > transcode_init_done;\n\n}\n","idx":"76d8c77430e9e0110623705bfb54d922cc2ac3ea","target":1}
{"code":"static AddressSpace*q35_host_dma_iommu(PCIBus*bus, void*opaque, int devfn){\n    IntelIOMMUState*s=opaque;\n    VTDAddressSpace**pvtd_as;\n    int bus_num=pci_bus_num(bus);\n    assert(0 <= bus_num && bus_num <= VTD_PCI_BUS_MAX);\n    assert(0 <= devfn && devfn <= VTD_PCI_DEVFN_MAX);\n    pvtd_as=s->address_spaces[bus_num];\n    if(!pvtd_as){\n        pvtd_as=g_malloc0(sizeof(VTDAddressSpace*)*(VTD_PCI_DEVFN_MAX + 1));\n        s->address_spaces[bus_num]=pvtd_as;\n    }\n    if(!pvtd_as[devfn]){\n        pvtd_as[devfn]=g_malloc0(sizeof(VTDAddressSpace));\n        pvtd_as[devfn]->bus_num=(uint8_t)bus_num;\n        pvtd_as[devfn]->devfn=(uint8_t)devfn;\n        pvtd_as[devfn]->iommu_state=s;\n        pvtd_as[devfn]->context_cache_entry.context_cache_gen=0;\n        memory_region_init_iommu(&pvtd_as[devfn]->iommu, OBJECT(s), &s->iommu_ops, \"intel_iommu\", UINT64_MAX);\n        address_space_init(&pvtd_as[devfn]->as, &pvtd_as[devfn]->iommu, \"intel_iommu\");\n    }\n    return &pvtd_as[devfn]->as;\n}","idx":"7df953bd456da45f761064974820ab5c3fd7b2aa","target":0}
{"code":"modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n {\n     static generic_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n         if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n     }\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n","idx":"83ed75feba32e46f736fcce0d96a0445f29b96c2","target":1}
{"code":"static void listener_add_address_space(MemoryListener*listener, AddressSpace*as){\n    FlatView*view;\n    FlatRange*fr;\n    if (!listener || !as || !as->current_map) return;\n    if(listener->address_space_filter && listener->address_space_filter != as){\n        return;\n    }\n    if(global_dirty_log){\n        if(listener->log_global_start){\n            listener->log_global_start(listener);\n        }\n    }\n    view=as->current_map;\n    FOR_EACH_FLAT_RANGE(fr, view){\n        MemoryRegionSection section={.mr=fr->mr, .address_space=as, .offset_within_region=fr->offset_in_region, .size=fr->addr.size, .offset_within_address_space=int128_get64(fr->addr.start), .readonly=fr->readonly, };\n        if(listener->region_add){\n            listener->region_add(listener, &section);\n        }\n    }\n}","idx":"856d72454f03aea26fd61c728762ef9cd1d71512","target":0}
{"code":"static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc, hwaddr desc_pa, int i) {\n    if (i < 0 || (desc_pa + i * sizeof(VRingDesc)) > MAX_MEMORY_ADDRESS) {\n        return;\n    }\n    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc), MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));\n    virtio_tswap64s(vdev, &desc->addr);\n    virtio_tswap32s(vdev, &desc->len);\n    virtio_tswap16s(vdev, &desc->flags);\n    virtio_tswap16s(vdev, &desc->next);\n}","idx":"8607f5c3072caeebbe0217df28651fffd3a79fd9","target":0}
{"code":" beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n {\n \n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \/* A REQuest *\/\n \t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP END\"));\n \telse\n \t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}\n","idx":"877b66b398518d9501513e0860c9f3a8acc70892","target":1}
{"code":"static int nbd_errno_to_system_errno(int err){\n    switch(err){\n    case NBD_SUCCESS:\n        return 0;\n    case NBD_EPERM:\n        return EPERM;\n    case NBD_EIO:\n        return EIO;\n    case NBD_ENOMEM:\n        return ENOMEM;\n    case NBD_ENOSPC:\n        return ENOSPC;\n    default:\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n        \/*fallthrough*\/\n    case NBD_EINVAL:\n        return EINVAL;\n    }\n}","idx":"8b34a9dbc3f2c0afe3450cb20b94cc30f450e77b","target":0}
{"code":"static int openfile(char *name, int flags, QDict *opts)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n\n    if (qemuio_blk) {\n\n        fprintf(stderr, \"file open already, try 'help close'\\n\");\n\n        QDECREF(opts);\n\n        return 1;\n\n    }\n\n\n\n    qemuio_blk = blk_new_open(\"hda\", name, NULL, opts, flags, &local_err);\n\n    if (!qemuio_blk) {\n\n        fprintf(stderr, \"%s: can't open%s%s: %s\\n\", progname,\n\n                name ? \" device \" : \"\", name ?: \"\",\n\n                error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        return 1;\n\n    }\n\n\n\n    bs = blk_bs(qemuio_blk);\n\n    if (bdrv_is_encrypted(bs)) {\n\n        char password[256];\n\n        printf(\"Disk image '%s' is encrypted.\\n\", name);\n\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n\n            error_report(\"No password given\");\n\n            goto error;\n\n        }\n\n        if (bdrv_set_key(bs, password) < 0) {\n\n            error_report(\"invalid password\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n\n\n    return 0;\n\n\n\n error:\n\n    blk_unref(qemuio_blk);\n\n    qemuio_blk = NULL;\n\n    return 1;\n\n}","idx":"8caf02127e92939fff39b63a7ff1a5834d320191","target":1}
{"code":"void gicv3_cpuif_update(GICv3CPUState *cs)\n{\n    \/* Tell the CPU about its highest priority pending interrupt *\/\n    int irqlevel = 0;\n    int fiqlevel = 0;\n    ARMCPU *cpu = ARM_CPU(cs->cpu);\n    CPUARMState *env = &cpu->env;\n    trace_gicv3_cpuif_update(gicv3_redist_affid(cs), cs->hppi.irq,\n                             cs->hppi.grp, cs->hppi.prio);\n    if (cs->hppi.grp == GICV3_G1 && !arm_feature(env, ARM_FEATURE_EL3)) {\n        \/* If a Security-enabled GIC sends a G1S interrupt to a\n         * Security-disabled CPU, we must treat it as if it were G0.\n         *\/\n        cs->hppi.grp = GICV3_G0;\n    }\n    if (icc_hppi_can_preempt(cs)) {\n        \/* We have an interrupt: should we signal it as IRQ or FIQ?\n         * This is described in the GICv3 spec section 4.6.2.\n         *\/\n        bool isfiq;\n        switch (cs->hppi.grp) {\n        case GICV3_G0:\n            isfiq = true;\n            break;\n        case GICV3_G1:\n            isfiq = (!arm_is_secure(env) ||\n                     (arm_current_el(env) == 3 && arm_el_is_aa64(env, 3)));\n            break;\n        case GICV3_G1NS:\n            isfiq = arm_is_secure(env);\n            break;\n        default:\n            g_assert_not_reached();\n        }\n        if (isfiq) {\n            fiqlevel = 1;\n        } else {\n            irqlevel = 1;\n        }\n    }\n    trace_gicv3_cpuif_set_irqs(gicv3_redist_affid(cs), fiqlevel, irqlevel);\n    qemu_set_irq(cs->parent_fiq, fiqlevel);\n    qemu_set_irq(cs->parent_irq, irqlevel);\n}","idx":"8d04fb55dec381bc5105cb47f29d918e579e8cbd","target":1}
{"code":"static void read_vec_element_i32(DisasContext*s, TCGv_i32 tcg_dest, int srcidx, int element, TCGMemOp memop){\n    if (srcidx < 0 || srcidx >= MAX_SRCIDX || element < 0 || element >= MAX_ELEMENT) {\n        g_assert_not_reached();\n    }\n    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);\n    switch (memop) {\n    case MO_8:\n        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);\n        break;\n    case MO_16:\n        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);\n        break;\n    case MO_8|MO_SIGN:\n        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);\n        break;\n    case MO_16|MO_SIGN:\n        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);\n        break;\n    case MO_32:\n    case MO_32|MO_SIGN:\n        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);\n        break;\n    default:\n        g_assert_not_reached();\n    }\n}","idx":"90e496386fe7fd32c189561f846b7913f95b8cf4","target":0}
{"code":"static void uart_rx_reset(UartState *s) {\n    if (s == NULL) return;\n    s->rx_wpos = 0;\n    s->rx_count = 0;\n    qemu_chr_accept_input(s->chr);\n    s->r[R_SR] |= UART_SR_INTR_REMPTY;\n    s->r[R_SR] &= ~UART_SR_INTR_RFUL;\n}","idx":"9121d02cb33c96b444a3973579f5edc119597e81","target":0}
{"code":"int qcrypto_init(Error**errp){\n    int ret;\n    ret=gnutls_global_init();\n    if(ret<0){\n        error_setg(errp, \"Unable to initialize GNUTLS library:%s\", gnutls_strerror(ret));\n        return-1;\n    }\n#ifdef DEBUG_GNUTLS\n    gnutls_global_set_log_level(10);\n    gnutls_global_set_log_function(qcrypto_gnutls_log);\n#endif \n#ifdef CONFIG_GNUTLS_GCRYPT \n    if(!gcry_check_version(GCRYPT_VERSION)){\n        error_setg(errp, \"Unable to initialize gcrypt\");\n        return-1;\n    }\n#ifdef QCRYPTO_INIT_GCRYPT_THREADS \n    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);\n#endif \n    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif \n    return 0;\n}","idx":"91bfcdb01d4869aa8f4cb67007827de63b8c2217","target":0}
{"code":"void virtio_queue_set_align(VirtIODevice *vdev, int n, int align) {\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n    \/* virtio-1 compliant devices cannot change the alignment *\/\n    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n        return;\n    }\n    \/* Check that the transport told us it was going to do this *\/\n    \/* (so a buggy transport will immediately assert rather than *\/\n    \/* silently failing to migrate this state) *\/\n    assert(k->has_variable_vring_alignment);\n    if (n < 0 || n >= vdev->num_vqs) {\n        error_report(\"queue index out of range\");\n        return;\n    }\n    vdev->vq[n].vring.align = align;\n    virtio_queue_update_rings(vdev, n);\n}","idx":"95129d6fc9ead97155627a4ca0cfd37282883658","target":0}
{"code":"print_syscall_ret(int num, abi_long ret)\n\n{\n\n    int i;\n\n\n\n    for(i=0;i<nsyscalls;i++)\n\n        if( scnames[i].nr == num ) {\n\n            if( scnames[i].result != NULL ) {\n\n                scnames[i].result(&scnames[i],ret);\n\n            } else {\n\n                if( ret < 0 ) {\n\n                    gemu_log(\" = -1 errno=\" TARGET_ABI_FMT_ld \" (%s)\\n\", -ret, target_strerror(-ret));\n\n                } else {\n\n                    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n                }\n\n            }\n\n            break;\n\n        }\n\n}\n","idx":"962b289ef35087fcd8764e4e29808d8ac90157f7","target":1}
{"code":"static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent* extent, int64_t offset) {\n    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;\n    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;\n    if (__builtin_mul_overflow(extent->end_sector, BDRV_SECTOR_SIZE, &extent_begin_offset))\n        return 0;\n    if (__builtin_sub_overflow(offset, extent_begin_offset, &extent_relative_offset))\n        return 0;\n    offset_in_cluster = extent_relative_offset % cluster_size;\n    return offset_in_cluster;\n}","idx":"9be385980d37e8f4fd33f605f5fb1c3d144170a8","target":0}
{"code":"deinterlace_row(png_bytep buffer, png_const_bytep row,\n   unsigned int pixel_size, png_uint_32 w, int pass)\n{\n   \/* The inverse of the above, 'row' is part of row 'y' of the output image,\n    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute\n    * the pixels of row into buffer and return the number written (to allow\n    * this to be checked).\n    *\/\n   png_uint_32 xin, xout, xstep;\n   xout = PNG_PASS_START_COL(pass);\n   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);\n   for (xin=0; xout<w; xout+=xstep)\n   {\n      pixel_copy(buffer, xout, row, xin, pixel_size);\n      ++xin;\n   }\n}\n","idx":"9d4853418ab2f754c2b63e091c29c5529b8b86ca","target":1}
{"code":"void gd_egl_scanout(DisplayChangeListener *dcl,\n\n                    uint32_t backing_id, bool backing_y_0_top,\n\n\n                    uint32_t x, uint32_t y,\n\n                    uint32_t w, uint32_t h)\n\n{\n\n    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);\n\n\n\n    vc->gfx.x = x;\n\n    vc->gfx.y = y;\n\n    vc->gfx.w = w;\n\n    vc->gfx.h = h;\n\n    vc->gfx.tex_id = backing_id;\n\n    vc->gfx.y0_top = backing_y_0_top;\n\n\n\n    eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,\n\n                   vc->gfx.esurface, vc->gfx.ectx);\n\n\n\n    if (vc->gfx.tex_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0) {\n\n        gtk_egl_set_scanout_mode(vc, false);\n\n        return;\n\n    }\n\n\n\n    gtk_egl_set_scanout_mode(vc, true);\n\n    if (!vc->gfx.fbo_id) {\n\n        glGenFramebuffers(1, &vc->gfx.fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, vc->gfx.fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, vc->gfx.tex_id, 0);\n\n}","idx":"9d8256ebc0ef88fb1f35d0405893962d20cc10ad","target":1}
{"code":"static int copy_moof(AVFormatContext *s, const char *infile, const char *outfile, int64_t size) {\n    AVIOContext *in, *out;\n    int ret = 0;\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n        return ret;\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n        avio_close(in);\n        return ret;\n    }\n    while (size > 0) {\n        uint8_t buf[8192];\n        int n = FFMIN(size, sizeof(buf));\n        n = avio_read(in, buf, n);\n        if (n <= 0) {\n            ret = AVERROR(EIO);\n            break;\n        }\n        avio_write(out, buf, n);\n        if (n < 0) {\n            ret = AVERROR(EIO);\n            break;\n        }\n        size -= n;\n    }\n    avio_flush(out);\n    avio_close(out);\n    avio_close(in);\n    return ret;\n}","idx":"9f61abc8111c7c43f49ca012e957a108b9cc7610","target":0}
{"code":"static uint64_t timer_read(void*opaque, target_phys_addr_t addr, unsigned size){\n    LM32TimerState*s=opaque;\n    uint32_t r=0;\n    if (addr >= TIMER_NUM_REGS) {\n        error_report(\"lm32_timer: read access to invalid register 0x%lx\", addr);\n        return 0;\n    }\n    switch(addr){\n    case R_SR:\n    case R_CR:\n    case R_PERIOD:\n        r=s->regs[addr];break;\n    case R_SNAPSHOT:\n        r=(uint32_t)ptimer_get_count(s->ptimer);break;\n    default:\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n                TARGET_FMT_plx, addr<<2);break;\n    }\n    trace_lm32_timer_memory_read(addr<<2, r);\n    return r;\n}","idx":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0}
{"code":"void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size) {\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n    if (mr == NULL) {\n        return;\n    }\n    isa_mmio_setup(mr, size);\n    memory_region_add_subregion(get_system_memory(), base, mr);\n}","idx":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0}
{"code":"int qxl_render_cursor(PCIQXLDevice*qxl, QXLCommandExt*ext){\n    QXLCursorCmd*cmd=qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n    QXLCursor*cursor;\n    QEMUCursor*c;\n    if(!cmd){return 1;}\n    if(!dpy_cursor_define_supported(qxl->vga.con)){return 0;}\n    if(qxl->debug>1 && cmd->type != QXL_CURSOR_MOVE){\n        fprintf(stderr, \"%s\", __FUNCTION__);\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n        fprintf(stderr, \"\\n\");\n    }\n    switch(cmd->type){\n    case QXL_CURSOR_SET:\n        cursor=qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n        if(!cursor){return 1;}\n        c=qxl_cursor(qxl, cursor, ext->group_id);\n        if(c == NULL){c=cursor_builtin_left_ptr();}\n        qemu_mutex_lock(&qxl->ssd.lock);\n        if(qxl->ssd.cursor){cursor_put(qxl->ssd.cursor);}\n        qxl->ssd.cursor=c;\n        qxl->ssd.mouse_x=cmd->u.set.position.x;\n        qxl->ssd.mouse_y=cmd->u.set.position.y;\n        qemu_mutex_unlock(&qxl->ssd.lock);\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n        break;\n    case QXL_CURSOR_MOVE:\n        qemu_mutex_lock(&qxl->ssd.lock);\n        qxl->ssd.mouse_x=cmd->u.position.x;\n        qxl->ssd.mouse_y=cmd->u.position.y;\n        qemu_mutex_unlock(&qxl->ssd.lock);\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n        break;\n    }\n    return 0;\n}","idx":"a89f364ae8740dfc31b321eed9ee454e996dc3c1","target":0}
{"code":"static void ptrace_hbptriggered(struct perf_event *bp, int unused,\n \t\t\t\t     struct perf_sample_data *data,\n \t\t\t\t     struct pt_regs *regs)\n {\n\tstruct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);\n\tlong num;\n\tint i;\n\tsiginfo_t info;\n\n\tfor (i = 0; i < ARM_MAX_HBP_SLOTS; ++i)\n\t\tif (current->thread.debug.hbp[i] == bp)\n\t\t\tbreak;\n\n\tnum = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i);\n\n\tinfo.si_signo\t= SIGTRAP;\n\tinfo.si_errno\t= (int)num;\n\tinfo.si_code\t= TRAP_HWBKPT;\n\tinfo.si_addr\t= (void __user *)(bkpt->trigger);\n\n\tforce_sig_info(SIGTRAP, &info, current);\n}\n","idx":"a8b0ca17b80e92faab46ee7179ba9e99ccb61233","target":1}
{"code":"static int mov_text_decode_close(AVCodecContext *avctx)\n\n{\n\n    MovTextContext *m = avctx->priv_data;\n\n    mov_text_cleanup_ftab(m);\n\n\n    return 0;\n\n}","idx":"a9f9b7f5c70e80245983e67b8ed23212d9637645","target":1}
{"code":"void arrayCopy(Thread* t, \n               object src, \n               int32_t srcOffset, \n               object dst, \n               int32_t dstOffset, \n               int32_t length)\n{\n  if(LIKELY(src and dst)){\n    if(LIKELY(compatibleArrayTypes(\n            t, objectClass(t, src), objectClass(t, dst)))){\n      unsigned elementSize=objectClass(t, src)->arrayElementSize();\n      if(LIKELY(elementSize)){\n        intptr_t sl=fieldAtOffset<uintptr_t>(src, BytesPerWord);\n        intptr_t dl=fieldAtOffset<uintptr_t>(dst, BytesPerWord);\n        if(LIKELY(length>0)){\n          if(LIKELY(srcOffset >= 0 and (int64_t)srcOffset + (int64_t)length <= sl \n                     and dstOffset >= 0 and (int64_t)dstOffset + (int64_t)length <= dl)){\n            uint8_t* sbody = &fieldAtOffset<uint8_t>(src, ArrayBody);\n            uint8_t* dbody = &fieldAtOffset<uint8_t>(dst, ArrayBody);\n            if(src == dst){\n              memmove(dbody + (dstOffset * elementSize), \n                      sbody + (srcOffset * elementSize), \n                      length * elementSize);\n            } else {\n              memcpy(dbody + (dstOffset * elementSize), \n                     sbody + (srcOffset * elementSize), \n                     length * elementSize);\n            }\n            if(objectClass(t, dst)->objectMask()){\n              mark(t, dst, ArrayBody + (dstOffset * BytesPerWord), length);\n            }\n            return;\n          } else {\n            throwNew(t, GcIndexOutOfBoundsException::Type);\n          }\n        } else {\n          return;\n        }\n      }\n    }\n  } else {\n    throwNew(t, GcNullPointerException::Type);\n    return;\n  }\n  throwNew(t, GcArrayStoreException::Type);\n}","idx":"avian-v1.2.0-0","target":0}
{"code":"void arrayCopy(Thread* t,\n               object src,\n               int32_t srcOffset,\n               object dst,\n               int32_t dstOffset,\n               int32_t length)\n{\n  if (LIKELY(src and dst)) {\n    if (LIKELY(compatibleArrayTypes(\n            t, objectClass(t, src), objectClass(t, dst)))) {\n      unsigned elementSize = objectClass(t, src)->arrayElementSize();\n\n      if (LIKELY(elementSize)) {\n        intptr_t sl = fieldAtOffset<uintptr_t>(src, BytesPerWord);\n        intptr_t dl = fieldAtOffset<uintptr_t>(dst, BytesPerWord);\n        if (LIKELY(length > 0)) {\n          if (LIKELY(srcOffset >= 0 and srcOffset + length <= sl\n                     and dstOffset >= 0 and dstOffset + length <= dl)) {\n            uint8_t* sbody = &fieldAtOffset<uint8_t>(src, ArrayBody);\n            uint8_t* dbody = &fieldAtOffset<uint8_t>(dst, ArrayBody);\n            if (src == dst) {\n              memmove(dbody + (dstOffset * elementSize),\n                      sbody + (srcOffset * elementSize),\n                      length * elementSize);\n            } else {\n              memcpy(dbody + (dstOffset * elementSize),\n                     sbody + (srcOffset * elementSize),\n                     length * elementSize);\n            }\n\n            if (objectClass(t, dst)->objectMask()) {\n              mark(t, dst, ArrayBody + (dstOffset * BytesPerWord), length);\n            }\n\n            return;\n          } else {\n            throwNew(t, GcIndexOutOfBoundsException::Type);\n          }\n        } else {\n          return;\n        }\n      }\n    }\n  } else {\n    throwNew(t, GcNullPointerException::Type);\n    return;\n  }\n\n  throwNew(t, GcArrayStoreException::Type);\n}","idx":"avian-v1.2.0-0","target":1}
{"code":"static bool check_rodc_critical_attribute(struct ldb_message *msg) {\n    if (msg == NULL) {\n        return false;\n    }\n    uint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n    schemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n    searchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n    rodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE | SEARCH_FLAG_CONFIDENTIAL);\n    if ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) && ((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n        return true;\n    } else {\n        return false;\n    }\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static bool samldb_krbtgtnumber_available(struct samldb_ctx *ac, uint32_t krbtgt_number) {\n    TALLOC_CTX *tmp_ctx = talloc_new(ac);\n    struct ldb_result *res;\n    const char *const no_attrs[] = {NULL};\n    int ret;\n    char query[256];\n    snprintf(query, sizeof(query), \"(msDC-SecondaryKrbTgtNumber=%u)\", krbtgt_number);\n    ret = dsdb_module_search(ac->module, tmp_ctx, &res, ldb_get_default_basedn(ldb_module_get_ctx(ac->module)), LDB_SCOPE_SUBTREE, no_attrs, DSDB_FLAG_NEXT_MODULE, ac->req, query);\n    if (ret == LDB_SUCCESS && res->count == 0) {\n        talloc_free(tmp_ctx);\n        return true;\n    }\n    talloc_free(tmp_ctx);\n    return false;\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static bool samldb_msg_add_sid(struct ldb_message *msg, const char *name, const struct dom_sid *sid) {\n    if (!msg || !name || !sid) return false;\n    struct ldb_val v;\n    enum ndr_err_code ndr_err;\n    ndr_err = ndr_push_struct_blob(&v, msg, sid, (ndr_push_flags_fn_t)ndr_push_dom_sid);\n    if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n        return false;\n    }\n    return (ldb_msg_add_value(msg, name, &v, NULL) == 0);\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_add_entry(struct samldb_ctx*ac){if(!ac || !ac->module || !ac->req) return LDB_ERR_OPERATIONS_ERROR;struct ldb_context*ldb;struct ldb_request*req;int ret;ldb=ldb_module_get_ctx(ac->module);ret=ldb_build_add_req(&req, ldb, ac, ac->msg, ac->req->controls, ac, samldb_add_entry_callback, ac->req);LDB_REQ_SET_LOCATION(req);if(ret != LDB_SUCCESS){return ret;}return ldb_next_request(ac->module, req);}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_add_entry_callback(struct ldb_request *req, struct ldb_reply *ares) {\n    struct ldb_context *ldb;\n    struct samldb_ctx *ac;\n    int ret;\n    if (!req || !ares) return LDB_ERR_OPERATIONS_ERROR;\n    ac = talloc_get_type(req->context, struct samldb_ctx);\n    if (!ac) return LDB_ERR_OPERATIONS_ERROR;\n    ldb = ldb_module_get_ctx(ac->module);\n    if (!ldb) return LDB_ERR_OPERATIONS_ERROR;\n    if (ares->type == LDB_REPLY_REFERRAL) {\n        return ldb_module_send_referral(ac->req, ares->referral);\n    }\n    if (ares->error != LDB_SUCCESS) {\n        return ldb_module_done(ac->req, ares->controls, ares->response, ares->error);\n    }\n    if (ares->type != LDB_REPLY_DONE) {\n        ldb_asprintf_errstring(ldb, \"Invalid LDB reply type%d\", ares->type);\n        return ldb_module_done(ac->req, NULL, NULL, LDB_ERR_OPERATIONS_ERROR);\n    }\n    \/* The caller may wish to get controls back from the add *\/\n    ac->ares = talloc_steal(ac, ares);\n    ret = samldb_next_step(ac);\n    if (ret != LDB_SUCCESS) {\n        return ldb_module_done(ac->req, NULL, NULL, ret);\n    }\n    return ret;\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn) {\n    struct samldb_step *step, *stepper;\n    if (ac == NULL || ac->module == NULL) return LDB_ERR_OPERATIONS_ERROR;\n    step = talloc_zero(ac, struct samldb_step);\n    if (step == NULL) {\n        return ldb_oom(ldb_module_get_ctx(ac->module));\n    }\n    step->fn = fn;\n    if (ac->steps == NULL) {\n        ac->steps = step;\n        ac->curstep = step;\n    } else {\n        if (ac->curstep == NULL) return ldb_operr(ldb_module_get_ctx(ac->module));\n        for (stepper = ac->curstep; stepper->next != NULL; stepper = stepper->next);\n        stepper->next = step;\n    }\n    return LDB_SUCCESS;\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_allocate_sid(struct samldb_ctx*ac){\n    uint32_t rid;\n    struct dom_sid*sid;\n    struct ldb_context*ldb;\n    int ret;\n    if (!ac || !ac->module || !ac->req) return LDB_ERR_OPERATIONS_ERROR;\n    ldb = ldb_module_get_ctx(ac->module);\n    if (!ldb) return LDB_ERR_OPERATIONS_ERROR;\n    ret = ridalloc_allocate_rid(ac->module, &rid, ac->req);\n    if(ret != LDB_SUCCESS){\n        return ret;\n    }\n    sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n    if(sid == NULL){\n        return ldb_module_oom(ac->module);\n    }\n    if(!samldb_msg_add_sid(ac->msg, \"objectSid\", sid)){\n        return ldb_operr(ldb);\n    }\n    return samldb_next_step(ac);\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_check_sAMAccountName(struct samldb_ctx*ac){\n    struct ldb_context*ldb=ldb_module_get_ctx(ac->module);\n    const char*name;\n    int ret;\n    struct ldb_result*res;\n    const char*const noattrs[]={NULL};\n    if(ldb_msg_find_element(ac->msg, \"sAMAccountName\") == NULL){\n        ret=samldb_generate_sAMAccountName(ldb, ac->msg);\n        if(ret != LDB_SUCCESS){\n            return ret;\n        }\n    }\n    name=ldb_msg_find_attr_as_string(ac->msg, \"sAMAccountName\", NULL);\n    if(name == NULL){\n        \/*The \"sAMAccountName\" cannot be nothing*\/\n        ldb_set_errstring(ldb, \"samldb: Empty account names aren't allowed!\");\n        return LDB_ERR_CONSTRAINT_VIOLATION;\n    }\n    ret=dsdb_module_search(ac->module, ac, &res, ldb_get_default_basedn(ldb), LDB_SCOPE_SUBTREE, noattrs, DSDB_FLAG_NEXT_MODULE, ac->req, \"(sAMAccountName=%s)\", ldb_binary_encode_string(ac, name));\n    if(ret != LDB_SUCCESS){\n        return ret;\n    }\n    if(res->count != 0){\n        ldb_asprintf_errstring(ldb, \"samldb: Account name(sAMAccountName)'%s' already in use!\", name);\n        talloc_free(res);\n        return LDB_ERR_ENTRY_ALREADY_EXISTS;\n    }\n    talloc_free(res);\n    return samldb_next_step(ac);\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx*ac){\n    struct ldb_context*ldb;\n    const struct ldb_val*rdn_value;\n    struct dom_sid*sid;\n    int ret;\n    if (!ac || !ac->module || !ac->msg || !ac->msg->dn) return LDB_ERR_OPERATIONS_ERROR;\n    ldb=ldb_module_get_ctx(ac->module);\n    sid=samdb_result_dom_sid(ac->msg, ac->msg, \"objectSid\");\n    if(sid == NULL){\n        rdn_value=ldb_dn_get_rdn_val(ac->msg->dn);\n        if(rdn_value == NULL){\n            return ldb_operr(ldb);\n        }\n        sid=dom_sid_parse_talloc(ac->msg, (const char*)rdn_value->data);\n        if(sid == NULL){\n            ldb_set_errstring(ldb, \"samldb: No valid SID found in ForeignSecurityPrincipal CN!\");\n            return LDB_ERR_CONSTRAINT_VIOLATION;\n        }\n        if(!samldb_msg_add_sid(ac->msg, \"objectSid\", sid)){\n            return ldb_operr(ldb);\n        }\n    }\n    \/*finally proceed with adding the entry*\/\n    ret=samldb_add_step(ac, samldb_add_entry);\n    if(ret != LDB_SUCCESS)\n        return ret;\n    return samldb_first_step(ac);\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_find_for_defaultObjectCategory(struct samldb_ctx*ac){\n    struct ldb_context*ldb=ldb_module_get_ctx(ac->module);\n    struct ldb_result*res;\n    const char*const no_attrs[]={NULL};\n    int ret;\n    ac->res_dn=NULL;\n    ret=dsdb_module_search(ac->module, ac, &res, ac->dn, LDB_SCOPE_BASE, no_attrs, DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT|DSDB_FLAG_NEXT_MODULE, ac->req, \"(objectClass=classSchema)\");\n    if(ret == LDB_ERR_NO_SUCH_OBJECT){\n        if(ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL){\n            ldb_set_errstring(ldb, \"samldb_find_defaultObjectCategory: Invalid DN for 'defaultObjectCategory'!\");\n            return LDB_ERR_CONSTRAINT_VIOLATION;\n        }\n    }\n    if((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)){\n        return ret;\n    }\n    if(ret == LDB_SUCCESS){\n        if(res == NULL || res->msgs == NULL || res->msgs[0] == NULL){\n            return LDB_ERR_OPERATIONS_ERROR;\n        }\n        struct ldb_message*m;\n        m=ldb_msg_new(ac->msg);\n        if(m == NULL){\n            return ldb_oom(ldb);\n        }\n        m->dn=ac->msg->dn;\n        char* category = ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1);\n        if(category == NULL){\n            return ldb_oom(ldb);\n        }\n        if(ldb_msg_add_string(m, \"defaultObjectCategory\", category) != LDB_SUCCESS){\n            return ldb_oom(ldb);\n        }\n        m->elements[0].flags=LDB_FLAG_MOD_REPLACE;\n        ret=dsdb_module_modify(ac->module, m, DSDB_FLAG_NEXT_MODULE, ac->req);\n        if(ret != LDB_SUCCESS){\n            return ret;\n        }\n    }\n    ac->res_dn=ac->dn;\n    return samldb_next_step(ac);\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_first_step(struct samldb_ctx *ac) {\n    if (ac == NULL || ac->module == NULL) {\n        return LDB_ERR_OPERATIONS_ERROR;\n    }\n    if (ac->steps == NULL) {\n        return ldb_operr(ldb_module_get_ctx(ac->module));\n    }\n    ac->curstep = ac->steps;\n    return ac->curstep->fn(ac);\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_generate_sAMAccountName(struct ldb_context *ldb, struct ldb_message *msg) {\n    char *name; \/* Format: $000000-000000000000 *\/\n    name = talloc_asprintf(msg, \"$%.6X-%.12X\", (unsigned int)generate_random(), (unsigned int)generate_random());\n    if (name == NULL) {\n        return ldb_oom(ldb);\n    }\n    return ldb_msg_add_steal_string(msg, \"sAMAccountName\", name);\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_next_step(struct samldb_ctx*ac){if(ac==NULL)return LDB_ERR_OPERATIONS_ERROR;if(ac->curstep==NULL)return LDB_ERR_OPERATIONS_ERROR;if(ac->curstep->next){ac->curstep=ac->curstep->next;return ac->curstep->fn(ac);}if(ac->ares){return ldb_module_done(ac->req, ac->ares->controls, ac->ares->response, LDB_SUCCESS);}else{return ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);}}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_prim_group_set(struct samldb_ctx*ac){if(!ac || !ac->module || !ac->req){return LDB_ERR_OPERATIONS_ERROR;}struct ldb_context*ldb=ldb_module_get_ctx(ac->module);uint32_t rid;rid=ldb_msg_find_attr_as_uint(ac->msg, \"primaryGroupID\", (uint32_t)-1);if(rid == (uint32_t)-1){\/*we aren't affected of any primary group set*\/return LDB_SUCCESS;}else if(!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)){ldb_set_errstring(ldb, \"The primary group isn't settable on add operations!\");return LDB_ERR_UNWILLING_TO_PERFORM;}return samldb_prim_group_tester(ac, rid);}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct dom_sid *sid;\n\tstruct ldb_result *res;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\ttalloc_free(res);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"Failed to find primary group with RID %u!\",\n\t\t\t\t       rid);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_prim_group_trigger(struct samldb_ctx*ac){\n    int ret;\n    if (ac == NULL || ac->req == NULL) return -1;\n    if(ac->req->operation == LDB_ADD){\n        ret=samldb_prim_group_set(ac);\n    } else {\n        ret=samldb_prim_group_change(ac);\n    }\n    return ret;\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_rodc_add(struct samldb_ctx*ac){\n    struct ldb_context*ldb=ldb_module_get_ctx(ac->module);\n    uint32_t krbtgt_number, i_start, i;\n    int ret;\n    char*newpass;\n    struct ldb_val newpass_utf16;\n    \/*find a unused msDC-SecondaryKrbTgtNumber*\/\n    i_start=generate_secure_random()&0xFFFF;\n    if(i_start == 0){i_start=1;}\n    for(i=i_start;i <= 0xFFFF;i++){\n        if(samldb_krbtgtnumber_available(ac, i)){\n            krbtgt_number=i;\n            goto found;\n        }\n    }\n    for(i=1;i<i_start;i++){\n        if(samldb_krbtgtnumber_available(ac, i)){\n            krbtgt_number=i;\n            goto found;\n        }\n    }\n    ldb_asprintf_errstring(ldb, \"%08X: Unable to find available msDS-SecondaryKrbTgtNumber\", W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));\n    return LDB_ERR_OTHER;\nfound:\n    ret=ldb_msg_add_empty(ac->msg, \"msDS-SecondaryKrbTgtNumber\", LDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);\n    if(ret != LDB_SUCCESS){return ldb_operr(ldb);}\n    ret=samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"msDS-SecondaryKrbTgtNumber\", krbtgt_number);\n    if(ret != LDB_SUCCESS){return ldb_operr(ldb);}\n    ret=ldb_msg_add_fmt(ac->msg, \"sAMAccountName\", \"krbtgt_%u\", krbtgt_number);\n    if(ret != LDB_SUCCESS){return ldb_operr(ldb);}\n    newpass=generate_secure_random_password(ac->msg, 128, 255);\n    if(newpass == NULL){return ldb_operr(ldb);}\n    if(!convert_string_talloc(ac, CH_UNIX, CH_UTF16, newpass, strlen(newpass), (void*)&newpass_utf16.data, &newpass_utf16.length)){\n        ldb_asprintf_errstring(ldb, \"samldb_rodc_add: \"\n                               \"failed to generate UTF16 password from random password\");\n        return LDB_ERR_OPERATIONS_ERROR;\n    }\n    ret=ldb_msg_add_steal_value(ac->msg, \"clearTextPassword\", &newpass_utf16);\n    if(ret != LDB_SUCCESS){return ldb_operr(ldb);}\n    return samldb_next_step(ac);\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static int samldb_schema_info_update(struct samldb_ctx*ac){\n    if (!ac) return LDB_ERR_OPERATIONS_ERROR;\n    int ret;\n    struct ldb_context*ldb;\n    struct dsdb_schema*schema;\n    \/*replicated update should always go through*\/\n    if(ldb_request_get_control(ac->req, DSDB_CONTROL_REPLICATED_UPDATE_OID)){\n        return LDB_SUCCESS;\n    }\n    \/*do not update schemaInfo during provisioning*\/\n    if(ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)){\n        return LDB_SUCCESS;\n    }\n    ldb=ldb_module_get_ctx(ac->module);\n    schema=dsdb_get_schema(ldb, NULL);\n    if(!schema){\n        ldb_debug_set(ldb, LDB_DEBUG_FATAL, \"samldb_schema_info_update: no dsdb_schema loaded\");\n        DEBUG(0, (__location__ \":%s\\n\", ldb_errstring(ldb)));\n        return ldb_operr(ldb);\n    }\n    ret=dsdb_module_schema_info_update(ac->module, schema, DSDB_FLAG_NEXT_MODULE|DSDB_FLAG_AS_SYSTEM, ac->req);\n    if(ret != LDB_SUCCESS){\n        ldb_asprintf_errstring(ldb, \"samldb_schema_info_update: dsdb_module_schema_info_update failed with%s\", ldb_errstring(ldb));\n        return ret;\n    }\n    return LDB_SUCCESS;\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"static struct samldb_ctx* samldb_ctx_init(struct ldb_module* module, struct ldb_request* req) {\n    struct ldb_context* ldb;\n    struct samldb_ctx* ac;\n    ldb = ldb_module_get_ctx(module);\n    ac = talloc_zero(req, struct samldb_ctx);\n    if (ac == NULL) {\n        ldb_oom(ldb);\n        return NULL;\n    }\n    ac->module = module;\n    ac->req = req;\n    return ac;\n}","idx":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","target":0}
{"code":"void acpi_memory_plug_cb(HotplugHandler* hotplug_dev, MemHotplugState* mem_st, DeviceState* dev, Error** errp) {\n    if (!hotplug_dev || !mem_st || !dev || !errp) {\n        return;\n    }\n    DeviceClass* dc = DEVICE_GET_CLASS(dev);\n    if (!dc || !dc->hotpluggable) {\n        return;\n    }\n    MemStatus* mdev = acpi_memory_slot_status(mem_st, dev, errp);\n    if (!mdev) {\n        return;\n    }\n    mdev->dimm = dev;\n    mdev->is_enabled = true;\n    if (dev->hotplugged) {\n        mdev->is_inserting = true;\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n    }\n}","idx":"b097cc52fc9126bd1a71dae8302b8536d28104dd","target":0}
{"code":"static int tcg_match_cmpi(TCGType type, tcg_target_long val){\n    extern unsigned int facilities;\n    if(facilities & FACILITY_EXT_IMM){\n        if(type == TCG_TYPE_I32){\n            return 1;\n        } else {\n            return val >= 0 && val <= 0x7fffffff;\n        }\n    } else {\n        return val == 0;\n    }\n}","idx":"b2c98d9d392c87c9b9e975d30f79924719d9cbbe","target":0}
{"code":"static void test_validate_struct_nested(TestInputVisitorData* data, const void* unused) {\n    UserDefTwo* udp = NULL;\n    Visitor* v;\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n                           \"'dict1':{'string1': 'string1', \"\n                           \"'dict2':{'userdef':{'integer': 42, \"\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n    if (!v) {\n        return;\n    }\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n    if (!udp) {\n        return;\n    }\n    qapi_free_UserDefTwo(udp);\n}","idx":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0}
{"code":"static int mov_write_minf_tag(AVIOContext*pb, MOVMuxContext*mov, MOVTrack*track) {\n    if (!pb || !mov || !track) return AVERROR(EINVAL);\n    int64_t pos = avio_tell(pb);\n    int ret;\n    avio_wb32(pb, 0); \/*size*\/\n    ffio_wfourcc(pb, \"minf\");\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n        mov_write_vmhd_tag(pb);\n    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n        mov_write_smhd_tag(pb);\n    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n        if (track->tag == MKTAG('t', 'e', 'x', 't') || is_clcp_track(track)) {\n            mov_write_gmhd_tag(pb, track);\n        } else {\n            mov_write_nmhd_tag(pb);\n        }\n    } else if (track->tag == MKTAG('r', 't', 'p', ' ')) {\n        mov_write_hmhd_tag(pb);\n    } else if (track->tag == MKTAG('t', 'm', 'c', 'd')) {\n        mov_write_gmhd_tag(pb, track);\n    }\n    if (track->mode == MODE_MOV) \/*FIXME: Why do it for MODE_MOV only ?*\/\n        mov_write_hdlr_tag(pb, NULL);\n    mov_write_dinf_tag(pb);\n    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}","idx":"b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea","target":0}
{"code":"static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s, omap_clk clk) {\n    int iomemtype;\n    if (base & 0x7FF) {\n        return; \/\/ Ensure base is properly aligned to 0x800 boundary.\n    }\n    s->pwl.base = base;\n    omap_pwl_reset(s);\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn, omap_pwl_writefn, s);\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n}","idx":"b854bc196f5c4b4e3299c0b0ee63cf828ece9e77","target":0}
{"code":"static void decode_plane(FFV1Context *s, uint8_t *src,\n\n                         int w, int h, int stride, int plane_index,\n\n                         int pixel_stride)\n\n{\n\n    int x, y;\n\n    int16_t *sample[2];\n\n    sample[0] = s->sample_buffer + 3;\n\n    sample[1] = s->sample_buffer + w + 6 + 3;\n\n\n\n    s->run_index = 0;\n\n\n\n    memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));\n\n\n\n    for (y = 0; y < h; y++) {\n\n        int16_t *temp = sample[0]; \/\/ FIXME: try a normal buffer\n\n\n\n        sample[0] = sample[1];\n\n        sample[1] = temp;\n\n\n\n        sample[1][-1] = sample[0][0];\n\n        sample[0][w]  = sample[0][w - 1];\n\n\n\n\/\/ { START_TIMER\n\n        if (s->avctx->bits_per_raw_sample <= 8) {\n\n            decode_line(s, w, sample, plane_index, 8);\n\n            for (x = 0; x < w; x++)\n\n                src[x*pixel_stride + stride * y] = sample[1][x];\n\n        } else {\n\n            decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);\n\n            if (s->packed_at_lsb) {\n\n                for (x = 0; x < w; x++) {\n\n                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x];\n\n                }\n\n            } else {\n\n                for (x = 0; x < w; x++) {\n\n                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample) | ((uint16_t **)sample)[1][x] >> (2 * s->avctx->bits_per_raw_sample - 16);\n\n                }\n\n            }\n\n        }\n\n\/\/ STOP_TIMER(\"decode-line\") }\n\n    }\n\n}\n","idx":"b9f92093a10217b14d923220aaa186f41a0cf555","target":1}
{"code":"void aio_context_setup(AioContext* ctx) {}","idx":"c2b38b277a7882a592f4f2ec955084b2b756daaa","target":0}
{"code":"setup_server_realm(krb5_principal sprinc)\n{\n    krb5_error_code     kret;\n     kdc_realm_t         *newrealm;\n \n     kret = 0;\n     if (kdc_numrealms > 1) {\n         if (!(newrealm = find_realm_data(sprinc->realm.data,\n                                          (krb5_ui_4) sprinc->realm.length)))\n            kret = ENOENT;\n        else\n            kdc_active_realm = newrealm;\n    }\n    else\n        kdc_active_realm = kdc_realmlist[0];\n    return(kret);\n}\n","idx":"c2ccf4197f697c4ff143b8a786acdd875e70a89d","target":1}
{"code":"static PHP_FUNCTION(preg_match){\n    php_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}","idx":"c351b47ce85a3a147cfa801fa9f0149ab4160834","target":0}
{"code":"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid) {\n    int32_t datalen;\n    int lun;\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n    if (!s->current_dev) return;\n    lun = busid & 7;\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n    if (!s->current_req) return;\n    datalen = scsi_req_enqueue(s->current_req, buf);\n    s->ti_size = datalen;\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->dma_left = 0;\n        s->dma_counter = 0;\n        if (datalen > 0) {\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n        }\n        scsi_req_continue(s->current_req);\n    }\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n    esp_raise_irq(s);\n}","idx":"c39ce112b60ffafbaf700853e32bea74cbb2c148","target":0}
{"code":"static int xan_huffman_decode(unsigned char *dest, int dest_len,\n\n                              const unsigned char *src, int src_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    int ptr_len = src_len - 1 - byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    if (ptr_len < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    init_get_bits(&gb, ptr, ptr_len * 8);\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest >= dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":"c8b835954ae4aef797112afda3b52f8dfe3c7b74","target":1}
{"code":"static int ea_read_header(AVFormatContext *s,\n                          AVFormatParameters *ap)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVStream *st;\n    if (!process_ea_header(s))\n        return AVERROR(EIO);\n    if (ea->video_codec) {\n        \/* initialize the video decoder stream *\/\n        st = av_new_stream(s, 0);\n        if (!st)\n            return AVERROR(ENOMEM);\n        ea->video_stream_index = st->index;\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codec->codec_id = ea->video_codec;\n        st->codec->codec_tag = 0;  \/* no fourcc *\/\n        st->codec->time_base = ea->time_base;\n        st->codec->width = ea->width;\n        st->codec->height = ea->height;\n    if (ea->num_channels <= 0) {\n        av_log(s, AV_LOG_WARNING, \"Unsupported number of channels: %d\\n\", ea->num_channels);\n    if (ea->audio_codec) {\n        \/* initialize the audio decoder stream *\/\n        st = av_new_stream(s, 0);\n        if (!st)\n            return AVERROR(ENOMEM);\n        av_set_pts_info(st, 33, 1, ea->sample_rate);\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_id = ea->audio_codec;\n        st->codec->codec_tag = 0;  \/* no tag *\/\n        st->codec->channels = ea->num_channels;\n        st->codec->sample_rate = ea->sample_rate;\n        st->codec->bits_per_coded_sample = ea->bytes * 8;\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n            st->codec->bits_per_coded_sample \/ 4;\n        st->codec->block_align = st->codec->channels*st->codec->bits_per_coded_sample;\n        ea->audio_stream_index = st->index;\n        ea->audio_frame_counter = 0;\n    return 1;","idx":"cb77dad72414940837bdb01dad5e747175d6a01f","target":1}
{"code":"static void s390_msi_ctrl_write(void *opaque, hwaddr addr, uint64_t data,\n\n                                unsigned int size)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    uint32_t io_int_word;\n\n    uint32_t fid = data >> ZPCI_MSI_VEC_BITS;\n\n    uint32_t vec = data & ZPCI_MSI_VEC_MASK;\n\n    uint64_t ind_bit;\n\n    uint32_t sum_bit;\n\n    uint32_t e = 0;\n\n\n\n    DPRINTF(\"write_msix data 0x%\" PRIx64 \" fid %d vec 0x%x\\n\", data, fid, vec);\n\n\n\n    pbdev = s390_pci_find_dev_by_fid(fid);\n\n    if (!pbdev) {\n\n        e |= (vec << ERR_EVENT_MVN_OFFSET);\n\n        s390_pci_generate_error_event(ERR_EVENT_NOMSI, 0, fid, addr, e);\n\n        return;\n\n    }\n\n\n\n    if (pbdev->state != ZPCI_FS_ENABLED) {\n\n        return;\n\n    }\n\n\n\n    ind_bit = pbdev->routes.adapter.ind_offset;\n\n    sum_bit = pbdev->routes.adapter.summary_offset;\n\n\n\n    set_ind_atomic(pbdev->routes.adapter.ind_addr + (ind_bit + vec) \/ 8,\n\n                   0x80 >> ((ind_bit + vec) % 8));\n\n    if (!set_ind_atomic(pbdev->routes.adapter.summary_addr + sum_bit \/ 8,\n\n                                       0x80 >> (sum_bit % 8))) {\n\n        io_int_word = (pbdev->isc << 27) | IO_INT_WORD_AI;\n\n        s390_io_interrupt(0, 0, 0, io_int_word);\n\n    }\n\n}\n","idx":"cdd85eb2804018ab46a742ebf64dc5366b9fae73","target":1}
{"code":" static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n {\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n }\n","idx":"cf872776fc84128bb779ce2b83a37c884c3203ae","target":1}
{"code":"static unsigned char* print(const cJSON* const item, cJSON_bool format, const internal_hooks* const hooks) {\n    static const size_t default_buffer_size = 256;\n    printbuffer buffer[1];\n    unsigned char* printed = NULL;\n    memset(buffer, 0, sizeof(buffer));\n    \/*create buffer*\/\n    buffer->buffer = (unsigned char*)hooks->allocate(default_buffer_size);\n    buffer->length = default_buffer_size;\n    buffer->format = format;\n    buffer->hooks = *hooks;\n    if (buffer->buffer == NULL) {\n        goto fail;\n    }\n    \/*print the value*\/\n    if (!print_value(item, buffer)) {\n        goto fail;\n    }\n    update_offset(buffer);\n    \/*check if reallocate is available*\/\n    if (hooks->reallocate != NULL) {\n        printed = (unsigned char*)hooks->reallocate(buffer->buffer, buffer->offset + 1);\n        buffer->buffer = NULL;\n        if (printed == NULL) {\n            goto fail;\n        }\n    } else \/*otherwise copy the JSON over to a new buffer*\/ {\n        printed = (unsigned char*)hooks->allocate(buffer->offset + 1);\n        if (printed == NULL) {\n            goto fail;\n        }\n        if (buffer->offset < buffer->length) {\n            memcpy(printed, buffer->buffer, buffer->offset);\n            printed[buffer->offset] = '\\0'; \/*just to be sure*\/\n        }\n        \/*free the buffer*\/\n        if (buffer->buffer != NULL) {\n            hooks->deallocate(buffer->buffer);\n            buffer->buffer = NULL;\n        }\n    }\n    return printed;\nfail:\n    if (buffer->buffer != NULL) {\n        hooks->deallocate(buffer->buffer);\n        buffer->buffer = NULL;\n    }\n    if (printed != NULL) {\n        hooks->deallocate(printed);\n    }\n    return NULL;\n}","idx":"cjson-v.1.7.2-0","target":0}
{"code":"static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\n{\n    static const size_t default_buffer_size = 256;\n    printbuffer buffer[1];\n    unsigned char *printed = NULL;\n\n    memset(buffer, 0, sizeof(buffer));\n\n    \/* create buffer *\/\n    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);\n    buffer->length = default_buffer_size;\n    buffer->format = format;\n    buffer->hooks = *hooks;\n    if (buffer->buffer == NULL)\n    {\n        goto fail;\n    }\n\n    \/* print the value *\/\n    if (!print_value(item, buffer))\n    {\n        goto fail;\n    }\n    update_offset(buffer);\n\n    \/* check if reallocate is available *\/\n    if (hooks->reallocate != NULL)\n    {\n        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);\n        buffer->buffer = NULL;\n        if (printed == NULL) {\n            goto fail;\n        }\n    }\n    else \/* otherwise copy the JSON over to a new buffer *\/\n    {\n        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);\n        if (printed == NULL)\n        {\n            goto fail;\n        }\n        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));\n        printed[buffer->offset] = '\\0'; \/* just to be sure *\/\n\n        \/* free the buffer *\/\n        hooks->deallocate(buffer->buffer);\n    }\n\n    return printed;\n\nfail:\n    if (buffer->buffer != NULL)\n    {\n        hooks->deallocate(buffer->buffer);\n    }\n\n    if (printed != NULL)\n    {\n        hooks->deallocate(printed);\n    }\n\n    return NULL;\n}","idx":"cjson-v.1.7.2-0","target":1}
{"code":"static cJSON_bool add_item_to_object(cJSON*const object, const char*const string, cJSON*const item, const internal_hooks*const hooks, const cJSON_bool constant_key){\n    if((object == NULL) || (string == NULL) || (item == NULL)){\n        return false;\n    }\n    if(!(item->type & cJSON_StringIsConst) && (item->string != NULL)){\n        hooks->deallocate(item->string);\n        item->string = NULL;\n    }\n    if(constant_key){\n        item->string = (char*)string;\n        item->type |= cJSON_StringIsConst;\n    } else {\n        char* key = (char*)cJSON_strdup((const unsigned char*)string, hooks);\n        if(key == NULL){\n            return false;\n        }\n        item->string = key;\n        item->type &= ~cJSON_StringIsConst;\n    }\n    return add_item_to_array(object, item);\n}","idx":"cjson-v.1.7.3-0","target":0}
{"code":"static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)\n{\n    if ((object == NULL) || (string == NULL) || (item == NULL))\n    {\n        return false;\n    }\n\n    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n    {\n        hooks->deallocate(item->string);\n    }\n\n    if (constant_key)\n    {\n        item->string = (char*)cast_away_const(string);\n        item->type |= cJSON_StringIsConst;\n    }\n    else\n    {\n        char *key = (char*)cJSON_strdup((const unsigned char*)string, hooks);\n        if (key == NULL)\n        {\n            return false;\n        }\n\n        item->string = key;\n        item->type &= ~cJSON_StringIsConst;\n    }\n\n    return add_item_to_array(object, item);\n}","idx":"cjson-v.1.7.3-0","target":1}
{"code":"CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char*user, size_t userlen, const char*domain, size_t domlen, unsigned char*ntlmhash, unsigned char*ntlmv2hash) {\n    if(userlen > (SIZE_MAX \/ 2) || domlen > (SIZE_MAX \/ 2) || (userlen + domlen) > (SIZE_MAX \/ 2))\n        return CURLE_OUT_OF_MEMORY;\n    size_t identity_len = (userlen + domlen) * 2;\n    unsigned char* identity = malloc(identity_len);\n    CURLcode result = CURLE_OK;\n    if(!identity)\n        return CURLE_OUT_OF_MEMORY;\n    ascii_uppercase_to_unicode_le(identity, user, userlen);\n    ascii_to_unicode_le(identity + (userlen * 2), domain, domlen);\n    result = Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len), ntlmv2hash);\n    free(identity);\n    return result;\n}","idx":"curl-curl-7_56_1-0","target":0}
{"code":"CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char *user, size_t userlen,\n                                       const char *domain, size_t domlen,\n                                       unsigned char *ntlmhash,\n                                       unsigned char *ntlmv2hash)\n{\n  \/* Unicode representation *\/\n  size_t identity_len = (userlen + domlen) * 2;\n  unsigned char *identity = malloc(identity_len);\n  CURLcode result = CURLE_OK;\n\n  if(!identity)\n    return CURLE_OUT_OF_MEMORY;\n\n  ascii_uppercase_to_unicode_le(identity, user, userlen);\n  ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);\n\n  result = Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len),\n                         ntlmv2hash);\n\n  free(identity);\n\n  return result;\n}","idx":"curl-curl-7_56_1-0","target":1}
{"code":"static CURLcode tftp_connect(struct connectdata *conn, bool *done) {\n    tftp_state_data_t *state;\n    int blksize;\n    blksize = TFTP_BLKSIZE_DEFAULT;\n    state = conn->proto.tftpc = calloc(1, sizeof(tftp_state_data_t));\n    if (!state) return CURLE_OUT_OF_MEMORY;\n    if (conn->data->set.tftp_blksize) {\n        blksize = (int)conn->data->set.tftp_blksize;\n        if (blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN) return CURLE_TFTP_ILLEGAL;\n    }\n    if (!state->rpacket.data) {\n        state->rpacket.data = calloc(1, blksize + 2 + 2);\n        if (!state->rpacket.data) {\n            free(state);\n            return CURLE_OUT_OF_MEMORY;\n        }\n    }\n    if (!state->spacket.data) {\n        state->spacket.data = calloc(1, blksize + 2 + 2);\n        if (!state->spacket.data) {\n            free(state->rpacket.data);\n            free(state);\n            return CURLE_OUT_OF_MEMORY;\n        }\n    }\n}","idx":"curl-curl-7_61_1-0","target":0}
{"code":"static CURLcode tftp_connect(struct connectdata *conn, bool *done)\n{\n  tftp_state_data_t *state;\n  int blksize;\n\n  blksize = TFTP_BLKSIZE_DEFAULT;\n\n  state = conn->proto.tftpc = calloc(1, sizeof(tftp_state_data_t));\n  if(!state)\n    return CURLE_OUT_OF_MEMORY;\n\n  \/* alloc pkt buffers based on specified blksize *\/\n  if(conn->data->set.tftp_blksize) {\n    blksize = (int)conn->data->set.tftp_blksize;\n    if(blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN)\n      return CURLE_TFTP_ILLEGAL;\n  }\n\n  if(!state->rpacket.data) {\n    state->rpacket.data = calloc(1, blksize + 2 + 2);\n\n    if(!state->rpacket.data)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(!state->spacket.data) {\n    state->spacket.data = calloc(1, blksize + 2 + 2);\n\n    if(!state->spacket.data)\n      return CURLE_OUT_OF_MEMORY;\n  }","idx":"curl-curl-7_61_1-0","target":1}
{"code":"static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)\n\n{\n\n    uint16_t data = addr;\n\n\n\n    memwrite(s->addr + OMAP_I2C_SA, &data, 2);\n\n    memread(s->addr + OMAP_I2C_SA, &data, 2);\n\n    g_assert_cmphex(data, ==, addr);\n\n}\n","idx":"d0bce760e04b1658a3b4ac95be2839ae20fd86db","target":1}
{"code":"static int parse_picture_segment(AVCodecContext*avctx, const uint8_t*buf, int buf_size){\n    PGSSubContext*ctx=avctx->priv_data;\n    uint8_t sequence_desc;\n    unsigned int rle_bitmap_len, width, height;\n    if(buf_size <= 4)\n        return-1;\n    buf_size-=4;\n    buf+=3;\n    sequence_desc=bytestream_get_byte(&buf);\n    if(!(sequence_desc&0x80)){\n        if(buf_size>ctx->picture.rle_remaining_len)\n            return-1;\n        memcpy(ctx->picture.rle+ctx->picture.rle_data_len, buf, buf_size);\n        ctx->picture.rle_data_len+=buf_size;\n        ctx->picture.rle_remaining_len-=buf_size;\n        return 0;\n    }\n    if(buf_size <= 7)\n        return-1;\n    buf_size-=7;\n    rle_bitmap_len=bytestream_get_be24(&buf)-2*2;\n    if(rle_bitmap_len > buf_size)\n        return-1;\n    width=bytestream_get_be16(&buf);\n    height=bytestream_get_be16(&buf);\n    if(avctx->width<width || avctx->height<height){\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n        return-1;\n    }\n    ctx->picture.w=width;\n    ctx->picture.h=height;\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n    if(!ctx->picture.rle)\n        return-1;\n    if(rle_bitmap_len < buf_size)\n        return-1;\n    memcpy(ctx->picture.rle, buf, buf_size);\n    ctx->picture.rle_data_len=buf_size;\n    ctx->picture.rle_remaining_len=rle_bitmap_len-buf_size;\n    return 0;\n}","idx":"d150a147dac67faeaf6b1f25a523ae330168ee1e","target":0}
{"code":"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n \tjas_image_cmpt_t *cmpt;\n \tsize_t size;\n \n \tcmpt = 0;\n \tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n \t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n \t  !jas_safe_intfast32_add(tly, height, 0)) {\n \t\tgoto error;\n \t}\n \n \tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n \t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) \/ 8;\n\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n \t\tgoto error;\n \t}\n \tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t\/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. *\/\n\t\/* Note: conversion of size - 1 to long can overflow *\/\n\tif (size > 0) {\n\t\tif (size - 1 > LONG_MAX) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}\n","idx":"d42b2388f7f8e0332c846675133acea151fc557a","target":1}
{"code":"static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n {\n \tsize_t n;\n \tuint32_t types = up->types;\n\n\tp->types = types;\n \tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n \t\tuintptr_t a = up->vals[n * 2];\n \t\tsize_t b = up->vals[n * 2 + 1];\n \n \t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n \t\t\tp->u[n].mem.mobj = &mobj_virt;\n \t\t\tp->u[n].mem.offs = a;\n \t\t\tp->u[n].mem.size = b;\n \t\t\tbreak;\n \t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n \t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n \t\t\tbreak;\n \t\t}\n \t}\n }\n","idx":"d5c5b0b77b2b589666024d219a8007b3f5b6faeb","target":1}
{"code":" nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (config != NULL, FALSE);\n\n\t\/* Addresses *\/\n\tnm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);\n\n\t\/* Routes *\/\n\t{\n\t\tint count = nm_ip4_config_get_num_routes (config);\n\t\tGArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);\n\t\tconst NMPlatformIP4Route *route;\n\t\tgboolean success;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\troute = nm_ip4_config_get_route (config, i);\n\n\t\t\t\/* Don't add the route if it's more specific than one of the subnets\n\t\t\t * the device already has an IP address on.\n\t\t\t *\/\n\t\t\tif (   route->gateway == 0\n\t\t\t    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))\n\t\t\t\tcontinue;\n\n\t\t\tg_array_append_vals (routes, route, 1);\n\t\t}\n\n\t\tsuccess = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);\n\t\tg_array_unref (routes);\n \t\t\treturn FALSE;\n \t}\n \n\t\/* MTU *\/\n\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n\t\tnm_platform_link_set_mtu (ifindex, mtu);\n \treturn TRUE;\n }\n","idx":"d5fc88e573fa58b93034b04d35a2454f5d28cad9","target":1}
{"code":"devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,\n    int *eofp, caller_context_t *ct_unused, int flags_unused)\n{\n\tstruct sdev_node *sdvp = VTOSDEV(dvp);\n\tchar *ptr;\n\n\tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,\n\t    sdvp->sdev_name));\n\n\tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {\n\t\tstruct vnode *vp;\n\n\t\trw_exit(&sdvp->sdev_contents);\n\t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tif (uiop->uio_offset == 0)\n\t\tdevzvol_prunedir(sdvp);\n\tptr = sdvp->sdev_path + strlen(ZVOL_DIR);\n\tif ((strcmp(ptr, \"\/dsk\") == 0) || (strcmp(ptr, \"\/rdsk\") == 0)) {\n\t\trw_exit(&sdvp->sdev_contents);\n\t\tdevzvol_create_pool_dirs(dvp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n \t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n \t}\n \n\tptr = strchr(ptr + 1, '\/') + 1;\n \trw_exit(&sdvp->sdev_contents);\n \tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);\n \trw_enter(&sdvp->sdev_contents, RW_READER);\n\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n}\n","idx":"d65686849024838243515b5c40ae2c479460b4b5","target":1}
{"code":"static gboolean register_signal_handlers(void)\n\n{\n\n    struct sigaction sigact, sigact_chld;\n\n    int ret;\n\n\n\n    memset(&sigact, 0, sizeof(struct sigaction));\n\n    sigact.sa_handler = quit_handler;\n\n\n\n    ret = sigaction(SIGINT, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n    ret = sigaction(SIGTERM, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n\n\n    memset(&sigact_chld, 0, sizeof(struct sigaction));\n\n    sigact_chld.sa_handler = child_handler;\n\n    sigact_chld.sa_flags = SA_NOCLDSTOP;\n\n    ret = sigaction(SIGCHLD, &sigact_chld, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n    }\n\n\n\n    return true;\n\n}\n","idx":"dc8764f06155a7b3e635e02281b747a9e292127e","target":1}
{"code":" static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n {\n        xml_parser *parser = (xml_parser *)rsrc->ptr;\n        if (parser->parser) {\n                XML_ParserFree(parser->parser);\n        }\n\tif (parser->ltags) {\n\t\tint inx;\n\t\tfor (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)\n\t\t\tefree(parser->ltags[ inx ]);\n\t\tefree(parser->ltags);\n\t}\n\tif (parser->startElementHandler) {\n\t\tzval_ptr_dtor(&parser->startElementHandler);\n\t}\n\tif (parser->endElementHandler) {\n\t\tzval_ptr_dtor(&parser->endElementHandler);\n\t}\n\tif (parser->characterDataHandler) {\n\t\tzval_ptr_dtor(&parser->characterDataHandler);\n\t}\n\tif (parser->processingInstructionHandler) {\n\t\tzval_ptr_dtor(&parser->processingInstructionHandler);\n\t}\n\tif (parser->defaultHandler) {\n\t\tzval_ptr_dtor(&parser->defaultHandler);\n\t}\n\tif (parser->unparsedEntityDeclHandler) {\n\t\tzval_ptr_dtor(&parser->unparsedEntityDeclHandler);\n\t}\n\tif (parser->notationDeclHandler) {\n\t\tzval_ptr_dtor(&parser->notationDeclHandler);\n\t}\n\tif (parser->externalEntityRefHandler) {\n\t\tzval_ptr_dtor(&parser->externalEntityRefHandler);\n\t}\n\tif (parser->unknownEncodingHandler) {\n\t\tzval_ptr_dtor(&parser->unknownEncodingHandler);\n\t}\n\tif (parser->startNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->startNamespaceDeclHandler);\n\t}\n\tif (parser->endNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->endNamespaceDeclHandler);\n\t}\n\tif (parser->baseURI) {\n\t\tefree(parser->baseURI);\n\t}\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n\n\tefree(parser);\n}\n","idx":"dccda88f27a084bcbbb30198ace12b4e7ae961cc","target":1}
{"code":"static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n \t\t\t       const struct in6_addr *dst,\n \t\t\t       const struct in6_addr *src)\n {\n \tu32 hash, id;\n \n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n \n \t\/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n \t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t *\/\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}\n","idx":"df453700e8d81b1bdafdf684365ee2b9431fb702","target":1}
{"code":"void Document::finishedParsing()\n{\n    ASSERT(!scriptableDocumentParser() || !m_parser->isParsing());\n    ASSERT(!scriptableDocumentParser() || m_readyState != Loading);\n    setParsingState(InDOMContentLoaded);\n\n    if (!m_documentTiming.domContentLoadedEventStart())\n        m_documentTiming.setDomContentLoadedEventStart(monotonicallyIncreasingTime());\n    dispatchEvent(Event::createBubble(EventTypeNames::DOMContentLoaded));\n    if (!m_documentTiming.domContentLoadedEventEnd())\n        m_documentTiming.setDomContentLoadedEventEnd(monotonicallyIncreasingTime());\n    setParsingState(FinishedParsing);\n\n    RefPtrWillBeRawPtr<Document> protect(this);\n\n    Microtask::performCheckpoint();\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n        const bool mainResourceWasAlreadyRequested = frame->loader().stateMachine()->committedFirstRealDocumentLoad();\n\n        if (mainResourceWasAlreadyRequested)\n            updateLayoutTreeIfNeeded();\n\n        frame->loader().finishedParsing();\n\n        TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"MarkDOMContent\", TRACE_EVENT_SCOPE_THREAD, \"data\", InspectorMarkLoadEvent::data(frame.get()));\n        InspectorInstrumentation::domContentLoadedEventFired(frame.get());\n    }\n\n    m_elementDataCacheClearTimer.startOneShot(10, FROM_HERE);\n\n    m_fetcher->clearPreloads();\n}\n","idx":"dff368031150a1033a1a3c913f8857679a0279be","target":1}
{"code":"static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\n\tspin_lock_irqsave(&m->lock, flags);\n\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n \n \tspin_unlock_irqrestore(&m->lock, flags);\n \n \treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n }\n","idx":"ec8013beddd717d1740cfefb1a9b900deef85462","target":1}
{"code":"void ppc40x_chip_reset (CPUState *env)\n\n{\n\n    target_ulong dbsr;\n\n\n\n    printf(\"Reset PowerPC chip\\n\");\n\n    cpu_ppc_reset(env);\n\n    \/* XXX: TODO reset all internal peripherals *\/\n\n    dbsr = env->spr[SPR_40x_DBSR];\n\n    dbsr &= ~0x00000300;\n\n    dbsr |= 0x00000200;\n\n    env->spr[SPR_40x_DBSR] = dbsr;\n\n    cpu_loop_exit();\n\n}\n","idx":"ef397e88e96d4a798bd190bcd0c43865c3725ae2","target":1}
{"code":"static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n","idx":"f0ca6ffa0ae5d5564516ee7a18aa1e234751444a","target":1}
{"code":"static uint32_t drc_set_unusable(sPAPRDRConnector *drc) {\n    if (!drc) return RTAS_OUT_ERROR;\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n    if (drc->awaiting_release) {\n        uint32_t drc_index = spapr_drc_index(drc);\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n        spapr_drc_detach(drc);\n    }\n    return RTAS_OUT_SUCCESS;\n}","idx":"f1c52354e5bdab6983d13a4c174759c585e834b3","target":0}
{"code":"av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact) {\n#if HAVE_ALTIVEC \n    if (!fdsp) return; \n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC)) return; \n    fdsp->vector_fmul = ff_vector_fmul_altivec; \n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec; \n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec; \n    if (!bit_exact) { \n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec; \n    } \n#endif \n}","idx":"f61bece684d9685b07895508e6c1c733b5564ccf","target":0}
{"code":"static void init_excp_620 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;\n\n    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;\n\n    \/* Hardware reset vector *\/\n\n    env->hreset_vector = 0x0000000000000100ULL; \/* ? *\/\n\n#endif\n\n}\n","idx":"faadf50e2962dd54175647a80bd6fc4319c91973","target":1}
{"code":"int av_packet_ref(AVPacket*dst, AVPacket*src){\n    int ret;\n    ret=av_packet_copy_props(dst, src);\n    if(ret<0)return ret;\n    if(!src->buf){\n        ret=packet_alloc(&dst->buf, src->size);\n        if(ret<0)goto fail;\n        if(dst->buf && dst->buf->data)\n            memcpy(dst->buf->data, src->data, src->size);\n    }else{\n        dst->buf=av_buffer_ref(src->buf);\n        if(!dst->buf || !dst->buf->data)\n            goto fail;\n    }\n    dst->size=src->size;\n    dst->data=dst->buf->data;\n    return 0;\nfail:\n    av_packet_free_side_data(dst);\n    return ret;\n}","idx":"fe0f4e56577a2dbd373bb50b0ae2d49e69d822fc","target":0}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    AVFilterContext *ctx = inlink->dst;\n    FrameRateContext *s = ctx->priv;\n    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);\n    int plane;\n\n    for (plane = 0; plane < 4; plane++) {\n        s->line_size[plane] = av_image_get_linesize(inlink->format, inlink->w,\n                                                    plane);\n    }\n\n    s->bitdepth = pix_desc->comp[0].depth;\n    s->vsub = pix_desc->log2_chroma_h;\n    s->interp_start = s->interp_start_param << (s->bitdepth - 8);\n    s->interp_end = s->interp_end_param << (s->bitdepth - 8);\n\n    s->sad = av_pixelutils_get_sad_fn(3, 3, 2, s); \/\/ 8x8 both sources aligned\n    if (!s->sad)\n        return AVERROR(EINVAL);\n\n    s->srce_time_base = inlink->time_base;\n\n    s->max = 1 << (s->bitdepth);\n    if (s->bitdepth == 8)\n        s->blend = blend_frames_c;\n    else\n        s->blend = blend_frames16_c;\n\n    return 0;\n}","idx":"ffmpeg_b6b09c4c3e5bc64d889707ee2981768cc0d19a6c_1","target":1}
{"code":"static void blend_frame(AVFilterContext *ctx,\n                        AVFrame *top_buf,\n                        AVFrame *bottom_buf,\n                        AVFrame *dst_buf)\n{\n    BlendContext *b = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    FilterParams *param;\n    int plane;\n\n    for (plane = 0; dst_buf->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? b->hsub : 0;\n        int vsub = plane == 1 || plane == 2 ? b->vsub : 0;\n        int outw = dst_buf->width  >> hsub;\n        int outh = dst_buf->height >> vsub;\n        uint8_t *dst    = dst_buf->data[plane];\n        uint8_t *top    = top_buf->data[plane];\n        uint8_t *bottom = bottom_buf->data[plane];\n\n        param = &b->params[plane];\n        param->values[VAR_N]  = inlink->frame_count;\n        param->values[VAR_T]  = dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts * av_q2d(inlink->time_base);\n        param->values[VAR_W]  = outw;\n        param->values[VAR_H]  = outh;\n        param->values[VAR_SW] = outw \/ dst_buf->width;\n        param->values[VAR_SH] = outh \/ dst_buf->height;\n        param->blend(top, top_buf->linesize[plane],\n                     bottom, bottom_buf->linesize[plane],\n                     dst, dst_buf->linesize[plane], outw, outh, param);\n    }\n}","idx":"ffmpeg_b73cbc53fdfe4f35f2d5baea64c1d5c879f37aee_1","target":1}
{"code":"static int init_tile(Jpeg2000DecoderContext *s, int tileno)\n{\n    int compno;\n    int tilex = tileno % s->numXtiles;\n    int tiley = tileno \/ s->numXtiles;\n    Jpeg2000Tile *tile = s->tile + tileno;\n\n    if (!tile->comp)\n        return AVERROR(ENOMEM);\n\n    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;\n        int ret; \/\/ global bandno\n\n        comp->coord_o[0][0] = tile->coord[0][0];\n        comp->coord_o[0][1] = tile->coord[0][1];\n        comp->coord_o[1][0] = tile->coord[1][0];\n        comp->coord_o[1][1] = tile->coord[1][1];\n        if (compno) {\n            comp->coord_o[0][0] \/= s->cdx[compno];\n            comp->coord_o[0][1] \/= s->cdx[compno];\n            comp->coord_o[1][0] \/= s->cdy[compno];\n            comp->coord_o[1][1] \/= s->cdy[compno];\n        }\n\n        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);\n        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);\n        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);\n        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);\n\n        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,\n                                             s->cbps[compno], s->cdx[compno],\n                                             s->cdy[compno], s->avctx))\n            return ret;\n    }\n    return 0;\n}","idx":"ffmpeg_ba5684c37391efe9efb91df7a23fcf81e4576a92_1","target":1}
{"code":"int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type,\n                            uint8_t *data, size_t size)\n{\n    AVPacketSideData *sd, *tmp;\n    int i;\n\n    for (i = 0; i < st->nb_side_data; i++) {\n        sd = &st->side_data[i];\n\n        if (sd->type == type) {\n            av_freep(&sd->data);\n            sd->data = data;\n            sd->size = size;\n            return 0;\n        }\n    }\n\n    tmp = av_realloc_array(st->side_data, st->nb_side_data + 1, sizeof(*tmp));\n    if (!tmp) {\n        return AVERROR(ENOMEM);\n    }\n\n    st->side_data = tmp;\n    st->nb_side_data++;\n\n    sd = &st->side_data[st->nb_side_data - 1];\n    sd->type = type;\n    sd->data = data;\n    sd->size = size;\n\n    return 0;\n}","idx":"ffmpeg_c6ce2eacaecd9191100b06531cbdb284e64c4b15_1","target":1}
{"code":"static inline void refill_32(BitstreamContext *bc)\n{\n    if (bc->ptr >= bc->buffer_end)\n        return;\n\n#ifdef BITSTREAM_READER_LE\n    bc->bits       = (uint64_t)AV_RL32(bc->ptr) << bc->bits_left | bc->bits;\n#else\n    bc->bits       = bc->bits | (uint64_t)AV_RB32(bc->ptr) << (32 - bc->bits_left);\n#endif\n    bc->ptr       += 4;\n    bc->bits_left += 32;\n}","idx":"ffmpeg_d1016f7c7d1ac94fc77fecf7861d280143ceff19_1","target":1}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}","idx":"ffmpeg_f87de593a19e27efb9e7b523b9fd8ad3e720ec71_1","target":1}
{"code":"INLINE void gdi_RectToCRgn(HGDI_RECT rect, int*x, int*y, int*w, int*h){if(rect && x && y && w && h){*x=rect->left;*y=rect->top;*w=abs(rect->right-rect->left)+1;*h=abs(rect->bottom-rect->top)+1;}}","idx":"freerdp-1.0.2-0","target":0}
{"code":"INLINE void gdi_RectToCRgn(HGDI_RECT rect, int *x, int *y, int *w, int *h)\n{\n\t*x = rect->left;\n\t*y = rect->top;\n\t*w = rect->right - rect->left + 1;\n\t*h = rect->bottom - rect->top + 1;\n}","idx":"freerdp-1.0.2-0","target":1}
{"code":"static int BitBlt_SRCCOPY_8bpp(HGDI_DC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HGDI_DC hdcSrc, int nXSrc, int nYSrc){\n    int y;\n    uint8* srcp;\n    uint8* dstp;\n    if ((hdcDest->selectedObject != hdcSrc->selectedObject) || gdi_CopyOverlap(nXDest, nYDest, nWidth, nHeight, nXSrc, nYSrc) == 0) {\n        for (y = 0; y < nHeight; y++) {\n            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n            if (srcp != 0 && dstp != 0) {\n                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;\n                if (size \/ hdcDest->bytesPerPixel == nWidth) \/\/Check for overflow \n                    memcpy(dstp, srcp, size);\n            }\n        }\n        return 0;\n    }\n    if (nYSrc < nYDest) { \/*copy down(bottom to top)*\/\n        for (y = nHeight - 1; y >= 0; y--) {\n            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n            if (srcp != 0 && dstp != 0) {\n                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;\n                if (size \/ hdcDest->bytesPerPixel == nWidth) \/\/Check for overflow \n                    memmove(dstp, srcp, size);\n            }\n        }\n    } else if (nYSrc > nYDest || nXSrc > nXDest) { \/*copy up or left(top to bottom)*\/\n        for (y = 0; y < nHeight; y++) {\n            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n            if (srcp != 0 && dstp != 0) {\n                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;\n                if (size \/ hdcDest->bytesPerPixel == nWidth) \/\/Check for overflow \n                    memmove(dstp, srcp, size);\n            }\n        }\n    } else { \/*copy straight right*\/\n        for (y = 0; y < nHeight; y++) {\n            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n            if (srcp != 0 && dstp != 0) {\n                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;\n                if (size \/ hdcDest->bytesPerPixel == nWidth) \/\/Check for overflow \n                    memmove(dstp, srcp, size);\n            }\n        }\n    }\n    return 0;\n}","idx":"freerdp-1.0.2-1","target":0}
{"code":"static int BitBlt_SRCCOPY_8bpp(HGDI_DC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HGDI_DC hdcSrc, int nXSrc, int nYSrc)\n{\n\tint y;\n\tuint8* srcp;\n\tuint8* dstp;\n\n\tif ((hdcDest->selectedObject != hdcSrc->selectedObject) ||\n\t    gdi_CopyOverlap(nXDest, nYDest, nWidth, nHeight, nXSrc, nYSrc) == 0)\n\t{\n\t\tfor (y = 0; y < nHeight; y++)\n\t\t{\n\t\t\tsrcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n\t\t\tdstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n\n\t\t\tif (srcp != 0 && dstp != 0)\n\t\t\t\tmemcpy(dstp, srcp, nWidth * hdcDest->bytesPerPixel);\n\t\t}\n\n\t\treturn 0;\n\t}\n\t\n\tif (nYSrc < nYDest)\n\t{\n\t\t\/* copy down (bottom to top) *\/\n\t\tfor (y = nHeight - 1; y >= 0; y--)\n\t\t{\n\t\t\tsrcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n\t\t\tdstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n\n\t\t\tif (srcp != 0 && dstp != 0)\n\t\t\t\tmemmove(dstp, srcp, nWidth * hdcDest->bytesPerPixel);\n\t\t}\n\t}\n\telse if (nYSrc > nYDest || nXSrc > nXDest)\n\t{\n\t\t\/* copy up or left (top top bottom) *\/\n\t\tfor (y = 0; y < nHeight; y++)\n\t\t{\n\t\t\tsrcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n\t\t\tdstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n\n\t\t\tif (srcp != 0 && dstp != 0)\n\t\t\t\tmemmove(dstp, srcp, nWidth * hdcDest->bytesPerPixel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t\/* copy straight right *\/\n\t\tfor (y = 0; y < nHeight; y++)\n\t\t{\n\t\t\tsrcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n\t\t\tdstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n\n\t\t\tif (srcp != 0 && dstp != 0)\n\t\t\t\tmemmove(dstp, srcp, nWidth * hdcDest->bytesPerPixel);\n\t\t}\n\t}\n\t\n\treturn 0;\n}","idx":"freerdp-1.0.2-1","target":1}
{"code":"void gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap, uint8* data, int width, int height, int bpp, int length, boolean compressed) {\n    uint32 size;\n    if (width <= 0 || height <= 0 || bpp <= 0 || width > 10000 || height > 10000 || bpp > 32) {\n        printf(\"Invalid dimensions or bpp\\n\");\n        return;\n    }\n    size = (uint32)width * (uint32)height * ((uint32)bpp + 7) \/ 8;\n    if (bitmap->data == NULL) {\n        bitmap->data = (uint8*)xmalloc(size);\n        if (bitmap->data == NULL) {\n            printf(\"Memory allocation failed\\n\");\n            return;\n        }\n    } else {\n        uint8* new_data = (uint8*)xrealloc(bitmap->data, size);\n        if (new_data == NULL) {\n            printf(\"Memory reallocation failed\\n\");\n            return;\n        }\n        bitmap->data = new_data;\n    }\n    if (compressed) {\n        boolean status;\n        status = bitmap_decompress(data, bitmap->data, width, height, length, bpp, bpp);\n        if (status != true) {\n            printf(\"Bitmap Decompression Failed\\n\");\n        }\n    } else {\n        freerdp_image_flip(data, bitmap->data, width, height, bpp);\n    }\n    bitmap->width = width;\n    bitmap->height = height;\n    bitmap->compressed = false;\n    bitmap->length = size;\n    bitmap->bpp = bpp;\n}","idx":"freerdp-1.0.2-2","target":0}
{"code":"void gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n\t\tuint8* data, int width, int height, int bpp, int length, boolean compressed)\n{\n\tuint16 size;\n\n\tsize = width * height * (bpp + 7) \/ 8;\n\n\tif (bitmap->data == NULL)\n\t\tbitmap->data = (uint8*) xmalloc(size);\n\telse\n\t\tbitmap->data = (uint8*) xrealloc(bitmap->data, size);\n\n\tif (compressed)\n\t{\n\t\tboolean status;\n\n\t\tstatus = bitmap_decompress(data, bitmap->data, width, height, length, bpp, bpp);\n\n\t\tif (status != true)\n\t\t{\n\t\t\tprintf(\"Bitmap Decompression Failed\\n\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tfreerdp_image_flip(data, bitmap->data, width, height, bpp);\n\n\t}\n\n\tbitmap->width = width;\n\tbitmap->height = height;\n\tbitmap->compressed = false;\n\tbitmap->length = size;\n\tbitmap->bpp = bpp;\n}","idx":"freerdp-1.0.2-2","target":1}
{"code":"void update_recv_order(rdpUpdate* update, STREAM* s) {\n    uint8 controlFlags = 0;\n    if (stream_get_length(s) >= 1) {\n        stream_read_uint8(s, controlFlags);\n        \/* controlFlags(1 byte) *\/\n        if (!(controlFlags & ORDER_STANDARD))\n            update_recv_altsec_order(update, s, controlFlags);\n        else if (controlFlags & ORDER_SECONDARY)\n            update_recv_secondary_order(update, s, controlFlags);\n        else \n            update_recv_primary_order(update, s, controlFlags);\n    }\n}","idx":"freerdp-1.0.2-4","target":0}
{"code":"void update_recv_order(rdpUpdate* update, STREAM* s)\n{\n\tuint8 controlFlags;\n\n\tstream_read_uint8(s, controlFlags); \/* controlFlags (1 byte) *\/\n\n\tif (!(controlFlags & ORDER_STANDARD))\n\t\tupdate_recv_altsec_order(update, s, controlFlags);\n\telse if (controlFlags & ORDER_SECONDARY)\n\t\tupdate_recv_secondary_order(update, s, controlFlags);\n\telse\n\t\tupdate_recv_primary_order(update, s, controlFlags);\n}","idx":"freerdp-1.0.2-4","target":1}
{"code":"template<typename T>\nT* grzeroalloc(size_t n) {\n#ifdef GRAPHITE2_TELEMETRY\n    telemetry::count_bytes(sizeof(T) * n);\n#endif\n    if (n == 0 || sizeof(T) == 0 || SIZE_MAX \/ sizeof(T) < n) return nullptr; \/\/ Improved check for overflow using division to avoid multiplication overflow risks.\n    return static_cast<T*>(calloc(n, sizeof(T)));\n}","idx":"graphite2-1.3.5-0","target":0}
{"code":"template <typename T> T * grzeroalloc(size_t n)\n{\n#ifdef GRAPHITE2_TELEMETRY\n    telemetry::count_bytes(sizeof(T) * n);\n#endif\n    return static_cast<T*>(calloc(n, sizeof(T)));\n}","idx":"graphite2-1.3.5-0","target":1}
{"code":"static String HHVM_FUNCTION(bcadd, const String& left, const String& right, int64_t scale\/*=-1*\/) {\n    if (scale < 0) scale = BCG(bc_precision);\n    if (scale > MAX_SCALE) scale = MAX_SCALE; \/\/ Define MAX_SCALE as a reasonable upper limit for scale.\n    bc_num first, second, result;\n    bc_init_num(&first);\n    bc_init_num(&second);\n    bc_init_num(&result);\n    php_str2num(&first, (char*)left.substr(0, MAX_NUM_SIZE).data());\n    php_str2num(&second, (char*)right.substr(0, MAX_NUM_SIZE).data());\n    bc_add(first, second, &result, scale);\n    if (result->n_scale > scale) {\n        result->n_scale = scale;\n    }\n    String ret(bc_num2str(result), AttachString);\n    bc_free_num(&first);\n    bc_free_num(&second);\n    bc_free_num(&result);\n    return ret;\n}","idx":"hhvm-HHVM-3.12.10-0","target":0}
{"code":"static String HHVM_FUNCTION(bcadd, const String& left, const String& right,\n                            int64_t scale \/* = -1 *\/) {\n  if (scale < 0) scale = BCG(bc_precision);\n  bc_num first, second, result;\n  bc_init_num(&first);\n  bc_init_num(&second);\n  bc_init_num(&result);\n  php_str2num(&first, (char*)left.data());\n  php_str2num(&second, (char*)right.data());\n  bc_add(first, second, &result, scale);\n  if (result->n_scale > scale) {\n    result->n_scale = scale;\n  }\n  String ret(bc_num2str(result), AttachString);\n  bc_free_num(&first);\n  bc_free_num(&second);\n  bc_free_num(&result);\n  return ret;\n}","idx":"hhvm-HHVM-3.12.10-0","target":1}
{"code":"String StringUtil::Implode(const Variant& items, const String& delim, const bool checkIsContainer\/*=true*\/) {\n    if (checkIsContainer && !isContainer(items)) {\n        throw_param_is_not_container();\n    }\n    int size = getContainerSize(items);\n    if (size == 0) return empty_string();\n    if (size > (INT_MAX \/ sizeof(String))) throw std::overflow_error(\"Size is too large\");\n    std::vector<String> sitems(size);\n    size_t len = 0;\n    int lenDelim = delim.size();\n    int i = 0;\n    for (ArrayIter iter(items); iter; ++iter) {\n        sitems[i] = iter.second().toString();\n        len += sitems[i].size() + lenDelim;\n        if (len < sitems[i].size()) throw std::overflow_error(\"Length overflow\");\n        i++;\n    }\n    len -= lenDelim; \/\/ always one delimiter less than count of items \n    assert(i == size);\n    String s = String(len, ReserveString);\n    char* buffer = s.mutableData();\n    const char* sdelim = delim.data();\n    char* p = buffer;\n    String& init_str = sitems[0];\n    int init_len = init_str.size();\n    memcpy(p, init_str.data(), init_len);\n    p += init_len;\n    for (int i = 1; i < size; i++) {\n        String& item = sitems[i];\n        memcpy(p, sdelim, lenDelim);\n        p += lenDelim;\n        int lenItem = item.size();\n        memcpy(p, item.data(), lenItem);\n        p += lenItem;\n    }\n    assert(p - buffer == len);\n    s.setSize(len);\n    return s;\n}","idx":"hhvm-HHVM-3.12.10-1","target":0}
{"code":"String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer \/* = true *\/) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n\n  String* sitems = (String*)req::malloc(size * sizeof(String));\n  int len = 0;\n  int lenDelim = delim.size();\n  int i = 0;\n  for (ArrayIter iter(items); iter; ++iter) {\n    new (&sitems[i]) String(iter.second().toString());\n    len += sitems[i].size() + lenDelim;\n    i++;\n  }\n  len -= lenDelim; \/\/ always one delimiter less than count of items\n  assert(i == size);\n\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  sitems[0].~String();\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n    sitems[i].~String();\n  }\n  req::free(sitems);\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}","idx":"hhvm-HHVM-3.12.10-1","target":1}
{"code":"static void brigade_move(apr_bucket_brigade *b, apr_bucket_brigade *a, apr_bucket *e) {\n    if (b == NULL || a == NULL || b == a) return;\n    apr_bucket *f;\n    if (e != APR_BRIGADE_SENTINEL(b)) {\n        f = APR_RING_LAST(&b->list);\n        APR_RING_UNSPLICE(e, f, link);\n        APR_RING_SPLICE_HEAD(&a->list, e, f, apr_bucket, link);\n    }\n    APR_BRIGADE_CHECK_CONSISTENCY(a);\n    APR_BRIGADE_CHECK_CONSISTENCY(b);\n}","idx":"httpd_03cab3f0aaf1bdf28cfd53e8c550030d5fe3a3ba_0","target":0}
{"code":"static long get_chunk_size(char *b) {\n    long chunksize = 0;\n    size_t chunkbits = sizeof(long) * 8;\n    size_t len = strlen(b);\n    ap_xlate_proto_from_ascii(b, len);\n    \/* Skip leading zeros *\/\n    while (*b == '0' && len > 0) {\n        ++b;\n        --len;\n    }\n    while (apr_isxdigit(*b) && (chunkbits > 0) && len > 0) {\n        int xvalue = 0;\n        if (*b >= '0' && *b <= '9') {\n            xvalue = *b - '0';\n        } else if (*b >= 'A' && *b <= 'F') {\n            xvalue = *b - 'A' + 0xa;\n        } else if (*b >= 'a' && *b <= 'f') {\n            xvalue = *b - 'a' + 0xa;\n        }\n        chunksize = (chunksize << 4) | xvalue;\n        chunkbits -= 4;\n        ++b;\n        --len;\n    }\n    if (apr_isxdigit(*b) && (chunkbits <= 0) && len > 0) {\n        \/* overflow *\/\n        return -1;\n    }\n    return chunksize;\n}","idx":"httpd_12cd078edfbd1ecce7533b49ce34f4f2743c725b_0","target":0}
{"code":"AP_DECLARE(char*)ap_md5_binary(apr_pool_t*p, const unsigned char*buf, int length){const char*hex=\"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;unsigned char hash[APR_MD5_DIGESTSIZE];char*r, result[33];\/*(MD5_DIGESTSIZE*2)+1*\/int i;\/**Take the MD5 hash of the string argument.*\/apr_md5_init(&my_md5);#if APR_CHARSET_EBCDIC \n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);#endif \n    apr_md5_update(&my_md5, buf, (unsigned int)length);apr_md5_final(hash, &my_md5);for(i=0, r=result;i<APR_MD5_DIGESTSIZE;i++){*r++=hex[hash[i]>>4];*r++=hex[hash[i]&0xF];}*r='\n    return apr_pstrndup(p, result, (APR_MD5_DIGESTSIZE*2)+1);}","idx":"httpd_27680735a0ee17ef5cefd7684a43e95dba679cc8_0","target":0}
{"code":"static int set_group_privs(void) {\n    if (!geteuid()) {\n        const char *name;\n        if (unixd_config.user_name[0] == '#') {\n            struct passwd *ent;\n            char *endptr;\n            uid_t uid = strtoul(&unixd_config.user_name[1], &endptr, 10);\n            if (*endptr != '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, 0, NULL, \"Invalid UID format\");\n                return -1;\n            }\n            if ((ent = getpwuid(uid)) == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, \"getpwuid: couldn't determine user name from uid %u, \"\n                             \"you probably need to modify the User directive\", (unsigned)uid);\n                return -1;\n            }\n            name = ent->pw_name;\n        } else {\n            name = unixd_config.user_name;\n        }\n#if !defined(OS2) && !defined(TPF)\n        if (setgid(unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, \"setgid: unable to set group id to Group %u\", (unsigned)unixd_config.group_id);\n            return -1;\n        }\n        if (initgroups(name, unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, \"initgroups: unable to set groups for User %s \"\n                        \"and Group %u\", name, (unsigned)unixd_config.group_id);\n            return -1;\n        }\n#endif \/*!defined(OS2) && !defined(TPF)*\/\n    }\n    return 0;\n}","idx":"httpd_8038760bc02c48c31a059dda2ad061a6460cd0dd_0","target":0}
{"code":"AP_DECLARE(char*)ap_md5_binary(apr_pool_t*p, const unsigned char*buf, int length){const char*hex=\"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;unsigned char hash[APR_MD5_DIGESTSIZE];char*r, result[33];\/*(MD5_DIGESTSIZE*2)+1*\/int i;\/**Take the MD5 hash of the string argument.*\/apr_md5_init(&my_md5);#if APR_CHARSET_EBCDIC \n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);#endif \n    apr_md5_update(&my_md5, buf, (unsigned int)length);apr_md5_final(hash, &my_md5);for(i=0, r=result;i<APR_MD5_DIGESTSIZE;i++){*r++=hex[hash[i]>>4];*r++=hex[hash[i]&0xF];}*r='\\0';\n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);}","idx":"httpd_8dddb48ed8aa22eb4959dfc9c7275275e19c4299_0","target":0}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    size_t calculated_size = ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, calculated_size);\n    if (!ap_scoreboard_image) return;\n    more_storage=shared_score;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score+calculated_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_8e8c19e46a77da0b247c91af6b30dde0c28163aa_0","target":0}
{"code":"AP_DECLARE(char*)ap_field_noparam(apr_pool_t*p, const char*intype){\n    const char*semi;\n    if(intype == NULL || *intype == '\\0') return NULL;\n    semi=ap_strchr_c(intype, ';');\n    if(semi == NULL){\n        return apr_pstrdup(p, intype);\n    } else {\n        while((semi>intype) && apr_isspace(semi[-1])){\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi-intype);\n    }\n}","idx":"httpd_9413f5d49bae37718a97303fd1b07661b1cb5778_0","target":0}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));\n    if (!ap_scoreboard_image) {\n        return;\n    }\n    more_storage=shared_score;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage <= (char*)shared_score+scoreboard_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_9ad8554d836907d0dcbe899992b297f4e1975c23_0","target":0}
{"code":"AP_DECLARE(char*)ap_field_noparam(apr_pool_t*p, const char*intype){\n    const char*semi;\n    if(intype == NULL)\n        return NULL;\n    semi=ap_strchr_c(intype, ';');\n    if(semi == NULL){\n        return apr_pstrdup(p, intype);\n    }else{\n        while((semi>intype) && apr_isspace(semi[-1])){\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi-intype);\n    }\n}","idx":"httpd_b7f6b9ef9951e2fc956040d0e6b9e65359899ef7_0","target":0}
{"code":"AP_CORE_DECLARE(void)ap_parse_uri(request_rec*r, const char*uri){\n    int status=HTTP_OK;\n    r->unparsed_uri=apr_pstrdup(r->pool, uri);\n    while((uri[0] == '\/') && (uri[1] == '\/')){\n        ++uri;\n    }\n    if(r->method_number == M_CONNECT){\n        status=apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }else{\n        status=apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if(status == APR_SUCCESS){\n        if(r->parsed_uri.scheme && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))){\n            r->hostname=r->parsed_uri.hostname;\n        }else if(r->method_number == M_CONNECT){\n            r->hostname=r->parsed_uri.hostname;\n        }\n        r->args=r->parsed_uri.query;\n        r->uri=r->parsed_uri.path ? r->parsed_uri.path : apr_pstrdup(r->pool, \"\/\");\n        #if defined(OS2) || defined(WIN32)\n        {\n            char*x;\n            for(x=r->uri;(x=strchr(x, '\\')) != NULL;)*x='\/';\n        }\n        #endif\/*OS2 || WIN32*\/\n    }else{\n        r->args=NULL;\n        r->hostname=NULL;\n        r->status=HTTP_BAD_REQUEST;\n        r->uri=apr_pstrdup(r->pool, uri);\n    }\n}","idx":"httpd_bfd6489f6b8ab0cbfbddc8e4d5754fa3660316e1_0","target":0}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));\n    if (!ap_scoreboard_image) return;\n    more_storage=shared_score;\n    if (!more_storage) return;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score+scoreboard_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_e95b9b94154dcd872cedbfbd7d77b4c252002034_0","target":0}
{"code":"static void* merge_action_dir_configs(apr_pool_t* p, void* basev, void* addv) {\n    if (!basev || !addv) return NULL;\n    action_dir_config* base = (action_dir_config*)basev;\n    action_dir_config* add = (action_dir_config*)addv;\n    action_dir_config* new = (action_dir_config*)apr_palloc(p, sizeof(action_dir_config));\n    if (!new) return NULL;\n    int i;\n    new->action_types = apr_table_overlay(p, add->action_types, base->action_types);\n    for (i = 0; i < METHODS; ++i) {\n        new->scripted[i] = add->scripted[i] ? add->scripted[i] : base->scripted[i];\n    }\n    new->configured = (base->configured || add->configured);\n    return new;\n}","idx":"httpd_ecec010fd3f8197d1a6724dd38b0d3a9c1e95d4a_0","target":0}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));\n    more_storage=shared_score;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage <= (char*)shared_score+scoreboard_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_edfecb64c8e7f169c3d396a0cc12da4baf41f6a8_0","target":0}
{"code":"void jas_free(void*ptr){JAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));if(ptr != NULL){free(ptr);}}","idx":"jasper-version-2.0.11-0","target":0}
{"code":"void jas_free(void *ptr)\n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}","idx":"jasper-version-2.0.11-0","target":1}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (INT_MAX - 16))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    return (char *)realloc((char *)ptr - diff, size + diff) + diff;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size, 32);\n#else\n    return realloc(ptr, size);\n#endif\n}","idx":"libav_727640fec3cec9b3cb655b1a6dab306bc6234f7a_1","target":1}
{"code":"static int biquad_init_coeffs(void *avc, struct FFIIRFilterCoeffs *c,\n                              enum IIRFilterMode filt_mode, int order,\n                              float cutoff_ratio, float stopband)\n{\n    double cos_w0, sin_w0;\n    double a0, x0, x1;\n\n    if (filt_mode != FF_FILTER_MODE_HIGHPASS &&\n        filt_mode != FF_FILTER_MODE_LOWPASS) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter currently only supports \"\n               \"high-pass and low-pass filter modes\\n\");\n        return -1;\n    }\n    if (order != 2) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter must have order of 2\\n\");\n        return -1;\n    }\n\n    cos_w0 = cos(M_PI * cutoff_ratio);\n    sin_w0 = sin(M_PI * cutoff_ratio);\n\n    a0 = 1.0 + (sin_w0 \/ 2.0);\n\n    if (filt_mode == FF_FILTER_MODE_HIGHPASS) {\n        c->gain  =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x1       = (-(1.0 + cos_w0))        \/ a0;\n    } else { \/\/ FF_FILTER_MODE_LOWPASS\n        c->gain  =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x1       =   (1.0 - cos_w0)         \/ a0;\n    }\n    c->cy[0] = (-1.0 + (sin_w0 \/ 2.0)) \/ a0;\n    c->cy[1] =  (2.0 *  cos_w0)        \/ a0;\n\n    \/\/ divide by gain to make the x coeffs integers.\n    \/\/ during filtering, the delay state will include the gain multiplication\n    c->cx[0] = lrintf(x0 \/ c->gain);\n    c->cx[1] = lrintf(x1 \/ c->gain);\n\n    return 0;\n}","idx":"libav_8d0b5ee0283ad22ab65429548b3d38dacc6552d0_1","target":1}
{"code":"static inline void init_get_bits(GetBitContext *s, const uint8_t *buffer,\n                                 int bit_size)\n{\n    int buffer_size = (bit_size+7)>>3;\n    if (buffer_size < 0 || bit_size < 0) {\n        buffer_size = bit_size = 0;\n        buffer = NULL;\n    }\n\n    s->buffer       = buffer;\n    s->size_in_bits = bit_size;\n#if !UNCHECKED_BITSTREAM_READER\n    s->size_in_bits_plus8 = bit_size + 8;\n#endif\n    s->buffer_end   = buffer + buffer_size;\n    s->index        = 0;\n}","idx":"libav_ce8867a53583ae0c3ee8429342f33cf95a728660_1","target":1}
{"code":"static\nECDSA_SIG *SM2_sig_gen(const EC_KEY *key, const BIGNUM *e)\n{\n    const BIGNUM *dA = EC_KEY_get0_private_key(key);\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n\n    ECDSA_SIG *sig = NULL;\n    EC_POINT *kG = NULL;\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *rk = NULL;\n    BIGNUM *r = NULL;\n    BIGNUM *s = NULL;\n    BIGNUM *x1 = NULL;\n    BIGNUM *tmp = NULL;\n\n    kG = EC_POINT_new(group);\n    if (kG == NULL)\n        goto done;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto done;\n\n    BN_CTX_start(ctx);\n\n    k = BN_CTX_get(ctx);\n    rk = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n\n    if (tmp == NULL)\n        goto done;\n\n    \/* These values are returned and so should not be allocated out of the context *\/\n    r = BN_new();\n    s = BN_new();\n\n    if (r == NULL || s == NULL)\n        goto done;\n\n    for (;;) {\n        BN_priv_rand_range(k, order);\n\n        if (EC_POINT_mul(group, kG, k, NULL, NULL, ctx) == 0)\n            goto done;\n\n        if (EC_POINT_get_affine_coordinates_GFp(group, kG, x1, NULL, ctx) == 0)\n            goto done;\n\n        if (BN_mod_add(r, e, x1, order, ctx) == 0)\n            goto done;\n\n        \/* try again if r == 0 or r+k == n *\/\n        if (BN_is_zero(r))\n            continue;\n\n        BN_add(rk, r, k);\n\n        if (BN_cmp(rk, order) == 0)\n            continue;\n\n        BN_add(s, dA, BN_value_one());\n        BN_mod_inverse(s, s, order, ctx);\n\n        BN_mod_mul(tmp, dA, r, order, ctx);\n        BN_sub(tmp, k, tmp);\n\n        BN_mod_mul(s, s, tmp, order, ctx);\n\n        sig = ECDSA_SIG_new();\n\n        if (sig == NULL)\n            goto done;\n\n         \/* takes ownership of r and s *\/\n        ECDSA_SIG_set0(sig, r, s);\n        break;\n    }\n\n done:\n\n    if (sig == NULL) {\n        BN_free(r);\n        BN_free(s);\n    }\n\n    BN_CTX_free(ctx);\n    EC_POINT_free(kG);\n    return sig;\n\n}","idx":"openssl_24578a18649b707d6800f04cac63e764445fbff5_1","target":1}
{"code":"void CRYPTO_destroy_dynlockid(int i)\n\t{\n\tCRYPTO_dynlock *pointer = NULL;\n\tif (i)\n\t\ti = -i-1;\n\tif (dynlock_destroy_callback == NULL)\n\t\treturn;\n\n\tCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))\n\t\treturn;\n\tpointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\n\tif (pointer != NULL)\n\t\t{\n\t\t--pointer->references;\n#ifdef REF_CHECK\n\t\tif (pointer->references < 0)\n\t\t\t{\n\t\t\tfprintf(stderr,\"CRYPTO_destroy_dynlockid, bad reference count\\n\");\n\t\t\tabort();\n\t\t\t}\n\t\telse\n#endif\n\t\t\tif (pointer->references <= 0)\n\t\t\t\t{\n\t\t\t\tsk_CRYPTO_dynlock_set(dyn_locks, i, NULL);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tpointer = NULL;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (pointer)\n\t\t{\n\t\tdynlock_destroy_callback(pointer->data,__FILE__,__LINE__);\n\t\tOPENSSL_free(pointer);\n\t\t}\n\t}","idx":"openssl_acd5c2acdca78d43c360387f0ae6b9a76ca3a5db_1","target":1}
{"code":"void PEM_dek_info(char *buf, const char *type, int len, char *str)\n\t{\n\tstatic const unsigned char map[17]=\"0123456789ABCDEF\";\n\tlong i;\n\tint j;\n\n\tstrcat(buf,\"DEK-Info: \");\n\tstrcat(buf,type);\n\tstrcat(buf,\",\");\n\tj=strlen(buf);\n\tfor (i=0; i<len; i++)\n\t\t{\n\t\tbuf[j+i*2]  =map[(str[i]>>4)&0x0f];\n\t\tbuf[j+i*2+1]=map[(str[i]   )&0x0f];\n\t\t}\n\tbuf[j+i*2]='\\n';\n\tbuf[j+i*2+1]='\\0';\n\t}","idx":"openssl_af7e41d654be6c9d590ab32d8a62e865ce153973_1","target":1}
{"code":"BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n        {\n\tBN_ULONG t1,t2;\n\tint c=0;\n\n\tassert(n >= 0);\n\tif (n <= 0) return((BN_ULONG)0);\n\n\tfor (;;)\n\t\t{\n\t\tt1=a[0]; t2=b[0];\n\t\tr[0]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[1]; t2=b[1];\n\t\tr[1]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[2]; t2=b[2];\n\t\tr[2]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[3]; t2=b[3];\n\t\tr[3]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\ta+=4;\n\t\tb+=4;\n\t\tr+=4;\n\t\t}\n\treturn(c);\n\t}","idx":"openssl_b8a6868629e2e78bfd55feba6884ce0c43831fe1_1","target":1}
{"code":"static int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           int max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned int i;\n\n    if (max-- < 1)\n        return (0);\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (max < (int)i)\n                return 0;\n            \/* Skip leading zeroes *\/\n            while (i && *p == 0) {\n                p++;\n                i--;\n            }\n            if (i > sizeof(long))\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return (1);\n}","idx":"openssl_fad572c151d33d540c83f14a22be1bd6e67bb566_1","target":1}
