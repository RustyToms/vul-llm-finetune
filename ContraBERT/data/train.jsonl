{"code": "@Override\n    public AuthenticationResult handleResponse(final byte[] response)\n    {\n        if (_state == State.COMPLETE)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalStateException(\"Multiple Authentications not permitted.\"));\n        }\n        else if (_state == State.INITIAL && (response == null || response.length == 0))\n        {\n            _state = State.CHALLENGE_SENT;\n            return new AuthenticationResult(new byte[0], AuthenticationResult.AuthenticationStatus.CONTINUE);\n        }\n\n        _state = State.COMPLETE;\n        if (response == null || response.length == 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n\n        int authzidNullPosition = findNullPosition(response, 0);\n        if (authzidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n        int authcidNullPosition = findNullPosition(response, authzidNullPosition + 1);\n        if (authcidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authcid null terminator not found\"));\n        }\n\n        String password;\n        _username = new String(response, authzidNullPosition + 1, authcidNullPosition - authzidNullPosition - 1, UTF8);\n        // TODO: should not get pwd as a String but as a char array...\n        int passwordLen = response.length - authcidNullPosition - 1;\n        password = new String(response, authcidNullPosition + 1, passwordLen, UTF8);\n        return _usernamePasswordAuthenticationProvider.authenticate(_username, password);\n    }", "code_tokens": ["@", "Override", "public", "AuthenticationResult", "handleResponse", "(", "final", "byte", "[", "]", "response", ")", "{", "if", "(", "_state", "==", "State", ".", "COMPLETE", ")", "{", "return", "new", "AuthenticationResult", "(", "AuthenticationResult", ".", "AuthenticationStatus", ".", "ERROR", ",", "new", "IllegalStateException", "(", "\"", "Multiple Authentications not permitted.", "\"", ")", ")", ";", "}", "else", "if", "(", "_state", "==", "State", ".", "INITIAL", "&&", "(", "response", "==", "null", "||", "response", ".", "length", "==", "0", ")", ")", "{", "_state", "=", "State", ".", "CHALLENGE_SENT", ";", "return", "new", "AuthenticationResult", "(", "new", "byte", "[", "0", "]", ",", "AuthenticationResult", ".", "AuthenticationStatus", ".", "CONTINUE", ")", ";", "}", "_state", "=", "State", ".", "COMPLETE", ";", "if", "(", "response", "==", "null", "||", "response", ".", "length", "==", "0", ")", "{", "return", "new", "AuthenticationResult", "(", "AuthenticationResult", ".", "AuthenticationStatus", ".", "ERROR", ",", "new", "IllegalArgumentException", "(", "\"", "Invalid PLAIN encoding, authzid null terminator not found", "\"", ")", ")", ";", "}", "int", "authzidNullPosition", "=", "findNullPosition", "(", "response", ",", "0", ")", ";", "if", "(", "authzidNullPosition", "<", "0", ")", "{", "return", "new", "AuthenticationResult", "(", "AuthenticationResult", ".", "AuthenticationStatus", ".", "ERROR", ",", "new", "IllegalArgumentException", "(", "\"", "Invalid PLAIN encoding, authzid null terminator not found", "\"", ")", ")", ";", "}", "int", "authcidNullPosition", "=", "findNullPosition", "(", "response", ",", "authzidNullPosition", "+", "1", ")", ";", "if", "(", "authcidNullPosition", "<", "0", ")", "{", "return", "new", "AuthenticationResult", "(", "AuthenticationResult", ".", "AuthenticationStatus", ".", "ERROR", ",", "new", "IllegalArgumentException", "(", "\"", "Invalid PLAIN encoding, authcid null terminator not found", "\"", ")", ")", ";", "}", "String", "password", ";", "_username", "=", "new", "String", "(", "response", ",", "authzidNullPosition", "+", "1", ",", "authcidNullPosition", "-", "authzidNullPosition", "-", "1", ",", "UTF8", ")", ";", "int", "passwordLen", "=", "response", ".", "length", "-", "authcidNullPosition", "-", "1", ";", "password", "=", "new", "String", "(", "response", ",", "authcidNullPosition", "+", "1", ",", "passwordLen", ",", "UTF8", ")", ";", "return", "_usernamePasswordAuthenticationProvider", ".", "authenticate", "(", "_username", ",", "password", ")", ";", "}"], "idx": 5573, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "4b9fb37abbe882193b16595ed7b8e9d8383f59e1", "function_name": "handleResponse", "body_hash": "6428c7b56ad26407d8c4d21a9cc74ec8f384aa68"}
{"code": "private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        // form field validation\n        // this pattern needs to be generalized and moved to stapler\n        SignupInfo si = new SignupInfo(req);\n\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else {\n            User user = User.get(si.username, false);\n            if (null != user)\n                // Allow sign up. SCM people has no such property.\n                if (user.getProperty(Details.class) != null)\n                    si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n        }\n\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(si.email==null || !si.email.contains(\"@\"))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if(si.errorMessage!=null) {\n            // failed. ask the user to try again.\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        // register the user\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        try {\n            // legacy hack. mail support has moved out to a separate plugin\n            Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n            Constructor<?> c = up.getDeclaredConstructor(String.class);\n            user.addProperty((UserProperty)c.newInstance(si.email));\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Failed to set the e-mail address\",e);\n        }\n        user.save();\n        return user;\n    }", "code_tokens": ["private", "User", "createAccount", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ",", "boolean", "selfRegistration", ",", "String", "formView", ")", "throws", "ServletException", ",", "IOException", "{", "SignupInfo", "si", "=", "new", "SignupInfo", "(", "req", ")", ";", "if", "(", "selfRegistration", "&&", "!", "validateCaptcha", "(", "si", ".", "captcha", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage", "(", ")", ";", "if", "(", "si", ".", "password1", "!=", "null", "&&", "!", "si", ".", "password1", ".", "equals", "(", "si", ".", "password2", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch", "(", ")", ";", "if", "(", "!", "(", "si", ".", "password1", "!=", "null", "&&", "si", ".", "password1", ".", "length", "(", ")", "!=", "0", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired", "(", ")", ";", "if", "(", "si", ".", "username", "==", "null", "||", "si", ".", "username", ".", "length", "(", ")", "==", "0", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired", "(", ")", ";", "else", "{", "User", "user", "=", "User", ".", "get", "(", "si", ".", "username", ",", "false", ")", ";", "if", "(", "null", "!=", "user", ")", "if", "(", "user", ".", "getProperty", "(", "Details", ".", "class", ")", "!=", "null", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken", "(", ")", ";", "}", "if", "(", "si", ".", "fullname", "==", "null", "||", "si", ".", "fullname", ".", "length", "(", ")", "==", "0", ")", "si", ".", "fullname", "=", "si", ".", "username", ";", "if", "(", "si", ".", "email", "==", "null", "||", "!", "si", ".", "email", ".", "contains", "(", "\"", "@", "\"", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress", "(", ")", ";", "if", "(", "si", ".", "errorMessage", "!=", "null", ")", "{", "req", ".", "setAttribute", "(", "\"", "data", "\"", ",", "si", ")", ";", "req", ".", "getView", "(", "this", ",", "formView", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "return", "null", ";", "}", "User", "user", "=", "createAccount", "(", "si", ".", "username", ",", "si", ".", "password1", ")", ";", "user", ".", "setFullName", "(", "si", ".", "fullname", ")", ";", "try", "{", "Class", "<", "?", ">", "up", "=", "Jenkins", ".", "getInstance", "(", ")", ".", "pluginManager", ".", "uberClassLoader", ".", "loadClass", "(", "\"", "hudson.tasks.Mailer$UserProperty", "\"", ")", ";", "Constructor", "<", "?", ">", "c", "=", "up", ".", "getDeclaredConstructor", "(", "String", ".", "class", ")", ";", "user", ".", "addProperty", "(", "(", "UserProperty", ")", "c", ".", "newInstance", "(", "si", ".", "email", ")", ")", ";", "}", "catch", "(", "RuntimeException", "e", ")", "{", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to set the e-mail address", "\"", ",", "e", ")", ";", "}", "user", ".", "save", "(", ")", ";", "return", "user", ";", "}"], "idx": 30073, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "01a087d127d7a871eac02b03143464e2f4c6d48c", "function_name": "createAccount", "body_hash": "f272de1ad4071b60e04629617c9bb57489c8bb0a"}
{"code": "private boolean processRemainingHeader() throws IOException {\n        // Ignore the 2 bytes already read. 4 for the mask\n        int headerLength;\n        if (isMasked()) {\n            headerLength = 4;\n        } else {\n            headerLength = 0;\n        }\n        // Add additional bytes depending on length\n        if (payloadLength == 126) {\n            headerLength += 2;\n        } else if (payloadLength == 127) {\n            headerLength += 8;\n        }\n        if (inputBuffer.remaining() < headerLength) {\n            return false;\n        }\n        // Calculate new payload length if necessary\n        if (payloadLength == 126) {\n            payloadLength = byteArrayToLong(inputBuffer.array(),\n                    inputBuffer.arrayOffset() + inputBuffer.position(), 2);\n            inputBuffer.position(inputBuffer.position() + 2);\n        } else if (payloadLength == 127) {\n            payloadLength = byteArrayToLong(inputBuffer.array(),\n                    inputBuffer.arrayOffset() + inputBuffer.position(), 8);\n            inputBuffer.position(inputBuffer.position() + 8);\n        }\n        if (Util.isControl(opCode)) {\n            if (payloadLength > 125) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlPayloadTooBig\", Long.valueOf(payloadLength))));\n            }\n            if (!fin) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlNoFin\")));\n            }\n        }\n        if (isMasked()) {\n            inputBuffer.get(mask, 0, 4);\n        }\n        state = State.DATA;\n        return true;\n    }", "code_tokens": ["private", "boolean", "processRemainingHeader", "(", ")", "throws", "IOException", "{", "int", "headerLength", ";", "if", "(", "isMasked", "(", ")", ")", "{", "headerLength", "=", "4", ";", "}", "else", "{", "headerLength", "=", "0", ";", "}", "if", "(", "payloadLength", "==", "126", ")", "{", "headerLength", "+=", "2", ";", "}", "else", "if", "(", "payloadLength", "==", "127", ")", "{", "headerLength", "+=", "8", ";", "}", "if", "(", "inputBuffer", ".", "remaining", "(", ")", "<", "headerLength", ")", "{", "return", "false", ";", "}", "if", "(", "payloadLength", "==", "126", ")", "{", "payloadLength", "=", "byteArrayToLong", "(", "inputBuffer", ".", "array", "(", ")", ",", "inputBuffer", ".", "arrayOffset", "(", ")", "+", "inputBuffer", ".", "position", "(", ")", ",", "2", ")", ";", "inputBuffer", ".", "position", "(", "inputBuffer", ".", "position", "(", ")", "+", "2", ")", ";", "}", "else", "if", "(", "payloadLength", "==", "127", ")", "{", "payloadLength", "=", "byteArrayToLong", "(", "inputBuffer", ".", "array", "(", ")", ",", "inputBuffer", ".", "arrayOffset", "(", ")", "+", "inputBuffer", ".", "position", "(", ")", ",", "8", ")", ";", "inputBuffer", ".", "position", "(", "inputBuffer", ".", "position", "(", ")", "+", "8", ")", ";", "}", "if", "(", "Util", ".", "isControl", "(", "opCode", ")", ")", "{", "if", "(", "payloadLength", ">", "125", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.controlPayloadTooBig", "\"", ",", "Long", ".", "valueOf", "(", "payloadLength", ")", ")", ")", ")", ";", "}", "if", "(", "!", "fin", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.controlNoFin", "\"", ")", ")", ")", ";", "}", "}", "if", "(", "isMasked", "(", ")", ")", "{", "inputBuffer", ".", "get", "(", "mask", ",", "0", ",", "4", ")", ";", "}", "state", "=", "State", ".", "DATA", ";", "return", "true", ";", "}"], "idx": 82446, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "12d715676038efbf9c728af10163f8277fc019d5", "function_name": "processRemainingHeader", "body_hash": "c25fa83047429e1b1797fff2526ca7ffb48a50e8"}
{"code": "@Override\n    public SessionData decode(String data) {\n        byte[] bytes = Base64.getDecoder().decode(data);\n        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);\n             WhitelistObjectInputStream objectInputStream = new WhitelistObjectInputStream(inputStream)) {\n            return (SessionData) objectInputStream.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            throw new PippoRuntimeException(e, \"Cannot deserialize session. A new one will be created.\");\n        }\n    }", "code_tokens": ["@", "Override", "public", "SessionData", "decode", "(", "String", "data", ")", "{", "byte", "[", "]", "bytes", "=", "Base64", ".", "getDecoder", "(", ")", ".", "decode", "(", "data", ")", ";", "try", "(", "ByteArrayInputStream", "inputStream", "=", "new", "ByteArrayInputStream", "(", "bytes", ")", ";", "WhitelistObjectInputStream", "objectInputStream", "=", "new", "WhitelistObjectInputStream", "(", "inputStream", ")", ")", "{", "return", "(", "SessionData", ")", "objectInputStream", ".", "readObject", "(", ")", ";", "}", "catch", "(", "IOException", "|", "ClassNotFoundException", "e", ")", "{", "throw", "new", "PippoRuntimeException", "(", "e", ",", "\"", "Cannot deserialize session. A new one will be created.", "\"", ")", ";", "}", "}"], "idx": 61522, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "c6b26551a82d2dd32097fcb17c13c3b830916296", "function_name": "decode", "body_hash": "f73ae3114b4b3f4e9b9a15cadcebe64bc7e5dacb"}
{"code": "protected void doDirectory(HttpServletRequest request,HttpServletResponse response, Resource resource)\n        throws IOException\n    {\n        if (_directory)\n        {\n            String listing = resource.getListHTML(request.getRequestURI(),request.getPathInfo().lastIndexOf(\"/\") > 0, request.getQueryString());\n            response.setContentType(\"text/html; charset=UTF-8\");\n            response.getWriter().println(listing);\n        }\n        else\n            response.sendError(HttpStatus.FORBIDDEN_403);\n    }", "code_tokens": ["protected", "void", "doDirectory", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Resource", "resource", ")", "throws", "IOException", "{", "if", "(", "_directory", ")", "{", "String", "listing", "=", "resource", ".", "getListHTML", "(", "request", ".", "getRequestURI", "(", ")", ",", "request", ".", "getPathInfo", "(", ")", ".", "lastIndexOf", "(", "\"", "/", "\"", ")", ">", "0", ",", "request", ".", "getQueryString", "(", ")", ")", ";", "response", ".", "setContentType", "(", "\"", "text/html; charset=UTF-8", "\"", ")", ";", "response", ".", "getWriter", "(", ")", ".", "println", "(", "listing", ")", ";", "}", "else", "response", ".", "sendError", "(", "HttpStatus", ".", "FORBIDDEN_403", ")", ";", "}"], "idx": 79530, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "ca77bd384a2970cabbbdab25cf6251c6fb76cd21", "function_name": "doDirectory", "body_hash": "a96c705a891f9208a4ea57c39d6f0c1ff6fa4eb3"}
{"code": "public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                // we went too far into the future\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to roll over to the next field.\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    //check if value was actually set\n                    if (f.valueOf(cal) != next) {\n                        // we need to roll over to the next field.\n                        f.rollUp(cal, 1);\n                        f.setTo(cal,f.first(this));\n                        // since higher order field is affected by this, we need to restart from all over\n                        continue OUTER;\n                    }\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }", "code_tokens": ["public", "Calendar", "ceil", "(", "Calendar", "cal", ")", "{", "Calendar", "twoYearsFuture", "=", "(", "Calendar", ")", "cal", ".", "clone", "(", ")", ";", "twoYearsFuture", ".", "add", "(", "Calendar", ".", "YEAR", ",", "2", ")", ";", "OUTER", ":", "while", "(", "true", ")", "{", "if", "(", "cal", ".", "compareTo", "(", "twoYearsFuture", ")", ">", "0", ")", "{", "throw", "new", "RareOrImpossibleDateException", "(", ")", ";", "}", "for", "(", "CalendarField", "f", ":", "CalendarField", ".", "ADJUST_ORDER", ")", "{", "int", "cur", "=", "f", ".", "valueOf", "(", "cal", ")", ";", "int", "next", "=", "f", ".", "ceil", "(", "this", ",", "cur", ")", ";", "if", "(", "cur", "==", "next", ")", "continue", ";", "for", "(", "CalendarField", "l", "=", "f", ".", "lowerField", ";", "l", "!=", "null", ";", "l", "=", "l", ".", "lowerField", ")", "l", ".", "clear", "(", "cal", ")", ";", "if", "(", "next", "<", "0", ")", "{", "f", ".", "rollUp", "(", "cal", ",", "1", ")", ";", "f", ".", "setTo", "(", "cal", ",", "f", ".", "first", "(", "this", ")", ")", ";", "continue", "OUTER", ";", "}", "else", "{", "f", ".", "setTo", "(", "cal", ",", "next", ")", ";", "if", "(", "f", ".", "valueOf", "(", "cal", ")", "!=", "next", ")", "{", "f", ".", "rollUp", "(", "cal", ",", "1", ")", ";", "f", ".", "setTo", "(", "cal", ",", "f", ".", "first", "(", "this", ")", ")", ";", "continue", "OUTER", ";", "}", "if", "(", "f", ".", "redoAdjustmentIfModified", ")", "continue", "OUTER", ";", "}", "}", "return", "cal", ";", "}", "}"], "idx": 82173, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "73afa0ca786a87f05b5433e2e38f863826fcad17", "function_name": "ceil", "body_hash": "890ece75d314905934f86df391d951fbe641e4d2"}
{"code": "public SSOValidatorResponse validateSamlResponse(\n        org.opensaml.saml.saml2.core.Response samlResponse,\n        boolean postBinding\n    ) throws WSSecurityException {\n        // Check the Issuer\n        validateIssuer(samlResponse.getIssuer());\n\n        // The Response must contain at least one Assertion.\n        if (samlResponse.getAssertions() == null || samlResponse.getAssertions().isEmpty()) {\n            LOG.fine(\"The Response must contain at least one Assertion\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // The Response must contain a Destination that matches the assertionConsumerURL if it is\n        // signed\n        String destination = samlResponse.getDestination();\n        if (samlResponse.isSigned()\n            && (destination == null || !destination.equals(assertionConsumerURL))) {\n            LOG.fine(\"The Response must contain a destination that matches the assertion consumer URL\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Validate Assertions\n        org.opensaml.saml.saml2.core.Assertion validAssertion = null;\n        Date sessionNotOnOrAfter = null;\n        for (org.opensaml.saml.saml2.core.Assertion assertion : samlResponse.getAssertions()) {\n            // Check the Issuer\n            if (assertion.getIssuer() == null) {\n                LOG.fine(\"Assertion Issuer must not be null\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            validateIssuer(assertion.getIssuer());\n            \n            if (enforceAssertionsSigned && postBinding && assertion.getSignature() == null) {\n                LOG.fine(\"If the HTTP Post binding is used to deliver the Response, \"\n                         + \"the enclosed assertions must be signed\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            \n            // Check for AuthnStatements and validate the Subject accordingly\n            if (assertion.getAuthnStatements() != null\n                && !assertion.getAuthnStatements().isEmpty()) {\n                org.opensaml.saml.saml2.core.Subject subject = assertion.getSubject();\n                if (validateAuthenticationSubject(subject, assertion.getID(), postBinding)) {\n                    validateAudienceRestrictionCondition(assertion.getConditions());\n                    validAssertion = assertion;\n                    // Store Session NotOnOrAfter\n                    for (AuthnStatement authnStatment : assertion.getAuthnStatements()) {\n                        if (authnStatment.getSessionNotOnOrAfter() != null) {\n                            sessionNotOnOrAfter = authnStatment.getSessionNotOnOrAfter().toDate();\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (validAssertion == null) {\n            LOG.fine(\"The Response did not contain any Authentication Statement that matched \"\n                     + \"the Subject Confirmation criteria\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        SSOValidatorResponse validatorResponse = new SSOValidatorResponse();\n        validatorResponse.setResponseId(samlResponse.getID());\n        validatorResponse.setSessionNotOnOrAfter(sessionNotOnOrAfter);\n        if (samlResponse.getIssueInstant() != null) {\n            validatorResponse.setCreated(samlResponse.getIssueInstant().toDate());\n        }\n        \n        // the assumption for now is that SAMLResponse will contain only a single assertion\n        Element assertionElement = validAssertion.getDOM();\n        Element clonedAssertionElement = (Element)assertionElement.cloneNode(true);\n        validatorResponse.setAssertionElement(clonedAssertionElement);\n        validatorResponse.setAssertion(DOM2Writer.nodeToString(clonedAssertionElement));\n        \n        return validatorResponse;\n    }", "code_tokens": ["public", "SSOValidatorResponse", "validateSamlResponse", "(", "org", ".", "opensaml", ".", "saml", ".", "saml2", ".", "core", ".", "Response", "samlResponse", ",", "boolean", "postBinding", ")", "throws", "WSSecurityException", "{", "validateIssuer", "(", "samlResponse", ".", "getIssuer", "(", ")", ")", ";", "if", "(", "samlResponse", ".", "getAssertions", "(", ")", "==", "null", "||", "samlResponse", ".", "getAssertions", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "The Response must contain at least one Assertion", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "String", "destination", "=", "samlResponse", ".", "getDestination", "(", ")", ";", "if", "(", "samlResponse", ".", "isSigned", "(", ")", "&&", "(", "destination", "==", "null", "||", "!", "destination", ".", "equals", "(", "assertionConsumerURL", ")", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "The Response must contain a destination that matches the assertion consumer URL", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "org", ".", "opensaml", ".", "saml", ".", "saml2", ".", "core", ".", "Assertion", "validAssertion", "=", "null", ";", "Date", "sessionNotOnOrAfter", "=", "null", ";", "for", "(", "org", ".", "opensaml", ".", "saml", ".", "saml2", ".", "core", ".", "Assertion", "assertion", ":", "samlResponse", ".", "getAssertions", "(", ")", ")", "{", "if", "(", "assertion", ".", "getIssuer", "(", ")", "==", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "Assertion Issuer must not be null", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "validateIssuer", "(", "assertion", ".", "getIssuer", "(", ")", ")", ";", "if", "(", "enforceAssertionsSigned", "&&", "postBinding", "&&", "assertion", ".", "getSignature", "(", ")", "==", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "If the HTTP Post binding is used to deliver the Response, ", "\"", "+", "\"", "the enclosed assertions must be signed", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "if", "(", "assertion", ".", "getAuthnStatements", "(", ")", "!=", "null", "&&", "!", "assertion", ".", "getAuthnStatements", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "org", ".", "opensaml", ".", "saml", ".", "saml2", ".", "core", ".", "Subject", "subject", "=", "assertion", ".", "getSubject", "(", ")", ";", "if", "(", "validateAuthenticationSubject", "(", "subject", ",", "assertion", ".", "getID", "(", ")", ",", "postBinding", ")", ")", "{", "validateAudienceRestrictionCondition", "(", "assertion", ".", "getConditions", "(", ")", ")", ";", "validAssertion", "=", "assertion", ";", "for", "(", "AuthnStatement", "authnStatment", ":", "assertion", ".", "getAuthnStatements", "(", ")", ")", "{", "if", "(", "authnStatment", ".", "getSessionNotOnOrAfter", "(", ")", "!=", "null", ")", "{", "sessionNotOnOrAfter", "=", "authnStatment", ".", "getSessionNotOnOrAfter", "(", ")", ".", "toDate", "(", ")", ";", "}", "}", "}", "}", "}", "if", "(", "validAssertion", "==", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "The Response did not contain any Authentication Statement that matched ", "\"", "+", "\"", "the Subject Confirmation criteria", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "SSOValidatorResponse", "validatorResponse", "=", "new", "SSOValidatorResponse", "(", ")", ";", "validatorResponse", ".", "setResponseId", "(", "samlResponse", ".", "getID", "(", ")", ")", ";", "validatorResponse", ".", "setSessionNotOnOrAfter", "(", "sessionNotOnOrAfter", ")", ";", "if", "(", "samlResponse", ".", "getIssueInstant", "(", ")", "!=", "null", ")", "{", "validatorResponse", ".", "setCreated", "(", "samlResponse", ".", "getIssueInstant", "(", ")", ".", "toDate", "(", ")", ")", ";", "}", "Element", "assertionElement", "=", "validAssertion", ".", "getDOM", "(", ")", ";", "Element", "clonedAssertionElement", "=", "(", "Element", ")", "assertionElement", ".", "cloneNode", "(", "true", ")", ";", "validatorResponse", ".", "setAssertionElement", "(", "clonedAssertionElement", ")", ";", "validatorResponse", ".", "setAssertion", "(", "DOM2Writer", ".", "nodeToString", "(", "clonedAssertionElement", ")", ")", ";", "return", "validatorResponse", ";", "}"], "idx": 33786, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "845eccb6484b43ba02875c71e824db23ae4f20c0", "function_name": "validateSamlResponse", "body_hash": "d527a316d22b46d2b7c194dfa2957babae3f9c78"}
{"code": "public FormValidation doSendTestMail(\n                @QueryParameter String smtpServer, @QueryParameter String adminAddress, @QueryParameter boolean useSMTPAuth,\n                @QueryParameter String smtpAuthUserName, @QueryParameter Secret smtpAuthPasswordSecret,\n                @QueryParameter boolean useSsl, @QueryParameter String smtpPort, @QueryParameter String charset,\n                @QueryParameter String sendTestMailTo) throws IOException, ServletException, InterruptedException {\n            try {\n                // TODO 1.590+ Jenkins.getActiveInstance\n                final Jenkins jenkins = Jenkins.getInstance();\n                if (jenkins == null) {\n                    throw new IOException(\"Jenkins instance is not ready\");\n                }\n                \n                if (!useSMTPAuth) {\n                    smtpAuthUserName = null;\n                    smtpAuthPasswordSecret = null;\n                }\n                \n                MimeMessage msg = new MimeMessage(createSession(smtpServer, smtpPort, useSsl, smtpAuthUserName, smtpAuthPasswordSecret));\n                msg.setSubject(Messages.Mailer_TestMail_Subject(testEmailCount.incrementAndGet()), charset);\n                msg.setText(Messages.Mailer_TestMail_Content(testEmailCount.get(), jenkins.getDisplayName()), charset);\n                msg.setFrom(stringToAddress(adminAddress, charset));\n                if (StringUtils.isNotBlank(replyToAddress)) {\n                    msg.setReplyTo(new Address[]{stringToAddress(replyToAddress, charset)});\n                }\n                msg.setSentDate(new Date());\n                msg.setRecipient(Message.RecipientType.TO, stringToAddress(sendTestMailTo, charset));\n\n                Transport.send(msg);                \n                return FormValidation.ok(Messages.Mailer_EmailSentSuccessfully());\n            } catch (MessagingException e) {\n                return FormValidation.errorWithMarkup(\"<p>\"+Messages.Mailer_FailedToSendEmail()+\"</p><pre>\"+Util.escape(Functions.printThrowable(e))+\"</pre>\");\n            }\n        }", "code_tokens": ["public", "FormValidation", "doSendTestMail", "(", "@", "QueryParameter", "String", "smtpServer", ",", "@", "QueryParameter", "String", "adminAddress", ",", "@", "QueryParameter", "boolean", "useSMTPAuth", ",", "@", "QueryParameter", "String", "smtpAuthUserName", ",", "@", "QueryParameter", "Secret", "smtpAuthPasswordSecret", ",", "@", "QueryParameter", "boolean", "useSsl", ",", "@", "QueryParameter", "String", "smtpPort", ",", "@", "QueryParameter", "String", "charset", ",", "@", "QueryParameter", "String", "sendTestMailTo", ")", "throws", "IOException", ",", "ServletException", ",", "InterruptedException", "{", "try", "{", "final", "Jenkins", "jenkins", "=", "Jenkins", ".", "getInstance", "(", ")", ";", "if", "(", "jenkins", "==", "null", ")", "{", "throw", "new", "IOException", "(", "\"", "Jenkins instance is not ready", "\"", ")", ";", "}", "if", "(", "!", "useSMTPAuth", ")", "{", "smtpAuthUserName", "=", "null", ";", "smtpAuthPasswordSecret", "=", "null", ";", "}", "MimeMessage", "msg", "=", "new", "MimeMessage", "(", "createSession", "(", "smtpServer", ",", "smtpPort", ",", "useSsl", ",", "smtpAuthUserName", ",", "smtpAuthPasswordSecret", ")", ")", ";", "msg", ".", "setSubject", "(", "Messages", ".", "Mailer_TestMail_Subject", "(", "testEmailCount", ".", "incrementAndGet", "(", ")", ")", ",", "charset", ")", ";", "msg", ".", "setText", "(", "Messages", ".", "Mailer_TestMail_Content", "(", "testEmailCount", ".", "get", "(", ")", ",", "jenkins", ".", "getDisplayName", "(", ")", ")", ",", "charset", ")", ";", "msg", ".", "setFrom", "(", "stringToAddress", "(", "adminAddress", ",", "charset", ")", ")", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "replyToAddress", ")", ")", "{", "msg", ".", "setReplyTo", "(", "new", "Address", "[", "]", "{", "stringToAddress", "(", "replyToAddress", ",", "charset", ")", "}", ")", ";", "}", "msg", ".", "setSentDate", "(", "new", "Date", "(", ")", ")", ";", "msg", ".", "setRecipient", "(", "Message", ".", "RecipientType", ".", "TO", ",", "stringToAddress", "(", "sendTestMailTo", ",", "charset", ")", ")", ";", "Transport", ".", "send", "(", "msg", ")", ";", "return", "FormValidation", ".", "ok", "(", "Messages", ".", "Mailer_EmailSentSuccessfully", "(", ")", ")", ";", "}", "catch", "(", "MessagingException", "e", ")", "{", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "<p>", "\"", "+", "Messages", ".", "Mailer_FailedToSendEmail", "(", ")", "+", "\"", "</p><pre>", "\"", "+", "Util", ".", "escape", "(", "Functions", ".", "printThrowable", "(", "e", ")", ")", "+", "\"", "</pre>", "\"", ")", ";", "}", "}"], "idx": 47162, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "98e79cf", "function_name": "doSendTestMail", "body_hash": "35266a9c7061086853cec05d0953bdb45ca3acb5"}
{"code": "private static FormValidation _error(Kind kind, Throwable e, String message) {\n        if (e==null)    return _errorWithMarkup(Util.escape(message),kind);\n\n        return _errorWithMarkup(Util.escape(message)+\n            \" <a href='#' class='showDetails'>\"\n            + Messages.FormValidation_Error_Details()\n            + \"</a><pre style='display:none'>\"\n            + Util.escape(Functions.printThrowable(e)) +\n            \"</pre>\",kind\n        );\n    }", "code_tokens": ["private", "static", "FormValidation", "_error", "(", "Kind", "kind", ",", "Throwable", "e", ",", "String", "message", ")", "{", "if", "(", "e", "==", "null", ")", "return", "_errorWithMarkup", "(", "Util", ".", "escape", "(", "message", ")", ",", "kind", ")", ";", "return", "_errorWithMarkup", "(", "Util", ".", "escape", "(", "message", ")", "+", "\"", " <a href='#' class='showDetails'>", "\"", "+", "Messages", ".", "FormValidation_Error_Details", "(", ")", "+", "\"", "</a><pre style='display:none'>", "\"", "+", "Util", ".", "escape", "(", "Functions", ".", "printThrowable", "(", "e", ")", ")", "+", "\"", "</pre>", "\"", ",", "kind", ")", ";", "}"], "idx": 79054, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "feb2703adb0c121705e5c8e9ddf8f663b6481cbd", "function_name": "_error", "body_hash": "8a7eebe2d624be9f89b95b5f0336997c5be4c5a4"}
{"code": "@Override\n    public String getWindowId(FacesContext facesContext)\n    {\n        Map<String, Object> requestMap = facesContext.getExternalContext().getRequestMap();\n\n        // try to lookup from cache\n        String windowId = (String) requestMap.get(CACHE_WINDOW_ID);\n        if (windowId != null)\n        {\n            return windowId;\n        }\n\n        windowId = getOrCreateWindowId(facesContext);\n\n\n        if (windowId != null)\n        {\n            windowId = sanitiseWindowId(windowId);\n\n            // don't cut the windowId generated from JSF\n            ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =\n                    clientWindowConfig.getClientWindowRenderMode(facesContext);\n            if (!ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))\n            {\n                if (windowId.length() > this.maxWindowIdCount)\n                {\n                    windowId = windowId.substring(0, this.maxWindowIdCount);\n                }\n            }\n\n            requestMap.put(CACHE_WINDOW_ID, windowId);\n        }\n\n        return windowId;\n    }", "code_tokens": ["@", "Override", "public", "String", "getWindowId", "(", "FacesContext", "facesContext", ")", "{", "Map", "<", "String", ",", "Object", ">", "requestMap", "=", "facesContext", ".", "getExternalContext", "(", ")", ".", "getRequestMap", "(", ")", ";", "String", "windowId", "=", "(", "String", ")", "requestMap", ".", "get", "(", "CACHE_WINDOW_ID", ")", ";", "if", "(", "windowId", "!=", "null", ")", "{", "return", "windowId", ";", "}", "windowId", "=", "getOrCreateWindowId", "(", "facesContext", ")", ";", "if", "(", "windowId", "!=", "null", ")", "{", "windowId", "=", "sanitiseWindowId", "(", "windowId", ")", ";", "ClientWindowConfig", ".", "ClientWindowRenderMode", "clientWindowRenderMode", "=", "clientWindowConfig", ".", "getClientWindowRenderMode", "(", "facesContext", ")", ";", "if", "(", "!", "ClientWindowConfig", ".", "ClientWindowRenderMode", ".", "DELEGATED", ".", "equals", "(", "clientWindowRenderMode", ")", ")", "{", "if", "(", "windowId", ".", "length", "(", ")", ">", "this", ".", "maxWindowIdCount", ")", "{", "windowId", "=", "windowId", ".", "substring", "(", "0", ",", "this", ".", "maxWindowIdCount", ")", ";", "}", "}", "requestMap", ".", "put", "(", "CACHE_WINDOW_ID", ",", "windowId", ")", ";", "}", "return", "windowId", ";", "}"], "idx": 79086, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "72e607f3", "function_name": "getWindowId", "body_hash": "2a4eeb19a9d0ce1bba813d29022a9be5f1360ecd"}
{"code": "@Override\n    public void send(Map<String, String> config, UserModel user, String subject, String textBody, String htmlBody) throws EmailException {\n        Transport transport = null;\n        try {\n            String address = retrieveEmailAddress(user);\n\n            Properties props = new Properties();\n\n            if (config.containsKey(\"host\")) {\n                props.setProperty(\"mail.smtp.host\", config.get(\"host\"));\n            }\n\n            boolean auth = \"true\".equals(config.get(\"auth\"));\n            boolean ssl = \"true\".equals(config.get(\"ssl\"));\n            boolean starttls = \"true\".equals(config.get(\"starttls\"));\n\n            if (config.containsKey(\"port\") && config.get(\"port\") != null) {\n                props.setProperty(\"mail.smtp.port\", config.get(\"port\"));\n            }\n\n            if (auth) {\n                props.setProperty(\"mail.smtp.auth\", \"true\");\n            }\n\n            if (ssl) {\n                props.setProperty(\"mail.smtp.ssl.enable\", \"true\");\n            }\n\n            if (starttls) {\n                props.setProperty(\"mail.smtp.starttls.enable\", \"true\");\n            }\n\n            if (ssl || starttls) {\n                setupTruststore(props);\n            }\n\n            props.setProperty(\"mail.smtp.timeout\", \"10000\");\n            props.setProperty(\"mail.smtp.connectiontimeout\", \"10000\");\n\n            String from = config.get(\"from\");\n            String fromDisplayName = config.get(\"fromDisplayName\");\n            String replyTo = config.get(\"replyTo\");\n            String replyToDisplayName = config.get(\"replyToDisplayName\");\n            String envelopeFrom = config.get(\"envelopeFrom\");\n\n            Session session = Session.getInstance(props);\n\n            Multipart multipart = new MimeMultipart(\"alternative\");\n\n            if (textBody != null) {\n                MimeBodyPart textPart = new MimeBodyPart();\n                textPart.setText(textBody, \"UTF-8\");\n                multipart.addBodyPart(textPart);\n            }\n\n            if (htmlBody != null) {\n                MimeBodyPart htmlPart = new MimeBodyPart();\n                htmlPart.setContent(htmlBody, \"text/html; charset=UTF-8\");\n                multipart.addBodyPart(htmlPart);\n            }\n\n            SMTPMessage msg = new SMTPMessage(session);\n            msg.setFrom(toInternetAddress(from, fromDisplayName));\n\n            msg.setReplyTo(new Address[]{toInternetAddress(from, fromDisplayName)});\n            if (replyTo != null && !replyTo.isEmpty()) {\n                msg.setReplyTo(new Address[]{toInternetAddress(replyTo, replyToDisplayName)});\n            }\n            if (envelopeFrom != null && !envelopeFrom.isEmpty()) {\n                msg.setEnvelopeFrom(envelopeFrom);\n            }\n\n            msg.setHeader(\"To\", address);\n            msg.setSubject(subject, \"utf-8\");\n            msg.setContent(multipart);\n            msg.saveChanges();\n            msg.setSentDate(new Date());\n\n            transport = session.getTransport(\"smtp\");\n            if (auth) {\n                try (VaultStringSecret vaultStringSecret = this.session.vault().getStringSecret(config.get(\"password\"))) {\n                    transport.connect(config.get(\"user\"), vaultStringSecret.get().orElse(config.get(\"password\")));\n                }\n            } else {\n                transport.connect();\n            }\n            transport.sendMessage(msg, new InternetAddress[]{new InternetAddress(address)});\n        } catch (Exception e) {\n            ServicesLogger.LOGGER.failedToSendEmail(e);\n            throw new EmailException(e);\n        } finally {\n            if (transport != null) {\n                try {\n                    transport.close();\n                } catch (MessagingException e) {\n                    logger.warn(\"Failed to close transport\", e);\n                }\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "send", "(", "Map", "<", "String", ",", "String", ">", "config", ",", "UserModel", "user", ",", "String", "subject", ",", "String", "textBody", ",", "String", "htmlBody", ")", "throws", "EmailException", "{", "Transport", "transport", "=", "null", ";", "try", "{", "String", "address", "=", "retrieveEmailAddress", "(", "user", ")", ";", "Properties", "props", "=", "new", "Properties", "(", ")", ";", "if", "(", "config", ".", "containsKey", "(", "\"", "host", "\"", ")", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.host", "\"", ",", "config", ".", "get", "(", "\"", "host", "\"", ")", ")", ";", "}", "boolean", "auth", "=", "\"", "true", "\"", ".", "equals", "(", "config", ".", "get", "(", "\"", "auth", "\"", ")", ")", ";", "boolean", "ssl", "=", "\"", "true", "\"", ".", "equals", "(", "config", ".", "get", "(", "\"", "ssl", "\"", ")", ")", ";", "boolean", "starttls", "=", "\"", "true", "\"", ".", "equals", "(", "config", ".", "get", "(", "\"", "starttls", "\"", ")", ")", ";", "if", "(", "config", ".", "containsKey", "(", "\"", "port", "\"", ")", "&&", "config", ".", "get", "(", "\"", "port", "\"", ")", "!=", "null", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.port", "\"", ",", "config", ".", "get", "(", "\"", "port", "\"", ")", ")", ";", "}", "if", "(", "auth", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.auth", "\"", ",", "\"", "true", "\"", ")", ";", "}", "if", "(", "ssl", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.ssl.enable", "\"", ",", "\"", "true", "\"", ")", ";", "}", "if", "(", "starttls", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.starttls.enable", "\"", ",", "\"", "true", "\"", ")", ";", "}", "if", "(", "ssl", "||", "starttls", ")", "{", "setupTruststore", "(", "props", ")", ";", "}", "props", ".", "setProperty", "(", "\"", "mail.smtp.timeout", "\"", ",", "\"", "10000", "\"", ")", ";", "props", ".", "setProperty", "(", "\"", "mail.smtp.connectiontimeout", "\"", ",", "\"", "10000", "\"", ")", ";", "String", "from", "=", "config", ".", "get", "(", "\"", "from", "\"", ")", ";", "String", "fromDisplayName", "=", "config", ".", "get", "(", "\"", "fromDisplayName", "\"", ")", ";", "String", "replyTo", "=", "config", ".", "get", "(", "\"", "replyTo", "\"", ")", ";", "String", "replyToDisplayName", "=", "config", ".", "get", "(", "\"", "replyToDisplayName", "\"", ")", ";", "String", "envelopeFrom", "=", "config", ".", "get", "(", "\"", "envelopeFrom", "\"", ")", ";", "Session", "session", "=", "Session", ".", "getInstance", "(", "props", ")", ";", "Multipart", "multipart", "=", "new", "MimeMultipart", "(", "\"", "alternative", "\"", ")", ";", "if", "(", "textBody", "!=", "null", ")", "{", "MimeBodyPart", "textPart", "=", "new", "MimeBodyPart", "(", ")", ";", "textPart", ".", "setText", "(", "textBody", ",", "\"", "UTF-8", "\"", ")", ";", "multipart", ".", "addBodyPart", "(", "textPart", ")", ";", "}", "if", "(", "htmlBody", "!=", "null", ")", "{", "MimeBodyPart", "htmlPart", "=", "new", "MimeBodyPart", "(", ")", ";", "htmlPart", ".", "setContent", "(", "htmlBody", ",", "\"", "text/html; charset=UTF-8", "\"", ")", ";", "multipart", ".", "addBodyPart", "(", "htmlPart", ")", ";", "}", "SMTPMessage", "msg", "=", "new", "SMTPMessage", "(", "session", ")", ";", "msg", ".", "setFrom", "(", "toInternetAddress", "(", "from", ",", "fromDisplayName", ")", ")", ";", "msg", ".", "setReplyTo", "(", "new", "Address", "[", "]", "{", "toInternetAddress", "(", "from", ",", "fromDisplayName", ")", "}", ")", ";", "if", "(", "replyTo", "!=", "null", "&&", "!", "replyTo", ".", "isEmpty", "(", ")", ")", "{", "msg", ".", "setReplyTo", "(", "new", "Address", "[", "]", "{", "toInternetAddress", "(", "replyTo", ",", "replyToDisplayName", ")", "}", ")", ";", "}", "if", "(", "envelopeFrom", "!=", "null", "&&", "!", "envelopeFrom", ".", "isEmpty", "(", ")", ")", "{", "msg", ".", "setEnvelopeFrom", "(", "envelopeFrom", ")", ";", "}", "msg", ".", "setHeader", "(", "\"", "To", "\"", ",", "address", ")", ";", "msg", ".", "setSubject", "(", "subject", ",", "\"", "utf-8", "\"", ")", ";", "msg", ".", "setContent", "(", "multipart", ")", ";", "msg", ".", "saveChanges", "(", ")", ";", "msg", ".", "setSentDate", "(", "new", "Date", "(", ")", ")", ";", "transport", "=", "session", ".", "getTransport", "(", "\"", "smtp", "\"", ")", ";", "if", "(", "auth", ")", "{", "try", "(", "VaultStringSecret", "vaultStringSecret", "=", "this", ".", "session", ".", "vault", "(", ")", ".", "getStringSecret", "(", "config", ".", "get", "(", "\"", "password", "\"", ")", ")", ")", "{", "transport", ".", "connect", "(", "config", ".", "get", "(", "\"", "user", "\"", ")", ",", "vaultStringSecret", ".", "get", "(", ")", ".", "orElse", "(", "config", ".", "get", "(", "\"", "password", "\"", ")", ")", ")", ";", "}", "}", "else", "{", "transport", ".", "connect", "(", ")", ";", "}", "transport", ".", "sendMessage", "(", "msg", ",", "new", "InternetAddress", "[", "]", "{", "new", "InternetAddress", "(", "address", ")", "}", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "ServicesLogger", ".", "LOGGER", ".", "failedToSendEmail", "(", "e", ")", ";", "throw", "new", "EmailException", "(", "e", ")", ";", "}", "finally", "{", "if", "(", "transport", "!=", "null", ")", "{", "try", "{", "transport", ".", "close", "(", ")", ";", "}", "catch", "(", "MessagingException", "e", ")", "{", "logger", ".", "warn", "(", "\"", "Failed to close transport", "\"", ",", "e", ")", ";", "}", "}", "}", "}"], "idx": 40502, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "97b565469058cacac6d2559b2cff37effcca2cfd", "function_name": "send", "body_hash": "6efe94db3f717242ad96461d730c6f7caf3a255a"}
{"code": "protected Document getDocument(URL url) throws StageException {\n\t\ttry {\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t\t\taddAuthHeader(conn);\n\t\t\tconn.setRequestProperty(\"Accept\", \"application/xml\");\n\t\t\tint status = conn.getResponseCode();\n\t\t\tif (status == HttpURLConnection.HTTP_OK) {\n\t\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\t\tDocument doc = builder.parse(conn.getInputStream());\n\t\t\t\tconn.disconnect();\n\t\t\t\treturn doc;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdrainOutput(conn);\n\t\t\t\tif (status == HttpURLConnection.HTTP_UNAUTHORIZED) {\n\t\t\t\t\tthrow new IOException(\"Incorrect username / password supplied.\");\n\t\t\t\t}\n\t\t\t\telse if (status == HttpURLConnection.HTTP_NOT_FOUND) {\n\t\t\t\t\tthrow new IOException(\"Document not found - is this a Nexus server?\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IOException(\"Server returned error code \" + status + \" for \" + url.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow createStageExceptionForIOException(nexusURL, ex);\n\t\t}\n\t\tcatch (ParserConfigurationException ex) {\n\t\t\tthrow new StageException(ex);\n\t\t}\n\t\tcatch (SAXException ex) {\n\t\t\tthrow new StageException(ex);\n\t\t}\n\n\t}", "code_tokens": ["protected", "Document", "getDocument", "(", "URL", "url", ")", "throws", "StageException", "{", "try", "{", "HttpURLConnection", "conn", "=", "(", "HttpURLConnection", ")", "url", ".", "openConnection", "(", ")", ";", "addAuthHeader", "(", "conn", ")", ";", "conn", ".", "setRequestProperty", "(", "\"", "Accept", "\"", ",", "\"", "application/xml", "\"", ")", ";", "int", "status", "=", "conn", ".", "getResponseCode", "(", ")", ";", "if", "(", "status", "==", "HttpURLConnection", ".", "HTTP_OK", ")", "{", "DocumentBuilder", "builder", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ".", "newDocumentBuilder", "(", ")", ";", "Document", "doc", "=", "builder", ".", "parse", "(", "conn", ".", "getInputStream", "(", ")", ")", ";", "conn", ".", "disconnect", "(", ")", ";", "return", "doc", ";", "}", "else", "{", "drainOutput", "(", "conn", ")", ";", "if", "(", "status", "==", "HttpURLConnection", ".", "HTTP_UNAUTHORIZED", ")", "{", "throw", "new", "IOException", "(", "\"", "Incorrect username / password supplied.", "\"", ")", ";", "}", "else", "if", "(", "status", "==", "HttpURLConnection", ".", "HTTP_NOT_FOUND", ")", "{", "throw", "new", "IOException", "(", "\"", "Document not found - is this a Nexus server?", "\"", ")", ";", "}", "else", "{", "throw", "new", "IOException", "(", "\"", "Server returned error code ", "\"", "+", "status", "+", "\"", " for ", "\"", "+", "url", ".", "toString", "(", ")", ")", ";", "}", "}", "}", "catch", "(", "IOException", "ex", ")", "{", "throw", "createStageExceptionForIOException", "(", "nexusURL", ",", "ex", ")", ";", "}", "catch", "(", "ParserConfigurationException", "ex", ")", "{", "throw", "new", "StageException", "(", "ex", ")", ";", "}", "catch", "(", "SAXException", "ex", ")", "{", "throw", "new", "StageException", "(", "ex", ")", ";", "}", "}"], "idx": 69554, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "1e4d6fe", "function_name": "getDocument", "body_hash": "261e18d9bb87c321844c40ab4d3117e157a970b4"}
{"code": "public static boolean isFileOutsideDir(\n          @NonNull final String filePath, @NonNull final String baseDirPath) throws IOException {\n    File file = new File(filePath);\n    File baseDir = new File(baseDirPath);\n    return !file.getCanonicalPath().startsWith(baseDir.getCanonicalPath());\n  }", "code_tokens": ["public", "static", "boolean", "isFileOutsideDir", "(", "@", "NonNull", "final", "String", "filePath", ",", "@", "NonNull", "final", "String", "baseDirPath", ")", "throws", "IOException", "{", "File", "file", "=", "new", "File", "(", "filePath", ")", ";", "File", "baseDir", "=", "new", "File", "(", "baseDirPath", ")", ";", "return", "!", "file", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "baseDir", ".", "getCanonicalPath", "(", ")", ")", ";", "}"], "idx": 27289, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "af35e870ed09411d2f1fae6db1b04598cd1a31b6", "function_name": "isFileOutsideDir", "body_hash": "40d82131a4e8ac959469d8872438b4eb65c2c9bf"}
{"code": "private String getBodyContentAsString() {\n\t\tif (body == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tString contentType = (messageProperties != null) ? messageProperties.getContentType() : null;\n\t\t\tif (MessageProperties.CONTENT_TYPE_SERIALIZED_OBJECT.equals(contentType)) {\n\t\t\t\treturn SerializationUtils.deserialize(body).toString();\n\t\t\t}\n\t\t\tif (MessageProperties.CONTENT_TYPE_TEXT_PLAIN.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON_ALT.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_XML.equals(contentType)) {\n\t\t\t\treturn new String(body, ENCODING);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t\t// Comes out as '[B@....b' (so harmless)\n\t\treturn body.toString()+\"(byte[\"+body.length+\"])\";//NOSONAR\n\t}", "code_tokens": ["private", "String", "getBodyContentAsString", "(", ")", "{", "if", "(", "body", "==", "null", ")", "{", "return", "null", ";", "}", "try", "{", "String", "contentType", "=", "(", "messageProperties", "!=", "null", ")", "?", "messageProperties", ".", "getContentType", "(", ")", ":", "null", ";", "if", "(", "MessageProperties", ".", "CONTENT_TYPE_SERIALIZED_OBJECT", ".", "equals", "(", "contentType", ")", ")", "{", "return", "SerializationUtils", ".", "deserialize", "(", "body", ")", ".", "toString", "(", ")", ";", "}", "if", "(", "MessageProperties", ".", "CONTENT_TYPE_TEXT_PLAIN", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_JSON", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_JSON_ALT", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_XML", ".", "equals", "(", "contentType", ")", ")", "{", "return", "new", "String", "(", "body", ",", "ENCODING", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "}", "return", "body", ".", "toString", "(", ")", "+", "\"", "(byte[", "\"", "+", "body", ".", "length", "+", "\"", "])", "\"", ";", "}"], "idx": 61698, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "83fe9fdec2c86a57898d56c5e109debd9d5c07d", "function_name": "getBodyContentAsString", "body_hash": "20b95c2f180f69289cca1df45dd72dfb12313c45"}
{"code": "public AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {\n        Key key = getJWTKey();\n        Jwt jwt;\n        try {\n            jwt = Jwts.parser().setSigningKey(key).parse(token.getPrincipal());\n        } catch (JwtException e) {\n            throw new AuthenticationException(e);\n        }\n        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());\n        Object principal = extractPrincipalFromWebToken(jwt);\n        return new SimpleAuthenticationInfo(principal, credentials, getName());\n    }", "code_tokens": ["public", "AuthenticationInfo", "loadAuthenticationInfo", "(", "JSONWebToken", "token", ")", "{", "Key", "key", "=", "getJWTKey", "(", ")", ";", "Jwt", "jwt", ";", "try", "{", "jwt", "=", "Jwts", ".", "parser", "(", ")", ".", "setSigningKey", "(", "key", ")", ".", "parse", "(", "token", ".", "getPrincipal", "(", ")", ")", ";", "}", "catch", "(", "JwtException", "e", ")", "{", "throw", "new", "AuthenticationException", "(", "e", ")", ";", "}", "String", "credentials", "=", "legacyHashing", "?", "token", ".", "getCredentials", "(", ")", ":", "encryptPassword", "(", "token", ".", "getCredentials", "(", ")", ")", ";", "Object", "principal", "=", "extractPrincipalFromWebToken", "(", "jwt", ")", ";", "return", "new", "SimpleAuthenticationInfo", "(", "principal", ",", "credentials", ",", "getName", "(", ")", ")", ";", "}"], "idx": 43594, "cwe": "CWE-347", "target": 1, "status": "VULNERABLE", "commit": "8c754a0ad234555e813dcbf9e57d637f9f23d8fb", "function_name": "loadAuthenticationInfo", "body_hash": "f93e376aa1e738ae635cb232991bf5fc64beeee7"}
{"code": "public void recycle() {\n        bytesRead=0;\n\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTime = -1;\n    }", "code_tokens": ["public", "void", "recycle", "(", ")", "{", "bytesRead", "=", "0", ";", "contentLength", "=", "-", "1", ";", "contentTypeMB", "=", "null", ";", "charset", "=", "null", ";", "characterEncoding", "=", "null", ";", "expectation", "=", "false", ";", "headers", ".", "recycle", "(", ")", ";", "serverNameMB", ".", "recycle", "(", ")", ";", "serverPort", "=", "-", "1", ";", "localAddrMB", ".", "recycle", "(", ")", ";", "localNameMB", ".", "recycle", "(", ")", ";", "localPort", "=", "-", "1", ";", "peerAddrMB", ".", "recycle", "(", ")", ";", "remoteAddrMB", ".", "recycle", "(", ")", ";", "remoteHostMB", ".", "recycle", "(", ")", ";", "remotePort", "=", "-", "1", ";", "available", "=", "0", ";", "sendfile", "=", "true", ";", "serverCookies", ".", "recycle", "(", ")", ";", "parameters", ".", "recycle", "(", ")", ";", "pathParameters", ".", "clear", "(", ")", ";", "uriMB", ".", "recycle", "(", ")", ";", "decodedUriMB", ".", "recycle", "(", ")", ";", "queryMB", ".", "recycle", "(", ")", ";", "methodMB", ".", "recycle", "(", ")", ";", "protoMB", ".", "recycle", "(", ")", ";", "schemeMB", ".", "recycle", "(", ")", ";", "remoteUser", ".", "recycle", "(", ")", ";", "remoteUserNeedsAuthorization", "=", "false", ";", "authType", ".", "recycle", "(", ")", ";", "attributes", ".", "clear", "(", ")", ";", "listener", "=", "null", ";", "synchronized", "(", "nonBlockingStateLock", ")", "{", "fireListener", "=", "false", ";", "registeredForRead", "=", "false", ";", "}", "allDataReadEventSent", ".", "set", "(", "false", ")", ";", "startTime", "=", "-", "1", ";", "}"], "idx": 74434, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "411caf29ac1c16e6ac291b6e5543b2371dbd25e2", "function_name": "recycle", "body_hash": "f4a8e466539714f0b5ad66e76fd3b567d0b58203"}
{"code": "private String resolveToken(HttpServletRequest request) {\n        String bearerToken = request.getHeader(WebSecurityConfig.AUTHORIZATION_HEADER);\n        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(TOKEN_PREFIX)) {\n            return bearerToken.substring(7, bearerToken.length());\n        }\n        String jwt = request.getParameter(WebSecurityConfig.AUTHORIZATION_TOKEN);\n        if (StringUtils.hasText(jwt)) {\n            return jwt;\n        }\n        return null;\n    }", "code_tokens": ["private", "String", "resolveToken", "(", "HttpServletRequest", "request", ")", "{", "String", "bearerToken", "=", "request", ".", "getHeader", "(", "WebSecurityConfig", ".", "AUTHORIZATION_HEADER", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "bearerToken", ")", "&&", "bearerToken", ".", "startsWith", "(", "TOKEN_PREFIX", ")", ")", "{", "return", "bearerToken", ".", "substring", "(", "7", ",", "bearerToken", ".", "length", "(", ")", ")", ";", "}", "String", "jwt", "=", "request", ".", "getParameter", "(", "WebSecurityConfig", ".", "AUTHORIZATION_TOKEN", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "jwt", ")", ")", "{", "return", "jwt", ";", "}", "return", "null", ";", "}"], "idx": 98064, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "13f5810751485de07d8746f21fe1e271e24e3473", "function_name": "resolveToken", "body_hash": "2f4adac58a22356f3c5233a7c67d61fb1f36ad22"}
{"code": "public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                // we went too far into the future\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to roll over to the next field.\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }", "code_tokens": ["public", "Calendar", "ceil", "(", "Calendar", "cal", ")", "{", "Calendar", "twoYearsFuture", "=", "(", "Calendar", ")", "cal", ".", "clone", "(", ")", ";", "twoYearsFuture", ".", "add", "(", "Calendar", ".", "YEAR", ",", "2", ")", ";", "OUTER", ":", "while", "(", "true", ")", "{", "if", "(", "cal", ".", "compareTo", "(", "twoYearsFuture", ")", ">", "0", ")", "{", "throw", "new", "RareOrImpossibleDateException", "(", ")", ";", "}", "for", "(", "CalendarField", "f", ":", "CalendarField", ".", "ADJUST_ORDER", ")", "{", "int", "cur", "=", "f", ".", "valueOf", "(", "cal", ")", ";", "int", "next", "=", "f", ".", "ceil", "(", "this", ",", "cur", ")", ";", "if", "(", "cur", "==", "next", ")", "continue", ";", "for", "(", "CalendarField", "l", "=", "f", ".", "lowerField", ";", "l", "!=", "null", ";", "l", "=", "l", ".", "lowerField", ")", "l", ".", "clear", "(", "cal", ")", ";", "if", "(", "next", "<", "0", ")", "{", "f", ".", "rollUp", "(", "cal", ",", "1", ")", ";", "f", ".", "setTo", "(", "cal", ",", "f", ".", "first", "(", "this", ")", ")", ";", "continue", "OUTER", ";", "}", "else", "{", "f", ".", "setTo", "(", "cal", ",", "next", ")", ";", "if", "(", "f", ".", "redoAdjustmentIfModified", ")", "continue", "OUTER", ";", "}", "}", "return", "cal", ";", "}", "}"], "idx": 82172, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "73afa0ca786a87f05b5433e2e38f863826fcad17", "function_name": "ceil", "body_hash": "fc1c71d29a189d2ab038cb391e6104f8da05d306"}
{"code": "private Changes handleRequest(ContextRequest contextRequest, Session session, Profile profile, ContextResponse data,\n                                  ServletRequest request, ServletResponse response, Date timestamp) {\n        Changes changes = ServletCommon.handleEvents(contextRequest.getEvents(), session, profile, request, response, timestamp,\n                privacyService, eventService);\n        data.setProcessedEvents(changes.getProcessedItems());\n\n        profile = changes.getProfile();\n\n        if (contextRequest.isRequireSegments()) {\n            data.setProfileSegments(profile.getSegments());\n        }\n\n        if (contextRequest.getRequiredProfileProperties() != null) {\n            Map<String, Object> profileProperties = new HashMap<>(profile.getProperties());\n            if (!contextRequest.getRequiredProfileProperties().contains(\"*\")) {\n                profileProperties.keySet().retainAll(contextRequest.getRequiredProfileProperties());\n            }\n            data.setProfileProperties(profileProperties);\n        }\n\n        if (session != null) {\n            data.setSessionId(session.getItemId());\n            if (contextRequest.getRequiredSessionProperties() != null) {\n                Map<String, Object> sessionProperties = new HashMap<>(session.getProperties());\n                if (!contextRequest.getRequiredSessionProperties().contains(\"*\")) {\n                    sessionProperties.keySet().retainAll(contextRequest.getRequiredSessionProperties());\n                }\n                data.setSessionProperties(sessionProperties);\n            }\n        }\n\n        processOverrides(contextRequest, profile, session);\n\n        List<PersonalizationService.PersonalizedContent> filterNodes = contextRequest.getFilters();\n        if (filterNodes != null) {\n            data.setFilteringResults(new HashMap<>());\n            for (PersonalizationService.PersonalizedContent personalizedContent : sanitizePersonalizedContentObjects(filterNodes)) {\n                data.getFilteringResults().put(personalizedContent.getId(), personalizationService.filter(profile,\n                        session, personalizedContent));\n            }\n        }\n\n        List<PersonalizationService.PersonalizationRequest> personalizations = contextRequest.getPersonalizations();\n        if (personalizations != null) {\n            data.setPersonalizations(new HashMap<>());\n            for (PersonalizationService.PersonalizationRequest personalization : sanitizePersonalizations(personalizations)) {\n                data.getPersonalizations().put(personalization.getId(), personalizationService.personalizeList(profile,\n                        session, personalization));\n            }\n        }\n\n        if (!(profile instanceof Persona)) {\n            data.setTrackedConditions(rulesService.getTrackedConditions(contextRequest.getSource()));\n        } else {\n            data.setTrackedConditions(Collections.emptySet());\n        }\n\n        data.setAnonymousBrowsing(privacyService.isRequireAnonymousBrowsing(profile));\n        data.setConsents(profile.getConsents());\n\n        return changes;\n    }", "code_tokens": ["private", "Changes", "handleRequest", "(", "ContextRequest", "contextRequest", ",", "Session", "session", ",", "Profile", "profile", ",", "ContextResponse", "data", ",", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "Date", "timestamp", ")", "{", "Changes", "changes", "=", "ServletCommon", ".", "handleEvents", "(", "contextRequest", ".", "getEvents", "(", ")", ",", "session", ",", "profile", ",", "request", ",", "response", ",", "timestamp", ",", "privacyService", ",", "eventService", ")", ";", "data", ".", "setProcessedEvents", "(", "changes", ".", "getProcessedItems", "(", ")", ")", ";", "profile", "=", "changes", ".", "getProfile", "(", ")", ";", "if", "(", "contextRequest", ".", "isRequireSegments", "(", ")", ")", "{", "data", ".", "setProfileSegments", "(", "profile", ".", "getSegments", "(", ")", ")", ";", "}", "if", "(", "contextRequest", ".", "getRequiredProfileProperties", "(", ")", "!=", "null", ")", "{", "Map", "<", "String", ",", "Object", ">", "profileProperties", "=", "new", "HashMap", "<", ">", "(", "profile", ".", "getProperties", "(", ")", ")", ";", "if", "(", "!", "contextRequest", ".", "getRequiredProfileProperties", "(", ")", ".", "contains", "(", "\"", "*", "\"", ")", ")", "{", "profileProperties", ".", "keySet", "(", ")", ".", "retainAll", "(", "contextRequest", ".", "getRequiredProfileProperties", "(", ")", ")", ";", "}", "data", ".", "setProfileProperties", "(", "profileProperties", ")", ";", "}", "if", "(", "session", "!=", "null", ")", "{", "data", ".", "setSessionId", "(", "session", ".", "getItemId", "(", ")", ")", ";", "if", "(", "contextRequest", ".", "getRequiredSessionProperties", "(", ")", "!=", "null", ")", "{", "Map", "<", "String", ",", "Object", ">", "sessionProperties", "=", "new", "HashMap", "<", ">", "(", "session", ".", "getProperties", "(", ")", ")", ";", "if", "(", "!", "contextRequest", ".", "getRequiredSessionProperties", "(", ")", ".", "contains", "(", "\"", "*", "\"", ")", ")", "{", "sessionProperties", ".", "keySet", "(", ")", ".", "retainAll", "(", "contextRequest", ".", "getRequiredSessionProperties", "(", ")", ")", ";", "}", "data", ".", "setSessionProperties", "(", "sessionProperties", ")", ";", "}", "}", "processOverrides", "(", "contextRequest", ",", "profile", ",", "session", ")", ";", "List", "<", "PersonalizationService", ".", "PersonalizedContent", ">", "filterNodes", "=", "contextRequest", ".", "getFilters", "(", ")", ";", "if", "(", "filterNodes", "!=", "null", ")", "{", "data", ".", "setFilteringResults", "(", "new", "HashMap", "<", ">", "(", ")", ")", ";", "for", "(", "PersonalizationService", ".", "PersonalizedContent", "personalizedContent", ":", "sanitizePersonalizedContentObjects", "(", "filterNodes", ")", ")", "{", "data", ".", "getFilteringResults", "(", ")", ".", "put", "(", "personalizedContent", ".", "getId", "(", ")", ",", "personalizationService", ".", "filter", "(", "profile", ",", "session", ",", "personalizedContent", ")", ")", ";", "}", "}", "List", "<", "PersonalizationService", ".", "PersonalizationRequest", ">", "personalizations", "=", "contextRequest", ".", "getPersonalizations", "(", ")", ";", "if", "(", "personalizations", "!=", "null", ")", "{", "data", ".", "setPersonalizations", "(", "new", "HashMap", "<", ">", "(", ")", ")", ";", "for", "(", "PersonalizationService", ".", "PersonalizationRequest", "personalization", ":", "sanitizePersonalizations", "(", "personalizations", ")", ")", "{", "data", ".", "getPersonalizations", "(", ")", ".", "put", "(", "personalization", ".", "getId", "(", ")", ",", "personalizationService", ".", "personalizeList", "(", "profile", ",", "session", ",", "personalization", ")", ")", ";", "}", "}", "if", "(", "!", "(", "profile", "instanceof", "Persona", ")", ")", "{", "data", ".", "setTrackedConditions", "(", "rulesService", ".", "getTrackedConditions", "(", "contextRequest", ".", "getSource", "(", ")", ")", ")", ";", "}", "else", "{", "data", ".", "setTrackedConditions", "(", "Collections", ".", "emptySet", "(", ")", ")", ";", "}", "data", ".", "setAnonymousBrowsing", "(", "privacyService", ".", "isRequireAnonymousBrowsing", "(", "profile", ")", ")", ";", "data", ".", "setConsents", "(", "profile", ".", "getConsents", "(", ")", ")", ";", "return", "changes", ";", "}"], "idx": 73884, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "0b81ba35dd3c3c2e0a92ce06592b3df90571eced", "function_name": "handleRequest", "body_hash": "6d321911d0ff77669359c70286eb4a48282a44d6"}
{"code": "@Override\n\tprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tHttpServletRequest requestToUse = request;\n\n\t\tif (\"POST\".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n\t\t\tString paramValue = request.getParameter(this.methodParam);\n\t\t\tif (StringUtils.hasLength(paramValue)) {\n\t\t\t\tString method = paramValue.toUpperCase(Locale.ENGLISH);\n\t\t\t\tif (ALLOWED_METHODS.contains(method)) {\n\t\t\t\t\trequestToUse = new HttpMethodRequestWrapper(request, method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfilterChain.doFilter(requestToUse, response);\n\t}", "code_tokens": ["@", "Override", "protected", "void", "doFilterInternal", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "FilterChain", "filterChain", ")", "throws", "ServletException", ",", "IOException", "{", "HttpServletRequest", "requestToUse", "=", "request", ";", "if", "(", "\"", "POST", "\"", ".", "equals", "(", "request", ".", "getMethod", "(", ")", ")", "&&", "request", ".", "getAttribute", "(", "WebUtils", ".", "ERROR_EXCEPTION_ATTRIBUTE", ")", "==", "null", ")", "{", "String", "paramValue", "=", "request", ".", "getParameter", "(", "this", ".", "methodParam", ")", ";", "if", "(", "StringUtils", ".", "hasLength", "(", "paramValue", ")", ")", "{", "String", "method", "=", "paramValue", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ";", "if", "(", "ALLOWED_METHODS", ".", "contains", "(", "method", ")", ")", "{", "requestToUse", "=", "new", "HttpMethodRequestWrapper", "(", "request", ",", "method", ")", ";", "}", "}", "}", "filterChain", ".", "doFilter", "(", "requestToUse", ",", "response", ")", ";", "}"], "idx": 103427, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "f2694a8ed93f1f63f87ce45d0bb638478b426acd", "function_name": "doFilterInternal", "body_hash": "bd7cc6279d1e60a93281837c3753aa61e2aa7dd5"}
{"code": "public String getIconFileName() {\n\t\treturn \"plugin/jenkins-multijob-plugin/tool32.png\";\n\t}", "code_tokens": ["public", "String", "getIconFileName", "(", ")", "{", "return", "\"", "plugin/jenkins-multijob-plugin/tool32.png", "\"", ";", "}"], "idx": 85140, "cwe": "CWE-862", "target": 1, "status": "VULNERABLE", "commit": "2424cec7a099fe4392f052a754fadc28de9f8d86", "function_name": "getIconFileName", "body_hash": "a631db5646f9cbab5cd0892d4c31a578038fd3d2"}
{"code": "@Override\n    protected void initializeStreams() throws IOException {\n        NIOOutputStream outputStream = null;\n        try {\n            channel = socket.getChannel();\n            channel.configureBlocking(false);\n\n            if (sslContext == null) {\n                sslContext = SSLContext.getDefault();\n            }\n\n            String remoteHost = null;\n            int remotePort = -1;\n\n            try {\n                URI remoteAddress = new URI(this.getRemoteAddress());\n                remoteHost = remoteAddress.getHost();\n                remotePort = remoteAddress.getPort();\n            } catch (Exception e) {\n            }\n\n            // initialize engine, the initial sslSession we get will need to be\n            // updated once the ssl handshake process is completed.\n            if (remoteHost != null && remotePort != -1) {\n                sslEngine = sslContext.createSSLEngine(remoteHost, remotePort);\n            } else {\n                sslEngine = sslContext.createSSLEngine();\n            }\n\n            sslEngine.setUseClientMode(false);\n            if (enabledCipherSuites != null) {\n                sslEngine.setEnabledCipherSuites(enabledCipherSuites);\n            }\n\n            if (enabledProtocols != null) {\n                sslEngine.setEnabledProtocols(enabledProtocols);\n            }\n\n            if (wantClientAuth) {\n                sslEngine.setWantClientAuth(wantClientAuth);\n            }\n\n            if (needClientAuth) {\n                sslEngine.setNeedClientAuth(needClientAuth);\n            }\n\n            sslSession = sslEngine.getSession();\n\n            inputBuffer = ByteBuffer.allocate(sslSession.getPacketBufferSize());\n            inputBuffer.clear();\n\n            outputStream = new NIOOutputStream(channel);\n            outputStream.setEngine(sslEngine);\n            this.dataOut = new DataOutputStream(outputStream);\n            this.buffOut = outputStream;\n            sslEngine.beginHandshake();\n            handshakeStatus = sslEngine.getHandshakeStatus();\n            doHandshake();\n\n        } catch (Exception e) {\n            try {\n                if(outputStream != null) {\n                    outputStream.close();\n                }\n                super.closeStreams();\n            } catch (Exception ex) {}\n            throw new IOException(e);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "initializeStreams", "(", ")", "throws", "IOException", "{", "NIOOutputStream", "outputStream", "=", "null", ";", "try", "{", "channel", "=", "socket", ".", "getChannel", "(", ")", ";", "channel", ".", "configureBlocking", "(", "false", ")", ";", "if", "(", "sslContext", "==", "null", ")", "{", "sslContext", "=", "SSLContext", ".", "getDefault", "(", ")", ";", "}", "String", "remoteHost", "=", "null", ";", "int", "remotePort", "=", "-", "1", ";", "try", "{", "URI", "remoteAddress", "=", "new", "URI", "(", "this", ".", "getRemoteAddress", "(", ")", ")", ";", "remoteHost", "=", "remoteAddress", ".", "getHost", "(", ")", ";", "remotePort", "=", "remoteAddress", ".", "getPort", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "}", "if", "(", "remoteHost", "!=", "null", "&&", "remotePort", "!=", "-", "1", ")", "{", "sslEngine", "=", "sslContext", ".", "createSSLEngine", "(", "remoteHost", ",", "remotePort", ")", ";", "}", "else", "{", "sslEngine", "=", "sslContext", ".", "createSSLEngine", "(", ")", ";", "}", "sslEngine", ".", "setUseClientMode", "(", "false", ")", ";", "if", "(", "enabledCipherSuites", "!=", "null", ")", "{", "sslEngine", ".", "setEnabledCipherSuites", "(", "enabledCipherSuites", ")", ";", "}", "if", "(", "enabledProtocols", "!=", "null", ")", "{", "sslEngine", ".", "setEnabledProtocols", "(", "enabledProtocols", ")", ";", "}", "if", "(", "wantClientAuth", ")", "{", "sslEngine", ".", "setWantClientAuth", "(", "wantClientAuth", ")", ";", "}", "if", "(", "needClientAuth", ")", "{", "sslEngine", ".", "setNeedClientAuth", "(", "needClientAuth", ")", ";", "}", "sslSession", "=", "sslEngine", ".", "getSession", "(", ")", ";", "inputBuffer", "=", "ByteBuffer", ".", "allocate", "(", "sslSession", ".", "getPacketBufferSize", "(", ")", ")", ";", "inputBuffer", ".", "clear", "(", ")", ";", "outputStream", "=", "new", "NIOOutputStream", "(", "channel", ")", ";", "outputStream", ".", "setEngine", "(", "sslEngine", ")", ";", "this", ".", "dataOut", "=", "new", "DataOutputStream", "(", "outputStream", ")", ";", "this", ".", "buffOut", "=", "outputStream", ";", "sslEngine", ".", "beginHandshake", "(", ")", ";", "handshakeStatus", "=", "sslEngine", ".", "getHandshakeStatus", "(", ")", ";", "doHandshake", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "try", "{", "if", "(", "outputStream", "!=", "null", ")", "{", "outputStream", ".", "close", "(", ")", ";", "}", "super", ".", "closeStreams", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "}", "throw", "new", "IOException", "(", "e", ")", ";", "}", "}"], "idx": 39782, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "bde7097fb8173cf871827df7811b3865679b963d", "function_name": "initializeStreams", "body_hash": "b055a846395b384a521262302cc8c6aaabcd8cb8"}
{"code": "public void resetAuthenticationFailureCounter(String username)\n    {\n        if (this.authorizationManager.hasAccess(Right.PROGRAM)) {\n            this.authenticationFailureManager.resetAuthenticationFailureCounter(username);\n        }\n    }", "code_tokens": ["public", "void", "resetAuthenticationFailureCounter", "(", "String", "username", ")", "{", "if", "(", "this", ".", "authorizationManager", ".", "hasAccess", "(", "Right", ".", "PROGRAM", ")", ")", "{", "this", ".", "authenticationFailureManager", ".", "resetAuthenticationFailureCounter", "(", "username", ")", ";", "}", "}"], "idx": 72826, "cwe": "CWE-732", "target": 0, "status": "FIXED", "commit": "0ad11db", "function_name": "resetAuthenticationFailureCounter", "body_hash": "3f74cafee328f06e86835795cdf6215c38358a4a"}
{"code": "public SendfileState processSendfile(SelectionKey sk, NioSocketWrapper socketWrapper,\n                boolean calledByProcessor) {\n            NioChannel sc = null;\n            try {\n                unreg(sk, socketWrapper, sk.readyOps());\n                SendfileData sd = socketWrapper.getSendfileData();\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing send file for: \" + sd.fileName);\n                }\n\n                if (sd.fchannel == null) {\n                    // Setup the file channel\n                    File f = new File(sd.fileName);\n                    if (!f.exists()) {\n                        return SendfileState.ERROR;\n                    }\n                    @SuppressWarnings(\"resource\") // Closed when channel is closed\n                    FileInputStream fis = new FileInputStream(f);\n                    sd.fchannel = fis.getChannel();\n                }\n\n                // Configure output channel\n                sc = socketWrapper.getSocket();\n                // TLS/SSL channel is slightly different\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n\n                // We still have data in the buffer\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        socketWrapper.updateLastWrite();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if (written > 0) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        socketWrapper.updateLastWrite();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for: \"+sd.fileName);\n                    }\n                    socketWrapper.setSendfileData(null);\n                    try {\n                        sd.fchannel.close();\n                    } catch (Exception ignore) {\n                    }\n                    // For calls from outside the Poller, the caller is\n                    // responsible for registering the socket for the\n                    // appropriate event(s) if sendfile completes.\n                    if (!calledByProcessor) {\n                        if (sd.keepAlive) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            reg(sk,socketWrapper,SelectionKey.OP_READ);\n                        } else {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Send file connection is being closed\");\n                            }\n                            close(sc, sk);\n                        }\n                    }\n                    return SendfileState.DONE;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                    }\n                    if (calledByProcessor) {\n                        add(socketWrapper.getSocket(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,socketWrapper,SelectionKey.OP_WRITE);\n                    }\n                    return SendfileState.PENDING;\n                }\n            } catch (IOException x) {\n                if (log.isDebugEnabled()) log.debug(\"Unable to complete sendfile request:\", x);\n                if (!calledByProcessor && sc != null) {\n                    close(sc, sk);\n                }\n                return SendfileState.ERROR;\n            } catch (Throwable t) {\n                log.error(\"\", t);\n                if (!calledByProcessor && sc != null) {\n                    close(sc, sk);\n                }\n                return SendfileState.ERROR;\n            }\n        }", "code_tokens": ["public", "SendfileState", "processSendfile", "(", "SelectionKey", "sk", ",", "NioSocketWrapper", "socketWrapper", ",", "boolean", "calledByProcessor", ")", "{", "NioChannel", "sc", "=", "null", ";", "try", "{", "unreg", "(", "sk", ",", "socketWrapper", ",", "sk", ".", "readyOps", "(", ")", ")", ";", "SendfileData", "sd", "=", "socketWrapper", ".", "getSendfileData", "(", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Processing send file for: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "sd", ".", "fchannel", "==", "null", ")", "{", "File", "f", "=", "new", "File", "(", "sd", ".", "fileName", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "return", "SendfileState", ".", "ERROR", ";", "}", "@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "FileInputStream", "fis", "=", "new", "FileInputStream", "(", "f", ")", ";", "sd", ".", "fchannel", "=", "fis", ".", "getChannel", "(", ")", ";", "}", "sc", "=", "socketWrapper", ".", "getSocket", "(", ")", ";", "WritableByteChannel", "wc", "=", "(", "(", "sc", "instanceof", "SecureNioChannel", ")", "?", "sc", ":", "sc", ".", "getIOChannel", "(", ")", ")", ";", "if", "(", "sc", ".", "getOutboundRemaining", "(", ")", ">", "0", ")", "{", "if", "(", "sc", ".", "flushOutbound", "(", ")", ")", "{", "socketWrapper", ".", "updateLastWrite", "(", ")", ";", "}", "}", "else", "{", "long", "written", "=", "sd", ".", "fchannel", ".", "transferTo", "(", "sd", ".", "pos", ",", "sd", ".", "length", ",", "wc", ")", ";", "if", "(", "written", ">", "0", ")", "{", "sd", ".", "pos", "+=", "written", ";", "sd", ".", "length", "-=", "written", ";", "socketWrapper", ".", "updateLastWrite", "(", ")", ";", "}", "else", "{", "if", "(", "sd", ".", "fchannel", ".", "size", "(", ")", "<=", "sd", ".", "pos", ")", "{", "throw", "new", "IOException", "(", "\"", "Sendfile configured to ", "\"", "+", "\"", "send more data than was available", "\"", ")", ";", "}", "}", "}", "if", "(", "sd", ".", "length", "<=", "0", "&&", "sc", ".", "getOutboundRemaining", "(", ")", "<=", "0", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file complete for: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "socketWrapper", ".", "setSendfileData", "(", "null", ")", ";", "try", "{", "sd", ".", "fchannel", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "}", "if", "(", "!", "calledByProcessor", ")", "{", "if", "(", "sd", ".", "keepAlive", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection is keep alive, registering back for OP_READ", "\"", ")", ";", "}", "reg", "(", "sk", ",", "socketWrapper", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file connection is being closed", "\"", ")", ";", "}", "close", "(", "sc", ",", "sk", ")", ";", "}", "}", "return", "SendfileState", ".", "DONE", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "OP_WRITE for sendfile: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "calledByProcessor", ")", "{", "add", "(", "socketWrapper", ".", "getSocket", "(", ")", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "socketWrapper", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "return", "SendfileState", ".", "PENDING", ";", "}", "}", "catch", "(", "IOException", "x", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Unable to complete sendfile request:", "\"", ",", "x", ")", ";", "if", "(", "!", "calledByProcessor", "&&", "sc", "!=", "null", ")", "{", "close", "(", "sc", ",", "sk", ")", ";", "}", "return", "SendfileState", ".", "ERROR", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"", "\"", ",", "t", ")", ";", "if", "(", "!", "calledByProcessor", "&&", "sc", "!=", "null", ")", "{", "close", "(", "sc", ",", "sk", ")", ";", "}", "return", "SendfileState", ".", "ERROR", ";", "}", "}"], "idx": 50791, "cwe": "CWE-388", "target": 0, "status": "FIXED", "commit": "cbc9b18a845d3c8c053ac293dffda6c6c19dd92b", "function_name": "processSendfile", "body_hash": "7e8465e34967fb4893b004c3dd39658a56bae68b"}
{"code": "private Document parse(String configFile) {\n    Document doc = null;\n    try {\n      SAXParserFactory factory = SAXParserFactory.newInstance();\n      factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n      factory.setValidating(false);\n\n      // Create the builder and parse the file\n      SAXParser parser = factory.newSAXParser();\n      parser.parse(configFile, this);\n\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Resource::\" + getResourceSpecifierPath());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Instance Count::\" + getInstanceCount());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Service Name::\" + getServiceName());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Filter String::\" + getFilterString());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Naming Service Host::\" + getNamingServiceHost());\n      UIMAFramework.getLogger().log(Level.CONFIG,\n              \"Server Socket Timeout::\" + getServerSocketTimeout());\n\n    } catch (Exception ex) {\n      ex.printStackTrace();\n    }\n    return doc;\n  }", "code_tokens": ["private", "Document", "parse", "(", "String", "configFile", ")", "{", "Document", "doc", "=", "null", ";", "try", "{", "SAXParserFactory", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "false", ")", ";", "factory", ".", "setValidating", "(", "false", ")", ";", "SAXParser", "parser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "parser", ".", "parse", "(", "configFile", ",", "this", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Resource::", "\"", "+", "getResourceSpecifierPath", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Instance Count::", "\"", "+", "getInstanceCount", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Service Name::", "\"", "+", "getServiceName", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Filter String::", "\"", "+", "getFilterString", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Naming Service Host::", "\"", "+", "getNamingServiceHost", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Server Socket Timeout::", "\"", "+", "getServerSocketTimeout", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "}", "return", "doc", ";", "}"], "idx": 70226, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "39909bf21fd694f4fb792d1de8adc72562ead25e", "function_name": "parse", "body_hash": "1090ff57e13e4a0680ab0efb243d44d0b796ce87"}
{"code": "private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        // form field validation\n        // this pattern needs to be generalized and moved to stapler\n        SignupInfo si = new SignupInfo(req);\n\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else {\n            User user = User.get(si.username, false);\n            if (null != user)\n                // Allow sign up. SCM people has no such property.\n                if (user.getProperty(Details.class) != null)\n                    si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n        }\n\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(si.email==null || !si.email.contains(\"@\"))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if (! User.isIdOrFullnameAllowed(si.username)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalUsername(si.username);\n        }\n\n        if (! User.isIdOrFullnameAllowed(si.fullname)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalFullname(si.fullname);\n        }\n\n        if(si.errorMessage!=null) {\n            // failed. ask the user to try again.\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        // register the user\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        try {\n            // legacy hack. mail support has moved out to a separate plugin\n            Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n            Constructor<?> c = up.getDeclaredConstructor(String.class);\n            user.addProperty((UserProperty)c.newInstance(si.email));\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Failed to set the e-mail address\",e);\n        }\n        user.save();\n        return user;\n    }", "code_tokens": ["private", "User", "createAccount", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ",", "boolean", "selfRegistration", ",", "String", "formView", ")", "throws", "ServletException", ",", "IOException", "{", "SignupInfo", "si", "=", "new", "SignupInfo", "(", "req", ")", ";", "if", "(", "selfRegistration", "&&", "!", "validateCaptcha", "(", "si", ".", "captcha", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage", "(", ")", ";", "if", "(", "si", ".", "password1", "!=", "null", "&&", "!", "si", ".", "password1", ".", "equals", "(", "si", ".", "password2", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch", "(", ")", ";", "if", "(", "!", "(", "si", ".", "password1", "!=", "null", "&&", "si", ".", "password1", ".", "length", "(", ")", "!=", "0", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired", "(", ")", ";", "if", "(", "si", ".", "username", "==", "null", "||", "si", ".", "username", ".", "length", "(", ")", "==", "0", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired", "(", ")", ";", "else", "{", "User", "user", "=", "User", ".", "get", "(", "si", ".", "username", ",", "false", ")", ";", "if", "(", "null", "!=", "user", ")", "if", "(", "user", ".", "getProperty", "(", "Details", ".", "class", ")", "!=", "null", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken", "(", ")", ";", "}", "if", "(", "si", ".", "fullname", "==", "null", "||", "si", ".", "fullname", ".", "length", "(", ")", "==", "0", ")", "si", ".", "fullname", "=", "si", ".", "username", ";", "if", "(", "si", ".", "email", "==", "null", "||", "!", "si", ".", "email", ".", "contains", "(", "\"", "@", "\"", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress", "(", ")", ";", "if", "(", "!", "User", ".", "isIdOrFullnameAllowed", "(", "si", ".", "username", ")", ")", "{", "si", ".", "errorMessage", "=", "hudson", ".", "model", ".", "Messages", ".", "User_IllegalUsername", "(", "si", ".", "username", ")", ";", "}", "if", "(", "!", "User", ".", "isIdOrFullnameAllowed", "(", "si", ".", "fullname", ")", ")", "{", "si", ".", "errorMessage", "=", "hudson", ".", "model", ".", "Messages", ".", "User_IllegalFullname", "(", "si", ".", "fullname", ")", ";", "}", "if", "(", "si", ".", "errorMessage", "!=", "null", ")", "{", "req", ".", "setAttribute", "(", "\"", "data", "\"", ",", "si", ")", ";", "req", ".", "getView", "(", "this", ",", "formView", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "return", "null", ";", "}", "User", "user", "=", "createAccount", "(", "si", ".", "username", ",", "si", ".", "password1", ")", ";", "user", ".", "setFullName", "(", "si", ".", "fullname", ")", ";", "try", "{", "Class", "<", "?", ">", "up", "=", "Jenkins", ".", "getInstance", "(", ")", ".", "pluginManager", ".", "uberClassLoader", ".", "loadClass", "(", "\"", "hudson.tasks.Mailer$UserProperty", "\"", ")", ";", "Constructor", "<", "?", ">", "c", "=", "up", ".", "getDeclaredConstructor", "(", "String", ".", "class", ")", ";", "user", ".", "addProperty", "(", "(", "UserProperty", ")", "c", ".", "newInstance", "(", "si", ".", "email", ")", ")", ";", "}", "catch", "(", "RuntimeException", "e", ")", "{", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to set the e-mail address", "\"", ",", "e", ")", ";", "}", "user", ".", "save", "(", ")", ";", "return", "user", ";", "}"], "idx": 30074, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "01a087d127d7a871eac02b03143464e2f4c6d48c", "function_name": "createAccount", "body_hash": "6357f0f5c1a37acf0c5617bd0fcd2ea877bc3187"}
{"code": "public void list(HttpServletRequest request,\n                     HttpServletResponse response,\n                     String message) throws IOException {\n\n        PrintWriter writer = response.getWriter();\n\n        // HTML Header Section\n        writer.print(Constants.HTML_HEADER_SECTION);\n\n        // Body Header Section\n        Object[] args = new Object[2];\n        args[0] = request.getContextPath();\n        args[1] = sm.getString(\"htmlHostManagerServlet.title\");\n        writer.print(MessageFormat.format\n                     (Constants.BODY_HEADER_SECTION, args));\n\n        // Message Section\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.messageLabel\");\n        if (message == null || message.length() == 0) {\n            args[1] = \"OK\";\n        } else {\n            args[1] = RequestUtil.filter(message);\n        }\n        writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args));\n\n        // Manager Section\n        args = new Object[9];\n        args[0] = sm.getString(\"htmlHostManagerServlet.manager\");\n        args[1] = response.encodeURL(request.getContextPath() + \"/html/list\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.list\");\n        args[3] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpHtmlManagerFile\"));\n        args[4] = sm.getString(\"htmlHostManagerServlet.helpHtmlManager\");\n        args[5] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpManagerFile\"));\n        args[6] = sm.getString(\"htmlHostManagerServlet.helpManager\");\n        args[7] = response.encodeURL(\"/manager/status\");\n        args[8] = sm.getString(\"statusServlet.title\");\n        writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args));\n\n         // Hosts Header Section\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.hostName\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.hostAliases\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.hostTasks\");\n        writer.print(MessageFormat.format(HOSTS_HEADER_SECTION, args));\n\n        // Hosts Row Section\n        // Create sorted map of host names.\n        Container[] children = engine.findChildren();\n        String hostNames[] = new String[children.length];\n        for (int i = 0; i < children.length; i++)\n            hostNames[i] = children[i].getName();\n\n        TreeMap<String,String> sortedHostNamesMap =\n            new TreeMap<String,String>();\n\n        for (int i = 0; i < hostNames.length; i++) {\n            String displayPath = hostNames[i];\n            sortedHostNamesMap.put(displayPath, hostNames[i]);\n        }\n\n        String hostsStart = sm.getString(\"htmlHostManagerServlet.hostsStart\");\n        String hostsStop = sm.getString(\"htmlHostManagerServlet.hostsStop\");\n        String hostsRemove = sm.getString(\"htmlHostManagerServlet.hostsRemove\");\n\n        Iterator<Map.Entry<String,String>> iterator =\n            sortedHostNamesMap.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String,String> entry = iterator.next();\n            String hostName = (String) entry.getKey();\n            Host host = (Host) engine.findChild(hostName);\n\n            if (host != null ) {\n                args = new Object[2];\n                args[0] = RequestUtil.filter(hostName);\n                String[] aliases = host.findAliases();\n                StringBuffer buf = new StringBuffer();\n                if (aliases.length > 0) {\n                    buf.append(aliases[0]);\n                    for (int j = 1; j < aliases.length; j++) {\n                        buf.append(\", \").append(aliases[j]);\n                    }\n                }\n\n                if (buf.length() == 0) {\n                    buf.append(\"&nbsp;\");\n                    args[1] = buf.toString();\n                } else {\n                    args[1] = RequestUtil.filter(buf.toString());\n                }\n\n                writer.print\n                    (MessageFormat.format(HOSTS_ROW_DETAILS_SECTION, args));\n\n                args = new Object[7];\n                args[0] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/start?name=\" +\n                     URLEncoder.encode(hostName, \"UTF-8\"));\n                args[1] = hostsStart;\n                args[2] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/stop?name=\" +\n                     URLEncoder.encode(hostName, \"UTF-8\"));\n                args[3] = hostsStop;\n                args[4] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/remove?name=\" +\n                     URLEncoder.encode(hostName, \"UTF-8\"));\n                args[5] = hostsRemove;\n                args[6] = RequestUtil.filter(hostName);\n                if (host == this.host) {\n                    writer.print(MessageFormat.format(\n                        MANAGER_HOST_ROW_BUTTON_SECTION, args));\n                } else {\n                    writer.print(MessageFormat.format(\n                        HOSTS_ROW_BUTTON_SECTION, args));\n                }\n\n            }\n        }\n\n        // Add Section\n        args = new Object[6];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.addHost\");\n        args[2] = response.encodeURL(request.getContextPath() + \"/html/add\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.addName\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.addAliases\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.addAppBase\");\n        writer.print(MessageFormat.format(ADD_SECTION_START, args));\n \n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addAutoDeploy\");\n        args[1] = \"autoDeploy\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployOnStartup\");\n        args[1] = \"deployOnStartup\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployXML\");\n        args[1] = \"deployXML\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addUnpackWARs\");\n        args[1] = \"unpackWARs\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlNamespaceAware\");\n        args[1] = \"xmlNamespaceAware\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlValidation\");\n        args[1] = \"xmlValidation\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n\n        args[0] = sm.getString(\"htmlHostManagerServlet.addManager\");\n        args[1] = \"manager\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        \n        args = new Object[1];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addButton\");\n        writer.print(MessageFormat.format(ADD_SECTION_END, args));\n\n        // Server Header Section\n        args = new Object[7];\n        args[0] = sm.getString(\"htmlHostManagerServlet.serverTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.serverVersion\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.serverJVMVersion\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.serverJVMVendor\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.serverOSName\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.serverOSVersion\");\n        args[6] = sm.getString(\"htmlHostManagerServlet.serverOSArch\");\n        writer.print(MessageFormat.format\n                     (Constants.SERVER_HEADER_SECTION, args));\n\n        // Server Row Section\n        args = new Object[6];\n        args[0] = ServerInfo.getServerInfo();\n        args[1] = System.getProperty(\"java.runtime.version\");\n        args[2] = System.getProperty(\"java.vm.vendor\");\n        args[3] = System.getProperty(\"os.name\");\n        args[4] = System.getProperty(\"os.version\");\n        args[5] = System.getProperty(\"os.arch\");\n        writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args));\n\n        // HTML Tail Section\n        writer.print(Constants.HTML_TAIL_SECTION);\n\n        // Finish up the response\n        writer.flush();\n        writer.close();\n    }", "code_tokens": ["public", "void", "list", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "String", "message", ")", "throws", "IOException", "{", "PrintWriter", "writer", "=", "response", ".", "getWriter", "(", ")", ";", "writer", ".", "print", "(", "Constants", ".", "HTML_HEADER_SECTION", ")", ";", "Object", "[", "]", "args", "=", "new", "Object", "[", "2", "]", ";", "args", "[", "0", "]", "=", "request", ".", "getContextPath", "(", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.title", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "BODY_HEADER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.messageLabel", "\"", ")", ";", "if", "(", "message", "==", "null", "||", "message", ".", "length", "(", ")", "==", "0", ")", "{", "args", "[", "1", "]", "=", "\"", "OK", "\"", ";", "}", "else", "{", "args", "[", "1", "]", "=", "RequestUtil", ".", "filter", "(", "message", ")", ";", "}", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "MESSAGE_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "9", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.manager", "\"", ")", ";", "args", "[", "1", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/list", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.list", "\"", ")", ";", "args", "[", "3", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/", "\"", "+", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpHtmlManagerFile", "\"", ")", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpHtmlManager", "\"", ")", ";", "args", "[", "5", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/", "\"", "+", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpManagerFile", "\"", ")", ")", ";", "args", "[", "6", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpManager", "\"", ")", ";", "args", "[", "7", "]", "=", "response", ".", "encodeURL", "(", "\"", "/manager/status", "\"", ")", ";", "args", "[", "8", "]", "=", "sm", ".", "getString", "(", "\"", "statusServlet.title", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "MANAGER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostName", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostAliases", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostTasks", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_HEADER_SECTION", ",", "args", ")", ")", ";", "Container", "[", "]", "children", "=", "engine", ".", "findChildren", "(", ")", ";", "String", "hostNames", "[", "]", "=", "new", "String", "[", "children", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "children", ".", "length", ";", "i", "++", ")", "hostNames", "[", "i", "]", "=", "children", "[", "i", "]", ".", "getName", "(", ")", ";", "TreeMap", "<", "String", ",", "String", ">", "sortedHostNamesMap", "=", "new", "TreeMap", "<", "String", ",", "String", ">", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hostNames", ".", "length", ";", "i", "++", ")", "{", "String", "displayPath", "=", "hostNames", "[", "i", "]", ";", "sortedHostNamesMap", ".", "put", "(", "displayPath", ",", "hostNames", "[", "i", "]", ")", ";", "}", "String", "hostsStart", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsStart", "\"", ")", ";", "String", "hostsStop", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsStop", "\"", ")", ";", "String", "hostsRemove", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsRemove", "\"", ")", ";", "Iterator", "<", "Map", ".", "Entry", "<", "String", ",", "String", ">", ">", "iterator", "=", "sortedHostNamesMap", ".", "entrySet", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iterator", ".", "hasNext", "(", ")", ")", "{", "Map", ".", "Entry", "<", "String", ",", "String", ">", "entry", "=", "iterator", ".", "next", "(", ")", ";", "String", "hostName", "=", "(", "String", ")", "entry", ".", "getKey", "(", ")", ";", "Host", "host", "=", "(", "Host", ")", "engine", ".", "findChild", "(", "hostName", ")", ";", "if", "(", "host", "!=", "null", ")", "{", "args", "=", "new", "Object", "[", "2", "]", ";", "args", "[", "0", "]", "=", "RequestUtil", ".", "filter", "(", "hostName", ")", ";", "String", "[", "]", "aliases", "=", "host", ".", "findAliases", "(", ")", ";", "StringBuffer", "buf", "=", "new", "StringBuffer", "(", ")", ";", "if", "(", "aliases", ".", "length", ">", "0", ")", "{", "buf", ".", "append", "(", "aliases", "[", "0", "]", ")", ";", "for", "(", "int", "j", "=", "1", ";", "j", "<", "aliases", ".", "length", ";", "j", "++", ")", "{", "buf", ".", "append", "(", "\"", ", ", "\"", ")", ".", "append", "(", "aliases", "[", "j", "]", ")", ";", "}", "}", "if", "(", "buf", ".", "length", "(", ")", "==", "0", ")", "{", "buf", ".", "append", "(", "\"", "&nbsp;", "\"", ")", ";", "args", "[", "1", "]", "=", "buf", ".", "toString", "(", ")", ";", "}", "else", "{", "args", "[", "1", "]", "=", "RequestUtil", ".", "filter", "(", "buf", ".", "toString", "(", ")", ")", ";", "}", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_ROW_DETAILS_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "7", "]", ";", "args", "[", "0", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/start?name=", "\"", "+", "URLEncoder", ".", "encode", "(", "hostName", ",", "\"", "UTF-8", "\"", ")", ")", ";", "args", "[", "1", "]", "=", "hostsStart", ";", "args", "[", "2", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/stop?name=", "\"", "+", "URLEncoder", ".", "encode", "(", "hostName", ",", "\"", "UTF-8", "\"", ")", ")", ";", "args", "[", "3", "]", "=", "hostsStop", ";", "args", "[", "4", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/remove?name=", "\"", "+", "URLEncoder", ".", "encode", "(", "hostName", ",", "\"", "UTF-8", "\"", ")", ")", ";", "args", "[", "5", "]", "=", "hostsRemove", ";", "args", "[", "6", "]", "=", "RequestUtil", ".", "filter", "(", "hostName", ")", ";", "if", "(", "host", "==", "this", ".", "host", ")", "{", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "MANAGER_HOST_ROW_BUTTON_SECTION", ",", "args", ")", ")", ";", "}", "else", "{", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_ROW_BUTTON_SECTION", ",", "args", ")", ")", ";", "}", "}", "}", "args", "=", "new", "Object", "[", "6", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addTitle", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addHost", "\"", ")", ";", "args", "[", "2", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/add", "\"", ")", ";", "args", "[", "3", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addName", "\"", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAliases", "\"", ")", ";", "args", "[", "5", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAppBase", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_START", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAutoDeploy", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "autoDeploy", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addDeployOnStartup", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "deployOnStartup", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addDeployXML", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "deployXML", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addUnpackWARs", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "unpackWARs", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addXmlNamespaceAware", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "xmlNamespaceAware", "\"", ";", "args", "[", "2", "]", "=", "\"", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addXmlValidation", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "xmlValidation", "\"", ";", "args", "[", "2", "]", "=", "\"", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addManager", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "manager", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "1", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addButton", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_END", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "7", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverTitle", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverVersion", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverJVMVersion", "\"", ")", ";", "args", "[", "3", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverJVMVendor", "\"", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSName", "\"", ")", ";", "args", "[", "5", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSVersion", "\"", ")", ";", "args", "[", "6", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSArch", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "SERVER_HEADER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "6", "]", ";", "args", "[", "0", "]", "=", "ServerInfo", ".", "getServerInfo", "(", ")", ";", "args", "[", "1", "]", "=", "System", ".", "getProperty", "(", "\"", "java.runtime.version", "\"", ")", ";", "args", "[", "2", "]", "=", "System", ".", "getProperty", "(", "\"", "java.vm.vendor", "\"", ")", ";", "args", "[", "3", "]", "=", "System", ".", "getProperty", "(", "\"", "os.name", "\"", ")", ";", "args", "[", "4", "]", "=", "System", ".", "getProperty", "(", "\"", "os.version", "\"", ")", ";", "args", "[", "5", "]", "=", "System", ".", "getProperty", "(", "\"", "os.arch", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "SERVER_ROW_SECTION", ",", "args", ")", ")", ";", "writer", ".", "print", "(", "Constants", ".", "HTML_TAIL_SECTION", ")", ";", "writer", ".", "flush", "(", ")", ";", "writer", ".", "close", "(", ")", ";", "}"], "idx": 79268, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "49c71fc59c1b8f8da77aea9eb53e61db168aebab", "function_name": "list", "body_hash": "b760bbba4153e730da2265eb523ebc3623e0f11b"}
{"code": "public static RootPersistentEntity createAclEntity(String entityType, String uuid) {\n        // Validate the uuid first, exception will be thrown if the uuid string is not a valid uuid\n        UUID uuidObj = UUID.fromString(uuid);\n        uuid = uuidObj.toString();\n\n        if (CUBE_INSTANCE.equals(entityType)) {\n            CubeInstance cubeInstance = new CubeInstance();\n            cubeInstance.setUuid(uuid);\n\n            return cubeInstance;\n        }\n\n        if (DATA_MODEL_DESC.equals(entityType)) {\n            DataModelDesc modelInstance = new DataModelDesc();\n            modelInstance.setUuid(uuid);\n\n            return modelInstance;\n        }\n\n        if (JOB_INSTANCE.equals(entityType)) {\n            JobInstance jobInstance = new JobInstance();\n            jobInstance.setUuid(uuid);\n\n            return jobInstance;\n        }\n\n        if (PROJECT_INSTANCE.equals(entityType)) {\n            ProjectInstance projectInstance = new ProjectInstance();\n            projectInstance.setUuid(uuid);\n\n            return projectInstance;\n        }\n\n        throw new RuntimeException(\"Unsupported entity type!\");\n    }", "code_tokens": ["public", "static", "RootPersistentEntity", "createAclEntity", "(", "String", "entityType", ",", "String", "uuid", ")", "{", "UUID", "uuidObj", "=", "UUID", ".", "fromString", "(", "uuid", ")", ";", "uuid", "=", "uuidObj", ".", "toString", "(", ")", ";", "if", "(", "CUBE_INSTANCE", ".", "equals", "(", "entityType", ")", ")", "{", "CubeInstance", "cubeInstance", "=", "new", "CubeInstance", "(", ")", ";", "cubeInstance", ".", "setUuid", "(", "uuid", ")", ";", "return", "cubeInstance", ";", "}", "if", "(", "DATA_MODEL_DESC", ".", "equals", "(", "entityType", ")", ")", "{", "DataModelDesc", "modelInstance", "=", "new", "DataModelDesc", "(", ")", ";", "modelInstance", ".", "setUuid", "(", "uuid", ")", ";", "return", "modelInstance", ";", "}", "if", "(", "JOB_INSTANCE", ".", "equals", "(", "entityType", ")", ")", "{", "JobInstance", "jobInstance", "=", "new", "JobInstance", "(", ")", ";", "jobInstance", ".", "setUuid", "(", "uuid", ")", ";", "return", "jobInstance", ";", "}", "if", "(", "PROJECT_INSTANCE", ".", "equals", "(", "entityType", ")", ")", "{", "ProjectInstance", "projectInstance", "=", "new", "ProjectInstance", "(", ")", ";", "projectInstance", ".", "setUuid", "(", "uuid", ")", ";", "return", "projectInstance", ";", "}", "throw", "new", "RuntimeException", "(", "\"", "Unsupported entity type!", "\"", ")", ";", "}"], "idx": 92492, "cwe": "CWE-89", "target": 0, "status": "FIXED", "commit": "5fbb6c9c3780d7384c8f1dc378b96bb9c43cfdbe", "function_name": "createAclEntity", "body_hash": "6513214e64f504584aa00d0d1aaf8c5a36599fa2"}
{"code": "public String scanPseudoAttribute(boolean scanningTextDecl, \n                                      XMLString value) \n        throws IOException, XNIException {\n\n        // REVISIT: This method is used for generic scanning of \n        // pseudo attributes, but since there are only three such\n        // attributes: version, encoding, and standalone there are\n        // for performant ways of scanning them. Every decl must\n        // have a version, and in TextDecls this version must\n        // be followed by an encoding declaration. Also the\n        // methods we invoke on the scanners allow non-ASCII\n        // characters to be parsed in the decls, but since\n        // we don't even know what the actual encoding of the\n        // document is until we scan the encoding declaration\n        // you cannot reliably read any characters outside\n        // of the ASCII range here. -- mrglavas\n        String name = fEntityScanner.scanName();\n        XMLEntityManager.print(fEntityManager.getCurrentEntity());\n        if (name == null) {\n            reportFatalError(\"PseudoAttrNameExpected\", null);\n        }\n        fEntityScanner.skipDeclSpaces();\n        if (!fEntityScanner.skipChar('=')) {\n            reportFatalError(scanningTextDecl ? \"EqRequiredInTextDecl\"\n                             : \"EqRequiredInXMLDecl\", new Object[]{name});\n        }\n        fEntityScanner.skipDeclSpaces();\n        int quote = fEntityScanner.peekChar();\n        if (quote != '\\'' && quote != '\"') {\n            reportFatalError(scanningTextDecl ? \"QuoteRequiredInTextDecl\"\n                             : \"QuoteRequiredInXMLDecl\" , new Object[]{name});\n        }\n        fEntityScanner.scanChar();\n        int c = fEntityScanner.scanLiteral(quote, value);\n        if (c != quote) {\n            fStringBuffer2.clear();\n            do {\n                fStringBuffer2.append(value);\n                if (c != -1) {\n                    if (c == '&' || c == '%' || c == '<' || c == ']') {\n                        fStringBuffer2.append((char)fEntityScanner.scanChar());\n                    }\n                    // REVISIT: Even if you could reliably read non-ASCII chars\n                    // why bother scanning for surrogates here? Only ASCII chars\n                    // match the productions in XMLDecls and TextDecls. -- mrglavas\n                    else if (XMLChar.isHighSurrogate(c)) {\n                        scanSurrogates(fStringBuffer2);\n                    }\n                    else if (isInvalidLiteral(c)) {\n                        String key = scanningTextDecl\n                            ? \"InvalidCharInTextDecl\" : \"InvalidCharInXMLDecl\";\n                        reportFatalError(key,\n                                       new Object[] {Integer.toString(c, 16)});\n                        fEntityScanner.scanChar();\n                    }\n                }\n                c = fEntityScanner.scanLiteral(quote, value);\n            } while (c != quote);\n            fStringBuffer2.append(value);\n            value.setValues(fStringBuffer2);\n        }\n        if (!fEntityScanner.skipChar(quote)) {\n            reportFatalError(scanningTextDecl ? \"CloseQuoteMissingInTextDecl\"\n                             : \"CloseQuoteMissingInXMLDecl\",\n                             new Object[]{name});\n        }\n\n        // return\n        return name;\n\n    }", "code_tokens": ["public", "String", "scanPseudoAttribute", "(", "boolean", "scanningTextDecl", ",", "XMLString", "value", ")", "throws", "IOException", ",", "XNIException", "{", "String", "name", "=", "fEntityScanner", ".", "scanName", "(", ")", ";", "XMLEntityManager", ".", "print", "(", "fEntityManager", ".", "getCurrentEntity", "(", ")", ")", ";", "if", "(", "name", "==", "null", ")", "{", "reportFatalError", "(", "\"", "PseudoAttrNameExpected", "\"", ",", "null", ")", ";", "}", "fEntityScanner", ".", "skipDeclSpaces", "(", ")", ";", "if", "(", "!", "fEntityScanner", ".", "skipChar", "(", "'='", ")", ")", "{", "reportFatalError", "(", "scanningTextDecl", "?", "\"", "EqRequiredInTextDecl", "\"", ":", "\"", "EqRequiredInXMLDecl", "\"", ",", "new", "Object", "[", "]", "{", "name", "}", ")", ";", "}", "fEntityScanner", ".", "skipDeclSpaces", "(", ")", ";", "int", "quote", "=", "fEntityScanner", ".", "peekChar", "(", ")", ";", "if", "(", "quote", "!=", "'\\''", "&&", "quote", "!=", "'\"'", ")", "{", "reportFatalError", "(", "scanningTextDecl", "?", "\"", "QuoteRequiredInTextDecl", "\"", ":", "\"", "QuoteRequiredInXMLDecl", "\"", ",", "new", "Object", "[", "]", "{", "name", "}", ")", ";", "}", "fEntityScanner", ".", "scanChar", "(", ")", ";", "int", "c", "=", "fEntityScanner", ".", "scanLiteral", "(", "quote", ",", "value", ")", ";", "if", "(", "c", "!=", "quote", ")", "{", "fStringBuffer2", ".", "clear", "(", ")", ";", "do", "{", "fStringBuffer2", ".", "append", "(", "value", ")", ";", "if", "(", "c", "!=", "-", "1", ")", "{", "if", "(", "c", "==", "'&'", "||", "c", "==", "'%'", "||", "c", "==", "'<'", "||", "c", "==", "']'", ")", "{", "fStringBuffer2", ".", "append", "(", "(", "char", ")", "fEntityScanner", ".", "scanChar", "(", ")", ")", ";", "}", "else", "if", "(", "XMLChar", ".", "isHighSurrogate", "(", "c", ")", ")", "{", "scanSurrogates", "(", "fStringBuffer2", ")", ";", "}", "else", "if", "(", "isInvalidLiteral", "(", "c", ")", ")", "{", "String", "key", "=", "scanningTextDecl", "?", "\"", "InvalidCharInTextDecl", "\"", ":", "\"", "InvalidCharInXMLDecl", "\"", ";", "reportFatalError", "(", "key", ",", "new", "Object", "[", "]", "{", "Integer", ".", "toString", "(", "c", ",", "16", ")", "}", ")", ";", "fEntityScanner", ".", "scanChar", "(", ")", ";", "}", "}", "c", "=", "fEntityScanner", ".", "scanLiteral", "(", "quote", ",", "value", ")", ";", "}", "while", "(", "c", "!=", "quote", ")", ";", "fStringBuffer2", ".", "append", "(", "value", ")", ";", "value", ".", "setValues", "(", "fStringBuffer2", ")", ";", "}", "if", "(", "!", "fEntityScanner", ".", "skipChar", "(", "quote", ")", ")", "{", "reportFatalError", "(", "scanningTextDecl", "?", "\"", "CloseQuoteMissingInTextDecl", "\"", ":", "\"", "CloseQuoteMissingInXMLDecl", "\"", ",", "new", "Object", "[", "]", "{", "name", "}", ")", ";", "}", "return", "name", ";", "}"], "idx": 103676, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "266e837852e0f0e3c8c1ad572b6fc4dbb4ded17", "function_name": "scanPseudoAttribute", "body_hash": "75dc8f6988507f86c98639d3b6c62564069764c3"}
{"code": "public synchronized TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        acl.checkPermission(Item.CREATE);\n\n        Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n        if (parent.getItem(name) != null) {\n            throw new IllegalArgumentException(parent.getDisplayName() + \" already contains an item '\" + name + \"'\");\n        }\n        // TODO what if we have no DISCOVER permission on the existing job?\n\n        // place it as config.xml\n        File configXml = Items.getConfigFile(getRootDirFor(name)).getFile();\n        final File dir = configXml.getParentFile();\n        dir.mkdirs();\n        try {\n            IOUtils.copy(xml,configXml);\n\n            // load it\n            TopLevelItem result = Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<TopLevelItem,IOException>() {\n                @Override public TopLevelItem call() throws IOException {\n                    return (TopLevelItem) Items.load(parent, dir);\n                }\n            });\n            add(result);\n\n            ItemListener.fireOnCreated(result);\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            return result;\n        } catch (IOException e) {\n            // if anything fails, delete the config file to avoid further confusion\n            Util.deleteRecursive(dir);\n            throw e;\n        }\n    }", "code_tokens": ["public", "synchronized", "TopLevelItem", "createProjectFromXML", "(", "String", "name", ",", "InputStream", "xml", ")", "throws", "IOException", "{", "acl", ".", "checkPermission", "(", "Item", ".", "CREATE", ")", ";", "Jenkins", ".", "getInstance", "(", ")", ".", "getProjectNamingStrategy", "(", ")", ".", "checkName", "(", "name", ")", ";", "if", "(", "parent", ".", "getItem", "(", "name", ")", "!=", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "parent", ".", "getDisplayName", "(", ")", "+", "\"", " already contains an item '", "\"", "+", "name", "+", "\"", "'", "\"", ")", ";", "}", "File", "configXml", "=", "Items", ".", "getConfigFile", "(", "getRootDirFor", "(", "name", ")", ")", ".", "getFile", "(", ")", ";", "final", "File", "dir", "=", "configXml", ".", "getParentFile", "(", ")", ";", "dir", ".", "mkdirs", "(", ")", ";", "try", "{", "IOUtils", ".", "copy", "(", "xml", ",", "configXml", ")", ";", "TopLevelItem", "result", "=", "Items", ".", "whileUpdatingByXml", "(", "new", "NotReallyRoleSensitiveCallable", "<", "TopLevelItem", ",", "IOException", ">", "(", ")", "{", "@", "Override", "public", "TopLevelItem", "call", "(", ")", "throws", "IOException", "{", "return", "(", "TopLevelItem", ")", "Items", ".", "load", "(", "parent", ",", "dir", ")", ";", "}", "}", ")", ";", "add", "(", "result", ")", ";", "ItemListener", ".", "fireOnCreated", "(", "result", ")", ";", "Jenkins", ".", "getInstance", "(", ")", ".", "rebuildDependencyGraphAsync", "(", ")", ";", "return", "result", ";", "}", "catch", "(", "IOException", "e", ")", "{", "Util", ".", "deleteRecursive", "(", "dir", ")", ";", "throw", "e", ";", "}", "}"], "idx": 110765, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "e78e9e8144f7304cf274cd4b756f458cf63a3556", "function_name": "createProjectFromXML", "body_hash": "2cf4ce6f9c664eba4e1e57b9c38a89214933f0aa"}
{"code": "@Override\n    public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException {\n        String function = uri.getQueryParameters().getFirst(callbackQueryParameter);\n        if (enabled && function != null && !function.trim().isEmpty() && !jsonpCompatibleMediaTypes.getPossible(context.getMediaType()).isEmpty()){\n\n            OutputStreamWriter writer = new OutputStreamWriter(context.getOutputStream());\n\n            if (wrapInTryCatch) writer.write(\"try{\");\n            writer.write(function + \"(\");\n            writer.flush();\n\n            // Disable the close method before calling context.proceed()\n            OutputStream old = context.getOutputStream();\n            DoNotCloseDelegateOutputStream wrappedOutputStream = new DoNotCloseDelegateOutputStream(old);\n            context.setOutputStream(wrappedOutputStream);\n\n            try {\n                context.proceed();\n                wrappedOutputStream.flush();\n                writer.write(\")\");\n                if (wrapInTryCatch) writer.write(\"}catch(e){}\");\n                writer.flush();\n            } finally {\n                context.setOutputStream(old);\n            }\n        } else {\n            context.proceed();\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "aroundWriteTo", "(", "WriterInterceptorContext", "context", ")", "throws", "IOException", ",", "WebApplicationException", "{", "String", "function", "=", "uri", ".", "getQueryParameters", "(", ")", ".", "getFirst", "(", "callbackQueryParameter", ")", ";", "if", "(", "enabled", "&&", "function", "!=", "null", "&&", "!", "function", ".", "trim", "(", ")", ".", "isEmpty", "(", ")", "&&", "!", "jsonpCompatibleMediaTypes", ".", "getPossible", "(", "context", ".", "getMediaType", "(", ")", ")", ".", "isEmpty", "(", ")", ")", "{", "OutputStreamWriter", "writer", "=", "new", "OutputStreamWriter", "(", "context", ".", "getOutputStream", "(", ")", ")", ";", "if", "(", "wrapInTryCatch", ")", "writer", ".", "write", "(", "\"", "try{", "\"", ")", ";", "writer", ".", "write", "(", "function", "+", "\"", "(", "\"", ")", ";", "writer", ".", "flush", "(", ")", ";", "OutputStream", "old", "=", "context", ".", "getOutputStream", "(", ")", ";", "DoNotCloseDelegateOutputStream", "wrappedOutputStream", "=", "new", "DoNotCloseDelegateOutputStream", "(", "old", ")", ";", "context", ".", "setOutputStream", "(", "wrappedOutputStream", ")", ";", "try", "{", "context", ".", "proceed", "(", ")", ";", "wrappedOutputStream", ".", "flush", "(", ")", ";", "writer", ".", "write", "(", "\"", ")", "\"", ")", ";", "if", "(", "wrapInTryCatch", ")", "writer", ".", "write", "(", "\"", "}catch(e){}", "\"", ")", ";", "writer", ".", "flush", "(", ")", ";", "}", "finally", "{", "context", ".", "setOutputStream", "(", "old", ")", ";", "}", "}", "else", "{", "context", ".", "proceed", "(", ")", ";", "}", "}"], "idx": 79861, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "7cc46c65b11de69b87ef8850dc68cca3de8cd7c6", "function_name": "aroundWriteTo", "body_hash": "a6affec5725226b65d60254d41865ae2bb6ff9fe"}
{"code": "public Object read(final InputSource in) throws SAXException,\n                                            IOException {\n        if ( this.docFragment == null ) {\n            DocumentBuilderFactory f;\n            try {\n                f =  DocumentBuilderFactory.newInstance();\n            } catch ( FactoryConfigurationError e ) {\n                // obscure JDK1.5 bug where FactoryFinder in the JRE returns a null ClassLoader, so fall back to hard coded xerces.\n                // https://stg.network.org/bugzilla/show_bug.cgi?id=47169\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4633368\n                try {\n                    f = (DocumentBuilderFactory) Class.forName( \"org.apache.xerces.jaxp.DocumentBuilderFactoryImpl\" ).newInstance();\n                } catch ( Exception e1 ) {\n                    throw new RuntimeException( \"Unable to create new DOM Document\",\n                                                e1 );\n                }\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            \n            try {\n                this.document = f.newDocumentBuilder().newDocument();\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            this.docFragment = this.document.createDocumentFragment();\n        }\n\n        SAXParser localParser = null;\n        if ( this.parser == null ) {\n            SAXParserFactory factory = null;\n            try {\n                factory = SAXParserFactory.newInstance();\n            } catch ( FactoryConfigurationError e) {\n                // obscure JDK1.5 bug where FactoryFinder in the JRE returns a null ClassLoader, so fall back to hard coded xerces.\n                // https://stg.network.org/bugzilla/show_bug.cgi?id=47169\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4633368                \n                try {\n                    factory = (SAXParserFactory) Class.forName( \"org.apache.xerces.jaxp.SAXParserFactoryImpl\" ).newInstance();\n                } catch ( Exception e1 ) {\n                    throw new RuntimeException( \"Unable to create new DOM Document\",\n                                                e1 );\n                }\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            \n            factory.setNamespaceAware( true );\n\n            final String isValidatingString = System.getProperty( \"drools.schema.validating\" );\n            if ( System.getProperty( \"drools.schema.validating\" ) != null ) {\n                this.isValidating = Boolean.getBoolean( \"drools.schema.validating\" );\n            }\n\n            if ( this.isValidating == true ) {\n                factory.setValidating( true );\n                try {\n                    localParser = factory.newSAXParser();\n                } catch ( final ParserConfigurationException e ) {\n                    throw new RuntimeException( e.getMessage() );\n                }\n\n                try {\n                    localParser.setProperty( ExtensibleXmlParser.JAXP_SCHEMA_LANGUAGE,\n                                             ExtensibleXmlParser.W3C_XML_SCHEMA );\n                } catch ( final SAXNotRecognizedException e ) {\n                    boolean hideWarnings = Boolean.getBoolean( \"drools.schema.hidewarnings\" );\n                    if ( !hideWarnings ) {\n                        logger.warn( \"Your SAX parser is not JAXP 1.2 compliant - turning off validation.\" );\n                    }\n                    localParser = null;\n                }\n            }\n\n            if ( localParser == null ) {\n                // not jaxp1.2 compliant so turn off validation\n                try {\n                    this.isValidating = false;\n                    factory.setValidating( this.isValidating );\n                    localParser = factory.newSAXParser();\n                } catch ( final ParserConfigurationException e ) {\n                    throw new RuntimeException( e.getMessage() );\n                }\n            }\n        } else {\n            localParser = this.parser;\n        }\n\n        if ( !localParser.isNamespaceAware() ) {\n            throw new RuntimeException( \"parser must be namespace-aware\" );\n        }\n\n        localParser.parse( in,\n                           this );\n\n        return this.data;\n    }", "code_tokens": ["public", "Object", "read", "(", "final", "InputSource", "in", ")", "throws", "SAXException", ",", "IOException", "{", "if", "(", "this", ".", "docFragment", "==", "null", ")", "{", "DocumentBuilderFactory", "f", ";", "try", "{", "f", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "FactoryConfigurationError", "e", ")", "{", "try", "{", "f", "=", "(", "DocumentBuilderFactory", ")", "Class", ".", "forName", "(", "\"", "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl", "\"", ")", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "Exception", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e1", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e", ")", ";", "}", "try", "{", "this", ".", "document", "=", "f", ".", "newDocumentBuilder", "(", ")", ".", "newDocument", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e", ")", ";", "}", "this", ".", "docFragment", "=", "this", ".", "document", ".", "createDocumentFragment", "(", ")", ";", "}", "SAXParser", "localParser", "=", "null", ";", "if", "(", "this", ".", "parser", "==", "null", ")", "{", "SAXParserFactory", "factory", "=", "null", ";", "try", "{", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "FactoryConfigurationError", "e", ")", "{", "try", "{", "factory", "=", "(", "SAXParserFactory", ")", "Class", ".", "forName", "(", "\"", "org.apache.xerces.jaxp.SAXParserFactoryImpl", "\"", ")", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "Exception", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e1", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e", ")", ";", "}", "factory", ".", "setNamespaceAware", "(", "true", ")", ";", "final", "String", "isValidatingString", "=", "System", ".", "getProperty", "(", "\"", "drools.schema.validating", "\"", ")", ";", "if", "(", "System", ".", "getProperty", "(", "\"", "drools.schema.validating", "\"", ")", "!=", "null", ")", "{", "this", ".", "isValidating", "=", "Boolean", ".", "getBoolean", "(", "\"", "drools.schema.validating", "\"", ")", ";", "}", "if", "(", "this", ".", "isValidating", "==", "true", ")", "{", "factory", ".", "setValidating", "(", "true", ")", ";", "try", "{", "localParser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "}", "catch", "(", "final", "ParserConfigurationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "try", "{", "localParser", ".", "setProperty", "(", "ExtensibleXmlParser", ".", "JAXP_SCHEMA_LANGUAGE", ",", "ExtensibleXmlParser", ".", "W3C_XML_SCHEMA", ")", ";", "}", "catch", "(", "final", "SAXNotRecognizedException", "e", ")", "{", "boolean", "hideWarnings", "=", "Boolean", ".", "getBoolean", "(", "\"", "drools.schema.hidewarnings", "\"", ")", ";", "if", "(", "!", "hideWarnings", ")", "{", "logger", ".", "warn", "(", "\"", "Your SAX parser is not JAXP 1.2 compliant - turning off validation.", "\"", ")", ";", "}", "localParser", "=", "null", ";", "}", "}", "if", "(", "localParser", "==", "null", ")", "{", "try", "{", "this", ".", "isValidating", "=", "false", ";", "factory", ".", "setValidating", "(", "this", ".", "isValidating", ")", ";", "localParser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "}", "catch", "(", "final", "ParserConfigurationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "else", "{", "localParser", "=", "this", ".", "parser", ";", "}", "if", "(", "!", "localParser", ".", "isNamespaceAware", "(", ")", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "parser must be namespace-aware", "\"", ")", ";", "}", "localParser", ".", "parse", "(", "in", ",", "this", ")", ";", "return", "this", ".", "data", ";", "}"], "idx": 110773, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "5b850e8c121be994dbbc5ecba3de4e7355ac4331", "function_name": "read", "body_hash": "be195970323acaed9ca5282ae02b4eb73869552c"}
{"code": "@RequirePOST\n    public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        if(channel!=null) {\n            req.getView(this,\"already-launched.jelly\").forward(req, rsp);\n            return;\n        }\n\n        connect(true);\n\n        // TODO: would be nice to redirect the user to \"launching...\" wait page,\n        // then spend a few seconds there and poll for the completion periodically.\n        rsp.sendRedirect(\"log\");\n    }", "code_tokens": ["@", "RequirePOST", "public", "void", "doLaunchSlaveAgent", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "channel", "!=", "null", ")", "{", "req", ".", "getView", "(", "this", ",", "\"", "already-launched.jelly", "\"", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "return", ";", "}", "connect", "(", "true", ")", ";", "rsp", ".", "sendRedirect", "(", "\"", "log", "\"", ")", ";", "}"], "idx": 86451, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "40250f08aca7f3f8816f21870ee23463a52ef2f2", "function_name": "doLaunchSlaveAgent", "body_hash": "67d8ee7a5a52d6b292bcae9b772befc2c127d153"}
{"code": "public void execute(ActionInvocation invocation) throws Exception {\n        // if the finalNamespace wasn't explicitly defined, assume the current one\n        if (this.namespace == null) {\n            this.namespace = invocation.getProxy().getNamespace();\n        }\n\n        ValueStack stack = ActionContext.getContext().getValueStack();\n        String finalNamespace = TextParseUtil.translateVariables(namespace, stack);\n        String finalActionName = TextParseUtil.translateVariables(actionName, stack);\n        String finalMethodName = this.methodName != null\n                ? TextParseUtil.translateVariables(this.methodName, stack)\n                : null;\n\n        if (isInChainHistory(finalNamespace, finalActionName, finalMethodName)) {\n            addToHistory(finalNamespace, finalActionName, finalMethodName);\n            throw new XWorkException(\"Infinite recursion detected: \"\n                    + ActionChainResult.getChainHistory().toString());\n        }\n\n        if (ActionChainResult.getChainHistory().isEmpty() && invocation != null && invocation.getProxy() != null) {\n            addToHistory(finalNamespace, invocation.getProxy().getActionName(), invocation.getProxy().getMethod());\n        }\n        addToHistory(finalNamespace, finalActionName, finalMethodName);\n\n        HashMap<String, Object> extraContext = new HashMap<String, Object>();\n        extraContext.put(ActionContext.VALUE_STACK, ActionContext.getContext().getValueStack());\n        extraContext.put(ActionContext.PARAMETERS, ActionContext.getContext().getParameters());\n        extraContext.put(CHAIN_HISTORY, ActionChainResult.getChainHistory());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Chaining to action \" + finalActionName);\n        }\n\n        proxy = actionProxyFactory.createActionProxy(finalNamespace, finalActionName, finalMethodName, extraContext);\n        proxy.execute();\n    }", "code_tokens": ["public", "void", "execute", "(", "ActionInvocation", "invocation", ")", "throws", "Exception", "{", "if", "(", "this", ".", "namespace", "==", "null", ")", "{", "this", ".", "namespace", "=", "invocation", ".", "getProxy", "(", ")", ".", "getNamespace", "(", ")", ";", "}", "ValueStack", "stack", "=", "ActionContext", ".", "getContext", "(", ")", ".", "getValueStack", "(", ")", ";", "String", "finalNamespace", "=", "TextParseUtil", ".", "translateVariables", "(", "namespace", ",", "stack", ")", ";", "String", "finalActionName", "=", "TextParseUtil", ".", "translateVariables", "(", "actionName", ",", "stack", ")", ";", "String", "finalMethodName", "=", "this", ".", "methodName", "!=", "null", "?", "TextParseUtil", ".", "translateVariables", "(", "this", ".", "methodName", ",", "stack", ")", ":", "null", ";", "if", "(", "isInChainHistory", "(", "finalNamespace", ",", "finalActionName", ",", "finalMethodName", ")", ")", "{", "addToHistory", "(", "finalNamespace", ",", "finalActionName", ",", "finalMethodName", ")", ";", "throw", "new", "XWorkException", "(", "\"", "Infinite recursion detected: ", "\"", "+", "ActionChainResult", ".", "getChainHistory", "(", ")", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "ActionChainResult", ".", "getChainHistory", "(", ")", ".", "isEmpty", "(", ")", "&&", "invocation", "!=", "null", "&&", "invocation", ".", "getProxy", "(", ")", "!=", "null", ")", "{", "addToHistory", "(", "finalNamespace", ",", "invocation", ".", "getProxy", "(", ")", ".", "getActionName", "(", ")", ",", "invocation", ".", "getProxy", "(", ")", ".", "getMethod", "(", ")", ")", ";", "}", "addToHistory", "(", "finalNamespace", ",", "finalActionName", ",", "finalMethodName", ")", ";", "HashMap", "<", "String", ",", "Object", ">", "extraContext", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "extraContext", ".", "put", "(", "ActionContext", ".", "VALUE_STACK", ",", "ActionContext", ".", "getContext", "(", ")", ".", "getValueStack", "(", ")", ")", ";", "extraContext", ".", "put", "(", "ActionContext", ".", "PARAMETERS", ",", "ActionContext", ".", "getContext", "(", ")", ".", "getParameters", "(", ")", ")", ";", "extraContext", ".", "put", "(", "CHAIN_HISTORY", ",", "ActionChainResult", ".", "getChainHistory", "(", ")", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Chaining to action ", "\"", "+", "finalActionName", ")", ";", "}", "proxy", "=", "actionProxyFactory", ".", "createActionProxy", "(", "finalNamespace", ",", "finalActionName", ",", "finalMethodName", ",", "extraContext", ")", ";", "proxy", ".", "execute", "(", ")", ";", "}"], "idx": 12221, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "4a3917176de2df7f33a85511d067f31e50dcc1b", "function_name": "execute", "body_hash": "81fa3540bc38cb406d34cd01228747f76d5584b4"}
{"code": "public void recycle() {\n        bytesRead=0;\n\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        trailerFields.clear();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTimeNanos = -1;\n    }", "code_tokens": ["public", "void", "recycle", "(", ")", "{", "bytesRead", "=", "0", ";", "contentLength", "=", "-", "1", ";", "contentTypeMB", "=", "null", ";", "charset", "=", "null", ";", "characterEncoding", "=", "null", ";", "expectation", "=", "false", ";", "headers", ".", "recycle", "(", ")", ";", "trailerFields", ".", "clear", "(", ")", ";", "serverNameMB", ".", "recycle", "(", ")", ";", "serverPort", "=", "-", "1", ";", "localAddrMB", ".", "recycle", "(", ")", ";", "localNameMB", ".", "recycle", "(", ")", ";", "localPort", "=", "-", "1", ";", "peerAddrMB", ".", "recycle", "(", ")", ";", "remoteAddrMB", ".", "recycle", "(", ")", ";", "remoteHostMB", ".", "recycle", "(", ")", ";", "remotePort", "=", "-", "1", ";", "available", "=", "0", ";", "sendfile", "=", "true", ";", "serverCookies", ".", "recycle", "(", ")", ";", "parameters", ".", "recycle", "(", ")", ";", "pathParameters", ".", "clear", "(", ")", ";", "uriMB", ".", "recycle", "(", ")", ";", "decodedUriMB", ".", "recycle", "(", ")", ";", "queryMB", ".", "recycle", "(", ")", ";", "methodMB", ".", "recycle", "(", ")", ";", "protoMB", ".", "recycle", "(", ")", ";", "schemeMB", ".", "recycle", "(", ")", ";", "remoteUser", ".", "recycle", "(", ")", ";", "remoteUserNeedsAuthorization", "=", "false", ";", "authType", ".", "recycle", "(", ")", ";", "attributes", ".", "clear", "(", ")", ";", "listener", "=", "null", ";", "synchronized", "(", "nonBlockingStateLock", ")", "{", "fireListener", "=", "false", ";", "registeredForRead", "=", "false", ";", "}", "allDataReadEventSent", ".", "set", "(", "false", ")", ";", "startTimeNanos", "=", "-", "1", ";", "}"], "idx": 74731, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "b59099e4ca501a039510334ebe1024971cd6f959", "function_name": "recycle", "body_hash": "6d2da3458e0fc88841365277e5b814692ce6de39"}
{"code": "private void doDirectoryRedirect(HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n        StringBuilder location = new StringBuilder(request.getRequestURI());\n        location.append('/');\n        if (request.getQueryString() != null) {\n            location.append('?');\n            location.append(request.getQueryString());\n        }\n        response.sendRedirect(response.encodeRedirectURL(location.toString()));\n    }", "code_tokens": ["private", "void", "doDirectoryRedirect", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "IOException", "{", "StringBuilder", "location", "=", "new", "StringBuilder", "(", "request", ".", "getRequestURI", "(", ")", ")", ";", "location", ".", "append", "(", "'/'", ")", ";", "if", "(", "request", ".", "getQueryString", "(", ")", "!=", "null", ")", "{", "location", ".", "append", "(", "'?'", ")", ";", "location", ".", "append", "(", "request", ".", "getQueryString", "(", ")", ")", ";", "}", "response", ".", "sendRedirect", "(", "response", ".", "encodeRedirectURL", "(", "location", ".", "toString", "(", ")", ")", ")", ";", "}"], "idx": 65600, "cwe": "CWE-601", "target": 1, "status": "VULNERABLE", "commit": "efb860b3ff8ebcf606199b8d0d432f76898040da", "function_name": "doDirectoryRedirect", "body_hash": "835220ed2b5bd47713d8935751a4a46339af59ea"}
{"code": "private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        // form field validation\n        // this pattern needs to be generalized and moved to stapler\n        SignupInfo si = new SignupInfo(req);\n\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else if(!containsOnlyAcceptableCharacters(si.username))\n            if(ID_REGEX == null){\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameInvalidCharacters();\n            }else{\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameInvalidCharactersCustom(ID_REGEX);\n            }\n        else {\n            // do not create the user - we just want to check if the user already exists but is not a \"login\" user.\n            User user = User.getById(si.username, false); \n            if (null != user)\n                // Allow sign up. SCM people has no such property.\n                if (user.getProperty(Details.class) != null)\n                    si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n        }\n\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(isMailerPluginPresent() && (si.email==null || !si.email.contains(\"@\")))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if (! User.isIdOrFullnameAllowed(si.username)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalUsername(si.username);\n        }\n\n        if (! User.isIdOrFullnameAllowed(si.fullname)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalFullname(si.fullname);\n        }\n\n        if(si.errorMessage!=null) {\n            // failed. ask the user to try again.\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        // register the user\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        if(isMailerPluginPresent()) {\n            try {\n                // legacy hack. mail support has moved out to a separate plugin\n                Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n                Constructor<?> c = up.getDeclaredConstructor(String.class);\n                user.addProperty((UserProperty)c.newInstance(si.email));\n            } catch (ReflectiveOperationException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        user.save();\n        return user;\n    }", "code_tokens": ["private", "User", "createAccount", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ",", "boolean", "selfRegistration", ",", "String", "formView", ")", "throws", "ServletException", ",", "IOException", "{", "SignupInfo", "si", "=", "new", "SignupInfo", "(", "req", ")", ";", "if", "(", "selfRegistration", "&&", "!", "validateCaptcha", "(", "si", ".", "captcha", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage", "(", ")", ";", "if", "(", "si", ".", "password1", "!=", "null", "&&", "!", "si", ".", "password1", ".", "equals", "(", "si", ".", "password2", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch", "(", ")", ";", "if", "(", "!", "(", "si", ".", "password1", "!=", "null", "&&", "si", ".", "password1", ".", "length", "(", ")", "!=", "0", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired", "(", ")", ";", "if", "(", "si", ".", "username", "==", "null", "||", "si", ".", "username", ".", "length", "(", ")", "==", "0", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired", "(", ")", ";", "else", "if", "(", "!", "containsOnlyAcceptableCharacters", "(", "si", ".", "username", ")", ")", "if", "(", "ID_REGEX", "==", "null", ")", "{", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameInvalidCharacters", "(", ")", ";", "}", "else", "{", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameInvalidCharactersCustom", "(", "ID_REGEX", ")", ";", "}", "else", "{", "User", "user", "=", "User", ".", "getById", "(", "si", ".", "username", ",", "false", ")", ";", "if", "(", "null", "!=", "user", ")", "if", "(", "user", ".", "getProperty", "(", "Details", ".", "class", ")", "!=", "null", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken", "(", ")", ";", "}", "if", "(", "si", ".", "fullname", "==", "null", "||", "si", ".", "fullname", ".", "length", "(", ")", "==", "0", ")", "si", ".", "fullname", "=", "si", ".", "username", ";", "if", "(", "isMailerPluginPresent", "(", ")", "&&", "(", "si", ".", "email", "==", "null", "||", "!", "si", ".", "email", ".", "contains", "(", "\"", "@", "\"", ")", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress", "(", ")", ";", "if", "(", "!", "User", ".", "isIdOrFullnameAllowed", "(", "si", ".", "username", ")", ")", "{", "si", ".", "errorMessage", "=", "hudson", ".", "model", ".", "Messages", ".", "User_IllegalUsername", "(", "si", ".", "username", ")", ";", "}", "if", "(", "!", "User", ".", "isIdOrFullnameAllowed", "(", "si", ".", "fullname", ")", ")", "{", "si", ".", "errorMessage", "=", "hudson", ".", "model", ".", "Messages", ".", "User_IllegalFullname", "(", "si", ".", "fullname", ")", ";", "}", "if", "(", "si", ".", "errorMessage", "!=", "null", ")", "{", "req", ".", "setAttribute", "(", "\"", "data", "\"", ",", "si", ")", ";", "req", ".", "getView", "(", "this", ",", "formView", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "return", "null", ";", "}", "User", "user", "=", "createAccount", "(", "si", ".", "username", ",", "si", ".", "password1", ")", ";", "user", ".", "setFullName", "(", "si", ".", "fullname", ")", ";", "if", "(", "isMailerPluginPresent", "(", ")", ")", "{", "try", "{", "Class", "<", "?", ">", "up", "=", "Jenkins", ".", "getInstance", "(", ")", ".", "pluginManager", ".", "uberClassLoader", ".", "loadClass", "(", "\"", "hudson.tasks.Mailer$UserProperty", "\"", ")", ";", "Constructor", "<", "?", ">", "c", "=", "up", ".", "getDeclaredConstructor", "(", "String", ".", "class", ")", ";", "user", ".", "addProperty", "(", "(", "UserProperty", ")", "c", ".", "newInstance", "(", "si", ".", "email", ")", ")", ";", "}", "catch", "(", "ReflectiveOperationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "user", ".", "save", "(", ")", ";", "return", "user", ";", "}"], "idx": 73233, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "de7aaab441151fb1760855fec83681c6a8756a45", "function_name": "createAccount", "body_hash": "a6cd3fc3ebd4cdbe09e96d2b7882a07ae5d56163"}
{"code": "private static void processZipStream(File dir, InputStream inputStream) throws IOException\n   {\n      String canonicalDestinationDirPath = dir.getCanonicalPath();\n      ZipInputStream zip = new ZipInputStream(inputStream);\n      while (true)\n      {\n         ZipEntry entry = zip.getNextEntry();\n         if (entry == null)\n         {\n            break;\n         }\n\n         File file = new File(dir, entry.getName());\n\n         // https://snyk.io/research/zip-slip-vulnerability\n         String canonicalDestinationFile = file.getCanonicalPath();\n         if (!canonicalDestinationFile.startsWith(canonicalDestinationDirPath + File.separator))\n         {\n            throw new IOException(\"Entry is outside of the target dir: \" + entry.getName());\n         }\n\n         if (entry.isDirectory())\n         {\n            FileHelper.mkdirsQuietly(file);\n            continue;\n         }\n\n         File parent = file.getParentFile();\n         if (parent != null)\n         {\n            FileHelper.mkdirsQuietly(parent);\n         }\n\n         FileOutputStream fos = new FileOutputStream(file);\n         byte[] bytes = new byte[1024];\n         int length;\n         while ((length = zip.read(bytes)) >= 0)\n         {\n            fos.write(bytes, 0, length);\n         }\n         fos.close();\n      }\n   }", "code_tokens": ["private", "static", "void", "processZipStream", "(", "File", "dir", ",", "InputStream", "inputStream", ")", "throws", "IOException", "{", "String", "canonicalDestinationDirPath", "=", "dir", ".", "getCanonicalPath", "(", ")", ";", "ZipInputStream", "zip", "=", "new", "ZipInputStream", "(", "inputStream", ")", ";", "while", "(", "true", ")", "{", "ZipEntry", "entry", "=", "zip", ".", "getNextEntry", "(", ")", ";", "if", "(", "entry", "==", "null", ")", "{", "break", ";", "}", "File", "file", "=", "new", "File", "(", "dir", ",", "entry", ".", "getName", "(", ")", ")", ";", "String", "canonicalDestinationFile", "=", "file", ".", "getCanonicalPath", "(", ")", ";", "if", "(", "!", "canonicalDestinationFile", ".", "startsWith", "(", "canonicalDestinationDirPath", "+", "File", ".", "separator", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "Entry is outside of the target dir: ", "\"", "+", "entry", ".", "getName", "(", ")", ")", ";", "}", "if", "(", "entry", ".", "isDirectory", "(", ")", ")", "{", "FileHelper", ".", "mkdirsQuietly", "(", "file", ")", ";", "continue", ";", "}", "File", "parent", "=", "file", ".", "getParentFile", "(", ")", ";", "if", "(", "parent", "!=", "null", ")", "{", "FileHelper", ".", "mkdirsQuietly", "(", "parent", ")", ";", "}", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "file", ")", ";", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "1024", "]", ";", "int", "length", ";", "while", "(", "(", "length", "=", "zip", ".", "read", "(", "bytes", ")", ")", ">=", "0", ")", "{", "fos", ".", "write", "(", "bytes", ",", "0", ",", "length", ")", ";", "}", "fos", ".", "close", "(", ")", ";", "}", "}"], "idx": 27288, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "8eaf4225048ea5ba7e59ef4556dab2098fcc4a1d", "function_name": "processZipStream", "body_hash": "8547e56642fa60e9980c29f133a947427eb389da"}
{"code": "public void testBasics() throws Exception {\n        jenkins.setSecurityRealm(createDummySecurityRealm());\n        User u = User.get(\"foo\");\n        final ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n        final String token = t.getApiToken();\n\n        // Make sure that user is able to get the token via the interface\n        ACL.impersonate(u.impersonate(), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(\"User is unable to get its own token\", token, t.getApiToken());\n            }\n        });\n\n        // test the authentication via Token\n        WebClient wc = createClientForUser(\"foo\");\n        assertEquals(u,wc.executeOnServer(new Callable<User>() {\n            public User call() throws Exception {\n                return User.current();\n            }\n        }));\n        \n        // Make sure the UI shows the token to the user\n        HtmlPage config = wc.goTo(u.getUrl() + \"/configure\");\n        HtmlForm form = config.getFormByName(\"config\");\n        assertEquals(token, form.getInputByName(\"_.apiToken\").getValueAttribute());\n\n        // round-trip shouldn't change the API token\n        submit(form);\n        assertSame(t, u.getProperty(ApiTokenProperty.class));\n    }", "code_tokens": ["public", "void", "testBasics", "(", ")", "throws", "Exception", "{", "jenkins", ".", "setSecurityRealm", "(", "createDummySecurityRealm", "(", ")", ")", ";", "User", "u", "=", "User", ".", "get", "(", "\"", "foo", "\"", ")", ";", "final", "ApiTokenProperty", "t", "=", "u", ".", "getProperty", "(", "ApiTokenProperty", ".", "class", ")", ";", "final", "String", "token", "=", "t", ".", "getApiToken", "(", ")", ";", "ACL", ".", "impersonate", "(", "u", ".", "impersonate", "(", ")", ",", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "assertEquals", "(", "\"", "User is unable to get its own token", "\"", ",", "token", ",", "t", ".", "getApiToken", "(", ")", ")", ";", "}", "}", ")", ";", "WebClient", "wc", "=", "createClientForUser", "(", "\"", "foo", "\"", ")", ";", "assertEquals", "(", "u", ",", "wc", ".", "executeOnServer", "(", "new", "Callable", "<", "User", ">", "(", ")", "{", "public", "User", "call", "(", ")", "throws", "Exception", "{", "return", "User", ".", "current", "(", ")", ";", "}", "}", ")", ")", ";", "HtmlPage", "config", "=", "wc", ".", "goTo", "(", "u", ".", "getUrl", "(", ")", "+", "\"", "/configure", "\"", ")", ";", "HtmlForm", "form", "=", "config", ".", "getFormByName", "(", "\"", "config", "\"", ")", ";", "assertEquals", "(", "token", ",", "form", ".", "getInputByName", "(", "\"", "_.apiToken", "\"", ")", ".", "getValueAttribute", "(", ")", ")", ";", "submit", "(", "form", ")", ";", "assertSame", "(", "t", ",", "u", ".", "getProperty", "(", "ApiTokenProperty", ".", "class", ")", ")", ";", "}"], "idx": 35166, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "b3f16489ad5f15c3e749ed066cf6b4251f6668c6", "function_name": "testBasics", "body_hash": "e7a901ca073ee7243eea68d02142a9a8f410e2e2"}
{"code": "private void normalizeNumber(int start, int end) {\n    int pos = start;\n    // Sign\n    if (pos < end) {\n      switch (jsonish.charAt(pos)) {\n        case '+':\n          elide(pos, pos + 1);\n          ++pos;\n          break;\n        case '-':\n          ++pos;\n          break;\n        default:\n          break;\n      }\n    }\n\n    // Integer part\n    int intEnd = endOfDigitRun(pos, end);\n    if (pos == intEnd) {  // No empty integer parts allowed in JSON.\n      insert(pos, '0');\n    } else if ('0' == jsonish.charAt(pos)) {\n      boolean reencoded = false;\n      int maxDigVal = 0; // The value of the max digit\n      int probableBase = 10; // The base suggested by the prefix\n      int firstDigitIndex = -1;\n      if (intEnd - pos == 1 && intEnd < end\n              && 'x' == (jsonish.charAt(intEnd) | 32)) {  // Recode hex.\n        probableBase = 16;\n        firstDigitIndex = intEnd + 1;\n        for (intEnd = intEnd + 1; intEnd < end; ++intEnd) {\n          char ch = jsonish.charAt(intEnd);\n          int digVal;\n          if ('0' <= ch && ch <= '9') {\n            digVal = ch - '0';\n          } else {\n            ch |= 32;\n            if ('a' <= ch && ch <= 'f') {\n              digVal = ch - ('a' - 10);\n            } else {\n              break;\n            }\n          }\n          maxDigVal = Math.max(digVal, maxDigVal);\n        }\n        reencoded = true;\n      } else if (intEnd - pos > 1) {  // Recode octal.\n        probableBase = 8;\n        firstDigitIndex = pos;\n        for (int i = pos; i < intEnd; ++i) {\n          int digVal = jsonish.charAt(i) - '0';\n          if (digVal < 0) {\n            break;\n          }\n          maxDigVal = Math.max(digVal, maxDigVal);\n        }\n        reencoded = true;\n      }\n      if (reencoded) {\n        // Avoid multiple signs.\n        // Putting out the underflowed value is the least bad option.\n        elide(pos, intEnd);\n\n        String digits = jsonish.substring(firstDigitIndex, intEnd);\n\n        int nDigits = digits.length();\n        int base = probableBase > maxDigVal ? probableBase : maxDigVal > 10 ? 16 : 10;\n        if (nDigits == 0) {\n          sanitizedJson.append('0');\n        } else if (DIGITS_BY_BASE_THAT_FIT_IN_63B[base] >= nDigits) {\n          long value = Long.parseLong(digits, base);\n          sanitizedJson.append(value);\n        } else {\n          // If there are lots of digits, we need to reencode using a BigInteger\n          BigInteger value = new BigInteger(digits, base);\n          sanitizedJson.append(value);\n        }\n      }\n    }\n    pos = intEnd;\n\n    // Optional fraction.\n    if (pos < end && jsonish.charAt(pos) == '.') {\n      ++pos;\n      int fractionEnd = endOfDigitRun(pos, end);\n      if (fractionEnd == pos) {\n        insert(pos, '0');\n      }\n      // JS eval will discard digits after 24(?) but will not treat them as a\n      // syntax error, and JSON allows arbitrary length fractions.\n      pos = fractionEnd;\n    }\n\n    // Optional exponent.\n    if (pos < end && 'e' == (jsonish.charAt(pos) | 32)) {\n      ++pos;\n      if (pos < end) {\n        switch (jsonish.charAt(pos)) {\n          // JSON allows explicit + in exponent but not for number as a whole.\n          case '+': case '-': ++pos; break;\n          default: break;\n        }\n      }\n      // JSON allows leading zeros on exponent part.\n      int expEnd = endOfDigitRun(pos, end);\n      if (expEnd == pos) {\n        insert(pos, '0');\n      }\n      pos = expEnd;\n    }\n    if (pos != end) {\n      elide(pos, end);\n    }\n  }", "code_tokens": ["private", "void", "normalizeNumber", "(", "int", "start", ",", "int", "end", ")", "{", "int", "pos", "=", "start", ";", "if", "(", "pos", "<", "end", ")", "{", "switch", "(", "jsonish", ".", "charAt", "(", "pos", ")", ")", "{", "case", "'+'", ":", "elide", "(", "pos", ",", "pos", "+", "1", ")", ";", "++", "pos", ";", "break", ";", "case", "'-'", ":", "++", "pos", ";", "break", ";", "default", ":", "break", ";", "}", "}", "int", "intEnd", "=", "endOfDigitRun", "(", "pos", ",", "end", ")", ";", "if", "(", "pos", "==", "intEnd", ")", "{", "insert", "(", "pos", ",", "'0'", ")", ";", "}", "else", "if", "(", "'0'", "==", "jsonish", ".", "charAt", "(", "pos", ")", ")", "{", "boolean", "reencoded", "=", "false", ";", "int", "maxDigVal", "=", "0", ";", "int", "probableBase", "=", "10", ";", "int", "firstDigitIndex", "=", "-", "1", ";", "if", "(", "intEnd", "-", "pos", "==", "1", "&&", "intEnd", "<", "end", "&&", "'x'", "==", "(", "jsonish", ".", "charAt", "(", "intEnd", ")", "|", "32", ")", ")", "{", "probableBase", "=", "16", ";", "firstDigitIndex", "=", "intEnd", "+", "1", ";", "for", "(", "intEnd", "=", "intEnd", "+", "1", ";", "intEnd", "<", "end", ";", "++", "intEnd", ")", "{", "char", "ch", "=", "jsonish", ".", "charAt", "(", "intEnd", ")", ";", "int", "digVal", ";", "if", "(", "'0'", "<=", "ch", "&&", "ch", "<=", "'9'", ")", "{", "digVal", "=", "ch", "-", "'0'", ";", "}", "else", "{", "ch", "|=", "32", ";", "if", "(", "'a'", "<=", "ch", "&&", "ch", "<=", "'f'", ")", "{", "digVal", "=", "ch", "-", "(", "'a'", "-", "10", ")", ";", "}", "else", "{", "break", ";", "}", "}", "maxDigVal", "=", "Math", ".", "max", "(", "digVal", ",", "maxDigVal", ")", ";", "}", "reencoded", "=", "true", ";", "}", "else", "if", "(", "intEnd", "-", "pos", ">", "1", ")", "{", "probableBase", "=", "8", ";", "firstDigitIndex", "=", "pos", ";", "for", "(", "int", "i", "=", "pos", ";", "i", "<", "intEnd", ";", "++", "i", ")", "{", "int", "digVal", "=", "jsonish", ".", "charAt", "(", "i", ")", "-", "'0'", ";", "if", "(", "digVal", "<", "0", ")", "{", "break", ";", "}", "maxDigVal", "=", "Math", ".", "max", "(", "digVal", ",", "maxDigVal", ")", ";", "}", "reencoded", "=", "true", ";", "}", "if", "(", "reencoded", ")", "{", "elide", "(", "pos", ",", "intEnd", ")", ";", "String", "digits", "=", "jsonish", ".", "substring", "(", "firstDigitIndex", ",", "intEnd", ")", ";", "int", "nDigits", "=", "digits", ".", "length", "(", ")", ";", "int", "base", "=", "probableBase", ">", "maxDigVal", "?", "probableBase", ":", "maxDigVal", ">", "10", "?", "16", ":", "10", ";", "if", "(", "nDigits", "==", "0", ")", "{", "sanitizedJson", ".", "append", "(", "'0'", ")", ";", "}", "else", "if", "(", "DIGITS_BY_BASE_THAT_FIT_IN_63B", "[", "base", "]", ">=", "nDigits", ")", "{", "long", "value", "=", "Long", ".", "parseLong", "(", "digits", ",", "base", ")", ";", "sanitizedJson", ".", "append", "(", "value", ")", ";", "}", "else", "{", "BigInteger", "value", "=", "new", "BigInteger", "(", "digits", ",", "base", ")", ";", "sanitizedJson", ".", "append", "(", "value", ")", ";", "}", "}", "}", "pos", "=", "intEnd", ";", "if", "(", "pos", "<", "end", "&&", "jsonish", ".", "charAt", "(", "pos", ")", "==", "'.'", ")", "{", "++", "pos", ";", "int", "fractionEnd", "=", "endOfDigitRun", "(", "pos", ",", "end", ")", ";", "if", "(", "fractionEnd", "==", "pos", ")", "{", "insert", "(", "pos", ",", "'0'", ")", ";", "}", "pos", "=", "fractionEnd", ";", "}", "if", "(", "pos", "<", "end", "&&", "'e'", "==", "(", "jsonish", ".", "charAt", "(", "pos", ")", "|", "32", ")", ")", "{", "++", "pos", ";", "if", "(", "pos", "<", "end", ")", "{", "switch", "(", "jsonish", ".", "charAt", "(", "pos", ")", ")", "{", "case", "'+'", ":", "case", "'-'", ":", "++", "pos", ";", "break", ";", "default", ":", "break", ";", "}", "}", "int", "expEnd", "=", "endOfDigitRun", "(", "pos", ",", "end", ")", ";", "if", "(", "expEnd", "==", "pos", ")", "{", "insert", "(", "pos", ",", "'0'", ")", ";", "}", "pos", "=", "expEnd", ";", "}", "if", "(", "pos", "!=", "end", ")", "{", "elide", "(", "pos", ",", "end", ")", ";", "}", "}"], "idx": 69937, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "d9261ad22872f84c3948f9711454b5630e3e977d", "function_name": "normalizeNumber", "body_hash": "f965e709e964c557e07479408fa04e02fbe1a049"}
{"code": "public Session createSession(String from) throws MessagingException {\n        Properties props = new Properties(System.getProperties());\n\n        MailAccount acc = mailAccount;\n        if(StringUtils.isNotBlank(from)){\n            InternetAddress fromAddress = new InternetAddress(from);\n            for(MailAccount ma : addAccounts) {\n                if(ma == null || !ma.isValid() || !ma.getAddress().equalsIgnoreCase(fromAddress.getAddress())) continue;\n                acc = ma;\n                break;\n            }\n        }\n\n        if(!acc.isValid()) {\n            // what do we want to do here?\n        }\n\n        if (acc.getSmtpHost() != null) {\n            props.put(\"mail.smtp.host\", acc.getSmtpHost());\n        }\n        if (acc.getSmtpPort() != null) {\n            props.put(\"mail.smtp.port\", acc.getSmtpPort());\n        }\n        if (acc.isUseSsl()) {\n            /* This allows the user to override settings by setting system properties but\n             * also allows us to use the default SMTPs port of 465 if no port is already set.\n             * It would be cleaner to use smtps, but that's done by calling session.getTransport()...\n             * and thats done in mail sender, and it would be a bit of a hack to get it all to\n             * coordinate, and we can make it work through setting mail.smtp properties.\n             */\n            if (props.getProperty(\"mail.smtp.socketFactory.port\") == null) {\n                String port = acc.getSmtpPort() == null ? \"465\" : mailAccount.getSmtpPort();\n                props.put(\"mail.smtp.port\", port);\n                props.put(\"mail.smtp.socketFactory.port\", port);\n            }\n            if (props.getProperty(\"mail.smtp.socketFactory.class\") == null) {\n                props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n            }\n            props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n\n            // RFC 2595 specifies additional checks that must be performed on the server's\n            // certificate to ensure that the server you connected to is the server you intended\n            // to connect to. This reduces the risk of \"man in the middle\" attacks.\n            if (props.getProperty(\"mail.smtp.ssl.checkserveridentity\") == null) {\n                props.put(\"mail.smtp.ssl.checkserveridentity\", \"true\");\n            }\n        }\n        if (!StringUtils.isBlank(acc.getSmtpUsername())) {\n            props.put(\"mail.smtp.auth\", \"true\");\n        }\n\n        // avoid hang by setting some timeout.\n        props.put(\"mail.smtp.timeout\", \"60000\");\n        props.put(\"mail.smtp.connectiontimeout\", \"60000\");\n\n        try {\n            String ap = acc.getAdvProperties();\n            if (ap != null && !isBlank(ap.trim())) {\n                props.load(new StringReader(ap));\n            }\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Parameters parse fail.\", e);\n        }\n\n        return Session.getInstance(props, getAuthenticator(acc));\n    }", "code_tokens": ["public", "Session", "createSession", "(", "String", "from", ")", "throws", "MessagingException", "{", "Properties", "props", "=", "new", "Properties", "(", "System", ".", "getProperties", "(", ")", ")", ";", "MailAccount", "acc", "=", "mailAccount", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "from", ")", ")", "{", "InternetAddress", "fromAddress", "=", "new", "InternetAddress", "(", "from", ")", ";", "for", "(", "MailAccount", "ma", ":", "addAccounts", ")", "{", "if", "(", "ma", "==", "null", "||", "!", "ma", ".", "isValid", "(", ")", "||", "!", "ma", ".", "getAddress", "(", ")", ".", "equalsIgnoreCase", "(", "fromAddress", ".", "getAddress", "(", ")", ")", ")", "continue", ";", "acc", "=", "ma", ";", "break", ";", "}", "}", "if", "(", "!", "acc", ".", "isValid", "(", ")", ")", "{", "}", "if", "(", "acc", ".", "getSmtpHost", "(", ")", "!=", "null", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.host", "\"", ",", "acc", ".", "getSmtpHost", "(", ")", ")", ";", "}", "if", "(", "acc", ".", "getSmtpPort", "(", ")", "!=", "null", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.port", "\"", ",", "acc", ".", "getSmtpPort", "(", ")", ")", ";", "}", "if", "(", "acc", ".", "isUseSsl", "(", ")", ")", "{", "if", "(", "props", ".", "getProperty", "(", "\"", "mail.smtp.socketFactory.port", "\"", ")", "==", "null", ")", "{", "String", "port", "=", "acc", ".", "getSmtpPort", "(", ")", "==", "null", "?", "\"", "465", "\"", ":", "mailAccount", ".", "getSmtpPort", "(", ")", ";", "props", ".", "put", "(", "\"", "mail.smtp.port", "\"", ",", "port", ")", ";", "props", ".", "put", "(", "\"", "mail.smtp.socketFactory.port", "\"", ",", "port", ")", ";", "}", "if", "(", "props", ".", "getProperty", "(", "\"", "mail.smtp.socketFactory.class", "\"", ")", "==", "null", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.socketFactory.class", "\"", ",", "\"", "javax.net.ssl.SSLSocketFactory", "\"", ")", ";", "}", "props", ".", "put", "(", "\"", "mail.smtp.socketFactory.fallback", "\"", ",", "\"", "false", "\"", ")", ";", "if", "(", "props", ".", "getProperty", "(", "\"", "mail.smtp.ssl.checkserveridentity", "\"", ")", "==", "null", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.ssl.checkserveridentity", "\"", ",", "\"", "true", "\"", ")", ";", "}", "}", "if", "(", "!", "StringUtils", ".", "isBlank", "(", "acc", ".", "getSmtpUsername", "(", ")", ")", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.auth", "\"", ",", "\"", "true", "\"", ")", ";", "}", "props", ".", "put", "(", "\"", "mail.smtp.timeout", "\"", ",", "\"", "60000", "\"", ")", ";", "props", ".", "put", "(", "\"", "mail.smtp.connectiontimeout", "\"", ",", "\"", "60000", "\"", ")", ";", "try", "{", "String", "ap", "=", "acc", ".", "getAdvProperties", "(", ")", ";", "if", "(", "ap", "!=", "null", "&&", "!", "isBlank", "(", "ap", ".", "trim", "(", ")", ")", ")", "{", "props", ".", "load", "(", "new", "StringReader", "(", "ap", ")", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Parameters parse fail.", "\"", ",", "e", ")", ";", "}", "return", "Session", ".", "getInstance", "(", "props", ",", "getAuthenticator", "(", "acc", ")", ")", ";", "}"], "idx": 40751, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "ac039ba5", "function_name": "createSession", "body_hash": "0d67f95b92bec786ca17d1a39c55d0d9ff02ee76"}
{"code": "static Secret tryDecrypt(Cipher cipher, byte[] in) throws UnsupportedEncodingException {\n        try {\n            String plainText = new String(cipher.doFinal(in), \"UTF-8\");\n            if(plainText.endsWith(MAGIC))\n                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));\n            return null;\n        } catch (GeneralSecurityException e) {\n            return null; // if the key doesn't match with the bytes, it can result in BadPaddingException\n        }\n    }", "code_tokens": ["static", "Secret", "tryDecrypt", "(", "Cipher", "cipher", ",", "byte", "[", "]", "in", ")", "throws", "UnsupportedEncodingException", "{", "try", "{", "String", "plainText", "=", "new", "String", "(", "cipher", ".", "doFinal", "(", "in", ")", ",", "\"", "UTF-8", "\"", ")", ";", "if", "(", "plainText", ".", "endsWith", "(", "MAGIC", ")", ")", "return", "new", "Secret", "(", "plainText", ".", "substring", "(", "0", ",", "plainText", ".", "length", "(", ")", "-", "MAGIC", ".", "length", "(", ")", ")", ")", ";", "return", "null", ";", "}", "catch", "(", "GeneralSecurityException", "e", ")", "{", "return", "null", ";", "}", "}"], "idx": 98779, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "4895eaafca468b7f0f1a3166b2fca7414f0d5da5", "function_name": "tryDecrypt", "body_hash": "1688e88db44d07ab0e931e917285e798e0f965a0"}
{"code": "public SecurityWebFilterChain build() {\n\t\tif(this.built != null) {\n\t\t\tthrow new IllegalStateException(\"This has already been built with the following stacktrace. \" + buildToString());\n\t\t}\n\t\tthis.built = new RuntimeException(\"First Build Invocation\").fillInStackTrace();\n\t\tif(this.headers != null) {\n\t\t\tthis.headers.configure(this);\n\t\t}\n\t\tWebFilter securityContextRepositoryWebFilter = securityContextRepositoryWebFilter();\n\t\tif(securityContextRepositoryWebFilter != null) {\n\t\t\tthis.webFilters.add(securityContextRepositoryWebFilter);\n\t\t}\n\t\tif(this.csrf != null) {\n\t\t\tthis.csrf.configure(this);\n\t\t}\n\t\tif(this.httpBasic != null) {\n\t\t\tthis.httpBasic.authenticationManager(this.authenticationManager);\n\t\t\tthis.httpBasic.configure(this);\n\t\t}\n\t\tif(this.formLogin != null) {\n\t\t\tthis.formLogin.authenticationManager(this.authenticationManager);\n\t\t\tif(this.securityContextRepository != null) {\n\t\t\t\tthis.formLogin.securityContextRepository(this.securityContextRepository);\n\t\t\t}\n\t\t\tif(this.formLogin.authenticationEntryPoint == null) {\n\t\t\t\tthis.webFilters.add(new OrderedWebFilter(new LoginPageGeneratingWebFilter(), SecurityWebFiltersOrder.LOGIN_PAGE_GENERATING.getOrder()));\n\t\t\t\tthis.webFilters.add(new OrderedWebFilter(new LogoutPageGeneratingWebFilter(), SecurityWebFiltersOrder.LOGOUT_PAGE_GENERATING.getOrder()));\n\t\t\t}\n\t\t\tthis.formLogin.configure(this);\n\t\t}\n\t\tif(this.logout != null) {\n\t\t\tthis.logout.configure(this);\n\t\t}\n\t\tthis.requestCache.configure(this);\n\t\tthis.addFilterAt(new SecurityContextServerWebExchangeWebFilter(), SecurityWebFiltersOrder.SECURITY_CONTEXT_SERVER_WEB_EXCHANGE);\n\t\tif(this.authorizeExchange != null) {\n\t\t\tServerAuthenticationEntryPoint authenticationEntryPoint = getAuthenticationEntryPoint();\n\t\t\tExceptionTranslationWebFilter exceptionTranslationWebFilter = new ExceptionTranslationWebFilter();\n\t\t\tif(authenticationEntryPoint != null) {\n\t\t\t\texceptionTranslationWebFilter.setAuthenticationEntryPoint(\n\t\t\t\t\tauthenticationEntryPoint);\n\t\t\t}\n\t\t\tif(accessDeniedHandler != null) {\n\t\t\t\texceptionTranslationWebFilter.setAccessDeniedHandler(accessDeniedHandler);\n\t\t\t}\n\t\t\tthis.addFilterAt(exceptionTranslationWebFilter, SecurityWebFiltersOrder.EXCEPTION_TRANSLATION);\n\t\t\tthis.authorizeExchange.configure(this);\n\t\t}\n\t\tAnnotationAwareOrderComparator.sort(this.webFilters);\n\t\tList<WebFilter> sortedWebFilters = new ArrayList<>();\n\t\tthis.webFilters.forEach( f -> {\n\t\t\tif(f instanceof OrderedWebFilter) {\n\t\t\t\tf = ((OrderedWebFilter) f).webFilter;\n\t\t\t}\n\t\t\tsortedWebFilters.add(f);\n\t\t});\n\t\treturn new MatcherSecurityWebFilterChain(getSecurityMatcher(), sortedWebFilters);\n\t}", "code_tokens": ["public", "SecurityWebFilterChain", "build", "(", ")", "{", "if", "(", "this", ".", "built", "!=", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "This has already been built with the following stacktrace. ", "\"", "+", "buildToString", "(", ")", ")", ";", "}", "this", ".", "built", "=", "new", "RuntimeException", "(", "\"", "First Build Invocation", "\"", ")", ".", "fillInStackTrace", "(", ")", ";", "if", "(", "this", ".", "headers", "!=", "null", ")", "{", "this", ".", "headers", ".", "configure", "(", "this", ")", ";", "}", "WebFilter", "securityContextRepositoryWebFilter", "=", "securityContextRepositoryWebFilter", "(", ")", ";", "if", "(", "securityContextRepositoryWebFilter", "!=", "null", ")", "{", "this", ".", "webFilters", ".", "add", "(", "securityContextRepositoryWebFilter", ")", ";", "}", "if", "(", "this", ".", "csrf", "!=", "null", ")", "{", "this", ".", "csrf", ".", "configure", "(", "this", ")", ";", "}", "if", "(", "this", ".", "httpBasic", "!=", "null", ")", "{", "this", ".", "httpBasic", ".", "authenticationManager", "(", "this", ".", "authenticationManager", ")", ";", "this", ".", "httpBasic", ".", "configure", "(", "this", ")", ";", "}", "if", "(", "this", ".", "formLogin", "!=", "null", ")", "{", "this", ".", "formLogin", ".", "authenticationManager", "(", "this", ".", "authenticationManager", ")", ";", "if", "(", "this", ".", "securityContextRepository", "!=", "null", ")", "{", "this", ".", "formLogin", ".", "securityContextRepository", "(", "this", ".", "securityContextRepository", ")", ";", "}", "if", "(", "this", ".", "formLogin", ".", "authenticationEntryPoint", "==", "null", ")", "{", "this", ".", "webFilters", ".", "add", "(", "new", "OrderedWebFilter", "(", "new", "LoginPageGeneratingWebFilter", "(", ")", ",", "SecurityWebFiltersOrder", ".", "LOGIN_PAGE_GENERATING", ".", "getOrder", "(", ")", ")", ")", ";", "this", ".", "webFilters", ".", "add", "(", "new", "OrderedWebFilter", "(", "new", "LogoutPageGeneratingWebFilter", "(", ")", ",", "SecurityWebFiltersOrder", ".", "LOGOUT_PAGE_GENERATING", ".", "getOrder", "(", ")", ")", ")", ";", "}", "this", ".", "formLogin", ".", "configure", "(", "this", ")", ";", "}", "if", "(", "this", ".", "logout", "!=", "null", ")", "{", "this", ".", "logout", ".", "configure", "(", "this", ")", ";", "}", "this", ".", "requestCache", ".", "configure", "(", "this", ")", ";", "this", ".", "addFilterAt", "(", "new", "SecurityContextServerWebExchangeWebFilter", "(", ")", ",", "SecurityWebFiltersOrder", ".", "SECURITY_CONTEXT_SERVER_WEB_EXCHANGE", ")", ";", "if", "(", "this", ".", "authorizeExchange", "!=", "null", ")", "{", "ServerAuthenticationEntryPoint", "authenticationEntryPoint", "=", "getAuthenticationEntryPoint", "(", ")", ";", "ExceptionTranslationWebFilter", "exceptionTranslationWebFilter", "=", "new", "ExceptionTranslationWebFilter", "(", ")", ";", "if", "(", "authenticationEntryPoint", "!=", "null", ")", "{", "exceptionTranslationWebFilter", ".", "setAuthenticationEntryPoint", "(", "authenticationEntryPoint", ")", ";", "}", "if", "(", "accessDeniedHandler", "!=", "null", ")", "{", "exceptionTranslationWebFilter", ".", "setAccessDeniedHandler", "(", "accessDeniedHandler", ")", ";", "}", "this", ".", "addFilterAt", "(", "exceptionTranslationWebFilter", ",", "SecurityWebFiltersOrder", ".", "EXCEPTION_TRANSLATION", ")", ";", "this", ".", "authorizeExchange", ".", "configure", "(", "this", ")", ";", "}", "AnnotationAwareOrderComparator", ".", "sort", "(", "this", ".", "webFilters", ")", ";", "List", "<", "WebFilter", ">", "sortedWebFilters", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "this", ".", "webFilters", ".", "forEach", "(", "f", "->", "{", "if", "(", "f", "instanceof", "OrderedWebFilter", ")", "{", "f", "=", "(", "(", "OrderedWebFilter", ")", "f", ")", ".", "webFilter", ";", "}", "sortedWebFilters", ".", "add", "(", "f", ")", ";", "}", ")", ";", "return", "new", "MatcherSecurityWebFilterChain", "(", "getSecurityMatcher", "(", ")", ",", "sortedWebFilters", ")", ";", "}"], "idx": 86265, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "7b8fa90d96aaf751a3256fa755d5f17e081c20f", "function_name": "build", "body_hash": "93c3ad2349c0fa2d7f5b9e5ebf2e16bc2a3ab4c7"}
{"code": "private RootBeanDefinition registerMessageBroker(Element brokerElement,\n\t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n\t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate,\n\t\t\tRuntimeBeanReference userRegistry, ParserContext context, Object source) {\n\n\t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n\t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n\n\t\tConstructorArgumentValues cavs = new ConstructorArgumentValues();\n\t\tcavs.addIndexedArgumentValue(0, inChannel);\n\t\tcavs.addIndexedArgumentValue(1, outChannel);\n\t\tcavs.addIndexedArgumentValue(2, brokerChannel);\n\n\t\tRootBeanDefinition brokerDef;\n\t\tif (simpleBrokerElem != null) {\n\t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cavs, null);\n\t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n\t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n\t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n\t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n\t\t\t}\n\t\t}\n\t\telse if (brokerRelayElem != null) {\n\t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\n\t\t\tMutablePropertyValues values = new MutablePropertyValues();\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n\t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n\t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n\t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n\t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n\t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n\t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n\t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n\t\t\t}\n\t\t\tManagedMap<String, Object> map = new ManagedMap<String, Object>();\n\t\t\tmap.setSource(source);\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n\t\t\t\tmap.put(destination, userDestHandler);\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n\t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n\t\t\t\t\t\tbrokerTemplate, destination, context, source));\n\t\t\t}\n\t\t\tif (!map.isEmpty()) {\n\t\t\t\tvalues.add(\"systemSubscriptions\", map);\n\t\t\t}\n\t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n\t\t\tbrokerDef = new RootBeanDefinition(handlerType, cavs, values);\n\t\t}\n\t\telse {\n\t\t\t// Should not happen\n\t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n\t\t}\n\t\tregisterBeanDef(brokerDef, context, source);\n\t\treturn brokerDef;\n\t}", "code_tokens": ["private", "RootBeanDefinition", "registerMessageBroker", "(", "Element", "brokerElement", ",", "RuntimeBeanReference", "inChannel", ",", "RuntimeBeanReference", "outChannel", ",", "RuntimeBeanReference", "brokerChannel", ",", "Object", "userDestHandler", ",", "RuntimeBeanReference", "brokerTemplate", ",", "RuntimeBeanReference", "userRegistry", ",", "ParserContext", "context", ",", "Object", "source", ")", "{", "Element", "simpleBrokerElem", "=", "DomUtils", ".", "getChildElementByTagName", "(", "brokerElement", ",", "\"", "simple-broker", "\"", ")", ";", "Element", "brokerRelayElem", "=", "DomUtils", ".", "getChildElementByTagName", "(", "brokerElement", ",", "\"", "stomp-broker-relay", "\"", ")", ";", "ConstructorArgumentValues", "cavs", "=", "new", "ConstructorArgumentValues", "(", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "0", ",", "inChannel", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "1", ",", "outChannel", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "2", ",", "brokerChannel", ")", ";", "RootBeanDefinition", "brokerDef", ";", "if", "(", "simpleBrokerElem", "!=", "null", ")", "{", "String", "prefix", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "prefix", "\"", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "3", ",", "Arrays", ".", "asList", "(", "StringUtils", ".", "tokenizeToStringArray", "(", "prefix", ",", "\"", ",", "\"", ")", ")", ")", ";", "brokerDef", "=", "new", "RootBeanDefinition", "(", "SimpleBrokerMessageHandler", ".", "class", ",", "cavs", ",", "null", ")", ";", "if", "(", "brokerElement", ".", "hasAttribute", "(", "\"", "path-matcher", "\"", ")", ")", "{", "String", "pathMatcherRef", "=", "brokerElement", ".", "getAttribute", "(", "\"", "path-matcher", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "pathMatcher", "\"", ",", "new", "RuntimeBeanReference", "(", "pathMatcherRef", ")", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "scheduler", "\"", ")", ")", "{", "String", "scheduler", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "scheduler", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "taskScheduler", "\"", ",", "new", "RuntimeBeanReference", "(", "scheduler", ")", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "heartbeat", "\"", ")", ")", "{", "String", "heartbeatValue", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "heartbeat", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "heartbeatValue", "\"", ",", "heartbeatValue", ")", ";", "}", "}", "else", "if", "(", "brokerRelayElem", "!=", "null", ")", "{", "String", "prefix", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "prefix", "\"", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "3", ",", "Arrays", ".", "asList", "(", "StringUtils", ".", "tokenizeToStringArray", "(", "prefix", ",", "\"", ",", "\"", ")", ")", ")", ";", "MutablePropertyValues", "values", "=", "new", "MutablePropertyValues", "(", ")", ";", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "relay-host", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "relayHost", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "relay-host", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "relay-port", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "relayPort", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "relay-port", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "client-login", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "clientLogin", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "client-login", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "client-passcode", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "clientPasscode", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "client-passcode", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "system-login", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemLogin", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "system-login", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "system-passcode", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemPasscode", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "system-passcode", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "heartbeat-send-interval", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemHeartbeatSendInterval", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "heartbeat-send-interval", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "heartbeat-receive-interval", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemHeartbeatReceiveInterval", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "heartbeat-receive-interval", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "virtual-host", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "virtualHost", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "virtual-host", "\"", ")", ")", ";", "}", "ManagedMap", "<", "String", ",", "Object", ">", "map", "=", "new", "ManagedMap", "<", "String", ",", "Object", ">", "(", ")", ";", "map", ".", "setSource", "(", "source", ")", ";", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "user-destination-broadcast", "\"", ")", ")", "{", "String", "destination", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "user-destination-broadcast", "\"", ")", ";", "map", ".", "put", "(", "destination", ",", "userDestHandler", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "user-registry-broadcast", "\"", ")", ")", "{", "String", "destination", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "user-registry-broadcast", "\"", ")", ";", "map", ".", "put", "(", "destination", ",", "registerUserRegistryMessageHandler", "(", "userRegistry", ",", "brokerTemplate", ",", "destination", ",", "context", ",", "source", ")", ")", ";", "}", "if", "(", "!", "map", ".", "isEmpty", "(", ")", ")", "{", "values", ".", "add", "(", "\"", "systemSubscriptions", "\"", ",", "map", ")", ";", "}", "Class", "<", "?", ">", "handlerType", "=", "StompBrokerRelayMessageHandler", ".", "class", ";", "brokerDef", "=", "new", "RootBeanDefinition", "(", "handlerType", ",", "cavs", ",", "values", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Neither <simple-broker> nor <stomp-broker-relay> elements found.", "\"", ")", ";", "}", "registerBeanDef", "(", "brokerDef", ",", "context", ",", "source", ")", ";", "return", "brokerDef", ";", "}"], "idx": 103436, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "246a6db1cad205ca9b6fca00c544ab7443ba202", "function_name": "registerMessageBroker", "body_hash": "37161b2375eae4bf88cfb27fe2b7970d32d0d59d"}
{"code": "private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }", "code_tokens": ["private", "void", "doDsaTest", "(", "String", "sigName", ",", "BigInteger", "s", ",", "KeyFactory", "ecKeyFact", ",", "DSAPublicKeySpec", "pubKey", ",", "DSAPrivateKeySpec", "priKey", ")", "throws", "NoSuchAlgorithmException", ",", "NoSuchProviderException", ",", "InvalidKeyException", ",", "InvalidKeySpecException", ",", "SignatureException", "{", "SecureRandom", "k", "=", "new", "TestRandomBigInteger", "(", "BigIntegers", ".", "asUnsignedByteArray", "(", "new", "BigInteger", "(", "\"", "72546832179840998877302529996971396893172522460793442785601695562409154906335", "\"", ")", ")", ")", ";", "byte", "[", "]", "M", "=", "Hex", ".", "decode", "(", "\"", "1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD", "\"", ")", ";", "Signature", "dsa", "=", "Signature", ".", "getInstance", "(", "sigName", ",", "\"", "BC", "\"", ")", ";", "dsa", ".", "initSign", "(", "ecKeyFact", ".", "generatePrivate", "(", "priKey", ")", ",", "k", ")", ";", "dsa", ".", "update", "(", "M", ",", "0", ",", "M", ".", "length", ")", ";", "byte", "[", "]", "encSig", "=", "dsa", ".", "sign", "(", ")", ";", "ASN1Sequence", "sig", "=", "ASN1Sequence", ".", "getInstance", "(", "encSig", ")", ";", "BigInteger", "r", "=", "new", "BigInteger", "(", "\"", "4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510", "\"", ",", "16", ")", ";", "BigInteger", "sigR", "=", "ASN1Integer", ".", "getInstance", "(", "sig", ".", "getObjectAt", "(", "0", ")", ")", ".", "getValue", "(", ")", ";", "if", "(", "!", "r", ".", "equals", "(", "sigR", ")", ")", "{", "fail", "(", "\"", "r component wrong.", "\"", "+", "Strings", ".", "lineSeparator", "(", ")", "+", "\"", " expecting: ", "\"", "+", "r", ".", "toString", "(", "16", ")", "+", "Strings", ".", "lineSeparator", "(", ")", "+", "\"", " got      : ", "\"", "+", "sigR", ".", "toString", "(", "16", ")", ")", ";", "}", "BigInteger", "sigS", "=", "ASN1Integer", ".", "getInstance", "(", "sig", ".", "getObjectAt", "(", "1", ")", ")", ".", "getValue", "(", ")", ";", "if", "(", "!", "s", ".", "equals", "(", "sigS", ")", ")", "{", "fail", "(", "\"", "s component wrong.", "\"", "+", "Strings", ".", "lineSeparator", "(", ")", "+", "\"", " expecting: ", "\"", "+", "s", ".", "toString", "(", "16", ")", "+", "Strings", ".", "lineSeparator", "(", ")", "+", "\"", " got      : ", "\"", "+", "sigS", ".", "toString", "(", "16", ")", ")", ";", "}", "dsa", ".", "initVerify", "(", "ecKeyFact", ".", "generatePublic", "(", "pubKey", ")", ")", ";", "dsa", ".", "update", "(", "M", ",", "0", ",", "M", ".", "length", ")", ";", "if", "(", "!", "dsa", ".", "verify", "(", "encSig", ")", ")", "{", "fail", "(", "\"", "signature fails", "\"", ")", ";", "}", "}"], "idx": 48220, "cwe": "CWE-361", "target": 1, "status": "VULNERABLE", "commit": "acaac81f96fec91ab45bd0412beaf9c3acd8defa", "function_name": "doDsaTest", "body_hash": "51e6a9353b93dfff7085d998fb36fe7b816b3b03"}
{"code": "public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=\\\\-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=\\\\-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=\\\\-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=\\\\-\\\\/\\\\:]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=\\\\-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }", "code_tokens": ["public", "String", "getUrlRegex", "(", ")", "{", "if", "(", "StringUtils", ".", "isNotEmpty", "(", "urlRegexExpression", ")", ")", "{", "return", "(", "String", ")", "parse", "(", "urlRegexExpression", ",", "String", ".", "class", ")", ";", "}", "else", "if", "(", "StringUtils", ".", "isNotEmpty", "(", "urlRegex", ")", ")", "{", "return", "urlRegex", ";", "}", "else", "{", "return", "\"", "^(https?|ftp):", "\\\\", "/", "\\\\", "/", "\"", "+", "\"", "(([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;", "\\\\", "?&=", "\\\\", "-]|%[0-9a-f]{2})+", "\"", "+", "\"", "(:([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;", "\\\\", "?&=", "\\\\", "-]|%[0-9a-f]{2})+)?", "\"", "+", "\"", "@)?(#?", "\"", "+", "\"", ")((([a-z0-9]", "\\\\", ".|[a-z0-9][a-z0-9-]*[a-z0-9]", "\\\\", ".)*", "\"", "+", "\"", "[a-z][a-z0-9-]*[a-z0-9]", "\"", "+", "\"", "|((", "\\\\", "d|[1-9]", "\\\\", "d|1", "\\\\", "d{2}|2[0-4][0-9]|25[0-5])", "\\\\", ".){3}", "\"", "+", "\"", "(", "\\\\", "d|[1-9]", "\\\\", "d|1", "\\\\", "d{2}|2[0-4][0-9]|25[0-5])", "\"", "+", "\"", ")(:", "\\\\", "d+)?", "\"", "+", "\"", ")(((", "\\\\", "/([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;:@&=", "\\\\", "-]|%[0-9a-f]{2})*)*", "\"", "+", "\"", "(", "\\\\", "?([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;:@&=", "\\\\", "-", "\\\\", "/", "\\\\", ":]|%[0-9a-f]{2})*)", "\"", "+", "\"", "?)?)?", "\"", "+", "\"", "(#([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;:@&=", "\\\\", "-]|%[0-9a-f]{2})*)?", "\"", "+", "\"", "$", "\"", ";", "}", "}"], "idx": 12210, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "3fddfb6eb562d597c935084e9e81d43ed6bcd02", "function_name": "getUrlRegex", "body_hash": "e17f3c79027f487cfabda00a945054e6c65fbdc6"}
{"code": "@Override\n    public void setupRoutes() {\n        path(controllerBasePath(), () -> {\n            before(\"\", mimeType, this::setContentType);\n            before(\"/*\", mimeType, this::setContentType);\n            before(\"\", mimeType, this::verifyContentType);\n            before(\"/*\", mimeType, this::verifyContentType);\n\n            // change the line below to enable appropriate security\n            before(\"\", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);\n\n            get(\"\", mimeType, this::show);\n\n            post(\"\", mimeType, this::createOrUpdate);\n            put(\"\", mimeType, this::createOrUpdate);\n\n            delete(\"\", mimeType, this::deleteBackupConfig);\n        });\n    }", "code_tokens": ["@", "Override", "public", "void", "setupRoutes", "(", ")", "{", "path", "(", "controllerBasePath", "(", ")", ",", "(", ")", "->", "{", "before", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "setContentType", ")", ";", "before", "(", "\"", "/*", "\"", ",", "mimeType", ",", "this", "::", "setContentType", ")", ";", "before", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "verifyContentType", ")", ";", "before", "(", "\"", "/*", "\"", ",", "mimeType", ",", "this", "::", "verifyContentType", ")", ";", "before", "(", "\"", "\"", ",", "mimeType", ",", "this", ".", "apiAuthenticationHelper", "::", "checkAdminUserAnd403", ")", ";", "get", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "show", ")", ";", "post", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "createOrUpdate", ")", ";", "put", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "createOrUpdate", ")", ";", "delete", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "deleteBackupConfig", ")", ";", "}", ")", ";", "}"], "idx": 43965, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "7d0baab0d361c377af84994f95ba76c280048548", "function_name": "setupRoutes", "body_hash": "f18ca705f62df59ae2dab05c7a10f10c4bb09c66"}
{"code": "protected void parseInputStream(InputStream stream) {\n\t\tSAXParserFactory pf = SAXParserFactory.newInstance();\n\t\ttry {\n\t\t\tSAXParser parser = pf.newSAXParser();\n\t\t\tparser.parse(stream, new SAXHandler());\n\t\t} catch (ParserConfigurationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (SAXException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Build the source and sink lists\n\t\tbuildSourceSinkLists();\n\t}", "code_tokens": ["protected", "void", "parseInputStream", "(", "InputStream", "stream", ")", "{", "SAXParserFactory", "pf", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "try", "{", "SAXParser", "parser", "=", "pf", ".", "newSAXParser", "(", ")", ";", "parser", ".", "parse", "(", "stream", ",", "new", "SAXHandler", "(", ")", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "buildSourceSinkLists", "(", ")", ";", "}"], "idx": 69032, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "01fcfcc475d1e5a677249cd94763f9e824104097", "function_name": "parseInputStream", "body_hash": "576565f2f106a140a61e1e92d6b254be1d7ebe01"}
{"code": "@Override\n        public void doFilter(final ServletRequest req, final ServletResponse resp, final FilterChain filterChain)\n                throws IOException, ServletException {\n\n            // set frame options accordingly\n            final HttpServletResponse response = (HttpServletResponse) resp;\n            response.setHeader(FRAME_OPTIONS, SAME_ORIGIN);\n\n            filterChain.doFilter(req, resp);\n        }", "code_tokens": ["@", "Override", "public", "void", "doFilter", "(", "final", "ServletRequest", "req", ",", "final", "ServletResponse", "resp", ",", "final", "FilterChain", "filterChain", ")", "throws", "IOException", ",", "ServletException", "{", "final", "HttpServletResponse", "response", "=", "(", "HttpServletResponse", ")", "resp", ";", "response", ".", "setHeader", "(", "FRAME_OPTIONS", ",", "SAME_ORIGIN", ")", ";", "filterChain", ".", "doFilter", "(", "req", ",", "resp", ")", ";", "}"], "idx": 28, "cwe": "CWE-1021", "target": 0, "status": "FIXED", "commit": "dbf259508c2b8e176d8cb837177aaadbf44f0670", "function_name": "doFilter", "body_hash": "6b50e4c1beda3030c481a273ca1be17383f5c8c1"}
{"code": "public User getUser() {\n            return user;\n        }", "code_tokens": ["public", "User", "getUser", "(", ")", "{", "return", "user", ";", "}"], "idx": 13600, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "3cd946cbef82c6da5ccccf3890d0ae4e091c4265", "function_name": "getUser", "body_hash": "7be3b17f394781772152de73ac50464cce0da957"}
{"code": "private void postWorkDirectory() {\n\n        // Acquire (or calculate) the work directory path\n        String workDir = getWorkDir();\n        if (workDir == null || workDir.length() == 0) {\n\n            // Retrieve our parent (normally a host) name\n            String hostName = null;\n            String engineName = null;\n            String hostWorkDir = null;\n            Container parentHost = getParent();\n            if (parentHost != null) {\n                hostName = parentHost.getName();\n                if (parentHost instanceof StandardHost) {\n                    hostWorkDir = ((StandardHost)parentHost).getWorkDir();\n                }\n                Container parentEngine = parentHost.getParent();\n                if (parentEngine != null) {\n                   engineName = parentEngine.getName();\n                }\n            }\n            if ((hostName == null) || (hostName.length() < 1))\n                hostName = \"_\";\n            if ((engineName == null) || (engineName.length() < 1))\n                engineName = \"_\";\n\n            String temp = getPath();\n            if (temp.startsWith(\"/\"))\n                temp = temp.substring(1);\n            temp = temp.replace('/', '_');\n            temp = temp.replace('\\\\', '_');\n            if (temp.length() < 1)\n                temp = \"_\";\n            if (hostWorkDir != null ) {\n                workDir = hostWorkDir + File.separator + temp;\n            } else {\n                workDir = \"work\" + File.separator + engineName +\n                    File.separator + hostName + File.separator + temp;\n            }\n            setWorkDir(workDir);\n        }\n\n        // Create this directory if necessary\n        File dir = new File(workDir);\n        if (!dir.isAbsolute()) {\n            File catalinaHome = engineBase();\n            String catalinaHomePath = null;\n            try {\n                catalinaHomePath = catalinaHome.getCanonicalPath();\n                dir = new File(catalinaHomePath, workDir);\n            } catch (IOException e) {\n            }\n        }\n        dir.mkdirs();\n\n        // Set the appropriate servlet context attribute\n        if (context == null) {\n            getServletContext();\n        }\n        context.setAttribute(ServletContext.TEMPDIR, dir);\n        context.setAttributeReadOnly(ServletContext.TEMPDIR);\n    }", "code_tokens": ["private", "void", "postWorkDirectory", "(", ")", "{", "String", "workDir", "=", "getWorkDir", "(", ")", ";", "if", "(", "workDir", "==", "null", "||", "workDir", ".", "length", "(", ")", "==", "0", ")", "{", "String", "hostName", "=", "null", ";", "String", "engineName", "=", "null", ";", "String", "hostWorkDir", "=", "null", ";", "Container", "parentHost", "=", "getParent", "(", ")", ";", "if", "(", "parentHost", "!=", "null", ")", "{", "hostName", "=", "parentHost", ".", "getName", "(", ")", ";", "if", "(", "parentHost", "instanceof", "StandardHost", ")", "{", "hostWorkDir", "=", "(", "(", "StandardHost", ")", "parentHost", ")", ".", "getWorkDir", "(", ")", ";", "}", "Container", "parentEngine", "=", "parentHost", ".", "getParent", "(", ")", ";", "if", "(", "parentEngine", "!=", "null", ")", "{", "engineName", "=", "parentEngine", ".", "getName", "(", ")", ";", "}", "}", "if", "(", "(", "hostName", "==", "null", ")", "||", "(", "hostName", ".", "length", "(", ")", "<", "1", ")", ")", "hostName", "=", "\"", "_", "\"", ";", "if", "(", "(", "engineName", "==", "null", ")", "||", "(", "engineName", ".", "length", "(", ")", "<", "1", ")", ")", "engineName", "=", "\"", "_", "\"", ";", "String", "temp", "=", "getPath", "(", ")", ";", "if", "(", "temp", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "temp", "=", "temp", ".", "substring", "(", "1", ")", ";", "temp", "=", "temp", ".", "replace", "(", "'/'", ",", "'_'", ")", ";", "temp", "=", "temp", ".", "replace", "(", "'\\\\'", ",", "'_'", ")", ";", "if", "(", "temp", ".", "length", "(", ")", "<", "1", ")", "temp", "=", "\"", "_", "\"", ";", "if", "(", "hostWorkDir", "!=", "null", ")", "{", "workDir", "=", "hostWorkDir", "+", "File", ".", "separator", "+", "temp", ";", "}", "else", "{", "workDir", "=", "\"", "work", "\"", "+", "File", ".", "separator", "+", "engineName", "+", "File", ".", "separator", "+", "hostName", "+", "File", ".", "separator", "+", "temp", ";", "}", "setWorkDir", "(", "workDir", ")", ";", "}", "File", "dir", "=", "new", "File", "(", "workDir", ")", ";", "if", "(", "!", "dir", ".", "isAbsolute", "(", ")", ")", "{", "File", "catalinaHome", "=", "engineBase", "(", ")", ";", "String", "catalinaHomePath", "=", "null", ";", "try", "{", "catalinaHomePath", "=", "catalinaHome", ".", "getCanonicalPath", "(", ")", ";", "dir", "=", "new", "File", "(", "catalinaHomePath", ",", "workDir", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "}", "dir", ".", "mkdirs", "(", ")", ";", "if", "(", "context", "==", "null", ")", "{", "getServletContext", "(", ")", ";", "}", "context", ".", "setAttribute", "(", "ServletContext", ".", "TEMPDIR", ",", "dir", ")", ";", "context", ".", "setAttributeReadOnly", "(", "ServletContext", ".", "TEMPDIR", ")", ";", "}"], "idx": 113206, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "a697f7b52c4e3aea0c6763b33d413b54a518e883", "function_name": "postWorkDirectory", "body_hash": "fda271380f9ce19fc79396fa0c232d60fd66e44e"}
{"code": "public static String applySorting(String query, Sort sort, String alias) {\n\n\t\tAssert.hasText(query);\n\n\t\tif (null == sort || !sort.iterator().hasNext()) {\n\t\t\treturn query;\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder(query);\n\n\t\tif (!ORDER_BY.matcher(query).matches()) {\n\t\t\tbuilder.append(\" order by \");\n\t\t} else {\n\t\t\tbuilder.append(\", \");\n\t\t}\n\n\t\tSet<String> aliases = getOuterJoinAliases(query);\n\n\t\tfor (Order order : sort) {\n\t\t\tbuilder.append(getOrderClause(aliases, alias, order)).append(\", \");\n\t\t}\n\n\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\treturn builder.toString();\n\t}", "code_tokens": ["public", "static", "String", "applySorting", "(", "String", "query", ",", "Sort", "sort", ",", "String", "alias", ")", "{", "Assert", ".", "hasText", "(", "query", ")", ";", "if", "(", "null", "==", "sort", "||", "!", "sort", ".", "iterator", "(", ")", ".", "hasNext", "(", ")", ")", "{", "return", "query", ";", "}", "StringBuilder", "builder", "=", "new", "StringBuilder", "(", "query", ")", ";", "if", "(", "!", "ORDER_BY", ".", "matcher", "(", "query", ")", ".", "matches", "(", ")", ")", "{", "builder", ".", "append", "(", "\"", " order by ", "\"", ")", ";", "}", "else", "{", "builder", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "Set", "<", "String", ">", "aliases", "=", "getOuterJoinAliases", "(", "query", ")", ";", "for", "(", "Order", "order", ":", "sort", ")", "{", "builder", ".", "append", "(", "getOrderClause", "(", "aliases", ",", "alias", ",", "order", ")", ")", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "builder", ".", "delete", "(", "builder", ".", "length", "(", ")", "-", "2", ",", "builder", ".", "length", "(", ")", ")", ";", "return", "builder", ".", "toString", "(", ")", ";", "}"], "idx": 92661, "cwe": "CWE-89", "target": 1, "status": "VULNERABLE", "commit": "b8e7fecccc7dc8edcabb4704656a7abe6352c08f", "function_name": "applySorting", "body_hash": "1e66a8f393945dd42b50ba0bce4c255e86305fff"}
{"code": "private static void writeString(ByteBuffer buffer, String string) {\n        int length = string.length();\n        for (int charIndex = 0; charIndex < length; charIndex++) {\n            char c = string.charAt(charIndex);\n            if(c != '\\r' && c != '\\n') {\n                buffer.put((byte) c);\n            } else {\n                buffer.put((byte) ' ');\n            }\n        }\n    }", "code_tokens": ["private", "static", "void", "writeString", "(", "ByteBuffer", "buffer", ",", "String", "string", ")", "{", "int", "length", "=", "string", ".", "length", "(", ")", ";", "for", "(", "int", "charIndex", "=", "0", ";", "charIndex", "<", "length", ";", "charIndex", "++", ")", "{", "char", "c", "=", "string", ".", "charAt", "(", "charIndex", ")", ";", "if", "(", "c", "!=", "'\\r'", "&&", "c", "!=", "'\\n'", ")", "{", "buffer", ".", "put", "(", "(", "byte", ")", "c", ")", ";", "}", "else", "{", "buffer", ".", "put", "(", "(", "byte", ")", "' '", ")", ";", "}", "}", "}"], "idx": 34, "cwe": "CWE-113", "target": 1, "status": "VULNERABLE", "commit": "85d4478e598105fe94ac152d3e11e388374e8b8", "function_name": "writeString", "body_hash": "2f3f5d1dedf8f65d0ede4e176c85e7f2dd313235"}
{"code": "private static String parseSoapMethodName(InputStream stream, String charEncoding) {\r\n\t\ttry {\r\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\r\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\r\n\t\t\tfactory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // disable DTDs entirely for that factory\r\n\t\t\tfactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); // disable external entities\r\n\t\t\tfinal XMLStreamReader xmlReader;\r\n\t\t\tif (charEncoding != null) {\r\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\r\n\t\t\t} else {\r\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\r\n\t\t\t}\r\n\r\n\t\t\t//best-effort parsing\r\n\r\n\t\t\t//start document, go to first tag\r\n\t\t\txmlReader.nextTag();\r\n\r\n\t\t\t//expect first tag to be \"Envelope\"\r\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\r\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\r\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\r\n\t\t\t\treturn null; //failed\r\n\t\t\t}\r\n\r\n\t\t\t//scan for body tag\r\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\r\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\r\n\t\t\t\treturn null; //failed\r\n\t\t\t}\r\n\r\n\t\t\txmlReader.nextTag();\r\n\r\n\t\t\t//tag is method name\r\n\t\t\treturn \".\" + xmlReader.getLocalName();\r\n\t\t} catch (final XMLStreamException e) {\r\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\r\n\t\t\t//failed\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}", "code_tokens": ["private", "static", "String", "parseSoapMethodName", "(", "InputStream", "stream", ",", "String", "charEncoding", ")", "{", "try", "{", "final", "XMLInputFactory", "factory", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "SUPPORT_DTD", ",", "false", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "IS_SUPPORTING_EXTERNAL_ENTITIES", ",", "false", ")", ";", "final", "XMLStreamReader", "xmlReader", ";", "if", "(", "charEncoding", "!=", "null", ")", "{", "xmlReader", "=", "factory", ".", "createXMLStreamReader", "(", "stream", ",", "charEncoding", ")", ";", "}", "else", "{", "xmlReader", "=", "factory", ".", "createXMLStreamReader", "(", "stream", ")", ";", "}", "xmlReader", ".", "nextTag", "(", ")", ";", "if", "(", "!", "\"", "Envelope", "\"", ".", "equals", "(", "xmlReader", ".", "getLocalName", "(", ")", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Unexpected first tag of SOAP request: '", "\"", "+", "xmlReader", ".", "getLocalName", "(", ")", "+", "\"", "' (expected 'Envelope')", "\"", ")", ";", "return", "null", ";", "}", "if", "(", "!", "scanForChildTag", "(", "xmlReader", ",", "\"", "Body", "\"", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Unable to find SOAP 'Body' tag", "\"", ")", ";", "return", "null", ";", "}", "xmlReader", ".", "nextTag", "(", ")", ";", "return", "\"", ".", "\"", "+", "xmlReader", ".", "getLocalName", "(", ")", ";", "}", "catch", "(", "final", "XMLStreamException", "e", ")", "{", "LOG", ".", "debug", "(", "\"", "Unable to parse SOAP request", "\"", ",", "e", ")", ";", "return", "null", ";", "}", "}"], "idx": 67515, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "ef111822562d0b9365bd3e671a75b65bd0613353", "function_name": "parseSoapMethodName", "body_hash": "bcaaf6f147d4e2ab9dc69adbb1b2e17db8f7d2f3"}
{"code": "public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getParameterTypes().length == 0)\n            return null;\n\n        if (!ObjectName.class.isAssignableFrom(method.getParameterTypes()[0]))\n            return null;\n\n        MBeanServer mbs = (MBeanServer) proxy;\n        if (mbs != null && Proxy.getInvocationHandler(mbs) instanceof MBeanInvocationHandler) {\n            mbs = ((MBeanInvocationHandler) Proxy.getInvocationHandler(mbs)).getDelegate();\n        }\n        if (mbs instanceof EventAdminMBeanServerWrapper) {\n            mbs = ((EventAdminMBeanServerWrapper) mbs).getDelegate();\n        }\n\n        ObjectName objectName = (ObjectName) args[0];\n        if (\"getAttribute\".equals(method.getName())) {\n            handleGetAttribute(mbs, objectName, (String) args[1]);\n        } else if (\"getAttributes\".equals(method.getName())) {\n            handleGetAttributes(mbs, objectName, (String[]) args[1]);\n        } else if (\"setAttribute\".equals(method.getName())) {\n            handleSetAttribute(mbs, objectName, (Attribute) args[1]);\n        } else if (\"setAttributes\".equals(method.getName())) {\n            handleSetAttributes(mbs, objectName, (AttributeList) args[1]);\n        } else if (\"invoke\".equals(method.getName())) {\n            handleInvoke(mbs, objectName, (String) args[1], (Object[]) args[2], (String[]) args[3]);\n        }\n\n        return null;\n    }", "code_tokens": ["public", "Object", "invoke", "(", "Object", "proxy", ",", "Method", "method", ",", "Object", "[", "]", "args", ")", "throws", "Throwable", "{", "if", "(", "method", ".", "getParameterTypes", "(", ")", ".", "length", "==", "0", ")", "return", "null", ";", "if", "(", "!", "ObjectName", ".", "class", ".", "isAssignableFrom", "(", "method", ".", "getParameterTypes", "(", ")", "[", "0", "]", ")", ")", "return", "null", ";", "MBeanServer", "mbs", "=", "(", "MBeanServer", ")", "proxy", ";", "if", "(", "mbs", "!=", "null", "&&", "Proxy", ".", "getInvocationHandler", "(", "mbs", ")", "instanceof", "MBeanInvocationHandler", ")", "{", "mbs", "=", "(", "(", "MBeanInvocationHandler", ")", "Proxy", ".", "getInvocationHandler", "(", "mbs", ")", ")", ".", "getDelegate", "(", ")", ";", "}", "if", "(", "mbs", "instanceof", "EventAdminMBeanServerWrapper", ")", "{", "mbs", "=", "(", "(", "EventAdminMBeanServerWrapper", ")", "mbs", ")", ".", "getDelegate", "(", ")", ";", "}", "ObjectName", "objectName", "=", "(", "ObjectName", ")", "args", "[", "0", "]", ";", "if", "(", "\"", "getAttribute", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleGetAttribute", "(", "mbs", ",", "objectName", ",", "(", "String", ")", "args", "[", "1", "]", ")", ";", "}", "else", "if", "(", "\"", "getAttributes", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleGetAttributes", "(", "mbs", ",", "objectName", ",", "(", "String", "[", "]", ")", "args", "[", "1", "]", ")", ";", "}", "else", "if", "(", "\"", "setAttribute", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleSetAttribute", "(", "mbs", ",", "objectName", ",", "(", "Attribute", ")", "args", "[", "1", "]", ")", ";", "}", "else", "if", "(", "\"", "setAttributes", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleSetAttributes", "(", "mbs", ",", "objectName", ",", "(", "AttributeList", ")", "args", "[", "1", "]", ")", ";", "}", "else", "if", "(", "\"", "invoke", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleInvoke", "(", "mbs", ",", "objectName", ",", "(", "String", ")", "args", "[", "1", "]", ",", "(", "Object", "[", "]", ")", "args", "[", "2", "]", ",", "(", "String", "[", "]", ")", "args", "[", "3", "]", ")", ";", "}", "return", "null", ";", "}"], "idx": 94394, "cwe": "CWE-918", "target": 0, "status": "FIXED", "commit": "3e4c4bed2d08e81ca5961ab5fcadab23470db1c9", "function_name": "invoke", "body_hash": "0fff818e2bf759f810c5fca449e04e68b8ef0086"}
{"code": "public HttpResponse doPostCredential(@QueryParameter String username, @QueryParameter String password) throws IOException, ServletException {\n            this.username = username;\n            this.password = Secret.fromString(password);\n            save();\n            return HttpResponses.redirectTo(\"credentialOK\");\n        }", "code_tokens": ["public", "HttpResponse", "doPostCredential", "(", "@", "QueryParameter", "String", "username", ",", "@", "QueryParameter", "String", "password", ")", "throws", "IOException", ",", "ServletException", "{", "this", ".", "username", "=", "username", ";", "this", ".", "password", "=", "Secret", ".", "fromString", "(", "password", ")", ";", "save", "(", ")", ";", "return", "HttpResponses", ".", "redirectTo", "(", "\"", "credentialOK", "\"", ")", ";", "}"], "idx": 72676, "cwe": "CWE-732", "target": 1, "status": "VULNERABLE", "commit": "b0ed9669bc00dbccf1be6896bb527b4cf2e7687d", "function_name": "doPostCredential", "body_hash": "649848634de43cabdeae34281e13ba05e42eb840"}
{"code": "@Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            boolean allowHalfClosedRemote = false;\n            boolean isTrailers = false;\n            if (stream == null && !connection.streamMayHaveExisted(streamId)) {\n                stream = connection.remote().createStream(streamId, endOfStream);\n                // Allow the state to be HALF_CLOSE_REMOTE if we're creating it in that state.\n                allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;\n            } else if (stream != null) {\n                isTrailers = stream.isHeadersReceived();\n            }\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n                return;\n            }\n\n            boolean isInformational = !connection.isServer() &&\n                    HttpStatusClass.valueOf(headers.status()) == INFORMATIONAL;\n            if ((isInformational || !endOfStream) && stream.isHeadersReceived() || stream.isTrailersReceived()) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                                  \"Stream %d received too many headers EOS: %s state: %s\",\n                                  streamId, endOfStream, stream.state());\n            }\n\n            switch (stream.state()) {\n                case RESERVED_REMOTE:\n                    stream.open(endOfStream);\n                    break;\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    // Allowed to receive headers in these states.\n                    break;\n                case HALF_CLOSED_REMOTE:\n                    if (!allowHalfClosedRemote) {\n                        throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                                stream.id(), stream.state());\n                    }\n                    break;\n                case CLOSED:\n                    throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                            stream.id(), stream.state());\n                default:\n                    // Connection error.\n                    throw connectionError(PROTOCOL_ERROR, \"Stream %d in unexpected state: %s\", stream.id(),\n                            stream.state());\n            }\n\n            if (!isTrailers) {\n                // extract the content-length header\n                List<? extends CharSequence> contentLength = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n                if (contentLength != null && !contentLength.isEmpty()) {\n                    try {\n                        long cLength = HttpUtil.normalizeAndGetContentLength(contentLength, false, true);\n                        if (cLength != -1) {\n                            headers.setLong(HttpHeaderNames.CONTENT_LENGTH, cLength);\n                            stream.setProperty(contentLengthKey, new ContentLength(cLength));\n                        }\n                    } catch (IllegalArgumentException e) {\n                        throw streamError(stream.id(), PROTOCOL_ERROR, e,\n                                \"Multiple content-length headers received\");\n                    }\n                }\n            }\n\n            stream.headersReceived(isInformational);\n            verifyContentLength(stream, 0, endOfStream);\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n            listener.onHeadersRead(ctx, streamId, headers, streamDependency,\n                    weight, exclusive, padding, endOfStream);\n            // If the headers completes this stream, close it.\n            if (endOfStream) {\n                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n            }\n        }", "code_tokens": ["@", "Override", "public", "void", "onHeadersRead", "(", "ChannelHandlerContext", "ctx", ",", "int", "streamId", ",", "Http2Headers", "headers", ",", "int", "streamDependency", ",", "short", "weight", ",", "boolean", "exclusive", ",", "int", "padding", ",", "boolean", "endOfStream", ")", "throws", "Http2Exception", "{", "Http2Stream", "stream", "=", "connection", ".", "stream", "(", "streamId", ")", ";", "boolean", "allowHalfClosedRemote", "=", "false", ";", "boolean", "isTrailers", "=", "false", ";", "if", "(", "stream", "==", "null", "&&", "!", "connection", ".", "streamMayHaveExisted", "(", "streamId", ")", ")", "{", "stream", "=", "connection", ".", "remote", "(", ")", ".", "createStream", "(", "streamId", ",", "endOfStream", ")", ";", "allowHalfClosedRemote", "=", "stream", ".", "state", "(", ")", "==", "HALF_CLOSED_REMOTE", ";", "}", "else", "if", "(", "stream", "!=", "null", ")", "{", "isTrailers", "=", "stream", ".", "isHeadersReceived", "(", ")", ";", "}", "if", "(", "shouldIgnoreHeadersOrDataFrame", "(", "ctx", ",", "streamId", ",", "stream", ",", "\"", "HEADERS", "\"", ")", ")", "{", "return", ";", "}", "boolean", "isInformational", "=", "!", "connection", ".", "isServer", "(", ")", "&&", "HttpStatusClass", ".", "valueOf", "(", "headers", ".", "status", "(", ")", ")", "==", "INFORMATIONAL", ";", "if", "(", "(", "isInformational", "||", "!", "endOfStream", ")", "&&", "stream", ".", "isHeadersReceived", "(", ")", "||", "stream", ".", "isTrailersReceived", "(", ")", ")", "{", "throw", "streamError", "(", "streamId", ",", "PROTOCOL_ERROR", ",", "\"", "Stream %d received too many headers EOS: %s state: %s", "\"", ",", "streamId", ",", "endOfStream", ",", "stream", ".", "state", "(", ")", ")", ";", "}", "switch", "(", "stream", ".", "state", "(", ")", ")", "{", "case", "RESERVED_REMOTE", ":", "stream", ".", "open", "(", "endOfStream", ")", ";", "break", ";", "case", "OPEN", ":", "case", "HALF_CLOSED_LOCAL", ":", "break", ";", "case", "HALF_CLOSED_REMOTE", ":", "if", "(", "!", "allowHalfClosedRemote", ")", "{", "throw", "streamError", "(", "stream", ".", "id", "(", ")", ",", "STREAM_CLOSED", ",", "\"", "Stream %d in unexpected state: %s", "\"", ",", "stream", ".", "id", "(", ")", ",", "stream", ".", "state", "(", ")", ")", ";", "}", "break", ";", "case", "CLOSED", ":", "throw", "streamError", "(", "stream", ".", "id", "(", ")", ",", "STREAM_CLOSED", ",", "\"", "Stream %d in unexpected state: %s", "\"", ",", "stream", ".", "id", "(", ")", ",", "stream", ".", "state", "(", ")", ")", ";", "default", ":", "throw", "connectionError", "(", "PROTOCOL_ERROR", ",", "\"", "Stream %d in unexpected state: %s", "\"", ",", "stream", ".", "id", "(", ")", ",", "stream", ".", "state", "(", ")", ")", ";", "}", "if", "(", "!", "isTrailers", ")", "{", "List", "<", "?", "extends", "CharSequence", ">", "contentLength", "=", "headers", ".", "getAll", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ")", ";", "if", "(", "contentLength", "!=", "null", "&&", "!", "contentLength", ".", "isEmpty", "(", ")", ")", "{", "try", "{", "long", "cLength", "=", "HttpUtil", ".", "normalizeAndGetContentLength", "(", "contentLength", ",", "false", ",", "true", ")", ";", "if", "(", "cLength", "!=", "-", "1", ")", "{", "headers", ".", "setLong", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ",", "cLength", ")", ";", "stream", ".", "setProperty", "(", "contentLengthKey", ",", "new", "ContentLength", "(", "cLength", ")", ")", ";", "}", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "throw", "streamError", "(", "stream", ".", "id", "(", ")", ",", "PROTOCOL_ERROR", ",", "e", ",", "\"", "Multiple content-length headers received", "\"", ")", ";", "}", "}", "}", "stream", ".", "headersReceived", "(", "isInformational", ")", ";", "verifyContentLength", "(", "stream", ",", "0", ",", "endOfStream", ")", ";", "encoder", ".", "flowController", "(", ")", ".", "updateDependencyTree", "(", "streamId", ",", "streamDependency", ",", "weight", ",", "exclusive", ")", ";", "listener", ".", "onHeadersRead", "(", "ctx", ",", "streamId", ",", "headers", ",", "streamDependency", ",", "weight", ",", "exclusive", ",", "padding", ",", "endOfStream", ")", ";", "if", "(", "endOfStream", ")", "{", "lifecycleManager", ".", "closeStreamRemote", "(", "stream", ",", "ctx", ".", "newSucceededFuture", "(", ")", ")", ";", "}", "}"], "idx": 54166, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "b0fa4d5aab4215f3c22ce6123dd8dd5f38dc0432", "function_name": "onHeadersRead", "body_hash": "e990c9c332579cc1bf33e2d153cff3fa7250c472"}
{"code": "public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                //unreg(sk,attachment);//only do this if we do process send file on a separate thread\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n                \n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                        return false;\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n            }\n            return true;\n        }", "code_tokens": ["public", "boolean", "processSendfile", "(", "SelectionKey", "sk", ",", "KeyAttachment", "attachment", ",", "boolean", "reg", ",", "boolean", "event", ")", "{", "NioChannel", "sc", "=", "null", ";", "try", "{", "SendfileData", "sd", "=", "attachment", ".", "getSendfileData", "(", ")", ";", "if", "(", "sd", ".", "fchannel", "==", "null", ")", "{", "File", "f", "=", "new", "File", "(", "sd", ".", "fileName", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "sd", ".", "fchannel", "=", "new", "FileInputStream", "(", "f", ")", ".", "getChannel", "(", ")", ";", "}", "sc", "=", "attachment", ".", "getChannel", "(", ")", ";", "sc", ".", "setSendFile", "(", "true", ")", ";", "WritableByteChannel", "wc", "=", "(", "(", "sc", "instanceof", "SecureNioChannel", ")", "?", "sc", ":", "sc", ".", "getIOChannel", "(", ")", ")", ";", "if", "(", "sc", ".", "getOutboundRemaining", "(", ")", ">", "0", ")", "{", "if", "(", "sc", ".", "flushOutbound", "(", ")", ")", "{", "attachment", ".", "access", "(", ")", ";", "}", "}", "else", "{", "long", "written", "=", "sd", ".", "fchannel", ".", "transferTo", "(", "sd", ".", "pos", ",", "sd", ".", "length", ",", "wc", ")", ";", "if", "(", "written", ">", "0", ")", "{", "sd", ".", "pos", "+=", "written", ";", "sd", ".", "length", "-=", "written", ";", "attachment", ".", "access", "(", ")", ";", "}", "else", "{", "if", "(", "sd", ".", "fchannel", ".", "size", "(", ")", "<=", "sd", ".", "pos", ")", "{", "throw", "new", "IOException", "(", "\"", "Sendfile configured to ", "\"", "+", "\"", "send more data than was available", "\"", ")", ";", "}", "}", "}", "if", "(", "sd", ".", "length", "<=", "0", "&&", "sc", ".", "getOutboundRemaining", "(", ")", "<=", "0", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file complete for:", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "attachment", ".", "setSendfileData", "(", "null", ")", ";", "try", "{", "sd", ".", "fchannel", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "}", "if", "(", "sd", ".", "keepAlive", ")", "{", "if", "(", "reg", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection is keep alive, registering back for OP_READ", "\"", ")", ";", "}", "if", "(", "event", ")", "{", "this", ".", "add", "(", "attachment", ".", "getChannel", "(", ")", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "}", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file connection is being closed", "\"", ")", ";", "}", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "STOP", ",", "false", ")", ";", "return", "false", ";", "}", "}", "else", "if", "(", "attachment", ".", "interestOps", "(", ")", "==", "0", "&&", "reg", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "OP_WRITE for sendilfe:", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "event", ")", "{", "add", "(", "attachment", ".", "getChannel", "(", ")", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "}", "}", "catch", "(", "IOException", "x", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Unable to complete sendfile request:", "\"", ",", "x", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"", "\"", ",", "t", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "finally", "{", "if", "(", "sc", "!=", "null", ")", "sc", ".", "setSendFile", "(", "false", ")", ";", "}", "return", "true", ";", "}"], "idx": 8251, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "48dded4ab1209a030770ab67a789d3b2528b6329", "function_name": "processSendfile", "body_hash": "2d40ad4449f0afef2e741585dc71c43d9441c1cc"}
{"code": "public boolean matchesPassword(String password) {\n        return  getApiTokenInsecure().equals(password);\n    }", "code_tokens": ["public", "boolean", "matchesPassword", "(", "String", "password", ")", "{", "return", "getApiTokenInsecure", "(", ")", ".", "equals", "(", "password", ")", ";", "}"], "idx": 14794, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "79e0b64322a6b15e0b80ac6511c9aa74383642be", "function_name": "matchesPassword", "body_hash": "c8a5b5e5d51f5ed9c9e023a1dbdb020ebca2f025"}
{"code": "private byte[] decryptBlock(\n        byte[] in_enc,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] M = null, K = null, K1 = null, K2 = null;\n        int len;\n\n        // Ensure that the length of the input is greater than the MAC in bytes\n        if (inLen < V.length + mac.getMacSize())\n        {\n            throw new InvalidCipherTextException(\"Length of input must be greater than the MAC and V combined\");\n        }\n\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen - V.length - mac.getMacSize()];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, K1.length, K2, 0, K2.length);\n            }\n\n            M = new byte[K1.length];\n\n            for (int i = 0; i != K1.length; i++)\n            {\n                M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);\n            }\n\n            len = K1.length;\n        }\n        else\n        {\n            // Block cipher mode.        \n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If IV provide use it to initialize the cipher\n            if (IV != null)\n            {\n                cipher.init(false, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(false, new KeyParameter(K1));    \n            }\n\n            M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];\n            len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);\n            len += cipher.doFinal(M, len);\n        }\n\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n        // Verify the MAC.\n        int end = inOff + inLen;\n        byte[] T1 = Arrays.copyOfRange(in_enc, end - mac.getMacSize(), end);\n\n        byte[] T2 = new byte[T1.length];\n        mac.init(new KeyParameter(K2));\n        mac.update(in_enc, inOff + V.length, inLen - V.length - T2.length);\n\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T2, 0);\n\n        if (!Arrays.constantTimeAreEqual(T1, T2))\n        {\n            throw new InvalidCipherTextException(\"Invalid MAC.\");\n        }\n\n        // Output the message.\n        return Arrays.copyOfRange(M, 0, len);\n    }", "code_tokens": ["private", "byte", "[", "]", "decryptBlock", "(", "byte", "[", "]", "in_enc", ",", "int", "inOff", ",", "int", "inLen", ")", "throws", "InvalidCipherTextException", "{", "byte", "[", "]", "M", "=", "null", ",", "K", "=", "null", ",", "K1", "=", "null", ",", "K2", "=", "null", ";", "int", "len", ";", "if", "(", "inLen", "<", "V", ".", "length", "+", "mac", ".", "getMacSize", "(", ")", ")", "{", "throw", "new", "InvalidCipherTextException", "(", "\"", "Length of input must be greater than the MAC and V combined", "\"", ")", ";", "}", "if", "(", "cipher", "==", "null", ")", "{", "K1", "=", "new", "byte", "[", "inLen", "-", "V", ".", "length", "-", "mac", ".", "getMacSize", "(", ")", "]", ";", "K2", "=", "new", "byte", "[", "param", ".", "getMacKeySize", "(", ")", "/", "8", "]", ";", "K", "=", "new", "byte", "[", "K1", ".", "length", "+", "K2", ".", "length", "]", ";", "kdf", ".", "generateBytes", "(", "K", ",", "0", ",", "K", ".", "length", ")", ";", "if", "(", "V", ".", "length", "!=", "0", ")", "{", "System", ".", "arraycopy", "(", "K", ",", "0", ",", "K2", ",", "0", ",", "K2", ".", "length", ")", ";", "System", ".", "arraycopy", "(", "K", ",", "K2", ".", "length", ",", "K1", ",", "0", ",", "K1", ".", "length", ")", ";", "}", "else", "{", "System", ".", "arraycopy", "(", "K", ",", "0", ",", "K1", ",", "0", ",", "K1", ".", "length", ")", ";", "System", ".", "arraycopy", "(", "K", ",", "K1", ".", "length", ",", "K2", ",", "0", ",", "K2", ".", "length", ")", ";", "}", "M", "=", "new", "byte", "[", "K1", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "K1", ".", "length", ";", "i", "++", ")", "{", "M", "[", "i", "]", "=", "(", "byte", ")", "(", "in_enc", "[", "inOff", "+", "V", ".", "length", "+", "i", "]", "^", "K1", "[", "i", "]", ")", ";", "}", "len", "=", "K1", ".", "length", ";", "}", "else", "{", "K1", "=", "new", "byte", "[", "(", "(", "IESWithCipherParameters", ")", "param", ")", ".", "getCipherKeySize", "(", ")", "/", "8", "]", ";", "K2", "=", "new", "byte", "[", "param", ".", "getMacKeySize", "(", ")", "/", "8", "]", ";", "K", "=", "new", "byte", "[", "K1", ".", "length", "+", "K2", ".", "length", "]", ";", "kdf", ".", "generateBytes", "(", "K", ",", "0", ",", "K", ".", "length", ")", ";", "System", ".", "arraycopy", "(", "K", ",", "0", ",", "K1", ",", "0", ",", "K1", ".", "length", ")", ";", "System", ".", "arraycopy", "(", "K", ",", "K1", ".", "length", ",", "K2", ",", "0", ",", "K2", ".", "length", ")", ";", "if", "(", "IV", "!=", "null", ")", "{", "cipher", ".", "init", "(", "false", ",", "new", "ParametersWithIV", "(", "new", "KeyParameter", "(", "K1", ")", ",", "IV", ")", ")", ";", "}", "else", "{", "cipher", ".", "init", "(", "false", ",", "new", "KeyParameter", "(", "K1", ")", ")", ";", "}", "M", "=", "new", "byte", "[", "cipher", ".", "getOutputSize", "(", "inLen", "-", "V", ".", "length", "-", "mac", ".", "getMacSize", "(", ")", ")", "]", ";", "len", "=", "cipher", ".", "processBytes", "(", "in_enc", ",", "inOff", "+", "V", ".", "length", ",", "inLen", "-", "V", ".", "length", "-", "mac", ".", "getMacSize", "(", ")", ",", "M", ",", "0", ")", ";", "len", "+=", "cipher", ".", "doFinal", "(", "M", ",", "len", ")", ";", "}", "byte", "[", "]", "P2", "=", "param", ".", "getEncodingV", "(", ")", ";", "byte", "[", "]", "L2", "=", "null", ";", "if", "(", "V", ".", "length", "!=", "0", ")", "{", "L2", "=", "getLengthTag", "(", "P2", ")", ";", "}", "int", "end", "=", "inOff", "+", "inLen", ";", "byte", "[", "]", "T1", "=", "Arrays", ".", "copyOfRange", "(", "in_enc", ",", "end", "-", "mac", ".", "getMacSize", "(", ")", ",", "end", ")", ";", "byte", "[", "]", "T2", "=", "new", "byte", "[", "T1", ".", "length", "]", ";", "mac", ".", "init", "(", "new", "KeyParameter", "(", "K2", ")", ")", ";", "mac", ".", "update", "(", "in_enc", ",", "inOff", "+", "V", ".", "length", ",", "inLen", "-", "V", ".", "length", "-", "T2", ".", "length", ")", ";", "if", "(", "P2", "!=", "null", ")", "{", "mac", ".", "update", "(", "P2", ",", "0", ",", "P2", ".", "length", ")", ";", "}", "if", "(", "V", ".", "length", "!=", "0", ")", "{", "mac", ".", "update", "(", "L2", ",", "0", ",", "L2", ".", "length", ")", ";", "}", "mac", ".", "doFinal", "(", "T2", ",", "0", ")", ";", "if", "(", "!", "Arrays", ".", "constantTimeAreEqual", "(", "T1", ",", "T2", ")", ")", "{", "throw", "new", "InvalidCipherTextException", "(", "\"", "Invalid MAC.", "\"", ")", ";", "}", "return", "Arrays", ".", "copyOfRange", "(", "M", ",", "0", ",", "len", ")", ";", "}"], "idx": 48126, "cwe": "CWE-361", "target": 1, "status": "VULNERABLE", "commit": "21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35", "function_name": "decryptBlock", "body_hash": "90c0f4229c7db5d17e56b0911f2358f629591652"}
{"code": "protected final File file(String name, boolean mustExist) {\n\n        if (name.equals(\"/\")) {\n            name = \"\";\n        }\n        File file = new File(fileBase, name);\n\n        // If the requested names ends in '/', the Java File API will return a\n        // matching file if one exists. This isn't what we want as it is not\n        // consistent with the Servlet spec rules for request mapping.\n        if (name.endsWith(\"/\") && file.isFile()) {\n            return null;\n        }\n\n        // If the file/dir must exist but the identified file/dir can't be read\n        // then signal that the resource was not found\n        if (mustExist && !file.canRead()) {\n            return null;\n        }\n\n        // If allow linking is enabled, files are not limited to being located\n        // under the fileBase so all further checks are disabled.\n        if (getRoot().getAllowLinking()) {\n            return file;\n        }\n\n        // Check that this file is located under the WebResourceSet's base\n        String canPath = null;\n        try {\n            canPath = file.getCanonicalPath();\n        } catch (IOException e) {\n            // Ignore\n        }\n        if (canPath == null || !canPath.startsWith(canonicalBase)) {\n            return null;\n        }\n\n        // Ensure that the file is not outside the fileBase. This should not be\n        // possible for standard requests (the request is normalized early in\n        // the request processing) but might be possible for some access via the\n        // Servlet API (RequestDispatcher, HTTP/2 push etc.) therefore these\n        // checks are retained as an additional safety measure\n        // absoluteBase has been normalized so absPath needs to be normalized as\n        // well.\n        String absPath = normalize(file.getAbsolutePath());\n        if (absoluteBase.length() > absPath.length()) {\n            return null;\n        }\n\n        // Remove the fileBase location from the start of the paths since that\n        // was not part of the requested path and the remaining check only\n        // applies to the request path\n        absPath = absPath.substring(absoluteBase.length());\n        canPath = canPath.substring(canonicalBase.length());\n\n        // Case sensitivity check\n        // The normalized requested path should be an exact match the equivalent\n        // canonical path. If it is not, possible reasons include:\n        // - case differences on case insensitive file systems\n        // - Windows removing a trailing ' ' or '.' from the file name\n        //\n        // In all cases, a mis-match here results in the resource not being\n        // found\n        //\n        // absPath is normalized so canPath needs to be normalized as well\n        // Can't normalize canPath earlier as canonicalBase is not normalized\n        if (canPath.length() > 0) {\n            canPath = normalize(canPath);\n        }\n        if (!canPath.equals(absPath)) {\n            return null;\n        }\n\n        return file;\n    }", "code_tokens": ["protected", "final", "File", "file", "(", "String", "name", ",", "boolean", "mustExist", ")", "{", "if", "(", "name", ".", "equals", "(", "\"", "/", "\"", ")", ")", "{", "name", "=", "\"", "\"", ";", "}", "File", "file", "=", "new", "File", "(", "fileBase", ",", "name", ")", ";", "if", "(", "name", ".", "endsWith", "(", "\"", "/", "\"", ")", "&&", "file", ".", "isFile", "(", ")", ")", "{", "return", "null", ";", "}", "if", "(", "mustExist", "&&", "!", "file", ".", "canRead", "(", ")", ")", "{", "return", "null", ";", "}", "if", "(", "getRoot", "(", ")", ".", "getAllowLinking", "(", ")", ")", "{", "return", "file", ";", "}", "String", "canPath", "=", "null", ";", "try", "{", "canPath", "=", "file", ".", "getCanonicalPath", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "if", "(", "canPath", "==", "null", "||", "!", "canPath", ".", "startsWith", "(", "canonicalBase", ")", ")", "{", "return", "null", ";", "}", "String", "absPath", "=", "normalize", "(", "file", ".", "getAbsolutePath", "(", ")", ")", ";", "if", "(", "absoluteBase", ".", "length", "(", ")", ">", "absPath", ".", "length", "(", ")", ")", "{", "return", "null", ";", "}", "absPath", "=", "absPath", ".", "substring", "(", "absoluteBase", ".", "length", "(", ")", ")", ";", "canPath", "=", "canPath", ".", "substring", "(", "canonicalBase", ".", "length", "(", ")", ")", ";", "if", "(", "canPath", ".", "length", "(", ")", ">", "0", ")", "{", "canPath", "=", "normalize", "(", "canPath", ")", ";", "}", "if", "(", "!", "canPath", ".", "equals", "(", "absPath", ")", ")", "{", "return", "null", ";", "}", "return", "file", ";", "}"], "idx": 53720, "cwe": "CWE-434", "target": 1, "status": "VULNERABLE", "commit": "a9dd96046d7acb0357c6b7b9e6cc70d186fae663", "function_name": "file", "body_hash": "7da30366e99c16693c56e03b28f470ef3e547d93"}
{"code": "private Document parseXML(InputStream pXmlFile) throws ParserException {\n    final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    dbf.setValidating(false);\n    try {\n      dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n    } catch (ParserConfigurationException e) {\n      // ignore since all implementations are required to support the\n      // {@link javax.xml.XMLConstants#FEATURE_SECURE_PROCESSING} feature\n    }\n    final DocumentBuilder db;\n    try {\n      db = dbf.newDocumentBuilder();\n    } catch (Exception se) {\n      throw new ParserException(\"XML Parser configuration error.\", se);\n    }\n    try {\n      db.setEntityResolver(getEntityResolver());\n      db.setErrorHandler(getErrorHandler());\n      return db.parse(pXmlFile);\n    } catch (Exception se) {\n      throw new ParserException(\"Error parsing XML stream: \" + se, se);\n    }\n  }", "code_tokens": ["private", "Document", "parseXML", "(", "InputStream", "pXmlFile", ")", "throws", "ParserException", "{", "final", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "dbf", ".", "setValidating", "(", "false", ")", ";", "try", "{", "dbf", ".", "setFeature", "(", "XMLConstants", ".", "FEATURE_SECURE_PROCESSING", ",", "true", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e", ")", "{", "}", "final", "DocumentBuilder", "db", ";", "try", "{", "db", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "}", "catch", "(", "Exception", "se", ")", "{", "throw", "new", "ParserException", "(", "\"", "XML Parser configuration error.", "\"", ",", "se", ")", ";", "}", "try", "{", "db", ".", "setEntityResolver", "(", "getEntityResolver", "(", ")", ")", ";", "db", ".", "setErrorHandler", "(", "getErrorHandler", "(", ")", ")", ";", "return", "db", ".", "parse", "(", "pXmlFile", ")", ";", "}", "catch", "(", "Exception", "se", ")", "{", "throw", "new", "ParserException", "(", "\"", "Error parsing XML stream: ", "\"", "+", "se", ",", "se", ")", ";", "}", "}"], "idx": 67655, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "3bba91131b5257e64b9d0a2193e1e32a145b2a2", "function_name": "parseXML", "body_hash": "25922a375debfd04d63c099f81bc3967857fafee"}
{"code": "protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #{}: {}\", i, part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #{}: is mimetype: multipart/*\", i);\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = part.getFileName();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                        DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "extractAttachmentsFromMultipart", "(", "Multipart", "mp", ",", "Map", "<", "String", ",", "Attachment", ">", "map", ")", "throws", "MessagingException", ",", "IOException", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "mp", ".", "getCount", "(", ")", ";", "i", "++", ")", "{", "Part", "part", "=", "mp", ".", "getBodyPart", "(", "i", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: {}", "\"", ",", "i", ",", "part", ")", ";", "if", "(", "part", ".", "isMimeType", "(", "\"", "multipart/*", "\"", ")", ")", "{", "LOG", ".", "trace", "(", "\"", "Part #{}: is mimetype: multipart/*", "\"", ",", "i", ")", ";", "extractAttachmentsFromMultipart", "(", "(", "Multipart", ")", "part", ".", "getContent", "(", ")", ",", "map", ")", ";", "}", "else", "{", "String", "disposition", "=", "part", ".", "getDisposition", "(", ")", ";", "String", "fileName", "=", "part", ".", "getFileName", "(", ")", ";", "if", "(", "LOG", ".", "isTraceEnabled", "(", ")", ")", "{", "LOG", ".", "trace", "(", "\"", "Part #{}: Disposition: {}", "\"", ",", "i", ",", "disposition", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: Description: {}", "\"", ",", "i", ",", "part", ".", "getDescription", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: ContentType: {}", "\"", ",", "i", ",", "part", ".", "getContentType", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: FileName: {}", "\"", ",", "i", ",", "fileName", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: Size: {}", "\"", ",", "i", ",", "part", ".", "getSize", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: LineCount: {}", "\"", ",", "i", ",", "part", ".", "getLineCount", "(", ")", ")", ";", "}", "if", "(", "validDisposition", "(", "disposition", ",", "fileName", ")", "||", "fileName", "!=", "null", ")", "{", "LOG", ".", "debug", "(", "\"", "Mail contains file attachment: {}", "\"", ",", "fileName", ")", ";", "if", "(", "!", "map", ".", "containsKey", "(", "fileName", ")", ")", "{", "DefaultAttachment", "camelAttachment", "=", "new", "DefaultAttachment", "(", "part", ".", "getDataHandler", "(", ")", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Enumeration", "<", "Header", ">", "headers", "=", "part", ".", "getAllHeaders", "(", ")", ";", "while", "(", "headers", ".", "hasMoreElements", "(", ")", ")", "{", "Header", "header", "=", "headers", ".", "nextElement", "(", ")", ";", "camelAttachment", ".", "addHeader", "(", "header", ".", "getName", "(", ")", ",", "header", ".", "getValue", "(", ")", ")", ";", "}", "map", ".", "put", "(", "fileName", ",", "camelAttachment", ")", ";", "}", "else", "{", "LOG", ".", "warn", "(", "\"", "Cannot extract duplicate file attachment: {}.", "\"", ",", "fileName", ")", ";", "}", "}", "}", "}", "}"], "idx": 21183, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "4580e4d6c65cfd544c1791c824b5819477c583c", "function_name": "extractAttachmentsFromMultipart", "body_hash": "72f277bb8b681065867bea1060c951299825929a"}
{"code": "public static C3P0Config extractXmlConfigFromInputStream(InputStream is) throws Exception\n    {\n        DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();\n        DocumentBuilder db = fact.newDocumentBuilder();\n        Document doc = db.parse( is );\n\n        return extractConfigFromXmlDoc(doc);\n    }", "code_tokens": ["public", "static", "C3P0Config", "extractXmlConfigFromInputStream", "(", "InputStream", "is", ")", "throws", "Exception", "{", "DocumentBuilderFactory", "fact", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "DocumentBuilder", "db", "=", "fact", ".", "newDocumentBuilder", "(", ")", ";", "Document", "doc", "=", "db", ".", "parse", "(", "is", ")", ";", "return", "extractConfigFromXmlDoc", "(", "doc", ")", ";", "}"], "idx": 69566, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "2eb0ea97f745740b18dd45e4a909112d4685f87b", "function_name": "extractXmlConfigFromInputStream", "body_hash": "e9e168165e593ba33ad59d458b5d51c3e434972f"}
{"code": "public void sendFile(String url, Object body, String fileName) {\n        template.sendBodyAndHeader(url, body, Exchange.FILE_NAME, fileName);\n    }", "code_tokens": ["public", "void", "sendFile", "(", "String", "url", ",", "Object", "body", ",", "String", "fileName", ")", "{", "template", ".", "sendBodyAndHeader", "(", "url", ",", "body", ",", "Exchange", ".", "FILE_NAME", ",", "fileName", ")", ";", "}"], "idx": 94836, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "2281b1f365c50ee1a470fb9990b753eadee9095", "function_name": "sendFile", "body_hash": "ec336f927081824539ecef5a44615fc08fa52232"}
{"code": "@RequestMapping(value=\"/change_password.do\", method = POST)\n    public String changePassword(\n            Model model,\n            @RequestParam(\"current_password\") String currentPassword,\n            @RequestParam(\"new_password\") String newPassword,\n            @RequestParam(\"confirm_password\") String confirmPassword,\n            HttpServletResponse response,\n            HttpServletRequest request) {\n\n        PasswordConfirmationValidation validation = new PasswordConfirmationValidation(newPassword, confirmPassword);\n        if (!validation.valid()) {\n            model.addAttribute(\"message_code\", validation.getMessageCode());\n            response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());\n            return \"change_password\";\n        }\n\n        SecurityContext securityContext = SecurityContextHolder.getContext();\n        Authentication authentication = securityContext.getAuthentication();\n        String username = authentication.getName();\n\n        try {\n            changePasswordService.changePassword(username, currentPassword, newPassword);\n            request.getSession().invalidate();\n            request.getSession(true);\n            securityContext.setAuthentication(authentication);\n            return \"redirect:profile\";\n        } catch (BadCredentialsException e) {\n            model.addAttribute(\"message_code\", \"unauthorized\");\n        } catch (InvalidPasswordException e) {\n            model.addAttribute(\"message\", e.getMessagesAsOneString());\n        }\n        response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());\n        return \"change_password\";\n    }", "code_tokens": ["@", "RequestMapping", "(", "value", "=", "\"", "/change_password.do", "\"", ",", "method", "=", "POST", ")", "public", "String", "changePassword", "(", "Model", "model", ",", "@", "RequestParam", "(", "\"", "current_password", "\"", ")", "String", "currentPassword", ",", "@", "RequestParam", "(", "\"", "new_password", "\"", ")", "String", "newPassword", ",", "@", "RequestParam", "(", "\"", "confirm_password", "\"", ")", "String", "confirmPassword", ",", "HttpServletResponse", "response", ",", "HttpServletRequest", "request", ")", "{", "PasswordConfirmationValidation", "validation", "=", "new", "PasswordConfirmationValidation", "(", "newPassword", ",", "confirmPassword", ")", ";", "if", "(", "!", "validation", ".", "valid", "(", ")", ")", "{", "model", ".", "addAttribute", "(", "\"", "message_code", "\"", ",", "validation", ".", "getMessageCode", "(", ")", ")", ";", "response", ".", "setStatus", "(", "HttpStatus", ".", "UNPROCESSABLE_ENTITY", ".", "value", "(", ")", ")", ";", "return", "\"", "change_password", "\"", ";", "}", "SecurityContext", "securityContext", "=", "SecurityContextHolder", ".", "getContext", "(", ")", ";", "Authentication", "authentication", "=", "securityContext", ".", "getAuthentication", "(", ")", ";", "String", "username", "=", "authentication", ".", "getName", "(", ")", ";", "try", "{", "changePasswordService", ".", "changePassword", "(", "username", ",", "currentPassword", ",", "newPassword", ")", ";", "request", ".", "getSession", "(", ")", ".", "invalidate", "(", ")", ";", "request", ".", "getSession", "(", "true", ")", ";", "securityContext", ".", "setAuthentication", "(", "authentication", ")", ";", "return", "\"", "redirect:profile", "\"", ";", "}", "catch", "(", "BadCredentialsException", "e", ")", "{", "model", ".", "addAttribute", "(", "\"", "message_code", "\"", ",", "\"", "unauthorized", "\"", ")", ";", "}", "catch", "(", "InvalidPasswordException", "e", ")", "{", "model", ".", "addAttribute", "(", "\"", "message", "\"", ",", "e", ".", "getMessagesAsOneString", "(", ")", ")", ";", "}", "response", ".", "setStatus", "(", "HttpStatus", ".", "UNPROCESSABLE_ENTITY", ".", "value", "(", ")", ")", ";", "return", "\"", "change_password", "\"", ";", "}"], "idx": 70897, "cwe": "CWE-613", "target": 1, "status": "VULNERABLE", "commit": "9730cd6a3bbb481ee4e400b51952b537589c469d", "function_name": "changePassword", "body_hash": "e06e1811238f43c928a3cebf5709094b06236b7e"}
{"code": "private ResetPasswordResponse changePasswordCodeAuthenticated(String code, String newPassword) {\n        ExpiringCode expiringCode = expiringCodeStore.retrieveCode(code);\n        if (expiringCode == null) {\n            throw new InvalidCodeException(\"invalid_code\", \"Sorry, your reset password link is no longer valid. Please request a new one\", 422);\n        }\n        String userId;\n        String userName;\n        Date passwordLastModified;\n        String clientId;\n        String redirectUri;\n        PasswordChange change;\n        try {\n            change = JsonUtils.readValue(expiringCode.getData(), PasswordChange.class);\n        } catch (JsonUtils.JsonUtilException x) {\n            throw new InvalidCodeException(\"invalid_code\", \"Sorry, your reset password link is no longer valid. Please request a new one\", 422);\n        }\n        userId = change.getUserId();\n        userName = change.getUsername();\n        passwordLastModified = change.getPasswordModifiedTime();\n        clientId = change.getClientId();\n        redirectUri = change.getRedirectUri();\n\n        ScimUser user = scimUserProvisioning.retrieve(userId);\n        try {\n            if (isUserModified(user, expiringCode.getExpiresAt(), userName, passwordLastModified)) {\n                throw new UaaException(\"Invalid password reset request.\");\n            }\n            if (!user.isVerified()) {\n                scimUserProvisioning.verifyUser(userId, -1);\n            }\n            if (scimUserProvisioning.checkPasswordMatches(userId, newPassword)) {\n                throw new InvalidPasswordException(\"Your new password cannot be the same as the old password.\", UNPROCESSABLE_ENTITY);\n            }\n            scimUserProvisioning.changePassword(userId, null, newPassword);\n            publish(new PasswordChangeEvent(\"Password changed\", getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n\n            String redirectLocation = \"home\";\n            if (!isEmpty(clientId) && !isEmpty(redirectUri)) {\n                try {\n                    ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n                    Set<String> redirectUris = clientDetails.getRegisteredRedirectUri() == null ? Collections.emptySet() :\n                        clientDetails.getRegisteredRedirectUri();\n                    String matchingRedirectUri = UaaUrlUtils.findMatchingRedirectUri(redirectUris, redirectUri, null);\n                    if (matchingRedirectUri != null) {\n                        redirectLocation = matchingRedirectUri;\n                    }\n                } catch (NoSuchClientException nsce) {}\n            }\n            return new ResetPasswordResponse(user, redirectLocation, clientId);\n        } catch (Exception e) {\n            publish(new PasswordChangeFailureEvent(e.getMessage(), getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n            throw e;\n        }\n    }", "code_tokens": ["private", "ResetPasswordResponse", "changePasswordCodeAuthenticated", "(", "String", "code", ",", "String", "newPassword", ")", "{", "ExpiringCode", "expiringCode", "=", "expiringCodeStore", ".", "retrieveCode", "(", "code", ")", ";", "if", "(", "expiringCode", "==", "null", ")", "{", "throw", "new", "InvalidCodeException", "(", "\"", "invalid_code", "\"", ",", "\"", "Sorry, your reset password link is no longer valid. Please request a new one", "\"", ",", "422", ")", ";", "}", "String", "userId", ";", "String", "userName", ";", "Date", "passwordLastModified", ";", "String", "clientId", ";", "String", "redirectUri", ";", "PasswordChange", "change", ";", "try", "{", "change", "=", "JsonUtils", ".", "readValue", "(", "expiringCode", ".", "getData", "(", ")", ",", "PasswordChange", ".", "class", ")", ";", "}", "catch", "(", "JsonUtils", ".", "JsonUtilException", "x", ")", "{", "throw", "new", "InvalidCodeException", "(", "\"", "invalid_code", "\"", ",", "\"", "Sorry, your reset password link is no longer valid. Please request a new one", "\"", ",", "422", ")", ";", "}", "userId", "=", "change", ".", "getUserId", "(", ")", ";", "userName", "=", "change", ".", "getUsername", "(", ")", ";", "passwordLastModified", "=", "change", ".", "getPasswordModifiedTime", "(", ")", ";", "clientId", "=", "change", ".", "getClientId", "(", ")", ";", "redirectUri", "=", "change", ".", "getRedirectUri", "(", ")", ";", "ScimUser", "user", "=", "scimUserProvisioning", ".", "retrieve", "(", "userId", ")", ";", "try", "{", "if", "(", "isUserModified", "(", "user", ",", "expiringCode", ".", "getExpiresAt", "(", ")", ",", "userName", ",", "passwordLastModified", ")", ")", "{", "throw", "new", "UaaException", "(", "\"", "Invalid password reset request.", "\"", ")", ";", "}", "if", "(", "!", "user", ".", "isVerified", "(", ")", ")", "{", "scimUserProvisioning", ".", "verifyUser", "(", "userId", ",", "-", "1", ")", ";", "}", "if", "(", "scimUserProvisioning", ".", "checkPasswordMatches", "(", "userId", ",", "newPassword", ")", ")", "{", "throw", "new", "InvalidPasswordException", "(", "\"", "Your new password cannot be the same as the old password.", "\"", ",", "UNPROCESSABLE_ENTITY", ")", ";", "}", "scimUserProvisioning", ".", "changePassword", "(", "userId", ",", "null", ",", "newPassword", ")", ";", "publish", "(", "new", "PasswordChangeEvent", "(", "\"", "Password changed", "\"", ",", "getUaaUser", "(", "user", ")", ",", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "getAuthentication", "(", ")", ")", ")", ";", "String", "redirectLocation", "=", "\"", "home", "\"", ";", "if", "(", "!", "isEmpty", "(", "clientId", ")", "&&", "!", "isEmpty", "(", "redirectUri", ")", ")", "{", "try", "{", "ClientDetails", "clientDetails", "=", "clientDetailsService", ".", "loadClientByClientId", "(", "clientId", ")", ";", "Set", "<", "String", ">", "redirectUris", "=", "clientDetails", ".", "getRegisteredRedirectUri", "(", ")", "==", "null", "?", "Collections", ".", "emptySet", "(", ")", ":", "clientDetails", ".", "getRegisteredRedirectUri", "(", ")", ";", "String", "matchingRedirectUri", "=", "UaaUrlUtils", ".", "findMatchingRedirectUri", "(", "redirectUris", ",", "redirectUri", ",", "null", ")", ";", "if", "(", "matchingRedirectUri", "!=", "null", ")", "{", "redirectLocation", "=", "matchingRedirectUri", ";", "}", "}", "catch", "(", "NoSuchClientException", "nsce", ")", "{", "}", "}", "return", "new", "ResetPasswordResponse", "(", "user", ",", "redirectLocation", ",", "clientId", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "publish", "(", "new", "PasswordChangeFailureEvent", "(", "e", ".", "getMessage", "(", ")", ",", "getUaaUser", "(", "user", ")", ",", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "getAuthentication", "(", ")", ")", ")", ";", "throw", "e", ";", "}", "}"], "idx": 33899, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "66132926f1bac0b878da5841be2f93fa5075d88f", "function_name": "changePasswordCodeAuthenticated", "body_hash": "d62458c1586b3575cdb6d1b01ef422ac812f57dd"}
{"code": "public Object getBody() throws JMSException {\n        Message message = getMessage();\n        if (message instanceof TextMessage) {\n            return ((TextMessage) message).getText();\n        }\n        if (message instanceof ObjectMessage) {\n            try {\n                return ((ObjectMessage) message).getObject();\n            } catch (Exception e) {\n                //message could not be parsed, make the reason available\n                return new String(\"Cannot display ObjectMessage body. Reason: \" + e.getMessage());\n            }\n        }\n        if (message instanceof MapMessage) {\n            return createMapBody((MapMessage) message);\n        }\n        if (message instanceof BytesMessage) {\n            BytesMessage msg = (BytesMessage) message;\n            int len = (int) msg.getBodyLength();\n            if (len > -1) {\n                byte[] data = new byte[len];\n                msg.readBytes(data);\n                return new String(data);\n            } else {\n                return \"\";\n            }\n        }\n        if (message instanceof StreamMessage) {\n            return \"StreamMessage is not viewable\";\n        }\n\n        // unknown message type\n        if (message != null) {\n            return \"Unknown message type [\" + message.getClass().getName() + \"] \" + message;\n        }\n\n        return null;\n    }", "code_tokens": ["public", "Object", "getBody", "(", ")", "throws", "JMSException", "{", "Message", "message", "=", "getMessage", "(", ")", ";", "if", "(", "message", "instanceof", "TextMessage", ")", "{", "return", "(", "(", "TextMessage", ")", "message", ")", ".", "getText", "(", ")", ";", "}", "if", "(", "message", "instanceof", "ObjectMessage", ")", "{", "try", "{", "return", "(", "(", "ObjectMessage", ")", "message", ")", ".", "getObject", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "return", "new", "String", "(", "\"", "Cannot display ObjectMessage body. Reason: ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "if", "(", "message", "instanceof", "MapMessage", ")", "{", "return", "createMapBody", "(", "(", "MapMessage", ")", "message", ")", ";", "}", "if", "(", "message", "instanceof", "BytesMessage", ")", "{", "BytesMessage", "msg", "=", "(", "BytesMessage", ")", "message", ";", "int", "len", "=", "(", "int", ")", "msg", ".", "getBodyLength", "(", ")", ";", "if", "(", "len", ">", "-", "1", ")", "{", "byte", "[", "]", "data", "=", "new", "byte", "[", "len", "]", ";", "msg", ".", "readBytes", "(", "data", ")", ";", "return", "new", "String", "(", "data", ")", ";", "}", "else", "{", "return", "\"", "\"", ";", "}", "}", "if", "(", "message", "instanceof", "StreamMessage", ")", "{", "return", "\"", "StreamMessage is not viewable", "\"", ";", "}", "if", "(", "message", "!=", "null", ")", "{", "return", "\"", "Unknown message type [", "\"", "+", "message", ".", "getClass", "(", ")", ".", "getName", "(", ")", "+", "\"", "] ", "\"", "+", "message", ";", "}", "return", "null", ";", "}"], "idx": 5523, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "6f03921b31d9fefeddb0f4fa63150ed1f94a14b", "function_name": "getBody", "body_hash": "ffd79d1ef4b3ce21c4e933f47f894a945dd11d99"}
{"code": "private Page<TaskExecution> queryForPageableResults(Pageable pageable,\n\t\t\tString selectClause, String fromClause, String whereClause,\n\t\t\tMapSqlParameterSource queryParameters, long totalCount) {\n\t\tSqlPagingQueryProviderFactoryBean factoryBean = new SqlPagingQueryProviderFactoryBean();\n\t\tfactoryBean.setSelectClause(selectClause);\n\t\tfactoryBean.setFromClause(fromClause);\n\t\tif (StringUtils.hasText(whereClause)) {\n\t\t\tfactoryBean.setWhereClause(whereClause);\n\t\t}\n\t\tfinal Sort sort = pageable.getSort();\n\t\tfinal LinkedHashMap<String, Order> sortOrderMap = new LinkedHashMap<>();\n\n\t\tif (sort != null) {\n\t\t\tfor (Sort.Order sortOrder : sort) {\n\t\t\t\tsortOrderMap.put(sortOrder.getProperty(),\n\t\t\t\t\t\tsortOrder.isAscending() ? Order.ASCENDING : Order.DESCENDING);\n\t\t\t}\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(sortOrderMap)) {\n\t\t\tfactoryBean.setSortKeys(sortOrderMap);\n\t\t}\n\t\telse {\n\t\t\tfactoryBean.setSortKeys(this.orderMap);\n\t\t}\n\n\t\tfactoryBean.setDataSource(this.dataSource);\n\t\tPagingQueryProvider pagingQueryProvider;\n\t\ttry {\n\t\t\tpagingQueryProvider = factoryBean.getObject();\n\t\t\tpagingQueryProvider.init(this.dataSource);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tString query = pagingQueryProvider.getPageQuery(pageable);\n\t\tList<TaskExecution> resultList = this.jdbcTemplate.query(getQuery(query),\n\t\t\t\tqueryParameters, new TaskExecutionRowMapper());\n\t\treturn new PageImpl<>(resultList, pageable, totalCount);\n\t}", "code_tokens": ["private", "Page", "<", "TaskExecution", ">", "queryForPageableResults", "(", "Pageable", "pageable", ",", "String", "selectClause", ",", "String", "fromClause", ",", "String", "whereClause", ",", "MapSqlParameterSource", "queryParameters", ",", "long", "totalCount", ")", "{", "SqlPagingQueryProviderFactoryBean", "factoryBean", "=", "new", "SqlPagingQueryProviderFactoryBean", "(", ")", ";", "factoryBean", ".", "setSelectClause", "(", "selectClause", ")", ";", "factoryBean", ".", "setFromClause", "(", "fromClause", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "whereClause", ")", ")", "{", "factoryBean", ".", "setWhereClause", "(", "whereClause", ")", ";", "}", "final", "Sort", "sort", "=", "pageable", ".", "getSort", "(", ")", ";", "final", "LinkedHashMap", "<", "String", ",", "Order", ">", "sortOrderMap", "=", "new", "LinkedHashMap", "<", ">", "(", ")", ";", "if", "(", "sort", "!=", "null", ")", "{", "for", "(", "Sort", ".", "Order", "sortOrder", ":", "sort", ")", "{", "sortOrderMap", ".", "put", "(", "sortOrder", ".", "getProperty", "(", ")", ",", "sortOrder", ".", "isAscending", "(", ")", "?", "Order", ".", "ASCENDING", ":", "Order", ".", "DESCENDING", ")", ";", "}", "}", "if", "(", "!", "CollectionUtils", ".", "isEmpty", "(", "sortOrderMap", ")", ")", "{", "factoryBean", ".", "setSortKeys", "(", "sortOrderMap", ")", ";", "}", "else", "{", "factoryBean", ".", "setSortKeys", "(", "this", ".", "orderMap", ")", ";", "}", "factoryBean", ".", "setDataSource", "(", "this", ".", "dataSource", ")", ";", "PagingQueryProvider", "pagingQueryProvider", ";", "try", "{", "pagingQueryProvider", "=", "factoryBean", ".", "getObject", "(", ")", ";", "pagingQueryProvider", ".", "init", "(", "this", ".", "dataSource", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "String", "query", "=", "pagingQueryProvider", ".", "getPageQuery", "(", "pageable", ")", ";", "List", "<", "TaskExecution", ">", "resultList", "=", "this", ".", "jdbcTemplate", ".", "query", "(", "getQuery", "(", "query", ")", ",", "queryParameters", ",", "new", "TaskExecutionRowMapper", "(", ")", ")", ";", "return", "new", "PageImpl", "<", ">", "(", "resultList", ",", "pageable", ",", "totalCount", ")", ";", "}"], "idx": 92634, "cwe": "CWE-89", "target": 1, "status": "VULNERABLE", "commit": "25592edb004eb5b059e9a093658437b18cff0979", "function_name": "queryForPageableResults", "body_hash": "1b04f180e03d035194a64db5d7aca02a2a5131fa"}
{"code": "@Override public SubversionChangeLogSet parse(@SuppressWarnings(\"rawtypes\") Run build, RepositoryBrowser<?> browser, File changelogFile) throws IOException, SAXException {\n        // http://svn.apache.org/repos/asf/subversion/trunk/subversion/svn/schema/log.rnc\n\n        Digester digester = new Digester2();\n        ArrayList<LogEntry> r = new ArrayList<>();\n        digester.push(r);\n\n        digester.addObjectCreate(\"*/logentry\", LogEntry.class);\n        digester.addSetProperties(\"*/logentry\");\n        digester.addBeanPropertySetter(\"*/logentry/author\",\"user\");\n        digester.addBeanPropertySetter(\"*/logentry/date\");\n        digester.addBeanPropertySetter(\"*/logentry/msg\");\n        digester.addSetNext(\"*/logentry\",\"add\");\n\n        digester.addObjectCreate(\"*/logentry/paths/path\", Path.class);\n        digester.addSetProperties(\"*/logentry/paths/path\");\n        digester.addBeanPropertySetter(\"*/logentry/paths/path\",\"value\");\n        digester.addSetNext(\"*/logentry/paths/path\",\"addPath\");\n\n        try {\n            digester.parse(changelogFile);\n        } catch (IOException | SAXException e) {\n            throw new IOException(\"Failed to parse \" + changelogFile,e);\n        }\n\n        for (LogEntry e : r) {\n            e.finish();\n        }\n        return new SubversionChangeLogSet(build, browser, r, ignoreDirPropChanges);\n    }", "code_tokens": ["@", "Override", "public", "SubversionChangeLogSet", "parse", "(", "@", "SuppressWarnings", "(", "\"", "rawtypes", "\"", ")", "Run", "build", ",", "RepositoryBrowser", "<", "?", ">", "browser", ",", "File", "changelogFile", ")", "throws", "IOException", ",", "SAXException", "{", "Digester", "digester", "=", "new", "Digester2", "(", ")", ";", "ArrayList", "<", "LogEntry", ">", "r", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "digester", ".", "push", "(", "r", ")", ";", "digester", ".", "addObjectCreate", "(", "\"", "*/logentry", "\"", ",", "LogEntry", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "\"", "*/logentry", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/logentry/author", "\"", ",", "\"", "user", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/logentry/date", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/logentry/msg", "\"", ")", ";", "digester", ".", "addSetNext", "(", "\"", "*/logentry", "\"", ",", "\"", "add", "\"", ")", ";", "digester", ".", "addObjectCreate", "(", "\"", "*/logentry/paths/path", "\"", ",", "Path", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "\"", "*/logentry/paths/path", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/logentry/paths/path", "\"", ",", "\"", "value", "\"", ")", ";", "digester", ".", "addSetNext", "(", "\"", "*/logentry/paths/path", "\"", ",", "\"", "addPath", "\"", ")", ";", "try", "{", "digester", ".", "parse", "(", "changelogFile", ")", ";", "}", "catch", "(", "IOException", "|", "SAXException", "e", ")", "{", "throw", "new", "IOException", "(", "\"", "Failed to parse ", "\"", "+", "changelogFile", ",", "e", ")", ";", "}", "for", "(", "LogEntry", "e", ":", "r", ")", "{", "e", ".", "finish", "(", ")", ";", "}", "return", "new", "SubversionChangeLogSet", "(", "build", ",", "browser", ",", "r", ",", "ignoreDirPropChanges", ")", ";", "}"], "idx": 69713, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "83f24081114a465f88d44fc84180d4d9d02c705d", "function_name": "parse", "body_hash": "4327a45569cb0ad14be4f929eacc7d913e85cee7"}
{"code": "private void registerMessageListener() {\n\t\t// do not register multiple packet listeners\n\t\tif (mPacketListener != null)\n\t\t\tmXMPPConnection.removePacketListener(mPacketListener);\n\n\t\tPacketTypeFilter filter = new PacketTypeFilter(Message.class);\n\n\t\tmPacketListener = new PacketListener() {\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\ttry {\n\t\t\t\tif (packet instanceof Message) {\n\t\t\t\t\tMessage msg = (Message) packet;\n\n\t\t\t\t\tString[] fromJID = getJabberID(msg.getFrom());\n\t\t\t\t\t\n\t\t\t\t\tint direction = ChatConstants.INCOMING;\n\t\t\t\t\tCarbon cc = CarbonManager.getCarbon(msg);\n\t\t\t\t\tif (cc != null && !msg.getFrom().equalsIgnoreCase(mConfig.jabberID)) {\n\t\t\t\t\t\tLog.w(TAG, \"Received illegal carbon from \" + msg.getFrom() + \": \" + cc.toXML());\n\t\t\t\t\t\tcc = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// extract timestamp\n\t\t\t\t\tlong ts;\n\t\t\t\t\tDelayInfo timestamp = (DelayInfo)msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n\t\t\t\t\tif (timestamp == null)\n\t\t\t\t\t\ttimestamp = (DelayInfo)msg.getExtension(\"x\", \"jabber:x:delay\");\n\t\t\t\t\tif (cc != null) // Carbon timestamp overrides packet timestamp\n\t\t\t\t\t\ttimestamp = cc.getForwarded().getDelayInfo();\n\t\t\t\t\tif (timestamp != null)\n\t\t\t\t\t\tts = timestamp.getStamp().getTime();\n\t\t\t\t\telse\n\t\t\t\t\t\tts = System.currentTimeMillis();\n\n\t\t\t\t\t// try to extract a carbon\n\t\t\t\t\tif (cc != null) {\n\t\t\t\t\t\tLog.d(TAG, \"carbon: \" + cc.toXML());\n\t\t\t\t\t\tmsg = (Message)cc.getForwarded().getForwardedPacket();\n\n\t\t\t\t\t\t// outgoing carbon: fromJID is actually chat peer's JID\n\t\t\t\t\t\tif (cc.getDirection() == Carbon.Direction.sent) {\n\t\t\t\t\t\t\tfromJID = getJabberID(msg.getTo());\n\t\t\t\t\t\t\tdirection = ChatConstants.OUTGOING;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfromJID = getJabberID(msg.getFrom());\n\n\t\t\t\t\t\t\t// hook off carbonated delivery receipts\n\t\t\t\t\t\t\tDeliveryReceipt dr = (DeliveryReceipt)msg.getExtension(\n\t\t\t\t\t\t\t\t\tDeliveryReceipt.ELEMENT, DeliveryReceipt.NAMESPACE);\n\t\t\t\t\t\t\tif (dr != null) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"got CC'ed delivery receipt for \" + dr.getId());\n\t\t\t\t\t\t\t\tchangeMessageDeliveryStatus(dr.getId(), ChatConstants.DS_ACKED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ignore carbon copies of OTR messages sent by broken clients\n\t\t\t\t\t\tif (msg.getBody() != null && msg.getBody().startsWith(\"?OTR\")) {\n\t\t\t\t\t\t\tLog.i(TAG, \"Ignoring OTR carbon from \" + msg.getFrom() + \" to \" + msg.getTo());\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for jabber MUC invitation\n\t\t\t\t\tif(direction == ChatConstants.INCOMING && handleMucInvitation(msg)) {\n\t\t\t\t\t\tsendReceiptIfRequested(packet);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tString chatMessage = msg.getBody();\n\n\t\t\t\t\t// display error inline\n\t\t\t\t\tif (msg.getType() == Message.Type.error) {\n\t\t\t\t\t\tif (changeMessageDeliveryStatus(msg.getPacketID(), ChatConstants.DS_FAILED))\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, msg.getError().toString(), (cc != null), Message.Type.error);\n\t\t\t\t\t\telse if (mucJIDs.contains(msg.getFrom())) {\n\t\t\t\t\t\t\thandleKickedFromMUC(msg.getFrom(), false, null,\n\t\t\t\t\t\t\t\t\tmsg.getError().toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // we do not want to add errors as \"incoming messages\"\n\t\t\t\t\t}\n\n\t\t\t\t\t// ignore empty messages\n\t\t\t\t\tif (chatMessage == null) {\n\t\t\t\t\t\tif (msg.getSubject() != null && msg.getType() == Message.Type.groupchat\n\t\t\t\t\t\t\t\t&& mucJIDs.contains(fromJID[0])) {\n\t\t\t\t\t\t\t// this is a MUC subject, update our DB\n\t\t\t\t\t\t\tContentValues cvR = new ContentValues();\n\t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, msg.getSubject());\n\t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.available.ordinal());\n\t\t\t\t\t\t\tLog.d(TAG, \"MUC subject for \" + fromJID[0] + \" set to: \" + msg.getSubject());\n\t\t\t\t\t\t\tupsertRoster(cvR, fromJID[0]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLog.d(TAG, \"empty message.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// obtain Last Message Correction, if present\n\t\t\t\t\tReplace replace = (Replace)msg.getExtension(Replace.NAMESPACE);\n\t\t\t\t\tString replace_id = (replace != null) ? replace.getId() : null;\n\n\t\t\t\t\t// carbons are old. all others are new\n\t\t\t\t\tint is_new = (cc == null) ? ChatConstants.DS_NEW : ChatConstants.DS_SENT_OR_READ;\n\t\t\t\t\tif (msg.getType() == Message.Type.error)\n\t\t\t\t\t\tis_new = ChatConstants.DS_FAILED;\n\n\t\t\t\t\tboolean is_muc = (msg.getType() == Message.Type.groupchat);\n\t\t\t\t\tboolean is_from_me = (direction == ChatConstants.OUTGOING) ||\n\t\t\t\t\t\t(is_muc && fromJID[1].equals(getMyMucNick(fromJID[0])));\n\n\t\t\t\t\t// handle MUC-PMs: messages from a nick from a known MUC or with\n\t\t\t\t\t// an <x> element\n\t\t\t\t\tMUCUser muc_x = (MUCUser)msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\t\t\t\t\tboolean is_muc_pm = !is_muc  && !TextUtils.isEmpty(fromJID[1]) &&\n\t\t\t\t\t\t\t(muc_x != null || mucJIDs.contains(fromJID[0]));\n\n\t\t\t\t\t// TODO: ignoring 'received' MUC-PM carbons, until XSF sorts out shit:\n\t\t\t\t\t// - if yaxim is in the MUC, it will receive a non-carbonated copy of\n\t\t\t\t\t//   incoming messages, but not of outgoing ones\n\t\t\t\t\t// - if yaxim isn't in the MUC, it can't respond anyway\n\t\t\t\t\tif (is_muc_pm && !is_from_me && cc != null)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tif (is_muc_pm) {\n\t\t\t\t\t\t// store MUC-PMs under the participant's full JID, not bare\n\t\t\t\t\t\t//is_from_me = fromJID[1].equals(getMyMucNick(fromJID[0]));\n\t\t\t\t\t\tfromJID[0] = fromJID[0] + \"/\" + fromJID[1];\n\t\t\t\t\t\tfromJID[1] = null;\n\t\t\t\t\t\tLog.d(TAG, \"MUC-PM: \" + fromJID[0] + \" d=\" + direction + \" fromme=\" + is_from_me);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Carbons and MUC history are 'silent' by default\n\t\t\t\t\tboolean is_silent = (cc != null) || (is_muc && timestamp != null);\n\n\t\t\t\t\tif (!is_muc || checkAddMucMessage(msg, msg.getPacketID(), fromJID, timestamp)) {\n\t\t\t\t\t\taddChatMessageToDB(direction, fromJID, chatMessage, is_new, ts, msg.getPacketID(), replace_id);\n\t\t\t\t\t\t// only notify on private messages or when MUC notification requested\n\t\t\t\t\t\tboolean need_notify = !is_muc || mConfig.needMucNotification(getMyMucNick(fromJID[0]), chatMessage);\n\t\t\t\t\t\t// outgoing carbon -> clear notification by signalling 'null' message\n\t\t\t\t\t\tif (is_from_me) {\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, null, true, msg.getType());\n\t\t\t\t\t\t\t// TODO: MUC PMs\n\t\t\t\t\t\t\tChatHelper.markAsRead(mService, fromJID[0]);\n\t\t\t\t\t\t} else if (direction == ChatConstants.INCOMING && need_notify)\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, chatMessage, is_silent, msg.getType());\n\t\t\t\t\t}\n\t\t\t\t\tsendReceiptIfRequested(packet);\n\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// SMACK silently discards exceptions dropped from processPacket :(\n\t\t\t\t\tLog.e(TAG, \"failed to process packet:\");\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tmXMPPConnection.addPacketListener(mPacketListener, filter);\n\t}", "code_tokens": ["private", "void", "registerMessageListener", "(", ")", "{", "if", "(", "mPacketListener", "!=", "null", ")", "mXMPPConnection", ".", "removePacketListener", "(", "mPacketListener", ")", ";", "PacketTypeFilter", "filter", "=", "new", "PacketTypeFilter", "(", "Message", ".", "class", ")", ";", "mPacketListener", "=", "new", "PacketListener", "(", ")", "{", "public", "void", "processPacket", "(", "Packet", "packet", ")", "{", "try", "{", "if", "(", "packet", "instanceof", "Message", ")", "{", "Message", "msg", "=", "(", "Message", ")", "packet", ";", "String", "[", "]", "fromJID", "=", "getJabberID", "(", "msg", ".", "getFrom", "(", ")", ")", ";", "int", "direction", "=", "ChatConstants", ".", "INCOMING", ";", "Carbon", "cc", "=", "CarbonManager", ".", "getCarbon", "(", "msg", ")", ";", "if", "(", "cc", "!=", "null", "&&", "!", "msg", ".", "getFrom", "(", ")", ".", "equalsIgnoreCase", "(", "mConfig", ".", "jabberID", ")", ")", "{", "Log", ".", "w", "(", "TAG", ",", "\"", "Received illegal carbon from ", "\"", "+", "msg", ".", "getFrom", "(", ")", "+", "\"", ": ", "\"", "+", "cc", ".", "toXML", "(", ")", ")", ";", "cc", "=", "null", ";", "}", "long", "ts", ";", "DelayInfo", "timestamp", "=", "(", "DelayInfo", ")", "msg", ".", "getExtension", "(", "\"", "delay", "\"", ",", "\"", "urn:xmpp:delay", "\"", ")", ";", "if", "(", "timestamp", "==", "null", ")", "timestamp", "=", "(", "DelayInfo", ")", "msg", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "jabber:x:delay", "\"", ")", ";", "if", "(", "cc", "!=", "null", ")", "timestamp", "=", "cc", ".", "getForwarded", "(", ")", ".", "getDelayInfo", "(", ")", ";", "if", "(", "timestamp", "!=", "null", ")", "ts", "=", "timestamp", ".", "getStamp", "(", ")", ".", "getTime", "(", ")", ";", "else", "ts", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "if", "(", "cc", "!=", "null", ")", "{", "Log", ".", "d", "(", "TAG", ",", "\"", "carbon: ", "\"", "+", "cc", ".", "toXML", "(", ")", ")", ";", "msg", "=", "(", "Message", ")", "cc", ".", "getForwarded", "(", ")", ".", "getForwardedPacket", "(", ")", ";", "if", "(", "cc", ".", "getDirection", "(", ")", "==", "Carbon", ".", "Direction", ".", "sent", ")", "{", "fromJID", "=", "getJabberID", "(", "msg", ".", "getTo", "(", ")", ")", ";", "direction", "=", "ChatConstants", ".", "OUTGOING", ";", "}", "else", "{", "fromJID", "=", "getJabberID", "(", "msg", ".", "getFrom", "(", ")", ")", ";", "DeliveryReceipt", "dr", "=", "(", "DeliveryReceipt", ")", "msg", ".", "getExtension", "(", "DeliveryReceipt", ".", "ELEMENT", ",", "DeliveryReceipt", ".", "NAMESPACE", ")", ";", "if", "(", "dr", "!=", "null", ")", "{", "Log", ".", "d", "(", "TAG", ",", "\"", "got CC'ed delivery receipt for ", "\"", "+", "dr", ".", "getId", "(", ")", ")", ";", "changeMessageDeliveryStatus", "(", "dr", ".", "getId", "(", ")", ",", "ChatConstants", ".", "DS_ACKED", ")", ";", "}", "}", "if", "(", "msg", ".", "getBody", "(", ")", "!=", "null", "&&", "msg", ".", "getBody", "(", ")", ".", "startsWith", "(", "\"", "?OTR", "\"", ")", ")", "{", "Log", ".", "i", "(", "TAG", ",", "\"", "Ignoring OTR carbon from ", "\"", "+", "msg", ".", "getFrom", "(", ")", "+", "\"", " to ", "\"", "+", "msg", ".", "getTo", "(", ")", ")", ";", "return", ";", "}", "}", "if", "(", "direction", "==", "ChatConstants", ".", "INCOMING", "&&", "handleMucInvitation", "(", "msg", ")", ")", "{", "sendReceiptIfRequested", "(", "packet", ")", ";", "return", ";", "}", "String", "chatMessage", "=", "msg", ".", "getBody", "(", ")", ";", "if", "(", "msg", ".", "getType", "(", ")", "==", "Message", ".", "Type", ".", "error", ")", "{", "if", "(", "changeMessageDeliveryStatus", "(", "msg", ".", "getPacketID", "(", ")", ",", "ChatConstants", ".", "DS_FAILED", ")", ")", "mServiceCallBack", ".", "notifyMessage", "(", "fromJID", ",", "msg", ".", "getError", "(", ")", ".", "toString", "(", ")", ",", "(", "cc", "!=", "null", ")", ",", "Message", ".", "Type", ".", "error", ")", ";", "else", "if", "(", "mucJIDs", ".", "contains", "(", "msg", ".", "getFrom", "(", ")", ")", ")", "{", "handleKickedFromMUC", "(", "msg", ".", "getFrom", "(", ")", ",", "false", ",", "null", ",", "msg", ".", "getError", "(", ")", ".", "toString", "(", ")", ")", ";", "}", "return", ";", "}", "if", "(", "chatMessage", "==", "null", ")", "{", "if", "(", "msg", ".", "getSubject", "(", ")", "!=", "null", "&&", "msg", ".", "getType", "(", ")", "==", "Message", ".", "Type", ".", "groupchat", "&&", "mucJIDs", ".", "contains", "(", "fromJID", "[", "0", "]", ")", ")", "{", "ContentValues", "cvR", "=", "new", "ContentValues", "(", ")", ";", "cvR", ".", "put", "(", "RosterProvider", ".", "RosterConstants", ".", "STATUS_MESSAGE", ",", "msg", ".", "getSubject", "(", ")", ")", ";", "cvR", ".", "put", "(", "RosterProvider", ".", "RosterConstants", ".", "STATUS_MODE", ",", "StatusMode", ".", "available", ".", "ordinal", "(", ")", ")", ";", "Log", ".", "d", "(", "TAG", ",", "\"", "MUC subject for ", "\"", "+", "fromJID", "[", "0", "]", "+", "\"", " set to: ", "\"", "+", "msg", ".", "getSubject", "(", ")", ")", ";", "upsertRoster", "(", "cvR", ",", "fromJID", "[", "0", "]", ")", ";", "return", ";", "}", "Log", ".", "d", "(", "TAG", ",", "\"", "empty message.", "\"", ")", ";", "return", ";", "}", "Replace", "replace", "=", "(", "Replace", ")", "msg", ".", "getExtension", "(", "Replace", ".", "NAMESPACE", ")", ";", "String", "replace_id", "=", "(", "replace", "!=", "null", ")", "?", "replace", ".", "getId", "(", ")", ":", "null", ";", "int", "is_new", "=", "(", "cc", "==", "null", ")", "?", "ChatConstants", ".", "DS_NEW", ":", "ChatConstants", ".", "DS_SENT_OR_READ", ";", "if", "(", "msg", ".", "getType", "(", ")", "==", "Message", ".", "Type", ".", "error", ")", "is_new", "=", "ChatConstants", ".", "DS_FAILED", ";", "boolean", "is_muc", "=", "(", "msg", ".", "getType", "(", ")", "==", "Message", ".", "Type", ".", "groupchat", ")", ";", "boolean", "is_from_me", "=", "(", "direction", "==", "ChatConstants", ".", "OUTGOING", ")", "||", "(", "is_muc", "&&", "fromJID", "[", "1", "]", ".", "equals", "(", "getMyMucNick", "(", "fromJID", "[", "0", "]", ")", ")", ")", ";", "MUCUser", "muc_x", "=", "(", "MUCUser", ")", "msg", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "http://jabber.org/protocol/muc#user", "\"", ")", ";", "boolean", "is_muc_pm", "=", "!", "is_muc", "&&", "!", "TextUtils", ".", "isEmpty", "(", "fromJID", "[", "1", "]", ")", "&&", "(", "muc_x", "!=", "null", "||", "mucJIDs", ".", "contains", "(", "fromJID", "[", "0", "]", ")", ")", ";", "if", "(", "is_muc_pm", "&&", "!", "is_from_me", "&&", "cc", "!=", "null", ")", "return", ";", "if", "(", "is_muc_pm", ")", "{", "fromJID", "[", "0", "]", "=", "fromJID", "[", "0", "]", "+", "\"", "/", "\"", "+", "fromJID", "[", "1", "]", ";", "fromJID", "[", "1", "]", "=", "null", ";", "Log", ".", "d", "(", "TAG", ",", "\"", "MUC-PM: ", "\"", "+", "fromJID", "[", "0", "]", "+", "\"", " d=", "\"", "+", "direction", "+", "\"", " fromme=", "\"", "+", "is_from_me", ")", ";", "}", "boolean", "is_silent", "=", "(", "cc", "!=", "null", ")", "||", "(", "is_muc", "&&", "timestamp", "!=", "null", ")", ";", "if", "(", "!", "is_muc", "||", "checkAddMucMessage", "(", "msg", ",", "msg", ".", "getPacketID", "(", ")", ",", "fromJID", ",", "timestamp", ")", ")", "{", "addChatMessageToDB", "(", "direction", ",", "fromJID", ",", "chatMessage", ",", "is_new", ",", "ts", ",", "msg", ".", "getPacketID", "(", ")", ",", "replace_id", ")", ";", "boolean", "need_notify", "=", "!", "is_muc", "||", "mConfig", ".", "needMucNotification", "(", "getMyMucNick", "(", "fromJID", "[", "0", "]", ")", ",", "chatMessage", ")", ";", "if", "(", "is_from_me", ")", "{", "mServiceCallBack", ".", "notifyMessage", "(", "fromJID", ",", "null", ",", "true", ",", "msg", ".", "getType", "(", ")", ")", ";", "ChatHelper", ".", "markAsRead", "(", "mService", ",", "fromJID", "[", "0", "]", ")", ";", "}", "else", "if", "(", "direction", "==", "ChatConstants", ".", "INCOMING", "&&", "need_notify", ")", "mServiceCallBack", ".", "notifyMessage", "(", "fromJID", ",", "chatMessage", ",", "is_silent", ",", "msg", ".", "getType", "(", ")", ")", ";", "}", "sendReceiptIfRequested", "(", "packet", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "Log", ".", "e", "(", "TAG", ",", "\"", "failed to process packet:", "\"", ")", ";", "e", ".", "printStackTrace", "(", ")", ";", "}", "}", "}", ";", "mXMPPConnection", ".", "addPacketListener", "(", "mPacketListener", ",", "filter", ")", ";", "}"], "idx": 11523, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "65a38dc77545d9568732189e86089390f0ceaf9f", "function_name": "registerMessageListener", "body_hash": "ed39285e9ebba9c61ab28e75f898256b7b1f0ba3"}
{"code": "private void writeSession(SessionInformations session, boolean displayUser) throws IOException {\r\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\r\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\r\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\r\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\r\n\t\twrite(\"'>\");\r\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\r\n\t\twrite(\"</a>\");\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(durationFormat.format(session.getLastAccess()));\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(durationFormat.format(session.getAge()));\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\r\n\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(integerFormat.format(session.getAttributeCount()));\r\n\t\twrite(nextColumnAlignCenter);\r\n\t\tif (session.isSerializable()) {\r\n\t\t\twrite(\"#oui#\");\r\n\t\t} else {\r\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\r\n\t\t}\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(integerFormat.format(session.getSerializedSize()));\r\n\t\tfinal String nextColumn = \"</td><td>\";\r\n\t\twrite(nextColumn);\r\n\t\tfinal String remoteAddr = session.getRemoteAddr();\r\n\t\tif (remoteAddr == null) {\r\n\t\t\twrite(\"&nbsp;\");\r\n\t\t} else {\r\n\t\t\twrite(htmlEncodeButNotSpace(remoteAddr));\r\n\t\t}\r\n\t\twrite(nextColumnAlignCenter);\r\n\t\twriteCountry(session);\r\n\t\tif (displayUser) {\r\n\t\t\twrite(nextColumn);\r\n\t\t\tfinal String remoteUser = session.getRemoteUser();\r\n\t\t\tif (remoteUser == null) {\r\n\t\t\t\twrite(\"&nbsp;\");\r\n\t\t\t} else {\r\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\r\n\t\t\t}\r\n\t\t}\r\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\r\n\t\twrite(A_HREF_PART_SESSIONS);\r\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\r\n\t\twrite(urlEncode(session.getId()));\r\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\r\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\r\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\r\n\t\twrite(\"</a>\");\r\n\t\twrite(\"</td>\");\r\n\t}", "code_tokens": ["private", "void", "writeSession", "(", "SessionInformations", "session", ",", "boolean", "displayUser", ")", "throws", "IOException", "{", "final", "String", "nextColumnAlignRight", "=", "\"", "</td><td align='right'>", "\"", ";", "final", "String", "nextColumnAlignCenter", "=", "\"", "</td><td align='center'>", "\"", ";", "write", "(", "\"", "<td><a href='?part=sessions&amp;sessionId=", "\"", ")", ";", "write", "(", "htmlEncodeButNotSpace", "(", "session", ".", "getId", "(", ")", ")", ")", ";", "write", "(", "\"", "'>", "\"", ")", ";", "write", "(", "htmlEncodeButNotSpace", "(", "session", ".", "getId", "(", ")", ")", ")", ";", "write", "(", "\"", "</a>", "\"", ")", ";", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "durationFormat", ".", "format", "(", "session", ".", "getLastAccess", "(", ")", ")", ")", ";", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "durationFormat", ".", "format", "(", "session", ".", "getAge", "(", ")", ")", ")", ";", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "expiryFormat", ".", "format", "(", "session", ".", "getExpirationDate", "(", ")", ")", ")", ";", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "integerFormat", ".", "format", "(", "session", ".", "getAttributeCount", "(", ")", ")", ")", ";", "write", "(", "nextColumnAlignCenter", ")", ";", "if", "(", "session", ".", "isSerializable", "(", ")", ")", "{", "write", "(", "\"", "#oui#", "\"", ")", ";", "}", "else", "{", "write", "(", "\"", "<span class='severe'>#non#</span>", "\"", ")", ";", "}", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "integerFormat", ".", "format", "(", "session", ".", "getSerializedSize", "(", ")", ")", ")", ";", "final", "String", "nextColumn", "=", "\"", "</td><td>", "\"", ";", "write", "(", "nextColumn", ")", ";", "final", "String", "remoteAddr", "=", "session", ".", "getRemoteAddr", "(", ")", ";", "if", "(", "remoteAddr", "==", "null", ")", "{", "write", "(", "\"", "&nbsp;", "\"", ")", ";", "}", "else", "{", "write", "(", "htmlEncodeButNotSpace", "(", "remoteAddr", ")", ")", ";", "}", "write", "(", "nextColumnAlignCenter", ")", ";", "writeCountry", "(", "session", ")", ";", "if", "(", "displayUser", ")", "{", "write", "(", "nextColumn", ")", ";", "final", "String", "remoteUser", "=", "session", ".", "getRemoteUser", "(", ")", ";", "if", "(", "remoteUser", "==", "null", ")", "{", "write", "(", "\"", "&nbsp;", "\"", ")", ";", "}", "else", "{", "writeDirectly", "(", "htmlEncodeButNotSpace", "(", "remoteUser", ")", ")", ";", "}", "}", "write", "(", "\"", "</td><td align='center' class='noPrint'>", "\"", ")", ";", "write", "(", "A_HREF_PART_SESSIONS", ")", ";", "write", "(", "\"", "&amp;action=invalidate_session&amp;sessionId=", "\"", ")", ";", "write", "(", "urlEncode", "(", "session", ".", "getId", "(", ")", ")", ")", ";", "write", "(", "\"", "' onclick=", "\\\"", "javascript:return confirm('", "\"", "+", "getStringForJavascript", "(", "\"", "confirm_invalidate_session", "\"", ")", "+", "\"", "');", "\\\"", ">", "\"", ")", ";", "write", "(", "\"", "<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />", "\"", ")", ";", "write", "(", "\"", "</a>", "\"", ")", ";", "write", "(", "\"", "</td>", "\"", ")", ";", "}"], "idx": 79342, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "aacbc46151ff4ac1ca34ce0899c2a6113071c66e", "function_name": "writeSession", "body_hash": "2e23beeaac881ee8b5d991f06011d5428bdd06a2"}
{"code": "public void testValidUrlWithDefaultRegex() throws Exception {\n        URLValidator validator = new URLValidator();\n\n        Pattern pattern = Pattern.compile(validator.getUrlRegex(), Pattern.CASE_INSENSITIVE);\n\n        assertFalse(pattern.matcher(\"myapp://test.com\").matches());\n        assertFalse(pattern.matcher(\"myap://test.com\").matches());\n        assertFalse(pattern.matcher(\"\").matches());\n        assertFalse(pattern.matcher(\"   \").matches());\n        assertFalse(pattern.matcher(\"no url\").matches());\n        assertFalse(pattern.matcher(\"http://example.com////////////////////////////////////////////////////////////////////////////////////??\").matches());\n\n        assertTrue(pattern.matcher(\"http://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com:443/login\").matches());\n        assertTrue(pattern.matcher(\"http://localhost:8080/myapp\").matches());\n\n        assertTrue(pattern.matcher(\"http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F\"));\n\n        assertTrue(pattern.matcher(\"http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa\"));\n\n        assertTrue(pattern.matcher(\"http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F\"));\n\n        //this will cause test to hang indefinitely using JDK 1.8.0_121, Struts 2.5.10.1 and JUnit 4.5\n        assertTrue(pattern.matcher(\"http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/\"));\n\n        //this will cause test to hang indefinitely using JDK 1.8.0_121, Struts 2.5.10.1 and JUnit 4.5\n        assertTrue(pattern.matcher(\"http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E\"));\n\n        assertTrue(pattern.matcher(\"http://253.254.255.1\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://253.254.255.1\"));\n\n        assertTrue(pattern.matcher(\"http://253.254.255.12\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://253.254.255.12\"));\n\n        assertTrue(pattern.matcher(\"http://1.2.3.100\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://1.2.3.100\"));\n\n        assertTrue(pattern.matcher(\"http://1.2.3.255\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://1.2.3.255\"));\n\n    }", "code_tokens": ["public", "void", "testValidUrlWithDefaultRegex", "(", ")", "throws", "Exception", "{", "URLValidator", "validator", "=", "new", "URLValidator", "(", ")", ";", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "validator", ".", "getUrlRegex", "(", ")", ",", "Pattern", ".", "CASE_INSENSITIVE", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "myapp://test.com", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "myap://test.com", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "   ", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "no url", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "http://example.com////////////////////////////////////////////////////////////////////////////////////??", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://www.opensymphony.com", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "https://www.opensymphony.com", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "https://www.opensymphony.com:443/login", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://localhost:8080/myapp", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://253.254.255.1", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://253.254.255.1", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://253.254.255.12", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://253.254.255.12", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://1.2.3.100", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://1.2.3.100", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://1.2.3.255", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://1.2.3.255", "\"", ")", ")", ";", "}"], "idx": 7196, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "a05259ed69a5a48379aa91650e4cd1cb4bd6e5a", "function_name": "testValidUrlWithDefaultRegex", "body_hash": "6f04c30145194ef9b3f43961608f6ee74d6e80be"}
{"code": "public static DotCorpus parseDotCorpus(InputStream dotCorpusStream) throws CoreException {\r\n    DocumentBuilderFactory documentBuilderFacoty = DocumentBuilderFactory.newInstance();\r\n    try {\r\n      documentBuilderFacoty.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\r\n    } catch (ParserConfigurationException e1) {\r\n      throw new RuntimeException(e1);\r\n    }\r\n\r\n    DocumentBuilder documentBuilder;\r\n\r\n    try {\r\n      documentBuilder = documentBuilderFacoty.newDocumentBuilder();\r\n    } catch (ParserConfigurationException e) {\r\n      String message = \"This should never happen:\" + (e.getMessage() != null ? e.getMessage() : \"\");\r\n\r\n      IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\r\n\r\n      throw new CoreException(s);\r\n    }\r\n\r\n    org.w3c.dom.Document dotCorpusDOM;\r\n\r\n    try {\r\n      dotCorpusDOM = documentBuilder.parse(dotCorpusStream);\r\n    } catch (SAXException e) {\r\n      String message = e.getMessage() != null ? e.getMessage() : \"\";\r\n\r\n      IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\r\n\r\n      throw new CoreException(s);\r\n    } catch (IOException e) {\r\n      String message = e.getMessage() != null ? e.getMessage() : \"\";\r\n\r\n      IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\r\n\r\n      throw new CoreException(s);\r\n    }\r\n\r\n    DotCorpus dotCorpus = new DotCorpus();\r\n\r\n    // get corpora root element\r\n    Element configElement = dotCorpusDOM.getDocumentElement();\r\n\r\n    if (CONFIG_ELEMENT.equals(configElement.getNodeName())) {\r\n      // TODO:\r\n      // throw exception\r\n    }\r\n\r\n    NodeList corporaChildNodes = configElement.getChildNodes();\r\n\r\n    for (int i = 0; i < corporaChildNodes.getLength(); i++) {\r\n      Node corporaChildNode = corporaChildNodes.item(i);\r\n\r\n      if (!(corporaChildNode instanceof Element)) {\r\n        continue;\r\n      }\r\n\r\n      Element corporaChildElement = (Element) corporaChildNode;\r\n\r\n      // TODO: This code will emit NumberFormatExceptions if the values\r\n      // are incorrect, they should be caught, logged and replaced with default\r\n      // values\r\n      \r\n      if (TYPESYSTEM_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        dotCorpus.setTypeSystemFilename(corporaChildElement.getAttribute(TYPESYTEM_FILE_ATTRIBUTE));\r\n      } else if (CORPUS_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        String corpusFolderName = corporaChildElement.getAttribute(CORPUS_FOLDER_ATTRIBUTE);\r\n\r\n        dotCorpus.addCorpusFolder(corpusFolderName);\r\n      } else if (STYLE_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        String type = corporaChildElement.getAttribute(STYLE_TYPE_ATTRIBUTE);\r\n\r\n        String styleString = corporaChildElement.getAttribute(STYLE_STYLE_ATTRIBUTE);\r\n\r\n        int colorInteger = Integer\r\n                .parseInt(corporaChildElement.getAttribute(STYLE_COLOR_ATTRIBUTE));\r\n\r\n        Color color = new Color(colorInteger);\r\n\r\n        String drawingLayerString = corporaChildElement.getAttribute(STYLE_LAYER_ATTRIBUTE);\r\n        \r\n        String drawingConfigString = corporaChildElement.getAttribute(STYLE_CONFIG_ATTRIBUTE);\r\n        \r\n        if (drawingConfigString.length() == 0)\r\n          drawingConfigString = null;\r\n        \r\n        int drawingLayer;\r\n\r\n        try {\r\n          drawingLayer = Integer.parseInt(drawingLayerString);\r\n        } catch (NumberFormatException e) {\r\n          drawingLayer = 0;\r\n        }\r\n\r\n        AnnotationStyle style = new AnnotationStyle(type, AnnotationStyle.Style\r\n                .valueOf(styleString), color, drawingLayer, drawingConfigString);\r\n\r\n        dotCorpus.setStyle(style);\r\n      } else if (CAS_PROCESSOR_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        dotCorpus.addCasProcessorFolder(corporaChildElement\r\n                .getAttribute(CAS_PROCESSOR_FOLDER_ATTRIBUTE));\r\n      } else if (EDITOR_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        String lineLengthHintString = corporaChildElement\r\n                .getAttribute(EDITOR_LINE_LENGTH_ATTRIBUTE);\r\n\r\n        int lineLengthHint = Integer.parseInt(lineLengthHintString);\r\n\r\n        dotCorpus.setEditorLineLength(lineLengthHint);\r\n      } else if (SHOWN_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        String type = corporaChildElement.getAttribute(SHOWN_TYPE_ATTRIBUTE);\r\n        \r\n        String isVisisbleString = corporaChildElement.getAttribute(SHOWN_IS_VISISBLE_ATTRIBUTE);\r\n        \r\n        boolean isVisible = Boolean.parseBoolean(isVisisbleString);\r\n        \r\n        if (isVisible) {\r\n          dotCorpus.setShownType(type); \r\n        }\r\n      }\r\n      else {\r\n        String message = \"Unexpected element: \" + corporaChildElement.getNodeName();\r\n\r\n        IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, null);\r\n\r\n        throw new CoreException(s);\r\n      }\r\n    }\r\n\r\n    return dotCorpus;\r\n  }", "code_tokens": ["public", "static", "DotCorpus", "parseDotCorpus", "(", "InputStream", "dotCorpusStream", ")", "throws", "CoreException", "{", "DocumentBuilderFactory", "documentBuilderFacoty", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "try", "{", "documentBuilderFacoty", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "e1", ")", ";", "}", "DocumentBuilder", "documentBuilder", ";", "try", "{", "documentBuilder", "=", "documentBuilderFacoty", ".", "newDocumentBuilder", "(", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e", ")", "{", "String", "message", "=", "\"", "This should never happen:", "\"", "+", "(", "e", ".", "getMessage", "(", ")", "!=", "null", "?", "e", ".", "getMessage", "(", ")", ":", "\"", "\"", ")", ";", "IStatus", "s", "=", "new", "Status", "(", "IStatus", ".", "ERROR", ",", "CasEditorPlugin", ".", "ID", ",", "IStatus", ".", "OK", ",", "message", ",", "e", ")", ";", "throw", "new", "CoreException", "(", "s", ")", ";", "}", "org", ".", "w3c", ".", "dom", ".", "Document", "dotCorpusDOM", ";", "try", "{", "dotCorpusDOM", "=", "documentBuilder", ".", "parse", "(", "dotCorpusStream", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "String", "message", "=", "e", ".", "getMessage", "(", ")", "!=", "null", "?", "e", ".", "getMessage", "(", ")", ":", "\"", "\"", ";", "IStatus", "s", "=", "new", "Status", "(", "IStatus", ".", "ERROR", ",", "CasEditorPlugin", ".", "ID", ",", "IStatus", ".", "OK", ",", "message", ",", "e", ")", ";", "throw", "new", "CoreException", "(", "s", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "String", "message", "=", "e", ".", "getMessage", "(", ")", "!=", "null", "?", "e", ".", "getMessage", "(", ")", ":", "\"", "\"", ";", "IStatus", "s", "=", "new", "Status", "(", "IStatus", ".", "ERROR", ",", "CasEditorPlugin", ".", "ID", ",", "IStatus", ".", "OK", ",", "message", ",", "e", ")", ";", "throw", "new", "CoreException", "(", "s", ")", ";", "}", "DotCorpus", "dotCorpus", "=", "new", "DotCorpus", "(", ")", ";", "Element", "configElement", "=", "dotCorpusDOM", ".", "getDocumentElement", "(", ")", ";", "if", "(", "CONFIG_ELEMENT", ".", "equals", "(", "configElement", ".", "getNodeName", "(", ")", ")", ")", "{", "}", "NodeList", "corporaChildNodes", "=", "configElement", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "corporaChildNodes", ".", "getLength", "(", ")", ";", "i", "++", ")", "{", "Node", "corporaChildNode", "=", "corporaChildNodes", ".", "item", "(", "i", ")", ";", "if", "(", "!", "(", "corporaChildNode", "instanceof", "Element", ")", ")", "{", "continue", ";", "}", "Element", "corporaChildElement", "=", "(", "Element", ")", "corporaChildNode", ";", "if", "(", "TYPESYSTEM_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "dotCorpus", ".", "setTypeSystemFilename", "(", "corporaChildElement", ".", "getAttribute", "(", "TYPESYTEM_FILE_ATTRIBUTE", ")", ")", ";", "}", "else", "if", "(", "CORPUS_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "corpusFolderName", "=", "corporaChildElement", ".", "getAttribute", "(", "CORPUS_FOLDER_ATTRIBUTE", ")", ";", "dotCorpus", ".", "addCorpusFolder", "(", "corpusFolderName", ")", ";", "}", "else", "if", "(", "STYLE_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "type", "=", "corporaChildElement", ".", "getAttribute", "(", "STYLE_TYPE_ATTRIBUTE", ")", ";", "String", "styleString", "=", "corporaChildElement", ".", "getAttribute", "(", "STYLE_STYLE_ATTRIBUTE", ")", ";", "int", "colorInteger", "=", "Integer", ".", "parseInt", "(", "corporaChildElement", ".", "getAttribute", "(", "STYLE_COLOR_ATTRIBUTE", ")", ")", ";", "Color", "color", "=", "new", "Color", "(", "colorInteger", ")", ";", "String", "drawingLayerString", "=", "corporaChildElement", ".", "getAttribute", "(", "STYLE_LAYER_ATTRIBUTE", ")", ";", "String", "drawingConfigString", "=", "corporaChildElement", ".", "getAttribute", "(", "STYLE_CONFIG_ATTRIBUTE", ")", ";", "if", "(", "drawingConfigString", ".", "length", "(", ")", "==", "0", ")", "drawingConfigString", "=", "null", ";", "int", "drawingLayer", ";", "try", "{", "drawingLayer", "=", "Integer", ".", "parseInt", "(", "drawingLayerString", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "drawingLayer", "=", "0", ";", "}", "AnnotationStyle", "style", "=", "new", "AnnotationStyle", "(", "type", ",", "AnnotationStyle", ".", "Style", ".", "valueOf", "(", "styleString", ")", ",", "color", ",", "drawingLayer", ",", "drawingConfigString", ")", ";", "dotCorpus", ".", "setStyle", "(", "style", ")", ";", "}", "else", "if", "(", "CAS_PROCESSOR_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "dotCorpus", ".", "addCasProcessorFolder", "(", "corporaChildElement", ".", "getAttribute", "(", "CAS_PROCESSOR_FOLDER_ATTRIBUTE", ")", ")", ";", "}", "else", "if", "(", "EDITOR_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "lineLengthHintString", "=", "corporaChildElement", ".", "getAttribute", "(", "EDITOR_LINE_LENGTH_ATTRIBUTE", ")", ";", "int", "lineLengthHint", "=", "Integer", ".", "parseInt", "(", "lineLengthHintString", ")", ";", "dotCorpus", ".", "setEditorLineLength", "(", "lineLengthHint", ")", ";", "}", "else", "if", "(", "SHOWN_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "type", "=", "corporaChildElement", ".", "getAttribute", "(", "SHOWN_TYPE_ATTRIBUTE", ")", ";", "String", "isVisisbleString", "=", "corporaChildElement", ".", "getAttribute", "(", "SHOWN_IS_VISISBLE_ATTRIBUTE", ")", ";", "boolean", "isVisible", "=", "Boolean", ".", "parseBoolean", "(", "isVisisbleString", ")", ";", "if", "(", "isVisible", ")", "{", "dotCorpus", ".", "setShownType", "(", "type", ")", ";", "}", "}", "else", "{", "String", "message", "=", "\"", "Unexpected element: ", "\"", "+", "corporaChildElement", ".", "getNodeName", "(", ")", ";", "IStatus", "s", "=", "new", "Status", "(", "IStatus", ".", "ERROR", ",", "CasEditorPlugin", ".", "ID", ",", "IStatus", ".", "OK", ",", "message", ",", "null", ")", ";", "throw", "new", "CoreException", "(", "s", ")", ";", "}", "}", "return", "dotCorpus", ";", "}"], "idx": 70515, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "39909bf21fd694f4fb792d1de8adc72562ead25e", "function_name": "parseDotCorpus", "body_hash": "b1adceab73ac319473308451a4eb74276f4cc539"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (this.converters != null) {\n            setProperty(camelContext, dataFormat, \"converters\", this.converters);\n        }\n        if (this.aliases != null) {\n            setProperty(camelContext, dataFormat, \"aliases\", this.aliases);\n        }\n        if (this.omitFields != null) {\n            setProperty(camelContext, dataFormat, \"omitFields\", this.omitFields);\n        }\n        if (this.implicitCollections != null) {\n            setProperty(camelContext, dataFormat, \"implicitCollections\", this.implicitCollections);\n        }\n        if (this.mode != null) {\n            setProperty(camelContext, dataFormat, \"mode\", mode);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "encoding", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "encoding", "\"", ",", "encoding", ")", ";", "}", "if", "(", "this", ".", "converters", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "converters", "\"", ",", "this", ".", "converters", ")", ";", "}", "if", "(", "this", ".", "aliases", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "aliases", "\"", ",", "this", ".", "aliases", ")", ";", "}", "if", "(", "this", ".", "omitFields", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "omitFields", "\"", ",", "this", ".", "omitFields", ")", ";", "}", "if", "(", "this", ".", "implicitCollections", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "implicitCollections", "\"", ",", "this", ".", "implicitCollections", ")", ";", "}", "if", "(", "this", ".", "mode", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "mode", "\"", ",", "mode", ")", ";", "}", "}"], "idx": 3121, "cwe": "CWE-19", "target": 1, "status": "VULNERABLE", "commit": "4491c080cb6c8659fc05441e49307b7d4349aa56", "function_name": "configureDataFormat", "body_hash": "c4155bab3ee16b5ce7434519f5dd22b7da74b741"}
{"code": "private Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tList<Node> childNodes = fragment.childNodes();\n\t\tfor ( Node node : childNodes ) {\n\t\t\tdocument.body().appendChild( node.clone() );\n\t\t}\n\n\t\treturn document;\n\t}", "code_tokens": ["private", "Document", "getFragmentAsDocument", "(", "CharSequence", "value", ")", "{", "Document", "fragment", "=", "Jsoup", ".", "parse", "(", "value", ".", "toString", "(", ")", ",", "baseURI", ",", "Parser", ".", "xmlParser", "(", ")", ")", ";", "Document", "document", "=", "Document", ".", "createShell", "(", "baseURI", ")", ";", "List", "<", "Node", ">", "childNodes", "=", "fragment", ".", "childNodes", "(", ")", ";", "for", "(", "Node", "node", ":", "childNodes", ")", "{", "document", ".", "body", "(", ")", ".", "appendChild", "(", "node", ".", "clone", "(", ")", ")", ";", "}", "return", "document", ";", "}"], "idx": 79126, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "124b7dd6d9a4ad24d4d49f74701f05a13e56ceee", "function_name": "getFragmentAsDocument", "body_hash": "dcad1d120e431bf4b853558209a29208b3cee2af"}
{"code": "@Override\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\", token.getUsername());\n        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");\n        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);\n        \n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n        \n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n        \n        attributeNames.add(getUserEmailAttribute());\n        \n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n        }\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \"follow\");\n        \n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore()) \n                throw new UnknownAccountException(\"Unknown account\");\n            \n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"//\"));\n                buffer.append(\"//\");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \"//\"), \"/\"));\n                \n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\"ldap\")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \"//\");\n            \tuserDN = StringUtils.substringAfter(userDN, \"/\");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n            \n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n                \n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n                \n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) \n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n                \n                if (getUserSshKeyAttribute() != null) \n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n            \n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter) \n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n            \n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\"Email is required but not available in ldap directory\");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n        }\n\t}", "code_tokens": ["@", "Override", "public", "Authenticated", "authenticate", "(", "UsernamePasswordToken", "token", ")", "{", "String", "fullName", "=", "null", ";", "String", "email", "=", "null", ";", "Collection", "<", "String", ">", "groupNames", "=", "null", ";", "Collection", "<", "String", ">", "sshKeys", "=", "null", ";", "Name", "userSearchBase", ";", "try", "{", "userSearchBase", "=", "new", "CompositeName", "(", ")", ".", "add", "(", "getUserSearchBase", "(", ")", ")", ";", "}", "catch", "(", "InvalidNameException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "String", "userSearchFilter", "=", "StringUtils", ".", "replace", "(", "getUserSearchFilter", "(", ")", ",", "\"", "{0}", "\"", ",", "token", ".", "getUsername", "(", ")", ")", ";", "userSearchFilter", "=", "StringUtils", ".", "replace", "(", "userSearchFilter", ",", "\"", "\\\\", "\"", ",", "\"", "\\\\", "\\\\", "\"", ")", ";", "logger", ".", "debug", "(", "\"", "Evaluated user search filter: ", "\"", "+", "userSearchFilter", ")", ";", "SearchControls", "searchControls", "=", "new", "SearchControls", "(", ")", ";", "searchControls", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "List", "<", "String", ">", "attributeNames", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "if", "(", "getUserFullNameAttribute", "(", ")", "!=", "null", ")", "attributeNames", ".", "add", "(", "getUserFullNameAttribute", "(", ")", ")", ";", "if", "(", "getUserSshKeyAttribute", "(", ")", "!=", "null", ")", "attributeNames", ".", "add", "(", "getUserSshKeyAttribute", "(", ")", ")", ";", "attributeNames", ".", "add", "(", "getUserEmailAttribute", "(", ")", ")", ";", "if", "(", "getGroupRetrieval", "(", ")", "instanceof", "GetGroupsUsingAttribute", ")", "{", "GetGroupsUsingAttribute", "groupRetrieval", "=", "(", "GetGroupsUsingAttribute", ")", "getGroupRetrieval", "(", ")", ";", "attributeNames", ".", "add", "(", "groupRetrieval", ".", "getUserGroupsAttribute", "(", ")", ")", ";", "}", "searchControls", ".", "setReturningAttributes", "(", "(", "String", "[", "]", ")", "attributeNames", ".", "toArray", "(", "new", "String", "[", "0", "]", ")", ")", ";", "searchControls", ".", "setReturningObjFlag", "(", "true", ")", ";", "Hashtable", "<", "String", ",", "String", ">", "ldapEnv", "=", "new", "Hashtable", "<", ">", "(", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "INITIAL_CONTEXT_FACTORY", ",", "\"", "com.sun.jndi.ldap.LdapCtxFactory", "\"", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "PROVIDER_URL", ",", "getLdapUrl", "(", ")", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "\"", "simple", "\"", ")", ";", "ldapEnv", ".", "put", "(", "\"", "com.sun.jndi.ldap.connect.timeout", "\"", ",", "String", ".", "valueOf", "(", "getTimeout", "(", ")", "*", "1000L", ")", ")", ";", "ldapEnv", ".", "put", "(", "\"", "com.sun.jndi.ldap.read.timeout", "\"", ",", "String", ".", "valueOf", "(", "getTimeout", "(", ")", "*", "1000L", ")", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "REFERRAL", ",", "\"", "follow", "\"", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "getManagerDN", "(", ")", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "getManagerPassword", "(", ")", ")", ";", "DirContext", "ctx", "=", "null", ";", "DirContext", "referralCtx", "=", "null", ";", "try", "{", "logger", ".", "debug", "(", "\"", "Binding to ldap url '", "\"", "+", "getLdapUrl", "(", ")", "+", "\"", "'...", "\"", ")", ";", "try", "{", "ctx", "=", "new", "InitialDirContext", "(", "ldapEnv", ")", ";", "}", "catch", "(", "AuthenticationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Can not bind to ldap server '", "\"", "+", "getLdapUrl", "(", ")", "+", "\"", "': ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "}", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "ctx", ".", "search", "(", "userSearchBase", ",", "userSearchFilter", ",", "searchControls", ")", ";", "if", "(", "results", "==", "null", "||", "!", "results", ".", "hasMore", "(", ")", ")", "throw", "new", "UnknownAccountException", "(", "\"", "Unknown account", "\"", ")", ";", "SearchResult", "searchResult", "=", "(", "SearchResult", ")", "results", ".", "next", "(", ")", ";", "String", "userDN", "=", "searchResult", ".", "getNameInNamespace", "(", ")", ";", "if", "(", "!", "searchResult", ".", "isRelative", "(", ")", ")", "{", "StringBuffer", "buffer", "=", "new", "StringBuffer", "(", ")", ";", "buffer", ".", "append", "(", "StringUtils", ".", "substringBefore", "(", "searchResult", ".", "getName", "(", ")", ",", "\"", "//", "\"", ")", ")", ";", "buffer", ".", "append", "(", "\"", "//", "\"", ")", ";", "buffer", ".", "append", "(", "StringUtils", ".", "substringBefore", "(", "StringUtils", ".", "substringAfter", "(", "searchResult", ".", "getName", "(", ")", ",", "\"", "//", "\"", ")", ",", "\"", "/", "\"", ")", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "PROVIDER_URL", ",", "buffer", ".", "toString", "(", ")", ")", ";", "logger", ".", "debug", "(", "\"", "Binding to referral ldap url '", "\"", "+", "buffer", ".", "toString", "(", ")", "+", "\"", "'...", "\"", ")", ";", "referralCtx", "=", "new", "InitialDirContext", "(", "ldapEnv", ")", ";", "}", "if", "(", "userDN", ".", "startsWith", "(", "\"", "ldap", "\"", ")", ")", "{", "userDN", "=", "StringUtils", ".", "substringAfter", "(", "userDN", ",", "\"", "//", "\"", ")", ";", "userDN", "=", "StringUtils", ".", "substringAfter", "(", "userDN", ",", "\"", "/", "\"", ")", ";", "}", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "userDN", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "new", "String", "(", "token", ".", "getPassword", "(", ")", ")", ")", ";", "DirContext", "userCtx", "=", "null", ";", "try", "{", "logger", ".", "debug", "(", "\"", "Authenticating user by binding as '", "\"", "+", "userDN", "+", "\"", "'...", "\"", ")", ";", "userCtx", "=", "new", "InitialDirContext", "(", "ldapEnv", ")", ";", "}", "catch", "(", "AuthenticationException", "e", ")", "{", "throw", "new", "org", ".", "apache", ".", "shiro", ".", "authc", ".", "AuthenticationException", "(", "\"", "Unable to bind as '", "\"", "+", "userDN", "+", "\"", "'", "\"", ",", "e", ")", ";", "}", "finally", "{", "if", "(", "userCtx", "!=", "null", ")", "{", "try", "{", "userCtx", ".", "close", "(", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "}", "}", "}", "Attributes", "searchResultAttributes", "=", "searchResult", ".", "getAttributes", "(", ")", ";", "if", "(", "searchResultAttributes", "!=", "null", ")", "{", "if", "(", "getUserFullNameAttribute", "(", ")", "!=", "null", ")", "{", "Attribute", "attribute", "=", "searchResultAttributes", ".", "get", "(", "getUserFullNameAttribute", "(", ")", ")", ";", "if", "(", "attribute", "!=", "null", "&&", "attribute", ".", "get", "(", ")", "!=", "null", ")", "fullName", "=", "(", "String", ")", "attribute", ".", "get", "(", ")", ";", "}", "Attribute", "attribute", "=", "searchResultAttributes", ".", "get", "(", "getUserEmailAttribute", "(", ")", ")", ";", "if", "(", "attribute", "!=", "null", "&&", "attribute", ".", "get", "(", ")", "!=", "null", ")", "email", "=", "(", "String", ")", "attribute", ".", "get", "(", ")", ";", "if", "(", "getGroupRetrieval", "(", ")", "instanceof", "GetGroupsUsingAttribute", ")", "groupNames", "=", "retrieveGroupsByAttribute", "(", "ctx", ",", "referralCtx", ",", "searchResultAttributes", ")", ";", "if", "(", "getUserSshKeyAttribute", "(", ")", "!=", "null", ")", "sshKeys", "=", "retrieveSshKeys", "(", "searchResultAttributes", ")", ";", "}", "if", "(", "getGroupRetrieval", "(", ")", "instanceof", "SearchGroupsUsingFilter", ")", "groupNames", "=", "retrieveGroupsByFilter", "(", "ctx", ",", "referralCtx", ",", "userDN", ")", ";", "if", "(", "StringUtils", ".", "isBlank", "(", "email", ")", ")", "throw", "new", "AccountException", "(", "\"", "Email is required but not available in ldap directory", "\"", ")", ";", "else", "return", "new", "Authenticated", "(", "email", ",", "fullName", ",", "groupNames", ",", "sshKeys", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "finally", "{", "if", "(", "ctx", "!=", "null", ")", "{", "try", "{", "ctx", ".", "close", "(", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "}", "}", "if", "(", "referralCtx", "!=", "null", ")", "{", "try", "{", "referralCtx", ".", "close", "(", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "}", "}", "}", "}"], "idx": 92844, "cwe": "CWE-90", "target": 1, "status": "VULNERABLE", "commit": "4440f0c57e440488d7e653417b2547eaae8ad19c", "function_name": "authenticate", "body_hash": "a27eb8d735c71d7a084b10385fccf7de13cf696f"}
{"code": "public C3P0Config findConfig() throws Exception\n    {\n\tC3P0Config out;\n\n\tHashMap flatDefaults = C3P0ConfigUtils.extractHardcodedC3P0Defaults();\n\n\t// this includes System properties, but we have to check for System properties\n\t// again, since we want system properties to override unspecified user, default-config\n\t// properties in the XML\n\tflatDefaults.putAll( C3P0ConfigUtils.extractC3P0PropertiesResources() );\n\n\tString cfgFile = C3P0Config.getPropsFileConfigProperty( XML_CFG_FILE_KEY );\n\tboolean expandEntityReferences = findExpandEntityReferences();\n\t\n\tif (cfgFile == null)\n\t    {\n\t\tC3P0Config xmlConfig = C3P0ConfigXmlUtils.extractXmlConfigFromDefaultResource( expandEntityReferences );\n\t\tif (xmlConfig != null)\n\t\t    {\n\t\t\tinsertDefaultsUnderNascentConfig( flatDefaults, xmlConfig );\n\t\t\tout = xmlConfig;\n\t\t\t\n\t\t\tmbOverrideWarning(\"resource\", C3P0ConfigXmlUtils.XML_CONFIG_RSRC_PATH);\n\t\t    }\n\t\telse\n\t\t    out = C3P0ConfigUtils.configFromFlatDefaults( flatDefaults );\n\t    }\n\telse\n\t    {\n\t\tcfgFile = cfgFile.trim();\n\n\t\tInputStream is = null;\n\t\ttry\n\t\t    {\n\t\t\tif ( cfgFile.startsWith( CLASSLOADER_RESOURCE_PREFIX ) )\n\t\t\t{\n\t\t\t    ClassLoader cl = this.getClass().getClassLoader();\n\t\t\t    String rsrcPath = cfgFile.substring( CLASSLOADER_RESOURCE_PREFIX.length() );\n\n\t\t\t    // eliminate leading slash because ClassLoader.getResource\n\t\t\t    // is always absolute and does not expect a leading slash\n\t\t\t    if (rsrcPath.startsWith(\"/\")) \n\t\t\t\trsrcPath = rsrcPath.substring(1);\n\n\t\t\t    is = cl.getResourceAsStream( rsrcPath );\n\t\t\t    if ( is == null )\n\t\t\t\tthrow new FileNotFoundException(\"Specified ClassLoader resource '\" + rsrcPath + \"' could not be found. \" +\n\t\t\t\t\t\t\t\t\"[ Found in configuration: \" + XML_CFG_FILE_KEY + '=' + cfgFile + \" ]\");\n\n\t\t\t    mbOverrideWarning( \"resource\", rsrcPath );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    is = new BufferedInputStream( new FileInputStream( cfgFile ) );\n\t\t\t    mbOverrideWarning( \"file\", cfgFile );\n\t\t\t}\n\n\t\t\tC3P0Config xmlConfig = C3P0ConfigXmlUtils.extractXmlConfigFromInputStream( is, expandEntityReferences );\n\t\t\tinsertDefaultsUnderNascentConfig( flatDefaults, xmlConfig );\n\t\t\tout = xmlConfig;\n\t\t    }\n\t\tfinally\n\t\t    {\n\t\t\ttry { if (is != null) is.close();}\n\t\t\tcatch (Exception e)\n\t\t\t    { e.printStackTrace(); }\n\t\t    }\n\t    }\n\n\t// overwrite default, unspecified user config with System properties\n\t// defined values\n\tProperties sysPropConfig = C3P0ConfigUtils.findAllC3P0SystemProperties();\n\tout.defaultConfig.props.putAll( sysPropConfig );\n\n\treturn out;\n    }", "code_tokens": ["public", "C3P0Config", "findConfig", "(", ")", "throws", "Exception", "{", "C3P0Config", "out", ";", "HashMap", "flatDefaults", "=", "C3P0ConfigUtils", ".", "extractHardcodedC3P0Defaults", "(", ")", ";", "flatDefaults", ".", "putAll", "(", "C3P0ConfigUtils", ".", "extractC3P0PropertiesResources", "(", ")", ")", ";", "String", "cfgFile", "=", "C3P0Config", ".", "getPropsFileConfigProperty", "(", "XML_CFG_FILE_KEY", ")", ";", "boolean", "expandEntityReferences", "=", "findExpandEntityReferences", "(", ")", ";", "if", "(", "cfgFile", "==", "null", ")", "{", "C3P0Config", "xmlConfig", "=", "C3P0ConfigXmlUtils", ".", "extractXmlConfigFromDefaultResource", "(", "expandEntityReferences", ")", ";", "if", "(", "xmlConfig", "!=", "null", ")", "{", "insertDefaultsUnderNascentConfig", "(", "flatDefaults", ",", "xmlConfig", ")", ";", "out", "=", "xmlConfig", ";", "mbOverrideWarning", "(", "\"", "resource", "\"", ",", "C3P0ConfigXmlUtils", ".", "XML_CONFIG_RSRC_PATH", ")", ";", "}", "else", "out", "=", "C3P0ConfigUtils", ".", "configFromFlatDefaults", "(", "flatDefaults", ")", ";", "}", "else", "{", "cfgFile", "=", "cfgFile", ".", "trim", "(", ")", ";", "InputStream", "is", "=", "null", ";", "try", "{", "if", "(", "cfgFile", ".", "startsWith", "(", "CLASSLOADER_RESOURCE_PREFIX", ")", ")", "{", "ClassLoader", "cl", "=", "this", ".", "getClass", "(", ")", ".", "getClassLoader", "(", ")", ";", "String", "rsrcPath", "=", "cfgFile", ".", "substring", "(", "CLASSLOADER_RESOURCE_PREFIX", ".", "length", "(", ")", ")", ";", "if", "(", "rsrcPath", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "rsrcPath", "=", "rsrcPath", ".", "substring", "(", "1", ")", ";", "is", "=", "cl", ".", "getResourceAsStream", "(", "rsrcPath", ")", ";", "if", "(", "is", "==", "null", ")", "throw", "new", "FileNotFoundException", "(", "\"", "Specified ClassLoader resource '", "\"", "+", "rsrcPath", "+", "\"", "' could not be found. ", "\"", "+", "\"", "[ Found in configuration: ", "\"", "+", "XML_CFG_FILE_KEY", "+", "'='", "+", "cfgFile", "+", "\"", " ]", "\"", ")", ";", "mbOverrideWarning", "(", "\"", "resource", "\"", ",", "rsrcPath", ")", ";", "}", "else", "{", "is", "=", "new", "BufferedInputStream", "(", "new", "FileInputStream", "(", "cfgFile", ")", ")", ";", "mbOverrideWarning", "(", "\"", "file", "\"", ",", "cfgFile", ")", ";", "}", "C3P0Config", "xmlConfig", "=", "C3P0ConfigXmlUtils", ".", "extractXmlConfigFromInputStream", "(", "is", ",", "expandEntityReferences", ")", ";", "insertDefaultsUnderNascentConfig", "(", "flatDefaults", ",", "xmlConfig", ")", ";", "out", "=", "xmlConfig", ";", "}", "finally", "{", "try", "{", "if", "(", "is", "!=", "null", ")", "is", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "}", "}", "Properties", "sysPropConfig", "=", "C3P0ConfigUtils", ".", "findAllC3P0SystemProperties", "(", ")", ";", "out", ".", "defaultConfig", ".", "props", ".", "putAll", "(", "sysPropConfig", ")", ";", "return", "out", ";", "}"], "idx": 76602, "cwe": "CWE-776", "target": 1, "status": "VULNERABLE", "commit": "f38f27635c384806c2a9d6500d80183d9f09d78b", "function_name": "findConfig", "body_hash": "7d8d02338bf04ffe8d7fb87c0c51fb36d7fa81cb"}
{"code": "private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    int length = s.readInt();\n    ImmutableLongArray.Builder builder = ImmutableLongArray.builder();\n    for (int i = 0; i < length; i++) {\n      builder.add(doubleToRawLongBits(s.readDouble()));\n    }\n    this.longs = new AtomicLongArray(builder.build().toArray());\n  }", "code_tokens": ["private", "void", "readObject", "(", "java", ".", "io", ".", "ObjectInputStream", "s", ")", "throws", "java", ".", "io", ".", "IOException", ",", "ClassNotFoundException", "{", "s", ".", "defaultReadObject", "(", ")", ";", "int", "length", "=", "s", ".", "readInt", "(", ")", ";", "ImmutableLongArray", ".", "Builder", "builder", "=", "ImmutableLongArray", ".", "builder", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "length", ";", "i", "++", ")", "{", "builder", ".", "add", "(", "doubleToRawLongBits", "(", "s", ".", "readDouble", "(", ")", ")", ")", ";", "}", "this", ".", "longs", "=", "new", "AtomicLongArray", "(", "builder", ".", "build", "(", ")", ".", "toArray", "(", ")", ")", ";", "}"], "idx": 75357, "cwe": "CWE-770", "target": 0, "status": "FIXED", "commit": "f89ece5721b2f637fe754937ff1f3c86d80bb196", "function_name": "readObject", "body_hash": "a81538a8d149e6f263dbc7349a0aa1dbb2a68fc3"}
{"code": "public static void enableDefaultTyping(ObjectMapper mapper) {\n\t\tif(mapper != null) {\n\t\t\tTypeResolverBuilder<?> typeBuilder = mapper.getDeserializationConfig().getDefaultTyper(null);\n\t\t\tif (typeBuilder == null) {\n\t\t\t\tmapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["public", "static", "void", "enableDefaultTyping", "(", "ObjectMapper", "mapper", ")", "{", "if", "(", "mapper", "!=", "null", ")", "{", "TypeResolverBuilder", "<", "?", ">", "typeBuilder", "=", "mapper", ".", "getDeserializationConfig", "(", ")", ".", "getDefaultTyper", "(", "null", ")", ";", "if", "(", "typeBuilder", "==", "null", ")", "{", "mapper", ".", "enableDefaultTyping", "(", "ObjectMapper", ".", "DefaultTyping", ".", "NON_FINAL", ",", "JsonTypeInfo", ".", "As", ".", "PROPERTY", ")", ";", "}", "}", "}"], "idx": 59034, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "5dee8534cd1b92952d10cc56335b5d5856f48f3b", "function_name": "enableDefaultTyping", "body_hash": "da8f29be1f5f60e69af5af0f16982549d4dd7135"}
{"code": "protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)\n    {\n        for (int i = 0; i != 5 * bitlength; i++)\n        {\n            BigInteger p = new BigInteger(bitlength, 1, param.getRandom());\n\n            if (p.mod(e).equals(ONE))\n            {\n                continue;\n            }\n\n            if (p.multiply(p).compareTo(sqrdBound) < 0)\n            {\n                continue;\n            }\n\n            if (!isProbablePrime(p))\n            {\n                continue;\n            }\n\n            if (!e.gcd(p.subtract(ONE)).equals(ONE))\n            {\n                continue;\n            }\n\n            return p;\n        }\n\n        throw new IllegalStateException(\"unable to generate prime number for RSA key\");\n    }", "code_tokens": ["protected", "BigInteger", "chooseRandomPrime", "(", "int", "bitlength", ",", "BigInteger", "e", ",", "BigInteger", "sqrdBound", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "5", "*", "bitlength", ";", "i", "++", ")", "{", "BigInteger", "p", "=", "new", "BigInteger", "(", "bitlength", ",", "1", ",", "param", ".", "getRandom", "(", ")", ")", ";", "if", "(", "p", ".", "mod", "(", "e", ")", ".", "equals", "(", "ONE", ")", ")", "{", "continue", ";", "}", "if", "(", "p", ".", "multiply", "(", "p", ")", ".", "compareTo", "(", "sqrdBound", ")", "<", "0", ")", "{", "continue", ";", "}", "if", "(", "!", "isProbablePrime", "(", "p", ")", ")", "{", "continue", ";", "}", "if", "(", "!", "e", ".", "gcd", "(", "p", ".", "subtract", "(", "ONE", ")", ")", ".", "equals", "(", "ONE", ")", ")", "{", "continue", ";", "}", "return", "p", ";", "}", "throw", "new", "IllegalStateException", "(", "\"", "unable to generate prime number for RSA key", "\"", ")", ";", "}"], "idx": 42145, "cwe": "CWE-327", "target": 0, "status": "FIXED", "commit": "22467b6e8fe19717ecdf201c0cf91bacf04a55ad", "function_name": "chooseRandomPrime", "body_hash": "6b79845830a77df9d70ca954054d3c0c25b7442c"}
{"code": "protected String parseFor(final String infoName) throws ParserConfigurationException, SAXException, IOException {\n            SAXParserFactory factory = SAXParserFactory.newInstance();\n            factory.setValidating(false);\n            factory.setNamespaceAware(false);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n            SAXParser saxParser = factory.newSAXParser();\n            ReadInfoHandler riHandler = new ReadInfoHandler(infoName);\n            try {\n                saxParser.parse(this.reportFile, riHandler);\n            } catch (BreakParsingException e) {\n                // break parsing\n            }\n            return riHandler.getInfo();\n        }", "code_tokens": ["protected", "String", "parseFor", "(", "final", "String", "infoName", ")", "throws", "ParserConfigurationException", ",", "SAXException", ",", "IOException", "{", "SAXParserFactory", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setValidating", "(", "false", ")", ";", "factory", ".", "setNamespaceAware", "(", "false", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "SAXParser", "saxParser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "ReadInfoHandler", "riHandler", "=", "new", "ReadInfoHandler", "(", "infoName", ")", ";", "try", "{", "saxParser", ".", "parse", "(", "this", ".", "reportFile", ",", "riHandler", ")", ";", "}", "catch", "(", "BreakParsingException", "e", ")", "{", "}", "return", "riHandler", ".", "getInfo", "(", ")", ";", "}"], "idx": 69647, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "5ca59b8c7d23af4450dc7f19c1b4107d59063ae1", "function_name": "parseFor", "body_hash": "267429ace20cad84423318565d82ff22e04cc05f"}
{"code": "@RequestMapping(value = \"/accept.do\", method = POST)\n    public String acceptInvitation(@RequestParam(\"password\") String password,\n                                   @RequestParam(\"password_confirmation\") String passwordConfirmation,\n                                   @RequestParam(\"code\") String code,\n                                   Model model,\n                                   HttpServletRequest request,\n                                   HttpServletResponse response) throws IOException {\n\n        PasswordConfirmationValidation validation = new PasswordConfirmationValidation(password, passwordConfirmation);\n\n        UaaPrincipal principal =  (UaaPrincipal) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n\n        if (!validation.valid()) {\n           return processErrorReload(code, model, principal.getEmail(), response, \"error_message_code\", validation.getMessageCode());\n//           return handleUnprocessableEntity(model, response, \"error_message_code\", validation.getMessageCode(), \"invitations/accept_invite\");\n        }\n        try {\n            passwordValidator.validate(password);\n        } catch (InvalidPasswordException e) {\n            return processErrorReload(code, model, principal.getEmail(), response, \"error_message\", e.getMessagesAsOneString());\n//            return handleUnprocessableEntity(model, response, \"error_message\", e.getMessagesAsOneString(), \"invitations/accept_invite\");\n        }\n        AcceptedInvitation invitation;\n        try {\n            invitation = invitationsService.acceptInvitation(code, password);\n        } catch (HttpClientErrorException e) {\n            return handleUnprocessableEntity(model, response, \"error_message_code\", \"code_expired\", \"invitations/accept_invite\");\n        }\n        principal = new UaaPrincipal(\n            invitation.getUser().getId(),\n            invitation.getUser().getUserName(),\n            invitation.getUser().getPrimaryEmail(),\n            invitation.getUser().getOrigin(),\n            invitation.getUser().getExternalId(),\n            IdentityZoneHolder.get().getId()\n        );\n        UaaAuthentication authentication = new UaaAuthentication(principal, UaaAuthority.USER_AUTHORITIES, new UaaAuthenticationDetails(request));\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        return \"redirect:\" + invitation.getRedirectUri();\n    }", "code_tokens": ["@", "RequestMapping", "(", "value", "=", "\"", "/accept.do", "\"", ",", "method", "=", "POST", ")", "public", "String", "acceptInvitation", "(", "@", "RequestParam", "(", "\"", "password", "\"", ")", "String", "password", ",", "@", "RequestParam", "(", "\"", "password_confirmation", "\"", ")", "String", "passwordConfirmation", ",", "@", "RequestParam", "(", "\"", "code", "\"", ")", "String", "code", ",", "Model", "model", ",", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "IOException", "{", "PasswordConfirmationValidation", "validation", "=", "new", "PasswordConfirmationValidation", "(", "password", ",", "passwordConfirmation", ")", ";", "UaaPrincipal", "principal", "=", "(", "UaaPrincipal", ")", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "getAuthentication", "(", ")", ".", "getPrincipal", "(", ")", ";", "if", "(", "!", "validation", ".", "valid", "(", ")", ")", "{", "return", "processErrorReload", "(", "code", ",", "model", ",", "principal", ".", "getEmail", "(", ")", ",", "response", ",", "\"", "error_message_code", "\"", ",", "validation", ".", "getMessageCode", "(", ")", ")", ";", "}", "try", "{", "passwordValidator", ".", "validate", "(", "password", ")", ";", "}", "catch", "(", "InvalidPasswordException", "e", ")", "{", "return", "processErrorReload", "(", "code", ",", "model", ",", "principal", ".", "getEmail", "(", ")", ",", "response", ",", "\"", "error_message", "\"", ",", "e", ".", "getMessagesAsOneString", "(", ")", ")", ";", "}", "AcceptedInvitation", "invitation", ";", "try", "{", "invitation", "=", "invitationsService", ".", "acceptInvitation", "(", "code", ",", "password", ")", ";", "}", "catch", "(", "HttpClientErrorException", "e", ")", "{", "return", "handleUnprocessableEntity", "(", "model", ",", "response", ",", "\"", "error_message_code", "\"", ",", "\"", "code_expired", "\"", ",", "\"", "invitations/accept_invite", "\"", ")", ";", "}", "principal", "=", "new", "UaaPrincipal", "(", "invitation", ".", "getUser", "(", ")", ".", "getId", "(", ")", ",", "invitation", ".", "getUser", "(", ")", ".", "getUserName", "(", ")", ",", "invitation", ".", "getUser", "(", ")", ".", "getPrimaryEmail", "(", ")", ",", "invitation", ".", "getUser", "(", ")", ".", "getOrigin", "(", ")", ",", "invitation", ".", "getUser", "(", ")", ".", "getExternalId", "(", ")", ",", "IdentityZoneHolder", ".", "get", "(", ")", ".", "getId", "(", ")", ")", ";", "UaaAuthentication", "authentication", "=", "new", "UaaAuthentication", "(", "principal", ",", "UaaAuthority", ".", "USER_AUTHORITIES", ",", "new", "UaaAuthenticationDetails", "(", "request", ")", ")", ";", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "setAuthentication", "(", "authentication", ")", ";", "return", "\"", "redirect:", "\"", "+", "invitation", ".", "getRedirectUri", "(", ")", ";", "}"], "idx": 35653, "cwe": "CWE-269", "target": 1, "status": "VULNERABLE", "commit": "4f942064d85454a4bcc4da04cd482d114816c14a", "function_name": "acceptInvitation", "body_hash": "19596b78ed805b49c115ae4c63a4a8ce5378dd59"}
{"code": "public static void main(String[] args) throws Exception {\r\n                System.out.println(\"_________________________________________________\");\r\n                System.out.println(\"Configure options using uddi.xml and tck.properties\");\r\n                System.out.println(\"java -Duddi.client.xml=uddi.xml -jar juddi-tck-runner-{VERSION}-SNAPSHOT-jar-with-dependencies.jar\");\r\n                System.out.println(\"_________________________________________________\");\r\n                System.out.println();\r\n                System.out.println(\"Options\");\r\n                System.out.println(\"-Dtests=TestClass1,TestClass2    Comma delimited set of focused tests to run\");\r\n                System.out.println(\"_________________________________________________\");\r\n                System.out.println(\"Running! this can take anywhere from 2-5 minutes!\");\r\n                System.out.println(\"\");\r\n                if (!new File(\"tck.properties\").exists()) {\r\n                        System.out.println(\"tck.properties was not found! I give up!\");\r\n                        System.exit(1);\r\n                }\r\n                String s = System.getProperty(\"uddi.client.xml\");\r\n                if (s == null || !new File(s).exists()) {\r\n                        System.out.println(\"The value for option -Duddi.client.xml=\" + s + \" is either null or the file doesn't exist! I give up!\");\r\n                        System.exit(1);\r\n                }\r\n                String focusedTests = System.getProperty(\"tests\");\r\n                Result result = null;\r\n                JUnitCore junit = new JUnitCore();\r\n                Class[] cs = null;\r\n                if (focusedTests != null) {\r\n                        String[] items = focusedTests.split(\",\");\r\n                        cs = new Class[items.length];\r\n                        for (int i = 0; i < items.length; i++) {\r\n                                cs[i] = Class.forName(items[i]);\r\n                        }\r\n                } else {\r\n                        cs = new Class[]{\r\n                                //the bpel tests really only test wsdl to uddi\r\n                                org.apache.juddi.v2.tck.UDDI_020_TmodelIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_030_BusinessEntityIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_040_BusinessServiceIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_050_BindingTemplateIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_060_PublisherAssertionIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_070_FindEntityIntegrationTest.class,\r\n                                org.apache.juddi.v3.bpel.BPEL_010_IntegrationTest.class,\r\n                                org.apache.juddi.v3.bpel.BPEL_020_IntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.JUDDI_010_PublisherIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.JUDDI_100_ClientSubscriptionInfoIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.JUDDI_300_MultiNodeIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_010_PublisherIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_020_TmodelIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_030_BusinessEntityIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_030_BusinessEntityLoadIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_040_BusinessServiceIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_040_PerformanceIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_040_BusinessServiceLoadIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_050_BindingTemplateIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_060_PublisherAssertionIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_070_FindEntityIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_080_SubscriptionIntegrationTest.class,\r\n                                //note that this is different, there is an IntegrationTest version\r\n                                //however it's for hosting our own mail server and reconfiguring juddi\r\n                                //org.apache.juddi.v3.tck.UDDI_090_SubscriptionListenerExternalTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_090_HttpExternalTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_090_Smtp_ExternalTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_090_RMIIntegrationTest.class,\r\n                                //org.apache.juddi.v3.tck.JUDDI_091_RMISubscriptionListenerIntegrationTest.class,\r\n                                \r\n                                org.apache.juddi.v3.tck.UDDI_110_FindBusinessIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_120_CombineCategoryBagsFindServiceIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_130_CombineCategoryBagsFindBusinessIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_140_NegativePublicationIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_141_JIRAIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_142_DigitalSignatureIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_150_CustodyTransferIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_160_RESTIntergrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_170_ValueSetValidationIntegrationTest.class\r\n                        };\r\n                }\r\n\r\n                result = junit.run(cs);\r\n\r\n                String filename = \"uddi-tck-results-\" + new SimpleDateFormat(\"yyyyMMddhhmm\").format(new Date()) + \".txt\";\r\n                FileWriter fw = new FileWriter(filename);\r\n\r\n                BufferedWriter bw = new BufferedWriter(fw);\r\n                bw.write(\"UDDI-TCK Test Results generated \" + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\").format(new Date()));\r\n                bw.newLine();\r\n                bw.write(\"____________________________________________\");\r\n                bw.newLine();\r\n                bw.write(\"Summary\");\r\n                bw.newLine();\r\n                bw.write(\"Failed Test Cases: \" + result.getFailureCount());\r\n                bw.newLine();\r\n                bw.write(\"Skipped Test Cases: \" + result.getIgnoreCount());\r\n                bw.newLine();\r\n                bw.write(\"Ran Test Cases: \" + result.getRunCount());\r\n                bw.newLine();\r\n                bw.write(\"Time: \" + result.getRunTime());\r\n                bw.newLine();\r\n                bw.write(\"____________________________________________\");\r\n\r\n                bw.newLine();\r\n                bw.write(\"Tests Ran\");\r\n                bw.newLine();\r\n                for (int i = 0; i < cs.length; i++) {\r\n                        bw.write(cs[i].getCanonicalName());\r\n                        bw.newLine();\r\n                }\r\n                bw.write(\"____________________________________________\");\r\n                bw.newLine();\r\n                bw.write(\"Failed Test cases\");\r\n                bw.newLine();\r\n                bw.write(\"____________________________________________\");\r\n                bw.newLine();\r\n                for (int i = 0; i < result.getFailures().size(); i++) {\r\n                        try {\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getTestHeader());\r\n                                } catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getDescription().getClassName());\r\n                                }\r\n                                catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getDescription().getMethodName() == null ? \"null method!\" : result.getFailures().get(i).getDescription().getMethodName());\r\n                                } catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getMessage() == null ? \"no message\" : result.getFailures().get(i).getMessage());\r\n                                } catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                //result.getFailures().get(i).getException().printStackTrace();\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getTrace());\r\n                                } catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                bw.write(\"____________________________________________\");\r\n                                bw.newLine();\r\n                        } catch (Exception ex) {\r\n                                ex.printStackTrace();\r\n                        }\r\n                }\r\n                System.out.println(\"____________________________________________\");\r\n                System.out.println(\"Summary\");\r\n                System.out.println(\"Failed Test Cases: \" + result.getFailureCount());\r\n                System.out.println(\"Skipped Test Cases: \" + result.getIgnoreCount());\r\n                System.out.println(\"Ran Test Cases: \" + result.getRunCount());\r\n                System.out.println(\"Time: \" + result.getRunTime() + \"ms which is \" +\r\n                org.apache.commons.lang.time.DurationFormatUtils.formatDurationHMS(result.getRunTime()));\r\n                System.out.println(\"-------------------------------------\");\r\n                System.out.println(\"Results written to \" + filename);\r\n\r\n                bw.close();\r\n                fw.close();\r\n                junit = null;\r\n                System.out.println(\"Exit code: \" + result.getFailureCount());\r\n                System.exit(result.getFailureCount());\r\n        }", "code_tokens": ["public", "static", "void", "main", "(", "String", "[", "]", "args", ")", "throws", "Exception", "{", "System", ".", "out", ".", "println", "(", "\"", "_________________________________________________", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Configure options using uddi.xml and tck.properties", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "java -Duddi.client.xml=uddi.xml -jar juddi-tck-runner-{VERSION}-SNAPSHOT-jar-with-dependencies.jar", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "_________________________________________________", "\"", ")", ";", "System", ".", "out", ".", "println", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Options", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "-Dtests=TestClass1,TestClass2    Comma delimited set of focused tests to run", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "_________________________________________________", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Running! this can take anywhere from 2-5 minutes!", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "\"", ")", ";", "if", "(", "!", "new", "File", "(", "\"", "tck.properties", "\"", ")", ".", "exists", "(", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "tck.properties was not found! I give up!", "\"", ")", ";", "System", ".", "exit", "(", "1", ")", ";", "}", "String", "s", "=", "System", ".", "getProperty", "(", "\"", "uddi.client.xml", "\"", ")", ";", "if", "(", "s", "==", "null", "||", "!", "new", "File", "(", "s", ")", ".", "exists", "(", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "The value for option -Duddi.client.xml=", "\"", "+", "s", "+", "\"", " is either null or the file doesn't exist! I give up!", "\"", ")", ";", "System", ".", "exit", "(", "1", ")", ";", "}", "String", "focusedTests", "=", "System", ".", "getProperty", "(", "\"", "tests", "\"", ")", ";", "Result", "result", "=", "null", ";", "JUnitCore", "junit", "=", "new", "JUnitCore", "(", ")", ";", "Class", "[", "]", "cs", "=", "null", ";", "if", "(", "focusedTests", "!=", "null", ")", "{", "String", "[", "]", "items", "=", "focusedTests", ".", "split", "(", "\"", ",", "\"", ")", ";", "cs", "=", "new", "Class", "[", "items", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "items", ".", "length", ";", "i", "++", ")", "{", "cs", "[", "i", "]", "=", "Class", ".", "forName", "(", "items", "[", "i", "]", ")", ";", "}", "}", "else", "{", "cs", "=", "new", "Class", "[", "]", "{", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_020_TmodelIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_030_BusinessEntityIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_040_BusinessServiceIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_050_BindingTemplateIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_060_PublisherAssertionIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_070_FindEntityIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "bpel", ".", "BPEL_010_IntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "bpel", ".", "BPEL_020_IntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "JUDDI_010_PublisherIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "JUDDI_100_ClientSubscriptionInfoIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "JUDDI_300_MultiNodeIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_010_PublisherIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_020_TmodelIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_030_BusinessEntityIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_030_BusinessEntityLoadIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_040_BusinessServiceIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_040_PerformanceIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_040_BusinessServiceLoadIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_050_BindingTemplateIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_060_PublisherAssertionIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_070_FindEntityIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_080_SubscriptionIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_090_HttpExternalTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_090_Smtp_ExternalTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_090_RMIIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_110_FindBusinessIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_120_CombineCategoryBagsFindServiceIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_130_CombineCategoryBagsFindBusinessIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_140_NegativePublicationIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_141_JIRAIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_142_DigitalSignatureIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_150_CustodyTransferIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_160_RESTIntergrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_170_ValueSetValidationIntegrationTest", ".", "class", "}", ";", "}", "result", "=", "junit", ".", "run", "(", "cs", ")", ";", "String", "filename", "=", "\"", "uddi-tck-results-", "\"", "+", "new", "SimpleDateFormat", "(", "\"", "yyyyMMddhhmm", "\"", ")", ".", "format", "(", "new", "Date", "(", ")", ")", "+", "\"", ".txt", "\"", ";", "FileWriter", "fw", "=", "new", "FileWriter", "(", "filename", ")", ";", "BufferedWriter", "bw", "=", "new", "BufferedWriter", "(", "fw", ")", ";", "bw", ".", "write", "(", "\"", "UDDI-TCK Test Results generated ", "\"", "+", "new", "SimpleDateFormat", "(", "\"", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "\"", ")", ".", "format", "(", "new", "Date", "(", ")", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Summary", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Failed Test Cases: ", "\"", "+", "result", ".", "getFailureCount", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Skipped Test Cases: ", "\"", "+", "result", ".", "getIgnoreCount", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Ran Test Cases: ", "\"", "+", "result", ".", "getRunCount", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Time: ", "\"", "+", "result", ".", "getRunTime", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Tests Ran", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "cs", ".", "length", ";", "i", "++", ")", "{", "bw", ".", "write", "(", "cs", "[", "i", "]", ".", "getCanonicalName", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "}", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Failed Test cases", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "result", ".", "getFailures", "(", ")", ".", "size", "(", ")", ";", "i", "++", ")", "{", "try", "{", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getTestHeader", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getDescription", "(", ")", ".", "getClassName", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getDescription", "(", ")", ".", "getMethodName", "(", ")", "==", "null", "?", "\"", "null method!", "\"", ":", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getDescription", "(", ")", ".", "getMethodName", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getMessage", "(", ")", "==", "null", "?", "\"", "no message", "\"", ":", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getMessage", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getTrace", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "}", "}", "System", ".", "out", ".", "println", "(", "\"", "____________________________________________", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Summary", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Failed Test Cases: ", "\"", "+", "result", ".", "getFailureCount", "(", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Skipped Test Cases: ", "\"", "+", "result", ".", "getIgnoreCount", "(", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Ran Test Cases: ", "\"", "+", "result", ".", "getRunCount", "(", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Time: ", "\"", "+", "result", ".", "getRunTime", "(", ")", "+", "\"", "ms which is ", "\"", "+", "org", ".", "apache", ".", "commons", ".", "lang", ".", "time", ".", "DurationFormatUtils", ".", "formatDurationHMS", "(", "result", ".", "getRunTime", "(", ")", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "-------------------------------------", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Results written to ", "\"", "+", "filename", ")", ";", "bw", ".", "close", "(", ")", ";", "fw", ".", "close", "(", ")", ";", "junit", "=", "null", ";", "System", ".", "out", ".", "println", "(", "\"", "Exit code: ", "\"", "+", "result", ".", "getFailureCount", "(", ")", ")", ";", "System", ".", "exit", "(", "result", ".", "getFailureCount", "(", ")", ")", ";", "}"], "idx": 62932, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "e6ae0f4ce39e73ba29ab1c2926a41ac71e68574a", "function_name": "main", "body_hash": "1e9286f3ffd1297bbe8edc119e1051caf8891637"}
{"code": "public static void setFeaturesBySystemProperty(SAXParserFactory factory)\n                throws SAXException, ParserConfigurationException {\n\n            final boolean enableExternalDtdLoad = Boolean.parseBoolean(\n                System.getProperty(ENABLE_EXTERNAL_DTD_LOAD, \"false\"));\n\n            factory.setFeature(LOAD_EXTERNAL_DTD, enableExternalDtdLoad);\n            factory.setFeature(EXTERNAL_GENERAL_ENTITIES, enableExternalDtdLoad);\n        }", "code_tokens": ["public", "static", "void", "setFeaturesBySystemProperty", "(", "SAXParserFactory", "factory", ")", "throws", "SAXException", ",", "ParserConfigurationException", "{", "final", "boolean", "enableExternalDtdLoad", "=", "Boolean", ".", "parseBoolean", "(", "System", ".", "getProperty", "(", "ENABLE_EXTERNAL_DTD_LOAD", ",", "\"", "false", "\"", ")", ")", ";", "factory", ".", "setFeature", "(", "LOAD_EXTERNAL_DTD", ",", "enableExternalDtdLoad", ")", ";", "factory", ".", "setFeature", "(", "EXTERNAL_GENERAL_ENTITIES", ",", "enableExternalDtdLoad", ")", ";", "}"], "idx": 69878, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "c46a16d177e6797895b195c288ae9a9a096254b8", "function_name": "setFeaturesBySystemProperty", "body_hash": "5f8b75442b29c94569de55f3f9a94a879a7e1a47"}
{"code": "@Override\n\tprotected void onInitialize()\n\t{\n\t\tsuper.onInitialize();\n\n\t\tthis.textarea = new TextArea<String>(\"textarea\", this.getModel());\n\t\tthis.textarea.setEscapeModelStrings(false);\n\t\tthis.add(this.textarea.setOutputMarkupId(true));\n\n\t\tthis.add(JQueryWidget.newWidgetBehavior(this, this.container));\n\t}", "code_tokens": ["@", "Override", "protected", "void", "onInitialize", "(", ")", "{", "super", ".", "onInitialize", "(", ")", ";", "this", ".", "textarea", "=", "new", "TextArea", "<", "String", ">", "(", "\"", "textarea", "\"", ",", "this", ".", "getModel", "(", ")", ")", ";", "this", ".", "textarea", ".", "setEscapeModelStrings", "(", "false", ")", ";", "this", ".", "add", "(", "this", ".", "textarea", ".", "setOutputMarkupId", "(", "true", ")", ")", ";", "this", ".", "add", "(", "JQueryWidget", ".", "newWidgetBehavior", "(", "this", ",", "this", ".", "container", ")", ")", ";", "}"], "idx": 81626, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "22e414d693e8ef679ac6da38107fbc118a63f00", "function_name": "onInitialize", "body_hash": "0bff044d9fab97485b043e6ed745ab4012d8a47d"}
{"code": "@After\n    public void cleanUpDomainList() throws Exception {\n        IdentityZoneHolder.clear();\n        IdentityProvider<UaaIdentityProviderDefinition> uaaProvider = getWebApplicationContext().getBean(JdbcIdentityProviderProvisioning.class).retrieveByOrigin(UAA, IdentityZone.getUaa().getId());\n        uaaProvider.getConfig().setEmailDomain(null);\n        getWebApplicationContext().getBean(JdbcIdentityProviderProvisioning.class).update(uaaProvider);\n    }", "code_tokens": ["@", "After", "public", "void", "cleanUpDomainList", "(", ")", "throws", "Exception", "{", "IdentityZoneHolder", ".", "clear", "(", ")", ";", "IdentityProvider", "<", "UaaIdentityProviderDefinition", ">", "uaaProvider", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "JdbcIdentityProviderProvisioning", ".", "class", ")", ".", "retrieveByOrigin", "(", "UAA", ",", "IdentityZone", ".", "getUaa", "(", ")", ".", "getId", "(", ")", ")", ";", "uaaProvider", ".", "getConfig", "(", ")", ".", "setEmailDomain", "(", "null", ")", ";", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "JdbcIdentityProviderProvisioning", ".", "class", ")", ".", "update", "(", "uaaProvider", ")", ";", "}"], "idx": 35962, "cwe": "CWE-269", "target": 0, "status": "FIXED", "commit": "2ca35f1723e039aa7d2318134b05d02e40072a18", "function_name": "cleanUpDomainList", "body_hash": "994afe430db0b3501556e1eb575b188ff8a9a067"}
{"code": "@Override\n\t\tpublic void setPropertyValue(String propertyName, Object value) throws BeansException {\n\n\t\t\tif (!isWritableProperty(propertyName)) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName);\n\t\t\t}\n\n\t\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\t\t\tcontext.addPropertyAccessor(new PropertyTraversingMapAccessor(type, conversionService));\n\t\t\tcontext.setTypeConverter(new StandardTypeConverter(conversionService));\n\t\t\tcontext.setTypeLocator(REJECTING_LOCATOR);\n\t\t\tcontext.setRootObject(map);\n\n\t\t\tExpression expression = PARSER.parseExpression(propertyName);\n\n\t\t\tPropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();\n\t\t\tTypeInformation<?> owningType = leafProperty.getOwningType();\n\t\t\tTypeInformation<?> propertyType = owningType.getProperty(leafProperty.getSegment());\n\n\t\t\tpropertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n\n\t\t\tif (conversionRequired(value, propertyType.getType())) {\n\n\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),\n\t\t\t\t\t\tleafProperty.getSegment());\n\t\t\t\tMethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n\n\t\t\t\tvalue = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(context, value);\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O);\n\t\t\t}\n\t\t}", "code_tokens": ["@", "Override", "public", "void", "setPropertyValue", "(", "String", "propertyName", ",", "Object", "value", ")", "throws", "BeansException", "{", "if", "(", "!", "isWritableProperty", "(", "propertyName", ")", ")", "{", "throw", "new", "NotWritablePropertyException", "(", "type", ",", "propertyName", ")", ";", "}", "StandardEvaluationContext", "context", "=", "new", "StandardEvaluationContext", "(", ")", ";", "context", ".", "addPropertyAccessor", "(", "new", "PropertyTraversingMapAccessor", "(", "type", ",", "conversionService", ")", ")", ";", "context", ".", "setTypeConverter", "(", "new", "StandardTypeConverter", "(", "conversionService", ")", ")", ";", "context", ".", "setTypeLocator", "(", "REJECTING_LOCATOR", ")", ";", "context", ".", "setRootObject", "(", "map", ")", ";", "Expression", "expression", "=", "PARSER", ".", "parseExpression", "(", "propertyName", ")", ";", "PropertyPath", "leafProperty", "=", "getPropertyPath", "(", "propertyName", ")", ".", "getLeafProperty", "(", ")", ";", "TypeInformation", "<", "?", ">", "owningType", "=", "leafProperty", ".", "getOwningType", "(", ")", ";", "TypeInformation", "<", "?", ">", "propertyType", "=", "owningType", ".", "getProperty", "(", "leafProperty", ".", "getSegment", "(", ")", ")", ";", "propertyType", "=", "propertyName", ".", "endsWith", "(", "\"", "]", "\"", ")", "?", "propertyType", ".", "getActualType", "(", ")", ":", "propertyType", ";", "if", "(", "conversionRequired", "(", "value", ",", "propertyType", ".", "getType", "(", ")", ")", ")", "{", "PropertyDescriptor", "descriptor", "=", "BeanUtils", ".", "getPropertyDescriptor", "(", "owningType", ".", "getType", "(", ")", ",", "leafProperty", ".", "getSegment", "(", ")", ")", ";", "MethodParameter", "methodParameter", "=", "new", "MethodParameter", "(", "descriptor", ".", "getReadMethod", "(", ")", ",", "-", "1", ")", ";", "TypeDescriptor", "typeDescriptor", "=", "TypeDescriptor", ".", "nested", "(", "methodParameter", ",", "0", ")", ";", "value", "=", "conversionService", ".", "convert", "(", "value", ",", "TypeDescriptor", ".", "forObject", "(", "value", ")", ",", "typeDescriptor", ")", ";", "}", "try", "{", "expression", ".", "setValue", "(", "context", ",", "value", ")", ";", "}", "catch", "(", "SpelEvaluationException", "o_O", ")", "{", "throw", "new", "NotWritablePropertyException", "(", "type", ",", "propertyName", ",", "\"", "Could not write property!", "\"", ",", "o_O", ")", ";", "}", "}"], "idx": 11867, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "b1a20ae1e82a63f99b3afc6f2aaedb3bf4dc432", "function_name": "setPropertyValue", "body_hash": "28eec69271886736a5ac530407642aa52a0202a0"}
{"code": "public static void securityClassLoad(ClassLoader loader){\n\n        if( System.getSecurityManager() == null ){\n            return;\n        }\n\n        final String basePackage = \"org.apache.jasper.\";\n        try {\n            loader.loadClass( basePackage +\n                \"runtime.JspFactoryImpl$PrivilegedGetPageContext\");\n            loader.loadClass( basePackage +\n                \"runtime.JspFactoryImpl$PrivilegedReleasePageContext\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspRuntimeLibrary\");\n\n            loader.loadClass( basePackage +\n                \"runtime.ServletResponseWrapperInclude\");\n            loader.loadClass( basePackage +\n                \"runtime.TagHandlerPool\");\n            loader.loadClass( basePackage +\n                \"runtime.JspFragmentHelper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.ProtectedFunctionMapper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$1\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$2\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$3\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$4\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$5\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$6\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$7\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$8\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$9\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$10\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$11\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$12\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspContextWrapper\");\n\n            // Trigger loading of class and reading of property\n            SecurityUtil.isPackageProtectionEnabled();\n\n            loader.loadClass( basePackage +\n                \"servlet.JspServletWrapper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspWriterImpl$1\");\n        } catch (ClassNotFoundException ex) {\n            log.error(\"SecurityClassLoad\", ex);\n        }\n    }", "code_tokens": ["public", "static", "void", "securityClassLoad", "(", "ClassLoader", "loader", ")", "{", "if", "(", "System", ".", "getSecurityManager", "(", ")", "==", "null", ")", "{", "return", ";", "}", "final", "String", "basePackage", "=", "\"", "org.apache.jasper.", "\"", ";", "try", "{", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspFactoryImpl$PrivilegedGetPageContext", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspFactoryImpl$PrivilegedReleasePageContext", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspRuntimeLibrary", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.ServletResponseWrapperInclude", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.TagHandlerPool", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspFragmentHelper", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.ProtectedFunctionMapper", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$1", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$2", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$3", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$4", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$5", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$6", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$7", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$8", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$9", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$10", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$11", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$12", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspContextWrapper", "\"", ")", ";", "SecurityUtil", ".", "isPackageProtectionEnabled", "(", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "servlet.JspServletWrapper", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspWriterImpl$1", "\"", ")", ";", "}", "catch", "(", "ClassNotFoundException", "ex", ")", "{", "log", ".", "error", "(", "\"", "SecurityClassLoad", "\"", ",", "ex", ")", ";", "}", "}"], "idx": 99755, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "3adf2d614bce0fb9587b0eb7a4a9fbb7ac8e6d82", "function_name": "securityClassLoad", "body_hash": "187d7b4ef628c97981843066e79f37bd2a5f2266"}
{"code": "private Environment getRemoteEnvironment(RestTemplate restTemplate,\n\t\t\tConfigClientProperties properties, String label, String state) {\n\t\tString path = \"/{name}/{profile}\";\n\t\tString name = properties.getName();\n\t\tString profile = properties.getProfile();\n\t\tString token = properties.getToken();\n\t\tint noOfUrls = properties.getUri().length;\n\t\tif (noOfUrls > 1) {\n\t\t\tlogger.info(\"Multiple Config Server Urls found listed.\");\n\t\t}\n\n\t\tObject[] args = new String[] { name, profile };\n\t\tif (StringUtils.hasText(label)) {\n\t\t\tif (label.contains(\"/\")) {\n\t\t\t\tlabel = label.replace(\"/\", \"(_)\");\n\t\t\t}\n\t\t\targs = new String[] { name, profile, label };\n\t\t\tpath = path + \"/{label}\";\n\t\t}\n\t\tResponseEntity<Environment> response = null;\n\n\t\tfor (int i = 0; i < noOfUrls; i++) {\n\t\t\tCredentials credentials = properties.getCredentials(i);\n\t\t\tString uri = credentials.getUri();\n\t\t\tString username = credentials.getUsername();\n\t\t\tString password = credentials.getPassword();\n\n\t\t\tlogger.info(\"Fetching config from server at : \" + uri);\n\n\t\t\ttry {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.setAccept(\n\t\t\t\t\t\tCollections.singletonList(MediaType.parseMediaType(V2_JSON)));\n\t\t\t\taddAuthorizationToken(properties, headers, username, password);\n\t\t\t\tif (StringUtils.hasText(token)) {\n\t\t\t\t\theaders.add(TOKEN_HEADER, token);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasText(state) && properties.isSendState()) {\n\t\t\t\t\theaders.add(STATE_HEADER, state);\n\t\t\t\t}\n\n\t\t\t\tfinal HttpEntity<Void> entity = new HttpEntity<>((Void) null, headers);\n\t\t\t\tresponse = restTemplate.exchange(uri + path, HttpMethod.GET, entity,\n\t\t\t\t\t\tEnvironment.class, args);\n\t\t\t}\n\t\t\tcatch (HttpClientErrorException e) {\n\t\t\t\tif (e.getStatusCode() != HttpStatus.NOT_FOUND) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ResourceAccessException e) {\n\t\t\t\tlogger.info(\"Connect Timeout Exception on Url - \" + uri\n\t\t\t\t\t\t+ \". Will be trying the next url if available\");\n\t\t\t\tif (i == noOfUrls - 1) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (response == null || response.getStatusCode() != HttpStatus.OK) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tEnvironment result = response.getBody();\n\t\t\treturn result;\n\t\t}\n\n\t\treturn null;\n\t}", "code_tokens": ["private", "Environment", "getRemoteEnvironment", "(", "RestTemplate", "restTemplate", ",", "ConfigClientProperties", "properties", ",", "String", "label", ",", "String", "state", ")", "{", "String", "path", "=", "\"", "/{name}/{profile}", "\"", ";", "String", "name", "=", "properties", ".", "getName", "(", ")", ";", "String", "profile", "=", "properties", ".", "getProfile", "(", ")", ";", "String", "token", "=", "properties", ".", "getToken", "(", ")", ";", "int", "noOfUrls", "=", "properties", ".", "getUri", "(", ")", ".", "length", ";", "if", "(", "noOfUrls", ">", "1", ")", "{", "logger", ".", "info", "(", "\"", "Multiple Config Server Urls found listed.", "\"", ")", ";", "}", "Object", "[", "]", "args", "=", "new", "String", "[", "]", "{", "name", ",", "profile", "}", ";", "if", "(", "StringUtils", ".", "hasText", "(", "label", ")", ")", "{", "if", "(", "label", ".", "contains", "(", "\"", "/", "\"", ")", ")", "{", "label", "=", "label", ".", "replace", "(", "\"", "/", "\"", ",", "\"", "(_)", "\"", ")", ";", "}", "args", "=", "new", "String", "[", "]", "{", "name", ",", "profile", ",", "label", "}", ";", "path", "=", "path", "+", "\"", "/{label}", "\"", ";", "}", "ResponseEntity", "<", "Environment", ">", "response", "=", "null", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "noOfUrls", ";", "i", "++", ")", "{", "Credentials", "credentials", "=", "properties", ".", "getCredentials", "(", "i", ")", ";", "String", "uri", "=", "credentials", ".", "getUri", "(", ")", ";", "String", "username", "=", "credentials", ".", "getUsername", "(", ")", ";", "String", "password", "=", "credentials", ".", "getPassword", "(", ")", ";", "logger", ".", "info", "(", "\"", "Fetching config from server at : ", "\"", "+", "uri", ")", ";", "try", "{", "HttpHeaders", "headers", "=", "new", "HttpHeaders", "(", ")", ";", "headers", ".", "setAccept", "(", "Collections", ".", "singletonList", "(", "MediaType", ".", "parseMediaType", "(", "V2_JSON", ")", ")", ")", ";", "addAuthorizationToken", "(", "properties", ",", "headers", ",", "username", ",", "password", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "token", ")", ")", "{", "headers", ".", "add", "(", "TOKEN_HEADER", ",", "token", ")", ";", "}", "if", "(", "StringUtils", ".", "hasText", "(", "state", ")", "&&", "properties", ".", "isSendState", "(", ")", ")", "{", "headers", ".", "add", "(", "STATE_HEADER", ",", "state", ")", ";", "}", "final", "HttpEntity", "<", "Void", ">", "entity", "=", "new", "HttpEntity", "<", ">", "(", "(", "Void", ")", "null", ",", "headers", ")", ";", "response", "=", "restTemplate", ".", "exchange", "(", "uri", "+", "path", ",", "HttpMethod", ".", "GET", ",", "entity", ",", "Environment", ".", "class", ",", "args", ")", ";", "}", "catch", "(", "HttpClientErrorException", "e", ")", "{", "if", "(", "e", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "NOT_FOUND", ")", "{", "throw", "e", ";", "}", "}", "catch", "(", "ResourceAccessException", "e", ")", "{", "logger", ".", "info", "(", "\"", "Connect Timeout Exception on Url - ", "\"", "+", "uri", "+", "\"", ". Will be trying the next url if available", "\"", ")", ";", "if", "(", "i", "==", "noOfUrls", "-", "1", ")", "{", "throw", "e", ";", "}", "else", "{", "continue", ";", "}", "}", "if", "(", "response", "==", "null", "||", "response", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "OK", ")", "{", "return", "null", ";", "}", "Environment", "result", "=", "response", ".", "getBody", "(", ")", ";", "return", "result", ";", "}", "return", "null", ";", "}"], "idx": 26301, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "651f458919c40ef9a5e93e7d76bf98575910fad0", "function_name": "getRemoteEnvironment", "body_hash": "9b3b01c79845e9bdb8f76069d3a873ec211931fe"}
{"code": "private static void maybeInitJmx()\n    {\n        String jmxPort = System.getProperty(\"com.sun.management.jmxremote.port\");\n\n        if (jmxPort == null)\n        {\n            logger.warn(\"JMX is not enabled to receive remote connections. Please see cassandra-env.sh for more info.\");\n\n            jmxPort = System.getProperty(\"cassandra.jmx.local.port\");\n\n            if (jmxPort == null)\n            {\n                logger.error(\"cassandra.jmx.local.port missing from cassandra-env.sh, unable to start local JMX service.\" + jmxPort);\n            }\n            else\n            {\n                System.setProperty(\"java.rmi.server.hostname\", InetAddress.getLoopbackAddress().getHostAddress());\n\n                try\n                {\n                    RMIServerSocketFactory serverFactory = new RMIServerSocketFactoryImpl();\n                    Map<String, ?> env = Collections.singletonMap(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverFactory);\n\n                    Registry registry = new JmxRegistry(Integer.valueOf(jmxPort), null, serverFactory, \"jmxrmi\");\n                    JMXServiceURL url = new JMXServiceURL(String.format(\"service:jmx:rmi://localhost/jndi/rmi://localhost:%s/jmxrmi\", jmxPort));\n                    @SuppressWarnings(\"resource\")\n                    RMIJRMPServerImpl server = new RMIJRMPServerImpl(Integer.valueOf(jmxPort),\n                                                                     null,\n                                                                     (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE),\n                                                                     env);\n                    jmxServer = new RMIConnectorServer(url, env, server, ManagementFactory.getPlatformMBeanServer());\n                    jmxServer.start();\n                    ((JmxRegistry)registry).setRemoteServerStub(server.toStub());\n                }\n                catch (IOException e)\n                {\n                    logger.error(\"Error starting local jmx server: \", e);\n                }\n            }\n        }\n        else\n        {\n            logger.info(\"JMX is enabled to receive remote connections on port: \" + jmxPort);\n        }\n    }", "code_tokens": ["private", "static", "void", "maybeInitJmx", "(", ")", "{", "String", "jmxPort", "=", "System", ".", "getProperty", "(", "\"", "com.sun.management.jmxremote.port", "\"", ")", ";", "if", "(", "jmxPort", "==", "null", ")", "{", "logger", ".", "warn", "(", "\"", "JMX is not enabled to receive remote connections. Please see cassandra-env.sh for more info.", "\"", ")", ";", "jmxPort", "=", "System", ".", "getProperty", "(", "\"", "cassandra.jmx.local.port", "\"", ")", ";", "if", "(", "jmxPort", "==", "null", ")", "{", "logger", ".", "error", "(", "\"", "cassandra.jmx.local.port missing from cassandra-env.sh, unable to start local JMX service.", "\"", "+", "jmxPort", ")", ";", "}", "else", "{", "System", ".", "setProperty", "(", "\"", "java.rmi.server.hostname", "\"", ",", "InetAddress", ".", "getLoopbackAddress", "(", ")", ".", "getHostAddress", "(", ")", ")", ";", "try", "{", "RMIServerSocketFactory", "serverFactory", "=", "new", "RMIServerSocketFactoryImpl", "(", ")", ";", "Map", "<", "String", ",", "?", ">", "env", "=", "Collections", ".", "singletonMap", "(", "RMIConnectorServer", ".", "RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE", ",", "serverFactory", ")", ";", "Registry", "registry", "=", "new", "JmxRegistry", "(", "Integer", ".", "valueOf", "(", "jmxPort", ")", ",", "null", ",", "serverFactory", ",", "\"", "jmxrmi", "\"", ")", ";", "JMXServiceURL", "url", "=", "new", "JMXServiceURL", "(", "String", ".", "format", "(", "\"", "service:jmx:rmi://localhost/jndi/rmi://localhost:%s/jmxrmi", "\"", ",", "jmxPort", ")", ")", ";", "@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "RMIJRMPServerImpl", "server", "=", "new", "RMIJRMPServerImpl", "(", "Integer", ".", "valueOf", "(", "jmxPort", ")", ",", "null", ",", "(", "RMIServerSocketFactory", ")", "env", ".", "get", "(", "RMIConnectorServer", ".", "RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE", ")", ",", "env", ")", ";", "jmxServer", "=", "new", "RMIConnectorServer", "(", "url", ",", "env", ",", "server", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "jmxServer", ".", "start", "(", ")", ";", "(", "(", "JmxRegistry", ")", "registry", ")", ".", "setRemoteServerStub", "(", "server", ".", "toStub", "(", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "logger", ".", "error", "(", "\"", "Error starting local jmx server: ", "\"", ",", "e", ")", ";", "}", "}", "}", "else", "{", "logger", ".", "info", "(", "\"", "JMX is enabled to receive remote connections on port: ", "\"", "+", "jmxPort", ")", ";", "}", "}"], "idx": 72440, "cwe": "CWE-668", "target": 1, "status": "VULNERABLE", "commit": "63f4da90c3c51d230c535265786dbc7a33c1ace9", "function_name": "maybeInitJmx", "body_hash": "167d54c6f2cd07c6cb6ace14275c06b5734c4e4e"}
{"code": "private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        case '\\t': replace(i, i + 1, \"\\\\t\"); break;\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \"foo\"\n        // or internal quotes that might need to be escaped : f\"o -> f\\\"o.\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\"' as closing regardless.\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string\n        // literals so that the output can be embedded in HTML script elements\n        // and in XML CDATA sections without affecting the parser state.\n        // References:\n        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements\n        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state\n        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state\n        // https://www.w3.org/TR/xml/#sec-cdata-sect\n        case '<':\n          // Disallow <!--, which lets the HTML parser switch into the \"script\n          // data escaped\" state.\n          // Disallow <script, which followed by various characters lets the\n          // HTML parser switch into or out of the \"script data double escaped\"\n          // state.\n          // Disallow </script, which ends a script block.\n          if (i + 3 >= end)\n            break;\n          char c1 = jsonish.charAt(i + 1);\n          char c2 = jsonish.charAt(i + 2);\n          char c3 = jsonish.charAt(i + 3);\n          char lc1 = (char) (c1 | 32);\n          char lc2 = (char) (c2 | 32);\n          char lc3 = (char) (c3 | 32);\n          if ((c1 == '!' && c2 == '-' && c3 == '-') ||\n              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {\n            replace(i, i + 1, \"\\\\u003c\"); // Escaped <\n          }\n          break;\n        case '>':\n          // Disallow -->, which lets the HTML parser switch out of the \"script\n          // data escaped\" or \"script data double escaped\" state.\n          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)\n              && '-' == jsonish.charAt(i - 1)) {\n            replace(i, i + 1, \"\\\\u003e\"); // Escaped >\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \"u00\");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \"\\-\" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n             // Proceed to hex-escape below since control characters are\n             // disallowed by ECMA-404 which governs JavaScript's `JSON.parse`.\n             // Common ones like CR, LF, and TAB are given short escape sequences above.\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\"'); }\n  }", "code_tokens": ["private", "void", "sanitizeString", "(", "int", "start", ",", "int", "end", ")", "{", "boolean", "closed", "=", "false", ";", "for", "(", "int", "i", "=", "start", ";", "i", "<", "end", ";", "++", "i", ")", "{", "char", "ch", "=", "jsonish", ".", "charAt", "(", "i", ")", ";", "switch", "(", "ch", ")", "{", "case", "'\\t'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "t", "\"", ")", ";", "break", ";", "case", "'\\n'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "n", "\"", ")", ";", "break", ";", "case", "'\\r'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "r", "\"", ")", ";", "break", ";", "case", "'\\u2028'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2028", "\"", ")", ";", "break", ";", "case", "'\\u2029'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2029", "\"", ")", ";", "break", ";", "case", "'\"'", ":", "case", "'\\''", ":", "if", "(", "i", "==", "start", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "{", "if", "(", "i", "+", "1", "==", "end", ")", "{", "char", "startDelim", "=", "jsonish", ".", "charAt", "(", "start", ")", ";", "if", "(", "startDelim", "!=", "'\\''", ")", "{", "startDelim", "=", "'\"'", ";", "}", "closed", "=", "startDelim", "==", "ch", ";", "}", "if", "(", "closed", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "if", "(", "ch", "==", "'\"'", ")", "{", "insert", "(", "i", ",", "'\\\\'", ")", ";", "}", "}", "break", ";", "case", "'<'", ":", "if", "(", "i", "+", "3", ">=", "end", ")", "break", ";", "char", "c1", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "char", "c2", "=", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ";", "char", "c3", "=", "jsonish", ".", "charAt", "(", "i", "+", "3", ")", ";", "char", "lc1", "=", "(", "char", ")", "(", "c1", "|", "32", ")", ";", "char", "lc2", "=", "(", "char", ")", "(", "c2", "|", "32", ")", ";", "char", "lc3", "=", "(", "char", ")", "(", "c3", "|", "32", ")", ";", "if", "(", "(", "c1", "==", "'!'", "&&", "c2", "==", "'-'", "&&", "c3", "==", "'-'", ")", "||", "(", "lc1", "==", "'s'", "&&", "lc2", "==", "'c'", "&&", "lc3", "==", "'r'", ")", "||", "(", "c1", "==", "'/'", "&&", "lc2", "==", "'s'", "&&", "lc3", "==", "'c'", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u003c", "\"", ")", ";", "}", "break", ";", "case", "'>'", ":", "if", "(", "(", "i", "-", "2", ")", ">=", "start", "&&", "'-'", "==", "jsonish", ".", "charAt", "(", "i", "-", "2", ")", "&&", "'-'", "==", "jsonish", ".", "charAt", "(", "i", "-", "1", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u003e", "\"", ")", ";", "}", "break", ";", "case", "']'", ":", "if", "(", "i", "+", "2", "<", "end", "&&", "']'", "==", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", "&&", "'>'", "==", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u005d", "\"", ")", ";", "}", "break", ";", "case", "'\\\\'", ":", "if", "(", "i", "+", "1", "==", "end", ")", "{", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "char", "sch", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "switch", "(", "sch", ")", "{", "case", "'b'", ":", "case", "'f'", ":", "case", "'n'", ":", "case", "'r'", ":", "case", "'t'", ":", "case", "'\\\\'", ":", "case", "'/'", ":", "case", "'\"'", ":", "++", "i", ";", "break", ";", "case", "'v'", ":", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u0008", "\"", ")", ";", "++", "i", ";", "break", ";", "case", "'x'", ":", "if", "(", "i", "+", "4", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u00", "\"", ")", ";", "i", "+=", "3", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'u'", ":", "if", "(", "i", "+", "6", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", "&&", "isHexAt", "(", "i", "+", "4", ")", "&&", "isHexAt", "(", "i", "+", "5", ")", ")", "{", "i", "+=", "5", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'0'", ":", "case", "'1'", ":", "case", "'2'", ":", "case", "'3'", ":", "case", "'4'", ":", "case", "'5'", ":", "case", "'6'", ":", "case", "'7'", ":", "int", "octalEnd", "=", "i", "+", "1", ";", "if", "(", "octalEnd", "+", "1", "<", "end", "&&", "isOctAt", "(", "octalEnd", "+", "1", ")", ")", "{", "++", "octalEnd", ";", "if", "(", "ch", "<=", "'3'", "&&", "octalEnd", "+", "1", "<", "end", "&&", "isOctAt", "(", "octalEnd", "+", "1", ")", ")", "{", "++", "octalEnd", ";", "}", "int", "value", "=", "0", ";", "for", "(", "int", "j", "=", "i", ";", "j", "<", "octalEnd", ";", "++", "j", ")", "{", "value", "=", "(", "value", "<<", "3", ")", "|", "(", "jsonish", ".", "charAt", "(", "j", ")", "-", "'0'", ")", ";", "}", "replace", "(", "i", "+", "1", ",", "octalEnd", ",", "\"", "u00", "\"", ")", ";", "appendHex", "(", "value", ",", "2", ")", ";", "}", "i", "=", "octalEnd", "-", "1", ";", "break", ";", "default", ":", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "break", ";", "default", ":", "if", "(", "ch", "<", "0x20", ")", "{", "}", "else", "if", "(", "ch", "<", "0xd800", ")", "{", "continue", ";", "}", "else", "if", "(", "ch", "<", "0xe000", ")", "{", "if", "(", "Character", ".", "isHighSurrogate", "(", "ch", ")", "&&", "i", "+", "1", "<", "end", "&&", "Character", ".", "isLowSurrogate", "(", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "continue", ";", "}", "}", "else", "if", "(", "ch", "<=", "0xfffd", ")", "{", "continue", ";", "}", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u", "\"", ")", ";", "for", "(", "int", "j", "=", "4", ";", "--", "j", ">=", "0", ";", ")", "{", "sanitizedJson", ".", "append", "(", "HEX_DIGITS", "[", "(", "ch", ">>>", "(", "j", "<<", "2", ")", ")", "&", "0xf", "]", ")", ";", "}", "break", ";", "}", "}", "if", "(", "!", "closed", ")", "{", "insert", "(", "end", ",", "'\"'", ")", ";", "}", "}"], "idx": 70004, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "f2c9858c02cf521dd05f2c6f8f9450f2e1343090", "function_name": "sanitizeString", "body_hash": "e828c7708f82d9216eea01d19ba359866bdac19c"}
{"code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }  \n        if (camelContext != null && !Boolean.parseBoolean(camelContext.getProperty(ACCESS_EXTERNAL_DTD))) {\n            try {\n                factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            } catch (SAXException e) {\n                LOG.error(e.getMessage(), e);\n                throw new IllegalStateException(e);\n            } \n        }\n        return factory;\n    }", "code_tokens": ["protected", "SchemaFactory", "createSchemaFactory", "(", ")", "{", "SchemaFactory", "factory", "=", "SchemaFactory", ".", "newInstance", "(", "schemaLanguage", ")", ";", "if", "(", "getResourceResolver", "(", ")", "!=", "null", ")", "{", "factory", ".", "setResourceResolver", "(", "getResourceResolver", "(", ")", ")", ";", "}", "if", "(", "camelContext", "!=", "null", "&&", "!", "Boolean", ".", "parseBoolean", "(", "camelContext", ".", "getProperty", "(", "ACCESS_EXTERNAL_DTD", ")", ")", ")", "{", "try", "{", "factory", ".", "setProperty", "(", "XMLConstants", ".", "ACCESS_EXTERNAL_DTD", ",", "\"", "\"", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "LOG", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}", "return", "factory", ";", "}"], "idx": 66864, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "22c355bb4ffb500405499d189db30932ca5aac9", "function_name": "createSchemaFactory", "body_hash": "a324417d127ef6c5aeee7c41643ca466de992d43"}
{"code": "public final int doWikiStartTag()\n        throws IOException\n    {\n        WikiEngine engine = m_wikiContext.getEngine();\n        WikiPage   page   = m_wikiContext.getPage();\n\n        if( page != null )\n        {\n            if( page instanceof Attachment )\n            {\n                pageContext.getOut().print( TextUtil.replaceEntities( ((Attachment)page).getFileName() ) );\n            }\n            else\n            {\n                pageContext.getOut().print( engine.beautifyTitle( m_wikiContext.getName() ) );\n            }\n        }\n\n        return SKIP_BODY;\n    }", "code_tokens": ["public", "final", "int", "doWikiStartTag", "(", ")", "throws", "IOException", "{", "WikiEngine", "engine", "=", "m_wikiContext", ".", "getEngine", "(", ")", ";", "WikiPage", "page", "=", "m_wikiContext", ".", "getPage", "(", ")", ";", "if", "(", "page", "!=", "null", ")", "{", "if", "(", "page", "instanceof", "Attachment", ")", "{", "pageContext", ".", "getOut", "(", ")", ".", "print", "(", "TextUtil", ".", "replaceEntities", "(", "(", "(", "Attachment", ")", "page", ")", ".", "getFileName", "(", ")", ")", ")", ";", "}", "else", "{", "pageContext", ".", "getOut", "(", ")", ".", "print", "(", "engine", ".", "beautifyTitle", "(", "m_wikiContext", ".", "getName", "(", ")", ")", ")", ";", "}", "}", "return", "SKIP_BODY", ";", "}"], "idx": 79601, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "59881d4c80c3c686cce582714ef6ff31956502ad", "function_name": "doWikiStartTag", "body_hash": "b2c9cf8051fd7aeb9703333d18d3f112374e0094"}
{"code": "public QName get(String qualifiedName, String uri) {\n        int index = qualifiedName.indexOf(':');\n\n        if (index < 0) {\n            return get(qualifiedName, Namespace.get(uri));\n        } else {\n            String name = qualifiedName.substring(index + 1);\n            String prefix = qualifiedName.substring(0, index);\n\n            return get(name, Namespace.get(prefix, uri));\n        }\n    }", "code_tokens": ["public", "QName", "get", "(", "String", "qualifiedName", ",", "String", "uri", ")", "{", "int", "index", "=", "qualifiedName", ".", "indexOf", "(", "':'", ")", ";", "if", "(", "index", "<", "0", ")", "{", "return", "get", "(", "qualifiedName", ",", "Namespace", ".", "get", "(", "uri", ")", ")", ";", "}", "else", "{", "String", "name", "=", "qualifiedName", ".", "substring", "(", "index", "+", "1", ")", ";", "String", "prefix", "=", "qualifiedName", ".", "substring", "(", "0", ",", "index", ")", ";", "return", "get", "(", "name", ",", "Namespace", ".", "get", "(", "prefix", ",", "uri", ")", ")", ";", "}", "}"], "idx": 94227, "cwe": "CWE-91", "target": 1, "status": "VULNERABLE", "commit": "e598eb43d418744c4dbf62f647dd2381c9ce9387", "function_name": "get", "body_hash": "cd58d8c817de79182fcec20310c2673a45718314"}
{"code": "public void testCall(final String path, final String expectedResponse) throws Exception {\n        TestHttpClient client = new TestHttpClient();\n        String servletPath = \"/servletContext/secured/\" + path;\n        String url = DefaultServer.getDefaultServerURL() + servletPath;\n        HttpGet get = new HttpGet(url);\n        HttpResponse result = client.execute(get);\n        assertEquals(StatusCodes.UNAUTHORIZED, result.getStatusLine().getStatusCode());\n        Header[] values = result.getHeaders(WWW_AUTHENTICATE.toString());\n        assertEquals(1, values.length);\n        String value = values[0].getValue();\n        assertTrue(value.startsWith(DIGEST.toString()));\n        Map<DigestWWWAuthenticateToken, String> parsedHeader = DigestWWWAuthenticateToken.parseHeader(value.substring(7));\n        assertEquals(REALM_NAME, parsedHeader.get(DigestWWWAuthenticateToken.REALM));\n        assertEquals(DigestAlgorithm.MD5.getToken(), parsedHeader.get(DigestWWWAuthenticateToken.ALGORITHM));\n        assertTrue(parsedHeader.containsKey(DigestWWWAuthenticateToken.MESSAGE_QOP));\n\n        String nonce = parsedHeader.get(DigestWWWAuthenticateToken.NONCE);\n\n        String clientResponse = createResponse(\"user1\", REALM_NAME, \"password1\", \"GET\", servletPath, nonce);\n\n        client = new TestHttpClient();\n        get = new HttpGet(url);\n        StringBuilder sb = new StringBuilder(DIGEST.toString());\n        sb.append(\" \");\n        sb.append(DigestAuthorizationToken.USERNAME.getName()).append(\"=\").append(\"\\\"user1\\\"\").append(\",\");\n        sb.append(DigestAuthorizationToken.REALM.getName()).append(\"=\\\"\").append(REALM_NAME).append(\"\\\",\");\n        sb.append(DigestAuthorizationToken.NONCE.getName()).append(\"=\\\"\").append(nonce).append(\"\\\",\");\n        sb.append(DigestAuthorizationToken.DIGEST_URI.getName()).append(\"=\\\"\" + servletPath + \"\\\",\");\n        sb.append(DigestAuthorizationToken.RESPONSE.getName()).append(\"=\\\"\").append(clientResponse).append(\"\\\"\");\n\n        get.addHeader(AUTHORIZATION.toString(), sb.toString());\n        result = client.execute(get);\n        assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());\n\n        final String response = HttpClientUtils.readResponse(result);\n        assertEquals(expectedResponse, response);\n    }", "code_tokens": ["public", "void", "testCall", "(", "final", "String", "path", ",", "final", "String", "expectedResponse", ")", "throws", "Exception", "{", "TestHttpClient", "client", "=", "new", "TestHttpClient", "(", ")", ";", "String", "servletPath", "=", "\"", "/servletContext/secured/", "\"", "+", "path", ";", "String", "url", "=", "DefaultServer", ".", "getDefaultServerURL", "(", ")", "+", "servletPath", ";", "HttpGet", "get", "=", "new", "HttpGet", "(", "url", ")", ";", "HttpResponse", "result", "=", "client", ".", "execute", "(", "get", ")", ";", "assertEquals", "(", "StatusCodes", ".", "UNAUTHORIZED", ",", "result", ".", "getStatusLine", "(", ")", ".", "getStatusCode", "(", ")", ")", ";", "Header", "[", "]", "values", "=", "result", ".", "getHeaders", "(", "WWW_AUTHENTICATE", ".", "toString", "(", ")", ")", ";", "assertEquals", "(", "1", ",", "values", ".", "length", ")", ";", "String", "value", "=", "values", "[", "0", "]", ".", "getValue", "(", ")", ";", "assertTrue", "(", "value", ".", "startsWith", "(", "DIGEST", ".", "toString", "(", ")", ")", ")", ";", "Map", "<", "DigestWWWAuthenticateToken", ",", "String", ">", "parsedHeader", "=", "DigestWWWAuthenticateToken", ".", "parseHeader", "(", "value", ".", "substring", "(", "7", ")", ")", ";", "assertEquals", "(", "REALM_NAME", ",", "parsedHeader", ".", "get", "(", "DigestWWWAuthenticateToken", ".", "REALM", ")", ")", ";", "assertEquals", "(", "DigestAlgorithm", ".", "MD5", ".", "getToken", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestWWWAuthenticateToken", ".", "ALGORITHM", ")", ")", ";", "assertTrue", "(", "parsedHeader", ".", "containsKey", "(", "DigestWWWAuthenticateToken", ".", "MESSAGE_QOP", ")", ")", ";", "String", "nonce", "=", "parsedHeader", ".", "get", "(", "DigestWWWAuthenticateToken", ".", "NONCE", ")", ";", "String", "clientResponse", "=", "createResponse", "(", "\"", "user1", "\"", ",", "REALM_NAME", ",", "\"", "password1", "\"", ",", "\"", "GET", "\"", ",", "servletPath", ",", "nonce", ")", ";", "client", "=", "new", "TestHttpClient", "(", ")", ";", "get", "=", "new", "HttpGet", "(", "url", ")", ";", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "DIGEST", ".", "toString", "(", ")", ")", ";", "sb", ".", "append", "(", "\"", " ", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "USERNAME", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\"", ")", ".", "append", "(", "\"", "\\\"", "user1", "\\\"", "\"", ")", ".", "append", "(", "\"", ",", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "REALM", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\\\"", "\"", ")", ".", "append", "(", "REALM_NAME", ")", ".", "append", "(", "\"", "\\\"", ",", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "NONCE", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\\\"", "\"", ")", ".", "append", "(", "nonce", ")", ".", "append", "(", "\"", "\\\"", ",", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "DIGEST_URI", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\\\"", "\"", "+", "servletPath", "+", "\"", "\\\"", ",", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "RESPONSE", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\\\"", "\"", ")", ".", "append", "(", "clientResponse", ")", ".", "append", "(", "\"", "\\\"", "\"", ")", ";", "get", ".", "addHeader", "(", "AUTHORIZATION", ".", "toString", "(", ")", ",", "sb", ".", "toString", "(", ")", ")", ";", "result", "=", "client", ".", "execute", "(", "get", ")", ";", "assertEquals", "(", "StatusCodes", ".", "OK", ",", "result", ".", "getStatusLine", "(", ")", ".", "getStatusCode", "(", ")", ")", ";", "final", "String", "response", "=", "HttpClientUtils", ".", "readResponse", "(", "result", ")", ";", "assertEquals", "(", "expectedResponse", ",", "response", ")", ";", "}"], "idx": 89515, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "facb33a5cedaf4b7b96d3840a08210370a806870", "function_name": "testCall", "body_hash": "b0743aee975c799a6a7b2537b2bbb1ab0c0322ea"}
{"code": "@SuppressJava6Requirement(reason = \"Guarded by version check\")\n    public static File createTempFile(String prefix, String suffix, File directory) throws IOException {\n        if (javaVersion() >= 7) {\n            if (directory == null) {\n                return Files.createTempFile(prefix, suffix).toFile();\n            }\n            return Files.createTempFile(directory.toPath(), prefix, suffix).toFile();\n        }\n        final File file;\n        if (directory == null) {\n            file = File.createTempFile(prefix, suffix);\n        } else {\n            file = File.createTempFile(prefix, suffix, directory);\n        }\n\n        // Try to adjust the perms, if this fails there is not much else we can do...\n        if (!file.setReadable(false, false)) {\n            throw new IOException(\"Failed to set permissions on temporary file \" + file);\n        }\n        if (!file.setReadable(true, true)) {\n            throw new IOException(\"Failed to set permissions on temporary file \" + file);\n        }\n        return file;\n    }", "code_tokens": ["@", "SuppressJava6Requirement", "(", "reason", "=", "\"", "Guarded by version check", "\"", ")", "public", "static", "File", "createTempFile", "(", "String", "prefix", ",", "String", "suffix", ",", "File", "directory", ")", "throws", "IOException", "{", "if", "(", "javaVersion", "(", ")", ">=", "7", ")", "{", "if", "(", "directory", "==", "null", ")", "{", "return", "Files", ".", "createTempFile", "(", "prefix", ",", "suffix", ")", ".", "toFile", "(", ")", ";", "}", "return", "Files", ".", "createTempFile", "(", "directory", ".", "toPath", "(", ")", ",", "prefix", ",", "suffix", ")", ".", "toFile", "(", ")", ";", "}", "final", "File", "file", ";", "if", "(", "directory", "==", "null", ")", "{", "file", "=", "File", ".", "createTempFile", "(", "prefix", ",", "suffix", ")", ";", "}", "else", "{", "file", "=", "File", ".", "createTempFile", "(", "prefix", ",", "suffix", ",", "directory", ")", ";", "}", "if", "(", "!", "file", ".", "setReadable", "(", "false", ",", "false", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "Failed to set permissions on temporary file ", "\"", "+", "file", ")", ";", "}", "if", "(", "!", "file", ".", "setReadable", "(", "true", ",", "true", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "Failed to set permissions on temporary file ", "\"", "+", "file", ")", ";", "}", "return", "file", ";", "}"], "idx": 71506, "cwe": "CWE-668", "target": 0, "status": "FIXED", "commit": "185f8b2756a36aaa4f973f1a2a025e7d981823f1", "function_name": "createTempFile", "body_hash": "9ba1531a72c4ee61edce4b0146516599b7974129"}
{"code": "public static boolean isFileOutsideDir(\n          @NonNull final String filePath, @NonNull final String baseDirPath) throws IOException {\n    File file = new File(filePath);\n    File baseDir = new File(baseDirPath);\n    return !file.getCanonicalFile().toPath().startsWith(baseDir.getCanonicalFile().toPath());\n  }", "code_tokens": ["public", "static", "boolean", "isFileOutsideDir", "(", "@", "NonNull", "final", "String", "filePath", ",", "@", "NonNull", "final", "String", "baseDirPath", ")", "throws", "IOException", "{", "File", "file", "=", "new", "File", "(", "filePath", ")", ";", "File", "baseDir", "=", "new", "File", "(", "baseDirPath", ")", ";", "return", "!", "file", ".", "getCanonicalFile", "(", ")", ".", "toPath", "(", ")", ".", "startsWith", "(", "baseDir", ".", "getCanonicalFile", "(", ")", ".", "toPath", "(", ")", ")", ";", "}"], "idx": 27290, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "af35e870ed09411d2f1fae6db1b04598cd1a31b6", "function_name": "isFileOutsideDir", "body_hash": "9a1e463cd23f73a99d5212943a3e1069630618b5"}
{"code": "public Map<String, FileEntry> generatorCode(TableDetails tableDetails, String tablePrefix,\n\t\t\tMap<String, String> customProperties, List<TemplateFile> templateFiles) {\n\n\t\tMap<String, FileEntry> map = new HashMap<>(templateFiles.size());\n\n\t\t// \u6a21\u677f\u6e32\u67d3\n\t\tMap<String, Object> context = GenUtils.getContext(tableDetails, tablePrefix, customProperties);\n\n\t\tfor (TemplateFile templateFile : templateFiles) {\n\t\t\tFileEntry fileEntry = new FileEntry();\n\t\t\tfileEntry.setType(templateFile.getType());\n\n\t\t\t// \u66ff\u6362\u8def\u5f84\u4e2d\u7684\u5360\u4f4d\u7b26\n\t\t\tString templateFilename = templateFile.getFilename();\n\t\t\tString filename = StrUtil.format(templateFilename, context);\n\t\t\tfileEntry.setFilename(filename);\n\n\t\t\tString parentFilePath = GenUtils.evaluateRealPath(templateFile.getParentFilePath(), context);\n\t\t\tfileEntry.setParentFilePath(parentFilePath);\n\n\t\t\t// \u5982\u679c\u662f\u6587\u4ef6\n\t\t\tif (TemplateEntryTypeEnum.FILE.getType().equals(fileEntry.getType())) {\n\t\t\t\tString filePath = GenUtils.concatFilePath(parentFilePath, filename);\n\t\t\t\tfileEntry.setFilePath(filePath);\n\t\t\t\t// \u6587\u4ef6\u5185\u5bb9\u6e32\u67d3\n\t\t\t\tTemplateEngineTypeEnum engineTypeEnum = TemplateEngineTypeEnum.of(templateFile.getEngineType());\n\n\t\t\t\ttry {\n\t\t\t\t\tString content = templateEngineDelegator.render(engineTypeEnum, templateFile.getContent(), context);\n\t\t\t\t\tfileEntry.setContent(content);\n\t\t\t\t}\n\t\t\t\tcatch (TemplateRenderException ex) {\n\t\t\t\t\tString errorMessage = StrUtil.format(\"\u6a21\u677f\u6e32\u67d3\u5f02\u5e38\uff0c\u6a21\u677f\u6587\u4ef6\u540d\uff1a\u3010{}\u3011\uff0c\u9519\u8bef\u8be6\u60c5\uff1a{}\", templateFilename,\n\t\t\t\t\t\t\tex.getMessage());\n\t\t\t\t\tthrow new BusinessException(SystemResultCode.SERVER_ERROR.getCode(), errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString currentPath = GenUtils.evaluateRealPath(templateFilename, context);\n\t\t\t\tfileEntry.setFilePath(GenUtils.concatFilePath(parentFilePath, currentPath));\n\t\t\t}\n\n\t\t\tmap.put(fileEntry.getFilePath(), fileEntry);\n\t\t}\n\n\t\treturn map;\n\t}", "code_tokens": ["public", "Map", "<", "String", ",", "FileEntry", ">", "generatorCode", "(", "TableDetails", "tableDetails", ",", "String", "tablePrefix", ",", "Map", "<", "String", ",", "String", ">", "customProperties", ",", "List", "<", "TemplateFile", ">", "templateFiles", ")", "{", "Map", "<", "String", ",", "FileEntry", ">", "map", "=", "new", "HashMap", "<", ">", "(", "templateFiles", ".", "size", "(", ")", ")", ";", "Map", "<", "String", ",", "Object", ">", "context", "=", "GenUtils", ".", "getContext", "(", "tableDetails", ",", "tablePrefix", ",", "customProperties", ")", ";", "for", "(", "TemplateFile", "templateFile", ":", "templateFiles", ")", "{", "FileEntry", "fileEntry", "=", "new", "FileEntry", "(", ")", ";", "fileEntry", ".", "setType", "(", "templateFile", ".", "getType", "(", ")", ")", ";", "String", "templateFilename", "=", "templateFile", ".", "getFilename", "(", ")", ";", "String", "filename", "=", "StrUtil", ".", "format", "(", "templateFilename", ",", "context", ")", ";", "fileEntry", ".", "setFilename", "(", "filename", ")", ";", "String", "parentFilePath", "=", "GenUtils", ".", "evaluateRealPath", "(", "templateFile", ".", "getParentFilePath", "(", ")", ",", "context", ")", ";", "fileEntry", ".", "setParentFilePath", "(", "parentFilePath", ")", ";", "if", "(", "TemplateEntryTypeEnum", ".", "FILE", ".", "getType", "(", ")", ".", "equals", "(", "fileEntry", ".", "getType", "(", ")", ")", ")", "{", "String", "filePath", "=", "GenUtils", ".", "concatFilePath", "(", "parentFilePath", ",", "filename", ")", ";", "fileEntry", ".", "setFilePath", "(", "filePath", ")", ";", "TemplateEngineTypeEnum", "engineTypeEnum", "=", "TemplateEngineTypeEnum", ".", "of", "(", "templateFile", ".", "getEngineType", "(", ")", ")", ";", "try", "{", "String", "content", "=", "templateEngineDelegator", ".", "render", "(", "engineTypeEnum", ",", "templateFile", ".", "getContent", "(", ")", ",", "context", ")", ";", "fileEntry", ".", "setContent", "(", "content", ")", ";", "}", "catch", "(", "TemplateRenderException", "ex", ")", "{", "String", "errorMessage", "=", "StrUtil", ".", "format", "(", "\"", "\u6a21\u677f\u6e32\u67d3\u5f02\u5e38\uff0c\u6a21\u677f\u6587\u4ef6\u540d\uff1a\u3010{}\u3011\uff0c\u9519\u8bef\u8be6\u60c5\uff1a{}", "\"", ",", "templateFilename", ",", "ex", ".", "getMessage", "(", ")", ")", ";", "throw", "new", "BusinessException", "(", "SystemResultCode", ".", "SERVER_ERROR", ".", "getCode", "(", ")", ",", "errorMessage", ")", ";", "}", "}", "else", "{", "String", "currentPath", "=", "GenUtils", ".", "evaluateRealPath", "(", "templateFilename", ",", "context", ")", ";", "fileEntry", ".", "setFilePath", "(", "GenUtils", ".", "concatFilePath", "(", "parentFilePath", ",", "currentPath", ")", ")", ";", "}", "map", ".", "put", "(", "fileEntry", ".", "getFilePath", "(", ")", ",", "fileEntry", ")", ";", "}", "return", "map", ";", "}"], "idx": 5560, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "84a7cb38daf0295b93aba21d562ec627e4eb463b", "function_name": "generatorCode", "body_hash": "6b4eb50d9d834094ea0305f4e9cf65d1106a7358"}
{"code": "public synchronized void download(StaplerRequest req, StaplerResponse rsp) throws InterruptedException, IOException {\n        rsp.setStatus(HttpServletResponse.SC_OK);\n\n        // server->client channel.\n        // this is created first, and this controls the lifespan of the channel\n        rsp.addHeader(\"Transfer-Encoding\", \"chunked\");\n        OutputStream out = rsp.getOutputStream();\n        if (DIY_CHUNKING) out = new ChunkedOutputStream(out);\n\n        // send something out so that the client will see the HTTP headers\n        out.write(\"Starting HTTP duplex channel\".getBytes());\n        out.flush();\n\n        // wait until we have the other channel\n        while(upload==null)\n            wait();\n\n        try {\n            channel = new Channel(\"HTTP full-duplex channel \" + uuid,\n                    Computer.threadPoolForRemoting, Mode.BINARY, upload, out, null, restricted);\n\n            // so that we can detect dead clients, periodically send something\n            PingThread ping = new PingThread(channel) {\n                @Override\n                protected void onDead(Throwable diagnosis) {\n                    LOGGER.log(Level.INFO,\"Duplex-HTTP session \" + uuid + \" is terminated\",diagnosis);\n                    // this will cause the channel to abort and subsequently clean up\n                    try {\n                        upload.close();\n                    } catch (IOException e) {\n                        // this can never happen\n                        throw new AssertionError(e);\n                    }\n                }\n\n                @Override\n                protected void onDead() {\n                    onDead(null);\n                }\n            };\n            ping.start();\n            main(channel);\n            channel.join();\n            ping.interrupt();\n        } finally {\n            // publish that we are done\n            completed=true;\n            notify();\n        }\n    }", "code_tokens": ["public", "synchronized", "void", "download", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "InterruptedException", ",", "IOException", "{", "rsp", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_OK", ")", ";", "rsp", ".", "addHeader", "(", "\"", "Transfer-Encoding", "\"", ",", "\"", "chunked", "\"", ")", ";", "OutputStream", "out", "=", "rsp", ".", "getOutputStream", "(", ")", ";", "if", "(", "DIY_CHUNKING", ")", "out", "=", "new", "ChunkedOutputStream", "(", "out", ")", ";", "out", ".", "write", "(", "\"", "Starting HTTP duplex channel", "\"", ".", "getBytes", "(", ")", ")", ";", "out", ".", "flush", "(", ")", ";", "while", "(", "upload", "==", "null", ")", "wait", "(", ")", ";", "try", "{", "channel", "=", "new", "Channel", "(", "\"", "HTTP full-duplex channel ", "\"", "+", "uuid", ",", "Computer", ".", "threadPoolForRemoting", ",", "Mode", ".", "BINARY", ",", "upload", ",", "out", ",", "null", ",", "restricted", ")", ";", "PingThread", "ping", "=", "new", "PingThread", "(", "channel", ")", "{", "@", "Override", "protected", "void", "onDead", "(", "Throwable", "diagnosis", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "INFO", ",", "\"", "Duplex-HTTP session ", "\"", "+", "uuid", "+", "\"", " is terminated", "\"", ",", "diagnosis", ")", ";", "try", "{", "upload", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "AssertionError", "(", "e", ")", ";", "}", "}", "@", "Override", "protected", "void", "onDead", "(", ")", "{", "onDead", "(", "null", ")", ";", "}", "}", ";", "ping", ".", "start", "(", ")", ";", "main", "(", "channel", ")", ";", "channel", ".", "join", "(", ")", ";", "ping", ".", "interrupt", "(", ")", ";", "}", "finally", "{", "completed", "=", "true", ";", "notify", "(", ")", ";", "}", "}"], "idx": 51159, "cwe": "CWE-399", "target": 1, "status": "VULNERABLE", "commit": "880e101b1a449355db6eb91f662aab9e5df75769", "function_name": "download", "body_hash": "3666f15e78f9b732f59f1b75cc28dc16c6a2e59c"}
{"code": "public static boolean isCsrfTokenValid(VaadinSession session,\n            String requestToken) {\n\n        if (session.getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String sessionToken = session.getCsrfToken();\n\n            try {\n                if (sessionToken == null || !MessageDigest.isEqual(\n                        sessionToken.getBytes(\"UTF-8\"),\n                        requestToken.getBytes(\"UTF-8\"))) {\n                    return false;\n                }\n            } catch (UnsupportedEncodingException e) {\n                getLogger().log(Level.WARNING,\n                        \"Session token was not UTF-8, this should never happen.\");\n                return false;\n            }\n        }\n        return true;\n    }", "code_tokens": ["public", "static", "boolean", "isCsrfTokenValid", "(", "VaadinSession", "session", ",", "String", "requestToken", ")", "{", "if", "(", "session", ".", "getService", "(", ")", ".", "getDeploymentConfiguration", "(", ")", ".", "isXsrfProtectionEnabled", "(", ")", ")", "{", "String", "sessionToken", "=", "session", ".", "getCsrfToken", "(", ")", ";", "try", "{", "if", "(", "sessionToken", "==", "null", "||", "!", "MessageDigest", ".", "isEqual", "(", "sessionToken", ".", "getBytes", "(", "\"", "UTF-8", "\"", ")", ",", "requestToken", ".", "getBytes", "(", "\"", "UTF-8", "\"", ")", ")", ")", "{", "return", "false", ";", "}", "}", "catch", "(", "UnsupportedEncodingException", "e", ")", "{", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Session token was not UTF-8, this should never happen.", "\"", ")", ";", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "idx": 20502, "cwe": "CWE-203", "target": 0, "status": "FIXED", "commit": "a26eb8d4c63816eae9579c661712e47fa6fa0e18", "function_name": "isCsrfTokenValid", "body_hash": "9bfb4262ec69397f878715fea61baf932a7505ea"}
{"code": "void resumeReadsInternal(boolean wakeup) {\n        synchronized (lock) {\n            boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n            state |= STATE_READS_RESUMED;\n            if (!alreadyResumed || wakeup) {\n                if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                    state |= STATE_IN_LISTENER_LOOP;\n                    getFramedChannel().runInIoThread(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            try {\n                                boolean moreData;\n                                do {\n                                    ChannelListener<? super R> listener = getReadListener();\n                                    if (listener == null || !isReadResumed()) {\n                                        return;\n                                    }\n                                    ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                    //if writes are shutdown or we become active then we stop looping\n                                    //we stop when writes are shutdown because we can't flush until we are active\n                                    //although we may be flushed as part of a batch\n                                    moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                                }\n                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);\n                            } finally {\n                                state &= ~STATE_IN_LISTENER_LOOP;\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }", "code_tokens": ["void", "resumeReadsInternal", "(", "boolean", "wakeup", ")", "{", "synchronized", "(", "lock", ")", "{", "boolean", "alreadyResumed", "=", "anyAreSet", "(", "state", ",", "STATE_READS_RESUMED", ")", ";", "state", "|=", "STATE_READS_RESUMED", ";", "if", "(", "!", "alreadyResumed", "||", "wakeup", ")", "{", "if", "(", "!", "anyAreSet", "(", "state", ",", "STATE_IN_LISTENER_LOOP", ")", ")", "{", "state", "|=", "STATE_IN_LISTENER_LOOP", ";", "getFramedChannel", "(", ")", ".", "runInIoThread", "(", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "try", "{", "boolean", "moreData", ";", "do", "{", "ChannelListener", "<", "?", "super", "R", ">", "listener", "=", "getReadListener", "(", ")", ";", "if", "(", "listener", "==", "null", "||", "!", "isReadResumed", "(", ")", ")", "{", "return", ";", "}", "ChannelListeners", ".", "invokeChannelListener", "(", "(", "R", ")", "AbstractFramedStreamSourceChannel", ".", "this", ",", "listener", ")", ";", "moreData", "=", "(", "frameDataRemaining", ">", "0", "&&", "data", "!=", "null", ")", "||", "!", "pendingFrameData", ".", "isEmpty", "(", ")", "||", "anyAreSet", "(", "state", ",", "STATE_WAITNG_MINUS_ONE", ")", ";", "}", "while", "(", "allAreSet", "(", "state", ",", "STATE_READS_RESUMED", ")", "&&", "allAreClear", "(", "state", ",", "STATE_CLOSED", "|", "STATE_STREAM_BROKEN", ")", "&&", "moreData", ")", ";", "}", "finally", "{", "state", "&=", "~", "STATE_IN_LISTENER_LOOP", ";", "}", "}", "}", ")", ";", "}", "}", "}", "}"], "idx": 82208, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "9bfe9fbbb595d51157b61693f072895f7dbadd1d", "function_name": "resumeReadsInternal", "body_hash": "390687ee44733f1f3f212263cf5c7784378eb5d5"}
{"code": "private void prepareRequest() throws IOException {\n\n        contentDelimitation = false;\n\n        if (protocol.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        Pattern restrictedUserAgents = protocol.getRestrictedUserAgentsPattern();\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    // Invalid transfer encoding\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n                }\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n                keepAlive = false;\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "contentDelimitation", "=", "false", ";", "if", "(", "protocol", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEP_ALIVE_HEADER_VALUE_TOKEN", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "inputBuffer", ".", "setSwallowInput", "(", "false", ")", ";", "request", ".", "setExpectation", "(", "true", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "Pattern", "restrictedUserAgents", "=", "protocol", ".", "getRestrictedUserAgentsPattern", "(", ")", ";", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "(", "http11", "||", "keepAlive", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "protocol", ".", "getAllowHostHeaderMismatch", "(", ")", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "inputBuffer", ".", "getFilters", "(", ")", ";", "if", "(", "http11", ")", "{", "MessageBytes", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ")", "{", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidTransferEncoding", "\"", ")", ";", "}", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 54414, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "05f9e8b00f5d9251fcd3c95dcfd6cf84177f46c8", "function_name": "prepareRequest", "body_hash": "9c9f35e2995b94a771906664f4644cf93fe4708b"}
{"code": "private Schema loadSchema(String schemaResource) {\n\t\tClassLoader loader = run( GetClassLoader.fromClass( XmlParserHelper.class ) );\n\n\t\tURL schemaUrl = run( GetResource.action( loader, schemaResource ) );\n\t\tSchemaFactory sf = SchemaFactory.newInstance( javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI );\n\t\tSchema schema = null;\n\t\ttry {\n\t\t\tschema = sf.newSchema( schemaUrl );\n\t\t}\n\t\tcatch ( SAXException e ) {\n\t\t\tlog.unableToCreateSchema( schemaResource, e.getMessage() );\n\t\t}\n\t\treturn schema;\n\t}", "code_tokens": ["private", "Schema", "loadSchema", "(", "String", "schemaResource", ")", "{", "ClassLoader", "loader", "=", "run", "(", "GetClassLoader", ".", "fromClass", "(", "XmlParserHelper", ".", "class", ")", ")", ";", "URL", "schemaUrl", "=", "run", "(", "GetResource", ".", "action", "(", "loader", ",", "schemaResource", ")", ")", ";", "SchemaFactory", "sf", "=", "SchemaFactory", ".", "newInstance", "(", "javax", ".", "xml", ".", "XMLConstants", ".", "W3C_XML_SCHEMA_NS_URI", ")", ";", "Schema", "schema", "=", "null", ";", "try", "{", "schema", "=", "sf", ".", "newSchema", "(", "schemaUrl", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "log", ".", "unableToCreateSchema", "(", "schemaResource", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "return", "schema", ";", "}"], "idx": 30736, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "2c95d4ea0ef20977be249e31a4a4f4f4f71c945d", "function_name": "loadSchema", "body_hash": "9679e3fb09c53b9a7ee6851699d6c2d4a0f9301d"}
{"code": "public QueryTargetPolicy getQueryTargetPolicyInstance() {\n        if (queryTargetPolicyPlugin.get() == null) {\n            queryTargetPolicyPlugin.instantiate(ReplicationPolicy.class,\n                    this, true);\n        }\n        return (QueryTargetPolicy) queryTargetPolicyPlugin.get();\n    }", "code_tokens": ["public", "QueryTargetPolicy", "getQueryTargetPolicyInstance", "(", ")", "{", "if", "(", "queryTargetPolicyPlugin", ".", "get", "(", ")", "==", "null", ")", "{", "queryTargetPolicyPlugin", ".", "instantiate", "(", "ReplicationPolicy", ".", "class", ",", "this", ",", "true", ")", ";", "}", "return", "(", "QueryTargetPolicy", ")", "queryTargetPolicyPlugin", ".", "get", "(", ")", ";", "}"], "idx": 33539, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "7f14c7df6b7c7ef42f0671138b9b5dd062fe99aa", "function_name": "getQueryTargetPolicyInstance", "body_hash": "eb80b1b07b30517af86153688d8d3a063d3b48f3"}
{"code": "public final int doWikiStartTag()\n        throws IOException\n    {\n        WikiEngine engine = m_wikiContext.getEngine();\n        WikiPage   page   = m_wikiContext.getPage();\n\n        if( page != null )\n        {\n            if( page instanceof Attachment )\n            {\n                pageContext.getOut().print( ((Attachment)page).getFileName() );\n            }\n            else\n            {\n                pageContext.getOut().print( engine.beautifyTitle( m_wikiContext.getName() ) );\n            }\n        }\n\n        return SKIP_BODY;\n    }", "code_tokens": ["public", "final", "int", "doWikiStartTag", "(", ")", "throws", "IOException", "{", "WikiEngine", "engine", "=", "m_wikiContext", ".", "getEngine", "(", ")", ";", "WikiPage", "page", "=", "m_wikiContext", ".", "getPage", "(", ")", ";", "if", "(", "page", "!=", "null", ")", "{", "if", "(", "page", "instanceof", "Attachment", ")", "{", "pageContext", ".", "getOut", "(", ")", ".", "print", "(", "(", "(", "Attachment", ")", "page", ")", ".", "getFileName", "(", ")", ")", ";", "}", "else", "{", "pageContext", ".", "getOut", "(", ")", ".", "print", "(", "engine", ".", "beautifyTitle", "(", "m_wikiContext", ".", "getName", "(", ")", ")", ")", ";", "}", "}", "return", "SKIP_BODY", ";", "}"], "idx": 79600, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "59881d4c80c3c686cce582714ef6ff31956502ad", "function_name": "doWikiStartTag", "body_hash": "23ad8e6b8303b6f08fdfb5c63a4c9f97b6d38b57"}
{"code": "@Override\n    protected void onFullPongMessage(final WebSocketChannel webSocketChannel, BufferedBinaryMessage bufferedBinaryMessage) {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            bufferedBinaryMessage.getData().free();\n            return;\n        }\n        final HandlerWrapper handler = getHandler(FrameType.PONG);\n        if (handler != null) {\n            final Pooled<ByteBuffer[]> pooled = bufferedBinaryMessage.getData();\n            final PongMessage message = DefaultPongMessage.create(toBuffer(pooled.getResource()));\n\n            session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        ((MessageHandler.Whole) handler.getHandler()).onMessage(message);\n                    } catch (Exception e) {\n                        invokeOnError(e);\n                    } finally {\n                        pooled.close();\n                    }\n                }\n            });\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "onFullPongMessage", "(", "final", "WebSocketChannel", "webSocketChannel", ",", "BufferedBinaryMessage", "bufferedBinaryMessage", ")", "{", "if", "(", "session", ".", "isSessionClosed", "(", ")", ")", "{", "bufferedBinaryMessage", ".", "getData", "(", ")", ".", "free", "(", ")", ";", "return", ";", "}", "final", "HandlerWrapper", "handler", "=", "getHandler", "(", "FrameType", ".", "PONG", ")", ";", "if", "(", "handler", "!=", "null", ")", "{", "final", "Pooled", "<", "ByteBuffer", "[", "]", ">", "pooled", "=", "bufferedBinaryMessage", ".", "getData", "(", ")", ";", "final", "PongMessage", "message", "=", "DefaultPongMessage", ".", "create", "(", "toBuffer", "(", "pooled", ".", "getResource", "(", ")", ")", ")", ";", "session", ".", "getContainer", "(", ")", ".", "invokeEndpointMethod", "(", "executor", ",", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "try", "{", "(", "(", "MessageHandler", ".", "Whole", ")", "handler", ".", "getHandler", "(", ")", ")", ".", "onMessage", "(", "message", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "invokeOnError", "(", "e", ")", ";", "}", "finally", "{", "pooled", ".", "close", "(", ")", ";", "}", "}", "}", ")", ";", "}", "}"], "idx": 52806, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "c7e84a0b7efced38506d7d1dfea5902366973877", "function_name": "onFullPongMessage", "body_hash": "58773f75261d1183c987655d6b19eaa483df2b1e"}
{"code": "@Override\n    public SecurityConstraint [] findSecurityConstraints(Request request,\n                                                         Context context) {\n\n        ArrayList<SecurityConstraint> results = null;\n        // Are there any defined security constraints?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraints defined\");\n            return null;\n        }\n\n        // Check each defined security constraint\n        String uri = request.getRequestPathMB().toString();\n        // Bug47080 - in rare cases this may be null or \"\"\n        // Mapper treats as '/' do the same to prevent NPE\n        if (uri == null || uri.length() == 0) {\n            uri = \"/\";\n        }\n\n        String method = request.getMethod();\n        int i;\n        boolean found = false;\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length; k++) {\n                    // Exact match including special case for the context root.\n                    if(uri.equals(patterns[k]) || patterns[k].length() == 0 && uri.equals(\"/\")) {\n                        found = true;\n                        if(collection[j].findMethod(method)) {\n                            if(results == null) {\n                                results = new ArrayList<>();\n                            }\n                            results.add(constraints[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        int longest = -1;\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                int length = -1;\n                for(int k=0; k < patterns.length; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") &&\n                       pattern.length() >= longest) {\n\n                        if(pattern.length() == 2) {\n                            matched = true;\n                            length = pattern.length();\n                        } else if(pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-1) ||\n                                  (pattern.length()-2 == uri.length() &&\n                                   pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-2))) {\n                            matched = true;\n                            length = pattern.length();\n                        }\n                    }\n                }\n                if(matched) {\n                    if(length > longest) {\n                        found = false;\n                        if(results != null) {\n                            results.clear();\n                        }\n                        longest = length;\n                    }\n                    if(collection[j].findMethod(method)) {\n                        found = true;\n                        if(results == null) {\n                            results = new ArrayList<>();\n                        }\n                        results.add(constraints[i]);\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return  resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            boolean matched = false;\n            int pos = -1;\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"*.\")){\n                        int slash = uri.lastIndexOf('/');\n                        int dot = uri.lastIndexOf('.');\n                        if(slash >= 0 && dot > slash &&\n                           dot != uri.length()-1 &&\n                           uri.length()-dot == pattern.length()-1) {\n                            if(pattern.regionMatches(1,uri,dot,uri.length()-dot)) {\n                                matched = true;\n                                pos = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if(matched) {\n                found = true;\n                if(collection[pos].findMethod(method)) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.equals(\"/\")){\n                        matched = true;\n                    }\n                }\n                if(matched) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(results == null) {\n            // No applicable security constraint was found\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraint located\");\n        }\n        return resultsToArray(results);\n    }", "code_tokens": ["@", "Override", "public", "SecurityConstraint", "[", "]", "findSecurityConstraints", "(", "Request", "request", ",", "Context", "context", ")", "{", "ArrayList", "<", "SecurityConstraint", ">", "results", "=", "null", ";", "SecurityConstraint", "constraints", "[", "]", "=", "context", ".", "findConstraints", "(", ")", ";", "if", "(", "(", "constraints", "==", "null", ")", "||", "(", "constraints", ".", "length", "==", "0", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "  No applicable constraints defined", "\"", ")", ";", "return", "null", ";", "}", "String", "uri", "=", "request", ".", "getRequestPathMB", "(", ")", ".", "toString", "(", ")", ";", "if", "(", "uri", "==", "null", "||", "uri", ".", "length", "(", ")", "==", "0", ")", "{", "uri", "=", "\"", "/", "\"", ";", "}", "String", "method", "=", "request", ".", "getMethod", "(", ")", ";", "int", "i", ";", "boolean", "found", "=", "false", ";", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", ";", "i", "++", ")", "{", "SecurityCollection", "[", "]", "collection", "=", "constraints", "[", "i", "]", ".", "findCollections", "(", ")", ";", "if", "(", "collection", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "  Checking constraint '", "\"", "+", "constraints", "[", "i", "]", "+", "\"", "' against ", "\"", "+", "method", "+", "\"", " ", "\"", "+", "uri", "+", "\"", " --> ", "\"", "+", "constraints", "[", "i", "]", ".", "included", "(", "uri", ",", "method", ")", ")", ";", "}", "for", "(", "int", "j", "=", "0", ";", "j", "<", "collection", ".", "length", ";", "j", "++", ")", "{", "String", "[", "]", "patterns", "=", "collection", "[", "j", "]", ".", "findPatterns", "(", ")", ";", "if", "(", "patterns", "==", "null", ")", "{", "continue", ";", "}", "for", "(", "int", "k", "=", "0", ";", "k", "<", "patterns", ".", "length", ";", "k", "++", ")", "{", "if", "(", "uri", ".", "equals", "(", "patterns", "[", "k", "]", ")", "||", "patterns", "[", "k", "]", ".", "length", "(", ")", "==", "0", "&&", "uri", ".", "equals", "(", "\"", "/", "\"", ")", ")", "{", "found", "=", "true", ";", "if", "(", "collection", "[", "j", "]", ".", "findMethod", "(", "method", ")", ")", "{", "if", "(", "results", "==", "null", ")", "{", "results", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "}", "results", ".", "add", "(", "constraints", "[", "i", "]", ")", ";", "}", "}", "}", "}", "}", "if", "(", "found", ")", "{", "return", "resultsToArray", "(", "results", ")", ";", "}", "int", "longest", "=", "-", "1", ";", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", ";", "i", "++", ")", "{", "SecurityCollection", "[", "]", "collection", "=", "constraints", "[", "i", "]", ".", "findCollections", "(", ")", ";", "if", "(", "collection", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "  Checking constraint '", "\"", "+", "constraints", "[", "i", "]", "+", "\"", "' against ", "\"", "+", "method", "+", "\"", " ", "\"", "+", "uri", "+", "\"", " --> ", "\"", "+", "constraints", "[", "i", "]", ".", "included", "(", "uri", ",", "method", ")", ")", ";", "}", "for", "(", "int", "j", "=", "0", ";", "j", "<", "collection", ".", "length", ";", "j", "++", ")", "{", "String", "[", "]", "patterns", "=", "collection", "[", "j", "]", ".", "findPatterns", "(", ")", ";", "if", "(", "patterns", "==", "null", ")", "{", "continue", ";", "}", "boolean", "matched", "=", "false", ";", "int", "length", "=", "-", "1", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "patterns", ".", "length", ";", "k", "++", ")", "{", "String", "pattern", "=", "patterns", "[", "k", "]", ";", "if", "(", "pattern", ".", "startsWith", "(", "\"", "/", "\"", ")", "&&", "pattern", ".", "endsWith", "(", "\"", "/*", "\"", ")", "&&", "pattern", ".", "length", "(", ")", ">=", "longest", ")", "{", "if", "(", "pattern", ".", "length", "(", ")", "==", "2", ")", "{", "matched", "=", "true", ";", "length", "=", "pattern", ".", "length", "(", ")", ";", "}", "else", "if", "(", "pattern", ".", "regionMatches", "(", "0", ",", "uri", ",", "0", ",", "pattern", ".", "length", "(", ")", "-", "1", ")", "||", "(", "pattern", ".", "length", "(", ")", "-", "2", "==", "uri", ".", "length", "(", ")", "&&", "pattern", ".", "regionMatches", "(", "0", ",", "uri", ",", "0", ",", "pattern", ".", "length", "(", ")", "-", "2", ")", ")", ")", "{", "matched", "=", "true", ";", "length", "=", "pattern", ".", "length", "(", ")", ";", "}", "}", "}", "if", "(", "matched", ")", "{", "if", "(", "length", ">", "longest", ")", "{", "found", "=", "false", ";", "if", "(", "results", "!=", "null", ")", "{", "results", ".", "clear", "(", ")", ";", "}", "longest", "=", "length", ";", "}", "if", "(", "collection", "[", "j", "]", ".", "findMethod", "(", "method", ")", ")", "{", "found", "=", "true", ";", "if", "(", "results", "==", "null", ")", "{", "results", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "}", "results", ".", "add", "(", "constraints", "[", "i", "]", ")", ";", "}", "}", "}", "}", "if", "(", "found", ")", "{", "return", "resultsToArray", "(", "results", ")", ";", "}", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", ";", "i", "++", ")", "{", "SecurityCollection", "[", "]", "collection", "=", "constraints", "[", "i", "]", ".", "findCollections", "(", ")", ";", "if", "(", "collection", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "  Checking constraint '", "\"", "+", "constraints", "[", "i", "]", "+", "\"", "' against ", "\"", "+", "method", "+", "\"", " ", "\"", "+", "uri", "+", "\"", " --> ", "\"", "+", "constraints", "[", "i", "]", ".", "included", "(", "uri", ",", "method", ")", ")", ";", "}", "boolean", "matched", "=", "false", ";", "int", "pos", "=", "-", "1", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "collection", ".", "length", ";", "j", "++", ")", "{", "String", "[", "]", "patterns", "=", "collection", "[", "j", "]", ".", "findPatterns", "(", ")", ";", "if", "(", "patterns", "==", "null", ")", "{", "continue", ";", "}", "for", "(", "int", "k", "=", "0", ";", "k", "<", "patterns", ".", "length", "&&", "!", "matched", ";", "k", "++", ")", "{", "String", "pattern", "=", "patterns", "[", "k", "]", ";", "if", "(", "pattern", ".", "startsWith", "(", "\"", "*.", "\"", ")", ")", "{", "int", "slash", "=", "uri", ".", "lastIndexOf", "(", "'/'", ")", ";", "int", "dot", "=", "uri", ".", "lastIndexOf", "(", "'.'", ")", ";", "if", "(", "slash", ">=", "0", "&&", "dot", ">", "slash", "&&", "dot", "!=", "uri", ".", "length", "(", ")", "-", "1", "&&", "uri", ".", "length", "(", ")", "-", "dot", "==", "pattern", ".", "length", "(", ")", "-", "1", ")", "{", "if", "(", "pattern", ".", "regionMatches", "(", "1", ",", "uri", ",", "dot", ",", "uri", ".", "length", "(", ")", "-", "dot", ")", ")", "{", "matched", "=", "true", ";", "pos", "=", "j", ";", "}", "}", "}", "}", "}", "if", "(", "matched", ")", "{", "found", "=", "true", ";", "if", "(", "collection", "[", "pos", "]", ".", "findMethod", "(", "method", ")", ")", "{", "if", "(", "results", "==", "null", ")", "{", "results", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "}", "results", ".", "add", "(", "constraints", "[", "i", "]", ")", ";", "}", "}", "}", "if", "(", "found", ")", "{", "return", "resultsToArray", "(", "results", ")", ";", "}", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", ";", "i", "++", ")", "{", "SecurityCollection", "[", "]", "collection", "=", "constraints", "[", "i", "]", ".", "findCollections", "(", ")", ";", "if", "(", "collection", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "  Checking constraint '", "\"", "+", "constraints", "[", "i", "]", "+", "\"", "' against ", "\"", "+", "method", "+", "\"", " ", "\"", "+", "uri", "+", "\"", " --> ", "\"", "+", "constraints", "[", "i", "]", ".", "included", "(", "uri", ",", "method", ")", ")", ";", "}", "for", "(", "int", "j", "=", "0", ";", "j", "<", "collection", ".", "length", ";", "j", "++", ")", "{", "String", "[", "]", "patterns", "=", "collection", "[", "j", "]", ".", "findPatterns", "(", ")", ";", "if", "(", "patterns", "==", "null", ")", "{", "continue", ";", "}", "boolean", "matched", "=", "false", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "patterns", ".", "length", "&&", "!", "matched", ";", "k", "++", ")", "{", "String", "pattern", "=", "patterns", "[", "k", "]", ";", "if", "(", "pattern", ".", "equals", "(", "\"", "/", "\"", ")", ")", "{", "matched", "=", "true", ";", "}", "}", "if", "(", "matched", ")", "{", "if", "(", "results", "==", "null", ")", "{", "results", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "}", "results", ".", "add", "(", "constraints", "[", "i", "]", ")", ";", "}", "}", "}", "if", "(", "results", "==", "null", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "  No applicable constraint located", "\"", ")", ";", "}", "return", "resultsToArray", "(", "results", ")", ";", "}"], "idx": 100874, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "723ea6a5bc5e7bc49e5ef84273c3b3c164a6a4fd", "function_name": "findSecurityConstraints", "body_hash": "d8036c7bf7e5213e3b9cc5ec3b17076c987c9329"}
{"code": "public void testValidUrlWithDefaultRegex() throws Exception {\n        URLValidator validator = new URLValidator();\n\n        Pattern pattern = Pattern.compile(validator.getUrlRegex(), Pattern.CASE_INSENSITIVE);\n\n        assertFalse(pattern.matcher(\"myapp://test.com\").matches());\n        assertFalse(pattern.matcher(\"myap://test.com\").matches());\n        assertFalse(pattern.matcher(\"\").matches());\n        assertFalse(pattern.matcher(\"   \").matches());\n        assertFalse(pattern.matcher(\"no url\").matches());\n        assertFalse(pattern.matcher(\"http://example.com////////////////////////////////////////////////////////////////////////////////////??\").matches());\n\n        assertTrue(pattern.matcher(\"http://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com:443/login\").matches());\n        assertTrue(pattern.matcher(\"http://localhost:8080/myapp\").matches());\n\n        assertTrue(pattern.matcher(\"http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F\"));\n\n        assertTrue(pattern.matcher(\"http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa\"));\n\n        assertTrue(pattern.matcher(\"http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F\"));\n\n        //this will cause test to hang indefinitely using JDK 1.8.0_121, Struts 2.5.10.1 and JUnit 4.5\n        assertTrue(pattern.matcher(\"http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/\"));\n\n        //this will cause test to hang indefinitely using JDK 1.8.0_121, Struts 2.5.10.1 and JUnit 4.5\n        assertTrue(pattern.matcher(\"http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E\"));\n    }", "code_tokens": ["public", "void", "testValidUrlWithDefaultRegex", "(", ")", "throws", "Exception", "{", "URLValidator", "validator", "=", "new", "URLValidator", "(", ")", ";", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "validator", ".", "getUrlRegex", "(", ")", ",", "Pattern", ".", "CASE_INSENSITIVE", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "myapp://test.com", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "myap://test.com", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "   ", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "no url", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertFalse", "(", "pattern", ".", "matcher", "(", "\"", "http://example.com////////////////////////////////////////////////////////////////////////////////////??", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://www.opensymphony.com", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "https://www.opensymphony.com", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "https://www.opensymphony.com:443/login", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://localhost:8080/myapp", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/", "\"", ")", ")", ";", "assertTrue", "(", "pattern", ".", "matcher", "(", "\"", "http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E", "\"", ")", ".", "matches", "(", ")", ")", ";", "assertTrue", "(", "UrlValidator", ".", "getInstance", "(", ")", ".", "isValid", "(", "\"", "http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E", "\"", ")", ")", ";", "}"], "idx": 7195, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "a05259ed69a5a48379aa91650e4cd1cb4bd6e5a", "function_name": "testValidUrlWithDefaultRegex", "body_hash": "716c4bbbcd31defbfd73091c6a17e33e2b93181b"}
{"code": "private static void assertSendsCorrectly(final byte[] sourceBytes, SSLEngine source,\n            SSLEngine dest, boolean needsRecordSplit) throws SSLException {\n        ByteBuffer sourceOut = ByteBuffer.wrap(sourceBytes);\n        SSLSession sourceSession = source.getSession();\n        ByteBuffer sourceToDest = ByteBuffer.allocate(sourceSession.getPacketBufferSize());\n        SSLEngineResult sourceOutRes = source.wrap(sourceOut, sourceToDest);\n        sourceToDest.flip();\n\n        String sourceCipherSuite = source.getSession().getCipherSuite();\n        assertEquals(sourceCipherSuite, sourceBytes.length, sourceOutRes.bytesConsumed());\n        assertEquals(sourceCipherSuite, HandshakeStatus.NOT_HANDSHAKING,\n                sourceOutRes.getHandshakeStatus());\n\n        SSLSession destSession = dest.getSession();\n        ByteBuffer destIn = ByteBuffer.allocate(destSession.getApplicationBufferSize());\n\n        int numUnwrapCalls = 0;\n        while (destIn.position() != sourceOut.limit()) {\n            SSLEngineResult destRes = dest.unwrap(sourceToDest, destIn);\n            assertEquals(sourceCipherSuite, HandshakeStatus.NOT_HANDSHAKING,\n                    destRes.getHandshakeStatus());\n            if (needsRecordSplit && numUnwrapCalls == 0) {\n                assertEquals(sourceCipherSuite, 1, destRes.bytesProduced());\n            }\n            numUnwrapCalls++;\n        }\n\n        destIn.flip();\n        byte[] actual = new byte[destIn.remaining()];\n        destIn.get(actual);\n        assertEquals(sourceCipherSuite, Arrays.toString(sourceBytes), Arrays.toString(actual));\n\n        if (needsRecordSplit) {\n            assertEquals(sourceCipherSuite, 2, numUnwrapCalls);\n        } else {\n            assertEquals(sourceCipherSuite, 1, numUnwrapCalls);\n            assertSendsCorrectlyWhenSplit(sourceBytes, source, dest);\n        }\n    }", "code_tokens": ["private", "static", "void", "assertSendsCorrectly", "(", "final", "byte", "[", "]", "sourceBytes", ",", "SSLEngine", "source", ",", "SSLEngine", "dest", ",", "boolean", "needsRecordSplit", ")", "throws", "SSLException", "{", "ByteBuffer", "sourceOut", "=", "ByteBuffer", ".", "wrap", "(", "sourceBytes", ")", ";", "SSLSession", "sourceSession", "=", "source", ".", "getSession", "(", ")", ";", "ByteBuffer", "sourceToDest", "=", "ByteBuffer", ".", "allocate", "(", "sourceSession", ".", "getPacketBufferSize", "(", ")", ")", ";", "SSLEngineResult", "sourceOutRes", "=", "source", ".", "wrap", "(", "sourceOut", ",", "sourceToDest", ")", ";", "sourceToDest", ".", "flip", "(", ")", ";", "String", "sourceCipherSuite", "=", "source", ".", "getSession", "(", ")", ".", "getCipherSuite", "(", ")", ";", "assertEquals", "(", "sourceCipherSuite", ",", "sourceBytes", ".", "length", ",", "sourceOutRes", ".", "bytesConsumed", "(", ")", ")", ";", "assertEquals", "(", "sourceCipherSuite", ",", "HandshakeStatus", ".", "NOT_HANDSHAKING", ",", "sourceOutRes", ".", "getHandshakeStatus", "(", ")", ")", ";", "SSLSession", "destSession", "=", "dest", ".", "getSession", "(", ")", ";", "ByteBuffer", "destIn", "=", "ByteBuffer", ".", "allocate", "(", "destSession", ".", "getApplicationBufferSize", "(", ")", ")", ";", "int", "numUnwrapCalls", "=", "0", ";", "while", "(", "destIn", ".", "position", "(", ")", "!=", "sourceOut", ".", "limit", "(", ")", ")", "{", "SSLEngineResult", "destRes", "=", "dest", ".", "unwrap", "(", "sourceToDest", ",", "destIn", ")", ";", "assertEquals", "(", "sourceCipherSuite", ",", "HandshakeStatus", ".", "NOT_HANDSHAKING", ",", "destRes", ".", "getHandshakeStatus", "(", ")", ")", ";", "if", "(", "needsRecordSplit", "&&", "numUnwrapCalls", "==", "0", ")", "{", "assertEquals", "(", "sourceCipherSuite", ",", "1", ",", "destRes", ".", "bytesProduced", "(", ")", ")", ";", "}", "numUnwrapCalls", "++", ";", "}", "destIn", ".", "flip", "(", ")", ";", "byte", "[", "]", "actual", "=", "new", "byte", "[", "destIn", ".", "remaining", "(", ")", "]", ";", "destIn", ".", "get", "(", "actual", ")", ";", "assertEquals", "(", "sourceCipherSuite", ",", "Arrays", ".", "toString", "(", "sourceBytes", ")", ",", "Arrays", ".", "toString", "(", "actual", ")", ")", ";", "if", "(", "needsRecordSplit", ")", "{", "assertEquals", "(", "sourceCipherSuite", ",", "2", ",", "numUnwrapCalls", ")", ";", "}", "else", "{", "assertEquals", "(", "sourceCipherSuite", ",", "1", ",", "numUnwrapCalls", ")", ";", "assertSendsCorrectlyWhenSplit", "(", "sourceBytes", ",", "source", ",", "dest", ")", ";", "}", "}"], "idx": 102249, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "e56958e7dea05c1784317f139e2216e2e707d391", "function_name": "assertSendsCorrectly", "body_hash": "6d1c13d64a3fc168970b59d1ef37770c89016e79"}
{"code": "public Thread newThread(final Runnable r) {\n            return doPrivileged(new PrivilegedAction<Thread>() {\n                public Thread run() {\n                    final Thread taskThread = new Thread(threadGroup, r, name + \" task-\" + getNextSeq(), stackSize);\n                    // Mark the thread as daemon if the Options.THREAD_DAEMON has been set\n                    if (markThreadAsDaemon) {\n                        taskThread.setDaemon(true);\n                    }\n                    return taskThread;\n                }\n            });\n        }", "code_tokens": ["public", "Thread", "newThread", "(", "final", "Runnable", "r", ")", "{", "return", "doPrivileged", "(", "new", "PrivilegedAction", "<", "Thread", ">", "(", ")", "{", "public", "Thread", "run", "(", ")", "{", "final", "Thread", "taskThread", "=", "new", "Thread", "(", "threadGroup", ",", "r", ",", "name", "+", "\"", " task-", "\"", "+", "getNextSeq", "(", ")", ",", "stackSize", ")", ";", "if", "(", "markThreadAsDaemon", ")", "{", "taskThread", ".", "setDaemon", "(", "true", ")", ";", "}", "return", "taskThread", ";", "}", "}", ")", ";", "}"], "idx": 109835, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "3a6cde771994ad347edacc13f75fbfefd6c4734d", "function_name": "newThread", "body_hash": "3ce50fc02ab1a59b4729df7addb7440eda1574ae"}
{"code": "private void signIn(String userName, String password) {\n        webDriver.findElement(By.name(\"username\")).sendKeys(userName);\n        webDriver.findElement(By.name(\"password\")).sendKeys(password);\n        webDriver.findElement(By.xpath(\"//input[@value='Sign in']\")).click();\n    }", "code_tokens": ["private", "void", "signIn", "(", "String", "userName", ",", "String", "password", ")", "{", "webDriver", ".", "findElement", "(", "By", ".", "name", "(", "\"", "username", "\"", ")", ")", ".", "sendKeys", "(", "userName", ")", ";", "webDriver", ".", "findElement", "(", "By", ".", "name", "(", "\"", "password", "\"", ")", ")", ".", "sendKeys", "(", "password", ")", ";", "webDriver", ".", "findElement", "(", "By", ".", "xpath", "(", "\"", "//input[@value='Sign in']", "\"", ")", ")", ".", "click", "(", ")", ";", "}"], "idx": 35173, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "14350228989e2aee900b8d48a848293bb5152b6f", "function_name": "signIn", "body_hash": "5dcd29f106089f31d68c6a86be15ce99d6e3d3fa"}
{"code": "@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN\n            + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')\")\n    public void migrateCube(CubeInstance cube, String projectName) {\n        KylinConfig config = KylinConfig.getInstanceFromEnv();\n        if (!config.isAllowAutoMigrateCube()) {\n            throw new InternalErrorException(\"One click migration is disabled, please contact your ADMIN\");\n        }\n\n        for (CubeSegment segment : cube.getSegments()) {\n            if (segment.getStatus() != SegmentStatusEnum.READY) {\n                throw new InternalErrorException(\n                        \"At least one segment is not in READY state. Please check whether there are Running or Error jobs.\");\n            }\n        }\n\n        String srcCfgUri = config.getAutoMigrateCubeSrcConfig();\n        String dstCfgUri = config.getAutoMigrateCubeDestConfig();\n\n        Preconditions.checkArgument(StringUtils.isNotEmpty(srcCfgUri), \"Source configuration should not be empty.\");\n        Preconditions.checkArgument(StringUtils.isNotEmpty(dstCfgUri),\n                \"Destination configuration should not be empty.\");\n\n        String stringBuilder = (\"%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true\");\n        String cmd = String.format(Locale.ROOT,\n                stringBuilder,\n                KylinConfig.getKylinHome(),\n                CliCommandExecutor.checkParameterWhiteList(srcCfgUri),\n                CliCommandExecutor.checkParameterWhiteList(dstCfgUri),\n                cube.getName(),\n                CliCommandExecutor.checkParameterWhiteList(projectName),\n                config.isAutoMigrateCubeCopyAcl(),\n                config.isAutoMigrateCubePurge());\n\n        logger.info(\"One click migration cmd: \" + cmd);\n\n        CliCommandExecutor exec = new CliCommandExecutor();\n        PatternedLogger patternedLogger = new PatternedLogger(logger);\n\n        try {\n            exec.execute(cmd, patternedLogger);\n        } catch (IOException e) {\n            throw new InternalErrorException(\"Failed to perform one-click migrating\", e);\n        }\n    }", "code_tokens": ["@", "PreAuthorize", "(", "Constant", ".", "ACCESS_HAS_ROLE_ADMIN", "+", "\"", " or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')", "\"", ")", "public", "void", "migrateCube", "(", "CubeInstance", "cube", ",", "String", "projectName", ")", "{", "KylinConfig", "config", "=", "KylinConfig", ".", "getInstanceFromEnv", "(", ")", ";", "if", "(", "!", "config", ".", "isAllowAutoMigrateCube", "(", ")", ")", "{", "throw", "new", "InternalErrorException", "(", "\"", "One click migration is disabled, please contact your ADMIN", "\"", ")", ";", "}", "for", "(", "CubeSegment", "segment", ":", "cube", ".", "getSegments", "(", ")", ")", "{", "if", "(", "segment", ".", "getStatus", "(", ")", "!=", "SegmentStatusEnum", ".", "READY", ")", "{", "throw", "new", "InternalErrorException", "(", "\"", "At least one segment is not in READY state. Please check whether there are Running or Error jobs.", "\"", ")", ";", "}", "}", "String", "srcCfgUri", "=", "config", ".", "getAutoMigrateCubeSrcConfig", "(", ")", ";", "String", "dstCfgUri", "=", "config", ".", "getAutoMigrateCubeDestConfig", "(", ")", ";", "Preconditions", ".", "checkArgument", "(", "StringUtils", ".", "isNotEmpty", "(", "srcCfgUri", ")", ",", "\"", "Source configuration should not be empty.", "\"", ")", ";", "Preconditions", ".", "checkArgument", "(", "StringUtils", ".", "isNotEmpty", "(", "dstCfgUri", ")", ",", "\"", "Destination configuration should not be empty.", "\"", ")", ";", "String", "stringBuilder", "=", "(", "\"", "%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true", "\"", ")", ";", "String", "cmd", "=", "String", ".", "format", "(", "Locale", ".", "ROOT", ",", "stringBuilder", ",", "KylinConfig", ".", "getKylinHome", "(", ")", ",", "CliCommandExecutor", ".", "checkParameterWhiteList", "(", "srcCfgUri", ")", ",", "CliCommandExecutor", ".", "checkParameterWhiteList", "(", "dstCfgUri", ")", ",", "cube", ".", "getName", "(", ")", ",", "CliCommandExecutor", ".", "checkParameterWhiteList", "(", "projectName", ")", ",", "config", ".", "isAutoMigrateCubeCopyAcl", "(", ")", ",", "config", ".", "isAutoMigrateCubePurge", "(", ")", ")", ";", "logger", ".", "info", "(", "\"", "One click migration cmd: ", "\"", "+", "cmd", ")", ";", "CliCommandExecutor", "exec", "=", "new", "CliCommandExecutor", "(", ")", ";", "PatternedLogger", "patternedLogger", "=", "new", "PatternedLogger", "(", "logger", ")", ";", "try", "{", "exec", ".", "execute", "(", "cmd", ",", "patternedLogger", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "InternalErrorException", "(", "\"", "Failed to perform one-click migrating", "\"", ",", "e", ")", ";", "}", "}"], "idx": 76734, "cwe": "CWE-78", "target": 0, "status": "FIXED", "commit": "0888c867a52479840a6f3fcd812f9305a95b8dfd", "function_name": "migrateCube", "body_hash": "31549b552387b4368dc6ef03b781689e429b0a26"}
{"code": "private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }", "code_tokens": ["private", "State", "readHeaders", "(", "ByteBuf", "buffer", ")", "{", "final", "HttpMessage", "message", "=", "this", ".", "message", ";", "final", "HttpHeaders", "headers", "=", "message", ".", "headers", "(", ")", ";", "AppendableCharSequence", "line", "=", "headerParser", ".", "parse", "(", "buffer", ")", ";", "if", "(", "line", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "line", ".", "length", "(", ")", ">", "0", ")", "{", "do", "{", "char", "firstChar", "=", "line", ".", "charAtUnsafe", "(", "0", ")", ";", "if", "(", "name", "!=", "null", "&&", "(", "firstChar", "==", "' '", "||", "firstChar", "==", "'\\t'", ")", ")", "{", "String", "trimmedLine", "=", "line", ".", "toString", "(", ")", ".", "trim", "(", ")", ";", "String", "valueStr", "=", "String", ".", "valueOf", "(", "value", ")", ";", "value", "=", "valueStr", "+", "' '", "+", "trimmedLine", ";", "}", "else", "{", "if", "(", "name", "!=", "null", ")", "{", "headers", ".", "add", "(", "name", ",", "value", ")", ";", "}", "splitHeader", "(", "line", ")", ";", "}", "line", "=", "headerParser", ".", "parse", "(", "buffer", ")", ";", "if", "(", "line", "==", "null", ")", "{", "return", "null", ";", "}", "}", "while", "(", "line", ".", "length", "(", ")", ">", "0", ")", ";", "}", "if", "(", "name", "!=", "null", ")", "{", "headers", ".", "add", "(", "name", ",", "value", ")", ";", "}", "name", "=", "null", ";", "value", "=", "null", ";", "State", "nextState", ";", "if", "(", "isContentAlwaysEmpty", "(", "message", ")", ")", "{", "HttpUtil", ".", "setTransferEncodingChunked", "(", "message", ",", "false", ")", ";", "nextState", "=", "State", ".", "SKIP_CONTROL_CHARS", ";", "}", "else", "if", "(", "HttpUtil", ".", "isTransferEncodingChunked", "(", "message", ")", ")", "{", "nextState", "=", "State", ".", "READ_CHUNK_SIZE", ";", "}", "else", "if", "(", "contentLength", "(", ")", ">=", "0", ")", "{", "nextState", "=", "State", ".", "READ_FIXED_LENGTH_CONTENT", ";", "}", "else", "{", "nextState", "=", "State", ".", "READ_VARIABLE_LENGTH_CONTENT", ";", "}", "return", "nextState", ";", "}"], "idx": 53933, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "8494b046ec7e4f28dbd44bc699cc4c4c9225172", "function_name": "readHeaders", "body_hash": "2ab78153a46ffa1abd8475971305e66556d90d30"}
{"code": "public static String javaScriptEscape(String input) {\n\t\tif (input == null) {\n\t\t\treturn input;\n\t\t}\n\n\t\tStringBuilder filtered = new StringBuilder(input.length());\n\t\tchar prevChar = '\\u0000';\n\t\tchar c;\n\t\tfor (int i = 0; i < input.length(); i++) {\n\t\t\tc = input.charAt(i);\n\t\t\tif (c == '\"') {\n\t\t\t\tfiltered.append(\"\\\\\\\"\");\n\t\t\t}\n\t\t\telse if (c == '\\'') {\n\t\t\t\tfiltered.append(\"\\\\'\");\n\t\t\t}\n\t\t\telse if (c == '\\\\') {\n\t\t\t\tfiltered.append(\"\\\\\\\\\");\n\t\t\t}\n\t\t\telse if (c == '/') {\n\t\t\t\tfiltered.append(\"\\\\/\");\n\t\t\t}\n\t\t\telse if (c == '\\t') {\n\t\t\t\tfiltered.append(\"\\\\t\");\n\t\t\t}\n\t\t\telse if (c == '\\n') {\n\t\t\t\tif (prevChar != '\\r') {\n\t\t\t\t\tfiltered.append(\"\\\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == '\\r') {\n\t\t\t\tfiltered.append(\"\\\\n\");\n\t\t\t}\n\t\t\telse if (c == '\\f') {\n\t\t\t\tfiltered.append(\"\\\\f\");\n\t\t\t}\n\t\t\telse if (c == '\\b') {\n\t\t\t\tfiltered.append(\"\\\\b\");\n\t\t\t}\n\t\t\t// No '\\v' in Java, use octal value for VT ascii char\n\t\t\telse if (c == '\\013') {\n\t\t\t\tfiltered.append(\"\\\\v\");\n\t\t\t}\n\t\t\telse if (c == '<') {\n\t\t\t\tfiltered.append(\"\\\\u003C\");\n\t\t\t}\n\t\t\telse if (c == '>') {\n\t\t\t\tfiltered.append(\"\\\\u003E\");\n\t\t\t}\n\t\t\t// Unicode for PS (line terminator in ECMA-262)\n\t\t\telse if (c == '\\u2028') {\n\t\t\t\tfiltered.append(\"\\\\u2028\");\n\t\t\t}\n\t\t\t// Unicode for LS (line terminator in ECMA-262)\n\t\t\telse if (c == '\\u2029') {\n\t\t\t\tfiltered.append(\"\\\\u2029\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfiltered.append(c);\n\t\t\t}\n\t\t\tprevChar = c;\n\n\t\t}\n\t\treturn filtered.toString();\n\t}", "code_tokens": ["public", "static", "String", "javaScriptEscape", "(", "String", "input", ")", "{", "if", "(", "input", "==", "null", ")", "{", "return", "input", ";", "}", "StringBuilder", "filtered", "=", "new", "StringBuilder", "(", "input", ".", "length", "(", ")", ")", ";", "char", "prevChar", "=", "'\\u0000'", ";", "char", "c", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "input", ".", "length", "(", ")", ";", "i", "++", ")", "{", "c", "=", "input", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "'\"'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "\\\"", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\''", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "'", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\\\'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "\\\\", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'/'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "/", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\t'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "t", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\n'", ")", "{", "if", "(", "prevChar", "!=", "'\\r'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "n", "\"", ")", ";", "}", "}", "else", "if", "(", "c", "==", "'\\r'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "n", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\f'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "f", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\b'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "b", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\013'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "v", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'<'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "u003C", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'>'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "u003E", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\u2028'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "u2028", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\u2029'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "u2029", "\"", ")", ";", "}", "else", "{", "filtered", ".", "append", "(", "c", ")", ";", "}", "prevChar", "=", "c", ";", "}", "return", "filtered", ".", "toString", "(", ")", ";", "}"], "idx": 79726, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "7a7df6637478607bef0277bf52a4e0a03e20a248", "function_name": "javaScriptEscape", "body_hash": "a0880418d4405517bc77a95fd29b5a240ce36c5b"}
{"code": "public static Document parseDocument(InputSource source) throws XMLException {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder xmlBuilder = dbf.newDocumentBuilder();\n            return xmlBuilder.parse(source);\n        } catch (Exception er) {\n            throw new XMLException(\"Error parsing XML document\", er);\n        }\n    }", "code_tokens": ["public", "static", "Document", "parseDocument", "(", "InputSource", "source", ")", "throws", "XMLException", "{", "try", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "DocumentBuilder", "xmlBuilder", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "return", "xmlBuilder", ".", "parse", "(", "source", ")", ";", "}", "catch", "(", "Exception", "er", ")", "{", "throw", "new", "XMLException", "(", "\"", "Error parsing XML document", "\"", ",", "er", ")", ";", "}", "}"], "idx": 66429, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "4debf8f25184b7283681ed3fb5e9e887d9d4fe22", "function_name": "parseDocument", "body_hash": "172c0d99149d9971d0577d667ecdf05c849ee136"}
{"code": "public FormValidation doRegexCheck(@QueryParameter final String value)\n            throws IOException, ServletException {\n        // No permission needed for simple syntax check\n        try {\n            Pattern.compile(value);\n            return FormValidation.ok();\n        } catch (Exception ex) {\n            return FormValidation.errorWithMarkup(\"Invalid <a href=\\\"\"\n                    + \"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html\"\n                    + \"\\\">regular expression</a> (\" + ex.getMessage() + \")\");\n        }\n    }", "code_tokens": ["public", "FormValidation", "doRegexCheck", "(", "@", "QueryParameter", "final", "String", "value", ")", "throws", "IOException", ",", "ServletException", "{", "try", "{", "Pattern", ".", "compile", "(", "value", ")", ";", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "Invalid <a href=", "\\\"", "\"", "+", "\"", "http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html", "\"", "+", "\"", "\\\"", ">regular expression</a> (", "\"", "+", "ex", ".", "getMessage", "(", ")", "+", "\"", ")", "\"", ")", ";", "}", "}"], "idx": 80561, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "40c6d62", "function_name": "doRegexCheck", "body_hash": "ef120c74480db2221f314e4bdd8c5b0d0c365e14"}
{"code": "public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain)\n          throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        String uri;\n        if (req.getPathInfo() == null) {\n            // workaround: on some containers such as CloudBees DEV@cloud, req.getPathInfo() is unexpectedly null,\n            // construct pathInfo based on contextPath and requestUri\n            uri = req.getRequestURI().substring(req.getContextPath().length());\n        } else {\n            uri = req.getPathInfo();\n        }\n        if (uriPattern != null && uriPattern.matcher(uri).matches()) {\n            User user = User.current();\n            String username = user != null ? user.getId() : req.getRemoteAddr();\n            String extra = \"\";\n            // For queue items, show what task is in the queue:\n            if (uri.startsWith(\"/queue/item/\")) {\n                extra = extractInfoFromQueueItem(uri);\n            } else if (uri.startsWith(\"/queue/cancelItem\")) {\n                extra = getFormattedQueueItemUrlFromItemId(Integer.parseInt(req.getParameter(\"id\")));\n                // not sure of the intent of the original author\n                // it looks to me we should always log the query parameters\n                // could we leak sensitive data?  There shouldn't be any in a query parameter...except for a badly coded plugin\n                // let's see if this becomes a wanted feature...\n                uri += \"?\" + req.getQueryString();\n            }\n\n            if (LOGGER.isLoggable(Level.FINE))\n                LOGGER.log(Level.FINE, \"Audit request {0} by user {1}\", new Object[]{uri, username});\n\n            onRequest(uri, extra, username);\n        } else {\n            LOGGER.log(Level.FINEST, \"Skip audit for request {0}\", uri);\n        }\n        chain.doFilter(req, res);\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "res", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "HttpServletRequest", "req", "=", "(", "HttpServletRequest", ")", "request", ";", "String", "uri", ";", "if", "(", "req", ".", "getPathInfo", "(", ")", "==", "null", ")", "{", "uri", "=", "req", ".", "getRequestURI", "(", ")", ".", "substring", "(", "req", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "}", "else", "{", "uri", "=", "req", ".", "getPathInfo", "(", ")", ";", "}", "if", "(", "uriPattern", "!=", "null", "&&", "uriPattern", ".", "matcher", "(", "uri", ")", ".", "matches", "(", ")", ")", "{", "User", "user", "=", "User", ".", "current", "(", ")", ";", "String", "username", "=", "user", "!=", "null", "?", "user", ".", "getId", "(", ")", ":", "req", ".", "getRemoteAddr", "(", ")", ";", "String", "extra", "=", "\"", "\"", ";", "if", "(", "uri", ".", "startsWith", "(", "\"", "/queue/item/", "\"", ")", ")", "{", "extra", "=", "extractInfoFromQueueItem", "(", "uri", ")", ";", "}", "else", "if", "(", "uri", ".", "startsWith", "(", "\"", "/queue/cancelItem", "\"", ")", ")", "{", "extra", "=", "getFormattedQueueItemUrlFromItemId", "(", "Integer", ".", "parseInt", "(", "req", ".", "getParameter", "(", "\"", "id", "\"", ")", ")", ")", ";", "uri", "+=", "\"", "?", "\"", "+", "req", ".", "getQueryString", "(", ")", ";", "}", "if", "(", "LOGGER", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Audit request {0} by user {1}", "\"", ",", "new", "Object", "[", "]", "{", "uri", ",", "username", "}", ")", ";", "onRequest", "(", "uri", ",", "extra", ",", "username", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINEST", ",", "\"", "Skip audit for request {0}", "\"", ",", "uri", ")", ";", "}", "chain", ".", "doFilter", "(", "req", ",", "res", ")", ";", "}"], "idx": 53817, "cwe": "CWE-435", "target": 1, "status": "VULNERABLE", "commit": "329c609", "function_name": "doFilter", "body_hash": "173450e02e32ff5ef8e6ba0eba1bdb0fa39eb679"}
{"code": "protected void addDefaultMapping(DefaultMapper mapper, String parameter, Object model) {\n\t\tExpression source = new RequestParameterExpression(parameter);\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tExpression target = expressionParser.parseExpression(parameter, parserContext);\n\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding default mapping for parameter '\" + parameter + \"'\");\n\t\t}\n\t\tmapper.addMapping(mapping);\n\t}", "code_tokens": ["protected", "void", "addDefaultMapping", "(", "DefaultMapper", "mapper", ",", "String", "parameter", ",", "Object", "model", ")", "{", "Expression", "source", "=", "new", "RequestParameterExpression", "(", "parameter", ")", ";", "ParserContext", "parserContext", "=", "new", "FluentParserContext", "(", ")", ".", "evaluate", "(", "model", ".", "getClass", "(", ")", ")", ";", "Expression", "target", "=", "expressionParser", ".", "parseExpression", "(", "parameter", ",", "parserContext", ")", ";", "DefaultMapping", "mapping", "=", "new", "DefaultMapping", "(", "source", ",", "target", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Adding default mapping for parameter '", "\"", "+", "parameter", "+", "\"", "'", "\"", ")", ";", "}", "mapper", ".", "addMapping", "(", "mapping", ")", ";", "}"], "idx": 1273, "cwe": "CWE-1188", "target": 1, "status": "VULNERABLE", "commit": "084b4", "function_name": "addDefaultMapping", "body_hash": "f0139c5d2ba8463a45e14907f916e76e3f9c03d8"}
{"code": "public void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n\n        // The MP4Parser library accepts either a File, or a byte array\n        // As MP4 video files are typically large, always use a file to\n        //  avoid OOMs that may occur with in-memory buffering\n        TemporaryResources tmp = new TemporaryResources();\n        TikaInputStream tstream = TikaInputStream.get(stream, tmp);\n\n        try (DataSource dataSource = new DirectFileReadDataSource(tstream.getFile())) {\n            try (IsoFile isoFile = new IsoFile(dataSource)) {\n                tmp.addResource(isoFile);\n\n                // Grab the file type box\n                FileTypeBox fileType = getOrNull(isoFile, FileTypeBox.class);\n                if (fileType != null) {\n                    // Identify the type\n                    MediaType type = MediaType.application(\"mp4\");\n                    for (Map.Entry<MediaType, List<String>> e : typesMap.entrySet()) {\n                        if (e.getValue().contains(fileType.getMajorBrand())) {\n                            type = e.getKey();\n                            break;\n                        }\n                    }\n                    metadata.set(Metadata.CONTENT_TYPE, type.toString());\n\n                    if (type.getType().equals(\"audio\")) {\n                        metadata.set(XMPDM.AUDIO_COMPRESSOR, fileType.getMajorBrand().trim());\n                    }\n                } else {\n                    // Some older QuickTime files lack the FileType\n                    metadata.set(Metadata.CONTENT_TYPE, \"video/quicktime\");\n                }\n\n\n                // Get the main MOOV box\n                MovieBox moov = getOrNull(isoFile, MovieBox.class);\n                if (moov == null) {\n                    // Bail out\n                    return;\n                }\n\n\n                XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n                xhtml.startDocument();\n\n\n                // Pull out some information from the header box\n                MovieHeaderBox mHeader = getOrNull(moov, MovieHeaderBox.class);\n                if (mHeader != null) {\n                    // Get the creation and modification dates\n                    metadata.set(Metadata.CREATION_DATE, mHeader.getCreationTime());\n                    metadata.set(TikaCoreProperties.MODIFIED, mHeader.getModificationTime());\n\n                    // Get the duration\n                    double durationSeconds = ((double) mHeader.getDuration()) / mHeader.getTimescale();\n                    metadata.set(XMPDM.DURATION, DURATION_FORMAT.format(durationSeconds));\n\n                    // The timescale is normally the sampling rate\n                    metadata.set(XMPDM.AUDIO_SAMPLE_RATE, (int) mHeader.getTimescale());\n                }\n\n\n                // Get some more information from the track header\n                // TODO Decide how to handle multiple tracks\n                List<TrackBox> tb = moov.getBoxes(TrackBox.class);\n                if (tb.size() > 0) {\n                    TrackBox track = tb.get(0);\n\n                    TrackHeaderBox header = track.getTrackHeaderBox();\n                    // Get the creation and modification dates\n                    metadata.set(TikaCoreProperties.CREATED, header.getCreationTime());\n                    metadata.set(TikaCoreProperties.MODIFIED, header.getModificationTime());\n\n                    // Get the video with and height\n                    metadata.set(Metadata.IMAGE_WIDTH, (int) header.getWidth());\n                    metadata.set(Metadata.IMAGE_LENGTH, (int) header.getHeight());\n\n                    // Get the sample information\n                    SampleTableBox samples = track.getSampleTableBox();\n                    if (samples !=  null) {\n                        SampleDescriptionBox sampleDesc = samples.getSampleDescriptionBox();\n                        if (sampleDesc != null) {\n                            // Look for the first Audio Sample, if present\n                            AudioSampleEntry sample = getOrNull(sampleDesc, AudioSampleEntry.class);\n                            if (sample != null) {\n                                XMPDM.ChannelTypePropertyConverter.convertAndSet(metadata, sample.getChannelCount());\n                                //metadata.set(XMPDM.AUDIO_SAMPLE_TYPE, sample.getSampleSize());    // TODO Num -> Type mapping\n                                metadata.set(XMPDM.AUDIO_SAMPLE_RATE, (int) sample.getSampleRate());\n                                //metadata.set(XMPDM.AUDIO_, sample.getSamplesPerPacket());\n                                //metadata.set(XMPDM.AUDIO_, sample.getBytesPerSample());\n                            }\n                        }\n                    }\n                }\n\n                // Get metadata from the User Data Box\n                UserDataBox userData = getOrNull(moov, UserDataBox.class);\n                if (userData != null) {\n                    extractGPS(userData, metadata);\n                    MetaBox meta = getOrNull(userData, MetaBox.class);\n\n                    // Check for iTunes Metadata\n                    // See http://atomicparsley.sourceforge.net/mpeg-4files.html and\n                    //  http://code.google.com/p/mp4v2/wiki/iTunesMetadata for more on these\n                    AppleItemListBox apple = getOrNull(meta, AppleItemListBox.class);\n                    if (apple != null) {\n                        // Title\n                        AppleNameBox title = getOrNull(apple, AppleNameBox.class);\n                        addMetadata(TikaCoreProperties.TITLE, metadata, title);\n\n                        // Artist\n                        AppleArtistBox artist = getOrNull(apple, AppleArtistBox.class);\n                        addMetadata(TikaCoreProperties.CREATOR, metadata, artist);\n                        addMetadata(XMPDM.ARTIST, metadata, artist);\n\n                        // Album Artist\n                        AppleArtist2Box artist2 = getOrNull(apple, AppleArtist2Box.class);\n                        addMetadata(XMPDM.ALBUM_ARTIST, metadata, artist2);\n\n                        // Album\n                        AppleAlbumBox album = getOrNull(apple, AppleAlbumBox.class);\n                        addMetadata(XMPDM.ALBUM, metadata, album);\n\n                        // Composer\n                        AppleTrackAuthorBox composer = getOrNull(apple, AppleTrackAuthorBox.class);\n                        addMetadata(XMPDM.COMPOSER, metadata, composer);\n\n                        // Genre\n                        AppleGenreBox genre = getOrNull(apple, AppleGenreBox.class);\n                        addMetadata(XMPDM.GENRE, metadata, genre);\n\n                        // Year\n                        AppleRecordingYear2Box year = getOrNull(apple, AppleRecordingYear2Box.class);\n                        if (year != null) {\n                            metadata.set(XMPDM.RELEASE_DATE, year.getValue());\n                        }\n\n                        // Track number\n                        AppleTrackNumberBox trackNum = getOrNull(apple, AppleTrackNumberBox.class);\n                        if (trackNum != null) {\n                            metadata.set(XMPDM.TRACK_NUMBER, trackNum.getA());\n                            //metadata.set(XMPDM.NUMBER_OF_TRACKS, trackNum.getB()); // TODO\n                        }\n\n                        // Disc number\n                        AppleDiskNumberBox discNum = getOrNull(apple, AppleDiskNumberBox.class);\n                        if (discNum != null) {\n                            metadata.set(XMPDM.DISC_NUMBER, discNum.getA());\n                        }\n\n                        // Compilation\n                        AppleCompilationBox compilation = getOrNull(apple, AppleCompilationBox.class);\n                        if (compilation != null) {\n                            metadata.set(XMPDM.COMPILATION, (int) compilation.getValue());\n                        }\n\n                        // Comment\n                        AppleCommentBox comment = getOrNull(apple, AppleCommentBox.class);\n                        addMetadata(XMPDM.LOG_COMMENT, metadata, comment);\n\n                        // Encoder\n                        AppleEncoderBox encoder = getOrNull(apple, AppleEncoderBox.class);\n                        if (encoder != null) {\n                            metadata.set(XMP.CREATOR_TOOL, encoder.getValue());\n                        }\n\n\n                        // As text\n                        for (Box box : apple.getBoxes()) {\n                            if (box instanceof Utf8AppleDataBox) {\n                                xhtml.element(\"p\", ((Utf8AppleDataBox) box).getValue());\n                            }\n                        }\n                    }\n\n                    // TODO Check for other kinds too\n                }\n\n\n                // All done\n                xhtml.endDocument();\n            }\n        } finally {\n            tmp.dispose();\n        }\n\n    }", "code_tokens": ["public", "void", "parse", "(", "InputStream", "stream", ",", "ContentHandler", "handler", ",", "Metadata", "metadata", ",", "ParseContext", "context", ")", "throws", "IOException", ",", "SAXException", ",", "TikaException", "{", "TemporaryResources", "tmp", "=", "new", "TemporaryResources", "(", ")", ";", "TikaInputStream", "tstream", "=", "TikaInputStream", ".", "get", "(", "stream", ",", "tmp", ")", ";", "try", "(", "DataSource", "dataSource", "=", "new", "DirectFileReadDataSource", "(", "tstream", ".", "getFile", "(", ")", ")", ")", "{", "try", "(", "IsoFile", "isoFile", "=", "new", "IsoFile", "(", "dataSource", ")", ")", "{", "tmp", ".", "addResource", "(", "isoFile", ")", ";", "FileTypeBox", "fileType", "=", "getOrNull", "(", "isoFile", ",", "FileTypeBox", ".", "class", ")", ";", "if", "(", "fileType", "!=", "null", ")", "{", "MediaType", "type", "=", "MediaType", ".", "application", "(", "\"", "mp4", "\"", ")", ";", "for", "(", "Map", ".", "Entry", "<", "MediaType", ",", "List", "<", "String", ">", ">", "e", ":", "typesMap", ".", "entrySet", "(", ")", ")", "{", "if", "(", "e", ".", "getValue", "(", ")", ".", "contains", "(", "fileType", ".", "getMajorBrand", "(", ")", ")", ")", "{", "type", "=", "e", ".", "getKey", "(", ")", ";", "break", ";", "}", "}", "metadata", ".", "set", "(", "Metadata", ".", "CONTENT_TYPE", ",", "type", ".", "toString", "(", ")", ")", ";", "if", "(", "type", ".", "getType", "(", ")", ".", "equals", "(", "\"", "audio", "\"", ")", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "AUDIO_COMPRESSOR", ",", "fileType", ".", "getMajorBrand", "(", ")", ".", "trim", "(", ")", ")", ";", "}", "}", "else", "{", "metadata", ".", "set", "(", "Metadata", ".", "CONTENT_TYPE", ",", "\"", "video/quicktime", "\"", ")", ";", "}", "MovieBox", "moov", "=", "getOrNull", "(", "isoFile", ",", "MovieBox", ".", "class", ")", ";", "if", "(", "moov", "==", "null", ")", "{", "return", ";", "}", "XHTMLContentHandler", "xhtml", "=", "new", "XHTMLContentHandler", "(", "handler", ",", "metadata", ")", ";", "xhtml", ".", "startDocument", "(", ")", ";", "MovieHeaderBox", "mHeader", "=", "getOrNull", "(", "moov", ",", "MovieHeaderBox", ".", "class", ")", ";", "if", "(", "mHeader", "!=", "null", ")", "{", "metadata", ".", "set", "(", "Metadata", ".", "CREATION_DATE", ",", "mHeader", ".", "getCreationTime", "(", ")", ")", ";", "metadata", ".", "set", "(", "TikaCoreProperties", ".", "MODIFIED", ",", "mHeader", ".", "getModificationTime", "(", ")", ")", ";", "double", "durationSeconds", "=", "(", "(", "double", ")", "mHeader", ".", "getDuration", "(", ")", ")", "/", "mHeader", ".", "getTimescale", "(", ")", ";", "metadata", ".", "set", "(", "XMPDM", ".", "DURATION", ",", "DURATION_FORMAT", ".", "format", "(", "durationSeconds", ")", ")", ";", "metadata", ".", "set", "(", "XMPDM", ".", "AUDIO_SAMPLE_RATE", ",", "(", "int", ")", "mHeader", ".", "getTimescale", "(", ")", ")", ";", "}", "List", "<", "TrackBox", ">", "tb", "=", "moov", ".", "getBoxes", "(", "TrackBox", ".", "class", ")", ";", "if", "(", "tb", ".", "size", "(", ")", ">", "0", ")", "{", "TrackBox", "track", "=", "tb", ".", "get", "(", "0", ")", ";", "TrackHeaderBox", "header", "=", "track", ".", "getTrackHeaderBox", "(", ")", ";", "metadata", ".", "set", "(", "TikaCoreProperties", ".", "CREATED", ",", "header", ".", "getCreationTime", "(", ")", ")", ";", "metadata", ".", "set", "(", "TikaCoreProperties", ".", "MODIFIED", ",", "header", ".", "getModificationTime", "(", ")", ")", ";", "metadata", ".", "set", "(", "Metadata", ".", "IMAGE_WIDTH", ",", "(", "int", ")", "header", ".", "getWidth", "(", ")", ")", ";", "metadata", ".", "set", "(", "Metadata", ".", "IMAGE_LENGTH", ",", "(", "int", ")", "header", ".", "getHeight", "(", ")", ")", ";", "SampleTableBox", "samples", "=", "track", ".", "getSampleTableBox", "(", ")", ";", "if", "(", "samples", "!=", "null", ")", "{", "SampleDescriptionBox", "sampleDesc", "=", "samples", ".", "getSampleDescriptionBox", "(", ")", ";", "if", "(", "sampleDesc", "!=", "null", ")", "{", "AudioSampleEntry", "sample", "=", "getOrNull", "(", "sampleDesc", ",", "AudioSampleEntry", ".", "class", ")", ";", "if", "(", "sample", "!=", "null", ")", "{", "XMPDM", ".", "ChannelTypePropertyConverter", ".", "convertAndSet", "(", "metadata", ",", "sample", ".", "getChannelCount", "(", ")", ")", ";", "metadata", ".", "set", "(", "XMPDM", ".", "AUDIO_SAMPLE_RATE", ",", "(", "int", ")", "sample", ".", "getSampleRate", "(", ")", ")", ";", "}", "}", "}", "}", "UserDataBox", "userData", "=", "getOrNull", "(", "moov", ",", "UserDataBox", ".", "class", ")", ";", "if", "(", "userData", "!=", "null", ")", "{", "extractGPS", "(", "userData", ",", "metadata", ")", ";", "MetaBox", "meta", "=", "getOrNull", "(", "userData", ",", "MetaBox", ".", "class", ")", ";", "AppleItemListBox", "apple", "=", "getOrNull", "(", "meta", ",", "AppleItemListBox", ".", "class", ")", ";", "if", "(", "apple", "!=", "null", ")", "{", "AppleNameBox", "title", "=", "getOrNull", "(", "apple", ",", "AppleNameBox", ".", "class", ")", ";", "addMetadata", "(", "TikaCoreProperties", ".", "TITLE", ",", "metadata", ",", "title", ")", ";", "AppleArtistBox", "artist", "=", "getOrNull", "(", "apple", ",", "AppleArtistBox", ".", "class", ")", ";", "addMetadata", "(", "TikaCoreProperties", ".", "CREATOR", ",", "metadata", ",", "artist", ")", ";", "addMetadata", "(", "XMPDM", ".", "ARTIST", ",", "metadata", ",", "artist", ")", ";", "AppleArtist2Box", "artist2", "=", "getOrNull", "(", "apple", ",", "AppleArtist2Box", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "ALBUM_ARTIST", ",", "metadata", ",", "artist2", ")", ";", "AppleAlbumBox", "album", "=", "getOrNull", "(", "apple", ",", "AppleAlbumBox", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "ALBUM", ",", "metadata", ",", "album", ")", ";", "AppleTrackAuthorBox", "composer", "=", "getOrNull", "(", "apple", ",", "AppleTrackAuthorBox", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "COMPOSER", ",", "metadata", ",", "composer", ")", ";", "AppleGenreBox", "genre", "=", "getOrNull", "(", "apple", ",", "AppleGenreBox", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "GENRE", ",", "metadata", ",", "genre", ")", ";", "AppleRecordingYear2Box", "year", "=", "getOrNull", "(", "apple", ",", "AppleRecordingYear2Box", ".", "class", ")", ";", "if", "(", "year", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "RELEASE_DATE", ",", "year", ".", "getValue", "(", ")", ")", ";", "}", "AppleTrackNumberBox", "trackNum", "=", "getOrNull", "(", "apple", ",", "AppleTrackNumberBox", ".", "class", ")", ";", "if", "(", "trackNum", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "TRACK_NUMBER", ",", "trackNum", ".", "getA", "(", ")", ")", ";", "}", "AppleDiskNumberBox", "discNum", "=", "getOrNull", "(", "apple", ",", "AppleDiskNumberBox", ".", "class", ")", ";", "if", "(", "discNum", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "DISC_NUMBER", ",", "discNum", ".", "getA", "(", ")", ")", ";", "}", "AppleCompilationBox", "compilation", "=", "getOrNull", "(", "apple", ",", "AppleCompilationBox", ".", "class", ")", ";", "if", "(", "compilation", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "COMPILATION", ",", "(", "int", ")", "compilation", ".", "getValue", "(", ")", ")", ";", "}", "AppleCommentBox", "comment", "=", "getOrNull", "(", "apple", ",", "AppleCommentBox", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "LOG_COMMENT", ",", "metadata", ",", "comment", ")", ";", "AppleEncoderBox", "encoder", "=", "getOrNull", "(", "apple", ",", "AppleEncoderBox", ".", "class", ")", ";", "if", "(", "encoder", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMP", ".", "CREATOR_TOOL", ",", "encoder", ".", "getValue", "(", ")", ")", ";", "}", "for", "(", "Box", "box", ":", "apple", ".", "getBoxes", "(", ")", ")", "{", "if", "(", "box", "instanceof", "Utf8AppleDataBox", ")", "{", "xhtml", ".", "element", "(", "\"", "p", "\"", ",", "(", "(", "Utf8AppleDataBox", ")", "box", ")", ".", "getValue", "(", ")", ")", ";", "}", "}", "}", "}", "xhtml", ".", "endDocument", "(", ")", ";", "}", "}", "finally", "{", "tmp", ".", "dispose", "(", ")", ";", "}", "}"], "idx": 83018, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "333d990", "function_name": "parse", "body_hash": "ebba3ad15ddeb80f4cafb689a1b02a6d6c6e644c"}
{"code": "private LikeCondition createLike(Type type, String toMatch) {\n\t\tif (notLike) {\n\t\t\treturn new NotLikeCondition(type, selector, toMatch);\n\t\t} else {\n\t\t\treturn new LikeCondition(type, selector, toMatch);\n\t\t}\n\t}", "code_tokens": ["private", "LikeCondition", "createLike", "(", "Type", "type", ",", "String", "toMatch", ")", "{", "if", "(", "notLike", ")", "{", "return", "new", "NotLikeCondition", "(", "type", ",", "selector", ",", "toMatch", ")", ";", "}", "else", "{", "return", "new", "LikeCondition", "(", "type", ",", "selector", ",", "toMatch", ")", ";", "}", "}"], "idx": 104986, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "3c20b874fba9cc2a78b9ace10208de1602b56c3f", "function_name": "createLike", "body_hash": "3f853370d603e1fd1c15e82bc82724a1aa67c415"}
{"code": "public void encode(FacesContext facesContext) throws IOException {\n        OutputStream outStream = facesContext.getExternalContext().getResponseOutputStream();\n        String expr = contentProducer.getExpressionString();\n\n        if (!Pattern.matches(PARENTHESES, expr)) { // method expression must not be executed\n            throw new IllegalArgumentException(\"Expression \\\"\" + expr + \"\\\" contains parentheses.\");\n        }\n\n        contentProducer.invoke(facesContext.getELContext(), new Object[] { outStream, userData });\n    }", "code_tokens": ["public", "void", "encode", "(", "FacesContext", "facesContext", ")", "throws", "IOException", "{", "OutputStream", "outStream", "=", "facesContext", ".", "getExternalContext", "(", ")", ".", "getResponseOutputStream", "(", ")", ";", "String", "expr", "=", "contentProducer", ".", "getExpressionString", "(", ")", ";", "if", "(", "!", "Pattern", ".", "matches", "(", "PARENTHESES", ",", "expr", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Expression ", "\\\"", "\"", "+", "expr", "+", "\"", "\\\"", " contains parentheses.", "\"", ")", ";", "}", "contentProducer", ".", "invoke", "(", "facesContext", ".", "getELContext", "(", ")", ",", "new", "Object", "[", "]", "{", "outStream", ",", "userData", "}", ")", ";", "}"], "idx": 94851, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "4c5ddae4d6ddcea591fa949762c1c79ac11cac99", "function_name": "encode", "body_hash": "b2b8a64a92c00210b5daa3a5706b1e7765c73de9"}
{"code": "public static RootPersistentEntity createAclEntity(String entityType, String uuid) {\n        if (CUBE_INSTANCE.equals(entityType)) {\n            CubeInstance cubeInstance = new CubeInstance();\n            cubeInstance.setUuid(uuid);\n\n            return cubeInstance;\n        }\n\n        if (DATA_MODEL_DESC.equals(entityType)) {\n            DataModelDesc modelInstance = new DataModelDesc();\n            modelInstance.setUuid(uuid);\n\n            return modelInstance;\n        }\n\n        if (JOB_INSTANCE.equals(entityType)) {\n            JobInstance jobInstance = new JobInstance();\n            jobInstance.setUuid(uuid);\n\n            return jobInstance;\n        }\n\n        if (PROJECT_INSTANCE.equals(entityType)) {\n            ProjectInstance projectInstance = new ProjectInstance();\n            projectInstance.setUuid(uuid);\n\n            return projectInstance;\n        }\n\n        throw new RuntimeException(\"Unsupported entity type!\");\n    }", "code_tokens": ["public", "static", "RootPersistentEntity", "createAclEntity", "(", "String", "entityType", ",", "String", "uuid", ")", "{", "if", "(", "CUBE_INSTANCE", ".", "equals", "(", "entityType", ")", ")", "{", "CubeInstance", "cubeInstance", "=", "new", "CubeInstance", "(", ")", ";", "cubeInstance", ".", "setUuid", "(", "uuid", ")", ";", "return", "cubeInstance", ";", "}", "if", "(", "DATA_MODEL_DESC", ".", "equals", "(", "entityType", ")", ")", "{", "DataModelDesc", "modelInstance", "=", "new", "DataModelDesc", "(", ")", ";", "modelInstance", ".", "setUuid", "(", "uuid", ")", ";", "return", "modelInstance", ";", "}", "if", "(", "JOB_INSTANCE", ".", "equals", "(", "entityType", ")", ")", "{", "JobInstance", "jobInstance", "=", "new", "JobInstance", "(", ")", ";", "jobInstance", ".", "setUuid", "(", "uuid", ")", ";", "return", "jobInstance", ";", "}", "if", "(", "PROJECT_INSTANCE", ".", "equals", "(", "entityType", ")", ")", "{", "ProjectInstance", "projectInstance", "=", "new", "ProjectInstance", "(", ")", ";", "projectInstance", ".", "setUuid", "(", "uuid", ")", ";", "return", "projectInstance", ";", "}", "throw", "new", "RuntimeException", "(", "\"", "Unsupported entity type!", "\"", ")", ";", "}"], "idx": 92491, "cwe": "CWE-89", "target": 1, "status": "VULNERABLE", "commit": "5fbb6c9c3780d7384c8f1dc378b96bb9c43cfdbe", "function_name": "createAclEntity", "body_hash": "636708831d24c2e7ff6776be2f0ad6d80a02b44b"}
{"code": "public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                //unreg(sk,attachment);//only do this if we do process send file on a separate thread\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n                \n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be unable to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n            }\n            return true;\n        }", "code_tokens": ["public", "boolean", "processSendfile", "(", "SelectionKey", "sk", ",", "KeyAttachment", "attachment", ",", "boolean", "reg", ",", "boolean", "event", ")", "{", "NioChannel", "sc", "=", "null", ";", "try", "{", "SendfileData", "sd", "=", "attachment", ".", "getSendfileData", "(", ")", ";", "if", "(", "sd", ".", "fchannel", "==", "null", ")", "{", "File", "f", "=", "new", "File", "(", "sd", ".", "fileName", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "sd", ".", "fchannel", "=", "new", "FileInputStream", "(", "f", ")", ".", "getChannel", "(", ")", ";", "}", "sc", "=", "attachment", ".", "getChannel", "(", ")", ";", "sc", ".", "setSendFile", "(", "true", ")", ";", "WritableByteChannel", "wc", "=", "(", "(", "sc", "instanceof", "SecureNioChannel", ")", "?", "sc", ":", "sc", ".", "getIOChannel", "(", ")", ")", ";", "if", "(", "sc", ".", "getOutboundRemaining", "(", ")", ">", "0", ")", "{", "if", "(", "sc", ".", "flushOutbound", "(", ")", ")", "{", "attachment", ".", "access", "(", ")", ";", "}", "}", "else", "{", "long", "written", "=", "sd", ".", "fchannel", ".", "transferTo", "(", "sd", ".", "pos", ",", "sd", ".", "length", ",", "wc", ")", ";", "if", "(", "written", ">", "0", ")", "{", "sd", ".", "pos", "+=", "written", ";", "sd", ".", "length", "-=", "written", ";", "attachment", ".", "access", "(", ")", ";", "}", "else", "{", "if", "(", "sd", ".", "fchannel", ".", "size", "(", ")", "<=", "sd", ".", "pos", ")", "{", "throw", "new", "IOException", "(", "\"", "Sendfile configured to ", "\"", "+", "\"", "send more data than was available", "\"", ")", ";", "}", "}", "}", "if", "(", "sd", ".", "length", "<=", "0", "&&", "sc", ".", "getOutboundRemaining", "(", ")", "<=", "0", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file complete for:", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "attachment", ".", "setSendfileData", "(", "null", ")", ";", "try", "{", "sd", ".", "fchannel", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "}", "if", "(", "sd", ".", "keepAlive", ")", "{", "if", "(", "reg", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection is keep alive, registering back for OP_READ", "\"", ")", ";", "}", "if", "(", "event", ")", "{", "this", ".", "add", "(", "attachment", ".", "getChannel", "(", ")", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "}", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file connection is being closed", "\"", ")", ";", "}", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "STOP", ",", "false", ")", ";", "}", "}", "else", "if", "(", "attachment", ".", "interestOps", "(", ")", "==", "0", "&&", "reg", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "OP_WRITE for sendilfe:", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "event", ")", "{", "add", "(", "attachment", ".", "getChannel", "(", ")", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "}", "}", "catch", "(", "IOException", "x", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Unable to complete sendfile request:", "\"", ",", "x", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"", "\"", ",", "t", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "finally", "{", "if", "(", "sc", "!=", "null", ")", "sc", ".", "setSendFile", "(", "false", ")", ";", "}", "return", "true", ";", "}"], "idx": 9131, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "ff8789737a0a64c12d68929497f16d8021052048", "function_name": "processSendfile", "body_hash": "8c0f2aedf1231acae0379f99da7b3284e488752f"}
{"code": "@Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n    }", "code_tokens": ["@", "Override", "public", "String", "encodeForJSString", "(", "String", "source", ")", "{", "return", "source", "==", "null", "?", "null", ":", "Encode", ".", "forJavaScript", "(", "source", ")", ".", "replace", "(", "\"", "\\\\", "-", "\"", ",", "\"", "\\\\", "u002D", "\"", ")", ";", "}"], "idx": 77620, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "7d2365a248943071a44d8495655186e4f14ea294", "function_name": "encodeForJSString", "body_hash": "6bdd06bfc9d6aa2d16934c94ff99424d1a82fdd3"}
{"code": "protected Response handleLoginResponse(String samlResponse, SAMLDocumentHolder holder, ResponseType responseType, String relayState, String clientId) {\n\n            try {\n                KeyManager.ActiveRsaKey keys = session.keys().getActiveRsaKey(realm);\n                if (! isSuccessfulSamlResponse(responseType)) {\n                    String statusMessage = responseType.getStatus() == null ? Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR : responseType.getStatus().getStatusMessage();\n                    return callback.error(relayState, statusMessage);\n                }\n                if (responseType.getAssertions() == null || responseType.getAssertions().isEmpty()) {\n                    return callback.error(relayState, Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);\n                }\n\n                boolean assertionIsEncrypted = AssertionUtil.isAssertionEncrypted(responseType);\n\n                if (config.isWantAssertionsEncrypted() && !assertionIsEncrypted) {\n                    logger.error(\"The assertion is not encrypted, which is required.\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                Element assertionElement;\n\n                if (assertionIsEncrypted) {\n                    // This methods writes the parsed and decrypted assertion back on the responseType parameter:\n                    assertionElement = AssertionUtil.decryptAssertion(holder, responseType, keys.getPrivateKey());\n                } else {\n                    /* We verify the assertion using original document to handle cases where the IdP\n                    includes whitespace and/or newlines inside tags. */\n                    assertionElement = DocumentUtil.getElement(holder.getSamlDocument(), new QName(JBossSAMLConstants.ASSERTION.get()));\n                }\n\n                boolean signed = AssertionUtil.isSignedElement(assertionElement);\n                if ((config.isWantAssertionsSigned() && !signed)\n                        || (signed && config.isValidateSignature() && !AssertionUtil.isSignatureValid(assertionElement, getIDPKeyLocator()))) {\n                    logger.error(\"validation failed\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SIGNATURE);\n                    return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                AssertionType assertion = responseType.getAssertions().get(0).getAssertion();\n\n                SubjectType subject = assertion.getSubject();\n                SubjectType.STSubType subType = subject.getSubType();\n                NameIDType subjectNameID = (NameIDType) subType.getBaseID();\n                //Map<String, String> notes = new HashMap<>();\n                BrokeredIdentityContext identity = new BrokeredIdentityContext(subjectNameID.getValue());\n                identity.getContextData().put(SAML_LOGIN_RESPONSE, responseType);\n                identity.getContextData().put(SAML_ASSERTION, assertion);\n                if (clientId != null && ! clientId.trim().isEmpty()) {\n                    identity.getContextData().put(SAML_IDP_INITIATED_CLIENT_ID, clientId);\n                }\n\n                identity.setUsername(subjectNameID.getValue());\n\n                //SAML Spec 2.2.2 Format is optional\n                if (subjectNameID.getFormat() != null && subjectNameID.getFormat().toString().equals(JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get())) {\n                    identity.setEmail(subjectNameID.getValue());\n                }\n\n                if (config.isStoreToken()) {\n                    identity.setToken(samlResponse);\n                }\n\n                ConditionsValidator.Builder cvb = new ConditionsValidator.Builder(assertion.getID(), assertion.getConditions(), destinationValidator);\n                try {\n                    String issuerURL = getEntityId(session.getContext().getUri(), realm);\n                    cvb.addAllowedAudience(URI.create(issuerURL));\n                    // getDestination has been validated to match request URL already so it matches SAML endpoint\n                    cvb.addAllowedAudience(URI.create(responseType.getDestination()));\n                } catch (IllegalArgumentException ex) {\n                    // warning has been already emitted in DeploymentBuilder\n                }\n                if (! cvb.build().isValid()) {\n                    logger.error(\"Assertion expired.\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.EXPIRED_CODE);\n                }\n\n                AuthnStatementType authn = null;\n                for (Object statement : assertion.getStatements()) {\n                    if (statement instanceof AuthnStatementType) {\n                        authn = (AuthnStatementType)statement;\n                        identity.getContextData().put(SAML_AUTHN_STATEMENT, authn);\n                        break;\n                    }\n                }\n                if (assertion.getAttributeStatements() != null ) {\n                    for (AttributeStatementType attrStatement : assertion.getAttributeStatements()) {\n                        for (AttributeStatementType.ASTChoiceType choice : attrStatement.getAttributes()) {\n                            AttributeType attribute = choice.getAttribute();\n                            if (X500SAMLProfileConstants.EMAIL.getFriendlyName().equals(attribute.getFriendlyName())\n                                    || X500SAMLProfileConstants.EMAIL.get().equals(attribute.getName())) {\n                                if (!attribute.getAttributeValue().isEmpty()) identity.setEmail(attribute.getAttributeValue().get(0).toString());\n                            }\n                        }\n\n                    }\n\n                }\n                String brokerUserId = config.getAlias() + \".\" + subjectNameID.getValue();\n                identity.setBrokerUserId(brokerUserId);\n                identity.setIdpConfig(config);\n                identity.setIdp(provider);\n                if (authn != null && authn.getSessionIndex() != null) {\n                    identity.setBrokerSessionId(identity.getBrokerUserId() + \".\" + authn.getSessionIndex());\n                 }\n                identity.setCode(relayState);\n\n\n                return callback.authenticated(identity);\n            } catch (WebApplicationException e) {\n                return e.getResponse();\n            } catch (Exception e) {\n                throw new IdentityBrokerException(\"Could not process response from SAML identity provider.\", e);\n            }\n        }", "code_tokens": ["protected", "Response", "handleLoginResponse", "(", "String", "samlResponse", ",", "SAMLDocumentHolder", "holder", ",", "ResponseType", "responseType", ",", "String", "relayState", ",", "String", "clientId", ")", "{", "try", "{", "KeyManager", ".", "ActiveRsaKey", "keys", "=", "session", ".", "keys", "(", ")", ".", "getActiveRsaKey", "(", "realm", ")", ";", "if", "(", "!", "isSuccessfulSamlResponse", "(", "responseType", ")", ")", "{", "String", "statusMessage", "=", "responseType", ".", "getStatus", "(", ")", "==", "null", "?", "Messages", ".", "IDENTITY_PROVIDER_UNEXPECTED_ERROR", ":", "responseType", ".", "getStatus", "(", ")", ".", "getStatusMessage", "(", ")", ";", "return", "callback", ".", "error", "(", "relayState", ",", "statusMessage", ")", ";", "}", "if", "(", "responseType", ".", "getAssertions", "(", ")", "==", "null", "||", "responseType", ".", "getAssertions", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "return", "callback", ".", "error", "(", "relayState", ",", "Messages", ".", "IDENTITY_PROVIDER_UNEXPECTED_ERROR", ")", ";", "}", "boolean", "assertionIsEncrypted", "=", "AssertionUtil", ".", "isAssertionEncrypted", "(", "responseType", ")", ";", "if", "(", "config", ".", "isWantAssertionsEncrypted", "(", ")", "&&", "!", "assertionIsEncrypted", ")", "{", "logger", ".", "error", "(", "\"", "The assertion is not encrypted, which is required.", "\"", ")", ";", "event", ".", "event", "(", "EventType", ".", "IDENTITY_PROVIDER_RESPONSE", ")", ";", "event", ".", "error", "(", "Errors", ".", "INVALID_SAML_RESPONSE", ")", ";", "return", "ErrorPage", ".", "error", "(", "session", ",", "null", ",", "Response", ".", "Status", ".", "BAD_REQUEST", ",", "Messages", ".", "INVALID_REQUESTER", ")", ";", "}", "Element", "assertionElement", ";", "if", "(", "assertionIsEncrypted", ")", "{", "assertionElement", "=", "AssertionUtil", ".", "decryptAssertion", "(", "holder", ",", "responseType", ",", "keys", ".", "getPrivateKey", "(", ")", ")", ";", "}", "else", "{", "assertionElement", "=", "DocumentUtil", ".", "getElement", "(", "holder", ".", "getSamlDocument", "(", ")", ",", "new", "QName", "(", "JBossSAMLConstants", ".", "ASSERTION", ".", "get", "(", ")", ")", ")", ";", "}", "boolean", "signed", "=", "AssertionUtil", ".", "isSignedElement", "(", "assertionElement", ")", ";", "if", "(", "(", "config", ".", "isWantAssertionsSigned", "(", ")", "&&", "!", "signed", ")", "||", "(", "signed", "&&", "config", ".", "isValidateSignature", "(", ")", "&&", "!", "AssertionUtil", ".", "isSignatureValid", "(", "assertionElement", ",", "getIDPKeyLocator", "(", ")", ")", ")", ")", "{", "logger", ".", "error", "(", "\"", "validation failed", "\"", ")", ";", "event", ".", "event", "(", "EventType", ".", "IDENTITY_PROVIDER_RESPONSE", ")", ";", "event", ".", "error", "(", "Errors", ".", "INVALID_SIGNATURE", ")", ";", "return", "ErrorPage", ".", "error", "(", "session", ",", "null", ",", "Response", ".", "Status", ".", "BAD_REQUEST", ",", "Messages", ".", "INVALID_REQUESTER", ")", ";", "}", "AssertionType", "assertion", "=", "responseType", ".", "getAssertions", "(", ")", ".", "get", "(", "0", ")", ".", "getAssertion", "(", ")", ";", "SubjectType", "subject", "=", "assertion", ".", "getSubject", "(", ")", ";", "SubjectType", ".", "STSubType", "subType", "=", "subject", ".", "getSubType", "(", ")", ";", "NameIDType", "subjectNameID", "=", "(", "NameIDType", ")", "subType", ".", "getBaseID", "(", ")", ";", "BrokeredIdentityContext", "identity", "=", "new", "BrokeredIdentityContext", "(", "subjectNameID", ".", "getValue", "(", ")", ")", ";", "identity", ".", "getContextData", "(", ")", ".", "put", "(", "SAML_LOGIN_RESPONSE", ",", "responseType", ")", ";", "identity", ".", "getContextData", "(", ")", ".", "put", "(", "SAML_ASSERTION", ",", "assertion", ")", ";", "if", "(", "clientId", "!=", "null", "&&", "!", "clientId", ".", "trim", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "identity", ".", "getContextData", "(", ")", ".", "put", "(", "SAML_IDP_INITIATED_CLIENT_ID", ",", "clientId", ")", ";", "}", "identity", ".", "setUsername", "(", "subjectNameID", ".", "getValue", "(", ")", ")", ";", "if", "(", "subjectNameID", ".", "getFormat", "(", ")", "!=", "null", "&&", "subjectNameID", ".", "getFormat", "(", ")", ".", "toString", "(", ")", ".", "equals", "(", "JBossSAMLURIConstants", ".", "NAMEID_FORMAT_EMAIL", ".", "get", "(", ")", ")", ")", "{", "identity", ".", "setEmail", "(", "subjectNameID", ".", "getValue", "(", ")", ")", ";", "}", "if", "(", "config", ".", "isStoreToken", "(", ")", ")", "{", "identity", ".", "setToken", "(", "samlResponse", ")", ";", "}", "ConditionsValidator", ".", "Builder", "cvb", "=", "new", "ConditionsValidator", ".", "Builder", "(", "assertion", ".", "getID", "(", ")", ",", "assertion", ".", "getConditions", "(", ")", ",", "destinationValidator", ")", ";", "try", "{", "String", "issuerURL", "=", "getEntityId", "(", "session", ".", "getContext", "(", ")", ".", "getUri", "(", ")", ",", "realm", ")", ";", "cvb", ".", "addAllowedAudience", "(", "URI", ".", "create", "(", "issuerURL", ")", ")", ";", "cvb", ".", "addAllowedAudience", "(", "URI", ".", "create", "(", "responseType", ".", "getDestination", "(", ")", ")", ")", ";", "}", "catch", "(", "IllegalArgumentException", "ex", ")", "{", "}", "if", "(", "!", "cvb", ".", "build", "(", ")", ".", "isValid", "(", ")", ")", "{", "logger", ".", "error", "(", "\"", "Assertion expired.", "\"", ")", ";", "event", ".", "event", "(", "EventType", ".", "IDENTITY_PROVIDER_RESPONSE", ")", ";", "event", ".", "error", "(", "Errors", ".", "INVALID_SAML_RESPONSE", ")", ";", "return", "ErrorPage", ".", "error", "(", "session", ",", "null", ",", "Response", ".", "Status", ".", "BAD_REQUEST", ",", "Messages", ".", "EXPIRED_CODE", ")", ";", "}", "AuthnStatementType", "authn", "=", "null", ";", "for", "(", "Object", "statement", ":", "assertion", ".", "getStatements", "(", ")", ")", "{", "if", "(", "statement", "instanceof", "AuthnStatementType", ")", "{", "authn", "=", "(", "AuthnStatementType", ")", "statement", ";", "identity", ".", "getContextData", "(", ")", ".", "put", "(", "SAML_AUTHN_STATEMENT", ",", "authn", ")", ";", "break", ";", "}", "}", "if", "(", "assertion", ".", "getAttributeStatements", "(", ")", "!=", "null", ")", "{", "for", "(", "AttributeStatementType", "attrStatement", ":", "assertion", ".", "getAttributeStatements", "(", ")", ")", "{", "for", "(", "AttributeStatementType", ".", "ASTChoiceType", "choice", ":", "attrStatement", ".", "getAttributes", "(", ")", ")", "{", "AttributeType", "attribute", "=", "choice", ".", "getAttribute", "(", ")", ";", "if", "(", "X500SAMLProfileConstants", ".", "EMAIL", ".", "getFriendlyName", "(", ")", ".", "equals", "(", "attribute", ".", "getFriendlyName", "(", ")", ")", "||", "X500SAMLProfileConstants", ".", "EMAIL", ".", "get", "(", ")", ".", "equals", "(", "attribute", ".", "getName", "(", ")", ")", ")", "{", "if", "(", "!", "attribute", ".", "getAttributeValue", "(", ")", ".", "isEmpty", "(", ")", ")", "identity", ".", "setEmail", "(", "attribute", ".", "getAttributeValue", "(", ")", ".", "get", "(", "0", ")", ".", "toString", "(", ")", ")", ";", "}", "}", "}", "}", "String", "brokerUserId", "=", "config", ".", "getAlias", "(", ")", "+", "\"", ".", "\"", "+", "subjectNameID", ".", "getValue", "(", ")", ";", "identity", ".", "setBrokerUserId", "(", "brokerUserId", ")", ";", "identity", ".", "setIdpConfig", "(", "config", ")", ";", "identity", ".", "setIdp", "(", "provider", ")", ";", "if", "(", "authn", "!=", "null", "&&", "authn", ".", "getSessionIndex", "(", ")", "!=", "null", ")", "{", "identity", ".", "setBrokerSessionId", "(", "identity", ".", "getBrokerUserId", "(", ")", "+", "\"", ".", "\"", "+", "authn", ".", "getSessionIndex", "(", ")", ")", ";", "}", "identity", ".", "setCode", "(", "relayState", ")", ";", "return", "callback", ".", "authenticated", "(", "identity", ")", ";", "}", "catch", "(", "WebApplicationException", "e", ")", "{", "return", "e", ".", "getResponse", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "IdentityBrokerException", "(", "\"", "Could not process response from SAML identity provider.", "\"", ",", "e", ")", ";", "}", "}"], "idx": 39205, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "0fe0b875d63cce3d2855d85d25bb8757bce13eb1", "function_name": "handleLoginResponse", "body_hash": "95a4693c6d6165204827b4eaced9d70a5e2e995e"}
{"code": "public SendfileState processSendfile(SelectionKey sk, NioSocketWrapper socketWrapper,\n                boolean calledByProcessor) {\n            NioChannel sc = null;\n            try {\n                unreg(sk, socketWrapper, sk.readyOps());\n                SendfileData sd = socketWrapper.getSendfileData();\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing send file for: \" + sd.fileName);\n                }\n\n                if (sd.fchannel == null) {\n                    // Setup the file channel\n                    File f = new File(sd.fileName);\n                    if (!f.exists()) {\n                        cancelledKey(sk);\n                        return SendfileState.ERROR;\n                    }\n                    @SuppressWarnings(\"resource\") // Closed when channel is closed\n                    FileInputStream fis = new FileInputStream(f);\n                    sd.fchannel = fis.getChannel();\n                }\n\n                // Configure output channel\n                sc = socketWrapper.getSocket();\n                // TLS/SSL channel is slightly different\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n\n                // We still have data in the buffer\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        socketWrapper.updateLastWrite();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if (written > 0) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        socketWrapper.updateLastWrite();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for: \"+sd.fileName);\n                    }\n                    socketWrapper.setSendfileData(null);\n                    try {\n                        sd.fchannel.close();\n                    } catch (Exception ignore) {\n                    }\n                    // For calls from outside the Poller, the caller is\n                    // responsible for registering the socket for the\n                    // appropriate event(s) if sendfile completes.\n                    if (!calledByProcessor) {\n                        if (sd.keepAlive) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            reg(sk,socketWrapper,SelectionKey.OP_READ);\n                        } else {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Send file connection is being closed\");\n                            }\n                            close(sc, sk);\n                        }\n                    }\n                    return SendfileState.DONE;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                    }\n                    if (calledByProcessor) {\n                        add(socketWrapper.getSocket(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,socketWrapper,SelectionKey.OP_WRITE);\n                    }\n                    return SendfileState.PENDING;\n                }\n            } catch (IOException x) {\n                if (log.isDebugEnabled()) log.debug(\"Unable to complete sendfile request:\", x);\n                if (!calledByProcessor && sc != null) {\n                    close(sc, sk);\n                } else {\n                    cancelledKey(sk);\n                }\n                return SendfileState.ERROR;\n            } catch (Throwable t) {\n                log.error(\"\", t);\n                if (!calledByProcessor && sc != null) {\n                    close(sc, sk);\n                } else {\n                    cancelledKey(sk);\n                }\n                return SendfileState.ERROR;\n            }\n        }", "code_tokens": ["public", "SendfileState", "processSendfile", "(", "SelectionKey", "sk", ",", "NioSocketWrapper", "socketWrapper", ",", "boolean", "calledByProcessor", ")", "{", "NioChannel", "sc", "=", "null", ";", "try", "{", "unreg", "(", "sk", ",", "socketWrapper", ",", "sk", ".", "readyOps", "(", ")", ")", ";", "SendfileData", "sd", "=", "socketWrapper", ".", "getSendfileData", "(", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Processing send file for: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "sd", ".", "fchannel", "==", "null", ")", "{", "File", "f", "=", "new", "File", "(", "sd", ".", "fileName", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "cancelledKey", "(", "sk", ")", ";", "return", "SendfileState", ".", "ERROR", ";", "}", "@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "FileInputStream", "fis", "=", "new", "FileInputStream", "(", "f", ")", ";", "sd", ".", "fchannel", "=", "fis", ".", "getChannel", "(", ")", ";", "}", "sc", "=", "socketWrapper", ".", "getSocket", "(", ")", ";", "WritableByteChannel", "wc", "=", "(", "(", "sc", "instanceof", "SecureNioChannel", ")", "?", "sc", ":", "sc", ".", "getIOChannel", "(", ")", ")", ";", "if", "(", "sc", ".", "getOutboundRemaining", "(", ")", ">", "0", ")", "{", "if", "(", "sc", ".", "flushOutbound", "(", ")", ")", "{", "socketWrapper", ".", "updateLastWrite", "(", ")", ";", "}", "}", "else", "{", "long", "written", "=", "sd", ".", "fchannel", ".", "transferTo", "(", "sd", ".", "pos", ",", "sd", ".", "length", ",", "wc", ")", ";", "if", "(", "written", ">", "0", ")", "{", "sd", ".", "pos", "+=", "written", ";", "sd", ".", "length", "-=", "written", ";", "socketWrapper", ".", "updateLastWrite", "(", ")", ";", "}", "else", "{", "if", "(", "sd", ".", "fchannel", ".", "size", "(", ")", "<=", "sd", ".", "pos", ")", "{", "throw", "new", "IOException", "(", "\"", "Sendfile configured to ", "\"", "+", "\"", "send more data than was available", "\"", ")", ";", "}", "}", "}", "if", "(", "sd", ".", "length", "<=", "0", "&&", "sc", ".", "getOutboundRemaining", "(", ")", "<=", "0", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file complete for: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "socketWrapper", ".", "setSendfileData", "(", "null", ")", ";", "try", "{", "sd", ".", "fchannel", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "}", "if", "(", "!", "calledByProcessor", ")", "{", "if", "(", "sd", ".", "keepAlive", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection is keep alive, registering back for OP_READ", "\"", ")", ";", "}", "reg", "(", "sk", ",", "socketWrapper", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file connection is being closed", "\"", ")", ";", "}", "close", "(", "sc", ",", "sk", ")", ";", "}", "}", "return", "SendfileState", ".", "DONE", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "OP_WRITE for sendfile: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "calledByProcessor", ")", "{", "add", "(", "socketWrapper", ".", "getSocket", "(", ")", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "socketWrapper", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "return", "SendfileState", ".", "PENDING", ";", "}", "}", "catch", "(", "IOException", "x", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Unable to complete sendfile request:", "\"", ",", "x", ")", ";", "if", "(", "!", "calledByProcessor", "&&", "sc", "!=", "null", ")", "{", "close", "(", "sc", ",", "sk", ")", ";", "}", "else", "{", "cancelledKey", "(", "sk", ")", ";", "}", "return", "SendfileState", ".", "ERROR", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"", "\"", ",", "t", ")", ";", "if", "(", "!", "calledByProcessor", "&&", "sc", "!=", "null", ")", "{", "close", "(", "sc", ",", "sk", ")", ";", "}", "else", "{", "cancelledKey", "(", "sk", ")", ";", "}", "return", "SendfileState", ".", "ERROR", ";", "}", "}"], "idx": 50790, "cwe": "CWE-388", "target": 1, "status": "VULNERABLE", "commit": "cbc9b18a845d3c8c053ac293dffda6c6c19dd92b", "function_name": "processSendfile", "body_hash": "2921b2fe74ee18cd2d530548641e403def105273"}
{"code": "protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {\n      boolean isValid = false;\n\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Binding the user.\");\n      }\n      context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);\n      context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n      try {\n         context.getAttributes(\"\", null);\n         isValid = true;\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"User \" + dn + \" successfully bound.\");\n         }\n      } catch (AuthenticationException e) {\n         isValid = false;\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Authentication failed for dn=\" + dn);\n         }\n      }\n\n      if (isLoginPropertySet(CONNECTION_USERNAME)) {\n         context.addToEnvironment(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));\n      } else {\n         context.removeFromEnvironment(Context.SECURITY_PRINCIPAL);\n      }\n      if (isLoginPropertySet(CONNECTION_PASSWORD)) {\n         context.addToEnvironment(Context.SECURITY_CREDENTIALS, getPlainPassword(getLDAPPropertyValue(CONNECTION_PASSWORD)));\n      } else {\n         context.removeFromEnvironment(Context.SECURITY_CREDENTIALS);\n      }\n\n      return isValid;\n   }", "code_tokens": ["protected", "boolean", "bindUser", "(", "DirContext", "context", ",", "String", "dn", ",", "String", "password", ")", "throws", "NamingException", "{", "boolean", "isValid", "=", "false", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Binding the user.", "\"", ")", ";", "}", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "dn", ")", ";", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "password", ")", ";", "try", "{", "context", ".", "getAttributes", "(", "\"", "\"", ",", "null", ")", ";", "isValid", "=", "true", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "User ", "\"", "+", "dn", "+", "\"", " successfully bound.", "\"", ")", ";", "}", "}", "catch", "(", "AuthenticationException", "e", ")", "{", "isValid", "=", "false", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Authentication failed for dn=", "\"", "+", "dn", ")", ";", "}", "}", "if", "(", "isLoginPropertySet", "(", "CONNECTION_USERNAME", ")", ")", "{", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "getLDAPPropertyValue", "(", "CONNECTION_USERNAME", ")", ")", ";", "}", "else", "{", "context", ".", "removeFromEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ")", ";", "}", "if", "(", "isLoginPropertySet", "(", "CONNECTION_PASSWORD", ")", ")", "{", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "getPlainPassword", "(", "getLDAPPropertyValue", "(", "CONNECTION_PASSWORD", ")", ")", ")", ";", "}", "else", "{", "context", ".", "removeFromEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ")", ";", "}", "return", "isValid", ";", "}"], "idx": 38280, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "ec1c5a96c7", "function_name": "bindUser", "body_hash": "485f613fedd42ba25d7c2dc91f41a70e5af1a02e"}
{"code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }  \n        if (!Boolean.parseBoolean(camelContext.getProperty(ACCESS_EXTERNAL_DTD))) {\n            try {\n                factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            } catch (SAXException e) {\n                LOG.error(e.getMessage(), e);\n                throw new IllegalStateException(e);\n            } \n        }\n        return factory;\n    }", "code_tokens": ["protected", "SchemaFactory", "createSchemaFactory", "(", ")", "{", "SchemaFactory", "factory", "=", "SchemaFactory", ".", "newInstance", "(", "schemaLanguage", ")", ";", "if", "(", "getResourceResolver", "(", ")", "!=", "null", ")", "{", "factory", ".", "setResourceResolver", "(", "getResourceResolver", "(", ")", ")", ";", "}", "if", "(", "!", "Boolean", ".", "parseBoolean", "(", "camelContext", ".", "getProperty", "(", "ACCESS_EXTERNAL_DTD", ")", ")", ")", "{", "try", "{", "factory", ".", "setProperty", "(", "XMLConstants", ".", "ACCESS_EXTERNAL_DTD", ",", "\"", "\"", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "LOG", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}", "return", "factory", ";", "}"], "idx": 66863, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "22c355bb4ffb500405499d189db30932ca5aac9", "function_name": "createSchemaFactory", "body_hash": "f324d45c7b4bf7b8f9cdbfc0dd67e5848de6c286"}
{"code": "protected void setUpSSL() throws Exception {\n\t\tif (this.sslPropertiesLocation == null && this.keyStore == null && this.trustStore == null\n\t\t\t\t&& this.keyStoreResource == null && this.trustStoreResource == null) {\n\t\t\tif (this.skipServerCertificateValidation) {\n\t\t\t\tif (this.sslAlgorithmSet) {\n\t\t\t\t\tthis.connectionFactory.useSslProtocol(this.sslAlgorithm);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.connectionFactory.useSslProtocol();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuseDefaultTrustStoreMechanism();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this.sslPropertiesLocation != null) {\n\t\t\t\tthis.sslProperties.load(this.sslPropertiesLocation.getInputStream());\n\t\t\t}\n\t\t\tPathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n\t\t\tString keyStoreName = getKeyStore();\n\t\t\tString trustStoreName = getTrustStore();\n\t\t\tString keyStorePassword = getKeyStorePassphrase();\n\t\t\tString trustStorePassword = getTrustStorePassphrase();\n\t\t\tString keyStoreType = getKeyStoreType();\n\t\t\tString trustStoreType = getTrustStoreType();\n\t\t\tchar[] keyPassphrase = null;\n\t\t\tif (keyStorePassword != null) {\n\t\t\t\tkeyPassphrase = keyStorePassword.toCharArray();\n\t\t\t}\n\t\t\tchar[] trustPassphrase = null;\n\t\t\tif (trustStorePassword != null) {\n\t\t\t\ttrustPassphrase = trustStorePassword.toCharArray();\n\t\t\t}\n\t\t\tKeyManager[] keyManagers = null;\n\t\t\tTrustManager[] trustManagers = null;\n\t\t\tif (StringUtils.hasText(keyStoreName) || this.keyStoreResource != null) {\n\t\t\t\tResource keyStoreResource = this.keyStoreResource != null ? this.keyStoreResource\n\t\t\t\t\t\t: resolver.getResource(keyStoreName);\n\t\t\t\tKeyStore ks = KeyStore.getInstance(keyStoreType);\n\t\t\t\tks.load(keyStoreResource.getInputStream(), keyPassphrase);\n\t\t\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n\t\t\t\tkmf.init(ks, keyPassphrase);\n\t\t\t\tkeyManagers = kmf.getKeyManagers();\n\t\t\t}\n\t\t\tif (StringUtils.hasText(trustStoreName) || this.trustStoreResource != null) {\n\t\t\t\tResource trustStoreResource = this.trustStoreResource != null ? this.trustStoreResource\n\t\t\t\t\t\t: resolver.getResource(trustStoreName);\n\t\t\t\tKeyStore tks = KeyStore.getInstance(trustStoreType);\n\t\t\t\ttks.load(trustStoreResource.getInputStream(), trustPassphrase);\n\t\t\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n\t\t\t\ttmf.init(tks);\n\t\t\t\ttrustManagers = tmf.getTrustManagers();\n\t\t\t}\n\n\t\t\tif (this.logger.isDebugEnabled()) {\n\t\t\t\tthis.logger.debug(\"Initializing SSLContext with KM: \"\n\t\t\t\t\t\t+ Arrays.toString(keyManagers)\n\t\t\t\t\t\t+ \", TM: \" + Arrays.toString(trustManagers)\n\t\t\t\t\t\t+ \", random: \" + this.secureRandom);\n\t\t\t}\n\t\t\tSSLContext context = createSSLContext();\n\t\t\tcontext.init(keyManagers, trustManagers, this.secureRandom);\n\t\t\tthis.connectionFactory.useSslProtocol(context);\n\t\t}\n\t}", "code_tokens": ["protected", "void", "setUpSSL", "(", ")", "throws", "Exception", "{", "if", "(", "this", ".", "sslPropertiesLocation", "==", "null", "&&", "this", ".", "keyStore", "==", "null", "&&", "this", ".", "trustStore", "==", "null", "&&", "this", ".", "keyStoreResource", "==", "null", "&&", "this", ".", "trustStoreResource", "==", "null", ")", "{", "if", "(", "this", ".", "skipServerCertificateValidation", ")", "{", "if", "(", "this", ".", "sslAlgorithmSet", ")", "{", "this", ".", "connectionFactory", ".", "useSslProtocol", "(", "this", ".", "sslAlgorithm", ")", ";", "}", "else", "{", "this", ".", "connectionFactory", ".", "useSslProtocol", "(", ")", ";", "}", "}", "else", "{", "useDefaultTrustStoreMechanism", "(", ")", ";", "}", "}", "else", "{", "if", "(", "this", ".", "sslPropertiesLocation", "!=", "null", ")", "{", "this", ".", "sslProperties", ".", "load", "(", "this", ".", "sslPropertiesLocation", ".", "getInputStream", "(", ")", ")", ";", "}", "PathMatchingResourcePatternResolver", "resolver", "=", "new", "PathMatchingResourcePatternResolver", "(", ")", ";", "String", "keyStoreName", "=", "getKeyStore", "(", ")", ";", "String", "trustStoreName", "=", "getTrustStore", "(", ")", ";", "String", "keyStorePassword", "=", "getKeyStorePassphrase", "(", ")", ";", "String", "trustStorePassword", "=", "getTrustStorePassphrase", "(", ")", ";", "String", "keyStoreType", "=", "getKeyStoreType", "(", ")", ";", "String", "trustStoreType", "=", "getTrustStoreType", "(", ")", ";", "char", "[", "]", "keyPassphrase", "=", "null", ";", "if", "(", "keyStorePassword", "!=", "null", ")", "{", "keyPassphrase", "=", "keyStorePassword", ".", "toCharArray", "(", ")", ";", "}", "char", "[", "]", "trustPassphrase", "=", "null", ";", "if", "(", "trustStorePassword", "!=", "null", ")", "{", "trustPassphrase", "=", "trustStorePassword", ".", "toCharArray", "(", ")", ";", "}", "KeyManager", "[", "]", "keyManagers", "=", "null", ";", "TrustManager", "[", "]", "trustManagers", "=", "null", ";", "if", "(", "StringUtils", ".", "hasText", "(", "keyStoreName", ")", "||", "this", ".", "keyStoreResource", "!=", "null", ")", "{", "Resource", "keyStoreResource", "=", "this", ".", "keyStoreResource", "!=", "null", "?", "this", ".", "keyStoreResource", ":", "resolver", ".", "getResource", "(", "keyStoreName", ")", ";", "KeyStore", "ks", "=", "KeyStore", ".", "getInstance", "(", "keyStoreType", ")", ";", "ks", ".", "load", "(", "keyStoreResource", ".", "getInputStream", "(", ")", ",", "keyPassphrase", ")", ";", "KeyManagerFactory", "kmf", "=", "KeyManagerFactory", ".", "getInstance", "(", "\"", "SunX509", "\"", ")", ";", "kmf", ".", "init", "(", "ks", ",", "keyPassphrase", ")", ";", "keyManagers", "=", "kmf", ".", "getKeyManagers", "(", ")", ";", "}", "if", "(", "StringUtils", ".", "hasText", "(", "trustStoreName", ")", "||", "this", ".", "trustStoreResource", "!=", "null", ")", "{", "Resource", "trustStoreResource", "=", "this", ".", "trustStoreResource", "!=", "null", "?", "this", ".", "trustStoreResource", ":", "resolver", ".", "getResource", "(", "trustStoreName", ")", ";", "KeyStore", "tks", "=", "KeyStore", ".", "getInstance", "(", "trustStoreType", ")", ";", "tks", ".", "load", "(", "trustStoreResource", ".", "getInputStream", "(", ")", ",", "trustPassphrase", ")", ";", "TrustManagerFactory", "tmf", "=", "TrustManagerFactory", ".", "getInstance", "(", "\"", "SunX509", "\"", ")", ";", "tmf", ".", "init", "(", "tks", ")", ";", "trustManagers", "=", "tmf", ".", "getTrustManagers", "(", ")", ";", "}", "if", "(", "this", ".", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "this", ".", "logger", ".", "debug", "(", "\"", "Initializing SSLContext with KM: ", "\"", "+", "Arrays", ".", "toString", "(", "keyManagers", ")", "+", "\"", ", TM: ", "\"", "+", "Arrays", ".", "toString", "(", "trustManagers", ")", "+", "\"", ", random: ", "\"", "+", "this", ".", "secureRandom", ")", ";", "}", "SSLContext", "context", "=", "createSSLContext", "(", ")", ";", "context", ".", "init", "(", "keyManagers", ",", "trustManagers", ",", "this", ".", "secureRandom", ")", ";", "this", ".", "connectionFactory", ".", "useSslProtocol", "(", "context", ")", ";", "}", "}"], "idx": 40637, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "d64e7fa3993dac577c0973e0caf8c31d27ef5e44", "function_name": "setUpSSL", "body_hash": "b529bd30874c6e17b1eedb5e20f2f97d8776ed00"}
{"code": "private static String getIdFromToken(Element token) {\n        if (token != null) {\n            // Try to find the \"Id\" on the token.\n            if (token.hasAttributeNS(WSConstants.WSU_NS, \"Id\")) {\n                return token.getAttributeNS(WSConstants.WSU_NS, \"Id\");\n            } else if (token.hasAttributeNS(null, \"ID\")) {\n                return token.getAttributeNS(null, \"ID\");\n            } else if (token.hasAttributeNS(null, \"AssertionID\")) {\n                return token.getAttributeNS(null, \"AssertionID\");\n            }\n        }\n        return \"\";\n    }", "code_tokens": ["private", "static", "String", "getIdFromToken", "(", "Element", "token", ")", "{", "if", "(", "token", "!=", "null", ")", "{", "if", "(", "token", ".", "hasAttributeNS", "(", "WSConstants", ".", "WSU_NS", ",", "\"", "Id", "\"", ")", ")", "{", "return", "token", ".", "getAttributeNS", "(", "WSConstants", ".", "WSU_NS", ",", "\"", "Id", "\"", ")", ";", "}", "else", "if", "(", "token", ".", "hasAttributeNS", "(", "null", ",", "\"", "ID", "\"", ")", ")", "{", "return", "token", ".", "getAttributeNS", "(", "null", ",", "\"", "ID", "\"", ")", ";", "}", "else", "if", "(", "token", ".", "hasAttributeNS", "(", "null", ",", "\"", "AssertionID", "\"", ")", ")", "{", "return", "token", ".", "getAttributeNS", "(", "null", ",", "\"", "AssertionID", "\"", ")", ";", "}", "}", "return", "\"", "\"", ";", "}"], "idx": 50587, "cwe": "CWE-384", "target": 1, "status": "VULNERABLE", "commit": "66c2c5b9", "function_name": "getIdFromToken", "body_hash": "9f97860bf54829569faa9fe97f213c7d1a06d85e"}
{"code": "@Override\n\t\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\t\tthrows ServletException, IOException {\n\t\t\tString origin = request.getParameter(\"origin\");\n\t\t\tif (origin == null) {\n\t\t\t\tresponse.setStatus(500);\n\t\t\t\tresponse.getWriter().println(\n\t\t\t\t\t\t\"Required parameter 'origin' missing. Example: 107.20.175.135:7001\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\torigin = origin.trim();\n\n\t\t\tHttpGet httpget = null;\n\t\t\tInputStream is = null;\n\t\t\tboolean hasFirstParameter = false;\n\t\t\tStringBuilder url = new StringBuilder();\n\t\t\tif (!origin.startsWith(\"http\")) {\n\t\t\t\turl.append(\"http://\");\n\t\t\t}\n\t\t\turl.append(origin);\n\t\t\tif (origin.contains(\"?\")) {\n\t\t\t\thasFirstParameter = true;\n\t\t\t}\n\t\t\tMap<String, String[]> params = request.getParameterMap();\n\t\t\tfor (String key : params.keySet()) {\n\t\t\t\tif (!key.equals(\"origin\")) {\n\t\t\t\t\tString[] values = params.get(key);\n\t\t\t\t\tString value = values[0].trim();\n\t\t\t\t\tif (hasFirstParameter) {\n\t\t\t\t\t\turl.append(\"&\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\turl.append(\"?\");\n\t\t\t\t\t\thasFirstParameter = true;\n\t\t\t\t\t}\n\t\t\t\t\turl.append(key).append(\"=\").append(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString proxyUrlString = url.toString();\n\n\t\t\tif (!isAllowedToProxy(proxyUrlString)) {\n\t\t\t\tlog.warn(\"Origin parameter: \" + origin\n\t\t\t\t\t\t+ \" is not in the allowed list of proxy host names.  If it \"\n\t\t\t\t\t\t+ \"should be allowed add it to hystrix.dashboard.proxyStreamAllowList.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlog.info(\"\\n\\nProxy opening connection to: \" + proxyUrlString + \"\\n\\n\");\n\t\t\ttry {\n\t\t\t\thttpget = new HttpGet(proxyUrlString);\n\t\t\t\tHttpClient client = ProxyConnectionManager.httpClient;\n\t\t\t\tHttpResponse httpResponse = client.execute(httpget);\n\t\t\t\tint statusCode = httpResponse.getStatusLine().getStatusCode();\n\t\t\t\tif (statusCode == HttpStatus.SC_OK) {\n\t\t\t\t\t// writeTo swallows exceptions and never quits even if outputstream is\n\t\t\t\t\t// throwing IOExceptions (such as broken pipe) ... since the\n\t\t\t\t\t// inputstream is infinite\n\t\t\t\t\t// httpResponse.getEntity().writeTo(new\n\t\t\t\t\t// OutputStreamWrapper(response.getOutputStream()));\n\t\t\t\t\t// so I copy it manually ...\n\t\t\t\t\tis = httpResponse.getEntity().getContent();\n\n\t\t\t\t\t// set headers\n\t\t\t\t\tcopyHeadersToServletResponse(httpResponse.getAllHeaders(), response);\n\n\t\t\t\t\t// copy data from source to response\n\t\t\t\t\tOutputStream os = response.getOutputStream();\n\t\t\t\t\tint b = -1;\n\t\t\t\t\twhile ((b = is.read()) != -1) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tos.write(b);\n\t\t\t\t\t\t\tif (b == 10 /** flush buffer on line feed */\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tos.flush();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (ex.getClass().getSimpleName()\n\t\t\t\t\t\t\t\t\t.equalsIgnoreCase(\"ClientAbortException\")) {\n\t\t\t\t\t\t\t\t// don't throw an exception as this means the user closed\n\t\t\t\t\t\t\t\t// the connection\n\t\t\t\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t\t\t\t\"Connection closed by client. Will stop proxying ...\");\n\t\t\t\t\t\t\t\t// break out of the while loop\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// received unknown error while writing so throw an\n\t\t\t\t\t\t\t\t// exception\n\t\t\t\t\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.warn(\"Failed opening connection to \" + proxyUrlString + \" : \"\n\t\t\t\t\t\t\t+ statusCode + \" : \" + httpResponse.getStatusLine());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlog.error(\"Error proxying request: \" + url, ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (httpget != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thttpget.abort();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tlog.error(\"failed aborting proxy connection.\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// httpget.abort() MUST be called first otherwise is.close() hangs\n\t\t\t\t// (because data is still streaming?)\n\t\t\t\tif (is != null) {\n\t\t\t\t\t// this should already be closed by httpget.abort() above\n\t\t\t\t\ttry {\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t// ignore errors on close\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}", "code_tokens": ["@", "Override", "protected", "void", "doGet", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "String", "origin", "=", "request", ".", "getParameter", "(", "\"", "origin", "\"", ")", ";", "if", "(", "origin", "==", "null", ")", "{", "response", ".", "setStatus", "(", "500", ")", ";", "response", ".", "getWriter", "(", ")", ".", "println", "(", "\"", "Required parameter 'origin' missing. Example: 107.20.175.135:7001", "\"", ")", ";", "return", ";", "}", "origin", "=", "origin", ".", "trim", "(", ")", ";", "HttpGet", "httpget", "=", "null", ";", "InputStream", "is", "=", "null", ";", "boolean", "hasFirstParameter", "=", "false", ";", "StringBuilder", "url", "=", "new", "StringBuilder", "(", ")", ";", "if", "(", "!", "origin", ".", "startsWith", "(", "\"", "http", "\"", ")", ")", "{", "url", ".", "append", "(", "\"", "http://", "\"", ")", ";", "}", "url", ".", "append", "(", "origin", ")", ";", "if", "(", "origin", ".", "contains", "(", "\"", "?", "\"", ")", ")", "{", "hasFirstParameter", "=", "true", ";", "}", "Map", "<", "String", ",", "String", "[", "]", ">", "params", "=", "request", ".", "getParameterMap", "(", ")", ";", "for", "(", "String", "key", ":", "params", ".", "keySet", "(", ")", ")", "{", "if", "(", "!", "key", ".", "equals", "(", "\"", "origin", "\"", ")", ")", "{", "String", "[", "]", "values", "=", "params", ".", "get", "(", "key", ")", ";", "String", "value", "=", "values", "[", "0", "]", ".", "trim", "(", ")", ";", "if", "(", "hasFirstParameter", ")", "{", "url", ".", "append", "(", "\"", "&", "\"", ")", ";", "}", "else", "{", "url", ".", "append", "(", "\"", "?", "\"", ")", ";", "hasFirstParameter", "=", "true", ";", "}", "url", ".", "append", "(", "key", ")", ".", "append", "(", "\"", "=", "\"", ")", ".", "append", "(", "value", ")", ";", "}", "}", "String", "proxyUrlString", "=", "url", ".", "toString", "(", ")", ";", "if", "(", "!", "isAllowedToProxy", "(", "proxyUrlString", ")", ")", "{", "log", ".", "warn", "(", "\"", "Origin parameter: ", "\"", "+", "origin", "+", "\"", " is not in the allowed list of proxy host names.  If it ", "\"", "+", "\"", "should be allowed add it to hystrix.dashboard.proxyStreamAllowList.", "\"", ")", ";", "return", ";", "}", "log", ".", "info", "(", "\"", "\\n", "\\n", "Proxy opening connection to: ", "\"", "+", "proxyUrlString", "+", "\"", "\\n", "\\n", "\"", ")", ";", "try", "{", "httpget", "=", "new", "HttpGet", "(", "proxyUrlString", ")", ";", "HttpClient", "client", "=", "ProxyConnectionManager", ".", "httpClient", ";", "HttpResponse", "httpResponse", "=", "client", ".", "execute", "(", "httpget", ")", ";", "int", "statusCode", "=", "httpResponse", ".", "getStatusLine", "(", ")", ".", "getStatusCode", "(", ")", ";", "if", "(", "statusCode", "==", "HttpStatus", ".", "SC_OK", ")", "{", "is", "=", "httpResponse", ".", "getEntity", "(", ")", ".", "getContent", "(", ")", ";", "copyHeadersToServletResponse", "(", "httpResponse", ".", "getAllHeaders", "(", ")", ",", "response", ")", ";", "OutputStream", "os", "=", "response", ".", "getOutputStream", "(", ")", ";", "int", "b", "=", "-", "1", ";", "while", "(", "(", "b", "=", "is", ".", "read", "(", ")", ")", "!=", "-", "1", ")", "{", "try", "{", "os", ".", "write", "(", "b", ")", ";", "if", "(", "b", "==", "10", ")", "{", "os", ".", "flush", "(", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "if", "(", "ex", ".", "getClass", "(", ")", ".", "getSimpleName", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "ClientAbortException", "\"", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection closed by client. Will stop proxying ...", "\"", ")", ";", "break", ";", "}", "else", "{", "throw", "new", "RuntimeException", "(", "ex", ")", ";", "}", "}", "}", "}", "else", "{", "log", ".", "warn", "(", "\"", "Failed opening connection to ", "\"", "+", "proxyUrlString", "+", "\"", " : ", "\"", "+", "statusCode", "+", "\"", " : ", "\"", "+", "httpResponse", ".", "getStatusLine", "(", ")", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "log", ".", "error", "(", "\"", "Error proxying request: ", "\"", "+", "url", ",", "ex", ")", ";", "}", "finally", "{", "if", "(", "httpget", "!=", "null", ")", "{", "try", "{", "httpget", ".", "abort", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "log", ".", "error", "(", "\"", "failed aborting proxy connection.", "\"", ",", "ex", ")", ";", "}", "}", "if", "(", "is", "!=", "null", ")", "{", "try", "{", "is", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "}", "}", "}", "}"], "idx": 65989, "cwe": "CWE-610", "target": 0, "status": "FIXED", "commit": "a9f0315aa", "function_name": "doGet", "body_hash": "2db179280559c627b5db268f48cac68e5d4ba911"}
{"code": "@Override\n        public int fill(ByteBuffer buffer) throws IOException\n        {\n            try\n            {\n                try (AutoLock l = _lock.lock())\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\">fill {}\", SslConnection.this);\n\n                    int filled = -2;\n                    try\n                    {\n                        if (_fillState != FillState.IDLE)\n                            return filled = 0;\n\n                        // Do we already have some decrypted data?\n                        if (BufferUtil.hasContent(_decryptedInput))\n                            return filled = BufferUtil.append(buffer, _decryptedInput);\n\n                        // loop filling and unwrapping until we have something\n                        while (true)\n                        {\n                            HandshakeStatus status = _sslEngine.getHandshakeStatus();\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"fill {}\", status);\n                            switch (status)\n                            {\n                                case NEED_UNWRAP:\n                                case NOT_HANDSHAKING:\n                                    break;\n\n                                case NEED_TASK:\n                                    _sslEngine.getDelegatedTask().run();\n                                    continue;\n\n                                case NEED_WRAP:\n                                    if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER))\n                                    {\n                                        Throwable failure = _failure;\n                                        if (failure != null)\n                                            rethrow(failure);\n                                        if (_sslEngine.isInboundDone())\n                                            return filled = -1;\n                                        continue;\n                                    }\n                                    // Handle in needsFillInterest().\n                                    return filled = 0;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected HandshakeStatus \" + status);\n                            }\n\n                            acquireEncryptedInput();\n\n                            // can we use the passed buffer if it is big enough\n                            ByteBuffer appIn;\n                            int appBufferSize = getApplicationBufferSize();\n                            if (_decryptedInput == null)\n                            {\n                                if (BufferUtil.space(buffer) > appBufferSize)\n                                    appIn = buffer;\n                                else\n                                    appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);\n                            }\n                            else\n                            {\n                                appIn = _decryptedInput;\n                                BufferUtil.compact(_encryptedInput);\n                            }\n\n                            // Let's try reading some encrypted data... even if we have some already.\n                            int netFilled = networkFill(_encryptedInput);\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"net filled={}\", netFilled);\n\n                            // Workaround for Java 11 behavior.\n                            if (netFilled < 0 && isHandshakeInitial() && BufferUtil.isEmpty(_encryptedInput))\n                                closeInbound();\n\n                            if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone())\n                                throw new SSLHandshakeException(\"Closed during handshake\");\n\n                            if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE))\n                            {\n                                if (LOG.isDebugEnabled())\n                                    LOG.debug(\"fill starting handshake {}\", SslConnection.this);\n                            }\n\n                            // Let's unwrap even if we have no net data because in that\n                            // case we want to fall through to the handshake handling\n                            int pos = BufferUtil.flipToFill(appIn);\n                            SSLEngineResult unwrapResult;\n                            try\n                            {\n                                _underflown = false;\n                                unwrapResult = SslConnection.this.unwrap(_sslEngine, _encryptedInput, appIn);\n                            }\n                            finally\n                            {\n                                BufferUtil.flipToFlush(appIn, pos);\n                            }\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}\",\n                                    netFilled,\n                                    StringUtil.replace(unwrapResult.toString(), '\\n', ' '),\n                                    BufferUtil.toSummaryString(_encryptedInput),\n                                    BufferUtil.toDetailString(appIn),\n                                    BufferUtil.toDetailString(buffer));\n\n                            SSLEngineResult.Status unwrap = unwrapResult.getStatus();\n\n                            // Extra check on unwrapResultStatus == OK with zero bytes consumed\n                            // or produced is due to an SSL client on Android (see bug #454773).\n                            if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0)\n                                unwrap = Status.BUFFER_UNDERFLOW;\n\n                            switch (unwrap)\n                            {\n                                case CLOSED:\n                                    Throwable failure = _failure;\n                                    if (failure != null)\n                                        rethrow(failure);\n                                    return filled = -1;\n\n                                case BUFFER_UNDERFLOW:\n                                    if (netFilled > 0)\n                                    {\n                                        if (BufferUtil.space(_encryptedInput) > 0)\n                                            continue; // try filling some more\n                                        BufferUtil.clear(_encryptedInput);\n                                        throw new SSLHandshakeException(\"Encrypted buffer max length exceeded\");\n                                    }\n                                    _underflown = true;\n                                    if (netFilled < 0 && _sslEngine.getUseClientMode())\n                                    {\n                                        Throwable closeFailure = closeInbound();\n                                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                                        {\n                                            Throwable handshakeFailure = new SSLHandshakeException(\"Abruptly closed by peer\");\n                                            if (closeFailure != null)\n                                                handshakeFailure.addSuppressed(closeFailure);\n                                            throw handshakeFailure;\n                                        }\n                                        return filled = -1;\n                                    }\n                                    return filled = netFilled;\n\n                                case BUFFER_OVERFLOW:\n                                    // It's possible that SSLSession.applicationBufferSize has been expanded\n                                    // by the SSLEngine implementation. Unwrapping a large encrypted buffer\n                                    // causes BUFFER_OVERFLOW because the (old) applicationBufferSize is\n                                    // too small. Release the decrypted input buffer so it will be re-acquired\n                                    // with the larger capacity.\n                                    // See also system property \"jsse.SSLEngine.acceptLargeFragments\".\n                                    if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize())\n                                    {\n                                        releaseDecryptedInputBuffer();\n                                        continue;\n                                    }\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n\n                                case OK:\n                                    if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED)\n                                        handshakeSucceeded();\n\n                                    if (isRenegotiating() && !allowRenegotiate())\n                                        return filled = -1;\n\n                                    // If bytes were produced, don't bother with the handshake status;\n                                    // pass the decrypted data to the application, which will perform\n                                    // another call to fill() or flush().\n                                    if (unwrapResult.bytesProduced() > 0)\n                                    {\n                                        if (appIn == buffer)\n                                            return filled = unwrapResult.bytesProduced();\n                                        return filled = BufferUtil.append(buffer, _decryptedInput);\n                                    }\n\n                                    break;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n                            }\n                        }\n                    }\n                    catch (Throwable x)\n                    {\n                        Throwable f = handleException(x, \"fill\");\n                        Throwable failure = handshakeFailed(f);\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));\n                        }\n                        throw failure;\n                    }\n                    finally\n                    {\n                        releaseEncryptedInputBuffer();\n                        releaseDecryptedInputBuffer();\n\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());\n                        }\n\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"<fill f={} uf={} {}\", filled, _underflown, SslConnection.this);\n                    }\n                }\n            }\n            catch (Throwable x)\n            {\n                close(x);\n                rethrow(x);\n                // Never reached.\n                throw new AssertionError();\n            }\n        }", "code_tokens": ["@", "Override", "public", "int", "fill", "(", "ByteBuffer", "buffer", ")", "throws", "IOException", "{", "try", "{", "try", "(", "AutoLock", "l", "=", "_lock", ".", "lock", "(", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", ">fill {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "int", "filled", "=", "-", "2", ";", "try", "{", "if", "(", "_fillState", "!=", "FillState", ".", "IDLE", ")", "return", "filled", "=", "0", ";", "if", "(", "BufferUtil", ".", "hasContent", "(", "_decryptedInput", ")", ")", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "while", "(", "true", ")", "{", "HandshakeStatus", "status", "=", "_sslEngine", ".", "getHandshakeStatus", "(", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill {}", "\"", ",", "status", ")", ";", "switch", "(", "status", ")", "{", "case", "NEED_UNWRAP", ":", "case", "NOT_HANDSHAKING", ":", "break", ";", "case", "NEED_TASK", ":", "_sslEngine", ".", "getDelegatedTask", "(", ")", ".", "run", "(", ")", ";", "continue", ";", "case", "NEED_WRAP", ":", "if", "(", "_flushState", "==", "FlushState", ".", "IDLE", "&&", "flush", "(", "BufferUtil", ".", "EMPTY_BUFFER", ")", ")", "{", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "if", "(", "_sslEngine", ".", "isInboundDone", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "continue", ";", "}", "return", "filled", "=", "0", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected HandshakeStatus ", "\"", "+", "status", ")", ";", "}", "acquireEncryptedInput", "(", ")", ";", "ByteBuffer", "appIn", ";", "int", "appBufferSize", "=", "getApplicationBufferSize", "(", ")", ";", "if", "(", "_decryptedInput", "==", "null", ")", "{", "if", "(", "BufferUtil", ".", "space", "(", "buffer", ")", ">", "appBufferSize", ")", "appIn", "=", "buffer", ";", "else", "appIn", "=", "_decryptedInput", "=", "_bufferPool", ".", "acquire", "(", "appBufferSize", ",", "_decryptedDirectBuffers", ")", ";", "}", "else", "{", "appIn", "=", "_decryptedInput", ";", "BufferUtil", ".", "compact", "(", "_encryptedInput", ")", ";", "}", "int", "netFilled", "=", "networkFill", "(", "_encryptedInput", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "net filled={}", "\"", ",", "netFilled", ")", ";", "if", "(", "netFilled", "<", "0", "&&", "isHandshakeInitial", "(", ")", "&&", "BufferUtil", ".", "isEmpty", "(", "_encryptedInput", ")", ")", "closeInbound", "(", ")", ";", "if", "(", "netFilled", ">", "0", "&&", "!", "isHandshakeComplete", "(", ")", "&&", "isOutboundDone", "(", ")", ")", "throw", "new", "SSLHandshakeException", "(", "\"", "Closed during handshake", "\"", ")", ";", "if", "(", "_handshake", ".", "compareAndSet", "(", "HandshakeState", ".", "INITIAL", ",", "HandshakeState", ".", "HANDSHAKE", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill starting handshake {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "}", "int", "pos", "=", "BufferUtil", ".", "flipToFill", "(", "appIn", ")", ";", "SSLEngineResult", "unwrapResult", ";", "try", "{", "_underflown", "=", "false", ";", "unwrapResult", "=", "SslConnection", ".", "this", ".", "unwrap", "(", "_sslEngine", ",", "_encryptedInput", ",", "appIn", ")", ";", "}", "finally", "{", "BufferUtil", ".", "flipToFlush", "(", "appIn", ",", "pos", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}", "\"", ",", "netFilled", ",", "StringUtil", ".", "replace", "(", "unwrapResult", ".", "toString", "(", ")", ",", "'\\n'", ",", "' '", ")", ",", "BufferUtil", ".", "toSummaryString", "(", "_encryptedInput", ")", ",", "BufferUtil", ".", "toDetailString", "(", "appIn", ")", ",", "BufferUtil", ".", "toDetailString", "(", "buffer", ")", ")", ";", "SSLEngineResult", ".", "Status", "unwrap", "=", "unwrapResult", ".", "getStatus", "(", ")", ";", "if", "(", "unwrap", "==", "Status", ".", "OK", "&&", "unwrapResult", ".", "bytesConsumed", "(", ")", "==", "0", "&&", "unwrapResult", ".", "bytesProduced", "(", ")", "==", "0", ")", "unwrap", "=", "Status", ".", "BUFFER_UNDERFLOW", ";", "switch", "(", "unwrap", ")", "{", "case", "CLOSED", ":", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "return", "filled", "=", "-", "1", ";", "case", "BUFFER_UNDERFLOW", ":", "if", "(", "netFilled", ">", "0", ")", "{", "if", "(", "BufferUtil", ".", "space", "(", "_encryptedInput", ")", ">", "0", ")", "continue", ";", "BufferUtil", ".", "clear", "(", "_encryptedInput", ")", ";", "throw", "new", "SSLHandshakeException", "(", "\"", "Encrypted buffer max length exceeded", "\"", ")", ";", "}", "_underflown", "=", "true", ";", "if", "(", "netFilled", "<", "0", "&&", "_sslEngine", ".", "getUseClientMode", "(", ")", ")", "{", "Throwable", "closeFailure", "=", "closeInbound", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "Throwable", "handshakeFailure", "=", "new", "SSLHandshakeException", "(", "\"", "Abruptly closed by peer", "\"", ")", ";", "if", "(", "closeFailure", "!=", "null", ")", "handshakeFailure", ".", "addSuppressed", "(", "closeFailure", ")", ";", "throw", "handshakeFailure", ";", "}", "return", "filled", "=", "-", "1", ";", "}", "return", "filled", "=", "netFilled", ";", "case", "BUFFER_OVERFLOW", ":", "if", "(", "BufferUtil", ".", "isEmpty", "(", "_decryptedInput", ")", "&&", "appBufferSize", "<", "getApplicationBufferSize", "(", ")", ")", "{", "releaseDecryptedInputBuffer", "(", ")", ";", "continue", ";", "}", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "case", "OK", ":", "if", "(", "unwrapResult", ".", "getHandshakeStatus", "(", ")", "==", "HandshakeStatus", ".", "FINISHED", ")", "handshakeSucceeded", "(", ")", ";", "if", "(", "isRenegotiating", "(", ")", "&&", "!", "allowRenegotiate", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "if", "(", "unwrapResult", ".", "bytesProduced", "(", ")", ">", "0", ")", "{", "if", "(", "appIn", "==", "buffer", ")", "return", "filled", "=", "unwrapResult", ".", "bytesProduced", "(", ")", ";", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "}", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "Throwable", "f", "=", "handleException", "(", "x", ",", "\"", "fill", "\"", ")", ";", "Throwable", "failure", "=", "handshakeFailed", "(", "f", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "onFail", "(", "failure", ")", ")", ";", "}", "throw", "failure", ";", "}", "finally", "{", "releaseEncryptedInputBuffer", "(", ")", ";", "releaseDecryptedInputBuffer", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "completeWrite", "(", ")", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "<fill f={} uf={} {}", "\"", ",", "filled", ",", "_underflown", ",", "SslConnection", ".", "this", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "close", "(", "x", ")", ";", "rethrow", "(", "x", ")", ";", "throw", "new", "AssertionError", "(", ")", ";", "}", "}"], "idx": 65348, "cwe": "CWE-59", "target": 0, "status": "FIXED", "commit": "be22761a20a1685365c8e0356bf09b47e574cfd9", "function_name": "fill", "body_hash": "85f430775e21423e7d4a986744dfb7d90204c703"}
{"code": "protected Number extractFloat() throws ParseException {\n\t\tif (!acceptLeadinZero)\n\t\t\tcheckLeadinZero();\n\t\ttry {\n\t\t\tif (!useHiPrecisionFloat)\n\t\t\t\treturn Float.parseFloat(xs);\n\t\t\tif (xs.length() > 18) // follow JSonIJ parsing method\n\t\t\t\treturn new BigDecimal(xs);\n\t\t\treturn Double.parseDouble(xs);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ParseException(pos, ERROR_UNEXPECTED_TOKEN, xs);\n\t\t}\n\t}", "code_tokens": ["protected", "Number", "extractFloat", "(", ")", "throws", "ParseException", "{", "if", "(", "!", "acceptLeadinZero", ")", "checkLeadinZero", "(", ")", ";", "try", "{", "if", "(", "!", "useHiPrecisionFloat", ")", "return", "Float", ".", "parseFloat", "(", "xs", ")", ";", "if", "(", "xs", ".", "length", "(", ")", ">", "18", ")", "return", "new", "BigDecimal", "(", "xs", ")", ";", "return", "Double", ".", "parseDouble", "(", "xs", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "throw", "new", "ParseException", "(", "pos", ",", "ERROR_UNEXPECTED_TOKEN", ",", "xs", ")", ";", "}", "}"], "idx": 74249, "cwe": "CWE-754", "target": 0, "status": "FIXED", "commit": "7304d1e9fee8af72c93e7e31bb3f91445e479d53", "function_name": "extractFloat", "body_hash": "d8bf05b8064d10cf071bd7ea59e46e228d0636cd"}
{"code": "private File tempFile() throws IOException {\n        String newpostfix;\n        String diskFilename = getDiskFilename();\n        if (diskFilename != null) {\n            newpostfix = '_' + diskFilename;\n        } else {\n            newpostfix = getPostfix();\n        }\n        File tmpFile;\n        if (getBaseDirectory() == null) {\n            // create a temporary file\n            tmpFile = PlatformDependent.createTempFile(getPrefix(), newpostfix, null);\n        } else {\n            tmpFile = PlatformDependent.createTempFile(getPrefix(), newpostfix, new File(\n                    getBaseDirectory()));\n        }\n        if (deleteOnExit()) {\n            // See https://github.com/netty/netty/issues/10351\n            DeleteFileOnExitHook.add(tmpFile.getPath());\n        }\n        return tmpFile;\n    }", "code_tokens": ["private", "File", "tempFile", "(", ")", "throws", "IOException", "{", "String", "newpostfix", ";", "String", "diskFilename", "=", "getDiskFilename", "(", ")", ";", "if", "(", "diskFilename", "!=", "null", ")", "{", "newpostfix", "=", "'_'", "+", "diskFilename", ";", "}", "else", "{", "newpostfix", "=", "getPostfix", "(", ")", ";", "}", "File", "tmpFile", ";", "if", "(", "getBaseDirectory", "(", ")", "==", "null", ")", "{", "tmpFile", "=", "PlatformDependent", ".", "createTempFile", "(", "getPrefix", "(", ")", ",", "newpostfix", ",", "null", ")", ";", "}", "else", "{", "tmpFile", "=", "PlatformDependent", ".", "createTempFile", "(", "getPrefix", "(", ")", ",", "newpostfix", ",", "new", "File", "(", "getBaseDirectory", "(", ")", ")", ")", ";", "}", "if", "(", "deleteOnExit", "(", ")", ")", "{", "DeleteFileOnExitHook", ".", "add", "(", "tmpFile", ".", "getPath", "(", ")", ")", ";", "}", "return", "tmpFile", ";", "}"], "idx": 49793, "cwe": "CWE-378", "target": 0, "status": "FIXED", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "tempFile", "body_hash": "5da9d34b1517d418a84b73c5b662737d65137637"}
{"code": "private static void assertSendsCorrectly(final byte[] sourceBytes, SSLEngine source,\n            SSLEngine dest, boolean needsRecordSplit) throws SSLException {\n        ByteBuffer sourceOut = ByteBuffer.wrap(sourceBytes);\n        SSLSession sourceSession = source.getSession();\n        ByteBuffer sourceToDest = ByteBuffer.allocate(sourceSession.getPacketBufferSize());\n        SSLEngineResult sourceOutRes = source.wrap(sourceOut, sourceToDest);\n        sourceToDest.flip();\n\n        String sourceCipherSuite = source.getSession().getCipherSuite();\n        assertEquals(sourceCipherSuite, sourceBytes.length, sourceOutRes.bytesConsumed());\n        assertEquals(sourceCipherSuite, HandshakeStatus.NOT_HANDSHAKING,\n                sourceOutRes.getHandshakeStatus());\n\n        SSLSession destSession = dest.getSession();\n        ByteBuffer destIn = ByteBuffer.allocate(destSession.getApplicationBufferSize());\n\n        int numUnwrapCalls = 0;\n        while (destIn.position() != sourceOut.limit()) {\n            SSLEngineResult destRes = dest.unwrap(sourceToDest, destIn);\n            assertEquals(sourceCipherSuite, HandshakeStatus.NOT_HANDSHAKING,\n                    destRes.getHandshakeStatus());\n            if (needsRecordSplit && numUnwrapCalls == 0) {\n                assertEquals(sourceCipherSuite, 1, destRes.bytesProduced());\n            }\n            numUnwrapCalls++;\n        }\n\n        destIn.flip();\n        byte[] actual = new byte[destIn.remaining()];\n        destIn.get(actual);\n        assertEquals(sourceCipherSuite, Arrays.toString(sourceBytes), Arrays.toString(actual));\n\n        if (needsRecordSplit) {\n            assertEquals(sourceCipherSuite, 2, numUnwrapCalls);\n        } else {\n            assertEquals(sourceCipherSuite, 1, numUnwrapCalls);\n        }\n    }", "code_tokens": ["private", "static", "void", "assertSendsCorrectly", "(", "final", "byte", "[", "]", "sourceBytes", ",", "SSLEngine", "source", ",", "SSLEngine", "dest", ",", "boolean", "needsRecordSplit", ")", "throws", "SSLException", "{", "ByteBuffer", "sourceOut", "=", "ByteBuffer", ".", "wrap", "(", "sourceBytes", ")", ";", "SSLSession", "sourceSession", "=", "source", ".", "getSession", "(", ")", ";", "ByteBuffer", "sourceToDest", "=", "ByteBuffer", ".", "allocate", "(", "sourceSession", ".", "getPacketBufferSize", "(", ")", ")", ";", "SSLEngineResult", "sourceOutRes", "=", "source", ".", "wrap", "(", "sourceOut", ",", "sourceToDest", ")", ";", "sourceToDest", ".", "flip", "(", ")", ";", "String", "sourceCipherSuite", "=", "source", ".", "getSession", "(", ")", ".", "getCipherSuite", "(", ")", ";", "assertEquals", "(", "sourceCipherSuite", ",", "sourceBytes", ".", "length", ",", "sourceOutRes", ".", "bytesConsumed", "(", ")", ")", ";", "assertEquals", "(", "sourceCipherSuite", ",", "HandshakeStatus", ".", "NOT_HANDSHAKING", ",", "sourceOutRes", ".", "getHandshakeStatus", "(", ")", ")", ";", "SSLSession", "destSession", "=", "dest", ".", "getSession", "(", ")", ";", "ByteBuffer", "destIn", "=", "ByteBuffer", ".", "allocate", "(", "destSession", ".", "getApplicationBufferSize", "(", ")", ")", ";", "int", "numUnwrapCalls", "=", "0", ";", "while", "(", "destIn", ".", "position", "(", ")", "!=", "sourceOut", ".", "limit", "(", ")", ")", "{", "SSLEngineResult", "destRes", "=", "dest", ".", "unwrap", "(", "sourceToDest", ",", "destIn", ")", ";", "assertEquals", "(", "sourceCipherSuite", ",", "HandshakeStatus", ".", "NOT_HANDSHAKING", ",", "destRes", ".", "getHandshakeStatus", "(", ")", ")", ";", "if", "(", "needsRecordSplit", "&&", "numUnwrapCalls", "==", "0", ")", "{", "assertEquals", "(", "sourceCipherSuite", ",", "1", ",", "destRes", ".", "bytesProduced", "(", ")", ")", ";", "}", "numUnwrapCalls", "++", ";", "}", "destIn", ".", "flip", "(", ")", ";", "byte", "[", "]", "actual", "=", "new", "byte", "[", "destIn", ".", "remaining", "(", ")", "]", ";", "destIn", ".", "get", "(", "actual", ")", ";", "assertEquals", "(", "sourceCipherSuite", ",", "Arrays", ".", "toString", "(", "sourceBytes", ")", ",", "Arrays", ".", "toString", "(", "actual", ")", ")", ";", "if", "(", "needsRecordSplit", ")", "{", "assertEquals", "(", "sourceCipherSuite", ",", "2", ",", "numUnwrapCalls", ")", ";", "}", "else", "{", "assertEquals", "(", "sourceCipherSuite", ",", "1", ",", "numUnwrapCalls", ")", ";", "}", "}"], "idx": 102248, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "e56958e7dea05c1784317f139e2216e2e707d391", "function_name": "assertSendsCorrectly", "body_hash": "d70711b4bd8d2adc0bcc809062c61d99975eb570"}
{"code": "@Override\n    public boolean validateCrumb(ServletRequest request, String salt, String crumb) {\n        if (request instanceof HttpServletRequest) {\n            String newCrumb = issueCrumb(request, salt);\n            if ((newCrumb != null) && (crumb != null)) {\n                return MessageDigest.isEqual(newCrumb.getBytes(), crumb.getBytes());\n            }\n        }\n        return false;\n    }", "code_tokens": ["@", "Override", "public", "boolean", "validateCrumb", "(", "ServletRequest", "request", ",", "String", "salt", ",", "String", "crumb", ")", "{", "if", "(", "request", "instanceof", "HttpServletRequest", ")", "{", "String", "newCrumb", "=", "issueCrumb", "(", "request", ",", "salt", ")", ";", "if", "(", "(", "newCrumb", "!=", "null", ")", "&&", "(", "crumb", "!=", "null", ")", ")", "{", "return", "MessageDigest", ".", "isEqual", "(", "newCrumb", ".", "getBytes", "(", ")", ",", "crumb", ".", "getBytes", "(", ")", ")", ";", "}", "}", "return", "false", ";", "}"], "idx": 13771, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "559566b1ac62ebe966613933baf1714137daeb8c", "function_name": "validateCrumb", "body_hash": "9a5c77bb7387731ec0f4408f1c64f48976b46688"}
{"code": "private SSLException checkSSLAlerts() {\n        debug(\"JSSEngine: Checking inbound and outbound SSL Alerts. Have \" + ssl_fd.inboundAlerts.size() + \" inbound and \" + ssl_fd.outboundAlerts.size() + \" outbound alerts.\");\n\n        // Prefer inbound alerts to outbound alerts.\n        while (ssl_fd.inboundOffset < ssl_fd.inboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.inboundAlerts.get(ssl_fd.inboundOffset);\n            ssl_fd.inboundOffset += 1;\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Got inbound CLOSE_NOTIFY alert\");\n                closeInbound();\n            }\n\n            debug(\"JSSEngine: Got inbound alert: \" + event);\n\n            // Fire inbound alert prior to raising any exception.\n            fireAlertReceived(event);\n\n            // Not every SSL Alert is fatal; toException() only returns a\n            // SSLException on fatal instances. We shouldn't return NULL\n            // early without checking all alerts.\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        while (ssl_fd.outboundOffset < ssl_fd.outboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.outboundAlerts.get(ssl_fd.outboundOffset);\n            ssl_fd.outboundOffset += 1;\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Sent outbound CLOSE_NOTIFY alert.\");\n                closeOutbound();\n            }\n\n            debug(\"JSSEngine: Got outbound alert: \" + event);\n\n            // Fire outbound alert prior to raising any exception. Note that\n            // this still triggers after this alert is written to the output\n            // wire buffer.\n            fireAlertSent(event);\n\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        return null;\n    }", "code_tokens": ["private", "SSLException", "checkSSLAlerts", "(", ")", "{", "debug", "(", "\"", "JSSEngine: Checking inbound and outbound SSL Alerts. Have ", "\"", "+", "ssl_fd", ".", "inboundAlerts", ".", "size", "(", ")", "+", "\"", " inbound and ", "\"", "+", "ssl_fd", ".", "outboundAlerts", ".", "size", "(", ")", "+", "\"", " outbound alerts.", "\"", ")", ";", "while", "(", "ssl_fd", ".", "inboundOffset", "<", "ssl_fd", ".", "inboundAlerts", ".", "size", "(", ")", ")", "{", "SSLAlertEvent", "event", "=", "ssl_fd", ".", "inboundAlerts", ".", "get", "(", "ssl_fd", ".", "inboundOffset", ")", ";", "ssl_fd", ".", "inboundOffset", "+=", "1", ";", "if", "(", "event", ".", "getLevelEnum", "(", ")", "==", "SSLAlertLevel", ".", "WARNING", "&&", "event", ".", "getDescriptionEnum", "(", ")", "==", "SSLAlertDescription", ".", "CLOSE_NOTIFY", ")", "{", "debug", "(", "\"", "Got inbound CLOSE_NOTIFY alert", "\"", ")", ";", "closeInbound", "(", ")", ";", "}", "debug", "(", "\"", "JSSEngine: Got inbound alert: ", "\"", "+", "event", ")", ";", "fireAlertReceived", "(", "event", ")", ";", "SSLException", "exception", "=", "event", ".", "toException", "(", ")", ";", "if", "(", "exception", "!=", "null", ")", "{", "return", "exception", ";", "}", "}", "while", "(", "ssl_fd", ".", "outboundOffset", "<", "ssl_fd", ".", "outboundAlerts", ".", "size", "(", ")", ")", "{", "SSLAlertEvent", "event", "=", "ssl_fd", ".", "outboundAlerts", ".", "get", "(", "ssl_fd", ".", "outboundOffset", ")", ";", "ssl_fd", ".", "outboundOffset", "+=", "1", ";", "if", "(", "event", ".", "getLevelEnum", "(", ")", "==", "SSLAlertLevel", ".", "WARNING", "&&", "event", ".", "getDescriptionEnum", "(", ")", "==", "SSLAlertDescription", ".", "CLOSE_NOTIFY", ")", "{", "debug", "(", "\"", "Sent outbound CLOSE_NOTIFY alert.", "\"", ")", ";", "closeOutbound", "(", ")", ";", "}", "debug", "(", "\"", "JSSEngine: Got outbound alert: ", "\"", "+", "event", ")", ";", "fireAlertSent", "(", "event", ")", ";", "SSLException", "exception", "=", "event", ".", "toException", "(", ")", ";", "if", "(", "exception", "!=", "null", ")", "{", "return", "exception", ";", "}", "}", "return", "null", ";", "}"], "idx": 52918, "cwe": "CWE-401", "target": 0, "status": "FIXED", "commit": "3aabe0e9d59b0a42e68ac8cd0468f9c5179967d2", "function_name": "checkSSLAlerts", "body_hash": "f8ad56da70b8028734c5f55f5c9c4410808cc094"}
{"code": "public void recycle() {\n        bytesRead=0;\n\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        trailerFields.clear();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        errorException = null;\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTimeNanos = -1;\n    }", "code_tokens": ["public", "void", "recycle", "(", ")", "{", "bytesRead", "=", "0", ";", "contentLength", "=", "-", "1", ";", "contentTypeMB", "=", "null", ";", "charset", "=", "null", ";", "characterEncoding", "=", "null", ";", "expectation", "=", "false", ";", "headers", ".", "recycle", "(", ")", ";", "trailerFields", ".", "clear", "(", ")", ";", "serverNameMB", ".", "recycle", "(", ")", ";", "serverPort", "=", "-", "1", ";", "localAddrMB", ".", "recycle", "(", ")", ";", "localNameMB", ".", "recycle", "(", ")", ";", "localPort", "=", "-", "1", ";", "peerAddrMB", ".", "recycle", "(", ")", ";", "remoteAddrMB", ".", "recycle", "(", ")", ";", "remoteHostMB", ".", "recycle", "(", ")", ";", "remotePort", "=", "-", "1", ";", "available", "=", "0", ";", "sendfile", "=", "true", ";", "serverCookies", ".", "recycle", "(", ")", ";", "parameters", ".", "recycle", "(", ")", ";", "pathParameters", ".", "clear", "(", ")", ";", "uriMB", ".", "recycle", "(", ")", ";", "decodedUriMB", ".", "recycle", "(", ")", ";", "queryMB", ".", "recycle", "(", ")", ";", "methodMB", ".", "recycle", "(", ")", ";", "protoMB", ".", "recycle", "(", ")", ";", "schemeMB", ".", "recycle", "(", ")", ";", "remoteUser", ".", "recycle", "(", ")", ";", "remoteUserNeedsAuthorization", "=", "false", ";", "authType", ".", "recycle", "(", ")", ";", "attributes", ".", "clear", "(", ")", ";", "errorException", "=", "null", ";", "listener", "=", "null", ";", "synchronized", "(", "nonBlockingStateLock", ")", "{", "fireListener", "=", "false", ";", "registeredForRead", "=", "false", ";", "}", "allDataReadEventSent", ".", "set", "(", "false", ")", ";", "startTimeNanos", "=", "-", "1", ";", "}"], "idx": 74732, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "b59099e4ca501a039510334ebe1024971cd6f959", "function_name": "recycle", "body_hash": "cfc892cc28e10d134874b928650455951d01ebd2"}
{"code": "public void testCall(final String path, final String expectedResponse) throws Exception {\n        TestHttpClient client = new TestHttpClient();\n        String url = DefaultServer.getDefaultServerURL() + \"/servletContext/secured/\" + path;\n        HttpGet get = new HttpGet(url);\n        HttpResponse result = client.execute(get);\n        assertEquals(StatusCodes.UNAUTHORIZED, result.getStatusLine().getStatusCode());\n        Header[] values = result.getHeaders(WWW_AUTHENTICATE.toString());\n        assertEquals(1, values.length);\n        String value = values[0].getValue();\n        assertTrue(value.startsWith(DIGEST.toString()));\n        Map<DigestWWWAuthenticateToken, String> parsedHeader = DigestWWWAuthenticateToken.parseHeader(value.substring(7));\n        assertEquals(REALM_NAME, parsedHeader.get(DigestWWWAuthenticateToken.REALM));\n        assertEquals(DigestAlgorithm.MD5.getToken(), parsedHeader.get(DigestWWWAuthenticateToken.ALGORITHM));\n        assertTrue(parsedHeader.containsKey(DigestWWWAuthenticateToken.MESSAGE_QOP));\n\n        String nonce = parsedHeader.get(DigestWWWAuthenticateToken.NONCE);\n\n        String clientResponse = createResponse(\"user1\", REALM_NAME, \"password1\", \"GET\", \"/\", nonce);\n\n        client = new TestHttpClient();\n        get = new HttpGet(url);\n        StringBuilder sb = new StringBuilder(DIGEST.toString());\n        sb.append(\" \");\n        sb.append(DigestAuthorizationToken.USERNAME.getName()).append(\"=\").append(\"\\\"user1\\\"\").append(\",\");\n        sb.append(DigestAuthorizationToken.REALM.getName()).append(\"=\\\"\").append(REALM_NAME).append(\"\\\",\");\n        sb.append(DigestAuthorizationToken.NONCE.getName()).append(\"=\\\"\").append(nonce).append(\"\\\",\");\n        sb.append(DigestAuthorizationToken.DIGEST_URI.getName()).append(\"=\\\"/\\\",\");\n        sb.append(DigestAuthorizationToken.RESPONSE.getName()).append(\"=\\\"\").append(clientResponse).append(\"\\\"\");\n\n        get.addHeader(AUTHORIZATION.toString(), sb.toString());\n        result = client.execute(get);\n        assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());\n\n        final String response = HttpClientUtils.readResponse(result);\n        assertEquals(expectedResponse, response);\n    }", "code_tokens": ["public", "void", "testCall", "(", "final", "String", "path", ",", "final", "String", "expectedResponse", ")", "throws", "Exception", "{", "TestHttpClient", "client", "=", "new", "TestHttpClient", "(", ")", ";", "String", "url", "=", "DefaultServer", ".", "getDefaultServerURL", "(", ")", "+", "\"", "/servletContext/secured/", "\"", "+", "path", ";", "HttpGet", "get", "=", "new", "HttpGet", "(", "url", ")", ";", "HttpResponse", "result", "=", "client", ".", "execute", "(", "get", ")", ";", "assertEquals", "(", "StatusCodes", ".", "UNAUTHORIZED", ",", "result", ".", "getStatusLine", "(", ")", ".", "getStatusCode", "(", ")", ")", ";", "Header", "[", "]", "values", "=", "result", ".", "getHeaders", "(", "WWW_AUTHENTICATE", ".", "toString", "(", ")", ")", ";", "assertEquals", "(", "1", ",", "values", ".", "length", ")", ";", "String", "value", "=", "values", "[", "0", "]", ".", "getValue", "(", ")", ";", "assertTrue", "(", "value", ".", "startsWith", "(", "DIGEST", ".", "toString", "(", ")", ")", ")", ";", "Map", "<", "DigestWWWAuthenticateToken", ",", "String", ">", "parsedHeader", "=", "DigestWWWAuthenticateToken", ".", "parseHeader", "(", "value", ".", "substring", "(", "7", ")", ")", ";", "assertEquals", "(", "REALM_NAME", ",", "parsedHeader", ".", "get", "(", "DigestWWWAuthenticateToken", ".", "REALM", ")", ")", ";", "assertEquals", "(", "DigestAlgorithm", ".", "MD5", ".", "getToken", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestWWWAuthenticateToken", ".", "ALGORITHM", ")", ")", ";", "assertTrue", "(", "parsedHeader", ".", "containsKey", "(", "DigestWWWAuthenticateToken", ".", "MESSAGE_QOP", ")", ")", ";", "String", "nonce", "=", "parsedHeader", ".", "get", "(", "DigestWWWAuthenticateToken", ".", "NONCE", ")", ";", "String", "clientResponse", "=", "createResponse", "(", "\"", "user1", "\"", ",", "REALM_NAME", ",", "\"", "password1", "\"", ",", "\"", "GET", "\"", ",", "\"", "/", "\"", ",", "nonce", ")", ";", "client", "=", "new", "TestHttpClient", "(", ")", ";", "get", "=", "new", "HttpGet", "(", "url", ")", ";", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "DIGEST", ".", "toString", "(", ")", ")", ";", "sb", ".", "append", "(", "\"", " ", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "USERNAME", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\"", ")", ".", "append", "(", "\"", "\\\"", "user1", "\\\"", "\"", ")", ".", "append", "(", "\"", ",", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "REALM", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\\\"", "\"", ")", ".", "append", "(", "REALM_NAME", ")", ".", "append", "(", "\"", "\\\"", ",", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "NONCE", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\\\"", "\"", ")", ".", "append", "(", "nonce", ")", ".", "append", "(", "\"", "\\\"", ",", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "DIGEST_URI", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\\\"", "/", "\\\"", ",", "\"", ")", ";", "sb", ".", "append", "(", "DigestAuthorizationToken", ".", "RESPONSE", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", "=", "\\\"", "\"", ")", ".", "append", "(", "clientResponse", ")", ".", "append", "(", "\"", "\\\"", "\"", ")", ";", "get", ".", "addHeader", "(", "AUTHORIZATION", ".", "toString", "(", ")", ",", "sb", ".", "toString", "(", ")", ")", ";", "result", "=", "client", ".", "execute", "(", "get", ")", ";", "assertEquals", "(", "StatusCodes", ".", "OK", ",", "result", ".", "getStatusLine", "(", ")", ".", "getStatusCode", "(", ")", ")", ";", "final", "String", "response", "=", "HttpClientUtils", ".", "readResponse", "(", "result", ")", ";", "assertEquals", "(", "expectedResponse", ",", "response", ")", ";", "}"], "idx": 89514, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "facb33a5cedaf4b7b96d3840a08210370a806870", "function_name": "testCall", "body_hash": "5e71352aa3fb2971d90f10d2604c2c6f0f64741d"}
{"code": "@Override\n    public void log(org.apache.coyote.Request req,\n            org.apache.coyote.Response res, long time) {\n\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n        boolean create = false;\n        \n        if (request == null) {\n            create = true;\n            // Create objects\n            request = connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            // Link objects\n            request.setResponse(response);\n            response.setRequest(request);\n\n            // Set as notes\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            // Set query string encoding\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n        }\n        \n        try {\n            connector.getService().getContainer().logAccess(\n                    request, response, time, true);\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.warn(sm.getString(\"coyoteAdapter.accesslogFail\"), t);\n        }\n        \n        if (create) {\n            request.recycle();\n            response.recycle();\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "log", "(", "org", ".", "apache", ".", "coyote", ".", "Request", "req", ",", "org", ".", "apache", ".", "coyote", ".", "Response", "res", ",", "long", "time", ")", "{", "Request", "request", "=", "(", "Request", ")", "req", ".", "getNote", "(", "ADAPTER_NOTES", ")", ";", "Response", "response", "=", "(", "Response", ")", "res", ".", "getNote", "(", "ADAPTER_NOTES", ")", ";", "boolean", "create", "=", "false", ";", "if", "(", "request", "==", "null", ")", "{", "create", "=", "true", ";", "request", "=", "connector", ".", "createRequest", "(", ")", ";", "request", ".", "setCoyoteRequest", "(", "req", ")", ";", "response", "=", "connector", ".", "createResponse", "(", ")", ";", "response", ".", "setCoyoteResponse", "(", "res", ")", ";", "request", ".", "setResponse", "(", "response", ")", ";", "response", ".", "setRequest", "(", "request", ")", ";", "req", ".", "setNote", "(", "ADAPTER_NOTES", ",", "request", ")", ";", "res", ".", "setNote", "(", "ADAPTER_NOTES", ",", "response", ")", ";", "req", ".", "getParameters", "(", ")", ".", "setQueryStringEncoding", "(", "connector", ".", "getURIEncoding", "(", ")", ")", ";", "}", "try", "{", "connector", ".", "getService", "(", ")", ".", "getContainer", "(", ")", ".", "logAccess", "(", "request", ",", "response", ",", "time", ",", "true", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "t", ")", ";", "log", ".", "warn", "(", "sm", ".", "getString", "(", "\"", "coyoteAdapter.accesslogFail", "\"", ")", ",", "t", ")", ";", "}", "if", "(", "create", ")", "{", "request", ".", "recycle", "(", ")", ";", "response", ".", "recycle", "(", ")", ";", "}", "}"], "idx": 9057, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "fd8a579e0e2379a84826b11700adf396e4ed2041", "function_name": "log", "body_hash": "5361ea50c091393aa5eeec57fa17a163634e50be"}
{"code": "private static String verifyRedirectUri(UriInfo uriInfo, String rootUrl, String redirectUri, RealmModel realm, Set<String> validRedirects, boolean requireRedirectUri) {\n\n        if (redirectUri != null)\n            redirectUri = normalizeUrl(redirectUri);\n\n        if (redirectUri == null) {\n            if (!requireRedirectUri) {\n                redirectUri = getSingleValidRedirectUri(validRedirects);\n            }\n\n            if (redirectUri == null) {\n                logger.debug(\"No Redirect URI parameter specified\");\n                return null;\n            }\n        } else if (validRedirects.isEmpty()) {\n            logger.debug(\"No Redirect URIs supplied\");\n            redirectUri = null;\n        } else {\n            redirectUri = lowerCaseHostname(redirectUri);\n\n            String r = redirectUri;\n            Set<String> resolveValidRedirects = resolveValidRedirects(uriInfo, rootUrl, validRedirects);\n\n            boolean valid = matchesRedirects(resolveValidRedirects, r);\n\n            if (!valid && r.startsWith(Constants.INSTALLED_APP_URL) && r.indexOf(':', Constants.INSTALLED_APP_URL.length()) >= 0) {\n                int i = r.indexOf(':', Constants.INSTALLED_APP_URL.length());\n\n                StringBuilder sb = new StringBuilder();\n                sb.append(r.substring(0, i));\n\n                i = r.indexOf('/', i);\n                if (i >= 0) {\n                    sb.append(r.substring(i));\n                }\n\n                r = sb.toString();\n\n                valid = matchesRedirects(resolveValidRedirects, r);\n            }\n            if (valid && redirectUri.startsWith(\"/\")) {\n                redirectUri = relativeToAbsoluteURI(uriInfo, rootUrl, redirectUri);\n            }\n            redirectUri = valid ? redirectUri : null;\n        }\n\n        if (Constants.INSTALLED_APP_URN.equals(redirectUri)) {\n            return Urls.realmInstalledAppUrnCallback(uriInfo.getBaseUri(), realm.getName()).toString();\n        } else {\n            return redirectUri;\n        }\n    }", "code_tokens": ["private", "static", "String", "verifyRedirectUri", "(", "UriInfo", "uriInfo", ",", "String", "rootUrl", ",", "String", "redirectUri", ",", "RealmModel", "realm", ",", "Set", "<", "String", ">", "validRedirects", ",", "boolean", "requireRedirectUri", ")", "{", "if", "(", "redirectUri", "!=", "null", ")", "redirectUri", "=", "normalizeUrl", "(", "redirectUri", ")", ";", "if", "(", "redirectUri", "==", "null", ")", "{", "if", "(", "!", "requireRedirectUri", ")", "{", "redirectUri", "=", "getSingleValidRedirectUri", "(", "validRedirects", ")", ";", "}", "if", "(", "redirectUri", "==", "null", ")", "{", "logger", ".", "debug", "(", "\"", "No Redirect URI parameter specified", "\"", ")", ";", "return", "null", ";", "}", "}", "else", "if", "(", "validRedirects", ".", "isEmpty", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "No Redirect URIs supplied", "\"", ")", ";", "redirectUri", "=", "null", ";", "}", "else", "{", "redirectUri", "=", "lowerCaseHostname", "(", "redirectUri", ")", ";", "String", "r", "=", "redirectUri", ";", "Set", "<", "String", ">", "resolveValidRedirects", "=", "resolveValidRedirects", "(", "uriInfo", ",", "rootUrl", ",", "validRedirects", ")", ";", "boolean", "valid", "=", "matchesRedirects", "(", "resolveValidRedirects", ",", "r", ")", ";", "if", "(", "!", "valid", "&&", "r", ".", "startsWith", "(", "Constants", ".", "INSTALLED_APP_URL", ")", "&&", "r", ".", "indexOf", "(", "':'", ",", "Constants", ".", "INSTALLED_APP_URL", ".", "length", "(", ")", ")", ">=", "0", ")", "{", "int", "i", "=", "r", ".", "indexOf", "(", "':'", ",", "Constants", ".", "INSTALLED_APP_URL", ".", "length", "(", ")", ")", ";", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", ")", ";", "sb", ".", "append", "(", "r", ".", "substring", "(", "0", ",", "i", ")", ")", ";", "i", "=", "r", ".", "indexOf", "(", "'/'", ",", "i", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "sb", ".", "append", "(", "r", ".", "substring", "(", "i", ")", ")", ";", "}", "r", "=", "sb", ".", "toString", "(", ")", ";", "valid", "=", "matchesRedirects", "(", "resolveValidRedirects", ",", "r", ")", ";", "}", "if", "(", "valid", "&&", "redirectUri", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "{", "redirectUri", "=", "relativeToAbsoluteURI", "(", "uriInfo", ",", "rootUrl", ",", "redirectUri", ")", ";", "}", "redirectUri", "=", "valid", "?", "redirectUri", ":", "null", ";", "}", "if", "(", "Constants", ".", "INSTALLED_APP_URN", ".", "equals", "(", "redirectUri", ")", ")", "{", "return", "Urls", ".", "realmInstalledAppUrnCallback", "(", "uriInfo", ".", "getBaseUri", "(", ")", ",", "realm", ".", "getName", "(", ")", ")", ".", "toString", "(", ")", ";", "}", "else", "{", "return", "redirectUri", ";", "}", "}"], "idx": 65794, "cwe": "CWE-601", "target": 0, "status": "FIXED", "commit": "a957e118e6efb35fe7ef3a62acd66341a6523cb7", "function_name": "verifyRedirectUri", "body_hash": "68d4e505da6a8392ac01a1637b44dbe41e6e6bda"}
{"code": "@Override\n        public String getShortDescription() {\n            if(note != null) {\n                return Messages.Cause_RemoteCause_ShortDescriptionWithNote(addr, note);\n            } else {\n                return Messages.Cause_RemoteCause_ShortDescription(addr);\n            }\n        }", "code_tokens": ["@", "Override", "public", "String", "getShortDescription", "(", ")", "{", "if", "(", "note", "!=", "null", ")", "{", "return", "Messages", ".", "Cause_RemoteCause_ShortDescriptionWithNote", "(", "addr", ",", "note", ")", ";", "}", "else", "{", "return", "Messages", ".", "Cause_RemoteCause_ShortDescription", "(", "addr", ")", ";", "}", "}"], "idx": 77773, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "5d57c855f3147bfc5e7fda9252317b428a700014", "function_name": "getShortDescription", "body_hash": "349ad1a0d0df88d734ab8e53ead036f5a5d56b33"}
{"code": "@RequestMapping(value = \"/oauth/authorize\", method = RequestMethod.POST, params = OAuth2Utils.USER_OAUTH_APPROVAL)\n    public View approveOrDeny(@RequestParam Map<String, String> approvalParameters, Map<String, ?> model,\n                              SessionStatus sessionStatus, Principal principal) {\n\n        if (!(principal instanceof Authentication)) {\n            sessionStatus.setComplete();\n            throw new InsufficientAuthenticationException(\n              \"User must be authenticated with Spring Security before authorizing an access token.\");\n        }\n\n        AuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get(\"authorizationRequest\");\n\n        if (authorizationRequest == null) {\n            sessionStatus.setComplete();\n            throw new InvalidRequestException(\"Cannot approve uninitialized authorization request.\");\n        }\n\n        // Check to ensure the Authorization Request was not modified during the user approval step\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> originalAuthorizationRequest = (Map<String, Object>) model.get(\"org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.ORIGINAL_AUTHORIZATION_REQUEST\");\n        if (isAuthorizationRequestModified(authorizationRequest, originalAuthorizationRequest)) {\n            throw new InvalidRequestException(\"Changes were detected from the original authorization request.\");\n        }\n\n        try {\n            Set<String> responseTypes = authorizationRequest.getResponseTypes();\n            String grantType = deriveGrantTypeFromResponseType(responseTypes);\n\n            authorizationRequest.setApprovalParameters(approvalParameters);\n            authorizationRequest = userApprovalHandler.updateAfterApproval(authorizationRequest,\n              (Authentication) principal);\n            boolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);\n            authorizationRequest.setApproved(approved);\n\n            if (authorizationRequest.getRedirectUri() == null) {\n                sessionStatus.setComplete();\n                throw new InvalidRequestException(\"Cannot approve request when no redirect URI is provided.\");\n            }\n\n            if (!authorizationRequest.isApproved()) {\n                return new RedirectView(getUnsuccessfulRedirect(authorizationRequest,\n                  new UserDeniedAuthorizationException(\"User denied access\"), responseTypes.contains(\"token\")),\n                  false, true, false);\n            }\n\n            if (responseTypes.contains(\"token\") || responseTypes.contains(\"id_token\")) {\n                return getImplicitGrantOrHybridResponse(\n                  authorizationRequest,\n                  (Authentication) principal,\n                  grantType\n                ).getView();\n            }\n\n            return getAuthorizationCodeResponse(authorizationRequest, (Authentication) principal);\n        } finally {\n            sessionStatus.setComplete();\n        }\n\n    }", "code_tokens": ["@", "RequestMapping", "(", "value", "=", "\"", "/oauth/authorize", "\"", ",", "method", "=", "RequestMethod", ".", "POST", ",", "params", "=", "OAuth2Utils", ".", "USER_OAUTH_APPROVAL", ")", "public", "View", "approveOrDeny", "(", "@", "RequestParam", "Map", "<", "String", ",", "String", ">", "approvalParameters", ",", "Map", "<", "String", ",", "?", ">", "model", ",", "SessionStatus", "sessionStatus", ",", "Principal", "principal", ")", "{", "if", "(", "!", "(", "principal", "instanceof", "Authentication", ")", ")", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "throw", "new", "InsufficientAuthenticationException", "(", "\"", "User must be authenticated with Spring Security before authorizing an access token.", "\"", ")", ";", "}", "AuthorizationRequest", "authorizationRequest", "=", "(", "AuthorizationRequest", ")", "model", ".", "get", "(", "\"", "authorizationRequest", "\"", ")", ";", "if", "(", "authorizationRequest", "==", "null", ")", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "throw", "new", "InvalidRequestException", "(", "\"", "Cannot approve uninitialized authorization request.", "\"", ")", ";", "}", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Map", "<", "String", ",", "Object", ">", "originalAuthorizationRequest", "=", "(", "Map", "<", "String", ",", "Object", ">", ")", "model", ".", "get", "(", "\"", "org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.ORIGINAL_AUTHORIZATION_REQUEST", "\"", ")", ";", "if", "(", "isAuthorizationRequestModified", "(", "authorizationRequest", ",", "originalAuthorizationRequest", ")", ")", "{", "throw", "new", "InvalidRequestException", "(", "\"", "Changes were detected from the original authorization request.", "\"", ")", ";", "}", "try", "{", "Set", "<", "String", ">", "responseTypes", "=", "authorizationRequest", ".", "getResponseTypes", "(", ")", ";", "String", "grantType", "=", "deriveGrantTypeFromResponseType", "(", "responseTypes", ")", ";", "authorizationRequest", ".", "setApprovalParameters", "(", "approvalParameters", ")", ";", "authorizationRequest", "=", "userApprovalHandler", ".", "updateAfterApproval", "(", "authorizationRequest", ",", "(", "Authentication", ")", "principal", ")", ";", "boolean", "approved", "=", "userApprovalHandler", ".", "isApproved", "(", "authorizationRequest", ",", "(", "Authentication", ")", "principal", ")", ";", "authorizationRequest", ".", "setApproved", "(", "approved", ")", ";", "if", "(", "authorizationRequest", ".", "getRedirectUri", "(", ")", "==", "null", ")", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "throw", "new", "InvalidRequestException", "(", "\"", "Cannot approve request when no redirect URI is provided.", "\"", ")", ";", "}", "if", "(", "!", "authorizationRequest", ".", "isApproved", "(", ")", ")", "{", "return", "new", "RedirectView", "(", "getUnsuccessfulRedirect", "(", "authorizationRequest", ",", "new", "UserDeniedAuthorizationException", "(", "\"", "User denied access", "\"", ")", ",", "responseTypes", ".", "contains", "(", "\"", "token", "\"", ")", ")", ",", "false", ",", "true", ",", "false", ")", ";", "}", "if", "(", "responseTypes", ".", "contains", "(", "\"", "token", "\"", ")", "||", "responseTypes", ".", "contains", "(", "\"", "id_token", "\"", ")", ")", "{", "return", "getImplicitGrantOrHybridResponse", "(", "authorizationRequest", ",", "(", "Authentication", ")", "principal", ",", "grantType", ")", ".", "getView", "(", ")", ";", "}", "return", "getAuthorizationCodeResponse", "(", "authorizationRequest", ",", "(", "Authentication", ")", "principal", ")", ";", "}", "finally", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "}", "}"], "idx": 102826, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "95b7d9e7fae534a362b98de1df5bf501cd52c481", "function_name": "approveOrDeny", "body_hash": "343a9b0ab2a8c2fa3cefbdcc998b645bcf8f0ca6"}
{"code": "private static String parseSoapMethodName(InputStream stream, String charEncoding) {\r\n\t\ttry {\r\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\r\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\r\n\t\t\tfinal XMLStreamReader xmlReader;\r\n\t\t\tif (charEncoding != null) {\r\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\r\n\t\t\t} else {\r\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\r\n\t\t\t}\r\n\r\n\t\t\t//best-effort parsing\r\n\r\n\t\t\t//start document, go to first tag\r\n\t\t\txmlReader.nextTag();\r\n\r\n\t\t\t//expect first tag to be \"Envelope\"\r\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\r\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\r\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\r\n\t\t\t\treturn null; //failed\r\n\t\t\t}\r\n\r\n\t\t\t//scan for body tag\r\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\r\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\r\n\t\t\t\treturn null; //failed\r\n\t\t\t}\r\n\r\n\t\t\txmlReader.nextTag();\r\n\r\n\t\t\t//tag is method name\r\n\t\t\treturn \".\" + xmlReader.getLocalName();\r\n\t\t} catch (final XMLStreamException e) {\r\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\r\n\t\t\t//failed\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}", "code_tokens": ["private", "static", "String", "parseSoapMethodName", "(", "InputStream", "stream", ",", "String", "charEncoding", ")", "{", "try", "{", "final", "XMLInputFactory", "factory", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "final", "XMLStreamReader", "xmlReader", ";", "if", "(", "charEncoding", "!=", "null", ")", "{", "xmlReader", "=", "factory", ".", "createXMLStreamReader", "(", "stream", ",", "charEncoding", ")", ";", "}", "else", "{", "xmlReader", "=", "factory", ".", "createXMLStreamReader", "(", "stream", ")", ";", "}", "xmlReader", ".", "nextTag", "(", ")", ";", "if", "(", "!", "\"", "Envelope", "\"", ".", "equals", "(", "xmlReader", ".", "getLocalName", "(", ")", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Unexpected first tag of SOAP request: '", "\"", "+", "xmlReader", ".", "getLocalName", "(", ")", "+", "\"", "' (expected 'Envelope')", "\"", ")", ";", "return", "null", ";", "}", "if", "(", "!", "scanForChildTag", "(", "xmlReader", ",", "\"", "Body", "\"", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Unable to find SOAP 'Body' tag", "\"", ")", ";", "return", "null", ";", "}", "xmlReader", ".", "nextTag", "(", ")", ";", "return", "\"", ".", "\"", "+", "xmlReader", ".", "getLocalName", "(", ")", ";", "}", "catch", "(", "final", "XMLStreamException", "e", ")", "{", "LOG", ".", "debug", "(", "\"", "Unable to parse SOAP request", "\"", ",", "e", ")", ";", "return", "null", ";", "}", "}"], "idx": 67514, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "ef111822562d0b9365bd3e671a75b65bd0613353", "function_name": "parseSoapMethodName", "body_hash": "d8bf0e5acc6a3557d51cf5b0288915971e872f4a"}
{"code": "@BeforeClass\n  public static void setupClass() {\n    functionStringMap.put(new AlterRuntimeConfigFunction(), \"CLUSTER:WRITE\");\n    functionStringMap.put(new ChangeLogLevelFunction(), \"CLUSTER:WRITE\");\n    functionStringMap.put(new CloseDurableClientFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new CloseDurableCqFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new ContinuousQueryFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new CreateAsyncEventQueueFunction(), \"CLUSTER:MANAGE:DEPLOY\");\n    functionStringMap.put(new CreateDefinedIndexesFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new CreateDiskStoreFunction(), \"CLUSTER:MANAGE:DISK\");\n    functionStringMap.put(new CreateIndexFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new DataCommandFunction(), \"DATA\");\n    functionStringMap.put(new DeployFunction(), \"CLUSTER:MANAGE:DEPLOY\");\n    functionStringMap.put(new DescribeDiskStoreFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new DestroyAsyncEventQueueFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new DestroyDiskStoreFunction(), \"CLUSTER:MANAGE:DISK\");\n    functionStringMap.put(new DestroyIndexFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new ExportConfigFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ExportDataFunction(), \"DATA:READ\");\n    functionStringMap.put(new ExportLogsFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new FetchRegionAttributesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new FetchSharedConfigurationStatusFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GarbageCollectionFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new GatewayReceiverCreateFunction(), \"CLUSTER:MANAGE:GATEWAY\");\n    functionStringMap.put(new GatewaySenderCreateFunction(), \"CLUSTER:MANAGE:GATEWAY\");\n    functionStringMap.put(new GatewaySenderDestroyFunction(), \"CLUSTER:MANAGE:GATEWAY\");\n    functionStringMap.put(new GetClusterConfigurationFunction(), \"*\");\n    functionStringMap.put(new GetMemberConfigInformationFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetMemberInformationFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetRegionDescriptionFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetRegionsFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetStackTracesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetSubscriptionQueueSizeFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ImportDataFunction(), \"DATA:WRITE\");\n    functionStringMap.put(new ListAsyncEventQueuesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListDeployedFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListDiskStoresFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListDurableCqNamesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListFunctionFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListIndexFunction(), \"CLUSTER:READ:QUERY\");\n    functionStringMap.put(new NetstatFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new RebalanceFunction(), \"DATA:MANAGE\");\n    functionStringMap.put(new RegionAlterFunction(), \"DATA:MANAGE\");\n    functionStringMap.put(new RegionCreateFunction(), \"DATA:MANAGE\");\n    functionStringMap.put(new RegionDestroyFunction(), \"DATA:MANAGE\");\n    functionStringMap.put(new ShowMissingDiskStoresFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ShutDownFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new SizeExportLogsFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new UndeployFunction(), \"CLUSTER:MANAGE:DEPLOY\");\n    functionStringMap.put(new UnregisterFunction(), \"CLUSTER:MANAGE:DEPLOY\");\n    functionStringMap.put(new GetRegionNamesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new RecreateCacheFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new DownloadJarFunction(), \"CLUSTER:READ\");\n\n    functionStringMap.keySet().forEach(FunctionService::registerFunction);\n  }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "setupClass", "(", ")", "{", "functionStringMap", ".", "put", "(", "new", "AlterRuntimeConfigFunction", "(", ")", ",", "\"", "CLUSTER:WRITE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ChangeLogLevelFunction", "(", ")", ",", "\"", "CLUSTER:WRITE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CloseDurableClientFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:QUERY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CloseDurableCqFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:QUERY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ContinuousQueryFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateAsyncEventQueueFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:DEPLOY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateDefinedIndexesFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:QUERY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateDiskStoreFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:DISK", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateIndexFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:QUERY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DataCommandFunction", "(", ")", ",", "\"", "DATA", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DeployFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:DEPLOY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DescribeDiskStoreFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyAsyncEventQueueFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyDiskStoreFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:DISK", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyIndexFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:QUERY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ExportConfigFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ExportDataFunction", "(", ")", ",", "\"", "DATA:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ExportLogsFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "FetchRegionAttributesFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "FetchSharedConfigurationStatusFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GarbageCollectionFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GatewayReceiverCreateFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:GATEWAY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GatewaySenderCreateFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:GATEWAY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GatewaySenderDestroyFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:GATEWAY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetClusterConfigurationFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetMemberConfigInformationFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetMemberInformationFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetRegionDescriptionFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetRegionsFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetStackTracesFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetSubscriptionQueueSizeFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ImportDataFunction", "(", ")", ",", "\"", "DATA:WRITE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListAsyncEventQueuesFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListDeployedFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListDiskStoresFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListDurableCqNamesFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListFunctionFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListIndexFunction", "(", ")", ",", "\"", "CLUSTER:READ:QUERY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "NetstatFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RebalanceFunction", "(", ")", ",", "\"", "DATA:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RegionAlterFunction", "(", ")", ",", "\"", "DATA:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RegionCreateFunction", "(", ")", ",", "\"", "DATA:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RegionDestroyFunction", "(", ")", ",", "\"", "DATA:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ShowMissingDiskStoresFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ShutDownFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "SizeExportLogsFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "UndeployFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:DEPLOY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "UnregisterFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:DEPLOY", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetRegionNamesFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RecreateCacheFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DownloadJarFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "keySet", "(", ")", ".", "forEach", "(", "FunctionService", "::", "registerFunction", ")", ";", "}"], "idx": 88189, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "aa469239860778eb46e09dd7b390aee08f152480", "function_name": "setupClass", "body_hash": "f3107ad9879e7969dc507d3f0a2ab29319010b0f"}
{"code": "@Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T fromString(String content, Class<T> classOfT) {\n        try (StringReader reader = new StringReader(content)) {\n            JAXBContext jaxbContext = JAXBContext.newInstance(classOfT);\n\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();\n            xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n            xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, true);\n            XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);\n\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n\n            return (T) unmarshaller.unmarshal(xmlStreamReader);\n        } catch (JAXBException | XMLStreamException e) {\n            throw new PippoRuntimeException(e, \"Failed to deserialize content to '{}'\", classOfT.getName());\n        }\n    }", "code_tokens": ["@", "Override", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "public", "<", "T", ">", "T", "fromString", "(", "String", "content", ",", "Class", "<", "T", ">", "classOfT", ")", "{", "try", "(", "StringReader", "reader", "=", "new", "StringReader", "(", "content", ")", ")", "{", "JAXBContext", "jaxbContext", "=", "JAXBContext", ".", "newInstance", "(", "classOfT", ")", ";", "XMLInputFactory", "xmlInputFactory", "=", "XMLInputFactory", ".", "newFactory", "(", ")", ";", "xmlInputFactory", ".", "setProperty", "(", "XMLInputFactory", ".", "IS_SUPPORTING_EXTERNAL_ENTITIES", ",", "false", ")", ";", "xmlInputFactory", ".", "setProperty", "(", "XMLInputFactory", ".", "SUPPORT_DTD", ",", "true", ")", ";", "XMLStreamReader", "xmlStreamReader", "=", "xmlInputFactory", ".", "createXMLStreamReader", "(", "reader", ")", ";", "Unmarshaller", "unmarshaller", "=", "jaxbContext", ".", "createUnmarshaller", "(", ")", ";", "return", "(", "T", ")", "unmarshaller", ".", "unmarshal", "(", "xmlStreamReader", ")", ";", "}", "catch", "(", "JAXBException", "|", "XMLStreamException", "e", ")", "{", "throw", "new", "PippoRuntimeException", "(", "e", ",", "\"", "Failed to deserialize content to '{}'", "\"", ",", "classOfT", ".", "getName", "(", ")", ")", ";", "}", "}"], "idx": 68626, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "9f36e5891c0b11f840e1e1561ae96d83ba9ce759", "function_name": "fromString", "body_hash": "90ff88dca6308c5b796b1e80da0dc0591c81c496"}
{"code": "private void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\t// Check whether URL matches allowed resources\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, url)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + url +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + url + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(url);\n\t\t\trd.include(request, response);\n\t\t}\n\t}", "code_tokens": ["private", "void", "doInclude", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "String", "resourceUrl", ")", "throws", "ServletException", ",", "IOException", "{", "if", "(", "this", ".", "contentType", "!=", "null", ")", "{", "response", ".", "setContentType", "(", "this", ".", "contentType", ")", ";", "}", "String", "[", "]", "resourceUrls", "=", "StringUtils", ".", "tokenizeToStringArray", "(", "resourceUrl", ",", "RESOURCE_URL_DELIMITERS", ")", ";", "for", "(", "String", "url", ":", "resourceUrls", ")", "{", "if", "(", "this", ".", "allowedResources", "!=", "null", "&&", "!", "this", ".", "pathMatcher", ".", "match", "(", "this", ".", "allowedResources", ",", "url", ")", ")", "{", "throw", "new", "ServletException", "(", "\"", "Resource [", "\"", "+", "url", "+", "\"", "] does not match allowed pattern [", "\"", "+", "this", ".", "allowedResources", "+", "\"", "]", "\"", ")", ";", "}", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Including resource [", "\"", "+", "url", "+", "\"", "]", "\"", ")", ";", "}", "RequestDispatcher", "rd", "=", "request", ".", "getRequestDispatcher", "(", "url", ")", ";", "rd", ".", "include", "(", "request", ",", "response", ")", ";", "}", "}"], "idx": 26770, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "43bf008fbcd0d7945e2fcd5e30039bc4d74c7a98", "function_name": "doInclude", "body_hash": "db00e284c9f105ba4833857c6313b03511c2d456"}
{"code": "private void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser;\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n        } else {\n            original = Thread.currentThread().getContextClassLoader();\n        }\n        try {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa =\n                        new PrivilegedSetTccl(TagPluginManager.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(\n                        TagPluginManager.class.getClassLoader());\n            }\n\n            parser = new TagPluginParser(ctxt, blockExternal);\n\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        } finally {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n            }\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }", "code_tokens": ["private", "void", "init", "(", "ErrorDispatcher", "err", ")", "throws", "JasperException", "{", "if", "(", "initialized", ")", "return", ";", "String", "blockExternalString", "=", "ctxt", ".", "getInitParameter", "(", "Constants", ".", "XML_BLOCK_EXTERNAL_INIT_PARAM", ")", ";", "boolean", "blockExternal", ";", "if", "(", "blockExternalString", "==", "null", ")", "{", "blockExternal", "=", "true", ";", "}", "else", "{", "blockExternal", "=", "Boolean", ".", "parseBoolean", "(", "blockExternalString", ")", ";", "}", "TagPluginParser", "parser", ";", "ClassLoader", "original", ";", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedGetTccl", "pa", "=", "new", "PrivilegedGetTccl", "(", ")", ";", "original", "=", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "original", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "}", "try", "{", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedSetTccl", "pa", "=", "new", "PrivilegedSetTccl", "(", "TagPluginManager", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "Thread", ".", "currentThread", "(", ")", ".", "setContextClassLoader", "(", "TagPluginManager", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "}", "parser", "=", "new", "TagPluginParser", "(", "ctxt", ",", "blockExternal", ")", ";", "Enumeration", "<", "URL", ">", "urls", "=", "ctxt", ".", "getClassLoader", "(", ")", ".", "getResources", "(", "META_INF_JASPER_TAG_PLUGINS_XML", ")", ";", "if", "(", "urls", "!=", "null", ")", "{", "while", "(", "urls", ".", "hasMoreElements", "(", ")", ")", "{", "URL", "url", "=", "urls", ".", "nextElement", "(", ")", ";", "parser", ".", "parse", "(", "url", ")", ";", "}", "}", "URL", "url", "=", "ctxt", ".", "getResource", "(", "TAG_PLUGINS_XML", ")", ";", "if", "(", "url", "!=", "null", ")", "{", "parser", ".", "parse", "(", "url", ")", ";", "}", "}", "catch", "(", "IOException", "|", "SAXException", "e", ")", "{", "throw", "new", "JasperException", "(", "e", ")", ";", "}", "finally", "{", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedSetTccl", "pa", "=", "new", "PrivilegedSetTccl", "(", "original", ")", ";", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "Thread", ".", "currentThread", "(", ")", ".", "setContextClassLoader", "(", "original", ")", ";", "}", "}", "Map", "<", "String", ",", "String", ">", "plugins", "=", "parser", ".", "getPlugins", "(", ")", ";", "tagPlugins", "=", "new", "HashMap", "<", ">", "(", "plugins", ".", "size", "(", ")", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "entry", ":", "plugins", ".", "entrySet", "(", ")", ")", "{", "try", "{", "String", "tagClass", "=", "entry", ".", "getKey", "(", ")", ";", "String", "pluginName", "=", "entry", ".", "getValue", "(", ")", ";", "Class", "<", "?", ">", "pluginClass", "=", "ctxt", ".", "getClassLoader", "(", ")", ".", "loadClass", "(", "pluginName", ")", ";", "TagPlugin", "plugin", "=", "(", "TagPlugin", ")", "pluginClass", ".", "newInstance", "(", ")", ";", "tagPlugins", ".", "put", "(", "tagClass", ",", "plugin", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "err", ".", "jspError", "(", "e", ")", ";", "}", "}", "initialized", "=", "true", ";", "}"], "idx": 32796, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "ebe5c16f18ce1559e8462a94b3876a98525980d2", "function_name": "init", "body_hash": "519e7e996581cb161bd030f083ce13c53403956a"}
{"code": "@Override\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\", \n        \t\tescape(token.getUsername()));\n        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");\n        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);\n        \n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n        \n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n        \n        attributeNames.add(getUserEmailAttribute());\n        \n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n        }\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \"follow\");\n        \n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore()) \n                throw new UnknownAccountException(\"Unknown account\");\n            \n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"//\"));\n                buffer.append(\"//\");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \"//\"), \"/\"));\n                \n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\"ldap\")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \"//\");\n            \tuserDN = StringUtils.substringAfter(userDN, \"/\");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n            \n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n                \n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n                \n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) \n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n                \n                if (getUserSshKeyAttribute() != null) \n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n            \n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter) \n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n            \n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\"Email is required but not available in ldap directory\");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n        }\n\t}", "code_tokens": ["@", "Override", "public", "Authenticated", "authenticate", "(", "UsernamePasswordToken", "token", ")", "{", "String", "fullName", "=", "null", ";", "String", "email", "=", "null", ";", "Collection", "<", "String", ">", "groupNames", "=", "null", ";", "Collection", "<", "String", ">", "sshKeys", "=", "null", ";", "Name", "userSearchBase", ";", "try", "{", "userSearchBase", "=", "new", "CompositeName", "(", ")", ".", "add", "(", "getUserSearchBase", "(", ")", ")", ";", "}", "catch", "(", "InvalidNameException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "String", "userSearchFilter", "=", "StringUtils", ".", "replace", "(", "getUserSearchFilter", "(", ")", ",", "\"", "{0}", "\"", ",", "escape", "(", "token", ".", "getUsername", "(", ")", ")", ")", ";", "userSearchFilter", "=", "StringUtils", ".", "replace", "(", "userSearchFilter", ",", "\"", "\\\\", "\"", ",", "\"", "\\\\", "\\\\", "\"", ")", ";", "logger", ".", "debug", "(", "\"", "Evaluated user search filter: ", "\"", "+", "userSearchFilter", ")", ";", "SearchControls", "searchControls", "=", "new", "SearchControls", "(", ")", ";", "searchControls", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "List", "<", "String", ">", "attributeNames", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "if", "(", "getUserFullNameAttribute", "(", ")", "!=", "null", ")", "attributeNames", ".", "add", "(", "getUserFullNameAttribute", "(", ")", ")", ";", "if", "(", "getUserSshKeyAttribute", "(", ")", "!=", "null", ")", "attributeNames", ".", "add", "(", "getUserSshKeyAttribute", "(", ")", ")", ";", "attributeNames", ".", "add", "(", "getUserEmailAttribute", "(", ")", ")", ";", "if", "(", "getGroupRetrieval", "(", ")", "instanceof", "GetGroupsUsingAttribute", ")", "{", "GetGroupsUsingAttribute", "groupRetrieval", "=", "(", "GetGroupsUsingAttribute", ")", "getGroupRetrieval", "(", ")", ";", "attributeNames", ".", "add", "(", "groupRetrieval", ".", "getUserGroupsAttribute", "(", ")", ")", ";", "}", "searchControls", ".", "setReturningAttributes", "(", "(", "String", "[", "]", ")", "attributeNames", ".", "toArray", "(", "new", "String", "[", "0", "]", ")", ")", ";", "searchControls", ".", "setReturningObjFlag", "(", "true", ")", ";", "Hashtable", "<", "String", ",", "String", ">", "ldapEnv", "=", "new", "Hashtable", "<", ">", "(", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "INITIAL_CONTEXT_FACTORY", ",", "\"", "com.sun.jndi.ldap.LdapCtxFactory", "\"", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "PROVIDER_URL", ",", "getLdapUrl", "(", ")", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "\"", "simple", "\"", ")", ";", "ldapEnv", ".", "put", "(", "\"", "com.sun.jndi.ldap.connect.timeout", "\"", ",", "String", ".", "valueOf", "(", "getTimeout", "(", ")", "*", "1000L", ")", ")", ";", "ldapEnv", ".", "put", "(", "\"", "com.sun.jndi.ldap.read.timeout", "\"", ",", "String", ".", "valueOf", "(", "getTimeout", "(", ")", "*", "1000L", ")", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "REFERRAL", ",", "\"", "follow", "\"", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "getManagerDN", "(", ")", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "getManagerPassword", "(", ")", ")", ";", "DirContext", "ctx", "=", "null", ";", "DirContext", "referralCtx", "=", "null", ";", "try", "{", "logger", ".", "debug", "(", "\"", "Binding to ldap url '", "\"", "+", "getLdapUrl", "(", ")", "+", "\"", "'...", "\"", ")", ";", "try", "{", "ctx", "=", "new", "InitialDirContext", "(", "ldapEnv", ")", ";", "}", "catch", "(", "AuthenticationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Can not bind to ldap server '", "\"", "+", "getLdapUrl", "(", ")", "+", "\"", "': ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "}", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "ctx", ".", "search", "(", "userSearchBase", ",", "userSearchFilter", ",", "searchControls", ")", ";", "if", "(", "results", "==", "null", "||", "!", "results", ".", "hasMore", "(", ")", ")", "throw", "new", "UnknownAccountException", "(", "\"", "Unknown account", "\"", ")", ";", "SearchResult", "searchResult", "=", "(", "SearchResult", ")", "results", ".", "next", "(", ")", ";", "String", "userDN", "=", "searchResult", ".", "getNameInNamespace", "(", ")", ";", "if", "(", "!", "searchResult", ".", "isRelative", "(", ")", ")", "{", "StringBuffer", "buffer", "=", "new", "StringBuffer", "(", ")", ";", "buffer", ".", "append", "(", "StringUtils", ".", "substringBefore", "(", "searchResult", ".", "getName", "(", ")", ",", "\"", "//", "\"", ")", ")", ";", "buffer", ".", "append", "(", "\"", "//", "\"", ")", ";", "buffer", ".", "append", "(", "StringUtils", ".", "substringBefore", "(", "StringUtils", ".", "substringAfter", "(", "searchResult", ".", "getName", "(", ")", ",", "\"", "//", "\"", ")", ",", "\"", "/", "\"", ")", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "PROVIDER_URL", ",", "buffer", ".", "toString", "(", ")", ")", ";", "logger", ".", "debug", "(", "\"", "Binding to referral ldap url '", "\"", "+", "buffer", ".", "toString", "(", ")", "+", "\"", "'...", "\"", ")", ";", "referralCtx", "=", "new", "InitialDirContext", "(", "ldapEnv", ")", ";", "}", "if", "(", "userDN", ".", "startsWith", "(", "\"", "ldap", "\"", ")", ")", "{", "userDN", "=", "StringUtils", ".", "substringAfter", "(", "userDN", ",", "\"", "//", "\"", ")", ";", "userDN", "=", "StringUtils", ".", "substringAfter", "(", "userDN", ",", "\"", "/", "\"", ")", ";", "}", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "userDN", ")", ";", "ldapEnv", ".", "put", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "new", "String", "(", "token", ".", "getPassword", "(", ")", ")", ")", ";", "DirContext", "userCtx", "=", "null", ";", "try", "{", "logger", ".", "debug", "(", "\"", "Authenticating user by binding as '", "\"", "+", "userDN", "+", "\"", "'...", "\"", ")", ";", "userCtx", "=", "new", "InitialDirContext", "(", "ldapEnv", ")", ";", "}", "catch", "(", "AuthenticationException", "e", ")", "{", "throw", "new", "org", ".", "apache", ".", "shiro", ".", "authc", ".", "AuthenticationException", "(", "\"", "Unable to bind as '", "\"", "+", "userDN", "+", "\"", "'", "\"", ",", "e", ")", ";", "}", "finally", "{", "if", "(", "userCtx", "!=", "null", ")", "{", "try", "{", "userCtx", ".", "close", "(", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "}", "}", "}", "Attributes", "searchResultAttributes", "=", "searchResult", ".", "getAttributes", "(", ")", ";", "if", "(", "searchResultAttributes", "!=", "null", ")", "{", "if", "(", "getUserFullNameAttribute", "(", ")", "!=", "null", ")", "{", "Attribute", "attribute", "=", "searchResultAttributes", ".", "get", "(", "getUserFullNameAttribute", "(", ")", ")", ";", "if", "(", "attribute", "!=", "null", "&&", "attribute", ".", "get", "(", ")", "!=", "null", ")", "fullName", "=", "(", "String", ")", "attribute", ".", "get", "(", ")", ";", "}", "Attribute", "attribute", "=", "searchResultAttributes", ".", "get", "(", "getUserEmailAttribute", "(", ")", ")", ";", "if", "(", "attribute", "!=", "null", "&&", "attribute", ".", "get", "(", ")", "!=", "null", ")", "email", "=", "(", "String", ")", "attribute", ".", "get", "(", ")", ";", "if", "(", "getGroupRetrieval", "(", ")", "instanceof", "GetGroupsUsingAttribute", ")", "groupNames", "=", "retrieveGroupsByAttribute", "(", "ctx", ",", "referralCtx", ",", "searchResultAttributes", ")", ";", "if", "(", "getUserSshKeyAttribute", "(", ")", "!=", "null", ")", "sshKeys", "=", "retrieveSshKeys", "(", "searchResultAttributes", ")", ";", "}", "if", "(", "getGroupRetrieval", "(", ")", "instanceof", "SearchGroupsUsingFilter", ")", "groupNames", "=", "retrieveGroupsByFilter", "(", "ctx", ",", "referralCtx", ",", "userDN", ")", ";", "if", "(", "StringUtils", ".", "isBlank", "(", "email", ")", ")", "throw", "new", "AccountException", "(", "\"", "Email is required but not available in ldap directory", "\"", ")", ";", "else", "return", "new", "Authenticated", "(", "email", ",", "fullName", ",", "groupNames", ",", "sshKeys", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "finally", "{", "if", "(", "ctx", "!=", "null", ")", "{", "try", "{", "ctx", ".", "close", "(", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "}", "}", "if", "(", "referralCtx", "!=", "null", ")", "{", "try", "{", "referralCtx", ".", "close", "(", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "}", "}", "}", "}"], "idx": 92845, "cwe": "CWE-90", "target": 0, "status": "FIXED", "commit": "4440f0c57e440488d7e653417b2547eaae8ad19c", "function_name": "authenticate", "body_hash": "69890bc070cd653f57064d55d6ca3ab0c44f4068"}
{"code": "@Before\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        Connector c = getTomcatInstance().getConnector();\n        c.setProperty(\"secretRequired\", \"false\");\n        c.setProperty(\"allowedArbitraryRequestAttributes\", \"MYATTRIBUTE.*\");\n    }", "code_tokens": ["@", "Before", "@", "Override", "public", "void", "setUp", "(", ")", "throws", "Exception", "{", "super", ".", "setUp", "(", ")", ";", "Connector", "c", "=", "getTomcatInstance", "(", ")", ".", "getConnector", "(", ")", ";", "c", ".", "setProperty", "(", "\"", "secretRequired", "\"", ",", "\"", "false", "\"", ")", ";", "c", ".", "setProperty", "(", "\"", "allowedArbitraryRequestAttributes", "\"", ",", "\"", "MYATTRIBUTE.*", "\"", ")", ";", "}"], "idx": 115772, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "64159aa", "function_name": "setUp", "body_hash": "fab2e5f44a04c2194b07a266534abf7b71035da0"}
{"code": "void nextRequest() {\n        request.recycle();\n\n        // Copy leftover bytes to the beginning of the buffer\n        if (byteBuffer.remaining() > 0 && byteBuffer.position() > 0) {\n            byteBuffer.compact();\n            byteBuffer.flip();\n        }\n        // Always reset pos to zero\n        byteBuffer.limit(byteBuffer.limit() - byteBuffer.position()).position(0);\n\n        // Recycle filters\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        // Reset pointers\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        parsingRequestLinePhase = 0;\n        parsingRequestLineEol = false;\n        parsingRequestLineStart = 0;\n        parsingRequestLineQPos = -1;\n        headerData.recycle();\n    }", "code_tokens": ["void", "nextRequest", "(", ")", "{", "request", ".", "recycle", "(", ")", ";", "if", "(", "byteBuffer", ".", "remaining", "(", ")", ">", "0", "&&", "byteBuffer", ".", "position", "(", ")", ">", "0", ")", "{", "byteBuffer", ".", "compact", "(", ")", ";", "byteBuffer", ".", "flip", "(", ")", ";", "}", "byteBuffer", ".", "limit", "(", "byteBuffer", ".", "limit", "(", ")", "-", "byteBuffer", ".", "position", "(", ")", ")", ".", "position", "(", "0", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<=", "lastActiveFilter", ";", "i", "++", ")", "{", "activeFilters", "[", "i", "]", ".", "recycle", "(", ")", ";", "}", "lastActiveFilter", "=", "-", "1", ";", "parsingHeader", "=", "true", ";", "swallowInput", "=", "true", ";", "headerParsePos", "=", "HeaderParsePosition", ".", "HEADER_START", ";", "parsingRequestLine", "=", "true", ";", "parsingRequestLinePhase", "=", "0", ";", "parsingRequestLineEol", "=", "false", ";", "parsingRequestLineStart", "=", "0", ";", "parsingRequestLineQPos", "=", "-", "1", ";", "headerData", ".", "recycle", "(", ")", ";", "}"], "idx": 17060, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "452c8094a665ef6375530e81c033da4eeb2e4865", "function_name": "nextRequest", "body_hash": "c1f00ba5bda78be4e1cd75ddb2aabc31969fe9ba"}
{"code": "public void setMetaData(MetaData.Request request)\n    {\n        if (_metaData == null && _input != null && _channel != null)\n        {\n            _input.reopen();\n            _channel.getResponse().getHttpOutput().reopen();\n        }\n        _metaData = request;\n        _method = request.getMethod();\n        _httpFields = request.getFields();\n        final HttpURI uri = request.getURI();\n\n        boolean ambiguous = uri.isAmbiguous();\n        if (ambiguous)\n        {\n            UriCompliance compliance = _channel == null || _channel.getHttpConfiguration() == null ? null : _channel.getHttpConfiguration().getUriCompliance();\n            if (uri.hasAmbiguousSegment() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_SEGMENT)))\n                throw new BadMessageException(\"Ambiguous segment in URI\");\n            if (uri.hasAmbiguousSeparator() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_SEPARATOR)))\n                throw new BadMessageException(\"Ambiguous segment in URI\");\n            if (uri.hasAmbiguousParameter() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_PARAMETER)))\n                throw new BadMessageException(\"Ambiguous path parameter in URI\");\n        }\n\n        if (uri.isAbsolute() && uri.hasAuthority() && uri.getPath() != null)\n        {\n            _uri = uri;\n        }\n        else\n        {\n            HttpURI.Mutable builder = HttpURI.build(uri);\n\n            if (!uri.isAbsolute())\n                builder.scheme(HttpScheme.HTTP.asString());\n\n            if (uri.getPath() == null)\n                builder.path(\"/\");\n\n            if (!uri.hasAuthority())\n            {\n                HttpField field = getHttpFields().getField(HttpHeader.HOST);\n                if (field instanceof HostPortHttpField)\n                {\n                    HostPortHttpField authority = (HostPortHttpField)field;\n                    builder.host(authority.getHost()).port(authority.getPort());\n                }\n                else\n                {\n                    builder.host(findServerName()).port(findServerPort());\n                }\n            }\n            _uri = builder.asImmutable();\n        }\n\n        setSecure(HttpScheme.HTTPS.is(_uri.getScheme()));\n\n        String encoded = _uri.getPath();\n        String path;\n        if (encoded == null)\n            // TODO this is not really right for CONNECT\n            path = _uri.isAbsolute() ? \"/\" : null;\n        else if (encoded.startsWith(\"/\"))\n        {\n            path = (encoded.length() == 1) ? \"/\" : _uri.getDecodedPath();\n            // Strictly speaking if a URI is legal and encodes ambiguous segments, then they should be\n            // reflected in the decoded string version.  However, it can be ambiguous to provide a decoded path as\n            // a string, so we normalize again.  If an application wishes to see ambiguous URIs, then they can look\n            // at the encoded form of the URI\n            if (ambiguous)\n                path = URIUtil.canonicalPath(path);\n        }\n        else if (\"*\".equals(encoded) || HttpMethod.CONNECT.is(getMethod()))\n            path = encoded;\n        else\n            path = null;\n\n        if (path == null || path.isEmpty())\n        {\n            _pathInContext = encoded == null ? \"\" : encoded;\n            throw new BadMessageException(400, \"Bad URI\");\n        }\n        _pathInContext = path;\n    }", "code_tokens": ["public", "void", "setMetaData", "(", "MetaData", ".", "Request", "request", ")", "{", "if", "(", "_metaData", "==", "null", "&&", "_input", "!=", "null", "&&", "_channel", "!=", "null", ")", "{", "_input", ".", "reopen", "(", ")", ";", "_channel", ".", "getResponse", "(", ")", ".", "getHttpOutput", "(", ")", ".", "reopen", "(", ")", ";", "}", "_metaData", "=", "request", ";", "_method", "=", "request", ".", "getMethod", "(", ")", ";", "_httpFields", "=", "request", ".", "getFields", "(", ")", ";", "final", "HttpURI", "uri", "=", "request", ".", "getURI", "(", ")", ";", "boolean", "ambiguous", "=", "uri", ".", "isAmbiguous", "(", ")", ";", "if", "(", "ambiguous", ")", "{", "UriCompliance", "compliance", "=", "_channel", "==", "null", "||", "_channel", ".", "getHttpConfiguration", "(", ")", "==", "null", "?", "null", ":", "_channel", ".", "getHttpConfiguration", "(", ")", ".", "getUriCompliance", "(", ")", ";", "if", "(", "uri", ".", "hasAmbiguousSegment", "(", ")", "&&", "(", "compliance", "==", "null", "||", "!", "compliance", ".", "allows", "(", "UriCompliance", ".", "Violation", ".", "AMBIGUOUS_PATH_SEGMENT", ")", ")", ")", "throw", "new", "BadMessageException", "(", "\"", "Ambiguous segment in URI", "\"", ")", ";", "if", "(", "uri", ".", "hasAmbiguousSeparator", "(", ")", "&&", "(", "compliance", "==", "null", "||", "!", "compliance", ".", "allows", "(", "UriCompliance", ".", "Violation", ".", "AMBIGUOUS_PATH_SEPARATOR", ")", ")", ")", "throw", "new", "BadMessageException", "(", "\"", "Ambiguous segment in URI", "\"", ")", ";", "if", "(", "uri", ".", "hasAmbiguousParameter", "(", ")", "&&", "(", "compliance", "==", "null", "||", "!", "compliance", ".", "allows", "(", "UriCompliance", ".", "Violation", ".", "AMBIGUOUS_PATH_PARAMETER", ")", ")", ")", "throw", "new", "BadMessageException", "(", "\"", "Ambiguous path parameter in URI", "\"", ")", ";", "}", "if", "(", "uri", ".", "isAbsolute", "(", ")", "&&", "uri", ".", "hasAuthority", "(", ")", "&&", "uri", ".", "getPath", "(", ")", "!=", "null", ")", "{", "_uri", "=", "uri", ";", "}", "else", "{", "HttpURI", ".", "Mutable", "builder", "=", "HttpURI", ".", "build", "(", "uri", ")", ";", "if", "(", "!", "uri", ".", "isAbsolute", "(", ")", ")", "builder", ".", "scheme", "(", "HttpScheme", ".", "HTTP", ".", "asString", "(", ")", ")", ";", "if", "(", "uri", ".", "getPath", "(", ")", "==", "null", ")", "builder", ".", "path", "(", "\"", "/", "\"", ")", ";", "if", "(", "!", "uri", ".", "hasAuthority", "(", ")", ")", "{", "HttpField", "field", "=", "getHttpFields", "(", ")", ".", "getField", "(", "HttpHeader", ".", "HOST", ")", ";", "if", "(", "field", "instanceof", "HostPortHttpField", ")", "{", "HostPortHttpField", "authority", "=", "(", "HostPortHttpField", ")", "field", ";", "builder", ".", "host", "(", "authority", ".", "getHost", "(", ")", ")", ".", "port", "(", "authority", ".", "getPort", "(", ")", ")", ";", "}", "else", "{", "builder", ".", "host", "(", "findServerName", "(", ")", ")", ".", "port", "(", "findServerPort", "(", ")", ")", ";", "}", "}", "_uri", "=", "builder", ".", "asImmutable", "(", ")", ";", "}", "setSecure", "(", "HttpScheme", ".", "HTTPS", ".", "is", "(", "_uri", ".", "getScheme", "(", ")", ")", ")", ";", "String", "encoded", "=", "_uri", ".", "getPath", "(", ")", ";", "String", "path", ";", "if", "(", "encoded", "==", "null", ")", "path", "=", "_uri", ".", "isAbsolute", "(", ")", "?", "\"", "/", "\"", ":", "null", ";", "else", "if", "(", "encoded", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "{", "path", "=", "(", "encoded", ".", "length", "(", ")", "==", "1", ")", "?", "\"", "/", "\"", ":", "_uri", ".", "getDecodedPath", "(", ")", ";", "if", "(", "ambiguous", ")", "path", "=", "URIUtil", ".", "canonicalPath", "(", "path", ")", ";", "}", "else", "if", "(", "\"", "*", "\"", ".", "equals", "(", "encoded", ")", "||", "HttpMethod", ".", "CONNECT", ".", "is", "(", "getMethod", "(", ")", ")", ")", "path", "=", "encoded", ";", "else", "path", "=", "null", ";", "if", "(", "path", "==", "null", "||", "path", ".", "isEmpty", "(", ")", ")", "{", "_pathInContext", "=", "encoded", "==", "null", "?", "\"", "\"", ":", "encoded", ";", "throw", "new", "BadMessageException", "(", "400", ",", "\"", "Bad URI", "\"", ")", ";", "}", "_pathInContext", "=", "path", ";", "}"], "idx": 114808, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "d80c622b005c044e93f585c231b420a29371f6e0", "function_name": "setMetaData", "body_hash": "a68543a8bf1be0dabb8bdc9e9ba54dd60bf4d575"}
{"code": "public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                //unreg(sk,attachment);//only do this if we do process send file on a separate thread\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n                \n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n            }\n            return true;\n        }", "code_tokens": ["public", "boolean", "processSendfile", "(", "SelectionKey", "sk", ",", "KeyAttachment", "attachment", ",", "boolean", "reg", ",", "boolean", "event", ")", "{", "NioChannel", "sc", "=", "null", ";", "try", "{", "SendfileData", "sd", "=", "attachment", ".", "getSendfileData", "(", ")", ";", "if", "(", "sd", ".", "fchannel", "==", "null", ")", "{", "File", "f", "=", "new", "File", "(", "sd", ".", "fileName", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "sd", ".", "fchannel", "=", "new", "FileInputStream", "(", "f", ")", ".", "getChannel", "(", ")", ";", "}", "sc", "=", "attachment", ".", "getChannel", "(", ")", ";", "sc", ".", "setSendFile", "(", "true", ")", ";", "WritableByteChannel", "wc", "=", "(", "(", "sc", "instanceof", "SecureNioChannel", ")", "?", "sc", ":", "sc", ".", "getIOChannel", "(", ")", ")", ";", "if", "(", "sc", ".", "getOutboundRemaining", "(", ")", ">", "0", ")", "{", "if", "(", "sc", ".", "flushOutbound", "(", ")", ")", "{", "attachment", ".", "access", "(", ")", ";", "}", "}", "else", "{", "long", "written", "=", "sd", ".", "fchannel", ".", "transferTo", "(", "sd", ".", "pos", ",", "sd", ".", "length", ",", "wc", ")", ";", "if", "(", "written", ">", "0", ")", "{", "sd", ".", "pos", "+=", "written", ";", "sd", ".", "length", "-=", "written", ";", "attachment", ".", "access", "(", ")", ";", "}", "else", "{", "if", "(", "sd", ".", "fchannel", ".", "size", "(", ")", "<=", "sd", ".", "pos", ")", "{", "throw", "new", "IOException", "(", "\"", "Sendfile configured to ", "\"", "+", "\"", "send more data than was available", "\"", ")", ";", "}", "}", "}", "if", "(", "sd", ".", "length", "<=", "0", "&&", "sc", ".", "getOutboundRemaining", "(", ")", "<=", "0", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file complete for:", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "attachment", ".", "setSendfileData", "(", "null", ")", ";", "try", "{", "sd", ".", "fchannel", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "}", "if", "(", "sd", ".", "keepAlive", ")", "{", "if", "(", "reg", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection is keep alive, registering back for OP_READ", "\"", ")", ";", "}", "if", "(", "event", ")", "{", "this", ".", "add", "(", "attachment", ".", "getChannel", "(", ")", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "}", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file connection is being closed", "\"", ")", ";", "}", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "STOP", ",", "false", ")", ";", "}", "}", "else", "if", "(", "attachment", ".", "interestOps", "(", ")", "==", "0", "&&", "reg", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "OP_WRITE for sendilfe:", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "event", ")", "{", "add", "(", "attachment", ".", "getChannel", "(", ")", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "}", "}", "catch", "(", "IOException", "x", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Unable to complete sendfile request:", "\"", ",", "x", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"", "\"", ",", "t", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "finally", "{", "if", "(", "sc", "!=", "null", ")", "sc", ".", "setSendFile", "(", "false", ")", ";", "}", "return", "true", ";", "}"], "idx": 8250, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "48dded4ab1209a030770ab67a789d3b2528b6329", "function_name": "processSendfile", "body_hash": "36639b78258dfc5e852a2cfe17e5dbcad6dc86a0"}
{"code": "@SuppressRestrictedWarnings(XMLUtils.class) // TODO remove when baseline > 2.179\n\tprotected Document getDocument(URL url) throws StageException {\n\t\ttry {\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t\t\taddAuthHeader(conn);\n\t\t\tconn.setRequestProperty(\"Accept\", \"application/xml\");\n\t\t\tint status = conn.getResponseCode();\n\t\t\tif (status == HttpURLConnection.HTTP_OK) {\n\t\t\t\ttry (InputStream is = conn.getInputStream(); InputStreamReader isr = new InputStreamReader(is, StandardCharsets.UTF_8)) {\n\t\t\t\t\tDocument doc = XMLUtils.parse(isr);\n\t\t\t\t\tconn.disconnect();\n\t\t\t\t\treturn doc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdrainOutput(conn);\n\t\t\t\tif (status == HttpURLConnection.HTTP_UNAUTHORIZED) {\n\t\t\t\t\tthrow new IOException(\"Incorrect username / password supplied.\");\n\t\t\t\t}\n\t\t\t\telse if (status == HttpURLConnection.HTTP_NOT_FOUND) {\n\t\t\t\t\tthrow new IOException(\"Document not found - is this a Nexus server?\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IOException(\"Server returned error code \" + status + \" for \" + url.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow createStageExceptionForIOException(nexusURL, ex);\n\t\t}\n\t\tcatch (SAXException ex) {\n\t\t\tthrow new StageException(ex);\n\t\t}\n\n\t}", "code_tokens": ["@", "SuppressRestrictedWarnings", "(", "XMLUtils", ".", "class", ")", "protected", "Document", "getDocument", "(", "URL", "url", ")", "throws", "StageException", "{", "try", "{", "HttpURLConnection", "conn", "=", "(", "HttpURLConnection", ")", "url", ".", "openConnection", "(", ")", ";", "addAuthHeader", "(", "conn", ")", ";", "conn", ".", "setRequestProperty", "(", "\"", "Accept", "\"", ",", "\"", "application/xml", "\"", ")", ";", "int", "status", "=", "conn", ".", "getResponseCode", "(", ")", ";", "if", "(", "status", "==", "HttpURLConnection", ".", "HTTP_OK", ")", "{", "try", "(", "InputStream", "is", "=", "conn", ".", "getInputStream", "(", ")", ";", "InputStreamReader", "isr", "=", "new", "InputStreamReader", "(", "is", ",", "StandardCharsets", ".", "UTF_8", ")", ")", "{", "Document", "doc", "=", "XMLUtils", ".", "parse", "(", "isr", ")", ";", "conn", ".", "disconnect", "(", ")", ";", "return", "doc", ";", "}", "}", "else", "{", "drainOutput", "(", "conn", ")", ";", "if", "(", "status", "==", "HttpURLConnection", ".", "HTTP_UNAUTHORIZED", ")", "{", "throw", "new", "IOException", "(", "\"", "Incorrect username / password supplied.", "\"", ")", ";", "}", "else", "if", "(", "status", "==", "HttpURLConnection", ".", "HTTP_NOT_FOUND", ")", "{", "throw", "new", "IOException", "(", "\"", "Document not found - is this a Nexus server?", "\"", ")", ";", "}", "else", "{", "throw", "new", "IOException", "(", "\"", "Server returned error code ", "\"", "+", "status", "+", "\"", " for ", "\"", "+", "url", ".", "toString", "(", ")", ")", ";", "}", "}", "}", "catch", "(", "IOException", "ex", ")", "{", "throw", "createStageExceptionForIOException", "(", "nexusURL", ",", "ex", ")", ";", "}", "catch", "(", "SAXException", "ex", ")", "{", "throw", "new", "StageException", "(", "ex", ")", ";", "}", "}"], "idx": 69555, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "1e4d6fe", "function_name": "getDocument", "body_hash": "edaf78c0bb701c349c7d4d7318dfaf7bbf85ec2f"}
{"code": "public FormValidation doMatchText(\n                @QueryParameter(\"pattern\") final String testPattern,\n                @QueryParameter(\"testText\") String testText,\n                @QueryParameter(\"textSourceIsUrl\") final boolean textSourceIsUrl) {\n            if (textSourceIsUrl) {\n                testText = testText.replaceAll(\"/\\\\./\", \"/\").replaceAll(\"/view/change-requests\", \"\");\n                Matcher urlMatcher = URL_PATTERN.matcher(testText);\n                if (urlMatcher.matches()) {\n                    String[] urlParts = new String[NUM_OF_URL_PARTS];\n                    for (int i = 0; i < urlParts.length; i++) {\n                        urlParts[i] = urlMatcher.group(i + 1);\n                    }\n\n                    Run build = null;\n                    ItemGroup getItemInstance;\n\n                    if (urlParts[0].split(\"/job/\").length > 1) {\n                        /*\n                         * We matched a folders job. Let's get the jobs up to the part were the next\n                         * iteration can be continued from\n                         */\n                        StringBuilder fullFolderName = new StringBuilder();\n                        /* The interestingJobParts string created below is meant to discard everything\n                         * that comes before the first '/job' occurrent which is either nothing or the\n                         * prefix from where jenkins is served, ie: http://localhost/jenkins/job/<job>/<buildNumber>\n                         */\n                        String[] interestingJobParts = urlParts[0].split(\"/job/\", 2);\n                        String[] jobParts = interestingJobParts[interestingJobParts.length - 1].split(\"/job/\");\n                        for (String part: jobParts) {\n                            fullFolderName.append(\"/\").append(part);\n                        }\n                        getItemInstance = (ItemGroup)Jenkins.getInstance().getItemByFullName(fullFolderName.toString());\n                    } else {\n                        getItemInstance = (ItemGroup)Jenkins.getInstance();\n                    }\n\n                    if (getItemInstance == null) {\n                        throw new AssertionError(\"Folder not found!\");\n                    }\n\n                    /*\n                       Find out which of the following url types testText matches, if any,\n                       and assign to build accordingly. The url types are checked in the\n                       given order.\n                       Type 1: .../<job>/<buildNumber>/\n                       Type 2: .../<job>/<matrixInfo>/<buildNumber>/\n                       Type 3: .../<job>/<buildNumber>/<matrixInfo>/\n                     */\n\n                    final Item itemFromPart2 = getItemInstance.getItem(urlParts[2]);\n                    if (itemFromPart2 instanceof Job\n                            && isValidBuildId(urlParts[3])) {\n                        Job project = (Job)itemFromPart2;\n                        build = getBuildById(project, urlParts[3]);\n                    } else {\n                        final Item itemFromPart1 = getItemInstance.getItem(urlParts[1]);\n                        if (itemFromPart1 instanceof MatrixProject\n                                && isValidBuildId(urlParts[3])) {\n                            MatrixProject project = (MatrixProject)itemFromPart1;\n                            MatrixConfiguration configuration = project.getItem(urlParts[2]);\n                            build = getBuildById(configuration, urlParts[3]);\n                        } else if (itemFromPart1 instanceof MatrixProject\n                                && isValidBuildId(urlParts[2])) {\n                            MatrixProject matrixProject = (MatrixProject)itemFromPart1;\n                            MatrixConfiguration configuration = matrixProject.getItem(urlParts[3]);\n                            build = getBuildById(configuration, urlParts[2]);\n                        }\n                    }\n                    if (build != null) {\n                        try {\n                            final FailureReader failureReader = getFailureReader(testPattern);\n                            final FoundIndication foundIndication = failureReader.scan(build);\n                            if (foundIndication == null) {\n                                return FormValidation.warning(Messages.StringDoesNotMatchPattern());\n                            }\n                            return FormValidation.okWithMarkup(foundIndication.getFirstMatchingLine());\n                        } catch (IOException e) {\n                            return FormValidation.error(Messages.FailedToScanFile_Error());\n                        }\n                    }\n                }\n                return FormValidation.error(Messages.InvalidURL_Error());\n            } else {\n                try {\n                    if (testText.matches(testPattern)) {\n                        return FormValidation.ok(Messages.StringMatchesPattern());\n                    }\n                    return FormValidation.warning(Messages.StringDoesNotMatchPattern());\n                } catch (PatternSyntaxException e) {\n                    return FormValidation.error(Messages.InvalidPattern_Error());\n                }\n            }\n        }", "code_tokens": ["public", "FormValidation", "doMatchText", "(", "@", "QueryParameter", "(", "\"", "pattern", "\"", ")", "final", "String", "testPattern", ",", "@", "QueryParameter", "(", "\"", "testText", "\"", ")", "String", "testText", ",", "@", "QueryParameter", "(", "\"", "textSourceIsUrl", "\"", ")", "final", "boolean", "textSourceIsUrl", ")", "{", "if", "(", "textSourceIsUrl", ")", "{", "testText", "=", "testText", ".", "replaceAll", "(", "\"", "/", "\\\\", "./", "\"", ",", "\"", "/", "\"", ")", ".", "replaceAll", "(", "\"", "/view/change-requests", "\"", ",", "\"", "\"", ")", ";", "Matcher", "urlMatcher", "=", "URL_PATTERN", ".", "matcher", "(", "testText", ")", ";", "if", "(", "urlMatcher", ".", "matches", "(", ")", ")", "{", "String", "[", "]", "urlParts", "=", "new", "String", "[", "NUM_OF_URL_PARTS", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "urlParts", ".", "length", ";", "i", "++", ")", "{", "urlParts", "[", "i", "]", "=", "urlMatcher", ".", "group", "(", "i", "+", "1", ")", ";", "}", "Run", "build", "=", "null", ";", "ItemGroup", "getItemInstance", ";", "if", "(", "urlParts", "[", "0", "]", ".", "split", "(", "\"", "/job/", "\"", ")", ".", "length", ">", "1", ")", "{", "StringBuilder", "fullFolderName", "=", "new", "StringBuilder", "(", ")", ";", "String", "[", "]", "interestingJobParts", "=", "urlParts", "[", "0", "]", ".", "split", "(", "\"", "/job/", "\"", ",", "2", ")", ";", "String", "[", "]", "jobParts", "=", "interestingJobParts", "[", "interestingJobParts", ".", "length", "-", "1", "]", ".", "split", "(", "\"", "/job/", "\"", ")", ";", "for", "(", "String", "part", ":", "jobParts", ")", "{", "fullFolderName", ".", "append", "(", "\"", "/", "\"", ")", ".", "append", "(", "part", ")", ";", "}", "getItemInstance", "=", "(", "ItemGroup", ")", "Jenkins", ".", "getInstance", "(", ")", ".", "getItemByFullName", "(", "fullFolderName", ".", "toString", "(", ")", ")", ";", "}", "else", "{", "getItemInstance", "=", "(", "ItemGroup", ")", "Jenkins", ".", "getInstance", "(", ")", ";", "}", "if", "(", "getItemInstance", "==", "null", ")", "{", "throw", "new", "AssertionError", "(", "\"", "Folder not found!", "\"", ")", ";", "}", "final", "Item", "itemFromPart2", "=", "getItemInstance", ".", "getItem", "(", "urlParts", "[", "2", "]", ")", ";", "if", "(", "itemFromPart2", "instanceof", "Job", "&&", "isValidBuildId", "(", "urlParts", "[", "3", "]", ")", ")", "{", "Job", "project", "=", "(", "Job", ")", "itemFromPart2", ";", "build", "=", "getBuildById", "(", "project", ",", "urlParts", "[", "3", "]", ")", ";", "}", "else", "{", "final", "Item", "itemFromPart1", "=", "getItemInstance", ".", "getItem", "(", "urlParts", "[", "1", "]", ")", ";", "if", "(", "itemFromPart1", "instanceof", "MatrixProject", "&&", "isValidBuildId", "(", "urlParts", "[", "3", "]", ")", ")", "{", "MatrixProject", "project", "=", "(", "MatrixProject", ")", "itemFromPart1", ";", "MatrixConfiguration", "configuration", "=", "project", ".", "getItem", "(", "urlParts", "[", "2", "]", ")", ";", "build", "=", "getBuildById", "(", "configuration", ",", "urlParts", "[", "3", "]", ")", ";", "}", "else", "if", "(", "itemFromPart1", "instanceof", "MatrixProject", "&&", "isValidBuildId", "(", "urlParts", "[", "2", "]", ")", ")", "{", "MatrixProject", "matrixProject", "=", "(", "MatrixProject", ")", "itemFromPart1", ";", "MatrixConfiguration", "configuration", "=", "matrixProject", ".", "getItem", "(", "urlParts", "[", "3", "]", ")", ";", "build", "=", "getBuildById", "(", "configuration", ",", "urlParts", "[", "2", "]", ")", ";", "}", "}", "if", "(", "build", "!=", "null", ")", "{", "try", "{", "final", "FailureReader", "failureReader", "=", "getFailureReader", "(", "testPattern", ")", ";", "final", "FoundIndication", "foundIndication", "=", "failureReader", ".", "scan", "(", "build", ")", ";", "if", "(", "foundIndication", "==", "null", ")", "{", "return", "FormValidation", ".", "warning", "(", "Messages", ".", "StringDoesNotMatchPattern", "(", ")", ")", ";", "}", "return", "FormValidation", ".", "okWithMarkup", "(", "foundIndication", ".", "getFirstMatchingLine", "(", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "FailedToScanFile_Error", "(", ")", ")", ";", "}", "}", "}", "return", "FormValidation", ".", "error", "(", "Messages", ".", "InvalidURL_Error", "(", ")", ")", ";", "}", "else", "{", "try", "{", "if", "(", "testText", ".", "matches", "(", "testPattern", ")", ")", "{", "return", "FormValidation", ".", "ok", "(", "Messages", ".", "StringMatchesPattern", "(", ")", ")", ";", "}", "return", "FormValidation", ".", "warning", "(", "Messages", ".", "StringDoesNotMatchPattern", "(", ")", ")", ";", "}", "catch", "(", "PatternSyntaxException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "InvalidPattern_Error", "(", ")", ")", ";", "}", "}", "}"], "idx": 52795, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "f316c88", "function_name": "doMatchText", "body_hash": "1fa72a97ac6996a9cc8f855f45a7cc8abd12d707"}
{"code": "@SuppressWarnings(\"unchecked\")\n\tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n\n\t\tClass<?> returnValueClass = returnValue.getClass();\n\t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n\n\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n\t\t}\n\n\t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType = null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType = mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType != null) {\n\t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n\t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n\t}", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "protected", "<", "T", ">", "void", "writeWithMessageConverters", "(", "T", "returnValue", ",", "MethodParameter", "returnType", ",", "ServletServerHttpRequest", "inputMessage", ",", "ServletServerHttpResponse", "outputMessage", ")", "throws", "IOException", ",", "HttpMediaTypeNotAcceptableException", "{", "Class", "<", "?", ">", "returnValueClass", "=", "returnValue", ".", "getClass", "(", ")", ";", "HttpServletRequest", "servletRequest", "=", "inputMessage", ".", "getServletRequest", "(", ")", ";", "List", "<", "MediaType", ">", "requestedMediaTypes", "=", "getAcceptableMediaTypes", "(", "servletRequest", ")", ";", "List", "<", "MediaType", ">", "producibleMediaTypes", "=", "getProducibleMediaTypes", "(", "servletRequest", ",", "returnValueClass", ")", ";", "Set", "<", "MediaType", ">", "compatibleMediaTypes", "=", "new", "LinkedHashSet", "<", "MediaType", ">", "(", ")", ";", "for", "(", "MediaType", "requestedType", ":", "requestedMediaTypes", ")", "{", "for", "(", "MediaType", "producibleType", ":", "producibleMediaTypes", ")", "{", "if", "(", "requestedType", ".", "isCompatibleWith", "(", "producibleType", ")", ")", "{", "compatibleMediaTypes", ".", "add", "(", "getMostSpecificMediaType", "(", "requestedType", ",", "producibleType", ")", ")", ";", "}", "}", "}", "if", "(", "compatibleMediaTypes", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "HttpMediaTypeNotAcceptableException", "(", "producibleMediaTypes", ")", ";", "}", "List", "<", "MediaType", ">", "mediaTypes", "=", "new", "ArrayList", "<", "MediaType", ">", "(", "compatibleMediaTypes", ")", ";", "MediaType", ".", "sortBySpecificityAndQuality", "(", "mediaTypes", ")", ";", "MediaType", "selectedMediaType", "=", "null", ";", "for", "(", "MediaType", "mediaType", ":", "mediaTypes", ")", "{", "if", "(", "mediaType", ".", "isConcrete", "(", ")", ")", "{", "selectedMediaType", "=", "mediaType", ";", "break", ";", "}", "else", "if", "(", "mediaType", ".", "equals", "(", "MediaType", ".", "ALL", ")", "||", "mediaType", ".", "equals", "(", "MEDIA_TYPE_APPLICATION", ")", ")", "{", "selectedMediaType", "=", "MediaType", ".", "APPLICATION_OCTET_STREAM", ";", "break", ";", "}", "}", "if", "(", "selectedMediaType", "!=", "null", ")", "{", "selectedMediaType", "=", "selectedMediaType", ".", "removeQualityValue", "(", ")", ";", "for", "(", "HttpMessageConverter", "<", "?", ">", "messageConverter", ":", "this", ".", "messageConverters", ")", "{", "if", "(", "messageConverter", ".", "canWrite", "(", "returnValueClass", ",", "selectedMediaType", ")", ")", "{", "(", "(", "HttpMessageConverter", "<", "T", ">", ")", "messageConverter", ")", ".", "write", "(", "returnValue", ",", "selectedMediaType", ",", "outputMessage", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Written [", "\"", "+", "returnValue", "+", "\"", "] as ", "\\\"", "\"", "+", "selectedMediaType", "+", "\"", "\\\"", " using [", "\"", "+", "messageConverter", "+", "\"", "]", "\"", ")", ";", "}", "return", ";", "}", "}", "}", "throw", "new", "HttpMediaTypeNotAcceptableException", "(", "this", ".", "allSupportedMediaTypes", ")", ";", "}"], "idx": 64798, "cwe": "CWE-552", "target": 1, "status": "VULNERABLE", "commit": "03f547eb9868f48f44d59b56067d4ac4740672c3", "function_name": "writeWithMessageConverters", "body_hash": "c0df276b495d38d59e370c478ccad4328eccbcb7"}
{"code": "public R execute(HttpResponseProcessor<R> responseProcessor) {\n        byte[] bytes = null;\n\n        try {\n            for (Map.Entry<String, String> header : this.headers.entrySet()) {\n                this.builder.setHeader(header.getKey(), header.getValue());\n            }\n\n            preExecute(this.builder);\n\n            HttpResponse response = this.httpClient.execute(this.builder.build());\n            HttpEntity entity = response.getEntity();\n\n            if (entity != null) {\n                bytes = EntityUtils.toByteArray(entity);\n            }\n\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n\n            if (statusCode < 200 || statusCode >= 300) {\n                throw new HttpResponseException(\"Unexpected response from server: \" + statusCode + \" / \" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);\n            }\n\n            if (bytes == null) {\n                return null;\n            }\n\n            return responseProcessor.process(bytes);\n        } catch (HttpResponseException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing http method [\" + builder.getMethod() + \"]. Response : \" + String.valueOf(bytes), e);\n        }\n    }", "code_tokens": ["public", "R", "execute", "(", "HttpResponseProcessor", "<", "R", ">", "responseProcessor", ")", "{", "byte", "[", "]", "bytes", "=", "null", ";", "try", "{", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "header", ":", "this", ".", "headers", ".", "entrySet", "(", ")", ")", "{", "this", ".", "builder", ".", "setHeader", "(", "header", ".", "getKey", "(", ")", ",", "header", ".", "getValue", "(", ")", ")", ";", "}", "preExecute", "(", "this", ".", "builder", ")", ";", "HttpResponse", "response", "=", "this", ".", "httpClient", ".", "execute", "(", "this", ".", "builder", ".", "build", "(", ")", ")", ";", "HttpEntity", "entity", "=", "response", ".", "getEntity", "(", ")", ";", "if", "(", "entity", "!=", "null", ")", "{", "bytes", "=", "EntityUtils", ".", "toByteArray", "(", "entity", ")", ";", "}", "StatusLine", "statusLine", "=", "response", ".", "getStatusLine", "(", ")", ";", "int", "statusCode", "=", "statusLine", ".", "getStatusCode", "(", ")", ";", "if", "(", "statusCode", "<", "200", "||", "statusCode", ">=", "300", ")", "{", "throw", "new", "HttpResponseException", "(", "\"", "Unexpected response from server: ", "\"", "+", "statusCode", "+", "\"", " / ", "\"", "+", "statusLine", ".", "getReasonPhrase", "(", ")", ",", "statusCode", ",", "statusLine", ".", "getReasonPhrase", "(", ")", ",", "bytes", ")", ";", "}", "if", "(", "bytes", "==", "null", ")", "{", "return", "null", ";", "}", "return", "responseProcessor", ".", "process", "(", "bytes", ")", ";", "}", "catch", "(", "HttpResponseException", "e", ")", "{", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Error executing http method [", "\"", "+", "builder", ".", "getMethod", "(", ")", "+", "\"", "]. Response : ", "\"", "+", "String", ".", "valueOf", "(", "bytes", ")", ",", "e", ")", ";", "}", "}"], "idx": 63951, "cwe": "CWE-532", "target": 0, "status": "FIXED", "commit": "62c9e15776", "function_name": "execute", "body_hash": "549c9fda37e7b82a9d05733e37207c4196b50670"}
{"code": "public static String checkParameter(String commandParameter) {\n        String repaired = commandParameter.replaceAll(COMMAND_INJECT_REX, \"\");\n        if (repaired.length() != commandParameter.length()) {\n            logger.info(\"Detected illegal character in command {}, replace it to {}.\", commandParameter, repaired);\n        }\n        return repaired;\n    }", "code_tokens": ["public", "static", "String", "checkParameter", "(", "String", "commandParameter", ")", "{", "String", "repaired", "=", "commandParameter", ".", "replaceAll", "(", "COMMAND_INJECT_REX", ",", "\"", "\"", ")", ";", "if", "(", "repaired", ".", "length", "(", ")", "!=", "commandParameter", ".", "length", "(", ")", ")", "{", "logger", ".", "info", "(", "\"", "Detected illegal character in command {}, replace it to {}.", "\"", ",", "commandParameter", ",", "repaired", ")", ";", "}", "return", "repaired", ";", "}"], "idx": 76687, "cwe": "CWE-78", "target": 1, "status": "VULNERABLE", "commit": "0888c867a52479840a6f3fcd812f9305a95b8dfd", "function_name": "checkParameter", "body_hash": "2828657c7cc119ee35b50457efa40a4510c33d66"}
{"code": "private static FormValidation _error(Kind kind, Throwable e, String message) {\n        if (e==null)    return _errorWithMarkup(Util.escape(message),kind);\n\n        return _errorWithMarkup(Util.escape(message)+\n            \" <a href='#' class='showDetails'>\"\n            + Messages.FormValidation_Error_Details()\n            + \"</a><pre style='display:none'>\"\n            + Functions.printThrowable(e) +\n            \"</pre>\",kind\n        );\n    }", "code_tokens": ["private", "static", "FormValidation", "_error", "(", "Kind", "kind", ",", "Throwable", "e", ",", "String", "message", ")", "{", "if", "(", "e", "==", "null", ")", "return", "_errorWithMarkup", "(", "Util", ".", "escape", "(", "message", ")", ",", "kind", ")", ";", "return", "_errorWithMarkup", "(", "Util", ".", "escape", "(", "message", ")", "+", "\"", " <a href='#' class='showDetails'>", "\"", "+", "Messages", ".", "FormValidation_Error_Details", "(", ")", "+", "\"", "</a><pre style='display:none'>", "\"", "+", "Functions", ".", "printThrowable", "(", "e", ")", "+", "\"", "</pre>", "\"", ",", "kind", ")", ";", "}"], "idx": 79053, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "feb2703adb0c121705e5c8e9ddf8f663b6481cbd", "function_name": "_error", "body_hash": "f4acfa1693dbc3af9ed41fd5f8dc787dbd76bd79"}
{"code": "public T readFrom(Class<T> clazz, Type t, Annotation[] a, MediaType mt, \n                         MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        Parser parser = ATOM_ENGINE.getParser();\n        synchronized (parser) {\n            ParserOptions options = parser.getDefaultParserOptions();\n            if (options != null) {\n                options.setAutodetectCharset(autodetectCharset);\n            }\n        }\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(is);\n        Document<T> doc = parser.parse(reader);\n        return doc.getRoot();\n    }", "code_tokens": ["public", "T", "readFrom", "(", "Class", "<", "T", ">", "clazz", ",", "Type", "t", ",", "Annotation", "[", "]", "a", ",", "MediaType", "mt", ",", "MultivaluedMap", "<", "String", ",", "String", ">", "headers", ",", "InputStream", "is", ")", "throws", "IOException", "{", "Parser", "parser", "=", "ATOM_ENGINE", ".", "getParser", "(", ")", ";", "synchronized", "(", "parser", ")", "{", "ParserOptions", "options", "=", "parser", ".", "getDefaultParserOptions", "(", ")", ";", "if", "(", "options", "!=", "null", ")", "{", "options", ".", "setAutodetectCharset", "(", "autodetectCharset", ")", ";", "}", "}", "XMLStreamReader", "reader", "=", "StaxUtils", ".", "createXMLStreamReader", "(", "is", ")", ";", "Document", "<", "T", ">", "doc", "=", "parser", ".", "parse", "(", "reader", ")", ";", "return", "doc", ".", "getRoot", "(", ")", ";", "}"], "idx": 68638, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "8e4970d9", "function_name": "readFrom", "body_hash": "3680a911b21553d7cb9ac3a030e30efff5e5cee2"}
{"code": "@Bean\n    public Server rsServer() {\n        JAXRSServerFactoryBean endpoint = new JAXRSServerFactoryBean();\n        endpoint.setBus(bus);\n        endpoint.setServiceBeans(Arrays.<Object>asList(new HelloServiceImpl1(), new HelloServiceImpl2()));\n        endpoint.setAddress(\"/\");\n        endpoint.setFeatures(Arrays.asList(new Swagger2Feature()));\n        return endpoint.create();\n    }", "code_tokens": ["@", "Bean", "public", "Server", "rsServer", "(", ")", "{", "JAXRSServerFactoryBean", "endpoint", "=", "new", "JAXRSServerFactoryBean", "(", ")", ";", "endpoint", ".", "setBus", "(", "bus", ")", ";", "endpoint", ".", "setServiceBeans", "(", "Arrays", ".", "<", "Object", ">", "asList", "(", "new", "HelloServiceImpl1", "(", ")", ",", "new", "HelloServiceImpl2", "(", ")", ")", ")", ";", "endpoint", ".", "setAddress", "(", "\"", "/", "\"", ")", ";", "endpoint", ".", "setFeatures", "(", "Arrays", ".", "asList", "(", "new", "Swagger2Feature", "(", ")", ")", ")", ";", "return", "endpoint", ".", "create", "(", ")", ";", "}"], "idx": 79118, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "1f824d80", "function_name": "rsServer", "body_hash": "4f942589ef7c00bb4063d3a9a972ec3734ad145c"}
{"code": "public Object eval(String xml, String path, QName qname) {\n    if (xml == null || path == null || qname == null) {\n      return null;\n    }\n\n    if (xml.length() == 0 || path.length() == 0) {\n      return null;\n    }\n\n    if (!path.equals(oldPath)) {\n      try {\n        expression = xpath.compile(path);\n      } catch (XPathExpressionException e) {\n        expression = null;\n      }\n      oldPath = path;\n    }\n\n    if (expression == null) {\n      return null;\n    }\n\n    if (builder == null){\n      try {\n        initializeDocumentBuilderFactory();\n        builder = dbf.newDocumentBuilder();\n      } catch (ParserConfigurationException e) {\n        throw new RuntimeException(\"Error instantiating DocumentBuilder, cannot build xml parser\", e);\n      }\n    }\n\n    reader.set(xml);\n\n    try {\n      return expression.evaluate(builder.parse(inputSource), qname);\n    } catch (XPathExpressionException e) {\n      throw new RuntimeException (\"Invalid expression '\" + oldPath + \"'\", e);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Error loading expression '\" + oldPath + \"'\", e);\n    }\n  }", "code_tokens": ["public", "Object", "eval", "(", "String", "xml", ",", "String", "path", ",", "QName", "qname", ")", "{", "if", "(", "xml", "==", "null", "||", "path", "==", "null", "||", "qname", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "xml", ".", "length", "(", ")", "==", "0", "||", "path", ".", "length", "(", ")", "==", "0", ")", "{", "return", "null", ";", "}", "if", "(", "!", "path", ".", "equals", "(", "oldPath", ")", ")", "{", "try", "{", "expression", "=", "xpath", ".", "compile", "(", "path", ")", ";", "}", "catch", "(", "XPathExpressionException", "e", ")", "{", "expression", "=", "null", ";", "}", "oldPath", "=", "path", ";", "}", "if", "(", "expression", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "builder", "==", "null", ")", "{", "try", "{", "initializeDocumentBuilderFactory", "(", ")", ";", "builder", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Error instantiating DocumentBuilder, cannot build xml parser", "\"", ",", "e", ")", ";", "}", "}", "reader", ".", "set", "(", "xml", ")", ";", "try", "{", "return", "expression", ".", "evaluate", "(", "builder", ".", "parse", "(", "inputSource", ")", ",", "qname", ")", ";", "}", "catch", "(", "XPathExpressionException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Invalid expression '", "\"", "+", "oldPath", "+", "\"", "'", "\"", ",", "e", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Error loading expression '", "\"", "+", "oldPath", "+", "\"", "'", "\"", ",", "e", ")", ";", "}", "}"], "idx": 18598, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "b0a58d245875dc1b3ac58a7cf1a61d3b17805e96", "function_name": "eval", "body_hash": "7124488172c3d727478b3752e5fcc168c89b6fee"}
{"code": "public void execute(final FunctionContext context) {\n    CliFunctionResult result;\n    String memberId = context.getCache().getDistributedSystem().getDistributedMember().getId();\n    try {\n      LuceneDestroyIndexInfo indexInfo = (LuceneDestroyIndexInfo) context.getArguments();\n      String indexName = indexInfo.getIndexName();\n      String regionPath = indexInfo.getRegionPath();\n      LuceneService service = LuceneServiceProvider.get(context.getCache());\n      if (indexName == null) {\n        if (indexInfo.isDefinedDestroyOnly()) {\n          ((LuceneServiceImpl) service).destroyDefinedIndexes(regionPath);\n          result = new CliFunctionResult(memberId);\n        } else {\n          service.destroyIndexes(regionPath);\n          result = new CliFunctionResult(memberId, getXmlEntity(indexName, regionPath));\n        }\n      } else {\n        if (indexInfo.isDefinedDestroyOnly()) {\n          ((LuceneServiceImpl) service).destroyDefinedIndex(indexName, regionPath);\n          result = new CliFunctionResult(memberId);\n        } else {\n          service.destroyIndex(indexName, regionPath);\n          result = new CliFunctionResult(memberId, getXmlEntity(indexName, regionPath));\n        }\n      }\n    } catch (Exception e) {\n      result = new CliFunctionResult(memberId, e, e.getMessage());\n    }\n    context.getResultSender().lastResult(result);\n  }", "code_tokens": ["public", "void", "execute", "(", "final", "FunctionContext", "context", ")", "{", "CliFunctionResult", "result", ";", "String", "memberId", "=", "context", ".", "getCache", "(", ")", ".", "getDistributedSystem", "(", ")", ".", "getDistributedMember", "(", ")", ".", "getId", "(", ")", ";", "try", "{", "LuceneDestroyIndexInfo", "indexInfo", "=", "(", "LuceneDestroyIndexInfo", ")", "context", ".", "getArguments", "(", ")", ";", "String", "indexName", "=", "indexInfo", ".", "getIndexName", "(", ")", ";", "String", "regionPath", "=", "indexInfo", ".", "getRegionPath", "(", ")", ";", "LuceneService", "service", "=", "LuceneServiceProvider", ".", "get", "(", "context", ".", "getCache", "(", ")", ")", ";", "if", "(", "indexName", "==", "null", ")", "{", "if", "(", "indexInfo", ".", "isDefinedDestroyOnly", "(", ")", ")", "{", "(", "(", "LuceneServiceImpl", ")", "service", ")", ".", "destroyDefinedIndexes", "(", "regionPath", ")", ";", "result", "=", "new", "CliFunctionResult", "(", "memberId", ")", ";", "}", "else", "{", "service", ".", "destroyIndexes", "(", "regionPath", ")", ";", "result", "=", "new", "CliFunctionResult", "(", "memberId", ",", "getXmlEntity", "(", "indexName", ",", "regionPath", ")", ")", ";", "}", "}", "else", "{", "if", "(", "indexInfo", ".", "isDefinedDestroyOnly", "(", ")", ")", "{", "(", "(", "LuceneServiceImpl", ")", "service", ")", ".", "destroyDefinedIndex", "(", "indexName", ",", "regionPath", ")", ";", "result", "=", "new", "CliFunctionResult", "(", "memberId", ")", ";", "}", "else", "{", "service", ".", "destroyIndex", "(", "indexName", ",", "regionPath", ")", ";", "result", "=", "new", "CliFunctionResult", "(", "memberId", ",", "getXmlEntity", "(", "indexName", ",", "regionPath", ")", ")", ";", "}", "}", "}", "catch", "(", "Exception", "e", ")", "{", "result", "=", "new", "CliFunctionResult", "(", "memberId", ",", "e", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "context", ".", "getResultSender", "(", ")", ".", "lastResult", "(", "result", ")", ";", "}"], "idx": 88201, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "740289c61d60256c6270756bc84b9e24b76e4913", "function_name": "execute", "body_hash": "8ac274da7991cd48c5d5fae137b1c5f98b03f548"}
{"code": "public Object map2bean(final Map map, Class targetType) {\n\t\tObject target = null;\n\n\t\t// create targets type\n\t\tString className = (String) map.get(classMetadataName);\n\n\t\tif (className == null) {\n\t\t\tif (targetType == null) {\n\t\t\t\t// nothing to do, no information about target type found\n\t\t\t\ttarget = map;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\ttargetType = ClassLoaderUtil.loadClass(className);\n\t\t\t} catch (ClassNotFoundException cnfex) {\n\t\t\t\tthrow new JsonException(cnfex);\n\t\t\t}\n\t\t}\n\n\t\tif (target == null) {\n\t\t\ttarget = jsonParser.newObjectInstance(targetType);\n\t\t}\n\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());\n\n\t\tboolean targetIsMap = target instanceof Map;\n\n\t\tfor (Object key : map.keySet()) {\n\t\t\tString keyName = key.toString();\n\n\t\t\tif (classMetadataName != null) {\n\t\t\t\tif (keyName.equals(classMetadataName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared);\n\n\t\t\tif (!targetIsMap && pd == null) {\n\t\t\t\t// target property does not exist, continue\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// value is one of JSON basic types, like Number, Map, List...\n\t\t\tObject value = map.get(key);\n\n\t\t\tClass propertyType = pd == null ? null : pd.getType();\n\t\t\tClass componentType = pd == null ? null : pd.resolveComponentType(true);\n\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof List) {\n\t\t\t\t\tif (componentType != null && componentType != String.class) {\n\t\t\t\t\t\tvalue = generifyList((List) value, componentType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (value instanceof Map) {\n\t\t\t\t\t// if the value we want to inject is a Map...\n\t\t\t\t\tif (!ClassUtil.isTypeOf(propertyType, Map.class)) {\n\t\t\t\t\t\t// ... and if target is NOT a map\n\t\t\t\t\t\tvalue = map2bean((Map) value, propertyType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// target is also a Map, but we might need to generify it\n\t\t\t\t\t\tClass keyType = pd == null ? null : pd.resolveKeyType(true);\n\n\t\t\t\t\t\tif (keyType != String.class || componentType != String.class) {\n\t\t\t\t\t\t\t// generify\n\t\t\t\t\t\t\tvalue = generifyMap((Map) value, keyType, componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (targetIsMap) {\n\t\t\t\t((Map)target).put(keyName, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tsetValue(target, pd, value);\n\t\t\t\t} catch (Exception ignore) {\n\t\t\t\t\tignore.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}", "code_tokens": ["public", "Object", "map2bean", "(", "final", "Map", "map", ",", "Class", "targetType", ")", "{", "Object", "target", "=", "null", ";", "String", "className", "=", "(", "String", ")", "map", ".", "get", "(", "classMetadataName", ")", ";", "if", "(", "className", "==", "null", ")", "{", "if", "(", "targetType", "==", "null", ")", "{", "target", "=", "map", ";", "}", "}", "else", "{", "try", "{", "targetType", "=", "ClassLoaderUtil", ".", "loadClass", "(", "className", ")", ";", "}", "catch", "(", "ClassNotFoundException", "cnfex", ")", "{", "throw", "new", "JsonException", "(", "cnfex", ")", ";", "}", "}", "if", "(", "target", "==", "null", ")", "{", "target", "=", "jsonParser", ".", "newObjectInstance", "(", "targetType", ")", ";", "}", "ClassDescriptor", "cd", "=", "ClassIntrospector", ".", "get", "(", ")", ".", "lookup", "(", "target", ".", "getClass", "(", ")", ")", ";", "boolean", "targetIsMap", "=", "target", "instanceof", "Map", ";", "for", "(", "Object", "key", ":", "map", ".", "keySet", "(", ")", ")", "{", "String", "keyName", "=", "key", ".", "toString", "(", ")", ";", "if", "(", "classMetadataName", "!=", "null", ")", "{", "if", "(", "keyName", ".", "equals", "(", "classMetadataName", ")", ")", "{", "continue", ";", "}", "}", "PropertyDescriptor", "pd", "=", "cd", ".", "getPropertyDescriptor", "(", "keyName", ",", "declared", ")", ";", "if", "(", "!", "targetIsMap", "&&", "pd", "==", "null", ")", "{", "continue", ";", "}", "Object", "value", "=", "map", ".", "get", "(", "key", ")", ";", "Class", "propertyType", "=", "pd", "==", "null", "?", "null", ":", "pd", ".", "getType", "(", ")", ";", "Class", "componentType", "=", "pd", "==", "null", "?", "null", ":", "pd", ".", "resolveComponentType", "(", "true", ")", ";", "if", "(", "value", "!=", "null", ")", "{", "if", "(", "value", "instanceof", "List", ")", "{", "if", "(", "componentType", "!=", "null", "&&", "componentType", "!=", "String", ".", "class", ")", "{", "value", "=", "generifyList", "(", "(", "List", ")", "value", ",", "componentType", ")", ";", "}", "}", "else", "if", "(", "value", "instanceof", "Map", ")", "{", "if", "(", "!", "ClassUtil", ".", "isTypeOf", "(", "propertyType", ",", "Map", ".", "class", ")", ")", "{", "value", "=", "map2bean", "(", "(", "Map", ")", "value", ",", "propertyType", ")", ";", "}", "else", "{", "Class", "keyType", "=", "pd", "==", "null", "?", "null", ":", "pd", ".", "resolveKeyType", "(", "true", ")", ";", "if", "(", "keyType", "!=", "String", ".", "class", "||", "componentType", "!=", "String", ".", "class", ")", "{", "value", "=", "generifyMap", "(", "(", "Map", ")", "value", ",", "keyType", ",", "componentType", ")", ";", "}", "}", "}", "}", "if", "(", "targetIsMap", ")", "{", "(", "(", "Map", ")", "target", ")", ".", "put", "(", "keyName", ",", "value", ")", ";", "}", "else", "{", "try", "{", "setValue", "(", "target", ",", "pd", ",", "value", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "ignore", ".", "printStackTrace", "(", ")", ";", "}", "}", "}", "return", "target", ";", "}"], "idx": 59457, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "9bffc3913aeb8472c11bb543243004b4b4376f16", "function_name": "map2bean", "body_hash": "9eb376cfe560eb4047ccf6aa4a139e34ba1ca2ab"}
{"code": "@Override\n    public boolean willAttributeDistribute(String name, Object value) {\n        Pattern sessionAttributeNamePattern = getSessionAttributeNamePattern();\n        if (sessionAttributeNamePattern != null) {\n            if (!sessionAttributeNamePattern.matcher(name).matches()) {\n                if (getWarnOnSessionAttributeFilterFailure() || log.isDebugEnabled()) {\n                    String msg = sm.getString(\"managerBase.sessionAttributeNameFilter\",\n                            name, sessionAttributeNamePattern);\n                    if (getWarnOnSessionAttributeFilterFailure()) {\n                        log.warn(msg);\n                    } else {\n                        log.debug(msg);\n                    }\n                }\n                return false;\n            }\n        }\n\n        Pattern sessionAttributeValueClassNamePattern = getSessionAttributeValueClassNamePattern();\n        if (value != null && sessionAttributeValueClassNamePattern != null) {\n            if (!sessionAttributeValueClassNamePattern.matcher(\n                    value.getClass().getName()).matches()) {\n                if (getWarnOnSessionAttributeFilterFailure() || log.isDebugEnabled()) {\n                    String msg = sm.getString(\"managerBase.sessionAttributeValueClassNameFilter\",\n                            name, value.getClass().getName(), sessionAttributeNamePattern);\n                    if (getWarnOnSessionAttributeFilterFailure()) {\n                        log.warn(msg);\n                    } else {\n                        log.debug(msg);\n                    }\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }", "code_tokens": ["@", "Override", "public", "boolean", "willAttributeDistribute", "(", "String", "name", ",", "Object", "value", ")", "{", "Pattern", "sessionAttributeNamePattern", "=", "getSessionAttributeNamePattern", "(", ")", ";", "if", "(", "sessionAttributeNamePattern", "!=", "null", ")", "{", "if", "(", "!", "sessionAttributeNamePattern", ".", "matcher", "(", "name", ")", ".", "matches", "(", ")", ")", "{", "if", "(", "getWarnOnSessionAttributeFilterFailure", "(", ")", "||", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "String", "msg", "=", "sm", ".", "getString", "(", "\"", "managerBase.sessionAttributeNameFilter", "\"", ",", "name", ",", "sessionAttributeNamePattern", ")", ";", "if", "(", "getWarnOnSessionAttributeFilterFailure", "(", ")", ")", "{", "log", ".", "warn", "(", "msg", ")", ";", "}", "else", "{", "log", ".", "debug", "(", "msg", ")", ";", "}", "}", "return", "false", ";", "}", "}", "Pattern", "sessionAttributeValueClassNamePattern", "=", "getSessionAttributeValueClassNamePattern", "(", ")", ";", "if", "(", "value", "!=", "null", "&&", "sessionAttributeValueClassNamePattern", "!=", "null", ")", "{", "if", "(", "!", "sessionAttributeValueClassNamePattern", ".", "matcher", "(", "value", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ".", "matches", "(", ")", ")", "{", "if", "(", "getWarnOnSessionAttributeFilterFailure", "(", ")", "||", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "String", "msg", "=", "sm", ".", "getString", "(", "\"", "managerBase.sessionAttributeValueClassNameFilter", "\"", ",", "name", ",", "value", ".", "getClass", "(", ")", ".", "getName", "(", ")", ",", "sessionAttributeNamePattern", ")", ";", "if", "(", "getWarnOnSessionAttributeFilterFailure", "(", ")", ")", "{", "log", ".", "warn", "(", "msg", ")", ";", "}", "else", "{", "log", ".", "debug", "(", "msg", ")", ";", "}", "}", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "idx": 31991, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "50f1b1da794cd93b70ab5456d3c2c984408e1506", "function_name": "willAttributeDistribute", "body_hash": "16b9755afe47b6235491895b30ba488c88c03ab9"}
{"code": "protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n\t\tString targetUrl = null;\n\t\tHttpSession session = request.getSession(false);\n\t\tif (session != null && targetUrlSessionAttribute != null) {\n\t\t\ttargetUrl = (String) session.getAttribute(targetUrlSessionAttribute);\n\t\t\tsession.removeAttribute(targetUrlSessionAttribute);\n\t\t}\n\n\t\tif (isAlwaysUseDefaultTargetUrl() || !StringUtils.hasText(targetUrl) || (getTargetUrlParameter() != null && StringUtils.hasText(request.getParameter(getTargetUrlParameter())))) {\n\t\t\treturn super.determineTargetUrl(request, response);\n\t\t}\n\n\t\tlogger.debug(\"Found targetUrlSessionAttribute in request: \" + targetUrl);\n\n\t\t// URL returned from determineTargetUrl() is resolved against the context path,\n\t\t// whereas the \"from\" URL is resolved against the top of the website, so adjust this.\n\t\tif (targetUrl.startsWith(request.getContextPath()))\n\t\t\treturn targetUrl.substring(request.getContextPath().length());\n\n\t\treturn targetUrl;\n\t}", "code_tokens": ["protected", "String", "determineTargetUrl", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "{", "String", "targetUrl", "=", "null", ";", "HttpSession", "session", "=", "request", ".", "getSession", "(", "false", ")", ";", "if", "(", "session", "!=", "null", "&&", "targetUrlSessionAttribute", "!=", "null", ")", "{", "targetUrl", "=", "(", "String", ")", "session", ".", "getAttribute", "(", "targetUrlSessionAttribute", ")", ";", "session", ".", "removeAttribute", "(", "targetUrlSessionAttribute", ")", ";", "}", "if", "(", "isAlwaysUseDefaultTargetUrl", "(", ")", "||", "!", "StringUtils", ".", "hasText", "(", "targetUrl", ")", "||", "(", "getTargetUrlParameter", "(", ")", "!=", "null", "&&", "StringUtils", ".", "hasText", "(", "request", ".", "getParameter", "(", "getTargetUrlParameter", "(", ")", ")", ")", ")", ")", "{", "return", "super", ".", "determineTargetUrl", "(", "request", ",", "response", ")", ";", "}", "logger", ".", "debug", "(", "\"", "Found targetUrlSessionAttribute in request: ", "\"", "+", "targetUrl", ")", ";", "if", "(", "targetUrl", ".", "startsWith", "(", "request", ".", "getContextPath", "(", ")", ")", ")", "return", "targetUrl", ".", "substring", "(", "request", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "return", "targetUrl", ";", "}"], "idx": 65799, "cwe": "CWE-601", "target": 1, "status": "VULNERABLE", "commit": "8ac536a", "function_name": "determineTargetUrl", "body_hash": "c0b5f4b411b3afd3915d1132135d295f7a20f0cc"}
{"code": "private String guard(String filename) {\n            String guarded = filename.replace(\":\", \"_\");\n            guarded = FileSystems.getDefault().getPath(guarded).normalize().toString();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"guarded \" + filename + \" to \" + guarded);\n            }\n            return guarded;\n        }", "code_tokens": ["private", "String", "guard", "(", "String", "filename", ")", "{", "String", "guarded", "=", "filename", ".", "replace", "(", "\"", ":", "\"", ",", "\"", "_", "\"", ")", ";", "guarded", "=", "FileSystems", ".", "getDefault", "(", ")", ".", "getPath", "(", "guarded", ")", ".", "normalize", "(", ")", ".", "toString", "(", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "guarded ", "\"", "+", "filename", "+", "\"", " to ", "\"", "+", "guarded", ")", ";", "}", "return", "guarded", ";", "}"], "idx": 20892, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "729c4731574ffffaf58ebefdbaeb3bd19ed1c7b7", "function_name": "guard", "body_hash": "db565b7ea66d2f304b05754980c1eefd16536703"}
{"code": "@Override\n    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName) throws InvocationTargetException {\n        try {\n            Digester digester = new Digester();\n            digester.setValidating(false);\n            digester.setClassLoader(PmdParser.class.getClassLoader());\n\n            String rootXPath = \"pmd\";\n            digester.addObjectCreate(rootXPath, Pmd.class);\n            digester.addSetProperties(rootXPath);\n\n            String fileXPath = \"pmd/file\";\n            digester.addObjectCreate(fileXPath, hudson.plugins.pmd.parser.File.class);\n            digester.addSetProperties(fileXPath);\n            digester.addSetNext(fileXPath, \"addFile\", hudson.plugins.pmd.parser.File.class.getName());\n\n            String bugXPath = \"pmd/file/violation\";\n            digester.addObjectCreate(bugXPath, Violation.class);\n            digester.addSetProperties(bugXPath);\n            digester.addCallMethod(bugXPath, \"setMessage\", 0);\n            digester.addSetNext(bugXPath, \"addViolation\", Violation.class.getName());\n\n            Pmd module = (Pmd)digester.parse(file);\n            if (module == null) {\n                throw new SAXException(\"Input stream is not a PMD file.\");\n            }\n\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }", "code_tokens": ["@", "Override", "public", "Collection", "<", "FileAnnotation", ">", "parse", "(", "final", "InputStream", "file", ",", "final", "String", "moduleName", ")", "throws", "InvocationTargetException", "{", "try", "{", "Digester", "digester", "=", "new", "Digester", "(", ")", ";", "digester", ".", "setValidating", "(", "false", ")", ";", "digester", ".", "setClassLoader", "(", "PmdParser", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "String", "rootXPath", "=", "\"", "pmd", "\"", ";", "digester", ".", "addObjectCreate", "(", "rootXPath", ",", "Pmd", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "rootXPath", ")", ";", "String", "fileXPath", "=", "\"", "pmd/file", "\"", ";", "digester", ".", "addObjectCreate", "(", "fileXPath", ",", "hudson", ".", "plugins", ".", "pmd", ".", "parser", ".", "File", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "fileXPath", ")", ";", "digester", ".", "addSetNext", "(", "fileXPath", ",", "\"", "addFile", "\"", ",", "hudson", ".", "plugins", ".", "pmd", ".", "parser", ".", "File", ".", "class", ".", "getName", "(", ")", ")", ";", "String", "bugXPath", "=", "\"", "pmd/file/violation", "\"", ";", "digester", ".", "addObjectCreate", "(", "bugXPath", ",", "Violation", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "bugXPath", ")", ";", "digester", ".", "addCallMethod", "(", "bugXPath", ",", "\"", "setMessage", "\"", ",", "0", ")", ";", "digester", ".", "addSetNext", "(", "bugXPath", ",", "\"", "addViolation", "\"", ",", "Violation", ".", "class", ".", "getName", "(", ")", ")", ";", "Pmd", "module", "=", "(", "Pmd", ")", "digester", ".", "parse", "(", "file", ")", ";", "if", "(", "module", "==", "null", ")", "{", "throw", "new", "SAXException", "(", "\"", "Input stream is not a PMD file.", "\"", ")", ";", "}", "return", "convert", "(", "module", ",", "moduleName", ")", ";", "}", "catch", "(", "IOException", "exception", ")", "{", "throw", "new", "InvocationTargetException", "(", "exception", ")", ";", "}", "catch", "(", "SAXException", "exception", ")", "{", "throw", "new", "InvocationTargetException", "(", "exception", ")", ";", "}", "}"], "idx": 70024, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "f88399a021c22e30cb8fbac5200471d69f1b6224", "function_name": "parse", "body_hash": "5c67d9d282c459e71511d752e4ff21a00f66052c"}
{"code": "@Override\n    public Response processControlCommand(ControlCommand command) throws Exception {\n        String control = command.getCommand();\n        if (control != null && control.equals(\"shutdown\")) {\n            System.exit(0);\n        }\n        return null;\n    }", "code_tokens": ["@", "Override", "public", "Response", "processControlCommand", "(", "ControlCommand", "command", ")", "throws", "Exception", "{", "String", "control", "=", "command", ".", "getCommand", "(", ")", ";", "if", "(", "control", "!=", "null", "&&", "control", ".", "equals", "(", "\"", "shutdown", "\"", ")", ")", "{", "System", ".", "exit", "(", "0", ")", ";", "}", "return", "null", ";", "}"], "idx": 29558, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "00921f22ff9a8792d7663ef8fadd4823402a6324", "function_name": "processControlCommand", "body_hash": "dae63f68d3c1dac56e4b68b4a79b224b91372eda"}
{"code": "@Override\n    public String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        Object redirectAttribute = request.getAttribute(URI_OVERRIDE_ATTRIBUTE);\n        String redirectFormParam = request.getParameter(FORM_REDIRECT_PARAMETER);\n        if (redirectAttribute !=null) {\n            logger.debug(\"Returning redirectAttribute saved URI:\"+redirectAttribute);\n            return (String) redirectAttribute;\n        } else if (redirectFormParam != null) {\n            return redirectFormParam;\n        } else {\n            return super.determineTargetUrl(request, response);\n        }\n    }", "code_tokens": ["@", "Override", "public", "String", "determineTargetUrl", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "{", "Object", "redirectAttribute", "=", "request", ".", "getAttribute", "(", "URI_OVERRIDE_ATTRIBUTE", ")", ";", "String", "redirectFormParam", "=", "request", ".", "getParameter", "(", "FORM_REDIRECT_PARAMETER", ")", ";", "if", "(", "redirectAttribute", "!=", "null", ")", "{", "logger", ".", "debug", "(", "\"", "Returning redirectAttribute saved URI:", "\"", "+", "redirectAttribute", ")", ";", "return", "(", "String", ")", "redirectAttribute", ";", "}", "else", "if", "(", "redirectFormParam", "!=", "null", ")", "{", "return", "redirectFormParam", ";", "}", "else", "{", "return", "super", ".", "determineTargetUrl", "(", "request", ",", "response", ")", ";", "}", "}"], "idx": 65629, "cwe": "CWE-601", "target": 1, "status": "VULNERABLE", "commit": "57a15dfb7e0e3a59019ebe951793b586512b196", "function_name": "determineTargetUrl", "body_hash": "ff6925753bb34129303b69f3773e507833fbacf3"}
{"code": "private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }", "code_tokens": ["private", "JWT", "decode", "(", "String", "encodedJWT", ",", "Header", "header", ",", "String", "[", "]", "parts", ",", "Verifier", "verifier", ")", "{", "int", "index", "=", "encodedJWT", ".", "lastIndexOf", "(", "\"", ".", "\"", ")", ";", "byte", "[", "]", "message", "=", "encodedJWT", ".", "substring", "(", "0", ",", "index", ")", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ";", "if", "(", "parts", ".", "length", "==", "3", "&&", "verifier", "==", "null", ")", "{", "throw", "new", "MissingVerifierException", "(", "\"", "No Verifier has been provided for verify a signature signed using [", "\"", "+", "header", ".", "algorithm", ".", "getName", "(", ")", "+", "\"", "]", "\"", ")", ";", "}", "if", "(", "parts", ".", "length", "==", "2", "&&", "verifier", "!=", "null", ")", "{", "throw", "new", "InvalidJWTSignatureException", "(", ")", ";", "}", "if", "(", "parts", ".", "length", "==", "3", ")", "{", "byte", "[", "]", "signature", "=", "base64Decode", "(", "parts", "[", "2", "]", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ")", ";", "verifier", ".", "verify", "(", "header", ".", "algorithm", ",", "message", ",", "signature", ")", ";", "}", "JWT", "jwt", "=", "Mapper", ".", "deserialize", "(", "base64Decode", "(", "parts", "[", "1", "]", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ")", ",", "JWT", ".", "class", ")", ";", "if", "(", "jwt", ".", "isExpired", "(", ")", ")", "{", "throw", "new", "JWTExpiredException", "(", ")", ";", "}", "if", "(", "jwt", ".", "isUnavailableForProcessing", "(", ")", ")", "{", "throw", "new", "JWTUnavailableForProcessingException", "(", ")", ";", "}", "return", "jwt", ";", "}"], "idx": 11733, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "abb0d479389a2509f939452a6767dc424bb5e6ba", "function_name": "decode", "body_hash": "25f2b7268df8f285198eb98e439ad3fc21f771bd"}
{"code": "@Exported(inline=true)\n    public Map<String/*monitor name*/,Object> getMonitorData() {\n        Map<String,Object> r = new HashMap<String, Object>();\n        for (NodeMonitor monitor : NodeMonitor.getAll())\n            r.put(monitor.getClass().getName(),monitor.data(this));\n        return r;\n    }", "code_tokens": ["@", "Exported", "(", "inline", "=", "true", ")", "public", "Map", "<", "String", ",", "Object", ">", "getMonitorData", "(", ")", "{", "Map", "<", "String", ",", "Object", ">", "r", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "for", "(", "NodeMonitor", "monitor", ":", "NodeMonitor", ".", "getAll", "(", ")", ")", "r", ".", "put", "(", "monitor", ".", "getClass", "(", ")", ".", "getName", "(", ")", ",", "monitor", ".", "data", "(", "this", ")", ")", ";", "return", "r", ";", "}"], "idx": 13015, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "0f92cd08a19207de2cceb6a2f4e3e9f92fdc0899", "function_name": "getMonitorData", "body_hash": "94c25a20a2618bedf7d18a82a419fed845330536"}
{"code": "@RequirePOST\n        public FormValidation doMatchText(\n                @QueryParameter(\"pattern\") final String testPattern,\n                @QueryParameter(\"testText\") String testText,\n                @QueryParameter(\"textSourceIsUrl\") final boolean textSourceIsUrl) {\n            Jenkins.get().checkPermission(PluginImpl.UPDATE_PERMISSION);\n            if (textSourceIsUrl) {\n                testText = testText.replaceAll(\"/\\\\./\", \"/\").replaceAll(\"/view/change-requests\", \"\");\n                Matcher urlMatcher = URL_PATTERN.matcher(testText);\n                if (urlMatcher.matches()) {\n                    String[] urlParts = new String[NUM_OF_URL_PARTS];\n                    for (int i = 0; i < urlParts.length; i++) {\n                        urlParts[i] = urlMatcher.group(i + 1);\n                    }\n\n                    Run build = null;\n                    ItemGroup getItemInstance;\n\n                    if (urlParts[0].split(\"/job/\").length > 1) {\n                        /*\n                         * We matched a folders job. Let's get the jobs up to the part were the next\n                         * iteration can be continued from\n                         */\n                        StringBuilder fullFolderName = new StringBuilder();\n                        /* The interestingJobParts string created below is meant to discard everything\n                         * that comes before the first '/job' occurrent which is either nothing or the\n                         * prefix from where jenkins is served, ie: http://localhost/jenkins/job/<job>/<buildNumber>\n                         */\n                        String[] interestingJobParts = urlParts[0].split(\"/job/\", 2);\n                        String[] jobParts = interestingJobParts[interestingJobParts.length - 1].split(\"/job/\");\n                        for (String part: jobParts) {\n                            fullFolderName.append(\"/\").append(part);\n                        }\n                        getItemInstance = (ItemGroup)Jenkins.getInstance().getItemByFullName(fullFolderName.toString());\n                    } else {\n                        getItemInstance = (ItemGroup)Jenkins.getInstance();\n                    }\n\n                    if (getItemInstance == null) {\n                        throw new AssertionError(\"Folder not found!\");\n                    }\n\n                    /*\n                       Find out which of the following url types testText matches, if any,\n                       and assign to build accordingly. The url types are checked in the\n                       given order.\n                       Type 1: .../<job>/<buildNumber>/\n                       Type 2: .../<job>/<matrixInfo>/<buildNumber>/\n                       Type 3: .../<job>/<buildNumber>/<matrixInfo>/\n                     */\n\n                    final Item itemFromPart2 = getItemInstance.getItem(urlParts[2]);\n                    if (itemFromPart2 instanceof Job\n                            && isValidBuildId(urlParts[3])) {\n                        Job project = (Job)itemFromPart2;\n                        build = getBuildById(project, urlParts[3]);\n                    } else {\n                        final Item itemFromPart1 = getItemInstance.getItem(urlParts[1]);\n                        if (itemFromPart1 instanceof MatrixProject\n                                && isValidBuildId(urlParts[3])) {\n                            MatrixProject project = (MatrixProject)itemFromPart1;\n                            MatrixConfiguration configuration = project.getItem(urlParts[2]);\n                            build = getBuildById(configuration, urlParts[3]);\n                        } else if (itemFromPart1 instanceof MatrixProject\n                                && isValidBuildId(urlParts[2])) {\n                            MatrixProject matrixProject = (MatrixProject)itemFromPart1;\n                            MatrixConfiguration configuration = matrixProject.getItem(urlParts[3]);\n                            build = getBuildById(configuration, urlParts[2]);\n                        }\n                    }\n                    if (build != null) {\n                        try {\n                            final FailureReader failureReader = getFailureReader(testPattern);\n                            final FoundIndication foundIndication = failureReader.scan(build);\n                            if (foundIndication == null) {\n                                return FormValidation.warning(Messages.StringDoesNotMatchPattern());\n                            }\n                            return FormValidation.okWithMarkup(foundIndication.getFirstMatchingLine());\n                        } catch (IOException e) {\n                            return FormValidation.error(Messages.FailedToScanFile_Error());\n                        }\n                    }\n                }\n                return FormValidation.error(Messages.InvalidURL_Error());\n            } else {\n                try {\n                    final Pattern pattern = Pattern.compile(testPattern);\n                    final Matcher matcher = pattern.matcher(new FailureReader.InterruptibleCharSequence(testText));\n                    if (matcher.matches()) {\n                        return FormValidation.ok(Messages.StringMatchesPattern());\n                    }\n                    return FormValidation.warning(Messages.StringDoesNotMatchPattern());\n                } catch (PatternSyntaxException e) {\n                    return FormValidation.error(Messages.InvalidPattern_Error());\n                }\n            }\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doMatchText", "(", "@", "QueryParameter", "(", "\"", "pattern", "\"", ")", "final", "String", "testPattern", ",", "@", "QueryParameter", "(", "\"", "testText", "\"", ")", "String", "testText", ",", "@", "QueryParameter", "(", "\"", "textSourceIsUrl", "\"", ")", "final", "boolean", "textSourceIsUrl", ")", "{", "Jenkins", ".", "get", "(", ")", ".", "checkPermission", "(", "PluginImpl", ".", "UPDATE_PERMISSION", ")", ";", "if", "(", "textSourceIsUrl", ")", "{", "testText", "=", "testText", ".", "replaceAll", "(", "\"", "/", "\\\\", "./", "\"", ",", "\"", "/", "\"", ")", ".", "replaceAll", "(", "\"", "/view/change-requests", "\"", ",", "\"", "\"", ")", ";", "Matcher", "urlMatcher", "=", "URL_PATTERN", ".", "matcher", "(", "testText", ")", ";", "if", "(", "urlMatcher", ".", "matches", "(", ")", ")", "{", "String", "[", "]", "urlParts", "=", "new", "String", "[", "NUM_OF_URL_PARTS", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "urlParts", ".", "length", ";", "i", "++", ")", "{", "urlParts", "[", "i", "]", "=", "urlMatcher", ".", "group", "(", "i", "+", "1", ")", ";", "}", "Run", "build", "=", "null", ";", "ItemGroup", "getItemInstance", ";", "if", "(", "urlParts", "[", "0", "]", ".", "split", "(", "\"", "/job/", "\"", ")", ".", "length", ">", "1", ")", "{", "StringBuilder", "fullFolderName", "=", "new", "StringBuilder", "(", ")", ";", "String", "[", "]", "interestingJobParts", "=", "urlParts", "[", "0", "]", ".", "split", "(", "\"", "/job/", "\"", ",", "2", ")", ";", "String", "[", "]", "jobParts", "=", "interestingJobParts", "[", "interestingJobParts", ".", "length", "-", "1", "]", ".", "split", "(", "\"", "/job/", "\"", ")", ";", "for", "(", "String", "part", ":", "jobParts", ")", "{", "fullFolderName", ".", "append", "(", "\"", "/", "\"", ")", ".", "append", "(", "part", ")", ";", "}", "getItemInstance", "=", "(", "ItemGroup", ")", "Jenkins", ".", "getInstance", "(", ")", ".", "getItemByFullName", "(", "fullFolderName", ".", "toString", "(", ")", ")", ";", "}", "else", "{", "getItemInstance", "=", "(", "ItemGroup", ")", "Jenkins", ".", "getInstance", "(", ")", ";", "}", "if", "(", "getItemInstance", "==", "null", ")", "{", "throw", "new", "AssertionError", "(", "\"", "Folder not found!", "\"", ")", ";", "}", "final", "Item", "itemFromPart2", "=", "getItemInstance", ".", "getItem", "(", "urlParts", "[", "2", "]", ")", ";", "if", "(", "itemFromPart2", "instanceof", "Job", "&&", "isValidBuildId", "(", "urlParts", "[", "3", "]", ")", ")", "{", "Job", "project", "=", "(", "Job", ")", "itemFromPart2", ";", "build", "=", "getBuildById", "(", "project", ",", "urlParts", "[", "3", "]", ")", ";", "}", "else", "{", "final", "Item", "itemFromPart1", "=", "getItemInstance", ".", "getItem", "(", "urlParts", "[", "1", "]", ")", ";", "if", "(", "itemFromPart1", "instanceof", "MatrixProject", "&&", "isValidBuildId", "(", "urlParts", "[", "3", "]", ")", ")", "{", "MatrixProject", "project", "=", "(", "MatrixProject", ")", "itemFromPart1", ";", "MatrixConfiguration", "configuration", "=", "project", ".", "getItem", "(", "urlParts", "[", "2", "]", ")", ";", "build", "=", "getBuildById", "(", "configuration", ",", "urlParts", "[", "3", "]", ")", ";", "}", "else", "if", "(", "itemFromPart1", "instanceof", "MatrixProject", "&&", "isValidBuildId", "(", "urlParts", "[", "2", "]", ")", ")", "{", "MatrixProject", "matrixProject", "=", "(", "MatrixProject", ")", "itemFromPart1", ";", "MatrixConfiguration", "configuration", "=", "matrixProject", ".", "getItem", "(", "urlParts", "[", "3", "]", ")", ";", "build", "=", "getBuildById", "(", "configuration", ",", "urlParts", "[", "2", "]", ")", ";", "}", "}", "if", "(", "build", "!=", "null", ")", "{", "try", "{", "final", "FailureReader", "failureReader", "=", "getFailureReader", "(", "testPattern", ")", ";", "final", "FoundIndication", "foundIndication", "=", "failureReader", ".", "scan", "(", "build", ")", ";", "if", "(", "foundIndication", "==", "null", ")", "{", "return", "FormValidation", ".", "warning", "(", "Messages", ".", "StringDoesNotMatchPattern", "(", ")", ")", ";", "}", "return", "FormValidation", ".", "okWithMarkup", "(", "foundIndication", ".", "getFirstMatchingLine", "(", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "FailedToScanFile_Error", "(", ")", ")", ";", "}", "}", "}", "return", "FormValidation", ".", "error", "(", "Messages", ".", "InvalidURL_Error", "(", ")", ")", ";", "}", "else", "{", "try", "{", "final", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "testPattern", ")", ";", "final", "Matcher", "matcher", "=", "pattern", ".", "matcher", "(", "new", "FailureReader", ".", "InterruptibleCharSequence", "(", "testText", ")", ")", ";", "if", "(", "matcher", ".", "matches", "(", ")", ")", "{", "return", "FormValidation", ".", "ok", "(", "Messages", ".", "StringMatchesPattern", "(", ")", ")", ";", "}", "return", "FormValidation", ".", "warning", "(", "Messages", ".", "StringDoesNotMatchPattern", "(", ")", ")", ";", "}", "catch", "(", "PatternSyntaxException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "InvalidPattern_Error", "(", ")", ")", ";", "}", "}", "}"], "idx": 52796, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "f316c88", "function_name": "doMatchText", "body_hash": "ef9b7a503b785197febe462ceb0cb7da79927bf5"}
{"code": "private void addJsr160DispatcherIfExternallyConfigured(Configuration pConfig) {\n        for (String param : new String[] {\n            System.getProperty(\"org.jolokia.jsr160ProxyEnabled\"),\n            System.getenv(\"JOLOKIA_JSR160_PROXY_ENABLED\")\n        }) {\n            if (param !=null && (param.isEmpty() || Boolean.parseBoolean(param))){\n                String dispatchers = pConfig.get(ConfigKey.DISPATCHER_CLASSES);\n\n                pConfig.updateGlobalConfiguration(\n                    Collections.singletonMap(\n                        ConfigKey.DISPATCHER_CLASSES.getKeyValue(),\n                        (dispatchers != null ? dispatchers + \",\" : \"\") + \"org.jolokia.jsr160.Jsr160RequestDispatcher\"));\n                return;\n            }\n        }\n    }", "code_tokens": ["private", "void", "addJsr160DispatcherIfExternallyConfigured", "(", "Configuration", "pConfig", ")", "{", "for", "(", "String", "param", ":", "new", "String", "[", "]", "{", "System", ".", "getProperty", "(", "\"", "org.jolokia.jsr160ProxyEnabled", "\"", ")", ",", "System", ".", "getenv", "(", "\"", "JOLOKIA_JSR160_PROXY_ENABLED", "\"", ")", "}", ")", "{", "if", "(", "param", "!=", "null", "&&", "(", "param", ".", "isEmpty", "(", ")", "||", "Boolean", ".", "parseBoolean", "(", "param", ")", ")", ")", "{", "String", "dispatchers", "=", "pConfig", ".", "get", "(", "ConfigKey", ".", "DISPATCHER_CLASSES", ")", ";", "pConfig", ".", "updateGlobalConfiguration", "(", "Collections", ".", "singletonMap", "(", "ConfigKey", ".", "DISPATCHER_CLASSES", ".", "getKeyValue", "(", ")", ",", "(", "dispatchers", "!=", "null", "?", "dispatchers", "+", "\"", ",", "\"", ":", "\"", "\"", ")", "+", "\"", "org.jolokia.jsr160.Jsr160RequestDispatcher", "\"", ")", ")", ";", "return", ";", "}", "}", "}"], "idx": 72914, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "fd7b93da30c61a45bac10d8b311f1b79a74910f", "function_name": "addJsr160DispatcherIfExternallyConfigured", "body_hash": "192eefc3b9410e1b5f0b42e07954456ece372f71"}
{"code": "@RequirePOST\n        public FormValidation doValidateProxy(\n                @QueryParameter(\"testUrl\") String testUrl, @QueryParameter(\"name\") String name, @QueryParameter(\"port\") int port,\n                @QueryParameter(\"userName\") String userName, @QueryParameter(\"password\") String password,\n                @QueryParameter(\"noProxyHost\") String noProxyHost) {\n\n            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n\n            if (Util.fixEmptyAndTrim(testUrl) == null) {\n                return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());\n            }\n\n            String host = testUrl;\n            try {\n                URL url = new URL(testUrl);\n                host = url.getHost();\n            } catch (MalformedURLException e) {\n                return FormValidation.error(Messages.ProxyConfiguration_MalformedTestUrl(testUrl));\n            }\n\n            GetMethod method = null;\n            try {\n                method = new GetMethod(testUrl);\n                method.getParams().setParameter(\"http.socket.timeout\", DEFAULT_CONNECT_TIMEOUT_MILLIS > 0 ? DEFAULT_CONNECT_TIMEOUT_MILLIS : new Integer(30 * 1000));\n                \n                HttpClient client = new HttpClient();\n                if (Util.fixEmptyAndTrim(name) != null && !isNoProxyHost(host, noProxyHost)) {\n                    client.getHostConfiguration().setProxy(name, port);\n                    Credentials credentials = createCredentials(userName, password);\n                    AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n                    client.getState().setProxyCredentials(scope, credentials);\n                }\n                \n                int code = client.executeMethod(method);\n                if (code != HttpURLConnection.HTTP_OK) {\n                    return FormValidation.error(Messages.ProxyConfiguration_FailedToConnect(testUrl, code));\n                }\n            } catch (IOException e) {\n                return FormValidation.error(e, Messages.ProxyConfiguration_FailedToConnectViaProxy(testUrl));\n            } finally {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n            }\n            \n            return FormValidation.ok(Messages.ProxyConfiguration_Success());\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doValidateProxy", "(", "@", "QueryParameter", "(", "\"", "testUrl", "\"", ")", "String", "testUrl", ",", "@", "QueryParameter", "(", "\"", "name", "\"", ")", "String", "name", ",", "@", "QueryParameter", "(", "\"", "port", "\"", ")", "int", "port", ",", "@", "QueryParameter", "(", "\"", "userName", "\"", ")", "String", "userName", ",", "@", "QueryParameter", "(", "\"", "password", "\"", ")", "String", "password", ",", "@", "QueryParameter", "(", "\"", "noProxyHost", "\"", ")", "String", "noProxyHost", ")", "{", "Jenkins", ".", "getInstance", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "if", "(", "Util", ".", "fixEmptyAndTrim", "(", "testUrl", ")", "==", "null", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ProxyConfiguration_TestUrlRequired", "(", ")", ")", ";", "}", "String", "host", "=", "testUrl", ";", "try", "{", "URL", "url", "=", "new", "URL", "(", "testUrl", ")", ";", "host", "=", "url", ".", "getHost", "(", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ProxyConfiguration_MalformedTestUrl", "(", "testUrl", ")", ")", ";", "}", "GetMethod", "method", "=", "null", ";", "try", "{", "method", "=", "new", "GetMethod", "(", "testUrl", ")", ";", "method", ".", "getParams", "(", ")", ".", "setParameter", "(", "\"", "http.socket.timeout", "\"", ",", "DEFAULT_CONNECT_TIMEOUT_MILLIS", ">", "0", "?", "DEFAULT_CONNECT_TIMEOUT_MILLIS", ":", "new", "Integer", "(", "30", "*", "1000", ")", ")", ";", "HttpClient", "client", "=", "new", "HttpClient", "(", ")", ";", "if", "(", "Util", ".", "fixEmptyAndTrim", "(", "name", ")", "!=", "null", "&&", "!", "isNoProxyHost", "(", "host", ",", "noProxyHost", ")", ")", "{", "client", ".", "getHostConfiguration", "(", ")", ".", "setProxy", "(", "name", ",", "port", ")", ";", "Credentials", "credentials", "=", "createCredentials", "(", "userName", ",", "password", ")", ";", "AuthScope", "scope", "=", "new", "AuthScope", "(", "AuthScope", ".", "ANY_HOST", ",", "AuthScope", ".", "ANY_PORT", ")", ";", "client", ".", "getState", "(", ")", ".", "setProxyCredentials", "(", "scope", ",", "credentials", ")", ";", "}", "int", "code", "=", "client", ".", "executeMethod", "(", "method", ")", ";", "if", "(", "code", "!=", "HttpURLConnection", ".", "HTTP_OK", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ProxyConfiguration_FailedToConnect", "(", "testUrl", ",", "code", ")", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "e", ",", "Messages", ".", "ProxyConfiguration_FailedToConnectViaProxy", "(", "testUrl", ")", ")", ";", "}", "finally", "{", "if", "(", "method", "!=", "null", ")", "{", "method", ".", "releaseConnection", "(", ")", ";", "}", "}", "return", "FormValidation", ".", "ok", "(", "Messages", ".", "ProxyConfiguration_Success", "(", ")", ")", ";", "}"], "idx": 94363, "cwe": "CWE-918", "target": 0, "status": "FIXED", "commit": "2d16b459205730d85e51499c2457109b234ca9d9", "function_name": "doValidateProxy", "body_hash": "1bdd3f2c1922ca5114ad19123704211ad6fab6de"}
{"code": "@Override\n        public Long next()\n        {\n            if (currentNumber < currentEnd)\n            {\n                return currentNumber++;\n            }\n            currentNumber = start[++currentRange];\n            currentEnd = end[currentRange];\n            return currentNumber++;\n        }", "code_tokens": ["@", "Override", "public", "Long", "next", "(", ")", "{", "if", "(", "currentNumber", "<", "currentEnd", ")", "{", "return", "currentNumber", "++", ";", "}", "currentNumber", "=", "start", "[", "++", "currentRange", "]", ";", "currentEnd", "=", "end", "[", "currentRange", "]", ";", "return", "currentNumber", "++", ";", "}"], "idx": 115225, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "35779d3d37edb90e739b1f7c00cb6bb5c62d6360", "function_name": "next", "body_hash": "8cc16d6916c1ec0e0605e5752f95f3b23b289d53"}
{"code": "public void update(long done, long total, int item) {\n    if (exceptionTrhown) { return; }\n\n    // To avoid cache overloading, this object is saved when the upload starts,\n    // when it has finished, or when the interval from the last save is significant.\n    boolean save = bytesRead == 0 && done > 0 || done >= total || (new Date()).getTime() - saved.getTime() > DEFAULT_SAVE_INTERVAL;\n    bytesRead = done;\n    contentLength = total;\n    if (save) {\n      save();\n    }\n\n    // If other request has set an exception, it is thrown so the commons-fileupload's\n    // parser stops and the connection is closed.\n    if (isCanceled()) {\n      String eName = exception.getClass().getName().replaceAll(\"^.+\\\\.\", \"\");\n      logger.info(className + \" \" + sessionId + \" The upload has been canceled after \" + bytesRead + \" bytes received, raising an exception (\" + eName + \") to close the socket\");\n      exceptionTrhown = true;\n      throw exception;\n    }\n\n    // Just a way to slow down the upload process and see the progress bar in fast networks.\n    /* \n      Fix applied for https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-13128: \n      `slowUploads` is anyway controlled by the user since it is a design decision, however \n      the max value can be `half a minute`, so 30000 milliseconds.\n    */\n    if (slowUploads > 0 && slowUploads < 30000 && done < total) {\n      try {\n        Thread.sleep(slowUploads);\n      } catch (Exception e) {\n        exception = new RuntimeException(e);\n      }\n    }\n  }", "code_tokens": ["public", "void", "update", "(", "long", "done", ",", "long", "total", ",", "int", "item", ")", "{", "if", "(", "exceptionTrhown", ")", "{", "return", ";", "}", "boolean", "save", "=", "bytesRead", "==", "0", "&&", "done", ">", "0", "||", "done", ">=", "total", "||", "(", "new", "Date", "(", ")", ")", ".", "getTime", "(", ")", "-", "saved", ".", "getTime", "(", ")", ">", "DEFAULT_SAVE_INTERVAL", ";", "bytesRead", "=", "done", ";", "contentLength", "=", "total", ";", "if", "(", "save", ")", "{", "save", "(", ")", ";", "}", "if", "(", "isCanceled", "(", ")", ")", "{", "String", "eName", "=", "exception", ".", "getClass", "(", ")", ".", "getName", "(", ")", ".", "replaceAll", "(", "\"", "^.+", "\\\\", ".", "\"", ",", "\"", "\"", ")", ";", "logger", ".", "info", "(", "className", "+", "\"", " ", "\"", "+", "sessionId", "+", "\"", " The upload has been canceled after ", "\"", "+", "bytesRead", "+", "\"", " bytes received, raising an exception (", "\"", "+", "eName", "+", "\"", ") to close the socket", "\"", ")", ";", "exceptionTrhown", "=", "true", ";", "throw", "exception", ";", "}", "if", "(", "slowUploads", ">", "0", "&&", "slowUploads", "<", "30000", "&&", "done", "<", "total", ")", "{", "try", "{", "Thread", ".", "sleep", "(", "slowUploads", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "exception", "=", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "}"], "idx": 53715, "cwe": "CWE-434", "target": 0, "status": "FIXED", "commit": "aca1a97", "function_name": "update", "body_hash": "5cf47662199a19dd2db861b40e77fcc9ea45bbdc"}
{"code": "private static File newFile() throws IOException {\n        File file = File.createTempFile(\"netty-\", \".tmp\");\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n        return file;\n    }", "code_tokens": ["private", "static", "File", "newFile", "(", ")", "throws", "IOException", "{", "File", "file", "=", "File", ".", "createTempFile", "(", "\"", "netty-", "\"", ",", "\"", ".tmp", "\"", ")", ";", "file", ".", "deleteOnExit", "(", ")", ";", "final", "FileOutputStream", "out", "=", "new", "FileOutputStream", "(", "file", ")", ";", "out", ".", "write", "(", "data", ")", ";", "out", ".", "close", "(", ")", ";", "return", "file", ";", "}"], "idx": 50038, "cwe": "CWE-378", "target": 1, "status": "VULNERABLE", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "newFile", "body_hash": "495108ff27e20e8e5cc0c4238eeb68a8542326eb"}
{"code": "private javax.crypto.Cipher initNewCipher(int jcaCipherMode, byte[] key, byte[] iv, boolean streaming)\n            throws CryptoException {\n\n        javax.crypto.Cipher cipher = newCipherInstance(streaming);\n        java.security.Key jdkKey = new SecretKeySpec(key, getAlgorithmName());\n        IvParameterSpec ivSpec = null;\n        if (iv != null && iv.length > 0) {\n            ivSpec = new IvParameterSpec(iv);\n        }\n\n        init(cipher, jcaCipherMode, jdkKey, ivSpec, getSecureRandom());\n\n        return cipher;\n    }", "code_tokens": ["private", "javax", ".", "crypto", ".", "Cipher", "initNewCipher", "(", "int", "jcaCipherMode", ",", "byte", "[", "]", "key", ",", "byte", "[", "]", "iv", ",", "boolean", "streaming", ")", "throws", "CryptoException", "{", "javax", ".", "crypto", ".", "Cipher", "cipher", "=", "newCipherInstance", "(", "streaming", ")", ";", "java", ".", "security", ".", "Key", "jdkKey", "=", "new", "SecretKeySpec", "(", "key", ",", "getAlgorithmName", "(", ")", ")", ";", "IvParameterSpec", "ivSpec", "=", "null", ";", "if", "(", "iv", "!=", "null", "&&", "iv", ".", "length", ">", "0", ")", "{", "ivSpec", "=", "new", "IvParameterSpec", "(", "iv", ")", ";", "}", "init", "(", "cipher", ",", "jcaCipherMode", ",", "jdkKey", ",", "ivSpec", ",", "getSecureRandom", "(", ")", ")", ";", "return", "cipher", ";", "}"], "idx": 99490, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "a8018783373ff5e5210225069c9919e071597d5e", "function_name": "initNewCipher", "body_hash": "114d902f38666ff54bdc64e40dfa36ace32c7c88"}
{"code": "public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain)\n          throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        String uri = getPathInfo(req);\n        if (uriPattern != null && uriPattern.matcher(uri).matches()) {\n            User user = User.current();\n            String username = user != null ? user.getId() : req.getRemoteAddr();\n            String extra = \"\";\n            // For queue items, show what task is in the queue:\n            if (uri.startsWith(\"/queue/item/\")) {\n                extra = extractInfoFromQueueItem(uri);\n            } else if (uri.startsWith(\"/queue/cancelItem\")) {\n                extra = getFormattedQueueItemUrlFromItemId(Integer.parseInt(req.getParameter(\"id\")));\n                // not sure of the intent of the original author\n                // it looks to me we should always log the query parameters\n                // could we leak sensitive data?  There shouldn't be any in a query parameter...except for a badly coded plugin\n                // let's see if this becomes a wanted feature...\n                uri += \"?\" + req.getQueryString();\n            }\n\n            if (LOGGER.isLoggable(Level.FINE))\n                LOGGER.log(Level.FINE, \"Audit request {0} by user {1}\", new Object[]{uri, username});\n\n            onRequest(uri, extra, username);\n        } else {\n            LOGGER.log(Level.FINEST, \"Skip audit for request {0}\", uri);\n        }\n        chain.doFilter(req, res);\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "res", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "HttpServletRequest", "req", "=", "(", "HttpServletRequest", ")", "request", ";", "String", "uri", "=", "getPathInfo", "(", "req", ")", ";", "if", "(", "uriPattern", "!=", "null", "&&", "uriPattern", ".", "matcher", "(", "uri", ")", ".", "matches", "(", ")", ")", "{", "User", "user", "=", "User", ".", "current", "(", ")", ";", "String", "username", "=", "user", "!=", "null", "?", "user", ".", "getId", "(", ")", ":", "req", ".", "getRemoteAddr", "(", ")", ";", "String", "extra", "=", "\"", "\"", ";", "if", "(", "uri", ".", "startsWith", "(", "\"", "/queue/item/", "\"", ")", ")", "{", "extra", "=", "extractInfoFromQueueItem", "(", "uri", ")", ";", "}", "else", "if", "(", "uri", ".", "startsWith", "(", "\"", "/queue/cancelItem", "\"", ")", ")", "{", "extra", "=", "getFormattedQueueItemUrlFromItemId", "(", "Integer", ".", "parseInt", "(", "req", ".", "getParameter", "(", "\"", "id", "\"", ")", ")", ")", ";", "uri", "+=", "\"", "?", "\"", "+", "req", ".", "getQueryString", "(", ")", ";", "}", "if", "(", "LOGGER", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Audit request {0} by user {1}", "\"", ",", "new", "Object", "[", "]", "{", "uri", ",", "username", "}", ")", ";", "onRequest", "(", "uri", ",", "extra", ",", "username", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINEST", ",", "\"", "Skip audit for request {0}", "\"", ",", "uri", ")", ";", "}", "chain", ".", "doFilter", "(", "req", ",", "res", ")", ";", "}"], "idx": 53818, "cwe": "CWE-435", "target": 0, "status": "FIXED", "commit": "329c609", "function_name": "doFilter", "body_hash": "ea076e49722d6ad1eb4b1adc9569207a80c25ee4"}
{"code": "public static @Nonnull ConfidentialStore get() {\n        if (TEST!=null) return TEST.get();\n\n        Lookup lookup = Jenkins.getInstance().lookup;\n        ConfidentialStore cs = lookup.get(ConfidentialStore.class);\n        if (cs==null) {\n            try {\n                List<ConfidentialStore> r = (List) Service.loadInstances(ConfidentialStore.class.getClassLoader(), ConfidentialStore.class);\n                if (!r.isEmpty())\n                    cs = r.get(0);\n            } catch (IOException e) {\n                LOGGER.log(Level.WARNING, \"Failed to list up ConfidentialStore implementations\",e);\n                // fall through\n            }\n\n            if (cs==null)\n                try {\n                    cs = new DefaultConfidentialStore();\n                } catch (Exception e) {\n                    // if it's still null, bail out\n                    throw new Error(e);\n                }\n\n            cs = lookup.setIfNull(ConfidentialStore.class,cs);\n        }\n        return cs;\n    }", "code_tokens": ["public", "static", "@", "Nonnull", "ConfidentialStore", "get", "(", ")", "{", "if", "(", "TEST", "!=", "null", ")", "return", "TEST", ".", "get", "(", ")", ";", "Lookup", "lookup", "=", "Jenkins", ".", "getInstance", "(", ")", ".", "lookup", ";", "ConfidentialStore", "cs", "=", "lookup", ".", "get", "(", "ConfidentialStore", ".", "class", ")", ";", "if", "(", "cs", "==", "null", ")", "{", "try", "{", "List", "<", "ConfidentialStore", ">", "r", "=", "(", "List", ")", "Service", ".", "loadInstances", "(", "ConfidentialStore", ".", "class", ".", "getClassLoader", "(", ")", ",", "ConfidentialStore", ".", "class", ")", ";", "if", "(", "!", "r", ".", "isEmpty", "(", ")", ")", "cs", "=", "r", ".", "get", "(", "0", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to list up ConfidentialStore implementations", "\"", ",", "e", ")", ";", "}", "if", "(", "cs", "==", "null", ")", "try", "{", "cs", "=", "new", "DefaultConfidentialStore", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "Error", "(", "e", ")", ";", "}", "cs", "=", "lookup", ".", "setIfNull", "(", "ConfidentialStore", ".", "class", ",", "cs", ")", ";", "}", "return", "cs", ";", "}"], "idx": 99420, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "c3d8e05a1b3d58b6c4dcff97394cb3a79608b4b2", "function_name": "get", "body_hash": "70b6e2fa449d018622335e98bc2555facc2db8bf"}
{"code": "private static boolean validateGlobalResourceAccess(String globalName) {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        Map<String,String> registrations = globalResourceRegistrations.get(cl);\n        if (registrations != null && registrations.containsValue(globalName)) {\n            return true;\n        }\n        return false;\n    }", "code_tokens": ["private", "static", "boolean", "validateGlobalResourceAccess", "(", "String", "globalName", ")", "{", "ClassLoader", "cl", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "Map", "<", "String", ",", "String", ">", "registrations", "=", "globalResourceRegistrations", ".", "get", "(", "cl", ")", ";", "if", "(", "registrations", "!=", "null", "&&", "registrations", ".", "containsValue", "(", "globalName", ")", ")", "{", "return", "true", ";", "}", "return", "false", ";", "}"], "idx": 100637, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "66e227e0c73ea2f7e93cee9340b580912d580f5d", "function_name": "validateGlobalResourceAccess", "body_hash": "24f437e4c01d592a001f205c8bb79a30e7c5b597"}
{"code": "public static String migrate(String xml) {\n\t\tDocument xmlDoc;\n\t\ttry {\n\t\t\txmlDoc = new SAXReader().read(new StringReader(xml));\n\t\t} catch (DocumentException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t\tList<NodeTuple> tuples = new ArrayList<>();\n\t\tNode keyNode = new ScalarNode(Tag.STR, \"version\");\n\t\tNode valueNode = new ScalarNode(Tag.INT, \"0\");\n\t\ttuples.add(new NodeTuple(keyNode, valueNode));\n\t\t\n\t\tList<Node> jobNodes = new ArrayList<>();\n\t\tfor (Element jobElement: xmlDoc.getRootElement().element(\"jobs\").elements()) \n\t\t\tjobNodes.add(migrateJob(jobElement));\n\t\t\n\t\tif (!jobNodes.isEmpty()) {\n\t\t\tkeyNode = new ScalarNode(Tag.STR, \"jobs\");\n\t\t\ttuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, jobNodes, FlowStyle.BLOCK)));\n\t\t}\n\t\t\n\t\tList<Node> propertyNodes = new ArrayList<>();\n\t\tElement propertiesElement = xmlDoc.getRootElement().element(\"properties\");\n\t\tif (propertiesElement != null) {\n\t\t\tfor (Element propertyElement: propertiesElement.elements()) {\n\t\t\t\tNode nameNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"name\").trim());\n\t\t\t\tvalueNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"value\").trim());\n\t\t\t\tList<NodeTuple> propertyTuples = Lists.newArrayList(\n\t\t\t\t\t\tnew NodeTuple(new ScalarNode(Tag.STR, \"name\"), nameNode), \n\t\t\t\t\t\tnew NodeTuple(new ScalarNode(Tag.STR, \"value\"), valueNode));\n\t\t\t\tpropertyNodes.add(new MappingNode(Tag.MAP, propertyTuples, FlowStyle.BLOCK));\n\t\t\t}\n\t\t}\n\t\tif(!propertyNodes.isEmpty()) {\n\t\t\tkeyNode = new ScalarNode(Tag.STR, \"properties\");\n\t\t\ttuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, propertyNodes, FlowStyle.BLOCK)));\n\t\t}\n\t\t\n\t\tMappingNode rootNode = new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);\n\t\tStringWriter writer = new StringWriter();\n\t\tDumperOptions dumperOptions = new DumperOptions();\n\t\tSerializer serializer = new Serializer(new Emitter(writer, dumperOptions), \n\t\t\t\tnew Resolver(), dumperOptions, Tag.MAP);\n\t\ttry {\n\t\t\tserializer.open();\n\t\t\tserializer.serialize(rootNode);\n\t\t\tserializer.close();\n\t\t\treturn writer.toString();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t}", "code_tokens": ["public", "static", "String", "migrate", "(", "String", "xml", ")", "{", "Document", "xmlDoc", ";", "try", "{", "xmlDoc", "=", "new", "SAXReader", "(", ")", ".", "read", "(", "new", "StringReader", "(", "xml", ")", ")", ";", "}", "catch", "(", "DocumentException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "List", "<", "NodeTuple", ">", "tuples", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Node", "keyNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "version", "\"", ")", ";", "Node", "valueNode", "=", "new", "ScalarNode", "(", "Tag", ".", "INT", ",", "\"", "0", "\"", ")", ";", "tuples", ".", "add", "(", "new", "NodeTuple", "(", "keyNode", ",", "valueNode", ")", ")", ";", "List", "<", "Node", ">", "jobNodes", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "for", "(", "Element", "jobElement", ":", "xmlDoc", ".", "getRootElement", "(", ")", ".", "element", "(", "\"", "jobs", "\"", ")", ".", "elements", "(", ")", ")", "jobNodes", ".", "add", "(", "migrateJob", "(", "jobElement", ")", ")", ";", "if", "(", "!", "jobNodes", ".", "isEmpty", "(", ")", ")", "{", "keyNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "jobs", "\"", ")", ";", "tuples", ".", "add", "(", "new", "NodeTuple", "(", "keyNode", ",", "new", "SequenceNode", "(", "Tag", ".", "SEQ", ",", "jobNodes", ",", "FlowStyle", ".", "BLOCK", ")", ")", ")", ";", "}", "List", "<", "Node", ">", "propertyNodes", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Element", "propertiesElement", "=", "xmlDoc", ".", "getRootElement", "(", ")", ".", "element", "(", "\"", "properties", "\"", ")", ";", "if", "(", "propertiesElement", "!=", "null", ")", "{", "for", "(", "Element", "propertyElement", ":", "propertiesElement", ".", "elements", "(", ")", ")", "{", "Node", "nameNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "propertyElement", ".", "elementText", "(", "\"", "name", "\"", ")", ".", "trim", "(", ")", ")", ";", "valueNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "propertyElement", ".", "elementText", "(", "\"", "value", "\"", ")", ".", "trim", "(", ")", ")", ";", "List", "<", "NodeTuple", ">", "propertyTuples", "=", "Lists", ".", "newArrayList", "(", "new", "NodeTuple", "(", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "name", "\"", ")", ",", "nameNode", ")", ",", "new", "NodeTuple", "(", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "value", "\"", ")", ",", "valueNode", ")", ")", ";", "propertyNodes", ".", "add", "(", "new", "MappingNode", "(", "Tag", ".", "MAP", ",", "propertyTuples", ",", "FlowStyle", ".", "BLOCK", ")", ")", ";", "}", "}", "if", "(", "!", "propertyNodes", ".", "isEmpty", "(", ")", ")", "{", "keyNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "properties", "\"", ")", ";", "tuples", ".", "add", "(", "new", "NodeTuple", "(", "keyNode", ",", "new", "SequenceNode", "(", "Tag", ".", "SEQ", ",", "propertyNodes", ",", "FlowStyle", ".", "BLOCK", ")", ")", ")", ";", "}", "MappingNode", "rootNode", "=", "new", "MappingNode", "(", "Tag", ".", "MAP", ",", "tuples", ",", "FlowStyle", ".", "BLOCK", ")", ";", "StringWriter", "writer", "=", "new", "StringWriter", "(", ")", ";", "DumperOptions", "dumperOptions", "=", "new", "DumperOptions", "(", ")", ";", "Serializer", "serializer", "=", "new", "Serializer", "(", "new", "Emitter", "(", "writer", ",", "dumperOptions", ")", ",", "new", "Resolver", "(", ")", ",", "dumperOptions", ",", "Tag", ".", "MAP", ")", ";", "try", "{", "serializer", ".", "open", "(", ")", ";", "serializer", ".", "serialize", "(", "rootNode", ")", ";", "serializer", ".", "close", "(", ")", ";", "return", "writer", ".", "toString", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}"], "idx": 64235, "cwe": "CWE-538", "target": 1, "status": "VULNERABLE", "commit": "9196fd795e87dab069b4260a3590a0ea886e770f", "function_name": "migrate", "body_hash": "48c46fdf065b02f04b227eb8906b2af87a45779f"}
{"code": "private Ccm parseCCMXmlFile(InputStream ccmXmlFile) throws IOException, SAXException {\n\t\tSecureDigester digester = new SecureDigester(CcmParser.class);\n\n\t\tString rootXPath = \"ccm\";\n\t\tdigester.addObjectCreate(rootXPath, Ccm.class);\n\t\tdigester.addSetProperties(rootXPath);\n\n\t\tString fileMetric = \"ccm/metric\";\n\t\tdigester.addObjectCreate(fileMetric, Metric.class);\n\t\tdigester.addSetProperties(fileMetric);\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/complexity\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/unit\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/classification\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/file\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/startLineNumber\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/endLineNumber\");\n\t\tdigester.addSetNext(fileMetric, \"addMetric\", Metric.class.getName());\n\n\t\treturn (Ccm)digester.parse(ccmXmlFile);\n\t}", "code_tokens": ["private", "Ccm", "parseCCMXmlFile", "(", "InputStream", "ccmXmlFile", ")", "throws", "IOException", ",", "SAXException", "{", "SecureDigester", "digester", "=", "new", "SecureDigester", "(", "CcmParser", ".", "class", ")", ";", "String", "rootXPath", "=", "\"", "ccm", "\"", ";", "digester", ".", "addObjectCreate", "(", "rootXPath", ",", "Ccm", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "rootXPath", ")", ";", "String", "fileMetric", "=", "\"", "ccm/metric", "\"", ";", "digester", ".", "addObjectCreate", "(", "fileMetric", ",", "Metric", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "fileMetric", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/complexity", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/unit", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/classification", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/file", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/startLineNumber", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/endLineNumber", "\"", ")", ";", "digester", ".", "addSetNext", "(", "fileMetric", ",", "\"", "addMetric", "\"", ",", "Metric", ".", "class", ".", "getName", "(", ")", ")", ";", "return", "(", "Ccm", ")", "digester", ".", "parse", "(", "ccmXmlFile", ")", ";", "}"], "idx": 69280, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "066cb43b4413b3490d822ec8b8a32072ebd213ca", "function_name": "parseCCMXmlFile", "body_hash": "f9436d78ae4713004d8ecd193124d9f12c258070"}
{"code": "private JMXConnectorServer createServer(String serverName,\n            String bindAddress, int theRmiRegistryPort, int theRmiServerPort,\n            Map<String,Object> theEnv,\n            RMIClientSocketFactory registryCsf, RMIServerSocketFactory registrySsf,\n            RMIClientSocketFactory serverCsf, RMIServerSocketFactory serverSsf) {\n\n        // Create the RMI registry\n        Registry registry;\n        try {\n            registry = LocateRegistry.createRegistry(\n                    theRmiRegistryPort, registryCsf, registrySsf);\n        } catch (RemoteException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createRegistryFailed\",\n                    serverName, Integer.toString(theRmiRegistryPort)), e);\n            return null;\n        }\n\n        if (bindAddress == null) {\n            bindAddress = \"localhost\";\n        }\n\n        String url = \"service:jmx:rmi://\" + bindAddress;\n        JMXServiceURL serviceUrl;\n        try {\n            serviceUrl = new JMXServiceURL(url);\n        } catch (MalformedURLException e) {\n            log.error(sm.getString(\"jmxRemoteLifecycleListener.invalidURL\", serverName, url), e);\n            return null;\n        }\n\n        RMIConnectorServer cs = null;\n        try {\n            RMIJRMPServerImpl server = new RMIJRMPServerImpl(\n                    rmiServerPortPlatform, serverCsf, serverSsf, theEnv);\n            cs = new RMIConnectorServer(serviceUrl, theEnv, server,\n                    ManagementFactory.getPlatformMBeanServer());\n            cs.start();\n            registry.bind(\"jmxrmi\", server.toStub());\n            log.info(sm.getString(\"jmxRemoteLifecycleListener.start\",\n                    Integer.toString(theRmiRegistryPort),\n                    Integer.toString(theRmiServerPort), serverName));\n        } catch (IOException | AlreadyBoundException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createServerFailed\",\n                    serverName), e);\n        }\n        return cs;\n    }", "code_tokens": ["private", "JMXConnectorServer", "createServer", "(", "String", "serverName", ",", "String", "bindAddress", ",", "int", "theRmiRegistryPort", ",", "int", "theRmiServerPort", ",", "Map", "<", "String", ",", "Object", ">", "theEnv", ",", "RMIClientSocketFactory", "registryCsf", ",", "RMIServerSocketFactory", "registrySsf", ",", "RMIClientSocketFactory", "serverCsf", ",", "RMIServerSocketFactory", "serverSsf", ")", "{", "Registry", "registry", ";", "try", "{", "registry", "=", "LocateRegistry", ".", "createRegistry", "(", "theRmiRegistryPort", ",", "registryCsf", ",", "registrySsf", ")", ";", "}", "catch", "(", "RemoteException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.createRegistryFailed", "\"", ",", "serverName", ",", "Integer", ".", "toString", "(", "theRmiRegistryPort", ")", ")", ",", "e", ")", ";", "return", "null", ";", "}", "if", "(", "bindAddress", "==", "null", ")", "{", "bindAddress", "=", "\"", "localhost", "\"", ";", "}", "String", "url", "=", "\"", "service:jmx:rmi://", "\"", "+", "bindAddress", ";", "JMXServiceURL", "serviceUrl", ";", "try", "{", "serviceUrl", "=", "new", "JMXServiceURL", "(", "url", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.invalidURL", "\"", ",", "serverName", ",", "url", ")", ",", "e", ")", ";", "return", "null", ";", "}", "RMIConnectorServer", "cs", "=", "null", ";", "try", "{", "RMIJRMPServerImpl", "server", "=", "new", "RMIJRMPServerImpl", "(", "rmiServerPortPlatform", ",", "serverCsf", ",", "serverSsf", ",", "theEnv", ")", ";", "cs", "=", "new", "RMIConnectorServer", "(", "serviceUrl", ",", "theEnv", ",", "server", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "cs", ".", "start", "(", ")", ";", "registry", ".", "bind", "(", "\"", "jmxrmi", "\"", ",", "server", ".", "toStub", "(", ")", ")", ";", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.start", "\"", ",", "Integer", ".", "toString", "(", "theRmiRegistryPort", ")", ",", "Integer", ".", "toString", "(", "theRmiServerPort", ")", ",", "serverName", ")", ")", ";", "}", "catch", "(", "IOException", "|", "AlreadyBoundException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.createServerFailed", "\"", ",", "serverName", ")", ",", "e", ")", ";", "}", "return", "cs", ";", "}"], "idx": 99746, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "1fc9f58", "function_name": "createServer", "body_hash": "dd8c82e8ebd2723f7c62acfb859ad4c2355d8ebe"}
{"code": "private void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser = new TagPluginParser(ctxt, blockExternal);\n\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }", "code_tokens": ["private", "void", "init", "(", "ErrorDispatcher", "err", ")", "throws", "JasperException", "{", "if", "(", "initialized", ")", "return", ";", "String", "blockExternalString", "=", "ctxt", ".", "getInitParameter", "(", "Constants", ".", "XML_BLOCK_EXTERNAL_INIT_PARAM", ")", ";", "boolean", "blockExternal", ";", "if", "(", "blockExternalString", "==", "null", ")", "{", "blockExternal", "=", "true", ";", "}", "else", "{", "blockExternal", "=", "Boolean", ".", "parseBoolean", "(", "blockExternalString", ")", ";", "}", "TagPluginParser", "parser", "=", "new", "TagPluginParser", "(", "ctxt", ",", "blockExternal", ")", ";", "try", "{", "Enumeration", "<", "URL", ">", "urls", "=", "ctxt", ".", "getClassLoader", "(", ")", ".", "getResources", "(", "META_INF_JASPER_TAG_PLUGINS_XML", ")", ";", "if", "(", "urls", "!=", "null", ")", "{", "while", "(", "urls", ".", "hasMoreElements", "(", ")", ")", "{", "URL", "url", "=", "urls", ".", "nextElement", "(", ")", ";", "parser", ".", "parse", "(", "url", ")", ";", "}", "}", "URL", "url", "=", "ctxt", ".", "getResource", "(", "TAG_PLUGINS_XML", ")", ";", "if", "(", "url", "!=", "null", ")", "{", "parser", ".", "parse", "(", "url", ")", ";", "}", "}", "catch", "(", "IOException", "|", "SAXException", "e", ")", "{", "throw", "new", "JasperException", "(", "e", ")", ";", "}", "Map", "<", "String", ",", "String", ">", "plugins", "=", "parser", ".", "getPlugins", "(", ")", ";", "tagPlugins", "=", "new", "HashMap", "<", ">", "(", "plugins", ".", "size", "(", ")", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "entry", ":", "plugins", ".", "entrySet", "(", ")", ")", "{", "try", "{", "String", "tagClass", "=", "entry", ".", "getKey", "(", ")", ";", "String", "pluginName", "=", "entry", ".", "getValue", "(", ")", ";", "Class", "<", "?", ">", "pluginClass", "=", "ctxt", ".", "getClassLoader", "(", ")", ".", "loadClass", "(", "pluginName", ")", ";", "TagPlugin", "plugin", "=", "(", "TagPlugin", ")", "pluginClass", ".", "newInstance", "(", ")", ";", "tagPlugins", ".", "put", "(", "tagClass", ",", "plugin", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "err", ".", "jspError", "(", "e", ")", ";", "}", "}", "initialized", "=", "true", ";", "}"], "idx": 32133, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "5517c5517e8a7ddb994504f0c5c05001a376b10c", "function_name": "init", "body_hash": "66d58dc105944ee7f02747370ba7b55a4590ef0e"}
{"code": "public static C3P0Config extractXmlConfigFromInputStream(InputStream is) throws Exception\n    {\n        DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();\n\tfact.setExpandEntityReferences(false);\n        DocumentBuilder db = fact.newDocumentBuilder();\n        Document doc = db.parse( is );\n\n        return extractConfigFromXmlDoc(doc);\n    }", "code_tokens": ["public", "static", "C3P0Config", "extractXmlConfigFromInputStream", "(", "InputStream", "is", ")", "throws", "Exception", "{", "DocumentBuilderFactory", "fact", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "fact", ".", "setExpandEntityReferences", "(", "false", ")", ";", "DocumentBuilder", "db", "=", "fact", ".", "newDocumentBuilder", "(", ")", ";", "Document", "doc", "=", "db", ".", "parse", "(", "is", ")", ";", "return", "extractConfigFromXmlDoc", "(", "doc", ")", ";", "}"], "idx": 69567, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "2eb0ea97f745740b18dd45e4a909112d4685f87b", "function_name": "extractXmlConfigFromInputStream", "body_hash": "aa20951fc4fa70c27ea3bc96dae5817b555bcac5"}
{"code": "public C3P0Config findConfig() throws Exception\n    {\n\tC3P0Config out;\n\n\tHashMap flatDefaults = C3P0ConfigUtils.extractHardcodedC3P0Defaults();\n\n\t// this includes System properties, but we have to check for System properties\n\t// again, since we want system properties to override unspecified user, default-config\n\t// properties in the XML\n\tflatDefaults.putAll( C3P0ConfigUtils.extractC3P0PropertiesResources() );\n\n\tString cfgFile = C3P0Config.getPropsFileConfigProperty( XML_CFG_FILE_KEY );\n\tboolean usePermissiveParser = findUsePermissiveParser();\n\t\n\tif (cfgFile == null)\n\t    {\n\t\tC3P0Config xmlConfig = C3P0ConfigXmlUtils.extractXmlConfigFromDefaultResource( usePermissiveParser );\n\t\tif (xmlConfig != null)\n\t\t    {\n\t\t\tinsertDefaultsUnderNascentConfig( flatDefaults, xmlConfig );\n\t\t\tout = xmlConfig;\n\t\t\t\n\t\t\tmbOverrideWarning(\"resource\", C3P0ConfigXmlUtils.XML_CONFIG_RSRC_PATH);\n\t\t    }\n\t\telse\n\t\t    out = C3P0ConfigUtils.configFromFlatDefaults( flatDefaults );\n\t    }\n\telse\n\t    {\n\t\tcfgFile = cfgFile.trim();\n\n\t\tInputStream is = null;\n\t\ttry\n\t\t    {\n\t\t\tif ( cfgFile.startsWith( CLASSLOADER_RESOURCE_PREFIX ) )\n\t\t\t{\n\t\t\t    ClassLoader cl = this.getClass().getClassLoader();\n\t\t\t    String rsrcPath = cfgFile.substring( CLASSLOADER_RESOURCE_PREFIX.length() );\n\n\t\t\t    // eliminate leading slash because ClassLoader.getResource\n\t\t\t    // is always absolute and does not expect a leading slash\n\t\t\t    if (rsrcPath.startsWith(\"/\")) \n\t\t\t\trsrcPath = rsrcPath.substring(1);\n\n\t\t\t    is = cl.getResourceAsStream( rsrcPath );\n\t\t\t    if ( is == null )\n\t\t\t\tthrow new FileNotFoundException(\"Specified ClassLoader resource '\" + rsrcPath + \"' could not be found. \" +\n\t\t\t\t\t\t\t\t\"[ Found in configuration: \" + XML_CFG_FILE_KEY + '=' + cfgFile + \" ]\");\n\n\t\t\t    mbOverrideWarning( \"resource\", rsrcPath );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    is = new BufferedInputStream( new FileInputStream( cfgFile ) );\n\t\t\t    mbOverrideWarning( \"file\", cfgFile );\n\t\t\t}\n\n\t\t\tC3P0Config xmlConfig = C3P0ConfigXmlUtils.extractXmlConfigFromInputStream( is, usePermissiveParser );\n\t\t\tinsertDefaultsUnderNascentConfig( flatDefaults, xmlConfig );\n\t\t\tout = xmlConfig;\n\t\t    }\n\t\tfinally\n\t\t    {\n\t\t\ttry { if (is != null) is.close();}\n\t\t\tcatch (Exception e)\n\t\t\t    { e.printStackTrace(); }\n\t\t    }\n\t    }\n\n\t// overwrite default, unspecified user config with System properties\n\t// defined values\n\tProperties sysPropConfig = C3P0ConfigUtils.findAllC3P0SystemProperties();\n\tout.defaultConfig.props.putAll( sysPropConfig );\n\n\treturn out;\n    }", "code_tokens": ["public", "C3P0Config", "findConfig", "(", ")", "throws", "Exception", "{", "C3P0Config", "out", ";", "HashMap", "flatDefaults", "=", "C3P0ConfigUtils", ".", "extractHardcodedC3P0Defaults", "(", ")", ";", "flatDefaults", ".", "putAll", "(", "C3P0ConfigUtils", ".", "extractC3P0PropertiesResources", "(", ")", ")", ";", "String", "cfgFile", "=", "C3P0Config", ".", "getPropsFileConfigProperty", "(", "XML_CFG_FILE_KEY", ")", ";", "boolean", "usePermissiveParser", "=", "findUsePermissiveParser", "(", ")", ";", "if", "(", "cfgFile", "==", "null", ")", "{", "C3P0Config", "xmlConfig", "=", "C3P0ConfigXmlUtils", ".", "extractXmlConfigFromDefaultResource", "(", "usePermissiveParser", ")", ";", "if", "(", "xmlConfig", "!=", "null", ")", "{", "insertDefaultsUnderNascentConfig", "(", "flatDefaults", ",", "xmlConfig", ")", ";", "out", "=", "xmlConfig", ";", "mbOverrideWarning", "(", "\"", "resource", "\"", ",", "C3P0ConfigXmlUtils", ".", "XML_CONFIG_RSRC_PATH", ")", ";", "}", "else", "out", "=", "C3P0ConfigUtils", ".", "configFromFlatDefaults", "(", "flatDefaults", ")", ";", "}", "else", "{", "cfgFile", "=", "cfgFile", ".", "trim", "(", ")", ";", "InputStream", "is", "=", "null", ";", "try", "{", "if", "(", "cfgFile", ".", "startsWith", "(", "CLASSLOADER_RESOURCE_PREFIX", ")", ")", "{", "ClassLoader", "cl", "=", "this", ".", "getClass", "(", ")", ".", "getClassLoader", "(", ")", ";", "String", "rsrcPath", "=", "cfgFile", ".", "substring", "(", "CLASSLOADER_RESOURCE_PREFIX", ".", "length", "(", ")", ")", ";", "if", "(", "rsrcPath", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "rsrcPath", "=", "rsrcPath", ".", "substring", "(", "1", ")", ";", "is", "=", "cl", ".", "getResourceAsStream", "(", "rsrcPath", ")", ";", "if", "(", "is", "==", "null", ")", "throw", "new", "FileNotFoundException", "(", "\"", "Specified ClassLoader resource '", "\"", "+", "rsrcPath", "+", "\"", "' could not be found. ", "\"", "+", "\"", "[ Found in configuration: ", "\"", "+", "XML_CFG_FILE_KEY", "+", "'='", "+", "cfgFile", "+", "\"", " ]", "\"", ")", ";", "mbOverrideWarning", "(", "\"", "resource", "\"", ",", "rsrcPath", ")", ";", "}", "else", "{", "is", "=", "new", "BufferedInputStream", "(", "new", "FileInputStream", "(", "cfgFile", ")", ")", ";", "mbOverrideWarning", "(", "\"", "file", "\"", ",", "cfgFile", ")", ";", "}", "C3P0Config", "xmlConfig", "=", "C3P0ConfigXmlUtils", ".", "extractXmlConfigFromInputStream", "(", "is", ",", "usePermissiveParser", ")", ";", "insertDefaultsUnderNascentConfig", "(", "flatDefaults", ",", "xmlConfig", ")", ";", "out", "=", "xmlConfig", ";", "}", "finally", "{", "try", "{", "if", "(", "is", "!=", "null", ")", "is", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "}", "}", "Properties", "sysPropConfig", "=", "C3P0ConfigUtils", ".", "findAllC3P0SystemProperties", "(", ")", ";", "out", ".", "defaultConfig", ".", "props", ".", "putAll", "(", "sysPropConfig", ")", ";", "return", "out", ";", "}"], "idx": 76603, "cwe": "CWE-776", "target": 0, "status": "FIXED", "commit": "f38f27635c384806c2a9d6500d80183d9f09d78b", "function_name": "findConfig", "body_hash": "caa015355ada6cd88e6e0e748d27b8e155df72ba"}
{"code": "protected void throwable(BodyWriter w, Throwable throwable, boolean isCause) {\n    if (throwable != null) {\n      if (isCause) {\n        w.escape(\"Caused by: \");\n      }\n\n      w.println(throwable.toString());\n      for (StackTraceElement ste : throwable.getStackTrace()) {\n        String className = ste.getClassName();\n        if (className.startsWith(\"ratpack\")\n          || className.startsWith(\"io.netty\")\n          || className.startsWith(\"com.google\")\n          || className.startsWith(\"java\")\n          || className.startsWith(\"org.springsource.loaded\")\n          ) {\n          w.print(\"<span class='stack-core'>  at \").escape(ste.toString()).println(\"</span>\");\n        } else {\n          w.print(\"  at \").escape(ste.toString()).println(\"\");\n        }\n      }\n\n      throwable(w, throwable.getCause(), true);\n    }\n  }", "code_tokens": ["protected", "void", "throwable", "(", "BodyWriter", "w", ",", "Throwable", "throwable", ",", "boolean", "isCause", ")", "{", "if", "(", "throwable", "!=", "null", ")", "{", "if", "(", "isCause", ")", "{", "w", ".", "escape", "(", "\"", "Caused by: ", "\"", ")", ";", "}", "w", ".", "println", "(", "throwable", ".", "toString", "(", ")", ")", ";", "for", "(", "StackTraceElement", "ste", ":", "throwable", ".", "getStackTrace", "(", ")", ")", "{", "String", "className", "=", "ste", ".", "getClassName", "(", ")", ";", "if", "(", "className", ".", "startsWith", "(", "\"", "ratpack", "\"", ")", "||", "className", ".", "startsWith", "(", "\"", "io.netty", "\"", ")", "||", "className", ".", "startsWith", "(", "\"", "com.google", "\"", ")", "||", "className", ".", "startsWith", "(", "\"", "java", "\"", ")", "||", "className", ".", "startsWith", "(", "\"", "org.springsource.loaded", "\"", ")", ")", "{", "w", ".", "print", "(", "\"", "<span class='stack-core'>  at ", "\"", ")", ".", "escape", "(", "ste", ".", "toString", "(", ")", ")", ".", "println", "(", "\"", "</span>", "\"", ")", ";", "}", "else", "{", "w", ".", "print", "(", "\"", "  at ", "\"", ")", ".", "escape", "(", "ste", ".", "toString", "(", ")", ")", ".", "println", "(", "\"", "\"", ")", ";", "}", "}", "throwable", "(", "w", ",", "throwable", ".", "getCause", "(", ")", ",", "true", ")", ";", "}", "}"], "idx": 79872, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "a3cbb13be1527874528c3b99fc33517c0297b6d3", "function_name": "throwable", "body_hash": "322b36339348022261ff1b2155a8f052d909489c"}
{"code": "private String getBodyContentAsString() {\n\t\tif (body == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tString contentType = (messageProperties != null) ? messageProperties.getContentType() : null;\n\t\t\tif (MessageProperties.CONTENT_TYPE_SERIALIZED_OBJECT.equals(contentType)) {\n\t\t\t\treturn SERIALIZER_MESSAGE_CONVERTER.fromMessage(this).toString();\n\t\t\t}\n\t\t\tif (MessageProperties.CONTENT_TYPE_TEXT_PLAIN.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON_ALT.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_XML.equals(contentType)) {\n\t\t\t\treturn new String(body, ENCODING);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t\t// Comes out as '[B@....b' (so harmless)\n\t\treturn body.toString()+\"(byte[\"+body.length+\"])\";//NOSONAR\n\t}", "code_tokens": ["private", "String", "getBodyContentAsString", "(", ")", "{", "if", "(", "body", "==", "null", ")", "{", "return", "null", ";", "}", "try", "{", "String", "contentType", "=", "(", "messageProperties", "!=", "null", ")", "?", "messageProperties", ".", "getContentType", "(", ")", ":", "null", ";", "if", "(", "MessageProperties", ".", "CONTENT_TYPE_SERIALIZED_OBJECT", ".", "equals", "(", "contentType", ")", ")", "{", "return", "SERIALIZER_MESSAGE_CONVERTER", ".", "fromMessage", "(", "this", ")", ".", "toString", "(", ")", ";", "}", "if", "(", "MessageProperties", ".", "CONTENT_TYPE_TEXT_PLAIN", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_JSON", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_JSON_ALT", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_XML", ".", "equals", "(", "contentType", ")", ")", "{", "return", "new", "String", "(", "body", ",", "ENCODING", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "}", "return", "body", ".", "toString", "(", ")", "+", "\"", "(byte[", "\"", "+", "body", ".", "length", "+", "\"", "])", "\"", ";", "}"], "idx": 61699, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "83fe9fdec2c86a57898d56c5e109debd9d5c07d", "function_name": "getBodyContentAsString", "body_hash": "a39da4f5fe02340baede5171cd390c8558652c9a"}
{"code": "@Override\n    public void init(ServletConfig config) throws ServletException {\n\n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n\n        // Initialize the JSP Runtime Context\n        // Check for a custom Options implementation\n        String engineOptionsName = config.getInitParameter(\"engineOptionsClass\");\n        if (engineOptionsName != null) {\n            // Instantiate the indicated Options implementation\n            try {\n                ClassLoader loader = Thread.currentThread().getContextClassLoader();\n                Class<?> engineOptionsClass = loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig = { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor = engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                // Need to localize this.\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                // Use the default Options implementation\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            // Use the default Options implementation\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    return;\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"cannot locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "init", "(", "ServletConfig", "config", ")", "throws", "ServletException", "{", "super", ".", "init", "(", "config", ")", ";", "this", ".", "config", "=", "config", ";", "this", ".", "context", "=", "config", ".", "getServletContext", "(", ")", ";", "String", "engineOptionsName", "=", "config", ".", "getInitParameter", "(", "\"", "engineOptionsClass", "\"", ")", ";", "if", "(", "engineOptionsName", "!=", "null", ")", "{", "try", "{", "ClassLoader", "loader", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "Class", "<", "?", ">", "engineOptionsClass", "=", "loader", ".", "loadClass", "(", "engineOptionsName", ")", ";", "Class", "<", "?", ">", "[", "]", "ctorSig", "=", "{", "ServletConfig", ".", "class", ",", "ServletContext", ".", "class", "}", ";", "Constructor", "<", "?", ">", "ctor", "=", "engineOptionsClass", ".", "getConstructor", "(", "ctorSig", ")", ";", "Object", "[", "]", "args", "=", "{", "config", ",", "context", "}", ";", "options", "=", "(", "Options", ")", "ctor", ".", "newInstance", "(", "args", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "e", "=", "ExceptionUtils", ".", "unwrapInvocationTargetException", "(", "e", ")", ";", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "log", ".", "warn", "(", "\"", "Failed to load engineOptionsClass", "\"", ",", "e", ")", ";", "options", "=", "new", "EmbeddedServletOptions", "(", "config", ",", "context", ")", ";", "}", "}", "else", "{", "options", "=", "new", "EmbeddedServletOptions", "(", "config", ",", "context", ")", ";", "}", "rctxt", "=", "new", "JspRuntimeContext", "(", "context", ",", "options", ")", ";", "if", "(", "config", ".", "getInitParameter", "(", "\"", "jspFile", "\"", ")", "!=", "null", ")", "{", "jspFile", "=", "config", ".", "getInitParameter", "(", "\"", "jspFile", "\"", ")", ";", "try", "{", "if", "(", "null", "==", "context", ".", "getResource", "(", "jspFile", ")", ")", "{", "return", ";", "}", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "throw", "new", "ServletException", "(", "\"", "cannot locate jsp file", "\"", ",", "e", ")", ";", "}", "try", "{", "if", "(", "SecurityUtil", ".", "isPackageProtectionEnabled", "(", ")", ")", "{", "AccessController", ".", "doPrivileged", "(", "new", "PrivilegedExceptionAction", "<", "Object", ">", "(", ")", "{", "@", "Override", "public", "Object", "run", "(", ")", "throws", "IOException", ",", "ServletException", "{", "serviceJspFile", "(", "null", ",", "null", ",", "jspFile", ",", "true", ")", ";", "return", "null", ";", "}", "}", ")", ";", "}", "else", "{", "serviceJspFile", "(", "null", ",", "null", ",", "jspFile", ",", "true", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "ServletException", "(", "\"", "Could not precompile jsp: ", "\"", "+", "jspFile", ",", "e", ")", ";", "}", "catch", "(", "PrivilegedActionException", "e", ")", "{", "Throwable", "t", "=", "e", ".", "getCause", "(", ")", ";", "if", "(", "t", "instanceof", "ServletException", ")", "throw", "(", "ServletException", ")", "t", ";", "throw", "new", "ServletException", "(", "\"", "Could not precompile jsp: ", "\"", "+", "jspFile", ",", "e", ")", ";", "}", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.message.scratch.dir.is", "\"", ",", "options", ".", "getScratchDir", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "log", ".", "debug", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.message.dont.modify.servlets", "\"", ")", ")", ";", "}", "}"], "idx": 101831, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "f603f2f4595073f9490e01699d2083112a7c09a7", "function_name": "init", "body_hash": "cfb90ce96974d5134e7163205ac00b8e766c0e51"}
{"code": "public void copyDirectoryFromPod(\n      String namespace,\n      String pod,\n      String container,\n      String srcPath,\n      Path destination,\n      boolean enableTarCompressing)\n      throws IOException, ApiException {\n    if (!enableTarCompressing) {\n      TreeNode tree = new TreeNode(true, srcPath, true);\n      createDirectoryTree(tree, namespace, pod, container, srcPath);\n      createDirectoryStructureFromTree(tree, namespace, pod, container, srcPath, destination);\n      return;\n    }\n    final Process proc =\n        this.exec(\n            namespace,\n            pod,\n            new String[] {\"sh\", \"-c\", \"tar cz - \" + srcPath + \" | base64\"},\n            container,\n            false,\n            false);\n    try (InputStream is = new Base64InputStream(new BufferedInputStream(proc.getInputStream()));\n        ArchiveInputStream archive = new TarArchiveInputStream(new GzipCompressorInputStream(is))) {\n      for (ArchiveEntry entry = archive.getNextEntry();\n          entry != null;\n          entry = archive.getNextEntry()) {\n        if (!archive.canReadEntryData(entry)) {\n          log.error(\"Can't read: \" + entry);\n          continue;\n        }\n        File f = new File(destination.toFile(), entry.getName());\n        if (entry.isDirectory()) {\n          if (!f.isDirectory() && !f.mkdirs()) {\n            throw new IOException(\"create directory failed: \" + f);\n          }\n        } else {\n          File parent = f.getParentFile();\n          if (!parent.isDirectory() && !parent.mkdirs()) {\n            throw new IOException(\"create directory failed: \" + parent);\n          }\n          try (OutputStream fs = new FileOutputStream(f)) {\n            ByteStreams.copy(archive, fs);\n            fs.flush();\n          }\n        }\n      }\n    }\n    try {\n      int status = proc.waitFor();\n      if (status != 0) {\n        throw new IOException(\"Copy command failed with status \" + status);\n      }\n    } catch (InterruptedException ex) {\n      throw new IOException(ex);\n    }\n  }", "code_tokens": ["public", "void", "copyDirectoryFromPod", "(", "String", "namespace", ",", "String", "pod", ",", "String", "container", ",", "String", "srcPath", ",", "Path", "destination", ",", "boolean", "enableTarCompressing", ")", "throws", "IOException", ",", "ApiException", "{", "if", "(", "!", "enableTarCompressing", ")", "{", "TreeNode", "tree", "=", "new", "TreeNode", "(", "true", ",", "srcPath", ",", "true", ")", ";", "createDirectoryTree", "(", "tree", ",", "namespace", ",", "pod", ",", "container", ",", "srcPath", ")", ";", "createDirectoryStructureFromTree", "(", "tree", ",", "namespace", ",", "pod", ",", "container", ",", "srcPath", ",", "destination", ")", ";", "return", ";", "}", "final", "Process", "proc", "=", "this", ".", "exec", "(", "namespace", ",", "pod", ",", "new", "String", "[", "]", "{", "\"", "sh", "\"", ",", "\"", "-c", "\"", ",", "\"", "tar cz - ", "\"", "+", "srcPath", "+", "\"", " | base64", "\"", "}", ",", "container", ",", "false", ",", "false", ")", ";", "try", "(", "InputStream", "is", "=", "new", "Base64InputStream", "(", "new", "BufferedInputStream", "(", "proc", ".", "getInputStream", "(", ")", ")", ")", ";", "ArchiveInputStream", "archive", "=", "new", "TarArchiveInputStream", "(", "new", "GzipCompressorInputStream", "(", "is", ")", ")", ")", "{", "for", "(", "ArchiveEntry", "entry", "=", "archive", ".", "getNextEntry", "(", ")", ";", "entry", "!=", "null", ";", "entry", "=", "archive", ".", "getNextEntry", "(", ")", ")", "{", "if", "(", "!", "archive", ".", "canReadEntryData", "(", "entry", ")", ")", "{", "log", ".", "error", "(", "\"", "Can't read: ", "\"", "+", "entry", ")", ";", "continue", ";", "}", "File", "f", "=", "new", "File", "(", "destination", ".", "toFile", "(", ")", ",", "entry", ".", "getName", "(", ")", ")", ";", "if", "(", "entry", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "f", ".", "isDirectory", "(", ")", "&&", "!", "f", ".", "mkdirs", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "create directory failed: ", "\"", "+", "f", ")", ";", "}", "}", "else", "{", "File", "parent", "=", "f", ".", "getParentFile", "(", ")", ";", "if", "(", "!", "parent", ".", "isDirectory", "(", ")", "&&", "!", "parent", ".", "mkdirs", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "create directory failed: ", "\"", "+", "parent", ")", ";", "}", "try", "(", "OutputStream", "fs", "=", "new", "FileOutputStream", "(", "f", ")", ")", "{", "ByteStreams", ".", "copy", "(", "archive", ",", "fs", ")", ";", "fs", ".", "flush", "(", ")", ";", "}", "}", "}", "}", "try", "{", "int", "status", "=", "proc", ".", "waitFor", "(", ")", ";", "if", "(", "status", "!=", "0", ")", "{", "throw", "new", "IOException", "(", "\"", "Copy command failed with status ", "\"", "+", "status", ")", ";", "}", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "throw", "new", "IOException", "(", "ex", ")", ";", "}", "}"], "idx": 28736, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "eb2cfe945c1492503b086606734530550630d31f", "function_name": "copyDirectoryFromPod", "body_hash": "522bc183642fc393048d063037ed33a26659d264"}
{"code": "public static DotCorpus parseDotCorpus(InputStream dotCorpusStream) throws CoreException {\r\n    DocumentBuilderFactory documentBuilderFacoty = DocumentBuilderFactory.newInstance();\r\n\r\n    DocumentBuilder documentBuilder;\r\n\r\n    try {\r\n      documentBuilder = documentBuilderFacoty.newDocumentBuilder();\r\n    } catch (ParserConfigurationException e) {\r\n      String message = \"This should never happen:\" + (e.getMessage() != null ? e.getMessage() : \"\");\r\n\r\n      IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\r\n\r\n      throw new CoreException(s);\r\n    }\r\n\r\n    org.w3c.dom.Document dotCorpusDOM;\r\n\r\n    try {\r\n      dotCorpusDOM = documentBuilder.parse(dotCorpusStream);\r\n    } catch (SAXException e) {\r\n      String message = e.getMessage() != null ? e.getMessage() : \"\";\r\n\r\n      IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\r\n\r\n      throw new CoreException(s);\r\n    } catch (IOException e) {\r\n      String message = e.getMessage() != null ? e.getMessage() : \"\";\r\n\r\n      IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\r\n\r\n      throw new CoreException(s);\r\n    }\r\n\r\n    DotCorpus dotCorpus = new DotCorpus();\r\n\r\n    // get corpora root element\r\n    Element configElement = dotCorpusDOM.getDocumentElement();\r\n\r\n    if (CONFIG_ELEMENT.equals(configElement.getNodeName())) {\r\n      // TODO:\r\n      // throw exception\r\n    }\r\n\r\n    NodeList corporaChildNodes = configElement.getChildNodes();\r\n\r\n    for (int i = 0; i < corporaChildNodes.getLength(); i++) {\r\n      Node corporaChildNode = corporaChildNodes.item(i);\r\n\r\n      if (!(corporaChildNode instanceof Element)) {\r\n        continue;\r\n      }\r\n\r\n      Element corporaChildElement = (Element) corporaChildNode;\r\n\r\n      // TODO: This code will emit NumberFormatExceptions if the values\r\n      // are incorrect, they should be caught, logged and replaced with default\r\n      // values\r\n      \r\n      if (TYPESYSTEM_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        dotCorpus.setTypeSystemFilename(corporaChildElement.getAttribute(TYPESYTEM_FILE_ATTRIBUTE));\r\n      } else if (CORPUS_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        String corpusFolderName = corporaChildElement.getAttribute(CORPUS_FOLDER_ATTRIBUTE);\r\n\r\n        dotCorpus.addCorpusFolder(corpusFolderName);\r\n      } else if (STYLE_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        String type = corporaChildElement.getAttribute(STYLE_TYPE_ATTRIBUTE);\r\n\r\n        String styleString = corporaChildElement.getAttribute(STYLE_STYLE_ATTRIBUTE);\r\n\r\n        int colorInteger = Integer\r\n                .parseInt(corporaChildElement.getAttribute(STYLE_COLOR_ATTRIBUTE));\r\n\r\n        Color color = new Color(colorInteger);\r\n\r\n        String drawingLayerString = corporaChildElement.getAttribute(STYLE_LAYER_ATTRIBUTE);\r\n        \r\n        String drawingConfigString = corporaChildElement.getAttribute(STYLE_CONFIG_ATTRIBUTE);\r\n        \r\n        if (drawingConfigString.length() == 0)\r\n          drawingConfigString = null;\r\n        \r\n        int drawingLayer;\r\n\r\n        try {\r\n          drawingLayer = Integer.parseInt(drawingLayerString);\r\n        } catch (NumberFormatException e) {\r\n          drawingLayer = 0;\r\n        }\r\n\r\n        AnnotationStyle style = new AnnotationStyle(type, AnnotationStyle.Style\r\n                .valueOf(styleString), color, drawingLayer, drawingConfigString);\r\n\r\n        dotCorpus.setStyle(style);\r\n      } else if (CAS_PROCESSOR_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        dotCorpus.addCasProcessorFolder(corporaChildElement\r\n                .getAttribute(CAS_PROCESSOR_FOLDER_ATTRIBUTE));\r\n      } else if (EDITOR_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        String lineLengthHintString = corporaChildElement\r\n                .getAttribute(EDITOR_LINE_LENGTH_ATTRIBUTE);\r\n\r\n        int lineLengthHint = Integer.parseInt(lineLengthHintString);\r\n\r\n        dotCorpus.setEditorLineLength(lineLengthHint);\r\n      } else if (SHOWN_ELEMENT.equals(corporaChildElement.getNodeName())) {\r\n        String type = corporaChildElement.getAttribute(SHOWN_TYPE_ATTRIBUTE);\r\n        \r\n        String isVisisbleString = corporaChildElement.getAttribute(SHOWN_IS_VISISBLE_ATTRIBUTE);\r\n        \r\n        boolean isVisible = Boolean.parseBoolean(isVisisbleString);\r\n        \r\n        if (isVisible) {\r\n          dotCorpus.setShownType(type); \r\n        }\r\n      }\r\n      else {\r\n        String message = \"Unexpected element: \" + corporaChildElement.getNodeName();\r\n\r\n        IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, null);\r\n\r\n        throw new CoreException(s);\r\n      }\r\n    }\r\n\r\n    return dotCorpus;\r\n  }", "code_tokens": ["public", "static", "DotCorpus", "parseDotCorpus", "(", "InputStream", "dotCorpusStream", ")", "throws", "CoreException", "{", "DocumentBuilderFactory", "documentBuilderFacoty", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "DocumentBuilder", "documentBuilder", ";", "try", "{", "documentBuilder", "=", "documentBuilderFacoty", ".", "newDocumentBuilder", "(", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e", ")", "{", "String", "message", "=", "\"", "This should never happen:", "\"", "+", "(", "e", ".", "getMessage", "(", ")", "!=", "null", "?", "e", ".", "getMessage", "(", ")", ":", "\"", "\"", ")", ";", "IStatus", "s", "=", "new", "Status", "(", "IStatus", ".", "ERROR", ",", "CasEditorPlugin", ".", "ID", ",", "IStatus", ".", "OK", ",", "message", ",", "e", ")", ";", "throw", "new", "CoreException", "(", "s", ")", ";", "}", "org", ".", "w3c", ".", "dom", ".", "Document", "dotCorpusDOM", ";", "try", "{", "dotCorpusDOM", "=", "documentBuilder", ".", "parse", "(", "dotCorpusStream", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "String", "message", "=", "e", ".", "getMessage", "(", ")", "!=", "null", "?", "e", ".", "getMessage", "(", ")", ":", "\"", "\"", ";", "IStatus", "s", "=", "new", "Status", "(", "IStatus", ".", "ERROR", ",", "CasEditorPlugin", ".", "ID", ",", "IStatus", ".", "OK", ",", "message", ",", "e", ")", ";", "throw", "new", "CoreException", "(", "s", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "String", "message", "=", "e", ".", "getMessage", "(", ")", "!=", "null", "?", "e", ".", "getMessage", "(", ")", ":", "\"", "\"", ";", "IStatus", "s", "=", "new", "Status", "(", "IStatus", ".", "ERROR", ",", "CasEditorPlugin", ".", "ID", ",", "IStatus", ".", "OK", ",", "message", ",", "e", ")", ";", "throw", "new", "CoreException", "(", "s", ")", ";", "}", "DotCorpus", "dotCorpus", "=", "new", "DotCorpus", "(", ")", ";", "Element", "configElement", "=", "dotCorpusDOM", ".", "getDocumentElement", "(", ")", ";", "if", "(", "CONFIG_ELEMENT", ".", "equals", "(", "configElement", ".", "getNodeName", "(", ")", ")", ")", "{", "}", "NodeList", "corporaChildNodes", "=", "configElement", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "corporaChildNodes", ".", "getLength", "(", ")", ";", "i", "++", ")", "{", "Node", "corporaChildNode", "=", "corporaChildNodes", ".", "item", "(", "i", ")", ";", "if", "(", "!", "(", "corporaChildNode", "instanceof", "Element", ")", ")", "{", "continue", ";", "}", "Element", "corporaChildElement", "=", "(", "Element", ")", "corporaChildNode", ";", "if", "(", "TYPESYSTEM_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "dotCorpus", ".", "setTypeSystemFilename", "(", "corporaChildElement", ".", "getAttribute", "(", "TYPESYTEM_FILE_ATTRIBUTE", ")", ")", ";", "}", "else", "if", "(", "CORPUS_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "corpusFolderName", "=", "corporaChildElement", ".", "getAttribute", "(", "CORPUS_FOLDER_ATTRIBUTE", ")", ";", "dotCorpus", ".", "addCorpusFolder", "(", "corpusFolderName", ")", ";", "}", "else", "if", "(", "STYLE_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "type", "=", "corporaChildElement", ".", "getAttribute", "(", "STYLE_TYPE_ATTRIBUTE", ")", ";", "String", "styleString", "=", "corporaChildElement", ".", "getAttribute", "(", "STYLE_STYLE_ATTRIBUTE", ")", ";", "int", "colorInteger", "=", "Integer", ".", "parseInt", "(", "corporaChildElement", ".", "getAttribute", "(", "STYLE_COLOR_ATTRIBUTE", ")", ")", ";", "Color", "color", "=", "new", "Color", "(", "colorInteger", ")", ";", "String", "drawingLayerString", "=", "corporaChildElement", ".", "getAttribute", "(", "STYLE_LAYER_ATTRIBUTE", ")", ";", "String", "drawingConfigString", "=", "corporaChildElement", ".", "getAttribute", "(", "STYLE_CONFIG_ATTRIBUTE", ")", ";", "if", "(", "drawingConfigString", ".", "length", "(", ")", "==", "0", ")", "drawingConfigString", "=", "null", ";", "int", "drawingLayer", ";", "try", "{", "drawingLayer", "=", "Integer", ".", "parseInt", "(", "drawingLayerString", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "drawingLayer", "=", "0", ";", "}", "AnnotationStyle", "style", "=", "new", "AnnotationStyle", "(", "type", ",", "AnnotationStyle", ".", "Style", ".", "valueOf", "(", "styleString", ")", ",", "color", ",", "drawingLayer", ",", "drawingConfigString", ")", ";", "dotCorpus", ".", "setStyle", "(", "style", ")", ";", "}", "else", "if", "(", "CAS_PROCESSOR_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "dotCorpus", ".", "addCasProcessorFolder", "(", "corporaChildElement", ".", "getAttribute", "(", "CAS_PROCESSOR_FOLDER_ATTRIBUTE", ")", ")", ";", "}", "else", "if", "(", "EDITOR_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "lineLengthHintString", "=", "corporaChildElement", ".", "getAttribute", "(", "EDITOR_LINE_LENGTH_ATTRIBUTE", ")", ";", "int", "lineLengthHint", "=", "Integer", ".", "parseInt", "(", "lineLengthHintString", ")", ";", "dotCorpus", ".", "setEditorLineLength", "(", "lineLengthHint", ")", ";", "}", "else", "if", "(", "SHOWN_ELEMENT", ".", "equals", "(", "corporaChildElement", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "type", "=", "corporaChildElement", ".", "getAttribute", "(", "SHOWN_TYPE_ATTRIBUTE", ")", ";", "String", "isVisisbleString", "=", "corporaChildElement", ".", "getAttribute", "(", "SHOWN_IS_VISISBLE_ATTRIBUTE", ")", ";", "boolean", "isVisible", "=", "Boolean", ".", "parseBoolean", "(", "isVisisbleString", ")", ";", "if", "(", "isVisible", ")", "{", "dotCorpus", ".", "setShownType", "(", "type", ")", ";", "}", "}", "else", "{", "String", "message", "=", "\"", "Unexpected element: ", "\"", "+", "corporaChildElement", ".", "getNodeName", "(", ")", ";", "IStatus", "s", "=", "new", "Status", "(", "IStatus", ".", "ERROR", ",", "CasEditorPlugin", ".", "ID", ",", "IStatus", ".", "OK", ",", "message", ",", "null", ")", ";", "throw", "new", "CoreException", "(", "s", ")", ";", "}", "}", "return", "dotCorpus", ";", "}"], "idx": 70514, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "39909bf21fd694f4fb792d1de8adc72562ead25e", "function_name": "parseDotCorpus", "body_hash": "681a897fee10210f3737272c7601f5c5931b4f50"}
{"code": "@Override\n    protected void onFullPongMessage(final WebSocketChannel webSocketChannel, BufferedBinaryMessage bufferedBinaryMessage) {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            bufferedBinaryMessage.getData().free();\n            return;\n        }\n        final HandlerWrapper handler = getHandler(FrameType.PONG);\n        if (handler != null) {\n            final Pooled<ByteBuffer[]> pooled = bufferedBinaryMessage.getData();\n            final PongMessage message = DefaultPongMessage.create(toBuffer(pooled.getResource()));\n\n            session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        ((MessageHandler.Whole) handler.getHandler()).onMessage(message);\n                    } catch (Exception e) {\n                        invokeOnError(e);\n                    } finally {\n                        pooled.close();\n                    }\n                }\n            });\n        } else {\n            bufferedBinaryMessage.getData().free();\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "onFullPongMessage", "(", "final", "WebSocketChannel", "webSocketChannel", ",", "BufferedBinaryMessage", "bufferedBinaryMessage", ")", "{", "if", "(", "session", ".", "isSessionClosed", "(", ")", ")", "{", "bufferedBinaryMessage", ".", "getData", "(", ")", ".", "free", "(", ")", ";", "return", ";", "}", "final", "HandlerWrapper", "handler", "=", "getHandler", "(", "FrameType", ".", "PONG", ")", ";", "if", "(", "handler", "!=", "null", ")", "{", "final", "Pooled", "<", "ByteBuffer", "[", "]", ">", "pooled", "=", "bufferedBinaryMessage", ".", "getData", "(", ")", ";", "final", "PongMessage", "message", "=", "DefaultPongMessage", ".", "create", "(", "toBuffer", "(", "pooled", ".", "getResource", "(", ")", ")", ")", ";", "session", ".", "getContainer", "(", ")", ".", "invokeEndpointMethod", "(", "executor", ",", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "try", "{", "(", "(", "MessageHandler", ".", "Whole", ")", "handler", ".", "getHandler", "(", ")", ")", ".", "onMessage", "(", "message", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "invokeOnError", "(", "e", ")", ";", "}", "finally", "{", "pooled", ".", "close", "(", ")", ";", "}", "}", "}", ")", ";", "}", "else", "{", "bufferedBinaryMessage", ".", "getData", "(", ")", ".", "free", "(", ")", ";", "}", "}"], "idx": 52807, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "c7e84a0b7efced38506d7d1dfea5902366973877", "function_name": "onFullPongMessage", "body_hash": "0e347dedbced5855390c909833567b2811a717cd"}
{"code": "public Object extractValue(String strVal)\r\n   {\r\n      if (strVal == null)\r\n      {\r\n         if (defaultValue == null)\r\n         {\r\n            //System.out.println(\"NO DEFAULT VALUE\");\r\n            if (!StringToPrimitive.isPrimitive(baseType)) return null;\r\n            else\r\n               return StringToPrimitive.stringToPrimitiveBoxType(baseType, strVal);\r\n         }\r\n         else\r\n         {\r\n            strVal = defaultValue;\r\n            //System.out.println(\"DEFAULT VAULUE: \" + strVal);\r\n         }\r\n      }\r\n      if (paramConverter != null)\r\n      {\r\n         try {\r\n            return paramConverter.fromString(strVal);\r\n         } catch (Exception pce) {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\r\n                    getParamSignature(), strVal, target), pce);\r\n         }\r\n      }\r\n      if (unmarshaller != null)\r\n      {\r\n         try {\r\n         return unmarshaller.fromString(strVal);\r\n         } catch (Exception ue) {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\r\n                    getParamSignature(), strVal, target), ue);\r\n         }\r\n      }\r\n      else if (delegate != null)\r\n      {\r\n         try {\r\n            return delegate.fromString(strVal);\r\n         } catch (Exception pce) {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\r\n                    getParamSignature(), strVal, target), pce);\r\n         }\r\n      }\r\n      else if (constructor != null)\r\n      {\r\n         try\r\n         {\r\n            return constructor.newInstance(strVal);\r\n         }\r\n         catch (InstantiationException e)\r\n         {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), e);\r\n         }\r\n         catch (IllegalAccessException e)\r\n         {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), e);\r\n         }\r\n         catch (InvocationTargetException e)\r\n         {\r\n            Throwable targetException = e.getTargetException();\r\n            if (targetException instanceof WebApplicationException)\r\n            {\r\n               throw ((WebApplicationException)targetException);\r\n            }\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), targetException);\r\n         }\r\n      }\r\n      else if (valueOf != null)\r\n      {\r\n         try\r\n         {\r\n            return valueOf.invoke(null, strVal);\r\n         }\r\n         catch (IllegalAccessException e)\r\n         {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), e);\r\n         }\r\n         catch (InvocationTargetException e)\r\n         {\r\n            Throwable targetException = e.getTargetException();\r\n            if (targetException instanceof WebApplicationException)\r\n            {\r\n               throw ((WebApplicationException)targetException);\r\n            }\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), targetException);\r\n         }\r\n      }\r\n      try\r\n      {\r\n         if (StringToPrimitive.isPrimitive(baseType)) return StringToPrimitive.stringToPrimitiveBoxType(baseType, strVal);\r\n      }\r\n      catch (Exception e)\r\n      {\r\n         throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), e);\r\n      }\r\n      return null;\r\n   }", "code_tokens": ["public", "Object", "extractValue", "(", "String", "strVal", ")", "{", "if", "(", "strVal", "==", "null", ")", "{", "if", "(", "defaultValue", "==", "null", ")", "{", "if", "(", "!", "StringToPrimitive", ".", "isPrimitive", "(", "baseType", ")", ")", "return", "null", ";", "else", "return", "StringToPrimitive", ".", "stringToPrimitiveBoxType", "(", "baseType", ",", "strVal", ")", ";", "}", "else", "{", "strVal", "=", "defaultValue", ";", "}", "}", "if", "(", "paramConverter", "!=", "null", ")", "{", "try", "{", "return", "paramConverter", ".", "fromString", "(", "strVal", ")", ";", "}", "catch", "(", "Exception", "pce", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "pce", ")", ";", "}", "}", "if", "(", "unmarshaller", "!=", "null", ")", "{", "try", "{", "return", "unmarshaller", ".", "fromString", "(", "strVal", ")", ";", "}", "catch", "(", "Exception", "ue", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "ue", ")", ";", "}", "}", "else", "if", "(", "delegate", "!=", "null", ")", "{", "try", "{", "return", "delegate", ".", "fromString", "(", "strVal", ")", ";", "}", "catch", "(", "Exception", "pce", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "pce", ")", ";", "}", "}", "else", "if", "(", "constructor", "!=", "null", ")", "{", "try", "{", "return", "constructor", ".", "newInstance", "(", "strVal", ")", ";", "}", "catch", "(", "InstantiationException", "e", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "e", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "e", ")", ";", "}", "catch", "(", "InvocationTargetException", "e", ")", "{", "Throwable", "targetException", "=", "e", ".", "getTargetException", "(", ")", ";", "if", "(", "targetException", "instanceof", "WebApplicationException", ")", "{", "throw", "(", "(", "WebApplicationException", ")", "targetException", ")", ";", "}", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "targetException", ")", ";", "}", "}", "else", "if", "(", "valueOf", "!=", "null", ")", "{", "try", "{", "return", "valueOf", ".", "invoke", "(", "null", ",", "strVal", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "e", ")", ";", "}", "catch", "(", "InvocationTargetException", "e", ")", "{", "Throwable", "targetException", "=", "e", ".", "getTargetException", "(", ")", ";", "if", "(", "targetException", "instanceof", "WebApplicationException", ")", "{", "throw", "(", "(", "WebApplicationException", ")", "targetException", ")", ";", "}", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "targetException", ")", ";", "}", "}", "try", "{", "if", "(", "StringToPrimitive", ".", "isPrimitive", "(", "baseType", ")", ")", "return", "StringToPrimitive", ".", "stringToPrimitiveBoxType", "(", "baseType", ",", "strVal", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "e", ")", ";", "}", "return", "null", ";", "}"], "idx": 79886, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "791e107", "function_name": "extractValue", "body_hash": "082633e0c666eb2239ac5107966bd5f33d96c6cd"}
{"code": "@Override\n  public void Authenticate(String user, String password) throws AuthenticationException {\n\n    Hashtable<String, Object> env = new Hashtable<String, Object>();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n    env.put(Context.PROVIDER_URL, ldapURL);\n\n    // If the domain is available in the config, then append it unless domain is\n    // already part of the username. LDAP providers like Active Directory use a\n    // fully qualified user name like foo@bar.com.\n    if (!hasDomain(user) && ldapDomain != null) {\n      user  = user + \"@\" + ldapDomain;\n    }\n\n    // setup the security principal\n    String bindDN;\n    if (baseDN == null) {\n      bindDN = user;\n    } else {\n      bindDN = \"uid=\" + user + \",\" + baseDN;\n    }\n    env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n    env.put(Context.SECURITY_PRINCIPAL, bindDN);\n    env.put(Context.SECURITY_CREDENTIALS, password);\n\n    try {\n      // Create initial context\n      Context ctx = new InitialDirContext(env);\n      ctx.close();\n    } catch (NamingException e) {\n      throw new AuthenticationException(\"Error validating LDAP user\", e);\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "Authenticate", "(", "String", "user", ",", "String", "password", ")", "throws", "AuthenticationException", "{", "Hashtable", "<", "String", ",", "Object", ">", "env", "=", "new", "Hashtable", "<", "String", ",", "Object", ">", "(", ")", ";", "env", ".", "put", "(", "Context", ".", "INITIAL_CONTEXT_FACTORY", ",", "\"", "com.sun.jndi.ldap.LdapCtxFactory", "\"", ")", ";", "env", ".", "put", "(", "Context", ".", "PROVIDER_URL", ",", "ldapURL", ")", ";", "if", "(", "!", "hasDomain", "(", "user", ")", "&&", "ldapDomain", "!=", "null", ")", "{", "user", "=", "user", "+", "\"", "@", "\"", "+", "ldapDomain", ";", "}", "String", "bindDN", ";", "if", "(", "baseDN", "==", "null", ")", "{", "bindDN", "=", "user", ";", "}", "else", "{", "bindDN", "=", "\"", "uid=", "\"", "+", "user", "+", "\"", ",", "\"", "+", "baseDN", ";", "}", "env", ".", "put", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "\"", "simple", "\"", ")", ";", "env", ".", "put", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "bindDN", ")", ";", "env", ".", "put", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "password", ")", ";", "try", "{", "Context", "ctx", "=", "new", "InitialDirContext", "(", "env", ")", ";", "ctx", ".", "close", "(", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Error validating LDAP user", "\"", ",", "e", ")", ";", "}", "}"], "idx": 39188, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "6929846a8120eaf094b914b4ca8af80b65f891c8", "function_name": "Authenticate", "body_hash": "6fba6f846766e20d955a7829e6707f124b061ffb"}
{"code": "@Override public SubversionChangeLogSet parse(@SuppressWarnings(\"rawtypes\") Run build, RepositoryBrowser<?> browser, File changelogFile) throws IOException, SAXException {\n        // http://svn.apache.org/repos/asf/subversion/trunk/subversion/svn/schema/log.rnc\n\n        Digester digester = new Digester2();\n        if (!Boolean.getBoolean(SubversionChangeLogParser.class.getName() + \".UNSAFE\")) {\n            try {\n                digester.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n                digester.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                digester.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n                digester.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            } catch (ParserConfigurationException ex) {\n                LOGGER.log(Level.WARNING, \"Failed to securely configure Subversion changelog parser\", ex);\n                throw new SAXException(\"Failed to securely configure Subversion changelog parser\", ex);\n            }\n            digester.setXIncludeAware(false);\n        }\n        ArrayList<LogEntry> r = new ArrayList<>();\n        digester.push(r);\n\n        digester.addObjectCreate(\"*/logentry\", LogEntry.class);\n        digester.addSetProperties(\"*/logentry\");\n        digester.addBeanPropertySetter(\"*/logentry/author\",\"user\");\n        digester.addBeanPropertySetter(\"*/logentry/date\");\n        digester.addBeanPropertySetter(\"*/logentry/msg\");\n        digester.addSetNext(\"*/logentry\",\"add\");\n\n        digester.addObjectCreate(\"*/logentry/paths/path\", Path.class);\n        digester.addSetProperties(\"*/logentry/paths/path\");\n        digester.addBeanPropertySetter(\"*/logentry/paths/path\",\"value\");\n        digester.addSetNext(\"*/logentry/paths/path\",\"addPath\");\n\n        try {\n            digester.parse(changelogFile);\n        } catch (IOException | SAXException e) {\n            throw new IOException(\"Failed to parse \" + changelogFile,e);\n        }\n\n        for (LogEntry e : r) {\n            e.finish();\n        }\n        return new SubversionChangeLogSet(build, browser, r, ignoreDirPropChanges);\n    }", "code_tokens": ["@", "Override", "public", "SubversionChangeLogSet", "parse", "(", "@", "SuppressWarnings", "(", "\"", "rawtypes", "\"", ")", "Run", "build", ",", "RepositoryBrowser", "<", "?", ">", "browser", ",", "File", "changelogFile", ")", "throws", "IOException", ",", "SAXException", "{", "Digester", "digester", "=", "new", "Digester2", "(", ")", ";", "if", "(", "!", "Boolean", ".", "getBoolean", "(", "SubversionChangeLogParser", ".", "class", ".", "getName", "(", ")", "+", "\"", ".UNSAFE", "\"", ")", ")", "{", "try", "{", "digester", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "digester", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "digester", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "digester", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/nonvalidating/load-external-dtd", "\"", ",", "false", ")", ";", "}", "catch", "(", "ParserConfigurationException", "ex", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to securely configure Subversion changelog parser", "\"", ",", "ex", ")", ";", "throw", "new", "SAXException", "(", "\"", "Failed to securely configure Subversion changelog parser", "\"", ",", "ex", ")", ";", "}", "digester", ".", "setXIncludeAware", "(", "false", ")", ";", "}", "ArrayList", "<", "LogEntry", ">", "r", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "digester", ".", "push", "(", "r", ")", ";", "digester", ".", "addObjectCreate", "(", "\"", "*/logentry", "\"", ",", "LogEntry", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "\"", "*/logentry", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/logentry/author", "\"", ",", "\"", "user", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/logentry/date", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/logentry/msg", "\"", ")", ";", "digester", ".", "addSetNext", "(", "\"", "*/logentry", "\"", ",", "\"", "add", "\"", ")", ";", "digester", ".", "addObjectCreate", "(", "\"", "*/logentry/paths/path", "\"", ",", "Path", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "\"", "*/logentry/paths/path", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/logentry/paths/path", "\"", ",", "\"", "value", "\"", ")", ";", "digester", ".", "addSetNext", "(", "\"", "*/logentry/paths/path", "\"", ",", "\"", "addPath", "\"", ")", ";", "try", "{", "digester", ".", "parse", "(", "changelogFile", ")", ";", "}", "catch", "(", "IOException", "|", "SAXException", "e", ")", "{", "throw", "new", "IOException", "(", "\"", "Failed to parse ", "\"", "+", "changelogFile", ",", "e", ")", ";", "}", "for", "(", "LogEntry", "e", ":", "r", ")", "{", "e", ".", "finish", "(", ")", ";", "}", "return", "new", "SubversionChangeLogSet", "(", "build", ",", "browser", ",", "r", ",", "ignoreDirPropChanges", ")", ";", "}"], "idx": 69714, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "83f24081114a465f88d44fc84180d4d9d02c705d", "function_name": "parse", "body_hash": "a26cb5293187ad69c7f128134cdccc2e5b47f77c"}
{"code": "public static Map<String, Object> userLogin(DispatchContext ctx, Map<String, ?> context) {\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Locale locale = (Locale) context.get(\"locale\");\n        Delegator delegator = ctx.getDelegator();\n\n        // load the external auth modules -- note: this will only run once and cache the objects\n        if (!AuthHelper.authenticatorsLoaded()) {\n            AuthHelper.loadAuthenticators(dispatcher);\n        }\n\n        // Authenticate to LDAP if configured to do so\n        // TODO: this should be moved to using the NEW Authenticator API\n        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.enable\", delegator))) {\n            if (!LdapAuthenticationServices.userLogin(ctx, context)) {\n                String errMsg = UtilProperties.getMessage(resource, \"loginservices.ldap_authentication_failed\", locale);\n                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.fail.login\", delegator))) {\n                    return ServiceUtil.returnError(errMsg);\n                }\n                Debug.logInfo(errMsg, module);\n            }\n        }\n\n        Map<String, Object> result =  new LinkedHashMap<>();\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        // if isServiceAuth is not specified, default to not a service auth\n        boolean isServiceAuth = context.get(\"isServiceAuth\") != null && ((Boolean) context.get(\"isServiceAuth\")).booleanValue();\n\n        String username = (String) context.get(\"login.username\");\n        if (username == null) {\n            username = (String) context.get(\"username\");\n        }\n        String password = (String) context.get(\"login.password\");\n        if (password == null) {\n            password = (String) context.get(\"password\");\n        }\n\n        // get the visitId for the history entity\n        String visitId = (String) context.get(\"visitId\");\n\n        String errMsg = \"\";\n        if (UtilValidate.isEmpty(username)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.username_missing\", locale);\n        } else if (UtilValidate.isEmpty(password)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_missing\", locale);\n        } else {\n\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator))) {\n                username = username.toLowerCase(Locale.getDefault());\n            }\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {\n                password = password.toLowerCase(Locale.getDefault());\n            }\n\n            boolean repeat = true;\n            // starts at zero but it incremented at the beginning so in the first pass passNumber will be 1\n            int passNumber = 0;\n\n            while (repeat) {\n                repeat = false;\n                // pass number is incremented here because there are continues in this loop so it may never get to the end\n                passNumber++;\n\n                GenericValue userLogin = null;\n\n                try {\n                    // only get userLogin from cache for service calls; for web and other manual logins there is less time sensitivity\n                    userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                } catch (GenericEntityException e) {\n                    Debug.logWarning(e, \"\", module);\n                }\n\n\n                // see if any external auth modules want to sync the user info\n                if (userLogin == null) {\n                    try {\n                        AuthHelper.syncUser(username);\n                    } catch (AuthenticatorException e) {\n                        Debug.logWarning(e, module);\n                    }\n\n                    // check the user login object again\n                    try {\n                        userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                    } catch (GenericEntityException e) {\n                        Debug.logWarning(e, \"\", module);\n                    }\n                }\n\n                if (userLogin != null) {\n                    String ldmStr = EntityUtilProperties.getPropertyValue(\"security\", \"login.disable.minutes\", delegator);\n                    long loginDisableMinutes;\n\n                    try {\n                        loginDisableMinutes = Long.parseLong(ldmStr);\n                    } catch (Exception e) {\n                        loginDisableMinutes = 30;\n                        Debug.logWarning(\"Could not parse login.disable.minutes from security.properties, using default of 30\", module);\n                    }\n\n                    Timestamp disabledDateTime = userLogin.getTimestamp(\"disabledDateTime\");\n                    Timestamp reEnableTime = null;\n\n                    if (loginDisableMinutes > 0 && disabledDateTime != null) {\n                        reEnableTime = new Timestamp(disabledDateTime.getTime() + loginDisableMinutes * 60000);\n                    }\n\n                    boolean doStore = true;\n                    // we might change & store this userLogin, so we should clone it here to get a mutable copy\n                    userLogin = GenericValue.create(userLogin);\n\n                    // get the is system flag -- system accounts can only be used for service authentication\n                    boolean isSystem = (isServiceAuth && userLogin.get(\"isSystem\") != null) ?\n                            \"Y\".equalsIgnoreCase(userLogin.getString(\"isSystem\")) : false;\n\n                    // grab the hasLoggedOut flag\n                    Boolean hasLoggedOut = userLogin.getBoolean(\"hasLoggedOut\");\n\n                    if ((UtilValidate.isEmpty(userLogin.getString(\"enabled\")) || \"Y\".equals(userLogin.getString(\"enabled\")) ||\n                            (reEnableTime != null && reEnableTime.before(UtilDateTime.nowTimestamp())) || (isSystem)) && UtilValidate.isEmpty(userLogin.getString(\"disabledBy\"))) {\n\n                        String successfulLogin;\n\n                        if (!isSystem) {\n                            userLogin.set(\"enabled\", \"Y\");\n                            userLogin.set(\"disabledBy\", null);\n                        }\n\n                        // attempt to authenticate with Authenticator class(es)\n                        boolean authFatalError = false;\n                        boolean externalAuth = false;\n                        try {\n                            externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                        } catch (AuthenticatorException e) {\n                            // fatal error -- or single authenticator found -- fail now\n                            Debug.logWarning(e, module);\n                            authFatalError = true;\n\n                        }\n\n                        // check whether to sign in with Tomcat SSO\n                        boolean useTomcatSSO = EntityUtilProperties.propertyValueEquals(\"security\", \"security.login.tomcat.sso\", \"true\");\n                        HttpServletRequest request = (javax.servlet.http.HttpServletRequest) context.get(\"request\");\n                        // when request is not supplied, we will treat that SSO is not required as\n                        // in the usage of userLogin service in ICalWorker.java and XmlRpcEventHandler.java.\n                        useTomcatSSO = useTomcatSSO && (request!=null);\n\n                        // if the password.accept.encrypted.and.plain property in security is set to true allow plain or encrypted passwords\n                        // if this is a system account don't bother checking the passwords\n                        // if externalAuth passed; this is run as well\n                        if ((!authFatalError && externalAuth) || (useTomcatSSO ? TomcatSSOLogin(request, username, password) : checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, password) )) {\n                            Debug.logVerbose(\"[LoginServices.userLogin] : Password Matched\", module);\n\n                            // update the hasLoggedOut flag\n                            if (hasLoggedOut == null || hasLoggedOut) {\n                                userLogin.set(\"hasLoggedOut\", \"N\");\n                            }\n\n                            // reset failed login count if necessry\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n                            if (currentFailedLogins != null && currentFailedLogins.longValue() > 0) {\n                                userLogin.set(\"successiveFailedLogins\", Long.valueOf(0));\n                            } else if (hasLoggedOut != null && !hasLoggedOut) {\n                                // successful login & no loggout flag, no need to change anything, so don't do the store\n                                doStore = false;\n                            }\n\n                            successfulLogin = \"Y\";\n\n                            if (!isServiceAuth) {\n                                // get the UserLoginSession if this is not a service auth\n                                Map<?, ?> userLoginSessionMap = LoginWorker.getUserLoginSession(userLogin);\n\n                                // return the UserLoginSession Map\n                                if (userLoginSessionMap != null) {\n                                    result.put(\"userLoginSession\", userLoginSessionMap);\n                                }\n                            }\n\n                            result.put(\"userLogin\", userLogin);\n                            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        } else {\n                            // password is incorrect, but this may be the result of a stale cache entry,\n                            // so lets clear the cache and try again if this is the first pass\n                            // but only if authFatalError is not true; this would mean the single authenticator failed\n                            if (!authFatalError && isServiceAuth && passNumber <= 1) {\n                                delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                                repeat = true;\n                                continue;\n                            }\n\n                            Debug.logInfo(\"[LoginServices.userLogin] : Password Incorrect\", module);\n                            // password invalid...\n                            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_incorrect\", locale);\n\n                            // increment failed login count\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n\n                            if (currentFailedLogins == null) {\n                                currentFailedLogins = Long.valueOf(1);\n                            } else {\n                                currentFailedLogins = Long.valueOf(currentFailedLogins.longValue() + 1);\n                            }\n                            userLogin.set(\"successiveFailedLogins\", currentFailedLogins);\n\n                            // if failed logins over amount in properties file, disable account\n                            String mflStr = EntityUtilProperties.getPropertyValue(\"security\", \"max.failed.logins\", delegator);\n                            long maxFailedLogins = 3;\n                            try {\n                                maxFailedLogins = Long.parseLong(mflStr);\n                            } catch (Exception e) {\n                                maxFailedLogins = 3;\n                                Debug.logWarning(\"Could not parse max.failed.logins from security.properties, using default of 3\", module);\n                            }\n\n                            if (maxFailedLogins > 0 && currentFailedLogins.longValue() >= maxFailedLogins) {\n                                userLogin.set(\"enabled\", \"N\");\n                                userLogin.set(\"disabledDateTime\", UtilDateTime.nowTimestamp());\n                            }\n\n                            successfulLogin = \"N\";\n                        }\n\n                        // this section is being done in its own transaction rather than in the\n                        //current/existing transaction because we may return error and we don't\n                        //want that to stop this from getting stored\n                        Transaction parentTx = null;\n                        boolean beganTransaction = false;\n\n                        try {\n                            try {\n                                parentTx = TransactionUtil.suspend();\n                            } catch (GenericTransactionException e) {\n                                Debug.logError(e, \"Could not suspend transaction: \" + e.getMessage(), module);\n                            }\n\n                            try {\n                                beganTransaction = TransactionUtil.begin();\n\n                                if (doStore) {\n                                    userLogin.store();\n                                }\n\n                                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history\", delegator))) {\n                                    boolean createHistory = true;\n\n                                    // only save info on service auth if option set to true to do so\n                                    if (isServiceAuth && !\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.on.service.auth\", delegator))) {\n                                        createHistory = false;\n                                    }\n\n                                    if (createHistory) {\n                                        Map<String, Object> ulhCreateMap = UtilMisc.toMap(\"userLoginId\", username, \"visitId\", visitId,\n                                                \"fromDate\", UtilDateTime.nowTimestamp(), \"successfulLogin\", successfulLogin);\n\n                                        ModelEntity modelUserLogin = userLogin.getModelEntity();\n                                        if (modelUserLogin.isField(\"partyId\")) {\n                                            ulhCreateMap.put(\"partyId\", userLogin.get(\"partyId\"));\n                                        }\n\n                                        // ONLY save the password if it was incorrect\n                                        // we will check in the hash size isn't too huge for the store other wise store a fix string\n                                        if (\"N\".equals(successfulLogin) && !\"false\".equals(EntityUtilProperties.getPropertyValue(\"security\",\n                                                \"store.login.history.incorrect.password\", delegator))) {\n                                            ulhCreateMap.put(\"passwordUsed\", isGivenPasswordCanBeStored(delegator, password)\n                                                    ? \" TOO LONG FOR STORAGE \"\n                                                    : password);\n                                        }\n\n                                        delegator.create(\"UserLoginHistory\", ulhCreateMap);\n                                    }\n                                }\n                            } catch (GenericEntityException e) {\n                                String geeErrMsg = \"Error saving UserLoginHistory\";\n                                if (doStore) {\n                                    geeErrMsg += \" and updating login status to reset hasLoggedOut, unsuccessful login count, etc.\";\n                                }\n                                try {\n                                    TransactionUtil.rollback(beganTransaction, geeErrMsg, e);\n                                } catch (GenericTransactionException e2) {\n                                    Debug.logError(e2, \"Could not rollback nested transaction: \" + e2.getMessage(), module);\n                                }\n\n                                // if doStore is true then this error should not be ignored and we shouldn't consider it a successful login if this happens as there is something very wrong lower down that will bite us again later\n                                if (doStore) {\n                                    return ServiceUtil.returnError(geeErrMsg);\n                                }\n                            } finally {\n                                try {\n                                    TransactionUtil.commit(beganTransaction);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not commit nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        } finally {\n                            // resume/restore parent transaction\n                            if (parentTx != null) {\n                                try {\n                                    TransactionUtil.resume(parentTx);\n                                    Debug.logVerbose(\"Resumed the parent transaction.\", module);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not resume parent nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        }\n                    } else {\n                        // account is disabled, but this may be the result of a stale cache entry,\n                        // so lets clear the cache and try again if this is the first pass\n                        if (isServiceAuth && passNumber <= 1) {\n                            delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                            repeat = true;\n                            continue;\n                        }\n\n                        Map<String, Object> messageMap = UtilMisc.<String, Object>toMap(\"username\", username);\n                        errMsg = UtilProperties.getMessage(resource,\"loginservices.account_for_user_login_id_disabled\",messageMap ,locale);\n                        if (disabledDateTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"disabledDateTime\", disabledDateTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.since_datetime\",messageMap ,locale);\n                        } else {\n                            errMsg += \".\";\n                        }\n\n                        if (loginDisableMinutes > 0 && reEnableTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"reEnableTime\", reEnableTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.will_be_reenabled\",messageMap ,locale);\n                        } else {\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.not_scheduled_to_be_reenabled\",locale);\n                        }\n                    }\n                } else {\n                    // no userLogin object; there may be a non-syncing authenticator\n                    boolean externalAuth = false;\n                    try {\n                        externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                    } catch (AuthenticatorException e) {\n                        errMsg = e.getMessage();\n                        Debug.logError(e, \"External Authenticator had fatal exception : \" + e.getMessage(), module);\n                    }\n                    if (externalAuth) {\n                        // external auth passed - create a placeholder object for session\n                        userLogin = delegator.makeValue(\"UserLogin\");\n                        userLogin.set(\"userLoginId\", username);\n                        userLogin.set(\"enabled\", \"Y\");\n                        userLogin.set(\"hasLoggedOut\", \"N\");\n                        result.put(\"userLogin\", userLogin);\n                        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        //TODO: more than this is needed to support 100% external authentication\n                        //TODO: party + security information is needed; Userlogin will need to be stored\n                    } else {\n                        // userLogin record not found, user does not exist\n                        errMsg = UtilProperties.getMessage(resource, \"loginservices.user_not_found\", locale);\n                        Debug.logInfo(\"[LoginServices.userLogin] Invalid User : '\" + username + \"'; \" + errMsg, module);\n                    }\n                }\n            }\n        }\n\n        if (errMsg.length() > 0) {\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_FAIL);\n            result.put(ModelService.ERROR_MESSAGE, errMsg);\n        }\n        return result;\n    }", "code_tokens": ["public", "static", "Map", "<", "String", ",", "Object", ">", "userLogin", "(", "DispatchContext", "ctx", ",", "Map", "<", "String", ",", "?", ">", "context", ")", "{", "LocalDispatcher", "dispatcher", "=", "ctx", ".", "getDispatcher", "(", ")", ";", "Locale", "locale", "=", "(", "Locale", ")", "context", ".", "get", "(", "\"", "locale", "\"", ")", ";", "Delegator", "delegator", "=", "ctx", ".", "getDelegator", "(", ")", ";", "if", "(", "!", "AuthHelper", ".", "authenticatorsLoaded", "(", ")", ")", "{", "AuthHelper", ".", "loadAuthenticators", "(", "dispatcher", ")", ";", "}", "if", "(", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "security.ldap.enable", "\"", ",", "delegator", ")", ")", ")", "{", "if", "(", "!", "LdapAuthenticationServices", ".", "userLogin", "(", "ctx", ",", "context", ")", ")", "{", "String", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.ldap_authentication_failed", "\"", ",", "locale", ")", ";", "if", "(", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "security.ldap.fail.login", "\"", ",", "delegator", ")", ")", ")", "{", "return", "ServiceUtil", ".", "returnError", "(", "errMsg", ")", ";", "}", "Debug", ".", "logInfo", "(", "errMsg", ",", "module", ")", ";", "}", "}", "Map", "<", "String", ",", "Object", ">", "result", "=", "new", "LinkedHashMap", "<", ">", "(", ")", ";", "boolean", "useEncryption", "=", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "password.encrypt", "\"", ",", "delegator", ")", ")", ";", "boolean", "isServiceAuth", "=", "context", ".", "get", "(", "\"", "isServiceAuth", "\"", ")", "!=", "null", "&&", "(", "(", "Boolean", ")", "context", ".", "get", "(", "\"", "isServiceAuth", "\"", ")", ")", ".", "booleanValue", "(", ")", ";", "String", "username", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "login.username", "\"", ")", ";", "if", "(", "username", "==", "null", ")", "{", "username", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "username", "\"", ")", ";", "}", "String", "password", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "login.password", "\"", ")", ";", "if", "(", "password", "==", "null", ")", "{", "password", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "password", "\"", ")", ";", "}", "String", "visitId", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "visitId", "\"", ")", ";", "String", "errMsg", "=", "\"", "\"", ";", "if", "(", "UtilValidate", ".", "isEmpty", "(", "username", ")", ")", "{", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.username_missing", "\"", ",", "locale", ")", ";", "}", "else", "if", "(", "UtilValidate", ".", "isEmpty", "(", "password", ")", ")", "{", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.password_missing", "\"", ",", "locale", ")", ";", "}", "else", "{", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "username.lowercase", "\"", ",", "delegator", ")", ")", ")", "{", "username", "=", "username", ".", "toLowerCase", "(", "Locale", ".", "getDefault", "(", ")", ")", ";", "}", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "password.lowercase", "\"", ",", "delegator", ")", ")", ")", "{", "password", "=", "password", ".", "toLowerCase", "(", "Locale", ".", "getDefault", "(", ")", ")", ";", "}", "boolean", "repeat", "=", "true", ";", "int", "passNumber", "=", "0", ";", "while", "(", "repeat", ")", "{", "repeat", "=", "false", ";", "passNumber", "++", ";", "GenericValue", "userLogin", "=", "null", ";", "try", "{", "userLogin", "=", "EntityQuery", ".", "use", "(", "delegator", ")", ".", "from", "(", "\"", "UserLogin", "\"", ")", ".", "where", "(", "\"", "userLoginId", "\"", ",", "username", ")", ".", "cache", "(", "isServiceAuth", ")", ".", "queryOne", "(", ")", ";", "}", "catch", "(", "GenericEntityException", "e", ")", "{", "Debug", ".", "logWarning", "(", "e", ",", "\"", "\"", ",", "module", ")", ";", "}", "if", "(", "userLogin", "==", "null", ")", "{", "try", "{", "AuthHelper", ".", "syncUser", "(", "username", ")", ";", "}", "catch", "(", "AuthenticatorException", "e", ")", "{", "Debug", ".", "logWarning", "(", "e", ",", "module", ")", ";", "}", "try", "{", "userLogin", "=", "EntityQuery", ".", "use", "(", "delegator", ")", ".", "from", "(", "\"", "UserLogin", "\"", ")", ".", "where", "(", "\"", "userLoginId", "\"", ",", "username", ")", ".", "cache", "(", "isServiceAuth", ")", ".", "queryOne", "(", ")", ";", "}", "catch", "(", "GenericEntityException", "e", ")", "{", "Debug", ".", "logWarning", "(", "e", ",", "\"", "\"", ",", "module", ")", ";", "}", "}", "if", "(", "userLogin", "!=", "null", ")", "{", "String", "ldmStr", "=", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "login.disable.minutes", "\"", ",", "delegator", ")", ";", "long", "loginDisableMinutes", ";", "try", "{", "loginDisableMinutes", "=", "Long", ".", "parseLong", "(", "ldmStr", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "loginDisableMinutes", "=", "30", ";", "Debug", ".", "logWarning", "(", "\"", "Could not parse login.disable.minutes from security.properties, using default of 30", "\"", ",", "module", ")", ";", "}", "Timestamp", "disabledDateTime", "=", "userLogin", ".", "getTimestamp", "(", "\"", "disabledDateTime", "\"", ")", ";", "Timestamp", "reEnableTime", "=", "null", ";", "if", "(", "loginDisableMinutes", ">", "0", "&&", "disabledDateTime", "!=", "null", ")", "{", "reEnableTime", "=", "new", "Timestamp", "(", "disabledDateTime", ".", "getTime", "(", ")", "+", "loginDisableMinutes", "*", "60000", ")", ";", "}", "boolean", "doStore", "=", "true", ";", "userLogin", "=", "GenericValue", ".", "create", "(", "userLogin", ")", ";", "boolean", "isSystem", "=", "(", "isServiceAuth", "&&", "userLogin", ".", "get", "(", "\"", "isSystem", "\"", ")", "!=", "null", ")", "?", "\"", "Y", "\"", ".", "equalsIgnoreCase", "(", "userLogin", ".", "getString", "(", "\"", "isSystem", "\"", ")", ")", ":", "false", ";", "Boolean", "hasLoggedOut", "=", "userLogin", ".", "getBoolean", "(", "\"", "hasLoggedOut", "\"", ")", ";", "if", "(", "(", "UtilValidate", ".", "isEmpty", "(", "userLogin", ".", "getString", "(", "\"", "enabled", "\"", ")", ")", "||", "\"", "Y", "\"", ".", "equals", "(", "userLogin", ".", "getString", "(", "\"", "enabled", "\"", ")", ")", "||", "(", "reEnableTime", "!=", "null", "&&", "reEnableTime", ".", "before", "(", "UtilDateTime", ".", "nowTimestamp", "(", ")", ")", ")", "||", "(", "isSystem", ")", ")", "&&", "UtilValidate", ".", "isEmpty", "(", "userLogin", ".", "getString", "(", "\"", "disabledBy", "\"", ")", ")", ")", "{", "String", "successfulLogin", ";", "if", "(", "!", "isSystem", ")", "{", "userLogin", ".", "set", "(", "\"", "enabled", "\"", ",", "\"", "Y", "\"", ")", ";", "userLogin", ".", "set", "(", "\"", "disabledBy", "\"", ",", "null", ")", ";", "}", "boolean", "authFatalError", "=", "false", ";", "boolean", "externalAuth", "=", "false", ";", "try", "{", "externalAuth", "=", "AuthHelper", ".", "authenticate", "(", "username", ",", "password", ",", "isServiceAuth", ")", ";", "}", "catch", "(", "AuthenticatorException", "e", ")", "{", "Debug", ".", "logWarning", "(", "e", ",", "module", ")", ";", "authFatalError", "=", "true", ";", "}", "boolean", "useTomcatSSO", "=", "EntityUtilProperties", ".", "propertyValueEquals", "(", "\"", "security", "\"", ",", "\"", "security.login.tomcat.sso", "\"", ",", "\"", "true", "\"", ")", ";", "HttpServletRequest", "request", "=", "(", "javax", ".", "servlet", ".", "http", ".", "HttpServletRequest", ")", "context", ".", "get", "(", "\"", "request", "\"", ")", ";", "useTomcatSSO", "=", "useTomcatSSO", "&&", "(", "request", "!=", "null", ")", ";", "if", "(", "(", "!", "authFatalError", "&&", "externalAuth", ")", "||", "(", "useTomcatSSO", "?", "TomcatSSOLogin", "(", "request", ",", "username", ",", "password", ")", ":", "checkPassword", "(", "userLogin", ".", "getString", "(", "\"", "currentPassword", "\"", ")", ",", "useEncryption", ",", "password", ")", ")", ")", "{", "Debug", ".", "logVerbose", "(", "\"", "[LoginServices.userLogin] : Password Matched", "\"", ",", "module", ")", ";", "if", "(", "hasLoggedOut", "==", "null", "||", "hasLoggedOut", ")", "{", "userLogin", ".", "set", "(", "\"", "hasLoggedOut", "\"", ",", "\"", "N", "\"", ")", ";", "}", "Long", "currentFailedLogins", "=", "userLogin", ".", "getLong", "(", "\"", "successiveFailedLogins", "\"", ")", ";", "if", "(", "currentFailedLogins", "!=", "null", "&&", "currentFailedLogins", ".", "longValue", "(", ")", ">", "0", ")", "{", "userLogin", ".", "set", "(", "\"", "successiveFailedLogins", "\"", ",", "Long", ".", "valueOf", "(", "0", ")", ")", ";", "}", "else", "if", "(", "hasLoggedOut", "!=", "null", "&&", "!", "hasLoggedOut", ")", "{", "doStore", "=", "false", ";", "}", "successfulLogin", "=", "\"", "Y", "\"", ";", "if", "(", "!", "isServiceAuth", ")", "{", "Map", "<", "?", ",", "?", ">", "userLoginSessionMap", "=", "LoginWorker", ".", "getUserLoginSession", "(", "userLogin", ")", ";", "if", "(", "userLoginSessionMap", "!=", "null", ")", "{", "result", ".", "put", "(", "\"", "userLoginSession", "\"", ",", "userLoginSessionMap", ")", ";", "}", "}", "result", ".", "put", "(", "\"", "userLogin", "\"", ",", "userLogin", ")", ";", "result", ".", "put", "(", "ModelService", ".", "RESPONSE_MESSAGE", ",", "ModelService", ".", "RESPOND_SUCCESS", ")", ";", "}", "else", "{", "if", "(", "!", "authFatalError", "&&", "isServiceAuth", "&&", "passNumber", "<=", "1", ")", "{", "delegator", ".", "clearCacheLine", "(", "\"", "UserLogin", "\"", ",", "UtilMisc", ".", "toMap", "(", "\"", "userLoginId", "\"", ",", "username", ")", ")", ";", "repeat", "=", "true", ";", "continue", ";", "}", "Debug", ".", "logInfo", "(", "\"", "[LoginServices.userLogin] : Password Incorrect", "\"", ",", "module", ")", ";", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.password_incorrect", "\"", ",", "locale", ")", ";", "Long", "currentFailedLogins", "=", "userLogin", ".", "getLong", "(", "\"", "successiveFailedLogins", "\"", ")", ";", "if", "(", "currentFailedLogins", "==", "null", ")", "{", "currentFailedLogins", "=", "Long", ".", "valueOf", "(", "1", ")", ";", "}", "else", "{", "currentFailedLogins", "=", "Long", ".", "valueOf", "(", "currentFailedLogins", ".", "longValue", "(", ")", "+", "1", ")", ";", "}", "userLogin", ".", "set", "(", "\"", "successiveFailedLogins", "\"", ",", "currentFailedLogins", ")", ";", "String", "mflStr", "=", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "max.failed.logins", "\"", ",", "delegator", ")", ";", "long", "maxFailedLogins", "=", "3", ";", "try", "{", "maxFailedLogins", "=", "Long", ".", "parseLong", "(", "mflStr", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "maxFailedLogins", "=", "3", ";", "Debug", ".", "logWarning", "(", "\"", "Could not parse max.failed.logins from security.properties, using default of 3", "\"", ",", "module", ")", ";", "}", "if", "(", "maxFailedLogins", ">", "0", "&&", "currentFailedLogins", ".", "longValue", "(", ")", ">=", "maxFailedLogins", ")", "{", "userLogin", ".", "set", "(", "\"", "enabled", "\"", ",", "\"", "N", "\"", ")", ";", "userLogin", ".", "set", "(", "\"", "disabledDateTime", "\"", ",", "UtilDateTime", ".", "nowTimestamp", "(", ")", ")", ";", "}", "successfulLogin", "=", "\"", "N", "\"", ";", "}", "Transaction", "parentTx", "=", "null", ";", "boolean", "beganTransaction", "=", "false", ";", "try", "{", "try", "{", "parentTx", "=", "TransactionUtil", ".", "suspend", "(", ")", ";", "}", "catch", "(", "GenericTransactionException", "e", ")", "{", "Debug", ".", "logError", "(", "e", ",", "\"", "Could not suspend transaction: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "try", "{", "beganTransaction", "=", "TransactionUtil", ".", "begin", "(", ")", ";", "if", "(", "doStore", ")", "{", "userLogin", ".", "store", "(", ")", ";", "}", "if", "(", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "store.login.history", "\"", ",", "delegator", ")", ")", ")", "{", "boolean", "createHistory", "=", "true", ";", "if", "(", "isServiceAuth", "&&", "!", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "store.login.history.on.service.auth", "\"", ",", "delegator", ")", ")", ")", "{", "createHistory", "=", "false", ";", "}", "if", "(", "createHistory", ")", "{", "Map", "<", "String", ",", "Object", ">", "ulhCreateMap", "=", "UtilMisc", ".", "toMap", "(", "\"", "userLoginId", "\"", ",", "username", ",", "\"", "visitId", "\"", ",", "visitId", ",", "\"", "fromDate", "\"", ",", "UtilDateTime", ".", "nowTimestamp", "(", ")", ",", "\"", "successfulLogin", "\"", ",", "successfulLogin", ")", ";", "ModelEntity", "modelUserLogin", "=", "userLogin", ".", "getModelEntity", "(", ")", ";", "if", "(", "modelUserLogin", ".", "isField", "(", "\"", "partyId", "\"", ")", ")", "{", "ulhCreateMap", ".", "put", "(", "\"", "partyId", "\"", ",", "userLogin", ".", "get", "(", "\"", "partyId", "\"", ")", ")", ";", "}", "if", "(", "\"", "N", "\"", ".", "equals", "(", "successfulLogin", ")", "&&", "!", "\"", "false", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "store.login.history.incorrect.password", "\"", ",", "delegator", ")", ")", ")", "{", "ulhCreateMap", ".", "put", "(", "\"", "passwordUsed", "\"", ",", "isGivenPasswordCanBeStored", "(", "delegator", ",", "password", ")", "?", "\"", " TOO LONG FOR STORAGE ", "\"", ":", "password", ")", ";", "}", "delegator", ".", "create", "(", "\"", "UserLoginHistory", "\"", ",", "ulhCreateMap", ")", ";", "}", "}", "}", "catch", "(", "GenericEntityException", "e", ")", "{", "String", "geeErrMsg", "=", "\"", "Error saving UserLoginHistory", "\"", ";", "if", "(", "doStore", ")", "{", "geeErrMsg", "+=", "\"", " and updating login status to reset hasLoggedOut, unsuccessful login count, etc.", "\"", ";", "}", "try", "{", "TransactionUtil", ".", "rollback", "(", "beganTransaction", ",", "geeErrMsg", ",", "e", ")", ";", "}", "catch", "(", "GenericTransactionException", "e2", ")", "{", "Debug", ".", "logError", "(", "e2", ",", "\"", "Could not rollback nested transaction: ", "\"", "+", "e2", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "if", "(", "doStore", ")", "{", "return", "ServiceUtil", ".", "returnError", "(", "geeErrMsg", ")", ";", "}", "}", "finally", "{", "try", "{", "TransactionUtil", ".", "commit", "(", "beganTransaction", ")", ";", "}", "catch", "(", "GenericTransactionException", "e", ")", "{", "Debug", ".", "logError", "(", "e", ",", "\"", "Could not commit nested transaction: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "}", "}", "finally", "{", "if", "(", "parentTx", "!=", "null", ")", "{", "try", "{", "TransactionUtil", ".", "resume", "(", "parentTx", ")", ";", "Debug", ".", "logVerbose", "(", "\"", "Resumed the parent transaction.", "\"", ",", "module", ")", ";", "}", "catch", "(", "GenericTransactionException", "e", ")", "{", "Debug", ".", "logError", "(", "e", ",", "\"", "Could not resume parent nested transaction: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "}", "}", "}", "else", "{", "if", "(", "isServiceAuth", "&&", "passNumber", "<=", "1", ")", "{", "delegator", ".", "clearCacheLine", "(", "\"", "UserLogin", "\"", ",", "UtilMisc", ".", "toMap", "(", "\"", "userLoginId", "\"", ",", "username", ")", ")", ";", "repeat", "=", "true", ";", "continue", ";", "}", "Map", "<", "String", ",", "Object", ">", "messageMap", "=", "UtilMisc", ".", "<", "String", ",", "Object", ">", "toMap", "(", "\"", "username", "\"", ",", "username", ")", ";", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.account_for_user_login_id_disabled", "\"", ",", "messageMap", ",", "locale", ")", ";", "if", "(", "disabledDateTime", "!=", "null", ")", "{", "messageMap", "=", "UtilMisc", ".", "<", "String", ",", "Object", ">", "toMap", "(", "\"", "disabledDateTime", "\"", ",", "disabledDateTime", ")", ";", "errMsg", "+=", "\"", " ", "\"", "+", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.since_datetime", "\"", ",", "messageMap", ",", "locale", ")", ";", "}", "else", "{", "errMsg", "+=", "\"", ".", "\"", ";", "}", "if", "(", "loginDisableMinutes", ">", "0", "&&", "reEnableTime", "!=", "null", ")", "{", "messageMap", "=", "UtilMisc", ".", "<", "String", ",", "Object", ">", "toMap", "(", "\"", "reEnableTime", "\"", ",", "reEnableTime", ")", ";", "errMsg", "+=", "\"", " ", "\"", "+", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.will_be_reenabled", "\"", ",", "messageMap", ",", "locale", ")", ";", "}", "else", "{", "errMsg", "+=", "\"", " ", "\"", "+", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.not_scheduled_to_be_reenabled", "\"", ",", "locale", ")", ";", "}", "}", "}", "else", "{", "boolean", "externalAuth", "=", "false", ";", "try", "{", "externalAuth", "=", "AuthHelper", ".", "authenticate", "(", "username", ",", "password", ",", "isServiceAuth", ")", ";", "}", "catch", "(", "AuthenticatorException", "e", ")", "{", "errMsg", "=", "e", ".", "getMessage", "(", ")", ";", "Debug", ".", "logError", "(", "e", ",", "\"", "External Authenticator had fatal exception : ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "if", "(", "externalAuth", ")", "{", "userLogin", "=", "delegator", ".", "makeValue", "(", "\"", "UserLogin", "\"", ")", ";", "userLogin", ".", "set", "(", "\"", "userLoginId", "\"", ",", "username", ")", ";", "userLogin", ".", "set", "(", "\"", "enabled", "\"", ",", "\"", "Y", "\"", ")", ";", "userLogin", ".", "set", "(", "\"", "hasLoggedOut", "\"", ",", "\"", "N", "\"", ")", ";", "result", ".", "put", "(", "\"", "userLogin", "\"", ",", "userLogin", ")", ";", "result", ".", "put", "(", "ModelService", ".", "RESPONSE_MESSAGE", ",", "ModelService", ".", "RESPOND_SUCCESS", ")", ";", "}", "else", "{", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.user_not_found", "\"", ",", "locale", ")", ";", "Debug", ".", "logInfo", "(", "\"", "[LoginServices.userLogin] Invalid User : '", "\"", "+", "username", "+", "\"", "'; ", "\"", "+", "errMsg", ",", "module", ")", ";", "}", "}", "}", "}", "if", "(", "errMsg", ".", "length", "(", ")", ">", "0", ")", "{", "result", ".", "put", "(", "ModelService", ".", "RESPONSE_MESSAGE", ",", "ModelService", ".", "RESPOND_FAIL", ")", ";", "result", ".", "put", "(", "ModelService", ".", "ERROR_MESSAGE", ",", "errMsg", ")", ";", "}", "return", "result", ";", "}"], "idx": 20527, "cwe": "CWE-209", "target": 0, "status": "FIXED", "commit": "2f5b8d33e32c4d9a48243cf9e503236acd5aec5c", "function_name": "userLogin", "body_hash": "b94397c6f57cc2ef4f52e5d6b63a1acd465f08c9"}
{"code": "@RequestMapping(\"/session\")\n    public String session(Model model, @RequestParam String clientId, @RequestParam String messageOrigin) {\n        model.addAttribute(\"clientId\", clientId);\n        model.addAttribute(\"messageOrigin\", messageOrigin);\n        return \"session\";\n    }", "code_tokens": ["@", "RequestMapping", "(", "\"", "/session", "\"", ")", "public", "String", "session", "(", "Model", "model", ",", "@", "RequestParam", "String", "clientId", ",", "@", "RequestParam", "String", "messageOrigin", ")", "{", "model", ".", "addAttribute", "(", "\"", "clientId", "\"", ",", "clientId", ")", ";", "model", ".", "addAttribute", "(", "\"", "messageOrigin", "\"", ",", "messageOrigin", ")", ";", "return", "\"", "session", "\"", ";", "}"], "idx": 80391, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "96fe26711f8f8855d2994a531447f730afd61844", "function_name": "session", "body_hash": "0bb3fc6191465bc9ba808984ae631a7f5e1e45e6"}
{"code": "@Override\n\tprotected Object doZipTransform(final Message<?> message) throws Exception {\n\n\t\ttry {\n\t\t\tfinal Object payload = message.getPayload();\n\t\t\tfinal Object unzippedData;\n\n\t\t\tInputStream inputStream = null;\n\n\t\t\ttry {\n\t\t\t\tif (payload instanceof File) {\n\t\t\t\t\tfinal File filePayload = (File) payload;\n\n\t\t\t\t\tif (filePayload.isDirectory()) {\n\t\t\t\t\t\tthrow new UnsupportedOperationException(String.format(\"Cannot unzip a directory: '%s'\",\n\t\t\t\t\t\t\t\tfilePayload.getAbsolutePath()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!SpringZipUtils.isValid(filePayload)) {\n\t\t\t\t\t\tthrow new IllegalStateException(String.format(\"Not a zip file: '%s'.\",\n\t\t\t\t\t\t\t\tfilePayload.getAbsolutePath()));\n\t\t\t\t\t}\n\n\t\t\t\t\tinputStream = new FileInputStream(filePayload);\n\t\t\t\t}\n\t\t\t\telse if (payload instanceof InputStream) {\n\t\t\t\t\tinputStream = (InputStream) payload;\n\t\t\t\t}\n\t\t\t\telse if (payload instanceof byte[]) {\n\t\t\t\t\tinputStream = new ByteArrayInputStream((byte[]) payload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(String.format(\"Unsupported payload type '%s'. \" +\n\t\t\t\t\t\t\t\t\t\"The only supported payload types are java.io.File, byte[] and java.io.InputStream\",\n\t\t\t\t\t\t\tpayload.getClass().getSimpleName()));\n\t\t\t\t}\n\n\t\t\t\tfinal SortedMap<String, Object> uncompressedData = new TreeMap<String, Object>();\n\n\t\t\t\tZipUtil.iterate(inputStream, new ZipEntryCallback() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void process(InputStream zipEntryInputStream, ZipEntry zipEntry) throws IOException {\n\n\t\t\t\t\t\tfinal String zipEntryName = zipEntry.getName();\n\t\t\t\t\t\tfinal long zipEntryTime = zipEntry.getTime();\n\t\t\t\t\t\tfinal long zipEntryCompressedSize = zipEntry.getCompressedSize();\n\t\t\t\t\t\tfinal String type = zipEntry.isDirectory() ? \"directory\" : \"file\";\n\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(String.format(\"Unpacking Zip Entry - Name: '%s',Time: '%s', \" +\n\t\t\t\t\t\t\t\t\t\t\t\"Compressed Size: '%s', Type: '%s'\",\n\t\t\t\t\t\t\t\t\tzipEntryName, zipEntryTime, zipEntryCompressedSize, type));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ZipResultType.FILE.equals(zipResultType)) {\n\t\t\t\t\t\t\tfinal File destinationFile = checkPath(message, zipEntryName);\n\n\t\t\t\t\t\t\tif (zipEntry.isDirectory()) {\n\t\t\t\t\t\t\t\tdestinationFile.mkdirs(); //NOSONAR false positive\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tSpringZipUtils.copy(zipEntryInputStream, destinationFile);\n\t\t\t\t\t\t\t\tuncompressedData.put(zipEntryName, destinationFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ZipResultType.BYTE_ARRAY.equals(zipResultType)) {\n\t\t\t\t\t\t\tif (!zipEntry.isDirectory()) {\n\t\t\t\t\t\t\t\tcheckPath(message, zipEntryName);\n\t\t\t\t\t\t\t\tbyte[] data = IOUtils.toByteArray(zipEntryInputStream);\n\t\t\t\t\t\t\t\tuncompressedData.put(zipEntryName, data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Unsupported zipResultType \" + zipResultType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic File checkPath(final Message<?> message, final String zipEntryName) throws IOException {\n\t\t\t\t\t\tfinal File tempDir = new File(workDirectory, message.getHeaders().getId().toString());\n\t\t\t\t\t\ttempDir.mkdirs(); //NOSONAR false positive\n\t\t\t\t\t\tfinal File destinationFile = new File(tempDir, zipEntryName);\n\n\t\t\t\t\t\t/* If we see the relative traversal string of \"..\" we need to make sure\n\t\t\t\t\t\t * that the outputdir + name doesn't leave the outputdir.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!destinationFile.getCanonicalPath().startsWith(workDirectory.getCanonicalPath())) {\n\t\t\t\t\t\t\tthrow new ZipException(\"The file \" + zipEntryName +\n\t\t\t\t\t\t\t\t\t\" is trying to leave the target output directory of \" + workDirectory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn destinationFile;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (uncompressedData.isEmpty()) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"No data unzipped from payload with message Id \" + message.getHeaders().getId());\n\t\t\t\t\t}\n\t\t\t\t\tunzippedData = null;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tif (this.expectSingleResult) {\n\t\t\t\t\t\tif (uncompressedData.size() == 1) {\n\t\t\t\t\t\t\tunzippedData = uncompressedData.values().iterator().next();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new MessagingException(message,\n\t\t\t\t\t\t\t\t\tString.format(\"The UnZip operation extracted %s \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"result objects but expectSingleResult was 'true'.\", uncompressedData.size()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tunzippedData = uncompressedData;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tIOUtils.closeQuietly(inputStream);\n\t\t\t\tif (payload instanceof File && this.deleteFiles) {\n\t\t\t\t\tfinal File filePayload = (File) payload;\n\t\t\t\t\tif (!filePayload.delete() && logger.isWarnEnabled()) {\n\t\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\t\tlogger.warn(\"failed to delete File '\" + filePayload + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn unzippedData;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new MessageHandlingException(message, \"Failed to apply Zip transformation.\", e);\n\t\t}\n\t}", "code_tokens": ["@", "Override", "protected", "Object", "doZipTransform", "(", "final", "Message", "<", "?", ">", "message", ")", "throws", "Exception", "{", "try", "{", "final", "Object", "payload", "=", "message", ".", "getPayload", "(", ")", ";", "final", "Object", "unzippedData", ";", "InputStream", "inputStream", "=", "null", ";", "try", "{", "if", "(", "payload", "instanceof", "File", ")", "{", "final", "File", "filePayload", "=", "(", "File", ")", "payload", ";", "if", "(", "filePayload", ".", "isDirectory", "(", ")", ")", "{", "throw", "new", "UnsupportedOperationException", "(", "String", ".", "format", "(", "\"", "Cannot unzip a directory: '%s'", "\"", ",", "filePayload", ".", "getAbsolutePath", "(", ")", ")", ")", ";", "}", "if", "(", "!", "SpringZipUtils", ".", "isValid", "(", "filePayload", ")", ")", "{", "throw", "new", "IllegalStateException", "(", "String", ".", "format", "(", "\"", "Not a zip file: '%s'.", "\"", ",", "filePayload", ".", "getAbsolutePath", "(", ")", ")", ")", ";", "}", "inputStream", "=", "new", "FileInputStream", "(", "filePayload", ")", ";", "}", "else", "if", "(", "payload", "instanceof", "InputStream", ")", "{", "inputStream", "=", "(", "InputStream", ")", "payload", ";", "}", "else", "if", "(", "payload", "instanceof", "byte", "[", "]", ")", "{", "inputStream", "=", "new", "ByteArrayInputStream", "(", "(", "byte", "[", "]", ")", "payload", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "String", ".", "format", "(", "\"", "Unsupported payload type '%s'. ", "\"", "+", "\"", "The only supported payload types are java.io.File, byte[] and java.io.InputStream", "\"", ",", "payload", ".", "getClass", "(", ")", ".", "getSimpleName", "(", ")", ")", ")", ";", "}", "final", "SortedMap", "<", "String", ",", "Object", ">", "uncompressedData", "=", "new", "TreeMap", "<", "String", ",", "Object", ">", "(", ")", ";", "ZipUtil", ".", "iterate", "(", "inputStream", ",", "new", "ZipEntryCallback", "(", ")", "{", "@", "Override", "public", "void", "process", "(", "InputStream", "zipEntryInputStream", ",", "ZipEntry", "zipEntry", ")", "throws", "IOException", "{", "final", "String", "zipEntryName", "=", "zipEntry", ".", "getName", "(", ")", ";", "final", "long", "zipEntryTime", "=", "zipEntry", ".", "getTime", "(", ")", ";", "final", "long", "zipEntryCompressedSize", "=", "zipEntry", ".", "getCompressedSize", "(", ")", ";", "final", "String", "type", "=", "zipEntry", ".", "isDirectory", "(", ")", "?", "\"", "directory", "\"", ":", "\"", "file", "\"", ";", "if", "(", "logger", ".", "isInfoEnabled", "(", ")", ")", "{", "logger", ".", "info", "(", "String", ".", "format", "(", "\"", "Unpacking Zip Entry - Name: '%s',Time: '%s', ", "\"", "+", "\"", "Compressed Size: '%s', Type: '%s'", "\"", ",", "zipEntryName", ",", "zipEntryTime", ",", "zipEntryCompressedSize", ",", "type", ")", ")", ";", "}", "if", "(", "ZipResultType", ".", "FILE", ".", "equals", "(", "zipResultType", ")", ")", "{", "final", "File", "destinationFile", "=", "checkPath", "(", "message", ",", "zipEntryName", ")", ";", "if", "(", "zipEntry", ".", "isDirectory", "(", ")", ")", "{", "destinationFile", ".", "mkdirs", "(", ")", ";", "}", "else", "{", "SpringZipUtils", ".", "copy", "(", "zipEntryInputStream", ",", "destinationFile", ")", ";", "uncompressedData", ".", "put", "(", "zipEntryName", ",", "destinationFile", ")", ";", "}", "}", "else", "if", "(", "ZipResultType", ".", "BYTE_ARRAY", ".", "equals", "(", "zipResultType", ")", ")", "{", "if", "(", "!", "zipEntry", ".", "isDirectory", "(", ")", ")", "{", "checkPath", "(", "message", ",", "zipEntryName", ")", ";", "byte", "[", "]", "data", "=", "IOUtils", ".", "toByteArray", "(", "zipEntryInputStream", ")", ";", "uncompressedData", ".", "put", "(", "zipEntryName", ",", "data", ")", ";", "}", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Unsupported zipResultType ", "\"", "+", "zipResultType", ")", ";", "}", "}", "public", "File", "checkPath", "(", "final", "Message", "<", "?", ">", "message", ",", "final", "String", "zipEntryName", ")", "throws", "IOException", "{", "final", "File", "tempDir", "=", "new", "File", "(", "workDirectory", ",", "message", ".", "getHeaders", "(", ")", ".", "getId", "(", ")", ".", "toString", "(", ")", ")", ";", "tempDir", ".", "mkdirs", "(", ")", ";", "final", "File", "destinationFile", "=", "new", "File", "(", "tempDir", ",", "zipEntryName", ")", ";", "if", "(", "!", "destinationFile", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "workDirectory", ".", "getCanonicalPath", "(", ")", ")", ")", "{", "throw", "new", "ZipException", "(", "\"", "The file ", "\"", "+", "zipEntryName", "+", "\"", " is trying to leave the target output directory of ", "\"", "+", "workDirectory", ")", ";", "}", "return", "destinationFile", ";", "}", "}", ")", ";", "if", "(", "uncompressedData", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "logger", ".", "isWarnEnabled", "(", ")", ")", "{", "logger", ".", "warn", "(", "\"", "No data unzipped from payload with message Id ", "\"", "+", "message", ".", "getHeaders", "(", ")", ".", "getId", "(", ")", ")", ";", "}", "unzippedData", "=", "null", ";", "}", "else", "{", "if", "(", "this", ".", "expectSingleResult", ")", "{", "if", "(", "uncompressedData", ".", "size", "(", ")", "==", "1", ")", "{", "unzippedData", "=", "uncompressedData", ".", "values", "(", ")", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "}", "else", "{", "throw", "new", "MessagingException", "(", "message", ",", "String", ".", "format", "(", "\"", "The UnZip operation extracted %s ", "\"", "+", "\"", "result objects but expectSingleResult was 'true'.", "\"", ",", "uncompressedData", ".", "size", "(", ")", ")", ")", ";", "}", "}", "else", "{", "unzippedData", "=", "uncompressedData", ";", "}", "}", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "inputStream", ")", ";", "if", "(", "payload", "instanceof", "File", "&&", "this", ".", "deleteFiles", ")", "{", "final", "File", "filePayload", "=", "(", "File", ")", "payload", ";", "if", "(", "!", "filePayload", ".", "delete", "(", ")", "&&", "logger", ".", "isWarnEnabled", "(", ")", ")", "{", "if", "(", "logger", ".", "isWarnEnabled", "(", ")", ")", "{", "logger", ".", "warn", "(", "\"", "failed to delete File '", "\"", "+", "filePayload", "+", "\"", "'", "\"", ")", ";", "}", "}", "}", "}", "return", "unzippedData", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "MessageHandlingException", "(", "message", ",", "\"", "Failed to apply Zip transformation.", "\"", ",", "e", ")", ";", "}", "}"], "idx": 26488, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "d10f537283d90eabd28af57ac97f860a3913bf9b", "function_name": "doZipTransform", "body_hash": "6ec74a9f45d6f6ba7db6a701a08d8523ddd783b1"}
{"code": "@Override\n        public String getProperty( String key ) {\n            return System.getProperty(key);\n        }", "code_tokens": ["@", "Override", "public", "String", "getProperty", "(", "String", "key", ")", "{", "return", "System", ".", "getProperty", "(", "key", ")", ";", "}"], "idx": 101464, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "ae6163a4f230bc679abfc93e048ff92996badad6", "function_name": "getProperty", "body_hash": "e6b0896018385d9c1f58dd06c391a24b173b2943"}
{"code": "public void renameUser(final String oldName, final String newName) throws Exception {\n        update();\n\n        m_writeLock.lock();\n        \n        try {\n            // Get the old data\n            if (m_users.containsKey(oldName)) {\n                final User data = m_users.get(oldName);\n                if (data == null) {\n                    m_users.remove(oldName);\n                    throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n                } else {\n                    if (m_users.containsKey(newName)) {\n                        throw new Exception(\"UserFactory: cannot rename user \" + oldName + \". An user with the given name \" + newName + \" already exists\");\n                    }\n\n                    // Rename the user in the user map.\n                    m_users.remove(oldName);\n                    data.setUserId(newName);\n                    m_users.put(newName, data);\n        \n                    // Refresh the groups config first\n                    m_groupManager.update();\n                    \n                    // Rename the user in the group.\n                    m_groupManager.renameUser(oldName, newName);\n        \n                    // Rename the user in the view.\n                    // viewFactory.renameUser(oldName, newName);\n                }\n            } else {\n                throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n            }\n        \n            _saveCurrent();\n        } finally {\n            m_writeLock.unlock();\n        }\n    }", "code_tokens": ["public", "void", "renameUser", "(", "final", "String", "oldName", ",", "final", "String", "newName", ")", "throws", "Exception", "{", "update", "(", ")", ";", "m_writeLock", ".", "lock", "(", ")", ";", "try", "{", "if", "(", "m_users", ".", "containsKey", "(", "oldName", ")", ")", "{", "final", "User", "data", "=", "m_users", ".", "get", "(", "oldName", ")", ";", "if", "(", "data", "==", "null", ")", "{", "m_users", ".", "remove", "(", "oldName", ")", ";", "throw", "new", "Exception", "(", "\"", "UserFactory:rename the data contained for old user ", "\"", "+", "oldName", "+", "\"", " is null", "\"", ")", ";", "}", "else", "{", "if", "(", "m_users", ".", "containsKey", "(", "newName", ")", ")", "{", "throw", "new", "Exception", "(", "\"", "UserFactory: cannot rename user ", "\"", "+", "oldName", "+", "\"", ". An user with the given name ", "\"", "+", "newName", "+", "\"", " already exists", "\"", ")", ";", "}", "m_users", ".", "remove", "(", "oldName", ")", ";", "data", ".", "setUserId", "(", "newName", ")", ";", "m_users", ".", "put", "(", "newName", ",", "data", ")", ";", "m_groupManager", ".", "update", "(", ")", ";", "m_groupManager", ".", "renameUser", "(", "oldName", ",", "newName", ")", ";", "}", "}", "else", "{", "throw", "new", "Exception", "(", "\"", "UserFactory:rename the old user name ", "\"", "+", "oldName", "+", "\"", " is not found", "\"", ")", ";", "}", "_saveCurrent", "(", ")", ";", "}", "finally", "{", "m_writeLock", ".", "unlock", "(", ")", ";", "}", "}"], "idx": 45061, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "607151ea8f90212a3fb37c977fa57c7d58d26a84", "function_name": "renameUser", "body_hash": "47668e66e6a05e814631ca7f15e0c52b60d54726"}
{"code": "@Override\n  public ExitCode runWithoutHelp(CommandRunnerParams params)\n      throws IOException, InterruptedException {\n\n    if (saveFilename != null && loadFilename != null) {\n      params.getConsole().printErrorText(\"Can't use both --load and --save\");\n      return ExitCode.COMMANDLINE_ERROR;\n    }\n\n    if (saveFilename != null) {\n      invalidateChanges(params);\n      RemoteDaemonicParserState state = params.getParser().storeParserState(params.getCell());\n      try (FileOutputStream fos = new FileOutputStream(saveFilename);\n          ZipOutputStream zipos = new ZipOutputStream(fos)) {\n        zipos.putNextEntry(new ZipEntry(\"parser_data\"));\n        try (ObjectOutputStream oos = new ObjectOutputStream(zipos)) {\n          oos.writeObject(state);\n        }\n      }\n    } else if (loadFilename != null) {\n      try (FileInputStream fis = new FileInputStream(loadFilename);\n          ZipInputStream zipis = new ZipInputStream(fis)) {\n        ZipEntry entry = zipis.getNextEntry();\n        Preconditions.checkState(entry.getName().equals(\"parser_data\"));\n        try (ObjectInputStream ois = new ObjectInputStream(zipis)) {\n          RemoteDaemonicParserState state;\n          try {\n            state = (RemoteDaemonicParserState) ois.readObject();\n          } catch (ClassNotFoundException e) {\n            params.getConsole().printErrorText(\"Invalid file format\");\n            return ExitCode.COMMANDLINE_ERROR;\n          }\n          params.getParser().restoreParserState(state, params.getCell());\n        }\n      }\n      invalidateChanges(params);\n\n      ParserConfig configView = params.getBuckConfig().getView(ParserConfig.class);\n      if (configView.isParserCacheMutationWarningEnabled()) {\n        params\n            .getConsole()\n            .printErrorText(\n                params\n                    .getConsole()\n                    .getAnsi()\n                    .asWarningText(\n                        \"WARNING: Buck injected a parser state that may not match the local state.\"));\n      }\n    }\n\n    return ExitCode.SUCCESS;\n  }", "code_tokens": ["@", "Override", "public", "ExitCode", "runWithoutHelp", "(", "CommandRunnerParams", "params", ")", "throws", "IOException", ",", "InterruptedException", "{", "if", "(", "saveFilename", "!=", "null", "&&", "loadFilename", "!=", "null", ")", "{", "params", ".", "getConsole", "(", ")", ".", "printErrorText", "(", "\"", "Can't use both --load and --save", "\"", ")", ";", "return", "ExitCode", ".", "COMMANDLINE_ERROR", ";", "}", "if", "(", "saveFilename", "!=", "null", ")", "{", "invalidateChanges", "(", "params", ")", ";", "RemoteDaemonicParserState", "state", "=", "params", ".", "getParser", "(", ")", ".", "storeParserState", "(", "params", ".", "getCell", "(", ")", ")", ";", "try", "(", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "saveFilename", ")", ";", "ZipOutputStream", "zipos", "=", "new", "ZipOutputStream", "(", "fos", ")", ")", "{", "zipos", ".", "putNextEntry", "(", "new", "ZipEntry", "(", "\"", "parser_data", "\"", ")", ")", ";", "try", "(", "ObjectOutputStream", "oos", "=", "new", "ObjectOutputStream", "(", "zipos", ")", ")", "{", "oos", ".", "writeObject", "(", "state", ")", ";", "}", "}", "}", "else", "if", "(", "loadFilename", "!=", "null", ")", "{", "try", "(", "FileInputStream", "fis", "=", "new", "FileInputStream", "(", "loadFilename", ")", ";", "ZipInputStream", "zipis", "=", "new", "ZipInputStream", "(", "fis", ")", ")", "{", "ZipEntry", "entry", "=", "zipis", ".", "getNextEntry", "(", ")", ";", "Preconditions", ".", "checkState", "(", "entry", ".", "getName", "(", ")", ".", "equals", "(", "\"", "parser_data", "\"", ")", ")", ";", "try", "(", "ObjectInputStream", "ois", "=", "new", "ObjectInputStream", "(", "zipis", ")", ")", "{", "RemoteDaemonicParserState", "state", ";", "try", "{", "state", "=", "(", "RemoteDaemonicParserState", ")", "ois", ".", "readObject", "(", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "params", ".", "getConsole", "(", ")", ".", "printErrorText", "(", "\"", "Invalid file format", "\"", ")", ";", "return", "ExitCode", ".", "COMMANDLINE_ERROR", ";", "}", "params", ".", "getParser", "(", ")", ".", "restoreParserState", "(", "state", ",", "params", ".", "getCell", "(", ")", ")", ";", "}", "}", "invalidateChanges", "(", "params", ")", ";", "ParserConfig", "configView", "=", "params", ".", "getBuckConfig", "(", ")", ".", "getView", "(", "ParserConfig", ".", "class", ")", ";", "if", "(", "configView", ".", "isParserCacheMutationWarningEnabled", "(", ")", ")", "{", "params", ".", "getConsole", "(", ")", ".", "printErrorText", "(", "params", ".", "getConsole", "(", ")", ".", "getAnsi", "(", ")", ".", "asWarningText", "(", "\"", "WARNING: Buck injected a parser state that may not match the local state.", "\"", ")", ")", ";", "}", "}", "return", "ExitCode", ".", "SUCCESS", ";", "}"], "idx": 62168, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "8c5500981812564877bd122c0f8fab48d3528ddf", "function_name": "runWithoutHelp", "body_hash": "b473480beb7b792e6edf22a5d0aef3c079abcbb5"}
{"code": "protected void traceLdapEnv(Properties env)\n   {\n      if (trace)\n      {\n         Properties tmp = new Properties();\n         tmp.putAll(env);\n         String credentials = tmp.getProperty(Context.SECURITY_CREDENTIALS);\n         String bindCredential = tmp.getProperty(BIND_CREDENTIAL);\n         if (credentials != null && credentials.length() > 0)\n            tmp.setProperty(Context.SECURITY_CREDENTIALS, \"***\");\n         \n         if (bindCredential != null && bindCredential.length() > 0)\n             tmp.setProperty(BIND_CREDENTIAL, \"***\");\n         \n         log.trace(\"Logging into LDAP server, env=\" + tmp.toString());\n      }\n   }", "code_tokens": ["protected", "void", "traceLdapEnv", "(", "Properties", "env", ")", "{", "if", "(", "trace", ")", "{", "Properties", "tmp", "=", "new", "Properties", "(", ")", ";", "tmp", ".", "putAll", "(", "env", ")", ";", "String", "credentials", "=", "tmp", ".", "getProperty", "(", "Context", ".", "SECURITY_CREDENTIALS", ")", ";", "String", "bindCredential", "=", "tmp", ".", "getProperty", "(", "BIND_CREDENTIAL", ")", ";", "if", "(", "credentials", "!=", "null", "&&", "credentials", ".", "length", "(", ")", ">", "0", ")", "tmp", ".", "setProperty", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "\"", "***", "\"", ")", ";", "if", "(", "bindCredential", "!=", "null", "&&", "bindCredential", ".", "length", "(", ")", ">", "0", ")", "tmp", ".", "setProperty", "(", "BIND_CREDENTIAL", ",", "\"", "***", "\"", ")", ";", "log", ".", "trace", "(", "\"", "Logging into LDAP server, env=", "\"", "+", "tmp", ".", "toString", "(", ")", ")", ";", "}", "}"], "idx": 18066, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "0dc9d191b6eb1d13b8f0189c5b02ba6576f4722e", "function_name": "traceLdapEnv", "body_hash": "38b991f0c613aad657a632750980f21640ab3592"}
{"code": "protected void scanExternalID(String[] identifiers,\n                                  boolean optionalSystemId)\n        throws IOException, XNIException {\n\n        String systemId = null;\n        String publicId = null;\n        if (fEntityScanner.skipString(\"PUBLIC\")) {\n            if (!fEntityScanner.skipSpaces()) {\n                reportFatalError(\"SpaceRequiredAfterPUBLIC\", null);\n            }\n            scanPubidLiteral(fString);\n            publicId = fString.toString();\n\n            if (!fEntityScanner.skipSpaces() && !optionalSystemId) {\n                reportFatalError(\"SpaceRequiredBetweenPublicAndSystem\", null);\n            }\n        }\n\n        if (publicId != null || fEntityScanner.skipString(\"SYSTEM\")) {\n            if (publicId == null && !fEntityScanner.skipSpaces()) {\n                reportFatalError(\"SpaceRequiredAfterSYSTEM\", null);\n            }\n            int quote = fEntityScanner.peekChar();\n            if (quote != '\\'' && quote != '\"') {\n                if (publicId != null && optionalSystemId) {\n                    // looks like we don't have any system id\n                    // simply return the public id\n                    identifiers[0] = null;\n                    identifiers[1] = publicId;\n                    return;\n                }\n                reportFatalError(\"QuoteRequiredInSystemID\", null);\n            }\n            fEntityScanner.scanChar();\n            XMLString ident = fString;\n            if (fEntityScanner.scanLiteral(quote, ident) != quote) {\n                fStringBuffer.clear();\n                do {\n                    fStringBuffer.append(ident);\n                    int c = fEntityScanner.peekChar();\n                    if (XMLChar.isMarkup(c) || c == ']') {\n                        fStringBuffer.append((char)fEntityScanner.scanChar());\n                    }\n                } while (fEntityScanner.scanLiteral(quote, ident) != quote);\n                fStringBuffer.append(ident);\n                ident = fStringBuffer;\n            }\n            systemId = ident.toString();\n            if (!fEntityScanner.skipChar(quote)) {\n                reportFatalError(\"SystemIDUnterminated\", null);\n            }\n        }\n\n        // store result in array\n        identifiers[0] = systemId;\n        identifiers[1] = publicId;\n    }", "code_tokens": ["protected", "void", "scanExternalID", "(", "String", "[", "]", "identifiers", ",", "boolean", "optionalSystemId", ")", "throws", "IOException", ",", "XNIException", "{", "String", "systemId", "=", "null", ";", "String", "publicId", "=", "null", ";", "if", "(", "fEntityScanner", ".", "skipString", "(", "\"", "PUBLIC", "\"", ")", ")", "{", "if", "(", "!", "fEntityScanner", ".", "skipSpaces", "(", ")", ")", "{", "reportFatalError", "(", "\"", "SpaceRequiredAfterPUBLIC", "\"", ",", "null", ")", ";", "}", "scanPubidLiteral", "(", "fString", ")", ";", "publicId", "=", "fString", ".", "toString", "(", ")", ";", "if", "(", "!", "fEntityScanner", ".", "skipSpaces", "(", ")", "&&", "!", "optionalSystemId", ")", "{", "reportFatalError", "(", "\"", "SpaceRequiredBetweenPublicAndSystem", "\"", ",", "null", ")", ";", "}", "}", "if", "(", "publicId", "!=", "null", "||", "fEntityScanner", ".", "skipString", "(", "\"", "SYSTEM", "\"", ")", ")", "{", "if", "(", "publicId", "==", "null", "&&", "!", "fEntityScanner", ".", "skipSpaces", "(", ")", ")", "{", "reportFatalError", "(", "\"", "SpaceRequiredAfterSYSTEM", "\"", ",", "null", ")", ";", "}", "int", "quote", "=", "fEntityScanner", ".", "peekChar", "(", ")", ";", "if", "(", "quote", "!=", "'\\''", "&&", "quote", "!=", "'\"'", ")", "{", "if", "(", "publicId", "!=", "null", "&&", "optionalSystemId", ")", "{", "identifiers", "[", "0", "]", "=", "null", ";", "identifiers", "[", "1", "]", "=", "publicId", ";", "return", ";", "}", "reportFatalError", "(", "\"", "QuoteRequiredInSystemID", "\"", ",", "null", ")", ";", "}", "fEntityScanner", ".", "scanChar", "(", ")", ";", "XMLString", "ident", "=", "fString", ";", "if", "(", "fEntityScanner", ".", "scanLiteral", "(", "quote", ",", "ident", ")", "!=", "quote", ")", "{", "fStringBuffer", ".", "clear", "(", ")", ";", "do", "{", "fStringBuffer", ".", "append", "(", "ident", ")", ";", "int", "c", "=", "fEntityScanner", ".", "peekChar", "(", ")", ";", "if", "(", "XMLChar", ".", "isMarkup", "(", "c", ")", "||", "c", "==", "']'", ")", "{", "fStringBuffer", ".", "append", "(", "(", "char", ")", "fEntityScanner", ".", "scanChar", "(", ")", ")", ";", "}", "}", "while", "(", "fEntityScanner", ".", "scanLiteral", "(", "quote", ",", "ident", ")", "!=", "quote", ")", ";", "fStringBuffer", ".", "append", "(", "ident", ")", ";", "ident", "=", "fStringBuffer", ";", "}", "systemId", "=", "ident", ".", "toString", "(", ")", ";", "if", "(", "!", "fEntityScanner", ".", "skipChar", "(", "quote", ")", ")", "{", "reportFatalError", "(", "\"", "SystemIDUnterminated", "\"", ",", "null", ")", ";", "}", "}", "identifiers", "[", "0", "]", "=", "systemId", ";", "identifiers", "[", "1", "]", "=", "publicId", ";", "}"], "idx": 115350, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "0bdf77af1d4fd26ec2e630fb6d12e2dfa77bc12b", "function_name": "scanExternalID", "body_hash": "ab374b99ad7921f80ea5fe46dbfc9172dda904e0"}
{"code": "@Restricted(NoExternalUse.class)\n        public FormValidation doCheckItemPattern(@QueryParameter String itemPattern) {\n            try {\n\n                Pattern.compile(itemPattern);\n                return FormValidation.ok();\n            } catch (PatternSyntaxException ex) {\n\n                // Wrap exception message to <pre> tag as the error messages\n                // uses position indicator (^) prefixed with spaces which work\n                // with monospace fonts only.\n                return FormValidation.errorWithMarkup(\"Not a regular expression: <pre>\" + ex.getMessage() + \"</pre>\");\n            }\n        }", "code_tokens": ["@", "Restricted", "(", "NoExternalUse", ".", "class", ")", "public", "FormValidation", "doCheckItemPattern", "(", "@", "QueryParameter", "String", "itemPattern", ")", "{", "try", "{", "Pattern", ".", "compile", "(", "itemPattern", ")", ";", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "catch", "(", "PatternSyntaxException", "ex", ")", "{", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "Not a regular expression: <pre>", "\"", "+", "ex", ".", "getMessage", "(", ")", "+", "\"", "</pre>", "\"", ")", ";", "}", "}"], "idx": 80871, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "b3e562a", "function_name": "doCheckItemPattern", "body_hash": "25c9ffd10432e0d7b2f1e5771195b2fa4d6b93a8"}
{"code": "private static String getIdFromToken(Element token) {\n        if (token != null) {\n            // For SAML tokens get the ID/AssertionID\n            if (\"Assertion\".equals(token.getLocalName())\n                && WSConstants.SAML2_NS.equals(token.getNamespaceURI())) {\n                return token.getAttributeNS(null, \"ID\");\n            } else if (\"Assertion\".equals(token.getLocalName())\n                && WSConstants.SAML_NS.equals(token.getNamespaceURI())) {\n                return token.getAttributeNS(null, \"AssertionID\");\n            }\n\n            // For UsernameTokens get the username\n            if (WSConstants.USERNAME_TOKEN_LN.equals(token.getLocalName())\n                && WSConstants.WSSE_NS.equals(token.getNamespaceURI())) {\n                Element usernameElement =\n                    XMLUtils.getDirectChildElement(token, WSConstants.USERNAME_LN, WSConstants.WSSE_NS);\n                if (usernameElement != null) {\n                    return XMLUtils.getElementText(usernameElement);\n                }\n            }\n\n            // For BinarySecurityTokens take the hash of the value\n            if (WSConstants.BINARY_TOKEN_LN.equals(token.getLocalName())\n                && WSConstants.WSSE_NS.equals(token.getNamespaceURI())) {\n                String text = XMLUtils.getElementText(token);\n                if (text != null && !\"\".equals(text)) {\n                    try {\n                        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n                        byte[] bytes = digest.digest(text.getBytes());\n                        return Base64.getMimeEncoder().encodeToString(bytes);\n                    } catch (NoSuchAlgorithmException e) {\n                        // SHA-256 must be supported so not going to happen...\n                    }\n                }\n            }\n        }\n        return \"\";\n    }", "code_tokens": ["private", "static", "String", "getIdFromToken", "(", "Element", "token", ")", "{", "if", "(", "token", "!=", "null", ")", "{", "if", "(", "\"", "Assertion", "\"", ".", "equals", "(", "token", ".", "getLocalName", "(", ")", ")", "&&", "WSConstants", ".", "SAML2_NS", ".", "equals", "(", "token", ".", "getNamespaceURI", "(", ")", ")", ")", "{", "return", "token", ".", "getAttributeNS", "(", "null", ",", "\"", "ID", "\"", ")", ";", "}", "else", "if", "(", "\"", "Assertion", "\"", ".", "equals", "(", "token", ".", "getLocalName", "(", ")", ")", "&&", "WSConstants", ".", "SAML_NS", ".", "equals", "(", "token", ".", "getNamespaceURI", "(", ")", ")", ")", "{", "return", "token", ".", "getAttributeNS", "(", "null", ",", "\"", "AssertionID", "\"", ")", ";", "}", "if", "(", "WSConstants", ".", "USERNAME_TOKEN_LN", ".", "equals", "(", "token", ".", "getLocalName", "(", ")", ")", "&&", "WSConstants", ".", "WSSE_NS", ".", "equals", "(", "token", ".", "getNamespaceURI", "(", ")", ")", ")", "{", "Element", "usernameElement", "=", "XMLUtils", ".", "getDirectChildElement", "(", "token", ",", "WSConstants", ".", "USERNAME_LN", ",", "WSConstants", ".", "WSSE_NS", ")", ";", "if", "(", "usernameElement", "!=", "null", ")", "{", "return", "XMLUtils", ".", "getElementText", "(", "usernameElement", ")", ";", "}", "}", "if", "(", "WSConstants", ".", "BINARY_TOKEN_LN", ".", "equals", "(", "token", ".", "getLocalName", "(", ")", ")", "&&", "WSConstants", ".", "WSSE_NS", ".", "equals", "(", "token", ".", "getNamespaceURI", "(", ")", ")", ")", "{", "String", "text", "=", "XMLUtils", ".", "getElementText", "(", "token", ")", ";", "if", "(", "text", "!=", "null", "&&", "!", "\"", "\"", ".", "equals", "(", "text", ")", ")", "{", "try", "{", "MessageDigest", "digest", "=", "MessageDigest", ".", "getInstance", "(", "\"", "SHA-256", "\"", ")", ";", "byte", "[", "]", "bytes", "=", "digest", ".", "digest", "(", "text", ".", "getBytes", "(", ")", ")", ";", "return", "Base64", ".", "getMimeEncoder", "(", ")", ".", "encodeToString", "(", "bytes", ")", ";", "}", "catch", "(", "NoSuchAlgorithmException", "e", ")", "{", "}", "}", "}", "}", "return", "\"", "\"", ";", "}"], "idx": 50588, "cwe": "CWE-384", "target": 0, "status": "FIXED", "commit": "66c2c5b9", "function_name": "getIdFromToken", "body_hash": "2ab9c733bd2d59c11179019b4950791028e15f19"}
{"code": "public static ClusterNodeInformation unmarshal(final InputStream is) throws JAXBException {\n        try {\n            final Unmarshaller unmarshaller = JAXB_CONTEXT.createUnmarshaller();\n            final XMLStreamReader xsr = XmlUtils.createSafeReader(is);\n            return (ClusterNodeInformation) unmarshaller.unmarshal(xsr);\n        } catch (XMLStreamException e) {\n            throw new JAXBException(\"Error unmarshalling the cluster node information\", e);\n        }\n    }", "code_tokens": ["public", "static", "ClusterNodeInformation", "unmarshal", "(", "final", "InputStream", "is", ")", "throws", "JAXBException", "{", "try", "{", "final", "Unmarshaller", "unmarshaller", "=", "JAXB_CONTEXT", ".", "createUnmarshaller", "(", ")", ";", "final", "XMLStreamReader", "xsr", "=", "XmlUtils", ".", "createSafeReader", "(", "is", ")", ";", "return", "(", "ClusterNodeInformation", ")", "unmarshaller", ".", "unmarshal", "(", "xsr", ")", ";", "}", "catch", "(", "XMLStreamException", "e", ")", "{", "throw", "new", "JAXBException", "(", "\"", "Error unmarshalling the cluster node information", "\"", ",", "e", ")", ";", "}", "}"], "idx": 67995, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "9e2c7be7d3c6a380c5f61074d9a5a690b617c3dc", "function_name": "unmarshal", "body_hash": "367731bc58edcb152ddef25a1c8860e0f17d6846"}
{"code": "@Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter<NotFoundException> parameter) {\n        String path = event.getLocation().getPath();\n        String additionalInfo = \"\";\n        if (parameter.hasCustomMessage()) {\n            additionalInfo = \"Reason: \" + parameter.getCustomMessage();\n        }\n        path = Jsoup.clean(path, Whitelist.none());\n        additionalInfo = Jsoup.clean(additionalInfo, Whitelist.none());\n\n        boolean productionMode = event.getUI().getSession().getConfiguration()\n                .isProductionMode();\n\n        String template = getErrorHtml(productionMode);\n        template = template.replace(\"{{path}}\", path);\n        template = template.replace(\"{{additionalInfo}}\", additionalInfo);\n        if (template.contains(\"{{routes}}\")) {\n            template = template.replace(\"{{routes}}\", getRoutes(event));\n        }\n\n        getElement().appendChild(new Html(template).getElement());\n        return HttpServletResponse.SC_NOT_FOUND;\n    }", "code_tokens": ["@", "Override", "public", "int", "setErrorParameter", "(", "BeforeEnterEvent", "event", ",", "ErrorParameter", "<", "NotFoundException", ">", "parameter", ")", "{", "String", "path", "=", "event", ".", "getLocation", "(", ")", ".", "getPath", "(", ")", ";", "String", "additionalInfo", "=", "\"", "\"", ";", "if", "(", "parameter", ".", "hasCustomMessage", "(", ")", ")", "{", "additionalInfo", "=", "\"", "Reason: ", "\"", "+", "parameter", ".", "getCustomMessage", "(", ")", ";", "}", "path", "=", "Jsoup", ".", "clean", "(", "path", ",", "Whitelist", ".", "none", "(", ")", ")", ";", "additionalInfo", "=", "Jsoup", ".", "clean", "(", "additionalInfo", ",", "Whitelist", ".", "none", "(", ")", ")", ";", "boolean", "productionMode", "=", "event", ".", "getUI", "(", ")", ".", "getSession", "(", ")", ".", "getConfiguration", "(", ")", ".", "isProductionMode", "(", ")", ";", "String", "template", "=", "getErrorHtml", "(", "productionMode", ")", ";", "template", "=", "template", ".", "replace", "(", "\"", "{{path}}", "\"", ",", "path", ")", ";", "template", "=", "template", ".", "replace", "(", "\"", "{{additionalInfo}}", "\"", ",", "additionalInfo", ")", ";", "if", "(", "template", ".", "contains", "(", "\"", "{{routes}}", "\"", ")", ")", "{", "template", "=", "template", ".", "replace", "(", "\"", "{{routes}}", "\"", ",", "getRoutes", "(", "event", ")", ")", ";", "}", "getElement", "(", ")", ".", "appendChild", "(", "new", "Html", "(", "template", ")", ".", "getElement", "(", ")", ")", ";", "return", "HttpServletResponse", ".", "SC_NOT_FOUND", ";", "}"], "idx": 7711, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "a1533dc", "function_name": "setErrorParameter", "body_hash": "d714ed790ed23d9f8eae410f7a414d10658773ca"}
{"code": "public void handleMessage(Message message) throws Fault {\n        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);\n        if (\"GET\".equals(method)) {\n            return;\n        }\n\n        Message outMs = message.getExchange().getOutMessage();\n        Message inMsg = outMs == null ? message : outMs.getExchange().getInMessage();\n\n        XMLStreamReader originalXmlStreamReader = inMsg.getContent(XMLStreamReader.class);\n        if (originalXmlStreamReader == null) {\n            InputStream is = inMsg.getContent(InputStream.class);\n            if (is != null) {\n                originalXmlStreamReader = StaxUtils.createXMLStreamReader(is);\n            }\n        }\n\n        registerStaxActionInInterceptor(inMsg);\n\n        try {\n            XMLSecurityProperties properties = new XMLSecurityProperties();\n            configureDecryptionKeys(inMsg, properties);\n            Crypto signatureCrypto = getSignatureCrypto(inMsg);\n            configureSignatureKeys(signatureCrypto, inMsg, properties);\n\n            SecurityEventListener securityEventListener =\n                configureSecurityEventListener(signatureCrypto, inMsg, properties);\n            InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n\n            XMLStreamReader newXmlStreamReader =\n                inboundXMLSec.processInMessage(originalXmlStreamReader, null, securityEventListener);\n            inMsg.setContent(XMLStreamReader.class, newXmlStreamReader);\n\n        } catch (XMLStreamException e) {\n            throwFault(e.getMessage(), e);\n        } catch (XMLSecurityException e) {\n            throwFault(e.getMessage(), e);\n        } catch (IOException e) {\n            throwFault(e.getMessage(), e);\n        } catch (UnsupportedCallbackException e) {\n            throwFault(e.getMessage(), e);\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "throws", "Fault", "{", "String", "method", "=", "(", "String", ")", "message", ".", "get", "(", "Message", ".", "HTTP_REQUEST_METHOD", ")", ";", "if", "(", "\"", "GET", "\"", ".", "equals", "(", "method", ")", ")", "{", "return", ";", "}", "Message", "outMs", "=", "message", ".", "getExchange", "(", ")", ".", "getOutMessage", "(", ")", ";", "Message", "inMsg", "=", "outMs", "==", "null", "?", "message", ":", "outMs", ".", "getExchange", "(", ")", ".", "getInMessage", "(", ")", ";", "XMLStreamReader", "originalXmlStreamReader", "=", "inMsg", ".", "getContent", "(", "XMLStreamReader", ".", "class", ")", ";", "if", "(", "originalXmlStreamReader", "==", "null", ")", "{", "InputStream", "is", "=", "inMsg", ".", "getContent", "(", "InputStream", ".", "class", ")", ";", "if", "(", "is", "!=", "null", ")", "{", "originalXmlStreamReader", "=", "StaxUtils", ".", "createXMLStreamReader", "(", "is", ")", ";", "}", "}", "registerStaxActionInInterceptor", "(", "inMsg", ")", ";", "try", "{", "XMLSecurityProperties", "properties", "=", "new", "XMLSecurityProperties", "(", ")", ";", "configureDecryptionKeys", "(", "inMsg", ",", "properties", ")", ";", "Crypto", "signatureCrypto", "=", "getSignatureCrypto", "(", "inMsg", ")", ";", "configureSignatureKeys", "(", "signatureCrypto", ",", "inMsg", ",", "properties", ")", ";", "SecurityEventListener", "securityEventListener", "=", "configureSecurityEventListener", "(", "signatureCrypto", ",", "inMsg", ",", "properties", ")", ";", "InboundXMLSec", "inboundXMLSec", "=", "XMLSec", ".", "getInboundWSSec", "(", "properties", ")", ";", "XMLStreamReader", "newXmlStreamReader", "=", "inboundXMLSec", ".", "processInMessage", "(", "originalXmlStreamReader", ",", "null", ",", "securityEventListener", ")", ";", "inMsg", ".", "setContent", "(", "XMLStreamReader", ".", "class", ",", "newXmlStreamReader", ")", ";", "}", "catch", "(", "XMLStreamException", "e", ")", "{", "throwFault", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "catch", "(", "XMLSecurityException", "e", ")", "{", "throwFault", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throwFault", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "catch", "(", "UnsupportedCallbackException", "e", ")", "{", "throwFault", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "}"], "idx": 40419, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "fade9b81dabe27f864ca38e7b40f28fb44d6f165", "function_name": "handleMessage", "body_hash": "0b0837bca6b21abf0680d21e5289b3d18bfcb169"}
{"code": "public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/{0,1}([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }", "code_tokens": ["public", "String", "getUrlRegex", "(", ")", "{", "if", "(", "StringUtils", ".", "isNotEmpty", "(", "urlRegexExpression", ")", ")", "{", "return", "(", "String", ")", "parse", "(", "urlRegexExpression", ",", "String", ".", "class", ")", ";", "}", "else", "if", "(", "StringUtils", ".", "isNotEmpty", "(", "urlRegex", ")", ")", "{", "return", "urlRegex", ";", "}", "else", "{", "return", "\"", "^(https?|ftp):", "\\\\", "/", "\\\\", "/", "\"", "+", "\"", "(([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;", "\\\\", "?&=-]|%[0-9a-f]{2})+", "\"", "+", "\"", "(:([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;", "\\\\", "?&=-]|%[0-9a-f]{2})+)?", "\"", "+", "\"", "@)?(#?", "\"", "+", "\"", ")((([a-z0-9]", "\\\\", ".|[a-z0-9][a-z0-9-]*[a-z0-9]", "\\\\", ".)*", "\"", "+", "\"", "[a-z][a-z0-9-]*[a-z0-9]", "\"", "+", "\"", "|((", "\\\\", "d|[1-9]", "\\\\", "d|1", "\\\\", "d{2}|2[0-4][0-9]|25[0-5])", "\\\\", ".){3}", "\"", "+", "\"", "(", "\\\\", "d|[1-9]", "\\\\", "d|1", "\\\\", "d{2}|2[0-4][0-9]|25[0-5])", "\"", "+", "\"", ")(:", "\\\\", "d+)?", "\"", "+", "\"", ")(((", "\\\\", "/{0,1}([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;:@&=-]|%[0-9a-f]{2})*)*", "\"", "+", "\"", "(", "\\\\", "?([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;:@&=-]|%[0-9a-f]{2})*)", "\"", "+", "\"", "?)?)?", "\"", "+", "\"", "(#([a-z0-9$_", "\\\\", ".", "\\\\", "+!", "\\\\", "*", "\\\\", "'", "\\\\", "(", "\\\\", "),;:@&=-]|%[0-9a-f]{2})*)?", "\"", "+", "\"", "$", "\"", ";", "}", "}"], "idx": 12236, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "744c1f409d983641af3e8e3b573c2f2d2c2c6d9", "function_name": "getUrlRegex", "body_hash": "a366c92b6f50e148a2387926bf39f13189683a6a"}
{"code": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n    if (!nettyRequest.decoderResult().isSuccess()) {\n      LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n      sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n      return;\n    }\n\n    Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n\n    //Find the content length we will use this as an indicator of a body\n    Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n    String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n\n    //If there is a content length or transfer encoding that indicates there is a body\n    boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n\n    RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n\n    Channel channel = ctx.channel();\n\n    if (requestBody != null) {\n      channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n    }\n    InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n    InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n\n    ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n\n    DefaultRequest request = new DefaultRequest(\n      clock.instant(),\n      requestHeaders,\n      nettyRequest.method(),\n      nettyRequest.protocolVersion(),\n      nettyRequest.uri(),\n      remoteAddress,\n      socketAddress,\n      serverRegistry.get(ServerConfig.class),\n      requestBody,\n      connectionIdleTimeout,\n      channel.attr(CLIENT_CERT_KEY).get()\n    );\n\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders(false);\n    MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n    AtomicBoolean transmitted = new AtomicBoolean(false);\n\n    DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n\n    ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n\n    Action<Action<Object>> subscribeHandler = thing -> {\n      transmitted.set(true);\n      ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n    };\n\n    DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n      applicationConstants,\n      request,\n      channel,\n      responseTransmitter,\n      subscribeHandler\n    );\n\n    Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n    requestConstants.response = response;\n\n    DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n      if (!transmitted.get()) {\n        Handler lastHandler = requestConstants.handler;\n        StringBuilder description = new StringBuilder();\n        description\n          .append(\"No response sent for \")\n          .append(request.getMethod().getName())\n          .append(\" request to \")\n          .append(request.getUri());\n\n        if (lastHandler != null) {\n          description.append(\" (last handler: \");\n\n          if (lastHandler instanceof DescribingHandler) {\n            ((DescribingHandler) lastHandler).describeTo(description);\n          } else {\n            DescribingHandlers.describeTo(lastHandler, description);\n          }\n          description.append(\")\");\n        }\n\n        String message = description.toString();\n        LOGGER.warn(message);\n\n        response.getHeaders().clear();\n\n        ByteBuf body;\n        if (development) {\n          CharBuffer charBuffer = CharBuffer.wrap(message);\n          body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n          response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n        } else {\n          body = Unpooled.EMPTY_BUFFER;\n        }\n\n        response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n        responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n      }\n    });\n  }", "code_tokens": ["private", "void", "newRequest", "(", "ChannelHandlerContext", "ctx", ",", "HttpRequest", "nettyRequest", ")", "throws", "Exception", "{", "if", "(", "!", "nettyRequest", ".", "decoderResult", "(", ")", ".", "isSuccess", "(", ")", ")", "{", "LOGGER", ".", "debug", "(", "\"", "Failed to decode HTTP request.", "\"", ",", "nettyRequest", ".", "decoderResult", "(", ")", ".", "cause", "(", ")", ")", ";", "sendError", "(", "ctx", ",", "HttpResponseStatus", ".", "BAD_REQUEST", ")", ";", "return", ";", "}", "Headers", "requestHeaders", "=", "new", "NettyHeadersBackedHeaders", "(", "nettyRequest", ".", "headers", "(", ")", ")", ";", "Long", "contentLength", "=", "HttpUtil", ".", "getContentLength", "(", "nettyRequest", ",", "-", "1L", ")", ";", "String", "transferEncoding", "=", "requestHeaders", ".", "get", "(", "HttpHeaderNames", ".", "TRANSFER_ENCODING", ")", ";", "boolean", "hasBody", "=", "(", "contentLength", ">", "0", ")", "||", "(", "transferEncoding", "!=", "null", ")", ";", "RequestBody", "requestBody", "=", "hasBody", "?", "new", "RequestBody", "(", "contentLength", ",", "nettyRequest", ",", "ctx", ")", ":", "null", ";", "Channel", "channel", "=", "ctx", ".", "channel", "(", ")", ";", "if", "(", "requestBody", "!=", "null", ")", "{", "channel", ".", "attr", "(", "BODY_ACCUMULATOR_KEY", ")", ".", "set", "(", "requestBody", ")", ";", "}", "InetSocketAddress", "remoteAddress", "=", "(", "InetSocketAddress", ")", "channel", ".", "remoteAddress", "(", ")", ";", "InetSocketAddress", "socketAddress", "=", "(", "InetSocketAddress", ")", "channel", ".", "localAddress", "(", ")", ";", "ConnectionIdleTimeout", "connectionIdleTimeout", "=", "ConnectionIdleTimeout", ".", "of", "(", "channel", ")", ";", "DefaultRequest", "request", "=", "new", "DefaultRequest", "(", "clock", ".", "instant", "(", ")", ",", "requestHeaders", ",", "nettyRequest", ".", "method", "(", ")", ",", "nettyRequest", ".", "protocolVersion", "(", ")", ",", "nettyRequest", ".", "uri", "(", ")", ",", "remoteAddress", ",", "socketAddress", ",", "serverRegistry", ".", "get", "(", "ServerConfig", ".", "class", ")", ",", "requestBody", ",", "connectionIdleTimeout", ",", "channel", ".", "attr", "(", "CLIENT_CERT_KEY", ")", ".", "get", "(", ")", ")", ";", "HttpHeaders", "nettyHeaders", "=", "new", "DefaultHttpHeaders", "(", "false", ")", ";", "MutableHeaders", "responseHeaders", "=", "new", "NettyHeadersBackedMutableHeaders", "(", "nettyHeaders", ")", ";", "AtomicBoolean", "transmitted", "=", "new", "AtomicBoolean", "(", "false", ")", ";", "DefaultResponseTransmitter", "responseTransmitter", "=", "new", "DefaultResponseTransmitter", "(", "transmitted", ",", "channel", ",", "clock", ",", "nettyRequest", ",", "request", ",", "nettyHeaders", ",", "requestBody", ")", ";", "ctx", ".", "channel", "(", ")", ".", "attr", "(", "DefaultResponseTransmitter", ".", "ATTRIBUTE_KEY", ")", ".", "set", "(", "responseTransmitter", ")", ";", "Action", "<", "Action", "<", "Object", ">", ">", "subscribeHandler", "=", "thing", "->", "{", "transmitted", ".", "set", "(", "true", ")", ";", "ctx", ".", "channel", "(", ")", ".", "attr", "(", "CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY", ")", ".", "set", "(", "thing", ")", ";", "}", ";", "DefaultContext", ".", "RequestConstants", "requestConstants", "=", "new", "DefaultContext", ".", "RequestConstants", "(", "applicationConstants", ",", "request", ",", "channel", ",", "responseTransmitter", ",", "subscribeHandler", ")", ";", "Response", "response", "=", "new", "DefaultResponse", "(", "responseHeaders", ",", "ctx", ".", "alloc", "(", ")", ",", "responseTransmitter", ")", ";", "requestConstants", ".", "response", "=", "response", ";", "DefaultContext", ".", "start", "(", "channel", ".", "eventLoop", "(", ")", ",", "requestConstants", ",", "serverRegistry", ",", "handlers", ",", "execution", "->", "{", "if", "(", "!", "transmitted", ".", "get", "(", ")", ")", "{", "Handler", "lastHandler", "=", "requestConstants", ".", "handler", ";", "StringBuilder", "description", "=", "new", "StringBuilder", "(", ")", ";", "description", ".", "append", "(", "\"", "No response sent for ", "\"", ")", ".", "append", "(", "request", ".", "getMethod", "(", ")", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", " request to ", "\"", ")", ".", "append", "(", "request", ".", "getUri", "(", ")", ")", ";", "if", "(", "lastHandler", "!=", "null", ")", "{", "description", ".", "append", "(", "\"", " (last handler: ", "\"", ")", ";", "if", "(", "lastHandler", "instanceof", "DescribingHandler", ")", "{", "(", "(", "DescribingHandler", ")", "lastHandler", ")", ".", "describeTo", "(", "description", ")", ";", "}", "else", "{", "DescribingHandlers", ".", "describeTo", "(", "lastHandler", ",", "description", ")", ";", "}", "description", ".", "append", "(", "\"", ")", "\"", ")", ";", "}", "String", "message", "=", "description", ".", "toString", "(", ")", ";", "LOGGER", ".", "warn", "(", "message", ")", ";", "response", ".", "getHeaders", "(", ")", ".", "clear", "(", ")", ";", "ByteBuf", "body", ";", "if", "(", "development", ")", "{", "CharBuffer", "charBuffer", "=", "CharBuffer", ".", "wrap", "(", "message", ")", ";", "body", "=", "ByteBufUtil", ".", "encodeString", "(", "ctx", ".", "alloc", "(", ")", ",", "charBuffer", ",", "CharsetUtil", ".", "UTF_8", ")", ";", "response", ".", "contentType", "(", "HttpHeaderConstants", ".", "PLAIN_TEXT_UTF8", ")", ";", "}", "else", "{", "body", "=", "Unpooled", ".", "EMPTY_BUFFER", ";", "}", "response", ".", "getHeaders", "(", ")", ".", "set", "(", "HttpHeaderConstants", ".", "CONTENT_LENGTH", ",", "body", ".", "readableBytes", "(", ")", ")", ";", "responseTransmitter", ".", "transmit", "(", "HttpResponseStatus", ".", "INTERNAL_SERVER_ERROR", ",", "body", ")", ";", "}", "}", ")", ";", "}"], "idx": 73761, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "efb910d38a96494256f36675ef0e5061097dd77d", "function_name": "newRequest", "body_hash": "259df84ea12f40aab51b9c154aef569a53848aa9"}
{"code": "public static Connection connectSync(final ProtocolConnectionConfiguration configuration) throws IOException {\n        long timeoutMillis = configuration.getConnectionTimeout();\n        CallbackHandler handler = configuration.getCallbackHandler();\n        final CallbackHandler actualHandler;\n        ProtocolTimeoutHandler timeoutHandler = configuration.getTimeoutHandler();\n        // Note: If a client supplies a ProtocolTimeoutHandler it is taking on full responsibility for timeout management.\n        if (timeoutHandler == null) {\n            GeneralTimeoutHandler defaultTimeoutHandler = new GeneralTimeoutHandler();\n            // No point wrapping our AnonymousCallbackHandler.\n            actualHandler = handler != null ? new WrapperCallbackHandler(defaultTimeoutHandler, handler) : null;\n            timeoutHandler = defaultTimeoutHandler;\n        } else {\n            actualHandler = handler;\n        }\n\n        final IoFuture<Connection> future = connect(actualHandler, configuration);\n\n        IoFuture.Status status = timeoutHandler.await(future, timeoutMillis);\n\n        if (status == IoFuture.Status.DONE) {\n            return future.get();\n        }\n        if (status == IoFuture.Status.FAILED) {\n            throw ProtocolLogger.ROOT_LOGGER.failedToConnect(configuration.getUri(), future.getException());\n        }\n        throw ProtocolLogger.ROOT_LOGGER.couldNotConnect(configuration.getUri());\n    }", "code_tokens": ["public", "static", "Connection", "connectSync", "(", "final", "ProtocolConnectionConfiguration", "configuration", ")", "throws", "IOException", "{", "long", "timeoutMillis", "=", "configuration", ".", "getConnectionTimeout", "(", ")", ";", "CallbackHandler", "handler", "=", "configuration", ".", "getCallbackHandler", "(", ")", ";", "final", "CallbackHandler", "actualHandler", ";", "ProtocolTimeoutHandler", "timeoutHandler", "=", "configuration", ".", "getTimeoutHandler", "(", ")", ";", "if", "(", "timeoutHandler", "==", "null", ")", "{", "GeneralTimeoutHandler", "defaultTimeoutHandler", "=", "new", "GeneralTimeoutHandler", "(", ")", ";", "actualHandler", "=", "handler", "!=", "null", "?", "new", "WrapperCallbackHandler", "(", "defaultTimeoutHandler", ",", "handler", ")", ":", "null", ";", "timeoutHandler", "=", "defaultTimeoutHandler", ";", "}", "else", "{", "actualHandler", "=", "handler", ";", "}", "final", "IoFuture", "<", "Connection", ">", "future", "=", "connect", "(", "actualHandler", ",", "configuration", ")", ";", "IoFuture", ".", "Status", "status", "=", "timeoutHandler", ".", "await", "(", "future", ",", "timeoutMillis", ")", ";", "if", "(", "status", "==", "IoFuture", ".", "Status", ".", "DONE", ")", "{", "return", "future", ".", "get", "(", ")", ";", "}", "if", "(", "status", "==", "IoFuture", ".", "Status", ".", "FAILED", ")", "{", "throw", "ProtocolLogger", ".", "ROOT_LOGGER", ".", "failedToConnect", "(", "configuration", ".", "getUri", "(", ")", ",", "future", ".", "getException", "(", ")", ")", ";", "}", "throw", "ProtocolLogger", ".", "ROOT_LOGGER", ".", "couldNotConnect", "(", "configuration", ".", "getUri", "(", ")", ")", ";", "}"], "idx": 52880, "cwe": "CWE-401", "target": 1, "status": "VULNERABLE", "commit": "0332eaa2edb07df770bc429fa46bed9e0f2d1671", "function_name": "connectSync", "body_hash": "53e48c42a3c816bae6d6230a297a5bef43ede4ea"}
{"code": "@Override\n    public void deactivate() {\n        // Disassociate from the current conversation\n        if (isActive()) {\n            if (!isAssociated()) {\n                throw ConversationLogger.LOG.mustCallAssociateBeforeDeactivate();\n            }\n\n            try {\n                if (getCurrentConversation().isTransient() && getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) != null) {\n                    // WELD-1746 Don't destroy ended conversations - these must be destroyed in a synchronized block - see also cleanUpConversationMap()\n                    destroy();\n                } else {\n                    // Update the conversation timestamp\n                    getCurrentConversation().touch();\n                    if (!getBeanStore().isAttached()) {\n                        /*\n                         * This was a transient conversation at the beginning of the request, so we need to update the CID it uses, and attach it. We also add\n                         * it to the conversations the session knows about.\n                         */\n                        if (!(getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) instanceof ConversationNamingScheme)) {\n                            throw ConversationLogger.LOG.conversationNamingSchemeNotFound();\n                        }\n                        ((ConversationNamingScheme) getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME)).setCid(getCurrentConversation()\n                                .getId());\n\n                        try {\n                            getBeanStore().attach();\n                            getConversationMap().put(getCurrentConversation().getId(), getCurrentConversation());\n                        } catch (Exception cause) {\n                            // possible session not found error..\n                            ContextLogger.LOG.destroyingContextAfterBeanStoreAttachError(this, getBeanStore(), cause.getMessage());\n                            ContextLogger.LOG.catchingDebug(cause);\n                            destroy();\n                        }\n                    }\n                }\n            } finally {\n                // WELD-1690 always try to unlock the current conversation\n                getCurrentConversation().unlock();\n                // WELD-1802\n                setBeanStore(null);\n                // Clean up any expired/ended conversations\n                cleanUpConversationMap();\n                // deactivate the context\n                super.setActive(false);\n            }\n        } else {\n            throw ConversationLogger.LOG.contextNotActive();\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "deactivate", "(", ")", "{", "if", "(", "isActive", "(", ")", ")", "{", "if", "(", "!", "isAssociated", "(", ")", ")", "{", "throw", "ConversationLogger", ".", "LOG", ".", "mustCallAssociateBeforeDeactivate", "(", ")", ";", "}", "try", "{", "if", "(", "getCurrentConversation", "(", ")", ".", "isTransient", "(", ")", "&&", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", "!=", "null", ")", "{", "destroy", "(", ")", ";", "}", "else", "{", "getCurrentConversation", "(", ")", ".", "touch", "(", ")", ";", "if", "(", "!", "getBeanStore", "(", ")", ".", "isAttached", "(", ")", ")", "{", "if", "(", "!", "(", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", "instanceof", "ConversationNamingScheme", ")", ")", "{", "throw", "ConversationLogger", ".", "LOG", ".", "conversationNamingSchemeNotFound", "(", ")", ";", "}", "(", "(", "ConversationNamingScheme", ")", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", ")", ".", "setCid", "(", "getCurrentConversation", "(", ")", ".", "getId", "(", ")", ")", ";", "try", "{", "getBeanStore", "(", ")", ".", "attach", "(", ")", ";", "getConversationMap", "(", ")", ".", "put", "(", "getCurrentConversation", "(", ")", ".", "getId", "(", ")", ",", "getCurrentConversation", "(", ")", ")", ";", "}", "catch", "(", "Exception", "cause", ")", "{", "ContextLogger", ".", "LOG", ".", "destroyingContextAfterBeanStoreAttachError", "(", "this", ",", "getBeanStore", "(", ")", ",", "cause", ".", "getMessage", "(", ")", ")", ";", "ContextLogger", ".", "LOG", ".", "catchingDebug", "(", "cause", ")", ";", "destroy", "(", ")", ";", "}", "}", "}", "}", "finally", "{", "getCurrentConversation", "(", ")", ".", "unlock", "(", ")", ";", "setBeanStore", "(", "null", ")", ";", "cleanUpConversationMap", "(", ")", ";", "super", ".", "setActive", "(", "false", ")", ";", "}", "}", "else", "{", "throw", "ConversationLogger", ".", "LOG", ".", "contextNotActive", "(", ")", ";", "}", "}"], "idx": 49001, "cwe": "CWE-362", "target": 0, "status": "FIXED", "commit": "311dd79", "function_name": "deactivate", "body_hash": "60ef93c6c3594dd9cdd012ded3403e8a17c0ba2e"}
{"code": "protected void parseLocalesHeader(String value) {\n\n        // Store the accumulated languages that have been requested in\n        // a local collection, sorted by the quality value (so we can\n        // add Locales in descending order).  The values will be ArrayLists\n        // containing the corresponding Locales to be added\n        TreeMap<Double, ArrayList<Locale>> locales = new TreeMap<Double, ArrayList<Locale>>();\n\n        // Preprocess the value to remove all whitespace\n        int white = value.indexOf(' ');\n        if (white < 0)\n            white = value.indexOf('\\t');\n        if (white >= 0) {\n            StringBuilder sb = new StringBuilder();\n            int len = value.length();\n            for (int i = 0; i < len; i++) {\n                char ch = value.charAt(i);\n                if ((ch != ' ') && (ch != '\\t'))\n                    sb.append(ch);\n            }\n            parser.setString(sb.toString());\n        } else {\n            parser.setString(value);\n        }\n\n        // Process each comma-delimited language specification\n        int length = parser.getLength();\n        while (true) {\n\n            // Extract the next comma-delimited entry\n            int start = parser.getIndex();\n            if (start >= length)\n                break;\n            int end = parser.findChar(',');\n            String entry = parser.extract(start, end).trim();\n            parser.advance();   // For the following entry\n\n            // Extract the quality factor for this entry\n            double quality = 1.0;\n            int semi = entry.indexOf(\";q=\");\n            if (semi >= 0) {\n                try {\n                    quality = Double.parseDouble(entry.substring(semi + 3));\n                } catch (NumberFormatException e) {\n                    quality = 0.0;\n                }\n                entry = entry.substring(0, semi);\n            }\n\n            // Skip entries we are not going to keep track of\n            if (quality < 0.00005)\n                continue;       // Zero (or effectively zero) quality factors\n            if (\"*\".equals(entry))\n                continue;       // FIXME - \"*\" entries are not handled\n\n            // Extract the language and country for this entry\n            String language = null;\n            String country = null;\n            String variant = null;\n            int dash = entry.indexOf('-');\n            if (dash < 0) {\n                language = entry;\n                country = \"\";\n                variant = \"\";\n            } else {\n                language = entry.substring(0, dash);\n                country = entry.substring(dash + 1);\n                int vDash = country.indexOf('-');\n                if (vDash > 0) {\n                    String cTemp = country.substring(0, vDash);\n                    variant = country.substring(vDash + 1);\n                    country = cTemp;\n                } else {\n                    variant = \"\";\n                }\n            }\n            if (!isAlpha(language) || !isAlpha(country) || !isAlpha(variant)) {\n                continue;\n            }\n\n            // Add a new Locale to the list of Locales for this quality level\n            Locale locale = new Locale(language, country, variant);\n            Double key = new Double(-quality);  // Reverse the order\n            ArrayList<Locale> values = locales.get(key);\n            if (values == null) {\n                values = new ArrayList<Locale>();\n                locales.put(key, values);\n            }\n            values.add(locale);\n\n        }\n\n        // Process the quality values in highest->lowest order (due to\n        // negating the Double value when creating the key)\n        for (ArrayList<Locale> list : locales.values()) {\n            for (Locale locale : list) {\n                addLocale(locale);\n            }\n        }\n\n    }", "code_tokens": ["protected", "void", "parseLocalesHeader", "(", "String", "value", ")", "{", "TreeMap", "<", "Double", ",", "ArrayList", "<", "Locale", ">", ">", "locales", "=", "new", "TreeMap", "<", "Double", ",", "ArrayList", "<", "Locale", ">", ">", "(", ")", ";", "int", "white", "=", "value", ".", "indexOf", "(", "' '", ")", ";", "if", "(", "white", "<", "0", ")", "white", "=", "value", ".", "indexOf", "(", "'\\t'", ")", ";", "if", "(", "white", ">=", "0", ")", "{", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", ")", ";", "int", "len", "=", "value", ".", "length", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "char", "ch", "=", "value", ".", "charAt", "(", "i", ")", ";", "if", "(", "(", "ch", "!=", "' '", ")", "&&", "(", "ch", "!=", "'\\t'", ")", ")", "sb", ".", "append", "(", "ch", ")", ";", "}", "parser", ".", "setString", "(", "sb", ".", "toString", "(", ")", ")", ";", "}", "else", "{", "parser", ".", "setString", "(", "value", ")", ";", "}", "int", "length", "=", "parser", ".", "getLength", "(", ")", ";", "while", "(", "true", ")", "{", "int", "start", "=", "parser", ".", "getIndex", "(", ")", ";", "if", "(", "start", ">=", "length", ")", "break", ";", "int", "end", "=", "parser", ".", "findChar", "(", "','", ")", ";", "String", "entry", "=", "parser", ".", "extract", "(", "start", ",", "end", ")", ".", "trim", "(", ")", ";", "parser", ".", "advance", "(", ")", ";", "double", "quality", "=", "1.0", ";", "int", "semi", "=", "entry", ".", "indexOf", "(", "\"", ";q=", "\"", ")", ";", "if", "(", "semi", ">=", "0", ")", "{", "try", "{", "quality", "=", "Double", ".", "parseDouble", "(", "entry", ".", "substring", "(", "semi", "+", "3", ")", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "quality", "=", "0.0", ";", "}", "entry", "=", "entry", ".", "substring", "(", "0", ",", "semi", ")", ";", "}", "if", "(", "quality", "<", "0.00005", ")", "continue", ";", "if", "(", "\"", "*", "\"", ".", "equals", "(", "entry", ")", ")", "continue", ";", "String", "language", "=", "null", ";", "String", "country", "=", "null", ";", "String", "variant", "=", "null", ";", "int", "dash", "=", "entry", ".", "indexOf", "(", "'-'", ")", ";", "if", "(", "dash", "<", "0", ")", "{", "language", "=", "entry", ";", "country", "=", "\"", "\"", ";", "variant", "=", "\"", "\"", ";", "}", "else", "{", "language", "=", "entry", ".", "substring", "(", "0", ",", "dash", ")", ";", "country", "=", "entry", ".", "substring", "(", "dash", "+", "1", ")", ";", "int", "vDash", "=", "country", ".", "indexOf", "(", "'-'", ")", ";", "if", "(", "vDash", ">", "0", ")", "{", "String", "cTemp", "=", "country", ".", "substring", "(", "0", ",", "vDash", ")", ";", "variant", "=", "country", ".", "substring", "(", "vDash", "+", "1", ")", ";", "country", "=", "cTemp", ";", "}", "else", "{", "variant", "=", "\"", "\"", ";", "}", "}", "if", "(", "!", "isAlpha", "(", "language", ")", "||", "!", "isAlpha", "(", "country", ")", "||", "!", "isAlpha", "(", "variant", ")", ")", "{", "continue", ";", "}", "Locale", "locale", "=", "new", "Locale", "(", "language", ",", "country", ",", "variant", ")", ";", "Double", "key", "=", "new", "Double", "(", "-", "quality", ")", ";", "ArrayList", "<", "Locale", ">", "values", "=", "locales", ".", "get", "(", "key", ")", ";", "if", "(", "values", "==", "null", ")", "{", "values", "=", "new", "ArrayList", "<", "Locale", ">", "(", ")", ";", "locales", ".", "put", "(", "key", ",", "values", ")", ";", "}", "values", ".", "add", "(", "locale", ")", ";", "}", "for", "(", "ArrayList", "<", "Locale", ">", "list", ":", "locales", ".", "values", "(", ")", ")", "{", "for", "(", "Locale", "locale", ":", "list", ")", "{", "addLocale", "(", "locale", ")", ";", "}", "}", "}"], "idx": 111583, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "407841c426dc52a4c6b8ccd297df6c484a540056", "function_name": "parseLocalesHeader", "body_hash": "28cc9a57d492c1c6931872920ae6d52fdf3f7d44"}
{"code": "public static long getNextScheduledTime(final String cronEntry, long currentTime) throws MessageFormatException {\n\n        long result = 0;\n\n        if (cronEntry == null || cronEntry.length() == 0) {\n            return result;\n        }\n\n        // Handle the once per minute case \"* * * * *\"\n        // starting the next event at the top of the minute.\n        if (cronEntry.equals(\"* * * * *\")) {\n            result = currentTime + 60 * 1000;\n            result = result / 1000 * 1000;\n            return result;\n        }\n\n        List<String> list = tokenize(cronEntry);\n        List<CronEntry> entries = buildCronEntries(list);\n        Calendar working = Calendar.getInstance();\n        working.setTimeInMillis(currentTime);\n        working.set(Calendar.SECOND, 0);\n\n        CronEntry minutes = entries.get(MINUTES);\n        CronEntry hours = entries.get(HOURS);\n        CronEntry dayOfMonth = entries.get(DAY_OF_MONTH);\n        CronEntry month = entries.get(MONTH);\n        CronEntry dayOfWeek = entries.get(DAY_OF_WEEK);\n\n        // Start at the top of the next minute, cron is only guaranteed to be\n        // run on the minute.\n        int timeToNextMinute = 60 - working.get(Calendar.SECOND);\n        working.add(Calendar.SECOND, timeToNextMinute);\n\n        // If its already to late in the day this will roll us over to tomorrow\n        // so we'll need to check again when done updating month and day.\n        int currentMinutes = working.get(Calendar.MINUTE);\n        if (!isCurrent(minutes, currentMinutes)) {\n            int nextMinutes = getNext(minutes, currentMinutes);\n            working.add(Calendar.MINUTE, nextMinutes);\n        }\n\n        int currentHours = working.get(Calendar.HOUR_OF_DAY);\n        if (!isCurrent(hours, currentHours)) {\n            int nextHour = getNext(hours, currentHours);\n            working.add(Calendar.HOUR_OF_DAY, nextHour);\n        }\n\n        // We can roll into the next month here which might violate the cron setting\n        // rules so we check once then recheck again after applying the month settings.\n        doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);\n\n        // Start by checking if we are in the right month, if not then calculations\n        // need to start from the beginning of the month to ensure that we don't end\n        // up on the wrong day.  (Can happen when DAY_OF_WEEK is set and current time\n        // is ahead of the day of the week to execute on).\n        doUpdateCurrentMonth(working, month);\n\n        // Now Check day of week and day of month together since they can be specified\n        // together in one entry, if both \"day of month\" and \"day of week\" are restricted\n        // (not \"*\"), then either the \"day of month\" field (3) or the \"day of week\" field\n        // (5) must match the current day or the Calenday must be advanced.\n        doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);\n\n        // Now we can chose the correct hour and minute of the day in question.\n\n        currentHours = working.get(Calendar.HOUR_OF_DAY);\n        if (!isCurrent(hours, currentHours)) {\n            int nextHour = getNext(hours, currentHours);\n            working.add(Calendar.HOUR_OF_DAY, nextHour);\n        }\n\n        currentMinutes = working.get(Calendar.MINUTE);\n        if (!isCurrent(minutes, currentMinutes)) {\n            int nextMinutes = getNext(minutes, currentMinutes);\n            working.add(Calendar.MINUTE, nextMinutes);\n        }\n\n        result = working.getTimeInMillis();\n\n        if (result <= currentTime) {\n            throw new ArithmeticException(\"Unable to compute next scheduled exection time.\");\n        }\n\n        return result;\n    }", "code_tokens": ["public", "static", "long", "getNextScheduledTime", "(", "final", "String", "cronEntry", ",", "long", "currentTime", ")", "throws", "MessageFormatException", "{", "long", "result", "=", "0", ";", "if", "(", "cronEntry", "==", "null", "||", "cronEntry", ".", "length", "(", ")", "==", "0", ")", "{", "return", "result", ";", "}", "if", "(", "cronEntry", ".", "equals", "(", "\"", "* * * * *", "\"", ")", ")", "{", "result", "=", "currentTime", "+", "60", "*", "1000", ";", "result", "=", "result", "/", "1000", "*", "1000", ";", "return", "result", ";", "}", "List", "<", "String", ">", "list", "=", "tokenize", "(", "cronEntry", ")", ";", "List", "<", "CronEntry", ">", "entries", "=", "buildCronEntries", "(", "list", ")", ";", "Calendar", "working", "=", "Calendar", ".", "getInstance", "(", ")", ";", "working", ".", "setTimeInMillis", "(", "currentTime", ")", ";", "working", ".", "set", "(", "Calendar", ".", "SECOND", ",", "0", ")", ";", "CronEntry", "minutes", "=", "entries", ".", "get", "(", "MINUTES", ")", ";", "CronEntry", "hours", "=", "entries", ".", "get", "(", "HOURS", ")", ";", "CronEntry", "dayOfMonth", "=", "entries", ".", "get", "(", "DAY_OF_MONTH", ")", ";", "CronEntry", "month", "=", "entries", ".", "get", "(", "MONTH", ")", ";", "CronEntry", "dayOfWeek", "=", "entries", ".", "get", "(", "DAY_OF_WEEK", ")", ";", "int", "timeToNextMinute", "=", "60", "-", "working", ".", "get", "(", "Calendar", ".", "SECOND", ")", ";", "working", ".", "add", "(", "Calendar", ".", "SECOND", ",", "timeToNextMinute", ")", ";", "int", "currentMinutes", "=", "working", ".", "get", "(", "Calendar", ".", "MINUTE", ")", ";", "if", "(", "!", "isCurrent", "(", "minutes", ",", "currentMinutes", ")", ")", "{", "int", "nextMinutes", "=", "getNext", "(", "minutes", ",", "currentMinutes", ")", ";", "working", ".", "add", "(", "Calendar", ".", "MINUTE", ",", "nextMinutes", ")", ";", "}", "int", "currentHours", "=", "working", ".", "get", "(", "Calendar", ".", "HOUR_OF_DAY", ")", ";", "if", "(", "!", "isCurrent", "(", "hours", ",", "currentHours", ")", ")", "{", "int", "nextHour", "=", "getNext", "(", "hours", ",", "currentHours", ")", ";", "working", ".", "add", "(", "Calendar", ".", "HOUR_OF_DAY", ",", "nextHour", ")", ";", "}", "doUpdateCurrentDay", "(", "working", ",", "dayOfMonth", ",", "dayOfWeek", ")", ";", "doUpdateCurrentMonth", "(", "working", ",", "month", ")", ";", "doUpdateCurrentDay", "(", "working", ",", "dayOfMonth", ",", "dayOfWeek", ")", ";", "currentHours", "=", "working", ".", "get", "(", "Calendar", ".", "HOUR_OF_DAY", ")", ";", "if", "(", "!", "isCurrent", "(", "hours", ",", "currentHours", ")", ")", "{", "int", "nextHour", "=", "getNext", "(", "hours", ",", "currentHours", ")", ";", "working", ".", "add", "(", "Calendar", ".", "HOUR_OF_DAY", ",", "nextHour", ")", ";", "}", "currentMinutes", "=", "working", ".", "get", "(", "Calendar", ".", "MINUTE", ")", ";", "if", "(", "!", "isCurrent", "(", "minutes", ",", "currentMinutes", ")", ")", "{", "int", "nextMinutes", "=", "getNext", "(", "minutes", ",", "currentMinutes", ")", ";", "working", ".", "add", "(", "Calendar", ".", "MINUTE", ",", "nextMinutes", ")", ";", "}", "result", "=", "working", ".", "getTimeInMillis", "(", ")", ";", "if", "(", "result", "<=", "currentTime", ")", "{", "throw", "new", "ArithmeticException", "(", "\"", "Unable to compute next scheduled exection time.", "\"", ")", ";", "}", "return", "result", ";", "}"], "idx": 77465, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "148ca81dcd8f14cfe2ff37012fd1aa42518f02dc", "function_name": "getNextScheduledTime", "body_hash": "4dbc520e8a5051098325d7007e5bc88a50bad46e"}
{"code": "public Object extractValue(String strVal)\r\n   {\r\n      if (strVal == null)\r\n      {\r\n         if (defaultValue == null)\r\n         {\r\n            //System.out.println(\"NO DEFAULT VALUE\");\r\n            if (!StringToPrimitive.isPrimitive(baseType)) return null;\r\n            else\r\n               return StringToPrimitive.stringToPrimitiveBoxType(baseType, strVal);\r\n         }\r\n         else\r\n         {\r\n            strVal = defaultValue;\r\n            //System.out.println(\"DEFAULT VAULUE: \" + strVal);\r\n         }\r\n      }\r\n      if (paramConverter != null)\r\n      {\r\n         try {\r\n            return paramConverter.fromString(strVal);\r\n         } catch (Exception pce) {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\r\n                    getParamSignature(), strVal, target), pce);\r\n         }\r\n      }\r\n      if (unmarshaller != null)\r\n      {\r\n         try {\r\n         return unmarshaller.fromString(strVal);\r\n         } catch (Exception ue) {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\r\n                    getParamSignature(), strVal, target), ue);\r\n         }\r\n      }\r\n      else if (delegate != null)\r\n      {\r\n         try {\r\n            return delegate.fromString(strVal);\r\n         } catch (Exception pce) {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\r\n                    getParamSignature(), strVal, target), pce);\r\n         }\r\n      }\r\n      else if (constructor != null)\r\n      {\r\n         try\r\n         {\r\n            return constructor.newInstance(strVal);\r\n         }\r\n         catch (InstantiationException e)\r\n         {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), e);\r\n         }\r\n         catch (IllegalAccessException e)\r\n         {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), e);\r\n         }\r\n         catch (InvocationTargetException e)\r\n         {\r\n            Throwable targetException = e.getTargetException();\r\n            if (targetException instanceof WebApplicationException)\r\n            {\r\n               throw ((WebApplicationException)targetException);\r\n            }\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), targetException);\r\n         }\r\n      }\r\n      else if (valueOf != null)\r\n      {\r\n         try\r\n         {\r\n            return valueOf.invoke(null, strVal);\r\n         }\r\n         catch (IllegalAccessException e)\r\n         {\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), e);\r\n         }\r\n         catch (InvocationTargetException e)\r\n         {\r\n            Throwable targetException = e.getTargetException();\r\n            if (targetException instanceof WebApplicationException)\r\n            {\r\n               throw ((WebApplicationException)targetException);\r\n            }\r\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), targetException);\r\n         }\r\n      }\r\n      try\r\n      {\r\n         if (StringToPrimitive.isPrimitive(baseType)) return StringToPrimitive.stringToPrimitiveBoxType(baseType, strVal);\r\n      }\r\n      catch (Exception e)\r\n      {\r\n         throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), e);\r\n      }\r\n      return null;\r\n   }", "code_tokens": ["public", "Object", "extractValue", "(", "String", "strVal", ")", "{", "if", "(", "strVal", "==", "null", ")", "{", "if", "(", "defaultValue", "==", "null", ")", "{", "if", "(", "!", "StringToPrimitive", ".", "isPrimitive", "(", "baseType", ")", ")", "return", "null", ";", "else", "return", "StringToPrimitive", ".", "stringToPrimitiveBoxType", "(", "baseType", ",", "strVal", ")", ";", "}", "else", "{", "strVal", "=", "defaultValue", ";", "}", "}", "if", "(", "paramConverter", "!=", "null", ")", "{", "try", "{", "return", "paramConverter", ".", "fromString", "(", "strVal", ")", ";", "}", "catch", "(", "Exception", "pce", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "pce", ")", ";", "}", "}", "if", "(", "unmarshaller", "!=", "null", ")", "{", "try", "{", "return", "unmarshaller", ".", "fromString", "(", "strVal", ")", ";", "}", "catch", "(", "Exception", "ue", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "ue", ")", ";", "}", "}", "else", "if", "(", "delegate", "!=", "null", ")", "{", "try", "{", "return", "delegate", ".", "fromString", "(", "strVal", ")", ";", "}", "catch", "(", "Exception", "pce", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "strVal", ",", "target", ")", ",", "pce", ")", ";", "}", "}", "else", "if", "(", "constructor", "!=", "null", ")", "{", "try", "{", "return", "constructor", ".", "newInstance", "(", "strVal", ")", ";", "}", "catch", "(", "InstantiationException", "e", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "_encode", "(", "strVal", ")", ",", "target", ")", ",", "e", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "_encode", "(", "strVal", ")", ",", "target", ")", ",", "e", ")", ";", "}", "catch", "(", "InvocationTargetException", "e", ")", "{", "Throwable", "targetException", "=", "e", ".", "getTargetException", "(", ")", ";", "if", "(", "targetException", "instanceof", "WebApplicationException", ")", "{", "throw", "(", "(", "WebApplicationException", ")", "targetException", ")", ";", "}", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "_encode", "(", "strVal", ")", ",", "target", ")", ",", "targetException", ")", ";", "}", "}", "else", "if", "(", "valueOf", "!=", "null", ")", "{", "try", "{", "return", "valueOf", ".", "invoke", "(", "null", ",", "strVal", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "_encode", "(", "strVal", ")", ",", "target", ")", ",", "e", ")", ";", "}", "catch", "(", "InvocationTargetException", "e", ")", "{", "Throwable", "targetException", "=", "e", ".", "getTargetException", "(", ")", ";", "if", "(", "targetException", "instanceof", "WebApplicationException", ")", "{", "throw", "(", "(", "WebApplicationException", ")", "targetException", ")", ";", "}", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "_encode", "(", "strVal", ")", ",", "target", ")", ",", "targetException", ")", ";", "}", "}", "try", "{", "if", "(", "StringToPrimitive", ".", "isPrimitive", "(", "baseType", ")", ")", "return", "StringToPrimitive", ".", "stringToPrimitiveBoxType", "(", "baseType", ",", "strVal", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throwProcessingException", "(", "Messages", ".", "MESSAGES", ".", "unableToExtractParameter", "(", "getParamSignature", "(", ")", ",", "_encode", "(", "strVal", ")", ",", "target", ")", ",", "e", ")", ";", "}", "return", "null", ";", "}"], "idx": 79887, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "791e107", "function_name": "extractValue", "body_hash": "2692df6ab6f12ddcac74c6cd3d692a09b467db5a"}
{"code": "@RequestMapping(\"/oauth/token/revoke/client/{clientId}\")\n    public ResponseEntity<Void> revokeTokensForClient(@PathVariable String clientId) {\n        logger.debug(\"Revoking tokens for client: \" + clientId);\n        BaseClientDetails client = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId);\n        client.addAdditionalInformation(ClientConstants.TOKEN_SALT,generator.generate());\n        clientDetailsService.updateClientDetails(client);\n        logger.debug(\"Tokens revoked for client: \" + clientId);\n        return new ResponseEntity<>(OK);\n    }", "code_tokens": ["@", "RequestMapping", "(", "\"", "/oauth/token/revoke/client/{clientId}", "\"", ")", "public", "ResponseEntity", "<", "Void", ">", "revokeTokensForClient", "(", "@", "PathVariable", "String", "clientId", ")", "{", "logger", ".", "debug", "(", "\"", "Revoking tokens for client: ", "\"", "+", "clientId", ")", ";", "BaseClientDetails", "client", "=", "(", "BaseClientDetails", ")", "clientDetailsService", ".", "loadClientByClientId", "(", "clientId", ")", ";", "client", ".", "addAdditionalInformation", "(", "ClientConstants", ".", "TOKEN_SALT", ",", "generator", ".", "generate", "(", ")", ")", ";", "clientDetailsService", ".", "updateClientDetails", "(", "client", ")", ";", "logger", ".", "debug", "(", "\"", "Tokens revoked for client: ", "\"", "+", "clientId", ")", ";", "return", "new", "ResponseEntity", "<", ">", "(", "OK", ")", ";", "}"], "idx": 102685, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "1e2a746968cdac5b53164ca8955646e4257ecc7", "function_name": "revokeTokensForClient", "body_hash": "f1469033b61bd78ecad0088f7e2099cd48489d7c"}
{"code": "protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #\" + i + \": \" + part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #\" + i + \": is mimetype: multipart/*\");\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = FileUtil.stripPath(part.getFileName());\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                        final DataHandler dataHandler = part.getDataHandler();\n                        final DataSource dataSource = dataHandler.getDataSource();\n\n                        final DataHandler replacement = new DataHandler(new DelegatingDataSource(fileName, dataSource));\n                        DefaultAttachment camelAttachment = new DefaultAttachment(replacement);\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "extractAttachmentsFromMultipart", "(", "Multipart", "mp", ",", "Map", "<", "String", ",", "Attachment", ">", "map", ")", "throws", "MessagingException", ",", "IOException", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "mp", ".", "getCount", "(", ")", ";", "i", "++", ")", "{", "Part", "part", "=", "mp", ".", "getBodyPart", "(", "i", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #", "\"", "+", "i", "+", "\"", ": ", "\"", "+", "part", ")", ";", "if", "(", "part", ".", "isMimeType", "(", "\"", "multipart/*", "\"", ")", ")", "{", "LOG", ".", "trace", "(", "\"", "Part #", "\"", "+", "i", "+", "\"", ": is mimetype: multipart/*", "\"", ")", ";", "extractAttachmentsFromMultipart", "(", "(", "Multipart", ")", "part", ".", "getContent", "(", ")", ",", "map", ")", ";", "}", "else", "{", "String", "disposition", "=", "part", ".", "getDisposition", "(", ")", ";", "String", "fileName", "=", "FileUtil", ".", "stripPath", "(", "part", ".", "getFileName", "(", ")", ")", ";", "if", "(", "LOG", ".", "isTraceEnabled", "(", ")", ")", "{", "LOG", ".", "trace", "(", "\"", "Part #{}: Disposition: {}", "\"", ",", "i", ",", "disposition", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: Description: {}", "\"", ",", "i", ",", "part", ".", "getDescription", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: ContentType: {}", "\"", ",", "i", ",", "part", ".", "getContentType", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: FileName: {}", "\"", ",", "i", ",", "fileName", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: Size: {}", "\"", ",", "i", ",", "part", ".", "getSize", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: LineCount: {}", "\"", ",", "i", ",", "part", ".", "getLineCount", "(", ")", ")", ";", "}", "if", "(", "validDisposition", "(", "disposition", ",", "fileName", ")", "||", "fileName", "!=", "null", ")", "{", "LOG", ".", "debug", "(", "\"", "Mail contains file attachment: {}", "\"", ",", "fileName", ")", ";", "if", "(", "!", "map", ".", "containsKey", "(", "fileName", ")", ")", "{", "final", "DataHandler", "dataHandler", "=", "part", ".", "getDataHandler", "(", ")", ";", "final", "DataSource", "dataSource", "=", "dataHandler", ".", "getDataSource", "(", ")", ";", "final", "DataHandler", "replacement", "=", "new", "DataHandler", "(", "new", "DelegatingDataSource", "(", "fileName", ",", "dataSource", ")", ")", ";", "DefaultAttachment", "camelAttachment", "=", "new", "DefaultAttachment", "(", "replacement", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Enumeration", "<", "Header", ">", "headers", "=", "part", ".", "getAllHeaders", "(", ")", ";", "while", "(", "headers", ".", "hasMoreElements", "(", ")", ")", "{", "Header", "header", "=", "headers", ".", "nextElement", "(", ")", ";", "camelAttachment", ".", "addHeader", "(", "header", ".", "getName", "(", ")", ",", "header", ".", "getValue", "(", ")", ")", ";", "}", "map", ".", "put", "(", "fileName", ",", "camelAttachment", ")", ";", "}", "else", "{", "LOG", ".", "warn", "(", "\"", "Cannot extract duplicate file attachment: {}.", "\"", ",", "fileName", ")", ";", "}", "}", "}", "}", "}"], "idx": 21246, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "63c7c080de4d18f9ceb25843508710df2c2c6d4", "function_name": "extractAttachmentsFromMultipart", "body_hash": "ee2826501b5bfd949fec372646b6b0f3d5f5ce28"}
{"code": "public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                //unreg(sk,attachment);//only do this if we do process send file on a separate thread\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n                \n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n            }\n            return true;\n        }", "code_tokens": ["public", "boolean", "processSendfile", "(", "SelectionKey", "sk", ",", "KeyAttachment", "attachment", ",", "boolean", "reg", ",", "boolean", "event", ")", "{", "NioChannel", "sc", "=", "null", ";", "try", "{", "SendfileData", "sd", "=", "attachment", ".", "getSendfileData", "(", ")", ";", "if", "(", "sd", ".", "fchannel", "==", "null", ")", "{", "File", "f", "=", "new", "File", "(", "sd", ".", "fileName", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "sd", ".", "fchannel", "=", "new", "FileInputStream", "(", "f", ")", ".", "getChannel", "(", ")", ";", "}", "sc", "=", "attachment", ".", "getChannel", "(", ")", ";", "sc", ".", "setSendFile", "(", "true", ")", ";", "WritableByteChannel", "wc", "=", "(", "(", "sc", "instanceof", "SecureNioChannel", ")", "?", "sc", ":", "sc", ".", "getIOChannel", "(", ")", ")", ";", "if", "(", "sc", ".", "getOutboundRemaining", "(", ")", ">", "0", ")", "{", "if", "(", "sc", ".", "flushOutbound", "(", ")", ")", "{", "attachment", ".", "access", "(", ")", ";", "}", "}", "else", "{", "long", "written", "=", "sd", ".", "fchannel", ".", "transferTo", "(", "sd", ".", "pos", ",", "sd", ".", "length", ",", "wc", ")", ";", "if", "(", "written", ">", "0", ")", "{", "sd", ".", "pos", "+=", "written", ";", "sd", ".", "length", "-=", "written", ";", "attachment", ".", "access", "(", ")", ";", "}", "}", "if", "(", "sd", ".", "length", "<=", "0", "&&", "sc", ".", "getOutboundRemaining", "(", ")", "<=", "0", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file complete for:", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "attachment", ".", "setSendfileData", "(", "null", ")", ";", "try", "{", "sd", ".", "fchannel", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "}", "if", "(", "sd", ".", "keepAlive", ")", "{", "if", "(", "reg", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection is keep alive, registering back for OP_READ", "\"", ")", ";", "}", "if", "(", "event", ")", "{", "this", ".", "add", "(", "attachment", ".", "getChannel", "(", ")", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "}", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file connection is being closed", "\"", ")", ";", "}", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "STOP", ",", "false", ")", ";", "}", "}", "else", "if", "(", "attachment", ".", "interestOps", "(", ")", "==", "0", "&&", "reg", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "OP_WRITE for sendilfe:", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "event", ")", "{", "add", "(", "attachment", ".", "getChannel", "(", ")", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "}", "}", "catch", "(", "IOException", "x", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Unable to complete sendfile request:", "\"", ",", "x", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"", "\"", ",", "t", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ",", "false", ")", ";", "return", "false", ";", "}", "finally", "{", "if", "(", "sc", "!=", "null", ")", "sc", ".", "setSendFile", "(", "false", ")", ";", "}", "return", "true", ";", "}"], "idx": 9130, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "ff8789737a0a64c12d68929497f16d8021052048", "function_name": "processSendfile", "body_hash": "b0d16032fa24cd2c4d798df523c338c0d3e561e7"}
{"code": "@Override\n  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container = ctx.getContainer();\n    Map<String, String> environment = container.getLaunchContext()\n        .getEnvironment();\n    String imageName = environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    if (imageName == null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr = container.getContainerId().toString();\n    String runAsUser = ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir = ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List<String> -> stored as List -> fetched/converted to List<String>\n    //we can't do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List<String> localDirs = ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> logDirs = ctx.getExecutionAttribute(LOG_DIRS);\n    Set<String> capabilities = new HashSet<>(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand = new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List<String> allDirs = new ArrayList<>(localDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(logDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts = ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    /** Disabling docker's cgroup parent support for the time being. Docker\n     * needs to use a more recent libcontainer that supports net_cls. In\n     * addition we also need to revisit current cgroup creation in YARN.\n     */\n    //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath = ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride = environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride != null && disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List<String> overrideCommands = new ArrayList<>();\n      Path launchDst =\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile = dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp = new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile = ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile != null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "launchContainer", "(", "ContainerRuntimeContext", "ctx", ")", "throws", "ContainerExecutionException", "{", "Container", "container", "=", "ctx", ".", "getContainer", "(", ")", ";", "Map", "<", "String", ",", "String", ">", "environment", "=", "container", ".", "getLaunchContext", "(", ")", ".", "getEnvironment", "(", ")", ";", "String", "imageName", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_IMAGE", ")", ";", "if", "(", "imageName", "==", "null", ")", "{", "throw", "new", "ContainerExecutionException", "(", "ENV_DOCKER_CONTAINER_IMAGE", "+", "\"", " not set!", "\"", ")", ";", "}", "String", "containerIdStr", "=", "container", ".", "getContainerId", "(", ")", ".", "toString", "(", ")", ";", "String", "runAsUser", "=", "ctx", ".", "getExecutionAttribute", "(", "RUN_AS_USER", ")", ";", "Path", "containerWorkDir", "=", "ctx", ".", "getExecutionAttribute", "(", "CONTAINER_WORK_DIR", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "localDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "LOCAL_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "logDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "LOG_DIRS", ")", ";", "Set", "<", "String", ">", "capabilities", "=", "new", "HashSet", "<", ">", "(", "Arrays", ".", "asList", "(", "conf", ".", "getStrings", "(", "YarnConfiguration", ".", "NM_DOCKER_CONTAINER_CAPABILITIES", ",", "YarnConfiguration", ".", "DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES", ")", ")", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "DockerRunCommand", "runCommand", "=", "new", "DockerRunCommand", "(", "containerIdStr", ",", "runAsUser", ",", "imageName", ")", ".", "detachOnRun", "(", ")", ".", "setContainerWorkDir", "(", "containerWorkDir", ".", "toString", "(", ")", ")", ".", "setNetworkType", "(", "\"", "host", "\"", ")", ".", "setCapabilities", "(", "capabilities", ")", ".", "addMountLocation", "(", "\"", "/etc/passwd", "\"", ",", "\"", "/etc/password:ro", "\"", ")", ";", "List", "<", "String", ">", "allDirs", "=", "new", "ArrayList", "<", ">", "(", "localDirs", ")", ";", "allDirs", ".", "add", "(", "containerWorkDir", ".", "toString", "(", ")", ")", ";", "allDirs", ".", "addAll", "(", "logDirs", ")", ";", "for", "(", "String", "dir", ":", "allDirs", ")", "{", "runCommand", ".", "addMountLocation", "(", "dir", ",", "dir", ")", ";", "}", "if", "(", "allowPrivilegedContainerExecution", "(", "container", ")", ")", "{", "runCommand", ".", "setPrivileged", "(", ")", ";", "}", "String", "resourcesOpts", "=", "ctx", ".", "getExecutionAttribute", "(", "RESOURCES_OPTIONS", ")", ";", "Path", "nmPrivateContainerScriptPath", "=", "ctx", ".", "getExecutionAttribute", "(", "NM_PRIVATE_CONTAINER_SCRIPT_PATH", ")", ";", "String", "disableOverride", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE", ")", ";", "if", "(", "disableOverride", "!=", "null", "&&", "disableOverride", ".", "equals", "(", "\"", "true", "\"", ")", ")", "{", "if", "(", "LOG", ".", "isInfoEnabled", "(", ")", ")", "{", "LOG", ".", "info", "(", "\"", "command override disabled", "\"", ")", ";", "}", "}", "else", "{", "List", "<", "String", ">", "overrideCommands", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Path", "launchDst", "=", "new", "Path", "(", "containerWorkDir", ",", "ContainerLaunch", ".", "CONTAINER_SCRIPT", ")", ";", "overrideCommands", ".", "add", "(", "\"", "bash", "\"", ")", ";", "overrideCommands", ".", "add", "(", "launchDst", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ")", ";", "runCommand", ".", "setOverrideCommandWithArgs", "(", "overrideCommands", ")", ";", "}", "String", "commandFile", "=", "dockerClient", ".", "writeCommandToTempFile", "(", "runCommand", ",", "containerIdStr", ")", ";", "PrivilegedOperation", "launchOp", "=", "new", "PrivilegedOperation", "(", "PrivilegedOperation", ".", "OperationType", ".", "LAUNCH_DOCKER_CONTAINER", ")", ";", "launchOp", ".", "appendArgs", "(", "runAsUser", ",", "ctx", ".", "getExecutionAttribute", "(", "USER", ")", ",", "Integer", ".", "toString", "(", "PrivilegedOperation", ".", "RunAsUserCommand", ".", "LAUNCH_DOCKER_CONTAINER", ".", "getValue", "(", ")", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "APPID", ")", ",", "containerIdStr", ",", "containerWorkDir", ".", "toString", "(", ")", ",", "nmPrivateContainerScriptPath", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "NM_PRIVATE_TOKENS_PATH", ")", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "PID_FILE_PATH", ")", ".", "toString", "(", ")", ",", "StringUtils", ".", "join", "(", "PrivilegedOperation", ".", "LINUX_FILE_PATH_SEPARATOR", ",", "localDirs", ")", ",", "StringUtils", ".", "join", "(", "PrivilegedOperation", ".", "LINUX_FILE_PATH_SEPARATOR", ",", "logDirs", ")", ",", "commandFile", ",", "resourcesOpts", ")", ";", "String", "tcCommandFile", "=", "ctx", ".", "getExecutionAttribute", "(", "TC_COMMAND_FILE", ")", ";", "if", "(", "tcCommandFile", "!=", "null", ")", "{", "launchOp", ".", "appendArgs", "(", "tcCommandFile", ")", ";", "}", "try", "{", "privilegedOperationExecutor", ".", "executePrivilegedOperation", "(", "null", ",", "launchOp", ",", "null", ",", "container", ".", "getLaunchContext", "(", ")", ".", "getEnvironment", "(", ")", ",", "false", ",", "false", ")", ";", "}", "catch", "(", "PrivilegedOperationException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Launch container failed. Exception: ", "\"", ",", "e", ")", ";", "throw", "new", "ContainerExecutionException", "(", "\"", "Launch container failed", "\"", ",", "e", ".", "getExitCode", "(", ")", ",", "e", ".", "getOutput", "(", ")", ",", "e", ".", "getErrorOutput", "(", ")", ")", ";", "}", "}"], "idx": 7755, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "bbe3b0857d383c5e4dc4a7ade90a88a3e24338b", "function_name": "launchContainer", "body_hash": "28ced92f563d2e51ac7278ba634deea639253f33"}
{"code": "@Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (StringUtils.isNotEmpty(url)) {\n            // Percent-encode characters that are not allowed in unquoted\n            // HTML attributes: \", ', >, <, ` and space. We don't encode =\n            // since this would break links with query parameters.\n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        }\n        // fall through to empty string\n        return \"\";\n    }", "code_tokens": ["@", "Override", "@", "Nonnull", "public", "String", "getValidHref", "(", "final", "String", "url", ")", "{", "if", "(", "StringUtils", ".", "isNotEmpty", "(", "url", ")", ")", "{", "String", "encodedUrl", "=", "url", ".", "replaceAll", "(", "\"", "\\\"", "\"", ",", "\"", "%22", "\"", ")", ".", "replaceAll", "(", "\"", "'", "\"", ",", "\"", "%27", "\"", ")", ".", "replaceAll", "(", "\"", ">", "\"", ",", "\"", "%3E", "\"", ")", ".", "replaceAll", "(", "\"", "<", "\"", ",", "\"", "%3C", "\"", ")", ".", "replaceAll", "(", "\"", "`", "\"", ",", "\"", "%60", "\"", ")", ".", "replaceAll", "(", "\"", " ", "\"", ",", "\"", "%20", "\"", ")", ";", "int", "qMarkIx", "=", "encodedUrl", ".", "indexOf", "(", "'?'", ")", ";", "if", "(", "qMarkIx", ">", "0", ")", "{", "encodedUrl", "=", "encodedUrl", ".", "substring", "(", "0", ",", "qMarkIx", ")", "+", "encodedUrl", ".", "substring", "(", "qMarkIx", ")", ".", "replaceAll", "(", "\"", ":", "\"", ",", "\"", "%3A", "\"", ")", ";", "}", "encodedUrl", "=", "mangleNamespaces", "(", "encodedUrl", ")", ";", "if", "(", "xssFilter", ".", "isValidHref", "(", "encodedUrl", ")", ")", "{", "return", "encodedUrl", ";", "}", "}", "return", "\"", "\"", ";", "}"], "idx": 80969, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "ec6764d165abc4df8cffd8439761bb2228887db9", "function_name": "getValidHref", "body_hash": "c0b2cb92f1859b9f8557f98dd0caf89f09e2d99a"}
{"code": "@RequirePOST\n    public void doDisable(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        disable(true);\n        rsp.sendRedirect2(req.getContextPath()+\"/manage\");\n    }", "code_tokens": ["@", "RequirePOST", "public", "void", "doDisable", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", "{", "disable", "(", "true", ")", ";", "rsp", ".", "sendRedirect2", "(", "req", ".", "getContextPath", "(", ")", "+", "\"", "/manage", "\"", ")", ";", "}"], "idx": 38604, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "6efcf6c2ac39bc5c59ac7251822be8ddf67ceaf8", "function_name": "doDisable", "body_hash": "2c7ae8fb06be1fb7058b6e9b7d7a496bf5e4a40d"}
{"code": "private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n\n        if (!contentLengthFields.isEmpty()) {\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            //\n            // If a message is received that has multiple Content-Length header\n            //   fields with field-values consisting of the same decimal value, or a\n            //   single Content-Length header field with a field value containing a\n            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n            //   indicating that duplicate Content-Length header fields have been\n            //   generated or combined by an upstream message processor, then the\n            //   recipient MUST either reject the message as invalid or replace the\n            //   duplicated field-values with a single valid Content-Length field\n            //   containing that decimal value prior to determining the message body\n            //   length or forwarding the message.\n            boolean multipleContentLengths =\n                    contentLengthFields.size() > 1 || contentLengthFields.get(0).indexOf(COMMA) >= 0;\n            if (multipleContentLengths && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                if (allowDuplicateContentLengths) {\n                    // Find and enforce that all Content-Length values are the same\n                    String firstValue = null;\n                    for (String field : contentLengthFields) {\n                        String[] tokens = COMMA_PATTERN.split(field, -1);\n                        for (String token : tokens) {\n                            String trimmed = token.trim();\n                            if (firstValue == null) {\n                                firstValue = trimmed;\n                            } else if (!trimmed.equals(firstValue)) {\n                                throw new IllegalArgumentException(\n                                        \"Multiple Content-Length values found: \" + contentLengthFields);\n                            }\n                        }\n                    }\n                    // Replace the duplicated field-values with a single valid Content-Length field\n                    headers.set(HttpHeaderNames.CONTENT_LENGTH, firstValue);\n                    contentLength = Long.parseLong(firstValue);\n                } else {\n                    // Reject the message as invalid\n                    throw new IllegalArgumentException(\n                            \"Multiple Content-Length values found: \" + contentLengthFields);\n                }\n            } else {\n                contentLength = Long.parseLong(contentLengthFields.get(0));\n            }\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }", "code_tokens": ["private", "State", "readHeaders", "(", "ByteBuf", "buffer", ")", "{", "final", "HttpMessage", "message", "=", "this", ".", "message", ";", "final", "HttpHeaders", "headers", "=", "message", ".", "headers", "(", ")", ";", "AppendableCharSequence", "line", "=", "headerParser", ".", "parse", "(", "buffer", ")", ";", "if", "(", "line", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "line", ".", "length", "(", ")", ">", "0", ")", "{", "do", "{", "char", "firstChar", "=", "line", ".", "charAtUnsafe", "(", "0", ")", ";", "if", "(", "name", "!=", "null", "&&", "(", "firstChar", "==", "' '", "||", "firstChar", "==", "'\\t'", ")", ")", "{", "String", "trimmedLine", "=", "line", ".", "toString", "(", ")", ".", "trim", "(", ")", ";", "String", "valueStr", "=", "String", ".", "valueOf", "(", "value", ")", ";", "value", "=", "valueStr", "+", "' '", "+", "trimmedLine", ";", "}", "else", "{", "if", "(", "name", "!=", "null", ")", "{", "headers", ".", "add", "(", "name", ",", "value", ")", ";", "}", "splitHeader", "(", "line", ")", ";", "}", "line", "=", "headerParser", ".", "parse", "(", "buffer", ")", ";", "if", "(", "line", "==", "null", ")", "{", "return", "null", ";", "}", "}", "while", "(", "line", ".", "length", "(", ")", ">", "0", ")", ";", "}", "if", "(", "name", "!=", "null", ")", "{", "headers", ".", "add", "(", "name", ",", "value", ")", ";", "}", "name", "=", "null", ";", "value", "=", "null", ";", "List", "<", "String", ">", "contentLengthFields", "=", "headers", ".", "getAll", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ")", ";", "if", "(", "!", "contentLengthFields", ".", "isEmpty", "(", ")", ")", "{", "boolean", "multipleContentLengths", "=", "contentLengthFields", ".", "size", "(", ")", ">", "1", "||", "contentLengthFields", ".", "get", "(", "0", ")", ".", "indexOf", "(", "COMMA", ")", ">=", "0", ";", "if", "(", "multipleContentLengths", "&&", "message", ".", "protocolVersion", "(", ")", "==", "HttpVersion", ".", "HTTP_1_1", ")", "{", "if", "(", "allowDuplicateContentLengths", ")", "{", "String", "firstValue", "=", "null", ";", "for", "(", "String", "field", ":", "contentLengthFields", ")", "{", "String", "[", "]", "tokens", "=", "COMMA_PATTERN", ".", "split", "(", "field", ",", "-", "1", ")", ";", "for", "(", "String", "token", ":", "tokens", ")", "{", "String", "trimmed", "=", "token", ".", "trim", "(", ")", ";", "if", "(", "firstValue", "==", "null", ")", "{", "firstValue", "=", "trimmed", ";", "}", "else", "if", "(", "!", "trimmed", ".", "equals", "(", "firstValue", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Multiple Content-Length values found: ", "\"", "+", "contentLengthFields", ")", ";", "}", "}", "}", "headers", ".", "set", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ",", "firstValue", ")", ";", "contentLength", "=", "Long", ".", "parseLong", "(", "firstValue", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Multiple Content-Length values found: ", "\"", "+", "contentLengthFields", ")", ";", "}", "}", "else", "{", "contentLength", "=", "Long", ".", "parseLong", "(", "contentLengthFields", ".", "get", "(", "0", ")", ")", ";", "}", "}", "if", "(", "isContentAlwaysEmpty", "(", "message", ")", ")", "{", "HttpUtil", ".", "setTransferEncodingChunked", "(", "message", ",", "false", ")", ";", "return", "State", ".", "SKIP_CONTROL_CHARS", ";", "}", "else", "if", "(", "HttpUtil", ".", "isTransferEncodingChunked", "(", "message", ")", ")", "{", "if", "(", "!", "contentLengthFields", ".", "isEmpty", "(", ")", "&&", "message", ".", "protocolVersion", "(", ")", "==", "HttpVersion", ".", "HTTP_1_1", ")", "{", "handleTransferEncodingChunkedWithContentLength", "(", "message", ")", ";", "}", "return", "State", ".", "READ_CHUNK_SIZE", ";", "}", "else", "if", "(", "contentLength", "(", ")", ">=", "0", ")", "{", "return", "State", ".", "READ_FIXED_LENGTH_CONTENT", ";", "}", "else", "{", "return", "State", ".", "READ_VARIABLE_LENGTH_CONTENT", ";", "}", "}"], "idx": 53996, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "89c241e3b1795ff257af4ad6eadc616cb2fb3dc4", "function_name": "readHeaders", "body_hash": "24904494eb3564ae634bdf3a250857c8742a4433"}
{"code": "@Override\n    public Element handle(Element request, Map<String, Object> context) throws ServiceException {\n        ZimbraSoapContext zsc = getZimbraSoapContext(context);\n        Account account = getRequestedAccount(getZimbraSoapContext(context));\n\n        if (!canAccessAccount(zsc, account))\n            throw ServiceException.PERM_DENIED(\"can not access account\");\n        \n        String name = request.getAttribute(AccountConstants.E_NAME);\n        String typeStr = request.getAttribute(AccountConstants.A_TYPE, \"account\");\n        GalSearchType type = GalSearchType.fromString(typeStr);\n\n        boolean needCanExpand = request.getAttributeBool(AccountConstants.A_NEED_EXP, false);\n\n        String galAcctId = request.getAttribute(AccountConstants.A_GAL_ACCOUNT_ID, null);\n        \n        GalSearchParams params = new GalSearchParams(account, zsc);\n        params.setType(type);\n        params.setRequest(request);\n        params.setQuery(name);\n        params.setLimit(account.getContactAutoCompleteMaxResults());\n        params.setNeedCanExpand(needCanExpand);\n        params.setResponseName(AccountConstants.AUTO_COMPLETE_GAL_RESPONSE);\n        if (galAcctId != null)\n            params.setGalSyncAccount(Provisioning.getInstance().getAccountById(galAcctId));\n        GalSearchControl gal = new GalSearchControl(params);\n        gal.autocomplete();\n        return params.getResultCallback().getResponse();\n    }", "code_tokens": ["@", "Override", "public", "Element", "handle", "(", "Element", "request", ",", "Map", "<", "String", ",", "Object", ">", "context", ")", "throws", "ServiceException", "{", "ZimbraSoapContext", "zsc", "=", "getZimbraSoapContext", "(", "context", ")", ";", "Account", "account", "=", "getRequestedAccount", "(", "getZimbraSoapContext", "(", "context", ")", ")", ";", "if", "(", "!", "canAccessAccount", "(", "zsc", ",", "account", ")", ")", "throw", "ServiceException", ".", "PERM_DENIED", "(", "\"", "can not access account", "\"", ")", ";", "String", "name", "=", "request", ".", "getAttribute", "(", "AccountConstants", ".", "E_NAME", ")", ";", "String", "typeStr", "=", "request", ".", "getAttribute", "(", "AccountConstants", ".", "A_TYPE", ",", "\"", "account", "\"", ")", ";", "GalSearchType", "type", "=", "GalSearchType", ".", "fromString", "(", "typeStr", ")", ";", "boolean", "needCanExpand", "=", "request", ".", "getAttributeBool", "(", "AccountConstants", ".", "A_NEED_EXP", ",", "false", ")", ";", "String", "galAcctId", "=", "request", ".", "getAttribute", "(", "AccountConstants", ".", "A_GAL_ACCOUNT_ID", ",", "null", ")", ";", "GalSearchParams", "params", "=", "new", "GalSearchParams", "(", "account", ",", "zsc", ")", ";", "params", ".", "setType", "(", "type", ")", ";", "params", ".", "setRequest", "(", "request", ")", ";", "params", ".", "setQuery", "(", "name", ")", ";", "params", ".", "setLimit", "(", "account", ".", "getContactAutoCompleteMaxResults", "(", ")", ")", ";", "params", ".", "setNeedCanExpand", "(", "needCanExpand", ")", ";", "params", ".", "setResponseName", "(", "AccountConstants", ".", "AUTO_COMPLETE_GAL_RESPONSE", ")", ";", "if", "(", "galAcctId", "!=", "null", ")", "params", ".", "setGalSyncAccount", "(", "Provisioning", ".", "getInstance", "(", ")", ".", "getAccountById", "(", "galAcctId", ")", ")", ";", "GalSearchControl", "gal", "=", "new", "GalSearchControl", "(", "params", ")", ";", "gal", ".", "autocomplete", "(", ")", ";", "return", "params", ".", "getResultCallback", "(", ")", ".", "getResponse", "(", ")", ";", "}"], "idx": 85457, "cwe": "CWE-862", "target": 1, "status": "VULNERABLE", "commit": "1df440e0efa624d1772a05fb6d397d9beb4bda1e", "function_name": "handle", "body_hash": "49ea495d7bb3528ec9141f32a27a99e0dac0790c"}
{"code": "public static void load(String originalName, ClassLoader loader) {\n        // Adjust expected name to support shading of native libraries.\n        String packagePrefix = calculatePackagePrefix().replace('.', '_');\n        String name = packagePrefix + originalName;\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        try {\n            // first try to load from java.library.path\n            loadLibrary(loader, name, false);\n            return;\n        } catch (Throwable ex) {\n            suppressed.add(ex);\n        }\n\n        String libname = System.mapLibraryName(name);\n        String path = NATIVE_RESOURCE_HOME + libname;\n\n        InputStream in = null;\n        OutputStream out = null;\n        File tmpFile = null;\n        URL url;\n        if (loader == null) {\n            url = ClassLoader.getSystemResource(path);\n        } else {\n            url = loader.getResource(path);\n        }\n        try {\n            if (url == null) {\n                if (PlatformDependent.isOsx()) {\n                    String fileName = path.endsWith(\".jnilib\") ? NATIVE_RESOURCE_HOME + \"lib\" + name + \".dynlib\" :\n                            NATIVE_RESOURCE_HOME + \"lib\" + name + \".jnilib\";\n                    if (loader == null) {\n                        url = ClassLoader.getSystemResource(fileName);\n                    } else {\n                        url = loader.getResource(fileName);\n                    }\n                    if (url == null) {\n                        FileNotFoundException fnf = new FileNotFoundException(fileName);\n                        ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                        throw fnf;\n                    }\n                } else {\n                    FileNotFoundException fnf = new FileNotFoundException(path);\n                    ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                    throw fnf;\n                }\n            }\n\n            int index = libname.lastIndexOf('.');\n            String prefix = libname.substring(0, index);\n            String suffix = libname.substring(index);\n\n            tmpFile = File.createTempFile(prefix, suffix, WORKDIR);\n            in = url.openStream();\n            out = new FileOutputStream(tmpFile);\n\n            if (shouldShadedLibraryIdBePatched(packagePrefix)) {\n                patchShadedLibraryId(in, out, originalName, name);\n            } else {\n                byte[] buffer = new byte[8192];\n                int length;\n                while ((length = in.read(buffer)) > 0) {\n                    out.write(buffer, 0, length);\n                }\n            }\n\n            out.flush();\n\n            // Close the output stream before loading the unpacked library,\n            // because otherwise Windows will refuse to load it when it's in use by other process.\n            closeQuietly(out);\n            out = null;\n            loadLibrary(loader, tmpFile.getPath(), true);\n        } catch (UnsatisfiedLinkError e) {\n            try {\n                if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&\n                    !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {\n                    // Pass \"io.netty.native.workdir\" as an argument to allow shading tools to see\n                    // the string. Since this is printed out to users to tell them what to do next,\n                    // we want the value to be correct even when shading.\n                    logger.info(\"{} exists but cannot be executed even when execute permissions set; \" +\n                                \"check volume for \\\"noexec\\\" flag; use -D{}=[path] \" +\n                                \"to set native working directory separately.\",\n                                tmpFile.getPath(), \"io.netty.native.workdir\");\n                }\n            } catch (Throwable t) {\n                suppressed.add(t);\n                logger.debug(\"Error checking if {} is on a file store mounted with noexec\", tmpFile, t);\n            }\n            // Re-throw to fail the load\n            ThrowableUtil.addSuppressedAndClear(e, suppressed);\n            throw e;\n        } catch (Exception e) {\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(\"could not load a native library: \" + name);\n            ule.initCause(e);\n            ThrowableUtil.addSuppressedAndClear(ule, suppressed);\n            throw ule;\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n            // After we load the library it is safe to delete the file.\n            // We delete the file immediately to free up resources as soon as possible,\n            // and if this fails fallback to deleting on JVM exit.\n            if (tmpFile != null && (!DELETE_NATIVE_LIB_AFTER_LOADING || !tmpFile.delete())) {\n                tmpFile.deleteOnExit();\n            }\n        }\n    }", "code_tokens": ["public", "static", "void", "load", "(", "String", "originalName", ",", "ClassLoader", "loader", ")", "{", "String", "packagePrefix", "=", "calculatePackagePrefix", "(", ")", ".", "replace", "(", "'.'", ",", "'_'", ")", ";", "String", "name", "=", "packagePrefix", "+", "originalName", ";", "List", "<", "Throwable", ">", "suppressed", "=", "new", "ArrayList", "<", "Throwable", ">", "(", ")", ";", "try", "{", "loadLibrary", "(", "loader", ",", "name", ",", "false", ")", ";", "return", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "suppressed", ".", "add", "(", "ex", ")", ";", "}", "String", "libname", "=", "System", ".", "mapLibraryName", "(", "name", ")", ";", "String", "path", "=", "NATIVE_RESOURCE_HOME", "+", "libname", ";", "InputStream", "in", "=", "null", ";", "OutputStream", "out", "=", "null", ";", "File", "tmpFile", "=", "null", ";", "URL", "url", ";", "if", "(", "loader", "==", "null", ")", "{", "url", "=", "ClassLoader", ".", "getSystemResource", "(", "path", ")", ";", "}", "else", "{", "url", "=", "loader", ".", "getResource", "(", "path", ")", ";", "}", "try", "{", "if", "(", "url", "==", "null", ")", "{", "if", "(", "PlatformDependent", ".", "isOsx", "(", ")", ")", "{", "String", "fileName", "=", "path", ".", "endsWith", "(", "\"", ".jnilib", "\"", ")", "?", "NATIVE_RESOURCE_HOME", "+", "\"", "lib", "\"", "+", "name", "+", "\"", ".dynlib", "\"", ":", "NATIVE_RESOURCE_HOME", "+", "\"", "lib", "\"", "+", "name", "+", "\"", ".jnilib", "\"", ";", "if", "(", "loader", "==", "null", ")", "{", "url", "=", "ClassLoader", ".", "getSystemResource", "(", "fileName", ")", ";", "}", "else", "{", "url", "=", "loader", ".", "getResource", "(", "fileName", ")", ";", "}", "if", "(", "url", "==", "null", ")", "{", "FileNotFoundException", "fnf", "=", "new", "FileNotFoundException", "(", "fileName", ")", ";", "ThrowableUtil", ".", "addSuppressedAndClear", "(", "fnf", ",", "suppressed", ")", ";", "throw", "fnf", ";", "}", "}", "else", "{", "FileNotFoundException", "fnf", "=", "new", "FileNotFoundException", "(", "path", ")", ";", "ThrowableUtil", ".", "addSuppressedAndClear", "(", "fnf", ",", "suppressed", ")", ";", "throw", "fnf", ";", "}", "}", "int", "index", "=", "libname", ".", "lastIndexOf", "(", "'.'", ")", ";", "String", "prefix", "=", "libname", ".", "substring", "(", "0", ",", "index", ")", ";", "String", "suffix", "=", "libname", ".", "substring", "(", "index", ")", ";", "tmpFile", "=", "File", ".", "createTempFile", "(", "prefix", ",", "suffix", ",", "WORKDIR", ")", ";", "in", "=", "url", ".", "openStream", "(", ")", ";", "out", "=", "new", "FileOutputStream", "(", "tmpFile", ")", ";", "if", "(", "shouldShadedLibraryIdBePatched", "(", "packagePrefix", ")", ")", "{", "patchShadedLibraryId", "(", "in", ",", "out", ",", "originalName", ",", "name", ")", ";", "}", "else", "{", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "8192", "]", ";", "int", "length", ";", "while", "(", "(", "length", "=", "in", ".", "read", "(", "buffer", ")", ")", ">", "0", ")", "{", "out", ".", "write", "(", "buffer", ",", "0", ",", "length", ")", ";", "}", "}", "out", ".", "flush", "(", ")", ";", "closeQuietly", "(", "out", ")", ";", "out", "=", "null", ";", "loadLibrary", "(", "loader", ",", "tmpFile", ".", "getPath", "(", ")", ",", "true", ")", ";", "}", "catch", "(", "UnsatisfiedLinkError", "e", ")", "{", "try", "{", "if", "(", "tmpFile", "!=", "null", "&&", "tmpFile", ".", "isFile", "(", ")", "&&", "tmpFile", ".", "canRead", "(", ")", "&&", "!", "NoexecVolumeDetector", ".", "canExecuteExecutable", "(", "tmpFile", ")", ")", "{", "logger", ".", "info", "(", "\"", "{} exists but cannot be executed even when execute permissions set; ", "\"", "+", "\"", "check volume for ", "\\\"", "noexec", "\\\"", " flag; use -D{}=[path] ", "\"", "+", "\"", "to set native working directory separately.", "\"", ",", "tmpFile", ".", "getPath", "(", ")", ",", "\"", "io.netty.native.workdir", "\"", ")", ";", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "suppressed", ".", "add", "(", "t", ")", ";", "logger", ".", "debug", "(", "\"", "Error checking if {} is on a file store mounted with noexec", "\"", ",", "tmpFile", ",", "t", ")", ";", "}", "ThrowableUtil", ".", "addSuppressedAndClear", "(", "e", ",", "suppressed", ")", ";", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "UnsatisfiedLinkError", "ule", "=", "new", "UnsatisfiedLinkError", "(", "\"", "could not load a native library: ", "\"", "+", "name", ")", ";", "ule", ".", "initCause", "(", "e", ")", ";", "ThrowableUtil", ".", "addSuppressedAndClear", "(", "ule", ",", "suppressed", ")", ";", "throw", "ule", ";", "}", "finally", "{", "closeQuietly", "(", "in", ")", ";", "closeQuietly", "(", "out", ")", ";", "if", "(", "tmpFile", "!=", "null", "&&", "(", "!", "DELETE_NATIVE_LIB_AFTER_LOADING", "||", "!", "tmpFile", ".", "delete", "(", ")", ")", ")", "{", "tmpFile", ".", "deleteOnExit", "(", ")", ";", "}", "}", "}"], "idx": 49835, "cwe": "CWE-378", "target": 1, "status": "VULNERABLE", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "load", "body_hash": "0c4ffe6380b37f9fe31831984dadeea232cffec4"}
{"code": "public static void unzipFileTo(String file, String dest) throws IOException {\n        File target = new File(file);\n        if (!target.exists())\n            throw new IllegalArgumentException(\"Archive doesnt exist\");\n        FileInputStream fin = new FileInputStream(target);\n        int BUFFER = 2048;\n        byte data[] = new byte[BUFFER];\n\n        if (file.endsWith(\".zip\") || file.endsWith(\".jar\")) {\n            try(ZipInputStream zis = new ZipInputStream(fin)) {\n                //get the zipped file list entry\n                ZipEntry ze = zis.getNextEntry();\n\n                while (ze != null) {\n                    String fileName = ze.getName();\n\n                    String canonicalDestinationDirPath = new File(dest).getCanonicalPath();\n                    File newFile = new File(dest + File.separator + fileName);\n                    String canonicalDestinationFile = newFile.getCanonicalPath();\n\n                    if (!canonicalDestinationFile.startsWith(canonicalDestinationDirPath + File.separator)) {\n                        log.debug(\"Attempt to unzip entry is outside of the target dir\");\n                        throw new IOException(\"Entry is outside of the target dir: \");\n                    }\n\n                    if (ze.isDirectory()) {\n                        newFile.mkdirs();\n                        zis.closeEntry();\n                        ze = zis.getNextEntry();\n                        continue;\n                    }\n\n                    FileOutputStream fos = new FileOutputStream(newFile);\n\n                    int len;\n                    while ((len = zis.read(data)) > 0) {\n                        fos.write(data, 0, len);\n                    }\n\n                    fos.close();\n                    ze = zis.getNextEntry();\n                    log.debug(\"File extracted: \" + newFile.getAbsoluteFile());\n                }\n\n                zis.closeEntry();\n            }\n        } else if (file.endsWith(\".tar.gz\") || file.endsWith(\".tgz\")) {\n\n            BufferedInputStream in = new BufferedInputStream(fin);\n            GzipCompressorInputStream gzIn = new GzipCompressorInputStream(in);\n            TarArchiveInputStream tarIn = new TarArchiveInputStream(gzIn);\n\n            TarArchiveEntry entry;\n            /* Read the tar entries using the getNextEntry method **/\n            while ((entry = (TarArchiveEntry) tarIn.getNextEntry()) != null) {\n                log.info(\"Extracting: \" + entry.getName());\n                /* If the entry is a directory, create the directory. */\n\n                if (entry.isDirectory()) {\n                    File f = new File(dest + File.separator + entry.getName());\n                    f.mkdirs();\n                }\n                /*\n                 * If the entry is a file,write the decompressed file to the disk\n                 * and close destination stream.\n                 */\n                else {\n                    int count;\n                    try(FileOutputStream fos = new FileOutputStream(dest + File.separator + entry.getName());\n                        BufferedOutputStream destStream = new BufferedOutputStream(fos, BUFFER);) {\n                        while ((count = tarIn.read(data, 0, BUFFER)) != -1) {\n                            destStream.write(data, 0, count);\n                        }\n\n                        destStream.flush();\n                        IOUtils.closeQuietly(destStream);\n                    }\n                }\n            }\n\n            // Close the input stream\n            tarIn.close();\n        } else if (file.endsWith(\".gz\")) {\n            File extracted = new File(target.getParent(), target.getName().replace(\".gz\", \"\"));\n            if (extracted.exists())\n                extracted.delete();\n            extracted.createNewFile();\n            try(GZIPInputStream is2 = new GZIPInputStream(fin); OutputStream fos = FileUtils.openOutputStream(extracted)) {\n                IOUtils.copyLarge(is2, fos);\n                fos.flush();\n            }\n        } else {\n            throw new IllegalStateException(\"Unable to infer file type (compression format) from source file name: \" +\n                    file);\n        }\n        target.delete();\n    }", "code_tokens": ["public", "static", "void", "unzipFileTo", "(", "String", "file", ",", "String", "dest", ")", "throws", "IOException", "{", "File", "target", "=", "new", "File", "(", "file", ")", ";", "if", "(", "!", "target", ".", "exists", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"", "Archive doesnt exist", "\"", ")", ";", "FileInputStream", "fin", "=", "new", "FileInputStream", "(", "target", ")", ";", "int", "BUFFER", "=", "2048", ";", "byte", "data", "[", "]", "=", "new", "byte", "[", "BUFFER", "]", ";", "if", "(", "file", ".", "endsWith", "(", "\"", ".zip", "\"", ")", "||", "file", ".", "endsWith", "(", "\"", ".jar", "\"", ")", ")", "{", "try", "(", "ZipInputStream", "zis", "=", "new", "ZipInputStream", "(", "fin", ")", ")", "{", "ZipEntry", "ze", "=", "zis", ".", "getNextEntry", "(", ")", ";", "while", "(", "ze", "!=", "null", ")", "{", "String", "fileName", "=", "ze", ".", "getName", "(", ")", ";", "String", "canonicalDestinationDirPath", "=", "new", "File", "(", "dest", ")", ".", "getCanonicalPath", "(", ")", ";", "File", "newFile", "=", "new", "File", "(", "dest", "+", "File", ".", "separator", "+", "fileName", ")", ";", "String", "canonicalDestinationFile", "=", "newFile", ".", "getCanonicalPath", "(", ")", ";", "if", "(", "!", "canonicalDestinationFile", ".", "startsWith", "(", "canonicalDestinationDirPath", "+", "File", ".", "separator", ")", ")", "{", "log", ".", "debug", "(", "\"", "Attempt to unzip entry is outside of the target dir", "\"", ")", ";", "throw", "new", "IOException", "(", "\"", "Entry is outside of the target dir: ", "\"", ")", ";", "}", "if", "(", "ze", ".", "isDirectory", "(", ")", ")", "{", "newFile", ".", "mkdirs", "(", ")", ";", "zis", ".", "closeEntry", "(", ")", ";", "ze", "=", "zis", ".", "getNextEntry", "(", ")", ";", "continue", ";", "}", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "newFile", ")", ";", "int", "len", ";", "while", "(", "(", "len", "=", "zis", ".", "read", "(", "data", ")", ")", ">", "0", ")", "{", "fos", ".", "write", "(", "data", ",", "0", ",", "len", ")", ";", "}", "fos", ".", "close", "(", ")", ";", "ze", "=", "zis", ".", "getNextEntry", "(", ")", ";", "log", ".", "debug", "(", "\"", "File extracted: ", "\"", "+", "newFile", ".", "getAbsoluteFile", "(", ")", ")", ";", "}", "zis", ".", "closeEntry", "(", ")", ";", "}", "}", "else", "if", "(", "file", ".", "endsWith", "(", "\"", ".tar.gz", "\"", ")", "||", "file", ".", "endsWith", "(", "\"", ".tgz", "\"", ")", ")", "{", "BufferedInputStream", "in", "=", "new", "BufferedInputStream", "(", "fin", ")", ";", "GzipCompressorInputStream", "gzIn", "=", "new", "GzipCompressorInputStream", "(", "in", ")", ";", "TarArchiveInputStream", "tarIn", "=", "new", "TarArchiveInputStream", "(", "gzIn", ")", ";", "TarArchiveEntry", "entry", ";", "while", "(", "(", "entry", "=", "(", "TarArchiveEntry", ")", "tarIn", ".", "getNextEntry", "(", ")", ")", "!=", "null", ")", "{", "log", ".", "info", "(", "\"", "Extracting: ", "\"", "+", "entry", ".", "getName", "(", ")", ")", ";", "if", "(", "entry", ".", "isDirectory", "(", ")", ")", "{", "File", "f", "=", "new", "File", "(", "dest", "+", "File", ".", "separator", "+", "entry", ".", "getName", "(", ")", ")", ";", "f", ".", "mkdirs", "(", ")", ";", "}", "else", "{", "int", "count", ";", "try", "(", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "dest", "+", "File", ".", "separator", "+", "entry", ".", "getName", "(", ")", ")", ";", "BufferedOutputStream", "destStream", "=", "new", "BufferedOutputStream", "(", "fos", ",", "BUFFER", ")", ";", ")", "{", "while", "(", "(", "count", "=", "tarIn", ".", "read", "(", "data", ",", "0", ",", "BUFFER", ")", ")", "!=", "-", "1", ")", "{", "destStream", ".", "write", "(", "data", ",", "0", ",", "count", ")", ";", "}", "destStream", ".", "flush", "(", ")", ";", "IOUtils", ".", "closeQuietly", "(", "destStream", ")", ";", "}", "}", "}", "tarIn", ".", "close", "(", ")", ";", "}", "else", "if", "(", "file", ".", "endsWith", "(", "\"", ".gz", "\"", ")", ")", "{", "File", "extracted", "=", "new", "File", "(", "target", ".", "getParent", "(", ")", ",", "target", ".", "getName", "(", ")", ".", "replace", "(", "\"", ".gz", "\"", ",", "\"", "\"", ")", ")", ";", "if", "(", "extracted", ".", "exists", "(", ")", ")", "extracted", ".", "delete", "(", ")", ";", "extracted", ".", "createNewFile", "(", ")", ";", "try", "(", "GZIPInputStream", "is2", "=", "new", "GZIPInputStream", "(", "fin", ")", ";", "OutputStream", "fos", "=", "FileUtils", ".", "openOutputStream", "(", "extracted", ")", ")", "{", "IOUtils", ".", "copyLarge", "(", "is2", ",", "fos", ")", ";", "fos", ".", "flush", "(", ")", ";", "}", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Unable to infer file type (compression format) from source file name: ", "\"", "+", "file", ")", ";", "}", "target", ".", "delete", "(", ")", ";", "}"], "idx": 45001, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "f51f4242d67eed9c97a46051cc0c6c72d0830a27", "function_name": "unzipFileTo", "body_hash": "0667fbf7235fd4a703ac5894e396e37fbf4b5163"}
{"code": "public void updateByXml(Source source) throws IOException {\n        checkPermission(CONFIGURE);\n        XmlFile configXmlFile = getConfigFile();\n        AtomicFileWriter out = new AtomicFileWriter(configXmlFile.getFile());\n        try {\n            try {\n                // this allows us to use UTF-8 for storing data,\n                // plus it checks any well-formedness issue in the submitted\n                // data\n                Transformer t = TransformerFactory.newInstance()\n                        .newTransformer();\n                t.transform(source,\n                        new StreamResult(out));\n                out.close();\n            } catch (TransformerException e) {\n                throw new IOException2(\"Failed to persist configuration.xml\", e);\n            }\n\n            // try to reflect the changes by reloading\n            new XmlFile(Items.XSTREAM, out.getTemporaryFile()).unmarshal(this);\n            Items.updatingByXml.set(true);\n            try {\n                onLoad(getParent(), getRootDir().getName());\n            } finally {\n                Items.updatingByXml.set(false);\n            }\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            // if everything went well, commit this new version\n            out.commit();\n            SaveableListener.fireOnChange(this, getConfigFile());\n        } finally {\n            out.abort(); // don't leave anything behind\n        }\n    }", "code_tokens": ["public", "void", "updateByXml", "(", "Source", "source", ")", "throws", "IOException", "{", "checkPermission", "(", "CONFIGURE", ")", ";", "XmlFile", "configXmlFile", "=", "getConfigFile", "(", ")", ";", "AtomicFileWriter", "out", "=", "new", "AtomicFileWriter", "(", "configXmlFile", ".", "getFile", "(", ")", ")", ";", "try", "{", "try", "{", "Transformer", "t", "=", "TransformerFactory", ".", "newInstance", "(", ")", ".", "newTransformer", "(", ")", ";", "t", ".", "transform", "(", "source", ",", "new", "StreamResult", "(", "out", ")", ")", ";", "out", ".", "close", "(", ")", ";", "}", "catch", "(", "TransformerException", "e", ")", "{", "throw", "new", "IOException2", "(", "\"", "Failed to persist configuration.xml", "\"", ",", "e", ")", ";", "}", "new", "XmlFile", "(", "Items", ".", "XSTREAM", ",", "out", ".", "getTemporaryFile", "(", ")", ")", ".", "unmarshal", "(", "this", ")", ";", "Items", ".", "updatingByXml", ".", "set", "(", "true", ")", ";", "try", "{", "onLoad", "(", "getParent", "(", ")", ",", "getRootDir", "(", ")", ".", "getName", "(", ")", ")", ";", "}", "finally", "{", "Items", ".", "updatingByXml", ".", "set", "(", "false", ")", ";", "}", "Jenkins", ".", "getInstance", "(", ")", ".", "rebuildDependencyGraphAsync", "(", ")", ";", "out", ".", "commit", "(", ")", ";", "SaveableListener", ".", "fireOnChange", "(", "this", ",", "getConfigFile", "(", ")", ")", ";", "}", "finally", "{", "out", ".", "abort", "(", ")", ";", "}", "}"], "idx": 30477, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "54d44502bd6ec8df23bf8ef0413bdad650ef321e", "function_name": "updateByXml", "body_hash": "6f3c8058d8ef664006fc12e6c74345b52d445e48"}
{"code": "protected void doDirectory(HttpServletRequest request,HttpServletResponse response, Resource resource)\n        throws IOException\n    {\n        if (_directory)\n        {\n            String listing = resource.getListHTML(request.getRequestURI(),request.getPathInfo().lastIndexOf(\"/\") > 0);\n            response.setContentType(\"text/html; charset=UTF-8\");\n            response.getWriter().println(listing);\n        }\n        else\n            response.sendError(HttpStatus.FORBIDDEN_403);\n    }", "code_tokens": ["protected", "void", "doDirectory", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Resource", "resource", ")", "throws", "IOException", "{", "if", "(", "_directory", ")", "{", "String", "listing", "=", "resource", ".", "getListHTML", "(", "request", ".", "getRequestURI", "(", ")", ",", "request", ".", "getPathInfo", "(", ")", ".", "lastIndexOf", "(", "\"", "/", "\"", ")", ">", "0", ")", ";", "response", ".", "setContentType", "(", "\"", "text/html; charset=UTF-8", "\"", ")", ";", "response", ".", "getWriter", "(", ")", ".", "println", "(", "listing", ")", ";", "}", "else", "response", ".", "sendError", "(", "HttpStatus", ".", "FORBIDDEN_403", ")", ";", "}"], "idx": 79529, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "ca77bd384a2970cabbbdab25cf6251c6fb76cd21", "function_name": "doDirectory", "body_hash": "43defee35c95328d5f97cda0c7492c14e993c83e"}
{"code": "@RequirePOST\n    public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        this.implications(req.bindJSONToList(\n                Implication.class, req.getSubmittedForm().get(\"impl\")\n        ));\n        rsp.sendRedirect(\"\");\n    }", "code_tokens": ["@", "RequirePOST", "public", "void", "doConfigSubmit", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "this", ".", "implications", "(", "req", ".", "bindJSONToList", "(", "Implication", ".", "class", ",", "req", ".", "getSubmittedForm", "(", ")", ".", "get", "(", "\"", "impl", "\"", ")", ")", ")", ";", "rsp", ".", "sendRedirect", "(", "\"", "\"", ")", ";", "}"], "idx": 85311, "cwe": "CWE-862", "target": 1, "status": "VULNERABLE", "commit": "9a5d38f8056a830ef075f379fa1b489c08f7000f", "function_name": "doConfigSubmit", "body_hash": "055d3626e3383421247ab93f6bcaaf7e6dfbfe62"}
{"code": "public T newInstance(@Nullable StaplerRequest req, @Nonnull JSONObject formData) throws FormException {\n        try {\n            Method m = getClass().getMethod(\"newInstance\", StaplerRequest.class);\n\n            if(!Modifier.isAbstract(m.getDeclaringClass().getModifiers())) {\n                // this class overrides newInstance(StaplerRequest).\n                // maintain the backward compatible behavior\n                return verifyNewInstance(newInstance(req));\n            } else {\n                if (req==null) {\n                    // yes, req is supposed to be always non-null, but see the note above\n                    return verifyNewInstance(clazz.newInstance());\n                }\n\n                // new behavior as of 1.206\n                BindInterceptor oldInterceptor = req.getBindInterceptor();\n                try {\n                    NewInstanceBindInterceptor interceptor;\n                    if (oldInterceptor instanceof NewInstanceBindInterceptor) {\n                        interceptor = (NewInstanceBindInterceptor) oldInterceptor;\n                    } else {\n                        interceptor = new NewInstanceBindInterceptor(oldInterceptor);\n                        req.setBindInterceptor(interceptor);\n                    }\n                    interceptor.processed.put(formData, true);\n                    return verifyNewInstance(req.bindJSON(clazz, formData));\n                } finally {\n                    req.setBindInterceptor(oldInterceptor);\n                }\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(e); // impossible\n        } catch (InstantiationException | IllegalAccessException | RuntimeException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        }\n    }", "code_tokens": ["public", "T", "newInstance", "(", "@", "Nullable", "StaplerRequest", "req", ",", "@", "Nonnull", "JSONObject", "formData", ")", "throws", "FormException", "{", "try", "{", "Method", "m", "=", "getClass", "(", ")", ".", "getMethod", "(", "\"", "newInstance", "\"", ",", "StaplerRequest", ".", "class", ")", ";", "if", "(", "!", "Modifier", ".", "isAbstract", "(", "m", ".", "getDeclaringClass", "(", ")", ".", "getModifiers", "(", ")", ")", ")", "{", "return", "verifyNewInstance", "(", "newInstance", "(", "req", ")", ")", ";", "}", "else", "{", "if", "(", "req", "==", "null", ")", "{", "return", "verifyNewInstance", "(", "clazz", ".", "newInstance", "(", ")", ")", ";", "}", "BindInterceptor", "oldInterceptor", "=", "req", ".", "getBindInterceptor", "(", ")", ";", "try", "{", "NewInstanceBindInterceptor", "interceptor", ";", "if", "(", "oldInterceptor", "instanceof", "NewInstanceBindInterceptor", ")", "{", "interceptor", "=", "(", "NewInstanceBindInterceptor", ")", "oldInterceptor", ";", "}", "else", "{", "interceptor", "=", "new", "NewInstanceBindInterceptor", "(", "oldInterceptor", ")", ";", "req", ".", "setBindInterceptor", "(", "interceptor", ")", ";", "}", "interceptor", ".", "processed", ".", "put", "(", "formData", ",", "true", ")", ";", "return", "verifyNewInstance", "(", "req", ".", "bindJSON", "(", "clazz", ",", "formData", ")", ")", ";", "}", "finally", "{", "req", ".", "setBindInterceptor", "(", "oldInterceptor", ")", ";", "}", "}", "}", "catch", "(", "NoSuchMethodException", "e", ")", "{", "throw", "new", "AssertionError", "(", "e", ")", ";", "}", "catch", "(", "InstantiationException", "|", "IllegalAccessException", "|", "RuntimeException", "e", ")", "{", "throw", "new", "Error", "(", "\"", "Failed to instantiate ", "\"", "+", "clazz", "+", "\"", " from ", "\"", "+", "formData", ",", "e", ")", ";", "}", "}"], "idx": 14419, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "7366cc50106442a021c5178cd101057ecc08f2c2", "function_name": "newInstance", "body_hash": "4edb81780801962e3010f9618566acdd117e89ff"}
{"code": "protected void run() {\n        JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();\n        sf.setResourceClasses(MultipartStore.class);\n\n        Map<String, Object> props = new HashMap<>();\n        props.put(AttachmentDeserializer.ATTACHMENT_MAX_SIZE, String.valueOf(1024 * 10));\n        props.put(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD, String.valueOf(1024 * 5));\n        sf.setProperties(props);\n        //default lifecycle is per-request, change it to singleton\n        sf.setResourceProvider(MultipartStore.class,\n                               new SingletonResourceProvider(new MultipartStore()));\n        sf.setAddress(\"http://localhost:\" + PORT + \"/\");\n\n        server = sf.create();\n    }", "code_tokens": ["protected", "void", "run", "(", ")", "{", "JAXRSServerFactoryBean", "sf", "=", "new", "JAXRSServerFactoryBean", "(", ")", ";", "sf", ".", "setResourceClasses", "(", "MultipartStore", ".", "class", ")", ";", "Map", "<", "String", ",", "Object", ">", "props", "=", "new", "HashMap", "<", ">", "(", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MAX_SIZE", ",", "String", ".", "valueOf", "(", "1024", "*", "10", ")", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MEMORY_THRESHOLD", ",", "String", ".", "valueOf", "(", "1024", "*", "5", ")", ")", ";", "sf", ".", "setProperties", "(", "props", ")", ";", "sf", ".", "setResourceProvider", "(", "MultipartStore", ".", "class", ",", "new", "SingletonResourceProvider", "(", "new", "MultipartStore", "(", ")", ")", ")", ";", "sf", ".", "setAddress", "(", "\"", "http://localhost:", "\"", "+", "PORT", "+", "\"", "/", "\"", ")", ";", "server", "=", "sf", ".", "create", "(", ")", ";", "}"], "idx": 107998, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "8bd915bfd7735c248ad660059c6b6ad26cdbcdf6", "function_name": "run", "body_hash": "e80f9b45a2df70ba84ed41bbad388d93642b572a"}
{"code": "public static URL valueOf(String url) {\r\n        if (url == null || (url = url.trim()).length() == 0) {\r\n            throw new IllegalArgumentException(\"url == null\");\r\n        }\r\n        String protocol = null;\r\n        String username = null;\r\n        String password = null;\r\n        String host = null;\r\n        int port = 0;\r\n        String path = null;\r\n        Map<String, String> parameters = null;\r\n        int i = url.indexOf('?'); // separator between body and parameters\r\n        if (i >= 0) {\r\n            String[] parts = url.substring(i + 1).split(\"&\");\r\n            parameters = new HashMap<>();\r\n            for (String part : parts) {\r\n                part = part.trim();\r\n                if (part.length() > 0) {\r\n                    int j = part.indexOf('=');\r\n                    if (j >= 0) {\r\n                        String key = part.substring(0, j);\r\n                        String value = part.substring(j + 1);\r\n                        parameters.put(key, value);\r\n                        // compatible with lower versions registering \"default.\" keys\r\n                        if (key.startsWith(DEFAULT_KEY_PREFIX)) {\r\n                            parameters.putIfAbsent(key.substring(DEFAULT_KEY_PREFIX.length()), value);\r\n                        }\r\n                    } else {\r\n                        parameters.put(part, part);\r\n                    }\r\n                }\r\n            }\r\n            url = url.substring(0, i);\r\n        }\r\n        i = url.indexOf(\"://\");\r\n        if (i >= 0) {\r\n            if (i == 0) {\r\n                throw new IllegalStateException(\"url missing protocol: \\\"\" + url + \"\\\"\");\r\n            }\r\n            protocol = url.substring(0, i);\r\n            url = url.substring(i + 3);\r\n        } else {\r\n            // case: file:/path/to/file.txt\r\n            i = url.indexOf(\":/\");\r\n            if (i >= 0) {\r\n                if (i == 0) {\r\n                    throw new IllegalStateException(\"url missing protocol: \\\"\" + url + \"\\\"\");\r\n                }\r\n                protocol = url.substring(0, i);\r\n                url = url.substring(i + 1);\r\n            }\r\n        }\r\n\r\n        i = url.indexOf('/');\r\n        if (i >= 0) {\r\n            path = url.substring(i + 1);\r\n            url = url.substring(0, i);\r\n        }\r\n        i = url.lastIndexOf('@');\r\n        if (i >= 0) {\r\n            username = url.substring(0, i);\r\n            int j = username.indexOf(':');\r\n            if (j >= 0) {\r\n                password = username.substring(j + 1);\r\n                username = username.substring(0, j);\r\n            }\r\n            url = url.substring(i + 1);\r\n        }\r\n        i = url.lastIndexOf(':');\r\n        if (i >= 0 && i < url.length() - 1) {\r\n            if (url.lastIndexOf('%') > i) {\r\n                // ipv6 address with scope id\r\n                // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0\r\n                // see https://howdoesinternetwork.com/2013/ipv6-zone-id\r\n                // ignore\r\n            } else {\r\n                port = Integer.parseInt(url.substring(i + 1));\r\n                url = url.substring(0, i);\r\n            }\r\n        }\r\n        if (url.length() > 0) {\r\n            host = url;\r\n        }\r\n\r\n        return new URL(protocol, username, password, host, port, path, parameters);\r\n    }", "code_tokens": ["public", "static", "URL", "valueOf", "(", "String", "url", ")", "{", "if", "(", "url", "==", "null", "||", "(", "url", "=", "url", ".", "trim", "(", ")", ")", ".", "length", "(", ")", "==", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "url == null", "\"", ")", ";", "}", "String", "protocol", "=", "null", ";", "String", "username", "=", "null", ";", "String", "password", "=", "null", ";", "String", "host", "=", "null", ";", "int", "port", "=", "0", ";", "String", "path", "=", "null", ";", "Map", "<", "String", ",", "String", ">", "parameters", "=", "null", ";", "int", "i", "=", "url", ".", "indexOf", "(", "'?'", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "String", "[", "]", "parts", "=", "url", ".", "substring", "(", "i", "+", "1", ")", ".", "split", "(", "\"", "&", "\"", ")", ";", "parameters", "=", "new", "HashMap", "<", ">", "(", ")", ";", "for", "(", "String", "part", ":", "parts", ")", "{", "part", "=", "part", ".", "trim", "(", ")", ";", "if", "(", "part", ".", "length", "(", ")", ">", "0", ")", "{", "int", "j", "=", "part", ".", "indexOf", "(", "'='", ")", ";", "if", "(", "j", ">=", "0", ")", "{", "String", "key", "=", "part", ".", "substring", "(", "0", ",", "j", ")", ";", "String", "value", "=", "part", ".", "substring", "(", "j", "+", "1", ")", ";", "parameters", ".", "put", "(", "key", ",", "value", ")", ";", "if", "(", "key", ".", "startsWith", "(", "DEFAULT_KEY_PREFIX", ")", ")", "{", "parameters", ".", "putIfAbsent", "(", "key", ".", "substring", "(", "DEFAULT_KEY_PREFIX", ".", "length", "(", ")", ")", ",", "value", ")", ";", "}", "}", "else", "{", "parameters", ".", "put", "(", "part", ",", "part", ")", ";", "}", "}", "}", "url", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "}", "i", "=", "url", ".", "indexOf", "(", "\"", "://", "\"", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "if", "(", "i", "==", "0", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "url missing protocol: ", "\\\"", "\"", "+", "url", "+", "\"", "\\\"", "\"", ")", ";", "}", "protocol", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "url", "=", "url", ".", "substring", "(", "i", "+", "3", ")", ";", "}", "else", "{", "i", "=", "url", ".", "indexOf", "(", "\"", ":/", "\"", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "if", "(", "i", "==", "0", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "url missing protocol: ", "\\\"", "\"", "+", "url", "+", "\"", "\\\"", "\"", ")", ";", "}", "protocol", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "url", "=", "url", ".", "substring", "(", "i", "+", "1", ")", ";", "}", "}", "i", "=", "url", ".", "indexOf", "(", "'/'", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "path", "=", "url", ".", "substring", "(", "i", "+", "1", ")", ";", "url", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "}", "i", "=", "url", ".", "lastIndexOf", "(", "'@'", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "username", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "int", "j", "=", "username", ".", "indexOf", "(", "':'", ")", ";", "if", "(", "j", ">=", "0", ")", "{", "password", "=", "username", ".", "substring", "(", "j", "+", "1", ")", ";", "username", "=", "username", ".", "substring", "(", "0", ",", "j", ")", ";", "}", "url", "=", "url", ".", "substring", "(", "i", "+", "1", ")", ";", "}", "i", "=", "url", ".", "lastIndexOf", "(", "':'", ")", ";", "if", "(", "i", ">=", "0", "&&", "i", "<", "url", ".", "length", "(", ")", "-", "1", ")", "{", "if", "(", "url", ".", "lastIndexOf", "(", "'%'", ")", ">", "i", ")", "{", "}", "else", "{", "port", "=", "Integer", ".", "parseInt", "(", "url", ".", "substring", "(", "i", "+", "1", ")", ")", ";", "url", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "}", "}", "if", "(", "url", ".", "length", "(", ")", ">", "0", ")", "{", "host", "=", "url", ";", "}", "return", "new", "URL", "(", "protocol", ",", "username", ",", "password", ",", "host", ",", "port", ",", "path", ",", "parameters", ")", ";", "}"], "idx": 65394, "cwe": "CWE-601", "target": 1, "status": "VULNERABLE", "commit": "d5c0cf82715e15b8064a841d25856b73f243d3cd", "function_name": "valueOf", "body_hash": "9a70bfb21392ce0a4b354dbff661fb4e34012bb7"}
{"code": "private void setupJackson(Injector injector, final ObjectMapper mapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n\n    mapper.setInjectableValues(new GuiceInjectableValues(injector));\n    mapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(guiceIntrospector, mapper.getSerializationConfig().getAnnotationIntrospector()),\n        new AnnotationIntrospectorPair(guiceIntrospector, mapper.getDeserializationConfig().getAnnotationIntrospector())\n    );\n  }", "code_tokens": ["private", "void", "setupJackson", "(", "Injector", "injector", ",", "final", "ObjectMapper", "mapper", ")", "{", "final", "GuiceAnnotationIntrospector", "guiceIntrospector", "=", "new", "GuiceAnnotationIntrospector", "(", ")", ";", "mapper", ".", "setInjectableValues", "(", "new", "GuiceInjectableValues", "(", "injector", ")", ")", ";", "mapper", ".", "setAnnotationIntrospectors", "(", "new", "AnnotationIntrospectorPair", "(", "guiceIntrospector", ",", "mapper", ".", "getSerializationConfig", "(", ")", ".", "getAnnotationIntrospector", "(", ")", ")", ",", "new", "AnnotationIntrospectorPair", "(", "guiceIntrospector", ",", "mapper", ".", "getDeserializationConfig", "(", ")", ".", "getAnnotationIntrospector", "(", ")", ")", ")", ";", "}"], "idx": 98769, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "3f8f00a231c4b47981e0e2e48f18f1221249e6f3", "function_name": "setupJackson", "body_hash": "f3488a22c8ad0ee05c166f2b80395dbdaf0532df"}
{"code": "@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory.newInstance().newSAXParser().parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}", "code_tokens": ["@", "Override", "public", "ParseResults", "call", "(", ")", "{", "try", "{", "SAXParserFactory", ".", "newInstance", "(", ")", ".", "newSAXParser", "(", ")", ".", "parse", "(", "xmlInputStream", ",", "handler", ")", ";", "}", "catch", "(", "SAXException", "|", "IOException", "|", "ParserConfigurationException", "e", ")", "{", "throw", "new", "ReportPortalException", "(", "ErrorType", ".", "PARSING_XML_ERROR", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "return", "new", "ParseResults", "(", "handler", ".", "getStartSuiteTime", "(", ")", ",", "handler", ".", "getCommonDuration", "(", ")", ")", ";", "}"], "idx": 69752, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "8601c9e", "function_name": "call", "body_hash": "07be365e24a7a03dc72e7d2b8aeeef5def346efc"}
{"code": "public static long getNextScheduledTime(final String cronEntry, long currentTime) throws MessageFormatException {\n\n        long result = 0;\n\n        if (cronEntry == null || cronEntry.length() == 0) {\n            return result;\n        }\n\n        // Handle the once per minute case \"* * * * *\"\n        // starting the next event at the top of the minute.\n        if (cronEntry.startsWith(\"* * * * *\")) {\n            result = currentTime + 60 * 1000;\n            result = result / 1000 * 1000;\n            return result;\n        }\n\n        List<String> list = tokenize(cronEntry);\n        List<CronEntry> entries = buildCronEntries(list);\n        Calendar working = Calendar.getInstance();\n        working.setTimeInMillis(currentTime);\n        working.set(Calendar.SECOND, 0);\n\n        CronEntry minutes = entries.get(MINUTES);\n        CronEntry hours = entries.get(HOURS);\n        CronEntry dayOfMonth = entries.get(DAY_OF_MONTH);\n        CronEntry month = entries.get(MONTH);\n        CronEntry dayOfWeek = entries.get(DAY_OF_WEEK);\n\n        // Start at the top of the next minute, cron is only guaranteed to be\n        // run on the minute.\n        int timeToNextMinute = 60 - working.get(Calendar.SECOND);\n        working.add(Calendar.SECOND, timeToNextMinute);\n\n        // If its already to late in the day this will roll us over to tomorrow\n        // so we'll need to check again when done updating month and day.\n        int currentMinutes = working.get(Calendar.MINUTE);\n        if (!isCurrent(minutes, currentMinutes)) {\n            int nextMinutes = getNext(minutes, currentMinutes);\n            working.add(Calendar.MINUTE, nextMinutes);\n        }\n\n        int currentHours = working.get(Calendar.HOUR_OF_DAY);\n        if (!isCurrent(hours, currentHours)) {\n            int nextHour = getNext(hours, currentHours);\n            working.add(Calendar.HOUR_OF_DAY, nextHour);\n        }\n\n        // We can roll into the next month here which might violate the cron setting\n        // rules so we check once then recheck again after applying the month settings.\n        doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);\n\n        // Start by checking if we are in the right month, if not then calculations\n        // need to start from the beginning of the month to ensure that we don't end\n        // up on the wrong day.  (Can happen when DAY_OF_WEEK is set and current time\n        // is ahead of the day of the week to execute on).\n        doUpdateCurrentMonth(working, month);\n\n        // Now Check day of week and day of month together since they can be specified\n        // together in one entry, if both \"day of month\" and \"day of week\" are restricted\n        // (not \"*\"), then either the \"day of month\" field (3) or the \"day of week\" field\n        // (5) must match the current day or the Calenday must be advanced.\n        doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);\n\n        // Now we can chose the correct hour and minute of the day in question.\n\n        currentHours = working.get(Calendar.HOUR_OF_DAY);\n        if (!isCurrent(hours, currentHours)) {\n            int nextHour = getNext(hours, currentHours);\n            working.add(Calendar.HOUR_OF_DAY, nextHour);\n        }\n\n        currentMinutes = working.get(Calendar.MINUTE);\n        if (!isCurrent(minutes, currentMinutes)) {\n            int nextMinutes = getNext(minutes, currentMinutes);\n            working.add(Calendar.MINUTE, nextMinutes);\n        }\n\n        result = working.getTimeInMillis();\n\n        if (result <= currentTime) {\n            throw new ArithmeticException(\"Unable to compute next scheduled exection time.\");\n        }\n\n        return result;\n    }", "code_tokens": ["public", "static", "long", "getNextScheduledTime", "(", "final", "String", "cronEntry", ",", "long", "currentTime", ")", "throws", "MessageFormatException", "{", "long", "result", "=", "0", ";", "if", "(", "cronEntry", "==", "null", "||", "cronEntry", ".", "length", "(", ")", "==", "0", ")", "{", "return", "result", ";", "}", "if", "(", "cronEntry", ".", "startsWith", "(", "\"", "* * * * *", "\"", ")", ")", "{", "result", "=", "currentTime", "+", "60", "*", "1000", ";", "result", "=", "result", "/", "1000", "*", "1000", ";", "return", "result", ";", "}", "List", "<", "String", ">", "list", "=", "tokenize", "(", "cronEntry", ")", ";", "List", "<", "CronEntry", ">", "entries", "=", "buildCronEntries", "(", "list", ")", ";", "Calendar", "working", "=", "Calendar", ".", "getInstance", "(", ")", ";", "working", ".", "setTimeInMillis", "(", "currentTime", ")", ";", "working", ".", "set", "(", "Calendar", ".", "SECOND", ",", "0", ")", ";", "CronEntry", "minutes", "=", "entries", ".", "get", "(", "MINUTES", ")", ";", "CronEntry", "hours", "=", "entries", ".", "get", "(", "HOURS", ")", ";", "CronEntry", "dayOfMonth", "=", "entries", ".", "get", "(", "DAY_OF_MONTH", ")", ";", "CronEntry", "month", "=", "entries", ".", "get", "(", "MONTH", ")", ";", "CronEntry", "dayOfWeek", "=", "entries", ".", "get", "(", "DAY_OF_WEEK", ")", ";", "int", "timeToNextMinute", "=", "60", "-", "working", ".", "get", "(", "Calendar", ".", "SECOND", ")", ";", "working", ".", "add", "(", "Calendar", ".", "SECOND", ",", "timeToNextMinute", ")", ";", "int", "currentMinutes", "=", "working", ".", "get", "(", "Calendar", ".", "MINUTE", ")", ";", "if", "(", "!", "isCurrent", "(", "minutes", ",", "currentMinutes", ")", ")", "{", "int", "nextMinutes", "=", "getNext", "(", "minutes", ",", "currentMinutes", ")", ";", "working", ".", "add", "(", "Calendar", ".", "MINUTE", ",", "nextMinutes", ")", ";", "}", "int", "currentHours", "=", "working", ".", "get", "(", "Calendar", ".", "HOUR_OF_DAY", ")", ";", "if", "(", "!", "isCurrent", "(", "hours", ",", "currentHours", ")", ")", "{", "int", "nextHour", "=", "getNext", "(", "hours", ",", "currentHours", ")", ";", "working", ".", "add", "(", "Calendar", ".", "HOUR_OF_DAY", ",", "nextHour", ")", ";", "}", "doUpdateCurrentDay", "(", "working", ",", "dayOfMonth", ",", "dayOfWeek", ")", ";", "doUpdateCurrentMonth", "(", "working", ",", "month", ")", ";", "doUpdateCurrentDay", "(", "working", ",", "dayOfMonth", ",", "dayOfWeek", ")", ";", "currentHours", "=", "working", ".", "get", "(", "Calendar", ".", "HOUR_OF_DAY", ")", ";", "if", "(", "!", "isCurrent", "(", "hours", ",", "currentHours", ")", ")", "{", "int", "nextHour", "=", "getNext", "(", "hours", ",", "currentHours", ")", ";", "working", ".", "add", "(", "Calendar", ".", "HOUR_OF_DAY", ",", "nextHour", ")", ";", "}", "currentMinutes", "=", "working", ".", "get", "(", "Calendar", ".", "MINUTE", ")", ";", "if", "(", "!", "isCurrent", "(", "minutes", ",", "currentMinutes", ")", ")", "{", "int", "nextMinutes", "=", "getNext", "(", "minutes", ",", "currentMinutes", ")", ";", "working", ".", "add", "(", "Calendar", ".", "MINUTE", ",", "nextMinutes", ")", ";", "}", "result", "=", "working", ".", "getTimeInMillis", "(", ")", ";", "if", "(", "result", "<=", "currentTime", ")", "{", "throw", "new", "ArithmeticException", "(", "\"", "Unable to compute next scheduled exection time.", "\"", ")", ";", "}", "return", "result", ";", "}"], "idx": 77464, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "148ca81dcd8f14cfe2ff37012fd1aa42518f02dc", "function_name": "getNextScheduledTime", "body_hash": "24b304b46adc8bbe0870bf8f0421d42a3e7234ba"}
{"code": "@Override\n        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.process\",\n                        wrapper.getSocket(), status));\n            }\n            if (wrapper == null) {\n                // Nothing to do. Socket has been closed.\n                return SocketState.CLOSED;\n            }\n\n            S socket = wrapper.getSocket();\n\n            Processor processor = connections.get(socket);\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.connectionsGet\",\n                        processor, socket));\n            }\n\n            // Timeouts are calculated on a dedicated thread and then\n            // dispatched. Because of delays in the dispatch process, the\n            // timeout may no longer be required. Check here and avoid\n            // unnecessary processing.\n            if (SocketEvent.TIMEOUT == status &&\n                    (processor == null ||\n                    !processor.isAsync() && !processor.isUpgrade() ||\n                    processor.isAsync() && !processor.checkAsyncTimeoutGeneration())) {\n                // This is effectively a NO-OP\n                return SocketState.OPEN;\n            }\n\n            if (processor != null) {\n                // Make sure an async timeout doesn't fire\n                getProtocol().removeWaitingProcessor(processor);\n            } else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) {\n                // Nothing to do. Endpoint requested a close and there is no\n                // longer a processor associated with this socket.\n                return SocketState.CLOSED;\n            }\n\n            ContainerThreadMarker.set();\n\n            try {\n                if (processor == null) {\n                    String negotiatedProtocol = wrapper.getNegotiatedProtocol();\n                    // OpenSSL typically returns null whereas JSSE typically\n                    // returns \"\" when no protocol is negotiated\n                    if (negotiatedProtocol != null && negotiatedProtocol.length() > 0) {\n                        UpgradeProtocol upgradeProtocol = getProtocol().getNegotiatedProtocol(negotiatedProtocol);\n                        if (upgradeProtocol != null) {\n                            processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                            }\n                        } else if (negotiatedProtocol.equals(\"http/1.1\")) {\n                            // Explicitly negotiated the default protocol.\n                            // Obtain a processor below.\n                        } else {\n                            // TODO:\n                            // OpenSSL 1.0.2's ALPN callback doesn't support\n                            // failing the handshake with an error if no\n                            // protocol can be negotiated. Therefore, we need to\n                            // fail the connection here. Once this is fixed,\n                            // replace the code below with the commented out\n                            // block.\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        negotiatedProtocol));\n                            }\n                            return SocketState.CLOSED;\n                            /*\n                             * To replace the code above once OpenSSL 1.1.0 is\n                             * used.\n                            // Failed to create processor. This is a bug.\n                            throw new IllegalStateException(sm.getString(\n                                    \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                    negotiatedProtocol));\n                            */\n                        }\n                    }\n                }\n                if (processor == null) {\n                    processor = recycledProcessors.pop();\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorPop\", processor));\n                    }\n                }\n                if (processor == null) {\n                    processor = getProtocol().createProcessor();\n                    register(processor);\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                    }\n                }\n\n                processor.setSslSupport(\n                        wrapper.getSslSupport(getProtocol().getClientCertProvider()));\n\n                // Associate the processor with the connection\n                connections.put(socket, processor);\n\n                SocketState state = SocketState.CLOSED;\n                do {\n                    state = processor.process(wrapper, status);\n\n                    if (state == SocketState.UPGRADING) {\n                        // Get the HTTP upgrade handler\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        // Retrieve leftover input\n                        ByteBuffer leftOverInput = processor.getLeftoverInput();\n                        if (upgradeToken == null) {\n                            // Assume direct HTTP/2 connection\n                            UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(\"h2c\");\n                            if (upgradeProtocol != null) {\n                                // Release the Http11 processor to be re-used\n                                release(processor);\n                                // Create the upgrade processor\n                                processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                                wrapper.unRead(leftOverInput);\n                                // Associate with the processor with the connection\n                                connections.put(socket, processor);\n                            } else {\n                                if (getLog().isDebugEnabled()) {\n                                    getLog().debug(sm.getString(\n                                        \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        \"h2c\"));\n                                }\n                                // Exit loop and trigger appropriate clean-up\n                                state = SocketState.CLOSED;\n                            }\n                        } else {\n                            HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                            // Release the Http11 processor to be re-used\n                            release(processor);\n                            // Create the upgrade processor\n                            processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.upgradeCreate\",\n                                        processor, wrapper));\n                            }\n                            wrapper.unRead(leftOverInput);\n                            // Mark the connection as upgraded\n                            wrapper.setUpgraded(true);\n                            // Associate with the processor with the connection\n                            connections.put(socket, processor);\n                            // Initialise the upgrade handler (which may trigger\n                            // some IO using the new protocol which is why the lines\n                            // above are necessary)\n                            // This cast should be safe. If it fails the error\n                            // handling for the surrounding try/catch will deal with\n                            // it.\n                            if (upgradeToken.getInstanceManager() == null) {\n                                httpUpgradeHandler.init((WebConnection) processor);\n                            } else {\n                                ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                                try {\n                                    httpUpgradeHandler.init((WebConnection) processor);\n                                } finally {\n                                    upgradeToken.getContextBind().unbind(false, oldCL);\n                                }\n                            }\n                        }\n                    }\n                } while ( state == SocketState.UPGRADING);\n\n                if (state == SocketState.LONG) {\n                    // In the middle of processing a request/response. Keep the\n                    // socket associated with the processor. Exact requirements\n                    // depend on type of long poll\n                    longPoll(wrapper, processor);\n                    if (processor.isAsync()) {\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.OPEN) {\n                    // In keep-alive but between requests. OK to recycle\n                    // processor. Continue to poll for the next request.\n                    connections.remove(socket);\n                    release(processor);\n                    wrapper.registerReadInterest();\n                } else if (state == SocketState.SENDFILE) {\n                    // Sendfile in progress. If it fails, the socket will be\n                    // closed. If it works, the socket either be added to the\n                    // poller (or equivalent) to await more data or processed\n                    // if there are any pipe-lined requests remaining.\n                } else if (state == SocketState.UPGRADED) {\n                    // Don't add sockets back to the poller if this was a\n                    // non-blocking write otherwise the poller may trigger\n                    // multiple read events which may lead to thread starvation\n                    // in the connector. The write() method will add this socket\n                    // to the poller if necessary.\n                    if (status != SocketEvent.OPEN_WRITE) {\n                        longPoll(wrapper, processor);\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.SUSPENDED) {\n                    // Don't add sockets back to the poller.\n                    // The resumeProcessing() method will add this socket\n                    // to the poller.\n                } else {\n                    // Connection closed. OK to recycle the processor.\n                    // Processors handling upgrades require additional clean-up\n                    // before release.\n                    connections.remove(socket);\n                    if (processor.isUpgrade()) {\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                        InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                        if (instanceManager == null) {\n                            httpUpgradeHandler.destroy();\n                        } else {\n                            ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                            try {\n                                httpUpgradeHandler.destroy();\n                            } finally {\n                                try {\n                                    instanceManager.destroyInstance(httpUpgradeHandler);\n                                } catch (Throwable e) {\n                                    ExceptionUtils.handleThrowable(e);\n                                    getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n                                }\n                                upgradeToken.getContextBind().unbind(false, oldCL);\n                            }\n                        }\n                    }\n                    release(processor);\n                }\n                return state;\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.ioexception.debug\"), e);\n            } catch (ProtocolException e) {\n                // Protocol exceptions normally mean the client sent invalid or\n                // incomplete data.\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.protocolexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (OutOfMemoryError oome) {\n                // Try and handle this here to give Tomcat a chance to close the\n                // connection and prevent clients waiting until they time out.\n                // Worst case, it isn't recoverable and the attempt at logging\n                // will trigger another OOME.\n                getLog().error(sm.getString(\"abstractConnectionHandler.oome\"), oome);\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n            } finally {\n                ContainerThreadMarker.clear();\n            }\n\n            // Make sure socket/processor is removed from the list of current\n            // connections\n            connections.remove(socket);\n            release(processor);\n            return SocketState.CLOSED;\n        }", "code_tokens": ["@", "Override", "public", "SocketState", "process", "(", "SocketWrapperBase", "<", "S", ">", "wrapper", ",", "SocketEvent", "status", ")", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.process", "\"", ",", "wrapper", ".", "getSocket", "(", ")", ",", "status", ")", ")", ";", "}", "if", "(", "wrapper", "==", "null", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "S", "socket", "=", "wrapper", ".", "getSocket", "(", ")", ";", "Processor", "processor", "=", "connections", ".", "get", "(", "socket", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.connectionsGet", "\"", ",", "processor", ",", "socket", ")", ")", ";", "}", "if", "(", "SocketEvent", ".", "TIMEOUT", "==", "status", "&&", "(", "processor", "==", "null", "||", "!", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "isUpgrade", "(", ")", "||", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "checkAsyncTimeoutGeneration", "(", ")", ")", ")", "{", "return", "SocketState", ".", "OPEN", ";", "}", "if", "(", "processor", "!=", "null", ")", "{", "getProtocol", "(", ")", ".", "removeWaitingProcessor", "(", "processor", ")", ";", "}", "else", "if", "(", "status", "==", "SocketEvent", ".", "DISCONNECT", "||", "status", "==", "SocketEvent", ".", "ERROR", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "ContainerThreadMarker", ".", "set", "(", ")", ";", "try", "{", "if", "(", "processor", "==", "null", ")", "{", "String", "negotiatedProtocol", "=", "wrapper", ".", "getNegotiatedProtocol", "(", ")", ";", "if", "(", "negotiatedProtocol", "!=", "null", "&&", "negotiatedProtocol", ".", "length", "(", ")", ">", "0", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getNegotiatedProtocol", "(", "negotiatedProtocol", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "else", "if", "(", "negotiatedProtocol", ".", "equals", "(", "\"", "http/1.1", "\"", ")", ")", "{", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "negotiatedProtocol", ")", ")", ";", "}", "return", "SocketState", ".", "CLOSED", ";", "}", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "recycledProcessors", ".", "pop", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorPop", "\"", ",", "processor", ")", ")", ";", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "getProtocol", "(", ")", ".", "createProcessor", "(", ")", ";", "register", "(", "processor", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "processor", ".", "setSslSupport", "(", "wrapper", ".", "getSslSupport", "(", "getProtocol", "(", ")", ".", "getClientCertProvider", "(", ")", ")", ")", ";", "connections", ".", "put", "(", "socket", ",", "processor", ")", ";", "SocketState", "state", "=", "SocketState", ".", "CLOSED", ";", "do", "{", "state", "=", "processor", ".", "process", "(", "wrapper", ",", "status", ")", ";", "if", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "ByteBuffer", "leftOverInput", "=", "processor", ".", "getLeftoverInput", "(", ")", ";", "if", "(", "upgradeToken", "==", "null", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getUpgradeProtocol", "(", "\"", "h2c", "\"", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "release", "(", "processor", ")", ";", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "connections", ".", "put", "(", "socket", ",", "processor", ")", ";", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "\"", "h2c", "\"", ")", ")", ";", "}", "state", "=", "SocketState", ".", "CLOSED", ";", "}", "}", "else", "{", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "release", "(", "processor", ")", ";", "processor", "=", "getProtocol", "(", ")", ".", "createUpgradeProcessor", "(", "wrapper", ",", "upgradeToken", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.upgradeCreate", "\"", ",", "processor", ",", "wrapper", ")", ")", ";", "}", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "wrapper", ".", "setUpgraded", "(", "true", ")", ";", "connections", ".", "put", "(", "socket", ",", "processor", ")", ";", "if", "(", "upgradeToken", ".", "getInstanceManager", "(", ")", "==", "null", ")", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "finally", "{", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "}", "}", "}", "while", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", ";", "if", "(", "state", "==", "SocketState", ".", "LONG", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "if", "(", "processor", ".", "isAsync", "(", ")", ")", "{", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "OPEN", ")", "{", "connections", ".", "remove", "(", "socket", ")", ";", "release", "(", "processor", ")", ";", "wrapper", ".", "registerReadInterest", "(", ")", ";", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SENDFILE", ")", "{", "}", "else", "if", "(", "state", "==", "SocketState", ".", "UPGRADED", ")", "{", "if", "(", "status", "!=", "SocketEvent", ".", "OPEN_WRITE", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SUSPENDED", ")", "{", "}", "else", "{", "connections", ".", "remove", "(", "socket", ")", ";", "if", "(", "processor", ".", "isUpgrade", "(", ")", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "InstanceManager", "instanceManager", "=", "upgradeToken", ".", "getInstanceManager", "(", ")", ";", "if", "(", "instanceManager", "==", "null", ")", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "finally", "{", "try", "{", "instanceManager", ".", "destroyInstance", "(", "httpUpgradeHandler", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "}", "release", "(", "processor", ")", ";", "}", "return", "state", ";", "}", "catch", "(", "java", ".", "net", ".", "SocketException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.socketexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "java", ".", "io", ".", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.ioexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "ProtocolException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.protocolexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "OutOfMemoryError", "oome", ")", "{", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.oome", "\"", ")", ",", "oome", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "finally", "{", "ContainerThreadMarker", ".", "clear", "(", ")", ";", "}", "connections", ".", "remove", "(", "socket", ")", ";", "release", "(", "processor", ")", ";", "return", "SocketState", ".", "CLOSED", ";", "}"], "idx": 56903, "cwe": "CWE-476", "target": 0, "status": "FIXED", "commit": "923d834500802a61779318911d7898bd85fc950e", "function_name": "process", "body_hash": "80c71adcf3ac0e75d15daf1b8b49c08edc86a4bf"}
{"code": "private LikeCondition createLike(Type type, String toMatch) {\n\t\tif (notLike) {\n\t\t\treturn new NotLikeCondition(selector, selector.generateParameter(type.wrap(toMatch)));\n\t\t} else {\n\t\t\treturn new LikeCondition(selector, selector.generateParameter(type.wrap(toMatch)));\n\t\t}\n\t}", "code_tokens": ["private", "LikeCondition", "createLike", "(", "Type", "type", ",", "String", "toMatch", ")", "{", "if", "(", "notLike", ")", "{", "return", "new", "NotLikeCondition", "(", "selector", ",", "selector", ".", "generateParameter", "(", "type", ".", "wrap", "(", "toMatch", ")", ")", ")", ";", "}", "else", "{", "return", "new", "LikeCondition", "(", "selector", ",", "selector", ".", "generateParameter", "(", "type", ".", "wrap", "(", "toMatch", ")", ")", ")", ";", "}", "}"], "idx": 104987, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "3c20b874fba9cc2a78b9ace10208de1602b56c3f", "function_name": "createLike", "body_hash": "eecb46957f414d8992b2d7d3a65556266ef9152d"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (mappingFile != null) {\n            setProperty(camelContext, dataFormat, \"mappingFile\", mappingFile);\n        }\n        // should be true by default\n        boolean isValidation = getValidation() == null || getValidation();\n        setProperty(camelContext, dataFormat, \"validation\", isValidation);\n\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (packages != null) {\n            setProperty(camelContext, dataFormat, \"packages\", packages);\n        }\n        if (classes != null) {\n            setProperty(camelContext, dataFormat, \"classes\", classes);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "mappingFile", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "mappingFile", "\"", ",", "mappingFile", ")", ";", "}", "boolean", "isValidation", "=", "getValidation", "(", ")", "==", "null", "||", "getValidation", "(", ")", ";", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "validation", "\"", ",", "isValidation", ")", ";", "if", "(", "encoding", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "encoding", "\"", ",", "encoding", ")", ";", "}", "if", "(", "packages", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "packages", "\"", ",", "packages", ")", ";", "}", "if", "(", "classes", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "classes", "\"", ",", "classes", ")", ";", "}", "}"], "idx": 57330, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "573ebd3de810cc7e239f175e1d2d6993f1f2ad0", "function_name": "configureDataFormat", "body_hash": "e298af68af56c9cc465c75c69bcdbe321a86f104"}
{"code": "private boolean isFileWithinDirectory(\n            final File dir,\n            final File file\n    ) throws IOException {\n        final File dir_ = dir.getAbsoluteFile();\n        if (dir_.isDirectory()) {\n            final File fl = new File(dir_, file.getPath());\n            if (fl.isFile()) {\n                if (fl.getCanonicalFile().toPath().startsWith(dir_.getCanonicalFile().toPath())) {\n                    // Prevent accessing files outside the load-path.\n                    // E.g.: ../../coffee\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }", "code_tokens": ["private", "boolean", "isFileWithinDirectory", "(", "final", "File", "dir", ",", "final", "File", "file", ")", "throws", "IOException", "{", "final", "File", "dir_", "=", "dir", ".", "getAbsoluteFile", "(", ")", ";", "if", "(", "dir_", ".", "isDirectory", "(", ")", ")", "{", "final", "File", "fl", "=", "new", "File", "(", "dir_", ",", "file", ".", "getPath", "(", ")", ")", ";", "if", "(", "fl", ".", "isFile", "(", ")", ")", "{", "if", "(", "fl", ".", "getCanonicalFile", "(", ")", ".", "toPath", "(", ")", ".", "startsWith", "(", "dir_", ".", "getCanonicalFile", "(", ")", ".", "toPath", "(", ")", ")", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "idx": 27441, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "c942c73136333bc493050910f171a48e6f575b23", "function_name": "isFileWithinDirectory", "body_hash": "60b6c0949c79f114e0834c39e1f405f8ce94f45c"}
{"code": "@Override\n    public SecurityConstraint [] findSecurityConstraints(Request request,\n                                                         Context context) {\n\n        ArrayList<SecurityConstraint> results = null;\n        // Are there any defined security constraints?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraints defined\");\n            return null;\n        }\n\n        // Check each defined security constraint\n        String uri = request.getRequestPathMB().toString();\n        // Bug47080 - in rare cases this may be null\n        // Mapper treats as '/' do the same to prevent NPE\n        if (uri == null) {\n            uri = \"/\";\n        }\n\n        String method = request.getMethod();\n        int i;\n        boolean found = false;\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length; k++) {\n                    if(uri.equals(patterns[k])) {\n                        found = true;\n                        if(collection[j].findMethod(method)) {\n                            if(results == null) {\n                                results = new ArrayList<>();\n                            }\n                            results.add(constraints[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        int longest = -1;\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                int length = -1;\n                for(int k=0; k < patterns.length; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") &&\n                       pattern.length() >= longest) {\n\n                        if(pattern.length() == 2) {\n                            matched = true;\n                            length = pattern.length();\n                        } else if(pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-1) ||\n                                  (pattern.length()-2 == uri.length() &&\n                                   pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-2))) {\n                            matched = true;\n                            length = pattern.length();\n                        }\n                    }\n                }\n                if(matched) {\n                    if(length > longest) {\n                        found = false;\n                        if(results != null) {\n                            results.clear();\n                        }\n                        longest = length;\n                    }\n                    if(collection[j].findMethod(method)) {\n                        found = true;\n                        if(results == null) {\n                            results = new ArrayList<>();\n                        }\n                        results.add(constraints[i]);\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return  resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            boolean matched = false;\n            int pos = -1;\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"*.\")){\n                        int slash = uri.lastIndexOf('/');\n                        int dot = uri.lastIndexOf('.');\n                        if(slash >= 0 && dot > slash &&\n                           dot != uri.length()-1 &&\n                           uri.length()-dot == pattern.length()-1) {\n                            if(pattern.regionMatches(1,uri,dot,uri.length()-dot)) {\n                                matched = true;\n                                pos = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if(matched) {\n                found = true;\n                if(collection[pos].findMethod(method)) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.equals(\"/\")){\n                        matched = true;\n                    }\n                }\n                if(matched) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(results == null) {\n            // No applicable security constraint was found\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraint located\");\n        }\n        return resultsToArray(results);\n    }", "code_tokens": ["@", "Override", "public", "SecurityConstraint", "[", "]", "findSecurityConstraints", "(", "Request", "request", ",", "Context", "context", ")", "{", "ArrayList", "<", "SecurityConstraint", ">", "results", "=", "null", ";", "SecurityConstraint", "constraints", "[", "]", "=", "context", ".", "findConstraints", "(", ")", ";", "if", "(", "(", "constraints", "==", "null", ")", "||", "(", "constraints", ".", "length", "==", "0", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "  No applicable constraints defined", "\"", ")", ";", "return", "null", ";", "}", "String", "uri", "=", "request", ".", "getRequestPathMB", "(", ")", ".", "toString", "(", ")", ";", "if", "(", "uri", "==", "null", ")", "{", "uri", "=", "\"", "/", "\"", ";", "}", "String", "method", "=", "request", ".", "getMethod", "(", ")", ";", "int", "i", ";", "boolean", "found", "=", "false", ";", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", ";", "i", "++", ")", "{", "SecurityCollection", "[", "]", "collection", "=", "constraints", "[", "i", "]", ".", "findCollections", "(", ")", ";", "if", "(", "collection", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "  Checking constraint '", "\"", "+", "constraints", "[", "i", "]", "+", "\"", "' against ", "\"", "+", "method", "+", "\"", " ", "\"", "+", "uri", "+", "\"", " --> ", "\"", "+", "constraints", "[", "i", "]", ".", "included", "(", "uri", ",", "method", ")", ")", ";", "}", "for", "(", "int", "j", "=", "0", ";", "j", "<", "collection", ".", "length", ";", "j", "++", ")", "{", "String", "[", "]", "patterns", "=", "collection", "[", "j", "]", ".", "findPatterns", "(", ")", ";", "if", "(", "patterns", "==", "null", ")", "{", "continue", ";", "}", "for", "(", "int", "k", "=", "0", ";", "k", "<", "patterns", ".", "length", ";", "k", "++", ")", "{", "if", "(", "uri", ".", "equals", "(", "patterns", "[", "k", "]", ")", ")", "{", "found", "=", "true", ";", "if", "(", "collection", "[", "j", "]", ".", "findMethod", "(", "method", ")", ")", "{", "if", "(", "results", "==", "null", ")", "{", "results", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "}", "results", ".", "add", "(", "constraints", "[", "i", "]", ")", ";", "}", "}", "}", "}", "}", "if", "(", "found", ")", "{", "return", "resultsToArray", "(", "results", ")", ";", "}", "int", "longest", "=", "-", "1", ";", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", ";", "i", "++", ")", "{", "SecurityCollection", "[", "]", "collection", "=", "constraints", "[", "i", "]", ".", "findCollections", "(", ")", ";", "if", "(", "collection", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "  Checking constraint '", "\"", "+", "constraints", "[", "i", "]", "+", "\"", "' against ", "\"", "+", "method", "+", "\"", " ", "\"", "+", "uri", "+", "\"", " --> ", "\"", "+", "constraints", "[", "i", "]", ".", "included", "(", "uri", ",", "method", ")", ")", ";", "}", "for", "(", "int", "j", "=", "0", ";", "j", "<", "collection", ".", "length", ";", "j", "++", ")", "{", "String", "[", "]", "patterns", "=", "collection", "[", "j", "]", ".", "findPatterns", "(", ")", ";", "if", "(", "patterns", "==", "null", ")", "{", "continue", ";", "}", "boolean", "matched", "=", "false", ";", "int", "length", "=", "-", "1", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "patterns", ".", "length", ";", "k", "++", ")", "{", "String", "pattern", "=", "patterns", "[", "k", "]", ";", "if", "(", "pattern", ".", "startsWith", "(", "\"", "/", "\"", ")", "&&", "pattern", ".", "endsWith", "(", "\"", "/*", "\"", ")", "&&", "pattern", ".", "length", "(", ")", ">=", "longest", ")", "{", "if", "(", "pattern", ".", "length", "(", ")", "==", "2", ")", "{", "matched", "=", "true", ";", "length", "=", "pattern", ".", "length", "(", ")", ";", "}", "else", "if", "(", "pattern", ".", "regionMatches", "(", "0", ",", "uri", ",", "0", ",", "pattern", ".", "length", "(", ")", "-", "1", ")", "||", "(", "pattern", ".", "length", "(", ")", "-", "2", "==", "uri", ".", "length", "(", ")", "&&", "pattern", ".", "regionMatches", "(", "0", ",", "uri", ",", "0", ",", "pattern", ".", "length", "(", ")", "-", "2", ")", ")", ")", "{", "matched", "=", "true", ";", "length", "=", "pattern", ".", "length", "(", ")", ";", "}", "}", "}", "if", "(", "matched", ")", "{", "if", "(", "length", ">", "longest", ")", "{", "found", "=", "false", ";", "if", "(", "results", "!=", "null", ")", "{", "results", ".", "clear", "(", ")", ";", "}", "longest", "=", "length", ";", "}", "if", "(", "collection", "[", "j", "]", ".", "findMethod", "(", "method", ")", ")", "{", "found", "=", "true", ";", "if", "(", "results", "==", "null", ")", "{", "results", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "}", "results", ".", "add", "(", "constraints", "[", "i", "]", ")", ";", "}", "}", "}", "}", "if", "(", "found", ")", "{", "return", "resultsToArray", "(", "results", ")", ";", "}", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", ";", "i", "++", ")", "{", "SecurityCollection", "[", "]", "collection", "=", "constraints", "[", "i", "]", ".", "findCollections", "(", ")", ";", "if", "(", "collection", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "  Checking constraint '", "\"", "+", "constraints", "[", "i", "]", "+", "\"", "' against ", "\"", "+", "method", "+", "\"", " ", "\"", "+", "uri", "+", "\"", " --> ", "\"", "+", "constraints", "[", "i", "]", ".", "included", "(", "uri", ",", "method", ")", ")", ";", "}", "boolean", "matched", "=", "false", ";", "int", "pos", "=", "-", "1", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "collection", ".", "length", ";", "j", "++", ")", "{", "String", "[", "]", "patterns", "=", "collection", "[", "j", "]", ".", "findPatterns", "(", ")", ";", "if", "(", "patterns", "==", "null", ")", "{", "continue", ";", "}", "for", "(", "int", "k", "=", "0", ";", "k", "<", "patterns", ".", "length", "&&", "!", "matched", ";", "k", "++", ")", "{", "String", "pattern", "=", "patterns", "[", "k", "]", ";", "if", "(", "pattern", ".", "startsWith", "(", "\"", "*.", "\"", ")", ")", "{", "int", "slash", "=", "uri", ".", "lastIndexOf", "(", "'/'", ")", ";", "int", "dot", "=", "uri", ".", "lastIndexOf", "(", "'.'", ")", ";", "if", "(", "slash", ">=", "0", "&&", "dot", ">", "slash", "&&", "dot", "!=", "uri", ".", "length", "(", ")", "-", "1", "&&", "uri", ".", "length", "(", ")", "-", "dot", "==", "pattern", ".", "length", "(", ")", "-", "1", ")", "{", "if", "(", "pattern", ".", "regionMatches", "(", "1", ",", "uri", ",", "dot", ",", "uri", ".", "length", "(", ")", "-", "dot", ")", ")", "{", "matched", "=", "true", ";", "pos", "=", "j", ";", "}", "}", "}", "}", "}", "if", "(", "matched", ")", "{", "found", "=", "true", ";", "if", "(", "collection", "[", "pos", "]", ".", "findMethod", "(", "method", ")", ")", "{", "if", "(", "results", "==", "null", ")", "{", "results", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "}", "results", ".", "add", "(", "constraints", "[", "i", "]", ")", ";", "}", "}", "}", "if", "(", "found", ")", "{", "return", "resultsToArray", "(", "results", ")", ";", "}", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", ";", "i", "++", ")", "{", "SecurityCollection", "[", "]", "collection", "=", "constraints", "[", "i", "]", ".", "findCollections", "(", ")", ";", "if", "(", "collection", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "  Checking constraint '", "\"", "+", "constraints", "[", "i", "]", "+", "\"", "' against ", "\"", "+", "method", "+", "\"", " ", "\"", "+", "uri", "+", "\"", " --> ", "\"", "+", "constraints", "[", "i", "]", ".", "included", "(", "uri", ",", "method", ")", ")", ";", "}", "for", "(", "int", "j", "=", "0", ";", "j", "<", "collection", ".", "length", ";", "j", "++", ")", "{", "String", "[", "]", "patterns", "=", "collection", "[", "j", "]", ".", "findPatterns", "(", ")", ";", "if", "(", "patterns", "==", "null", ")", "{", "continue", ";", "}", "boolean", "matched", "=", "false", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "patterns", ".", "length", "&&", "!", "matched", ";", "k", "++", ")", "{", "String", "pattern", "=", "patterns", "[", "k", "]", ";", "if", "(", "pattern", ".", "equals", "(", "\"", "/", "\"", ")", ")", "{", "matched", "=", "true", ";", "}", "}", "if", "(", "matched", ")", "{", "if", "(", "results", "==", "null", ")", "{", "results", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "}", "results", ".", "add", "(", "constraints", "[", "i", "]", ")", ";", "}", "}", "}", "if", "(", "results", "==", "null", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "  No applicable constraint located", "\"", ")", ";", "}", "return", "resultsToArray", "(", "results", ")", ";", "}"], "idx": 100873, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "723ea6a5bc5e7bc49e5ef84273c3b3c164a6a4fd", "function_name": "findSecurityConstraints", "body_hash": "61ee7f2fb6b2bfd54d677b08e9729bd67143d764"}
{"code": "@Exported(inline=true)\n    public synchronized Item[] getItems() {\n        Item[] r = new Item[waitingList.size() + blockedProjects.size() + buildables.size() + pendings.size()];\n        waitingList.toArray(r);\n        int idx = waitingList.size();\n        for (BlockedItem p : blockedProjects.values())\n            r[idx++] = p;\n        for (BuildableItem p : reverse(buildables.values()))\n            r[idx++] = p;\n        for (BuildableItem p : reverse(pendings.values()))\n            r[idx++] = p;\n        return r;\n    }", "code_tokens": ["@", "Exported", "(", "inline", "=", "true", ")", "public", "synchronized", "Item", "[", "]", "getItems", "(", ")", "{", "Item", "[", "]", "r", "=", "new", "Item", "[", "waitingList", ".", "size", "(", ")", "+", "blockedProjects", ".", "size", "(", ")", "+", "buildables", ".", "size", "(", ")", "+", "pendings", ".", "size", "(", ")", "]", ";", "waitingList", ".", "toArray", "(", "r", ")", ";", "int", "idx", "=", "waitingList", ".", "size", "(", ")", ";", "for", "(", "BlockedItem", "p", ":", "blockedProjects", ".", "values", "(", ")", ")", "r", "[", "idx", "++", "]", "=", "p", ";", "for", "(", "BuildableItem", "p", ":", "reverse", "(", "buildables", ".", "values", "(", ")", ")", ")", "r", "[", "idx", "++", "]", "=", "p", ";", "for", "(", "BuildableItem", "p", ":", "reverse", "(", "pendings", ".", "values", "(", ")", ")", ")", "r", "[", "idx", "++", "]", "=", "p", ";", "return", "r", ";", "}"], "idx": 30555, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "581eb9ceb354b8a55c010d0547ff73cb6fd67a75", "function_name": "getItems", "body_hash": "c249045fc989f7173296e0dc12e4a03561047936"}
{"code": "public static void unzipFilesToPath(String jarPath, String destinationDir) throws IOException {\n        String canonicalDestDir = new File(destinationDir).getCanonicalPath();\n        if (!canonicalDestDir.endsWith(File.separator)) {\n            canonicalDestDir += File.separator;\n        }\n\n        File file = new File(jarPath);\n        try (JarFile jar = new JarFile(file)) {\n\n            // fist get all directories,\n            // then make those directory on the destination Path\n            /*for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {\n                JarEntry entry = (JarEntry) enums.nextElement();\n\n                String fileName = destinationDir + File.separator + entry.getName();\n                File f = new File(fileName);\n\n                if (fileName.endsWith(\"/\")) {\n                    f.mkdirs();\n                }\n\n            }*/\n\n            //now create all files\n            for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {\n                JarEntry entry = enums.nextElement();\n\n                String fileName = destinationDir + File.separator + entry.getName();\n                File f = new File(fileName);\n\n                if (!f.getCanonicalPath().startsWith(canonicalDestDir)) {\n                    System.out.println(\"Zip Slip exploit detected. Skipping entry \" + entry.getName());\n                    continue;\n                }\n\n                File parent = f.getParentFile();\n                if (!parent.exists()) {\n                    parent.mkdirs();\n                }\n\n                if (!fileName.endsWith(\"/\")) {\n                    try (InputStream is = jar.getInputStream(entry);\n                         FileOutputStream fos = new FileOutputStream(f)) {\n                        // write contents of 'is' to 'fos'\n                        while (is.available() > 0) {\n                            fos.write(is.read());\n                        }\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["public", "static", "void", "unzipFilesToPath", "(", "String", "jarPath", ",", "String", "destinationDir", ")", "throws", "IOException", "{", "String", "canonicalDestDir", "=", "new", "File", "(", "destinationDir", ")", ".", "getCanonicalPath", "(", ")", ";", "if", "(", "!", "canonicalDestDir", ".", "endsWith", "(", "File", ".", "separator", ")", ")", "{", "canonicalDestDir", "+=", "File", ".", "separator", ";", "}", "File", "file", "=", "new", "File", "(", "jarPath", ")", ";", "try", "(", "JarFile", "jar", "=", "new", "JarFile", "(", "file", ")", ")", "{", "for", "(", "Enumeration", "<", "JarEntry", ">", "enums", "=", "jar", ".", "entries", "(", ")", ";", "enums", ".", "hasMoreElements", "(", ")", ";", ")", "{", "JarEntry", "entry", "=", "enums", ".", "nextElement", "(", ")", ";", "String", "fileName", "=", "destinationDir", "+", "File", ".", "separator", "+", "entry", ".", "getName", "(", ")", ";", "File", "f", "=", "new", "File", "(", "fileName", ")", ";", "if", "(", "!", "f", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "canonicalDestDir", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "Zip Slip exploit detected. Skipping entry ", "\"", "+", "entry", ".", "getName", "(", ")", ")", ";", "continue", ";", "}", "File", "parent", "=", "f", ".", "getParentFile", "(", ")", ";", "if", "(", "!", "parent", ".", "exists", "(", ")", ")", "{", "parent", ".", "mkdirs", "(", ")", ";", "}", "if", "(", "!", "fileName", ".", "endsWith", "(", "\"", "/", "\"", ")", ")", "{", "try", "(", "InputStream", "is", "=", "jar", ".", "getInputStream", "(", "entry", ")", ";", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "f", ")", ")", "{", "while", "(", "is", ".", "available", "(", ")", ">", "0", ")", "{", "fos", ".", "write", "(", "is", ".", "read", "(", ")", ")", ";", "}", "}", "}", "}", "}", "}"], "idx": 27025, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "1ec02658fe6858162f5e6a24f97928de6696c5cb", "function_name": "unzipFilesToPath", "body_hash": "7ec293a9cc738f32f0d58c6a36c97911dfa176a8"}
{"code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\"Authorization\");\n\n        if (authorization!=null) {\n            // authenticate the user\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                try {\n                    Jenkins.getInstance().getSecurityRealm().loadUserByUsername(username);\n                } catch (UserMayOrMayNotExistException x) {\n                    // OK, give them the benefit of the doubt.\n                } catch (UsernameNotFoundException x) {\n                    // Not/no longer a user; deny the API token. (But do not leak the information that this happened.)\n                    chain.doFilter(request, response);\n                    return;\n                } catch (DataAccessException x) {\n                    throw new ServletException(x);\n                }\n                String password = uidpassword.substring(idx+1);\n\n                // attempt to authenticate as API token\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    // even if we fail to match the password, we aren't rejecting it.\n                    // as the user might be passing in a real password.\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n        }\n\n        chain.doFilter(request,response);\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "HttpServletRequest", "req", "=", "(", "HttpServletRequest", ")", "request", ";", "HttpServletResponse", "rsp", "=", "(", "HttpServletResponse", ")", "response", ";", "String", "authorization", "=", "req", ".", "getHeader", "(", "\"", "Authorization", "\"", ")", ";", "if", "(", "authorization", "!=", "null", ")", "{", "String", "uidpassword", "=", "Scrambler", ".", "descramble", "(", "authorization", ".", "substring", "(", "6", ")", ")", ";", "int", "idx", "=", "uidpassword", ".", "indexOf", "(", "':'", ")", ";", "if", "(", "idx", ">=", "0", ")", "{", "String", "username", "=", "uidpassword", ".", "substring", "(", "0", ",", "idx", ")", ";", "try", "{", "Jenkins", ".", "getInstance", "(", ")", ".", "getSecurityRealm", "(", ")", ".", "loadUserByUsername", "(", "username", ")", ";", "}", "catch", "(", "UserMayOrMayNotExistException", "x", ")", "{", "}", "catch", "(", "UsernameNotFoundException", "x", ")", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "return", ";", "}", "catch", "(", "DataAccessException", "x", ")", "{", "throw", "new", "ServletException", "(", "x", ")", ";", "}", "String", "password", "=", "uidpassword", ".", "substring", "(", "idx", "+", "1", ")", ";", "User", "u", "=", "User", ".", "get", "(", "username", ")", ";", "ApiTokenProperty", "t", "=", "u", ".", "getProperty", "(", "ApiTokenProperty", ".", "class", ")", ";", "if", "(", "t", "!=", "null", "&&", "t", ".", "matchesPassword", "(", "password", ")", ")", "{", "SecurityContext", "oldContext", "=", "ACL", ".", "impersonate", "(", "u", ".", "impersonate", "(", ")", ")", ";", "try", "{", "request", ".", "setAttribute", "(", "ApiTokenProperty", ".", "class", ".", "getName", "(", ")", ",", "u", ")", ";", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "return", ";", "}", "finally", "{", "SecurityContextHolder", ".", "setContext", "(", "oldContext", ")", ";", "}", "}", "}", "}", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}"], "idx": 38582, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "5548b5220cfd496831b5721124189ff18fbb12a3", "function_name": "doFilter", "body_hash": "6eb91d27120487a0a911c2427ffd73b26f9f2c17"}
{"code": "@POST\n    public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        Jenkins.get().checkPermission(Jenkins.ADMINISTER);\n        this.implications(req.bindJSONToList(\n                Implication.class, req.getSubmittedForm().get(\"impl\")\n        ));\n        rsp.sendRedirect(\"\");\n    }", "code_tokens": ["@", "POST", "public", "void", "doConfigSubmit", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "Jenkins", ".", "get", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "this", ".", "implications", "(", "req", ".", "bindJSONToList", "(", "Implication", ".", "class", ",", "req", ".", "getSubmittedForm", "(", ")", ".", "get", "(", "\"", "impl", "\"", ")", ")", ")", ";", "rsp", ".", "sendRedirect", "(", "\"", "\"", ")", ";", "}"], "idx": 85312, "cwe": "CWE-862", "target": 0, "status": "FIXED", "commit": "9a5d38f8056a830ef075f379fa1b489c08f7000f", "function_name": "doConfigSubmit", "body_hash": "646d47d828143dae694b6ac2fe9b4daa9a7d8647"}
{"code": "protected void parseInputStream(InputStream stream) {\n\t\tSAXParserFactory pf = SAXParserFactory.newInstance();\n\t\ttry {\n\t\t\t// Prevent XXE\n\t\t\tpf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\tpf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tpf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tSAXParser parser = pf.newSAXParser();\n\t\t\tparser.parse(stream, new SAXHandler());\n\t\t} catch (ParserConfigurationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (SAXException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Build the source and sink lists\n\t\tbuildSourceSinkLists();\n\t}", "code_tokens": ["protected", "void", "parseInputStream", "(", "InputStream", "stream", ")", "{", "SAXParserFactory", "pf", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "try", "{", "pf", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "pf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "pf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "SAXParser", "parser", "=", "pf", ".", "newSAXParser", "(", ")", ";", "parser", ".", "parse", "(", "stream", ",", "new", "SAXHandler", "(", ")", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "buildSourceSinkLists", "(", ")", ";", "}"], "idx": 69033, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "01fcfcc475d1e5a677249cd94763f9e824104097", "function_name": "parseInputStream", "body_hash": "a7163455ba1574751626ecc3eff0c61d69517e75"}
{"code": "@Override\n    protected void onSuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, Authentication authResult) throws IOException {\n        super.onSuccessfulAuthentication(request,response,authResult);\n        // make sure we have a session to store this successful authentication, given that we no longer\n        // let HttpSessionContextIntegrationFilter2 to create sessions.\n        // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later\n        // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its\n        // doFilter method.\n        request.getSession().invalidate();\n        request.getSession();\n    }", "code_tokens": ["@", "Override", "protected", "void", "onSuccessfulAuthentication", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Authentication", "authResult", ")", "throws", "IOException", "{", "super", ".", "onSuccessfulAuthentication", "(", "request", ",", "response", ",", "authResult", ")", ";", "request", ".", "getSession", "(", ")", ".", "invalidate", "(", ")", ";", "request", ".", "getSession", "(", ")", ";", "}"], "idx": 38628, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "8ac74c350779921598f9d5edfed39dd35de8842a", "function_name": "onSuccessfulAuthentication", "body_hash": "a60a05613ac8336b94a99537263ab6c75c7dfd6a"}
{"code": "@Exported(inline=true)\n    public Map<String/*monitor name*/,Object> getMonitorData() {\n        Map<String,Object> r = new HashMap<String, Object>();\n        if (hasPermission(CONNECT)) {\n            for (NodeMonitor monitor : NodeMonitor.getAll())\n                r.put(monitor.getClass().getName(), monitor.data(this));\n        }\n        return r;\n    }", "code_tokens": ["@", "Exported", "(", "inline", "=", "true", ")", "public", "Map", "<", "String", ",", "Object", ">", "getMonitorData", "(", ")", "{", "Map", "<", "String", ",", "Object", ">", "r", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "if", "(", "hasPermission", "(", "CONNECT", ")", ")", "{", "for", "(", "NodeMonitor", "monitor", ":", "NodeMonitor", ".", "getAll", "(", ")", ")", "r", ".", "put", "(", "monitor", ".", "getClass", "(", ")", ".", "getName", "(", ")", ",", "monitor", ".", "data", "(", "this", ")", ")", ";", "}", "return", "r", ";", "}"], "idx": 13016, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "0f92cd08a19207de2cceb6a2f4e3e9f92fdc0899", "function_name": "getMonitorData", "body_hash": "dfdbe0749f4ea4606849a9954f3228ba56777ea5"}
{"code": "private void registerMessageListener() {\n\t\t// do not register multiple packet listeners\n\t\tif (mPacketListener != null)\n\t\t\tmXMPPConnection.removePacketListener(mPacketListener);\n\n\t\tPacketTypeFilter filter = new PacketTypeFilter(Message.class);\n\n\t\tmPacketListener = new PacketListener() {\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\ttry {\n\t\t\t\tif (packet instanceof Message) {\n\t\t\t\t\tMessage msg = (Message) packet;\n\n\t\t\t\t\tString[] fromJID = getJabberID(msg.getFrom());\n\t\t\t\t\t\n\t\t\t\t\tint direction = ChatConstants.INCOMING;\n\t\t\t\t\tCarbon cc = CarbonManager.getCarbon(msg);\n\n\t\t\t\t\t// extract timestamp\n\t\t\t\t\tlong ts;\n\t\t\t\t\tDelayInfo timestamp = (DelayInfo)msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n\t\t\t\t\tif (timestamp == null)\n\t\t\t\t\t\ttimestamp = (DelayInfo)msg.getExtension(\"x\", \"jabber:x:delay\");\n\t\t\t\t\tif (cc != null) // Carbon timestamp overrides packet timestamp\n\t\t\t\t\t\ttimestamp = cc.getForwarded().getDelayInfo();\n\t\t\t\t\tif (timestamp != null)\n\t\t\t\t\t\tts = timestamp.getStamp().getTime();\n\t\t\t\t\telse\n\t\t\t\t\t\tts = System.currentTimeMillis();\n\n\t\t\t\t\t// try to extract a carbon\n\t\t\t\t\tif (cc != null) {\n\t\t\t\t\t\tLog.d(TAG, \"carbon: \" + cc.toXML());\n\t\t\t\t\t\tmsg = (Message)cc.getForwarded().getForwardedPacket();\n\n\t\t\t\t\t\t// outgoing carbon: fromJID is actually chat peer's JID\n\t\t\t\t\t\tif (cc.getDirection() == Carbon.Direction.sent) {\n\t\t\t\t\t\t\tfromJID = getJabberID(msg.getTo());\n\t\t\t\t\t\t\tdirection = ChatConstants.OUTGOING;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfromJID = getJabberID(msg.getFrom());\n\n\t\t\t\t\t\t\t// hook off carbonated delivery receipts\n\t\t\t\t\t\t\tDeliveryReceipt dr = (DeliveryReceipt)msg.getExtension(\n\t\t\t\t\t\t\t\t\tDeliveryReceipt.ELEMENT, DeliveryReceipt.NAMESPACE);\n\t\t\t\t\t\t\tif (dr != null) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"got CC'ed delivery receipt for \" + dr.getId());\n\t\t\t\t\t\t\t\tchangeMessageDeliveryStatus(dr.getId(), ChatConstants.DS_ACKED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ignore carbon copies of OTR messages sent by broken clients\n\t\t\t\t\t\tif (msg.getBody() != null && msg.getBody().startsWith(\"?OTR\")) {\n\t\t\t\t\t\t\tLog.i(TAG, \"Ignoring OTR carbon from \" + msg.getFrom() + \" to \" + msg.getTo());\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for jabber MUC invitation\n\t\t\t\t\tif(direction == ChatConstants.INCOMING && handleMucInvitation(msg)) {\n\t\t\t\t\t\tsendReceiptIfRequested(packet);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tString chatMessage = msg.getBody();\n\n\t\t\t\t\t// display error inline\n\t\t\t\t\tif (msg.getType() == Message.Type.error) {\n\t\t\t\t\t\tif (changeMessageDeliveryStatus(msg.getPacketID(), ChatConstants.DS_FAILED))\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, msg.getError().toString(), (cc != null), Message.Type.error);\n\t\t\t\t\t\telse if (mucJIDs.contains(msg.getFrom())) {\n\t\t\t\t\t\t\thandleKickedFromMUC(msg.getFrom(), false, null,\n\t\t\t\t\t\t\t\t\tmsg.getError().toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // we do not want to add errors as \"incoming messages\"\n\t\t\t\t\t}\n\n\t\t\t\t\t// ignore empty messages\n\t\t\t\t\tif (chatMessage == null) {\n\t\t\t\t\t\tif (msg.getSubject() != null && msg.getType() == Message.Type.groupchat\n\t\t\t\t\t\t\t\t&& mucJIDs.contains(fromJID[0])) {\n\t\t\t\t\t\t\t// this is a MUC subject, update our DB\n\t\t\t\t\t\t\tContentValues cvR = new ContentValues();\n\t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, msg.getSubject());\n\t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.available.ordinal());\n\t\t\t\t\t\t\tLog.d(TAG, \"MUC subject for \" + fromJID[0] + \" set to: \" + msg.getSubject());\n\t\t\t\t\t\t\tupsertRoster(cvR, fromJID[0]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLog.d(TAG, \"empty message.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// obtain Last Message Correction, if present\n\t\t\t\t\tReplace replace = (Replace)msg.getExtension(Replace.NAMESPACE);\n\t\t\t\t\tString replace_id = (replace != null) ? replace.getId() : null;\n\n\t\t\t\t\t// carbons are old. all others are new\n\t\t\t\t\tint is_new = (cc == null) ? ChatConstants.DS_NEW : ChatConstants.DS_SENT_OR_READ;\n\t\t\t\t\tif (msg.getType() == Message.Type.error)\n\t\t\t\t\t\tis_new = ChatConstants.DS_FAILED;\n\n\t\t\t\t\tboolean is_muc = (msg.getType() == Message.Type.groupchat);\n\t\t\t\t\tboolean is_from_me = (direction == ChatConstants.OUTGOING) ||\n\t\t\t\t\t\t(is_muc && fromJID[1].equals(getMyMucNick(fromJID[0])));\n\n\t\t\t\t\t// handle MUC-PMs: messages from a nick from a known MUC or with\n\t\t\t\t\t// an <x> element\n\t\t\t\t\tMUCUser muc_x = (MUCUser)msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\t\t\t\t\tboolean is_muc_pm = !is_muc  && !TextUtils.isEmpty(fromJID[1]) &&\n\t\t\t\t\t\t\t(muc_x != null || mucJIDs.contains(fromJID[0]));\n\n\t\t\t\t\t// TODO: ignoring 'received' MUC-PM carbons, until XSF sorts out shit:\n\t\t\t\t\t// - if yaxim is in the MUC, it will receive a non-carbonated copy of\n\t\t\t\t\t//   incoming messages, but not of outgoing ones\n\t\t\t\t\t// - if yaxim isn't in the MUC, it can't respond anyway\n\t\t\t\t\tif (is_muc_pm && !is_from_me && cc != null)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tif (is_muc_pm) {\n\t\t\t\t\t\t// store MUC-PMs under the participant's full JID, not bare\n\t\t\t\t\t\t//is_from_me = fromJID[1].equals(getMyMucNick(fromJID[0]));\n\t\t\t\t\t\tfromJID[0] = fromJID[0] + \"/\" + fromJID[1];\n\t\t\t\t\t\tfromJID[1] = null;\n\t\t\t\t\t\tLog.d(TAG, \"MUC-PM: \" + fromJID[0] + \" d=\" + direction + \" fromme=\" + is_from_me);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Carbons and MUC history are 'silent' by default\n\t\t\t\t\tboolean is_silent = (cc != null) || (is_muc && timestamp != null);\n\n\t\t\t\t\tif (!is_muc || checkAddMucMessage(msg, msg.getPacketID(), fromJID, timestamp)) {\n\t\t\t\t\t\taddChatMessageToDB(direction, fromJID, chatMessage, is_new, ts, msg.getPacketID(), replace_id);\n\t\t\t\t\t\t// only notify on private messages or when MUC notification requested\n\t\t\t\t\t\tboolean need_notify = !is_muc || mConfig.needMucNotification(getMyMucNick(fromJID[0]), chatMessage);\n\t\t\t\t\t\t// outgoing carbon -> clear notification by signalling 'null' message\n\t\t\t\t\t\tif (is_from_me) {\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, null, true, msg.getType());\n\t\t\t\t\t\t\t// TODO: MUC PMs\n\t\t\t\t\t\t\tChatHelper.markAsRead(mService, fromJID[0]);\n\t\t\t\t\t\t} else if (direction == ChatConstants.INCOMING && need_notify)\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, chatMessage, is_silent, msg.getType());\n\t\t\t\t\t}\n\t\t\t\t\tsendReceiptIfRequested(packet);\n\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// SMACK silently discards exceptions dropped from processPacket :(\n\t\t\t\t\tLog.e(TAG, \"failed to process packet:\");\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tmXMPPConnection.addPacketListener(mPacketListener, filter);\n\t}", "code_tokens": ["private", "void", "registerMessageListener", "(", ")", "{", "if", "(", "mPacketListener", "!=", "null", ")", "mXMPPConnection", ".", "removePacketListener", "(", "mPacketListener", ")", ";", "PacketTypeFilter", "filter", "=", "new", "PacketTypeFilter", "(", "Message", ".", "class", ")", ";", "mPacketListener", "=", "new", "PacketListener", "(", ")", "{", "public", "void", "processPacket", "(", "Packet", "packet", ")", "{", "try", "{", "if", "(", "packet", "instanceof", "Message", ")", "{", "Message", "msg", "=", "(", "Message", ")", "packet", ";", "String", "[", "]", "fromJID", "=", "getJabberID", "(", "msg", ".", "getFrom", "(", ")", ")", ";", "int", "direction", "=", "ChatConstants", ".", "INCOMING", ";", "Carbon", "cc", "=", "CarbonManager", ".", "getCarbon", "(", "msg", ")", ";", "long", "ts", ";", "DelayInfo", "timestamp", "=", "(", "DelayInfo", ")", "msg", ".", "getExtension", "(", "\"", "delay", "\"", ",", "\"", "urn:xmpp:delay", "\"", ")", ";", "if", "(", "timestamp", "==", "null", ")", "timestamp", "=", "(", "DelayInfo", ")", "msg", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "jabber:x:delay", "\"", ")", ";", "if", "(", "cc", "!=", "null", ")", "timestamp", "=", "cc", ".", "getForwarded", "(", ")", ".", "getDelayInfo", "(", ")", ";", "if", "(", "timestamp", "!=", "null", ")", "ts", "=", "timestamp", ".", "getStamp", "(", ")", ".", "getTime", "(", ")", ";", "else", "ts", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "if", "(", "cc", "!=", "null", ")", "{", "Log", ".", "d", "(", "TAG", ",", "\"", "carbon: ", "\"", "+", "cc", ".", "toXML", "(", ")", ")", ";", "msg", "=", "(", "Message", ")", "cc", ".", "getForwarded", "(", ")", ".", "getForwardedPacket", "(", ")", ";", "if", "(", "cc", ".", "getDirection", "(", ")", "==", "Carbon", ".", "Direction", ".", "sent", ")", "{", "fromJID", "=", "getJabberID", "(", "msg", ".", "getTo", "(", ")", ")", ";", "direction", "=", "ChatConstants", ".", "OUTGOING", ";", "}", "else", "{", "fromJID", "=", "getJabberID", "(", "msg", ".", "getFrom", "(", ")", ")", ";", "DeliveryReceipt", "dr", "=", "(", "DeliveryReceipt", ")", "msg", ".", "getExtension", "(", "DeliveryReceipt", ".", "ELEMENT", ",", "DeliveryReceipt", ".", "NAMESPACE", ")", ";", "if", "(", "dr", "!=", "null", ")", "{", "Log", ".", "d", "(", "TAG", ",", "\"", "got CC'ed delivery receipt for ", "\"", "+", "dr", ".", "getId", "(", ")", ")", ";", "changeMessageDeliveryStatus", "(", "dr", ".", "getId", "(", ")", ",", "ChatConstants", ".", "DS_ACKED", ")", ";", "}", "}", "if", "(", "msg", ".", "getBody", "(", ")", "!=", "null", "&&", "msg", ".", "getBody", "(", ")", ".", "startsWith", "(", "\"", "?OTR", "\"", ")", ")", "{", "Log", ".", "i", "(", "TAG", ",", "\"", "Ignoring OTR carbon from ", "\"", "+", "msg", ".", "getFrom", "(", ")", "+", "\"", " to ", "\"", "+", "msg", ".", "getTo", "(", ")", ")", ";", "return", ";", "}", "}", "if", "(", "direction", "==", "ChatConstants", ".", "INCOMING", "&&", "handleMucInvitation", "(", "msg", ")", ")", "{", "sendReceiptIfRequested", "(", "packet", ")", ";", "return", ";", "}", "String", "chatMessage", "=", "msg", ".", "getBody", "(", ")", ";", "if", "(", "msg", ".", "getType", "(", ")", "==", "Message", ".", "Type", ".", "error", ")", "{", "if", "(", "changeMessageDeliveryStatus", "(", "msg", ".", "getPacketID", "(", ")", ",", "ChatConstants", ".", "DS_FAILED", ")", ")", "mServiceCallBack", ".", "notifyMessage", "(", "fromJID", ",", "msg", ".", "getError", "(", ")", ".", "toString", "(", ")", ",", "(", "cc", "!=", "null", ")", ",", "Message", ".", "Type", ".", "error", ")", ";", "else", "if", "(", "mucJIDs", ".", "contains", "(", "msg", ".", "getFrom", "(", ")", ")", ")", "{", "handleKickedFromMUC", "(", "msg", ".", "getFrom", "(", ")", ",", "false", ",", "null", ",", "msg", ".", "getError", "(", ")", ".", "toString", "(", ")", ")", ";", "}", "return", ";", "}", "if", "(", "chatMessage", "==", "null", ")", "{", "if", "(", "msg", ".", "getSubject", "(", ")", "!=", "null", "&&", "msg", ".", "getType", "(", ")", "==", "Message", ".", "Type", ".", "groupchat", "&&", "mucJIDs", ".", "contains", "(", "fromJID", "[", "0", "]", ")", ")", "{", "ContentValues", "cvR", "=", "new", "ContentValues", "(", ")", ";", "cvR", ".", "put", "(", "RosterProvider", ".", "RosterConstants", ".", "STATUS_MESSAGE", ",", "msg", ".", "getSubject", "(", ")", ")", ";", "cvR", ".", "put", "(", "RosterProvider", ".", "RosterConstants", ".", "STATUS_MODE", ",", "StatusMode", ".", "available", ".", "ordinal", "(", ")", ")", ";", "Log", ".", "d", "(", "TAG", ",", "\"", "MUC subject for ", "\"", "+", "fromJID", "[", "0", "]", "+", "\"", " set to: ", "\"", "+", "msg", ".", "getSubject", "(", ")", ")", ";", "upsertRoster", "(", "cvR", ",", "fromJID", "[", "0", "]", ")", ";", "return", ";", "}", "Log", ".", "d", "(", "TAG", ",", "\"", "empty message.", "\"", ")", ";", "return", ";", "}", "Replace", "replace", "=", "(", "Replace", ")", "msg", ".", "getExtension", "(", "Replace", ".", "NAMESPACE", ")", ";", "String", "replace_id", "=", "(", "replace", "!=", "null", ")", "?", "replace", ".", "getId", "(", ")", ":", "null", ";", "int", "is_new", "=", "(", "cc", "==", "null", ")", "?", "ChatConstants", ".", "DS_NEW", ":", "ChatConstants", ".", "DS_SENT_OR_READ", ";", "if", "(", "msg", ".", "getType", "(", ")", "==", "Message", ".", "Type", ".", "error", ")", "is_new", "=", "ChatConstants", ".", "DS_FAILED", ";", "boolean", "is_muc", "=", "(", "msg", ".", "getType", "(", ")", "==", "Message", ".", "Type", ".", "groupchat", ")", ";", "boolean", "is_from_me", "=", "(", "direction", "==", "ChatConstants", ".", "OUTGOING", ")", "||", "(", "is_muc", "&&", "fromJID", "[", "1", "]", ".", "equals", "(", "getMyMucNick", "(", "fromJID", "[", "0", "]", ")", ")", ")", ";", "MUCUser", "muc_x", "=", "(", "MUCUser", ")", "msg", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "http://jabber.org/protocol/muc#user", "\"", ")", ";", "boolean", "is_muc_pm", "=", "!", "is_muc", "&&", "!", "TextUtils", ".", "isEmpty", "(", "fromJID", "[", "1", "]", ")", "&&", "(", "muc_x", "!=", "null", "||", "mucJIDs", ".", "contains", "(", "fromJID", "[", "0", "]", ")", ")", ";", "if", "(", "is_muc_pm", "&&", "!", "is_from_me", "&&", "cc", "!=", "null", ")", "return", ";", "if", "(", "is_muc_pm", ")", "{", "fromJID", "[", "0", "]", "=", "fromJID", "[", "0", "]", "+", "\"", "/", "\"", "+", "fromJID", "[", "1", "]", ";", "fromJID", "[", "1", "]", "=", "null", ";", "Log", ".", "d", "(", "TAG", ",", "\"", "MUC-PM: ", "\"", "+", "fromJID", "[", "0", "]", "+", "\"", " d=", "\"", "+", "direction", "+", "\"", " fromme=", "\"", "+", "is_from_me", ")", ";", "}", "boolean", "is_silent", "=", "(", "cc", "!=", "null", ")", "||", "(", "is_muc", "&&", "timestamp", "!=", "null", ")", ";", "if", "(", "!", "is_muc", "||", "checkAddMucMessage", "(", "msg", ",", "msg", ".", "getPacketID", "(", ")", ",", "fromJID", ",", "timestamp", ")", ")", "{", "addChatMessageToDB", "(", "direction", ",", "fromJID", ",", "chatMessage", ",", "is_new", ",", "ts", ",", "msg", ".", "getPacketID", "(", ")", ",", "replace_id", ")", ";", "boolean", "need_notify", "=", "!", "is_muc", "||", "mConfig", ".", "needMucNotification", "(", "getMyMucNick", "(", "fromJID", "[", "0", "]", ")", ",", "chatMessage", ")", ";", "if", "(", "is_from_me", ")", "{", "mServiceCallBack", ".", "notifyMessage", "(", "fromJID", ",", "null", ",", "true", ",", "msg", ".", "getType", "(", ")", ")", ";", "ChatHelper", ".", "markAsRead", "(", "mService", ",", "fromJID", "[", "0", "]", ")", ";", "}", "else", "if", "(", "direction", "==", "ChatConstants", ".", "INCOMING", "&&", "need_notify", ")", "mServiceCallBack", ".", "notifyMessage", "(", "fromJID", ",", "chatMessage", ",", "is_silent", ",", "msg", ".", "getType", "(", ")", ")", ";", "}", "sendReceiptIfRequested", "(", "packet", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "Log", ".", "e", "(", "TAG", ",", "\"", "failed to process packet:", "\"", ")", ";", "e", ".", "printStackTrace", "(", ")", ";", "}", "}", "}", ";", "mXMPPConnection", ".", "addPacketListener", "(", "mPacketListener", ",", "filter", ")", ";", "}"], "idx": 11522, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "65a38dc77545d9568732189e86089390f0ceaf9f", "function_name": "registerMessageListener", "body_hash": "4e6e9bad2f7a383058684203c1e8c41bedd15092"}
{"code": "public boolean matchesPassword(String password) {\n        String token = getApiTokenInsecure();\n        return MessageDigest.isEqual(password.getBytes(), token.getBytes());\n    }", "code_tokens": ["public", "boolean", "matchesPassword", "(", "String", "password", ")", "{", "String", "token", "=", "getApiTokenInsecure", "(", ")", ";", "return", "MessageDigest", ".", "isEqual", "(", "password", ".", "getBytes", "(", ")", ",", "token", ".", "getBytes", "(", ")", ")", ";", "}"], "idx": 14795, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "79e0b64322a6b15e0b80ac6511c9aa74383642be", "function_name": "matchesPassword", "body_hash": "dccdadb3867c2075185b31f563ecdfd7d69b84cf"}
{"code": "private static @Nullable User getOrCreate(@Nonnull String id, @Nonnull String fullName, boolean create) {\n        String idkey = idStrategy().keyFor(id);\n\n        byNameLock.readLock().lock();\n        User u;\n        try {\n            u = AllUsers.byName().get(idkey);\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        final File configFile = getConfigFileFor(id);\n        if (u == null && !configFile.isFile() && !configFile.getParentFile().isDirectory()) {\n            // check for legacy users and migrate if safe to do so.\n            File[] legacy = getLegacyConfigFilesFor(id);\n            if (legacy != null && legacy.length > 0) {\n                for (File legacyUserDir : legacy) {\n                    final XmlFile legacyXml = new XmlFile(XSTREAM, new File(legacyUserDir, \"config.xml\"));\n                    try {\n                        Object o = legacyXml.read();\n                        if (o instanceof User) {\n                            if (idStrategy().equals(id, legacyUserDir.getName()) && !idStrategy().filenameOf(legacyUserDir.getName())\n                                    .equals(legacyUserDir.getName())) {\n                                if (!legacyUserDir.renameTo(configFile.getParentFile())) {\n                                    LOGGER.log(Level.WARNING, \"Failed to migrate user record from {0} to {1}\",\n                                            new Object[]{legacyUserDir, configFile.getParentFile()});\n                                }\n                                break;\n                            }\n                        } else {\n                            LOGGER.log(Level.FINE, \"Unexpected object loaded from {0}: {1}\",\n                                    new Object[]{ legacyUserDir, o });\n                        }\n                    } catch (IOException e) {\n                        LOGGER.log(Level.FINE, String.format(\"Exception trying to load user from %s: %s\",\n                                new Object[]{ legacyUserDir, e.getMessage() }), e);\n                    }\n                }\n            }\n        }\n\n        File unsanitizedLegacyConfigFile = getUnsanitizedLegacyConfigFileFor(id);\n        boolean mustMigrateLegacyConfig = isMigrationRequiredForLegacyConfigFile(unsanitizedLegacyConfigFile, configFile);\n        if (mustMigrateLegacyConfig) {\n            File ancestor = unsanitizedLegacyConfigFile.getParentFile();\n            if (!configFile.exists()) {\n                try {\n                    Files.createDirectory(configFile.getParentFile().toPath());\n                    Files.move(unsanitizedLegacyConfigFile.toPath(), configFile.toPath());\n                } catch (IOException | InvalidPathException e) {\n                    LOGGER.log(\n                            Level.WARNING,\n                            String.format(\"Failed to migrate user record from %s to %s, see SECURITY-499 for more information\", idStrategy().legacyFilenameOf(id), idStrategy().filenameOf(id)),\n                            e);\n                }\n            }\n\n            // Don't clean up ancestors with other children; the directories should be cleaned up when the last child\n            // is migrated\n            File tmp = ancestor;\n            try {\n                while (!ancestor.equals(getRootDir())) {\n                    try (DirectoryStream<Path> stream = Files.newDirectoryStream(ancestor.toPath())) {\n                        if (!stream.iterator().hasNext()) {\n                            tmp = ancestor;\n                            ancestor = tmp.getParentFile();\n                            Files.deleteIfExists(tmp.toPath());\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            } catch (IOException | InvalidPathException e) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Could not delete \" + tmp + \" when cleaning up legacy user directories\", e);\n                }\n            }\n        }\n\n        if (u==null && (create || configFile.exists())) {\n            User tmp = new User(id, fullName);\n            User prev;\n            byNameLock.readLock().lock();\n            try {\n                prev = AllUsers.byName().putIfAbsent(idkey, u = tmp);\n            } finally {\n                byNameLock.readLock().unlock();\n            }\n            if (prev != null) {\n                u = prev; // if some has already put a value in the map, use it\n                if (LOGGER.isLoggable(Level.FINE) && !fullName.equals(prev.getFullName())) {\n                    LOGGER.log(Level.FINE, \"mismatch on fullName (\u2018\" + fullName + \"\u2019 vs. \u2018\" + prev.getFullName() + \"\u2019) for \u2018\" + id + \"\u2019\", new Throwable());\n                }\n            } else if (!id.equals(fullName) && !configFile.exists()) {\n                // JENKINS-16332: since the fullName may not be recoverable from the id, and various code may store the id only, we must save the fullName\n                try {\n                    u.save();\n                } catch (IOException x) {\n                    LOGGER.log(Level.WARNING, null, x);\n                }\n            }\n        }\n        return u;\n    }", "code_tokens": ["private", "static", "@", "Nullable", "User", "getOrCreate", "(", "@", "Nonnull", "String", "id", ",", "@", "Nonnull", "String", "fullName", ",", "boolean", "create", ")", "{", "String", "idkey", "=", "idStrategy", "(", ")", ".", "keyFor", "(", "id", ")", ";", "byNameLock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "User", "u", ";", "try", "{", "u", "=", "AllUsers", ".", "byName", "(", ")", ".", "get", "(", "idkey", ")", ";", "}", "finally", "{", "byNameLock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "final", "File", "configFile", "=", "getConfigFileFor", "(", "id", ")", ";", "if", "(", "u", "==", "null", "&&", "!", "configFile", ".", "isFile", "(", ")", "&&", "!", "configFile", ".", "getParentFile", "(", ")", ".", "isDirectory", "(", ")", ")", "{", "File", "[", "]", "legacy", "=", "getLegacyConfigFilesFor", "(", "id", ")", ";", "if", "(", "legacy", "!=", "null", "&&", "legacy", ".", "length", ">", "0", ")", "{", "for", "(", "File", "legacyUserDir", ":", "legacy", ")", "{", "final", "XmlFile", "legacyXml", "=", "new", "XmlFile", "(", "XSTREAM", ",", "new", "File", "(", "legacyUserDir", ",", "\"", "config.xml", "\"", ")", ")", ";", "try", "{", "Object", "o", "=", "legacyXml", ".", "read", "(", ")", ";", "if", "(", "o", "instanceof", "User", ")", "{", "if", "(", "idStrategy", "(", ")", ".", "equals", "(", "id", ",", "legacyUserDir", ".", "getName", "(", ")", ")", "&&", "!", "idStrategy", "(", ")", ".", "filenameOf", "(", "legacyUserDir", ".", "getName", "(", ")", ")", ".", "equals", "(", "legacyUserDir", ".", "getName", "(", ")", ")", ")", "{", "if", "(", "!", "legacyUserDir", ".", "renameTo", "(", "configFile", ".", "getParentFile", "(", ")", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to migrate user record from {0} to {1}", "\"", ",", "new", "Object", "[", "]", "{", "legacyUserDir", ",", "configFile", ".", "getParentFile", "(", ")", "}", ")", ";", "}", "break", ";", "}", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Unexpected object loaded from {0}: {1}", "\"", ",", "new", "Object", "[", "]", "{", "legacyUserDir", ",", "o", "}", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "String", ".", "format", "(", "\"", "Exception trying to load user from %s: %s", "\"", ",", "new", "Object", "[", "]", "{", "legacyUserDir", ",", "e", ".", "getMessage", "(", ")", "}", ")", ",", "e", ")", ";", "}", "}", "}", "}", "File", "unsanitizedLegacyConfigFile", "=", "getUnsanitizedLegacyConfigFileFor", "(", "id", ")", ";", "boolean", "mustMigrateLegacyConfig", "=", "isMigrationRequiredForLegacyConfigFile", "(", "unsanitizedLegacyConfigFile", ",", "configFile", ")", ";", "if", "(", "mustMigrateLegacyConfig", ")", "{", "File", "ancestor", "=", "unsanitizedLegacyConfigFile", ".", "getParentFile", "(", ")", ";", "if", "(", "!", "configFile", ".", "exists", "(", ")", ")", "{", "try", "{", "Files", ".", "createDirectory", "(", "configFile", ".", "getParentFile", "(", ")", ".", "toPath", "(", ")", ")", ";", "Files", ".", "move", "(", "unsanitizedLegacyConfigFile", ".", "toPath", "(", ")", ",", "configFile", ".", "toPath", "(", ")", ")", ";", "}", "catch", "(", "IOException", "|", "InvalidPathException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "String", ".", "format", "(", "\"", "Failed to migrate user record from %s to %s, see SECURITY-499 for more information", "\"", ",", "idStrategy", "(", ")", ".", "legacyFilenameOf", "(", "id", ")", ",", "idStrategy", "(", ")", ".", "filenameOf", "(", "id", ")", ")", ",", "e", ")", ";", "}", "}", "File", "tmp", "=", "ancestor", ";", "try", "{", "while", "(", "!", "ancestor", ".", "equals", "(", "getRootDir", "(", ")", ")", ")", "{", "try", "(", "DirectoryStream", "<", "Path", ">", "stream", "=", "Files", ".", "newDirectoryStream", "(", "ancestor", ".", "toPath", "(", ")", ")", ")", "{", "if", "(", "!", "stream", ".", "iterator", "(", ")", ".", "hasNext", "(", ")", ")", "{", "tmp", "=", "ancestor", ";", "ancestor", "=", "tmp", ".", "getParentFile", "(", ")", ";", "Files", ".", "deleteIfExists", "(", "tmp", ".", "toPath", "(", ")", ")", ";", "}", "else", "{", "break", ";", "}", "}", "}", "}", "catch", "(", "IOException", "|", "InvalidPathException", "e", ")", "{", "if", "(", "LOGGER", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Could not delete ", "\"", "+", "tmp", "+", "\"", " when cleaning up legacy user directories", "\"", ",", "e", ")", ";", "}", "}", "}", "if", "(", "u", "==", "null", "&&", "(", "create", "||", "configFile", ".", "exists", "(", ")", ")", ")", "{", "User", "tmp", "=", "new", "User", "(", "id", ",", "fullName", ")", ";", "User", "prev", ";", "byNameLock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "try", "{", "prev", "=", "AllUsers", ".", "byName", "(", ")", ".", "putIfAbsent", "(", "idkey", ",", "u", "=", "tmp", ")", ";", "}", "finally", "{", "byNameLock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "if", "(", "prev", "!=", "null", ")", "{", "u", "=", "prev", ";", "if", "(", "LOGGER", ".", "isLoggable", "(", "Level", ".", "FINE", ")", "&&", "!", "fullName", ".", "equals", "(", "prev", ".", "getFullName", "(", ")", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "mismatch on fullName (\u2018", "\"", "+", "fullName", "+", "\"", "\u2019 vs. \u2018", "\"", "+", "prev", ".", "getFullName", "(", ")", "+", "\"", "\u2019) for \u2018", "\"", "+", "id", "+", "\"", "\u2019", "\"", ",", "new", "Throwable", "(", ")", ")", ";", "}", "}", "else", "if", "(", "!", "id", ".", "equals", "(", "fullName", ")", "&&", "!", "configFile", ".", "exists", "(", ")", ")", "{", "try", "{", "u", ".", "save", "(", ")", ";", "}", "catch", "(", "IOException", "x", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "null", ",", "x", ")", ";", "}", "}", "}", "return", "u", ";", "}"], "idx": 98808, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "5f4d014b3b7f89e206c6c8509540ed559f604959", "function_name": "getOrCreate", "body_hash": "09fa3b8174e2e4d58a5dadd26c317b87a0e3f202"}
{"code": "public String scanPseudoAttribute(boolean scanningTextDecl, \n                                      XMLString value) \n        throws IOException, XNIException {\n\n        // REVISIT: This method is used for generic scanning of \n        // pseudo attributes, but since there are only three such\n        // attributes: version, encoding, and standalone there are\n        // for performant ways of scanning them. Every decl must\n        // have a version, and in TextDecls this version must\n        // be followed by an encoding declaration. Also the\n        // methods we invoke on the scanners allow non-ASCII\n        // characters to be parsed in the decls, but since\n        // we don't even know what the actual encoding of the\n        // document is until we scan the encoding declaration\n        // you cannot reliably read any characters outside\n        // of the ASCII range here. -- mrglavas\n        String name = scanPseudoAttributeName();\n        XMLEntityManager.print(fEntityManager.getCurrentEntity());\n        if (name == null) {\n            reportFatalError(\"PseudoAttrNameExpected\", null);\n        }\n        fEntityScanner.skipDeclSpaces();\n        if (!fEntityScanner.skipChar('=')) {\n            reportFatalError(scanningTextDecl ? \"EqRequiredInTextDecl\"\n                             : \"EqRequiredInXMLDecl\", new Object[]{name});\n        }\n        fEntityScanner.skipDeclSpaces();\n        int quote = fEntityScanner.peekChar();\n        if (quote != '\\'' && quote != '\"') {\n            reportFatalError(scanningTextDecl ? \"QuoteRequiredInTextDecl\"\n                             : \"QuoteRequiredInXMLDecl\" , new Object[]{name});\n        }\n        fEntityScanner.scanChar();\n        int c = fEntityScanner.scanLiteral(quote, value);\n        if (c != quote) {\n            fStringBuffer2.clear();\n            do {\n                fStringBuffer2.append(value);\n                if (c != -1) {\n                    if (c == '&' || c == '%' || c == '<' || c == ']') {\n                        fStringBuffer2.append((char)fEntityScanner.scanChar());\n                    }\n                    // REVISIT: Even if you could reliably read non-ASCII chars\n                    // why bother scanning for surrogates here? Only ASCII chars\n                    // match the productions in XMLDecls and TextDecls. -- mrglavas\n                    else if (XMLChar.isHighSurrogate(c)) {\n                        scanSurrogates(fStringBuffer2);\n                    }\n                    else if (isInvalidLiteral(c)) {\n                        String key = scanningTextDecl\n                            ? \"InvalidCharInTextDecl\" : \"InvalidCharInXMLDecl\";\n                        reportFatalError(key,\n                                       new Object[] {Integer.toString(c, 16)});\n                        fEntityScanner.scanChar();\n                    }\n                }\n                c = fEntityScanner.scanLiteral(quote, value);\n            } while (c != quote);\n            fStringBuffer2.append(value);\n            value.setValues(fStringBuffer2);\n        }\n        if (!fEntityScanner.skipChar(quote)) {\n            reportFatalError(scanningTextDecl ? \"CloseQuoteMissingInTextDecl\"\n                             : \"CloseQuoteMissingInXMLDecl\",\n                             new Object[]{name});\n        }\n\n        // return\n        return name;\n\n    }", "code_tokens": ["public", "String", "scanPseudoAttribute", "(", "boolean", "scanningTextDecl", ",", "XMLString", "value", ")", "throws", "IOException", ",", "XNIException", "{", "String", "name", "=", "scanPseudoAttributeName", "(", ")", ";", "XMLEntityManager", ".", "print", "(", "fEntityManager", ".", "getCurrentEntity", "(", ")", ")", ";", "if", "(", "name", "==", "null", ")", "{", "reportFatalError", "(", "\"", "PseudoAttrNameExpected", "\"", ",", "null", ")", ";", "}", "fEntityScanner", ".", "skipDeclSpaces", "(", ")", ";", "if", "(", "!", "fEntityScanner", ".", "skipChar", "(", "'='", ")", ")", "{", "reportFatalError", "(", "scanningTextDecl", "?", "\"", "EqRequiredInTextDecl", "\"", ":", "\"", "EqRequiredInXMLDecl", "\"", ",", "new", "Object", "[", "]", "{", "name", "}", ")", ";", "}", "fEntityScanner", ".", "skipDeclSpaces", "(", ")", ";", "int", "quote", "=", "fEntityScanner", ".", "peekChar", "(", ")", ";", "if", "(", "quote", "!=", "'\\''", "&&", "quote", "!=", "'\"'", ")", "{", "reportFatalError", "(", "scanningTextDecl", "?", "\"", "QuoteRequiredInTextDecl", "\"", ":", "\"", "QuoteRequiredInXMLDecl", "\"", ",", "new", "Object", "[", "]", "{", "name", "}", ")", ";", "}", "fEntityScanner", ".", "scanChar", "(", ")", ";", "int", "c", "=", "fEntityScanner", ".", "scanLiteral", "(", "quote", ",", "value", ")", ";", "if", "(", "c", "!=", "quote", ")", "{", "fStringBuffer2", ".", "clear", "(", ")", ";", "do", "{", "fStringBuffer2", ".", "append", "(", "value", ")", ";", "if", "(", "c", "!=", "-", "1", ")", "{", "if", "(", "c", "==", "'&'", "||", "c", "==", "'%'", "||", "c", "==", "'<'", "||", "c", "==", "']'", ")", "{", "fStringBuffer2", ".", "append", "(", "(", "char", ")", "fEntityScanner", ".", "scanChar", "(", ")", ")", ";", "}", "else", "if", "(", "XMLChar", ".", "isHighSurrogate", "(", "c", ")", ")", "{", "scanSurrogates", "(", "fStringBuffer2", ")", ";", "}", "else", "if", "(", "isInvalidLiteral", "(", "c", ")", ")", "{", "String", "key", "=", "scanningTextDecl", "?", "\"", "InvalidCharInTextDecl", "\"", ":", "\"", "InvalidCharInXMLDecl", "\"", ";", "reportFatalError", "(", "key", ",", "new", "Object", "[", "]", "{", "Integer", ".", "toString", "(", "c", ",", "16", ")", "}", ")", ";", "fEntityScanner", ".", "scanChar", "(", ")", ";", "}", "}", "c", "=", "fEntityScanner", ".", "scanLiteral", "(", "quote", ",", "value", ")", ";", "}", "while", "(", "c", "!=", "quote", ")", ";", "fStringBuffer2", ".", "append", "(", "value", ")", ";", "value", ".", "setValues", "(", "fStringBuffer2", ")", ";", "}", "if", "(", "!", "fEntityScanner", ".", "skipChar", "(", "quote", ")", ")", "{", "reportFatalError", "(", "scanningTextDecl", "?", "\"", "CloseQuoteMissingInTextDecl", "\"", ":", "\"", "CloseQuoteMissingInXMLDecl", "\"", ",", "new", "Object", "[", "]", "{", "name", "}", ")", ";", "}", "return", "name", ";", "}"], "idx": 103677, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "266e837852e0f0e3c8c1ad572b6fc4dbb4ded17", "function_name": "scanPseudoAttribute", "body_hash": "3b6b4924998e4decce884b01711c2b9feef7155a"}
{"code": "static protected UTF8Buffer readUTF(DataByteArrayInputStream is) throws ProtocolException {\n        int size = is.readUnsignedShort();\n        Buffer buffer = is.readBuffer(size);\n        if (buffer == null || buffer.length != size) {\n            throw new ProtocolException(\"Invalid message encoding\");\n        }\n        return buffer.utf8();\n    }", "code_tokens": ["static", "protected", "UTF8Buffer", "readUTF", "(", "DataByteArrayInputStream", "is", ")", "throws", "ProtocolException", "{", "int", "size", "=", "is", ".", "readUnsignedShort", "(", ")", ";", "Buffer", "buffer", "=", "is", ".", "readBuffer", "(", "size", ")", ";", "if", "(", "buffer", "==", "null", "||", "buffer", ".", "length", "!=", "size", ")", "{", "throw", "new", "ProtocolException", "(", "\"", "Invalid message encoding", "\"", ")", ";", "}", "return", "buffer", ".", "utf8", "(", ")", ";", "}"], "idx": 102079, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "2898f10be758decdc85ba6c523cb5be6b9092855", "function_name": "readUTF", "body_hash": "057a33edd8ee17b5b667fa0d892d39d2a159129e"}
{"code": "private Page<TaskExecution> queryForPageableResults(Pageable pageable,\n\t\t\tString selectClause, String fromClause, String whereClause,\n\t\t\tMapSqlParameterSource queryParameters, long totalCount) {\n\t\tSqlPagingQueryProviderFactoryBean factoryBean = new SqlPagingQueryProviderFactoryBean();\n\t\tfactoryBean.setSelectClause(selectClause);\n\t\tfactoryBean.setFromClause(fromClause);\n\t\tif (StringUtils.hasText(whereClause)) {\n\t\t\tfactoryBean.setWhereClause(whereClause);\n\t\t}\n\t\tfinal Sort sort = pageable.getSort();\n\t\tfinal LinkedHashMap<String, Order> sortOrderMap = new LinkedHashMap<>();\n\n\t\tif (sort != null) {\n\t\t\tfor (Sort.Order sortOrder : sort) {\n\t\t\t\tif (validSortColumns.contains(sortOrder.getProperty().toUpperCase())) {\n\t\t\t\t\tsortOrderMap.put(sortOrder.getProperty(),\n\t\t\t\t\t\t\tsortOrder.isAscending() ? Order.ASCENDING : Order.DESCENDING);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\t\t\"Invalid sort option selected: %s\", sortOrder.getProperty()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(sortOrderMap)) {\n\t\t\tfactoryBean.setSortKeys(sortOrderMap);\n\t\t}\n\t\telse {\n\t\t\tfactoryBean.setSortKeys(this.orderMap);\n\t\t}\n\n\t\tfactoryBean.setDataSource(this.dataSource);\n\t\tPagingQueryProvider pagingQueryProvider;\n\t\ttry {\n\t\t\tpagingQueryProvider = factoryBean.getObject();\n\t\t\tpagingQueryProvider.init(this.dataSource);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tString query = pagingQueryProvider.getPageQuery(pageable);\n\t\tList<TaskExecution> resultList = this.jdbcTemplate.query(getQuery(query),\n\t\t\t\tqueryParameters, new TaskExecutionRowMapper());\n\t\treturn new PageImpl<>(resultList, pageable, totalCount);\n\t}", "code_tokens": ["private", "Page", "<", "TaskExecution", ">", "queryForPageableResults", "(", "Pageable", "pageable", ",", "String", "selectClause", ",", "String", "fromClause", ",", "String", "whereClause", ",", "MapSqlParameterSource", "queryParameters", ",", "long", "totalCount", ")", "{", "SqlPagingQueryProviderFactoryBean", "factoryBean", "=", "new", "SqlPagingQueryProviderFactoryBean", "(", ")", ";", "factoryBean", ".", "setSelectClause", "(", "selectClause", ")", ";", "factoryBean", ".", "setFromClause", "(", "fromClause", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "whereClause", ")", ")", "{", "factoryBean", ".", "setWhereClause", "(", "whereClause", ")", ";", "}", "final", "Sort", "sort", "=", "pageable", ".", "getSort", "(", ")", ";", "final", "LinkedHashMap", "<", "String", ",", "Order", ">", "sortOrderMap", "=", "new", "LinkedHashMap", "<", ">", "(", ")", ";", "if", "(", "sort", "!=", "null", ")", "{", "for", "(", "Sort", ".", "Order", "sortOrder", ":", "sort", ")", "{", "if", "(", "validSortColumns", ".", "contains", "(", "sortOrder", ".", "getProperty", "(", ")", ".", "toUpperCase", "(", ")", ")", ")", "{", "sortOrderMap", ".", "put", "(", "sortOrder", ".", "getProperty", "(", ")", ",", "sortOrder", ".", "isAscending", "(", ")", "?", "Order", ".", "ASCENDING", ":", "Order", ".", "DESCENDING", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "String", ".", "format", "(", "\"", "Invalid sort option selected: %s", "\"", ",", "sortOrder", ".", "getProperty", "(", ")", ")", ")", ";", "}", "}", "}", "if", "(", "!", "CollectionUtils", ".", "isEmpty", "(", "sortOrderMap", ")", ")", "{", "factoryBean", ".", "setSortKeys", "(", "sortOrderMap", ")", ";", "}", "else", "{", "factoryBean", ".", "setSortKeys", "(", "this", ".", "orderMap", ")", ";", "}", "factoryBean", ".", "setDataSource", "(", "this", ".", "dataSource", ")", ";", "PagingQueryProvider", "pagingQueryProvider", ";", "try", "{", "pagingQueryProvider", "=", "factoryBean", ".", "getObject", "(", ")", ";", "pagingQueryProvider", ".", "init", "(", "this", ".", "dataSource", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "String", "query", "=", "pagingQueryProvider", ".", "getPageQuery", "(", "pageable", ")", ";", "List", "<", "TaskExecution", ">", "resultList", "=", "this", ".", "jdbcTemplate", ".", "query", "(", "getQuery", "(", "query", ")", ",", "queryParameters", ",", "new", "TaskExecutionRowMapper", "(", ")", ")", ";", "return", "new", "PageImpl", "<", ">", "(", "resultList", ",", "pageable", ",", "totalCount", ")", ";", "}"], "idx": 92635, "cwe": "CWE-89", "target": 0, "status": "FIXED", "commit": "25592edb004eb5b059e9a093658437b18cff0979", "function_name": "queryForPageableResults", "body_hash": "492377a8b483cd6cf7f450253ac39d42901495fb"}
{"code": "public static boolean isStaxSource(Source source) {\n\t\treturn ((source instanceof StaxSource) || (jaxp14Available && Jaxp14StaxHandler.isStaxSource(source)));\n\t}", "code_tokens": ["public", "static", "boolean", "isStaxSource", "(", "Source", "source", ")", "{", "return", "(", "(", "source", "instanceof", "StaxSource", ")", "||", "(", "jaxp14Available", "&&", "Jaxp14StaxHandler", ".", "isStaxSource", "(", "source", ")", ")", ")", ";", "}"], "idx": 45451, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "7387cb990e35b0f1b573faf29d4f9ae183d7a5e", "function_name": "isStaxSource", "body_hash": "87fe3ff5f475fadedf98e524e2234c0b80184096"}
{"code": "private Ccm parseCCMXmlFile(InputStream ccmXmlFile) throws IOException, SAXException {\n\t\tDigester digester = new Digester();\n\t\tdigester.setValidating(false);\n\t\tdigester.setClassLoader(CcmParser.class.getClassLoader());\n\n\t\tString rootXPath = \"ccm\";\n\t\tdigester.addObjectCreate(rootXPath, Ccm.class);\n\t\tdigester.addSetProperties(rootXPath);\n\n\t\tString fileMetric = \"ccm/metric\";\n\t\tdigester.addObjectCreate(fileMetric, Metric.class);\n\t\tdigester.addSetProperties(fileMetric);\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/complexity\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/unit\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/classification\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/file\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/startLineNumber\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/endLineNumber\");\n\t\tdigester.addSetNext(fileMetric, \"addMetric\", Metric.class.getName());\n\n\t\treturn (Ccm)digester.parse(ccmXmlFile);\n\t}", "code_tokens": ["private", "Ccm", "parseCCMXmlFile", "(", "InputStream", "ccmXmlFile", ")", "throws", "IOException", ",", "SAXException", "{", "Digester", "digester", "=", "new", "Digester", "(", ")", ";", "digester", ".", "setValidating", "(", "false", ")", ";", "digester", ".", "setClassLoader", "(", "CcmParser", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "String", "rootXPath", "=", "\"", "ccm", "\"", ";", "digester", ".", "addObjectCreate", "(", "rootXPath", ",", "Ccm", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "rootXPath", ")", ";", "String", "fileMetric", "=", "\"", "ccm/metric", "\"", ";", "digester", ".", "addObjectCreate", "(", "fileMetric", ",", "Metric", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "fileMetric", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/complexity", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/unit", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/classification", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/file", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/startLineNumber", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "ccm/metric/endLineNumber", "\"", ")", ";", "digester", ".", "addSetNext", "(", "fileMetric", ",", "\"", "addMetric", "\"", ",", "Metric", ".", "class", ".", "getName", "(", ")", ")", ";", "return", "(", "Ccm", ")", "digester", ".", "parse", "(", "ccmXmlFile", ")", ";", "}"], "idx": 69279, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "066cb43b4413b3490d822ec8b8a32072ebd213ca", "function_name": "parseCCMXmlFile", "body_hash": "70c9133049e9dbe79d297e076c80de5e8fa5f40e"}
{"code": "protected XStream createXStream(ClassResolver resolver, ClassLoader classLoader) {\n        if (xstreamDriver != null) {\n            xstream = new XStream(xstreamDriver);\n        } else {\n            xstream = new XStream();\n        }\n\n        if (mode != null) {\n            xstream.setMode(getModeFromString(mode));\n        }\n\n        ClassLoader xstreamLoader = xstream.getClassLoader();\n        if (classLoader != null && xstreamLoader instanceof CompositeClassLoader) {\n            ((CompositeClassLoader) xstreamLoader).add(classLoader);\n        }\n\n        try {\n            if (this.implicitCollections != null) {\n                for (Entry<String, String[]> entry : this.implicitCollections.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.addImplicitCollection(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.aliases != null) {\n                for (Entry<String, String> entry : this.aliases.entrySet()) {\n                    xstream.alias(entry.getKey(), resolver.resolveMandatoryClass(entry.getValue()));\n                    // It can turn the auto-detection mode off\n                    xstream.processAnnotations(resolver.resolveMandatoryClass(entry.getValue()));\n                }\n            }\n\n            if (this.omitFields != null) {\n                for (Entry<String, String[]> entry : this.omitFields.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.omitField(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.converters != null) {\n                for (String name : this.converters) {\n                    Class<Converter> converterClass = resolver.resolveMandatoryClass(name, Converter.class);\n                    Converter converter;\n\n                    Constructor<Converter> con = null;\n                    try {\n                        con = converterClass.getDeclaredConstructor(new Class[]{XStream.class});\n                    } catch (Exception e) {\n                        //swallow as we null check in a moment.\n                    }\n                    if (con != null) {\n                        converter = con.newInstance(xstream);\n                    } else {\n                        converter = converterClass.newInstance();\n                        try {\n                            Method method = converterClass.getMethod(\"setXStream\", new Class[]{XStream.class});\n                            if (method != null) {\n                                ObjectHelper.invokeMethod(method, converter, xstream);\n                            }\n                        } catch (Throwable e) {\n                            // swallow, as it just means the user never add an XStream setter, which is optional\n                        }\n                    }\n\n                    xstream.registerConverter(converter);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to build XStream instance\", e);\n        }\n\n        return xstream;\n    }", "code_tokens": ["protected", "XStream", "createXStream", "(", "ClassResolver", "resolver", ",", "ClassLoader", "classLoader", ")", "{", "if", "(", "xstreamDriver", "!=", "null", ")", "{", "xstream", "=", "new", "XStream", "(", "xstreamDriver", ")", ";", "}", "else", "{", "xstream", "=", "new", "XStream", "(", ")", ";", "}", "if", "(", "mode", "!=", "null", ")", "{", "xstream", ".", "setMode", "(", "getModeFromString", "(", "mode", ")", ")", ";", "}", "ClassLoader", "xstreamLoader", "=", "xstream", ".", "getClassLoader", "(", ")", ";", "if", "(", "classLoader", "!=", "null", "&&", "xstreamLoader", "instanceof", "CompositeClassLoader", ")", "{", "(", "(", "CompositeClassLoader", ")", "xstreamLoader", ")", ".", "add", "(", "classLoader", ")", ";", "}", "try", "{", "if", "(", "this", ".", "implicitCollections", "!=", "null", ")", "{", "for", "(", "Entry", "<", "String", ",", "String", "[", "]", ">", "entry", ":", "this", ".", "implicitCollections", ".", "entrySet", "(", ")", ")", "{", "for", "(", "String", "name", ":", "entry", ".", "getValue", "(", ")", ")", "{", "xstream", ".", "addImplicitCollection", "(", "resolver", ".", "resolveMandatoryClass", "(", "entry", ".", "getKey", "(", ")", ")", ",", "name", ")", ";", "}", "}", "}", "if", "(", "this", ".", "aliases", "!=", "null", ")", "{", "for", "(", "Entry", "<", "String", ",", "String", ">", "entry", ":", "this", ".", "aliases", ".", "entrySet", "(", ")", ")", "{", "xstream", ".", "alias", "(", "entry", ".", "getKey", "(", ")", ",", "resolver", ".", "resolveMandatoryClass", "(", "entry", ".", "getValue", "(", ")", ")", ")", ";", "xstream", ".", "processAnnotations", "(", "resolver", ".", "resolveMandatoryClass", "(", "entry", ".", "getValue", "(", ")", ")", ")", ";", "}", "}", "if", "(", "this", ".", "omitFields", "!=", "null", ")", "{", "for", "(", "Entry", "<", "String", ",", "String", "[", "]", ">", "entry", ":", "this", ".", "omitFields", ".", "entrySet", "(", ")", ")", "{", "for", "(", "String", "name", ":", "entry", ".", "getValue", "(", ")", ")", "{", "xstream", ".", "omitField", "(", "resolver", ".", "resolveMandatoryClass", "(", "entry", ".", "getKey", "(", ")", ")", ",", "name", ")", ";", "}", "}", "}", "if", "(", "this", ".", "converters", "!=", "null", ")", "{", "for", "(", "String", "name", ":", "this", ".", "converters", ")", "{", "Class", "<", "Converter", ">", "converterClass", "=", "resolver", ".", "resolveMandatoryClass", "(", "name", ",", "Converter", ".", "class", ")", ";", "Converter", "converter", ";", "Constructor", "<", "Converter", ">", "con", "=", "null", ";", "try", "{", "con", "=", "converterClass", ".", "getDeclaredConstructor", "(", "new", "Class", "[", "]", "{", "XStream", ".", "class", "}", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "}", "if", "(", "con", "!=", "null", ")", "{", "converter", "=", "con", ".", "newInstance", "(", "xstream", ")", ";", "}", "else", "{", "converter", "=", "converterClass", ".", "newInstance", "(", ")", ";", "try", "{", "Method", "method", "=", "converterClass", ".", "getMethod", "(", "\"", "setXStream", "\"", ",", "new", "Class", "[", "]", "{", "XStream", ".", "class", "}", ")", ";", "if", "(", "method", "!=", "null", ")", "{", "ObjectHelper", ".", "invokeMethod", "(", "method", ",", "converter", ",", "xstream", ")", ";", "}", "}", "catch", "(", "Throwable", "e", ")", "{", "}", "}", "xstream", ".", "registerConverter", "(", "converter", ")", ";", "}", "}", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to build XStream instance", "\"", ",", "e", ")", ";", "}", "return", "xstream", ";", "}"], "idx": 3609, "cwe": "CWE-19", "target": 1, "status": "VULNERABLE", "commit": "4491c080cb6c8659fc05441e49307b7d4349aa56", "function_name": "createXStream", "body_hash": "c6414540f7b53060226d8e31a27d9131dfc76938"}
{"code": "@Override\r\n\tprotected void configure() {\r\n\t\tsuper.configure();\r\n\t\t\r\n\t\tbind(JettyRunner.class).to(DefaultJettyRunner.class);\r\n\t\tbind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);\r\n\t\t\r\n\t\tbind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);\r\n\t\t\r\n\t\tbind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic ValidatorFactory get() {\r\n\t\t\t\tConfiguration<?> configuration = Validation.byDefaultProvider().configure();\r\n\t\t\t\treturn configuration.buildValidatorFactory();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}).in(Singleton.class);\r\n\t\t\r\n\t\tbind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);\r\n\r\n\t\t// configure markdown\r\n\t\tbind(MarkdownManager.class).to(DefaultMarkdownManager.class);\t\t\r\n\t\t\r\n\t\tconfigurePersistence();\r\n\t\tconfigureRestServices();\r\n\t\tconfigureWeb();\r\n\t\tconfigureBuild();\r\n\t\t\r\n\t\tbind(GitConfig.class).toProvider(GitConfigProvider.class);\r\n\r\n\t\t/*\r\n\t\t * Declare bindings explicitly instead of using ImplementedBy annotation as\r\n\t\t * HK2 to guice bridge can only search in explicit bindings in Guice   \r\n\t\t */\r\n\t\tbind(StorageManager.class).to(DefaultStorageManager.class);\r\n\t\tbind(SettingManager.class).to(DefaultSettingManager.class);\r\n\t\tbind(DataManager.class).to(DefaultDataManager.class);\r\n\t\tbind(TaskScheduler.class).to(DefaultTaskScheduler.class);\r\n\t\tbind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);\r\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\r\n\t\tbind(PullRequestManager.class).to(DefaultPullRequestManager.class);\r\n\t\tbind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);\r\n\t\tbind(ProjectManager.class).to(DefaultProjectManager.class);\r\n\t\tbind(UserManager.class).to(DefaultUserManager.class);\r\n\t\tbind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);\r\n\t\tbind(BuildManager.class).to(DefaultBuildManager.class);\r\n\t\tbind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);\r\n\t\tbind(JobManager.class).to(DefaultJobManager.class);\r\n\t\tbind(LogManager.class).to(DefaultLogManager.class);\r\n\t\tbind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);\r\n\t\tbind(MailManager.class).to(DefaultMailManager.class);\r\n\t\tbind(IssueManager.class).to(DefaultIssueManager.class);\r\n\t\tbind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);\r\n\t\tbind(BuildParamManager.class).to(DefaultBuildParamManager.class);\r\n\t\tbind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);\r\n\t\tbind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);\r\n\t\tbind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);\r\n\t\tbind(RoleManager.class).to(DefaultRoleManager.class);\r\n\t\tbind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);\r\n\t\tbind(UserInfoManager.class).to(DefaultUserInfoManager.class);\r\n\t\tbind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);\r\n\t\tbind(GroupManager.class).to(DefaultGroupManager.class);\r\n\t\tbind(MembershipManager.class).to(DefaultMembershipManager.class);\r\n\t\tbind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);\r\n\t\tbind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);\r\n\t\tbind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);\r\n\t\tbind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);\r\n\t\tbind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);\r\n\t\tbind(WorkExecutor.class).to(DefaultWorkExecutor.class);\r\n\t\tbind(PullRequestNotificationManager.class);\r\n\t\tbind(CommitNotificationManager.class);\r\n\t\tbind(BuildNotificationManager.class);\r\n\t\tbind(IssueNotificationManager.class);\r\n\t\tbind(EntityReferenceManager.class);\r\n\t\tbind(CodeCommentNotificationManager.class);\r\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\r\n\t\tbind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);\r\n\t\tbind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);\r\n\t\tbind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);\r\n\t\tbind(MilestoneManager.class).to(DefaultMilestoneManager.class);\r\n\t\tbind(Session.class).toProvider(SessionProvider.class);\r\n\t\tbind(EntityManager.class).toProvider(SessionProvider.class);\r\n\t\tbind(SessionFactory.class).toProvider(SessionFactoryProvider.class);\r\n\t\tbind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);\r\n\t\tbind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);\r\n\t\tbind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);\r\n\t\tbind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);\r\n\t\tbind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);\r\n\t\tbind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);\r\n\t\tbind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);\r\n\t\tbind(WebHookManager.class);\r\n\r\n\t\tcontribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);\r\n\t    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);\r\n\t    \r\n\t\tbind(Realm.class).to(OneAuthorizingRealm.class);\r\n\t\tbind(RememberMeManager.class).to(OneRememberMeManager.class);\r\n\t\tbind(WebSecurityManager.class).to(OneWebSecurityManager.class);\r\n\t\tbind(FilterChainResolver.class).to(OneFilterChainResolver.class);\r\n\t\tbind(BasicAuthenticationFilter.class);\r\n\t\tbind(PasswordService.class).to(OnePasswordService.class);\r\n\t\tbind(ShiroFilter.class);\r\n\t\tinstall(new ShiroAopModule());\r\n        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {\r\n\r\n            @Override\r\n            public void configure(FilterChainManager filterChainManager) {\r\n                filterChainManager.createChain(\"/**/info/refs\", \"noSessionCreation, authcBasic\");\r\n                filterChainManager.createChain(\"/**/git-upload-pack\", \"noSessionCreation, authcBasic\");\r\n                filterChainManager.createChain(\"/**/git-receive-pack\", \"noSessionCreation, authcBasic\");\r\n            }\r\n            \r\n        });\r\n        contributeFromPackage(Authenticator.class, Authenticator.class);\r\n        \r\n\t\tcontribute(ImplementationProvider.class, new ImplementationProvider() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic Class<?> getAbstractClass() {\r\n\t\t\t\treturn JobExecutor.class;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic Collection<Class<?>> getImplementations() {\r\n\t\t\t\treturn Sets.newHashSet(AutoDiscoveredJobExecutor.class);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\tcontribute(CodePullAuthorizationSource.class, DefaultJobManager.class);\r\n        \r\n\t\tbind(IndexManager.class).to(DefaultIndexManager.class);\r\n\t\tbind(SearchManager.class).to(DefaultSearchManager.class);\r\n\t\t\r\n\t\tbind(EntityValidator.class).to(DefaultEntityValidator.class);\r\n\t\t\r\n\t\tbind(GitFilter.class);\r\n\t\tbind(GitPreReceiveCallback.class);\r\n\t\tbind(GitPostReceiveCallback.class);\r\n\t\t\r\n\t    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic ExecutorService get() {\r\n\t\t        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, \r\n\t\t        \t\tnew SynchronousQueue<Runnable>()) {\r\n\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void execute(Runnable command) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(command));\r\n\t\t\t\t\t\t} catch (RejectedExecutionException e) {\r\n\t\t\t\t\t\t\tif (!isShutdown())\r\n\t\t\t\t\t\t\t\tthrow ExceptionUtils.unchecked(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t        };\r\n\t\t\t}\r\n\t    \t\r\n\t    }).in(Singleton.class);\r\n\t    \r\n\t    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic ForkJoinTask<?> submit(Runnable task) {\r\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void execute(Runnable task) {\r\n\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(task));\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> ForkJoinTask<T> submit(Callable<T> task) {\r\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> ForkJoinTask<T> submit(Runnable task, T result) {\r\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task), result);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)\r\n\t\t\t\t\tthrows InterruptedException, ExecutionException {\r\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks));\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\r\n\t\t\t\t\tthrows InterruptedException, ExecutionException, TimeoutException {\r\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, \r\n\t\t\t\t\tlong timeout, TimeUnit unit) throws InterruptedException {\r\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\r\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks));\r\n\t\t\t}\r\n\r\n\t    });\r\n\t}", "code_tokens": ["@", "Override", "protected", "void", "configure", "(", ")", "{", "super", ".", "configure", "(", ")", ";", "bind", "(", "JettyRunner", ".", "class", ")", ".", "to", "(", "DefaultJettyRunner", ".", "class", ")", ";", "bind", "(", "ServletContextHandler", ".", "class", ")", ".", "toProvider", "(", "DefaultJettyRunner", ".", "class", ")", ";", "bind", "(", "ObjectMapper", ".", "class", ")", ".", "toProvider", "(", "ObjectMapperProvider", ".", "class", ")", ".", "in", "(", "Singleton", ".", "class", ")", ";", "bind", "(", "ValidatorFactory", ".", "class", ")", ".", "toProvider", "(", "new", "com", ".", "google", ".", "inject", ".", "Provider", "<", "ValidatorFactory", ">", "(", ")", "{", "@", "Override", "public", "ValidatorFactory", "get", "(", ")", "{", "Configuration", "<", "?", ">", "configuration", "=", "Validation", ".", "byDefaultProvider", "(", ")", ".", "configure", "(", ")", ";", "return", "configuration", ".", "buildValidatorFactory", "(", ")", ";", "}", "}", ")", ".", "in", "(", "Singleton", ".", "class", ")", ";", "bind", "(", "Validator", ".", "class", ")", ".", "toProvider", "(", "ValidatorProvider", ".", "class", ")", ".", "in", "(", "Singleton", ".", "class", ")", ";", "bind", "(", "MarkdownManager", ".", "class", ")", ".", "to", "(", "DefaultMarkdownManager", ".", "class", ")", ";", "configurePersistence", "(", ")", ";", "configureRestServices", "(", ")", ";", "configureWeb", "(", ")", ";", "configureBuild", "(", ")", ";", "bind", "(", "GitConfig", ".", "class", ")", ".", "toProvider", "(", "GitConfigProvider", ".", "class", ")", ";", "bind", "(", "StorageManager", ".", "class", ")", ".", "to", "(", "DefaultStorageManager", ".", "class", ")", ";", "bind", "(", "SettingManager", ".", "class", ")", ".", "to", "(", "DefaultSettingManager", ".", "class", ")", ";", "bind", "(", "DataManager", ".", "class", ")", ".", "to", "(", "DefaultDataManager", ".", "class", ")", ";", "bind", "(", "TaskScheduler", ".", "class", ")", ".", "to", "(", "DefaultTaskScheduler", ".", "class", ")", ";", "bind", "(", "PullRequestCommentManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestCommentManager", ".", "class", ")", ";", "bind", "(", "CodeCommentManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentManager", ".", "class", ")", ";", "bind", "(", "PullRequestManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestManager", ".", "class", ")", ";", "bind", "(", "PullRequestUpdateManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestUpdateManager", ".", "class", ")", ";", "bind", "(", "ProjectManager", ".", "class", ")", ".", "to", "(", "DefaultProjectManager", ".", "class", ")", ";", "bind", "(", "UserManager", ".", "class", ")", ".", "to", "(", "DefaultUserManager", ".", "class", ")", ";", "bind", "(", "PullRequestReviewManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestReviewManager", ".", "class", ")", ";", "bind", "(", "BuildManager", ".", "class", ")", ".", "to", "(", "DefaultBuildManager", ".", "class", ")", ";", "bind", "(", "BuildDependenceManager", ".", "class", ")", ".", "to", "(", "DefaultBuildDependenceManager", ".", "class", ")", ";", "bind", "(", "JobManager", ".", "class", ")", ".", "to", "(", "DefaultJobManager", ".", "class", ")", ";", "bind", "(", "LogManager", ".", "class", ")", ".", "to", "(", "DefaultLogManager", ".", "class", ")", ";", "bind", "(", "PullRequestBuildManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestBuildManager", ".", "class", ")", ";", "bind", "(", "MailManager", ".", "class", ")", ".", "to", "(", "DefaultMailManager", ".", "class", ")", ";", "bind", "(", "IssueManager", ".", "class", ")", ".", "to", "(", "DefaultIssueManager", ".", "class", ")", ";", "bind", "(", "IssueFieldManager", ".", "class", ")", ".", "to", "(", "DefaultIssueFieldManager", ".", "class", ")", ";", "bind", "(", "BuildParamManager", ".", "class", ")", ".", "to", "(", "DefaultBuildParamManager", ".", "class", ")", ";", "bind", "(", "UserAuthorizationManager", ".", "class", ")", ".", "to", "(", "DefaultUserAuthorizationManager", ".", "class", ")", ";", "bind", "(", "GroupAuthorizationManager", ".", "class", ")", ".", "to", "(", "DefaultGroupAuthorizationManager", ".", "class", ")", ";", "bind", "(", "PullRequestWatchManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestWatchManager", ".", "class", ")", ";", "bind", "(", "RoleManager", ".", "class", ")", ".", "to", "(", "DefaultRoleManager", ".", "class", ")", ";", "bind", "(", "CommitInfoManager", ".", "class", ")", ".", "to", "(", "DefaultCommitInfoManager", ".", "class", ")", ";", "bind", "(", "UserInfoManager", ".", "class", ")", ".", "to", "(", "DefaultUserInfoManager", ".", "class", ")", ";", "bind", "(", "BatchWorkManager", ".", "class", ")", ".", "to", "(", "DefaultBatchWorkManager", ".", "class", ")", ";", "bind", "(", "GroupManager", ".", "class", ")", ".", "to", "(", "DefaultGroupManager", ".", "class", ")", ";", "bind", "(", "MembershipManager", ".", "class", ")", ".", "to", "(", "DefaultMembershipManager", ".", "class", ")", ";", "bind", "(", "PullRequestChangeManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestChangeManager", ".", "class", ")", ";", "bind", "(", "CodeCommentReplyManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentReplyManager", ".", "class", ")", ";", "bind", "(", "AttachmentStorageManager", ".", "class", ")", ".", "to", "(", "DefaultAttachmentStorageManager", ".", "class", ")", ";", "bind", "(", "CodeCommentRelationInfoManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentRelationInfoManager", ".", "class", ")", ";", "bind", "(", "CodeCommentRelationManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentRelationManager", ".", "class", ")", ";", "bind", "(", "WorkExecutor", ".", "class", ")", ".", "to", "(", "DefaultWorkExecutor", ".", "class", ")", ";", "bind", "(", "PullRequestNotificationManager", ".", "class", ")", ";", "bind", "(", "CommitNotificationManager", ".", "class", ")", ";", "bind", "(", "BuildNotificationManager", ".", "class", ")", ";", "bind", "(", "IssueNotificationManager", ".", "class", ")", ";", "bind", "(", "EntityReferenceManager", ".", "class", ")", ";", "bind", "(", "CodeCommentNotificationManager", ".", "class", ")", ";", "bind", "(", "CodeCommentManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentManager", ".", "class", ")", ";", "bind", "(", "IssueWatchManager", ".", "class", ")", ".", "to", "(", "DefaultIssueWatchManager", ".", "class", ")", ";", "bind", "(", "IssueChangeManager", ".", "class", ")", ".", "to", "(", "DefaultIssueChangeManager", ".", "class", ")", ";", "bind", "(", "IssueVoteManager", ".", "class", ")", ".", "to", "(", "DefaultIssueVoteManager", ".", "class", ")", ";", "bind", "(", "MilestoneManager", ".", "class", ")", ".", "to", "(", "DefaultMilestoneManager", ".", "class", ")", ";", "bind", "(", "Session", ".", "class", ")", ".", "toProvider", "(", "SessionProvider", ".", "class", ")", ";", "bind", "(", "EntityManager", ".", "class", ")", ".", "toProvider", "(", "SessionProvider", ".", "class", ")", ";", "bind", "(", "SessionFactory", ".", "class", ")", ".", "toProvider", "(", "SessionFactoryProvider", ".", "class", ")", ";", "bind", "(", "EntityManagerFactory", ".", "class", ")", ".", "toProvider", "(", "SessionFactoryProvider", ".", "class", ")", ";", "bind", "(", "IssueCommentManager", ".", "class", ")", ".", "to", "(", "DefaultIssueCommentManager", ".", "class", ")", ";", "bind", "(", "IssueQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultIssueQuerySettingManager", ".", "class", ")", ";", "bind", "(", "PullRequestQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestQuerySettingManager", ".", "class", ")", ";", "bind", "(", "CodeCommentQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentQuerySettingManager", ".", "class", ")", ";", "bind", "(", "CommitQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultCommitQuerySettingManager", ".", "class", ")", ";", "bind", "(", "BuildQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultBuildQuerySettingManager", ".", "class", ")", ";", "bind", "(", "WebHookManager", ".", "class", ")", ";", "contribute", "(", "ObjectMapperConfigurator", ".", "class", ",", "GitObjectMapperConfigurator", ".", "class", ")", ";", "contribute", "(", "ObjectMapperConfigurator", ".", "class", ",", "HibernateObjectMapperConfigurator", ".", "class", ")", ";", "bind", "(", "Realm", ".", "class", ")", ".", "to", "(", "OneAuthorizingRealm", ".", "class", ")", ";", "bind", "(", "RememberMeManager", ".", "class", ")", ".", "to", "(", "OneRememberMeManager", ".", "class", ")", ";", "bind", "(", "WebSecurityManager", ".", "class", ")", ".", "to", "(", "OneWebSecurityManager", ".", "class", ")", ";", "bind", "(", "FilterChainResolver", ".", "class", ")", ".", "to", "(", "OneFilterChainResolver", ".", "class", ")", ";", "bind", "(", "BasicAuthenticationFilter", ".", "class", ")", ";", "bind", "(", "PasswordService", ".", "class", ")", ".", "to", "(", "OnePasswordService", ".", "class", ")", ";", "bind", "(", "ShiroFilter", ".", "class", ")", ";", "install", "(", "new", "ShiroAopModule", "(", ")", ")", ";", "contribute", "(", "FilterChainConfigurator", ".", "class", ",", "new", "FilterChainConfigurator", "(", ")", "{", "@", "Override", "public", "void", "configure", "(", "FilterChainManager", "filterChainManager", ")", "{", "filterChainManager", ".", "createChain", "(", "\"", "/**/info/refs", "\"", ",", "\"", "noSessionCreation, authcBasic", "\"", ")", ";", "filterChainManager", ".", "createChain", "(", "\"", "/**/git-upload-pack", "\"", ",", "\"", "noSessionCreation, authcBasic", "\"", ")", ";", "filterChainManager", ".", "createChain", "(", "\"", "/**/git-receive-pack", "\"", ",", "\"", "noSessionCreation, authcBasic", "\"", ")", ";", "}", "}", ")", ";", "contributeFromPackage", "(", "Authenticator", ".", "class", ",", "Authenticator", ".", "class", ")", ";", "contribute", "(", "ImplementationProvider", ".", "class", ",", "new", "ImplementationProvider", "(", ")", "{", "@", "Override", "public", "Class", "<", "?", ">", "getAbstractClass", "(", ")", "{", "return", "JobExecutor", ".", "class", ";", "}", "@", "Override", "public", "Collection", "<", "Class", "<", "?", ">", ">", "getImplementations", "(", ")", "{", "return", "Sets", ".", "newHashSet", "(", "AutoDiscoveredJobExecutor", ".", "class", ")", ";", "}", "}", ")", ";", "contribute", "(", "CodePullAuthorizationSource", ".", "class", ",", "DefaultJobManager", ".", "class", ")", ";", "bind", "(", "IndexManager", ".", "class", ")", ".", "to", "(", "DefaultIndexManager", ".", "class", ")", ";", "bind", "(", "SearchManager", ".", "class", ")", ".", "to", "(", "DefaultSearchManager", ".", "class", ")", ";", "bind", "(", "EntityValidator", ".", "class", ")", ".", "to", "(", "DefaultEntityValidator", ".", "class", ")", ";", "bind", "(", "GitFilter", ".", "class", ")", ";", "bind", "(", "GitPreReceiveCallback", ".", "class", ")", ";", "bind", "(", "GitPostReceiveCallback", ".", "class", ")", ";", "bind", "(", "ExecutorService", ".", "class", ")", ".", "toProvider", "(", "new", "Provider", "<", "ExecutorService", ">", "(", ")", "{", "@", "Override", "public", "ExecutorService", "get", "(", ")", "{", "return", "new", "ThreadPoolExecutor", "(", "0", ",", "Integer", ".", "MAX_VALUE", ",", "60L", ",", "TimeUnit", ".", "SECONDS", ",", "new", "SynchronousQueue", "<", "Runnable", ">", "(", ")", ")", "{", "@", "Override", "public", "void", "execute", "(", "Runnable", "command", ")", "{", "try", "{", "super", ".", "execute", "(", "SecurityUtils", ".", "inheritSubject", "(", "command", ")", ")", ";", "}", "catch", "(", "RejectedExecutionException", "e", ")", "{", "if", "(", "!", "isShutdown", "(", ")", ")", "throw", "ExceptionUtils", ".", "unchecked", "(", "e", ")", ";", "}", "}", "}", ";", "}", "}", ")", ".", "in", "(", "Singleton", ".", "class", ")", ";", "bind", "(", "ForkJoinPool", ".", "class", ")", ".", "toInstance", "(", "new", "ForkJoinPool", "(", ")", "{", "@", "Override", "public", "ForkJoinTask", "<", "?", ">", "submit", "(", "Runnable", "task", ")", "{", "return", "super", ".", "submit", "(", "SecurityUtils", ".", "inheritSubject", "(", "task", ")", ")", ";", "}", "@", "Override", "public", "void", "execute", "(", "Runnable", "task", ")", "{", "super", ".", "execute", "(", "SecurityUtils", ".", "inheritSubject", "(", "task", ")", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "ForkJoinTask", "<", "T", ">", "submit", "(", "Callable", "<", "T", ">", "task", ")", "{", "return", "super", ".", "submit", "(", "SecurityUtils", ".", "inheritSubject", "(", "task", ")", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "ForkJoinTask", "<", "T", ">", "submit", "(", "Runnable", "task", ",", "T", "result", ")", "{", "return", "super", ".", "submit", "(", "SecurityUtils", ".", "inheritSubject", "(", "task", ")", ",", "result", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "T", "invokeAny", "(", "Collection", "<", "?", "extends", "Callable", "<", "T", ">", ">", "tasks", ")", "throws", "InterruptedException", ",", "ExecutionException", "{", "return", "super", ".", "invokeAny", "(", "SecurityUtils", ".", "inheritSubject", "(", "tasks", ")", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "T", "invokeAny", "(", "Collection", "<", "?", "extends", "Callable", "<", "T", ">", ">", "tasks", ",", "long", "timeout", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", ",", "ExecutionException", ",", "TimeoutException", "{", "return", "super", ".", "invokeAny", "(", "SecurityUtils", ".", "inheritSubject", "(", "tasks", ")", ",", "timeout", ",", "unit", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "List", "<", "Future", "<", "T", ">", ">", "invokeAll", "(", "Collection", "<", "?", "extends", "Callable", "<", "T", ">", ">", "tasks", ",", "long", "timeout", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", "{", "return", "super", ".", "invokeAll", "(", "SecurityUtils", ".", "inheritSubject", "(", "tasks", ")", ",", "timeout", ",", "unit", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "List", "<", "Future", "<", "T", ">", ">", "invokeAll", "(", "Collection", "<", "?", "extends", "Callable", "<", "T", ">", ">", "tasks", ")", "{", "return", "super", ".", "invokeAll", "(", "SecurityUtils", ".", "inheritSubject", "(", "tasks", ")", ")", ";", "}", "}", ")", ";", "}"], "idx": 73803, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "4f5dc6fb9e50f2c41c4929b0d8c5824b2cca3d65", "function_name": "configure", "body_hash": "d0013127c86af72481a56540547248afd1ad0218"}
{"code": "@Before\n    public void init() {\n        parser = new TldParser(true, true);\n    }", "code_tokens": ["@", "Before", "public", "void", "init", "(", ")", "{", "parser", "=", "new", "TldParser", "(", "true", ",", "true", ")", ";", "}"], "idx": 19697, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "05c84ff8304a69a30b251f207a7b93c2c882564d", "function_name": "init", "body_hash": "a0ef225019114785487f56f6c78e203802f3d189"}
{"code": "@Override\n\t\tpublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n\n\t\t\tif (!isWritableProperty(propertyName)) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName);\n\t\t\t}\n\n\t\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\t\t\tcontext.addPropertyAccessor(new PropertyTraversingMapAccessor(type, conversionService));\n\t\t\tcontext.setTypeConverter(new StandardTypeConverter(conversionService));\n\t\t\tcontext.setTypeLocator(typeName -> {\n\t\t\t\tthrow new SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);\n\t\t\t});\n\t\t\tcontext.setRootObject(map);\n\n\t\t\tExpression expression = PARSER.parseExpression(propertyName);\n\n\t\t\tPropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();\n\t\t\tTypeInformation<?> owningType = leafProperty.getOwningType();\n\t\t\tTypeInformation<?> propertyType = leafProperty.getTypeInformation();\n\n\t\t\tpropertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n\n\t\t\tif (propertyType != null && conversionRequired(value, propertyType.getType())) {\n\n\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),\n\t\t\t\t\t\tleafProperty.getSegment());\n\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tthrow new IllegalStateException(String.format(\"Couldn't find PropertyDescriptor for %s on %s!\",\n\t\t\t\t\t\t\tleafProperty.getSegment(), owningType.getType()));\n\t\t\t\t}\n\n\t\t\t\tMethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n\n\t\t\t\tif (typeDescriptor == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\tString.format(\"Couldn't obtain type descriptor for method parameter %s!\", methodParameter));\n\t\t\t\t}\n\n\t\t\t\tvalue = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(context, value);\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O);\n\t\t\t}\n\t\t}", "code_tokens": ["@", "Override", "public", "void", "setPropertyValue", "(", "String", "propertyName", ",", "@", "Nullable", "Object", "value", ")", "throws", "BeansException", "{", "if", "(", "!", "isWritableProperty", "(", "propertyName", ")", ")", "{", "throw", "new", "NotWritablePropertyException", "(", "type", ",", "propertyName", ")", ";", "}", "StandardEvaluationContext", "context", "=", "new", "StandardEvaluationContext", "(", ")", ";", "context", ".", "addPropertyAccessor", "(", "new", "PropertyTraversingMapAccessor", "(", "type", ",", "conversionService", ")", ")", ";", "context", ".", "setTypeConverter", "(", "new", "StandardTypeConverter", "(", "conversionService", ")", ")", ";", "context", ".", "setTypeLocator", "(", "typeName", "->", "{", "throw", "new", "SpelEvaluationException", "(", "SpelMessage", ".", "TYPE_NOT_FOUND", ",", "typeName", ")", ";", "}", ")", ";", "context", ".", "setRootObject", "(", "map", ")", ";", "Expression", "expression", "=", "PARSER", ".", "parseExpression", "(", "propertyName", ")", ";", "PropertyPath", "leafProperty", "=", "getPropertyPath", "(", "propertyName", ")", ".", "getLeafProperty", "(", ")", ";", "TypeInformation", "<", "?", ">", "owningType", "=", "leafProperty", ".", "getOwningType", "(", ")", ";", "TypeInformation", "<", "?", ">", "propertyType", "=", "leafProperty", ".", "getTypeInformation", "(", ")", ";", "propertyType", "=", "propertyName", ".", "endsWith", "(", "\"", "]", "\"", ")", "?", "propertyType", ".", "getActualType", "(", ")", ":", "propertyType", ";", "if", "(", "propertyType", "!=", "null", "&&", "conversionRequired", "(", "value", ",", "propertyType", ".", "getType", "(", ")", ")", ")", "{", "PropertyDescriptor", "descriptor", "=", "BeanUtils", ".", "getPropertyDescriptor", "(", "owningType", ".", "getType", "(", ")", ",", "leafProperty", ".", "getSegment", "(", ")", ")", ";", "if", "(", "descriptor", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "String", ".", "format", "(", "\"", "Couldn't find PropertyDescriptor for %s on %s!", "\"", ",", "leafProperty", ".", "getSegment", "(", ")", ",", "owningType", ".", "getType", "(", ")", ")", ")", ";", "}", "MethodParameter", "methodParameter", "=", "new", "MethodParameter", "(", "descriptor", ".", "getReadMethod", "(", ")", ",", "-", "1", ")", ";", "TypeDescriptor", "typeDescriptor", "=", "TypeDescriptor", ".", "nested", "(", "methodParameter", ",", "0", ")", ";", "if", "(", "typeDescriptor", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "String", ".", "format", "(", "\"", "Couldn't obtain type descriptor for method parameter %s!", "\"", ",", "methodParameter", ")", ")", ";", "}", "value", "=", "conversionService", ".", "convert", "(", "value", ",", "TypeDescriptor", ".", "forObject", "(", "value", ")", ",", "typeDescriptor", ")", ";", "}", "try", "{", "expression", ".", "setValue", "(", "context", ",", "value", ")", ";", "}", "catch", "(", "SpelEvaluationException", "o_O", ")", "{", "throw", "new", "NotWritablePropertyException", "(", "type", ",", "propertyName", ",", "\"", "Could not write property!", "\"", ",", "o_O", ")", ";", "}", "}"], "idx": 11742, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "ae1dd2741ce06d44a0966ecbd6f47beabde2b65", "function_name": "setPropertyValue", "body_hash": "3491d126f7d20a7c6262f2e609f4f3e76ecf4a1f"}
{"code": "@Override\n    public String getWindowId(FacesContext facesContext)\n    {\n        Map<String, Object> requestMap = facesContext.getExternalContext().getRequestMap();\n\n        // try to lookup from cache\n        String windowId = (String) requestMap.get(CACHE_WINDOW_ID);\n        if (windowId != null)\n        {\n            return windowId;\n        }\n\n        windowId = getOrCreateWindowId(facesContext);\n\n        if (windowId != null)\n        {\n            // don't cut the windowId generated from JSF\n            ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =\n                    clientWindowConfig.getClientWindowRenderMode(facesContext);\n            if (!ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))\n            {\n                if (windowId.length() > this.maxWindowIdCount)\n                {\n                    windowId = windowId.substring(0, this.maxWindowIdCount);\n                }\n            }\n\n            requestMap.put(CACHE_WINDOW_ID, windowId);\n        }\n\n        return windowId;\n    }", "code_tokens": ["@", "Override", "public", "String", "getWindowId", "(", "FacesContext", "facesContext", ")", "{", "Map", "<", "String", ",", "Object", ">", "requestMap", "=", "facesContext", ".", "getExternalContext", "(", ")", ".", "getRequestMap", "(", ")", ";", "String", "windowId", "=", "(", "String", ")", "requestMap", ".", "get", "(", "CACHE_WINDOW_ID", ")", ";", "if", "(", "windowId", "!=", "null", ")", "{", "return", "windowId", ";", "}", "windowId", "=", "getOrCreateWindowId", "(", "facesContext", ")", ";", "if", "(", "windowId", "!=", "null", ")", "{", "ClientWindowConfig", ".", "ClientWindowRenderMode", "clientWindowRenderMode", "=", "clientWindowConfig", ".", "getClientWindowRenderMode", "(", "facesContext", ")", ";", "if", "(", "!", "ClientWindowConfig", ".", "ClientWindowRenderMode", ".", "DELEGATED", ".", "equals", "(", "clientWindowRenderMode", ")", ")", "{", "if", "(", "windowId", ".", "length", "(", ")", ">", "this", ".", "maxWindowIdCount", ")", "{", "windowId", "=", "windowId", ".", "substring", "(", "0", ",", "this", ".", "maxWindowIdCount", ")", ";", "}", "}", "requestMap", ".", "put", "(", "CACHE_WINDOW_ID", ",", "windowId", ")", ";", "}", "return", "windowId", ";", "}"], "idx": 79085, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "72e607f3", "function_name": "getWindowId", "body_hash": "c1e0e6903843a3475305b255259f3cc108d0f524"}
{"code": "public QName get(String qualifiedName, String uri) {\n        int index = qualifiedName.indexOf(':');\n\n        if (index < 0) {\n            return get(qualifiedName, Namespace.get(uri));\n        } else if (index == 0){\n            throw new IllegalArgumentException(\"Qualified name cannot start with ':'.\");\n        } else {\n            String name = qualifiedName.substring(index + 1);\n            String prefix = qualifiedName.substring(0, index);\n\n            return get(name, Namespace.get(prefix, uri));\n        }\n    }", "code_tokens": ["public", "QName", "get", "(", "String", "qualifiedName", ",", "String", "uri", ")", "{", "int", "index", "=", "qualifiedName", ".", "indexOf", "(", "':'", ")", ";", "if", "(", "index", "<", "0", ")", "{", "return", "get", "(", "qualifiedName", ",", "Namespace", ".", "get", "(", "uri", ")", ")", ";", "}", "else", "if", "(", "index", "==", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Qualified name cannot start with ':'.", "\"", ")", ";", "}", "else", "{", "String", "name", "=", "qualifiedName", ".", "substring", "(", "index", "+", "1", ")", ";", "String", "prefix", "=", "qualifiedName", ".", "substring", "(", "0", ",", "index", ")", ";", "return", "get", "(", "name", ",", "Namespace", ".", "get", "(", "prefix", ",", "uri", ")", ")", ";", "}", "}"], "idx": 94228, "cwe": "CWE-91", "target": 0, "status": "FIXED", "commit": "e598eb43d418744c4dbf62f647dd2381c9ce9387", "function_name": "get", "body_hash": "359518468320d13e589da04b0bc3bb7ee965bbdc"}
{"code": "@Override\n        public void handleEvent(StreamConnection channel) {\n            final Map<String, String> headers = new HashMap<String, String>();\n            headers.put(UPGRADE, \"jboss-remoting\");\n            final String secKey = createSecKey();\n            headers.put(SEC_JBOSS_REMOTING_KEY, secKey);\n\n            IoFuture<T> upgradeFuture = HttpUpgrade.performUpgrade(type.cast(channel), uri, headers, upgradeChannel -> {\n                ChannelListeners.invokeChannelListener(upgradeChannel, openListener);\n            }, new RemotingHandshakeChecker(secKey));\n            upgradeFuture.addNotifier( new IoFuture.HandlingNotifier<T, FutureResult<T>>() {\n\n                @Override\n                public void handleCancelled(FutureResult<T> attachment) {\n                    attachment.setCancelled();\n                }\n\n                @Override\n                public void handleFailed(IOException exception, FutureResult<T> attachment) {\n                    attachment.setException(exception);\n                }\n\n                @Override\n                public void handleDone(T data, FutureResult<T> attachment) {\n                    attachment.setResult(data);\n                }\n\n            }, futureResult);\n        }", "code_tokens": ["@", "Override", "public", "void", "handleEvent", "(", "StreamConnection", "channel", ")", "{", "final", "Map", "<", "String", ",", "String", ">", "headers", "=", "new", "HashMap", "<", "String", ",", "String", ">", "(", ")", ";", "headers", ".", "put", "(", "UPGRADE", ",", "\"", "jboss-remoting", "\"", ")", ";", "final", "String", "secKey", "=", "createSecKey", "(", ")", ";", "headers", ".", "put", "(", "SEC_JBOSS_REMOTING_KEY", ",", "secKey", ")", ";", "IoFuture", "<", "T", ">", "upgradeFuture", "=", "HttpUpgrade", ".", "performUpgrade", "(", "type", ".", "cast", "(", "channel", ")", ",", "uri", ",", "headers", ",", "upgradeChannel", "->", "{", "ChannelListeners", ".", "invokeChannelListener", "(", "upgradeChannel", ",", "openListener", ")", ";", "}", ",", "new", "RemotingHandshakeChecker", "(", "secKey", ")", ")", ";", "upgradeFuture", ".", "addNotifier", "(", "new", "IoFuture", ".", "HandlingNotifier", "<", "T", ",", "FutureResult", "<", "T", ">", ">", "(", ")", "{", "@", "Override", "public", "void", "handleCancelled", "(", "FutureResult", "<", "T", ">", "attachment", ")", "{", "attachment", ".", "setCancelled", "(", ")", ";", "}", "@", "Override", "public", "void", "handleFailed", "(", "IOException", "exception", ",", "FutureResult", "<", "T", ">", "attachment", ")", "{", "attachment", ".", "setException", "(", "exception", ")", ";", "}", "@", "Override", "public", "void", "handleDone", "(", "T", "data", ",", "FutureResult", "<", "T", ">", "attachment", ")", "{", "attachment", ".", "setResult", "(", "data", ")", ";", "}", "}", ",", "futureResult", ")", ";", "}"], "idx": 52678, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "7c59d0e89972e855ab21654a12efa012e550f722", "function_name": "handleEvent", "body_hash": "77d473cfac216197197e20dd800693f6f0d6b37f"}
{"code": "public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            // Get the user document\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            // Get the stored validation key\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            // Get the validation key from the URL\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            // Compare the two keys\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                // Ensure to remove the validation key value, so it cannot be used afterwards to enable back\n                // a disabled user.\n                userObject.setStringValue(\"validkey\", \"\");\n                saveDocument(userDocument, context);\n\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n        }\n    }", "code_tokens": ["public", "int", "validateUser", "(", "boolean", "withConfirmEmail", ",", "XWikiContext", "context", ")", "throws", "XWikiException", "{", "try", "{", "XWikiRequest", "request", "=", "context", ".", "getRequest", "(", ")", ";", "String", "username", "=", "convertUsername", "(", "request", ".", "getParameter", "(", "\"", "xwikiname", "\"", ")", ",", "context", ")", ";", "if", "(", "username", ".", "indexOf", "(", "'.'", ")", "==", "-", "1", ")", "{", "username", "=", "\"", "XWiki.", "\"", "+", "username", ";", "}", "XWikiDocument", "userDocument", "=", "getDocument", "(", "username", ",", "context", ")", ";", "BaseObject", "userObject", "=", "userDocument", ".", "getObject", "(", "\"", "XWiki.XWikiUsers", "\"", ",", "0", ")", ";", "String", "storedKey", "=", "userObject", ".", "getStringValue", "(", "\"", "validkey", "\"", ")", ";", "String", "validationKey", "=", "request", ".", "getParameter", "(", "\"", "validkey", "\"", ")", ";", "PropertyInterface", "validationKeyClass", "=", "getClass", "(", "\"", "XWiki.XWikiUsers", "\"", ",", "context", ")", ".", "get", "(", "\"", "validkey", "\"", ")", ";", "if", "(", "validationKeyClass", "instanceof", "PasswordClass", ")", "{", "validationKey", "=", "(", "(", "PasswordClass", ")", "validationKeyClass", ")", ".", "getEquivalentPassword", "(", "storedKey", ",", "validationKey", ")", ";", "}", "if", "(", "(", "!", "storedKey", ".", "equals", "(", "\"", "\"", ")", "&&", "(", "storedKey", ".", "equals", "(", "validationKey", ")", ")", ")", ")", "{", "userObject", ".", "setStringValue", "(", "\"", "validkey", "\"", ",", "\"", "\"", ")", ";", "saveDocument", "(", "userDocument", ",", "context", ")", ";", "XWikiUser", "xWikiUser", "=", "new", "XWikiUser", "(", "userDocument", ".", "getDocumentReference", "(", ")", ")", ";", "xWikiUser", ".", "setDisabled", "(", "false", ",", "context", ")", ";", "xWikiUser", ".", "setEmailChecked", "(", "true", ",", "context", ")", ";", "if", "(", "withConfirmEmail", ")", "{", "String", "email", "=", "userObject", ".", "getStringValue", "(", "\"", "email", "\"", ")", ";", "String", "password", "=", "userObject", ".", "getStringValue", "(", "\"", "password", "\"", ")", ";", "sendValidationEmail", "(", "username", ",", "password", ",", "email", ",", "request", ".", "getParameter", "(", "\"", "validkey", "\"", ")", ",", "\"", "confirmation_email_content", "\"", ",", "context", ")", ";", "}", "return", "0", ";", "}", "else", "{", "return", "-", "1", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOGGER", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "throw", "new", "XWikiException", "(", "XWikiException", ".", "MODULE_XWIKI_APP", ",", "XWikiException", ".", "ERROR_XWIKI_APP_VALIDATE_USER", ",", "\"", "Exception while validating user", "\"", ",", "e", ",", "null", ")", ";", "}", "}"], "idx": 90598, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "f9a677408ffb06f309be46ef9d8df1915d9099a4", "function_name": "validateUser", "body_hash": "2c3681a580ee11cdc0cff7900381b62b79ded177"}
{"code": "@Override\n    protected void initializeStreams() throws IOException {\n        NIOOutputStream outputStream = null;\n        try {\n            channel = socket.getChannel();\n            channel.configureBlocking(false);\n\n            if (sslContext == null) {\n                sslContext = SSLContext.getDefault();\n            }\n\n            String remoteHost = null;\n            int remotePort = -1;\n\n            try {\n                URI remoteAddress = new URI(this.getRemoteAddress());\n                remoteHost = remoteAddress.getHost();\n                remotePort = remoteAddress.getPort();\n            } catch (Exception e) {\n            }\n\n            // initialize engine, the initial sslSession we get will need to be\n            // updated once the ssl handshake process is completed.\n            if (remoteHost != null && remotePort != -1) {\n                sslEngine = sslContext.createSSLEngine(remoteHost, remotePort);\n            } else {\n                sslEngine = sslContext.createSSLEngine();\n            }\n\n            if (verifyHostName) {\n                SSLParameters sslParams = new SSLParameters();\n                sslParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n                sslEngine.setSSLParameters(sslParams);\n            }\n\n            sslEngine.setUseClientMode(false);\n            if (enabledCipherSuites != null) {\n                sslEngine.setEnabledCipherSuites(enabledCipherSuites);\n            }\n\n            if (enabledProtocols != null) {\n                sslEngine.setEnabledProtocols(enabledProtocols);\n            }\n\n            if (wantClientAuth) {\n                sslEngine.setWantClientAuth(wantClientAuth);\n            }\n\n            if (needClientAuth) {\n                sslEngine.setNeedClientAuth(needClientAuth);\n            }\n\n            sslSession = sslEngine.getSession();\n\n            inputBuffer = ByteBuffer.allocate(sslSession.getPacketBufferSize());\n            inputBuffer.clear();\n\n            outputStream = new NIOOutputStream(channel);\n            outputStream.setEngine(sslEngine);\n            this.dataOut = new DataOutputStream(outputStream);\n            this.buffOut = outputStream;\n            sslEngine.beginHandshake();\n            handshakeStatus = sslEngine.getHandshakeStatus();\n            doHandshake();\n\n        } catch (Exception e) {\n            try {\n                if(outputStream != null) {\n                    outputStream.close();\n                }\n                super.closeStreams();\n            } catch (Exception ex) {}\n            throw new IOException(e);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "initializeStreams", "(", ")", "throws", "IOException", "{", "NIOOutputStream", "outputStream", "=", "null", ";", "try", "{", "channel", "=", "socket", ".", "getChannel", "(", ")", ";", "channel", ".", "configureBlocking", "(", "false", ")", ";", "if", "(", "sslContext", "==", "null", ")", "{", "sslContext", "=", "SSLContext", ".", "getDefault", "(", ")", ";", "}", "String", "remoteHost", "=", "null", ";", "int", "remotePort", "=", "-", "1", ";", "try", "{", "URI", "remoteAddress", "=", "new", "URI", "(", "this", ".", "getRemoteAddress", "(", ")", ")", ";", "remoteHost", "=", "remoteAddress", ".", "getHost", "(", ")", ";", "remotePort", "=", "remoteAddress", ".", "getPort", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "}", "if", "(", "remoteHost", "!=", "null", "&&", "remotePort", "!=", "-", "1", ")", "{", "sslEngine", "=", "sslContext", ".", "createSSLEngine", "(", "remoteHost", ",", "remotePort", ")", ";", "}", "else", "{", "sslEngine", "=", "sslContext", ".", "createSSLEngine", "(", ")", ";", "}", "if", "(", "verifyHostName", ")", "{", "SSLParameters", "sslParams", "=", "new", "SSLParameters", "(", ")", ";", "sslParams", ".", "setEndpointIdentificationAlgorithm", "(", "\"", "HTTPS", "\"", ")", ";", "sslEngine", ".", "setSSLParameters", "(", "sslParams", ")", ";", "}", "sslEngine", ".", "setUseClientMode", "(", "false", ")", ";", "if", "(", "enabledCipherSuites", "!=", "null", ")", "{", "sslEngine", ".", "setEnabledCipherSuites", "(", "enabledCipherSuites", ")", ";", "}", "if", "(", "enabledProtocols", "!=", "null", ")", "{", "sslEngine", ".", "setEnabledProtocols", "(", "enabledProtocols", ")", ";", "}", "if", "(", "wantClientAuth", ")", "{", "sslEngine", ".", "setWantClientAuth", "(", "wantClientAuth", ")", ";", "}", "if", "(", "needClientAuth", ")", "{", "sslEngine", ".", "setNeedClientAuth", "(", "needClientAuth", ")", ";", "}", "sslSession", "=", "sslEngine", ".", "getSession", "(", ")", ";", "inputBuffer", "=", "ByteBuffer", ".", "allocate", "(", "sslSession", ".", "getPacketBufferSize", "(", ")", ")", ";", "inputBuffer", ".", "clear", "(", ")", ";", "outputStream", "=", "new", "NIOOutputStream", "(", "channel", ")", ";", "outputStream", ".", "setEngine", "(", "sslEngine", ")", ";", "this", ".", "dataOut", "=", "new", "DataOutputStream", "(", "outputStream", ")", ";", "this", ".", "buffOut", "=", "outputStream", ";", "sslEngine", ".", "beginHandshake", "(", ")", ";", "handshakeStatus", "=", "sslEngine", ".", "getHandshakeStatus", "(", ")", ";", "doHandshake", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "try", "{", "if", "(", "outputStream", "!=", "null", ")", "{", "outputStream", ".", "close", "(", ")", ";", "}", "super", ".", "closeStreams", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "}", "throw", "new", "IOException", "(", "e", ")", ";", "}", "}"], "idx": 39783, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "bde7097fb8173cf871827df7811b3865679b963d", "function_name": "initializeStreams", "body_hash": "e99707a0b514d5f6f0653f3503dbe6f908744047"}
{"code": "@Override\n\tpublic OAuth2TokenValidatorResult validate(Jwt token) {\n\t\tAssert.notNull(token, \"token cannot be null\");\n\n\t\tString tokenIssuer = token.getClaimAsString(JwtClaimNames.ISS);\n\t\tif (this.issuer.equals(tokenIssuer)) {\n\t\t\treturn OAuth2TokenValidatorResult.success();\n\t\t} else {\n\t\t\treturn OAuth2TokenValidatorResult.failure(INVALID_ISSUER);\n\t\t}\n\t}", "code_tokens": ["@", "Override", "public", "OAuth2TokenValidatorResult", "validate", "(", "Jwt", "token", ")", "{", "Assert", ".", "notNull", "(", "token", ",", "\"", "token cannot be null", "\"", ")", ";", "String", "tokenIssuer", "=", "token", ".", "getClaimAsString", "(", "JwtClaimNames", ".", "ISS", ")", ";", "if", "(", "this", ".", "issuer", ".", "equals", "(", "tokenIssuer", ")", ")", "{", "return", "OAuth2TokenValidatorResult", ".", "success", "(", ")", ";", "}", "else", "{", "return", "OAuth2TokenValidatorResult", ".", "failure", "(", "INVALID_ISSUER", ")", ";", "}", "}"], "idx": 42940, "cwe": "CWE-345", "target": 0, "status": "FIXED", "commit": "c70b65c5df0e170a2d34d812b83db0b7bc71ea25", "function_name": "validate", "body_hash": "2228ba580cfdb62bb11eb20023b29348303d9436"}
{"code": "private HttpServletRequest createMockRequest(String path) {\r\n        HttpServletRequest request = createNiceMock(HttpServletRequest.class);\r\n\r\n        expect(request.getServletPath()).andReturn(\"\");\r\n        expect(request.getPathInfo()).andReturn(path);\r\n        replay(request);\r\n        return request;\r\n    }", "code_tokens": ["private", "HttpServletRequest", "createMockRequest", "(", "String", "path", ")", "{", "HttpServletRequest", "request", "=", "createNiceMock", "(", "HttpServletRequest", ".", "class", ")", ";", "expect", "(", "request", ".", "getServletPath", "(", ")", ")", ".", "andReturn", "(", "\"", "\"", ")", ";", "expect", "(", "request", ".", "getPathInfo", "(", ")", ")", ".", "andReturn", "(", "path", ")", ";", "replay", "(", "request", ")", ";", "return", "request", ";", "}"], "idx": 107932, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "01887f64", "function_name": "createMockRequest", "body_hash": "04a6ab620a98f88a2713dd029ed4b2e60af4fe0b"}
{"code": "@RequirePOST\n        public FormValidation doCheckUrl(@QueryParameter String value) {\n            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n            \n            try {\n                URLConnection conn = ProxyConfiguration.open(new URL(value));\n                conn.connect();\n                if (conn instanceof HttpURLConnection) {\n                    if (((HttpURLConnection) conn).getResponseCode() != HttpURLConnection.HTTP_OK) {\n                        return FormValidation.error(Messages.ZipExtractionInstaller_bad_connection());\n                    }\n                }\n                return FormValidation.ok();\n            } catch (MalformedURLException x) {\n                return FormValidation.error(Messages.ZipExtractionInstaller_malformed_url());\n            } catch (IOException x) {\n                return FormValidation.error(x,Messages.ZipExtractionInstaller_could_not_connect());\n            }\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doCheckUrl", "(", "@", "QueryParameter", "String", "value", ")", "{", "Jenkins", ".", "getInstance", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "try", "{", "URLConnection", "conn", "=", "ProxyConfiguration", ".", "open", "(", "new", "URL", "(", "value", ")", ")", ";", "conn", ".", "connect", "(", ")", ";", "if", "(", "conn", "instanceof", "HttpURLConnection", ")", "{", "if", "(", "(", "(", "HttpURLConnection", ")", "conn", ")", ".", "getResponseCode", "(", ")", "!=", "HttpURLConnection", ".", "HTTP_OK", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ZipExtractionInstaller_bad_connection", "(", ")", ")", ";", "}", "}", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "catch", "(", "MalformedURLException", "x", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ZipExtractionInstaller_malformed_url", "(", ")", ")", ";", "}", "catch", "(", "IOException", "x", ")", "{", "return", "FormValidation", ".", "error", "(", "x", ",", "Messages", ".", "ZipExtractionInstaller_could_not_connect", "(", ")", ")", ";", "}", "}"], "idx": 44414, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "6eea1e97840b5623829b2c1fd2e363c045bdc230", "function_name": "doCheckUrl", "body_hash": "1047ce40bab0b7931781c5b7e381f6e823f57806"}
{"code": "public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        // if there is no value - don't do comparison\n        // if a value is required, a required validator should be added to the field\n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value).trim()).matches()) {\n            addFieldError(fieldName, object);\n        }\n    }", "code_tokens": ["public", "void", "validate", "(", "Object", "object", ")", "throws", "ValidationException", "{", "String", "fieldName", "=", "getFieldName", "(", ")", ";", "Object", "value", "=", "this", ".", "getFieldValue", "(", "fieldName", ",", "object", ")", ";", "if", "(", "value", "==", "null", "||", "value", ".", "toString", "(", ")", ".", "length", "(", ")", "==", "0", ")", "{", "return", ";", "}", "if", "(", "!", "(", "value", ".", "getClass", "(", ")", ".", "equals", "(", "String", ".", "class", ")", ")", "||", "!", "Pattern", ".", "compile", "(", "getUrlRegex", "(", ")", ",", "Pattern", ".", "CASE_INSENSITIVE", ")", ".", "matcher", "(", "String", ".", "valueOf", "(", "value", ")", ".", "trim", "(", ")", ")", ".", "matches", "(", ")", ")", "{", "addFieldError", "(", "fieldName", ",", "object", ")", ";", "}", "}"], "idx": 6431, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "554b9dddb0fbd1e581ef577dd62a7c22955ad0f6", "function_name": "validate", "body_hash": "bf99e5dd803dcb0a0fead8b9e5de4d2646a1a849"}
{"code": "private static Document loadConfigFile(SolrResourceLoader resourceLoader, String parseContextConfigLoc) throws Exception {\n    try (InputStream in = resourceLoader.openResource(parseContextConfigLoc)) {\n      return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(in, parseContextConfigLoc);\n    }\n  }", "code_tokens": ["private", "static", "Document", "loadConfigFile", "(", "SolrResourceLoader", "resourceLoader", ",", "String", "parseContextConfigLoc", ")", "throws", "Exception", "{", "try", "(", "InputStream", "in", "=", "resourceLoader", ".", "openResource", "(", "parseContextConfigLoc", ")", ")", "{", "return", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ".", "newDocumentBuilder", "(", ")", ".", "parse", "(", "in", ",", "parseContextConfigLoc", ")", ";", "}", "}"], "idx": 68910, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "d1baf6ba593561f39e2da0a71a8440797005b55", "function_name": "loadConfigFile", "body_hash": "0ba1336c487734298b613f6cb74e34023aa9ed8d"}
{"code": "public void loadXmiFile(File xmiCasFile) {\r\n    try {\r\n      setXcasFileOpenDir(xmiCasFile.getParentFile());\r\n      Timer time = new Timer();\r\n      time.start();\r\n      SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\r\n      saxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\r\n      SAXParser parser = saxParserFactory.newSAXParser();\r\n      XmiCasDeserializer xmiCasDeserializer = new XmiCasDeserializer(getCas().getTypeSystem());\r\n      getCas().reset();\r\n      parser.parse(xmiCasFile, xmiCasDeserializer.getXmiCasHandler(getCas(), true));\r\n      time.stop();\r\n      handleSofas();\r\n\r\n      setTitle(\"XMI CAS\");\r\n      updateIndexTree(true);\r\n      setRunOnCasEnabled();\r\n      setEnableCasFileReadingAndWriting();\r\n      setStatusbarMessage(\"Done loading XMI CAS file in \" + time.getTimeSpan() + \".\");\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n      handleException(e);\r\n    }\r\n  }", "code_tokens": ["public", "void", "loadXmiFile", "(", "File", "xmiCasFile", ")", "{", "try", "{", "setXcasFileOpenDir", "(", "xmiCasFile", ".", "getParentFile", "(", ")", ")", ";", "Timer", "time", "=", "new", "Timer", "(", ")", ";", "time", ".", "start", "(", ")", ";", "SAXParserFactory", "saxParserFactory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "saxParserFactory", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "SAXParser", "parser", "=", "saxParserFactory", ".", "newSAXParser", "(", ")", ";", "XmiCasDeserializer", "xmiCasDeserializer", "=", "new", "XmiCasDeserializer", "(", "getCas", "(", ")", ".", "getTypeSystem", "(", ")", ")", ";", "getCas", "(", ")", ".", "reset", "(", ")", ";", "parser", ".", "parse", "(", "xmiCasFile", ",", "xmiCasDeserializer", ".", "getXmiCasHandler", "(", "getCas", "(", ")", ",", "true", ")", ")", ";", "time", ".", "stop", "(", ")", ";", "handleSofas", "(", ")", ";", "setTitle", "(", "\"", "XMI CAS", "\"", ")", ";", "updateIndexTree", "(", "true", ")", ";", "setRunOnCasEnabled", "(", ")", ";", "setEnableCasFileReadingAndWriting", "(", ")", ";", "setStatusbarMessage", "(", "\"", "Done loading XMI CAS file in ", "\"", "+", "time", ".", "getTimeSpan", "(", ")", "+", "\"", ".", "\"", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "handleException", "(", "e", ")", ";", "}", "}"], "idx": 70544, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "39909bf21fd694f4fb792d1de8adc72562ead25e", "function_name": "loadXmiFile", "body_hash": "1083319e4e6f0e41794f28e00f44d65d4aef1976"}
{"code": "private static String verifyRedirectUri(UriInfo uriInfo, String rootUrl, String redirectUri, RealmModel realm, Set<String> validRedirects, boolean requireRedirectUri) {\n        if (redirectUri == null) {\n            if (!requireRedirectUri) {\n                redirectUri = getSingleValidRedirectUri(validRedirects);\n            }\n\n            if (redirectUri == null) {\n                logger.debug(\"No Redirect URI parameter specified\");\n                return null;\n            }\n        } else if (validRedirects.isEmpty()) {\n            logger.debug(\"No Redirect URIs supplied\");\n            redirectUri = null;\n        } else {\n            redirectUri = lowerCaseHostname(redirectUri);\n\n            String r = redirectUri;\n            Set<String> resolveValidRedirects = resolveValidRedirects(uriInfo, rootUrl, validRedirects);\n\n            boolean valid = matchesRedirects(resolveValidRedirects, r);\n\n            if (!valid && r.startsWith(Constants.INSTALLED_APP_URL) && r.indexOf(':', Constants.INSTALLED_APP_URL.length()) >= 0) {\n                int i = r.indexOf(':', Constants.INSTALLED_APP_URL.length());\n\n                StringBuilder sb = new StringBuilder();\n                sb.append(r.substring(0, i));\n\n                i = r.indexOf('/', i);\n                if (i >= 0) {\n                    sb.append(r.substring(i));\n                }\n\n                r = sb.toString();\n\n                valid = matchesRedirects(resolveValidRedirects, r);\n            }\n            if (valid && redirectUri.startsWith(\"/\")) {\n                redirectUri = relativeToAbsoluteURI(uriInfo, rootUrl, redirectUri);\n            }\n            redirectUri = valid ? redirectUri : null;\n        }\n\n        if (Constants.INSTALLED_APP_URN.equals(redirectUri)) {\n            return Urls.realmInstalledAppUrnCallback(uriInfo.getBaseUri(), realm.getName()).toString();\n        } else {\n            return redirectUri;\n        }\n    }", "code_tokens": ["private", "static", "String", "verifyRedirectUri", "(", "UriInfo", "uriInfo", ",", "String", "rootUrl", ",", "String", "redirectUri", ",", "RealmModel", "realm", ",", "Set", "<", "String", ">", "validRedirects", ",", "boolean", "requireRedirectUri", ")", "{", "if", "(", "redirectUri", "==", "null", ")", "{", "if", "(", "!", "requireRedirectUri", ")", "{", "redirectUri", "=", "getSingleValidRedirectUri", "(", "validRedirects", ")", ";", "}", "if", "(", "redirectUri", "==", "null", ")", "{", "logger", ".", "debug", "(", "\"", "No Redirect URI parameter specified", "\"", ")", ";", "return", "null", ";", "}", "}", "else", "if", "(", "validRedirects", ".", "isEmpty", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "No Redirect URIs supplied", "\"", ")", ";", "redirectUri", "=", "null", ";", "}", "else", "{", "redirectUri", "=", "lowerCaseHostname", "(", "redirectUri", ")", ";", "String", "r", "=", "redirectUri", ";", "Set", "<", "String", ">", "resolveValidRedirects", "=", "resolveValidRedirects", "(", "uriInfo", ",", "rootUrl", ",", "validRedirects", ")", ";", "boolean", "valid", "=", "matchesRedirects", "(", "resolveValidRedirects", ",", "r", ")", ";", "if", "(", "!", "valid", "&&", "r", ".", "startsWith", "(", "Constants", ".", "INSTALLED_APP_URL", ")", "&&", "r", ".", "indexOf", "(", "':'", ",", "Constants", ".", "INSTALLED_APP_URL", ".", "length", "(", ")", ")", ">=", "0", ")", "{", "int", "i", "=", "r", ".", "indexOf", "(", "':'", ",", "Constants", ".", "INSTALLED_APP_URL", ".", "length", "(", ")", ")", ";", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", ")", ";", "sb", ".", "append", "(", "r", ".", "substring", "(", "0", ",", "i", ")", ")", ";", "i", "=", "r", ".", "indexOf", "(", "'/'", ",", "i", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "sb", ".", "append", "(", "r", ".", "substring", "(", "i", ")", ")", ";", "}", "r", "=", "sb", ".", "toString", "(", ")", ";", "valid", "=", "matchesRedirects", "(", "resolveValidRedirects", ",", "r", ")", ";", "}", "if", "(", "valid", "&&", "redirectUri", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "{", "redirectUri", "=", "relativeToAbsoluteURI", "(", "uriInfo", ",", "rootUrl", ",", "redirectUri", ")", ";", "}", "redirectUri", "=", "valid", "?", "redirectUri", ":", "null", ";", "}", "if", "(", "Constants", ".", "INSTALLED_APP_URN", ".", "equals", "(", "redirectUri", ")", ")", "{", "return", "Urls", ".", "realmInstalledAppUrnCallback", "(", "uriInfo", ".", "getBaseUri", "(", ")", ",", "realm", ".", "getName", "(", ")", ")", ".", "toString", "(", ")", ";", "}", "else", "{", "return", "redirectUri", ";", "}", "}"], "idx": 65793, "cwe": "CWE-601", "target": 1, "status": "VULNERABLE", "commit": "a957e118e6efb35fe7ef3a62acd66341a6523cb7", "function_name": "verifyRedirectUri", "body_hash": "a4383fbb4be900c79e373c157753c693be03558a"}
{"code": "static public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n        }\n        \n        File file = new File(dir, name);\n        \n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n        }\n        \n        file.getParentFile().mkdirs();\n        \n        return file;\n    }", "code_tokens": ["static", "public", "File", "allocateFile", "(", "File", "dir", ",", "String", "name", ")", "{", "int", "q", "=", "name", ".", "indexOf", "(", "'?'", ")", ";", "if", "(", "q", ">", "0", ")", "{", "name", "=", "name", ".", "substring", "(", "0", ",", "q", ")", ";", "}", "File", "file", "=", "new", "File", "(", "dir", ",", "name", ")", ";", "int", "dot", "=", "name", ".", "indexOf", "(", "'.'", ")", ";", "String", "prefix", "=", "dot", "<", "0", "?", "name", ":", "name", ".", "substring", "(", "0", ",", "dot", ")", ";", "String", "suffix", "=", "dot", "<", "0", "?", "\"", "\"", ":", "name", ".", "substring", "(", "dot", ")", ";", "int", "index", "=", "2", ";", "while", "(", "file", ".", "exists", "(", ")", ")", "{", "file", "=", "new", "File", "(", "dir", ",", "prefix", "+", "\"", "-", "\"", "+", "index", "++", "+", "suffix", ")", ";", "}", "file", ".", "getParentFile", "(", ")", ".", "mkdirs", "(", ")", ";", "return", "file", ";", "}"], "idx": 25760, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "e243e73e4064de87a913946bd320fbbe246da656", "function_name": "allocateFile", "body_hash": "85f7de72a585ba774ad13ccbabb90adf74759c58"}
{"code": "public static ListBoxModel doFillCredentialsIdItems(ItemGroup context) {\n        AbstractIdCredentialsListBoxModel result = new StandardListBoxModel().includeEmptyValue();\n        if (hasPermission(context)) {\n            result = result.withMatching(\n                            CredentialsMatchers.always(),\n                            CredentialsProvider.lookupCredentials(AmazonWebServicesCredentials.class,\n                                    context,\n                                    ACL.SYSTEM,\n                                    Collections.EMPTY_LIST));\n        }\n        return result;\n    }", "code_tokens": ["public", "static", "ListBoxModel", "doFillCredentialsIdItems", "(", "ItemGroup", "context", ")", "{", "AbstractIdCredentialsListBoxModel", "result", "=", "new", "StandardListBoxModel", "(", ")", ".", "includeEmptyValue", "(", ")", ";", "if", "(", "hasPermission", "(", "context", ")", ")", "{", "result", "=", "result", ".", "withMatching", "(", "CredentialsMatchers", ".", "always", "(", ")", ",", "CredentialsProvider", ".", "lookupCredentials", "(", "AmazonWebServicesCredentials", ".", "class", ",", "context", ",", "ACL", ".", "SYSTEM", ",", "Collections", ".", "EMPTY_LIST", ")", ")", ";", "}", "return", "result", ";", "}"], "idx": 85426, "cwe": "CWE-862", "target": 0, "status": "FIXED", "commit": "dd477a071bd633d9118c63dc3f19a2fd0590aecb", "function_name": "doFillCredentialsIdItems", "body_hash": "1ff2e26b74473eefe43ecce9e39f71d284dfcdc4"}
{"code": "@Override\n  protected void process(final ClusterDistributionManager dm) {\n    Throwable thr = null;\n    ReplyException rex = null;\n    if (this.functionObject == null) {\n      rex = new ReplyException(\n          new FunctionException(LocalizedStrings.ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED\n              .toLocalizedString(this.functionName)));\n\n      replyWithException(dm, rex);\n      return;\n    }\n\n    FunctionStats stats =\n        FunctionStats.getFunctionStats(this.functionObject.getId(), dm.getSystem());\n    TXStateProxy tx = null;\n    InternalCache cache = dm.getCache();\n\n    try {\n      tx = prepForTransaction(dm);\n      ResultSender resultSender = new MemberFunctionResultSender(dm, this, this.functionObject);\n      Set<Region> regions = new HashSet<Region>();\n      if (this.regionPathSet != null) {\n        for (String regionPath : this.regionPathSet) {\n          if (checkCacheClosing(dm) || checkDSClosing(dm)) {\n            if (dm.getCache() == null) {\n              thr = new CacheClosedException(\n                  LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0\n                      .toLocalizedString(dm.getId()));\n            } else {\n              dm.getCache().getCacheClosedException(\n                  LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0\n                      .toLocalizedString(dm.getId()));\n            }\n            return;\n          }\n          regions.add(cache.getRegion(regionPath));\n        }\n      }\n      FunctionContextImpl context = new MultiRegionFunctionContextImpl(cache,\n          this.functionObject.getId(), this.args, resultSender, regions, isReExecute);\n\n      long start = stats.startTime();\n      stats.startFunctionExecution(this.functionObject.hasResult());\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Executing Function: {} on remote member with context: {}\",\n            this.functionObject.getId(), context.toString());\n      }\n      this.functionObject.execute(context);\n      if (!this.replyLastMsg && this.functionObject.hasResult()) {\n        throw new FunctionException(\n            LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT\n                .toString(functionObject.getId()));\n      }\n      stats.endFunctionExecution(start, this.functionObject.hasResult());\n    } catch (FunctionException functionException) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"FunctionException occurred on remote member while executing Function: {}\",\n            this.functionObject.getId(), functionException);\n      }\n      stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n      rex = new ReplyException(functionException);\n      replyWithException(dm, rex);\n      // thr = functionException.getCause();\n    } catch (CancelException exception) {\n      // bug 37026: this is too noisy...\n      // throw new CacheClosedException(\"remote system shutting down\");\n      // thr = se; cache is closed, no point trying to send a reply\n      thr = new FunctionInvocationTargetException(exception);\n      stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n      rex = new ReplyException(thr);\n      replyWithException(dm, rex);\n    } catch (Exception exception) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Exception occurred on remote member while executing Function: {}\",\n            this.functionObject.getId(), exception);\n      }\n      stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n      rex = new ReplyException(exception);\n      replyWithException(dm, rex);\n      // thr = e.getCause();\n    } catch (VirtualMachineError err) {\n      SystemFailure.initiateFailure(err);\n      // If this ever returns, rethrow the error. We're poisoned\n      // now, so don't let this thread continue.\n      throw err;\n    } catch (Throwable t) {\n      // Whenever you catch Error or Throwable, you must also\n      // catch VirtualMachineError (see above). However, there is\n      // _still_ a possibility that you are dealing with a cascading\n      // error condition, so you also need to check to see if the JVM\n      // is still usable:\n      SystemFailure.checkFailure();\n      thr = t;\n    } finally {\n      cleanupTransaction(tx);\n      if (thr != null) {\n        rex = new ReplyException(thr);\n        replyWithException(dm, rex);\n      }\n    }\n  }", "code_tokens": ["@", "Override", "protected", "void", "process", "(", "final", "ClusterDistributionManager", "dm", ")", "{", "Throwable", "thr", "=", "null", ";", "ReplyException", "rex", "=", "null", ";", "if", "(", "this", ".", "functionObject", "==", "null", ")", "{", "rex", "=", "new", "ReplyException", "(", "new", "FunctionException", "(", "LocalizedStrings", ".", "ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED", ".", "toLocalizedString", "(", "this", ".", "functionName", ")", ")", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "return", ";", "}", "FunctionStats", "stats", "=", "FunctionStats", ".", "getFunctionStats", "(", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "dm", ".", "getSystem", "(", ")", ")", ";", "TXStateProxy", "tx", "=", "null", ";", "InternalCache", "cache", "=", "dm", ".", "getCache", "(", ")", ";", "try", "{", "tx", "=", "prepForTransaction", "(", "dm", ")", ";", "ResultSender", "resultSender", "=", "new", "MemberFunctionResultSender", "(", "dm", ",", "this", ",", "this", ".", "functionObject", ")", ";", "Set", "<", "Region", ">", "regions", "=", "new", "HashSet", "<", "Region", ">", "(", ")", ";", "if", "(", "this", ".", "regionPathSet", "!=", "null", ")", "{", "for", "(", "String", "regionPath", ":", "this", ".", "regionPathSet", ")", "{", "if", "(", "checkCacheClosing", "(", "dm", ")", "||", "checkDSClosing", "(", "dm", ")", ")", "{", "if", "(", "dm", ".", "getCache", "(", ")", "==", "null", ")", "{", "thr", "=", "new", "CacheClosedException", "(", "LocalizedStrings", ".", "PartitionMessage_REMOTE_CACHE_IS_CLOSED_0", ".", "toLocalizedString", "(", "dm", ".", "getId", "(", ")", ")", ")", ";", "}", "else", "{", "dm", ".", "getCache", "(", ")", ".", "getCacheClosedException", "(", "LocalizedStrings", ".", "PartitionMessage_REMOTE_CACHE_IS_CLOSED_0", ".", "toLocalizedString", "(", "dm", ".", "getId", "(", ")", ")", ")", ";", "}", "return", ";", "}", "regions", ".", "add", "(", "cache", ".", "getRegion", "(", "regionPath", ")", ")", ";", "}", "}", "FunctionContextImpl", "context", "=", "new", "MultiRegionFunctionContextImpl", "(", "cache", ",", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "this", ".", "args", ",", "resultSender", ",", "regions", ",", "isReExecute", ")", ";", "long", "start", "=", "stats", ".", "startTime", "(", ")", ";", "stats", ".", "startFunctionExecution", "(", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Executing Function: {} on remote member with context: {}", "\"", ",", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "context", ".", "toString", "(", ")", ")", ";", "}", "this", ".", "functionObject", ".", "execute", "(", "context", ")", ";", "if", "(", "!", "this", ".", "replyLastMsg", "&&", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", "{", "throw", "new", "FunctionException", "(", "LocalizedStrings", ".", "ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT", ".", "toString", "(", "functionObject", ".", "getId", "(", ")", ")", ")", ";", "}", "stats", ".", "endFunctionExecution", "(", "start", ",", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "}", "catch", "(", "FunctionException", "functionException", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "FunctionException occurred on remote member while executing Function: {}", "\"", ",", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "functionException", ")", ";", "}", "stats", ".", "endFunctionExecutionWithException", "(", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "rex", "=", "new", "ReplyException", "(", "functionException", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "}", "catch", "(", "CancelException", "exception", ")", "{", "thr", "=", "new", "FunctionInvocationTargetException", "(", "exception", ")", ";", "stats", ".", "endFunctionExecutionWithException", "(", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "rex", "=", "new", "ReplyException", "(", "thr", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "}", "catch", "(", "Exception", "exception", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Exception occurred on remote member while executing Function: {}", "\"", ",", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "exception", ")", ";", "}", "stats", ".", "endFunctionExecutionWithException", "(", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "rex", "=", "new", "ReplyException", "(", "exception", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "}", "catch", "(", "VirtualMachineError", "err", ")", "{", "SystemFailure", ".", "initiateFailure", "(", "err", ")", ";", "throw", "err", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "SystemFailure", ".", "checkFailure", "(", ")", ";", "thr", "=", "t", ";", "}", "finally", "{", "cleanupTransaction", "(", "tx", ")", ";", "if", "(", "thr", "!=", "null", ")", "{", "rex", "=", "new", "ReplyException", "(", "thr", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "}", "}", "}"], "idx": 87815, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "954ccb545d24a9c9a35cbd84023a4d7e07032de0", "function_name": "process", "body_hash": "154565a64e93290941eef67ef82ff2cd9a871eab"}
{"code": "private void prepareRequest() throws IOException {\n\n        http11 = true;\n        http09 = false;\n        contentDelimitation = false;\n\n        if (endpoint.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n        MessageBytes protocolMB = request.protocol();\n        if (protocolMB.equals(Constants.HTTP_11)) {\n            protocolMB.setString(Constants.HTTP_11);\n        } else if (protocolMB.equals(Constants.HTTP_10)) {\n            http11 = false;\n            keepAlive = false;\n            protocolMB.setString(Constants.HTTP_10);\n        } else if (protocolMB.equals(\"\")) {\n            // HTTP/0.9\n            http09 = true;\n            http11 = false;\n            keepAlive = false;\n        } else {\n            // Unsupported protocol\n            http11 = false;\n            // Send 505; Unsupported HTTP version\n            response.setStatus(505);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n            }\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents != null &&\n                        restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames);\n                for (String encodingName : encodingNames) {\n                    // \"identity\" codings are ignored\n                    addInputFilter(inputFilters, encodingName);\n                }\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "http11", "=", "true", ";", "http09", "=", "false", ";", "contentDelimitation", "=", "false", ";", "if", "(", "endpoint", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MessageBytes", "protocolMB", "=", "request", ".", "protocol", "(", ")", ";", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_11", ")", ")", "{", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_11", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_10", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_10", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "\"", "\"", ")", ")", "{", "http09", "=", "true", ";", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "http11", "=", "false", ";", "response", ".", "setStatus", "(", "505", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Unsupported HTTP version ", "\\\"", "\"", "+", "protocolMB", "+", "\"", "\\\"", "\"", ")", ";", "}", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEP_ALIVE_HEADER_VALUE_TOKEN", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "inputBuffer", ".", "setSwallowInput", "(", "false", ")", ";", "request", ".", "setExpectation", "(", "true", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "(", "http11", "||", "keepAlive", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "protocol", ".", "getAllowHostHeaderMismatch", "(", ")", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "inputBuffer", ".", "getFilters", "(", ")", ";", "if", "(", "http11", ")", "{", "MessageBytes", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ";", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "}", "else", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 55623, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "959f1df", "function_name": "prepareRequest", "body_hash": "e858fa6d99052b0db701618e360adf1999261c3c"}
{"code": "@RequestMapping(\"/oauth/token/revoke/client/{clientId}\")\n    public ResponseEntity<Void> revokeTokensForClient(@PathVariable String clientId) {\n        logger.debug(\"Revoking tokens for client: \" + clientId);\n        String zoneId = IdentityZoneHolder.get().getId();\n        BaseClientDetails client = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId);\n        client.addAdditionalInformation(ClientConstants.TOKEN_SALT,generator.generate());\n        clientDetailsService.updateClientDetails(client);\n        logger.debug(\"Tokens revoked for client: \" + clientId);\n        tokenProvisioning.deleteByClient(clientId, zoneId);\n        return new ResponseEntity<>(OK);\n    }", "code_tokens": ["@", "RequestMapping", "(", "\"", "/oauth/token/revoke/client/{clientId}", "\"", ")", "public", "ResponseEntity", "<", "Void", ">", "revokeTokensForClient", "(", "@", "PathVariable", "String", "clientId", ")", "{", "logger", ".", "debug", "(", "\"", "Revoking tokens for client: ", "\"", "+", "clientId", ")", ";", "String", "zoneId", "=", "IdentityZoneHolder", ".", "get", "(", ")", ".", "getId", "(", ")", ";", "BaseClientDetails", "client", "=", "(", "BaseClientDetails", ")", "clientDetailsService", ".", "loadClientByClientId", "(", "clientId", ")", ";", "client", ".", "addAdditionalInformation", "(", "ClientConstants", ".", "TOKEN_SALT", ",", "generator", ".", "generate", "(", ")", ")", ";", "clientDetailsService", ".", "updateClientDetails", "(", "client", ")", ";", "logger", ".", "debug", "(", "\"", "Tokens revoked for client: ", "\"", "+", "clientId", ")", ";", "tokenProvisioning", ".", "deleteByClient", "(", "clientId", ",", "zoneId", ")", ";", "return", "new", "ResponseEntity", "<", ">", "(", "OK", ")", ";", "}"], "idx": 102686, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "1e2a746968cdac5b53164ca8955646e4257ecc7", "function_name": "revokeTokensForClient", "body_hash": "2c287e236781d52fc26ea98c22e3cc7c094268d4"}
{"code": "protected void setUpSSL() throws Exception {\n\t\tif (this.sslPropertiesLocation == null && this.keyStore == null && this.trustStore == null\n\t\t\t\t&& this.keyStoreResource == null && this.trustStoreResource == null) {\n\t\t\tif (this.skipServerCertificateValidation) {\n\t\t\t\tif (this.sslAlgorithmSet) {\n\t\t\t\t\tthis.connectionFactory.useSslProtocol(this.sslAlgorithm);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.connectionFactory.useSslProtocol();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuseDefaultTrustStoreMechanism();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this.sslPropertiesLocation != null) {\n\t\t\t\tthis.sslProperties.load(this.sslPropertiesLocation.getInputStream());\n\t\t\t}\n\t\t\tPathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n\t\t\tString keyStoreName = getKeyStore();\n\t\t\tString trustStoreName = getTrustStore();\n\t\t\tString keyStorePassword = getKeyStorePassphrase();\n\t\t\tString trustStorePassword = getTrustStorePassphrase();\n\t\t\tString keyStoreType = getKeyStoreType();\n\t\t\tString trustStoreType = getTrustStoreType();\n\t\t\tchar[] keyPassphrase = null;\n\t\t\tif (keyStorePassword != null) {\n\t\t\t\tkeyPassphrase = keyStorePassword.toCharArray();\n\t\t\t}\n\t\t\tchar[] trustPassphrase = null;\n\t\t\tif (trustStorePassword != null) {\n\t\t\t\ttrustPassphrase = trustStorePassword.toCharArray();\n\t\t\t}\n\t\t\tKeyManager[] keyManagers = null;\n\t\t\tTrustManager[] trustManagers = null;\n\t\t\tif (StringUtils.hasText(keyStoreName) || this.keyStoreResource != null) {\n\t\t\t\tResource keyStoreResource = this.keyStoreResource != null ? this.keyStoreResource\n\t\t\t\t\t\t: resolver.getResource(keyStoreName);\n\t\t\t\tKeyStore ks = KeyStore.getInstance(keyStoreType);\n\t\t\t\tks.load(keyStoreResource.getInputStream(), keyPassphrase);\n\t\t\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n\t\t\t\tkmf.init(ks, keyPassphrase);\n\t\t\t\tkeyManagers = kmf.getKeyManagers();\n\t\t\t}\n\t\t\tif (StringUtils.hasText(trustStoreName) || this.trustStoreResource != null) {\n\t\t\t\tResource trustStoreResource = this.trustStoreResource != null ? this.trustStoreResource\n\t\t\t\t\t\t: resolver.getResource(trustStoreName);\n\t\t\t\tKeyStore tks = KeyStore.getInstance(trustStoreType);\n\t\t\t\ttks.load(trustStoreResource.getInputStream(), trustPassphrase);\n\t\t\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n\t\t\t\ttmf.init(tks);\n\t\t\t\ttrustManagers = tmf.getTrustManagers();\n\t\t\t}\n\n\t\t\tif (this.logger.isDebugEnabled()) {\n\t\t\t\tthis.logger.debug(\"Initializing SSLContext with KM: \"\n\t\t\t\t\t\t+ Arrays.toString(keyManagers)\n\t\t\t\t\t\t+ \", TM: \" + Arrays.toString(trustManagers)\n\t\t\t\t\t\t+ \", random: \" + this.secureRandom);\n\t\t\t}\n\t\t\tSSLContext context = createSSLContext();\n\t\t\tcontext.init(keyManagers, trustManagers, this.secureRandom);\n\t\t\tthis.connectionFactory.useSslProtocol(context);\n\t\t\tcheckHostVerification();\n\t\t}\n\t}", "code_tokens": ["protected", "void", "setUpSSL", "(", ")", "throws", "Exception", "{", "if", "(", "this", ".", "sslPropertiesLocation", "==", "null", "&&", "this", ".", "keyStore", "==", "null", "&&", "this", ".", "trustStore", "==", "null", "&&", "this", ".", "keyStoreResource", "==", "null", "&&", "this", ".", "trustStoreResource", "==", "null", ")", "{", "if", "(", "this", ".", "skipServerCertificateValidation", ")", "{", "if", "(", "this", ".", "sslAlgorithmSet", ")", "{", "this", ".", "connectionFactory", ".", "useSslProtocol", "(", "this", ".", "sslAlgorithm", ")", ";", "}", "else", "{", "this", ".", "connectionFactory", ".", "useSslProtocol", "(", ")", ";", "}", "}", "else", "{", "useDefaultTrustStoreMechanism", "(", ")", ";", "}", "}", "else", "{", "if", "(", "this", ".", "sslPropertiesLocation", "!=", "null", ")", "{", "this", ".", "sslProperties", ".", "load", "(", "this", ".", "sslPropertiesLocation", ".", "getInputStream", "(", ")", ")", ";", "}", "PathMatchingResourcePatternResolver", "resolver", "=", "new", "PathMatchingResourcePatternResolver", "(", ")", ";", "String", "keyStoreName", "=", "getKeyStore", "(", ")", ";", "String", "trustStoreName", "=", "getTrustStore", "(", ")", ";", "String", "keyStorePassword", "=", "getKeyStorePassphrase", "(", ")", ";", "String", "trustStorePassword", "=", "getTrustStorePassphrase", "(", ")", ";", "String", "keyStoreType", "=", "getKeyStoreType", "(", ")", ";", "String", "trustStoreType", "=", "getTrustStoreType", "(", ")", ";", "char", "[", "]", "keyPassphrase", "=", "null", ";", "if", "(", "keyStorePassword", "!=", "null", ")", "{", "keyPassphrase", "=", "keyStorePassword", ".", "toCharArray", "(", ")", ";", "}", "char", "[", "]", "trustPassphrase", "=", "null", ";", "if", "(", "trustStorePassword", "!=", "null", ")", "{", "trustPassphrase", "=", "trustStorePassword", ".", "toCharArray", "(", ")", ";", "}", "KeyManager", "[", "]", "keyManagers", "=", "null", ";", "TrustManager", "[", "]", "trustManagers", "=", "null", ";", "if", "(", "StringUtils", ".", "hasText", "(", "keyStoreName", ")", "||", "this", ".", "keyStoreResource", "!=", "null", ")", "{", "Resource", "keyStoreResource", "=", "this", ".", "keyStoreResource", "!=", "null", "?", "this", ".", "keyStoreResource", ":", "resolver", ".", "getResource", "(", "keyStoreName", ")", ";", "KeyStore", "ks", "=", "KeyStore", ".", "getInstance", "(", "keyStoreType", ")", ";", "ks", ".", "load", "(", "keyStoreResource", ".", "getInputStream", "(", ")", ",", "keyPassphrase", ")", ";", "KeyManagerFactory", "kmf", "=", "KeyManagerFactory", ".", "getInstance", "(", "\"", "SunX509", "\"", ")", ";", "kmf", ".", "init", "(", "ks", ",", "keyPassphrase", ")", ";", "keyManagers", "=", "kmf", ".", "getKeyManagers", "(", ")", ";", "}", "if", "(", "StringUtils", ".", "hasText", "(", "trustStoreName", ")", "||", "this", ".", "trustStoreResource", "!=", "null", ")", "{", "Resource", "trustStoreResource", "=", "this", ".", "trustStoreResource", "!=", "null", "?", "this", ".", "trustStoreResource", ":", "resolver", ".", "getResource", "(", "trustStoreName", ")", ";", "KeyStore", "tks", "=", "KeyStore", ".", "getInstance", "(", "trustStoreType", ")", ";", "tks", ".", "load", "(", "trustStoreResource", ".", "getInputStream", "(", ")", ",", "trustPassphrase", ")", ";", "TrustManagerFactory", "tmf", "=", "TrustManagerFactory", ".", "getInstance", "(", "\"", "SunX509", "\"", ")", ";", "tmf", ".", "init", "(", "tks", ")", ";", "trustManagers", "=", "tmf", ".", "getTrustManagers", "(", ")", ";", "}", "if", "(", "this", ".", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "this", ".", "logger", ".", "debug", "(", "\"", "Initializing SSLContext with KM: ", "\"", "+", "Arrays", ".", "toString", "(", "keyManagers", ")", "+", "\"", ", TM: ", "\"", "+", "Arrays", ".", "toString", "(", "trustManagers", ")", "+", "\"", ", random: ", "\"", "+", "this", ".", "secureRandom", ")", ";", "}", "SSLContext", "context", "=", "createSSLContext", "(", ")", ";", "context", ".", "init", "(", "keyManagers", ",", "trustManagers", ",", "this", ".", "secureRandom", ")", ";", "this", ".", "connectionFactory", ".", "useSslProtocol", "(", "context", ")", ";", "checkHostVerification", "(", ")", ";", "}", "}"], "idx": 40638, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "d64e7fa3993dac577c0973e0caf8c31d27ef5e44", "function_name": "setUpSSL", "body_hash": "39e1449055b226719b711340cec81e4a944094ac"}
{"code": "public User getUser() {\n            return userId == null\n                    ? User.getUnknown()\n                    : User.getById(userId, true)\n            ;\n        }", "code_tokens": ["public", "User", "getUser", "(", ")", "{", "return", "userId", "==", "null", "?", "User", ".", "getUnknown", "(", ")", ":", "User", ".", "getById", "(", "userId", ",", "true", ")", ";", "}"], "idx": 13601, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "3cd946cbef82c6da5ccccf3890d0ae4e091c4265", "function_name": "getUser", "body_hash": "4d4a5bd63ee29df8239cf0b04007691f0d40ef47"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (objectMapper != null) {\n            // must be a reference value\n            String ref = objectMapper.startsWith(\"#\") ? objectMapper : \"#\" + objectMapper;\n            setProperty(camelContext, dataFormat, \"objectMapper\", ref);\n        }\n        if (unmarshalType != null) {\n            setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n        }\n        if (prettyPrint != null) {\n            setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n        }\n        if (jsonView != null) {\n            setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n        }\n        if (include != null) {\n            setProperty(camelContext, dataFormat, \"include\", include);\n        }\n        if (allowJmsType != null) {\n            setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n        }\n        if (collectionType != null) {\n            setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n        }\n        if (useList != null) {\n            setProperty(camelContext, dataFormat, \"useList\", useList);\n        }\n        if (enableJaxbAnnotationModule != null) {\n            setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n        }\n        if (moduleClassNames != null) {\n            setProperty(camelContext, dataFormat, \"moduleClassNames\", moduleClassNames);\n        }\n        if (moduleRefs != null) {\n            setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n        }\n        if (enableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n        }\n        if (disableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n        }\n        if (permissions != null) {\n            setProperty(camelContext, dataFormat, \"permissions\", permissions);\n        }\n        if (allowUnmarshallType != null) {\n            setProperty(camelContext, dataFormat, \"allowUnmarshallType\", allowUnmarshallType);\n        }\n        // if we have the unmarshal type, but no permission set, then use it to be allowed\n        if (permissions == null && unmarshalType != null) {\n            String allow = \"+\" + unmarshalType.getName();\n            setProperty(camelContext, dataFormat, \"permissions\", allow);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "objectMapper", "!=", "null", ")", "{", "String", "ref", "=", "objectMapper", ".", "startsWith", "(", "\"", "#", "\"", ")", "?", "objectMapper", ":", "\"", "#", "\"", "+", "objectMapper", ";", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "objectMapper", "\"", ",", "ref", ")", ";", "}", "if", "(", "unmarshalType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "unmarshalType", "\"", ",", "unmarshalType", ")", ";", "}", "if", "(", "prettyPrint", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "prettyPrint", "\"", ",", "prettyPrint", ")", ";", "}", "if", "(", "jsonView", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "jsonView", "\"", ",", "jsonView", ")", ";", "}", "if", "(", "include", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "include", "\"", ",", "include", ")", ";", "}", "if", "(", "allowJmsType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowJmsType", "\"", ",", "allowJmsType", ")", ";", "}", "if", "(", "collectionType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "collectionType", "\"", ",", "collectionType", ")", ";", "}", "if", "(", "useList", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "useList", "\"", ",", "useList", ")", ";", "}", "if", "(", "enableJaxbAnnotationModule", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableJaxbAnnotationModule", "\"", ",", "enableJaxbAnnotationModule", ")", ";", "}", "if", "(", "moduleClassNames", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "moduleClassNames", "\"", ",", "moduleClassNames", ")", ";", "}", "if", "(", "moduleRefs", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "moduleRefs", "\"", ",", "moduleRefs", ")", ";", "}", "if", "(", "enableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableFeatures", "\"", ",", "enableFeatures", ")", ";", "}", "if", "(", "disableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "disableFeatures", "\"", ",", "disableFeatures", ")", ";", "}", "if", "(", "permissions", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "permissions", "\"", ",", "permissions", ")", ";", "}", "if", "(", "allowUnmarshallType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowUnmarshallType", "\"", ",", "allowUnmarshallType", ")", ";", "}", "if", "(", "permissions", "==", "null", "&&", "unmarshalType", "!=", "null", ")", "{", "String", "allow", "=", "\"", "+", "\"", "+", "unmarshalType", ".", "getName", "(", ")", ";", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "permissions", "\"", ",", "allow", ")", ";", "}", "}"], "idx": 57271, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "02270ab9c90ac0d59b85dbd59fb9c1007eb44a1", "function_name": "configureDataFormat", "body_hash": "261956fcab0f76cb74d632ea659b386b713c41ed"}
{"code": "private static CloseableHttpClient getAllTrustClient(HttpHost proxy) {\n\t\t\treturn HttpClients.custom()\n\t\t\t\t\t.setProxy(proxy)\n\t\t\t\t\t.setSslcontext(getSSLContext())\n\t\t\t\t\t.setHostnameVerifier(SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)\n\t\t\t\t\t.build();\n\t\t}", "code_tokens": ["private", "static", "CloseableHttpClient", "getAllTrustClient", "(", "HttpHost", "proxy", ")", "{", "return", "HttpClients", ".", "custom", "(", ")", ".", "setProxy", "(", "proxy", ")", ".", "setSslcontext", "(", "getSSLContext", "(", ")", ")", ".", "setHostnameVerifier", "(", "SSLConnectionSocketFactory", ".", "ALLOW_ALL_HOSTNAME_VERIFIER", ")", ".", "build", "(", ")", ";", "}"], "idx": 45759, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "5151e115", "function_name": "getAllTrustClient", "body_hash": "d45af3856dc83c7c35d8165750f473e6fdbb600f"}
{"code": "public Script compile() throws CompilationFailedException {\r\n        Binding binding = new Binding();\r\n        binding.setVariable(\"falsePositive\", falsePositive);\r\n        GroovyShell shell = new GroovyShell(WarningsDescriptor.class.getClassLoader(), binding);\r\n        return shell.parse(script);\r\n    }", "code_tokens": ["public", "Script", "compile", "(", ")", "throws", "CompilationFailedException", "{", "Binding", "binding", "=", "new", "Binding", "(", ")", ";", "binding", ".", "setVariable", "(", "\"", "falsePositive", "\"", ",", "falsePositive", ")", ";", "GroovyShell", "shell", "=", "new", "GroovyShell", "(", "WarningsDescriptor", ".", "class", ".", "getClassLoader", "(", ")", ",", "binding", ")", ";", "return", "shell", ".", "parse", "(", "script", ")", ";", "}"], "idx": 46301, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "32ee47ee6e067bbd77ec6559f81a6b206abad059", "function_name": "compile", "body_hash": "ee3a2a4e28843cab16ef77fbf7abea5e3481e7a7"}
{"code": "@Override\n    public void send(Map<String, String> config, UserModel user, String subject, String textBody, String htmlBody) throws EmailException {\n        Transport transport = null;\n        try {\n            String address = retrieveEmailAddress(user);\n\n            Properties props = new Properties();\n\n            if (config.containsKey(\"host\")) {\n                props.setProperty(\"mail.smtp.host\", config.get(\"host\"));\n            }\n\n            boolean auth = \"true\".equals(config.get(\"auth\"));\n            boolean ssl = \"true\".equals(config.get(\"ssl\"));\n            boolean starttls = \"true\".equals(config.get(\"starttls\"));\n\n            if (config.containsKey(\"port\") && config.get(\"port\") != null) {\n                props.setProperty(\"mail.smtp.port\", config.get(\"port\"));\n            }\n\n            if (auth) {\n                props.setProperty(\"mail.smtp.auth\", \"true\");\n            }\n\n            if (ssl) {\n                props.setProperty(\"mail.smtp.ssl.enable\", \"true\");\n            }\n\n            if (starttls) {\n                props.setProperty(\"mail.smtp.starttls.enable\", \"true\");\n            }\n\n            if (ssl || starttls) {\n                props.put(\"mail.smtp.ssl.protocols\", SUPPORTED_SSL_PROTOCOLS);\n\n                setupTruststore(props);\n            }\n\n            props.setProperty(\"mail.smtp.timeout\", \"10000\");\n            props.setProperty(\"mail.smtp.connectiontimeout\", \"10000\");\n\n            String from = config.get(\"from\");\n            String fromDisplayName = config.get(\"fromDisplayName\");\n            String replyTo = config.get(\"replyTo\");\n            String replyToDisplayName = config.get(\"replyToDisplayName\");\n            String envelopeFrom = config.get(\"envelopeFrom\");\n\n            Session session = Session.getInstance(props);\n\n            Multipart multipart = new MimeMultipart(\"alternative\");\n\n            if (textBody != null) {\n                MimeBodyPart textPart = new MimeBodyPart();\n                textPart.setText(textBody, \"UTF-8\");\n                multipart.addBodyPart(textPart);\n            }\n\n            if (htmlBody != null) {\n                MimeBodyPart htmlPart = new MimeBodyPart();\n                htmlPart.setContent(htmlBody, \"text/html; charset=UTF-8\");\n                multipart.addBodyPart(htmlPart);\n            }\n\n            SMTPMessage msg = new SMTPMessage(session);\n            msg.setFrom(toInternetAddress(from, fromDisplayName));\n\n            msg.setReplyTo(new Address[]{toInternetAddress(from, fromDisplayName)});\n            if (replyTo != null && !replyTo.isEmpty()) {\n                msg.setReplyTo(new Address[]{toInternetAddress(replyTo, replyToDisplayName)});\n            }\n            if (envelopeFrom != null && !envelopeFrom.isEmpty()) {\n                msg.setEnvelopeFrom(envelopeFrom);\n            }\n\n            msg.setHeader(\"To\", address);\n            msg.setSubject(subject, \"utf-8\");\n            msg.setContent(multipart);\n            msg.saveChanges();\n            msg.setSentDate(new Date());\n\n            transport = session.getTransport(\"smtp\");\n            if (auth) {\n                try (VaultStringSecret vaultStringSecret = this.session.vault().getStringSecret(config.get(\"password\"))) {\n                    transport.connect(config.get(\"user\"), vaultStringSecret.get().orElse(config.get(\"password\")));\n                }\n            } else {\n                transport.connect();\n            }\n            transport.sendMessage(msg, new InternetAddress[]{new InternetAddress(address)});\n        } catch (Exception e) {\n            ServicesLogger.LOGGER.failedToSendEmail(e);\n            throw new EmailException(e);\n        } finally {\n            if (transport != null) {\n                try {\n                    transport.close();\n                } catch (MessagingException e) {\n                    logger.warn(\"Failed to close transport\", e);\n                }\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "send", "(", "Map", "<", "String", ",", "String", ">", "config", ",", "UserModel", "user", ",", "String", "subject", ",", "String", "textBody", ",", "String", "htmlBody", ")", "throws", "EmailException", "{", "Transport", "transport", "=", "null", ";", "try", "{", "String", "address", "=", "retrieveEmailAddress", "(", "user", ")", ";", "Properties", "props", "=", "new", "Properties", "(", ")", ";", "if", "(", "config", ".", "containsKey", "(", "\"", "host", "\"", ")", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.host", "\"", ",", "config", ".", "get", "(", "\"", "host", "\"", ")", ")", ";", "}", "boolean", "auth", "=", "\"", "true", "\"", ".", "equals", "(", "config", ".", "get", "(", "\"", "auth", "\"", ")", ")", ";", "boolean", "ssl", "=", "\"", "true", "\"", ".", "equals", "(", "config", ".", "get", "(", "\"", "ssl", "\"", ")", ")", ";", "boolean", "starttls", "=", "\"", "true", "\"", ".", "equals", "(", "config", ".", "get", "(", "\"", "starttls", "\"", ")", ")", ";", "if", "(", "config", ".", "containsKey", "(", "\"", "port", "\"", ")", "&&", "config", ".", "get", "(", "\"", "port", "\"", ")", "!=", "null", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.port", "\"", ",", "config", ".", "get", "(", "\"", "port", "\"", ")", ")", ";", "}", "if", "(", "auth", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.auth", "\"", ",", "\"", "true", "\"", ")", ";", "}", "if", "(", "ssl", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.ssl.enable", "\"", ",", "\"", "true", "\"", ")", ";", "}", "if", "(", "starttls", ")", "{", "props", ".", "setProperty", "(", "\"", "mail.smtp.starttls.enable", "\"", ",", "\"", "true", "\"", ")", ";", "}", "if", "(", "ssl", "||", "starttls", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.ssl.protocols", "\"", ",", "SUPPORTED_SSL_PROTOCOLS", ")", ";", "setupTruststore", "(", "props", ")", ";", "}", "props", ".", "setProperty", "(", "\"", "mail.smtp.timeout", "\"", ",", "\"", "10000", "\"", ")", ";", "props", ".", "setProperty", "(", "\"", "mail.smtp.connectiontimeout", "\"", ",", "\"", "10000", "\"", ")", ";", "String", "from", "=", "config", ".", "get", "(", "\"", "from", "\"", ")", ";", "String", "fromDisplayName", "=", "config", ".", "get", "(", "\"", "fromDisplayName", "\"", ")", ";", "String", "replyTo", "=", "config", ".", "get", "(", "\"", "replyTo", "\"", ")", ";", "String", "replyToDisplayName", "=", "config", ".", "get", "(", "\"", "replyToDisplayName", "\"", ")", ";", "String", "envelopeFrom", "=", "config", ".", "get", "(", "\"", "envelopeFrom", "\"", ")", ";", "Session", "session", "=", "Session", ".", "getInstance", "(", "props", ")", ";", "Multipart", "multipart", "=", "new", "MimeMultipart", "(", "\"", "alternative", "\"", ")", ";", "if", "(", "textBody", "!=", "null", ")", "{", "MimeBodyPart", "textPart", "=", "new", "MimeBodyPart", "(", ")", ";", "textPart", ".", "setText", "(", "textBody", ",", "\"", "UTF-8", "\"", ")", ";", "multipart", ".", "addBodyPart", "(", "textPart", ")", ";", "}", "if", "(", "htmlBody", "!=", "null", ")", "{", "MimeBodyPart", "htmlPart", "=", "new", "MimeBodyPart", "(", ")", ";", "htmlPart", ".", "setContent", "(", "htmlBody", ",", "\"", "text/html; charset=UTF-8", "\"", ")", ";", "multipart", ".", "addBodyPart", "(", "htmlPart", ")", ";", "}", "SMTPMessage", "msg", "=", "new", "SMTPMessage", "(", "session", ")", ";", "msg", ".", "setFrom", "(", "toInternetAddress", "(", "from", ",", "fromDisplayName", ")", ")", ";", "msg", ".", "setReplyTo", "(", "new", "Address", "[", "]", "{", "toInternetAddress", "(", "from", ",", "fromDisplayName", ")", "}", ")", ";", "if", "(", "replyTo", "!=", "null", "&&", "!", "replyTo", ".", "isEmpty", "(", ")", ")", "{", "msg", ".", "setReplyTo", "(", "new", "Address", "[", "]", "{", "toInternetAddress", "(", "replyTo", ",", "replyToDisplayName", ")", "}", ")", ";", "}", "if", "(", "envelopeFrom", "!=", "null", "&&", "!", "envelopeFrom", ".", "isEmpty", "(", ")", ")", "{", "msg", ".", "setEnvelopeFrom", "(", "envelopeFrom", ")", ";", "}", "msg", ".", "setHeader", "(", "\"", "To", "\"", ",", "address", ")", ";", "msg", ".", "setSubject", "(", "subject", ",", "\"", "utf-8", "\"", ")", ";", "msg", ".", "setContent", "(", "multipart", ")", ";", "msg", ".", "saveChanges", "(", ")", ";", "msg", ".", "setSentDate", "(", "new", "Date", "(", ")", ")", ";", "transport", "=", "session", ".", "getTransport", "(", "\"", "smtp", "\"", ")", ";", "if", "(", "auth", ")", "{", "try", "(", "VaultStringSecret", "vaultStringSecret", "=", "this", ".", "session", ".", "vault", "(", ")", ".", "getStringSecret", "(", "config", ".", "get", "(", "\"", "password", "\"", ")", ")", ")", "{", "transport", ".", "connect", "(", "config", ".", "get", "(", "\"", "user", "\"", ")", ",", "vaultStringSecret", ".", "get", "(", ")", ".", "orElse", "(", "config", ".", "get", "(", "\"", "password", "\"", ")", ")", ")", ";", "}", "}", "else", "{", "transport", ".", "connect", "(", ")", ";", "}", "transport", ".", "sendMessage", "(", "msg", ",", "new", "InternetAddress", "[", "]", "{", "new", "InternetAddress", "(", "address", ")", "}", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "ServicesLogger", ".", "LOGGER", ".", "failedToSendEmail", "(", "e", ")", ";", "throw", "new", "EmailException", "(", "e", ")", ";", "}", "finally", "{", "if", "(", "transport", "!=", "null", ")", "{", "try", "{", "transport", ".", "close", "(", ")", ";", "}", "catch", "(", "MessagingException", "e", ")", "{", "logger", ".", "warn", "(", "\"", "Failed to close transport", "\"", ",", "e", ")", ";", "}", "}", "}", "}"], "idx": 40503, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "97b565469058cacac6d2559b2cff37effcca2cfd", "function_name": "send", "body_hash": "e2ae8053af9c798631dfe80b9c453a2b33e76490"}
{"code": "public static void setHiveConfWhiteList(HiveConf hiveConf) throws HiveAuthzPluginException {\n\n    String whiteListParamsStr = hiveConf\n        .getVar(ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST);\n\n    if(whiteListParamsStr == null || whiteListParamsStr.trim().isEmpty()) {\n      throw new HiveAuthzPluginException(\"Configuration parameter \"\n          + ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST.varname\n          + \" is not initialized.\");\n    }\n\n    // append regexes that user wanted to add\n    String whiteListAppend = hiveConf\n        .getVar(ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST_APPEND);\n    if (whiteListAppend != null && !whiteListAppend.trim().equals(\"\")) {\n      whiteListParamsStr = whiteListParamsStr + \"|\" + whiteListAppend;\n    }\n\n    hiveConf.setModifiableWhiteListRegex(whiteListParamsStr);\n\n    // disallow udfs that can potentially allow untrusted code execution\n    // if admin has already customized this list, honor that\n    String curBlackList = hiveConf.getVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST);\n    if (curBlackList == null || curBlackList.trim().isEmpty()) {\n      hiveConf.setVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST, \"reflect,reflect2,java_method\");\n    }\n  }", "code_tokens": ["public", "static", "void", "setHiveConfWhiteList", "(", "HiveConf", "hiveConf", ")", "throws", "HiveAuthzPluginException", "{", "String", "whiteListParamsStr", "=", "hiveConf", ".", "getVar", "(", "ConfVars", ".", "HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST", ")", ";", "if", "(", "whiteListParamsStr", "==", "null", "||", "whiteListParamsStr", ".", "trim", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "HiveAuthzPluginException", "(", "\"", "Configuration parameter ", "\"", "+", "ConfVars", ".", "HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST", ".", "varname", "+", "\"", " is not initialized.", "\"", ")", ";", "}", "String", "whiteListAppend", "=", "hiveConf", ".", "getVar", "(", "ConfVars", ".", "HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST_APPEND", ")", ";", "if", "(", "whiteListAppend", "!=", "null", "&&", "!", "whiteListAppend", ".", "trim", "(", ")", ".", "equals", "(", "\"", "\"", ")", ")", "{", "whiteListParamsStr", "=", "whiteListParamsStr", "+", "\"", "|", "\"", "+", "whiteListAppend", ";", "}", "hiveConf", ".", "setModifiableWhiteListRegex", "(", "whiteListParamsStr", ")", ";", "String", "curBlackList", "=", "hiveConf", ".", "getVar", "(", "ConfVars", ".", "HIVE_SERVER2_BUILTIN_UDF_BLACKLIST", ")", ";", "if", "(", "curBlackList", "==", "null", "||", "curBlackList", ".", "trim", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "hiveConf", ".", "setVar", "(", "ConfVars", ".", "HIVE_SERVER2_BUILTIN_UDF_BLACKLIST", ",", "\"", "reflect,reflect2,java_method", "\"", ")", ";", "}", "}"], "idx": 102474, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "1a1d6ca1bc3ae840238dc345fa1eb2c7c28c8cb", "function_name": "setHiveConfWhiteList", "body_hash": "2aa55aa3e0091afb4450beca745b9404c41c533d"}
{"code": "@Override\n    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        if (log.isDebugEnabled())\n            log.debug(\"Security checking request \" +\n                request.getMethod() + \" \" + request.getRequestURI());\n        LoginConfig config = this.context.getLoginConfig();\n\n        // Have we got a cached authenticated Principal to record?\n        if (cache) {\n            Principal principal = request.getUserPrincipal();\n            if (principal == null) {\n                Session session = request.getSessionInternal(false);\n                if (session != null) {\n                    principal = session.getPrincipal();\n                    if (principal != null) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"We have cached auth type \" +\n                                session.getAuthType() +\n                                \" for principal \" +\n                                session.getPrincipal());\n                        request.setAuthType(session.getAuthType());\n                        request.setUserPrincipal(principal);\n                    }\n                }\n            }\n        }\n\n        // Special handling for form-based logins to deal with the case\n        // where the login form (and therefore the \"j_security_check\" URI\n        // to which it submits) might be outside the secured area\n        String contextPath = this.context.getPath();\n        String requestURI = request.getDecodedRequestURI();\n        if (requestURI.startsWith(contextPath) &&\n            requestURI.endsWith(Constants.FORM_ACTION)) {\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled())\n                    log.debug(\" Failed authenticate() test ??\" + requestURI );\n                return;\n            }\n        }\n\n        // The Servlet may specify security constraints through annotations.\n        // Ensure that they have been processed before constraints are checked\n        Wrapper wrapper = (Wrapper) request.getMappingData().wrapper; \n        if (wrapper.getServlet() != null) {\n            wrapper.load();\n        }\n\n        Realm realm = this.context.getRealm();\n        // Is this request URI subject to a security constraint?\n        SecurityConstraint [] constraints\n            = realm.findSecurityConstraints(request, this.context);\n       \n        if ((constraints == null) /* &&\n            (!Constants.FORM_METHOD.equals(config.getAuthMethod())) */ ) {\n            if (log.isDebugEnabled())\n                log.debug(\" Not subject to any constraint\");\n            getNext().invoke(request, response);\n            return;\n        }\n\n        // Make sure that constrained resources are not cached by web proxies\n        // or browsers as caching can provide a security hole\n        if (disableProxyCaching && \n            // FIXME: Disabled for Mozilla FORM support over SSL \n            // (improper caching issue)\n            //!request.isSecure() &&\n            !\"POST\".equalsIgnoreCase(request.getMethod())) {\n            if (securePagesWithPragma) {\n                // FIXME: These cause problems with downloading office docs\n                // from IE under SSL and may not be needed for newer Mozilla\n                // clients.\n                response.setHeader(\"Pragma\", \"No-cache\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n            } else {\n                response.setHeader(\"Cache-Control\", \"private\");\n            }\n            response.setHeader(\"Expires\", DATE_ONE);\n        }\n\n        int i;\n        // Enforce any user data constraint for this security constraint\n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling hasUserDataPermission()\");\n        }\n        if (!realm.hasUserDataPermission(request, response,\n                                         constraints)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed hasUserDataPermission() test\");\n            }\n            /*\n             * ASSERT: Authenticator already set the appropriate\n             * HTTP status code, so we do not have to do anything special\n             */\n            return;\n        }\n\n        // Since authenticate modifies the response on failure,\n        // we have to check for allow-from-all first.\n        boolean authRequired = true;\n        for(i=0; i < constraints.length && authRequired; i++) {\n            if(!constraints[i].getAuthConstraint()) {\n                authRequired = false;\n            } else if(!constraints[i].getAllRoles()) {\n                String [] roles = constraints[i].findAuthRoles();\n                if(roles == null || roles.length == 0) {\n                    authRequired = false;\n                }\n            }\n        }\n             \n        if(authRequired) {  \n            if (log.isDebugEnabled()) {\n                log.debug(\" Calling authenticate()\");\n            }\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\" Failed authenticate() test\");\n                }\n                /*\n                 * ASSERT: Authenticator already set the appropriate\n                 * HTTP status code, so we do not have to do anything\n                 * special\n                 */\n                return;\n            } \n            \n        }\n    \n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling accessControl()\");\n        }\n        if (!realm.hasResourcePermission(request, response,\n                                         constraints,\n                                         this.context)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed accessControl() test\");\n            }\n            /*\n             * ASSERT: AccessControl method has already set the\n             * appropriate HTTP status code, so we do not have to do\n             * anything special\n             */\n            return;\n        }\n    \n        // Any and all specified constraints have been satisfied\n        if (log.isDebugEnabled()) {\n            log.debug(\" Successfully passed all security constraints\");\n        }\n        getNext().invoke(request, response);\n\n    }", "code_tokens": ["@", "Override", "public", "void", "invoke", "(", "Request", "request", ",", "Response", "response", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Security checking request ", "\"", "+", "request", ".", "getMethod", "(", ")", "+", "\"", " ", "\"", "+", "request", ".", "getRequestURI", "(", ")", ")", ";", "LoginConfig", "config", "=", "this", ".", "context", ".", "getLoginConfig", "(", ")", ";", "if", "(", "cache", ")", "{", "Principal", "principal", "=", "request", ".", "getUserPrincipal", "(", ")", ";", "if", "(", "principal", "==", "null", ")", "{", "Session", "session", "=", "request", ".", "getSessionInternal", "(", "false", ")", ";", "if", "(", "session", "!=", "null", ")", "{", "principal", "=", "session", ".", "getPrincipal", "(", ")", ";", "if", "(", "principal", "!=", "null", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "We have cached auth type ", "\"", "+", "session", ".", "getAuthType", "(", ")", "+", "\"", " for principal ", "\"", "+", "session", ".", "getPrincipal", "(", ")", ")", ";", "request", ".", "setAuthType", "(", "session", ".", "getAuthType", "(", ")", ")", ";", "request", ".", "setUserPrincipal", "(", "principal", ")", ";", "}", "}", "}", "}", "String", "contextPath", "=", "this", ".", "context", ".", "getPath", "(", ")", ";", "String", "requestURI", "=", "request", ".", "getDecodedRequestURI", "(", ")", ";", "if", "(", "requestURI", ".", "startsWith", "(", "contextPath", ")", "&&", "requestURI", ".", "endsWith", "(", "Constants", ".", "FORM_ACTION", ")", ")", "{", "if", "(", "!", "authenticate", "(", "request", ",", "response", ",", "config", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", " Failed authenticate() test ??", "\"", "+", "requestURI", ")", ";", "return", ";", "}", "}", "Wrapper", "wrapper", "=", "(", "Wrapper", ")", "request", ".", "getMappingData", "(", ")", ".", "wrapper", ";", "if", "(", "wrapper", ".", "getServlet", "(", ")", "!=", "null", ")", "{", "wrapper", ".", "load", "(", ")", ";", "}", "Realm", "realm", "=", "this", ".", "context", ".", "getRealm", "(", ")", ";", "SecurityConstraint", "[", "]", "constraints", "=", "realm", ".", "findSecurityConstraints", "(", "request", ",", "this", ".", "context", ")", ";", "if", "(", "(", "constraints", "==", "null", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", " Not subject to any constraint", "\"", ")", ";", "getNext", "(", ")", ".", "invoke", "(", "request", ",", "response", ")", ";", "return", ";", "}", "if", "(", "disableProxyCaching", "&&", "!", "\"", "POST", "\"", ".", "equalsIgnoreCase", "(", "request", ".", "getMethod", "(", ")", ")", ")", "{", "if", "(", "securePagesWithPragma", ")", "{", "response", ".", "setHeader", "(", "\"", "Pragma", "\"", ",", "\"", "No-cache", "\"", ")", ";", "response", ".", "setHeader", "(", "\"", "Cache-Control", "\"", ",", "\"", "no-cache", "\"", ")", ";", "}", "else", "{", "response", ".", "setHeader", "(", "\"", "Cache-Control", "\"", ",", "\"", "private", "\"", ")", ";", "}", "response", ".", "setHeader", "(", "\"", "Expires", "\"", ",", "DATE_ONE", ")", ";", "}", "int", "i", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Calling hasUserDataPermission()", "\"", ")", ";", "}", "if", "(", "!", "realm", ".", "hasUserDataPermission", "(", "request", ",", "response", ",", "constraints", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Failed hasUserDataPermission() test", "\"", ")", ";", "}", "return", ";", "}", "boolean", "authRequired", "=", "true", ";", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", "&&", "authRequired", ";", "i", "++", ")", "{", "if", "(", "!", "constraints", "[", "i", "]", ".", "getAuthConstraint", "(", ")", ")", "{", "authRequired", "=", "false", ";", "}", "else", "if", "(", "!", "constraints", "[", "i", "]", ".", "getAllRoles", "(", ")", ")", "{", "String", "[", "]", "roles", "=", "constraints", "[", "i", "]", ".", "findAuthRoles", "(", ")", ";", "if", "(", "roles", "==", "null", "||", "roles", ".", "length", "==", "0", ")", "{", "authRequired", "=", "false", ";", "}", "}", "}", "if", "(", "authRequired", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Calling authenticate()", "\"", ")", ";", "}", "if", "(", "!", "authenticate", "(", "request", ",", "response", ",", "config", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Failed authenticate() test", "\"", ")", ";", "}", "return", ";", "}", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Calling accessControl()", "\"", ")", ";", "}", "if", "(", "!", "realm", ".", "hasResourcePermission", "(", "request", ",", "response", ",", "constraints", ",", "this", ".", "context", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Failed accessControl() test", "\"", ")", ";", "}", "return", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Successfully passed all security constraints", "\"", ")", ";", "}", "getNext", "(", ")", ".", "invoke", "(", "request", ",", "response", ")", ";", "}"], "idx": 111283, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "2d7dbfe4c63a4242a9b28fdb662d91ceb7a84630", "function_name": "invoke", "body_hash": "83ead130b528b5df1f9c2a2501a0b087a9c11870"}
{"code": "private Optional<Style> tryLoadSLD(\n            final byte[] bytes, final Integer styleIndex,\n            final ClientHttpRequestFactory clientHttpRequestFactory) {\n        Assert.isTrue(styleIndex == null || styleIndex > -1,\n                      \"styleIndex must be > -1 but was: \" + styleIndex);\n\n        final Style[] styles;\n        try {\n\n            // check if the XML is valid\n            // this is only done in a separate step to avoid that fatal errors show up in the logs\n            // by setting a custom error handler.\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            db.setErrorHandler(new ErrorHandler());\n            db.parse(new ByteArrayInputStream(bytes));\n\n            // then read the styles\n            final SLDParser sldParser = new SLDParser(CommonFactoryFinder.getStyleFactory());\n            sldParser.setOnLineResourceLocator(new DefaultResourceLocator() {\n                @Override\n                public URL locateResource(final String uri) {\n                    try {\n                        final URL theUrl = super.locateResource(uri);\n                        final URI theUri;\n                        if (theUrl != null) {\n                            theUri = theUrl.toURI();\n                        } else {\n                            theUri = URI.create(uri);\n                        }\n                        if (theUri.getScheme().startsWith(\"http\")) {\n                            final ClientHttpRequest request = clientHttpRequestFactory.createRequest(\n                                    theUri, HttpMethod.GET);\n                            return request.getURI().toURL();\n                        }\n                        return null;\n                    } catch (IOException | URISyntaxException e) {\n                        return null;\n                    }\n                }\n            });\n            sldParser.setInput(new ByteArrayInputStream(bytes));\n            styles = sldParser.readXML();\n\n        } catch (Throwable e) {\n            return Optional.empty();\n        }\n\n        if (styleIndex != null) {\n            Assert.isTrue(styleIndex < styles.length, String.format(\"There where %s styles in file but \" +\n                                                                            \"requested index was: %s\",\n                                                                    styles.length, styleIndex + 1));\n        } else {\n            Assert.isTrue(styles.length < 2, String.format(\"There are %s therefore the styleRef must \" +\n                                                                   \"contain an index identifying the style.\" +\n                                                                   \"  The index starts at 1 for the first \" +\n                                                                   \"style.\\n\" +\n                                                                   \"\\tExample: thinline.sld##1\",\n                                                           styles.length));\n        }\n\n        if (styleIndex == null) {\n            return Optional.of(styles[0]);\n        } else {\n            return Optional.of(styles[styleIndex]);\n        }\n    }", "code_tokens": ["private", "Optional", "<", "Style", ">", "tryLoadSLD", "(", "final", "byte", "[", "]", "bytes", ",", "final", "Integer", "styleIndex", ",", "final", "ClientHttpRequestFactory", "clientHttpRequestFactory", ")", "{", "Assert", ".", "isTrue", "(", "styleIndex", "==", "null", "||", "styleIndex", ">", "-", "1", ",", "\"", "styleIndex must be > -1 but was: ", "\"", "+", "styleIndex", ")", ";", "final", "Style", "[", "]", "styles", ";", "try", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "dbf", ".", "setNamespaceAware", "(", "true", ")", ";", "dbf", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "DocumentBuilder", "db", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "db", ".", "setErrorHandler", "(", "new", "ErrorHandler", "(", ")", ")", ";", "db", ".", "parse", "(", "new", "ByteArrayInputStream", "(", "bytes", ")", ")", ";", "final", "SLDParser", "sldParser", "=", "new", "SLDParser", "(", "CommonFactoryFinder", ".", "getStyleFactory", "(", ")", ")", ";", "sldParser", ".", "setOnLineResourceLocator", "(", "new", "DefaultResourceLocator", "(", ")", "{", "@", "Override", "public", "URL", "locateResource", "(", "final", "String", "uri", ")", "{", "try", "{", "final", "URL", "theUrl", "=", "super", ".", "locateResource", "(", "uri", ")", ";", "final", "URI", "theUri", ";", "if", "(", "theUrl", "!=", "null", ")", "{", "theUri", "=", "theUrl", ".", "toURI", "(", ")", ";", "}", "else", "{", "theUri", "=", "URI", ".", "create", "(", "uri", ")", ";", "}", "if", "(", "theUri", ".", "getScheme", "(", ")", ".", "startsWith", "(", "\"", "http", "\"", ")", ")", "{", "final", "ClientHttpRequest", "request", "=", "clientHttpRequestFactory", ".", "createRequest", "(", "theUri", ",", "HttpMethod", ".", "GET", ")", ";", "return", "request", ".", "getURI", "(", ")", ".", "toURL", "(", ")", ";", "}", "return", "null", ";", "}", "catch", "(", "IOException", "|", "URISyntaxException", "e", ")", "{", "return", "null", ";", "}", "}", "}", ")", ";", "sldParser", ".", "setInput", "(", "new", "ByteArrayInputStream", "(", "bytes", ")", ")", ";", "styles", "=", "sldParser", ".", "readXML", "(", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "return", "Optional", ".", "empty", "(", ")", ";", "}", "if", "(", "styleIndex", "!=", "null", ")", "{", "Assert", ".", "isTrue", "(", "styleIndex", "<", "styles", ".", "length", ",", "String", ".", "format", "(", "\"", "There where %s styles in file but ", "\"", "+", "\"", "requested index was: %s", "\"", ",", "styles", ".", "length", ",", "styleIndex", "+", "1", ")", ")", ";", "}", "else", "{", "Assert", ".", "isTrue", "(", "styles", ".", "length", "<", "2", ",", "String", ".", "format", "(", "\"", "There are %s therefore the styleRef must ", "\"", "+", "\"", "contain an index identifying the style.", "\"", "+", "\"", "  The index starts at 1 for the first ", "\"", "+", "\"", "style.", "\\n", "\"", "+", "\"", "\\t", "Example: thinline.sld##1", "\"", ",", "styles", ".", "length", ")", ")", ";", "}", "if", "(", "styleIndex", "==", "null", ")", "{", "return", "Optional", ".", "of", "(", "styles", "[", "0", "]", ")", ";", "}", "else", "{", "return", "Optional", ".", "of", "(", "styles", "[", "styleIndex", "]", ")", ";", "}", "}"], "idx": 67343, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "e1d0527d13db06b2b62ca7d6afb9e97dacd67a0e", "function_name": "tryLoadSLD", "body_hash": "8b7b1a10d3edf19e24ce9a1cd8531acf0778ec76"}
{"code": "@Override\n    public HeaderEmitter headersStart(int streamId, boolean headersEndStream)\n            throws Http2Exception, IOException {\n\n        // Check the pause state before processing headers since the pause state\n        // determines if a new stream is created or if this stream is ignored.\n        checkPauseState();\n\n        if (connectionState.get().isNewStreamAllowed()) {\n            Stream stream = getStream(streamId, false);\n            if (stream == null) {\n                stream = createRemoteStream(streamId);\n            }\n            if (streamId < maxActiveRemoteStreamId) {\n                throw new ConnectionException(sm.getString(\"upgradeHandler.stream.old\",\n                        Integer.valueOf(streamId), Integer.valueOf(maxActiveRemoteStreamId)),\n                        Http2Error.PROTOCOL_ERROR);\n            }\n            stream.checkState(FrameType.HEADERS);\n            stream.receivedStartOfHeaders(headersEndStream);\n            closeIdleStreams(streamId);\n            if (localSettings.getMaxConcurrentStreams() < activeRemoteStreamCount.incrementAndGet()) {\n                setConnectionTimeoutForStreamCount(activeRemoteStreamCount.decrementAndGet());\n                // Ignoring maxConcurrentStreams increases the overhead count\n                increaseOverheadCount();\n                throw new StreamException(sm.getString(\"upgradeHandler.tooManyRemoteStreams\",\n                        Long.toString(localSettings.getMaxConcurrentStreams())),\n                        Http2Error.REFUSED_STREAM, streamId);\n            }\n            // Valid new stream reduces the overhead count\n            reduceOverheadCount();\n            return stream;\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"upgradeHandler.noNewStreams\",\n                        connectionId, Integer.toString(streamId)));\n            }\n            reduceOverheadCount();\n            // Stateless so a static can be used to save on GC\n            return HEADER_SINK;\n        }\n    }", "code_tokens": ["@", "Override", "public", "HeaderEmitter", "headersStart", "(", "int", "streamId", ",", "boolean", "headersEndStream", ")", "throws", "Http2Exception", ",", "IOException", "{", "checkPauseState", "(", ")", ";", "if", "(", "connectionState", ".", "get", "(", ")", ".", "isNewStreamAllowed", "(", ")", ")", "{", "Stream", "stream", "=", "getStream", "(", "streamId", ",", "false", ")", ";", "if", "(", "stream", "==", "null", ")", "{", "stream", "=", "createRemoteStream", "(", "streamId", ")", ";", "}", "if", "(", "streamId", "<", "maxActiveRemoteStreamId", ")", "{", "throw", "new", "ConnectionException", "(", "sm", ".", "getString", "(", "\"", "upgradeHandler.stream.old", "\"", ",", "Integer", ".", "valueOf", "(", "streamId", ")", ",", "Integer", ".", "valueOf", "(", "maxActiveRemoteStreamId", ")", ")", ",", "Http2Error", ".", "PROTOCOL_ERROR", ")", ";", "}", "stream", ".", "checkState", "(", "FrameType", ".", "HEADERS", ")", ";", "stream", ".", "receivedStartOfHeaders", "(", "headersEndStream", ")", ";", "closeIdleStreams", "(", "streamId", ")", ";", "if", "(", "localSettings", ".", "getMaxConcurrentStreams", "(", ")", "<", "activeRemoteStreamCount", ".", "incrementAndGet", "(", ")", ")", "{", "setConnectionTimeoutForStreamCount", "(", "activeRemoteStreamCount", ".", "decrementAndGet", "(", ")", ")", ";", "increaseOverheadCount", "(", ")", ";", "throw", "new", "StreamException", "(", "sm", ".", "getString", "(", "\"", "upgradeHandler.tooManyRemoteStreams", "\"", ",", "Long", ".", "toString", "(", "localSettings", ".", "getMaxConcurrentStreams", "(", ")", ")", ")", ",", "Http2Error", ".", "REFUSED_STREAM", ",", "streamId", ")", ";", "}", "reduceOverheadCount", "(", ")", ";", "return", "stream", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "upgradeHandler.noNewStreams", "\"", ",", "connectionId", ",", "Integer", ".", "toString", "(", "streamId", ")", ")", ")", ";", "}", "reduceOverheadCount", "(", ")", ";", "return", "HEADER_SINK", ";", "}", "}"], "idx": 99693, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "1bbc650cbc3f08d85a1ec6d803c47ae53a84f3bb", "function_name": "headersStart", "body_hash": "403a88660460d373e1ef357d2c1f3a57b802c7b4"}
{"code": "@Configuration\n    public Option[] config() throws InterruptedException {\n\n        MavenArtifactUrlReference karafUrl = maven()\n                .groupId(\"org.apache.unomi\")\n                .artifactId(\"unomi\")\n                .type(\"tar.gz\")\n                .versionAsInProject();\n\n        MavenUrlReference routerRepo = maven()\n                .groupId(\"org.apache.unomi\")\n                .artifactId(\"unomi-router-karaf-feature\")\n                .classifier(\"features\")\n                .type(\"xml\")\n                .versionAsInProject();\n\n        List<Option> options = new ArrayList<>();\n\n        Option[] commonOptions = new Option[]{\n                debugConfiguration(\"5006\", false),\n                karafDistributionConfiguration()\n                        .frameworkUrl(karafUrl)\n                        .unpackDirectory(new File(KARAF_DIR))\n                        .useDeployFolder(true),\n                replaceConfigurationFile(\"etc/org.apache.unomi.router.cfg\", new File(\n                        \"src/test/resources/org.apache.unomi.router.cfg\")),\n                replaceConfigurationFile(\"data/tmp/1-basic-test.csv\", new File(\n                        \"src/test/resources/1-basic-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/2-surfers-test.csv\", new File(\n                        \"src/test/resources/2-surfers-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/3-surfers-overwrite-test.csv\", new File(\n                        \"src/test/resources/3-surfers-overwrite-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/4-surfers-delete-test.csv\", new File(\n                        \"src/test/resources/4-surfers-delete-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/5-ranking-test.csv\", new File(\n                        \"src/test/resources/5-ranking-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/6-actors-test.csv\", new File(\n                        \"src/test/resources/6-actors-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/testLogin.json\", new File(\n                        \"src/test/resources/testLogin.json\")),\n                replaceConfigurationFile(\"data/tmp/testLoginEventCondition.json\", new File(\n                        \"src/test/resources/testLoginEventCondition.json\")),\n                keepRuntimeFolder(),\n                // configureConsole().ignoreLocalConsole(),\n                logLevel(LogLevel.INFO),\n                editConfigurationFilePut(\"etc/org.ops4j.pax.logging.cfg\", \"log4j2.rootLogger.level\", \"INFO\"),\n                editConfigurationFilePut(\"etc/org.apache.karaf.features.cfg\", \"serviceRequirements\", \"disable\"),\n//                editConfigurationFilePut(\"etc/org.ops4j.pax.web.cfg\", \"org.osgi.service.http.port\", HTTP_PORT),\n//                systemProperty(\"org.osgi.service.http.port\").value(HTTP_PORT),\n                systemProperty(\"org.ops4j.pax.exam.rbc.rmi.port\").value(\"1199\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.transport.port\").value(\"9500\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.cluster.name\").value(\"contextElasticSearchITests\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.http.port\").value(\"9400\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.bootstrap.seccomp\").value(\"false\"),\n                systemProperty(\"org.apache.unomi.hazelcast.group.name\").value(\"cellar\"),\n                systemProperty(\"org.apache.unomi.hazelcast.group.password\").value(\"pass\"),\n                systemProperty(\"org.apache.unomi.hazelcast.network.port\").value(\"5701\"),\n                systemProperty(\"org.apache.unomi.hazelcast.tcp-ip.members\").value(\"127.0.0.1\"),\n                systemProperty(\"org.apache.unomi.hazelcast.tcp-ip.interface\").value(\"127.0.0.1\"),\n                systemProperty(\"unomi.autoStart\").value(\"true\"),\n                features(routerRepo, \"unomi-router-karaf-feature\"),\n                CoreOptions.bundleStartLevel(100),\n                CoreOptions.frameworkStartLevel(100)\n        };\n\n        options.addAll(Arrays.asList(commonOptions));\n\n        if (JavaVersionUtil.getMajorVersion() >= 9) {\n            Option[] jdk9PlusOptions = new Option[]{\n                    new VMOption(\"--add-reads=java.xml=java.logging\"),\n                    new VMOption(\"--add-exports=java.base/org.apache.karaf.specs.locator=java.xml,ALL-UNNAMED\"),\n                    new VMOption(\"--patch-module\"),\n                    new VMOption(\"java.base=lib/endorsed/org.apache.karaf.specs.locator-\"\n                            + System.getProperty(\"karaf.version\") + \".jar\"),\n                    new VMOption(\"--patch-module\"), new VMOption(\"java.xml=lib/endorsed/org.apache.karaf.specs.java.xml-\"\n                    + System.getProperty(\"karaf.version\") + \".jar\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.security=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.net=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.lang=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.util=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.naming/javax.naming.spi=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.rmi/sun.rmi.transport.tcp=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.http=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.https=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.jar=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=jdk.naming.rmi/com.sun.jndi.url.rmi=ALL-UNNAMED\"),\n                    new VMOption(\"-classpath\"),\n                    new VMOption(\"lib/jdk9plus/*\" + File.pathSeparator + \"lib/boot/*\")\n\n            };\n            options.addAll(Arrays.asList(jdk9PlusOptions));\n        }\n\n        return options.toArray(new Option[0]);\n    }", "code_tokens": ["@", "Configuration", "public", "Option", "[", "]", "config", "(", ")", "throws", "InterruptedException", "{", "MavenArtifactUrlReference", "karafUrl", "=", "maven", "(", ")", ".", "groupId", "(", "\"", "org.apache.unomi", "\"", ")", ".", "artifactId", "(", "\"", "unomi", "\"", ")", ".", "type", "(", "\"", "tar.gz", "\"", ")", ".", "versionAsInProject", "(", ")", ";", "MavenUrlReference", "routerRepo", "=", "maven", "(", ")", ".", "groupId", "(", "\"", "org.apache.unomi", "\"", ")", ".", "artifactId", "(", "\"", "unomi-router-karaf-feature", "\"", ")", ".", "classifier", "(", "\"", "features", "\"", ")", ".", "type", "(", "\"", "xml", "\"", ")", ".", "versionAsInProject", "(", ")", ";", "List", "<", "Option", ">", "options", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Option", "[", "]", "commonOptions", "=", "new", "Option", "[", "]", "{", "debugConfiguration", "(", "\"", "5006", "\"", ",", "false", ")", ",", "karafDistributionConfiguration", "(", ")", ".", "frameworkUrl", "(", "karafUrl", ")", ".", "unpackDirectory", "(", "new", "File", "(", "KARAF_DIR", ")", ")", ".", "useDeployFolder", "(", "true", ")", ",", "replaceConfigurationFile", "(", "\"", "etc/org.apache.unomi.router.cfg", "\"", ",", "new", "File", "(", "\"", "src/test/resources/org.apache.unomi.router.cfg", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/1-basic-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/1-basic-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/2-surfers-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/2-surfers-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/3-surfers-overwrite-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/3-surfers-overwrite-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/4-surfers-delete-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/4-surfers-delete-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/5-ranking-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/5-ranking-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/6-actors-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/6-actors-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/testLogin.json", "\"", ",", "new", "File", "(", "\"", "src/test/resources/testLogin.json", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/testLoginEventCondition.json", "\"", ",", "new", "File", "(", "\"", "src/test/resources/testLoginEventCondition.json", "\"", ")", ")", ",", "keepRuntimeFolder", "(", ")", ",", "logLevel", "(", "LogLevel", ".", "INFO", ")", ",", "editConfigurationFilePut", "(", "\"", "etc/org.ops4j.pax.logging.cfg", "\"", ",", "\"", "log4j2.rootLogger.level", "\"", ",", "\"", "INFO", "\"", ")", ",", "editConfigurationFilePut", "(", "\"", "etc/org.apache.karaf.features.cfg", "\"", ",", "\"", "serviceRequirements", "\"", ",", "\"", "disable", "\"", ")", ",", "systemProperty", "(", "\"", "org.ops4j.pax.exam.rbc.rmi.port", "\"", ")", ".", "value", "(", "\"", "1199", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.itests.elasticsearch.transport.port", "\"", ")", ".", "value", "(", "\"", "9500", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.itests.elasticsearch.cluster.name", "\"", ")", ".", "value", "(", "\"", "contextElasticSearchITests", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.itests.elasticsearch.http.port", "\"", ")", ".", "value", "(", "\"", "9400", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.itests.elasticsearch.bootstrap.seccomp", "\"", ")", ".", "value", "(", "\"", "false", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.group.name", "\"", ")", ".", "value", "(", "\"", "cellar", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.group.password", "\"", ")", ".", "value", "(", "\"", "pass", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.network.port", "\"", ")", ".", "value", "(", "\"", "5701", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.tcp-ip.members", "\"", ")", ".", "value", "(", "\"", "127.0.0.1", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.tcp-ip.interface", "\"", ")", ".", "value", "(", "\"", "127.0.0.1", "\"", ")", ",", "systemProperty", "(", "\"", "unomi.autoStart", "\"", ")", ".", "value", "(", "\"", "true", "\"", ")", ",", "features", "(", "routerRepo", ",", "\"", "unomi-router-karaf-feature", "\"", ")", ",", "CoreOptions", ".", "bundleStartLevel", "(", "100", ")", ",", "CoreOptions", ".", "frameworkStartLevel", "(", "100", ")", "}", ";", "options", ".", "addAll", "(", "Arrays", ".", "asList", "(", "commonOptions", ")", ")", ";", "if", "(", "JavaVersionUtil", ".", "getMajorVersion", "(", ")", ">=", "9", ")", "{", "Option", "[", "]", "jdk9PlusOptions", "=", "new", "Option", "[", "]", "{", "new", "VMOption", "(", "\"", "--add-reads=java.xml=java.logging", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=java.base/org.apache.karaf.specs.locator=java.xml,ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--patch-module", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base=lib/endorsed/org.apache.karaf.specs.locator-", "\"", "+", "System", ".", "getProperty", "(", "\"", "karaf.version", "\"", ")", "+", "\"", ".jar", "\"", ")", ",", "new", "VMOption", "(", "\"", "--patch-module", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.xml=lib/endorsed/org.apache.karaf.specs.java.xml-", "\"", "+", "System", ".", "getProperty", "(", "\"", "karaf.version", "\"", ")", "+", "\"", ".jar", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base/java.security=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base/java.net=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base/java.lang=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base/java.util=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.naming/javax.naming.spi=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.rmi/sun.rmi.transport.tcp=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=java.base/sun.net.www.protocol.http=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=java.base/sun.net.www.protocol.https=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=java.base/sun.net.www.protocol.jar=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=jdk.naming.rmi/com.sun.jndi.url.rmi=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "-classpath", "\"", ")", ",", "new", "VMOption", "(", "\"", "lib/jdk9plus/*", "\"", "+", "File", ".", "pathSeparator", "+", "\"", "lib/boot/*", "\"", ")", "}", ";", "options", ".", "addAll", "(", "Arrays", ".", "asList", "(", "jdk9PlusOptions", ")", ")", ";", "}", "return", "options", ".", "toArray", "(", "new", "Option", "[", "0", "]", ")", ";", "}"], "idx": 99568, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "789ae8e820c507866b9c91590feebffa4e996f5e", "function_name": "config", "body_hash": "c7fac695c38b41bac9b5f8124b018e5fd09ed0e3"}
{"code": "protected void run() {\n        JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();\n        sf.setResourceClasses(MultipartStore.class);\n\n        Map<String, Object> props = new HashMap<>();\n        props.put(AttachmentDeserializer.ATTACHMENT_MAX_SIZE, String.valueOf(1024 * 10));\n        props.put(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD, String.valueOf(1024 * 5));\n        props.put(AttachmentDeserializer.ATTACHMENT_MAX_HEADER_SIZE, String.valueOf(400));\n        sf.setProperties(props);\n        //default lifecycle is per-request, change it to singleton\n        sf.setResourceProvider(MultipartStore.class,\n                               new SingletonResourceProvider(new MultipartStore()));\n        sf.setAddress(\"http://localhost:\" + PORT + \"/\");\n\n        server = sf.create();\n    }", "code_tokens": ["protected", "void", "run", "(", ")", "{", "JAXRSServerFactoryBean", "sf", "=", "new", "JAXRSServerFactoryBean", "(", ")", ";", "sf", ".", "setResourceClasses", "(", "MultipartStore", ".", "class", ")", ";", "Map", "<", "String", ",", "Object", ">", "props", "=", "new", "HashMap", "<", ">", "(", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MAX_SIZE", ",", "String", ".", "valueOf", "(", "1024", "*", "10", ")", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MEMORY_THRESHOLD", ",", "String", ".", "valueOf", "(", "1024", "*", "5", ")", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MAX_HEADER_SIZE", ",", "String", ".", "valueOf", "(", "400", ")", ")", ";", "sf", ".", "setProperties", "(", "props", ")", ";", "sf", ".", "setResourceProvider", "(", "MultipartStore", ".", "class", ",", "new", "SingletonResourceProvider", "(", "new", "MultipartStore", "(", ")", ")", ")", ";", "sf", ".", "setAddress", "(", "\"", "http://localhost:", "\"", "+", "PORT", "+", "\"", "/", "\"", ")", ";", "server", "=", "sf", ".", "create", "(", ")", ";", "}"], "idx": 107999, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "8bd915bfd7735c248ad660059c6b6ad26cdbcdf6", "function_name": "run", "body_hash": "2ca9cff25b09afd93ac4ae940a3fa452b65c6e2d"}
{"code": "private Session connectToServerRecursive(Endpoint endpoint,\n            ClientEndpointConfig clientEndpointConfiguration, URI path,\n            Set<URI> redirectSet)\n            throws DeploymentException {\n\n        boolean secure = false;\n        ByteBuffer proxyConnect = null;\n        URI proxyPath;\n\n        // Validate scheme (and build proxyPath)\n        String scheme = path.getScheme();\n        if (\"ws\".equalsIgnoreCase(scheme)) {\n            proxyPath = URI.create(\"http\" + path.toString().substring(2));\n        } else if (\"wss\".equalsIgnoreCase(scheme)) {\n            proxyPath = URI.create(\"https\" + path.toString().substring(3));\n            secure = true;\n        } else {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.pathWrongScheme\", scheme));\n        }\n\n        // Validate host\n        String host = path.getHost();\n        if (host == null) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.pathNoHost\"));\n        }\n        int port = path.getPort();\n\n        SocketAddress sa = null;\n\n        // Check to see if a proxy is configured. Javadoc indicates return value\n        // will never be null\n        List<Proxy> proxies = ProxySelector.getDefault().select(proxyPath);\n        Proxy selectedProxy = null;\n        for (Proxy proxy : proxies) {\n            if (proxy.type().equals(Proxy.Type.HTTP)) {\n                sa = proxy.address();\n                if (sa instanceof InetSocketAddress) {\n                    InetSocketAddress inet = (InetSocketAddress) sa;\n                    if (inet.isUnresolved()) {\n                        sa = new InetSocketAddress(inet.getHostName(), inet.getPort());\n                    }\n                }\n                selectedProxy = proxy;\n                break;\n            }\n        }\n\n        // If the port is not explicitly specified, compute it based on the\n        // scheme\n        if (port == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else {\n                // Must be wss due to scheme validation above\n                port = 443;\n            }\n        }\n\n        // If sa is null, no proxy is configured so need to create sa\n        if (sa == null) {\n            sa = new InetSocketAddress(host, port);\n        } else {\n            proxyConnect = createProxyRequest(host, port);\n        }\n\n        // Create the initial HTTP request to open the WebSocket connection\n        Map<String, List<String>> reqHeaders = createRequestHeaders(host, port,\n                clientEndpointConfiguration);\n        clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);\n        if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null\n                && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {\n            List<String> originValues = new ArrayList<>(1);\n            originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);\n            reqHeaders.put(Constants.ORIGIN_HEADER_NAME, originValues);\n        }\n        ByteBuffer request = createRequest(path, reqHeaders);\n\n        AsynchronousSocketChannel socketChannel;\n        try {\n            socketChannel = AsynchronousSocketChannel.open(getAsynchronousChannelGroup());\n        } catch (IOException ioe) {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.asynchronousSocketChannelFail\"), ioe);\n        }\n\n        Map<String,Object> userProperties = clientEndpointConfiguration.getUserProperties();\n\n        // Get the connection timeout\n        long timeout = Constants.IO_TIMEOUT_MS_DEFAULT;\n        String timeoutValue = (String) userProperties.get(Constants.IO_TIMEOUT_MS_PROPERTY);\n        if (timeoutValue != null) {\n            timeout = Long.valueOf(timeoutValue).intValue();\n        }\n\n        // Set-up\n        // Same size as the WsFrame input buffer\n        ByteBuffer response = ByteBuffer.allocate(getDefaultMaxBinaryMessageBufferSize());\n        String subProtocol;\n        boolean success = false;\n        List<Extension> extensionsAgreed = new ArrayList<>();\n        Transformation transformation = null;\n\n        // Open the connection\n        Future<Void> fConnect = socketChannel.connect(sa);\n        AsyncChannelWrapper channel = null;\n\n        if (proxyConnect != null) {\n            try {\n                fConnect.get(timeout, TimeUnit.MILLISECONDS);\n                // Proxy CONNECT is clear text\n                channel = new AsyncChannelWrapperNonSecure(socketChannel);\n                writeRequest(channel, proxyConnect, timeout);\n                HttpResponse httpResponse = processResponse(response, channel, timeout);\n                if (httpResponse.getStatus() != 200) {\n                    throw new DeploymentException(sm.getString(\n                            \"wsWebSocketContainer.proxyConnectFail\", selectedProxy,\n                            Integer.toString(httpResponse.getStatus())));\n                }\n            } catch (TimeoutException | InterruptedException | ExecutionException |\n                    EOFException e) {\n                if (channel != null) {\n                    channel.close();\n                }\n                throw new DeploymentException(\n                        sm.getString(\"wsWebSocketContainer.httpRequestFailed\"), e);\n            }\n        }\n\n        if (secure) {\n            // Regardless of whether a non-secure wrapper was created for a\n            // proxy CONNECT, need to use TLS from this point on so wrap the\n            // original AsynchronousSocketChannel\n            SSLEngine sslEngine = createSSLEngine(userProperties);\n            channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine);\n        } else if (channel == null) {\n            // Only need to wrap as this point if it wasn't wrapped to process a\n            // proxy CONNECT\n            channel = new AsyncChannelWrapperNonSecure(socketChannel);\n        }\n\n        try {\n            fConnect.get(timeout, TimeUnit.MILLISECONDS);\n\n            Future<Void> fHandshake = channel.handshake();\n            fHandshake.get(timeout, TimeUnit.MILLISECONDS);\n\n            writeRequest(channel, request, timeout);\n\n            HttpResponse httpResponse = processResponse(response, channel, timeout);\n\n            // Check maximum permitted redirects\n            int maxRedirects = Constants.MAX_REDIRECTIONS_DEFAULT;\n            String maxRedirectsValue =\n                    (String) userProperties.get(Constants.MAX_REDIRECTIONS_PROPERTY);\n            if (maxRedirectsValue != null) {\n                maxRedirects = Integer.parseInt(maxRedirectsValue);\n            }\n\n            if (httpResponse.status != 101) {\n                if(isRedirectStatus(httpResponse.status)){\n                    List<String> locationHeader =\n                            httpResponse.getHandshakeResponse().getHeaders().get(\n                                    Constants.LOCATION_HEADER_NAME);\n\n                    if (locationHeader == null || locationHeader.isEmpty() ||\n                            locationHeader.get(0) == null || locationHeader.get(0).isEmpty()) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.missingLocationHeader\",\n                                Integer.toString(httpResponse.status)));\n                    }\n\n                    URI redirectLocation = URI.create(locationHeader.get(0)).normalize();\n\n                    if (!redirectLocation.isAbsolute()) {\n                        redirectLocation = path.resolve(redirectLocation);\n                    }\n\n                    String redirectScheme = redirectLocation.getScheme().toLowerCase();\n\n                    if (redirectScheme.startsWith(\"http\")) {\n                        redirectLocation = new URI(redirectScheme.replace(\"http\", \"ws\"),\n                                redirectLocation.getUserInfo(), redirectLocation.getHost(),\n                                redirectLocation.getPort(), redirectLocation.getPath(),\n                                redirectLocation.getQuery(), redirectLocation.getFragment());\n                    }\n\n                    if (!redirectSet.add(redirectLocation) || redirectSet.size() > maxRedirects) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.redirectThreshold\", redirectLocation,\n                                Integer.toString(redirectSet.size()),\n                                Integer.toString(maxRedirects)));\n                    }\n\n                    return connectToServerRecursive(endpoint, clientEndpointConfiguration, redirectLocation, redirectSet);\n\n                }\n\n                else if (httpResponse.status == 401) {\n\n                    if (userProperties.get(Constants.AUTHORIZATION_HEADER_NAME) != null) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.failedAuthentication\",\n                                Integer.valueOf(httpResponse.status)));\n                    }\n\n                    List<String> wwwAuthenticateHeaders = httpResponse.getHandshakeResponse()\n                            .getHeaders().get(Constants.WWW_AUTHENTICATE_HEADER_NAME);\n\n                    if (wwwAuthenticateHeaders == null || wwwAuthenticateHeaders.isEmpty() ||\n                            wwwAuthenticateHeaders.get(0) == null || wwwAuthenticateHeaders.get(0).isEmpty()) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.missingWWWAuthenticateHeader\",\n                                Integer.toString(httpResponse.status)));\n                    }\n\n                    String authScheme = wwwAuthenticateHeaders.get(0).split(\"\\\\s+\", 2)[0];\n                    String requestUri = new String(request.array(), StandardCharsets.ISO_8859_1)\n                            .split(\"\\\\s\", 3)[1];\n\n                    Authenticator auth = AuthenticatorFactory.getAuthenticator(authScheme);\n\n                    if (auth == null) {\n                        throw new DeploymentException(\n                                sm.getString(\"wsWebSocketContainer.unsupportedAuthScheme\",\n                                        Integer.valueOf(httpResponse.status), authScheme));\n                    }\n\n                    userProperties.put(Constants.AUTHORIZATION_HEADER_NAME, auth.getAuthorization(\n                            requestUri, wwwAuthenticateHeaders.get(0), userProperties));\n\n                    return connectToServerRecursive(endpoint, clientEndpointConfiguration, path, redirectSet);\n\n                }\n\n                else {\n                    throw new DeploymentException(sm.getString(\"wsWebSocketContainer.invalidStatus\",\n                            Integer.toString(httpResponse.status)));\n                }\n            }\n            HandshakeResponse handshakeResponse = httpResponse.getHandshakeResponse();\n            clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);\n\n            // Sub-protocol\n            List<String> protocolHeaders = handshakeResponse.getHeaders().get(\n                    Constants.WS_PROTOCOL_HEADER_NAME);\n            if (protocolHeaders == null || protocolHeaders.size() == 0) {\n                subProtocol = null;\n            } else if (protocolHeaders.size() == 1) {\n                subProtocol = protocolHeaders.get(0);\n            } else {\n                throw new DeploymentException(\n                        sm.getString(\"wsWebSocketContainer.invalidSubProtocol\"));\n            }\n\n            // Extensions\n            // Should normally only be one header but handle the case of\n            // multiple headers\n            List<String> extHeaders = handshakeResponse.getHeaders().get(\n                    Constants.WS_EXTENSIONS_HEADER_NAME);\n            if (extHeaders != null) {\n                for (String extHeader : extHeaders) {\n                    Util.parseExtensionHeader(extensionsAgreed, extHeader);\n                }\n            }\n\n            // Build the transformations\n            TransformationFactory factory = TransformationFactory.getInstance();\n            for (Extension extension : extensionsAgreed) {\n                List<List<Extension.Parameter>> wrapper = new ArrayList<>(1);\n                wrapper.add(extension.getParameters());\n                Transformation t = factory.create(extension.getName(), wrapper, false);\n                if (t == null) {\n                    throw new DeploymentException(sm.getString(\n                            \"wsWebSocketContainer.invalidExtensionParameters\"));\n                }\n                if (transformation == null) {\n                    transformation = t;\n                } else {\n                    transformation.setNext(t);\n                }\n            }\n\n            success = true;\n        } catch (ExecutionException | InterruptedException | SSLException |\n                EOFException | TimeoutException | URISyntaxException | AuthenticationException e) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.httpRequestFailed\"), e);\n        } finally {\n            if (!success) {\n                channel.close();\n            }\n        }\n\n        // Switch to WebSocket\n        WsRemoteEndpointImplClient wsRemoteEndpointClient = new WsRemoteEndpointImplClient(channel);\n\n        WsSession wsSession = new WsSession(endpoint, wsRemoteEndpointClient,\n                this, null, null, null, null, null, extensionsAgreed,\n                subProtocol, Collections.<String,String>emptyMap(), secure,\n                clientEndpointConfiguration);\n\n        WsFrameClient wsFrameClient = new WsFrameClient(response, channel,\n                wsSession, transformation);\n        // WsFrame adds the necessary final transformations. Copy the\n        // completed transformation chain to the remote end point.\n        wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());\n\n        endpoint.onOpen(wsSession, clientEndpointConfiguration);\n        registerSession(endpoint, wsSession);\n\n        /* It is possible that the server sent one or more messages as soon as\n         * the WebSocket connection was established. Depending on the exact\n         * timing of when those messages were sent they could be sat in the\n         * input buffer waiting to be read and will not trigger a \"data\n         * available to read\" event. Therefore, it is necessary to process the\n         * input buffer here. Note that this happens on the current thread which\n         * means that this thread will be used for any onMessage notifications.\n         * This is a special case. Subsequent \"data available to read\" events\n         * will be handled by threads from the AsyncChannelGroup's executor.\n         */\n        wsFrameClient.startInputProcessing();\n\n        return wsSession;\n    }", "code_tokens": ["private", "Session", "connectToServerRecursive", "(", "Endpoint", "endpoint", ",", "ClientEndpointConfig", "clientEndpointConfiguration", ",", "URI", "path", ",", "Set", "<", "URI", ">", "redirectSet", ")", "throws", "DeploymentException", "{", "boolean", "secure", "=", "false", ";", "ByteBuffer", "proxyConnect", "=", "null", ";", "URI", "proxyPath", ";", "String", "scheme", "=", "path", ".", "getScheme", "(", ")", ";", "if", "(", "\"", "ws", "\"", ".", "equalsIgnoreCase", "(", "scheme", ")", ")", "{", "proxyPath", "=", "URI", ".", "create", "(", "\"", "http", "\"", "+", "path", ".", "toString", "(", ")", ".", "substring", "(", "2", ")", ")", ";", "}", "else", "if", "(", "\"", "wss", "\"", ".", "equalsIgnoreCase", "(", "scheme", ")", ")", "{", "proxyPath", "=", "URI", ".", "create", "(", "\"", "https", "\"", "+", "path", ".", "toString", "(", ")", ".", "substring", "(", "3", ")", ")", ";", "secure", "=", "true", ";", "}", "else", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.pathWrongScheme", "\"", ",", "scheme", ")", ")", ";", "}", "String", "host", "=", "path", ".", "getHost", "(", ")", ";", "if", "(", "host", "==", "null", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.pathNoHost", "\"", ")", ")", ";", "}", "int", "port", "=", "path", ".", "getPort", "(", ")", ";", "SocketAddress", "sa", "=", "null", ";", "List", "<", "Proxy", ">", "proxies", "=", "ProxySelector", ".", "getDefault", "(", ")", ".", "select", "(", "proxyPath", ")", ";", "Proxy", "selectedProxy", "=", "null", ";", "for", "(", "Proxy", "proxy", ":", "proxies", ")", "{", "if", "(", "proxy", ".", "type", "(", ")", ".", "equals", "(", "Proxy", ".", "Type", ".", "HTTP", ")", ")", "{", "sa", "=", "proxy", ".", "address", "(", ")", ";", "if", "(", "sa", "instanceof", "InetSocketAddress", ")", "{", "InetSocketAddress", "inet", "=", "(", "InetSocketAddress", ")", "sa", ";", "if", "(", "inet", ".", "isUnresolved", "(", ")", ")", "{", "sa", "=", "new", "InetSocketAddress", "(", "inet", ".", "getHostName", "(", ")", ",", "inet", ".", "getPort", "(", ")", ")", ";", "}", "}", "selectedProxy", "=", "proxy", ";", "break", ";", "}", "}", "if", "(", "port", "==", "-", "1", ")", "{", "if", "(", "\"", "ws", "\"", ".", "equalsIgnoreCase", "(", "scheme", ")", ")", "{", "port", "=", "80", ";", "}", "else", "{", "port", "=", "443", ";", "}", "}", "if", "(", "sa", "==", "null", ")", "{", "sa", "=", "new", "InetSocketAddress", "(", "host", ",", "port", ")", ";", "}", "else", "{", "proxyConnect", "=", "createProxyRequest", "(", "host", ",", "port", ")", ";", "}", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "reqHeaders", "=", "createRequestHeaders", "(", "host", ",", "port", ",", "clientEndpointConfiguration", ")", ";", "clientEndpointConfiguration", ".", "getConfigurator", "(", ")", ".", "beforeRequest", "(", "reqHeaders", ")", ";", "if", "(", "Constants", ".", "DEFAULT_ORIGIN_HEADER_VALUE", "!=", "null", "&&", "!", "reqHeaders", ".", "containsKey", "(", "Constants", ".", "ORIGIN_HEADER_NAME", ")", ")", "{", "List", "<", "String", ">", "originValues", "=", "new", "ArrayList", "<", ">", "(", "1", ")", ";", "originValues", ".", "add", "(", "Constants", ".", "DEFAULT_ORIGIN_HEADER_VALUE", ")", ";", "reqHeaders", ".", "put", "(", "Constants", ".", "ORIGIN_HEADER_NAME", ",", "originValues", ")", ";", "}", "ByteBuffer", "request", "=", "createRequest", "(", "path", ",", "reqHeaders", ")", ";", "AsynchronousSocketChannel", "socketChannel", ";", "try", "{", "socketChannel", "=", "AsynchronousSocketChannel", ".", "open", "(", "getAsynchronousChannelGroup", "(", ")", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.asynchronousSocketChannelFail", "\"", ")", ",", "ioe", ")", ";", "}", "Map", "<", "String", ",", "Object", ">", "userProperties", "=", "clientEndpointConfiguration", ".", "getUserProperties", "(", ")", ";", "long", "timeout", "=", "Constants", ".", "IO_TIMEOUT_MS_DEFAULT", ";", "String", "timeoutValue", "=", "(", "String", ")", "userProperties", ".", "get", "(", "Constants", ".", "IO_TIMEOUT_MS_PROPERTY", ")", ";", "if", "(", "timeoutValue", "!=", "null", ")", "{", "timeout", "=", "Long", ".", "valueOf", "(", "timeoutValue", ")", ".", "intValue", "(", ")", ";", "}", "ByteBuffer", "response", "=", "ByteBuffer", ".", "allocate", "(", "getDefaultMaxBinaryMessageBufferSize", "(", ")", ")", ";", "String", "subProtocol", ";", "boolean", "success", "=", "false", ";", "List", "<", "Extension", ">", "extensionsAgreed", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Transformation", "transformation", "=", "null", ";", "Future", "<", "Void", ">", "fConnect", "=", "socketChannel", ".", "connect", "(", "sa", ")", ";", "AsyncChannelWrapper", "channel", "=", "null", ";", "if", "(", "proxyConnect", "!=", "null", ")", "{", "try", "{", "fConnect", ".", "get", "(", "timeout", ",", "TimeUnit", ".", "MILLISECONDS", ")", ";", "channel", "=", "new", "AsyncChannelWrapperNonSecure", "(", "socketChannel", ")", ";", "writeRequest", "(", "channel", ",", "proxyConnect", ",", "timeout", ")", ";", "HttpResponse", "httpResponse", "=", "processResponse", "(", "response", ",", "channel", ",", "timeout", ")", ";", "if", "(", "httpResponse", ".", "getStatus", "(", ")", "!=", "200", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.proxyConnectFail", "\"", ",", "selectedProxy", ",", "Integer", ".", "toString", "(", "httpResponse", ".", "getStatus", "(", ")", ")", ")", ")", ";", "}", "}", "catch", "(", "TimeoutException", "|", "InterruptedException", "|", "ExecutionException", "|", "EOFException", "e", ")", "{", "if", "(", "channel", "!=", "null", ")", "{", "channel", ".", "close", "(", ")", ";", "}", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.httpRequestFailed", "\"", ")", ",", "e", ")", ";", "}", "}", "if", "(", "secure", ")", "{", "SSLEngine", "sslEngine", "=", "createSSLEngine", "(", "userProperties", ")", ";", "channel", "=", "new", "AsyncChannelWrapperSecure", "(", "socketChannel", ",", "sslEngine", ")", ";", "}", "else", "if", "(", "channel", "==", "null", ")", "{", "channel", "=", "new", "AsyncChannelWrapperNonSecure", "(", "socketChannel", ")", ";", "}", "try", "{", "fConnect", ".", "get", "(", "timeout", ",", "TimeUnit", ".", "MILLISECONDS", ")", ";", "Future", "<", "Void", ">", "fHandshake", "=", "channel", ".", "handshake", "(", ")", ";", "fHandshake", ".", "get", "(", "timeout", ",", "TimeUnit", ".", "MILLISECONDS", ")", ";", "writeRequest", "(", "channel", ",", "request", ",", "timeout", ")", ";", "HttpResponse", "httpResponse", "=", "processResponse", "(", "response", ",", "channel", ",", "timeout", ")", ";", "int", "maxRedirects", "=", "Constants", ".", "MAX_REDIRECTIONS_DEFAULT", ";", "String", "maxRedirectsValue", "=", "(", "String", ")", "userProperties", ".", "get", "(", "Constants", ".", "MAX_REDIRECTIONS_PROPERTY", ")", ";", "if", "(", "maxRedirectsValue", "!=", "null", ")", "{", "maxRedirects", "=", "Integer", ".", "parseInt", "(", "maxRedirectsValue", ")", ";", "}", "if", "(", "httpResponse", ".", "status", "!=", "101", ")", "{", "if", "(", "isRedirectStatus", "(", "httpResponse", ".", "status", ")", ")", "{", "List", "<", "String", ">", "locationHeader", "=", "httpResponse", ".", "getHandshakeResponse", "(", ")", ".", "getHeaders", "(", ")", ".", "get", "(", "Constants", ".", "LOCATION_HEADER_NAME", ")", ";", "if", "(", "locationHeader", "==", "null", "||", "locationHeader", ".", "isEmpty", "(", ")", "||", "locationHeader", ".", "get", "(", "0", ")", "==", "null", "||", "locationHeader", ".", "get", "(", "0", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.missingLocationHeader", "\"", ",", "Integer", ".", "toString", "(", "httpResponse", ".", "status", ")", ")", ")", ";", "}", "URI", "redirectLocation", "=", "URI", ".", "create", "(", "locationHeader", ".", "get", "(", "0", ")", ")", ".", "normalize", "(", ")", ";", "if", "(", "!", "redirectLocation", ".", "isAbsolute", "(", ")", ")", "{", "redirectLocation", "=", "path", ".", "resolve", "(", "redirectLocation", ")", ";", "}", "String", "redirectScheme", "=", "redirectLocation", ".", "getScheme", "(", ")", ".", "toLowerCase", "(", ")", ";", "if", "(", "redirectScheme", ".", "startsWith", "(", "\"", "http", "\"", ")", ")", "{", "redirectLocation", "=", "new", "URI", "(", "redirectScheme", ".", "replace", "(", "\"", "http", "\"", ",", "\"", "ws", "\"", ")", ",", "redirectLocation", ".", "getUserInfo", "(", ")", ",", "redirectLocation", ".", "getHost", "(", ")", ",", "redirectLocation", ".", "getPort", "(", ")", ",", "redirectLocation", ".", "getPath", "(", ")", ",", "redirectLocation", ".", "getQuery", "(", ")", ",", "redirectLocation", ".", "getFragment", "(", ")", ")", ";", "}", "if", "(", "!", "redirectSet", ".", "add", "(", "redirectLocation", ")", "||", "redirectSet", ".", "size", "(", ")", ">", "maxRedirects", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.redirectThreshold", "\"", ",", "redirectLocation", ",", "Integer", ".", "toString", "(", "redirectSet", ".", "size", "(", ")", ")", ",", "Integer", ".", "toString", "(", "maxRedirects", ")", ")", ")", ";", "}", "return", "connectToServerRecursive", "(", "endpoint", ",", "clientEndpointConfiguration", ",", "redirectLocation", ",", "redirectSet", ")", ";", "}", "else", "if", "(", "httpResponse", ".", "status", "==", "401", ")", "{", "if", "(", "userProperties", ".", "get", "(", "Constants", ".", "AUTHORIZATION_HEADER_NAME", ")", "!=", "null", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.failedAuthentication", "\"", ",", "Integer", ".", "valueOf", "(", "httpResponse", ".", "status", ")", ")", ")", ";", "}", "List", "<", "String", ">", "wwwAuthenticateHeaders", "=", "httpResponse", ".", "getHandshakeResponse", "(", ")", ".", "getHeaders", "(", ")", ".", "get", "(", "Constants", ".", "WWW_AUTHENTICATE_HEADER_NAME", ")", ";", "if", "(", "wwwAuthenticateHeaders", "==", "null", "||", "wwwAuthenticateHeaders", ".", "isEmpty", "(", ")", "||", "wwwAuthenticateHeaders", ".", "get", "(", "0", ")", "==", "null", "||", "wwwAuthenticateHeaders", ".", "get", "(", "0", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.missingWWWAuthenticateHeader", "\"", ",", "Integer", ".", "toString", "(", "httpResponse", ".", "status", ")", ")", ")", ";", "}", "String", "authScheme", "=", "wwwAuthenticateHeaders", ".", "get", "(", "0", ")", ".", "split", "(", "\"", "\\\\", "s+", "\"", ",", "2", ")", "[", "0", "]", ";", "String", "requestUri", "=", "new", "String", "(", "request", ".", "array", "(", ")", ",", "StandardCharsets", ".", "ISO_8859_1", ")", ".", "split", "(", "\"", "\\\\", "s", "\"", ",", "3", ")", "[", "1", "]", ";", "Authenticator", "auth", "=", "AuthenticatorFactory", ".", "getAuthenticator", "(", "authScheme", ")", ";", "if", "(", "auth", "==", "null", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.unsupportedAuthScheme", "\"", ",", "Integer", ".", "valueOf", "(", "httpResponse", ".", "status", ")", ",", "authScheme", ")", ")", ";", "}", "userProperties", ".", "put", "(", "Constants", ".", "AUTHORIZATION_HEADER_NAME", ",", "auth", ".", "getAuthorization", "(", "requestUri", ",", "wwwAuthenticateHeaders", ".", "get", "(", "0", ")", ",", "userProperties", ")", ")", ";", "return", "connectToServerRecursive", "(", "endpoint", ",", "clientEndpointConfiguration", ",", "path", ",", "redirectSet", ")", ";", "}", "else", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.invalidStatus", "\"", ",", "Integer", ".", "toString", "(", "httpResponse", ".", "status", ")", ")", ")", ";", "}", "}", "HandshakeResponse", "handshakeResponse", "=", "httpResponse", ".", "getHandshakeResponse", "(", ")", ";", "clientEndpointConfiguration", ".", "getConfigurator", "(", ")", ".", "afterResponse", "(", "handshakeResponse", ")", ";", "List", "<", "String", ">", "protocolHeaders", "=", "handshakeResponse", ".", "getHeaders", "(", ")", ".", "get", "(", "Constants", ".", "WS_PROTOCOL_HEADER_NAME", ")", ";", "if", "(", "protocolHeaders", "==", "null", "||", "protocolHeaders", ".", "size", "(", ")", "==", "0", ")", "{", "subProtocol", "=", "null", ";", "}", "else", "if", "(", "protocolHeaders", ".", "size", "(", ")", "==", "1", ")", "{", "subProtocol", "=", "protocolHeaders", ".", "get", "(", "0", ")", ";", "}", "else", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.invalidSubProtocol", "\"", ")", ")", ";", "}", "List", "<", "String", ">", "extHeaders", "=", "handshakeResponse", ".", "getHeaders", "(", ")", ".", "get", "(", "Constants", ".", "WS_EXTENSIONS_HEADER_NAME", ")", ";", "if", "(", "extHeaders", "!=", "null", ")", "{", "for", "(", "String", "extHeader", ":", "extHeaders", ")", "{", "Util", ".", "parseExtensionHeader", "(", "extensionsAgreed", ",", "extHeader", ")", ";", "}", "}", "TransformationFactory", "factory", "=", "TransformationFactory", ".", "getInstance", "(", ")", ";", "for", "(", "Extension", "extension", ":", "extensionsAgreed", ")", "{", "List", "<", "List", "<", "Extension", ".", "Parameter", ">", ">", "wrapper", "=", "new", "ArrayList", "<", ">", "(", "1", ")", ";", "wrapper", ".", "add", "(", "extension", ".", "getParameters", "(", ")", ")", ";", "Transformation", "t", "=", "factory", ".", "create", "(", "extension", ".", "getName", "(", ")", ",", "wrapper", ",", "false", ")", ";", "if", "(", "t", "==", "null", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.invalidExtensionParameters", "\"", ")", ")", ";", "}", "if", "(", "transformation", "==", "null", ")", "{", "transformation", "=", "t", ";", "}", "else", "{", "transformation", ".", "setNext", "(", "t", ")", ";", "}", "}", "success", "=", "true", ";", "}", "catch", "(", "ExecutionException", "|", "InterruptedException", "|", "SSLException", "|", "EOFException", "|", "TimeoutException", "|", "URISyntaxException", "|", "AuthenticationException", "e", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.httpRequestFailed", "\"", ")", ",", "e", ")", ";", "}", "finally", "{", "if", "(", "!", "success", ")", "{", "channel", ".", "close", "(", ")", ";", "}", "}", "WsRemoteEndpointImplClient", "wsRemoteEndpointClient", "=", "new", "WsRemoteEndpointImplClient", "(", "channel", ")", ";", "WsSession", "wsSession", "=", "new", "WsSession", "(", "endpoint", ",", "wsRemoteEndpointClient", ",", "this", ",", "null", ",", "null", ",", "null", ",", "null", ",", "null", ",", "extensionsAgreed", ",", "subProtocol", ",", "Collections", ".", "<", "String", ",", "String", ">", "emptyMap", "(", ")", ",", "secure", ",", "clientEndpointConfiguration", ")", ";", "WsFrameClient", "wsFrameClient", "=", "new", "WsFrameClient", "(", "response", ",", "channel", ",", "wsSession", ",", "transformation", ")", ";", "wsRemoteEndpointClient", ".", "setTransformation", "(", "wsFrameClient", ".", "getTransformation", "(", ")", ")", ";", "endpoint", ".", "onOpen", "(", "wsSession", ",", "clientEndpointConfiguration", ")", ";", "registerSession", "(", "endpoint", ",", "wsSession", ")", ";", "wsFrameClient", ".", "startInputProcessing", "(", ")", ";", "return", "wsSession", ";", "}"], "idx": 40073, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "2835bb4e030c1c741ed0847bb3b9c3822e4fbc8a", "function_name": "connectToServerRecursive", "body_hash": "95ae4fca8e9b467f077eae41dd1378d2cb4a2277"}
{"code": "private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                // If first byte is invalid, tail will be set to -1\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                // Additional checks to detect invalid sequences ASAP\n                // Checks derived from Unicode 6.2, Chapter 3, Table 3-7\n                // Check 2nd byte\n                int tailAvailable = inIndexLimit - inIndex - 1;\n                if (tailAvailable > 0) {\n                    // First byte C2..DF, second byte 80..BF\n                    if (jchar > 0x41 && jchar < 0x60 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E0, second byte A0..BF\n                    if (jchar == 0x60 && (bArr[inIndex + 1] & 0xE0) != 0xA0) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E1..EC, second byte 80..BF\n                    if (jchar > 0x60 && jchar < 0x6D &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte ED, second byte 80..9F\n                    if (jchar == 0x6D && (bArr[inIndex + 1] & 0xE0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte EE..EF, second byte 80..BF\n                    if (jchar > 0x6D && jchar < 0x70 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F0, second byte 90..BF\n                    if (jchar == 0x70 &&\n                            ((bArr[inIndex + 1] & 0xFF) < 0x90 ||\n                            (bArr[inIndex + 1] & 0xFF) > 0xBF)) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F1..F3, second byte 80..BF\n                    if (jchar > 0x70 && jchar < 0x74 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F4, second byte 80..8F\n                    if (jchar == 0x74 &&\n                            (bArr[inIndex + 1] & 0xF0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                }\n                // Check third byte if present and expected\n                if (tailAvailable > 1 && tail > 1) {\n                    if ((bArr[inIndex + 2] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(2);\n                    }\n                }\n                // Check fourth byte if present and expected\n                if (tailAvailable > 2 && tail > 2) {\n                    if ((bArr[inIndex + 3] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(3);\n                    }\n                }\n                if (tailAvailable < tail) {\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    // Encoded with 4 bytes. inIndex currently points\n                    // to the final byte. Move it back to first byte.\n                    inIndex -= 3;\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ?\n                CoderResult.OVERFLOW :\n                CoderResult.UNDERFLOW;\n    }", "code_tokens": ["private", "CoderResult", "decodeHasArray", "(", "ByteBuffer", "in", ",", "CharBuffer", "out", ")", "{", "int", "outRemaining", "=", "out", ".", "remaining", "(", ")", ";", "int", "pos", "=", "in", ".", "position", "(", ")", ";", "int", "limit", "=", "in", ".", "limit", "(", ")", ";", "final", "byte", "[", "]", "bArr", "=", "in", ".", "array", "(", ")", ";", "final", "char", "[", "]", "cArr", "=", "out", ".", "array", "(", ")", ";", "final", "int", "inIndexLimit", "=", "limit", "+", "in", ".", "arrayOffset", "(", ")", ";", "int", "inIndex", "=", "pos", "+", "in", ".", "arrayOffset", "(", ")", ";", "int", "outIndex", "=", "out", ".", "position", "(", ")", "+", "out", ".", "arrayOffset", "(", ")", ";", "for", "(", ";", "inIndex", "<", "inIndexLimit", "&&", "outRemaining", ">", "0", ";", "inIndex", "++", ")", "{", "int", "jchar", "=", "bArr", "[", "inIndex", "]", ";", "if", "(", "jchar", "<", "0", ")", "{", "jchar", "=", "jchar", "&", "0x7F", ";", "int", "tail", "=", "remainingBytes", "[", "jchar", "]", ";", "if", "(", "tail", "==", "-", "1", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "int", "tailAvailable", "=", "inIndexLimit", "-", "inIndex", "-", "1", ";", "if", "(", "tailAvailable", ">", "0", ")", "{", "if", "(", "jchar", ">", "0x41", "&&", "jchar", "<", "0x60", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", "==", "0x60", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xE0", ")", "!=", "0xA0", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", ">", "0x60", "&&", "jchar", "<", "0x6D", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", "==", "0x6D", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xE0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", ">", "0x6D", "&&", "jchar", "<", "0x70", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", "==", "0x70", "&&", "(", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xFF", ")", "<", "0x90", "||", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xFF", ")", ">", "0xBF", ")", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", ">", "0x70", "&&", "jchar", "<", "0x74", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", "==", "0x74", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xF0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "}", "if", "(", "tailAvailable", ">", "1", "&&", "tail", ">", "1", ")", "{", "if", "(", "(", "bArr", "[", "inIndex", "+", "2", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "2", ")", ";", "}", "}", "if", "(", "tailAvailable", ">", "2", "&&", "tail", ">", "2", ")", "{", "if", "(", "(", "bArr", "[", "inIndex", "+", "3", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "3", ")", ";", "}", "}", "if", "(", "tailAvailable", "<", "tail", ")", "{", "break", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "tail", ";", "i", "++", ")", "{", "int", "nextByte", "=", "bArr", "[", "inIndex", "+", "i", "+", "1", "]", "&", "0xFF", ";", "if", "(", "(", "nextByte", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", "+", "i", ")", ";", "}", "jchar", "=", "(", "jchar", "<<", "6", ")", "+", "nextByte", ";", "}", "jchar", "-=", "remainingNumbers", "[", "tail", "]", ";", "if", "(", "jchar", "<", "lowerEncodingLimit", "[", "tail", "]", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "inIndex", "+=", "tail", ";", "}", "if", "(", "jchar", ">=", "0xD800", "&&", "jchar", "<=", "0xDFFF", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "3", ")", ";", "}", "if", "(", "jchar", ">", "0x10FFFF", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "4", ")", ";", "}", "if", "(", "jchar", "<=", "0xffff", ")", "{", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "jchar", ";", "outRemaining", "--", ";", "}", "else", "{", "if", "(", "outRemaining", "<", "2", ")", "{", "inIndex", "-=", "3", ";", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "OVERFLOW", ";", "}", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "(", "(", "jchar", ">>", "0xA", ")", "+", "0xD7C0", ")", ";", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "(", "(", "jchar", "&", "0x3FF", ")", "+", "0xDC00", ")", ";", "outRemaining", "-=", "2", ";", "}", "}", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "(", "outRemaining", "==", "0", "&&", "inIndex", "<", "inIndexLimit", ")", "?", "CoderResult", ".", "OVERFLOW", ":", "CoderResult", ".", "UNDERFLOW", ";", "}"], "idx": 82482, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "156d76a6afeef440d14044a560d6ad1d029361c4", "function_name": "decodeHasArray", "body_hash": "8448ab92a7ee62d360631934f4caaded0f7ea69a"}
{"code": "public void list(HttpServletRequest request,\n                     HttpServletResponse response,\n                     String message) throws IOException {\n\n        PrintWriter writer = response.getWriter();\n\n        // HTML Header Section\n        writer.print(Constants.HTML_HEADER_SECTION);\n\n        // Body Header Section\n        Object[] args = new Object[2];\n        args[0] = request.getContextPath();\n        args[1] = sm.getString(\"htmlHostManagerServlet.title\");\n        writer.print(MessageFormat.format\n                     (Constants.BODY_HEADER_SECTION, args));\n\n        // Message Section\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.messageLabel\");\n        if (message == null || message.length() == 0) {\n            args[1] = \"OK\";\n        } else {\n            args[1] = RequestUtil.filter(message);\n        }\n        writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args));\n\n        // Manager Section\n        args = new Object[9];\n        args[0] = sm.getString(\"htmlHostManagerServlet.manager\");\n        args[1] = response.encodeURL(request.getContextPath() + \"/html/list\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.list\");\n        args[3] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpHtmlManagerFile\"));\n        args[4] = sm.getString(\"htmlHostManagerServlet.helpHtmlManager\");\n        args[5] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpManagerFile\"));\n        args[6] = sm.getString(\"htmlHostManagerServlet.helpManager\");\n        args[7] = response.encodeURL(\"/manager/status\");\n        args[8] = sm.getString(\"statusServlet.title\");\n        writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args));\n\n         // Hosts Header Section\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.hostName\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.hostAliases\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.hostTasks\");\n        writer.print(MessageFormat.format(HOSTS_HEADER_SECTION, args));\n\n        // Hosts Row Section\n        // Create sorted map of host names.\n        Container[] children = engine.findChildren();\n        String hostNames[] = new String[children.length];\n        for (int i = 0; i < children.length; i++)\n            hostNames[i] = children[i].getName();\n\n        TreeMap<String,String> sortedHostNamesMap =\n            new TreeMap<String,String>();\n\n        for (int i = 0; i < hostNames.length; i++) {\n            String displayPath = hostNames[i];\n            sortedHostNamesMap.put(displayPath, hostNames[i]);\n        }\n\n        String hostsStart = sm.getString(\"htmlHostManagerServlet.hostsStart\");\n        String hostsStop = sm.getString(\"htmlHostManagerServlet.hostsStop\");\n        String hostsRemove = sm.getString(\"htmlHostManagerServlet.hostsRemove\");\n\n        Iterator<Map.Entry<String,String>> iterator =\n            sortedHostNamesMap.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String,String> entry = iterator.next();\n            String hostName = (String) entry.getKey();\n            Host host = (Host) engine.findChild(hostName);\n\n            if (host != null ) {\n                args = new Object[2];\n                args[0] = RequestUtil.filter(hostName);\n                String[] aliases = host.findAliases();\n                StringBuffer buf = new StringBuffer();\n                if (aliases.length > 0) {\n                    buf.append(aliases[0]);\n                    for (int j = 1; j < aliases.length; j++) {\n                        buf.append(\", \").append(aliases[j]);\n                    }\n                }\n\n                if (buf.length() == 0) {\n                    buf.append(\"&nbsp;\");\n                    args[1] = buf.toString();\n                } else {\n                    args[1] = RequestUtil.filter(buf.toString());\n                }\n\n                writer.print\n                    (MessageFormat.format(HOSTS_ROW_DETAILS_SECTION, args));\n\n                args = new Object[7];\n                args[0] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/start?name=\" + hostName);\n                args[1] = hostsStart;\n                args[2] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/stop?name=\" + hostName);\n                args[3] = hostsStop;\n                args[4] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/remove?name=\" + hostName);\n                args[5] = hostsRemove;\n                args[6] = hostName;\n                if (host == this.host) {\n                    writer.print(MessageFormat.format(\n                        MANAGER_HOST_ROW_BUTTON_SECTION, args));\n                } else {\n                    writer.print(MessageFormat.format(\n                        HOSTS_ROW_BUTTON_SECTION, args));\n                }\n\n            }\n        }\n\n        // Add Section\n        args = new Object[6];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.addHost\");\n        args[2] = response.encodeURL(request.getContextPath() + \"/html/add\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.addName\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.addAliases\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.addAppBase\");\n        writer.print(MessageFormat.format(ADD_SECTION_START, args));\n \n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addAutoDeploy\");\n        args[1] = \"autoDeploy\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployOnStartup\");\n        args[1] = \"deployOnStartup\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployXML\");\n        args[1] = \"deployXML\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addUnpackWARs\");\n        args[1] = \"unpackWARs\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlNamespaceAware\");\n        args[1] = \"xmlNamespaceAware\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlValidation\");\n        args[1] = \"xmlValidation\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n\n        args[0] = sm.getString(\"htmlHostManagerServlet.addManager\");\n        args[1] = \"manager\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        \n        args = new Object[1];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addButton\");\n        writer.print(MessageFormat.format(ADD_SECTION_END, args));\n\n        // Server Header Section\n        args = new Object[7];\n        args[0] = sm.getString(\"htmlHostManagerServlet.serverTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.serverVersion\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.serverJVMVersion\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.serverJVMVendor\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.serverOSName\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.serverOSVersion\");\n        args[6] = sm.getString(\"htmlHostManagerServlet.serverOSArch\");\n        writer.print(MessageFormat.format\n                     (Constants.SERVER_HEADER_SECTION, args));\n\n        // Server Row Section\n        args = new Object[6];\n        args[0] = ServerInfo.getServerInfo();\n        args[1] = System.getProperty(\"java.runtime.version\");\n        args[2] = System.getProperty(\"java.vm.vendor\");\n        args[3] = System.getProperty(\"os.name\");\n        args[4] = System.getProperty(\"os.version\");\n        args[5] = System.getProperty(\"os.arch\");\n        writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args));\n\n        // HTML Tail Section\n        writer.print(Constants.HTML_TAIL_SECTION);\n\n        // Finish up the response\n        writer.flush();\n        writer.close();\n    }", "code_tokens": ["public", "void", "list", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "String", "message", ")", "throws", "IOException", "{", "PrintWriter", "writer", "=", "response", ".", "getWriter", "(", ")", ";", "writer", ".", "print", "(", "Constants", ".", "HTML_HEADER_SECTION", ")", ";", "Object", "[", "]", "args", "=", "new", "Object", "[", "2", "]", ";", "args", "[", "0", "]", "=", "request", ".", "getContextPath", "(", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.title", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "BODY_HEADER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.messageLabel", "\"", ")", ";", "if", "(", "message", "==", "null", "||", "message", ".", "length", "(", ")", "==", "0", ")", "{", "args", "[", "1", "]", "=", "\"", "OK", "\"", ";", "}", "else", "{", "args", "[", "1", "]", "=", "RequestUtil", ".", "filter", "(", "message", ")", ";", "}", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "MESSAGE_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "9", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.manager", "\"", ")", ";", "args", "[", "1", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/list", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.list", "\"", ")", ";", "args", "[", "3", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/", "\"", "+", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpHtmlManagerFile", "\"", ")", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpHtmlManager", "\"", ")", ";", "args", "[", "5", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/", "\"", "+", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpManagerFile", "\"", ")", ")", ";", "args", "[", "6", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpManager", "\"", ")", ";", "args", "[", "7", "]", "=", "response", ".", "encodeURL", "(", "\"", "/manager/status", "\"", ")", ";", "args", "[", "8", "]", "=", "sm", ".", "getString", "(", "\"", "statusServlet.title", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "MANAGER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostName", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostAliases", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostTasks", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_HEADER_SECTION", ",", "args", ")", ")", ";", "Container", "[", "]", "children", "=", "engine", ".", "findChildren", "(", ")", ";", "String", "hostNames", "[", "]", "=", "new", "String", "[", "children", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "children", ".", "length", ";", "i", "++", ")", "hostNames", "[", "i", "]", "=", "children", "[", "i", "]", ".", "getName", "(", ")", ";", "TreeMap", "<", "String", ",", "String", ">", "sortedHostNamesMap", "=", "new", "TreeMap", "<", "String", ",", "String", ">", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hostNames", ".", "length", ";", "i", "++", ")", "{", "String", "displayPath", "=", "hostNames", "[", "i", "]", ";", "sortedHostNamesMap", ".", "put", "(", "displayPath", ",", "hostNames", "[", "i", "]", ")", ";", "}", "String", "hostsStart", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsStart", "\"", ")", ";", "String", "hostsStop", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsStop", "\"", ")", ";", "String", "hostsRemove", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsRemove", "\"", ")", ";", "Iterator", "<", "Map", ".", "Entry", "<", "String", ",", "String", ">", ">", "iterator", "=", "sortedHostNamesMap", ".", "entrySet", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iterator", ".", "hasNext", "(", ")", ")", "{", "Map", ".", "Entry", "<", "String", ",", "String", ">", "entry", "=", "iterator", ".", "next", "(", ")", ";", "String", "hostName", "=", "(", "String", ")", "entry", ".", "getKey", "(", ")", ";", "Host", "host", "=", "(", "Host", ")", "engine", ".", "findChild", "(", "hostName", ")", ";", "if", "(", "host", "!=", "null", ")", "{", "args", "=", "new", "Object", "[", "2", "]", ";", "args", "[", "0", "]", "=", "RequestUtil", ".", "filter", "(", "hostName", ")", ";", "String", "[", "]", "aliases", "=", "host", ".", "findAliases", "(", ")", ";", "StringBuffer", "buf", "=", "new", "StringBuffer", "(", ")", ";", "if", "(", "aliases", ".", "length", ">", "0", ")", "{", "buf", ".", "append", "(", "aliases", "[", "0", "]", ")", ";", "for", "(", "int", "j", "=", "1", ";", "j", "<", "aliases", ".", "length", ";", "j", "++", ")", "{", "buf", ".", "append", "(", "\"", ", ", "\"", ")", ".", "append", "(", "aliases", "[", "j", "]", ")", ";", "}", "}", "if", "(", "buf", ".", "length", "(", ")", "==", "0", ")", "{", "buf", ".", "append", "(", "\"", "&nbsp;", "\"", ")", ";", "args", "[", "1", "]", "=", "buf", ".", "toString", "(", ")", ";", "}", "else", "{", "args", "[", "1", "]", "=", "RequestUtil", ".", "filter", "(", "buf", ".", "toString", "(", ")", ")", ";", "}", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_ROW_DETAILS_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "7", "]", ";", "args", "[", "0", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/start?name=", "\"", "+", "hostName", ")", ";", "args", "[", "1", "]", "=", "hostsStart", ";", "args", "[", "2", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/stop?name=", "\"", "+", "hostName", ")", ";", "args", "[", "3", "]", "=", "hostsStop", ";", "args", "[", "4", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/remove?name=", "\"", "+", "hostName", ")", ";", "args", "[", "5", "]", "=", "hostsRemove", ";", "args", "[", "6", "]", "=", "hostName", ";", "if", "(", "host", "==", "this", ".", "host", ")", "{", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "MANAGER_HOST_ROW_BUTTON_SECTION", ",", "args", ")", ")", ";", "}", "else", "{", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_ROW_BUTTON_SECTION", ",", "args", ")", ")", ";", "}", "}", "}", "args", "=", "new", "Object", "[", "6", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addTitle", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addHost", "\"", ")", ";", "args", "[", "2", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/add", "\"", ")", ";", "args", "[", "3", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addName", "\"", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAliases", "\"", ")", ";", "args", "[", "5", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAppBase", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_START", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAutoDeploy", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "autoDeploy", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addDeployOnStartup", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "deployOnStartup", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addDeployXML", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "deployXML", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addUnpackWARs", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "unpackWARs", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addXmlNamespaceAware", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "xmlNamespaceAware", "\"", ";", "args", "[", "2", "]", "=", "\"", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addXmlValidation", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "xmlValidation", "\"", ";", "args", "[", "2", "]", "=", "\"", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addManager", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "manager", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "1", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addButton", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_END", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "7", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverTitle", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverVersion", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverJVMVersion", "\"", ")", ";", "args", "[", "3", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverJVMVendor", "\"", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSName", "\"", ")", ";", "args", "[", "5", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSVersion", "\"", ")", ";", "args", "[", "6", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSArch", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "SERVER_HEADER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "6", "]", ";", "args", "[", "0", "]", "=", "ServerInfo", ".", "getServerInfo", "(", ")", ";", "args", "[", "1", "]", "=", "System", ".", "getProperty", "(", "\"", "java.runtime.version", "\"", ")", ";", "args", "[", "2", "]", "=", "System", ".", "getProperty", "(", "\"", "java.vm.vendor", "\"", ")", ";", "args", "[", "3", "]", "=", "System", ".", "getProperty", "(", "\"", "os.name", "\"", ")", ";", "args", "[", "4", "]", "=", "System", ".", "getProperty", "(", "\"", "os.version", "\"", ")", ";", "args", "[", "5", "]", "=", "System", ".", "getProperty", "(", "\"", "os.arch", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "SERVER_ROW_SECTION", ",", "args", ")", ")", ";", "writer", ".", "print", "(", "Constants", ".", "HTML_TAIL_SECTION", ")", ";", "writer", ".", "flush", "(", ")", ";", "writer", ".", "close", "(", ")", ";", "}"], "idx": 79267, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "49c71fc59c1b8f8da77aea9eb53e61db168aebab", "function_name": "list", "body_hash": "7923cf83ec6bdffb24cd7ad10011836def991c1d"}
{"code": "public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\t\tMap<String, Object> map = new HashMap<String, Object>(model);\n\t\tString path = ServletUriComponentsBuilder.fromContextPath(request).build()\n\t\t\t\t.getPath();\n\t\tmap.put(\"path\", (Object) path==null ? \"\" : path);\n\t\tcontext.setRootObject(map);\n\t\tString result = helper.replacePlaceholders(template, resolver);\n\t\tresponse.setContentType(getContentType());\n\t\tresponse.getWriter().append(result);\n\t}", "code_tokens": ["public", "void", "render", "(", "Map", "<", "String", ",", "?", ">", "model", ",", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "Exception", "{", "Map", "<", "String", ",", "Object", ">", "map", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", "model", ")", ";", "String", "path", "=", "ServletUriComponentsBuilder", ".", "fromContextPath", "(", "request", ")", ".", "build", "(", ")", ".", "getPath", "(", ")", ";", "map", ".", "put", "(", "\"", "path", "\"", ",", "(", "Object", ")", "path", "==", "null", "?", "\"", "\"", ":", "path", ")", ";", "context", ".", "setRootObject", "(", "map", ")", ";", "String", "result", "=", "helper", ".", "replacePlaceholders", "(", "template", ",", "resolver", ")", ";", "response", ".", "setContentType", "(", "getContentType", "(", ")", ")", ";", "response", ".", "getWriter", "(", ")", ".", "append", "(", "result", ")", ";", "}"], "idx": 4919, "cwe": "CWE-19", "target": 1, "status": "VULNERABLE", "commit": "fff77d3fea477b566bcacfbfc95f85821a2bdc2d", "function_name": "render", "body_hash": "e6837eda7962612ae37e93c2f777fb5ceb7b0faa"}
{"code": "public String getIconFileName() {\n        return Jenkins.getInstance().hasPermission(Jenkins.ADMINISTER) ? \"plugin/jenkins-multijob-plugin/tool32.png\" : null;\n\t}", "code_tokens": ["public", "String", "getIconFileName", "(", ")", "{", "return", "Jenkins", ".", "getInstance", "(", ")", ".", "hasPermission", "(", "Jenkins", ".", "ADMINISTER", ")", "?", "\"", "plugin/jenkins-multijob-plugin/tool32.png", "\"", ":", "null", ";", "}"], "idx": 85141, "cwe": "CWE-862", "target": 0, "status": "FIXED", "commit": "2424cec7a099fe4392f052a754fadc28de9f8d86", "function_name": "getIconFileName", "body_hash": "3e417499afc29175de759c446ea35410f38fa866"}
{"code": "protected void authenticatorConfig() {\n\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            // Security constraints present. Need an authenticator to\n            // support them.\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null) {\n            return;\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve) customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n\n        if (authenticator == null) {\n            if (authenticators == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorResources\"));\n                ok = false;\n                return;\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.getConstructor().newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null) {\n            Pipeline pipeline = context.getPipeline();\n            if (pipeline != null) {\n                pipeline.addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "authenticatorConfig", "(", ")", "{", "LoginConfig", "loginConfig", "=", "context", ".", "getLoginConfig", "(", ")", ";", "if", "(", "loginConfig", "==", "null", ")", "{", "loginConfig", "=", "DUMMY_LOGIN_CONFIG", ";", "context", ".", "setLoginConfig", "(", "loginConfig", ")", ";", "}", "if", "(", "context", ".", "getAuthenticator", "(", ")", "!=", "null", ")", "{", "return", ";", "}", "if", "(", "context", ".", "getRealm", "(", ")", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.missingRealm", "\"", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "Valve", "authenticator", "=", "null", ";", "if", "(", "customAuthenticators", "!=", "null", ")", "{", "authenticator", "=", "(", "Valve", ")", "customAuthenticators", ".", "get", "(", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ";", "}", "if", "(", "authenticator", "==", "null", ")", "{", "if", "(", "authenticators", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorResources", "\"", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "String", "authenticatorName", "=", "authenticators", ".", "getProperty", "(", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ";", "if", "(", "authenticatorName", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorMissing", "\"", ",", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "try", "{", "Class", "<", "?", ">", "authenticatorClass", "=", "Class", ".", "forName", "(", "authenticatorName", ")", ";", "authenticator", "=", "(", "Valve", ")", "authenticatorClass", ".", "getConstructor", "(", ")", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "t", ")", ";", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorInstantiate", "\"", ",", "authenticatorName", ")", ",", "t", ")", ";", "ok", "=", "false", ";", "}", "}", "if", "(", "authenticator", "!=", "null", ")", "{", "Pipeline", "pipeline", "=", "context", ".", "getPipeline", "(", ")", ";", "if", "(", "pipeline", "!=", "null", ")", "{", "pipeline", ".", "addValve", "(", "authenticator", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorConfigured", "\"", ",", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ")", ";", "}", "}", "}", "}"], "idx": 100471, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "4d637bc3986e5d09b9363e2144b8ba74fa6eac3a", "function_name": "authenticatorConfig", "body_hash": "612a37742d091c04770b4fcbd1cb2aaa0872bcbc"}
{"code": "public static int versionCompare(String fromVersion, String toVersion) {\n        String[] fromArr = fromVersion.split(\"\\\\.\");\n        String[] toArr = toVersion.split(\"\\\\.\");\n        int fromFirst = Integer.parseInt(fromArr[0]);\n        int fromMiddle = Integer.parseInt(fromArr[1]);\n        int fromEnd = Integer.parseInt(fromArr[2]);\n        int toFirst = Integer.parseInt(toArr[0]);\n        int toMiddle = Integer.parseInt(toArr[1]);\n        int toEnd = Integer.parseInt(toArr[2]);\n        if (fromFirst - toFirst != 0) {\n            return fromFirst - toFirst;\n        } else if (fromMiddle - toMiddle != 0) {\n            return fromMiddle - toMiddle;\n        } else {\n            return fromEnd - toEnd;\n        }\n    }", "code_tokens": ["public", "static", "int", "versionCompare", "(", "String", "fromVersion", ",", "String", "toVersion", ")", "{", "String", "[", "]", "fromArr", "=", "fromVersion", ".", "split", "(", "\"", "\\\\", ".", "\"", ")", ";", "String", "[", "]", "toArr", "=", "toVersion", ".", "split", "(", "\"", "\\\\", ".", "\"", ")", ";", "int", "fromFirst", "=", "Integer", ".", "parseInt", "(", "fromArr", "[", "0", "]", ")", ";", "int", "fromMiddle", "=", "Integer", ".", "parseInt", "(", "fromArr", "[", "1", "]", ")", ";", "int", "fromEnd", "=", "Integer", ".", "parseInt", "(", "fromArr", "[", "2", "]", ")", ";", "int", "toFirst", "=", "Integer", ".", "parseInt", "(", "toArr", "[", "0", "]", ")", ";", "int", "toMiddle", "=", "Integer", ".", "parseInt", "(", "toArr", "[", "1", "]", ")", ";", "int", "toEnd", "=", "Integer", ".", "parseInt", "(", "toArr", "[", "2", "]", ")", ";", "if", "(", "fromFirst", "-", "toFirst", "!=", "0", ")", "{", "return", "fromFirst", "-", "toFirst", ";", "}", "else", "if", "(", "fromMiddle", "-", "toMiddle", "!=", "0", ")", "{", "return", "fromMiddle", "-", "toMiddle", ";", "}", "else", "{", "return", "fromEnd", "-", "toEnd", ";", "}", "}"], "idx": 102441, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "1a783729a1d7e0cd59d59a8dd3a73cdd6ac0f30d", "function_name": "versionCompare", "body_hash": "8eec0a13c4401c7bb35f71696e8916332b59c6d6"}
{"code": "public static boolean isCsrfTokenValid(VaadinSession session,\n            String requestToken) {\n\n        if (session.getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String sessionToken = session.getCsrfToken();\n\n            if (sessionToken == null || !sessionToken.equals(requestToken)) {\n                return false;\n            }\n        }\n        return true;\n    }", "code_tokens": ["public", "static", "boolean", "isCsrfTokenValid", "(", "VaadinSession", "session", ",", "String", "requestToken", ")", "{", "if", "(", "session", ".", "getService", "(", ")", ".", "getDeploymentConfiguration", "(", ")", ".", "isXsrfProtectionEnabled", "(", ")", ")", "{", "String", "sessionToken", "=", "session", ".", "getCsrfToken", "(", ")", ";", "if", "(", "sessionToken", "==", "null", "||", "!", "sessionToken", ".", "equals", "(", "requestToken", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "idx": 20047, "cwe": "CWE-203", "target": 1, "status": "VULNERABLE", "commit": "a7ff693", "function_name": "isCsrfTokenValid", "body_hash": "206dd11395a9101bbf4bdca55757e21426beb27d"}
{"code": "private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n\n        String url = httpServletRequest.getRequestURI();\n        url = url.replaceFirst(\"/navigate/directions/v5/gh/\" + profile + \"/\", \"\");\n        url = url.replaceAll(\"\\\\?[*]\", \"\");\n\n        String[] pointStrings = url.split(\";\");\n\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n    }", "code_tokens": ["private", "List", "<", "GHPoint", ">", "getPointsFromRequest", "(", "HttpServletRequest", "httpServletRequest", ",", "String", "profile", ")", "{", "String", "url", "=", "httpServletRequest", ".", "getRequestURI", "(", ")", ";", "url", "=", "url", ".", "replaceFirst", "(", "\"", "/navigate/directions/v5/gh/", "\"", "+", "profile", "+", "\"", "/", "\"", ",", "\"", "\"", ")", ";", "url", "=", "url", ".", "replaceAll", "(", "\"", "\\\\", "?[*]", "\"", ",", "\"", "\"", ")", ";", "String", "[", "]", "pointStrings", "=", "url", ".", "split", "(", "\"", ";", "\"", ")", ";", "List", "<", "GHPoint", ">", "points", "=", "new", "ArrayList", "<", ">", "(", "pointStrings", ".", "length", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pointStrings", ".", "length", ";", "i", "++", ")", "{", "points", ".", "add", "(", "GHPoint", ".", "fromStringLonLat", "(", "pointStrings", "[", "i", "]", ")", ")", ";", "}", "return", "points", ";", "}"], "idx": 52624, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "eb189be1fa7443ebf4ae881e737a18f818c95f41", "function_name": "getPointsFromRequest", "body_hash": "188f381889da8018b1d44d598420caa8e960655f"}
{"code": "@SuppressWarnings(\"unchecked\")\n    private static Object parseParameter(Map<String, Object> context, Object value) {\n        if (value instanceof String) {\n            if (((String) value).startsWith(\"parameter::\") || ((String) value).startsWith(\"script::\")) {\n                String s = (String) value;\n                if (s.startsWith(\"parameter::\")) {\n                    return context.get(StringUtils.substringAfter(s, \"parameter::\"));\n                } else if (s.startsWith(\"script::\")) {\n                    String script = StringUtils.substringAfter(s, \"script::\");\n                    return executeScript(context, script);\n                }\n            }\n        } else if (value instanceof Map) {\n            Map<String, Object> values = new HashMap<String, Object>();\n            for (Map.Entry<String, Object> entry : ((Map<String, Object>) value).entrySet()) {\n                Object parameter = parseParameter(context, entry.getValue());\n                if (parameter == null) {\n                    return null;\n                }\n                values.put(entry.getKey(), parameter);\n            }\n            return values;\n        } else if (value instanceof List) {\n            List<Object> values = new ArrayList<Object>();\n            for (Object o : ((List<?>) value)) {\n                Object parameter = parseParameter(context, o);\n                if (parameter != null) {\n                    values.add(parameter);\n                }\n            }\n            return values;\n        }\n        return value;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "private", "static", "Object", "parseParameter", "(", "Map", "<", "String", ",", "Object", ">", "context", ",", "Object", "value", ")", "{", "if", "(", "value", "instanceof", "String", ")", "{", "if", "(", "(", "(", "String", ")", "value", ")", ".", "startsWith", "(", "\"", "parameter::", "\"", ")", "||", "(", "(", "String", ")", "value", ")", ".", "startsWith", "(", "\"", "script::", "\"", ")", ")", "{", "String", "s", "=", "(", "String", ")", "value", ";", "if", "(", "s", ".", "startsWith", "(", "\"", "parameter::", "\"", ")", ")", "{", "return", "context", ".", "get", "(", "StringUtils", ".", "substringAfter", "(", "s", ",", "\"", "parameter::", "\"", ")", ")", ";", "}", "else", "if", "(", "s", ".", "startsWith", "(", "\"", "script::", "\"", ")", ")", "{", "String", "script", "=", "StringUtils", ".", "substringAfter", "(", "s", ",", "\"", "script::", "\"", ")", ";", "return", "executeScript", "(", "context", ",", "script", ")", ";", "}", "}", "}", "else", "if", "(", "value", "instanceof", "Map", ")", "{", "Map", "<", "String", ",", "Object", ">", "values", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "entry", ":", "(", "(", "Map", "<", "String", ",", "Object", ">", ")", "value", ")", ".", "entrySet", "(", ")", ")", "{", "Object", "parameter", "=", "parseParameter", "(", "context", ",", "entry", ".", "getValue", "(", ")", ")", ";", "if", "(", "parameter", "==", "null", ")", "{", "return", "null", ";", "}", "values", ".", "put", "(", "entry", ".", "getKey", "(", ")", ",", "parameter", ")", ";", "}", "return", "values", ";", "}", "else", "if", "(", "value", "instanceof", "List", ")", "{", "List", "<", "Object", ">", "values", "=", "new", "ArrayList", "<", "Object", ">", "(", ")", ";", "for", "(", "Object", "o", ":", "(", "(", "List", "<", "?", ">", ")", "value", ")", ")", "{", "Object", "parameter", "=", "parseParameter", "(", "context", ",", "o", ")", ";", "if", "(", "parameter", "!=", "null", ")", "{", "values", ".", "add", "(", "parameter", ")", ";", "}", "}", "return", "values", ";", "}", "return", "value", ";", "}"], "idx": 102381, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "789ae8e820c507866b9c91590feebffa4e996f5e", "function_name": "parseParameter", "body_hash": "9c466bb788c7ecc8c9b23e558cecd025deaba9d7"}
{"code": "@Override\n        public Long next()\n        {\n            if (currentNumber >= maxValue)\n            {\n                throw new NoSuchElementException();\n            }\n            if (currentNumber < currentEnd)\n            {\n                return currentNumber++;\n            }\n            currentNumber = start[++currentRange];\n            currentEnd = end[currentRange];\n            return currentNumber++;\n        }", "code_tokens": ["@", "Override", "public", "Long", "next", "(", ")", "{", "if", "(", "currentNumber", ">=", "maxValue", ")", "{", "throw", "new", "NoSuchElementException", "(", ")", ";", "}", "if", "(", "currentNumber", "<", "currentEnd", ")", "{", "return", "currentNumber", "++", ";", "}", "currentNumber", "=", "start", "[", "++", "currentRange", "]", ";", "currentEnd", "=", "end", "[", "currentRange", "]", ";", "return", "currentNumber", "++", ";", "}"], "idx": 115226, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "35779d3d37edb90e739b1f7c00cb6bb5c62d6360", "function_name": "next", "body_hash": "50b3b55b743c66e831f2c756706295e462c601b9"}
{"code": "@RequirePOST\n        public FormValidation doSendTestMail(\n                @QueryParameter String smtpServer, @QueryParameter String adminAddress, @QueryParameter boolean useSMTPAuth,\n                @QueryParameter String smtpAuthUserName, @QueryParameter Secret smtpAuthPasswordSecret,\n                @QueryParameter boolean useSsl, @QueryParameter String smtpPort, @QueryParameter String charset,\n                @QueryParameter String sendTestMailTo) throws IOException, ServletException, InterruptedException {\n            try {\n                // TODO 1.590+ Jenkins.getActiveInstance\n                final Jenkins jenkins = Jenkins.getInstance();\n                if (jenkins == null) {\n                    throw new IOException(\"Jenkins instance is not ready\");\n                }\n\n                jenkins.checkPermission(Jenkins.ADMINISTER);\n                \n                if (!useSMTPAuth) {\n                    smtpAuthUserName = null;\n                    smtpAuthPasswordSecret = null;\n                }\n                \n                MimeMessage msg = new MimeMessage(createSession(smtpServer, smtpPort, useSsl, smtpAuthUserName, smtpAuthPasswordSecret));\n                msg.setSubject(Messages.Mailer_TestMail_Subject(testEmailCount.incrementAndGet()), charset);\n                msg.setText(Messages.Mailer_TestMail_Content(testEmailCount.get(), jenkins.getDisplayName()), charset);\n                msg.setFrom(stringToAddress(adminAddress, charset));\n                if (StringUtils.isNotBlank(replyToAddress)) {\n                    msg.setReplyTo(new Address[]{stringToAddress(replyToAddress, charset)});\n                }\n                msg.setSentDate(new Date());\n                msg.setRecipient(Message.RecipientType.TO, stringToAddress(sendTestMailTo, charset));\n\n                Transport.send(msg);                \n                return FormValidation.ok(Messages.Mailer_EmailSentSuccessfully());\n            } catch (MessagingException e) {\n                return FormValidation.errorWithMarkup(\"<p>\"+Messages.Mailer_FailedToSendEmail()+\"</p><pre>\"+Util.escape(Functions.printThrowable(e))+\"</pre>\");\n            }\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doSendTestMail", "(", "@", "QueryParameter", "String", "smtpServer", ",", "@", "QueryParameter", "String", "adminAddress", ",", "@", "QueryParameter", "boolean", "useSMTPAuth", ",", "@", "QueryParameter", "String", "smtpAuthUserName", ",", "@", "QueryParameter", "Secret", "smtpAuthPasswordSecret", ",", "@", "QueryParameter", "boolean", "useSsl", ",", "@", "QueryParameter", "String", "smtpPort", ",", "@", "QueryParameter", "String", "charset", ",", "@", "QueryParameter", "String", "sendTestMailTo", ")", "throws", "IOException", ",", "ServletException", ",", "InterruptedException", "{", "try", "{", "final", "Jenkins", "jenkins", "=", "Jenkins", ".", "getInstance", "(", ")", ";", "if", "(", "jenkins", "==", "null", ")", "{", "throw", "new", "IOException", "(", "\"", "Jenkins instance is not ready", "\"", ")", ";", "}", "jenkins", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "if", "(", "!", "useSMTPAuth", ")", "{", "smtpAuthUserName", "=", "null", ";", "smtpAuthPasswordSecret", "=", "null", ";", "}", "MimeMessage", "msg", "=", "new", "MimeMessage", "(", "createSession", "(", "smtpServer", ",", "smtpPort", ",", "useSsl", ",", "smtpAuthUserName", ",", "smtpAuthPasswordSecret", ")", ")", ";", "msg", ".", "setSubject", "(", "Messages", ".", "Mailer_TestMail_Subject", "(", "testEmailCount", ".", "incrementAndGet", "(", ")", ")", ",", "charset", ")", ";", "msg", ".", "setText", "(", "Messages", ".", "Mailer_TestMail_Content", "(", "testEmailCount", ".", "get", "(", ")", ",", "jenkins", ".", "getDisplayName", "(", ")", ")", ",", "charset", ")", ";", "msg", ".", "setFrom", "(", "stringToAddress", "(", "adminAddress", ",", "charset", ")", ")", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "replyToAddress", ")", ")", "{", "msg", ".", "setReplyTo", "(", "new", "Address", "[", "]", "{", "stringToAddress", "(", "replyToAddress", ",", "charset", ")", "}", ")", ";", "}", "msg", ".", "setSentDate", "(", "new", "Date", "(", ")", ")", ";", "msg", ".", "setRecipient", "(", "Message", ".", "RecipientType", ".", "TO", ",", "stringToAddress", "(", "sendTestMailTo", ",", "charset", ")", ")", ";", "Transport", ".", "send", "(", "msg", ")", ";", "return", "FormValidation", ".", "ok", "(", "Messages", ".", "Mailer_EmailSentSuccessfully", "(", ")", ")", ";", "}", "catch", "(", "MessagingException", "e", ")", "{", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "<p>", "\"", "+", "Messages", ".", "Mailer_FailedToSendEmail", "(", ")", "+", "\"", "</p><pre>", "\"", "+", "Util", ".", "escape", "(", "Functions", ".", "printThrowable", "(", "e", ")", ")", "+", "\"", "</pre>", "\"", ")", ";", "}", "}"], "idx": 47163, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "98e79cf", "function_name": "doSendTestMail", "body_hash": "7a3529722edc32380682521797e59945fd1ed397"}
{"code": "protected String sanitiseWindowId(String windowId)\n    {\n        return windowId.replace('(', '_');\n    }", "code_tokens": ["protected", "String", "sanitiseWindowId", "(", "String", "windowId", ")", "{", "return", "windowId", ".", "replace", "(", "'('", ",", "'_'", ")", ";", "}"], "idx": 79102, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "d95abe8c", "function_name": "sanitiseWindowId", "body_hash": "40ba5462cd789ab7d830b5497f78d59c19d5e4a0"}
{"code": "private IdentityZone createZone(String id, HttpStatus expect, String token, IdentityZoneConfiguration zoneConfiguration) throws Exception {\n        IdentityZone identityZone = getIdentityZone(id);\n        identityZone.setConfig(zoneConfiguration);\n        identityZone.getConfig().getSamlConfig().setPrivateKey(serviceProviderKey);\n        identityZone.getConfig().getSamlConfig().setPrivateKeyPassword(serviceProviderKeyPassword);\n        identityZone.getConfig().getSamlConfig().setCertificate(serviceProviderCertificate);\n        Map<String, String> keys = new HashMap<>();\n        keys.put(\"kid\", \"key\");\n        identityZone.getConfig().getTokenPolicy().setKeys(keys);\n        identityZone.getConfig().getTokenPolicy().setActiveKeyId(\"kid\");\n\n        MvcResult result = getMockMvc().perform(\n            post(\"/identity-zones\")\n                .header(\"Authorization\", \"Bearer \" + token)\n                .contentType(APPLICATION_JSON)\n                .content(JsonUtils.writeValueAsString(identityZone)))\n            .andExpect(status().is(expect.value()))\n            .andReturn();\n\n        if (expect.is2xxSuccessful()) {\n            return JsonUtils.readValue(result.getResponse().getContentAsString(), IdentityZone.class);\n        }\n        return null;\n    }", "code_tokens": ["private", "IdentityZone", "createZone", "(", "String", "id", ",", "HttpStatus", "expect", ",", "String", "token", ",", "IdentityZoneConfiguration", "zoneConfiguration", ")", "throws", "Exception", "{", "IdentityZone", "identityZone", "=", "getIdentityZone", "(", "id", ")", ";", "identityZone", ".", "setConfig", "(", "zoneConfiguration", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "getSamlConfig", "(", ")", ".", "setPrivateKey", "(", "serviceProviderKey", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "getSamlConfig", "(", ")", ".", "setPrivateKeyPassword", "(", "serviceProviderKeyPassword", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "getSamlConfig", "(", ")", ".", "setCertificate", "(", "serviceProviderCertificate", ")", ";", "Map", "<", "String", ",", "String", ">", "keys", "=", "new", "HashMap", "<", ">", "(", ")", ";", "keys", ".", "put", "(", "\"", "kid", "\"", ",", "\"", "key", "\"", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "getTokenPolicy", "(", ")", ".", "setKeys", "(", "keys", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "getTokenPolicy", "(", ")", ".", "setActiveKeyId", "(", "\"", "kid", "\"", ")", ";", "MvcResult", "result", "=", "getMockMvc", "(", ")", ".", "perform", "(", "post", "(", "\"", "/identity-zones", "\"", ")", ".", "header", "(", "\"", "Authorization", "\"", ",", "\"", "Bearer ", "\"", "+", "token", ")", ".", "contentType", "(", "APPLICATION_JSON", ")", ".", "content", "(", "JsonUtils", ".", "writeValueAsString", "(", "identityZone", ")", ")", ")", ".", "andExpect", "(", "status", "(", ")", ".", "is", "(", "expect", ".", "value", "(", ")", ")", ")", ".", "andReturn", "(", ")", ";", "if", "(", "expect", ".", "is2xxSuccessful", "(", ")", ")", "{", "return", "JsonUtils", ".", "readValue", "(", "result", ".", "getResponse", "(", ")", ".", "getContentAsString", "(", ")", ",", "IdentityZone", ".", "class", ")", ";", "}", "return", "null", ";", "}"], "idx": 109184, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "14c745aa293b8d3ce9cdd6bfbc6c0ef3f269b21", "function_name": "createZone", "body_hash": "34b183af566330a38e5a120b62e23aeb8958a582"}
{"code": "@Restricted(NoExternalUse.class)\n    @RequirePOST public HttpResponse doCheckUpdatesServer() throws IOException {\n        for (UpdateSite site : Jenkins.getInstance().getUpdateCenter().getSites()) {\n            FormValidation v = site.updateDirectlyNow(DownloadService.signatureCheck);\n            if (v.kind != FormValidation.Kind.OK) {\n                // TODO crude but enough for now\n                return v;\n            }\n        }\n        for (DownloadService.Downloadable d : DownloadService.Downloadable.all()) {\n            FormValidation v = d.updateNow();\n            if (v.kind != FormValidation.Kind.OK) {\n                return v;\n            }\n        }\n        return HttpResponses.forwardToPreviousPage();\n    }", "code_tokens": ["@", "Restricted", "(", "NoExternalUse", ".", "class", ")", "@", "RequirePOST", "public", "HttpResponse", "doCheckUpdatesServer", "(", ")", "throws", "IOException", "{", "for", "(", "UpdateSite", "site", ":", "Jenkins", ".", "getInstance", "(", ")", ".", "getUpdateCenter", "(", ")", ".", "getSites", "(", ")", ")", "{", "FormValidation", "v", "=", "site", ".", "updateDirectlyNow", "(", "DownloadService", ".", "signatureCheck", ")", ";", "if", "(", "v", ".", "kind", "!=", "FormValidation", ".", "Kind", ".", "OK", ")", "{", "return", "v", ";", "}", "}", "for", "(", "DownloadService", ".", "Downloadable", "d", ":", "DownloadService", ".", "Downloadable", ".", "all", "(", ")", ")", "{", "FormValidation", "v", "=", "d", ".", "updateNow", "(", ")", ";", "if", "(", "v", ".", "kind", "!=", "FormValidation", ".", "Kind", ".", "OK", ")", "{", "return", "v", ";", "}", "}", "return", "HttpResponses", ".", "forwardToPreviousPage", "(", ")", ";", "}"], "idx": 30509, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "56be107feb24ab3470efae7603041bbbb9cdf7fb", "function_name": "doCheckUpdatesServer", "body_hash": "292a8e8c83a60b24309d5acd20c25028ef277546"}
{"code": "public String verifyAndExtract(String signedStr) {\n    int index = signedStr.lastIndexOf(SIGNATURE);\n    if (index == -1) {\n      throw new IllegalArgumentException(\"Invalid input sign: \" + signedStr);\n    }\n    String originalSignature = signedStr.substring(index + SIGNATURE.length());\n    String rawValue = signedStr.substring(0, index);\n    String currentSignature = getSignature(rawValue);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Signature generated for \" + rawValue + \" inside verify is \" + currentSignature);\n    }\n    if (!originalSignature.equals(currentSignature)) {\n      throw new IllegalArgumentException(\"Invalid sign, original = \" + originalSignature +\n        \" current = \" + currentSignature);\n    }\n    return rawValue;\n  }", "code_tokens": ["public", "String", "verifyAndExtract", "(", "String", "signedStr", ")", "{", "int", "index", "=", "signedStr", ".", "lastIndexOf", "(", "SIGNATURE", ")", ";", "if", "(", "index", "==", "-", "1", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Invalid input sign: ", "\"", "+", "signedStr", ")", ";", "}", "String", "originalSignature", "=", "signedStr", ".", "substring", "(", "index", "+", "SIGNATURE", ".", "length", "(", ")", ")", ";", "String", "rawValue", "=", "signedStr", ".", "substring", "(", "0", ",", "index", ")", ";", "String", "currentSignature", "=", "getSignature", "(", "rawValue", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Signature generated for ", "\"", "+", "rawValue", "+", "\"", " inside verify is ", "\"", "+", "currentSignature", ")", ";", "}", "if", "(", "!", "originalSignature", ".", "equals", "(", "currentSignature", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Invalid sign, original = ", "\"", "+", "originalSignature", "+", "\"", " current = ", "\"", "+", "currentSignature", ")", ";", "}", "return", "rawValue", ";", "}"], "idx": 20518, "cwe": "CWE-203", "target": 1, "status": "VULNERABLE", "commit": "4de6ddc99a36f7ce8f6aa040dbe6f5b623349bb0", "function_name": "verifyAndExtract", "body_hash": "2798072b410f31d6fcea8383458c06c08e2ef0a1"}
{"code": "private void addSort(\n            final SearchRequestBuilder builder,\n            final AnyTypeKind kind,\n            final List<OrderByClause> orderBy) {\n\n        AnyUtils attrUtils = anyUtilsFactory.getInstance(kind);\n\n        for (OrderByClause clause : filterOrderBy(orderBy)) {\n            String sortName = null;\n\n            // Manage difference among external key attribute and internal JPA @Id\n            String fieldName = \"key\".equals(clause.getField()) ? \"id\" : clause.getField();\n\n            Field anyField = ReflectionUtils.findField(attrUtils.anyClass(), fieldName);\n            if (anyField == null) {\n                PlainSchema schema = schemaDAO.find(fieldName);\n                if (schema != null) {\n                    sortName = fieldName;\n                }\n            } else {\n                sortName = fieldName;\n            }\n\n            if (sortName == null) {\n                LOG.warn(\"Cannot build any valid clause from {}\", clause);\n            } else {\n                builder.addSort(sortName, SortOrder.valueOf(clause.getDirection().name()));\n            }\n        }\n    }", "code_tokens": ["private", "void", "addSort", "(", "final", "SearchRequestBuilder", "builder", ",", "final", "AnyTypeKind", "kind", ",", "final", "List", "<", "OrderByClause", ">", "orderBy", ")", "{", "AnyUtils", "attrUtils", "=", "anyUtilsFactory", ".", "getInstance", "(", "kind", ")", ";", "for", "(", "OrderByClause", "clause", ":", "filterOrderBy", "(", "orderBy", ")", ")", "{", "String", "sortName", "=", "null", ";", "String", "fieldName", "=", "\"", "key", "\"", ".", "equals", "(", "clause", ".", "getField", "(", ")", ")", "?", "\"", "id", "\"", ":", "clause", ".", "getField", "(", ")", ";", "Field", "anyField", "=", "ReflectionUtils", ".", "findField", "(", "attrUtils", ".", "anyClass", "(", ")", ",", "fieldName", ")", ";", "if", "(", "anyField", "==", "null", ")", "{", "PlainSchema", "schema", "=", "schemaDAO", ".", "find", "(", "fieldName", ")", ";", "if", "(", "schema", "!=", "null", ")", "{", "sortName", "=", "fieldName", ";", "}", "}", "else", "{", "sortName", "=", "fieldName", ";", "}", "if", "(", "sortName", "==", "null", ")", "{", "LOG", ".", "warn", "(", "\"", "Cannot build any valid clause from {}", "\"", ",", "clause", ")", ";", "}", "else", "{", "builder", ".", "addSort", "(", "sortName", ",", "SortOrder", ".", "valueOf", "(", "clause", ".", "getDirection", "(", ")", ".", "name", "(", ")", ")", ")", ";", "}", "}", "}"], "idx": 15743, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "735579b6f987b407049ac1f1da08e675d957c3e", "function_name": "addSort", "body_hash": "68c70b70dc5c213c4e7ed67e27543115d0da8fa6"}
{"code": "public static String canonicalPath(String path)\n    {\n        if (path==null || path.length()==0)\n            return path;\n\n        int end=path.length();\n        \n        int queryIdx=path.indexOf('?');\n        int start = path.lastIndexOf('/', (queryIdx > 0 ? queryIdx : end));\n        // int start = path.lastIndexOf('/', end);\n\n    search:\n        while (end>0)\n        {\n            switch(end-start)\n            {\n              case 2: // possible single dot\n                  if (path.charAt(start+1)!='.')\n                      break;\n                  break search;\n              case 3: // possible double dot\n                  if (path.charAt(start+1)!='.' || path.charAt(start+2)!='.')\n                      break;\n                  break search;\n            }\n            \n            end=start;\n            start=path.lastIndexOf('/',end-1);\n        }\n\n        // If we have checked the entire string\n        if (start>=end)\n            return path;\n        \n        StringBuffer buf = new StringBuffer(path);\n        int delStart=-1;\n        int delEnd=-1;\n        int skip=0;\n        \n        while (end>0)\n        {\n            switch(end-start)\n            {       \n              case 2: // possible single dot\n                  if (buf.charAt(start+1)!='.')\n                  {\n                      if (skip>0 && --skip==0)\n                      {   \n                          delStart=start>=0?start:0;\n                          if(delStart>0 && delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                              delStart++;\n                      }\n                      break;\n                  }\n                  \n                  if(start<0 && buf.length()>2 && buf.charAt(1)=='/' && buf.charAt(2)=='/')\n                      break;\n                  \n                  if(delEnd<0)\n                      delEnd=end;\n                  delStart=start;\n                  if (delStart<0 || delStart==0&&buf.charAt(delStart)=='/')\n                  {\n                      delStart++;\n                      if (delEnd<buf.length() && buf.charAt(delEnd)=='/')\n                          delEnd++;\n                      break;\n                  }\n                  if (end==buf.length())\n                      delStart++;\n                  \n                  end=start--;\n                  while (start>=0 && buf.charAt(start)!='/')\n                      start--;\n                  continue;\n                  \n              case 3: // possible double dot\n                  if (buf.charAt(start+1)!='.' || buf.charAt(start+2)!='.')\n                  {\n                      if (skip>0 && --skip==0)\n                      {   delStart=start>=0?start:0;\n                          if(delStart>0 && delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                              delStart++;\n                      }\n                      break;\n                  }\n                  \n                  delStart=start;\n                  if (delEnd<0)\n                      delEnd=end;\n\n                  skip++;\n                  end=start--;\n                  while (start>=0 && buf.charAt(start)!='/')\n                      start--;\n                  continue;\n\n              default:\n                  if (skip>0 && --skip==0)\n                  {\n                      delStart=start>=0?start:0;\n                      if(delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                          delStart++;\n                  }\n            }     \n            \n            // Do the delete\n            if (skip<=0 && delStart>=0 && delStart>=0)\n            {  \n                buf.delete(delStart,delEnd);\n                delStart=delEnd=-1;\n                if (skip>0)\n                    delEnd=end;\n            }\n            \n            end=start--;\n            while (start>=0 && buf.charAt(start)!='/')\n                start--;\n        }      \n\n        // Too many ..\n        if (skip>0)\n            return null;\n        \n        // Do the delete\n        if (delEnd>=0)\n            buf.delete(delStart,delEnd);\n\n        return buf.toString();\n    }", "code_tokens": ["public", "static", "String", "canonicalPath", "(", "String", "path", ")", "{", "if", "(", "path", "==", "null", "||", "path", ".", "length", "(", ")", "==", "0", ")", "return", "path", ";", "int", "end", "=", "path", ".", "length", "(", ")", ";", "int", "queryIdx", "=", "path", ".", "indexOf", "(", "'?'", ")", ";", "int", "start", "=", "path", ".", "lastIndexOf", "(", "'/'", ",", "(", "queryIdx", ">", "0", "?", "queryIdx", ":", "end", ")", ")", ";", "search", ":", "while", "(", "end", ">", "0", ")", "{", "switch", "(", "end", "-", "start", ")", "{", "case", "2", ":", "if", "(", "path", ".", "charAt", "(", "start", "+", "1", ")", "!=", "'.'", ")", "break", ";", "break", "search", ";", "case", "3", ":", "if", "(", "path", ".", "charAt", "(", "start", "+", "1", ")", "!=", "'.'", "||", "path", ".", "charAt", "(", "start", "+", "2", ")", "!=", "'.'", ")", "break", ";", "break", "search", ";", "}", "end", "=", "start", ";", "start", "=", "path", ".", "lastIndexOf", "(", "'/'", ",", "end", "-", "1", ")", ";", "}", "if", "(", "start", ">=", "end", ")", "return", "path", ";", "StringBuffer", "buf", "=", "new", "StringBuffer", "(", "path", ")", ";", "int", "delStart", "=", "-", "1", ";", "int", "delEnd", "=", "-", "1", ";", "int", "skip", "=", "0", ";", "while", "(", "end", ">", "0", ")", "{", "switch", "(", "end", "-", "start", ")", "{", "case", "2", ":", "if", "(", "buf", ".", "charAt", "(", "start", "+", "1", ")", "!=", "'.'", ")", "{", "if", "(", "skip", ">", "0", "&&", "--", "skip", "==", "0", ")", "{", "delStart", "=", "start", ">=", "0", "?", "start", ":", "0", ";", "if", "(", "delStart", ">", "0", "&&", "delEnd", "==", "buf", ".", "length", "(", ")", "&&", "buf", ".", "charAt", "(", "delEnd", "-", "1", ")", "==", "'.'", ")", "delStart", "++", ";", "}", "break", ";", "}", "if", "(", "start", "<", "0", "&&", "buf", ".", "length", "(", ")", ">", "2", "&&", "buf", ".", "charAt", "(", "1", ")", "==", "'/'", "&&", "buf", ".", "charAt", "(", "2", ")", "==", "'/'", ")", "break", ";", "if", "(", "delEnd", "<", "0", ")", "delEnd", "=", "end", ";", "delStart", "=", "start", ";", "if", "(", "delStart", "<", "0", "||", "delStart", "==", "0", "&&", "buf", ".", "charAt", "(", "delStart", ")", "==", "'/'", ")", "{", "delStart", "++", ";", "if", "(", "delEnd", "<", "buf", ".", "length", "(", ")", "&&", "buf", ".", "charAt", "(", "delEnd", ")", "==", "'/'", ")", "delEnd", "++", ";", "break", ";", "}", "if", "(", "end", "==", "buf", ".", "length", "(", ")", ")", "delStart", "++", ";", "end", "=", "start", "--", ";", "while", "(", "start", ">=", "0", "&&", "buf", ".", "charAt", "(", "start", ")", "!=", "'/'", ")", "start", "--", ";", "continue", ";", "case", "3", ":", "if", "(", "buf", ".", "charAt", "(", "start", "+", "1", ")", "!=", "'.'", "||", "buf", ".", "charAt", "(", "start", "+", "2", ")", "!=", "'.'", ")", "{", "if", "(", "skip", ">", "0", "&&", "--", "skip", "==", "0", ")", "{", "delStart", "=", "start", ">=", "0", "?", "start", ":", "0", ";", "if", "(", "delStart", ">", "0", "&&", "delEnd", "==", "buf", ".", "length", "(", ")", "&&", "buf", ".", "charAt", "(", "delEnd", "-", "1", ")", "==", "'.'", ")", "delStart", "++", ";", "}", "break", ";", "}", "delStart", "=", "start", ";", "if", "(", "delEnd", "<", "0", ")", "delEnd", "=", "end", ";", "skip", "++", ";", "end", "=", "start", "--", ";", "while", "(", "start", ">=", "0", "&&", "buf", ".", "charAt", "(", "start", ")", "!=", "'/'", ")", "start", "--", ";", "continue", ";", "default", ":", "if", "(", "skip", ">", "0", "&&", "--", "skip", "==", "0", ")", "{", "delStart", "=", "start", ">=", "0", "?", "start", ":", "0", ";", "if", "(", "delEnd", "==", "buf", ".", "length", "(", ")", "&&", "buf", ".", "charAt", "(", "delEnd", "-", "1", ")", "==", "'.'", ")", "delStart", "++", ";", "}", "}", "if", "(", "skip", "<=", "0", "&&", "delStart", ">=", "0", "&&", "delStart", ">=", "0", ")", "{", "buf", ".", "delete", "(", "delStart", ",", "delEnd", ")", ";", "delStart", "=", "delEnd", "=", "-", "1", ";", "if", "(", "skip", ">", "0", ")", "delEnd", "=", "end", ";", "}", "end", "=", "start", "--", ";", "while", "(", "start", ">=", "0", "&&", "buf", ".", "charAt", "(", "start", ")", "!=", "'/'", ")", "start", "--", ";", "}", "if", "(", "skip", ">", "0", ")", "return", "null", ";", "if", "(", "delEnd", ">=", "0", ")", "buf", ".", "delete", "(", "delStart", ",", "delEnd", ")", ";", "return", "buf", ".", "toString", "(", ")", ";", "}"], "idx": 20939, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "038ce0f5c29a60263e23aec544ecec516c043f98", "function_name": "canonicalPath", "body_hash": "36e622d698d74321075b85d4a68f7c964ed732ca"}
{"code": "@Override\n  public void handle(RoutingContext ctx) {\n\n    if (nagHttps) {\n      String uri = ctx.request().absoluteURI();\n      if (uri != null && !uri.startsWith(\"https:\")) {\n        log.warn(\"Using session cookies without https could make you susceptible to session hijacking: \" + uri);\n      }\n    }\n\n    HttpMethod method = ctx.request().method();\n\n    switch (method) {\n      case GET:\n        final String token = generateToken();\n        // put the token in the context for users who prefer to render the token directly on the HTML\n        ctx.put(headerName, token);\n        ctx.addCookie(Cookie.cookie(cookieName, token).setPath(cookiePath));\n        ctx.next();\n        break;\n      case POST:\n      case PUT:\n      case DELETE:\n      case PATCH:\n        final String header = ctx.request().getHeader(headerName);\n        final String cookie = ctx.getCookie(cookieName).getValue();\n        if (validateToken(header == null ? ctx.request().getFormAttribute(headerName) : header, cookie)) {\n          ctx.next();\n        } else {\n          forbidden(ctx);\n        }\n        break;\n      default:\n        // ignore these methods\n        ctx.next();\n        break;\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "RoutingContext", "ctx", ")", "{", "if", "(", "nagHttps", ")", "{", "String", "uri", "=", "ctx", ".", "request", "(", ")", ".", "absoluteURI", "(", ")", ";", "if", "(", "uri", "!=", "null", "&&", "!", "uri", ".", "startsWith", "(", "\"", "https:", "\"", ")", ")", "{", "log", ".", "warn", "(", "\"", "Using session cookies without https could make you susceptible to session hijacking: ", "\"", "+", "uri", ")", ";", "}", "}", "HttpMethod", "method", "=", "ctx", ".", "request", "(", ")", ".", "method", "(", ")", ";", "switch", "(", "method", ")", "{", "case", "GET", ":", "final", "String", "token", "=", "generateToken", "(", ")", ";", "ctx", ".", "put", "(", "headerName", ",", "token", ")", ";", "ctx", ".", "addCookie", "(", "Cookie", ".", "cookie", "(", "cookieName", ",", "token", ")", ".", "setPath", "(", "cookiePath", ")", ")", ";", "ctx", ".", "next", "(", ")", ";", "break", ";", "case", "POST", ":", "case", "PUT", ":", "case", "DELETE", ":", "case", "PATCH", ":", "final", "String", "header", "=", "ctx", ".", "request", "(", ")", ".", "getHeader", "(", "headerName", ")", ";", "final", "String", "cookie", "=", "ctx", ".", "getCookie", "(", "cookieName", ")", ".", "getValue", "(", ")", ";", "if", "(", "validateToken", "(", "header", "==", "null", "?", "ctx", ".", "request", "(", ")", ".", "getFormAttribute", "(", "headerName", ")", ":", "header", ",", "cookie", ")", ")", "{", "ctx", ".", "next", "(", ")", ";", "}", "else", "{", "forbidden", "(", "ctx", ")", ";", "}", "break", ";", "default", ":", "ctx", ".", "next", "(", ")", ";", "break", ";", "}", "}"], "idx": 48023, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "98891b1d9e022b467a3e4674aca4d1889849b1d", "function_name": "handle", "body_hash": "53d302bf6ba5ca1fdb0d560e42951c982e0b763f"}
{"code": "private void prepareRequest() throws IOException {\n\n        http11 = true;\n        http09 = false;\n        contentDelimitation = false;\n\n        if (endpoint.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n        MessageBytes protocolMB = request.protocol();\n        if (protocolMB.equals(Constants.HTTP_11)) {\n            protocolMB.setString(Constants.HTTP_11);\n        } else if (protocolMB.equals(Constants.HTTP_10)) {\n            http11 = false;\n            keepAlive = false;\n            protocolMB.setString(Constants.HTTP_10);\n        } else if (protocolMB.equals(\"\")) {\n            // HTTP/0.9\n            http09 = true;\n            http11 = false;\n            keepAlive = false;\n        } else {\n            // Unsupported protocol\n            http11 = false;\n            // Send 505; Unsupported HTTP version\n            response.setStatus(505);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n            }\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents != null &&\n                        restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        // \"identity\" codings are ignored\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    // Invalid transfer encoding\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n                }\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "http11", "=", "true", ";", "http09", "=", "false", ";", "contentDelimitation", "=", "false", ";", "if", "(", "endpoint", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MessageBytes", "protocolMB", "=", "request", ".", "protocol", "(", ")", ";", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_11", ")", ")", "{", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_11", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_10", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_10", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "\"", "\"", ")", ")", "{", "http09", "=", "true", ";", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "http11", "=", "false", ";", "response", ".", "setStatus", "(", "505", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Unsupported HTTP version ", "\\\"", "\"", "+", "protocolMB", "+", "\"", "\\\"", "\"", ")", ";", "}", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEP_ALIVE_HEADER_VALUE_TOKEN", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "inputBuffer", ".", "setSwallowInput", "(", "false", ")", ";", "request", ".", "setExpectation", "(", "true", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "(", "http11", "||", "keepAlive", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "protocol", ".", "getAllowHostHeaderMismatch", "(", ")", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "inputBuffer", ".", "getFilters", "(", ")", ";", "if", "(", "http11", ")", "{", "MessageBytes", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ")", "{", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidTransferEncoding", "\"", ")", ";", "}", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "}", "else", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 55624, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "959f1df", "function_name": "prepareRequest", "body_hash": "7c78331fc29f878eb6126601494c48c8d266e764"}
{"code": "private static String localeToString(Locale locale) {\n        if (locale != null) {\n            return locale.toString();//locale.getDisplayName();\n        } else {\n            return \"\";\n        }\n    }", "code_tokens": ["private", "static", "String", "localeToString", "(", "Locale", "locale", ")", "{", "if", "(", "locale", "!=", "null", ")", "{", "return", "locale", ".", "toString", "(", ")", ";", "}", "else", "{", "return", "\"", "\"", ";", "}", "}"], "idx": 79325, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "5971f9392edc6d70808b2599b062b050fcd11d23", "function_name": "localeToString", "body_hash": "4534cc690eceb065ecef498c775af571eab8be90"}
{"code": "@Override\n\tprotected void onInitialize()\n\t{\n\t\tsuper.onInitialize();\n\n\t\tthis.textarea = new HiddenField<String>(\"textarea\", this.getModel());\n\t\tthis.textarea.setOutputMarkupId(true);\n\t\tthis.textarea.setEscapeModelStrings(false);\n\t\tthis.add(this.textarea);\n\n\t\tthis.add(JQueryWidget.newWidgetBehavior(this, this.container));\n\t}", "code_tokens": ["@", "Override", "protected", "void", "onInitialize", "(", ")", "{", "super", ".", "onInitialize", "(", ")", ";", "this", ".", "textarea", "=", "new", "HiddenField", "<", "String", ">", "(", "\"", "textarea", "\"", ",", "this", ".", "getModel", "(", ")", ")", ";", "this", ".", "textarea", ".", "setOutputMarkupId", "(", "true", ")", ";", "this", ".", "textarea", ".", "setEscapeModelStrings", "(", "false", ")", ";", "this", ".", "add", "(", "this", ".", "textarea", ")", ";", "this", ".", "add", "(", "JQueryWidget", ".", "newWidgetBehavior", "(", "this", ",", "this", ".", "container", ")", ")", ";", "}"], "idx": 81627, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "22e414d693e8ef679ac6da38107fbc118a63f00", "function_name": "onInitialize", "body_hash": "b64c220d07326238001feac05ebfe24e12686987"}
{"code": "@Override\n  public void handle(RoutingContext context) {\n    HttpServerRequest request = context.request();\n    if (request.method() != HttpMethod.GET && request.method() != HttpMethod.HEAD) {\n      if (log.isTraceEnabled()) log.trace(\"Not GET or HEAD so ignoring request\");\n      context.next();\n    } else {\n      String path = Utils.removeDots(Utils.urlDecode(context.normalisedPath(), false));\n      // if the normalized path is null it cannot be resolved\n      if (path == null) {\n        log.warn(\"Invalid path: \" + context.request().path());\n        context.next();\n        return;\n      }\n\n      // only root is known for sure to be a directory. all other directories must be identified as such.\n      if (!directoryListing && \"/\".equals(path)) {\n        path = indexPage;\n      }\n\n      // can be called recursive for index pages\n      sendStatic(context, path);\n\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "RoutingContext", "context", ")", "{", "HttpServerRequest", "request", "=", "context", ".", "request", "(", ")", ";", "if", "(", "request", ".", "method", "(", ")", "!=", "HttpMethod", ".", "GET", "&&", "request", ".", "method", "(", ")", "!=", "HttpMethod", ".", "HEAD", ")", "{", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "log", ".", "trace", "(", "\"", "Not GET or HEAD so ignoring request", "\"", ")", ";", "context", ".", "next", "(", ")", ";", "}", "else", "{", "String", "path", "=", "Utils", ".", "removeDots", "(", "Utils", ".", "urlDecode", "(", "context", ".", "normalisedPath", "(", ")", ",", "false", ")", ")", ";", "if", "(", "path", "==", "null", ")", "{", "log", ".", "warn", "(", "\"", "Invalid path: ", "\"", "+", "context", ".", "request", "(", ")", ".", "path", "(", ")", ")", ";", "context", ".", "next", "(", ")", ";", "return", ";", "}", "if", "(", "!", "directoryListing", "&&", "\"", "/", "\"", ".", "equals", "(", "path", ")", ")", "{", "path", "=", "indexPage", ";", "}", "sendStatic", "(", "context", ",", "path", ")", ";", "}", "}"], "idx": 28750, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "57a65dce6f4c5aa5e3ce7288685e7f3447eb8f3b", "function_name": "handle", "body_hash": "6ef1ed588f560674386cbcd60637ab85f51bf3e6"}
{"code": "public @CheckForNull User getUser(String name) {\n        return User.get(name,hasPermission(ADMINISTER));\n    }", "code_tokens": ["public", "@", "CheckForNull", "User", "getUser", "(", "String", "name", ")", "{", "return", "User", ".", "get", "(", "name", ",", "hasPermission", "(", "ADMINISTER", ")", ")", ";", "}"], "idx": 44644, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "b88b20ec473200db35d0a0d29dcf192069106601", "function_name": "getUser", "body_hash": "318bd9cf84b1506c217f8543085a43c8223a3334"}
{"code": "private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new FixedSecureRandom(\n            new FixedSecureRandom.Source[] { new FixedSecureRandom.BigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\"))),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\")) });\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }", "code_tokens": ["private", "void", "doDsaTest", "(", "String", "sigName", ",", "BigInteger", "s", ",", "KeyFactory", "ecKeyFact", ",", "DSAPublicKeySpec", "pubKey", ",", "DSAPrivateKeySpec", "priKey", ")", "throws", "NoSuchAlgorithmException", ",", "NoSuchProviderException", ",", "InvalidKeyException", ",", "InvalidKeySpecException", ",", "SignatureException", "{", "SecureRandom", "k", "=", "new", "FixedSecureRandom", "(", "new", "FixedSecureRandom", ".", "Source", "[", "]", "{", "new", "FixedSecureRandom", ".", "BigInteger", "(", "BigIntegers", ".", "asUnsignedByteArray", "(", "new", "BigInteger", "(", "\"", "72546832179840998877302529996971396893172522460793442785601695562409154906335", "\"", ")", ")", ")", ",", "new", "FixedSecureRandom", ".", "Data", "(", "Hex", ".", "decode", "(", "\"", "01020304", "\"", ")", ")", "}", ")", ";", "byte", "[", "]", "M", "=", "Hex", ".", "decode", "(", "\"", "1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD", "\"", ")", ";", "Signature", "dsa", "=", "Signature", ".", "getInstance", "(", "sigName", ",", "\"", "BC", "\"", ")", ";", "dsa", ".", "initSign", "(", "ecKeyFact", ".", "generatePrivate", "(", "priKey", ")", ",", "k", ")", ";", "dsa", ".", "update", "(", "M", ",", "0", ",", "M", ".", "length", ")", ";", "byte", "[", "]", "encSig", "=", "dsa", ".", "sign", "(", ")", ";", "ASN1Sequence", "sig", "=", "ASN1Sequence", ".", "getInstance", "(", "encSig", ")", ";", "BigInteger", "r", "=", "new", "BigInteger", "(", "\"", "4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510", "\"", ",", "16", ")", ";", "BigInteger", "sigR", "=", "ASN1Integer", ".", "getInstance", "(", "sig", ".", "getObjectAt", "(", "0", ")", ")", ".", "getValue", "(", ")", ";", "if", "(", "!", "r", ".", "equals", "(", "sigR", ")", ")", "{", "fail", "(", "\"", "r component wrong.", "\"", "+", "Strings", ".", "lineSeparator", "(", ")", "+", "\"", " expecting: ", "\"", "+", "r", ".", "toString", "(", "16", ")", "+", "Strings", ".", "lineSeparator", "(", ")", "+", "\"", " got      : ", "\"", "+", "sigR", ".", "toString", "(", "16", ")", ")", ";", "}", "BigInteger", "sigS", "=", "ASN1Integer", ".", "getInstance", "(", "sig", ".", "getObjectAt", "(", "1", ")", ")", ".", "getValue", "(", ")", ";", "if", "(", "!", "s", ".", "equals", "(", "sigS", ")", ")", "{", "fail", "(", "\"", "s component wrong.", "\"", "+", "Strings", ".", "lineSeparator", "(", ")", "+", "\"", " expecting: ", "\"", "+", "s", ".", "toString", "(", "16", ")", "+", "Strings", ".", "lineSeparator", "(", ")", "+", "\"", " got      : ", "\"", "+", "sigS", ".", "toString", "(", "16", ")", ")", ";", "}", "dsa", ".", "initVerify", "(", "ecKeyFact", ".", "generatePublic", "(", "pubKey", ")", ")", ";", "dsa", ".", "update", "(", "M", ",", "0", ",", "M", ".", "length", ")", ";", "if", "(", "!", "dsa", ".", "verify", "(", "encSig", ")", ")", "{", "fail", "(", "\"", "signature fails", "\"", ")", ";", "}", "}"], "idx": 48221, "cwe": "CWE-361", "target": 0, "status": "FIXED", "commit": "acaac81f96fec91ab45bd0412beaf9c3acd8defa", "function_name": "doDsaTest", "body_hash": "02b93e1e12ea391a29a8b7f5d1c3963bc594d90a"}
{"code": "@Override\n    public BuildWrapper createBuildWrapper(AbstractBuild<?,?> build) {\n        return new BuildWrapper() {\n            @Override\n            public Environment setUp(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {\n            \tif (!StringUtils.isEmpty(location) && !StringUtils.isEmpty(file.getName())) {\n            \t    listener.getLogger().println(\"Copying file to \"+location);\n                    FilePath ws = build.getWorkspace();\n                    if (ws == null) {\n                        throw new IllegalStateException(\"The workspace should be created when setUp method is called\");\n                    }\n                    if (!ALLOW_FOLDER_TRAVERSAL_OUTSIDE_WORKSPACE && (PROHIBITED_DOUBLE_DOT.matcher(location).matches() || !ws.isDescendant(location))) {\n                        listener.error(\"Rejecting file path escaping base directory with relative path: \" + location);\n                        // force the build to fail\n                        return null;\n                    }\n                    FilePath locationFilePath = ws.child(location);\n                    locationFilePath.getParent().mkdirs();\n            \t    locationFilePath.copyFrom(file);\n                    locationFilePath.copyTo(new FilePath(getLocationUnderBuild(build)));\n            \t}\n                return new Environment() {};\n            }\n        };\n    }", "code_tokens": ["@", "Override", "public", "BuildWrapper", "createBuildWrapper", "(", "AbstractBuild", "<", "?", ",", "?", ">", "build", ")", "{", "return", "new", "BuildWrapper", "(", ")", "{", "@", "Override", "public", "Environment", "setUp", "(", "AbstractBuild", "build", ",", "Launcher", "launcher", ",", "BuildListener", "listener", ")", "throws", "IOException", ",", "InterruptedException", "{", "if", "(", "!", "StringUtils", ".", "isEmpty", "(", "location", ")", "&&", "!", "StringUtils", ".", "isEmpty", "(", "file", ".", "getName", "(", ")", ")", ")", "{", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Copying file to ", "\"", "+", "location", ")", ";", "FilePath", "ws", "=", "build", ".", "getWorkspace", "(", ")", ";", "if", "(", "ws", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "The workspace should be created when setUp method is called", "\"", ")", ";", "}", "if", "(", "!", "ALLOW_FOLDER_TRAVERSAL_OUTSIDE_WORKSPACE", "&&", "(", "PROHIBITED_DOUBLE_DOT", ".", "matcher", "(", "location", ")", ".", "matches", "(", ")", "||", "!", "ws", ".", "isDescendant", "(", "location", ")", ")", ")", "{", "listener", ".", "error", "(", "\"", "Rejecting file path escaping base directory with relative path: ", "\"", "+", "location", ")", ";", "return", "null", ";", "}", "FilePath", "locationFilePath", "=", "ws", ".", "child", "(", "location", ")", ";", "locationFilePath", ".", "getParent", "(", ")", ".", "mkdirs", "(", ")", ";", "locationFilePath", ".", "copyFrom", "(", "file", ")", ";", "locationFilePath", ".", "copyTo", "(", "new", "FilePath", "(", "getLocationUnderBuild", "(", "build", ")", ")", ")", ";", "}", "return", "new", "Environment", "(", ")", "{", "}", ";", "}", "}", ";", "}"], "idx": 21308, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "18fc7c0b466553cbd4f790db3270964305bee7f9", "function_name": "createBuildWrapper", "body_hash": "13630177a03dab7f1bad9123fec1d0c1ceea97de"}
{"code": "private void sendEntityMessage(Object message) throws Exception {\n        \n        MockEndpoint endpoint = getMockEndpoint(\"mock:result\");\n        endpoint.reset();\n        endpoint.expectedMessageCount(1);\n        \n        template.sendBody(\"direct:start1\", message);\n\n        assertMockEndpointsSatisfied();\n        \n        List<Exchange> list = endpoint.getReceivedExchanges();\n        Exchange exchange = list.get(0);\n        String xml = exchange.getIn().getBody(String.class);\n        assertTrue(\"Get a wrong transformed message\", xml.indexOf(\"<transformed subject=\\\"\\\">\") > 0);\n        \n        \n        \n        try {\n            template.sendBody(\"direct:start2\", message);\n            fail(\"Expect an exception here\");\n        } catch (Exception ex) {\n            // expect an exception here\n            assertTrue(\"Get a wrong exception\", ex instanceof CamelExecutionException);\n            // the file could not be found\n            assertTrue(\"Get a wrong exception cause\", ex.getCause() instanceof TransformerException);\n        }\n        \n    }", "code_tokens": ["private", "void", "sendEntityMessage", "(", "Object", "message", ")", "throws", "Exception", "{", "MockEndpoint", "endpoint", "=", "getMockEndpoint", "(", "\"", "mock:result", "\"", ")", ";", "endpoint", ".", "reset", "(", ")", ";", "endpoint", ".", "expectedMessageCount", "(", "1", ")", ";", "template", ".", "sendBody", "(", "\"", "direct:start1", "\"", ",", "message", ")", ";", "assertMockEndpointsSatisfied", "(", ")", ";", "List", "<", "Exchange", ">", "list", "=", "endpoint", ".", "getReceivedExchanges", "(", ")", ";", "Exchange", "exchange", "=", "list", ".", "get", "(", "0", ")", ";", "String", "xml", "=", "exchange", ".", "getIn", "(", ")", ".", "getBody", "(", "String", ".", "class", ")", ";", "assertTrue", "(", "\"", "Get a wrong transformed message", "\"", ",", "xml", ".", "indexOf", "(", "\"", "<transformed subject=", "\\\"", "\\\"", ">", "\"", ")", ">", "0", ")", ";", "try", "{", "template", ".", "sendBody", "(", "\"", "direct:start2", "\"", ",", "message", ")", ";", "fail", "(", "\"", "Expect an exception here", "\"", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "assertTrue", "(", "\"", "Get a wrong exception", "\"", ",", "ex", "instanceof", "CamelExecutionException", ")", ";", "assertTrue", "(", "\"", "Get a wrong exception cause", "\"", ",", "ex", ".", "getCause", "(", ")", "instanceof", "TransformerException", ")", ";", "}", "}"], "idx": 110303, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "1df559649a96a1ca0368373387e542f46e4820da", "function_name": "sendEntityMessage", "body_hash": "5dbae61f66ea43137382ecfd22a6d302765d6a6c"}
{"code": "@Override\n\t\tpublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n\n\t\t\tif (!isWritableProperty(propertyName)) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName);\n\t\t\t}\n\n\t\t\tPropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();\n\t\t\tTypeInformation<?> owningType = leafProperty.getOwningType();\n\t\t\tTypeInformation<?> propertyType = leafProperty.getTypeInformation();\n\n\t\t\tpropertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n\n\t\t\tif (propertyType != null && conversionRequired(value, propertyType.getType())) {\n\n\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),\n\t\t\t\t\t\tleafProperty.getSegment());\n\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tthrow new IllegalStateException(String.format(\"Couldn't find PropertyDescriptor for %s on %s!\",\n\t\t\t\t\t\t\tleafProperty.getSegment(), owningType.getType()));\n\t\t\t\t}\n\n\t\t\t\tMethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n\n\t\t\t\tif (typeDescriptor == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\tString.format(\"Couldn't obtain type descriptor for method parameter %s!\", methodParameter));\n\t\t\t\t}\n\n\t\t\t\tvalue = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n\t\t\t}\n\n\t\t\tEvaluationContext context = SimpleEvaluationContext //\n\t\t\t\t\t.forPropertyAccessors(new PropertyTraversingMapAccessor(type, conversionService)) //\n\t\t\t\t\t.withConversionService(conversionService) //\n\t\t\t\t\t.withRootObject(map) //\n\t\t\t\t\t.build();\n\n\t\t\tExpression expression = PARSER.parseExpression(propertyName);\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(context, value);\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O);\n\t\t\t}\n\t\t}", "code_tokens": ["@", "Override", "public", "void", "setPropertyValue", "(", "String", "propertyName", ",", "@", "Nullable", "Object", "value", ")", "throws", "BeansException", "{", "if", "(", "!", "isWritableProperty", "(", "propertyName", ")", ")", "{", "throw", "new", "NotWritablePropertyException", "(", "type", ",", "propertyName", ")", ";", "}", "PropertyPath", "leafProperty", "=", "getPropertyPath", "(", "propertyName", ")", ".", "getLeafProperty", "(", ")", ";", "TypeInformation", "<", "?", ">", "owningType", "=", "leafProperty", ".", "getOwningType", "(", ")", ";", "TypeInformation", "<", "?", ">", "propertyType", "=", "leafProperty", ".", "getTypeInformation", "(", ")", ";", "propertyType", "=", "propertyName", ".", "endsWith", "(", "\"", "]", "\"", ")", "?", "propertyType", ".", "getActualType", "(", ")", ":", "propertyType", ";", "if", "(", "propertyType", "!=", "null", "&&", "conversionRequired", "(", "value", ",", "propertyType", ".", "getType", "(", ")", ")", ")", "{", "PropertyDescriptor", "descriptor", "=", "BeanUtils", ".", "getPropertyDescriptor", "(", "owningType", ".", "getType", "(", ")", ",", "leafProperty", ".", "getSegment", "(", ")", ")", ";", "if", "(", "descriptor", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "String", ".", "format", "(", "\"", "Couldn't find PropertyDescriptor for %s on %s!", "\"", ",", "leafProperty", ".", "getSegment", "(", ")", ",", "owningType", ".", "getType", "(", ")", ")", ")", ";", "}", "MethodParameter", "methodParameter", "=", "new", "MethodParameter", "(", "descriptor", ".", "getReadMethod", "(", ")", ",", "-", "1", ")", ";", "TypeDescriptor", "typeDescriptor", "=", "TypeDescriptor", ".", "nested", "(", "methodParameter", ",", "0", ")", ";", "if", "(", "typeDescriptor", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "String", ".", "format", "(", "\"", "Couldn't obtain type descriptor for method parameter %s!", "\"", ",", "methodParameter", ")", ")", ";", "}", "value", "=", "conversionService", ".", "convert", "(", "value", ",", "TypeDescriptor", ".", "forObject", "(", "value", ")", ",", "typeDescriptor", ")", ";", "}", "EvaluationContext", "context", "=", "SimpleEvaluationContext", ".", "forPropertyAccessors", "(", "new", "PropertyTraversingMapAccessor", "(", "type", ",", "conversionService", ")", ")", ".", "withConversionService", "(", "conversionService", ")", ".", "withRootObject", "(", "map", ")", ".", "build", "(", ")", ";", "Expression", "expression", "=", "PARSER", ".", "parseExpression", "(", "propertyName", ")", ";", "try", "{", "expression", ".", "setValue", "(", "context", ",", "value", ")", ";", "}", "catch", "(", "SpelEvaluationException", "o_O", ")", "{", "throw", "new", "NotWritablePropertyException", "(", "type", ",", "propertyName", ",", "\"", "Could not write property!", "\"", ",", "o_O", ")", ";", "}", "}"], "idx": 11743, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "ae1dd2741ce06d44a0966ecbd6f47beabde2b65", "function_name": "setPropertyValue", "body_hash": "68423fb16aa5bfd1264d44963b62052822a50d6b"}
{"code": "@Override\n    public Response processControlCommand(ControlCommand command) throws Exception {\n        return null;\n    }", "code_tokens": ["@", "Override", "public", "Response", "processControlCommand", "(", "ControlCommand", "command", ")", "throws", "Exception", "{", "return", "null", ";", "}"], "idx": 29559, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "00921f22ff9a8792d7663ef8fadd4823402a6324", "function_name": "processControlCommand", "body_hash": "afcc77770f0d20c8ed1bd07e062bc7c5c475d37d"}
{"code": "public void changeApiToken() throws IOException {\n        _changeApiToken();\n        if (user!=null)\n            user.save();\n    }", "code_tokens": ["public", "void", "changeApiToken", "(", ")", "throws", "IOException", "{", "_changeApiToken", "(", ")", ";", "if", "(", "user", "!=", "null", ")", "user", ".", "save", "(", ")", ";", "}"], "idx": 2510, "cwe": "CWE-17", "target": 1, "status": "VULNERABLE", "commit": "57e78880cc035874bda916ef4d8d7fd7642af9db", "function_name": "changeApiToken", "body_hash": "7fa64c83d5618e93195d86a7c350a68e57dd36f8"}
{"code": "protected static File getTmpFolder() {\n        try {\n            File outputFolder = Files.createTempDirectory(\"codegen-\").toFile();\n            outputFolder.deleteOnExit();\n            return outputFolder;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }", "code_tokens": ["protected", "static", "File", "getTmpFolder", "(", ")", "{", "try", "{", "File", "outputFolder", "=", "Files", ".", "createTempDirectory", "(", "\"", "codegen-", "\"", ")", ".", "toFile", "(", ")", ";", "outputFolder", ".", "deleteOnExit", "(", ")", ";", "return", "outputFolder", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "return", "null", ";", "}", "}"], "idx": 50011, "cwe": "CWE-378", "target": 0, "status": "FIXED", "commit": "987ea7a30b463cc239580d6ad166c707ae942a89", "function_name": "getTmpFolder", "body_hash": "64ebe57a47b7d3dc5d46ed5922612e0f8b74ad54"}
{"code": "public String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n\n        // check for user specified immune characters\n        if ( immune != null && containsCharacter( c.charValue(), immune ) )\n            return cStr;\n\n        // check for standard characters (e.g., alphanumeric, etc.)\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}", "code_tokens": ["public", "String", "encodeCharacter", "(", "char", "[", "]", "immune", ",", "Character", "c", ")", "{", "String", "cStr", "=", "String", ".", "valueOf", "(", "c", ".", "charValue", "(", ")", ")", ";", "byte", "[", "]", "bytes", ";", "StringBuilder", "sb", ";", "if", "(", "immune", "!=", "null", "&&", "containsCharacter", "(", "c", ".", "charValue", "(", ")", ",", "immune", ")", ")", "return", "cStr", ";", "if", "(", "UNENCODED_SET", ".", "contains", "(", "c", ")", ")", "return", "cStr", ";", "bytes", "=", "toUtf8Bytes", "(", "cStr", ")", ";", "sb", "=", "new", "StringBuilder", "(", "bytes", ".", "length", "*", "3", ")", ";", "for", "(", "byte", "b", ":", "bytes", ")", "appendTwoUpperHex", "(", "sb", ".", "append", "(", "'%'", ")", ",", "b", ")", ";", "return", "sb", ".", "toString", "(", ")", ";", "}"], "idx": 41694, "cwe": "CWE-310", "target": 0, "status": "FIXED", "commit": "b7cbc53f9cc967cf1a5a9463d8c6fef9ed6ef4f7", "function_name": "encodeCharacter", "body_hash": "ef7b20a14357863937013240980c931abb1b7efc"}
{"code": "private RootBeanDefinition registerMessageBroker(Element brokerElement,\n\t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n\t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate,\n\t\t\tRuntimeBeanReference userRegistry, ParserContext context, Object source) {\n\n\t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n\t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n\n\t\tConstructorArgumentValues cavs = new ConstructorArgumentValues();\n\t\tcavs.addIndexedArgumentValue(0, inChannel);\n\t\tcavs.addIndexedArgumentValue(1, outChannel);\n\t\tcavs.addIndexedArgumentValue(2, brokerChannel);\n\n\t\tRootBeanDefinition brokerDef;\n\t\tif (simpleBrokerElem != null) {\n\t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cavs, null);\n\t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n\t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n\t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n\t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"selector-header\")) {\n\t\t\t\tString headerName = simpleBrokerElem.getAttribute(\"selector-header\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"selectorHeaderName\", headerName);\n\t\t\t}\n\t\t}\n\t\telse if (brokerRelayElem != null) {\n\t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\n\t\t\tMutablePropertyValues values = new MutablePropertyValues();\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n\t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n\t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n\t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n\t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n\t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n\t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n\t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n\t\t\t}\n\t\t\tManagedMap<String, Object> map = new ManagedMap<String, Object>();\n\t\t\tmap.setSource(source);\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n\t\t\t\tmap.put(destination, userDestHandler);\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n\t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n\t\t\t\t\t\tbrokerTemplate, destination, context, source));\n\t\t\t}\n\t\t\tif (!map.isEmpty()) {\n\t\t\t\tvalues.add(\"systemSubscriptions\", map);\n\t\t\t}\n\t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n\t\t\tbrokerDef = new RootBeanDefinition(handlerType, cavs, values);\n\t\t}\n\t\telse {\n\t\t\t// Should not happen\n\t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n\t\t}\n\t\tregisterBeanDef(brokerDef, context, source);\n\t\treturn brokerDef;\n\t}", "code_tokens": ["private", "RootBeanDefinition", "registerMessageBroker", "(", "Element", "brokerElement", ",", "RuntimeBeanReference", "inChannel", ",", "RuntimeBeanReference", "outChannel", ",", "RuntimeBeanReference", "brokerChannel", ",", "Object", "userDestHandler", ",", "RuntimeBeanReference", "brokerTemplate", ",", "RuntimeBeanReference", "userRegistry", ",", "ParserContext", "context", ",", "Object", "source", ")", "{", "Element", "simpleBrokerElem", "=", "DomUtils", ".", "getChildElementByTagName", "(", "brokerElement", ",", "\"", "simple-broker", "\"", ")", ";", "Element", "brokerRelayElem", "=", "DomUtils", ".", "getChildElementByTagName", "(", "brokerElement", ",", "\"", "stomp-broker-relay", "\"", ")", ";", "ConstructorArgumentValues", "cavs", "=", "new", "ConstructorArgumentValues", "(", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "0", ",", "inChannel", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "1", ",", "outChannel", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "2", ",", "brokerChannel", ")", ";", "RootBeanDefinition", "brokerDef", ";", "if", "(", "simpleBrokerElem", "!=", "null", ")", "{", "String", "prefix", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "prefix", "\"", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "3", ",", "Arrays", ".", "asList", "(", "StringUtils", ".", "tokenizeToStringArray", "(", "prefix", ",", "\"", ",", "\"", ")", ")", ")", ";", "brokerDef", "=", "new", "RootBeanDefinition", "(", "SimpleBrokerMessageHandler", ".", "class", ",", "cavs", ",", "null", ")", ";", "if", "(", "brokerElement", ".", "hasAttribute", "(", "\"", "path-matcher", "\"", ")", ")", "{", "String", "pathMatcherRef", "=", "brokerElement", ".", "getAttribute", "(", "\"", "path-matcher", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "pathMatcher", "\"", ",", "new", "RuntimeBeanReference", "(", "pathMatcherRef", ")", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "scheduler", "\"", ")", ")", "{", "String", "scheduler", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "scheduler", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "taskScheduler", "\"", ",", "new", "RuntimeBeanReference", "(", "scheduler", ")", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "heartbeat", "\"", ")", ")", "{", "String", "heartbeatValue", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "heartbeat", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "heartbeatValue", "\"", ",", "heartbeatValue", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "selector-header", "\"", ")", ")", "{", "String", "headerName", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "selector-header", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "selectorHeaderName", "\"", ",", "headerName", ")", ";", "}", "}", "else", "if", "(", "brokerRelayElem", "!=", "null", ")", "{", "String", "prefix", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "prefix", "\"", ")", ";", "cavs", ".", "addIndexedArgumentValue", "(", "3", ",", "Arrays", ".", "asList", "(", "StringUtils", ".", "tokenizeToStringArray", "(", "prefix", ",", "\"", ",", "\"", ")", ")", ")", ";", "MutablePropertyValues", "values", "=", "new", "MutablePropertyValues", "(", ")", ";", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "relay-host", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "relayHost", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "relay-host", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "relay-port", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "relayPort", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "relay-port", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "client-login", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "clientLogin", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "client-login", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "client-passcode", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "clientPasscode", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "client-passcode", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "system-login", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemLogin", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "system-login", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "system-passcode", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemPasscode", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "system-passcode", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "heartbeat-send-interval", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemHeartbeatSendInterval", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "heartbeat-send-interval", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "heartbeat-receive-interval", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemHeartbeatReceiveInterval", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "heartbeat-receive-interval", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "virtual-host", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "virtualHost", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "virtual-host", "\"", ")", ")", ";", "}", "ManagedMap", "<", "String", ",", "Object", ">", "map", "=", "new", "ManagedMap", "<", "String", ",", "Object", ">", "(", ")", ";", "map", ".", "setSource", "(", "source", ")", ";", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "user-destination-broadcast", "\"", ")", ")", "{", "String", "destination", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "user-destination-broadcast", "\"", ")", ";", "map", ".", "put", "(", "destination", ",", "userDestHandler", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "user-registry-broadcast", "\"", ")", ")", "{", "String", "destination", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "user-registry-broadcast", "\"", ")", ";", "map", ".", "put", "(", "destination", ",", "registerUserRegistryMessageHandler", "(", "userRegistry", ",", "brokerTemplate", ",", "destination", ",", "context", ",", "source", ")", ")", ";", "}", "if", "(", "!", "map", ".", "isEmpty", "(", ")", ")", "{", "values", ".", "add", "(", "\"", "systemSubscriptions", "\"", ",", "map", ")", ";", "}", "Class", "<", "?", ">", "handlerType", "=", "StompBrokerRelayMessageHandler", ".", "class", ";", "brokerDef", "=", "new", "RootBeanDefinition", "(", "handlerType", ",", "cavs", ",", "values", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Neither <simple-broker> nor <stomp-broker-relay> elements found.", "\"", ")", ";", "}", "registerBeanDef", "(", "brokerDef", ",", "context", ",", "source", ")", ";", "return", "brokerDef", ";", "}"], "idx": 103437, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "246a6db1cad205ca9b6fca00c544ab7443ba202", "function_name": "registerMessageBroker", "body_hash": "3a73b03f23761b643117be7f3eb297a917ddc858"}
{"code": "public static void main(String[] args) throws Exception {\r\n                System.out.println(\"_________________________________________________\");\r\n                System.out.println(\"Configure options using uddi.xml and tck.properties\");\r\n                System.out.println(\"java -Duddi.client.xml=uddi.xml -jar juddi-tck-runner-{VERSION}-SNAPSHOT-jar-with-dependencies.jar\");\r\n                System.out.println(\"_________________________________________________\");\r\n                System.out.println();\r\n                System.out.println(\"Options\");\r\n                System.out.println(\"-Dtests=TestClass1,TestClass2    Comma delimited set of focused tests to run\");\r\n                System.out.println(\"_________________________________________________\");\r\n                System.out.println(\"Running! this can take anywhere from 2-5 minutes!\");\r\n                System.out.println(\"\");\r\n                if (!new File(\"tck.properties\").exists()) {\r\n                        System.out.println(\"tck.properties was not found! I give up!\");\r\n                        System.exit(1);\r\n                }\r\n                String s = System.getProperty(\"uddi.client.xml\");\r\n                if (s == null || !new File(s).exists()) {\r\n                        System.out.println(\"The value for option -Duddi.client.xml=\" + s + \" is either null or the file doesn't exist! I give up!\");\r\n                        System.exit(1);\r\n                }\r\n                String focusedTests = System.getProperty(\"tests\");\r\n                Result result = null;\r\n                JUnitCore junit = new JUnitCore();\r\n                Class[] cs = null;\r\n                if (focusedTests != null) {\r\n                        String[] items = focusedTests.split(\",\");\r\n                        cs = new Class[items.length];\r\n                        for (int i = 0; i < items.length; i++) {\r\n                                cs[i] = Class.forName(items[i]);\r\n                        }\r\n                } else {\r\n                        cs = new Class[]{\r\n                                //the bpel tests really only test wsdl to uddi\r\n                                org.apache.juddi.v2.tck.UDDI_020_TmodelIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_030_BusinessEntityIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_040_BusinessServiceIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_050_BindingTemplateIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_060_PublisherAssertionIntegrationTest.class,\r\n                                org.apache.juddi.v2.tck.UDDI_070_FindEntityIntegrationTest.class,\r\n                                org.apache.juddi.v3.bpel.BPEL_010_IntegrationTest.class,\r\n                                org.apache.juddi.v3.bpel.BPEL_020_IntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.JUDDI_010_PublisherIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.JUDDI_100_ClientSubscriptionInfoIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.JUDDI_300_MultiNodeIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_010_PublisherIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_020_TmodelIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_030_BusinessEntityIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_030_BusinessEntityLoadIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_040_BusinessServiceIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_040_PerformanceIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_040_BusinessServiceLoadIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_050_BindingTemplateIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_060_PublisherAssertionIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_070_FindEntityIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_080_SubscriptionIntegrationTest.class,\r\n                                //note that this is different, there is an IntegrationTest version\r\n                                //however it's for hosting our own mail server and reconfiguring juddi\r\n                                //org.apache.juddi.v3.tck.UDDI_090_SubscriptionListenerExternalTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_090_HttpExternalTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_090_Smtp_ExternalTest.class,\r\n                                \r\n                                org.apache.juddi.v3.tck.UDDI_110_FindBusinessIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_120_CombineCategoryBagsFindServiceIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_130_CombineCategoryBagsFindBusinessIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_140_NegativePublicationIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_141_JIRAIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_142_DigitalSignatureIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_150_CustodyTransferIntegrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_160_RESTIntergrationTest.class,\r\n                                org.apache.juddi.v3.tck.UDDI_170_ValueSetValidationIntegrationTest.class\r\n                        };\r\n                }\r\n\r\n                result = junit.run(cs);\r\n\r\n                String filename = \"uddi-tck-results-\" + new SimpleDateFormat(\"yyyyMMddhhmm\").format(new Date()) + \".txt\";\r\n                FileWriter fw = new FileWriter(filename);\r\n\r\n                BufferedWriter bw = new BufferedWriter(fw);\r\n                bw.write(\"UDDI-TCK Test Results generated \" + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\").format(new Date()));\r\n                bw.newLine();\r\n                bw.write(\"____________________________________________\");\r\n                bw.newLine();\r\n                bw.write(\"Summary\");\r\n                bw.newLine();\r\n                bw.write(\"Failed Test Cases: \" + result.getFailureCount());\r\n                bw.newLine();\r\n                bw.write(\"Skipped Test Cases: \" + result.getIgnoreCount());\r\n                bw.newLine();\r\n                bw.write(\"Ran Test Cases: \" + result.getRunCount());\r\n                bw.newLine();\r\n                bw.write(\"Time: \" + result.getRunTime());\r\n                bw.newLine();\r\n                bw.write(\"____________________________________________\");\r\n\r\n                bw.newLine();\r\n                bw.write(\"Tests Ran\");\r\n                bw.newLine();\r\n                for (int i = 0; i < cs.length; i++) {\r\n                        bw.write(cs[i].getCanonicalName());\r\n                        bw.newLine();\r\n                }\r\n                bw.write(\"____________________________________________\");\r\n                bw.newLine();\r\n                bw.write(\"Failed Test cases\");\r\n                bw.newLine();\r\n                bw.write(\"____________________________________________\");\r\n                bw.newLine();\r\n                for (int i = 0; i < result.getFailures().size(); i++) {\r\n                        try {\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getTestHeader());\r\n                                } catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getDescription().getClassName());\r\n                                }\r\n                                catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getDescription().getMethodName() == null ? \"null method!\" : result.getFailures().get(i).getDescription().getMethodName());\r\n                                } catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getMessage() == null ? \"no message\" : result.getFailures().get(i).getMessage());\r\n                                } catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                //result.getFailures().get(i).getException().printStackTrace();\r\n                                try {\r\n                                        bw.write(result.getFailures().get(i).getTrace());\r\n                                } catch (Exception ex) {\r\n                                        bw.write(ex.getMessage());\r\n                                }\r\n                                bw.newLine();\r\n                                bw.write(\"____________________________________________\");\r\n                                bw.newLine();\r\n                        } catch (Exception ex) {\r\n                                ex.printStackTrace();\r\n                        }\r\n                }\r\n                System.out.println(\"____________________________________________\");\r\n                System.out.println(\"Summary\");\r\n                System.out.println(\"Failed Test Cases: \" + result.getFailureCount());\r\n                System.out.println(\"Skipped Test Cases: \" + result.getIgnoreCount());\r\n                System.out.println(\"Ran Test Cases: \" + result.getRunCount());\r\n                System.out.println(\"Time: \" + result.getRunTime() + \"ms which is \" +\r\n                org.apache.commons.lang.time.DurationFormatUtils.formatDurationHMS(result.getRunTime()));\r\n                System.out.println(\"-------------------------------------\");\r\n                System.out.println(\"Results written to \" + filename);\r\n\r\n                bw.close();\r\n                fw.close();\r\n                junit = null;\r\n                System.out.println(\"Exit code: \" + result.getFailureCount());\r\n                System.exit(result.getFailureCount());\r\n        }", "code_tokens": ["public", "static", "void", "main", "(", "String", "[", "]", "args", ")", "throws", "Exception", "{", "System", ".", "out", ".", "println", "(", "\"", "_________________________________________________", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Configure options using uddi.xml and tck.properties", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "java -Duddi.client.xml=uddi.xml -jar juddi-tck-runner-{VERSION}-SNAPSHOT-jar-with-dependencies.jar", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "_________________________________________________", "\"", ")", ";", "System", ".", "out", ".", "println", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Options", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "-Dtests=TestClass1,TestClass2    Comma delimited set of focused tests to run", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "_________________________________________________", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Running! this can take anywhere from 2-5 minutes!", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "\"", ")", ";", "if", "(", "!", "new", "File", "(", "\"", "tck.properties", "\"", ")", ".", "exists", "(", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "tck.properties was not found! I give up!", "\"", ")", ";", "System", ".", "exit", "(", "1", ")", ";", "}", "String", "s", "=", "System", ".", "getProperty", "(", "\"", "uddi.client.xml", "\"", ")", ";", "if", "(", "s", "==", "null", "||", "!", "new", "File", "(", "s", ")", ".", "exists", "(", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "The value for option -Duddi.client.xml=", "\"", "+", "s", "+", "\"", " is either null or the file doesn't exist! I give up!", "\"", ")", ";", "System", ".", "exit", "(", "1", ")", ";", "}", "String", "focusedTests", "=", "System", ".", "getProperty", "(", "\"", "tests", "\"", ")", ";", "Result", "result", "=", "null", ";", "JUnitCore", "junit", "=", "new", "JUnitCore", "(", ")", ";", "Class", "[", "]", "cs", "=", "null", ";", "if", "(", "focusedTests", "!=", "null", ")", "{", "String", "[", "]", "items", "=", "focusedTests", ".", "split", "(", "\"", ",", "\"", ")", ";", "cs", "=", "new", "Class", "[", "items", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "items", ".", "length", ";", "i", "++", ")", "{", "cs", "[", "i", "]", "=", "Class", ".", "forName", "(", "items", "[", "i", "]", ")", ";", "}", "}", "else", "{", "cs", "=", "new", "Class", "[", "]", "{", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_020_TmodelIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_030_BusinessEntityIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_040_BusinessServiceIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_050_BindingTemplateIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_060_PublisherAssertionIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v2", ".", "tck", ".", "UDDI_070_FindEntityIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "bpel", ".", "BPEL_010_IntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "bpel", ".", "BPEL_020_IntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "JUDDI_010_PublisherIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "JUDDI_100_ClientSubscriptionInfoIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "JUDDI_300_MultiNodeIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_010_PublisherIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_020_TmodelIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_030_BusinessEntityIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_030_BusinessEntityLoadIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_040_BusinessServiceIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_040_PerformanceIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_040_BusinessServiceLoadIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_050_BindingTemplateIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_060_PublisherAssertionIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_070_FindEntityIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_080_SubscriptionIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_090_HttpExternalTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_090_Smtp_ExternalTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_110_FindBusinessIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_120_CombineCategoryBagsFindServiceIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_130_CombineCategoryBagsFindBusinessIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_140_NegativePublicationIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_141_JIRAIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_142_DigitalSignatureIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_150_CustodyTransferIntegrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_160_RESTIntergrationTest", ".", "class", ",", "org", ".", "apache", ".", "juddi", ".", "v3", ".", "tck", ".", "UDDI_170_ValueSetValidationIntegrationTest", ".", "class", "}", ";", "}", "result", "=", "junit", ".", "run", "(", "cs", ")", ";", "String", "filename", "=", "\"", "uddi-tck-results-", "\"", "+", "new", "SimpleDateFormat", "(", "\"", "yyyyMMddhhmm", "\"", ")", ".", "format", "(", "new", "Date", "(", ")", ")", "+", "\"", ".txt", "\"", ";", "FileWriter", "fw", "=", "new", "FileWriter", "(", "filename", ")", ";", "BufferedWriter", "bw", "=", "new", "BufferedWriter", "(", "fw", ")", ";", "bw", ".", "write", "(", "\"", "UDDI-TCK Test Results generated ", "\"", "+", "new", "SimpleDateFormat", "(", "\"", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "\"", ")", ".", "format", "(", "new", "Date", "(", ")", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Summary", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Failed Test Cases: ", "\"", "+", "result", ".", "getFailureCount", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Skipped Test Cases: ", "\"", "+", "result", ".", "getIgnoreCount", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Ran Test Cases: ", "\"", "+", "result", ".", "getRunCount", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Time: ", "\"", "+", "result", ".", "getRunTime", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Tests Ran", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "cs", ".", "length", ";", "i", "++", ")", "{", "bw", ".", "write", "(", "cs", "[", "i", "]", ".", "getCanonicalName", "(", ")", ")", ";", "bw", ".", "newLine", "(", ")", ";", "}", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "Failed Test cases", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "result", ".", "getFailures", "(", ")", ".", "size", "(", ")", ";", "i", "++", ")", "{", "try", "{", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getTestHeader", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getDescription", "(", ")", ".", "getClassName", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getDescription", "(", ")", ".", "getMethodName", "(", ")", "==", "null", "?", "\"", "null method!", "\"", ":", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getDescription", "(", ")", ".", "getMethodName", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getMessage", "(", ")", "==", "null", "?", "\"", "no message", "\"", ":", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getMessage", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "try", "{", "bw", ".", "write", "(", "result", ".", "getFailures", "(", ")", ".", "get", "(", "i", ")", ".", "getTrace", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "bw", ".", "write", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "bw", ".", "newLine", "(", ")", ";", "bw", ".", "write", "(", "\"", "____________________________________________", "\"", ")", ";", "bw", ".", "newLine", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "}", "}", "System", ".", "out", ".", "println", "(", "\"", "____________________________________________", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Summary", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Failed Test Cases: ", "\"", "+", "result", ".", "getFailureCount", "(", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Skipped Test Cases: ", "\"", "+", "result", ".", "getIgnoreCount", "(", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Ran Test Cases: ", "\"", "+", "result", ".", "getRunCount", "(", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Time: ", "\"", "+", "result", ".", "getRunTime", "(", ")", "+", "\"", "ms which is ", "\"", "+", "org", ".", "apache", ".", "commons", ".", "lang", ".", "time", ".", "DurationFormatUtils", ".", "formatDurationHMS", "(", "result", ".", "getRunTime", "(", ")", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "-------------------------------------", "\"", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "Results written to ", "\"", "+", "filename", ")", ";", "bw", ".", "close", "(", ")", ";", "fw", ".", "close", "(", ")", ";", "junit", "=", "null", ";", "System", ".", "out", ".", "println", "(", "\"", "Exit code: ", "\"", "+", "result", ".", "getFailureCount", "(", ")", ")", ";", "System", ".", "exit", "(", "result", ".", "getFailureCount", "(", ")", ")", ";", "}"], "idx": 62933, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "e6ae0f4ce39e73ba29ab1c2926a41ac71e68574a", "function_name": "main", "body_hash": "b368446bac6a831100786aac7bfa92ac7fd9e638"}
{"code": "@Override\n    public AuthenticationResult handleResponse(final byte[] response)\n    {\n        if (_state == State.COMPLETE)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalStateException(\"Multiple Authentications not permitted.\"));\n        }\n        else if (_state == State.INITIAL && (response == null || response.length == 0))\n        {\n            _state = State.CHALLENGE_SENT;\n            return new AuthenticationResult(new byte[0], AuthenticationResult.AuthenticationStatus.CONTINUE);\n        }\n\n        _state = State.COMPLETE;\n        if (response == null || response.length == 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n\n        int authzidNullPosition = findNullPosition(response, 0);\n        if (authzidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n        int authcidNullPosition = findNullPosition(response, authzidNullPosition + 1);\n        if (authcidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authcid null terminator not found\"));\n        }\n\n        String password;\n        try\n        {\n            _username = new String(response, authzidNullPosition + 1, authcidNullPosition - authzidNullPosition - 1, UTF8);\n            // TODO: should not get pwd as a String but as a char array...\n            int passwordLen = response.length - authcidNullPosition - 1;\n            password = new String(response, authcidNullPosition + 1, passwordLen, UTF8);\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            throw new RuntimeException(\"JVM does not support UTF8\", e);\n        }\n        return _usernamePasswordAuthenticationProvider.authenticate(_username, password);\n    }", "code_tokens": ["@", "Override", "public", "AuthenticationResult", "handleResponse", "(", "final", "byte", "[", "]", "response", ")", "{", "if", "(", "_state", "==", "State", ".", "COMPLETE", ")", "{", "return", "new", "AuthenticationResult", "(", "AuthenticationResult", ".", "AuthenticationStatus", ".", "ERROR", ",", "new", "IllegalStateException", "(", "\"", "Multiple Authentications not permitted.", "\"", ")", ")", ";", "}", "else", "if", "(", "_state", "==", "State", ".", "INITIAL", "&&", "(", "response", "==", "null", "||", "response", ".", "length", "==", "0", ")", ")", "{", "_state", "=", "State", ".", "CHALLENGE_SENT", ";", "return", "new", "AuthenticationResult", "(", "new", "byte", "[", "0", "]", ",", "AuthenticationResult", ".", "AuthenticationStatus", ".", "CONTINUE", ")", ";", "}", "_state", "=", "State", ".", "COMPLETE", ";", "if", "(", "response", "==", "null", "||", "response", ".", "length", "==", "0", ")", "{", "return", "new", "AuthenticationResult", "(", "AuthenticationResult", ".", "AuthenticationStatus", ".", "ERROR", ",", "new", "IllegalArgumentException", "(", "\"", "Invalid PLAIN encoding, authzid null terminator not found", "\"", ")", ")", ";", "}", "int", "authzidNullPosition", "=", "findNullPosition", "(", "response", ",", "0", ")", ";", "if", "(", "authzidNullPosition", "<", "0", ")", "{", "return", "new", "AuthenticationResult", "(", "AuthenticationResult", ".", "AuthenticationStatus", ".", "ERROR", ",", "new", "IllegalArgumentException", "(", "\"", "Invalid PLAIN encoding, authzid null terminator not found", "\"", ")", ")", ";", "}", "int", "authcidNullPosition", "=", "findNullPosition", "(", "response", ",", "authzidNullPosition", "+", "1", ")", ";", "if", "(", "authcidNullPosition", "<", "0", ")", "{", "return", "new", "AuthenticationResult", "(", "AuthenticationResult", ".", "AuthenticationStatus", ".", "ERROR", ",", "new", "IllegalArgumentException", "(", "\"", "Invalid PLAIN encoding, authcid null terminator not found", "\"", ")", ")", ";", "}", "String", "password", ";", "try", "{", "_username", "=", "new", "String", "(", "response", ",", "authzidNullPosition", "+", "1", ",", "authcidNullPosition", "-", "authzidNullPosition", "-", "1", ",", "UTF8", ")", ";", "int", "passwordLen", "=", "response", ".", "length", "-", "authcidNullPosition", "-", "1", ";", "password", "=", "new", "String", "(", "response", ",", "authcidNullPosition", "+", "1", ",", "passwordLen", ",", "UTF8", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "JVM does not support UTF8", "\"", ",", "e", ")", ";", "}", "return", "_usernamePasswordAuthenticationProvider", ".", "authenticate", "(", "_username", ",", "password", ")", ";", "}"], "idx": 5572, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "4b9fb37abbe882193b16595ed7b8e9d8383f59e1", "function_name": "handleResponse", "body_hash": "e020a44f42aeb5ad5d3ce9ac82bacfa10ecc7f7c"}
{"code": "public AsciiString generateSessionId() {\n    ThreadLocalRandom random = ThreadLocalRandom.current();\n    UUID uuid = new UUID(random.nextLong(), random.nextLong());\n    return AsciiString.of(uuid.toString());\n  }", "code_tokens": ["public", "AsciiString", "generateSessionId", "(", ")", "{", "ThreadLocalRandom", "random", "=", "ThreadLocalRandom", ".", "current", "(", ")", ";", "UUID", "uuid", "=", "new", "UUID", "(", "random", ".", "nextLong", "(", ")", ",", "random", ".", "nextLong", "(", ")", ")", ";", "return", "AsciiString", ".", "of", "(", "uuid", ".", "toString", "(", ")", ")", ";", "}"], "idx": 42657, "cwe": "CWE-338", "target": 1, "status": "VULNERABLE", "commit": "f2b63eb82dd71194319fd3945f5edf29b8f3a42d", "function_name": "generateSessionId", "body_hash": "9210323f839910eb8cfe923c1d5335fe10de8941"}
{"code": "public void save(String comment, boolean minorEdit) throws XWikiException\n    {\n        if (hasAccessLevel(\"edit\")) {\n            // If the current author does not have PR don't let it set current user as author of the saved document\n            // since it can lead to right escalation\n            if (hasProgrammingRights() || !getConfiguration().getProperty(\"security.script.save.checkAuthor\", true)) {\n                saveDocument(comment, minorEdit);\n            } else {\n                saveAsAuthor(comment, minorEdit);\n            }\n        } else {\n            java.lang.Object[] args = {getDefaultEntityReferenceSerializer().serialize(getDocumentReference())};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied in edit mode on document {0}\", null, args);\n        }\n    }", "code_tokens": ["public", "void", "save", "(", "String", "comment", ",", "boolean", "minorEdit", ")", "throws", "XWikiException", "{", "if", "(", "hasAccessLevel", "(", "\"", "edit", "\"", ")", ")", "{", "if", "(", "hasProgrammingRights", "(", ")", "||", "!", "getConfiguration", "(", ")", ".", "getProperty", "(", "\"", "security.script.save.checkAuthor", "\"", ",", "true", ")", ")", "{", "saveDocument", "(", "comment", ",", "minorEdit", ")", ";", "}", "else", "{", "saveAsAuthor", "(", "comment", ",", "minorEdit", ")", ";", "}", "}", "else", "{", "java", ".", "lang", ".", "Object", "[", "]", "args", "=", "{", "getDefaultEntityReferenceSerializer", "(", ")", ".", "serialize", "(", "getDocumentReference", "(", ")", ")", "}", ";", "throw", "new", "XWikiException", "(", "XWikiException", ".", "MODULE_XWIKI_ACCESS", ",", "XWikiException", ".", "ERROR_XWIKI_ACCESS_DENIED", ",", "\"", "Access denied in edit mode on document {0}", "\"", ",", "null", ",", "args", ")", ";", "}", "}"], "idx": 90340, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "7ab0fe7b96809c7a3881454147598d46a1c9bbbe", "function_name": "save", "body_hash": "ecf4b39b861a739309cf1d0445c1c7faa08147bf"}
{"code": "private static String normalizePath(final String path) {\n        String s = path;\n        if (s == null) {\n            return \"/\";\n        }\n        int n = 0;\n        for (; n < s.length(); n++) {\n            if (s.charAt(n) != '/') {\n                break;\n            }\n        }\n        if (n > 1) {\n            s = s.substring(n - 1);\n        }\n        if (!s.startsWith(\"/\")) {\n            s = \"/\" + s;\n        }\n        return s;\n    }", "code_tokens": ["private", "static", "String", "normalizePath", "(", "final", "String", "path", ")", "{", "String", "s", "=", "path", ";", "if", "(", "s", "==", "null", ")", "{", "return", "\"", "/", "\"", ";", "}", "int", "n", "=", "0", ";", "for", "(", ";", "n", "<", "s", ".", "length", "(", ")", ";", "n", "++", ")", "{", "if", "(", "s", ".", "charAt", "(", "n", ")", "!=", "'/'", ")", "{", "break", ";", "}", "}", "if", "(", "n", ">", "1", ")", "{", "s", "=", "s", ".", "substring", "(", "n", "-", "1", ")", ";", "}", "if", "(", "!", "s", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "{", "s", "=", "\"", "/", "\"", "+", "s", ";", "}", "return", "s", ";", "}"], "idx": 67474, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "0554271750599756d4946c0d7ba43d04b1a7b22", "function_name": "normalizePath", "body_hash": "31a1cb40d734a38021869d965129606abaf5f2e3"}
{"code": "private static Document loadConfigFile(SolrResourceLoader resourceLoader, String parseContextConfigLoc) throws Exception {\n    return SafeXMLParsing.parseConfigXML(log, resourceLoader, parseContextConfigLoc);\n  }", "code_tokens": ["private", "static", "Document", "loadConfigFile", "(", "SolrResourceLoader", "resourceLoader", ",", "String", "parseContextConfigLoc", ")", "throws", "Exception", "{", "return", "SafeXMLParsing", ".", "parseConfigXML", "(", "log", ",", "resourceLoader", ",", "parseContextConfigLoc", ")", ";", "}"], "idx": 68911, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "d1baf6ba593561f39e2da0a71a8440797005b55", "function_name": "loadConfigFile", "body_hash": "6b3d30a965440c735bb285985f57b7b3ad8c666d"}
{"code": "@Before\n    public void setUp() throws Exception {\n        SecurityContextHolder.clearContext();\n        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();\n\n        Map<String, List<DescribedApproval>> approvalsByClientId = new HashMap<String, List<DescribedApproval>>();\n\n        DescribedApproval readApproval = new DescribedApproval();\n        readApproval.setUserId(\"userId\");\n        readApproval.setClientId(\"app\");\n        readApproval.setScope(\"thing.read\");\n        readApproval.setStatus(APPROVED);\n        readApproval.setDescription(\"Read your thing resources\");\n\n        DescribedApproval writeApproval = new DescribedApproval();\n        writeApproval.setUserId(\"userId\");\n        writeApproval.setClientId(\"app\");\n        writeApproval.setScope(\"thing.write\");\n        writeApproval.setStatus(APPROVED);\n        writeApproval.setDescription(\"Write to your thing resources\");\n\n        approvalsByClientId.put(\"app\", Arrays.asList(readApproval, writeApproval));\n\n        Mockito.when(approvalsService.getCurrentApprovalsByClientId()).thenReturn(approvalsByClientId);\n\n        BaseClientDetails appClient = new BaseClientDetails(\"app\",\"thing\",\"thing.read,thing.write\",\"authorization_code\", \"\");\n        appClient.addAdditionalInformation(ClientConstants.CLIENT_NAME, THE_ULTIMATE_APP);\n        Mockito.when(clientDetailsService.loadClientByClientId(\"app\")).thenReturn(appClient);\n    }", "code_tokens": ["@", "Before", "public", "void", "setUp", "(", ")", "throws", "Exception", "{", "SecurityContextHolder", ".", "clearContext", "(", ")", ";", "mockMvc", "=", "MockMvcBuilders", ".", "webAppContextSetup", "(", "webApplicationContext", ")", ".", "build", "(", ")", ";", "Map", "<", "String", ",", "List", "<", "DescribedApproval", ">", ">", "approvalsByClientId", "=", "new", "HashMap", "<", "String", ",", "List", "<", "DescribedApproval", ">", ">", "(", ")", ";", "DescribedApproval", "readApproval", "=", "new", "DescribedApproval", "(", ")", ";", "readApproval", ".", "setUserId", "(", "\"", "userId", "\"", ")", ";", "readApproval", ".", "setClientId", "(", "\"", "app", "\"", ")", ";", "readApproval", ".", "setScope", "(", "\"", "thing.read", "\"", ")", ";", "readApproval", ".", "setStatus", "(", "APPROVED", ")", ";", "readApproval", ".", "setDescription", "(", "\"", "Read your thing resources", "\"", ")", ";", "DescribedApproval", "writeApproval", "=", "new", "DescribedApproval", "(", ")", ";", "writeApproval", ".", "setUserId", "(", "\"", "userId", "\"", ")", ";", "writeApproval", ".", "setClientId", "(", "\"", "app", "\"", ")", ";", "writeApproval", ".", "setScope", "(", "\"", "thing.write", "\"", ")", ";", "writeApproval", ".", "setStatus", "(", "APPROVED", ")", ";", "writeApproval", ".", "setDescription", "(", "\"", "Write to your thing resources", "\"", ")", ";", "approvalsByClientId", ".", "put", "(", "\"", "app", "\"", ",", "Arrays", ".", "asList", "(", "readApproval", ",", "writeApproval", ")", ")", ";", "Mockito", ".", "when", "(", "approvalsService", ".", "getCurrentApprovalsByClientId", "(", ")", ")", ".", "thenReturn", "(", "approvalsByClientId", ")", ";", "BaseClientDetails", "appClient", "=", "new", "BaseClientDetails", "(", "\"", "app", "\"", ",", "\"", "thing", "\"", ",", "\"", "thing.read,thing.write", "\"", ",", "\"", "authorization_code", "\"", ",", "\"", "\"", ")", ";", "appClient", ".", "addAdditionalInformation", "(", "ClientConstants", ".", "CLIENT_NAME", ",", "THE_ULTIMATE_APP", ")", ";", "Mockito", ".", "when", "(", "clientDetailsService", ".", "loadClientByClientId", "(", "\"", "app", "\"", ")", ")", ".", "thenReturn", "(", "appClient", ")", ";", "}"], "idx": 35396, "cwe": "CWE-269", "target": 1, "status": "VULNERABLE", "commit": "24bc5ade80560cedb9300940d2b398163ab0dc6", "function_name": "setUp", "body_hash": "887e1fdf3e0530af0d77cf4651cb1095ea0183eb"}
{"code": "public void doCommand(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        final Jenkins jenkins = Jenkins.getInstance();\n        jenkins.checkPermission(Jenkins.READ);\n\n        // Strip trailing slash\n        final String commandName = req.getRestOfPath().substring(1);\n        CLICommand command = CLICommand.clone(commandName);\n        if (command == null) {\n            rsp.sendError(HttpServletResponse.SC_NOT_FOUND, \"No such command \" + commandName);\n            return;\n        }\n\n        req.setAttribute(\"command\", command);\n        req.getView(this, \"command.jelly\").forward(req, rsp);\n    }", "code_tokens": ["public", "void", "doCommand", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "ServletException", ",", "IOException", "{", "final", "Jenkins", "jenkins", "=", "Jenkins", ".", "getInstance", "(", ")", ";", "jenkins", ".", "checkPermission", "(", "Jenkins", ".", "READ", ")", ";", "final", "String", "commandName", "=", "req", ".", "getRestOfPath", "(", ")", ".", "substring", "(", "1", ")", ";", "CLICommand", "command", "=", "CLICommand", ".", "clone", "(", "commandName", ")", ";", "if", "(", "command", "==", "null", ")", "{", "rsp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "\"", "No such command ", "\"", "+", "commandName", ")", ";", "return", ";", "}", "req", ".", "setAttribute", "(", "\"", "command", "\"", ",", "command", ")", ";", "req", ".", "getView", "(", "this", ",", "\"", "command.jelly", "\"", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "}"], "idx": 7675, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "f5c51fbad2b62b81dc1e0402aeee058a4a478046", "function_name": "doCommand", "body_hash": "d0f2dd013eb231fd1097c3ffe17832ede6a288aa"}
{"code": "@Override\n  public void handle(RoutingContext ctx) {\n\n    if (nagHttps) {\n      String uri = ctx.request().absoluteURI();\n      if (uri != null && !uri.startsWith(\"https:\")) {\n        log.warn(\"Using session cookies without https could make you susceptible to session hijacking: \" + uri);\n      }\n    }\n\n    HttpMethod method = ctx.request().method();\n    Session session = ctx.session();\n\n    switch (method.name()) {\n      case \"GET\":\n        String token;\n\n        if (session == null) {\n          // if there's no session to store values, tokens are issued on every request\n          token = generateAndStoreToken(ctx);\n        } else {\n          // get the token from the session, this also considers the fact\n          // that the token might be invalid as it was issued for a previous session id\n          // session id's change on session upgrades (unauthenticated -> authenticated; role change; etc...)\n          String sessionToken = getTokenFromSession(ctx);\n          // when there's no token in the session, then we behave just like when there is no session\n          // create a new token, but we also store it in the session for the next runs\n          if (sessionToken == null) {\n            token = generateAndStoreToken(ctx);\n            // storing will include the session id too. The reason is that if a session is upgraded\n            // we don't want to allow the token to be valid anymore\n            session.put(headerName, session.id() + \"/\" + token);\n          } else {\n            String[] parts = sessionToken.split(\"\\\\.\");\n            try {\n              // validate validity\n              if (!(System.currentTimeMillis() > Long.parseLong(parts[1]) + timeout)) {\n                // we're still on the same session, no need to regenerate the token\n                // also note that the token isn't expired, so it can be reused\n                token = sessionToken;\n                // in this case specifically we don't issue the token as it is unchanged\n                // the user agent still has it from the previous interaction.\n              } else {\n                // fallback as the token is expired\n                token = generateAndStoreToken(ctx);\n              }\n            } catch (NumberFormatException e) {\n              log.error(\"Invalid Token format\", e);\n              // fallback as the token is expired\n              token = generateAndStoreToken(ctx);\n            }\n          }\n        }\n        // put the token in the context for users who prefer to render the token directly on the HTML\n        ctx.put(headerName, token);\n        ctx.next();\n        break;\n      case \"POST\":\n      case \"PUT\":\n      case \"DELETE\":\n      case \"PATCH\":\n        if (validateRequest(ctx)) {\n          // it matches, so refresh the token to avoid replay attacks\n          token = generateAndStoreToken(ctx);\n          // put the token in the context for users who prefer to\n          // render the token directly on the HTML\n          ctx.put(headerName, token);\n          ctx.next();\n        } else {\n          ctx.fail(403);\n        }\n        break;\n      default:\n        // ignore other methods\n        ctx.next();\n        break;\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "RoutingContext", "ctx", ")", "{", "if", "(", "nagHttps", ")", "{", "String", "uri", "=", "ctx", ".", "request", "(", ")", ".", "absoluteURI", "(", ")", ";", "if", "(", "uri", "!=", "null", "&&", "!", "uri", ".", "startsWith", "(", "\"", "https:", "\"", ")", ")", "{", "log", ".", "warn", "(", "\"", "Using session cookies without https could make you susceptible to session hijacking: ", "\"", "+", "uri", ")", ";", "}", "}", "HttpMethod", "method", "=", "ctx", ".", "request", "(", ")", ".", "method", "(", ")", ";", "Session", "session", "=", "ctx", ".", "session", "(", ")", ";", "switch", "(", "method", ".", "name", "(", ")", ")", "{", "case", "\"", "GET", "\"", ":", "String", "token", ";", "if", "(", "session", "==", "null", ")", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "}", "else", "{", "String", "sessionToken", "=", "getTokenFromSession", "(", "ctx", ")", ";", "if", "(", "sessionToken", "==", "null", ")", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "session", ".", "put", "(", "headerName", ",", "session", ".", "id", "(", ")", "+", "\"", "/", "\"", "+", "token", ")", ";", "}", "else", "{", "String", "[", "]", "parts", "=", "sessionToken", ".", "split", "(", "\"", "\\\\", ".", "\"", ")", ";", "try", "{", "if", "(", "!", "(", "System", ".", "currentTimeMillis", "(", ")", ">", "Long", ".", "parseLong", "(", "parts", "[", "1", "]", ")", "+", "timeout", ")", ")", "{", "token", "=", "sessionToken", ";", "}", "else", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "}", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "log", ".", "error", "(", "\"", "Invalid Token format", "\"", ",", "e", ")", ";", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "}", "}", "}", "ctx", ".", "put", "(", "headerName", ",", "token", ")", ";", "ctx", ".", "next", "(", ")", ";", "break", ";", "case", "\"", "POST", "\"", ":", "case", "\"", "PUT", "\"", ":", "case", "\"", "DELETE", "\"", ":", "case", "\"", "PATCH", "\"", ":", "if", "(", "validateRequest", "(", "ctx", ")", ")", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "ctx", ".", "put", "(", "headerName", ",", "token", ")", ";", "ctx", ".", "next", "(", ")", ";", "}", "else", "{", "ctx", ".", "fail", "(", "403", ")", ";", "}", "break", ";", "default", ":", "ctx", ".", "next", "(", ")", ";", "break", ";", "}", "}"], "idx": 48011, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "41a5534ff95c8bac1c6a0e715d7f0d1ad3c10bc4", "function_name": "handle", "body_hash": "fa0bdcaa25eb0b2576815373820ed923fae94cd7"}
{"code": "public static void unJar(File jarFile, File toDir, Pattern unpackRegex)\n      throws IOException {\n    try (JarFile jar = new JarFile(jarFile)) {\n      int numOfFailedLastModifiedSet = 0;\n      String targetDirPath = toDir.getCanonicalPath() + File.separator;\n      Enumeration<JarEntry> entries = jar.entries();\n      while (entries.hasMoreElements()) {\n        final JarEntry entry = entries.nextElement();\n        if (!entry.isDirectory() &&\n            unpackRegex.matcher(entry.getName()).matches()) {\n          try (InputStream in = jar.getInputStream(entry)) {\n            File file = new File(toDir, entry.getName());\n            ensureDirectory(file.getParentFile());\n            if (!file.getCanonicalPath().startsWith(targetDirPath)) {\n              throw new IOException(\"expanding \" + entry.getName()\n                  + \" would create file outside of \" + toDir);\n            }\n            try (OutputStream out = new FileOutputStream(file)) {\n              IOUtils.copyBytes(in, out, BUFFER_SIZE);\n            }\n            if (!file.setLastModified(entry.getTime())) {\n              numOfFailedLastModifiedSet++;\n            }\n          }\n        }\n      }\n      if (numOfFailedLastModifiedSet > 0) {\n        LOG.warn(\"Could not set last modfied time for {} file(s)\",\n            numOfFailedLastModifiedSet);\n      }\n    }\n  }", "code_tokens": ["public", "static", "void", "unJar", "(", "File", "jarFile", ",", "File", "toDir", ",", "Pattern", "unpackRegex", ")", "throws", "IOException", "{", "try", "(", "JarFile", "jar", "=", "new", "JarFile", "(", "jarFile", ")", ")", "{", "int", "numOfFailedLastModifiedSet", "=", "0", ";", "String", "targetDirPath", "=", "toDir", ".", "getCanonicalPath", "(", ")", "+", "File", ".", "separator", ";", "Enumeration", "<", "JarEntry", ">", "entries", "=", "jar", ".", "entries", "(", ")", ";", "while", "(", "entries", ".", "hasMoreElements", "(", ")", ")", "{", "final", "JarEntry", "entry", "=", "entries", ".", "nextElement", "(", ")", ";", "if", "(", "!", "entry", ".", "isDirectory", "(", ")", "&&", "unpackRegex", ".", "matcher", "(", "entry", ".", "getName", "(", ")", ")", ".", "matches", "(", ")", ")", "{", "try", "(", "InputStream", "in", "=", "jar", ".", "getInputStream", "(", "entry", ")", ")", "{", "File", "file", "=", "new", "File", "(", "toDir", ",", "entry", ".", "getName", "(", ")", ")", ";", "ensureDirectory", "(", "file", ".", "getParentFile", "(", ")", ")", ";", "if", "(", "!", "file", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "targetDirPath", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "expanding ", "\"", "+", "entry", ".", "getName", "(", ")", "+", "\"", " would create file outside of ", "\"", "+", "toDir", ")", ";", "}", "try", "(", "OutputStream", "out", "=", "new", "FileOutputStream", "(", "file", ")", ")", "{", "IOUtils", ".", "copyBytes", "(", "in", ",", "out", ",", "BUFFER_SIZE", ")", ";", "}", "if", "(", "!", "file", ".", "setLastModified", "(", "entry", ".", "getTime", "(", ")", ")", ")", "{", "numOfFailedLastModifiedSet", "++", ";", "}", "}", "}", "}", "if", "(", "numOfFailedLastModifiedSet", ">", "0", ")", "{", "LOG", ".", "warn", "(", "\"", "Could not set last modfied time for {} file(s)", "\"", ",", "numOfFailedLastModifiedSet", ")", ";", "}", "}", "}"], "idx": 22163, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "65e55097da2bb3f2fbdf9ba1946da25fe58bec9", "function_name": "unJar", "body_hash": "34aede2b61dc0f6bd9e887669f7373b99fab5aad"}
{"code": "public ResponseEntity<Void> postForRedirect(String path, HttpHeaders headers, MultiValueMap<String, String> params) {\n        ResponseEntity<Void> exchange = postForResponse(path, headers, params);\n\n        if (exchange.getStatusCode() != HttpStatus.FOUND) {\n            throw new IllegalStateException(\"Expected 302 but server returned status code \" + exchange.getStatusCode());\n        }\n\n        if (exchange.getHeaders().containsKey(\"Set-Cookie\")) {\n            String cookie = exchange.getHeaders().getFirst(\"Set-Cookie\");\n            headers.set(\"Cookie\", cookie);\n        }\n\n        String location = exchange.getHeaders().getLocation().toString();\n\n        return client.exchange(location, HttpMethod.GET, new HttpEntity<Void>(null, headers), Void.class);\n    }", "code_tokens": ["public", "ResponseEntity", "<", "Void", ">", "postForRedirect", "(", "String", "path", ",", "HttpHeaders", "headers", ",", "MultiValueMap", "<", "String", ",", "String", ">", "params", ")", "{", "ResponseEntity", "<", "Void", ">", "exchange", "=", "postForResponse", "(", "path", ",", "headers", ",", "params", ")", ";", "if", "(", "exchange", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "FOUND", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "Expected 302 but server returned status code ", "\"", "+", "exchange", ".", "getStatusCode", "(", ")", ")", ";", "}", "if", "(", "exchange", ".", "getHeaders", "(", ")", ".", "containsKey", "(", "\"", "Set-Cookie", "\"", ")", ")", "{", "String", "cookie", "=", "exchange", ".", "getHeaders", "(", ")", ".", "getFirst", "(", "\"", "Set-Cookie", "\"", ")", ";", "headers", ".", "set", "(", "\"", "Cookie", "\"", ",", "cookie", ")", ";", "}", "String", "location", "=", "exchange", ".", "getHeaders", "(", ")", ".", "getLocation", "(", ")", ".", "toString", "(", ")", ";", "return", "client", ".", "exchange", "(", "location", ",", "HttpMethod", ".", "GET", ",", "new", "HttpEntity", "<", "Void", ">", "(", "null", ",", "headers", ")", ",", "Void", ".", "class", ")", ";", "}"], "idx": 44175, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "a54f3fb8225ef7d5021ca7d4fb52bef1e884568e", "function_name": "postForRedirect", "body_hash": "df445101ed23be0b13e2cef24cb5529bc26b8278"}
{"code": "@BeforeClass\n  public static void setupClass() {\n    functionStringMap.put(new AlterConnectionFunction(), \"*\");\n    functionStringMap.put(new AlterMappingFunction(), \"*\");\n    functionStringMap.put(new CreateConnectionFunction(), \"*\");\n    functionStringMap.put(new CreateMappingFunction(), \"*\");\n    functionStringMap.put(new DescribeConnectionFunction(), \"*\");\n    functionStringMap.put(new DescribeMappingFunction(), \"*\");\n    functionStringMap.put(new DestroyConnectionFunction(), \"*\");\n    functionStringMap.put(new DestroyMappingFunction(), \"*\");\n    functionStringMap.put(new ListConnectionFunction(), \"*\");\n    functionStringMap.put(new ListMappingFunction(), \"*\");\n    functionStringMap.put(new InheritsDefaultPermissionsJDBCFunction(), \"*\");\n    functionStringMap.keySet().forEach(FunctionService::registerFunction);\n  }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "setupClass", "(", ")", "{", "functionStringMap", ".", "put", "(", "new", "AlterConnectionFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "AlterMappingFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateConnectionFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateMappingFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DescribeConnectionFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DescribeMappingFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyConnectionFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyMappingFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListConnectionFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListMappingFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "InheritsDefaultPermissionsJDBCFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "keySet", "(", ")", ".", "forEach", "(", "FunctionService", "::", "registerFunction", ")", ";", "}"], "idx": 87342, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "aa469239860778eb46e09dd7b390aee08f152480", "function_name": "setupClass", "body_hash": "55554d856b670e44ea700168039fa988347553b8"}
{"code": "@Override\n  protected void process(final ClusterDistributionManager dm) {\n    Throwable thr = null;\n    ReplyException rex = null;\n    if (this.functionObject == null) {\n      rex = new ReplyException(\n          new FunctionException(LocalizedStrings.ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED\n              .toLocalizedString(this.functionName)));\n\n      replyWithException(dm, rex);\n      return;\n    }\n\n    FunctionStats stats =\n        FunctionStats.getFunctionStats(this.functionObject.getId(), dm.getSystem());\n    TXStateProxy tx = null;\n    InternalCache cache = dm.getCache();\n\n    try {\n      tx = prepForTransaction(dm);\n      ResultSender resultSender = new MemberFunctionResultSender(dm, this, this.functionObject);\n      Set<Region> regions = new HashSet<Region>();\n      if (this.regionPathSet != null) {\n        for (String regionPath : this.regionPathSet) {\n          if (checkCacheClosing(dm) || checkDSClosing(dm)) {\n            if (dm.getCache() == null) {\n              thr = new CacheClosedException(\n                  LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0\n                      .toLocalizedString(dm.getId()));\n            } else {\n              dm.getCache().getCacheClosedException(\n                  LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0\n                      .toLocalizedString(dm.getId()));\n            }\n            return;\n          }\n          regions.add(cache.getRegion(regionPath));\n        }\n      }\n      FunctionContextImpl context = new MultiRegionFunctionContextImpl(cache,\n          this.functionObject.getId(), this.args, resultSender, regions, isReExecute);\n\n      long start = stats.startTime();\n      stats.startFunctionExecution(this.functionObject.hasResult());\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Executing Function: {} on remote member with context: {}\",\n            this.functionObject.getId(), context.toString());\n      }\n      this.functionObject.execute(context);\n      if (!this.replyLastMsg && this.functionObject.hasResult()) {\n        throw new FunctionException(\n            LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT\n                .toString(functionObject.getId()));\n      }\n      stats.endFunctionExecution(start, this.functionObject.hasResult());\n    } catch (FunctionException functionException) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"FunctionException occurred on remote member while executing Function: {}\",\n            this.functionObject.getId(), functionException);\n      }\n      stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n      rex = new ReplyException(functionException);\n      replyWithException(dm, rex);\n      // thr = functionException.getCause();\n    } catch (CancelException exception) {\n      // bug 37026: this is too noisy...\n      // throw new CacheClosedException(\"remote system shutting down\");\n      // thr = se; cache is closed, no point trying to send a reply\n      thr = new FunctionInvocationTargetException(exception);\n      stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n      rex = new ReplyException(thr);\n      replyWithException(dm, rex);\n    } catch (Exception exception) {\n      logger.error(\"Exception occurred on remote member while executing Function: {}\",\n          this.functionObject.getId(), exception);\n\n      stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n      rex = new ReplyException(exception);\n      replyWithException(dm, rex);\n      // thr = e.getCause();\n    } catch (VirtualMachineError err) {\n      SystemFailure.initiateFailure(err);\n      // If this ever returns, rethrow the error. We're poisoned\n      // now, so don't let this thread continue.\n      throw err;\n    } catch (Throwable t) {\n      // Whenever you catch Error or Throwable, you must also\n      // catch VirtualMachineError (see above). However, there is\n      // _still_ a possibility that you are dealing with a cascading\n      // error condition, so you also need to check to see if the JVM\n      // is still usable:\n      SystemFailure.checkFailure();\n      thr = t;\n    } finally {\n      cleanupTransaction(tx);\n      if (thr != null) {\n        rex = new ReplyException(thr);\n        replyWithException(dm, rex);\n      }\n    }\n  }", "code_tokens": ["@", "Override", "protected", "void", "process", "(", "final", "ClusterDistributionManager", "dm", ")", "{", "Throwable", "thr", "=", "null", ";", "ReplyException", "rex", "=", "null", ";", "if", "(", "this", ".", "functionObject", "==", "null", ")", "{", "rex", "=", "new", "ReplyException", "(", "new", "FunctionException", "(", "LocalizedStrings", ".", "ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED", ".", "toLocalizedString", "(", "this", ".", "functionName", ")", ")", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "return", ";", "}", "FunctionStats", "stats", "=", "FunctionStats", ".", "getFunctionStats", "(", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "dm", ".", "getSystem", "(", ")", ")", ";", "TXStateProxy", "tx", "=", "null", ";", "InternalCache", "cache", "=", "dm", ".", "getCache", "(", ")", ";", "try", "{", "tx", "=", "prepForTransaction", "(", "dm", ")", ";", "ResultSender", "resultSender", "=", "new", "MemberFunctionResultSender", "(", "dm", ",", "this", ",", "this", ".", "functionObject", ")", ";", "Set", "<", "Region", ">", "regions", "=", "new", "HashSet", "<", "Region", ">", "(", ")", ";", "if", "(", "this", ".", "regionPathSet", "!=", "null", ")", "{", "for", "(", "String", "regionPath", ":", "this", ".", "regionPathSet", ")", "{", "if", "(", "checkCacheClosing", "(", "dm", ")", "||", "checkDSClosing", "(", "dm", ")", ")", "{", "if", "(", "dm", ".", "getCache", "(", ")", "==", "null", ")", "{", "thr", "=", "new", "CacheClosedException", "(", "LocalizedStrings", ".", "PartitionMessage_REMOTE_CACHE_IS_CLOSED_0", ".", "toLocalizedString", "(", "dm", ".", "getId", "(", ")", ")", ")", ";", "}", "else", "{", "dm", ".", "getCache", "(", ")", ".", "getCacheClosedException", "(", "LocalizedStrings", ".", "PartitionMessage_REMOTE_CACHE_IS_CLOSED_0", ".", "toLocalizedString", "(", "dm", ".", "getId", "(", ")", ")", ")", ";", "}", "return", ";", "}", "regions", ".", "add", "(", "cache", ".", "getRegion", "(", "regionPath", ")", ")", ";", "}", "}", "FunctionContextImpl", "context", "=", "new", "MultiRegionFunctionContextImpl", "(", "cache", ",", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "this", ".", "args", ",", "resultSender", ",", "regions", ",", "isReExecute", ")", ";", "long", "start", "=", "stats", ".", "startTime", "(", ")", ";", "stats", ".", "startFunctionExecution", "(", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Executing Function: {} on remote member with context: {}", "\"", ",", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "context", ".", "toString", "(", ")", ")", ";", "}", "this", ".", "functionObject", ".", "execute", "(", "context", ")", ";", "if", "(", "!", "this", ".", "replyLastMsg", "&&", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", "{", "throw", "new", "FunctionException", "(", "LocalizedStrings", ".", "ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT", ".", "toString", "(", "functionObject", ".", "getId", "(", ")", ")", ")", ";", "}", "stats", ".", "endFunctionExecution", "(", "start", ",", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "}", "catch", "(", "FunctionException", "functionException", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "FunctionException occurred on remote member while executing Function: {}", "\"", ",", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "functionException", ")", ";", "}", "stats", ".", "endFunctionExecutionWithException", "(", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "rex", "=", "new", "ReplyException", "(", "functionException", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "}", "catch", "(", "CancelException", "exception", ")", "{", "thr", "=", "new", "FunctionInvocationTargetException", "(", "exception", ")", ";", "stats", ".", "endFunctionExecutionWithException", "(", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "rex", "=", "new", "ReplyException", "(", "thr", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "}", "catch", "(", "Exception", "exception", ")", "{", "logger", ".", "error", "(", "\"", "Exception occurred on remote member while executing Function: {}", "\"", ",", "this", ".", "functionObject", ".", "getId", "(", ")", ",", "exception", ")", ";", "stats", ".", "endFunctionExecutionWithException", "(", "this", ".", "functionObject", ".", "hasResult", "(", ")", ")", ";", "rex", "=", "new", "ReplyException", "(", "exception", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "}", "catch", "(", "VirtualMachineError", "err", ")", "{", "SystemFailure", ".", "initiateFailure", "(", "err", ")", ";", "throw", "err", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "SystemFailure", ".", "checkFailure", "(", ")", ";", "thr", "=", "t", ";", "}", "finally", "{", "cleanupTransaction", "(", "tx", ")", ";", "if", "(", "thr", "!=", "null", ")", "{", "rex", "=", "new", "ReplyException", "(", "thr", ")", ";", "replyWithException", "(", "dm", ",", "rex", ")", ";", "}", "}", "}"], "idx": 87814, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "954ccb545d24a9c9a35cbd84023a4d7e07032de0", "function_name": "process", "body_hash": "116da73cace137015f607bcef9a602d7e8fe5e12"}
{"code": "private IdentityZone createZone(String id, HttpStatus expect, String token, IdentityZoneConfiguration zoneConfiguration) throws Exception {\n        Map<String, String> keys = new HashMap<>();\n        keys.put(\"kid\", \"key\");\n        zoneConfiguration.getTokenPolicy().setKeys(keys);\n        zoneConfiguration.getTokenPolicy().setActiveKeyId(\"kid\");\n        zoneConfiguration.getTokenPolicy().setKeys(keys);\n\n        return createZone(id, expect, \"\" , token, zoneConfiguration);\n    }", "code_tokens": ["private", "IdentityZone", "createZone", "(", "String", "id", ",", "HttpStatus", "expect", ",", "String", "token", ",", "IdentityZoneConfiguration", "zoneConfiguration", ")", "throws", "Exception", "{", "Map", "<", "String", ",", "String", ">", "keys", "=", "new", "HashMap", "<", ">", "(", ")", ";", "keys", ".", "put", "(", "\"", "kid", "\"", ",", "\"", "key", "\"", ")", ";", "zoneConfiguration", ".", "getTokenPolicy", "(", ")", ".", "setKeys", "(", "keys", ")", ";", "zoneConfiguration", ".", "getTokenPolicy", "(", ")", ".", "setActiveKeyId", "(", "\"", "kid", "\"", ")", ";", "zoneConfiguration", ".", "getTokenPolicy", "(", ")", ".", "setKeys", "(", "keys", ")", ";", "return", "createZone", "(", "id", ",", "expect", ",", "\"", "\"", ",", "token", ",", "zoneConfiguration", ")", ";", "}"], "idx": 109185, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "14c745aa293b8d3ce9cdd6bfbc6c0ef3f269b21", "function_name": "createZone", "body_hash": "e82b2f4ce2f06e213e473212489931d155f7d2f4"}
{"code": "private SSLException checkSSLAlerts() {\n        debug(\"JSSEngine: Checking inbound and outbound SSL Alerts. Have \" + ssl_fd.inboundAlerts.size() + \" inbound and \" + ssl_fd.outboundAlerts.size() + \" outbound alerts.\");\n\n        // Prefer inbound alerts to outbound alerts.\n        while (ssl_fd.inboundOffset < ssl_fd.inboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.inboundAlerts.get(ssl_fd.inboundOffset);\n            ssl_fd.inboundOffset += 1;\n\t    event.setEngine(this);\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Got inbound CLOSE_NOTIFY alert\");\n                closeInbound();\n            }\n\n            debug(\"JSSEngine: Got inbound alert: \" + event);\n\n            // Fire inbound alert prior to raising any exception.\n            fireAlertReceived(event);\n\n            // Not every SSL Alert is fatal; toException() only returns a\n            // SSLException on fatal instances. We shouldn't return NULL\n            // early without checking all alerts.\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        while (ssl_fd.outboundOffset < ssl_fd.outboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.outboundAlerts.get(ssl_fd.outboundOffset);\n            ssl_fd.outboundOffset += 1;\n            event.setEngine(this);\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Sent outbound CLOSE_NOTIFY alert.\");\n                closeOutbound();\n            }\n\n            debug(\"JSSEngine: Got outbound alert: \" + event);\n\n            // Fire outbound alert prior to raising any exception. Note that\n            // this still triggers after this alert is written to the output\n            // wire buffer.\n            fireAlertSent(event);\n\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        return null;\n    }", "code_tokens": ["private", "SSLException", "checkSSLAlerts", "(", ")", "{", "debug", "(", "\"", "JSSEngine: Checking inbound and outbound SSL Alerts. Have ", "\"", "+", "ssl_fd", ".", "inboundAlerts", ".", "size", "(", ")", "+", "\"", " inbound and ", "\"", "+", "ssl_fd", ".", "outboundAlerts", ".", "size", "(", ")", "+", "\"", " outbound alerts.", "\"", ")", ";", "while", "(", "ssl_fd", ".", "inboundOffset", "<", "ssl_fd", ".", "inboundAlerts", ".", "size", "(", ")", ")", "{", "SSLAlertEvent", "event", "=", "ssl_fd", ".", "inboundAlerts", ".", "get", "(", "ssl_fd", ".", "inboundOffset", ")", ";", "ssl_fd", ".", "inboundOffset", "+=", "1", ";", "event", ".", "setEngine", "(", "this", ")", ";", "if", "(", "event", ".", "getLevelEnum", "(", ")", "==", "SSLAlertLevel", ".", "WARNING", "&&", "event", ".", "getDescriptionEnum", "(", ")", "==", "SSLAlertDescription", ".", "CLOSE_NOTIFY", ")", "{", "debug", "(", "\"", "Got inbound CLOSE_NOTIFY alert", "\"", ")", ";", "closeInbound", "(", ")", ";", "}", "debug", "(", "\"", "JSSEngine: Got inbound alert: ", "\"", "+", "event", ")", ";", "fireAlertReceived", "(", "event", ")", ";", "SSLException", "exception", "=", "event", ".", "toException", "(", ")", ";", "if", "(", "exception", "!=", "null", ")", "{", "return", "exception", ";", "}", "}", "while", "(", "ssl_fd", ".", "outboundOffset", "<", "ssl_fd", ".", "outboundAlerts", ".", "size", "(", ")", ")", "{", "SSLAlertEvent", "event", "=", "ssl_fd", ".", "outboundAlerts", ".", "get", "(", "ssl_fd", ".", "outboundOffset", ")", ";", "ssl_fd", ".", "outboundOffset", "+=", "1", ";", "event", ".", "setEngine", "(", "this", ")", ";", "if", "(", "event", ".", "getLevelEnum", "(", ")", "==", "SSLAlertLevel", ".", "WARNING", "&&", "event", ".", "getDescriptionEnum", "(", ")", "==", "SSLAlertDescription", ".", "CLOSE_NOTIFY", ")", "{", "debug", "(", "\"", "Sent outbound CLOSE_NOTIFY alert.", "\"", ")", ";", "closeOutbound", "(", ")", ";", "}", "debug", "(", "\"", "JSSEngine: Got outbound alert: ", "\"", "+", "event", ")", ";", "fireAlertSent", "(", "event", ")", ";", "SSLException", "exception", "=", "event", ".", "toException", "(", ")", ";", "if", "(", "exception", "!=", "null", ")", "{", "return", "exception", ";", "}", "}", "return", "null", ";", "}"], "idx": 52917, "cwe": "CWE-401", "target": 1, "status": "VULNERABLE", "commit": "3aabe0e9d59b0a42e68ac8cd0468f9c5179967d2", "function_name": "checkSSLAlerts", "body_hash": "cd8f6002a6b4591c14f916ae33e8f8e7fdacb52f"}
{"code": "@Override\n    protected void onExchange(Exchange exchange) throws Exception {\n\n        if (!cacheStylesheet || cacheCleared) {\n            loadResource(resourceUri);\n        }\n        super.onExchange(exchange);\n\n    }", "code_tokens": ["@", "Override", "protected", "void", "onExchange", "(", "Exchange", "exchange", ")", "throws", "Exception", "{", "if", "(", "!", "cacheStylesheet", "||", "cacheCleared", ")", "{", "loadResource", "(", "resourceUri", ")", ";", "}", "super", ".", "onExchange", "(", "exchange", ")", ";", "}"], "idx": 29587, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "2ec54fa0c13ae65bdcccff764af081a79fcc05f", "function_name": "onExchange", "body_hash": "dd16914e9ce119a47c092b6f46ce8086046de8d2"}
{"code": "public void execute(ActionInvocation invocation) throws Exception {\r\n\t\tactionName = conditionalParse(actionName, invocation);\r\n\t\tString portletNamespace = (String)invocation.getInvocationContext().get(PortletConstants.PORTLET_NAMESPACE);\r\n\t\tif (portletMode != null) {\r\n\t\t\tMap<PortletMode, String> namespaceMap = getNamespaceMap(invocation);\r\n\t\t\tnamespace = namespaceMap.get(portletMode);\r\n\t\t}\r\n\t\tif (namespace == null) {\r\n\t\t\tnamespace = invocation.getProxy().getNamespace();\r\n\t\t} else {\r\n\t\t\tnamespace = conditionalParse(namespace, invocation);\r\n\t\t}\r\n\t\tif (method == null) {\r\n\t\t\tmethod = \"\";\r\n\t\t} else {\r\n\t\t\tmethod = conditionalParse(method, invocation);\r\n\t\t}\r\n\r\n\t\tString resultCode = invocation.getResultCode();\r\n\t\tif (resultCode != null) {\r\n\t\t\tResultConfig resultConfig = invocation.getProxy().getConfig().getResults().get(resultCode);\r\n\t\t\tMap<String, String> resultConfigParams = resultConfig.getParams();\r\n            for (Map.Entry<String, String> e : resultConfigParams.entrySet()) {\r\n                if (!prohibitedResultParam.contains(e.getKey())) {\r\n                    requestParameters.put(e.getKey(), e.getValue() == null ? \"\" : conditionalParse(e.getValue(), invocation));\r\n                }\r\n            }\r\n\t\t}\r\n\r\n\t\tStringBuilder tmpLocation = new StringBuilder(actionMapper.getUriFromActionMapping(new ActionMapping(actionName,\r\n\t\t\t\t(portletNamespace == null ? namespace : portletNamespace + namespace), method, null)));\r\n\t\turlHelper.buildParametersString(requestParameters, tmpLocation, \"&\");\r\n\r\n\t\tsetLocation(tmpLocation.toString());\r\n\r\n\t\tsuper.execute(invocation);\r\n\t}", "code_tokens": ["public", "void", "execute", "(", "ActionInvocation", "invocation", ")", "throws", "Exception", "{", "actionName", "=", "conditionalParse", "(", "actionName", ",", "invocation", ")", ";", "String", "portletNamespace", "=", "(", "String", ")", "invocation", ".", "getInvocationContext", "(", ")", ".", "get", "(", "PortletConstants", ".", "PORTLET_NAMESPACE", ")", ";", "if", "(", "portletMode", "!=", "null", ")", "{", "Map", "<", "PortletMode", ",", "String", ">", "namespaceMap", "=", "getNamespaceMap", "(", "invocation", ")", ";", "namespace", "=", "namespaceMap", ".", "get", "(", "portletMode", ")", ";", "}", "if", "(", "namespace", "==", "null", ")", "{", "namespace", "=", "invocation", ".", "getProxy", "(", ")", ".", "getNamespace", "(", ")", ";", "}", "else", "{", "namespace", "=", "conditionalParse", "(", "namespace", ",", "invocation", ")", ";", "}", "if", "(", "method", "==", "null", ")", "{", "method", "=", "\"", "\"", ";", "}", "else", "{", "method", "=", "conditionalParse", "(", "method", ",", "invocation", ")", ";", "}", "String", "resultCode", "=", "invocation", ".", "getResultCode", "(", ")", ";", "if", "(", "resultCode", "!=", "null", ")", "{", "ResultConfig", "resultConfig", "=", "invocation", ".", "getProxy", "(", ")", ".", "getConfig", "(", ")", ".", "getResults", "(", ")", ".", "get", "(", "resultCode", ")", ";", "Map", "<", "String", ",", "String", ">", "resultConfigParams", "=", "resultConfig", ".", "getParams", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "e", ":", "resultConfigParams", ".", "entrySet", "(", ")", ")", "{", "if", "(", "!", "prohibitedResultParam", ".", "contains", "(", "e", ".", "getKey", "(", ")", ")", ")", "{", "requestParameters", ".", "put", "(", "e", ".", "getKey", "(", ")", ",", "e", ".", "getValue", "(", ")", "==", "null", "?", "\"", "\"", ":", "conditionalParse", "(", "e", ".", "getValue", "(", ")", ",", "invocation", ")", ")", ";", "}", "}", "}", "StringBuilder", "tmpLocation", "=", "new", "StringBuilder", "(", "actionMapper", ".", "getUriFromActionMapping", "(", "new", "ActionMapping", "(", "actionName", ",", "(", "portletNamespace", "==", "null", "?", "namespace", ":", "portletNamespace", "+", "namespace", ")", ",", "method", ",", "null", ")", ")", ")", ";", "urlHelper", ".", "buildParametersString", "(", "requestParameters", ",", "tmpLocation", ",", "\"", "&", "\"", ")", ";", "setLocation", "(", "tmpLocation", ".", "toString", "(", ")", ")", ";", "super", ".", "execute", "(", "invocation", ")", ";", "}"], "idx": 10557, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "4a3917176de2df7f33a85511d067f31e50dcc1b", "function_name": "execute", "body_hash": "520986f06875a2790afe14a6d93212ceee479d84"}
{"code": "protected XStream createXStream(ClassResolver resolver, ClassLoader classLoader) {\n        if (xstreamDriver != null) {\n            xstream = new XStream(xstreamDriver);\n        } else {\n            xstream = new XStream();\n        }\n\n        if (mode != null) {\n            xstream.setMode(getModeFromString(mode));\n        }\n\n        ClassLoader xstreamLoader = xstream.getClassLoader();\n        if (classLoader != null && xstreamLoader instanceof CompositeClassLoader) {\n            ((CompositeClassLoader) xstreamLoader).add(classLoader);\n        }\n\n        try {\n            if (this.implicitCollections != null) {\n                for (Entry<String, String[]> entry : this.implicitCollections.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.addImplicitCollection(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.aliases != null) {\n                for (Entry<String, String> entry : this.aliases.entrySet()) {\n                    xstream.alias(entry.getKey(), resolver.resolveMandatoryClass(entry.getValue()));\n                    // It can turn the auto-detection mode off\n                    xstream.processAnnotations(resolver.resolveMandatoryClass(entry.getValue()));\n                }\n            }\n\n            if (this.omitFields != null) {\n                for (Entry<String, String[]> entry : this.omitFields.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.omitField(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.converters != null) {\n                for (String name : this.converters) {\n                    Class<Converter> converterClass = resolver.resolveMandatoryClass(name, Converter.class);\n                    Converter converter;\n\n                    Constructor<Converter> con = null;\n                    try {\n                        con = converterClass.getDeclaredConstructor(new Class[]{XStream.class});\n                    } catch (Exception e) {\n                        //swallow as we null check in a moment.\n                    }\n                    if (con != null) {\n                        converter = con.newInstance(xstream);\n                    } else {\n                        converter = converterClass.newInstance();\n                        try {\n                            Method method = converterClass.getMethod(\"setXStream\", new Class[]{XStream.class});\n                            if (method != null) {\n                                ObjectHelper.invokeMethod(method, converter, xstream);\n                            }\n                        } catch (Throwable e) {\n                            // swallow, as it just means the user never add an XStream setter, which is optional\n                        }\n                    }\n\n                    xstream.registerConverter(converter);\n                }\n            }\n\n            addDefaultPermissions(xstream);\n            if (this.permissions != null) {\n                // permissions ::= pterm (',' pterm)*   # consits of one or more terms\n                // pterm       ::= aod? wterm           # each term preceded by an optional sign \n                // aod         ::= '+' | '-'            # indicates allow or deny where allow if omitted\n                // wterm       ::= a class name with optional wildcard characters\n                addPermissions(xstream, permissions);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to build XStream instance\", e);\n        }\n\n        return xstream;\n    }", "code_tokens": ["protected", "XStream", "createXStream", "(", "ClassResolver", "resolver", ",", "ClassLoader", "classLoader", ")", "{", "if", "(", "xstreamDriver", "!=", "null", ")", "{", "xstream", "=", "new", "XStream", "(", "xstreamDriver", ")", ";", "}", "else", "{", "xstream", "=", "new", "XStream", "(", ")", ";", "}", "if", "(", "mode", "!=", "null", ")", "{", "xstream", ".", "setMode", "(", "getModeFromString", "(", "mode", ")", ")", ";", "}", "ClassLoader", "xstreamLoader", "=", "xstream", ".", "getClassLoader", "(", ")", ";", "if", "(", "classLoader", "!=", "null", "&&", "xstreamLoader", "instanceof", "CompositeClassLoader", ")", "{", "(", "(", "CompositeClassLoader", ")", "xstreamLoader", ")", ".", "add", "(", "classLoader", ")", ";", "}", "try", "{", "if", "(", "this", ".", "implicitCollections", "!=", "null", ")", "{", "for", "(", "Entry", "<", "String", ",", "String", "[", "]", ">", "entry", ":", "this", ".", "implicitCollections", ".", "entrySet", "(", ")", ")", "{", "for", "(", "String", "name", ":", "entry", ".", "getValue", "(", ")", ")", "{", "xstream", ".", "addImplicitCollection", "(", "resolver", ".", "resolveMandatoryClass", "(", "entry", ".", "getKey", "(", ")", ")", ",", "name", ")", ";", "}", "}", "}", "if", "(", "this", ".", "aliases", "!=", "null", ")", "{", "for", "(", "Entry", "<", "String", ",", "String", ">", "entry", ":", "this", ".", "aliases", ".", "entrySet", "(", ")", ")", "{", "xstream", ".", "alias", "(", "entry", ".", "getKey", "(", ")", ",", "resolver", ".", "resolveMandatoryClass", "(", "entry", ".", "getValue", "(", ")", ")", ")", ";", "xstream", ".", "processAnnotations", "(", "resolver", ".", "resolveMandatoryClass", "(", "entry", ".", "getValue", "(", ")", ")", ")", ";", "}", "}", "if", "(", "this", ".", "omitFields", "!=", "null", ")", "{", "for", "(", "Entry", "<", "String", ",", "String", "[", "]", ">", "entry", ":", "this", ".", "omitFields", ".", "entrySet", "(", ")", ")", "{", "for", "(", "String", "name", ":", "entry", ".", "getValue", "(", ")", ")", "{", "xstream", ".", "omitField", "(", "resolver", ".", "resolveMandatoryClass", "(", "entry", ".", "getKey", "(", ")", ")", ",", "name", ")", ";", "}", "}", "}", "if", "(", "this", ".", "converters", "!=", "null", ")", "{", "for", "(", "String", "name", ":", "this", ".", "converters", ")", "{", "Class", "<", "Converter", ">", "converterClass", "=", "resolver", ".", "resolveMandatoryClass", "(", "name", ",", "Converter", ".", "class", ")", ";", "Converter", "converter", ";", "Constructor", "<", "Converter", ">", "con", "=", "null", ";", "try", "{", "con", "=", "converterClass", ".", "getDeclaredConstructor", "(", "new", "Class", "[", "]", "{", "XStream", ".", "class", "}", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "}", "if", "(", "con", "!=", "null", ")", "{", "converter", "=", "con", ".", "newInstance", "(", "xstream", ")", ";", "}", "else", "{", "converter", "=", "converterClass", ".", "newInstance", "(", ")", ";", "try", "{", "Method", "method", "=", "converterClass", ".", "getMethod", "(", "\"", "setXStream", "\"", ",", "new", "Class", "[", "]", "{", "XStream", ".", "class", "}", ")", ";", "if", "(", "method", "!=", "null", ")", "{", "ObjectHelper", ".", "invokeMethod", "(", "method", ",", "converter", ",", "xstream", ")", ";", "}", "}", "catch", "(", "Throwable", "e", ")", "{", "}", "}", "xstream", ".", "registerConverter", "(", "converter", ")", ";", "}", "}", "addDefaultPermissions", "(", "xstream", ")", ";", "if", "(", "this", ".", "permissions", "!=", "null", ")", "{", "addPermissions", "(", "xstream", ",", "permissions", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to build XStream instance", "\"", ",", "e", ")", ";", "}", "return", "xstream", ";", "}"], "idx": 3610, "cwe": "CWE-19", "target": 0, "status": "FIXED", "commit": "4491c080cb6c8659fc05441e49307b7d4349aa56", "function_name": "createXStream", "body_hash": "cf71347daf152593ea5fb99d7fed76cafae8de83"}
{"code": "public static String checkParameter(String commandParameter) {\n        return checkParameter(commandParameter, COMMAND_INJECT_REX);\n    }", "code_tokens": ["public", "static", "String", "checkParameter", "(", "String", "commandParameter", ")", "{", "return", "checkParameter", "(", "commandParameter", ",", "COMMAND_INJECT_REX", ")", ";", "}"], "idx": 76688, "cwe": "CWE-78", "target": 0, "status": "FIXED", "commit": "0888c867a52479840a6f3fcd812f9305a95b8dfd", "function_name": "checkParameter", "body_hash": "f9053bf5629a0cae4f9d1ae236d29014e862c573"}
{"code": "private boolean verifySecret(String action, int bridgeSecret) throws IllegalAccessException {\n        if (!jsMessageQueue.isBridgeEnabled()) {\n            if (bridgeSecret == -1) {\n                Log.d(LOG_TAG, action + \" call made before bridge was enabled.\");\n            } else {\n                Log.d(LOG_TAG, \"Ignoring \" + action + \" from previous page load.\");\n            }\n            return false;\n        }\n        // Bridge secret wrong and bridge not due to it being from the previous page.\n        if (expectedBridgeSecret < 0 || bridgeSecret != expectedBridgeSecret) {\n            Log.e(LOG_TAG, \"Bridge access attempt with wrong secret token, possibly from malicious code. Disabling exec() bridge!\");\n            clearBridgeSecret();\n            throw new IllegalAccessException();\n        }\n        return true;\n    }", "code_tokens": ["private", "boolean", "verifySecret", "(", "String", "action", ",", "int", "bridgeSecret", ")", "throws", "IllegalAccessException", "{", "if", "(", "!", "jsMessageQueue", ".", "isBridgeEnabled", "(", ")", ")", "{", "if", "(", "bridgeSecret", "==", "-", "1", ")", "{", "Log", ".", "d", "(", "LOG_TAG", ",", "action", "+", "\"", " call made before bridge was enabled.", "\"", ")", ";", "}", "else", "{", "Log", ".", "d", "(", "LOG_TAG", ",", "\"", "Ignoring ", "\"", "+", "action", "+", "\"", " from previous page load.", "\"", ")", ";", "}", "return", "false", ";", "}", "if", "(", "expectedBridgeSecret", "<", "0", "||", "bridgeSecret", "!=", "expectedBridgeSecret", ")", "{", "Log", ".", "e", "(", "LOG_TAG", ",", "\"", "Bridge access attempt with wrong secret token, possibly from malicious code. Disabling exec() bridge!", "\"", ")", ";", "clearBridgeSecret", "(", ")", ";", "throw", "new", "IllegalAccessException", "(", ")", ";", "}", "return", "true", ";", "}"], "idx": 110838, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "032ea8a8d386d8bcffc5de7fd3e4202478effb7d", "function_name": "verifySecret", "body_hash": "02601a803ae035fbef97bef198117fcd986ef0c6"}
{"code": "@Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            boolean allowHalfClosedRemote = false;\n            if (stream == null && !connection.streamMayHaveExisted(streamId)) {\n                stream = connection.remote().createStream(streamId, endOfStream);\n                // Allow the state to be HALF_CLOSE_REMOTE if we're creating it in that state.\n                allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;\n            }\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n                return;\n            }\n\n            boolean isInformational = !connection.isServer() &&\n                    HttpStatusClass.valueOf(headers.status()) == INFORMATIONAL;\n            if ((isInformational || !endOfStream) && stream.isHeadersReceived() || stream.isTrailersReceived()) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                                  \"Stream %d received too many headers EOS: %s state: %s\",\n                                  streamId, endOfStream, stream.state());\n            }\n\n            switch (stream.state()) {\n                case RESERVED_REMOTE:\n                    stream.open(endOfStream);\n                    break;\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    // Allowed to receive headers in these states.\n                    break;\n                case HALF_CLOSED_REMOTE:\n                    if (!allowHalfClosedRemote) {\n                        throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                                stream.id(), stream.state());\n                    }\n                    break;\n                case CLOSED:\n                    throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                            stream.id(), stream.state());\n                default:\n                    // Connection error.\n                    throw connectionError(PROTOCOL_ERROR, \"Stream %d in unexpected state: %s\", stream.id(),\n                            stream.state());\n            }\n\n            if (!stream.isHeadersReceived()) {\n                // extract the content-length header\n                List<? extends CharSequence> contentLength = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n                if (contentLength != null && !contentLength.isEmpty()) {\n                    try {\n                        long cLength = HttpUtil.normalizeAndGetContentLength(contentLength, false, true);\n                        if (cLength != -1) {\n                            headers.setLong(HttpHeaderNames.CONTENT_LENGTH, cLength);\n                            stream.setProperty(contentLengthKey, new ContentLength(cLength));\n                        }\n                    } catch (IllegalArgumentException e) {\n                        throw streamError(stream.id(), PROTOCOL_ERROR, e,\n                                \"Multiple content-length headers received\");\n                    }\n                }\n            }\n\n            stream.headersReceived(isInformational);\n            verifyContentLength(stream, 0, endOfStream);\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n            listener.onHeadersRead(ctx, streamId, headers, streamDependency,\n                    weight, exclusive, padding, endOfStream);\n            // If the headers completes this stream, close it.\n            if (endOfStream) {\n                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n            }\n        }", "code_tokens": ["@", "Override", "public", "void", "onHeadersRead", "(", "ChannelHandlerContext", "ctx", ",", "int", "streamId", ",", "Http2Headers", "headers", ",", "int", "streamDependency", ",", "short", "weight", ",", "boolean", "exclusive", ",", "int", "padding", ",", "boolean", "endOfStream", ")", "throws", "Http2Exception", "{", "Http2Stream", "stream", "=", "connection", ".", "stream", "(", "streamId", ")", ";", "boolean", "allowHalfClosedRemote", "=", "false", ";", "if", "(", "stream", "==", "null", "&&", "!", "connection", ".", "streamMayHaveExisted", "(", "streamId", ")", ")", "{", "stream", "=", "connection", ".", "remote", "(", ")", ".", "createStream", "(", "streamId", ",", "endOfStream", ")", ";", "allowHalfClosedRemote", "=", "stream", ".", "state", "(", ")", "==", "HALF_CLOSED_REMOTE", ";", "}", "if", "(", "shouldIgnoreHeadersOrDataFrame", "(", "ctx", ",", "streamId", ",", "stream", ",", "\"", "HEADERS", "\"", ")", ")", "{", "return", ";", "}", "boolean", "isInformational", "=", "!", "connection", ".", "isServer", "(", ")", "&&", "HttpStatusClass", ".", "valueOf", "(", "headers", ".", "status", "(", ")", ")", "==", "INFORMATIONAL", ";", "if", "(", "(", "isInformational", "||", "!", "endOfStream", ")", "&&", "stream", ".", "isHeadersReceived", "(", ")", "||", "stream", ".", "isTrailersReceived", "(", ")", ")", "{", "throw", "streamError", "(", "streamId", ",", "PROTOCOL_ERROR", ",", "\"", "Stream %d received too many headers EOS: %s state: %s", "\"", ",", "streamId", ",", "endOfStream", ",", "stream", ".", "state", "(", ")", ")", ";", "}", "switch", "(", "stream", ".", "state", "(", ")", ")", "{", "case", "RESERVED_REMOTE", ":", "stream", ".", "open", "(", "endOfStream", ")", ";", "break", ";", "case", "OPEN", ":", "case", "HALF_CLOSED_LOCAL", ":", "break", ";", "case", "HALF_CLOSED_REMOTE", ":", "if", "(", "!", "allowHalfClosedRemote", ")", "{", "throw", "streamError", "(", "stream", ".", "id", "(", ")", ",", "STREAM_CLOSED", ",", "\"", "Stream %d in unexpected state: %s", "\"", ",", "stream", ".", "id", "(", ")", ",", "stream", ".", "state", "(", ")", ")", ";", "}", "break", ";", "case", "CLOSED", ":", "throw", "streamError", "(", "stream", ".", "id", "(", ")", ",", "STREAM_CLOSED", ",", "\"", "Stream %d in unexpected state: %s", "\"", ",", "stream", ".", "id", "(", ")", ",", "stream", ".", "state", "(", ")", ")", ";", "default", ":", "throw", "connectionError", "(", "PROTOCOL_ERROR", ",", "\"", "Stream %d in unexpected state: %s", "\"", ",", "stream", ".", "id", "(", ")", ",", "stream", ".", "state", "(", ")", ")", ";", "}", "if", "(", "!", "stream", ".", "isHeadersReceived", "(", ")", ")", "{", "List", "<", "?", "extends", "CharSequence", ">", "contentLength", "=", "headers", ".", "getAll", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ")", ";", "if", "(", "contentLength", "!=", "null", "&&", "!", "contentLength", ".", "isEmpty", "(", ")", ")", "{", "try", "{", "long", "cLength", "=", "HttpUtil", ".", "normalizeAndGetContentLength", "(", "contentLength", ",", "false", ",", "true", ")", ";", "if", "(", "cLength", "!=", "-", "1", ")", "{", "headers", ".", "setLong", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ",", "cLength", ")", ";", "stream", ".", "setProperty", "(", "contentLengthKey", ",", "new", "ContentLength", "(", "cLength", ")", ")", ";", "}", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "throw", "streamError", "(", "stream", ".", "id", "(", ")", ",", "PROTOCOL_ERROR", ",", "e", ",", "\"", "Multiple content-length headers received", "\"", ")", ";", "}", "}", "}", "stream", ".", "headersReceived", "(", "isInformational", ")", ";", "verifyContentLength", "(", "stream", ",", "0", ",", "endOfStream", ")", ";", "encoder", ".", "flowController", "(", ")", ".", "updateDependencyTree", "(", "streamId", ",", "streamDependency", ",", "weight", ",", "exclusive", ")", ";", "listener", ".", "onHeadersRead", "(", "ctx", ",", "streamId", ",", "headers", ",", "streamDependency", ",", "weight", ",", "exclusive", ",", "padding", ",", "endOfStream", ")", ";", "if", "(", "endOfStream", ")", "{", "lifecycleManager", ".", "closeStreamRemote", "(", "stream", ",", "ctx", ".", "newSucceededFuture", "(", ")", ")", ";", "}", "}"], "idx": 54165, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "b0fa4d5aab4215f3c22ce6123dd8dd5f38dc0432", "function_name": "onHeadersRead", "body_hash": "19b6a15f85816d92b7b7aa2781387249c5b76b9c"}
{"code": "private boolean isFileWithinDirectory(\n            final File dir,\n            final File file\n    ) throws IOException {\n        final File dir_ = dir.getAbsoluteFile();\n        if (dir_.isDirectory()) {\n            final File fl = new File(dir_, file.getPath());\n            if (fl.isFile()) {\n                if (fl.getCanonicalPath().startsWith(dir_.getCanonicalPath())) {\n                    // Prevent accessing files outside the load-path.\n                    // E.g.: ../../coffee\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }", "code_tokens": ["private", "boolean", "isFileWithinDirectory", "(", "final", "File", "dir", ",", "final", "File", "file", ")", "throws", "IOException", "{", "final", "File", "dir_", "=", "dir", ".", "getAbsoluteFile", "(", ")", ";", "if", "(", "dir_", ".", "isDirectory", "(", ")", ")", "{", "final", "File", "fl", "=", "new", "File", "(", "dir_", ",", "file", ".", "getPath", "(", ")", ")", ";", "if", "(", "fl", ".", "isFile", "(", ")", ")", "{", "if", "(", "fl", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "dir_", ".", "getCanonicalPath", "(", ")", ")", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "idx": 27440, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "c942c73136333bc493050910f171a48e6f575b23", "function_name": "isFileWithinDirectory", "body_hash": "acadc0e1ac373c1f5d273c38120ede0ffc668212"}
{"code": "public Script compile() throws CompilationFailedException {\r\n        Binding binding = new Binding();\r\n        binding.setVariable(\"falsePositive\", falsePositive);\r\n        GroovyShell shell = new GroovyShell(GroovySandbox.createSecureClassLoader(WarningsDescriptor.class.getClassLoader()),\r\n                binding, GroovySandbox.createSecureCompilerConfiguration());\r\n        return shell.parse(script);\r\n    }", "code_tokens": ["public", "Script", "compile", "(", ")", "throws", "CompilationFailedException", "{", "Binding", "binding", "=", "new", "Binding", "(", ")", ";", "binding", ".", "setVariable", "(", "\"", "falsePositive", "\"", ",", "falsePositive", ")", ";", "GroovyShell", "shell", "=", "new", "GroovyShell", "(", "GroovySandbox", ".", "createSecureClassLoader", "(", "WarningsDescriptor", ".", "class", ".", "getClassLoader", "(", ")", ")", ",", "binding", ",", "GroovySandbox", ".", "createSecureCompilerConfiguration", "(", ")", ")", ";", "return", "shell", ".", "parse", "(", "script", ")", ";", "}"], "idx": 46300, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "32ee47ee6e067bbd77ec6559f81a6b206abad059", "function_name": "compile", "body_hash": "f6f28bde0cbf8378c1da60bf597853fe00a2c86f"}
{"code": "public static String applySorting(String query, Sort sort, String alias) {\n\n\t\tAssert.hasText(query);\n\n\t\tif (null == sort || !sort.iterator().hasNext()) {\n\t\t\treturn query;\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder(query);\n\n\t\tif (!ORDER_BY.matcher(query).matches()) {\n\t\t\tbuilder.append(\" order by \");\n\t\t} else {\n\t\t\tbuilder.append(\", \");\n\t\t}\n\n\t\tSet<String> aliases = getOuterJoinAliases(query);\n\t\tSet<String> functionAliases = getFunctionAliases(query);\n\n\t\tfor (Order order : sort) {\n\t\t\tbuilder.append(getOrderClause(aliases, functionAliases, alias, order)).append(\", \");\n\t\t}\n\n\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\treturn builder.toString();\n\t}", "code_tokens": ["public", "static", "String", "applySorting", "(", "String", "query", ",", "Sort", "sort", ",", "String", "alias", ")", "{", "Assert", ".", "hasText", "(", "query", ")", ";", "if", "(", "null", "==", "sort", "||", "!", "sort", ".", "iterator", "(", ")", ".", "hasNext", "(", ")", ")", "{", "return", "query", ";", "}", "StringBuilder", "builder", "=", "new", "StringBuilder", "(", "query", ")", ";", "if", "(", "!", "ORDER_BY", ".", "matcher", "(", "query", ")", ".", "matches", "(", ")", ")", "{", "builder", ".", "append", "(", "\"", " order by ", "\"", ")", ";", "}", "else", "{", "builder", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "Set", "<", "String", ">", "aliases", "=", "getOuterJoinAliases", "(", "query", ")", ";", "Set", "<", "String", ">", "functionAliases", "=", "getFunctionAliases", "(", "query", ")", ";", "for", "(", "Order", "order", ":", "sort", ")", "{", "builder", ".", "append", "(", "getOrderClause", "(", "aliases", ",", "functionAliases", ",", "alias", ",", "order", ")", ")", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "builder", ".", "delete", "(", "builder", ".", "length", "(", ")", "-", "2", ",", "builder", ".", "length", "(", ")", ")", ";", "return", "builder", ".", "toString", "(", ")", ";", "}"], "idx": 92662, "cwe": "CWE-89", "target": 0, "status": "FIXED", "commit": "b8e7fecccc7dc8edcabb4704656a7abe6352c08f", "function_name": "applySorting", "body_hash": "90673ece211900087e19fd80a44002f97a37fd00"}
{"code": "@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}", "code_tokens": ["@", "Override", "public", "ParseResults", "call", "(", ")", "{", "try", "{", "SAXParserFactory", "spf", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "SAXParser", "saxParser", "=", "spf", ".", "newSAXParser", "(", ")", ";", "XMLReader", "reader", "=", "saxParser", ".", "getXMLReader", "(", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/nonvalidating/load-external-dtd", "\"", ",", "false", ")", ";", "spf", ".", "setXIncludeAware", "(", "false", ")", ";", "reader", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "reader", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/nonvalidating/load-external-dtd", "\"", ",", "false", ")", ";", "reader", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "reader", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "saxParser", ".", "parse", "(", "xmlInputStream", ",", "handler", ")", ";", "}", "catch", "(", "SAXException", "|", "IOException", "|", "ParserConfigurationException", "e", ")", "{", "throw", "new", "ReportPortalException", "(", "ErrorType", ".", "PARSING_XML_ERROR", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "return", "new", "ParseResults", "(", "handler", ".", "getStartSuiteTime", "(", ")", ",", "handler", ".", "getCommonDuration", "(", ")", ")", ";", "}"], "idx": 69789, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "a73e0dfb4", "function_name": "call", "body_hash": "4feaae26efcd25d7dcdbe03c7193a5403b8db2d5"}
{"code": "protected String sanitiseWindowId(String windowId)\n    {\n        return StringUtils.removeSpecialChars(windowId);\n    }", "code_tokens": ["protected", "String", "sanitiseWindowId", "(", "String", "windowId", ")", "{", "return", "StringUtils", ".", "removeSpecialChars", "(", "windowId", ")", ";", "}"], "idx": 73329, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "beae6e12f64e1a0066c3add17a4bfcca2ee0fb2c", "function_name": "sanitiseWindowId", "body_hash": "8344ad680ea415111bd6dfa236b4a7d817862706"}
{"code": "private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }", "code_tokens": ["private", "LdapContext", "getLdapContextUsingStartTls", "(", "LdapContextFactory", "ldapContextFactory", ",", "Object", "principal", ",", "Object", "credentials", ")", "throws", "NamingException", "{", "JndiLdapContextFactory", "jndiLdapContextFactory", "=", "(", "JndiLdapContextFactory", ")", "ldapContextFactory", ";", "Hashtable", "<", "String", ",", "Object", ">", "env", "=", "new", "Hashtable", "<", ">", "(", ")", ";", "env", ".", "put", "(", "Context", ".", "INITIAL_CONTEXT_FACTORY", ",", "jndiLdapContextFactory", ".", "getContextFactoryClassName", "(", ")", ")", ";", "env", ".", "put", "(", "Context", ".", "PROVIDER_URL", ",", "jndiLdapContextFactory", ".", "getUrl", "(", ")", ")", ";", "LdapContext", "ctx", "=", "null", ";", "try", "{", "ctx", "=", "new", "InitialLdapContext", "(", "env", ",", "null", ")", ";", "StartTlsRequest", "startTlsRequest", "=", "new", "StartTlsRequest", "(", ")", ";", "StartTlsResponse", "tls", "=", "(", "StartTlsResponse", ")", "ctx", ".", "extendedOperation", "(", "startTlsRequest", ")", ";", "tls", ".", "negotiate", "(", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "jndiLdapContextFactory", ".", "getAuthenticationMechanism", "(", ")", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "principal", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "credentials", ")", ";", "return", "ctx", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LdapUtils", ".", "closeContext", "(", "ctx", ")", ";", "securityLog", ".", "error", "(", "withRealm", "(", "\"", "Failed to negotiate TLS connection with '%s': ", "\"", ",", "server", "(", "jndiLdapContextFactory", ")", ",", "e", ")", ")", ";", "throw", "new", "CommunicationException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "LdapUtils", ".", "closeContext", "(", "ctx", ")", ";", "securityLog", ".", "error", "(", "withRealm", "(", "\"", "Unexpected failure to negotiate TLS connection with '%s': ", "\"", ",", "server", "(", "jndiLdapContextFactory", ")", ",", "t", ")", ")", ";", "throw", "t", ";", "}", "}"], "idx": 38730, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "46de5d01ae2741ffe04c36270fc62c6d490f65c9", "function_name": "getLdapContextUsingStartTls", "body_hash": "1c7c33e89ec4b98329e39e53244d680dd92006b3"}
{"code": "public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\t\tMap<String, Object> map = new HashMap<String, Object>(model);\n\t\tString path = ServletUriComponentsBuilder.fromContextPath(request).build()\n\t\t\t\t.getPath();\n\t\tmap.put(\"path\", (Object) path==null ? \"\" : path);\n\t\tcontext.setRootObject(map);\n\t\tString maskedTemplate = template.replace(\"${\", prefix);\n\t\tPropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(prefix, \"}\");\n\t\tString result = helper.replacePlaceholders(maskedTemplate, resolver);\n\t\tresult = result.replace(prefix, \"${\");\n\t\tresponse.setContentType(getContentType());\n\t\tresponse.getWriter().append(result);\n\t}", "code_tokens": ["public", "void", "render", "(", "Map", "<", "String", ",", "?", ">", "model", ",", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "Exception", "{", "Map", "<", "String", ",", "Object", ">", "map", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", "model", ")", ";", "String", "path", "=", "ServletUriComponentsBuilder", ".", "fromContextPath", "(", "request", ")", ".", "build", "(", ")", ".", "getPath", "(", ")", ";", "map", ".", "put", "(", "\"", "path", "\"", ",", "(", "Object", ")", "path", "==", "null", "?", "\"", "\"", ":", "path", ")", ";", "context", ".", "setRootObject", "(", "map", ")", ";", "String", "maskedTemplate", "=", "template", ".", "replace", "(", "\"", "${", "\"", ",", "prefix", ")", ";", "PropertyPlaceholderHelper", "helper", "=", "new", "PropertyPlaceholderHelper", "(", "prefix", ",", "\"", "}", "\"", ")", ";", "String", "result", "=", "helper", ".", "replacePlaceholders", "(", "maskedTemplate", ",", "resolver", ")", ";", "result", "=", "result", ".", "replace", "(", "prefix", ",", "\"", "${", "\"", ")", ";", "response", ".", "setContentType", "(", "getContentType", "(", ")", ")", ";", "response", ".", "getWriter", "(", ")", ".", "append", "(", "result", ")", ";", "}"], "idx": 4920, "cwe": "CWE-19", "target": 0, "status": "FIXED", "commit": "fff77d3fea477b566bcacfbfc95f85821a2bdc2d", "function_name": "render", "body_hash": "b088d38e08d6d162fa659215830b260247e94913"}
{"code": "@Override\n        public String toString() {\n//            StringBuilder buf = new StringBuilder();\n//            for (long l : past5) {\n//                if(buf.length()>0)  buf.append(',');\n//                buf.append(l);\n//            }\n//            return buf.toString();\n            int fc = failureCount();\n            if(fc>0)\n                return Messages.ResponseTimeMonitor_TimeOut(fc);\n            return getAverage()+\"ms\";\n        }", "code_tokens": ["@", "Override", "public", "String", "toString", "(", ")", "{", "int", "fc", "=", "failureCount", "(", ")", ";", "if", "(", "fc", ">", "0", ")", "return", "Messages", ".", "ResponseTimeMonitor_TimeOut", "(", "fc", ")", ";", "return", "getAverage", "(", ")", "+", "\"", "ms", "\"", ";", "}"], "idx": 77708, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "1addc5d0feab0e77bb68e88fc74bb651e45cb462", "function_name": "toString", "body_hash": "6635034007e848c711912fdfc7dba12136ed5971"}
{"code": "public static Map<String, Lookup> getDefaultPrefixLookups() {\n        return DEFAULT_PREFIX_LOOKUPS;\n    }", "code_tokens": ["public", "static", "Map", "<", "String", ",", "Lookup", ">", "getDefaultPrefixLookups", "(", ")", "{", "return", "DEFAULT_PREFIX_LOOKUPS", ";", "}"], "idx": 105781, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "f025bc399e8125ffc7701ac74f09b833c5b5e152", "function_name": "getDefaultPrefixLookups", "body_hash": "fa56bca12220a74a4ca25aa7ea6962c20d73a3c7"}
{"code": "public void loadXmiFile(File xmiCasFile) {\r\n    try {\r\n      setXcasFileOpenDir(xmiCasFile.getParentFile());\r\n      Timer time = new Timer();\r\n      time.start();\r\n      SAXParser parser = SAXParserFactory.newInstance().newSAXParser();\r\n      XmiCasDeserializer xmiCasDeserializer = new XmiCasDeserializer(getCas().getTypeSystem());\r\n      getCas().reset();\r\n      parser.parse(xmiCasFile, xmiCasDeserializer.getXmiCasHandler(getCas(), true));\r\n      time.stop();\r\n      handleSofas();\r\n\r\n      setTitle(\"XMI CAS\");\r\n      updateIndexTree(true);\r\n      setRunOnCasEnabled();\r\n      setEnableCasFileReadingAndWriting();\r\n      setStatusbarMessage(\"Done loading XMI CAS file in \" + time.getTimeSpan() + \".\");\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n      handleException(e);\r\n    }\r\n  }", "code_tokens": ["public", "void", "loadXmiFile", "(", "File", "xmiCasFile", ")", "{", "try", "{", "setXcasFileOpenDir", "(", "xmiCasFile", ".", "getParentFile", "(", ")", ")", ";", "Timer", "time", "=", "new", "Timer", "(", ")", ";", "time", ".", "start", "(", ")", ";", "SAXParser", "parser", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ".", "newSAXParser", "(", ")", ";", "XmiCasDeserializer", "xmiCasDeserializer", "=", "new", "XmiCasDeserializer", "(", "getCas", "(", ")", ".", "getTypeSystem", "(", ")", ")", ";", "getCas", "(", ")", ".", "reset", "(", ")", ";", "parser", ".", "parse", "(", "xmiCasFile", ",", "xmiCasDeserializer", ".", "getXmiCasHandler", "(", "getCas", "(", ")", ",", "true", ")", ")", ";", "time", ".", "stop", "(", ")", ";", "handleSofas", "(", ")", ";", "setTitle", "(", "\"", "XMI CAS", "\"", ")", ";", "updateIndexTree", "(", "true", ")", ";", "setRunOnCasEnabled", "(", ")", ";", "setEnableCasFileReadingAndWriting", "(", ")", ";", "setStatusbarMessage", "(", "\"", "Done loading XMI CAS file in ", "\"", "+", "time", ".", "getTimeSpan", "(", ")", "+", "\"", ".", "\"", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "handleException", "(", "e", ")", ";", "}", "}"], "idx": 70543, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "39909bf21fd694f4fb792d1de8adc72562ead25e", "function_name": "loadXmiFile", "body_hash": "3c69dfb540cfb7d8c1b8dbf2d9a0623461d427c3"}
{"code": "private Changes handleRequest(ContextRequest contextRequest, Session session, Profile profile, ContextResponse data,\n                                  ServletRequest request, ServletResponse response, Date timestamp) {\n        Changes changes = ServletCommon.handleEvents(contextRequest.getEvents(), session, profile, request, response, timestamp,\n                privacyService, eventService);\n        data.setProcessedEvents(changes.getProcessedItems());\n\n        profile = changes.getProfile();\n\n        if (contextRequest.isRequireSegments()) {\n            data.setProfileSegments(profile.getSegments());\n        }\n\n        if (contextRequest.getRequiredProfileProperties() != null) {\n            Map<String, Object> profileProperties = new HashMap<>(profile.getProperties());\n            if (!contextRequest.getRequiredProfileProperties().contains(\"*\")) {\n                profileProperties.keySet().retainAll(contextRequest.getRequiredProfileProperties());\n            }\n            data.setProfileProperties(profileProperties);\n        }\n\n        if (session != null) {\n            data.setSessionId(session.getItemId());\n            if (contextRequest.getRequiredSessionProperties() != null) {\n                Map<String, Object> sessionProperties = new HashMap<>(session.getProperties());\n                if (!contextRequest.getRequiredSessionProperties().contains(\"*\")) {\n                    sessionProperties.keySet().retainAll(contextRequest.getRequiredSessionProperties());\n                }\n                data.setSessionProperties(sessionProperties);\n            }\n        }\n\n        processOverrides(contextRequest, profile, session);\n\n        List<PersonalizationService.PersonalizedContent> filterNodes = contextRequest.getFilters();\n        if (filterNodes != null) {\n            data.setFilteringResults(new HashMap<>());\n            for (PersonalizationService.PersonalizedContent personalizedContent : filterNodes) {\n                data.getFilteringResults().put(personalizedContent.getId(), personalizationService.filter(profile,\n                        session, personalizedContent));\n            }\n        }\n\n        List<PersonalizationService.PersonalizationRequest> personalizations = contextRequest.getPersonalizations();\n        if (personalizations != null) {\n            data.setPersonalizations(new HashMap<>());\n            for (PersonalizationService.PersonalizationRequest personalization : personalizations) {\n                data.getPersonalizations().put(personalization.getId(), personalizationService.personalizeList(profile,\n                        session, personalization));\n            }\n        }\n\n        if (!(profile instanceof Persona)) {\n            data.setTrackedConditions(rulesService.getTrackedConditions(contextRequest.getSource()));\n        } else {\n            data.setTrackedConditions(Collections.emptySet());\n        }\n\n        data.setAnonymousBrowsing(privacyService.isRequireAnonymousBrowsing(profile));\n        data.setConsents(profile.getConsents());\n\n        return changes;\n    }", "code_tokens": ["private", "Changes", "handleRequest", "(", "ContextRequest", "contextRequest", ",", "Session", "session", ",", "Profile", "profile", ",", "ContextResponse", "data", ",", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "Date", "timestamp", ")", "{", "Changes", "changes", "=", "ServletCommon", ".", "handleEvents", "(", "contextRequest", ".", "getEvents", "(", ")", ",", "session", ",", "profile", ",", "request", ",", "response", ",", "timestamp", ",", "privacyService", ",", "eventService", ")", ";", "data", ".", "setProcessedEvents", "(", "changes", ".", "getProcessedItems", "(", ")", ")", ";", "profile", "=", "changes", ".", "getProfile", "(", ")", ";", "if", "(", "contextRequest", ".", "isRequireSegments", "(", ")", ")", "{", "data", ".", "setProfileSegments", "(", "profile", ".", "getSegments", "(", ")", ")", ";", "}", "if", "(", "contextRequest", ".", "getRequiredProfileProperties", "(", ")", "!=", "null", ")", "{", "Map", "<", "String", ",", "Object", ">", "profileProperties", "=", "new", "HashMap", "<", ">", "(", "profile", ".", "getProperties", "(", ")", ")", ";", "if", "(", "!", "contextRequest", ".", "getRequiredProfileProperties", "(", ")", ".", "contains", "(", "\"", "*", "\"", ")", ")", "{", "profileProperties", ".", "keySet", "(", ")", ".", "retainAll", "(", "contextRequest", ".", "getRequiredProfileProperties", "(", ")", ")", ";", "}", "data", ".", "setProfileProperties", "(", "profileProperties", ")", ";", "}", "if", "(", "session", "!=", "null", ")", "{", "data", ".", "setSessionId", "(", "session", ".", "getItemId", "(", ")", ")", ";", "if", "(", "contextRequest", ".", "getRequiredSessionProperties", "(", ")", "!=", "null", ")", "{", "Map", "<", "String", ",", "Object", ">", "sessionProperties", "=", "new", "HashMap", "<", ">", "(", "session", ".", "getProperties", "(", ")", ")", ";", "if", "(", "!", "contextRequest", ".", "getRequiredSessionProperties", "(", ")", ".", "contains", "(", "\"", "*", "\"", ")", ")", "{", "sessionProperties", ".", "keySet", "(", ")", ".", "retainAll", "(", "contextRequest", ".", "getRequiredSessionProperties", "(", ")", ")", ";", "}", "data", ".", "setSessionProperties", "(", "sessionProperties", ")", ";", "}", "}", "processOverrides", "(", "contextRequest", ",", "profile", ",", "session", ")", ";", "List", "<", "PersonalizationService", ".", "PersonalizedContent", ">", "filterNodes", "=", "contextRequest", ".", "getFilters", "(", ")", ";", "if", "(", "filterNodes", "!=", "null", ")", "{", "data", ".", "setFilteringResults", "(", "new", "HashMap", "<", ">", "(", ")", ")", ";", "for", "(", "PersonalizationService", ".", "PersonalizedContent", "personalizedContent", ":", "filterNodes", ")", "{", "data", ".", "getFilteringResults", "(", ")", ".", "put", "(", "personalizedContent", ".", "getId", "(", ")", ",", "personalizationService", ".", "filter", "(", "profile", ",", "session", ",", "personalizedContent", ")", ")", ";", "}", "}", "List", "<", "PersonalizationService", ".", "PersonalizationRequest", ">", "personalizations", "=", "contextRequest", ".", "getPersonalizations", "(", ")", ";", "if", "(", "personalizations", "!=", "null", ")", "{", "data", ".", "setPersonalizations", "(", "new", "HashMap", "<", ">", "(", ")", ")", ";", "for", "(", "PersonalizationService", ".", "PersonalizationRequest", "personalization", ":", "personalizations", ")", "{", "data", ".", "getPersonalizations", "(", ")", ".", "put", "(", "personalization", ".", "getId", "(", ")", ",", "personalizationService", ".", "personalizeList", "(", "profile", ",", "session", ",", "personalization", ")", ")", ";", "}", "}", "if", "(", "!", "(", "profile", "instanceof", "Persona", ")", ")", "{", "data", ".", "setTrackedConditions", "(", "rulesService", ".", "getTrackedConditions", "(", "contextRequest", ".", "getSource", "(", ")", ")", ")", ";", "}", "else", "{", "data", ".", "setTrackedConditions", "(", "Collections", ".", "emptySet", "(", ")", ")", ";", "}", "data", ".", "setAnonymousBrowsing", "(", "privacyService", ".", "isRequireAnonymousBrowsing", "(", "profile", ")", ")", ";", "data", ".", "setConsents", "(", "profile", ".", "getConsents", "(", ")", ")", ";", "return", "changes", ";", "}"], "idx": 73883, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "0b81ba35dd3c3c2e0a92ce06592b3df90571eced", "function_name": "handleRequest", "body_hash": "56bb2e6760b9564d75379d873287aeab4f860ddd"}
{"code": "public static DomainSocketAddress newSocketAddress() {\n        try {\n            File file;\n            do {\n                file = File.createTempFile(\"NETTY\", \"UDS\");\n                if (!file.delete()) {\n                    throw new IOException(\"failed to delete: \" + file);\n                }\n            } while (file.getAbsolutePath().length() > 128);\n            return new DomainSocketAddress(file);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }", "code_tokens": ["public", "static", "DomainSocketAddress", "newSocketAddress", "(", ")", "{", "try", "{", "File", "file", ";", "do", "{", "file", "=", "File", ".", "createTempFile", "(", "\"", "NETTY", "\"", ",", "\"", "UDS", "\"", ")", ";", "if", "(", "!", "file", ".", "delete", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "failed to delete: ", "\"", "+", "file", ")", ";", "}", "}", "while", "(", "file", ".", "getAbsolutePath", "(", ")", ".", "length", "(", ")", ">", "128", ")", ";", "return", "new", "DomainSocketAddress", "(", "file", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}"], "idx": 50049, "cwe": "CWE-378", "target": 1, "status": "VULNERABLE", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "newSocketAddress", "body_hash": "2a2ae1188e13862962975616c876d8af2ddedb4f"}
{"code": "public T readFrom(Class<T> clazz, Type t, Annotation[] a, MediaType mt, \n                         MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        Parser parser = ATOM_ENGINE.getParser();\n        synchronized (parser) {\n            ParserOptions options = parser.getDefaultParserOptions();\n            if (options != null) {\n                options.setAutodetectCharset(autodetectCharset);\n                options.setResolveEntities(false);\n            }\n        }\n        Document<T> doc = parser.parse(is);\n        return doc.getRoot();\n    }", "code_tokens": ["public", "T", "readFrom", "(", "Class", "<", "T", ">", "clazz", ",", "Type", "t", ",", "Annotation", "[", "]", "a", ",", "MediaType", "mt", ",", "MultivaluedMap", "<", "String", ",", "String", ">", "headers", ",", "InputStream", "is", ")", "throws", "IOException", "{", "Parser", "parser", "=", "ATOM_ENGINE", ".", "getParser", "(", ")", ";", "synchronized", "(", "parser", ")", "{", "ParserOptions", "options", "=", "parser", ".", "getDefaultParserOptions", "(", ")", ";", "if", "(", "options", "!=", "null", ")", "{", "options", ".", "setAutodetectCharset", "(", "autodetectCharset", ")", ";", "options", ".", "setResolveEntities", "(", "false", ")", ";", "}", "}", "Document", "<", "T", ">", "doc", "=", "parser", ".", "parse", "(", "is", ")", ";", "return", "doc", ".", "getRoot", "(", ")", ";", "}"], "idx": 68637, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "8e4970d9", "function_name": "readFrom", "body_hash": "f92f6583f0c0ef5ac13a489d588849fa5ef2a4bd"}
{"code": "private void normalizeNumber(int start, int end) {\n    int pos = start;\n    // Sign\n    if (pos < end) {\n      switch (jsonish.charAt(pos)) {\n        case '+':\n          elide(pos, pos + 1);\n          ++pos;\n          break;\n        case '-':\n          ++pos;\n          break;\n        default:\n          break;\n      }\n    }\n\n    // Integer part\n    int intEnd = endOfDigitRun(pos, end);\n    if (pos == intEnd) {  // No empty integer parts allowed in JSON.\n      insert(pos, '0');\n    } else if ('0' == jsonish.charAt(pos)) {\n      boolean reencoded = false;\n      int maxDigVal = 0; // The value of the max digit\n      int probableBase = 10; // The base suggested by the prefix\n      int firstDigitIndex = -1;\n      if (intEnd - pos == 1 && intEnd < end\n              && 'x' == (jsonish.charAt(intEnd) | 32)) {  // Recode hex.\n        probableBase = 16;\n        firstDigitIndex = intEnd + 1;\n        for (intEnd = intEnd + 1; intEnd < end; ++intEnd) {\n          char ch = jsonish.charAt(intEnd);\n          int digVal;\n          if ('0' <= ch && ch <= '9') {\n            digVal = ch - '0';\n          } else {\n            ch |= 32;\n            if ('a' <= ch && ch <= 'f') {\n              digVal = ch - ('a' - 10);\n            } else {\n              break;\n            }\n          }\n          maxDigVal = Math.max(digVal, maxDigVal);\n        }\n        reencoded = true;\n      } else if (intEnd - pos > 1) {  // Recode octal.\n        probableBase = 8;\n        firstDigitIndex = pos;\n        for (int i = pos; i < intEnd; ++i) {\n          int digVal = jsonish.charAt(i) - '0';\n          if (digVal < 0) {\n            break;\n          }\n          maxDigVal = Math.max(digVal, maxDigVal);\n        }\n        reencoded = true;\n      }\n      if (reencoded) {\n        // Avoid multiple signs.\n        // Putting out the underflowed value is the least bad option.\n        elide(pos, intEnd);\n\n        String digits = jsonish.substring(firstDigitIndex, intEnd);\n\n        int nDigits = digits.length();\n        int base = probableBase > maxDigVal ? probableBase : maxDigVal > 10 ? 16 : 10;\n        if (DIGITS_BY_BASE_THAT_FIT_IN_63B[base] >= nDigits) {\n          long value = Long.parseLong(digits, base);\n          sanitizedJson.append(value);\n        } else {\n          // If there are lots of digits, we need to reencode using a BigInteger\n          BigInteger value = new BigInteger(digits, base);\n          sanitizedJson.append(value);\n        }\n      }\n    }\n    pos = intEnd;\n\n    // Optional fraction.\n    if (pos < end && jsonish.charAt(pos) == '.') {\n      ++pos;\n      int fractionEnd = endOfDigitRun(pos, end);\n      if (fractionEnd == pos) {\n        insert(pos, '0');\n      }\n      // JS eval will discard digits after 24(?) but will not treat them as a\n      // syntax error, and JSON allows arbitrary length fractions.\n      pos = fractionEnd;\n    }\n\n    // Optional exponent.\n    if (pos < end && 'e' == (jsonish.charAt(pos) | 32)) {\n      ++pos;\n      if (pos < end) {\n        switch (jsonish.charAt(pos)) {\n          // JSON allows explicit + in exponent but not for number as a whole.\n          case '+': case '-': ++pos; break;\n          default: break;\n        }\n      }\n      // JSON allows leading zeros on exponent part.\n      int expEnd = endOfDigitRun(pos, end);\n      if (expEnd == pos) {\n        insert(pos, '0');\n      }\n      pos = expEnd;\n    }\n    if (pos != end) {\n      elide(pos, end);\n    }\n  }", "code_tokens": ["private", "void", "normalizeNumber", "(", "int", "start", ",", "int", "end", ")", "{", "int", "pos", "=", "start", ";", "if", "(", "pos", "<", "end", ")", "{", "switch", "(", "jsonish", ".", "charAt", "(", "pos", ")", ")", "{", "case", "'+'", ":", "elide", "(", "pos", ",", "pos", "+", "1", ")", ";", "++", "pos", ";", "break", ";", "case", "'-'", ":", "++", "pos", ";", "break", ";", "default", ":", "break", ";", "}", "}", "int", "intEnd", "=", "endOfDigitRun", "(", "pos", ",", "end", ")", ";", "if", "(", "pos", "==", "intEnd", ")", "{", "insert", "(", "pos", ",", "'0'", ")", ";", "}", "else", "if", "(", "'0'", "==", "jsonish", ".", "charAt", "(", "pos", ")", ")", "{", "boolean", "reencoded", "=", "false", ";", "int", "maxDigVal", "=", "0", ";", "int", "probableBase", "=", "10", ";", "int", "firstDigitIndex", "=", "-", "1", ";", "if", "(", "intEnd", "-", "pos", "==", "1", "&&", "intEnd", "<", "end", "&&", "'x'", "==", "(", "jsonish", ".", "charAt", "(", "intEnd", ")", "|", "32", ")", ")", "{", "probableBase", "=", "16", ";", "firstDigitIndex", "=", "intEnd", "+", "1", ";", "for", "(", "intEnd", "=", "intEnd", "+", "1", ";", "intEnd", "<", "end", ";", "++", "intEnd", ")", "{", "char", "ch", "=", "jsonish", ".", "charAt", "(", "intEnd", ")", ";", "int", "digVal", ";", "if", "(", "'0'", "<=", "ch", "&&", "ch", "<=", "'9'", ")", "{", "digVal", "=", "ch", "-", "'0'", ";", "}", "else", "{", "ch", "|=", "32", ";", "if", "(", "'a'", "<=", "ch", "&&", "ch", "<=", "'f'", ")", "{", "digVal", "=", "ch", "-", "(", "'a'", "-", "10", ")", ";", "}", "else", "{", "break", ";", "}", "}", "maxDigVal", "=", "Math", ".", "max", "(", "digVal", ",", "maxDigVal", ")", ";", "}", "reencoded", "=", "true", ";", "}", "else", "if", "(", "intEnd", "-", "pos", ">", "1", ")", "{", "probableBase", "=", "8", ";", "firstDigitIndex", "=", "pos", ";", "for", "(", "int", "i", "=", "pos", ";", "i", "<", "intEnd", ";", "++", "i", ")", "{", "int", "digVal", "=", "jsonish", ".", "charAt", "(", "i", ")", "-", "'0'", ";", "if", "(", "digVal", "<", "0", ")", "{", "break", ";", "}", "maxDigVal", "=", "Math", ".", "max", "(", "digVal", ",", "maxDigVal", ")", ";", "}", "reencoded", "=", "true", ";", "}", "if", "(", "reencoded", ")", "{", "elide", "(", "pos", ",", "intEnd", ")", ";", "String", "digits", "=", "jsonish", ".", "substring", "(", "firstDigitIndex", ",", "intEnd", ")", ";", "int", "nDigits", "=", "digits", ".", "length", "(", ")", ";", "int", "base", "=", "probableBase", ">", "maxDigVal", "?", "probableBase", ":", "maxDigVal", ">", "10", "?", "16", ":", "10", ";", "if", "(", "DIGITS_BY_BASE_THAT_FIT_IN_63B", "[", "base", "]", ">=", "nDigits", ")", "{", "long", "value", "=", "Long", ".", "parseLong", "(", "digits", ",", "base", ")", ";", "sanitizedJson", ".", "append", "(", "value", ")", ";", "}", "else", "{", "BigInteger", "value", "=", "new", "BigInteger", "(", "digits", ",", "base", ")", ";", "sanitizedJson", ".", "append", "(", "value", ")", ";", "}", "}", "}", "pos", "=", "intEnd", ";", "if", "(", "pos", "<", "end", "&&", "jsonish", ".", "charAt", "(", "pos", ")", "==", "'.'", ")", "{", "++", "pos", ";", "int", "fractionEnd", "=", "endOfDigitRun", "(", "pos", ",", "end", ")", ";", "if", "(", "fractionEnd", "==", "pos", ")", "{", "insert", "(", "pos", ",", "'0'", ")", ";", "}", "pos", "=", "fractionEnd", ";", "}", "if", "(", "pos", "<", "end", "&&", "'e'", "==", "(", "jsonish", ".", "charAt", "(", "pos", ")", "|", "32", ")", ")", "{", "++", "pos", ";", "if", "(", "pos", "<", "end", ")", "{", "switch", "(", "jsonish", ".", "charAt", "(", "pos", ")", ")", "{", "case", "'+'", ":", "case", "'-'", ":", "++", "pos", ";", "break", ";", "default", ":", "break", ";", "}", "}", "int", "expEnd", "=", "endOfDigitRun", "(", "pos", ",", "end", ")", ";", "if", "(", "expEnd", "==", "pos", ")", "{", "insert", "(", "pos", ",", "'0'", ")", ";", "}", "pos", "=", "expEnd", ";", "}", "if", "(", "pos", "!=", "end", ")", "{", "elide", "(", "pos", ",", "end", ")", ";", "}", "}"], "idx": 69936, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "d9261ad22872f84c3948f9711454b5630e3e977d", "function_name": "normalizeNumber", "body_hash": "e028167e9c1c89048f8cf5082e7df0cd8469a8cb"}
{"code": "public String findFilter( String url_suffix )\n    {\n        if( url_suffix == null )\n        {\n            throw new IllegalArgumentException( \"The url_suffix must not be null.\" );\n        }\n        \n        CaptureType type = em.find( CaptureType.class, url_suffix );\n        \n        if( type != null )\n        {\n            return type.getCaptureFilter();\n        }\n        \n        return null;\n    }", "code_tokens": ["public", "String", "findFilter", "(", "String", "url_suffix", ")", "{", "if", "(", "url_suffix", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "The url_suffix must not be null.", "\"", ")", ";", "}", "CaptureType", "type", "=", "em", ".", "find", "(", "CaptureType", ".", "class", ",", "url_suffix", ")", ";", "if", "(", "type", "!=", "null", ")", "{", "return", "type", ".", "getCaptureFilter", "(", ")", ";", "}", "return", "null", ";", "}"], "idx": 74269, "cwe": "CWE-754", "target": 1, "status": "VULNERABLE", "commit": "0f74f431e0970a2e5784dbd955cfa4760e3b1ef7", "function_name": "findFilter", "body_hash": "477e3668b105c0268bbe6c0886d23dfb23fa27f6"}
{"code": "public void handleMessage(Message message) {\n        if (isGET(message) || message.getContent(XMLStreamReader.class) != null) {\n            LOG.fine(\"StaxInInterceptor skipped.\");\n            return;\n        }\n        InputStream is = message.getContent(InputStream.class);\n        Reader reader = null;\n        if (is == null) {\n            reader = message.getContent(Reader.class);\n            if (reader == null) {\n                return;\n            }\n        }\n        String contentType = (String)message.get(Message.CONTENT_TYPE);\n        \n        if (contentType != null \n            && contentType.contains(\"text/html\")\n            && MessageUtils.isRequestor(message)) {\n            StringBuilder htmlMessage = new StringBuilder(1024);\n            try {\n                if (reader == null) {\n                    reader = new InputStreamReader(is, (String)message.get(Message.ENCODING));\n                }\n                char s[] = new char[1024];\n                int i = reader.read(s);\n                while (htmlMessage.length() < 64536 && i > 0) {\n                    htmlMessage.append(s, 0, i);\n                    i = reader.read(s);\n                }\n            } catch (IOException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVALID_HTML_RESPONSETYPE\",\n                        LOG, \"(none)\"));\n            }\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVALID_HTML_RESPONSETYPE\",\n                    LOG, (htmlMessage == null || htmlMessage.length() == 0) ? \"(none)\" : htmlMessage));\n        }\n        if (contentType == null) {\n            //if contentType is null, this is likely a an empty post/put/delete/similar, lets see if it's\n            //detectable at all\n            Map<String, List<String>> m = CastUtils.cast((Map<?, ?>)message.get(Message.PROTOCOL_HEADERS));\n            if (m != null) {\n                List<String> contentLen = HttpHeaderHelper\n                    .getHeader(m, HttpHeaderHelper.CONTENT_LENGTH);\n                List<String> contentTE = HttpHeaderHelper\n                    .getHeader(m, HttpHeaderHelper.CONTENT_TRANSFER_ENCODING);\n                if ((StringUtils.isEmpty(contentLen) || \"0\".equals(contentLen.get(0)))\n                    && StringUtils.isEmpty(contentTE)) {\n                    return;\n                }\n            }\n        }\n\n        String encoding = (String)message.get(Message.ENCODING);\n\n        XMLStreamReader xreader;\n        try {\n            XMLInputFactory factory = getXMLInputFactory(message);\n            if (factory == null) {\n                if (reader != null) {\n                    xreader = StaxUtils.createXMLStreamReader(reader);\n                } else {\n                    xreader = StaxUtils.createXMLStreamReader(is, encoding);\n                }\n            } else {\n                synchronized (factory) {\n                    if (reader != null) {\n                        xreader = factory.createXMLStreamReader(reader);\n                    } else {\n                        xreader = factory.createXMLStreamReader(is, encoding);\n                    }\n                }                \n            }\n            xreader = configureRestrictions(xreader, message);\n        } catch (XMLStreamException e) {\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"STREAM_CREATE_EXC\",\n                                                                   LOG,\n                                                                   encoding), e);\n        }\n        message.setContent(XMLStreamReader.class, xreader);\n        message.getInterceptorChain().add(StaxInEndingInterceptor.INSTANCE);\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "{", "if", "(", "isGET", "(", "message", ")", "||", "message", ".", "getContent", "(", "XMLStreamReader", ".", "class", ")", "!=", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "StaxInInterceptor skipped.", "\"", ")", ";", "return", ";", "}", "InputStream", "is", "=", "message", ".", "getContent", "(", "InputStream", ".", "class", ")", ";", "Reader", "reader", "=", "null", ";", "if", "(", "is", "==", "null", ")", "{", "reader", "=", "message", ".", "getContent", "(", "Reader", ".", "class", ")", ";", "if", "(", "reader", "==", "null", ")", "{", "return", ";", "}", "}", "String", "contentType", "=", "(", "String", ")", "message", ".", "get", "(", "Message", ".", "CONTENT_TYPE", ")", ";", "if", "(", "contentType", "!=", "null", "&&", "contentType", ".", "contains", "(", "\"", "text/html", "\"", ")", "&&", "MessageUtils", ".", "isRequestor", "(", "message", ")", ")", "{", "StringBuilder", "htmlMessage", "=", "new", "StringBuilder", "(", "1024", ")", ";", "try", "{", "if", "(", "reader", "==", "null", ")", "{", "reader", "=", "new", "InputStreamReader", "(", "is", ",", "(", "String", ")", "message", ".", "get", "(", "Message", ".", "ENCODING", ")", ")", ";", "}", "char", "s", "[", "]", "=", "new", "char", "[", "1024", "]", ";", "int", "i", "=", "reader", ".", "read", "(", "s", ")", ";", "while", "(", "htmlMessage", ".", "length", "(", ")", "<", "64536", "&&", "i", ">", "0", ")", "{", "htmlMessage", ".", "append", "(", "s", ",", "0", ",", "i", ")", ";", "i", "=", "reader", ".", "read", "(", "s", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "INVALID_HTML_RESPONSETYPE", "\"", ",", "LOG", ",", "\"", "(none)", "\"", ")", ")", ";", "}", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "INVALID_HTML_RESPONSETYPE", "\"", ",", "LOG", ",", "(", "htmlMessage", "==", "null", "||", "htmlMessage", ".", "length", "(", ")", "==", "0", ")", "?", "\"", "(none)", "\"", ":", "htmlMessage", ")", ")", ";", "}", "if", "(", "contentType", "==", "null", ")", "{", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "m", "=", "CastUtils", ".", "cast", "(", "(", "Map", "<", "?", ",", "?", ">", ")", "message", ".", "get", "(", "Message", ".", "PROTOCOL_HEADERS", ")", ")", ";", "if", "(", "m", "!=", "null", ")", "{", "List", "<", "String", ">", "contentLen", "=", "HttpHeaderHelper", ".", "getHeader", "(", "m", ",", "HttpHeaderHelper", ".", "CONTENT_LENGTH", ")", ";", "List", "<", "String", ">", "contentTE", "=", "HttpHeaderHelper", ".", "getHeader", "(", "m", ",", "HttpHeaderHelper", ".", "CONTENT_TRANSFER_ENCODING", ")", ";", "if", "(", "(", "StringUtils", ".", "isEmpty", "(", "contentLen", ")", "||", "\"", "0", "\"", ".", "equals", "(", "contentLen", ".", "get", "(", "0", ")", ")", ")", "&&", "StringUtils", ".", "isEmpty", "(", "contentTE", ")", ")", "{", "return", ";", "}", "}", "}", "String", "encoding", "=", "(", "String", ")", "message", ".", "get", "(", "Message", ".", "ENCODING", ")", ";", "XMLStreamReader", "xreader", ";", "try", "{", "XMLInputFactory", "factory", "=", "getXMLInputFactory", "(", "message", ")", ";", "if", "(", "factory", "==", "null", ")", "{", "if", "(", "reader", "!=", "null", ")", "{", "xreader", "=", "StaxUtils", ".", "createXMLStreamReader", "(", "reader", ")", ";", "}", "else", "{", "xreader", "=", "StaxUtils", ".", "createXMLStreamReader", "(", "is", ",", "encoding", ")", ";", "}", "}", "else", "{", "synchronized", "(", "factory", ")", "{", "if", "(", "reader", "!=", "null", ")", "{", "xreader", "=", "factory", ".", "createXMLStreamReader", "(", "reader", ")", ";", "}", "else", "{", "xreader", "=", "factory", ".", "createXMLStreamReader", "(", "is", ",", "encoding", ")", ";", "}", "}", "}", "xreader", "=", "configureRestrictions", "(", "xreader", ",", "message", ")", ";", "}", "catch", "(", "XMLStreamException", "e", ")", "{", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "STREAM_CREATE_EXC", "\"", ",", "LOG", ",", "encoding", ")", ",", "e", ")", ";", "}", "message", ".", "setContent", "(", "XMLStreamReader", ".", "class", ",", "xreader", ")", ";", "message", ".", "getInterceptorChain", "(", ")", ".", "add", "(", "StaxInEndingInterceptor", ".", "INSTANCE", ")", ";", "}"], "idx": 51164, "cwe": "CWE-399", "target": 0, "status": "FIXED", "commit": "f8ed98e684c1a67a77ae8726db05a04a4978a445", "function_name": "handleMessage", "body_hash": "5124c5a35e0fd5c4385f08cd090222d65777b0bf"}
{"code": "@Override\n    public void awaitWritable() throws IOException {\n        if(Thread.currentThread() == getIoThread()) {\n            throw UndertowMessages.MESSAGES.awaitCalledFromIoThread();\n        }\n        synchronized (lock) {\n            if (anyAreSet(state, STATE_CLOSED) || broken) {\n                return;\n            }\n            if (readyForFlush) {\n                try {\n                    waiterCount++;\n                    //we need to re-check after incrementing the waiters count\n                    if(readyForFlush && !anyAreSet(state, STATE_CLOSED) && !broken) {\n                        lock.wait(awaitWritableTimeout);\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new InterruptedIOException();\n                } finally {\n                    waiterCount--;\n                }\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "awaitWritable", "(", ")", "throws", "IOException", "{", "if", "(", "Thread", ".", "currentThread", "(", ")", "==", "getIoThread", "(", ")", ")", "{", "throw", "UndertowMessages", ".", "MESSAGES", ".", "awaitCalledFromIoThread", "(", ")", ";", "}", "synchronized", "(", "lock", ")", "{", "if", "(", "anyAreSet", "(", "state", ",", "STATE_CLOSED", ")", "||", "broken", ")", "{", "return", ";", "}", "if", "(", "readyForFlush", ")", "{", "try", "{", "waiterCount", "++", ";", "if", "(", "readyForFlush", "&&", "!", "anyAreSet", "(", "state", ",", "STATE_CLOSED", ")", "&&", "!", "broken", ")", "{", "lock", ".", "wait", "(", "awaitWritableTimeout", ")", ";", "}", "}", "catch", "(", "InterruptedException", "e", ")", "{", "Thread", ".", "currentThread", "(", ")", ".", "interrupt", "(", ")", ";", "throw", "new", "InterruptedIOException", "(", ")", ";", "}", "finally", "{", "waiterCount", "--", ";", "}", "}", "}", "}"], "idx": 52351, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "40efb45a5ee92b8fd6a12757c59ee7e8d0dfa090", "function_name": "awaitWritable", "body_hash": "985894e681e744b9a641b03517afe5ba94eab2c7"}
{"code": "public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        if (path.isEmpty() || path.contains(\"..\") || path.contains(\"%\") || path.contains(\"META-INF\") || path.contains(\"WEB-INF\")) {\n            LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n    }", "code_tokens": ["public", "void", "doDynamic", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "req", ".", "getRestOfPath", "(", ")", ";", "if", "(", "path", ".", "isEmpty", "(", ")", "||", "path", ".", "contains", "(", "\"", "..", "\"", ")", "||", "path", ".", "contains", "(", "\"", "%", "\"", ")", "||", "path", ".", "contains", "(", "\"", "META-INF", "\"", ")", "||", "path", ".", "contains", "(", "\"", "WEB-INF", "\"", ")", ")", "{", "LOGGER", ".", "warning", "(", "\"", "rejecting possibly malicious ", "\"", "+", "req", ".", "getRequestURIWithQueryString", "(", ")", ")", ";", "rsp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "String", "requestPath", "=", "req", ".", "getRequestURI", "(", ")", ".", "substring", "(", "req", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "boolean", "staticLink", "=", "requestPath", ".", "startsWith", "(", "\"", "/static/", "\"", ")", ";", "long", "expires", "=", "staticLink", "?", "TimeUnit2", ".", "DAYS", ".", "toMillis", "(", "365", ")", ":", "-", "1", ";", "rsp", ".", "serveLocalizedFile", "(", "req", ",", "new", "URL", "(", "wrapper", ".", "baseResourceURL", ",", "'.'", "+", "path", ")", ",", "expires", ")", ";", "}"], "idx": 15087, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "8830d68f5fe21f344be3496984bc4470bfcd0564", "function_name": "doDynamic", "body_hash": "dfa218741b2796112c2dab196ec088ae4d747e28"}
{"code": "private static boolean validateGlobalResourceAccess(String globalName) {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        while (cl != null) {\n            Map<String,String> registrations = globalResourceRegistrations.get(cl);\n            if (registrations != null && registrations.containsValue(globalName)) {\n                return true;\n            }\n            cl = cl.getParent();\n        }\n        return false;\n    }", "code_tokens": ["private", "static", "boolean", "validateGlobalResourceAccess", "(", "String", "globalName", ")", "{", "ClassLoader", "cl", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "while", "(", "cl", "!=", "null", ")", "{", "Map", "<", "String", ",", "String", ">", "registrations", "=", "globalResourceRegistrations", ".", "get", "(", "cl", ")", ";", "if", "(", "registrations", "!=", "null", "&&", "registrations", ".", "containsValue", "(", "globalName", ")", ")", "{", "return", "true", ";", "}", "cl", "=", "cl", ".", "getParent", "(", ")", ";", "}", "return", "false", ";", "}"], "idx": 100638, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "66e227e0c73ea2f7e93cee9340b580912d580f5d", "function_name": "validateGlobalResourceAccess", "body_hash": "bf8c77e4a579475f2b35045f0309290e1f18dde7"}
{"code": "@Override\n    public ScmServerEndpoint create(JSONObject request) {\n\n        try {\n            Jenkins.get().checkPermission(Item.CREATE);\n        } catch (Exception e) {\n            throw new ServiceException.ForbiddenException(\"User does not have permission to create repository\", e);\n        }\n\n        List<ErrorMessage.Error> errors = new LinkedList<>();\n\n        // Validate name\n        final String name = (String) request.get(ScmServerEndpoint.NAME);\n        if(StringUtils.isBlank(name)){\n            errors.add(new ErrorMessage.Error(ScmServerEndpoint.NAME, ErrorMessage.Error.ErrorCodes.MISSING.toString(), ScmServerEndpoint.NAME + \" is required\"));\n        }\n\n        String url = (String) request.get(ScmServerEndpoint.API_URL);\n        final BitbucketEndpointConfiguration endpointConfiguration = BitbucketEndpointConfiguration.get();\n        if(StringUtils.isBlank(url)){\n            errors.add(new ErrorMessage.Error(ScmServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.MISSING.toString(), ScmServerEndpoint.API_URL + \" is required\"));\n        }else {\n            try {\n                String version = BitbucketServerApi.getVersion(url);\n                if (!BitbucketServerApi.isSupportedVersion(version)) {\n                    errors.add(new ErrorMessage.Error(BitbucketServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.INVALID.toString(),\n                            Messages.bbserver_version_validation_error(\n                                    version, BitbucketServerApi.MINIMUM_SUPPORTED_VERSION)));\n                } else {\n                    //validate presence of endpoint with same name\n                    url = BitbucketEndpointConfiguration.normalizeServerUrl(url);\n                    for (AbstractBitbucketEndpoint endpoint : endpointConfiguration.getEndpoints()) {\n                        if (url.equals(endpoint.getServerUrl())) {\n                            errors.add(new ErrorMessage.Error(ScmServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.ALREADY_EXISTS.toString(), ScmServerEndpoint.API_URL + \" already exists\"));\n                            break;\n                        }\n                    }\n                }\n            } catch (ServiceException e) {\n                errors.add(new ErrorMessage.Error(BitbucketServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.INVALID.toString(), StringUtils.isBlank(e.getMessage()) ? \"Invalid URL\" : e.getMessage()));\n            }\n        }\n\n        if(!errors.isEmpty()){\n            throw new ServiceException.BadRequestException(new ErrorMessage(400, \"Failed to create Bitbucket server endpoint\").addAll(errors));\n        }\n        final com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketServerEndpoint endpoint = new com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketServerEndpoint(name, url, false, null);\n        SecurityContext old=null;\n        try {\n            // We need to escalate privilege to add user defined endpoint to\n            old = ACL.impersonate(ACL.SYSTEM);\n            endpointConfiguration.addEndpoint(endpoint);\n        }finally {\n            //reset back to original privilege level\n            if(old != null){\n                SecurityContextHolder.setContext(old);\n            }\n        }\n        return new BitbucketServerEndpoint(endpoint, this);\n    }", "code_tokens": ["@", "Override", "public", "ScmServerEndpoint", "create", "(", "JSONObject", "request", ")", "{", "try", "{", "Jenkins", ".", "get", "(", ")", ".", "checkPermission", "(", "Item", ".", "CREATE", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "ServiceException", ".", "ForbiddenException", "(", "\"", "User does not have permission to create repository", "\"", ",", "e", ")", ";", "}", "List", "<", "ErrorMessage", ".", "Error", ">", "errors", "=", "new", "LinkedList", "<", ">", "(", ")", ";", "final", "String", "name", "=", "(", "String", ")", "request", ".", "get", "(", "ScmServerEndpoint", ".", "NAME", ")", ";", "if", "(", "StringUtils", ".", "isBlank", "(", "name", ")", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "ScmServerEndpoint", ".", "NAME", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "MISSING", ".", "toString", "(", ")", ",", "ScmServerEndpoint", ".", "NAME", "+", "\"", " is required", "\"", ")", ")", ";", "}", "String", "url", "=", "(", "String", ")", "request", ".", "get", "(", "ScmServerEndpoint", ".", "API_URL", ")", ";", "final", "BitbucketEndpointConfiguration", "endpointConfiguration", "=", "BitbucketEndpointConfiguration", ".", "get", "(", ")", ";", "if", "(", "StringUtils", ".", "isBlank", "(", "url", ")", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "ScmServerEndpoint", ".", "API_URL", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "MISSING", ".", "toString", "(", ")", ",", "ScmServerEndpoint", ".", "API_URL", "+", "\"", " is required", "\"", ")", ")", ";", "}", "else", "{", "try", "{", "String", "version", "=", "BitbucketServerApi", ".", "getVersion", "(", "url", ")", ";", "if", "(", "!", "BitbucketServerApi", ".", "isSupportedVersion", "(", "version", ")", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "BitbucketServerEndpoint", ".", "API_URL", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "INVALID", ".", "toString", "(", ")", ",", "Messages", ".", "bbserver_version_validation_error", "(", "version", ",", "BitbucketServerApi", ".", "MINIMUM_SUPPORTED_VERSION", ")", ")", ")", ";", "}", "else", "{", "url", "=", "BitbucketEndpointConfiguration", ".", "normalizeServerUrl", "(", "url", ")", ";", "for", "(", "AbstractBitbucketEndpoint", "endpoint", ":", "endpointConfiguration", ".", "getEndpoints", "(", ")", ")", "{", "if", "(", "url", ".", "equals", "(", "endpoint", ".", "getServerUrl", "(", ")", ")", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "ScmServerEndpoint", ".", "API_URL", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "ALREADY_EXISTS", ".", "toString", "(", ")", ",", "ScmServerEndpoint", ".", "API_URL", "+", "\"", " already exists", "\"", ")", ")", ";", "break", ";", "}", "}", "}", "}", "catch", "(", "ServiceException", "e", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "BitbucketServerEndpoint", ".", "API_URL", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "INVALID", ".", "toString", "(", ")", ",", "StringUtils", ".", "isBlank", "(", "e", ".", "getMessage", "(", ")", ")", "?", "\"", "Invalid URL", "\"", ":", "e", ".", "getMessage", "(", ")", ")", ")", ";", "}", "}", "if", "(", "!", "errors", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "ServiceException", ".", "BadRequestException", "(", "new", "ErrorMessage", "(", "400", ",", "\"", "Failed to create Bitbucket server endpoint", "\"", ")", ".", "addAll", "(", "errors", ")", ")", ";", "}", "final", "com", ".", "cloudbees", ".", "jenkins", ".", "plugins", ".", "bitbucket", ".", "endpoints", ".", "BitbucketServerEndpoint", "endpoint", "=", "new", "com", ".", "cloudbees", ".", "jenkins", ".", "plugins", ".", "bitbucket", ".", "endpoints", ".", "BitbucketServerEndpoint", "(", "name", ",", "url", ",", "false", ",", "null", ")", ";", "SecurityContext", "old", "=", "null", ";", "try", "{", "old", "=", "ACL", ".", "impersonate", "(", "ACL", ".", "SYSTEM", ")", ";", "endpointConfiguration", ".", "addEndpoint", "(", "endpoint", ")", ";", "}", "finally", "{", "if", "(", "old", "!=", "null", ")", "{", "SecurityContextHolder", ".", "setContext", "(", "old", ")", ";", "}", "}", "return", "new", "BitbucketServerEndpoint", "(", "endpoint", ",", "this", ")", ";", "}"], "idx": 83830, "cwe": "CWE-862", "target": 0, "status": "FIXED", "commit": "659a66aff", "function_name": "create", "body_hash": "55cf4291ba27c247d3827352a9431509ee3ee911"}
{"code": "protected UserModel validateCache(RealmModel realm, CachedUser cached) {\n        StorageId storageId = new StorageId(cached.getId());\n        if (!storageId.isLocal()) {\n            ComponentModel component = realm.getComponent(storageId.getProviderId());\n            UserStorageProviderModel model = new UserStorageProviderModel(component);\n            UserStorageProviderModel.CachePolicy policy = model.getCachePolicy();\n            // although we do set a timeout, Infinispan has no guarantees when the user will be evicted\n            // its also hard to test stuff\n            boolean invalidate = false;\n            if (policy != null) {\n                String currentTime = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(Time.currentTimeMillis()));\n                if (policy == UserStorageProviderModel.CachePolicy.NO_CACHE) {\n                    invalidate = true;\n                } else if (cached.getCacheTimestamp() < model.getCacheInvalidBefore()) {\n                    invalidate = true;\n                } else if (policy == UserStorageProviderModel.CachePolicy.EVICT_DAILY) {\n                    long dailyTimeout = dailyTimeout(model.getEvictionHour(), model.getEvictionMinute());\n                    dailyTimeout = dailyTimeout - (24 * 60 * 60 * 1000);\n                    //String timeout = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(dailyTimeout));\n                    //String stamp = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(cached.getCacheTimestamp()));\n                    if (cached.getCacheTimestamp() <= dailyTimeout) {\n                        invalidate = true;\n                    }\n                } else if (policy == UserStorageProviderModel.CachePolicy.EVICT_WEEKLY) {\n                    int oneWeek = 7 * 24 * 60 * 60 * 1000;\n                    long weeklyTimeout = weeklyTimeout(model.getEvictionDay(), model.getEvictionHour(), model.getEvictionMinute());\n                    long lastTimeout = weeklyTimeout - oneWeek;\n                    String timeout = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(weeklyTimeout));\n                    String stamp = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(cached.getCacheTimestamp()));\n                    if (cached.getCacheTimestamp() <= lastTimeout) {\n                        invalidate = true;\n                    }\n                }\n            }\n            if (invalidate) {\n                registerUserInvalidation(realm, cached);\n                return getDelegate().getUserById(cached.getId(), realm);\n            }\n        }\n        return new UserAdapter(cached, this, session, realm);\n    }", "code_tokens": ["protected", "UserModel", "validateCache", "(", "RealmModel", "realm", ",", "CachedUser", "cached", ")", "{", "StorageId", "storageId", "=", "new", "StorageId", "(", "cached", ".", "getId", "(", ")", ")", ";", "if", "(", "!", "storageId", ".", "isLocal", "(", ")", ")", "{", "ComponentModel", "component", "=", "realm", ".", "getComponent", "(", "storageId", ".", "getProviderId", "(", ")", ")", ";", "UserStorageProviderModel", "model", "=", "new", "UserStorageProviderModel", "(", "component", ")", ";", "UserStorageProviderModel", ".", "CachePolicy", "policy", "=", "model", ".", "getCachePolicy", "(", ")", ";", "boolean", "invalidate", "=", "false", ";", "if", "(", "policy", "!=", "null", ")", "{", "String", "currentTime", "=", "DateFormat", ".", "getDateTimeInstance", "(", "DateFormat", ".", "FULL", ",", "DateFormat", ".", "FULL", ")", ".", "format", "(", "new", "Date", "(", "Time", ".", "currentTimeMillis", "(", ")", ")", ")", ";", "if", "(", "policy", "==", "UserStorageProviderModel", ".", "CachePolicy", ".", "NO_CACHE", ")", "{", "invalidate", "=", "true", ";", "}", "else", "if", "(", "cached", ".", "getCacheTimestamp", "(", ")", "<", "model", ".", "getCacheInvalidBefore", "(", ")", ")", "{", "invalidate", "=", "true", ";", "}", "else", "if", "(", "policy", "==", "UserStorageProviderModel", ".", "CachePolicy", ".", "EVICT_DAILY", ")", "{", "long", "dailyTimeout", "=", "dailyTimeout", "(", "model", ".", "getEvictionHour", "(", ")", ",", "model", ".", "getEvictionMinute", "(", ")", ")", ";", "dailyTimeout", "=", "dailyTimeout", "-", "(", "24", "*", "60", "*", "60", "*", "1000", ")", ";", "if", "(", "cached", ".", "getCacheTimestamp", "(", ")", "<=", "dailyTimeout", ")", "{", "invalidate", "=", "true", ";", "}", "}", "else", "if", "(", "policy", "==", "UserStorageProviderModel", ".", "CachePolicy", ".", "EVICT_WEEKLY", ")", "{", "int", "oneWeek", "=", "7", "*", "24", "*", "60", "*", "60", "*", "1000", ";", "long", "weeklyTimeout", "=", "weeklyTimeout", "(", "model", ".", "getEvictionDay", "(", ")", ",", "model", ".", "getEvictionHour", "(", ")", ",", "model", ".", "getEvictionMinute", "(", ")", ")", ";", "long", "lastTimeout", "=", "weeklyTimeout", "-", "oneWeek", ";", "String", "timeout", "=", "DateFormat", ".", "getDateTimeInstance", "(", "DateFormat", ".", "FULL", ",", "DateFormat", ".", "FULL", ")", ".", "format", "(", "new", "Date", "(", "weeklyTimeout", ")", ")", ";", "String", "stamp", "=", "DateFormat", ".", "getDateTimeInstance", "(", "DateFormat", ".", "FULL", ",", "DateFormat", ".", "FULL", ")", ".", "format", "(", "new", "Date", "(", "cached", ".", "getCacheTimestamp", "(", ")", ")", ")", ";", "if", "(", "cached", ".", "getCacheTimestamp", "(", ")", "<=", "lastTimeout", ")", "{", "invalidate", "=", "true", ";", "}", "}", "}", "if", "(", "invalidate", ")", "{", "registerUserInvalidation", "(", "realm", ",", "cached", ")", ";", "return", "getDelegate", "(", ")", ".", "getUserById", "(", "cached", ".", "getId", "(", ")", ",", "realm", ")", ";", "}", "}", "return", "new", "UserAdapter", "(", "cached", ",", "this", ",", "session", ",", "realm", ")", ";", "}"], "idx": 32938, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "a78cfa4b2ca979a1981fb371cfdf2c7212f7b6e2", "function_name": "validateCache", "body_hash": "88fd6f9baf9471c8a47a9bc70d4220f096da16ed"}
{"code": "private static @Nullable User getOrCreate(@Nonnull String id, @Nonnull String fullName, boolean create) {\n        String idkey = idStrategy().keyFor(id);\n\n        byNameLock.readLock().lock();\n        User u;\n        try {\n            u = AllUsers.byName().get(idkey);\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        final File configFile = getConfigFileFor(id);\n        if (u == null && !configFile.isFile() && !configFile.getParentFile().isDirectory()) {\n            // check for legacy users and migrate if safe to do so.\n            File[] legacy = getLegacyConfigFilesFor(id);\n            if (legacy != null && legacy.length > 0) {\n                for (File legacyUserDir : legacy) {\n                    final XmlFile legacyXml = new XmlFile(XSTREAM, new File(legacyUserDir, \"config.xml\"));\n                    try {\n                        Object o = legacyXml.read();\n                        if (o instanceof User) {\n                            if (idStrategy().equals(id, legacyUserDir.getName()) && !idStrategy().filenameOf(legacyUserDir.getName())\n                                    .equals(legacyUserDir.getName())) {\n                                if (!legacyUserDir.renameTo(configFile.getParentFile())) {\n                                    LOGGER.log(Level.WARNING, \"Failed to migrate user record from {0} to {1}\",\n                                            new Object[]{legacyUserDir, configFile.getParentFile()});\n                                }\n                                break;\n                            }\n                        } else {\n                            LOGGER.log(Level.FINE, \"Unexpected object loaded from {0}: {1}\",\n                                    new Object[]{ legacyUserDir, o });\n                        }\n                    } catch (IOException e) {\n                        LOGGER.log(Level.FINE, String.format(\"Exception trying to load user from %s: %s\",\n                                new Object[]{ legacyUserDir, e.getMessage() }), e);\n                    }\n                }\n            }\n        }\n\n        File unsanitizedLegacyConfigFile = getUnsanitizedLegacyConfigFileFor(id);\n        if (unsanitizedLegacyConfigFile.exists() && !unsanitizedLegacyConfigFile.equals(configFile)) {\n            File ancestor = unsanitizedLegacyConfigFile.getParentFile();\n            if (!configFile.exists()) {\n                try {\n                    Files.createDirectory(configFile.getParentFile().toPath());\n                    Files.move(unsanitizedLegacyConfigFile.toPath(), configFile.toPath());\n                } catch (IOException | InvalidPathException e) {\n                    LOGGER.log(\n                            Level.WARNING,\n                            String.format(\"Failed to migrate user record from %s to %s, see SECURITY-499 for more information\", idStrategy().legacyFilenameOf(id), idStrategy().filenameOf(id)),\n                            e);\n                }\n            }\n\n            // Don't clean up ancestors with other children; the directories should be cleaned up when the last child\n            // is migrated\n            File tmp = ancestor;\n            try {\n                while (!ancestor.equals(getRootDir())) {\n                    try (DirectoryStream<Path> stream = Files.newDirectoryStream(ancestor.toPath())) {\n                        if (!stream.iterator().hasNext()) {\n                            tmp = ancestor;\n                            ancestor = tmp.getParentFile();\n                            Files.deleteIfExists(tmp.toPath());\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            } catch (IOException | InvalidPathException e) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Could not delete \" + tmp + \" when cleaning up legacy user directories\", e);\n                }\n            }\n        }\n\n        if (u==null && (create || configFile.exists())) {\n            User tmp = new User(id, fullName);\n            User prev;\n            byNameLock.readLock().lock();\n            try {\n                prev = AllUsers.byName().putIfAbsent(idkey, u = tmp);\n            } finally {\n                byNameLock.readLock().unlock();\n            }\n            if (prev != null) {\n                u = prev; // if some has already put a value in the map, use it\n                if (LOGGER.isLoggable(Level.FINE) && !fullName.equals(prev.getFullName())) {\n                    LOGGER.log(Level.FINE, \"mismatch on fullName (\u2018\" + fullName + \"\u2019 vs. \u2018\" + prev.getFullName() + \"\u2019) for \u2018\" + id + \"\u2019\", new Throwable());\n                }\n            } else if (!id.equals(fullName) && !configFile.exists()) {\n                // JENKINS-16332: since the fullName may not be recoverable from the id, and various code may store the id only, we must save the fullName\n                try {\n                    u.save();\n                } catch (IOException x) {\n                    LOGGER.log(Level.WARNING, null, x);\n                }\n            }\n        }\n        return u;\n    }", "code_tokens": ["private", "static", "@", "Nullable", "User", "getOrCreate", "(", "@", "Nonnull", "String", "id", ",", "@", "Nonnull", "String", "fullName", ",", "boolean", "create", ")", "{", "String", "idkey", "=", "idStrategy", "(", ")", ".", "keyFor", "(", "id", ")", ";", "byNameLock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "User", "u", ";", "try", "{", "u", "=", "AllUsers", ".", "byName", "(", ")", ".", "get", "(", "idkey", ")", ";", "}", "finally", "{", "byNameLock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "final", "File", "configFile", "=", "getConfigFileFor", "(", "id", ")", ";", "if", "(", "u", "==", "null", "&&", "!", "configFile", ".", "isFile", "(", ")", "&&", "!", "configFile", ".", "getParentFile", "(", ")", ".", "isDirectory", "(", ")", ")", "{", "File", "[", "]", "legacy", "=", "getLegacyConfigFilesFor", "(", "id", ")", ";", "if", "(", "legacy", "!=", "null", "&&", "legacy", ".", "length", ">", "0", ")", "{", "for", "(", "File", "legacyUserDir", ":", "legacy", ")", "{", "final", "XmlFile", "legacyXml", "=", "new", "XmlFile", "(", "XSTREAM", ",", "new", "File", "(", "legacyUserDir", ",", "\"", "config.xml", "\"", ")", ")", ";", "try", "{", "Object", "o", "=", "legacyXml", ".", "read", "(", ")", ";", "if", "(", "o", "instanceof", "User", ")", "{", "if", "(", "idStrategy", "(", ")", ".", "equals", "(", "id", ",", "legacyUserDir", ".", "getName", "(", ")", ")", "&&", "!", "idStrategy", "(", ")", ".", "filenameOf", "(", "legacyUserDir", ".", "getName", "(", ")", ")", ".", "equals", "(", "legacyUserDir", ".", "getName", "(", ")", ")", ")", "{", "if", "(", "!", "legacyUserDir", ".", "renameTo", "(", "configFile", ".", "getParentFile", "(", ")", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to migrate user record from {0} to {1}", "\"", ",", "new", "Object", "[", "]", "{", "legacyUserDir", ",", "configFile", ".", "getParentFile", "(", ")", "}", ")", ";", "}", "break", ";", "}", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Unexpected object loaded from {0}: {1}", "\"", ",", "new", "Object", "[", "]", "{", "legacyUserDir", ",", "o", "}", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "String", ".", "format", "(", "\"", "Exception trying to load user from %s: %s", "\"", ",", "new", "Object", "[", "]", "{", "legacyUserDir", ",", "e", ".", "getMessage", "(", ")", "}", ")", ",", "e", ")", ";", "}", "}", "}", "}", "File", "unsanitizedLegacyConfigFile", "=", "getUnsanitizedLegacyConfigFileFor", "(", "id", ")", ";", "if", "(", "unsanitizedLegacyConfigFile", ".", "exists", "(", ")", "&&", "!", "unsanitizedLegacyConfigFile", ".", "equals", "(", "configFile", ")", ")", "{", "File", "ancestor", "=", "unsanitizedLegacyConfigFile", ".", "getParentFile", "(", ")", ";", "if", "(", "!", "configFile", ".", "exists", "(", ")", ")", "{", "try", "{", "Files", ".", "createDirectory", "(", "configFile", ".", "getParentFile", "(", ")", ".", "toPath", "(", ")", ")", ";", "Files", ".", "move", "(", "unsanitizedLegacyConfigFile", ".", "toPath", "(", ")", ",", "configFile", ".", "toPath", "(", ")", ")", ";", "}", "catch", "(", "IOException", "|", "InvalidPathException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "String", ".", "format", "(", "\"", "Failed to migrate user record from %s to %s, see SECURITY-499 for more information", "\"", ",", "idStrategy", "(", ")", ".", "legacyFilenameOf", "(", "id", ")", ",", "idStrategy", "(", ")", ".", "filenameOf", "(", "id", ")", ")", ",", "e", ")", ";", "}", "}", "File", "tmp", "=", "ancestor", ";", "try", "{", "while", "(", "!", "ancestor", ".", "equals", "(", "getRootDir", "(", ")", ")", ")", "{", "try", "(", "DirectoryStream", "<", "Path", ">", "stream", "=", "Files", ".", "newDirectoryStream", "(", "ancestor", ".", "toPath", "(", ")", ")", ")", "{", "if", "(", "!", "stream", ".", "iterator", "(", ")", ".", "hasNext", "(", ")", ")", "{", "tmp", "=", "ancestor", ";", "ancestor", "=", "tmp", ".", "getParentFile", "(", ")", ";", "Files", ".", "deleteIfExists", "(", "tmp", ".", "toPath", "(", ")", ")", ";", "}", "else", "{", "break", ";", "}", "}", "}", "}", "catch", "(", "IOException", "|", "InvalidPathException", "e", ")", "{", "if", "(", "LOGGER", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Could not delete ", "\"", "+", "tmp", "+", "\"", " when cleaning up legacy user directories", "\"", ",", "e", ")", ";", "}", "}", "}", "if", "(", "u", "==", "null", "&&", "(", "create", "||", "configFile", ".", "exists", "(", ")", ")", ")", "{", "User", "tmp", "=", "new", "User", "(", "id", ",", "fullName", ")", ";", "User", "prev", ";", "byNameLock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "try", "{", "prev", "=", "AllUsers", ".", "byName", "(", ")", ".", "putIfAbsent", "(", "idkey", ",", "u", "=", "tmp", ")", ";", "}", "finally", "{", "byNameLock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "if", "(", "prev", "!=", "null", ")", "{", "u", "=", "prev", ";", "if", "(", "LOGGER", ".", "isLoggable", "(", "Level", ".", "FINE", ")", "&&", "!", "fullName", ".", "equals", "(", "prev", ".", "getFullName", "(", ")", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "mismatch on fullName (\u2018", "\"", "+", "fullName", "+", "\"", "\u2019 vs. \u2018", "\"", "+", "prev", ".", "getFullName", "(", ")", "+", "\"", "\u2019) for \u2018", "\"", "+", "id", "+", "\"", "\u2019", "\"", ",", "new", "Throwable", "(", ")", ")", ";", "}", "}", "else", "if", "(", "!", "id", ".", "equals", "(", "fullName", ")", "&&", "!", "configFile", ".", "exists", "(", ")", ")", "{", "try", "{", "u", ".", "save", "(", ")", ";", "}", "catch", "(", "IOException", "x", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "null", ",", "x", ")", ";", "}", "}", "}", "return", "u", ";", "}"], "idx": 98807, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "5f4d014b3b7f89e206c6c8509540ed559f604959", "function_name": "getOrCreate", "body_hash": "948432891e34f01ae02a3a3d4d77b9db6d193e5e"}
{"code": "private String guard(String filename) {\n            String guarded = filename.replace(\":\", \"_\").replace(\"\\\\\", \"\").replace(\"/\", \"\");\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"guarded \" + filename + \" to \" + guarded);\n            }\n            return guarded;\n        }", "code_tokens": ["private", "String", "guard", "(", "String", "filename", ")", "{", "String", "guarded", "=", "filename", ".", "replace", "(", "\"", ":", "\"", ",", "\"", "_", "\"", ")", ".", "replace", "(", "\"", "\\\\", "\"", ",", "\"", "\"", ")", ".", "replace", "(", "\"", "/", "\"", ",", "\"", "\"", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "guarded ", "\"", "+", "filename", "+", "\"", " to ", "\"", "+", "guarded", ")", ";", "}", "return", "guarded", ";", "}"], "idx": 20891, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "729c4731574ffffaf58ebefdbaeb3bd19ed1c7b7", "function_name": "guard", "body_hash": "a924f549a6d270770d1e9e5e6bfec948236a2894"}
{"code": "@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t\t// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\t// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n\n\t\t\t// Using the SAXParserFactory's setFeature\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\t// Using the XMLReader's setFeature\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n\t\t\t// Xerces 2 only - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}", "code_tokens": ["@", "Override", "public", "ParseResults", "call", "(", ")", "{", "try", "{", "SAXParserFactory", "spf", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "SAXParser", "saxParser", "=", "spf", ".", "newSAXParser", "(", ")", ";", "XMLReader", "reader", "=", "saxParser", ".", "getXMLReader", "(", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "reader", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "saxParser", ".", "parse", "(", "xmlInputStream", ",", "handler", ")", ";", "}", "catch", "(", "SAXException", "|", "IOException", "|", "ParserConfigurationException", "e", ")", "{", "throw", "new", "ReportPortalException", "(", "ErrorType", ".", "PARSING_XML_ERROR", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "return", "new", "ParseResults", "(", "handler", ".", "getStartSuiteTime", "(", ")", ",", "handler", ".", "getCommonDuration", "(", ")", ")", ";", "}"], "idx": 69753, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "8601c9e", "function_name": "call", "body_hash": "c6b9a20a3fc7b6e21a6a8b0a5b17cd78d5f6d65e"}
{"code": "public static Document parseDocument(InputSource source) throws XMLException {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder xmlBuilder = dbf.newDocumentBuilder();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            return xmlBuilder.parse(source);\n        } catch (Exception er) {\n            throw new XMLException(\"Error parsing XML document\", er);\n        }\n    }", "code_tokens": ["public", "static", "Document", "parseDocument", "(", "InputSource", "source", ")", "throws", "XMLException", "{", "try", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "DocumentBuilder", "xmlBuilder", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "dbf", ".", "setFeature", "(", "XMLConstants", ".", "FEATURE_SECURE_PROCESSING", ",", "true", ")", ";", "return", "xmlBuilder", ".", "parse", "(", "source", ")", ";", "}", "catch", "(", "Exception", "er", ")", "{", "throw", "new", "XMLException", "(", "\"", "Error parsing XML document", "\"", ",", "er", ")", ";", "}", "}"], "idx": 66430, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "4debf8f25184b7283681ed3fb5e9e887d9d4fe22", "function_name": "parseDocument", "body_hash": "7c4d1193059b3caf4ada44d804d8efcbe52d3019"}
{"code": "public boolean matches(String pattern, String source) {\n        if (pattern == null) {\n            throw new IllegalArgumentException(\"pattern argument cannot be null.\");\n        }\n        Pattern p = Pattern.compile(pattern);\n        Matcher m = p.matcher(source);\n        return m.matches();\n    }", "code_tokens": ["public", "boolean", "matches", "(", "String", "pattern", ",", "String", "source", ")", "{", "if", "(", "pattern", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "pattern argument cannot be null.", "\"", ")", ";", "}", "Pattern", "p", "=", "Pattern", ".", "compile", "(", "pattern", ")", ";", "Matcher", "m", "=", "p", ".", "matcher", "(", "source", ")", ";", "return", "m", ".", "matches", "(", ")", ";", "}"], "idx": 86552, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "6bcb92e06fa588b9c7790dd01bc02135d58d3f5b", "function_name": "matches", "body_hash": "ef55117e9b43ca4e0d7788c5de97af6ab217f8a8"}
{"code": "private void doTestRewrite(String config, String request, String expectedURI,\n            String expectedQueryString, String expectedAttributeValue) throws Exception {\n\n        Tomcat tomcat = getTomcatInstance();\n\n        // No file system docBase required\n        Context ctx = tomcat.addContext(\"\", null);\n\n        RewriteValve rewriteValve = new RewriteValve();\n        ctx.getPipeline().addValve(rewriteValve);\n\n        rewriteValve.setConfiguration(config);\n\n        Tomcat.addServlet(ctx, \"snoop\", new SnoopServlet());\n        ctx.addServletMappingDecoded(\"/a/%5A\", \"snoop\");\n        ctx.addServletMappingDecoded(\"/c/*\", \"snoop\");\n        Tomcat.addServlet(ctx, \"default\", new DefaultServlet());\n        ctx.addServletMappingDecoded(\"/\", \"default\");\n\n        tomcat.start();\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() + request, res, null);\n        res.setCharset(StandardCharsets.UTF_8);\n\n        if (expectedURI == null) {\n            // Rewrite is expected to fail. Probably because invalid characters\n            // were written into the request target\n            Assert.assertEquals(400, rc);\n        } else {\n            String body = res.toString();\n            RequestDescriptor requestDesc = SnoopResult.parse(body);\n            String requestURI = requestDesc.getRequestInfo(\"REQUEST-URI\");\n            Assert.assertEquals(expectedURI, requestURI);\n\n            if (expectedQueryString != null) {\n                String queryString = requestDesc.getRequestInfo(\"REQUEST-QUERY-STRING\");\n                Assert.assertEquals(expectedQueryString, queryString);\n            }\n\n            if (expectedAttributeValue != null) {\n                String attributeValue = requestDesc.getAttribute(\"X-Test\");\n                Assert.assertEquals(expectedAttributeValue, attributeValue);\n            }\n        }\n    }", "code_tokens": ["private", "void", "doTestRewrite", "(", "String", "config", ",", "String", "request", ",", "String", "expectedURI", ",", "String", "expectedQueryString", ",", "String", "expectedAttributeValue", ")", "throws", "Exception", "{", "Tomcat", "tomcat", "=", "getTomcatInstance", "(", ")", ";", "Context", "ctx", "=", "tomcat", ".", "addContext", "(", "\"", "\"", ",", "null", ")", ";", "RewriteValve", "rewriteValve", "=", "new", "RewriteValve", "(", ")", ";", "ctx", ".", "getPipeline", "(", ")", ".", "addValve", "(", "rewriteValve", ")", ";", "rewriteValve", ".", "setConfiguration", "(", "config", ")", ";", "Tomcat", ".", "addServlet", "(", "ctx", ",", "\"", "snoop", "\"", ",", "new", "SnoopServlet", "(", ")", ")", ";", "ctx", ".", "addServletMappingDecoded", "(", "\"", "/a/%5A", "\"", ",", "\"", "snoop", "\"", ")", ";", "ctx", ".", "addServletMappingDecoded", "(", "\"", "/c/*", "\"", ",", "\"", "snoop", "\"", ")", ";", "Tomcat", ".", "addServlet", "(", "ctx", ",", "\"", "default", "\"", ",", "new", "DefaultServlet", "(", ")", ")", ";", "ctx", ".", "addServletMappingDecoded", "(", "\"", "/", "\"", ",", "\"", "default", "\"", ")", ";", "tomcat", ".", "start", "(", ")", ";", "ByteChunk", "res", "=", "new", "ByteChunk", "(", ")", ";", "int", "rc", "=", "getUrl", "(", "\"", "http://localhost:", "\"", "+", "getPort", "(", ")", "+", "request", ",", "res", ",", "null", ")", ";", "res", ".", "setCharset", "(", "StandardCharsets", ".", "UTF_8", ")", ";", "if", "(", "expectedURI", "==", "null", ")", "{", "Assert", ".", "assertEquals", "(", "400", ",", "rc", ")", ";", "}", "else", "{", "String", "body", "=", "res", ".", "toString", "(", ")", ";", "RequestDescriptor", "requestDesc", "=", "SnoopResult", ".", "parse", "(", "body", ")", ";", "String", "requestURI", "=", "requestDesc", ".", "getRequestInfo", "(", "\"", "REQUEST-URI", "\"", ")", ";", "Assert", ".", "assertEquals", "(", "expectedURI", ",", "requestURI", ")", ";", "if", "(", "expectedQueryString", "!=", "null", ")", "{", "String", "queryString", "=", "requestDesc", ".", "getRequestInfo", "(", "\"", "REQUEST-QUERY-STRING", "\"", ")", ";", "Assert", ".", "assertEquals", "(", "expectedQueryString", ",", "queryString", ")", ";", "}", "if", "(", "expectedAttributeValue", "!=", "null", ")", "{", "String", "attributeValue", "=", "requestDesc", ".", "getAttribute", "(", "\"", "X-Test", "\"", ")", ";", "Assert", ".", "assertEquals", "(", "expectedAttributeValue", ",", "attributeValue", ")", ";", "}", "}", "}"], "idx": 11922, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "779d5d34e68e50d2f721897050b147106992f566", "function_name": "doTestRewrite", "body_hash": "32b1121082722fd846803d8ffab15a536719a59c"}
{"code": "private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    // The callers of this decode will have already handled 'none' if it was deemed to be valid based upon\n    // the provided verifiers. At this point, if we have a 'none' algorithm specified in the header, it is invalid.\n    if (header.algorithm == Algorithm.none) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }", "code_tokens": ["private", "JWT", "decode", "(", "String", "encodedJWT", ",", "Header", "header", ",", "String", "[", "]", "parts", ",", "Verifier", "verifier", ")", "{", "if", "(", "header", ".", "algorithm", "==", "Algorithm", ".", "none", ")", "{", "throw", "new", "MissingVerifierException", "(", "\"", "No Verifier has been provided for verify a signature signed using [", "\"", "+", "header", ".", "algorithm", ".", "getName", "(", ")", "+", "\"", "]", "\"", ")", ";", "}", "if", "(", "parts", ".", "length", "==", "3", "&&", "verifier", "==", "null", ")", "{", "throw", "new", "MissingVerifierException", "(", "\"", "No Verifier has been provided for verify a signature signed using [", "\"", "+", "header", ".", "algorithm", ".", "getName", "(", ")", "+", "\"", "]", "\"", ")", ";", "}", "if", "(", "parts", ".", "length", "==", "2", "&&", "verifier", "!=", "null", ")", "{", "throw", "new", "InvalidJWTSignatureException", "(", ")", ";", "}", "int", "index", "=", "encodedJWT", ".", "lastIndexOf", "(", "\"", ".", "\"", ")", ";", "byte", "[", "]", "message", "=", "encodedJWT", ".", "substring", "(", "0", ",", "index", ")", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ";", "if", "(", "parts", ".", "length", "==", "3", ")", "{", "byte", "[", "]", "signature", "=", "base64Decode", "(", "parts", "[", "2", "]", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ")", ";", "verifier", ".", "verify", "(", "header", ".", "algorithm", ",", "message", ",", "signature", ")", ";", "}", "JWT", "jwt", "=", "Mapper", ".", "deserialize", "(", "base64Decode", "(", "parts", "[", "1", "]", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ")", ",", "JWT", ".", "class", ")", ";", "if", "(", "jwt", ".", "isExpired", "(", ")", ")", "{", "throw", "new", "JWTExpiredException", "(", ")", ";", "}", "if", "(", "jwt", ".", "isUnavailableForProcessing", "(", ")", ")", "{", "throw", "new", "JWTUnavailableForProcessingException", "(", ")", ";", "}", "return", "jwt", ";", "}"], "idx": 11734, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "abb0d479389a2509f939452a6767dc424bb5e6ba", "function_name": "decode", "body_hash": "b1d97ae0d13140f88ce206dc6b194613054da7d7"}
{"code": "public static void enableDefaultTyping(ObjectMapper mapper) {\n\t\tif(mapper != null) {\n\t\t\tTypeResolverBuilder<?> typeBuilder = mapper.getDeserializationConfig().getDefaultTyper(null);\n\t\t\tif (typeBuilder == null) {\n\t\t\t\tmapper.setDefaultTyping(createWhitelistedDefaultTyping());\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["public", "static", "void", "enableDefaultTyping", "(", "ObjectMapper", "mapper", ")", "{", "if", "(", "mapper", "!=", "null", ")", "{", "TypeResolverBuilder", "<", "?", ">", "typeBuilder", "=", "mapper", ".", "getDeserializationConfig", "(", ")", ".", "getDefaultTyper", "(", "null", ")", ";", "if", "(", "typeBuilder", "==", "null", ")", "{", "mapper", ".", "setDefaultTyping", "(", "createWhitelistedDefaultTyping", "(", ")", ")", ";", "}", "}", "}"], "idx": 59035, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "5dee8534cd1b92952d10cc56335b5d5856f48f3b", "function_name": "enableDefaultTyping", "body_hash": "6ed566fa99144dbe3bbd114eb9891b59fd5e4a33"}
{"code": "@Override\n    public HttpContent getContent(String pathInContext,int maxBufferSize)\n        throws IOException\n    {\n        try\n        {\n            // try loading the content from our factory.\n            Resource resource = _factory.getResource(pathInContext);\n            HttpContent loaded = load(pathInContext, resource, maxBufferSize);\n            return loaded;\n        }\n        catch (Throwable t)\n        {\n            // Any error has potential to reveal fully qualified path\n            throw (InvalidPathException) new InvalidPathException(pathInContext, \"Invalid PathInContext\").initCause(t);\n        }\n    }", "code_tokens": ["@", "Override", "public", "HttpContent", "getContent", "(", "String", "pathInContext", ",", "int", "maxBufferSize", ")", "throws", "IOException", "{", "try", "{", "Resource", "resource", "=", "_factory", ".", "getResource", "(", "pathInContext", ")", ";", "HttpContent", "loaded", "=", "load", "(", "pathInContext", ",", "resource", ",", "maxBufferSize", ")", ";", "return", "loaded", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "throw", "(", "InvalidPathException", ")", "new", "InvalidPathException", "(", "pathInContext", ",", "\"", "Invalid PathInContext", "\"", ")", ".", "initCause", "(", "t", ")", ";", "}", "}"], "idx": 101962, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "a51920d650d924cc2cea011995624b394437c6e", "function_name": "getContent", "body_hash": "27522601bff35fc8abc8485e23aaef1cf5d086ca"}
{"code": "protected Object getHandlerInternal(HttpServletRequest request) throws Exception {\n        Object object = super.getHandlerInternal(request);\n\n        if (object instanceof String) {\n            String handlerName = (String) object;\n            object = getApplicationContext().getBean(handlerName);\n        }\n        if (object instanceof HandlerExecutionChain) {\n            HandlerExecutionChain handlerExecutionChain = (HandlerExecutionChain) object;\n            object = handlerExecutionChain.getHandler();\n        }\n\n        if (object != null) {\n            ServletRequestDataBinder binder = new ServletRequestDataBinder(object, \"request\");\n            try {\n                binder.bind(request);\n                binder.setIgnoreUnknownFields(true);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Bound POJO is now: \" + object);\n                }\n            }\n            catch (Exception e) {\n                LOG.warn(\"Caught: \" + e, e);\n                throw e;\n            }\n        }\n        return object;\n    }", "code_tokens": ["protected", "Object", "getHandlerInternal", "(", "HttpServletRequest", "request", ")", "throws", "Exception", "{", "Object", "object", "=", "super", ".", "getHandlerInternal", "(", "request", ")", ";", "if", "(", "object", "instanceof", "String", ")", "{", "String", "handlerName", "=", "(", "String", ")", "object", ";", "object", "=", "getApplicationContext", "(", ")", ".", "getBean", "(", "handlerName", ")", ";", "}", "if", "(", "object", "instanceof", "HandlerExecutionChain", ")", "{", "HandlerExecutionChain", "handlerExecutionChain", "=", "(", "HandlerExecutionChain", ")", "object", ";", "object", "=", "handlerExecutionChain", ".", "getHandler", "(", ")", ";", "}", "if", "(", "object", "!=", "null", ")", "{", "ServletRequestDataBinder", "binder", "=", "new", "ServletRequestDataBinder", "(", "object", ",", "\"", "request", "\"", ")", ";", "try", "{", "binder", ".", "bind", "(", "request", ")", ";", "binder", ".", "setIgnoreUnknownFields", "(", "true", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Bound POJO is now: ", "\"", "+", "object", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Caught: ", "\"", "+", "e", ",", "e", ")", ";", "throw", "e", ";", "}", "}", "return", "object", ";", "}"], "idx": 43807, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "1f464b9412e1b1c08d40c8ffac40edd52731da48", "function_name": "getHandlerInternal", "body_hash": "82733c77994dc6967b5ab13b12ff22d1735e1565"}
{"code": "@Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (origin != null) {\n            sb.append(\"remoteAddress=\").append(origin);\n        }\n        if (clientId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"clientId=\").append(clientId);\n        }\n        return sb.toString();\n    }", "code_tokens": ["@", "Override", "public", "String", "toString", "(", ")", "{", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", ")", ";", "if", "(", "origin", "!=", "null", ")", "{", "sb", ".", "append", "(", "\"", "remoteAddress=", "\"", ")", ".", "append", "(", "origin", ")", ";", "}", "if", "(", "clientId", "!=", "null", ")", "{", "if", "(", "sb", ".", "length", "(", ")", ">", "0", ")", "{", "sb", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "sb", ".", "append", "(", "\"", "clientId=", "\"", ")", ".", "append", "(", "clientId", ")", ";", "}", "return", "sb", ".", "toString", "(", ")", ";", "}"], "idx": 18722, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "a61bfabbad22f646ecf1f00016b448b26a60daf", "function_name": "toString", "body_hash": "18a57f77843913a964304a2800d0edfc08461a3f"}
{"code": "@RequirePOST\n        public HttpResponse doPostCredential(@QueryParameter String username, @QueryParameter String password) throws IOException, ServletException {\n            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n            this.username = username;\n            this.password = Secret.fromString(password);\n            save();\n            return HttpResponses.redirectTo(\"credentialOK\");\n        }", "code_tokens": ["@", "RequirePOST", "public", "HttpResponse", "doPostCredential", "(", "@", "QueryParameter", "String", "username", ",", "@", "QueryParameter", "String", "password", ")", "throws", "IOException", ",", "ServletException", "{", "Jenkins", ".", "getInstance", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "this", ".", "username", "=", "username", ";", "this", ".", "password", "=", "Secret", ".", "fromString", "(", "password", ")", ";", "save", "(", ")", ";", "return", "HttpResponses", ".", "redirectTo", "(", "\"", "credentialOK", "\"", ")", ";", "}"], "idx": 72677, "cwe": "CWE-732", "target": 0, "status": "FIXED", "commit": "b0ed9669bc00dbccf1be6896bb527b4cf2e7687d", "function_name": "doPostCredential", "body_hash": "d607378b37fafbd1cd379d4ab49903b94b596400"}
{"code": "protected void authenticatorConfig() {\n\n        LoginConfig loginConfig = context.getLoginConfig();\n\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null || constraints.length ==0) &&\n                !context.getPreemptiveAuthentication())  {\n            // No need for an authenticator\n            return;\n        } else {\n            if (loginConfig == null) {\n                // Security constraints present. Need an authenticator to\n                // support them.\n                loginConfig = DUMMY_LOGIN_CONFIG;\n                context.setLoginConfig(loginConfig);\n            }\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null) {\n            return;\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve) customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n\n        if (authenticator == null) {\n            if (authenticators == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorResources\"));\n                ok = false;\n                return;\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.getConstructor().newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null) {\n            Pipeline pipeline = context.getPipeline();\n            if (pipeline != null) {\n                pipeline.addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "authenticatorConfig", "(", ")", "{", "LoginConfig", "loginConfig", "=", "context", ".", "getLoginConfig", "(", ")", ";", "SecurityConstraint", "constraints", "[", "]", "=", "context", ".", "findConstraints", "(", ")", ";", "if", "(", "(", "constraints", "==", "null", "||", "constraints", ".", "length", "==", "0", ")", "&&", "!", "context", ".", "getPreemptiveAuthentication", "(", ")", ")", "{", "return", ";", "}", "else", "{", "if", "(", "loginConfig", "==", "null", ")", "{", "loginConfig", "=", "DUMMY_LOGIN_CONFIG", ";", "context", ".", "setLoginConfig", "(", "loginConfig", ")", ";", "}", "}", "if", "(", "context", ".", "getAuthenticator", "(", ")", "!=", "null", ")", "{", "return", ";", "}", "if", "(", "context", ".", "getRealm", "(", ")", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.missingRealm", "\"", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "Valve", "authenticator", "=", "null", ";", "if", "(", "customAuthenticators", "!=", "null", ")", "{", "authenticator", "=", "(", "Valve", ")", "customAuthenticators", ".", "get", "(", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ";", "}", "if", "(", "authenticator", "==", "null", ")", "{", "if", "(", "authenticators", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorResources", "\"", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "String", "authenticatorName", "=", "authenticators", ".", "getProperty", "(", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ";", "if", "(", "authenticatorName", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorMissing", "\"", ",", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "try", "{", "Class", "<", "?", ">", "authenticatorClass", "=", "Class", ".", "forName", "(", "authenticatorName", ")", ";", "authenticator", "=", "(", "Valve", ")", "authenticatorClass", ".", "getConstructor", "(", ")", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "t", ")", ";", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorInstantiate", "\"", ",", "authenticatorName", ")", ",", "t", ")", ";", "ok", "=", "false", ";", "}", "}", "if", "(", "authenticator", "!=", "null", ")", "{", "Pipeline", "pipeline", "=", "context", ".", "getPipeline", "(", ")", ";", "if", "(", "pipeline", "!=", "null", ")", "{", "pipeline", ".", "addValve", "(", "authenticator", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorConfigured", "\"", ",", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ")", ";", "}", "}", "}", "}"], "idx": 100470, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "4d637bc3986e5d09b9363e2144b8ba74fa6eac3a", "function_name": "authenticatorConfig", "body_hash": "3906a6a395f6c49a84fda44b315292d603319583"}
{"code": "@Override\n    protected void onSuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, Authentication authResult) throws IOException {\n        super.onSuccessfulAuthentication(request,response,authResult);\n        // make sure we have a session to store this successful authentication, given that we no longer\n        // let HttpSessionContextIntegrationFilter2 to create sessions.\n        // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later\n        // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its\n        // doFilter method.\n        request.getSession();\n    }", "code_tokens": ["@", "Override", "protected", "void", "onSuccessfulAuthentication", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Authentication", "authResult", ")", "throws", "IOException", "{", "super", ".", "onSuccessfulAuthentication", "(", "request", ",", "response", ",", "authResult", ")", ";", "request", ".", "getSession", "(", ")", ";", "}"], "idx": 38627, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "8ac74c350779921598f9d5edfed39dd35de8842a", "function_name": "onSuccessfulAuthentication", "body_hash": "04de242ed3322a14e5992bff56a24db78360f861"}
{"code": "protected void traceLdapEnv(Properties env)\n   {\n      if (trace)\n      {\n         Properties tmp = new Properties();\n         tmp.putAll(env);\n         String credentials = tmp.getProperty(Context.SECURITY_CREDENTIALS);\n         String bindCredential = tmp.getProperty(BIND_CREDENTIAL);\n         \n         if (credentials != null && credentials.length() > 0) {\n        \t tmp.setProperty(Context.SECURITY_CREDENTIALS, \"***\");\n         }\n            \n         if (bindCredential != null && bindCredential.length() > 0) {\n        \t tmp.setProperty(BIND_CREDENTIAL, \"***\");\n         }\n         \n         log.trace(\"Logging into LDAP server, env=\" + tmp.toString());\n      }\n   }", "code_tokens": ["protected", "void", "traceLdapEnv", "(", "Properties", "env", ")", "{", "if", "(", "trace", ")", "{", "Properties", "tmp", "=", "new", "Properties", "(", ")", ";", "tmp", ".", "putAll", "(", "env", ")", ";", "String", "credentials", "=", "tmp", ".", "getProperty", "(", "Context", ".", "SECURITY_CREDENTIALS", ")", ";", "String", "bindCredential", "=", "tmp", ".", "getProperty", "(", "BIND_CREDENTIAL", ")", ";", "if", "(", "credentials", "!=", "null", "&&", "credentials", ".", "length", "(", ")", ">", "0", ")", "{", "tmp", ".", "setProperty", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "\"", "***", "\"", ")", ";", "}", "if", "(", "bindCredential", "!=", "null", "&&", "bindCredential", ".", "length", "(", ")", ">", "0", ")", "{", "tmp", ".", "setProperty", "(", "BIND_CREDENTIAL", ",", "\"", "***", "\"", ")", ";", "}", "log", ".", "trace", "(", "\"", "Logging into LDAP server, env=", "\"", "+", "tmp", ".", "toString", "(", ")", ")", ";", "}", "}"], "idx": 18067, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "0dc9d191b6eb1d13b8f0189c5b02ba6576f4722e", "function_name": "traceLdapEnv", "body_hash": "1576983c865b3ef7ceaf5fdcd2efc111ecfbf325"}
{"code": "@Override\n\tpublic Environment setUp(@SuppressWarnings(\"rawtypes\")AbstractBuild build, Launcher launcher,\n\t\t\tfinal BuildListener listener) throws IOException, InterruptedException\n\t{\n\t\tDescriptorImpl DESCRIPTOR = Hudson.getInstance().getDescriptorByType(DescriptorImpl.class);\n\t\tString vnc2swf = Util.nullify(DESCRIPTOR.getVnc2swf());\n\t\tif(vnc2swf.equals(CANT_FIND_VNC2SWF))\n\t\t{\n\t\t\tlistener.fatalError(\"VNC Recorder: can't find 'vnc2swf' please check your jenkins global settings!\");\n\t\t\treturn null;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tFile vnc2swfFile = new File(vnc2swf);\n\t\t\tif (!vnc2swfFile.exists())\n\t\t\t{\n\t\t\t\tlistener.fatalError(\"VNC Recorder: can't find '\" + vnc2swf + \"' please check your jenkins global settings!\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tfinal VncRecorder vr = new VncRecorder();\n\t\tvr.setLoggingStream(listener.getLogger());\n//\t\tfinal Logger vncLogger = vr.getLoggerForPrintStream(listener.getLogger());\n\t\tif (!SystemUtils.IS_OS_UNIX)\n\t\t{\n\t\t\tlistener.fatalError(\"Feature \\\"Record VNC session\\\" works only under Unix/Linux!\");\n\t\t\treturn null;\n\t\t}\n\t\tString vncServReplaced = Util.replaceMacro(vncServ,build.getEnvironment(listener));\n\t\tif (vncServReplaced.indexOf(\":\") > 0 && vncServReplaced.split(\":\")[1].length() == 4 && vncServReplaced.split(\":\")[1].startsWith(\"59\") )\n\t\t{\n\t\t\tvncServReplaced = vncServReplaced.replace(\":59\", \":\");\n\t\t}\n\t\t\n\t\tString vncPasswFilePathReplaced = Util.replaceMacro(vncPasswFilePath,build.getEnvironment(listener));\n\t\t//String outFileBase = build.getEnvironment(listener).get(\"JOB_NAME\") + \"_\" +  build.getEnvironment(listener).get(\"BUILD_NUMBER\") + \".swf\";\n\t\tif (outFileName == null || outFileName.equalsIgnoreCase(\"null\"))\n\t\t{\n\t\t\toutFileName = \"${JOB_NAME}_${BUILD_NUMBER}\";\n\t\t}\n\t\tString outFileBase =  Util.replaceMacro(outFileName,build.getEnvironment(listener)) + \".swf\";\n\t\tlistener.getLogger().println(\"Recording from vnc server: \" + vncServReplaced);\n\t\tlistener.getLogger().println(\"Using vnc passwd file: \" + vncPasswFilePathReplaced);\n\t\t//\t\tlistener.getLogger().printf(\"Using vnc passwd file: %s\\n\",vncPasswFilePath);\t\n\n\n\t\tFile vncPasswFile = new File(vncPasswFilePathReplaced);\n\t\tif (vncPasswFilePathReplaced.isEmpty())\n\t\t{\n\t\t\tlistener.getLogger().println(\"VNC password file is an empty string, trying vnc connection without password\");\n\t\t\tvncPasswFile = null;\n\t\t}\n\t\telse if (!vncPasswFile.exists())\n\t\t{\n\t\t\tlistener.getLogger().println(\"Can't find \" +vncPasswFile  +\", trying vnc connection without password \");\n\t\t\tvncPasswFile = null;\n\t\t}\n\n\t\tFile artifactsDir = build.getArtifactsDir();\n\t\tlistener.getLogger().print(build.getUrl());\n\t\tif(!artifactsDir.exists())\n\t\t{\n\t\t\tif (!artifactsDir.mkdir())\n\t\t\t{\n\t\t\t  listener.error(\"Can't create \" + artifactsDir.getAbsolutePath());\n\t\t\t}\n\t\t}\n\n\t\tif (outFileBase == null || outFileBase.equalsIgnoreCase(\"null.swf\"))\n\t\t{\n\t\t\toutFileBase = build.getNumber() + \".swf\";\n\n\t\t}\n\t\tfinal File outFileSwf = new File(artifactsDir,outFileBase); \n\t\tfinal File outFileHtml = new File(outFileSwf.getAbsolutePath().replace(\".swf\", \".html\"));\n\n\t\tfinal Date from = new Date();\n\t\tfinal Future<Integer> recordState = vr.record(vncServReplaced, outFileSwf.getAbsolutePath(), vncPasswFile,vnc2swf);\n\n\t\treturn new Environment() {\n\t\t\t@Override\n\t\t\tpublic void buildEnvVars(Map<String, String> env) {\n\t\t\t\t//\t\t\t\tenv.put(\"PATH\",env.get(\"PATH\"));\n\t\t\t\t//\t\t\t\tenv.put(\"DISPLAY\", vncServ);\n\t\t\t\tif (setDisplay && env != null && vncServ != null)\n\t\t\t\t\tenv.put(\"DISPLAY\",Util.replaceMacro(vncServ,env));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean tearDown(AbstractBuild build, BuildListener listener)\n\t\t\t\t\tthrows IOException, InterruptedException {\n\t\t\t\tfinal Date to = new Date();\n\t\t\t\tif (recordState != null)\n\t\t\t\t{\t\n\t\t\t\t\trecordState.cancel(true);\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\t\t\t\tif (removeIfSuccessful == null)\n\t\t\t\t\tremoveIfSuccessful = false;\n\n\n\t\t\t\tif ((removeIfSuccessful && outFileSwf.exists()) && (build == null || build.getResult() == Result.SUCCESS || build.getResult() == null)  )\n\t\t\t\t{\n\t\t\t\t\tlistener.getLogger().println(\"Build successful: Removing video file \" + outFileSwf.getAbsolutePath() + \" \\n\");\n\t\t\t\t\t\n\t\t\t\t\tif(!outFileSwf.delete())\n\t\t\t\t\t listener.error(\"Can't delete \" + outFileSwf.getAbsolutePath());\n\t\t\t\t\t\n\t\t\t\t\tif(!outFileHtml.delete())\n\t                     listener.error(\"Can't delete \" + outFileHtml.getAbsolutePath());\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (!outFileSwf.exists())\n\t\t\t\t{\n\t\t\t\t\tlistener.error(\"File \" + outFileSwf.getAbsolutePath() +\" doesn't exist. \\nFeature \\\"Record VNC session\\\" failed!\");\n\t\t\t\t\tif (failJobIfFailed)\n\t\t\t\t\t    return false;\n\t\t\t\t\telse\n\t\t\t\t\t  return true;\n\t\t\t\t}  \n\n\n\t\t\t\tSimpleDateFormat sf = new SimpleDateFormat(\"yyyy-MM-dd 'T' HH:mm:ss\");\n\t\t\t\tlistener.hyperlink(\"artifact/\" + outFileHtml.getName(),\"Video from \" + sf.format(from) + \" to \" + sf.format(to));\n\t\t\t\tlistener.getLogger().print(\"\\n\");\n\t\t\t\t//\t\t\t\t\tString con = com.google.common.io.Files.toString(outFileHtml, Charset.forName(\"utf-8\"));\n\t\t\t\t//\t\t\t\t\tcon = con.replaceAll(\"<embed src=\\\"\"+ outFileSwf.getName() +\"\\\"\", \"<embed src=\\\"\"+ \"artifact/\" + outFileSwf.getName()  +\"\\\"\");\n\t\t\t\t//\t\t\t\t\tExpandableDetailsNote dn = new ExpandableDetailsNote(new Date().toString(),con);\n\t\t\t\t//\t\t\t\t\tlistener.annotate(dn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\t}", "code_tokens": ["@", "Override", "public", "Environment", "setUp", "(", "@", "SuppressWarnings", "(", "\"", "rawtypes", "\"", ")", "AbstractBuild", "build", ",", "Launcher", "launcher", ",", "final", "BuildListener", "listener", ")", "throws", "IOException", ",", "InterruptedException", "{", "DescriptorImpl", "DESCRIPTOR", "=", "Hudson", ".", "getInstance", "(", ")", ".", "getDescriptorByType", "(", "DescriptorImpl", ".", "class", ")", ";", "String", "vnc2swf", "=", "Util", ".", "nullify", "(", "DESCRIPTOR", ".", "getVnc2swf", "(", ")", ")", ";", "if", "(", "vnc2swf", ".", "equals", "(", "CANT_FIND_VNC2SWF", ")", ")", "{", "listener", ".", "fatalError", "(", "\"", "VNC Recorder: can't find 'vnc2swf' please check your jenkins global settings!", "\"", ")", ";", "return", "null", ";", "}", "else", "{", "File", "vnc2swfFile", "=", "new", "File", "(", "vnc2swf", ")", ";", "if", "(", "!", "vnc2swfFile", ".", "exists", "(", ")", ")", "{", "listener", ".", "fatalError", "(", "\"", "VNC Recorder: can't find '", "\"", "+", "vnc2swf", "+", "\"", "' please check your jenkins global settings!", "\"", ")", ";", "return", "null", ";", "}", "}", "final", "VncRecorder", "vr", "=", "new", "VncRecorder", "(", ")", ";", "vr", ".", "setLoggingStream", "(", "listener", ".", "getLogger", "(", ")", ")", ";", "if", "(", "!", "SystemUtils", ".", "IS_OS_UNIX", ")", "{", "listener", ".", "fatalError", "(", "\"", "Feature ", "\\\"", "Record VNC session", "\\\"", " works only under Unix/Linux!", "\"", ")", ";", "return", "null", ";", "}", "String", "vncServReplaced", "=", "Util", ".", "replaceMacro", "(", "vncServ", ",", "build", ".", "getEnvironment", "(", "listener", ")", ")", ";", "if", "(", "vncServReplaced", ".", "indexOf", "(", "\"", ":", "\"", ")", ">", "0", "&&", "vncServReplaced", ".", "split", "(", "\"", ":", "\"", ")", "[", "1", "]", ".", "length", "(", ")", "==", "4", "&&", "vncServReplaced", ".", "split", "(", "\"", ":", "\"", ")", "[", "1", "]", ".", "startsWith", "(", "\"", "59", "\"", ")", ")", "{", "vncServReplaced", "=", "vncServReplaced", ".", "replace", "(", "\"", ":59", "\"", ",", "\"", ":", "\"", ")", ";", "}", "String", "vncPasswFilePathReplaced", "=", "Util", ".", "replaceMacro", "(", "vncPasswFilePath", ",", "build", ".", "getEnvironment", "(", "listener", ")", ")", ";", "if", "(", "outFileName", "==", "null", "||", "outFileName", ".", "equalsIgnoreCase", "(", "\"", "null", "\"", ")", ")", "{", "outFileName", "=", "\"", "${JOB_NAME}_${BUILD_NUMBER}", "\"", ";", "}", "String", "outFileBase", "=", "Util", ".", "replaceMacro", "(", "outFileName", ",", "build", ".", "getEnvironment", "(", "listener", ")", ")", "+", "\"", ".swf", "\"", ";", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Recording from vnc server: ", "\"", "+", "vncServReplaced", ")", ";", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Using vnc passwd file: ", "\"", "+", "vncPasswFilePathReplaced", ")", ";", "File", "vncPasswFile", "=", "new", "File", "(", "vncPasswFilePathReplaced", ")", ";", "if", "(", "vncPasswFilePathReplaced", ".", "isEmpty", "(", ")", ")", "{", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "VNC password file is an empty string, trying vnc connection without password", "\"", ")", ";", "vncPasswFile", "=", "null", ";", "}", "else", "if", "(", "!", "vncPasswFile", ".", "exists", "(", ")", ")", "{", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Can't find ", "\"", "+", "vncPasswFile", "+", "\"", ", trying vnc connection without password ", "\"", ")", ";", "vncPasswFile", "=", "null", ";", "}", "File", "artifactsDir", "=", "build", ".", "getArtifactsDir", "(", ")", ";", "listener", ".", "getLogger", "(", ")", ".", "print", "(", "build", ".", "getUrl", "(", ")", ")", ";", "if", "(", "!", "artifactsDir", ".", "exists", "(", ")", ")", "{", "if", "(", "!", "artifactsDir", ".", "mkdir", "(", ")", ")", "{", "listener", ".", "error", "(", "\"", "Can't create ", "\"", "+", "artifactsDir", ".", "getAbsolutePath", "(", ")", ")", ";", "}", "}", "if", "(", "outFileBase", "==", "null", "||", "outFileBase", ".", "equalsIgnoreCase", "(", "\"", "null.swf", "\"", ")", ")", "{", "outFileBase", "=", "build", ".", "getNumber", "(", ")", "+", "\"", ".swf", "\"", ";", "}", "final", "File", "outFileSwf", "=", "new", "File", "(", "artifactsDir", ",", "outFileBase", ")", ";", "final", "File", "outFileHtml", "=", "new", "File", "(", "outFileSwf", ".", "getAbsolutePath", "(", ")", ".", "replace", "(", "\"", ".swf", "\"", ",", "\"", ".html", "\"", ")", ")", ";", "final", "Date", "from", "=", "new", "Date", "(", ")", ";", "final", "Future", "<", "Integer", ">", "recordState", "=", "vr", ".", "record", "(", "vncServReplaced", ",", "outFileSwf", ".", "getAbsolutePath", "(", ")", ",", "vncPasswFile", ",", "vnc2swf", ")", ";", "return", "new", "Environment", "(", ")", "{", "@", "Override", "public", "void", "buildEnvVars", "(", "Map", "<", "String", ",", "String", ">", "env", ")", "{", "if", "(", "setDisplay", "&&", "env", "!=", "null", "&&", "vncServ", "!=", "null", ")", "env", ".", "put", "(", "\"", "DISPLAY", "\"", ",", "Util", ".", "replaceMacro", "(", "vncServ", ",", "env", ")", ")", ";", "}", "@", "Override", "public", "boolean", "tearDown", "(", "AbstractBuild", "build", ",", "BuildListener", "listener", ")", "throws", "IOException", ",", "InterruptedException", "{", "final", "Date", "to", "=", "new", "Date", "(", ")", ";", "if", "(", "recordState", "!=", "null", ")", "{", "recordState", ".", "cancel", "(", "true", ")", ";", "Thread", ".", "sleep", "(", "1000", ")", ";", "}", "if", "(", "removeIfSuccessful", "==", "null", ")", "removeIfSuccessful", "=", "false", ";", "if", "(", "(", "removeIfSuccessful", "&&", "outFileSwf", ".", "exists", "(", ")", ")", "&&", "(", "build", "==", "null", "||", "build", ".", "getResult", "(", ")", "==", "Result", ".", "SUCCESS", "||", "build", ".", "getResult", "(", ")", "==", "null", ")", ")", "{", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Build successful: Removing video file ", "\"", "+", "outFileSwf", ".", "getAbsolutePath", "(", ")", "+", "\"", " ", "\\n", "\"", ")", ";", "if", "(", "!", "outFileSwf", ".", "delete", "(", ")", ")", "listener", ".", "error", "(", "\"", "Can't delete ", "\"", "+", "outFileSwf", ".", "getAbsolutePath", "(", ")", ")", ";", "if", "(", "!", "outFileHtml", ".", "delete", "(", ")", ")", "listener", ".", "error", "(", "\"", "Can't delete ", "\"", "+", "outFileHtml", ".", "getAbsolutePath", "(", ")", ")", ";", "return", "true", ";", "}", "if", "(", "!", "outFileSwf", ".", "exists", "(", ")", ")", "{", "listener", ".", "error", "(", "\"", "File ", "\"", "+", "outFileSwf", ".", "getAbsolutePath", "(", ")", "+", "\"", " doesn't exist. ", "\\n", "Feature ", "\\\"", "Record VNC session", "\\\"", " failed!", "\"", ")", ";", "if", "(", "failJobIfFailed", ")", "return", "false", ";", "else", "return", "true", ";", "}", "SimpleDateFormat", "sf", "=", "new", "SimpleDateFormat", "(", "\"", "yyyy-MM-dd 'T' HH:mm:ss", "\"", ")", ";", "listener", ".", "hyperlink", "(", "\"", "artifact/", "\"", "+", "outFileHtml", ".", "getName", "(", ")", ",", "\"", "Video from ", "\"", "+", "sf", ".", "format", "(", "from", ")", "+", "\"", " to ", "\"", "+", "sf", ".", "format", "(", "to", ")", ")", ";", "listener", ".", "getLogger", "(", ")", ".", "print", "(", "\"", "\\n", "\"", ")", ";", "return", "true", ";", "}", "}", ";", "}"], "idx": 80641, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "42f720d", "function_name": "setUp", "body_hash": "67340611d846323b919fd9a391323c78cfab6961"}
{"code": "public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            // Get the user document\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            // Get the stored validation key\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            // Get the validation key from the URL\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            // Compare the two keys\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n                saveDocument(userDocument, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n        }\n    }", "code_tokens": ["public", "int", "validateUser", "(", "boolean", "withConfirmEmail", ",", "XWikiContext", "context", ")", "throws", "XWikiException", "{", "try", "{", "XWikiRequest", "request", "=", "context", ".", "getRequest", "(", ")", ";", "String", "username", "=", "convertUsername", "(", "request", ".", "getParameter", "(", "\"", "xwikiname", "\"", ")", ",", "context", ")", ";", "if", "(", "username", ".", "indexOf", "(", "'.'", ")", "==", "-", "1", ")", "{", "username", "=", "\"", "XWiki.", "\"", "+", "username", ";", "}", "XWikiDocument", "userDocument", "=", "getDocument", "(", "username", ",", "context", ")", ";", "BaseObject", "userObject", "=", "userDocument", ".", "getObject", "(", "\"", "XWiki.XWikiUsers", "\"", ",", "0", ")", ";", "String", "storedKey", "=", "userObject", ".", "getStringValue", "(", "\"", "validkey", "\"", ")", ";", "String", "validationKey", "=", "request", ".", "getParameter", "(", "\"", "validkey", "\"", ")", ";", "PropertyInterface", "validationKeyClass", "=", "getClass", "(", "\"", "XWiki.XWikiUsers", "\"", ",", "context", ")", ".", "get", "(", "\"", "validkey", "\"", ")", ";", "if", "(", "validationKeyClass", "instanceof", "PasswordClass", ")", "{", "validationKey", "=", "(", "(", "PasswordClass", ")", "validationKeyClass", ")", ".", "getEquivalentPassword", "(", "storedKey", ",", "validationKey", ")", ";", "}", "if", "(", "(", "!", "storedKey", ".", "equals", "(", "\"", "\"", ")", "&&", "(", "storedKey", ".", "equals", "(", "validationKey", ")", ")", ")", ")", "{", "XWikiUser", "xWikiUser", "=", "new", "XWikiUser", "(", "userDocument", ".", "getDocumentReference", "(", ")", ")", ";", "xWikiUser", ".", "setDisabled", "(", "false", ",", "context", ")", ";", "xWikiUser", ".", "setEmailChecked", "(", "true", ",", "context", ")", ";", "saveDocument", "(", "userDocument", ",", "context", ")", ";", "if", "(", "withConfirmEmail", ")", "{", "String", "email", "=", "userObject", ".", "getStringValue", "(", "\"", "email", "\"", ")", ";", "String", "password", "=", "userObject", ".", "getStringValue", "(", "\"", "password", "\"", ")", ";", "sendValidationEmail", "(", "username", ",", "password", ",", "email", ",", "request", ".", "getParameter", "(", "\"", "validkey", "\"", ")", ",", "\"", "confirmation_email_content", "\"", ",", "context", ")", ";", "}", "return", "0", ";", "}", "else", "{", "return", "-", "1", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOGGER", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "throw", "new", "XWikiException", "(", "XWikiException", ".", "MODULE_XWIKI_APP", ",", "XWikiException", ".", "ERROR_XWIKI_APP_VALIDATE_USER", ",", "\"", "Exception while validating user", "\"", ",", "e", ",", "null", ")", ";", "}", "}"], "idx": 90597, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "f9a677408ffb06f309be46ef9d8df1915d9099a4", "function_name": "validateUser", "body_hash": "b47aa6a8c8307bc91bd733c8f29b00217dd9b9e5"}
{"code": "@Override\n    protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n        log.trace(\"Service: {}\", request);\n\n        // is there a consumer registered for the request.\n        HttpConsumer consumer = getServletResolveConsumerStrategy().resolve(request, getConsumers());\n        if (consumer == null) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n\n        if (consumer.getEndpoint().getHttpMethodRestrict() != null) {\n            Iterator it = ObjectHelper.createIterable(consumer.getEndpoint().getHttpMethodRestrict()).iterator();\n            boolean match = false;\n            while (it.hasNext()) {\n                String method = it.next().toString();\n                if (method.equalsIgnoreCase(request.getMethod())) {\n                    match = true;\n                    break;\n                }\n            }\n            if (!match) {\n                response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n                return;\n            }\n        }\n\n        if (\"TRACE\".equals(request.getMethod()) && !consumer.isTraceEnabled()) {\n            response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n            return;\n        }\n\n        // we do not support java serialized objects unless explicit enabled\n        String contentType = request.getContentType();\n        if (HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType) && !consumer.getEndpoint().getComponent().isAllowJavaSerializedObject()) {\n            System.out.println(\"415 miser !!!\");\n            response.sendError(HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);\n            return;\n        }\n        \n        final Exchange result = (Exchange) request.getAttribute(EXCHANGE_ATTRIBUTE_NAME);\n        if (result == null) {\n            // no asynchronous result so leverage continuation\n            final Continuation continuation = ContinuationSupport.getContinuation(request);\n            if (continuation.isInitial() && continuationTimeout != null) {\n                // set timeout on initial\n                continuation.setTimeout(continuationTimeout);\n            }\n\n            // are we suspended and a request is dispatched initially?\n            if (consumer.isSuspended() && continuation.isInitial()) {\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n                return;\n            }\n\n            if (continuation.isExpired()) {\n                String id = (String) continuation.getAttribute(EXCHANGE_ATTRIBUTE_ID);\n                // remember this id as expired\n                expiredExchanges.put(id, id);\n                log.warn(\"Continuation expired of exchangeId: {}\", id);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n                return;\n            }\n\n            // a new request so create an exchange\n            final Exchange exchange = new DefaultExchange(consumer.getEndpoint(), ExchangePattern.InOut);\n\n            if (consumer.getEndpoint().isBridgeEndpoint()) {\n                exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n                exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n            }\n            if (consumer.getEndpoint().isDisableStreamCache()) {\n                exchange.setProperty(Exchange.DISABLE_HTTP_STREAM_CACHE, Boolean.TRUE);\n            }\n            \n            HttpHelper.setCharsetFromContentType(request.getContentType(), exchange);\n            \n            exchange.setIn(new HttpMessage(exchange, request, response));\n            // set context path as header\n            String contextPath = consumer.getEndpoint().getPath();\n            exchange.getIn().setHeader(\"CamelServletContextPath\", contextPath);\n            \n            String httpPath = (String)exchange.getIn().getHeader(Exchange.HTTP_PATH);\n            // here we just remove the CamelServletContextPath part from the HTTP_PATH\n            if (contextPath != null\n                && httpPath.startsWith(contextPath)) {\n                exchange.getIn().setHeader(Exchange.HTTP_PATH,\n                        httpPath.substring(contextPath.length()));\n            }\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"Suspending continuation of exchangeId: {}\", exchange.getExchangeId());\n            }\n            continuation.setAttribute(EXCHANGE_ATTRIBUTE_ID, exchange.getExchangeId());\n\n            // we want to handle the UoW\n            try {\n                consumer.createUoW(exchange);\n            } catch (Exception e) {\n                log.error(\"Error processing request\", e);\n                throw new ServletException(e);\n            }\n\n            // must suspend before we process the exchange\n            continuation.suspend();\n\n            ClassLoader oldTccl = overrideTccl(exchange);\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"Processing request for exchangeId: {}\", exchange.getExchangeId());\n            }\n            // use the asynchronous API to process the exchange\n            \n            consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {\n                public void done(boolean doneSync) {\n                    // check if the exchange id is already expired\n                    boolean expired = expiredExchanges.remove(exchange.getExchangeId()) != null;\n                    if (!expired) {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Resuming continuation of exchangeId: {}\", exchange.getExchangeId());\n                        }\n                        // resume processing after both, sync and async callbacks\n                        continuation.setAttribute(EXCHANGE_ATTRIBUTE_NAME, exchange);\n                        continuation.resume();\n                    } else {\n                        log.warn(\"Cannot resume expired continuation of exchangeId: {}\", exchange.getExchangeId());\n                    }\n                }\n            });\n\n            if (oldTccl != null) {\n                restoreTccl(exchange, oldTccl);\n            }\n            \n            // return to let Jetty continuation to work as it will resubmit and invoke the service\n            // method again when its resumed\n            return;\n        }\n\n        try {\n            // now lets output to the response\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resumed continuation and writing response for exchangeId: {}\", result.getExchangeId());\n            }\n            Integer bs = consumer.getEndpoint().getResponseBufferSize();\n            if (bs != null) {\n                log.trace(\"Using response buffer size: {}\", bs);\n                response.setBufferSize(bs);\n            }\n            consumer.getBinding().writeResponse(result, response);\n        } catch (IOException e) {\n            log.error(\"Error processing request\", e);\n            throw e;\n        } catch (Exception e) {\n            log.error(\"Error processing request\", e);\n            throw new ServletException(e);\n        } finally {\n            consumer.doneUoW(result);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "service", "(", "final", "HttpServletRequest", "request", ",", "final", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "log", ".", "trace", "(", "\"", "Service: {}", "\"", ",", "request", ")", ";", "HttpConsumer", "consumer", "=", "getServletResolveConsumerStrategy", "(", ")", ".", "resolve", "(", "request", ",", "getConsumers", "(", ")", ")", ";", "if", "(", "consumer", "==", "null", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ")", ";", "return", ";", "}", "if", "(", "consumer", ".", "getEndpoint", "(", ")", ".", "getHttpMethodRestrict", "(", ")", "!=", "null", ")", "{", "Iterator", "it", "=", "ObjectHelper", ".", "createIterable", "(", "consumer", ".", "getEndpoint", "(", ")", ".", "getHttpMethodRestrict", "(", ")", ")", ".", "iterator", "(", ")", ";", "boolean", "match", "=", "false", ";", "while", "(", "it", ".", "hasNext", "(", ")", ")", "{", "String", "method", "=", "it", ".", "next", "(", ")", ".", "toString", "(", ")", ";", "if", "(", "method", ".", "equalsIgnoreCase", "(", "request", ".", "getMethod", "(", ")", ")", ")", "{", "match", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "match", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_METHOD_NOT_ALLOWED", ")", ";", "return", ";", "}", "}", "if", "(", "\"", "TRACE", "\"", ".", "equals", "(", "request", ".", "getMethod", "(", ")", ")", "&&", "!", "consumer", ".", "isTraceEnabled", "(", ")", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_METHOD_NOT_ALLOWED", ")", ";", "return", ";", "}", "String", "contentType", "=", "request", ".", "getContentType", "(", ")", ";", "if", "(", "HttpConstants", ".", "CONTENT_TYPE_JAVA_SERIALIZED_OBJECT", ".", "equals", "(", "contentType", ")", "&&", "!", "consumer", ".", "getEndpoint", "(", ")", ".", "getComponent", "(", ")", ".", "isAllowJavaSerializedObject", "(", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "415 miser !!!", "\"", ")", ";", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_UNSUPPORTED_MEDIA_TYPE", ")", ";", "return", ";", "}", "final", "Exchange", "result", "=", "(", "Exchange", ")", "request", ".", "getAttribute", "(", "EXCHANGE_ATTRIBUTE_NAME", ")", ";", "if", "(", "result", "==", "null", ")", "{", "final", "Continuation", "continuation", "=", "ContinuationSupport", ".", "getContinuation", "(", "request", ")", ";", "if", "(", "continuation", ".", "isInitial", "(", ")", "&&", "continuationTimeout", "!=", "null", ")", "{", "continuation", ".", "setTimeout", "(", "continuationTimeout", ")", ";", "}", "if", "(", "consumer", ".", "isSuspended", "(", ")", "&&", "continuation", ".", "isInitial", "(", ")", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_SERVICE_UNAVAILABLE", ")", ";", "return", ";", "}", "if", "(", "continuation", ".", "isExpired", "(", ")", ")", "{", "String", "id", "=", "(", "String", ")", "continuation", ".", "getAttribute", "(", "EXCHANGE_ATTRIBUTE_ID", ")", ";", "expiredExchanges", ".", "put", "(", "id", ",", "id", ")", ";", "log", ".", "warn", "(", "\"", "Continuation expired of exchangeId: {}", "\"", ",", "id", ")", ";", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_SERVICE_UNAVAILABLE", ")", ";", "return", ";", "}", "final", "Exchange", "exchange", "=", "new", "DefaultExchange", "(", "consumer", ".", "getEndpoint", "(", ")", ",", "ExchangePattern", ".", "InOut", ")", ";", "if", "(", "consumer", ".", "getEndpoint", "(", ")", ".", "isBridgeEndpoint", "(", ")", ")", "{", "exchange", ".", "setProperty", "(", "Exchange", ".", "SKIP_GZIP_ENCODING", ",", "Boolean", ".", "TRUE", ")", ";", "exchange", ".", "setProperty", "(", "Exchange", ".", "SKIP_WWW_FORM_URLENCODED", ",", "Boolean", ".", "TRUE", ")", ";", "}", "if", "(", "consumer", ".", "getEndpoint", "(", ")", ".", "isDisableStreamCache", "(", ")", ")", "{", "exchange", ".", "setProperty", "(", "Exchange", ".", "DISABLE_HTTP_STREAM_CACHE", ",", "Boolean", ".", "TRUE", ")", ";", "}", "HttpHelper", ".", "setCharsetFromContentType", "(", "request", ".", "getContentType", "(", ")", ",", "exchange", ")", ";", "exchange", ".", "setIn", "(", "new", "HttpMessage", "(", "exchange", ",", "request", ",", "response", ")", ")", ";", "String", "contextPath", "=", "consumer", ".", "getEndpoint", "(", ")", ".", "getPath", "(", ")", ";", "exchange", ".", "getIn", "(", ")", ".", "setHeader", "(", "\"", "CamelServletContextPath", "\"", ",", "contextPath", ")", ";", "String", "httpPath", "=", "(", "String", ")", "exchange", ".", "getIn", "(", ")", ".", "getHeader", "(", "Exchange", ".", "HTTP_PATH", ")", ";", "if", "(", "contextPath", "!=", "null", "&&", "httpPath", ".", "startsWith", "(", "contextPath", ")", ")", "{", "exchange", ".", "getIn", "(", ")", ".", "setHeader", "(", "Exchange", ".", "HTTP_PATH", ",", "httpPath", ".", "substring", "(", "contextPath", ".", "length", "(", ")", ")", ")", ";", "}", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Suspending continuation of exchangeId: {}", "\"", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "}", "continuation", ".", "setAttribute", "(", "EXCHANGE_ATTRIBUTE_ID", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "try", "{", "consumer", ".", "createUoW", "(", "exchange", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "Error processing request", "\"", ",", "e", ")", ";", "throw", "new", "ServletException", "(", "e", ")", ";", "}", "continuation", ".", "suspend", "(", ")", ";", "ClassLoader", "oldTccl", "=", "overrideTccl", "(", "exchange", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Processing request for exchangeId: {}", "\"", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "}", "consumer", ".", "getAsyncProcessor", "(", ")", ".", "process", "(", "exchange", ",", "new", "AsyncCallback", "(", ")", "{", "public", "void", "done", "(", "boolean", "doneSync", ")", "{", "boolean", "expired", "=", "expiredExchanges", ".", "remove", "(", "exchange", ".", "getExchangeId", "(", ")", ")", "!=", "null", ";", "if", "(", "!", "expired", ")", "{", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Resuming continuation of exchangeId: {}", "\"", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "}", "continuation", ".", "setAttribute", "(", "EXCHANGE_ATTRIBUTE_NAME", ",", "exchange", ")", ";", "continuation", ".", "resume", "(", ")", ";", "}", "else", "{", "log", ".", "warn", "(", "\"", "Cannot resume expired continuation of exchangeId: {}", "\"", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "}", "}", "}", ")", ";", "if", "(", "oldTccl", "!=", "null", ")", "{", "restoreTccl", "(", "exchange", ",", "oldTccl", ")", ";", "}", "return", ";", "}", "try", "{", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Resumed continuation and writing response for exchangeId: {}", "\"", ",", "result", ".", "getExchangeId", "(", ")", ")", ";", "}", "Integer", "bs", "=", "consumer", ".", "getEndpoint", "(", ")", ".", "getResponseBufferSize", "(", ")", ";", "if", "(", "bs", "!=", "null", ")", "{", "log", ".", "trace", "(", "\"", "Using response buffer size: {}", "\"", ",", "bs", ")", ";", "response", ".", "setBufferSize", "(", "bs", ")", ";", "}", "consumer", ".", "getBinding", "(", ")", ".", "writeResponse", "(", "result", ",", "response", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"", "Error processing request", "\"", ",", "e", ")", ";", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "Error processing request", "\"", ",", "e", ")", ";", "throw", "new", "ServletException", "(", "e", ")", ";", "}", "finally", "{", "consumer", ".", "doneUoW", "(", "result", ")", ";", "}", "}"], "idx": 3332, "cwe": "CWE-19", "target": 1, "status": "VULNERABLE", "commit": "0afcf721ff209eb10a24c5e4b48ca9d6727ea99a", "function_name": "service", "body_hash": "1d73520ca0e275ba0a23858fae4a8ef731595014"}
{"code": "private static String normalizePath(final String path) {\n        String s = path;\n        if (s == null) {\n            return null;\n        }\n        int n = 0;\n        for (; n < s.length(); n++) {\n            if (s.charAt(n) != '/') {\n                break;\n            }\n        }\n        if (n > 1) {\n            s = s.substring(n - 1);\n        }\n        return s;\n    }", "code_tokens": ["private", "static", "String", "normalizePath", "(", "final", "String", "path", ")", "{", "String", "s", "=", "path", ";", "if", "(", "s", "==", "null", ")", "{", "return", "null", ";", "}", "int", "n", "=", "0", ";", "for", "(", ";", "n", "<", "s", ".", "length", "(", ")", ";", "n", "++", ")", "{", "if", "(", "s", ".", "charAt", "(", "n", ")", "!=", "'/'", ")", "{", "break", ";", "}", "}", "if", "(", "n", ">", "1", ")", "{", "s", "=", "s", ".", "substring", "(", "n", "-", "1", ")", ";", "}", "return", "s", ";", "}"], "idx": 67473, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "0554271750599756d4946c0d7ba43d04b1a7b22", "function_name": "normalizePath", "body_hash": "989caeedd106a90171e30973e9bb7be1befc5b15"}
{"code": "public static URL valueOf(String url) {\r\n        if (url == null || (url = url.trim()).length() == 0) {\r\n            throw new IllegalArgumentException(\"url == null\");\r\n        }\r\n        String protocol = null;\r\n        String username = null;\r\n        String password = null;\r\n        String host = null;\r\n        int port = 0;\r\n        String path = null;\r\n        Map<String, String> parameters = null;\r\n        // ignore the url content following '#'\r\n        int poundIndex = url.indexOf('#');\r\n        if (poundIndex != -1) {\r\n            url = url.substring(0, poundIndex);\r\n        }\r\n        int i = url.indexOf('?'); // separator between body and parameters\r\n        if (i >= 0) {\r\n            String[] parts = url.substring(i + 1).split(\"&\");\r\n            parameters = new HashMap<>();\r\n            for (String part : parts) {\r\n                part = part.trim();\r\n                if (part.length() > 0) {\r\n                    int j = part.indexOf('=');\r\n                    if (j >= 0) {\r\n                        String key = part.substring(0, j);\r\n                        String value = part.substring(j + 1);\r\n                        parameters.put(key, value);\r\n                        // compatible with lower versions registering \"default.\" keys\r\n                        if (key.startsWith(DEFAULT_KEY_PREFIX)) {\r\n                            parameters.putIfAbsent(key.substring(DEFAULT_KEY_PREFIX.length()), value);\r\n                        }\r\n                    } else {\r\n                        parameters.put(part, part);\r\n                    }\r\n                }\r\n            }\r\n            url = url.substring(0, i);\r\n        }\r\n        i = url.indexOf(\"://\");\r\n        if (i >= 0) {\r\n            if (i == 0) {\r\n                throw new IllegalStateException(\"url missing protocol: \\\"\" + url + \"\\\"\");\r\n            }\r\n            protocol = url.substring(0, i);\r\n            url = url.substring(i + 3);\r\n        } else {\r\n            // case: file:/path/to/file.txt\r\n            i = url.indexOf(\":/\");\r\n            if (i >= 0) {\r\n                if (i == 0) {\r\n                    throw new IllegalStateException(\"url missing protocol: \\\"\" + url + \"\\\"\");\r\n                }\r\n                protocol = url.substring(0, i);\r\n                url = url.substring(i + 1);\r\n            }\r\n        }\r\n\r\n        i = url.indexOf('/');\r\n        if (i >= 0) {\r\n            path = url.substring(i + 1);\r\n            url = url.substring(0, i);\r\n        }\r\n        i = url.lastIndexOf('@');\r\n        if (i >= 0) {\r\n            username = url.substring(0, i);\r\n            int j = username.indexOf(':');\r\n            if (j >= 0) {\r\n                password = username.substring(j + 1);\r\n                username = username.substring(0, j);\r\n            }\r\n            url = url.substring(i + 1);\r\n        }\r\n        i = url.lastIndexOf(':');\r\n        if (i >= 0 && i < url.length() - 1) {\r\n            if (url.lastIndexOf('%') > i) {\r\n                // ipv6 address with scope id\r\n                // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0\r\n                // see https://howdoesinternetwork.com/2013/ipv6-zone-id\r\n                // ignore\r\n            } else {\r\n                port = Integer.parseInt(url.substring(i + 1));\r\n                url = url.substring(0, i);\r\n            }\r\n        }\r\n        if (url.length() > 0) {\r\n            host = url;\r\n        }\r\n\r\n        return new URL(protocol, username, password, host, port, path, parameters);\r\n    }", "code_tokens": ["public", "static", "URL", "valueOf", "(", "String", "url", ")", "{", "if", "(", "url", "==", "null", "||", "(", "url", "=", "url", ".", "trim", "(", ")", ")", ".", "length", "(", ")", "==", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "url == null", "\"", ")", ";", "}", "String", "protocol", "=", "null", ";", "String", "username", "=", "null", ";", "String", "password", "=", "null", ";", "String", "host", "=", "null", ";", "int", "port", "=", "0", ";", "String", "path", "=", "null", ";", "Map", "<", "String", ",", "String", ">", "parameters", "=", "null", ";", "int", "poundIndex", "=", "url", ".", "indexOf", "(", "'#'", ")", ";", "if", "(", "poundIndex", "!=", "-", "1", ")", "{", "url", "=", "url", ".", "substring", "(", "0", ",", "poundIndex", ")", ";", "}", "int", "i", "=", "url", ".", "indexOf", "(", "'?'", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "String", "[", "]", "parts", "=", "url", ".", "substring", "(", "i", "+", "1", ")", ".", "split", "(", "\"", "&", "\"", ")", ";", "parameters", "=", "new", "HashMap", "<", ">", "(", ")", ";", "for", "(", "String", "part", ":", "parts", ")", "{", "part", "=", "part", ".", "trim", "(", ")", ";", "if", "(", "part", ".", "length", "(", ")", ">", "0", ")", "{", "int", "j", "=", "part", ".", "indexOf", "(", "'='", ")", ";", "if", "(", "j", ">=", "0", ")", "{", "String", "key", "=", "part", ".", "substring", "(", "0", ",", "j", ")", ";", "String", "value", "=", "part", ".", "substring", "(", "j", "+", "1", ")", ";", "parameters", ".", "put", "(", "key", ",", "value", ")", ";", "if", "(", "key", ".", "startsWith", "(", "DEFAULT_KEY_PREFIX", ")", ")", "{", "parameters", ".", "putIfAbsent", "(", "key", ".", "substring", "(", "DEFAULT_KEY_PREFIX", ".", "length", "(", ")", ")", ",", "value", ")", ";", "}", "}", "else", "{", "parameters", ".", "put", "(", "part", ",", "part", ")", ";", "}", "}", "}", "url", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "}", "i", "=", "url", ".", "indexOf", "(", "\"", "://", "\"", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "if", "(", "i", "==", "0", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "url missing protocol: ", "\\\"", "\"", "+", "url", "+", "\"", "\\\"", "\"", ")", ";", "}", "protocol", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "url", "=", "url", ".", "substring", "(", "i", "+", "3", ")", ";", "}", "else", "{", "i", "=", "url", ".", "indexOf", "(", "\"", ":/", "\"", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "if", "(", "i", "==", "0", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "url missing protocol: ", "\\\"", "\"", "+", "url", "+", "\"", "\\\"", "\"", ")", ";", "}", "protocol", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "url", "=", "url", ".", "substring", "(", "i", "+", "1", ")", ";", "}", "}", "i", "=", "url", ".", "indexOf", "(", "'/'", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "path", "=", "url", ".", "substring", "(", "i", "+", "1", ")", ";", "url", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "}", "i", "=", "url", ".", "lastIndexOf", "(", "'@'", ")", ";", "if", "(", "i", ">=", "0", ")", "{", "username", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "int", "j", "=", "username", ".", "indexOf", "(", "':'", ")", ";", "if", "(", "j", ">=", "0", ")", "{", "password", "=", "username", ".", "substring", "(", "j", "+", "1", ")", ";", "username", "=", "username", ".", "substring", "(", "0", ",", "j", ")", ";", "}", "url", "=", "url", ".", "substring", "(", "i", "+", "1", ")", ";", "}", "i", "=", "url", ".", "lastIndexOf", "(", "':'", ")", ";", "if", "(", "i", ">=", "0", "&&", "i", "<", "url", ".", "length", "(", ")", "-", "1", ")", "{", "if", "(", "url", ".", "lastIndexOf", "(", "'%'", ")", ">", "i", ")", "{", "}", "else", "{", "port", "=", "Integer", ".", "parseInt", "(", "url", ".", "substring", "(", "i", "+", "1", ")", ")", ";", "url", "=", "url", ".", "substring", "(", "0", ",", "i", ")", ";", "}", "}", "if", "(", "url", ".", "length", "(", ")", ">", "0", ")", "{", "host", "=", "url", ";", "}", "return", "new", "URL", "(", "protocol", ",", "username", ",", "password", ",", "host", ",", "port", ",", "path", ",", "parameters", ")", ";", "}"], "idx": 65395, "cwe": "CWE-601", "target": 0, "status": "FIXED", "commit": "d5c0cf82715e15b8064a841d25856b73f243d3cd", "function_name": "valueOf", "body_hash": "c068635d3d349daf00d3b06741459b1629230765"}
{"code": "private byte[] decryptBlock(\n        byte[] in_enc,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] M, K, K1, K2;\n        int len = 0;\n\n        // Ensure that the length of the input is greater than the MAC in bytes\n        if (inLen < V.length + mac.getMacSize())\n        {\n            throw new InvalidCipherTextException(\"Length of input must be greater than the MAC and V combined\");\n        }\n\n        // note order is important: set up keys, do simple encryptions, check mac, do final encryption.\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen - V.length - mac.getMacSize()];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, K1.length, K2, 0, K2.length);\n            }\n\n            // process the message\n            M = new byte[K1.length];\n\n            for (int i = 0; i != K1.length; i++)\n            {\n                M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);\n            }\n        }\n        else\n        {\n            // Block cipher mode.        \n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If IV provide use it to initialize the cipher\n            if (IV != null)\n            {\n                cipher.init(false, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(false, new KeyParameter(K1));\n            }\n\n            M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];\n\n            // do initial processing\n            len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);\n        }\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n        // Verify the MAC.\n        int end = inOff + inLen;\n        byte[] T1 = Arrays.copyOfRange(in_enc, end - mac.getMacSize(), end);\n\n        byte[] T2 = new byte[T1.length];\n        mac.init(new KeyParameter(K2));\n        mac.update(in_enc, inOff + V.length, inLen - V.length - T2.length);\n\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T2, 0);\n\n        if (!Arrays.constantTimeAreEqual(T1, T2))\n        {\n            throw new InvalidCipherTextException(\"invalid MAC\");\n        }\n\n        if (cipher == null)\n        {\n            return M;\n        }\n        else\n        {\n            len += cipher.doFinal(M, len);\n\n            return Arrays.copyOfRange(M, 0, len);\n        }\n    }", "code_tokens": ["private", "byte", "[", "]", "decryptBlock", "(", "byte", "[", "]", "in_enc", ",", "int", "inOff", ",", "int", "inLen", ")", "throws", "InvalidCipherTextException", "{", "byte", "[", "]", "M", ",", "K", ",", "K1", ",", "K2", ";", "int", "len", "=", "0", ";", "if", "(", "inLen", "<", "V", ".", "length", "+", "mac", ".", "getMacSize", "(", ")", ")", "{", "throw", "new", "InvalidCipherTextException", "(", "\"", "Length of input must be greater than the MAC and V combined", "\"", ")", ";", "}", "if", "(", "cipher", "==", "null", ")", "{", "K1", "=", "new", "byte", "[", "inLen", "-", "V", ".", "length", "-", "mac", ".", "getMacSize", "(", ")", "]", ";", "K2", "=", "new", "byte", "[", "param", ".", "getMacKeySize", "(", ")", "/", "8", "]", ";", "K", "=", "new", "byte", "[", "K1", ".", "length", "+", "K2", ".", "length", "]", ";", "kdf", ".", "generateBytes", "(", "K", ",", "0", ",", "K", ".", "length", ")", ";", "if", "(", "V", ".", "length", "!=", "0", ")", "{", "System", ".", "arraycopy", "(", "K", ",", "0", ",", "K2", ",", "0", ",", "K2", ".", "length", ")", ";", "System", ".", "arraycopy", "(", "K", ",", "K2", ".", "length", ",", "K1", ",", "0", ",", "K1", ".", "length", ")", ";", "}", "else", "{", "System", ".", "arraycopy", "(", "K", ",", "0", ",", "K1", ",", "0", ",", "K1", ".", "length", ")", ";", "System", ".", "arraycopy", "(", "K", ",", "K1", ".", "length", ",", "K2", ",", "0", ",", "K2", ".", "length", ")", ";", "}", "M", "=", "new", "byte", "[", "K1", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "K1", ".", "length", ";", "i", "++", ")", "{", "M", "[", "i", "]", "=", "(", "byte", ")", "(", "in_enc", "[", "inOff", "+", "V", ".", "length", "+", "i", "]", "^", "K1", "[", "i", "]", ")", ";", "}", "}", "else", "{", "K1", "=", "new", "byte", "[", "(", "(", "IESWithCipherParameters", ")", "param", ")", ".", "getCipherKeySize", "(", ")", "/", "8", "]", ";", "K2", "=", "new", "byte", "[", "param", ".", "getMacKeySize", "(", ")", "/", "8", "]", ";", "K", "=", "new", "byte", "[", "K1", ".", "length", "+", "K2", ".", "length", "]", ";", "kdf", ".", "generateBytes", "(", "K", ",", "0", ",", "K", ".", "length", ")", ";", "System", ".", "arraycopy", "(", "K", ",", "0", ",", "K1", ",", "0", ",", "K1", ".", "length", ")", ";", "System", ".", "arraycopy", "(", "K", ",", "K1", ".", "length", ",", "K2", ",", "0", ",", "K2", ".", "length", ")", ";", "if", "(", "IV", "!=", "null", ")", "{", "cipher", ".", "init", "(", "false", ",", "new", "ParametersWithIV", "(", "new", "KeyParameter", "(", "K1", ")", ",", "IV", ")", ")", ";", "}", "else", "{", "cipher", ".", "init", "(", "false", ",", "new", "KeyParameter", "(", "K1", ")", ")", ";", "}", "M", "=", "new", "byte", "[", "cipher", ".", "getOutputSize", "(", "inLen", "-", "V", ".", "length", "-", "mac", ".", "getMacSize", "(", ")", ")", "]", ";", "len", "=", "cipher", ".", "processBytes", "(", "in_enc", ",", "inOff", "+", "V", ".", "length", ",", "inLen", "-", "V", ".", "length", "-", "mac", ".", "getMacSize", "(", ")", ",", "M", ",", "0", ")", ";", "}", "byte", "[", "]", "P2", "=", "param", ".", "getEncodingV", "(", ")", ";", "byte", "[", "]", "L2", "=", "null", ";", "if", "(", "V", ".", "length", "!=", "0", ")", "{", "L2", "=", "getLengthTag", "(", "P2", ")", ";", "}", "int", "end", "=", "inOff", "+", "inLen", ";", "byte", "[", "]", "T1", "=", "Arrays", ".", "copyOfRange", "(", "in_enc", ",", "end", "-", "mac", ".", "getMacSize", "(", ")", ",", "end", ")", ";", "byte", "[", "]", "T2", "=", "new", "byte", "[", "T1", ".", "length", "]", ";", "mac", ".", "init", "(", "new", "KeyParameter", "(", "K2", ")", ")", ";", "mac", ".", "update", "(", "in_enc", ",", "inOff", "+", "V", ".", "length", ",", "inLen", "-", "V", ".", "length", "-", "T2", ".", "length", ")", ";", "if", "(", "P2", "!=", "null", ")", "{", "mac", ".", "update", "(", "P2", ",", "0", ",", "P2", ".", "length", ")", ";", "}", "if", "(", "V", ".", "length", "!=", "0", ")", "{", "mac", ".", "update", "(", "L2", ",", "0", ",", "L2", ".", "length", ")", ";", "}", "mac", ".", "doFinal", "(", "T2", ",", "0", ")", ";", "if", "(", "!", "Arrays", ".", "constantTimeAreEqual", "(", "T1", ",", "T2", ")", ")", "{", "throw", "new", "InvalidCipherTextException", "(", "\"", "invalid MAC", "\"", ")", ";", "}", "if", "(", "cipher", "==", "null", ")", "{", "return", "M", ";", "}", "else", "{", "len", "+=", "cipher", ".", "doFinal", "(", "M", ",", "len", ")", ";", "return", "Arrays", ".", "copyOfRange", "(", "M", ",", "0", ",", "len", ")", ";", "}", "}"], "idx": 48127, "cwe": "CWE-361", "target": 0, "status": "FIXED", "commit": "21dcb3d9744c83dcf2ff8fcee06dbca7bfa4ef35", "function_name": "decryptBlock", "body_hash": "f410cff09b7132682ef1ffa032304625c7787c2d"}
{"code": "private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath() + File.separatorChar;\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n    }", "code_tokens": ["private", "void", "expand", "(", "ArchiveEntrySupplier", "supplier", ",", "EntryWriter", "writer", ",", "File", "targetDirectory", ")", "throws", "IOException", "{", "String", "targetDirPath", "=", "targetDirectory", ".", "getCanonicalPath", "(", ")", "+", "File", ".", "separatorChar", ";", "ArchiveEntry", "nextEntry", "=", "supplier", ".", "getNextReadableEntry", "(", ")", ";", "while", "(", "nextEntry", "!=", "null", ")", "{", "File", "f", "=", "new", "File", "(", "targetDirectory", ",", "nextEntry", ".", "getName", "(", ")", ")", ";", "if", "(", "!", "f", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "targetDirPath", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "expanding ", "\"", "+", "nextEntry", ".", "getName", "(", ")", "+", "\"", " would create file outside of ", "\"", "+", "targetDirectory", ")", ";", "}", "if", "(", "nextEntry", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "f", ".", "isDirectory", "(", ")", "&&", "!", "f", ".", "mkdirs", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "failed to create directory ", "\"", "+", "f", ")", ";", "}", "}", "else", "{", "File", "parent", "=", "f", ".", "getParentFile", "(", ")", ";", "if", "(", "!", "parent", ".", "isDirectory", "(", ")", "&&", "!", "parent", ".", "mkdirs", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "failed to create directory ", "\"", "+", "parent", ")", ";", "}", "try", "(", "OutputStream", "o", "=", "Files", ".", "newOutputStream", "(", "f", ".", "toPath", "(", ")", ")", ")", "{", "writer", ".", "writeEntryDataTo", "(", "nextEntry", ",", "o", ")", ";", "}", "}", "nextEntry", "=", "supplier", ".", "getNextReadableEntry", "(", ")", ";", "}", "}"], "idx": 11720, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "a080293da69f3fe3d11d5214432e1469ee195870", "function_name": "expand", "body_hash": "7dc33e835f35b78e68f7ef96448a5f872c14d645"}
{"code": "private Schema loadSchema(String schemaResource) {\n\t\tClassLoader loader = run( GetClassLoader.fromClass( XmlParserHelper.class ) );\n\n\t\tURL schemaUrl = loader.getResource( schemaResource );\n\t\tSchemaFactory sf = SchemaFactory.newInstance( javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI );\n\t\tSchema schema = null;\n\t\ttry {\n\t\t\tschema = sf.newSchema( schemaUrl );\n\t\t}\n\t\tcatch ( SAXException e ) {\n\t\t\tlog.unableToCreateSchema( schemaResource, e.getMessage() );\n\t\t}\n\t\treturn schema;\n\t}", "code_tokens": ["private", "Schema", "loadSchema", "(", "String", "schemaResource", ")", "{", "ClassLoader", "loader", "=", "run", "(", "GetClassLoader", ".", "fromClass", "(", "XmlParserHelper", ".", "class", ")", ")", ";", "URL", "schemaUrl", "=", "loader", ".", "getResource", "(", "schemaResource", ")", ";", "SchemaFactory", "sf", "=", "SchemaFactory", ".", "newInstance", "(", "javax", ".", "xml", ".", "XMLConstants", ".", "W3C_XML_SCHEMA_NS_URI", ")", ";", "Schema", "schema", "=", "null", ";", "try", "{", "schema", "=", "sf", ".", "newSchema", "(", "schemaUrl", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "log", ".", "unableToCreateSchema", "(", "schemaResource", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "return", "schema", ";", "}"], "idx": 30735, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "2c95d4ea0ef20977be249e31a4a4f4f4f71c945d", "function_name": "loadSchema", "body_hash": "d48bdc10ee176628974a84bb9ad555206d309225"}
{"code": "protected Response handleLoginResponse(String samlResponse, SAMLDocumentHolder holder, ResponseType responseType, String relayState, String clientId) {\n\n            try {\n                KeyManager.ActiveRsaKey keys = session.keys().getActiveRsaKey(realm);\n                if (! isSuccessfulSamlResponse(responseType)) {\n                    String statusMessage = responseType.getStatus() == null ? Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR : responseType.getStatus().getStatusMessage();\n                    return callback.error(relayState, statusMessage);\n                }\n                if (responseType.getAssertions() == null || responseType.getAssertions().isEmpty()) {\n                    return callback.error(relayState, Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);\n                }\n\n                boolean assertionIsEncrypted = AssertionUtil.isAssertionEncrypted(responseType);\n\n                if (config.isWantAssertionsEncrypted() && !assertionIsEncrypted) {\n                    logger.error(\"The assertion is not encrypted, which is required.\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                Element assertionElement;\n\n                if (assertionIsEncrypted) {\n                    // This methods writes the parsed and decrypted assertion back on the responseType parameter:\n                    assertionElement = AssertionUtil.decryptAssertion(holder, responseType, keys.getPrivateKey());\n                } else {\n                    /* We verify the assertion using original document to handle cases where the IdP\n                    includes whitespace and/or newlines inside tags. */\n                    assertionElement = DocumentUtil.getElement(holder.getSamlDocument(), new QName(JBossSAMLConstants.ASSERTION.get()));\n                }\n\n                boolean signed = AssertionUtil.isSignedElement(assertionElement);\n                if ((config.isWantAssertionsSigned() && !signed)\n                        || (signed && config.isValidateSignature() && !AssertionUtil.isSignatureValid(assertionElement, getIDPKeyLocator()))) {\n                    logger.error(\"validation failed\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SIGNATURE);\n                    return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                }\n\n                AssertionType assertion = responseType.getAssertions().get(0).getAssertion();\n\n                SubjectType subject = assertion.getSubject();\n                SubjectType.STSubType subType = subject.getSubType();\n                NameIDType subjectNameID = (NameIDType) subType.getBaseID();\n                //Map<String, String> notes = new HashMap<>();\n                BrokeredIdentityContext identity = new BrokeredIdentityContext(subjectNameID.getValue());\n                identity.getContextData().put(SAML_LOGIN_RESPONSE, responseType);\n                identity.getContextData().put(SAML_ASSERTION, assertion);\n                if (clientId != null && ! clientId.trim().isEmpty()) {\n                    identity.getContextData().put(SAML_IDP_INITIATED_CLIENT_ID, clientId);\n                }\n\n                identity.setUsername(subjectNameID.getValue());\n\n                //SAML Spec 2.2.2 Format is optional\n                if (subjectNameID.getFormat() != null && subjectNameID.getFormat().toString().equals(JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get())) {\n                    identity.setEmail(subjectNameID.getValue());\n                }\n\n                if (config.isStoreToken()) {\n                    identity.setToken(samlResponse);\n                }\n\n                AuthnStatementType authn = null;\n                for (Object statement : assertion.getStatements()) {\n                    if (statement instanceof AuthnStatementType) {\n                        authn = (AuthnStatementType)statement;\n                        identity.getContextData().put(SAML_AUTHN_STATEMENT, authn);\n                        break;\n                    }\n                }\n                if (assertion.getAttributeStatements() != null ) {\n                    for (AttributeStatementType attrStatement : assertion.getAttributeStatements()) {\n                        for (AttributeStatementType.ASTChoiceType choice : attrStatement.getAttributes()) {\n                            AttributeType attribute = choice.getAttribute();\n                            if (X500SAMLProfileConstants.EMAIL.getFriendlyName().equals(attribute.getFriendlyName())\n                                    || X500SAMLProfileConstants.EMAIL.get().equals(attribute.getName())) {\n                                if (!attribute.getAttributeValue().isEmpty()) identity.setEmail(attribute.getAttributeValue().get(0).toString());\n                            }\n                        }\n\n                    }\n\n                }\n                String brokerUserId = config.getAlias() + \".\" + subjectNameID.getValue();\n                identity.setBrokerUserId(brokerUserId);\n                identity.setIdpConfig(config);\n                identity.setIdp(provider);\n                if (authn != null && authn.getSessionIndex() != null) {\n                    identity.setBrokerSessionId(identity.getBrokerUserId() + \".\" + authn.getSessionIndex());\n                 }\n                identity.setCode(relayState);\n\n\n                return callback.authenticated(identity);\n            } catch (WebApplicationException e) {\n                return e.getResponse();\n            } catch (Exception e) {\n                throw new IdentityBrokerException(\"Could not process response from SAML identity provider.\", e);\n            }\n        }", "code_tokens": ["protected", "Response", "handleLoginResponse", "(", "String", "samlResponse", ",", "SAMLDocumentHolder", "holder", ",", "ResponseType", "responseType", ",", "String", "relayState", ",", "String", "clientId", ")", "{", "try", "{", "KeyManager", ".", "ActiveRsaKey", "keys", "=", "session", ".", "keys", "(", ")", ".", "getActiveRsaKey", "(", "realm", ")", ";", "if", "(", "!", "isSuccessfulSamlResponse", "(", "responseType", ")", ")", "{", "String", "statusMessage", "=", "responseType", ".", "getStatus", "(", ")", "==", "null", "?", "Messages", ".", "IDENTITY_PROVIDER_UNEXPECTED_ERROR", ":", "responseType", ".", "getStatus", "(", ")", ".", "getStatusMessage", "(", ")", ";", "return", "callback", ".", "error", "(", "relayState", ",", "statusMessage", ")", ";", "}", "if", "(", "responseType", ".", "getAssertions", "(", ")", "==", "null", "||", "responseType", ".", "getAssertions", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "return", "callback", ".", "error", "(", "relayState", ",", "Messages", ".", "IDENTITY_PROVIDER_UNEXPECTED_ERROR", ")", ";", "}", "boolean", "assertionIsEncrypted", "=", "AssertionUtil", ".", "isAssertionEncrypted", "(", "responseType", ")", ";", "if", "(", "config", ".", "isWantAssertionsEncrypted", "(", ")", "&&", "!", "assertionIsEncrypted", ")", "{", "logger", ".", "error", "(", "\"", "The assertion is not encrypted, which is required.", "\"", ")", ";", "event", ".", "event", "(", "EventType", ".", "IDENTITY_PROVIDER_RESPONSE", ")", ";", "event", ".", "error", "(", "Errors", ".", "INVALID_SAML_RESPONSE", ")", ";", "return", "ErrorPage", ".", "error", "(", "session", ",", "null", ",", "Response", ".", "Status", ".", "BAD_REQUEST", ",", "Messages", ".", "INVALID_REQUESTER", ")", ";", "}", "Element", "assertionElement", ";", "if", "(", "assertionIsEncrypted", ")", "{", "assertionElement", "=", "AssertionUtil", ".", "decryptAssertion", "(", "holder", ",", "responseType", ",", "keys", ".", "getPrivateKey", "(", ")", ")", ";", "}", "else", "{", "assertionElement", "=", "DocumentUtil", ".", "getElement", "(", "holder", ".", "getSamlDocument", "(", ")", ",", "new", "QName", "(", "JBossSAMLConstants", ".", "ASSERTION", ".", "get", "(", ")", ")", ")", ";", "}", "boolean", "signed", "=", "AssertionUtil", ".", "isSignedElement", "(", "assertionElement", ")", ";", "if", "(", "(", "config", ".", "isWantAssertionsSigned", "(", ")", "&&", "!", "signed", ")", "||", "(", "signed", "&&", "config", ".", "isValidateSignature", "(", ")", "&&", "!", "AssertionUtil", ".", "isSignatureValid", "(", "assertionElement", ",", "getIDPKeyLocator", "(", ")", ")", ")", ")", "{", "logger", ".", "error", "(", "\"", "validation failed", "\"", ")", ";", "event", ".", "event", "(", "EventType", ".", "IDENTITY_PROVIDER_RESPONSE", ")", ";", "event", ".", "error", "(", "Errors", ".", "INVALID_SIGNATURE", ")", ";", "return", "ErrorPage", ".", "error", "(", "session", ",", "null", ",", "Response", ".", "Status", ".", "BAD_REQUEST", ",", "Messages", ".", "INVALID_REQUESTER", ")", ";", "}", "AssertionType", "assertion", "=", "responseType", ".", "getAssertions", "(", ")", ".", "get", "(", "0", ")", ".", "getAssertion", "(", ")", ";", "SubjectType", "subject", "=", "assertion", ".", "getSubject", "(", ")", ";", "SubjectType", ".", "STSubType", "subType", "=", "subject", ".", "getSubType", "(", ")", ";", "NameIDType", "subjectNameID", "=", "(", "NameIDType", ")", "subType", ".", "getBaseID", "(", ")", ";", "BrokeredIdentityContext", "identity", "=", "new", "BrokeredIdentityContext", "(", "subjectNameID", ".", "getValue", "(", ")", ")", ";", "identity", ".", "getContextData", "(", ")", ".", "put", "(", "SAML_LOGIN_RESPONSE", ",", "responseType", ")", ";", "identity", ".", "getContextData", "(", ")", ".", "put", "(", "SAML_ASSERTION", ",", "assertion", ")", ";", "if", "(", "clientId", "!=", "null", "&&", "!", "clientId", ".", "trim", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "identity", ".", "getContextData", "(", ")", ".", "put", "(", "SAML_IDP_INITIATED_CLIENT_ID", ",", "clientId", ")", ";", "}", "identity", ".", "setUsername", "(", "subjectNameID", ".", "getValue", "(", ")", ")", ";", "if", "(", "subjectNameID", ".", "getFormat", "(", ")", "!=", "null", "&&", "subjectNameID", ".", "getFormat", "(", ")", ".", "toString", "(", ")", ".", "equals", "(", "JBossSAMLURIConstants", ".", "NAMEID_FORMAT_EMAIL", ".", "get", "(", ")", ")", ")", "{", "identity", ".", "setEmail", "(", "subjectNameID", ".", "getValue", "(", ")", ")", ";", "}", "if", "(", "config", ".", "isStoreToken", "(", ")", ")", "{", "identity", ".", "setToken", "(", "samlResponse", ")", ";", "}", "AuthnStatementType", "authn", "=", "null", ";", "for", "(", "Object", "statement", ":", "assertion", ".", "getStatements", "(", ")", ")", "{", "if", "(", "statement", "instanceof", "AuthnStatementType", ")", "{", "authn", "=", "(", "AuthnStatementType", ")", "statement", ";", "identity", ".", "getContextData", "(", ")", ".", "put", "(", "SAML_AUTHN_STATEMENT", ",", "authn", ")", ";", "break", ";", "}", "}", "if", "(", "assertion", ".", "getAttributeStatements", "(", ")", "!=", "null", ")", "{", "for", "(", "AttributeStatementType", "attrStatement", ":", "assertion", ".", "getAttributeStatements", "(", ")", ")", "{", "for", "(", "AttributeStatementType", ".", "ASTChoiceType", "choice", ":", "attrStatement", ".", "getAttributes", "(", ")", ")", "{", "AttributeType", "attribute", "=", "choice", ".", "getAttribute", "(", ")", ";", "if", "(", "X500SAMLProfileConstants", ".", "EMAIL", ".", "getFriendlyName", "(", ")", ".", "equals", "(", "attribute", ".", "getFriendlyName", "(", ")", ")", "||", "X500SAMLProfileConstants", ".", "EMAIL", ".", "get", "(", ")", ".", "equals", "(", "attribute", ".", "getName", "(", ")", ")", ")", "{", "if", "(", "!", "attribute", ".", "getAttributeValue", "(", ")", ".", "isEmpty", "(", ")", ")", "identity", ".", "setEmail", "(", "attribute", ".", "getAttributeValue", "(", ")", ".", "get", "(", "0", ")", ".", "toString", "(", ")", ")", ";", "}", "}", "}", "}", "String", "brokerUserId", "=", "config", ".", "getAlias", "(", ")", "+", "\"", ".", "\"", "+", "subjectNameID", ".", "getValue", "(", ")", ";", "identity", ".", "setBrokerUserId", "(", "brokerUserId", ")", ";", "identity", ".", "setIdpConfig", "(", "config", ")", ";", "identity", ".", "setIdp", "(", "provider", ")", ";", "if", "(", "authn", "!=", "null", "&&", "authn", ".", "getSessionIndex", "(", ")", "!=", "null", ")", "{", "identity", ".", "setBrokerSessionId", "(", "identity", ".", "getBrokerUserId", "(", ")", "+", "\"", ".", "\"", "+", "authn", ".", "getSessionIndex", "(", ")", ")", ";", "}", "identity", ".", "setCode", "(", "relayState", ")", ";", "return", "callback", ".", "authenticated", "(", "identity", ")", ";", "}", "catch", "(", "WebApplicationException", "e", ")", "{", "return", "e", ".", "getResponse", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "IdentityBrokerException", "(", "\"", "Could not process response from SAML identity provider.", "\"", ",", "e", ")", ";", "}", "}"], "idx": 39204, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "0fe0b875d63cce3d2855d85d25bb8757bce13eb1", "function_name": "handleLoginResponse", "body_hash": "02897a5fc21a7b10cf35d316743f7ee6fde96841"}
{"code": "@Override\n        public void processPacket(PacketContext context) {\n            // TODO filter packets sent to processors based on registrations\n            for (ProcessorEntry entry : processors) {\n                long start = System.nanoTime();\n                entry.processor().process(context);\n                entry.addNanos(System.nanoTime() - start);\n            }\n        }", "code_tokens": ["@", "Override", "public", "void", "processPacket", "(", "PacketContext", "context", ")", "{", "for", "(", "ProcessorEntry", "entry", ":", "processors", ")", "{", "long", "start", "=", "System", ".", "nanoTime", "(", ")", ";", "entry", ".", "processor", "(", ")", ".", "process", "(", "context", ")", ";", "entry", ".", "addNanos", "(", "System", ".", "nanoTime", "(", ")", "-", "start", ")", ";", "}", "}"], "idx": 56724, "cwe": "CWE-476", "target": 1, "status": "VULNERABLE", "commit": "f563830299f152e04717ef32fef84dadcd0ed54d", "function_name": "processPacket", "body_hash": "09624314898f094aab8a6fda8aa0d8923710ef5a"}
{"code": "private File file(String id) throws IOException {\n        File storageDir = directory();\n        if (storageDir == null) {\n            return null;\n        }\n\n        String filename = id + FILE_EXT;\n        File file = new File(storageDir, filename);\n\n        // Check the file is within the storage directory\n        if (!file.getCanonicalPath().startsWith(storageDir.getCanonicalPath())) {\n            log.warn(sm.getString(\"fileStore.invalid\", file.getPath(), id));\n            return null;\n        }\n\n        return file;\n    }", "code_tokens": ["private", "File", "file", "(", "String", "id", ")", "throws", "IOException", "{", "File", "storageDir", "=", "directory", "(", ")", ";", "if", "(", "storageDir", "==", "null", ")", "{", "return", "null", ";", "}", "String", "filename", "=", "id", "+", "FILE_EXT", ";", "File", "file", "=", "new", "File", "(", "storageDir", ",", "filename", ")", ";", "if", "(", "!", "file", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "storageDir", ".", "getCanonicalPath", "(", ")", ")", ")", "{", "log", ".", "warn", "(", "sm", ".", "getString", "(", "\"", "fileStore.invalid", "\"", ",", "file", ".", "getPath", "(", ")", ",", "id", ")", ")", ";", "return", "null", ";", "}", "return", "file", ";", "}"], "idx": 59370, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "3aa8f28db7efb311cdd1b6fe15a9cd3b167a2222", "function_name": "file", "body_hash": "15fca031a1934dc0211ca08a99f4ac1b7f3285f6"}
{"code": "private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        // http://www.openwall.com/lists/oss-security/2017/04/03/4\n        denyTypes(new Class[] { void.class, Void.class });\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); // SECURITY-247 defense\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }", "code_tokens": ["private", "void", "init", "(", ")", "{", "addImmutableType", "(", "Result", ".", "class", ")", ";", "denyTypes", "(", "new", "Class", "[", "]", "{", "void", ".", "class", ",", "Void", ".", "class", "}", ")", ";", "registerConverter", "(", "new", "RobustCollectionConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "RobustMapConverter", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableMapConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSortedSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableListConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "CopyOnWriteMap", ".", "Tree", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "DescribableList", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "Label", ".", "ConverterImpl", "(", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "AssociatedConverterImpl", "(", "this", ")", ",", "-", "10", ")", ";", "registerConverter", "(", "new", "BlacklistedTypesConverter", "(", ")", ",", "PRIORITY_VERY_HIGH", ")", ";", "registerConverter", "(", "new", "DynamicProxyConverter", "(", "getMapper", "(", ")", ")", "{", "@", "Override", "public", "boolean", "canConvert", "(", "Class", "type", ")", "{", "return", "type", "!=", "null", "&&", "super", ".", "canConvert", "(", "type", ")", ";", "}", "@", "Override", "public", "Object", "unmarshal", "(", "HierarchicalStreamReader", "reader", ",", "UnmarshallingContext", "context", ")", "{", "throw", "new", "ConversionException", "(", "\"", "<dynamic-proxy> not supported", "\"", ")", ";", "}", "}", ",", "PRIORITY_VERY_HIGH", ")", ";", "}"], "idx": 59075, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "727d58f690abf64f543407e1de3545eca76ad30e", "function_name": "init", "body_hash": "cd2645b2fef4f5dbbe38112987d6deda838189c4"}
{"code": "@Override\n    public HttpContent getContent(String pathInContext,int maxBufferSize)\n        throws IOException\n    {\n        // try loading the content from our factory.\n        Resource resource=_factory.getResource(pathInContext);\n        HttpContent loaded = load(pathInContext,resource,maxBufferSize);\n        return loaded;\n    }", "code_tokens": ["@", "Override", "public", "HttpContent", "getContent", "(", "String", "pathInContext", ",", "int", "maxBufferSize", ")", "throws", "IOException", "{", "Resource", "resource", "=", "_factory", ".", "getResource", "(", "pathInContext", ")", ";", "HttpContent", "loaded", "=", "load", "(", "pathInContext", ",", "resource", ",", "maxBufferSize", ")", ";", "return", "loaded", ";", "}"], "idx": 101961, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "a51920d650d924cc2cea011995624b394437c6e", "function_name": "getContent", "body_hash": "a3f0b40571d19fbf96b6376d32cc61e3edd7a6f8"}
{"code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }  \n        if (camelContext == null || !Boolean.parseBoolean(camelContext.getGlobalOptions().get(ACCESS_EXTERNAL_DTD))) {\n            try {\n                factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            } catch (SAXException e) {\n                LOG.error(e.getMessage(), e);\n                throw new IllegalStateException(e);\n            } \n        }\n        return factory;\n    }", "code_tokens": ["protected", "SchemaFactory", "createSchemaFactory", "(", ")", "{", "SchemaFactory", "factory", "=", "SchemaFactory", ".", "newInstance", "(", "schemaLanguage", ")", ";", "if", "(", "getResourceResolver", "(", ")", "!=", "null", ")", "{", "factory", ".", "setResourceResolver", "(", "getResourceResolver", "(", ")", ")", ";", "}", "if", "(", "camelContext", "==", "null", "||", "!", "Boolean", ".", "parseBoolean", "(", "camelContext", ".", "getGlobalOptions", "(", ")", ".", "get", "(", "ACCESS_EXTERNAL_DTD", ")", ")", ")", "{", "try", "{", "factory", ".", "setProperty", "(", "XMLConstants", ".", "ACCESS_EXTERNAL_DTD", ",", "\"", "\"", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "LOG", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}", "return", "factory", ";", "}"], "idx": 67141, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "9c6a8f61de40c20f28240fbb2af4cb425793d41", "function_name": "createSchemaFactory", "body_hash": "13adbadb123cc293260bdfe7236cd02fed2ec7c8"}
{"code": "private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> values = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        int contentLengthValuesCount = values.size();\n\n        if (contentLengthValuesCount > 0) {\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            //\n            // If a message is received that has multiple Content-Length header\n            //   fields with field-values consisting of the same decimal value, or a\n            //   single Content-Length header field with a field value containing a\n            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n            //   indicating that duplicate Content-Length header fields have been\n            //   generated or combined by an upstream message processor, then the\n            //   recipient MUST either reject the message as invalid or replace the\n            //   duplicated field-values with a single valid Content-Length field\n            //   containing that decimal value prior to determining the message body\n            //   length or forwarding the message.\n            if (contentLengthValuesCount > 1 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                throw new IllegalArgumentException(\"Multiple Content-Length headers found\");\n            }\n            contentLength = Long.parseLong(values.get(0));\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            // See https://tools.ietf.org/html/rfc7230#section-3.3.3\n            //\n            //       If a message is received with both a Transfer-Encoding and a\n            //       Content-Length header field, the Transfer-Encoding overrides the\n            //       Content-Length.  Such a message might indicate an attempt to\n            //       perform request smuggling (Section 9.5) or response splitting\n            //       (Section 9.4) and ought to be handled as an error.  A sender MUST\n            //       remove the received Content-Length field prior to forwarding such\n            //       a message downstream.\n            //\n            // This is also what http_parser does:\n            // https://github.com/nodejs/http-parser/blob/v2.9.2/http_parser.c#L1769\n            if (contentLengthValuesCount > 0 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                throw new IllegalArgumentException(\n                        \"Both 'Content-Length: \" + contentLength + \"' and 'Transfer-Encoding: chunked' found\");\n            }\n\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }", "code_tokens": ["private", "State", "readHeaders", "(", "ByteBuf", "buffer", ")", "{", "final", "HttpMessage", "message", "=", "this", ".", "message", ";", "final", "HttpHeaders", "headers", "=", "message", ".", "headers", "(", ")", ";", "AppendableCharSequence", "line", "=", "headerParser", ".", "parse", "(", "buffer", ")", ";", "if", "(", "line", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "line", ".", "length", "(", ")", ">", "0", ")", "{", "do", "{", "char", "firstChar", "=", "line", ".", "charAtUnsafe", "(", "0", ")", ";", "if", "(", "name", "!=", "null", "&&", "(", "firstChar", "==", "' '", "||", "firstChar", "==", "'\\t'", ")", ")", "{", "String", "trimmedLine", "=", "line", ".", "toString", "(", ")", ".", "trim", "(", ")", ";", "String", "valueStr", "=", "String", ".", "valueOf", "(", "value", ")", ";", "value", "=", "valueStr", "+", "' '", "+", "trimmedLine", ";", "}", "else", "{", "if", "(", "name", "!=", "null", ")", "{", "headers", ".", "add", "(", "name", ",", "value", ")", ";", "}", "splitHeader", "(", "line", ")", ";", "}", "line", "=", "headerParser", ".", "parse", "(", "buffer", ")", ";", "if", "(", "line", "==", "null", ")", "{", "return", "null", ";", "}", "}", "while", "(", "line", ".", "length", "(", ")", ">", "0", ")", ";", "}", "if", "(", "name", "!=", "null", ")", "{", "headers", ".", "add", "(", "name", ",", "value", ")", ";", "}", "name", "=", "null", ";", "value", "=", "null", ";", "List", "<", "String", ">", "values", "=", "headers", ".", "getAll", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ")", ";", "int", "contentLengthValuesCount", "=", "values", ".", "size", "(", ")", ";", "if", "(", "contentLengthValuesCount", ">", "0", ")", "{", "if", "(", "contentLengthValuesCount", ">", "1", "&&", "message", ".", "protocolVersion", "(", ")", "==", "HttpVersion", ".", "HTTP_1_1", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Multiple Content-Length headers found", "\"", ")", ";", "}", "contentLength", "=", "Long", ".", "parseLong", "(", "values", ".", "get", "(", "0", ")", ")", ";", "}", "if", "(", "isContentAlwaysEmpty", "(", "message", ")", ")", "{", "HttpUtil", ".", "setTransferEncodingChunked", "(", "message", ",", "false", ")", ";", "return", "State", ".", "SKIP_CONTROL_CHARS", ";", "}", "else", "if", "(", "HttpUtil", ".", "isTransferEncodingChunked", "(", "message", ")", ")", "{", "if", "(", "contentLengthValuesCount", ">", "0", "&&", "message", ".", "protocolVersion", "(", ")", "==", "HttpVersion", ".", "HTTP_1_1", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Both 'Content-Length: ", "\"", "+", "contentLength", "+", "\"", "' and 'Transfer-Encoding: chunked' found", "\"", ")", ";", "}", "return", "State", ".", "READ_CHUNK_SIZE", ";", "}", "else", "if", "(", "contentLength", "(", ")", ">=", "0", ")", "{", "return", "State", ".", "READ_FIXED_LENGTH_CONTENT", ";", "}", "else", "{", "return", "State", ".", "READ_VARIABLE_LENGTH_CONTENT", ";", "}", "}"], "idx": 53934, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "8494b046ec7e4f28dbd44bc699cc4c4c9225172", "function_name": "readHeaders", "body_hash": "a5c24af16564e747d98c0b70686b847fa9b4be02"}
{"code": "private void unzip(File dir, File zipFile) throws IOException {\n        dir = dir.getAbsoluteFile();    // without absolutization, getParentFile below seems to fail\n        ZipFile zip = new ZipFile(zipFile);\n        @SuppressWarnings(\"unchecked\")\n        Enumeration<ZipEntry> entries = zip.getEntries();\n\n        try {\n            while (entries.hasMoreElements()) {\n                ZipEntry e = entries.nextElement();\n                File f = new File(dir, e.getName());\n                if (e.isDirectory()) {\n                    mkdirs(f);\n                } else {\n                    File p = f.getParentFile();\n                    if (p != null) {\n                        mkdirs(p);\n                    }\n                    try (InputStream input = zip.getInputStream(e)) {\n                        IOUtils.copy(input, writing(f));\n                    }\n                    try {\n                        FilePath target = new FilePath(f);\n                        int mode = e.getUnixMode();\n                        if (mode!=0)    // Ant returns 0 if the archive doesn't record the access mode\n                            target.chmod(mode);\n                    } catch (InterruptedException ex) {\n                        LOGGER.log(Level.WARNING, \"unable to set permissions\", ex);\n                    }\n                    f.setLastModified(e.getTime());\n                }\n            }\n        } finally {\n            zip.close();\n        }\n    }", "code_tokens": ["private", "void", "unzip", "(", "File", "dir", ",", "File", "zipFile", ")", "throws", "IOException", "{", "dir", "=", "dir", ".", "getAbsoluteFile", "(", ")", ";", "ZipFile", "zip", "=", "new", "ZipFile", "(", "zipFile", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Enumeration", "<", "ZipEntry", ">", "entries", "=", "zip", ".", "getEntries", "(", ")", ";", "try", "{", "while", "(", "entries", ".", "hasMoreElements", "(", ")", ")", "{", "ZipEntry", "e", "=", "entries", ".", "nextElement", "(", ")", ";", "File", "f", "=", "new", "File", "(", "dir", ",", "e", ".", "getName", "(", ")", ")", ";", "if", "(", "e", ".", "isDirectory", "(", ")", ")", "{", "mkdirs", "(", "f", ")", ";", "}", "else", "{", "File", "p", "=", "f", ".", "getParentFile", "(", ")", ";", "if", "(", "p", "!=", "null", ")", "{", "mkdirs", "(", "p", ")", ";", "}", "try", "(", "InputStream", "input", "=", "zip", ".", "getInputStream", "(", "e", ")", ")", "{", "IOUtils", ".", "copy", "(", "input", ",", "writing", "(", "f", ")", ")", ";", "}", "try", "{", "FilePath", "target", "=", "new", "FilePath", "(", "f", ")", ";", "int", "mode", "=", "e", ".", "getUnixMode", "(", ")", ";", "if", "(", "mode", "!=", "0", ")", "target", ".", "chmod", "(", "mode", ")", ";", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "unable to set permissions", "\"", ",", "ex", ")", ";", "}", "f", ".", "setLastModified", "(", "e", ".", "getTime", "(", ")", ")", ";", "}", "}", "}", "finally", "{", "zip", ".", "close", "(", ")", ";", "}", "}"], "idx": 77923, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "8ede53387ec060a7c343e32efe808b1016f0c10c", "function_name": "unzip", "body_hash": "aa93c97d7186d3b249cee83408375efa85df04e9"}
{"code": "public FormValidation doRegexCheck(@QueryParameter final String value)\n            throws IOException, ServletException {\n        // No permission needed for simple syntax check\n        try {\n            Pattern.compile(value);\n            return FormValidation.ok();\n        } catch (Exception ex) {\n            // SECURITY-1722: As the exception message will contain the user input Pattern,\n            // it needs to be escaped to prevent an XSS attack\n            return FormValidation.errorWithMarkup(\"Invalid <a href=\\\"\"\n                    + \"https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html\"\n                    + \"\\\">regular expression</a> (\" + Util.escape(ex.getMessage()) + \")\");\n        }\n    }", "code_tokens": ["public", "FormValidation", "doRegexCheck", "(", "@", "QueryParameter", "final", "String", "value", ")", "throws", "IOException", ",", "ServletException", "{", "try", "{", "Pattern", ".", "compile", "(", "value", ")", ";", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "Invalid <a href=", "\\\"", "\"", "+", "\"", "https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html", "\"", "+", "\"", "\\\"", ">regular expression</a> (", "\"", "+", "Util", ".", "escape", "(", "ex", ".", "getMessage", "(", ")", ")", "+", "\"", ")", "\"", ")", ";", "}", "}"], "idx": 80562, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "40c6d62", "function_name": "doRegexCheck", "body_hash": "4807fdf3b4698e78ae0780a97152bd96ff735eb4"}
{"code": "@Override\n    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        if (log.isDebugEnabled())\n            log.debug(\"Security checking request \" +\n                request.getMethod() + \" \" + request.getRequestURI());\n        LoginConfig config = this.context.getLoginConfig();\n\n        // Have we got a cached authenticated Principal to record?\n        if (cache) {\n            Principal principal = request.getUserPrincipal();\n            if (principal == null) {\n                Session session = request.getSessionInternal(false);\n                if (session != null) {\n                    principal = session.getPrincipal();\n                    if (principal != null) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"We have cached auth type \" +\n                                session.getAuthType() +\n                                \" for principal \" +\n                                session.getPrincipal());\n                        request.setAuthType(session.getAuthType());\n                        request.setUserPrincipal(principal);\n                    }\n                }\n            }\n        }\n\n        // Special handling for form-based logins to deal with the case\n        // where the login form (and therefore the \"j_security_check\" URI\n        // to which it submits) might be outside the secured area\n        String contextPath = this.context.getPath();\n        String requestURI = request.getDecodedRequestURI();\n        if (requestURI.startsWith(contextPath) &&\n            requestURI.endsWith(Constants.FORM_ACTION)) {\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled())\n                    log.debug(\" Failed authenticate() test ??\" + requestURI );\n                return;\n            }\n        }\n\n        // The Servlet may specify security constraints through annotations.\n        // Ensure that they have been processed before constraints are checked\n        Wrapper wrapper = (Wrapper) request.getMappingData().wrapper; \n        if (wrapper.getServlet() == null) {\n            wrapper.load();\n        }\n\n        Realm realm = this.context.getRealm();\n        // Is this request URI subject to a security constraint?\n        SecurityConstraint [] constraints\n            = realm.findSecurityConstraints(request, this.context);\n       \n        if ((constraints == null) /* &&\n            (!Constants.FORM_METHOD.equals(config.getAuthMethod())) */ ) {\n            if (log.isDebugEnabled())\n                log.debug(\" Not subject to any constraint\");\n            getNext().invoke(request, response);\n            return;\n        }\n\n        // Make sure that constrained resources are not cached by web proxies\n        // or browsers as caching can provide a security hole\n        if (disableProxyCaching && \n            // FIXME: Disabled for Mozilla FORM support over SSL \n            // (improper caching issue)\n            //!request.isSecure() &&\n            !\"POST\".equalsIgnoreCase(request.getMethod())) {\n            if (securePagesWithPragma) {\n                // FIXME: These cause problems with downloading office docs\n                // from IE under SSL and may not be needed for newer Mozilla\n                // clients.\n                response.setHeader(\"Pragma\", \"No-cache\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n            } else {\n                response.setHeader(\"Cache-Control\", \"private\");\n            }\n            response.setHeader(\"Expires\", DATE_ONE);\n        }\n\n        int i;\n        // Enforce any user data constraint for this security constraint\n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling hasUserDataPermission()\");\n        }\n        if (!realm.hasUserDataPermission(request, response,\n                                         constraints)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed hasUserDataPermission() test\");\n            }\n            /*\n             * ASSERT: Authenticator already set the appropriate\n             * HTTP status code, so we do not have to do anything special\n             */\n            return;\n        }\n\n        // Since authenticate modifies the response on failure,\n        // we have to check for allow-from-all first.\n        boolean authRequired = true;\n        for(i=0; i < constraints.length && authRequired; i++) {\n            if(!constraints[i].getAuthConstraint()) {\n                authRequired = false;\n            } else if(!constraints[i].getAllRoles()) {\n                String [] roles = constraints[i].findAuthRoles();\n                if(roles == null || roles.length == 0) {\n                    authRequired = false;\n                }\n            }\n        }\n             \n        if(authRequired) {  \n            if (log.isDebugEnabled()) {\n                log.debug(\" Calling authenticate()\");\n            }\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\" Failed authenticate() test\");\n                }\n                /*\n                 * ASSERT: Authenticator already set the appropriate\n                 * HTTP status code, so we do not have to do anything\n                 * special\n                 */\n                return;\n            } \n            \n        }\n    \n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling accessControl()\");\n        }\n        if (!realm.hasResourcePermission(request, response,\n                                         constraints,\n                                         this.context)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed accessControl() test\");\n            }\n            /*\n             * ASSERT: AccessControl method has already set the\n             * appropriate HTTP status code, so we do not have to do\n             * anything special\n             */\n            return;\n        }\n    \n        // Any and all specified constraints have been satisfied\n        if (log.isDebugEnabled()) {\n            log.debug(\" Successfully passed all security constraints\");\n        }\n        getNext().invoke(request, response);\n\n    }", "code_tokens": ["@", "Override", "public", "void", "invoke", "(", "Request", "request", ",", "Response", "response", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Security checking request ", "\"", "+", "request", ".", "getMethod", "(", ")", "+", "\"", " ", "\"", "+", "request", ".", "getRequestURI", "(", ")", ")", ";", "LoginConfig", "config", "=", "this", ".", "context", ".", "getLoginConfig", "(", ")", ";", "if", "(", "cache", ")", "{", "Principal", "principal", "=", "request", ".", "getUserPrincipal", "(", ")", ";", "if", "(", "principal", "==", "null", ")", "{", "Session", "session", "=", "request", ".", "getSessionInternal", "(", "false", ")", ";", "if", "(", "session", "!=", "null", ")", "{", "principal", "=", "session", ".", "getPrincipal", "(", ")", ";", "if", "(", "principal", "!=", "null", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "We have cached auth type ", "\"", "+", "session", ".", "getAuthType", "(", ")", "+", "\"", " for principal ", "\"", "+", "session", ".", "getPrincipal", "(", ")", ")", ";", "request", ".", "setAuthType", "(", "session", ".", "getAuthType", "(", ")", ")", ";", "request", ".", "setUserPrincipal", "(", "principal", ")", ";", "}", "}", "}", "}", "String", "contextPath", "=", "this", ".", "context", ".", "getPath", "(", ")", ";", "String", "requestURI", "=", "request", ".", "getDecodedRequestURI", "(", ")", ";", "if", "(", "requestURI", ".", "startsWith", "(", "contextPath", ")", "&&", "requestURI", ".", "endsWith", "(", "Constants", ".", "FORM_ACTION", ")", ")", "{", "if", "(", "!", "authenticate", "(", "request", ",", "response", ",", "config", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", " Failed authenticate() test ??", "\"", "+", "requestURI", ")", ";", "return", ";", "}", "}", "Wrapper", "wrapper", "=", "(", "Wrapper", ")", "request", ".", "getMappingData", "(", ")", ".", "wrapper", ";", "if", "(", "wrapper", ".", "getServlet", "(", ")", "==", "null", ")", "{", "wrapper", ".", "load", "(", ")", ";", "}", "Realm", "realm", "=", "this", ".", "context", ".", "getRealm", "(", ")", ";", "SecurityConstraint", "[", "]", "constraints", "=", "realm", ".", "findSecurityConstraints", "(", "request", ",", "this", ".", "context", ")", ";", "if", "(", "(", "constraints", "==", "null", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", " Not subject to any constraint", "\"", ")", ";", "getNext", "(", ")", ".", "invoke", "(", "request", ",", "response", ")", ";", "return", ";", "}", "if", "(", "disableProxyCaching", "&&", "!", "\"", "POST", "\"", ".", "equalsIgnoreCase", "(", "request", ".", "getMethod", "(", ")", ")", ")", "{", "if", "(", "securePagesWithPragma", ")", "{", "response", ".", "setHeader", "(", "\"", "Pragma", "\"", ",", "\"", "No-cache", "\"", ")", ";", "response", ".", "setHeader", "(", "\"", "Cache-Control", "\"", ",", "\"", "no-cache", "\"", ")", ";", "}", "else", "{", "response", ".", "setHeader", "(", "\"", "Cache-Control", "\"", ",", "\"", "private", "\"", ")", ";", "}", "response", ".", "setHeader", "(", "\"", "Expires", "\"", ",", "DATE_ONE", ")", ";", "}", "int", "i", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Calling hasUserDataPermission()", "\"", ")", ";", "}", "if", "(", "!", "realm", ".", "hasUserDataPermission", "(", "request", ",", "response", ",", "constraints", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Failed hasUserDataPermission() test", "\"", ")", ";", "}", "return", ";", "}", "boolean", "authRequired", "=", "true", ";", "for", "(", "i", "=", "0", ";", "i", "<", "constraints", ".", "length", "&&", "authRequired", ";", "i", "++", ")", "{", "if", "(", "!", "constraints", "[", "i", "]", ".", "getAuthConstraint", "(", ")", ")", "{", "authRequired", "=", "false", ";", "}", "else", "if", "(", "!", "constraints", "[", "i", "]", ".", "getAllRoles", "(", ")", ")", "{", "String", "[", "]", "roles", "=", "constraints", "[", "i", "]", ".", "findAuthRoles", "(", ")", ";", "if", "(", "roles", "==", "null", "||", "roles", ".", "length", "==", "0", ")", "{", "authRequired", "=", "false", ";", "}", "}", "}", "if", "(", "authRequired", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Calling authenticate()", "\"", ")", ";", "}", "if", "(", "!", "authenticate", "(", "request", ",", "response", ",", "config", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Failed authenticate() test", "\"", ")", ";", "}", "return", ";", "}", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Calling accessControl()", "\"", ")", ";", "}", "if", "(", "!", "realm", ".", "hasResourcePermission", "(", "request", ",", "response", ",", "constraints", ",", "this", ".", "context", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Failed accessControl() test", "\"", ")", ";", "}", "return", ";", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", " Successfully passed all security constraints", "\"", ")", ";", "}", "getNext", "(", ")", ".", "invoke", "(", "request", ",", "response", ")", ";", "}"], "idx": 111284, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "2d7dbfe4c63a4242a9b28fdb662d91ceb7a84630", "function_name": "invoke", "body_hash": "6d772d6aa1b45dfc648dfccc89cfe9662ccc5caa"}
{"code": "@Test(expected = CryptoException.class)\n    public void getRememberedPrincipalsNoMoreDefaultCipher() {\n        HttpServletRequest mockRequest = createMock(HttpServletRequest.class);\n        HttpServletResponse mockResponse = createMock(HttpServletResponse.class);\n        WebSubjectContext context = new DefaultWebSubjectContext();\n        context.setServletRequest(mockRequest);\n        context.setServletResponse(mockResponse);\n\n        expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);\n        expect(mockRequest.getContextPath()).andReturn( \"/test\" );\n\n\n        //The following base64 string was determined from the log output of the above 'onSuccessfulLogin' test.\n        //This will have to change any time the PrincipalCollection implementation changes:\n        final String userPCAesBase64 = \"0o6DCfePYTjK4q579qzUFEfkeGRvbBOdKHp2y8/nGAltt1Vz8uW0Z8igeO\" +\n                \"Tq/yBmcw25f3Q0ui/Leg3x0iQZWhw9Bbu0mFHmHsGxEd6mPwtUpSegIjyX5c/kZpqnb7QLdajPWiczX8P\" +\n                \"Oc2Eku5+8ye1u38Y8uKlklHxcYCPh0pRiDSBxfjPsLaDfOpGbmPjZd4SVg68i/++TvUjqBNJyb+pDix3f\" +\n                \"PeuPvReWGcE50iovezVZrEfDOAQ0cZYW35ShypMWOmE9yZnb+p8++StDyAUegryyuIa4pjuRzfMh9D+sN\" +\n                \"F9tm/EnDC1VCer2S/a0AGlWAQiM7jrWt1sNinZcKIrvShaWI21tONJt8WhozNS2H72lk4p92rfLNHeglT\" +\n                \"xObxIYxLfTI9KiToSe1nYmpQmbBO8x1wWDkWBG//EqRvhgbIfQVqJp12T0fJC1nFuZuVhw/ZanaAZGDk8\" +\n                \"7aLMiw3T6FBZtWaspgvfH+0TJrTD8Ra386ekNXNN8JW8=\";\n\n        Cookie[] cookies = new Cookie[]{\n            new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64)\n        };\n\n        expect(mockRequest.getCookies()).andReturn(cookies);\n        replay(mockRequest);\n\n        CookieRememberMeManager mgr = new CookieRememberMeManager();\n        // without the old default cipher set, this will fail (expected)\n        // mgr.setCipherKey( Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"));\n        // this will throw a CryptoException\n        mgr.getRememberedPrincipals(context);\n    }", "code_tokens": ["@", "Test", "(", "expected", "=", "CryptoException", ".", "class", ")", "public", "void", "getRememberedPrincipalsNoMoreDefaultCipher", "(", ")", "{", "HttpServletRequest", "mockRequest", "=", "createMock", "(", "HttpServletRequest", ".", "class", ")", ";", "HttpServletResponse", "mockResponse", "=", "createMock", "(", "HttpServletResponse", ".", "class", ")", ";", "WebSubjectContext", "context", "=", "new", "DefaultWebSubjectContext", "(", ")", ";", "context", ".", "setServletRequest", "(", "mockRequest", ")", ";", "context", ".", "setServletResponse", "(", "mockResponse", ")", ";", "expect", "(", "mockRequest", ".", "getAttribute", "(", "ShiroHttpServletRequest", ".", "IDENTITY_REMOVED_KEY", ")", ")", ".", "andReturn", "(", "null", ")", ";", "expect", "(", "mockRequest", ".", "getContextPath", "(", ")", ")", ".", "andReturn", "(", "\"", "/test", "\"", ")", ";", "final", "String", "userPCAesBase64", "=", "\"", "0o6DCfePYTjK4q579qzUFEfkeGRvbBOdKHp2y8/nGAltt1Vz8uW0Z8igeO", "\"", "+", "\"", "Tq/yBmcw25f3Q0ui/Leg3x0iQZWhw9Bbu0mFHmHsGxEd6mPwtUpSegIjyX5c/kZpqnb7QLdajPWiczX8P", "\"", "+", "\"", "Oc2Eku5+8ye1u38Y8uKlklHxcYCPh0pRiDSBxfjPsLaDfOpGbmPjZd4SVg68i/++TvUjqBNJyb+pDix3f", "\"", "+", "\"", "PeuPvReWGcE50iovezVZrEfDOAQ0cZYW35ShypMWOmE9yZnb+p8++StDyAUegryyuIa4pjuRzfMh9D+sN", "\"", "+", "\"", "F9tm/EnDC1VCer2S/a0AGlWAQiM7jrWt1sNinZcKIrvShaWI21tONJt8WhozNS2H72lk4p92rfLNHeglT", "\"", "+", "\"", "xObxIYxLfTI9KiToSe1nYmpQmbBO8x1wWDkWBG//EqRvhgbIfQVqJp12T0fJC1nFuZuVhw/ZanaAZGDk8", "\"", "+", "\"", "7aLMiw3T6FBZtWaspgvfH+0TJrTD8Ra386ekNXNN8JW8=", "\"", ";", "Cookie", "[", "]", "cookies", "=", "new", "Cookie", "[", "]", "{", "new", "Cookie", "(", "CookieRememberMeManager", ".", "DEFAULT_REMEMBER_ME_COOKIE_NAME", ",", "userPCAesBase64", ")", "}", ";", "expect", "(", "mockRequest", ".", "getCookies", "(", ")", ")", ".", "andReturn", "(", "cookies", ")", ";", "replay", "(", "mockRequest", ")", ";", "CookieRememberMeManager", "mgr", "=", "new", "CookieRememberMeManager", "(", ")", ";", "mgr", ".", "getRememberedPrincipals", "(", "context", ")", ";", "}"], "idx": 109404, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "a8018783373ff5e5210225069c9919e071597d5e", "function_name": "getRememberedPrincipalsNoMoreDefaultCipher", "body_hash": "47fdacecabcf149531dff10943cabb95c6ab3f5d"}
{"code": "@Override\n  protected void doPost(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    String effectiveUser = request.getRemoteUser();\n    if (securityEnabled) {\n      try {\n        // As Thrift HTTP transport doesn't support SPNEGO yet (THRIFT-889),\n        // Kerberos authentication is being done at servlet level.\n        effectiveUser = doKerberosAuth(request);\n        // It is standard for client applications expect this header.\n        // Please see http://tools.ietf.org/html/rfc4559 for more details.\n        response.addHeader(WWW_AUTHENTICATE,  NEGOTIATE + \" \" + outToken);\n      } catch (HttpAuthenticationException e) {\n        LOG.error(\"Kerberos Authentication failed\", e);\n        // Send a 401 to the client\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        response.addHeader(WWW_AUTHENTICATE, NEGOTIATE);\n        response.getWriter().println(\"Authentication Error: \" + e.getMessage());\n        return;\n      }\n    }\n    String doAsUserFromQuery = request.getHeader(\"doAs\");\n    if(effectiveUser == null) {\n      effectiveUser = realUser.getShortUserName();\n    }\n    if (doAsUserFromQuery != null) {\n      if (!doAsEnabled) {\n        throw new ServletException(\"Support for proxyuser is not configured\");\n      }\n      // The authenticated remote user is attempting to perform 'doAs' proxy user.\n      UserGroupInformation remoteUser = UserGroupInformation.createRemoteUser(effectiveUser);\n      // create and attempt to authorize a proxy user (the client is attempting\n      // to do proxy user)\n      UserGroupInformation ugi = UserGroupInformation.createProxyUser(doAsUserFromQuery,\n          remoteUser);\n      // validate the proxy user authorization\n      try {\n        ProxyUsers.authorize(ugi, request.getRemoteAddr(), conf);\n      } catch (AuthorizationException e) {\n        throw new ServletException(e.getMessage());\n      }\n      effectiveUser = doAsUserFromQuery;\n    }\n    hbaseHandler.setEffectiveUser(effectiveUser);\n    super.doPost(request, response);\n  }", "code_tokens": ["@", "Override", "protected", "void", "doPost", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "String", "effectiveUser", "=", "request", ".", "getRemoteUser", "(", ")", ";", "if", "(", "securityEnabled", ")", "{", "try", "{", "effectiveUser", "=", "doKerberosAuth", "(", "request", ")", ";", "response", ".", "addHeader", "(", "WWW_AUTHENTICATE", ",", "NEGOTIATE", "+", "\"", " ", "\"", "+", "outToken", ")", ";", "}", "catch", "(", "HttpAuthenticationException", "e", ")", "{", "LOG", ".", "error", "(", "\"", "Kerberos Authentication failed", "\"", ",", "e", ")", ";", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_UNAUTHORIZED", ")", ";", "response", ".", "addHeader", "(", "WWW_AUTHENTICATE", ",", "NEGOTIATE", ")", ";", "response", ".", "getWriter", "(", ")", ".", "println", "(", "\"", "Authentication Error: ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "return", ";", "}", "}", "String", "doAsUserFromQuery", "=", "request", ".", "getHeader", "(", "\"", "doAs", "\"", ")", ";", "if", "(", "effectiveUser", "==", "null", ")", "{", "effectiveUser", "=", "realUser", ".", "getShortUserName", "(", ")", ";", "}", "if", "(", "doAsUserFromQuery", "!=", "null", ")", "{", "if", "(", "!", "doAsEnabled", ")", "{", "throw", "new", "ServletException", "(", "\"", "Support for proxyuser is not configured", "\"", ")", ";", "}", "UserGroupInformation", "remoteUser", "=", "UserGroupInformation", ".", "createRemoteUser", "(", "effectiveUser", ")", ";", "UserGroupInformation", "ugi", "=", "UserGroupInformation", ".", "createProxyUser", "(", "doAsUserFromQuery", ",", "remoteUser", ")", ";", "try", "{", "ProxyUsers", ".", "authorize", "(", "ugi", ",", "request", ".", "getRemoteAddr", "(", ")", ",", "conf", ")", ";", "}", "catch", "(", "AuthorizationException", "e", ")", "{", "throw", "new", "ServletException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "effectiveUser", "=", "doAsUserFromQuery", ";", "}", "hbaseHandler", ".", "setEffectiveUser", "(", "effectiveUser", ")", ";", "super", ".", "doPost", "(", "request", ",", "response", ")", ";", "}"], "idx": 48964, "cwe": "CWE-362", "target": 1, "status": "VULNERABLE", "commit": "0c42acbdf86d08af3003105a26a2201f75f2e2c", "function_name": "doPost", "body_hash": "5e595d1a77a9987f0a0183650dc9b61031160fa2"}
{"code": "public static Map<String, String> getSAMLAttributes() {\n        Map<String, String> attributes = new HashMap<>();\n        attributes.put(SAML_CLIENT_SIGNATURE, \"true\");\n        attributes.put(SAML_AUTHNSTATEMENT, \"true\");\n        attributes.put(SAML_FORCE_POST_BINDING, \"true\");\n        attributes.put(SAML_SERVER_SIGNATURE, \"true\");\n        attributes.put(SAML_SIGNATURE_ALGORITHM, \"RSA_SHA256\");\n        attributes.put(SAML_FORCE_NAME_ID_FORMAT, \"false\");\n        attributes.put(SAML_NAME_ID_FORMAT, \"username\");\n        attributes.put(SAML_ALLOW_ECP_FLOW, \"false\");\n        attributes.put(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(\"saml\"));\n        return attributes;\n    }", "code_tokens": ["public", "static", "Map", "<", "String", ",", "String", ">", "getSAMLAttributes", "(", ")", "{", "Map", "<", "String", ",", "String", ">", "attributes", "=", "new", "HashMap", "<", ">", "(", ")", ";", "attributes", ".", "put", "(", "SAML_CLIENT_SIGNATURE", ",", "\"", "true", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_AUTHNSTATEMENT", ",", "\"", "true", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_FORCE_POST_BINDING", ",", "\"", "true", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_SERVER_SIGNATURE", ",", "\"", "true", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_SIGNATURE_ALGORITHM", ",", "\"", "RSA_SHA256", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_FORCE_NAME_ID_FORMAT", ",", "\"", "false", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_NAME_ID_FORMAT", ",", "\"", "username", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_ALLOW_ECP_FLOW", ",", "\"", "false", "\"", ")", ";", "attributes", ".", "put", "(", "SamlConfigAttributes", ".", "SAML_ARTIFACT_BINDING_IDENTIFIER", ",", "ArtifactBindingUtils", ".", "computeArtifactBindingIdentifierString", "(", "\"", "saml", "\"", ")", ")", ";", "return", "attributes", ";", "}"], "idx": 39604, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "44000caaf5051d7f218d1ad79573bd3d175cad0d", "function_name": "getSAMLAttributes", "body_hash": "4e8fde028705f3947c5353ca87f48843a7d51d01"}
{"code": "public void save(String comment, boolean minorEdit) throws XWikiException\n    {\n        if (hasAccessLevel(\"edit\")) {\n            // If the current author does not have PR don't let it set current user as author of the saved document\n            // since it can lead to right escalation\n            if (hasProgrammingRights()) {\n                saveDocument(comment, minorEdit);\n            } else {\n                saveAsAuthor(comment, minorEdit);\n            }\n        } else {\n            java.lang.Object[] args = {getDefaultEntityReferenceSerializer().serialize(getDocumentReference())};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied in edit mode on document {0}\", null, args);\n        }\n    }", "code_tokens": ["public", "void", "save", "(", "String", "comment", ",", "boolean", "minorEdit", ")", "throws", "XWikiException", "{", "if", "(", "hasAccessLevel", "(", "\"", "edit", "\"", ")", ")", "{", "if", "(", "hasProgrammingRights", "(", ")", ")", "{", "saveDocument", "(", "comment", ",", "minorEdit", ")", ";", "}", "else", "{", "saveAsAuthor", "(", "comment", ",", "minorEdit", ")", ";", "}", "}", "else", "{", "java", ".", "lang", ".", "Object", "[", "]", "args", "=", "{", "getDefaultEntityReferenceSerializer", "(", ")", ".", "serialize", "(", "getDocumentReference", "(", ")", ")", "}", ";", "throw", "new", "XWikiException", "(", "XWikiException", ".", "MODULE_XWIKI_ACCESS", ",", "XWikiException", ".", "ERROR_XWIKI_ACCESS_DENIED", ",", "\"", "Access denied in edit mode on document {0}", "\"", ",", "null", ",", "args", ")", ";", "}", "}"], "idx": 90339, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "7ab0fe7b96809c7a3881454147598d46a1c9bbbe", "function_name": "save", "body_hash": "78e2022f8f587f4d687713ad73ed02eaff3c1657"}
{"code": "private boolean instanceMethodParametersResolveToSameTypes(Method subTypeMethod, Method superTypeMethod) {\n\t\tif ( subTypeMethod.getParameterTypes().length == 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tResolvedType resolvedSubType = typeResolver.resolve( subTypeMethod.getDeclaringClass() );\n\n\t\tMemberResolver memberResolver = new MemberResolver( typeResolver );\n\t\tmemberResolver.setMethodFilter( new SimpleMethodFilter( subTypeMethod, superTypeMethod ) );\n\t\tResolvedTypeWithMembers typeWithMembers = memberResolver.resolve(\n\t\t\t\tresolvedSubType,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t);\n\n\t\t// ClassMate itself doesn't require any special permissions, but it invokes reflection APIs which do.\n\t\t// Wrapping the call into a privileged action to avoid that all calling code bases need to have the required\n\t\t// permission\n\t\tResolvedMethod[] resolvedMethods = run( GetResolvedMemberMethods.action( typeWithMembers ) );\n\n\t\t// The ClassMate doc says that overridden methods are flattened to one\n\t\t// resolved method. But that is the case only for methods without any\n\t\t// generic parameters.\n\t\tif ( resolvedMethods.length == 1 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// For methods with generic parameters I have to compare the argument\n\t\t// types (which are resolved) of the two filtered member methods.\n\t\tfor ( int i = 0; i < resolvedMethods[0].getArgumentCount(); i++ ) {\n\n\t\t\tif ( !resolvedMethods[0].getArgumentType( i )\n\t\t\t\t\t.equals( resolvedMethods[1].getArgumentType( i ) ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "boolean", "instanceMethodParametersResolveToSameTypes", "(", "Method", "subTypeMethod", ",", "Method", "superTypeMethod", ")", "{", "if", "(", "subTypeMethod", ".", "getParameterTypes", "(", ")", ".", "length", "==", "0", ")", "{", "return", "true", ";", "}", "ResolvedType", "resolvedSubType", "=", "typeResolver", ".", "resolve", "(", "subTypeMethod", ".", "getDeclaringClass", "(", ")", ")", ";", "MemberResolver", "memberResolver", "=", "new", "MemberResolver", "(", "typeResolver", ")", ";", "memberResolver", ".", "setMethodFilter", "(", "new", "SimpleMethodFilter", "(", "subTypeMethod", ",", "superTypeMethod", ")", ")", ";", "ResolvedTypeWithMembers", "typeWithMembers", "=", "memberResolver", ".", "resolve", "(", "resolvedSubType", ",", "null", ",", "null", ")", ";", "ResolvedMethod", "[", "]", "resolvedMethods", "=", "run", "(", "GetResolvedMemberMethods", ".", "action", "(", "typeWithMembers", ")", ")", ";", "if", "(", "resolvedMethods", ".", "length", "==", "1", ")", "{", "return", "true", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "resolvedMethods", "[", "0", "]", ".", "getArgumentCount", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "resolvedMethods", "[", "0", "]", ".", "getArgumentType", "(", "i", ")", ".", "equals", "(", "resolvedMethods", "[", "1", "]", ".", "getArgumentType", "(", "i", ")", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "idx": 30741, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "67fdff14831c035c25e098fe14bd86523d17f726", "function_name": "instanceMethodParametersResolveToSameTypes", "body_hash": "4d2c24a44975a8d9a2093562dc8096073d4b8281"}
{"code": "public boolean matches(String pattern, String source) {\n        if (pattern == null) {\n            throw new IllegalArgumentException(\"pattern argument cannot be null.\");\n        }\n        Pattern p = Pattern.compile(pattern, caseInsensitive ? CASE_INSENSITIVE : DEFAULT);\n        Matcher m = p.matcher(source);\n        return m.matches();\n    }", "code_tokens": ["public", "boolean", "matches", "(", "String", "pattern", ",", "String", "source", ")", "{", "if", "(", "pattern", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "pattern argument cannot be null.", "\"", ")", ";", "}", "Pattern", "p", "=", "Pattern", ".", "compile", "(", "pattern", ",", "caseInsensitive", "?", "CASE_INSENSITIVE", ":", "DEFAULT", ")", ";", "Matcher", "m", "=", "p", ".", "matcher", "(", "source", ")", ";", "return", "m", ".", "matches", "(", ")", ";", "}"], "idx": 86553, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "6bcb92e06fa588b9c7790dd01bc02135d58d3f5b", "function_name": "matches", "body_hash": "d269e3aff18fc9396f048c2b6fcc22dec4f2d30e"}
{"code": "private int readEncryptedData(final ByteBuffer dst, final int pending) throws SSLException {\n        try {\n            int bytesRead = 0;\n            final int pos = dst.position();\n            if (dst.remaining() >= pending) {\n                final int limit = dst.limit();\n                final int len = min(pending, limit - pos);\n                if (dst.isDirect()) {\n                    bytesRead = readEncryptedDataDirect(dst, pos, len);\n                    // Need to update the position on the dst buffer.\n                    if (bytesRead > 0) {\n                        dst.position(pos + bytesRead);\n                    }\n                } else {\n                    // The heap method will update the position on the dst buffer automatically.\n                    bytesRead = readEncryptedDataHeap(dst, len);\n                }\n            }\n\n            return bytesRead;\n        } catch (Exception e) {\n            throw convertException(e);\n        }\n    }", "code_tokens": ["private", "int", "readEncryptedData", "(", "final", "ByteBuffer", "dst", ",", "final", "int", "pending", ")", "throws", "SSLException", "{", "try", "{", "int", "bytesRead", "=", "0", ";", "final", "int", "pos", "=", "dst", ".", "position", "(", ")", ";", "if", "(", "dst", ".", "remaining", "(", ")", ">=", "pending", ")", "{", "final", "int", "limit", "=", "dst", ".", "limit", "(", ")", ";", "final", "int", "len", "=", "min", "(", "pending", ",", "limit", "-", "pos", ")", ";", "if", "(", "dst", ".", "isDirect", "(", ")", ")", "{", "bytesRead", "=", "readEncryptedDataDirect", "(", "dst", ",", "pos", ",", "len", ")", ";", "if", "(", "bytesRead", ">", "0", ")", "{", "dst", ".", "position", "(", "pos", "+", "bytesRead", ")", ";", "}", "}", "else", "{", "bytesRead", "=", "readEncryptedDataHeap", "(", "dst", ",", "len", ")", ";", "}", "}", "return", "bytesRead", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "convertException", "(", "e", ")", ";", "}", "}"], "idx": 97863, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "e56958e7dea05c1784317f139e2216e2e707d391", "function_name": "readEncryptedData", "body_hash": "3c3ba3a7d381a9da2b97ea1c9a28b92d5837c2b9"}
{"code": "private boolean processRemainingHeader() throws IOException {\n        // Ignore the 2 bytes already read. 4 for the mask\n        int headerLength;\n        if (isMasked()) {\n            headerLength = 4;\n        } else {\n            headerLength = 0;\n        }\n        // Add additional bytes depending on length\n        if (payloadLength == 126) {\n            headerLength += 2;\n        } else if (payloadLength == 127) {\n            headerLength += 8;\n        }\n        if (inputBuffer.remaining() < headerLength) {\n            return false;\n        }\n        // Calculate new payload length if necessary\n        if (payloadLength == 126) {\n            payloadLength = byteArrayToLong(inputBuffer.array(),\n                    inputBuffer.arrayOffset() + inputBuffer.position(), 2);\n            inputBuffer.position(inputBuffer.position() + 2);\n        } else if (payloadLength == 127) {\n            payloadLength = byteArrayToLong(inputBuffer.array(),\n                    inputBuffer.arrayOffset() + inputBuffer.position(), 8);\n            // The most significant bit of those 8 bytes is required to be zero\n            // (see RFC 6455, section 5.2). If the most significant bit is set,\n            // the resulting payload length will be negative so test for that.\n            if (payloadLength < 0) {\n                throw new WsIOException(\n                        new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString(\"wsFrame.payloadMsbInvalid\")));\n            }\n            inputBuffer.position(inputBuffer.position() + 8);\n        }\n        if (Util.isControl(opCode)) {\n            if (payloadLength > 125) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlPayloadTooBig\", Long.valueOf(payloadLength))));\n            }\n            if (!fin) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlNoFin\")));\n            }\n        }\n        if (isMasked()) {\n            inputBuffer.get(mask, 0, 4);\n        }\n        state = State.DATA;\n        return true;\n    }", "code_tokens": ["private", "boolean", "processRemainingHeader", "(", ")", "throws", "IOException", "{", "int", "headerLength", ";", "if", "(", "isMasked", "(", ")", ")", "{", "headerLength", "=", "4", ";", "}", "else", "{", "headerLength", "=", "0", ";", "}", "if", "(", "payloadLength", "==", "126", ")", "{", "headerLength", "+=", "2", ";", "}", "else", "if", "(", "payloadLength", "==", "127", ")", "{", "headerLength", "+=", "8", ";", "}", "if", "(", "inputBuffer", ".", "remaining", "(", ")", "<", "headerLength", ")", "{", "return", "false", ";", "}", "if", "(", "payloadLength", "==", "126", ")", "{", "payloadLength", "=", "byteArrayToLong", "(", "inputBuffer", ".", "array", "(", ")", ",", "inputBuffer", ".", "arrayOffset", "(", ")", "+", "inputBuffer", ".", "position", "(", ")", ",", "2", ")", ";", "inputBuffer", ".", "position", "(", "inputBuffer", ".", "position", "(", ")", "+", "2", ")", ";", "}", "else", "if", "(", "payloadLength", "==", "127", ")", "{", "payloadLength", "=", "byteArrayToLong", "(", "inputBuffer", ".", "array", "(", ")", ",", "inputBuffer", ".", "arrayOffset", "(", ")", "+", "inputBuffer", ".", "position", "(", ")", ",", "8", ")", ";", "if", "(", "payloadLength", "<", "0", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.payloadMsbInvalid", "\"", ")", ")", ")", ";", "}", "inputBuffer", ".", "position", "(", "inputBuffer", ".", "position", "(", ")", "+", "8", ")", ";", "}", "if", "(", "Util", ".", "isControl", "(", "opCode", ")", ")", "{", "if", "(", "payloadLength", ">", "125", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.controlPayloadTooBig", "\"", ",", "Long", ".", "valueOf", "(", "payloadLength", ")", ")", ")", ")", ";", "}", "if", "(", "!", "fin", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.controlNoFin", "\"", ")", ")", ")", ";", "}", "}", "if", "(", "isMasked", "(", ")", ")", "{", "inputBuffer", ".", "get", "(", "mask", ",", "0", ",", "4", ")", ";", "}", "state", "=", "State", ".", "DATA", ";", "return", "true", ";", "}"], "idx": 82447, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "12d715676038efbf9c728af10163f8277fc019d5", "function_name": "processRemainingHeader", "body_hash": "1172c039743b8471e65bde46d4b0d968fbc58b6d"}
{"code": "private void checkPrivileges(HiveOperationType hiveOpType, List<HivePrivilegeObject> hiveObjects,\n                               String userName, Operation2Privilege.IOType ioType, List<String> deniedMessages) {\n\n    if (hiveObjects == null) {\n      return;\n    }\n\n    boolean isAdmin = false;\n    if (admins != null && admins.length > 0) {\n      isAdmin = Arrays.asList(admins).contains(userName);\n    }\n\n    if (isAdmin) {\n      return; // Skip rest of checks if user is admin\n    }\n\n    // Special-casing for ADMIN-level operations that do not require object checking.\n    if (Operation2Privilege.isAdminPrivOperation(hiveOpType)) {\n      // Require ADMIN privilege\n      deniedMessages.add(SQLPrivTypeGrant.ADMIN_PRIV.toString() + \" on \" + ioType);\n      return; // Ignore object, fail if not admin, succeed if admin.\n    }\n\n    boolean needAdmin = false;\n    for (HivePrivilegeObject hiveObj : hiveObjects) {\n      // If involving local file system\n      if (hiveObj.getType() == HivePrivilegeObject.HivePrivilegeObjectType.LOCAL_URI) {\n        needAdmin = true;\n        break;\n      }\n    }\n    if (!needAdmin) {\n      switch (hiveOpType) {\n        case ADD:\n        case DFS:\n        case COMPILE:\n          needAdmin = true;\n          break;\n        default:\n          break;\n      }\n    }\n    if (needAdmin) {\n      deniedMessages.add(\"ADMIN\");\n    }\n  }", "code_tokens": ["private", "void", "checkPrivileges", "(", "HiveOperationType", "hiveOpType", ",", "List", "<", "HivePrivilegeObject", ">", "hiveObjects", ",", "String", "userName", ",", "Operation2Privilege", ".", "IOType", "ioType", ",", "List", "<", "String", ">", "deniedMessages", ")", "{", "if", "(", "hiveObjects", "==", "null", ")", "{", "return", ";", "}", "boolean", "isAdmin", "=", "false", ";", "if", "(", "admins", "!=", "null", "&&", "admins", ".", "length", ">", "0", ")", "{", "isAdmin", "=", "Arrays", ".", "asList", "(", "admins", ")", ".", "contains", "(", "userName", ")", ";", "}", "if", "(", "isAdmin", ")", "{", "return", ";", "}", "if", "(", "Operation2Privilege", ".", "isAdminPrivOperation", "(", "hiveOpType", ")", ")", "{", "deniedMessages", ".", "add", "(", "SQLPrivTypeGrant", ".", "ADMIN_PRIV", ".", "toString", "(", ")", "+", "\"", " on ", "\"", "+", "ioType", ")", ";", "return", ";", "}", "boolean", "needAdmin", "=", "false", ";", "for", "(", "HivePrivilegeObject", "hiveObj", ":", "hiveObjects", ")", "{", "if", "(", "hiveObj", ".", "getType", "(", ")", "==", "HivePrivilegeObject", ".", "HivePrivilegeObjectType", ".", "LOCAL_URI", ")", "{", "needAdmin", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "needAdmin", ")", "{", "switch", "(", "hiveOpType", ")", "{", "case", "ADD", ":", "case", "DFS", ":", "case", "COMPILE", ":", "needAdmin", "=", "true", ";", "break", ";", "default", ":", "break", ";", "}", "}", "if", "(", "needAdmin", ")", "{", "deniedMessages", ".", "add", "(", "\"", "ADMIN", "\"", ")", ";", "}", "}"], "idx": 102455, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "00c0ee7bc4b8492476b377a6edafcc33411f14b", "function_name": "checkPrivileges", "body_hash": "03ece10ddd008847bd2d2c3093f4a0a1292fa29b"}
{"code": "protected UserModel validateCache(RealmModel realm, CachedUser cached) {\n        if (!realm.getId().equals(cached.getRealm())) {\n            return null;\n        }\n\n        StorageId storageId = new StorageId(cached.getId());\n        if (!storageId.isLocal()) {\n            ComponentModel component = realm.getComponent(storageId.getProviderId());\n            UserStorageProviderModel model = new UserStorageProviderModel(component);\n            UserStorageProviderModel.CachePolicy policy = model.getCachePolicy();\n            // although we do set a timeout, Infinispan has no guarantees when the user will be evicted\n            // its also hard to test stuff\n            boolean invalidate = false;\n            if (policy != null) {\n                String currentTime = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(Time.currentTimeMillis()));\n                if (policy == UserStorageProviderModel.CachePolicy.NO_CACHE) {\n                    invalidate = true;\n                } else if (cached.getCacheTimestamp() < model.getCacheInvalidBefore()) {\n                    invalidate = true;\n                } else if (policy == UserStorageProviderModel.CachePolicy.EVICT_DAILY) {\n                    long dailyTimeout = dailyTimeout(model.getEvictionHour(), model.getEvictionMinute());\n                    dailyTimeout = dailyTimeout - (24 * 60 * 60 * 1000);\n                    //String timeout = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(dailyTimeout));\n                    //String stamp = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(cached.getCacheTimestamp()));\n                    if (cached.getCacheTimestamp() <= dailyTimeout) {\n                        invalidate = true;\n                    }\n                } else if (policy == UserStorageProviderModel.CachePolicy.EVICT_WEEKLY) {\n                    int oneWeek = 7 * 24 * 60 * 60 * 1000;\n                    long weeklyTimeout = weeklyTimeout(model.getEvictionDay(), model.getEvictionHour(), model.getEvictionMinute());\n                    long lastTimeout = weeklyTimeout - oneWeek;\n                    String timeout = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(weeklyTimeout));\n                    String stamp = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(cached.getCacheTimestamp()));\n                    if (cached.getCacheTimestamp() <= lastTimeout) {\n                        invalidate = true;\n                    }\n                }\n            }\n            if (invalidate) {\n                registerUserInvalidation(realm, cached);\n                return getDelegate().getUserById(cached.getId(), realm);\n            }\n        }\n        return new UserAdapter(cached, this, session, realm);\n    }", "code_tokens": ["protected", "UserModel", "validateCache", "(", "RealmModel", "realm", ",", "CachedUser", "cached", ")", "{", "if", "(", "!", "realm", ".", "getId", "(", ")", ".", "equals", "(", "cached", ".", "getRealm", "(", ")", ")", ")", "{", "return", "null", ";", "}", "StorageId", "storageId", "=", "new", "StorageId", "(", "cached", ".", "getId", "(", ")", ")", ";", "if", "(", "!", "storageId", ".", "isLocal", "(", ")", ")", "{", "ComponentModel", "component", "=", "realm", ".", "getComponent", "(", "storageId", ".", "getProviderId", "(", ")", ")", ";", "UserStorageProviderModel", "model", "=", "new", "UserStorageProviderModel", "(", "component", ")", ";", "UserStorageProviderModel", ".", "CachePolicy", "policy", "=", "model", ".", "getCachePolicy", "(", ")", ";", "boolean", "invalidate", "=", "false", ";", "if", "(", "policy", "!=", "null", ")", "{", "String", "currentTime", "=", "DateFormat", ".", "getDateTimeInstance", "(", "DateFormat", ".", "FULL", ",", "DateFormat", ".", "FULL", ")", ".", "format", "(", "new", "Date", "(", "Time", ".", "currentTimeMillis", "(", ")", ")", ")", ";", "if", "(", "policy", "==", "UserStorageProviderModel", ".", "CachePolicy", ".", "NO_CACHE", ")", "{", "invalidate", "=", "true", ";", "}", "else", "if", "(", "cached", ".", "getCacheTimestamp", "(", ")", "<", "model", ".", "getCacheInvalidBefore", "(", ")", ")", "{", "invalidate", "=", "true", ";", "}", "else", "if", "(", "policy", "==", "UserStorageProviderModel", ".", "CachePolicy", ".", "EVICT_DAILY", ")", "{", "long", "dailyTimeout", "=", "dailyTimeout", "(", "model", ".", "getEvictionHour", "(", ")", ",", "model", ".", "getEvictionMinute", "(", ")", ")", ";", "dailyTimeout", "=", "dailyTimeout", "-", "(", "24", "*", "60", "*", "60", "*", "1000", ")", ";", "if", "(", "cached", ".", "getCacheTimestamp", "(", ")", "<=", "dailyTimeout", ")", "{", "invalidate", "=", "true", ";", "}", "}", "else", "if", "(", "policy", "==", "UserStorageProviderModel", ".", "CachePolicy", ".", "EVICT_WEEKLY", ")", "{", "int", "oneWeek", "=", "7", "*", "24", "*", "60", "*", "60", "*", "1000", ";", "long", "weeklyTimeout", "=", "weeklyTimeout", "(", "model", ".", "getEvictionDay", "(", ")", ",", "model", ".", "getEvictionHour", "(", ")", ",", "model", ".", "getEvictionMinute", "(", ")", ")", ";", "long", "lastTimeout", "=", "weeklyTimeout", "-", "oneWeek", ";", "String", "timeout", "=", "DateFormat", ".", "getDateTimeInstance", "(", "DateFormat", ".", "FULL", ",", "DateFormat", ".", "FULL", ")", ".", "format", "(", "new", "Date", "(", "weeklyTimeout", ")", ")", ";", "String", "stamp", "=", "DateFormat", ".", "getDateTimeInstance", "(", "DateFormat", ".", "FULL", ",", "DateFormat", ".", "FULL", ")", ".", "format", "(", "new", "Date", "(", "cached", ".", "getCacheTimestamp", "(", ")", ")", ")", ";", "if", "(", "cached", ".", "getCacheTimestamp", "(", ")", "<=", "lastTimeout", ")", "{", "invalidate", "=", "true", ";", "}", "}", "}", "if", "(", "invalidate", ")", "{", "registerUserInvalidation", "(", "realm", ",", "cached", ")", ";", "return", "getDelegate", "(", ")", ".", "getUserById", "(", "cached", ".", "getId", "(", ")", ",", "realm", ")", ";", "}", "}", "return", "new", "UserAdapter", "(", "cached", ",", "this", ",", "session", ",", "realm", ")", ";", "}"], "idx": 32939, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "a78cfa4b2ca979a1981fb371cfdf2c7212f7b6e2", "function_name": "validateCache", "body_hash": "4bccbd6d02482b869af21b8c24d2276f96adbabf"}
{"code": "private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        case '\\t': replace(i, i + 1, \"\\\\t\"); break;\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \"foo\"\n        // or internal quotes that might need to be escaped : f\"o -> f\\\"o.\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\"' as closing regardless.\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string\n        // literals so that the output can be embedded in HTML script elements\n        // and in XML CDATA sections without affecting the parser state.\n        // References:\n        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements\n        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state\n        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state\n        // https://www.w3.org/TR/xml/#sec-cdata-sect\n        case '<': {\n          // Disallow <!--, which lets the HTML parser switch into the \"script\n          // data escaped\" state.\n          // Disallow <script, which followed by various characters lets the\n          // HTML parser switch into or out of the \"script data double escaped\"\n          // state.\n          // Disallow </script, which ends a script block.\n          if (i + 3 >= end) {\n            break;\n          }\n          char c1 = jsonish.charAt(i + 1);\n          char c2 = jsonish.charAt(i + 2);\n          char c3 = jsonish.charAt(i + 3);\n          char lc1 = (char) (c1 | 32);\n          char lc2 = (char) (c2 | 32);\n          char lc3 = (char) (c3 | 32);\n          if (\n                  (c1 == '\\\\' || c2 == '\\\\' || c3 == '\\\\') ||\n                          (c1 == '!' && c2 == '-' && c3 == '-') ||\n                          (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n                          (c1 == '/' && lc2 == 's' && lc3 == 'c')\n          ) {\n            replace(i, i + 1, \"\\\\u003c\"); // Escaped <\n          }\n          break;\n        }\n        case '>':\n          // Disallow -->, which lets the HTML parser switch out of the \"script\n          // data escaped\" or \"script data double escaped\" state.\n          if ((i - 2) >= start) {\n            int cm2 = jsonish.charAt(i - 2);\n            int cm1 = jsonish.charAt(i - 1);\n            if (('-' == cm2 || '\\\\' == cm2) && ('-' == cm1 || '\\\\' == cm1)) {\n              replace(i, i + 1, \"\\\\u003e\"); // Escaped >\n            }\n          }\n          break;\n        case ']':\n          if (i + 2 < end) {\n            char c1 = jsonish.charAt(i + 1);\n            char c2 = jsonish.charAt(i + 2);\n            if ((']' == c1 || '\\\\' == c1) && ('>' == c2 || '\\\\' == c2)) {\n              replace(i, i + 1, \"\\\\u005d\");\n            }\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7': {\n              int octalStart = i + 1;\n              int octalEnd = octalStart;\n              ++octalEnd;\n              if (octalEnd < end && isOctAt(octalEnd)) {\n                ++octalEnd;\n                if (sch <= '3' && octalEnd < end && isOctAt(octalEnd)) {\n                  ++octalEnd;\n                }\n              }\n              int value = 0;\n              for (int j = octalStart; j < octalEnd; ++j) {\n                char digit = jsonish.charAt(j);\n                value = (value << 3) | (digit - '0');\n              }\n              replace(octalStart, octalEnd, \"u00\");\n              appendHex(value, 2);\n\n              i = octalEnd - 1;\n              break;\n            }\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \"\\-\" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n             // Proceed to hex-escape below since control characters are\n             // disallowed by ECMA-404 which governs JavaScript's `JSON.parse`.\n             // Common ones like CR, LF, and TAB are given short escape sequences above.\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\"'); }\n  }", "code_tokens": ["private", "void", "sanitizeString", "(", "int", "start", ",", "int", "end", ")", "{", "boolean", "closed", "=", "false", ";", "for", "(", "int", "i", "=", "start", ";", "i", "<", "end", ";", "++", "i", ")", "{", "char", "ch", "=", "jsonish", ".", "charAt", "(", "i", ")", ";", "switch", "(", "ch", ")", "{", "case", "'\\t'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "t", "\"", ")", ";", "break", ";", "case", "'\\n'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "n", "\"", ")", ";", "break", ";", "case", "'\\r'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "r", "\"", ")", ";", "break", ";", "case", "'\\u2028'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2028", "\"", ")", ";", "break", ";", "case", "'\\u2029'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2029", "\"", ")", ";", "break", ";", "case", "'\"'", ":", "case", "'\\''", ":", "if", "(", "i", "==", "start", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "{", "if", "(", "i", "+", "1", "==", "end", ")", "{", "char", "startDelim", "=", "jsonish", ".", "charAt", "(", "start", ")", ";", "if", "(", "startDelim", "!=", "'\\''", ")", "{", "startDelim", "=", "'\"'", ";", "}", "closed", "=", "startDelim", "==", "ch", ";", "}", "if", "(", "closed", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "if", "(", "ch", "==", "'\"'", ")", "{", "insert", "(", "i", ",", "'\\\\'", ")", ";", "}", "}", "break", ";", "case", "'<'", ":", "{", "if", "(", "i", "+", "3", ">=", "end", ")", "{", "break", ";", "}", "char", "c1", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "char", "c2", "=", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ";", "char", "c3", "=", "jsonish", ".", "charAt", "(", "i", "+", "3", ")", ";", "char", "lc1", "=", "(", "char", ")", "(", "c1", "|", "32", ")", ";", "char", "lc2", "=", "(", "char", ")", "(", "c2", "|", "32", ")", ";", "char", "lc3", "=", "(", "char", ")", "(", "c3", "|", "32", ")", ";", "if", "(", "(", "c1", "==", "'\\\\'", "||", "c2", "==", "'\\\\'", "||", "c3", "==", "'\\\\'", ")", "||", "(", "c1", "==", "'!'", "&&", "c2", "==", "'-'", "&&", "c3", "==", "'-'", ")", "||", "(", "lc1", "==", "'s'", "&&", "lc2", "==", "'c'", "&&", "lc3", "==", "'r'", ")", "||", "(", "c1", "==", "'/'", "&&", "lc2", "==", "'s'", "&&", "lc3", "==", "'c'", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u003c", "\"", ")", ";", "}", "break", ";", "}", "case", "'>'", ":", "if", "(", "(", "i", "-", "2", ")", ">=", "start", ")", "{", "int", "cm2", "=", "jsonish", ".", "charAt", "(", "i", "-", "2", ")", ";", "int", "cm1", "=", "jsonish", ".", "charAt", "(", "i", "-", "1", ")", ";", "if", "(", "(", "'-'", "==", "cm2", "||", "'\\\\'", "==", "cm2", ")", "&&", "(", "'-'", "==", "cm1", "||", "'\\\\'", "==", "cm1", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u003e", "\"", ")", ";", "}", "}", "break", ";", "case", "']'", ":", "if", "(", "i", "+", "2", "<", "end", ")", "{", "char", "c1", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "char", "c2", "=", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ";", "if", "(", "(", "']'", "==", "c1", "||", "'\\\\'", "==", "c1", ")", "&&", "(", "'>'", "==", "c2", "||", "'\\\\'", "==", "c2", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u005d", "\"", ")", ";", "}", "}", "break", ";", "case", "'\\\\'", ":", "if", "(", "i", "+", "1", "==", "end", ")", "{", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "char", "sch", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "switch", "(", "sch", ")", "{", "case", "'b'", ":", "case", "'f'", ":", "case", "'n'", ":", "case", "'r'", ":", "case", "'t'", ":", "case", "'\\\\'", ":", "case", "'/'", ":", "case", "'\"'", ":", "++", "i", ";", "break", ";", "case", "'v'", ":", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u0008", "\"", ")", ";", "++", "i", ";", "break", ";", "case", "'x'", ":", "if", "(", "i", "+", "4", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u00", "\"", ")", ";", "i", "+=", "3", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'u'", ":", "if", "(", "i", "+", "6", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", "&&", "isHexAt", "(", "i", "+", "4", ")", "&&", "isHexAt", "(", "i", "+", "5", ")", ")", "{", "i", "+=", "5", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'0'", ":", "case", "'1'", ":", "case", "'2'", ":", "case", "'3'", ":", "case", "'4'", ":", "case", "'5'", ":", "case", "'6'", ":", "case", "'7'", ":", "{", "int", "octalStart", "=", "i", "+", "1", ";", "int", "octalEnd", "=", "octalStart", ";", "++", "octalEnd", ";", "if", "(", "octalEnd", "<", "end", "&&", "isOctAt", "(", "octalEnd", ")", ")", "{", "++", "octalEnd", ";", "if", "(", "sch", "<=", "'3'", "&&", "octalEnd", "<", "end", "&&", "isOctAt", "(", "octalEnd", ")", ")", "{", "++", "octalEnd", ";", "}", "}", "int", "value", "=", "0", ";", "for", "(", "int", "j", "=", "octalStart", ";", "j", "<", "octalEnd", ";", "++", "j", ")", "{", "char", "digit", "=", "jsonish", ".", "charAt", "(", "j", ")", ";", "value", "=", "(", "value", "<<", "3", ")", "|", "(", "digit", "-", "'0'", ")", ";", "}", "replace", "(", "octalStart", ",", "octalEnd", ",", "\"", "u00", "\"", ")", ";", "appendHex", "(", "value", ",", "2", ")", ";", "i", "=", "octalEnd", "-", "1", ";", "break", ";", "}", "default", ":", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "break", ";", "default", ":", "if", "(", "ch", "<", "0x20", ")", "{", "}", "else", "if", "(", "ch", "<", "0xd800", ")", "{", "continue", ";", "}", "else", "if", "(", "ch", "<", "0xe000", ")", "{", "if", "(", "Character", ".", "isHighSurrogate", "(", "ch", ")", "&&", "i", "+", "1", "<", "end", "&&", "Character", ".", "isLowSurrogate", "(", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "continue", ";", "}", "}", "else", "if", "(", "ch", "<=", "0xfffd", ")", "{", "continue", ";", "}", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u", "\"", ")", ";", "for", "(", "int", "j", "=", "4", ";", "--", "j", ">=", "0", ";", ")", "{", "sanitizedJson", ".", "append", "(", "HEX_DIGITS", "[", "(", "ch", ">>>", "(", "j", "<<", "2", ")", ")", "&", "0xf", "]", ")", ";", "}", "break", ";", "}", "}", "if", "(", "!", "closed", ")", "{", "insert", "(", "end", ",", "'\"'", ")", ";", "}", "}"], "idx": 69760, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "89d91f328bd3eb46bee6b8ee78a5fce1e3a11c18", "function_name": "sanitizeString", "body_hash": "d5215c15cd9974c9793272abd6cd5d13c3c079a1"}
{"code": "protected Object readResolve()\r\n        throws ObjectStreamException {\r\n        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);\r\n        if (factory != null)\r\n            return factory;\r\n\r\n        // reset these transient fields to empty values\r\n        _transactional = new ConcurrentHashMap();\r\n        _brokers = newBrokerSet();\r\n\r\n        // turn off logging while de-serializing BrokerFactory\r\n        String saveLogConfig = _conf.getLog();\r\n        _conf.setLog(\"none\");\r\n        makeReadOnly();\r\n        // re-enable any logging which was in effect\r\n        _conf.setLog(saveLogConfig);\r\n        \r\n        return this;\r\n    }", "code_tokens": ["protected", "Object", "readResolve", "(", ")", "throws", "ObjectStreamException", "{", "AbstractBrokerFactory", "factory", "=", "getPooledFactoryForKey", "(", "_poolKey", ")", ";", "if", "(", "factory", "!=", "null", ")", "return", "factory", ";", "_transactional", "=", "new", "ConcurrentHashMap", "(", ")", ";", "_brokers", "=", "newBrokerSet", "(", ")", ";", "String", "saveLogConfig", "=", "_conf", ".", "getLog", "(", ")", ";", "_conf", ".", "setLog", "(", "\"", "none", "\"", ")", ";", "makeReadOnly", "(", ")", ";", "_conf", ".", "setLog", "(", "saveLogConfig", ")", ";", "return", "this", ";", "}"], "idx": 33095, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "521fecd2d9b91c27e9f90d97e5f5479d17239eb8", "function_name": "readResolve", "body_hash": "2df2294b0c203dc6a1d1e5709e8e18936c59baf3"}
{"code": "@SuppressWarnings(\"unchecked\")\n    public This transformObject(Saml2ObjectTransformer<T> tr) {\n        final StringTransformer original = this.transformer;\n        this.transformer = s -> {\n            final String originalTransformed = original.transform(s);\n\n            if (originalTransformed == null) {\n                return null;\n            }\n\n            final ByteArrayInputStream baos = new ByteArrayInputStream(originalTransformed.getBytes());\n            final T saml2Object = (T) new SAML2Response().getSAML2ObjectFromStream(baos);\n            final T transformed = tr.transform(saml2Object);\n\n            if (transformed == null) {\n                return null;\n            }\n\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            XMLStreamWriter xmlStreamWriter = StaxUtil.getXMLStreamWriter(bos);\n\n            if (transformed instanceof AuthnRequestType) {\n                new SAMLRequestWriter(xmlStreamWriter).write((AuthnRequestType) transformed);\n            } else if (transformed instanceof LogoutRequestType) {\n                new SAMLRequestWriter(xmlStreamWriter).write((LogoutRequestType) transformed);\n            } else if (transformed instanceof ArtifactResolveType) {\n                new SAMLRequestWriter(xmlStreamWriter).write((ArtifactResolveType) transformed);\n            } else if (transformed instanceof AttributeQueryType) {\n                new SAMLRequestWriter(xmlStreamWriter).write((AttributeQueryType) transformed);\n            } else if (transformed instanceof ResponseType) {\n                new SAMLResponseWriter(xmlStreamWriter).write((ResponseType) transformed);\n            } else if (transformed instanceof ArtifactResponseType) {\n                new SAMLResponseWriter(xmlStreamWriter).write((ArtifactResponseType) transformed);\n            } else if (transformed instanceof StatusResponseType) {\n                new SAMLResponseWriter(xmlStreamWriter).write((StatusResponseType) transformed, SAMLProtocolQNames.LOGOUT_RESPONSE.getQName(\"samlp\"));\n            } else {\n                Assert.assertNotNull(\"Unknown type: <null>\", transformed);\n                Assert.fail(\"Unknown type: \" + transformed.getClass().getName());\n            }\n            String res = new String(bos.toByteArray(), GeneralConstants.SAML_CHARSET);\n            LOG.debugf(\"  ---> %s\", res);\n            return res;\n        };\n        return (This) this;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "public", "This", "transformObject", "(", "Saml2ObjectTransformer", "<", "T", ">", "tr", ")", "{", "final", "StringTransformer", "original", "=", "this", ".", "transformer", ";", "this", ".", "transformer", "=", "s", "->", "{", "final", "String", "originalTransformed", "=", "original", ".", "transform", "(", "s", ")", ";", "if", "(", "originalTransformed", "==", "null", ")", "{", "return", "null", ";", "}", "final", "ByteArrayInputStream", "baos", "=", "new", "ByteArrayInputStream", "(", "originalTransformed", ".", "getBytes", "(", ")", ")", ";", "final", "T", "saml2Object", "=", "(", "T", ")", "new", "SAML2Response", "(", ")", ".", "getSAML2ObjectFromStream", "(", "baos", ")", ";", "final", "T", "transformed", "=", "tr", ".", "transform", "(", "saml2Object", ")", ";", "if", "(", "transformed", "==", "null", ")", "{", "return", "null", ";", "}", "ByteArrayOutputStream", "bos", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "XMLStreamWriter", "xmlStreamWriter", "=", "StaxUtil", ".", "getXMLStreamWriter", "(", "bos", ")", ";", "if", "(", "transformed", "instanceof", "AuthnRequestType", ")", "{", "new", "SAMLRequestWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "AuthnRequestType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "LogoutRequestType", ")", "{", "new", "SAMLRequestWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "LogoutRequestType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "ArtifactResolveType", ")", "{", "new", "SAMLRequestWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "ArtifactResolveType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "AttributeQueryType", ")", "{", "new", "SAMLRequestWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "AttributeQueryType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "ResponseType", ")", "{", "new", "SAMLResponseWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "ResponseType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "ArtifactResponseType", ")", "{", "new", "SAMLResponseWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "ArtifactResponseType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "StatusResponseType", ")", "{", "new", "SAMLResponseWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "StatusResponseType", ")", "transformed", ",", "SAMLProtocolQNames", ".", "LOGOUT_RESPONSE", ".", "getQName", "(", "\"", "samlp", "\"", ")", ")", ";", "}", "else", "{", "Assert", ".", "assertNotNull", "(", "\"", "Unknown type: <null>", "\"", ",", "transformed", ")", ";", "Assert", ".", "fail", "(", "\"", "Unknown type: ", "\"", "+", "transformed", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ";", "}", "String", "res", "=", "new", "String", "(", "bos", ".", "toByteArray", "(", ")", ",", "GeneralConstants", ".", "SAML_CHARSET", ")", ";", "LOG", ".", "debugf", "(", "\"", "  ---> %s", "\"", ",", "res", ")", ";", "return", "res", ";", "}", ";", "return", "(", "This", ")", "this", ";", "}"], "idx": 39593, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "0fe0b875d63cce3d2855d85d25bb8757bce13eb1", "function_name": "transformObject", "body_hash": "64b08f989cdf9eb34ae743374a9d45f22851d372"}
{"code": "protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #\" + i + \": \" + part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #\" + i + \": is mimetype: multipart/*\");\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = part.getFileName();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                        DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "extractAttachmentsFromMultipart", "(", "Multipart", "mp", ",", "Map", "<", "String", ",", "Attachment", ">", "map", ")", "throws", "MessagingException", ",", "IOException", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "mp", ".", "getCount", "(", ")", ";", "i", "++", ")", "{", "Part", "part", "=", "mp", ".", "getBodyPart", "(", "i", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #", "\"", "+", "i", "+", "\"", ": ", "\"", "+", "part", ")", ";", "if", "(", "part", ".", "isMimeType", "(", "\"", "multipart/*", "\"", ")", ")", "{", "LOG", ".", "trace", "(", "\"", "Part #", "\"", "+", "i", "+", "\"", ": is mimetype: multipart/*", "\"", ")", ";", "extractAttachmentsFromMultipart", "(", "(", "Multipart", ")", "part", ".", "getContent", "(", ")", ",", "map", ")", ";", "}", "else", "{", "String", "disposition", "=", "part", ".", "getDisposition", "(", ")", ";", "String", "fileName", "=", "part", ".", "getFileName", "(", ")", ";", "if", "(", "LOG", ".", "isTraceEnabled", "(", ")", ")", "{", "LOG", ".", "trace", "(", "\"", "Part #{}: Disposition: {}", "\"", ",", "i", ",", "disposition", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: Description: {}", "\"", ",", "i", ",", "part", ".", "getDescription", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: ContentType: {}", "\"", ",", "i", ",", "part", ".", "getContentType", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: FileName: {}", "\"", ",", "i", ",", "fileName", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: Size: {}", "\"", ",", "i", ",", "part", ".", "getSize", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: LineCount: {}", "\"", ",", "i", ",", "part", ".", "getLineCount", "(", ")", ")", ";", "}", "if", "(", "validDisposition", "(", "disposition", ",", "fileName", ")", "||", "fileName", "!=", "null", ")", "{", "LOG", ".", "debug", "(", "\"", "Mail contains file attachment: {}", "\"", ",", "fileName", ")", ";", "if", "(", "!", "map", ".", "containsKey", "(", "fileName", ")", ")", "{", "DefaultAttachment", "camelAttachment", "=", "new", "DefaultAttachment", "(", "part", ".", "getDataHandler", "(", ")", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Enumeration", "<", "Header", ">", "headers", "=", "part", ".", "getAllHeaders", "(", ")", ";", "while", "(", "headers", ".", "hasMoreElements", "(", ")", ")", "{", "Header", "header", "=", "headers", ".", "nextElement", "(", ")", ";", "camelAttachment", ".", "addHeader", "(", "header", ".", "getName", "(", ")", ",", "header", ".", "getValue", "(", ")", ")", ";", "}", "map", ".", "put", "(", "fileName", ",", "camelAttachment", ")", ";", "}", "else", "{", "LOG", ".", "warn", "(", "\"", "Cannot extract duplicate file attachment: {}.", "\"", ",", "fileName", ")", ";", "}", "}", "}", "}", "}"], "idx": 21245, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "63c7c080de4d18f9ceb25843508710df2c2c6d4", "function_name": "extractAttachmentsFromMultipart", "body_hash": "36ccb2a41dab755f4f5b9e6d89b6484c5eb47f1e"}
{"code": "public Object eval(String xml, String path, QName qname) {\n    if (xml == null || path == null || qname == null) {\n      return null;\n    }\n\n    if (xml.length() == 0 || path.length() == 0) {\n      return null;\n    }\n\n    if (!path.equals(oldPath)) {\n      try {\n        expression = xpath.compile(path);\n      } catch (XPathExpressionException e) {\n        expression = null;\n      }\n      oldPath = path;\n    }\n\n    if (expression == null) {\n      return null;\n    }\n\n    reader.set(xml);\n\n    try {\n      return expression.evaluate(inputSource, qname);\n    } catch (XPathExpressionException e) {\n      throw new RuntimeException (\"Invalid expression '\" + oldPath + \"'\", e);\n    }\n  }", "code_tokens": ["public", "Object", "eval", "(", "String", "xml", ",", "String", "path", ",", "QName", "qname", ")", "{", "if", "(", "xml", "==", "null", "||", "path", "==", "null", "||", "qname", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "xml", ".", "length", "(", ")", "==", "0", "||", "path", ".", "length", "(", ")", "==", "0", ")", "{", "return", "null", ";", "}", "if", "(", "!", "path", ".", "equals", "(", "oldPath", ")", ")", "{", "try", "{", "expression", "=", "xpath", ".", "compile", "(", "path", ")", ";", "}", "catch", "(", "XPathExpressionException", "e", ")", "{", "expression", "=", "null", ";", "}", "oldPath", "=", "path", ";", "}", "if", "(", "expression", "==", "null", ")", "{", "return", "null", ";", "}", "reader", ".", "set", "(", "xml", ")", ";", "try", "{", "return", "expression", ".", "evaluate", "(", "inputSource", ",", "qname", ")", ";", "}", "catch", "(", "XPathExpressionException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Invalid expression '", "\"", "+", "oldPath", "+", "\"", "'", "\"", ",", "e", ")", ";", "}", "}"], "idx": 18597, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "b0a58d245875dc1b3ac58a7cf1a61d3b17805e96", "function_name": "eval", "body_hash": "bf7cca6ca51eca0e272924d93fdb58a14a32b124"}
{"code": "public ResourceInvoker match(HttpRequest request, int start)\r\n   {\r\n      if (!CACHE || (request.getHttpHeaders().getMediaType() !=null && !request.getHttpHeaders().getMediaType().getParameters().isEmpty())) {\r\n         return root.match(request, start).invoker;\r\n      }\r\n      MatchCache.Key key = new MatchCache.Key(request, start);\r\n      MatchCache match = cache.get(key);\r\n      if (match != null) {\r\n         //System.out.println(\"*** cache hit: \" + key.method + \" \" + key.path);\r\n         request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\r\n      } else {\r\n         match = root.match(request, start);\r\n         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r\n            //System.out.println(\"*** caching: \" + key.method + \" \" + key.path);\r\n            match.match = null;\r\n            if (cache.size() >= CACHE_SIZE) {\r\n               cache.clear();\r\n            }\r\n            cache.putIfAbsent(key, match);\r\n         }\r\n      }\r\n      return match.invoker;\r\n   }", "code_tokens": ["public", "ResourceInvoker", "match", "(", "HttpRequest", "request", ",", "int", "start", ")", "{", "if", "(", "!", "CACHE", "||", "(", "request", ".", "getHttpHeaders", "(", ")", ".", "getMediaType", "(", ")", "!=", "null", "&&", "!", "request", ".", "getHttpHeaders", "(", ")", ".", "getMediaType", "(", ")", ".", "getParameters", "(", ")", ".", "isEmpty", "(", ")", ")", ")", "{", "return", "root", ".", "match", "(", "request", ",", "start", ")", ".", "invoker", ";", "}", "MatchCache", ".", "Key", "key", "=", "new", "MatchCache", ".", "Key", "(", "request", ",", "start", ")", ";", "MatchCache", "match", "=", "cache", ".", "get", "(", "key", ")", ";", "if", "(", "match", "!=", "null", ")", "{", "request", ".", "setAttribute", "(", "RESTEASY_CHOSEN_ACCEPT", ",", "match", ".", "chosen", ")", ";", "}", "else", "{", "match", "=", "root", ".", "match", "(", "request", ",", "start", ")", ";", "if", "(", "match", ".", "match", "!=", "null", "&&", "match", ".", "match", ".", "expression", ".", "getNumGroups", "(", ")", "==", "0", "&&", "match", ".", "invoker", "instanceof", "ResourceMethodInvoker", ")", "{", "match", ".", "match", "=", "null", ";", "if", "(", "cache", ".", "size", "(", ")", ">=", "CACHE_SIZE", ")", "{", "cache", ".", "clear", "(", ")", ";", "}", "cache", ".", "putIfAbsent", "(", "key", ",", "match", ")", ";", "}", "}", "return", "match", ".", "invoker", ";", "}"], "idx": 115268, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "dd255d654f15b5b270a166d695f8813dc08675d4", "function_name": "match", "body_hash": "5c905651856b8ab5c13dafe97282dcca84ffed25"}
{"code": "@Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }\n                protected Collection<TopLevelItem> all() { return getAllItems(TopLevelItem.class); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {// for computers\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {// for users\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {// for views\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return viewGroupMixIn.getViews(); }\n            });\n    }", "code_tokens": ["@", "Override", "public", "SearchIndexBuilder", "makeSearchIndex", "(", ")", "{", "return", "super", ".", "makeSearchIndex", "(", ")", ".", "add", "(", "\"", "configure", "\"", ",", "\"", "config", "\"", ",", "\"", "configure", "\"", ")", ".", "add", "(", "\"", "manage", "\"", ")", ".", "add", "(", "\"", "log", "\"", ")", ".", "add", "(", "new", "CollectionSearchIndex", "<", "TopLevelItem", ">", "(", ")", "{", "protected", "SearchItem", "get", "(", "String", "key", ")", "{", "return", "getItemByFullName", "(", "key", ",", "TopLevelItem", ".", "class", ")", ";", "}", "protected", "Collection", "<", "TopLevelItem", ">", "all", "(", ")", "{", "return", "getAllItems", "(", "TopLevelItem", ".", "class", ")", ";", "}", "}", ")", ".", "add", "(", "getPrimaryView", "(", ")", ".", "makeSearchIndex", "(", ")", ")", ".", "add", "(", "new", "CollectionSearchIndex", "(", ")", "{", "protected", "Computer", "get", "(", "String", "key", ")", "{", "return", "getComputer", "(", "key", ")", ";", "}", "protected", "Collection", "<", "Computer", ">", "all", "(", ")", "{", "return", "computers", ".", "values", "(", ")", ";", "}", "}", ")", ".", "add", "(", "new", "CollectionSearchIndex", "(", ")", "{", "protected", "User", "get", "(", "String", "key", ")", "{", "return", "User", ".", "get", "(", "key", ",", "false", ")", ";", "}", "protected", "Collection", "<", "User", ">", "all", "(", ")", "{", "return", "User", ".", "getAll", "(", ")", ";", "}", "}", ")", ".", "add", "(", "new", "CollectionSearchIndex", "(", ")", "{", "protected", "View", "get", "(", "String", "key", ")", "{", "return", "getView", "(", "key", ")", ";", "}", "protected", "Collection", "<", "View", ">", "all", "(", ")", "{", "return", "viewGroupMixIn", ".", "getViews", "(", ")", ";", "}", "}", ")", ";", "}"], "idx": 13365, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "246a0fa90a05b729eaabca6d697016015f622e57", "function_name": "makeSearchIndex", "body_hash": "2e3e1f428aa42dd4cb8c876f25e11220f41efeb9"}
{"code": "protected void sendDirectory(HttpServletRequest request,\n            HttpServletResponse response,\n            Resource resource,\n            String pathInContext)\n    throws IOException\n    {\n        if (!_dirAllowed)\n        {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n\n        byte[] data=null;\n        String base = URIUtil.addPaths(request.getRequestURI(),URIUtil.SLASH);\n\n        //If the DefaultServlet has a resource base set, use it\n        if (_resourceBase != null)\n        {\n            // handle ResourceCollection\n            if (_resourceBase instanceof ResourceCollection)\n                resource=_resourceBase.addPath(pathInContext);\n        }\n        //Otherwise, try using the resource base of its enclosing context handler\n        else if (_contextHandler.getBaseResource() instanceof ResourceCollection)\n            resource=_contextHandler.getBaseResource().addPath(pathInContext);\n\n        String dir = resource.getListHTML(base,pathInContext.length()>1);\n        if (dir==null)\n        {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN,\n            \"No directory\");\n            return;\n        }\n\n        data=dir.getBytes(\"UTF-8\");\n        response.setContentType(\"text/html; charset=UTF-8\");\n        response.setContentLength(data.length);\n        response.getOutputStream().write(data);\n    }", "code_tokens": ["protected", "void", "sendDirectory", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Resource", "resource", ",", "String", "pathInContext", ")", "throws", "IOException", "{", "if", "(", "!", "_dirAllowed", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ")", ";", "return", ";", "}", "byte", "[", "]", "data", "=", "null", ";", "String", "base", "=", "URIUtil", ".", "addPaths", "(", "request", ".", "getRequestURI", "(", ")", ",", "URIUtil", ".", "SLASH", ")", ";", "if", "(", "_resourceBase", "!=", "null", ")", "{", "if", "(", "_resourceBase", "instanceof", "ResourceCollection", ")", "resource", "=", "_resourceBase", ".", "addPath", "(", "pathInContext", ")", ";", "}", "else", "if", "(", "_contextHandler", ".", "getBaseResource", "(", ")", "instanceof", "ResourceCollection", ")", "resource", "=", "_contextHandler", ".", "getBaseResource", "(", ")", ".", "addPath", "(", "pathInContext", ")", ";", "String", "dir", "=", "resource", ".", "getListHTML", "(", "base", ",", "pathInContext", ".", "length", "(", ")", ">", "1", ")", ";", "if", "(", "dir", "==", "null", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ",", "\"", "No directory", "\"", ")", ";", "return", ";", "}", "data", "=", "dir", ".", "getBytes", "(", "\"", "UTF-8", "\"", ")", ";", "response", ".", "setContentType", "(", "\"", "text/html; charset=UTF-8", "\"", ")", ";", "response", ".", "setContentLength", "(", "data", ".", "length", ")", ";", "response", ".", "getOutputStream", "(", ")", ".", "write", "(", "data", ")", ";", "}"], "idx": 79546, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "ca77bd384a2970cabbbdab25cf6251c6fb76cd21", "function_name": "sendDirectory", "body_hash": "763a8b69bd47e9bfa96855825034294e70da52bf"}
{"code": "@SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"False positive\")\n    public synchronized int run(String[] args) throws Exception{\n        if (used) {\n            throw new IllegalStateException(\"CLI instance already used\");\n        }\n\n        used = true;\n\n        CLIParser parser = new CLIParser(\"oozie-setup.sh\", HELP_INFO);\n        String oozieHome = System.getProperty(OOZIE_HOME);\n        parser.addCommand(HELP_CMD, \"\", \"display usage for all commands or specified command\", new Options(), false);\n        parser.addCommand(CREATE_CMD, \"\", \"create a new timestamped version of oozie sharelib\",\n                createUpgradeOptions(CREATE_CMD), false);\n        parser.addCommand(UPGRADE_CMD, \"\",\n                \"[deprecated][use command \\\"create\\\" to create new version]   upgrade oozie sharelib \\n\",\n                createUpgradeOptions(UPGRADE_CMD), false);\n\n        try {\n            final CLIParser.Command command = parser.parse(args);\n            String sharelibAction = command.getName();\n\n            if (sharelibAction.equals(HELP_CMD)){\n                parser.showHelp(command.getCommandLine());\n                return 0;\n            }\n\n            if (!command.getCommandLine().hasOption(FS_OPT)){\n                throw new Exception(\"-fs option must be specified\");\n            }\n\n            int threadPoolSize = Integer.valueOf(command.getCommandLine().getOptionValue(CONCURRENCY_OPT, \"1\"));\n            File srcFile = null;\n\n            //Check whether user provided locallib\n            if (command.getCommandLine().hasOption(LIB_OPT)){\n                srcFile = new File(command.getCommandLine().getOptionValue(LIB_OPT));\n            }\n            else {\n                //Since user did not provide locallib, find the default one under oozie home dir\n                Collection<File> files =\n                        FileUtils.listFiles(new File(oozieHome), new WildcardFileFilter(\"oozie-sharelib*.tar.gz\"), null);\n\n                if (files.size() > 1){\n                    throw new IOException(\"more than one sharelib tar found at \" + oozieHome);\n                }\n\n                if (files.isEmpty()){\n                    throw new IOException(\"default sharelib tar not found in oozie home dir: \" + oozieHome);\n                }\n\n                srcFile = files.iterator().next();\n            }\n\n            Map<String, String> extraLibs = new HashMap<>();\n            if (command.getCommandLine().hasOption(EXTRALIBS)) {\n                String[] param = command.getCommandLine().getOptionValues(EXTRALIBS);\n                extraLibs = getExtraLibs(param);\n            }\n\n            File temp = File.createTempFile(\"oozie\", \".dir\");\n            temp.delete();\n            temp.mkdir();\n            temp.deleteOnExit();\n\n            //Check whether the lib is a tar file or folder\n            if (!srcFile.isDirectory()){\n                FileUtil.unTar(srcFile, temp);\n                srcFile = new File(temp.toString() + \"/share/lib\");\n            }\n            else {\n                //Get the lib directory since it's a folder\n                srcFile = new File(srcFile, \"lib\");\n            }\n\n            String hdfsUri = command.getCommandLine().getOptionValue(FS_OPT);\n            Path srcPath = new Path(srcFile.toString());\n\n            Services services = new Services();\n            services.getConf().set(Services.CONF_SERVICE_CLASSES,\n                \"org.apache.oozie.service.LiteWorkflowAppService, org.apache.oozie.service.HadoopAccessorService\");\n            services.getConf().set(Services.CONF_SERVICE_EXT_CLASSES, \"\");\n            services.init();\n            WorkflowAppService lwas = services.get(WorkflowAppService.class);\n            HadoopAccessorService has = services.get(HadoopAccessorService.class);\n            Path dstPath = lwas.getSystemLibPath();\n\n            URI uri = new Path(hdfsUri).toUri();\n            Configuration fsConf = has.createConfiguration(uri.getAuthority());\n            FileSystem fs = FileSystem.get(uri, fsConf);\n\n            if (!fs.exists(dstPath)) {\n                fs.mkdirs(dstPath);\n            }\n            ECPolicyDisabler.tryDisableECPolicyForPath(fs, dstPath);\n\n            if (sharelibAction.equals(CREATE_CMD) || sharelibAction.equals(UPGRADE_CMD)){\n                dstPath= new Path(dstPath.toString() +  Path.SEPARATOR +  SHARE_LIB_PREFIX + getTimestampDirectory()  );\n            }\n\n            System.out.println(\"the destination path for sharelib is: \" + dstPath);\n\n            checkIfSourceFilesExist(srcFile);\n            copyToSharelib(threadPoolSize, srcFile, srcPath, dstPath, fs);\n            copyExtraLibs(threadPoolSize, extraLibs, dstPath, fs);\n\n            if (sharelibAction.equals(CREATE_CMD) || sharelibAction.equals(UPGRADE_CMD)) {\n                applySharelibPermission(fs, dstPath);\n            }\n\n            services.destroy();\n            FileUtils.deleteDirectory(temp);\n\n            return 0;\n        }\n        catch (ParseException ex) {\n            System.err.println(\"Invalid sub-command: \" + ex.getMessage());\n            System.err.println();\n            System.err.println(parser.shortHelp());\n            return 1;\n        }\n        catch (NumberFormatException ex) {\n            logError(\"Invalid configuration value: \", ex);\n            return 1;\n        }\n        catch (Exception ex) {\n            logError(ex.getMessage(), ex);\n            return 1;\n        }\n    }", "code_tokens": ["@", "SuppressFBWarnings", "(", "value", "=", "\"", "PATH_TRAVERSAL_IN", "\"", ",", "justification", "=", "\"", "False positive", "\"", ")", "public", "synchronized", "int", "run", "(", "String", "[", "]", "args", ")", "throws", "Exception", "{", "if", "(", "used", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "CLI instance already used", "\"", ")", ";", "}", "used", "=", "true", ";", "CLIParser", "parser", "=", "new", "CLIParser", "(", "\"", "oozie-setup.sh", "\"", ",", "HELP_INFO", ")", ";", "String", "oozieHome", "=", "System", ".", "getProperty", "(", "OOZIE_HOME", ")", ";", "parser", ".", "addCommand", "(", "HELP_CMD", ",", "\"", "\"", ",", "\"", "display usage for all commands or specified command", "\"", ",", "new", "Options", "(", ")", ",", "false", ")", ";", "parser", ".", "addCommand", "(", "CREATE_CMD", ",", "\"", "\"", ",", "\"", "create a new timestamped version of oozie sharelib", "\"", ",", "createUpgradeOptions", "(", "CREATE_CMD", ")", ",", "false", ")", ";", "parser", ".", "addCommand", "(", "UPGRADE_CMD", ",", "\"", "\"", ",", "\"", "[deprecated][use command ", "\\\"", "create", "\\\"", " to create new version]   upgrade oozie sharelib ", "\\n", "\"", ",", "createUpgradeOptions", "(", "UPGRADE_CMD", ")", ",", "false", ")", ";", "try", "{", "final", "CLIParser", ".", "Command", "command", "=", "parser", ".", "parse", "(", "args", ")", ";", "String", "sharelibAction", "=", "command", ".", "getName", "(", ")", ";", "if", "(", "sharelibAction", ".", "equals", "(", "HELP_CMD", ")", ")", "{", "parser", ".", "showHelp", "(", "command", ".", "getCommandLine", "(", ")", ")", ";", "return", "0", ";", "}", "if", "(", "!", "command", ".", "getCommandLine", "(", ")", ".", "hasOption", "(", "FS_OPT", ")", ")", "{", "throw", "new", "Exception", "(", "\"", "-fs option must be specified", "\"", ")", ";", "}", "int", "threadPoolSize", "=", "Integer", ".", "valueOf", "(", "command", ".", "getCommandLine", "(", ")", ".", "getOptionValue", "(", "CONCURRENCY_OPT", ",", "\"", "1", "\"", ")", ")", ";", "File", "srcFile", "=", "null", ";", "if", "(", "command", ".", "getCommandLine", "(", ")", ".", "hasOption", "(", "LIB_OPT", ")", ")", "{", "srcFile", "=", "new", "File", "(", "command", ".", "getCommandLine", "(", ")", ".", "getOptionValue", "(", "LIB_OPT", ")", ")", ";", "}", "else", "{", "Collection", "<", "File", ">", "files", "=", "FileUtils", ".", "listFiles", "(", "new", "File", "(", "oozieHome", ")", ",", "new", "WildcardFileFilter", "(", "\"", "oozie-sharelib*.tar.gz", "\"", ")", ",", "null", ")", ";", "if", "(", "files", ".", "size", "(", ")", ">", "1", ")", "{", "throw", "new", "IOException", "(", "\"", "more than one sharelib tar found at ", "\"", "+", "oozieHome", ")", ";", "}", "if", "(", "files", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "default sharelib tar not found in oozie home dir: ", "\"", "+", "oozieHome", ")", ";", "}", "srcFile", "=", "files", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "}", "Map", "<", "String", ",", "String", ">", "extraLibs", "=", "new", "HashMap", "<", ">", "(", ")", ";", "if", "(", "command", ".", "getCommandLine", "(", ")", ".", "hasOption", "(", "EXTRALIBS", ")", ")", "{", "String", "[", "]", "param", "=", "command", ".", "getCommandLine", "(", ")", ".", "getOptionValues", "(", "EXTRALIBS", ")", ";", "extraLibs", "=", "getExtraLibs", "(", "param", ")", ";", "}", "File", "temp", "=", "File", ".", "createTempFile", "(", "\"", "oozie", "\"", ",", "\"", ".dir", "\"", ")", ";", "temp", ".", "delete", "(", ")", ";", "temp", ".", "mkdir", "(", ")", ";", "temp", ".", "deleteOnExit", "(", ")", ";", "if", "(", "!", "srcFile", ".", "isDirectory", "(", ")", ")", "{", "FileUtil", ".", "unTar", "(", "srcFile", ",", "temp", ")", ";", "srcFile", "=", "new", "File", "(", "temp", ".", "toString", "(", ")", "+", "\"", "/share/lib", "\"", ")", ";", "}", "else", "{", "srcFile", "=", "new", "File", "(", "srcFile", ",", "\"", "lib", "\"", ")", ";", "}", "String", "hdfsUri", "=", "command", ".", "getCommandLine", "(", ")", ".", "getOptionValue", "(", "FS_OPT", ")", ";", "Path", "srcPath", "=", "new", "Path", "(", "srcFile", ".", "toString", "(", ")", ")", ";", "Services", "services", "=", "new", "Services", "(", ")", ";", "services", ".", "getConf", "(", ")", ".", "set", "(", "Services", ".", "CONF_SERVICE_CLASSES", ",", "\"", "org.apache.oozie.service.LiteWorkflowAppService, org.apache.oozie.service.HadoopAccessorService", "\"", ")", ";", "services", ".", "getConf", "(", ")", ".", "set", "(", "Services", ".", "CONF_SERVICE_EXT_CLASSES", ",", "\"", "\"", ")", ";", "services", ".", "init", "(", ")", ";", "WorkflowAppService", "lwas", "=", "services", ".", "get", "(", "WorkflowAppService", ".", "class", ")", ";", "HadoopAccessorService", "has", "=", "services", ".", "get", "(", "HadoopAccessorService", ".", "class", ")", ";", "Path", "dstPath", "=", "lwas", ".", "getSystemLibPath", "(", ")", ";", "URI", "uri", "=", "new", "Path", "(", "hdfsUri", ")", ".", "toUri", "(", ")", ";", "Configuration", "fsConf", "=", "has", ".", "createConfiguration", "(", "uri", ".", "getAuthority", "(", ")", ")", ";", "FileSystem", "fs", "=", "FileSystem", ".", "get", "(", "uri", ",", "fsConf", ")", ";", "if", "(", "!", "fs", ".", "exists", "(", "dstPath", ")", ")", "{", "fs", ".", "mkdirs", "(", "dstPath", ")", ";", "}", "ECPolicyDisabler", ".", "tryDisableECPolicyForPath", "(", "fs", ",", "dstPath", ")", ";", "if", "(", "sharelibAction", ".", "equals", "(", "CREATE_CMD", ")", "||", "sharelibAction", ".", "equals", "(", "UPGRADE_CMD", ")", ")", "{", "dstPath", "=", "new", "Path", "(", "dstPath", ".", "toString", "(", ")", "+", "Path", ".", "SEPARATOR", "+", "SHARE_LIB_PREFIX", "+", "getTimestampDirectory", "(", ")", ")", ";", "}", "System", ".", "out", ".", "println", "(", "\"", "the destination path for sharelib is: ", "\"", "+", "dstPath", ")", ";", "checkIfSourceFilesExist", "(", "srcFile", ")", ";", "copyToSharelib", "(", "threadPoolSize", ",", "srcFile", ",", "srcPath", ",", "dstPath", ",", "fs", ")", ";", "copyExtraLibs", "(", "threadPoolSize", ",", "extraLibs", ",", "dstPath", ",", "fs", ")", ";", "if", "(", "sharelibAction", ".", "equals", "(", "CREATE_CMD", ")", "||", "sharelibAction", ".", "equals", "(", "UPGRADE_CMD", ")", ")", "{", "applySharelibPermission", "(", "fs", ",", "dstPath", ")", ";", "}", "services", ".", "destroy", "(", ")", ";", "FileUtils", ".", "deleteDirectory", "(", "temp", ")", ";", "return", "0", ";", "}", "catch", "(", "ParseException", "ex", ")", "{", "System", ".", "err", ".", "println", "(", "\"", "Invalid sub-command: ", "\"", "+", "ex", ".", "getMessage", "(", ")", ")", ";", "System", ".", "err", ".", "println", "(", ")", ";", "System", ".", "err", ".", "println", "(", "parser", ".", "shortHelp", "(", ")", ")", ";", "return", "1", ";", "}", "catch", "(", "NumberFormatException", "ex", ")", "{", "logError", "(", "\"", "Invalid configuration value: ", "\"", ",", "ex", ")", ";", "return", "1", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "logError", "(", "ex", ".", "getMessage", "(", ")", ",", "ex", ")", ";", "return", "1", ";", "}", "}"], "idx": 49427, "cwe": "CWE-362", "target": 1, "status": "VULNERABLE", "commit": "f1e01a9e155692aa5632f4573ab1b3ebeab7ef45", "function_name": "run", "body_hash": "140af3ca0cecff5032acd9be31689c906cfe8f49"}
{"code": "public void execute(final FunctionContext context) {\n    CliFunctionResult result = null;\n    String memberId = context.getCache().getDistributedSystem().getDistributedMember().getId();\n    try {\n      LuceneDestroyIndexInfo indexInfo = (LuceneDestroyIndexInfo) context.getArguments();\n      String indexName = indexInfo.getIndexName();\n      String regionPath = indexInfo.getRegionPath();\n      LuceneService service = LuceneServiceProvider.get(context.getCache());\n      if (indexName == null) {\n        if (indexInfo.isDefinedDestroyOnly()) {\n          ((LuceneServiceImpl) service).destroyDefinedIndexes(regionPath);\n          result = new CliFunctionResult(memberId);\n        } else {\n          service.destroyIndexes(regionPath);\n          result = new CliFunctionResult(memberId, getXmlEntity(indexName, regionPath));\n        }\n      } else {\n        if (indexInfo.isDefinedDestroyOnly()) {\n          ((LuceneServiceImpl) service).destroyDefinedIndex(indexName, regionPath);\n          result = new CliFunctionResult(memberId);\n        } else {\n          service.destroyIndex(indexName, regionPath);\n          result = new CliFunctionResult(memberId, getXmlEntity(indexName, regionPath));\n        }\n      }\n    } catch (Exception e) {\n      result = new CliFunctionResult(memberId, e, e.getMessage());\n    }\n    context.getResultSender().lastResult(result);\n  }", "code_tokens": ["public", "void", "execute", "(", "final", "FunctionContext", "context", ")", "{", "CliFunctionResult", "result", "=", "null", ";", "String", "memberId", "=", "context", ".", "getCache", "(", ")", ".", "getDistributedSystem", "(", ")", ".", "getDistributedMember", "(", ")", ".", "getId", "(", ")", ";", "try", "{", "LuceneDestroyIndexInfo", "indexInfo", "=", "(", "LuceneDestroyIndexInfo", ")", "context", ".", "getArguments", "(", ")", ";", "String", "indexName", "=", "indexInfo", ".", "getIndexName", "(", ")", ";", "String", "regionPath", "=", "indexInfo", ".", "getRegionPath", "(", ")", ";", "LuceneService", "service", "=", "LuceneServiceProvider", ".", "get", "(", "context", ".", "getCache", "(", ")", ")", ";", "if", "(", "indexName", "==", "null", ")", "{", "if", "(", "indexInfo", ".", "isDefinedDestroyOnly", "(", ")", ")", "{", "(", "(", "LuceneServiceImpl", ")", "service", ")", ".", "destroyDefinedIndexes", "(", "regionPath", ")", ";", "result", "=", "new", "CliFunctionResult", "(", "memberId", ")", ";", "}", "else", "{", "service", ".", "destroyIndexes", "(", "regionPath", ")", ";", "result", "=", "new", "CliFunctionResult", "(", "memberId", ",", "getXmlEntity", "(", "indexName", ",", "regionPath", ")", ")", ";", "}", "}", "else", "{", "if", "(", "indexInfo", ".", "isDefinedDestroyOnly", "(", ")", ")", "{", "(", "(", "LuceneServiceImpl", ")", "service", ")", ".", "destroyDefinedIndex", "(", "indexName", ",", "regionPath", ")", ";", "result", "=", "new", "CliFunctionResult", "(", "memberId", ")", ";", "}", "else", "{", "service", ".", "destroyIndex", "(", "indexName", ",", "regionPath", ")", ";", "result", "=", "new", "CliFunctionResult", "(", "memberId", ",", "getXmlEntity", "(", "indexName", ",", "regionPath", ")", ")", ";", "}", "}", "}", "catch", "(", "Exception", "e", ")", "{", "result", "=", "new", "CliFunctionResult", "(", "memberId", ",", "e", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "context", ".", "getResultSender", "(", ")", ".", "lastResult", "(", "result", ")", ";", "}"], "idx": 88200, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "740289c61d60256c6270756bc84b9e24b76e4913", "function_name": "execute", "body_hash": "5bde7445717962b454675988dcf52ad4068c4e5c"}
{"code": "@SuppressJava6Requirement(reason = \"Guarded by version check\")\n    public static File createTempFile(String prefix, String suffix, File directory) throws IOException {\n        if (javaVersion() >= 7) {\n            if (directory == null) {\n                return Files.createTempFile(prefix, suffix).toFile();\n            }\n            return Files.createTempFile(directory.toPath(), prefix, suffix).toFile();\n        }\n        if (directory == null) {\n            return File.createTempFile(prefix, suffix);\n        }\n        File file = File.createTempFile(prefix, suffix, directory);\n        // Try to adjust the perms, if this fails there is not much else we can do...\n        file.setReadable(false, false);\n        file.setReadable(true, true);\n        return file;\n    }", "code_tokens": ["@", "SuppressJava6Requirement", "(", "reason", "=", "\"", "Guarded by version check", "\"", ")", "public", "static", "File", "createTempFile", "(", "String", "prefix", ",", "String", "suffix", ",", "File", "directory", ")", "throws", "IOException", "{", "if", "(", "javaVersion", "(", ")", ">=", "7", ")", "{", "if", "(", "directory", "==", "null", ")", "{", "return", "Files", ".", "createTempFile", "(", "prefix", ",", "suffix", ")", ".", "toFile", "(", ")", ";", "}", "return", "Files", ".", "createTempFile", "(", "directory", ".", "toPath", "(", ")", ",", "prefix", ",", "suffix", ")", ".", "toFile", "(", ")", ";", "}", "if", "(", "directory", "==", "null", ")", "{", "return", "File", ".", "createTempFile", "(", "prefix", ",", "suffix", ")", ";", "}", "File", "file", "=", "File", ".", "createTempFile", "(", "prefix", ",", "suffix", ",", "directory", ")", ";", "file", ".", "setReadable", "(", "false", ",", "false", ")", ";", "file", ".", "setReadable", "(", "true", ",", "true", ")", ";", "return", "file", ";", "}"], "idx": 71505, "cwe": "CWE-668", "target": 1, "status": "VULNERABLE", "commit": "185f8b2756a36aaa4f973f1a2a025e7d981823f1", "function_name": "createTempFile", "body_hash": "d09aa4db257dd2b43d3601f54295b451a8914463"}
{"code": "protected synchronized void decorateWithTLS(TLSClientParameters tlsClientParameters, \n            HttpURLConnection connection) throws GeneralSecurityException {\n\n        \n        int hash = tlsClientParameters.hashCode();\n        if (hash != lastTlsHash) {\n            lastTlsHash = hash;\n            socketFactory = null;\n        }\n        \n        // always reload socketFactory from HttpsURLConnection.defaultSSLSocketFactory and \n        // tlsClientParameters.sslSocketFactory to allow runtime configuration change\n        if (tlsClientParameters.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            socketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n            \n        } else if (tlsClientParameters.getSSLSocketFactory() != null) {\n            // see if an SSLSocketFactory was set. This allows easy interop\n            // with not-yet-commons-ssl.jar, or even just people who like doing their\n            // own JSSE.\n            socketFactory = tlsClientParameters.getSSLSocketFactory();\n            \n        } else if (socketFactory == null) {\n            // ssl socket factory not yet instantiated, create a new one with tlsClientParameters's Trust\n            // Managers, Key Managers, etc\n\n            SSLContext ctx = \n                org.apache.cxf.transport.https.SSLUtils.getSSLContext(tlsClientParameters);\n\n            String[] cipherSuites = \n                SSLUtils.getCiphersuitesToInclude(tlsClientParameters.getCipherSuites(), \n                                                  tlsClientParameters.getCipherSuitesFilter(), \n                                                  ctx.getSocketFactory().getDefaultCipherSuites(),\n                                                  SSLUtils.getSupportedCipherSuites(ctx), \n                                                  LOG);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null ? tlsClientParameters\n                .getSecureSocketProtocol() : \"TLS\";\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(), cipherSuites,\n                                                        protocol);\n            //recalc the hashcode since some of the above MAY have changed the tlsClientParameters \n            lastTlsHash = tlsClientParameters.hashCode();\n        } else {\n           // ssl socket factory already initialized, reuse it to benefit of keep alive\n        }\n        \n        \n        HostnameVerifier verifier = org.apache.cxf.transport.https.SSLUtils\n            .getHostnameVerifier(tlsClientParameters);\n        \n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            conn.setHostnameVerifier(verifier);\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case and other possible hidden API's \n            // that are similar to the Sun cases\n            try {\n                Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n                \n                InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy, \n                                         Method method, \n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return true;\n                        }\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {method.getReturnType()},\n                                                                        handler);\n\n                method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                method.invoke(connection, proxy);\n            } catch (Exception ex) {\n                //Ignore this one\n            }\n            try {\n                Method getSSLSocketFactory =  connection.getClass().getMethod(\"getSSLSocketFactory\");\n                Method setSSLSocketFactory = connection.getClass()\n                    .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                    setSSLSocketFactory.invoke(connection, socketFactory);\n                } else {\n                    //need to see if we can create one - mostly the weblogic case.   The \n                    //weblogic SSLSocketFactory has a protected constructor that can take\n                    //a JSSE SSLSocketFactory so we'll try and use that\n                    Constructor<?> c = getSSLSocketFactory.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    ReflectionUtil.setAccessible(c);\n                    setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                }\n            } catch (Exception ex) {\n                if (connection.getClass().getName().contains(\"weblogic\")) {\n                    if (!weblogicWarned) {\n                        weblogicWarned = true;\n                        LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                } \n                //if we cannot set the SSLSocketFactor, we're in serious trouble.\n                throw new IllegalArgumentException(\"Error decorating connection class \" \n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }", "code_tokens": ["protected", "synchronized", "void", "decorateWithTLS", "(", "TLSClientParameters", "tlsClientParameters", ",", "HttpURLConnection", "connection", ")", "throws", "GeneralSecurityException", "{", "int", "hash", "=", "tlsClientParameters", ".", "hashCode", "(", ")", ";", "if", "(", "hash", "!=", "lastTlsHash", ")", "{", "lastTlsHash", "=", "hash", ";", "socketFactory", "=", "null", ";", "}", "if", "(", "tlsClientParameters", ".", "isUseHttpsURLConnectionDefaultSslSocketFactory", "(", ")", ")", "{", "socketFactory", "=", "HttpsURLConnection", ".", "getDefaultSSLSocketFactory", "(", ")", ";", "}", "else", "if", "(", "tlsClientParameters", ".", "getSSLSocketFactory", "(", ")", "!=", "null", ")", "{", "socketFactory", "=", "tlsClientParameters", ".", "getSSLSocketFactory", "(", ")", ";", "}", "else", "if", "(", "socketFactory", "==", "null", ")", "{", "SSLContext", "ctx", "=", "org", ".", "apache", ".", "cxf", ".", "transport", ".", "https", ".", "SSLUtils", ".", "getSSLContext", "(", "tlsClientParameters", ")", ";", "String", "[", "]", "cipherSuites", "=", "SSLUtils", ".", "getCiphersuitesToInclude", "(", "tlsClientParameters", ".", "getCipherSuites", "(", ")", ",", "tlsClientParameters", ".", "getCipherSuitesFilter", "(", ")", ",", "ctx", ".", "getSocketFactory", "(", ")", ".", "getDefaultCipherSuites", "(", ")", ",", "SSLUtils", ".", "getSupportedCipherSuites", "(", "ctx", ")", ",", "LOG", ")", ";", "String", "protocol", "=", "tlsClientParameters", ".", "getSecureSocketProtocol", "(", ")", "!=", "null", "?", "tlsClientParameters", ".", "getSecureSocketProtocol", "(", ")", ":", "\"", "TLS", "\"", ";", "socketFactory", "=", "new", "SSLSocketFactoryWrapper", "(", "ctx", ".", "getSocketFactory", "(", ")", ",", "cipherSuites", ",", "protocol", ")", ";", "lastTlsHash", "=", "tlsClientParameters", ".", "hashCode", "(", ")", ";", "}", "else", "{", "}", "HostnameVerifier", "verifier", "=", "org", ".", "apache", ".", "cxf", ".", "transport", ".", "https", ".", "SSLUtils", ".", "getHostnameVerifier", "(", "tlsClientParameters", ")", ";", "if", "(", "connection", "instanceof", "HttpsURLConnection", ")", "{", "HttpsURLConnection", "conn", "=", "(", "HttpsURLConnection", ")", "connection", ";", "conn", ".", "setHostnameVerifier", "(", "verifier", ")", ";", "conn", ".", "setSSLSocketFactory", "(", "socketFactory", ")", ";", "}", "else", "{", "try", "{", "Method", "method", "=", "connection", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "getHostnameVerifier", "\"", ")", ";", "InvocationHandler", "handler", "=", "new", "ReflectionInvokationHandler", "(", "verifier", ")", "{", "public", "Object", "invoke", "(", "Object", "proxy", ",", "Method", "method", ",", "Object", "[", "]", "args", ")", "throws", "Throwable", "{", "try", "{", "return", "super", ".", "invoke", "(", "proxy", ",", "method", ",", "args", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "return", "true", ";", "}", "}", "}", ";", "Object", "proxy", "=", "java", ".", "lang", ".", "reflect", ".", "Proxy", ".", "newProxyInstance", "(", "this", ".", "getClass", "(", ")", ".", "getClassLoader", "(", ")", ",", "new", "Class", "[", "]", "{", "method", ".", "getReturnType", "(", ")", "}", ",", "handler", ")", ";", "method", "=", "connection", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "setHostnameVerifier", "\"", ",", "method", ".", "getReturnType", "(", ")", ")", ";", "method", ".", "invoke", "(", "connection", ",", "proxy", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "}", "try", "{", "Method", "getSSLSocketFactory", "=", "connection", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "getSSLSocketFactory", "\"", ")", ";", "Method", "setSSLSocketFactory", "=", "connection", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "setSSLSocketFactory", "\"", ",", "getSSLSocketFactory", ".", "getReturnType", "(", ")", ")", ";", "if", "(", "getSSLSocketFactory", ".", "getReturnType", "(", ")", ".", "isInstance", "(", "socketFactory", ")", ")", "{", "setSSLSocketFactory", ".", "invoke", "(", "connection", ",", "socketFactory", ")", ";", "}", "else", "{", "Constructor", "<", "?", ">", "c", "=", "getSSLSocketFactory", ".", "getReturnType", "(", ")", ".", "getDeclaredConstructor", "(", "SSLSocketFactory", ".", "class", ")", ";", "ReflectionUtil", ".", "setAccessible", "(", "c", ")", ";", "setSSLSocketFactory", ".", "invoke", "(", "connection", ",", "c", ".", "newInstance", "(", "socketFactory", ")", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "if", "(", "connection", ".", "getClass", "(", ")", ".", "getName", "(", ")", ".", "contains", "(", "\"", "weblogic", "\"", ")", ")", "{", "if", "(", "!", "weblogicWarned", ")", "{", "weblogicWarned", "=", "true", ";", "LOG", ".", "warning", "(", "\"", "Could not configure SSLSocketFactory on Weblogic.  ", "\"", "+", "\"", " Use the Weblogic control panel to configure the SSL settings.", "\"", ")", ";", "}", "return", ";", "}", "throw", "new", "IllegalArgumentException", "(", "\"", "Error decorating connection class ", "\"", "+", "connection", ".", "getClass", "(", ")", ".", "getName", "(", ")", ",", "ex", ")", ";", "}", "}", "}"], "idx": 74789, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "8ed6208f987ff72e4c4d2cf8a6b1ec9b27575d4", "function_name": "decorateWithTLS", "body_hash": "a432d9b7790f39e443fb00f92687f5dd848d71fe"}
{"code": "@Override\n    public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {\n        if (cloud != null) return;\n        try {\n            cloud = new CloudFactory().getCloud();\n        } catch (CloudException e) {\n            return; // not running on a known cloud environment, so nothing to do\n        }\n\n        for (ServiceInfo serviceInfo : cloud.getServiceInfos()) {\n            if (serviceInfo instanceof SsoServiceInfo) {\n                Map<String, Object> map = new HashMap<>();\n                SsoServiceInfo ssoServiceInfo = (SsoServiceInfo) serviceInfo;\n                map.put(\"security.oauth2.client.clientId\", ssoServiceInfo.getClientId());\n                map.put(\"security.oauth2.client.clientSecret\", ssoServiceInfo.getClientSecret());\n                map.put(\"security.oauth2.client.accessTokenUri\", ssoServiceInfo.getAuthDomain() + \"/oauth/token\");\n                map.put(\"security.oauth2.client.userAuthorizationUri\", ssoServiceInfo.getAuthDomain() + \"/oauth/authorize\");\n                map.put(\"ssoServiceUrl\", ssoServiceInfo.getAuthDomain());\n                map.put(\"security.oauth2.resource.userInfoUri\", ssoServiceInfo.getAuthDomain() + \"/userinfo\");\n                map.put(\"security.oauth2.resource.tokenInfoUri\", ssoServiceInfo.getAuthDomain() + \"/check_token\");\n                map.put(\"security.oauth2.resource.jwk.key-set-uri\", ssoServiceInfo.getAuthDomain() + \"/token_keys\");\n                MapPropertySource mapPropertySource = new MapPropertySource(\"vcapPivotalSso\", map);\n\n                event.getEnvironment().getPropertySources().addFirst(mapPropertySource);\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "onApplicationEvent", "(", "ApplicationEnvironmentPreparedEvent", "event", ")", "{", "if", "(", "cloud", "!=", "null", ")", "return", ";", "try", "{", "cloud", "=", "new", "CloudFactory", "(", ")", ".", "getCloud", "(", ")", ";", "}", "catch", "(", "CloudException", "e", ")", "{", "return", ";", "}", "for", "(", "ServiceInfo", "serviceInfo", ":", "cloud", ".", "getServiceInfos", "(", ")", ")", "{", "if", "(", "serviceInfo", "instanceof", "SsoServiceInfo", ")", "{", "Map", "<", "String", ",", "Object", ">", "map", "=", "new", "HashMap", "<", ">", "(", ")", ";", "SsoServiceInfo", "ssoServiceInfo", "=", "(", "SsoServiceInfo", ")", "serviceInfo", ";", "map", ".", "put", "(", "\"", "security.oauth2.client.clientId", "\"", ",", "ssoServiceInfo", ".", "getClientId", "(", ")", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.client.clientSecret", "\"", ",", "ssoServiceInfo", ".", "getClientSecret", "(", ")", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.client.accessTokenUri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/oauth/token", "\"", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.client.userAuthorizationUri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/oauth/authorize", "\"", ")", ";", "map", ".", "put", "(", "\"", "ssoServiceUrl", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.resource.userInfoUri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/userinfo", "\"", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.resource.tokenInfoUri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/check_token", "\"", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.resource.jwk.key-set-uri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/token_keys", "\"", ")", ";", "MapPropertySource", "mapPropertySource", "=", "new", "MapPropertySource", "(", "\"", "vcapPivotalSso", "\"", ",", "map", ")", ";", "event", ".", "getEnvironment", "(", ")", ".", "getPropertySources", "(", ")", ".", "addFirst", "(", "mapPropertySource", ")", ";", "}", "}", "}"], "idx": 105669, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "ef647a2acf2363c6018e8543d665ac8862593372", "function_name": "onApplicationEvent", "body_hash": "697114bc902e81e1b8b8131f71d101ff91792e44"}
{"code": "final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }", "code_tokens": ["final", "static", "private", "XMLStreamReader", "createXMLStreamReader", "(", "InputStream", "inputStream", ")", "throws", "XMLStreamException", ",", "IOException", "{", "XMLInputFactory", "factory", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "IS_COALESCING", ",", "true", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "IS_REPLACING_ENTITY_REFERENCES", ",", "true", ")", ";", "return", "factory", ".", "createXMLStreamReader", "(", "wrapPrefixRemovingInputStream", "(", "inputStream", ")", ")", ";", "}"], "idx": 67856, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "6a0d7d56e4ffb420316ce7849fde881344fbf881", "function_name": "createXMLStreamReader", "body_hash": "38fc77d2603cf008aabb8050b2d054d5fa49120b"}
{"code": "private HttpServletRequest createMockRequest(String path) {\r\n        HttpServletRequest request = createNiceMock(HttpServletRequest.class);\r\n\r\n        expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();\r\n        expect(request.getContextPath()).andReturn(\"\");\r\n        expect(request.getPathInfo()).andReturn(path);\r\n        replay(request);\r\n        return request;\r\n    }", "code_tokens": ["private", "HttpServletRequest", "createMockRequest", "(", "String", "path", ")", "{", "HttpServletRequest", "request", "=", "createNiceMock", "(", "HttpServletRequest", ".", "class", ")", ";", "expect", "(", "request", ".", "getAttribute", "(", "WebUtils", ".", "INCLUDE_CONTEXT_PATH_ATTRIBUTE", ")", ")", ".", "andReturn", "(", "null", ")", ".", "anyTimes", "(", ")", ";", "expect", "(", "request", ".", "getContextPath", "(", ")", ")", ".", "andReturn", "(", "\"", "\"", ")", ";", "expect", "(", "request", ".", "getPathInfo", "(", ")", ")", ".", "andReturn", "(", "path", ")", ";", "replay", "(", "request", ")", ";", "return", "request", ";", "}"], "idx": 107931, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "01887f64", "function_name": "createMockRequest", "body_hash": "5427c6332ad68aff0d689da86af33f9707249d55"}
{"code": "public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (long i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }", "code_tokens": ["public", "void", "parseCentralDirectoryFormat", "(", "final", "byte", "[", "]", "data", ",", "final", "int", "offset", ",", "final", "int", "length", ")", "{", "this", ".", "format", "=", "ZipShort", ".", "getValue", "(", "data", ",", "offset", ")", ";", "this", ".", "algId", "=", "EncryptionAlgorithm", ".", "getAlgorithmByCode", "(", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "2", ")", ")", ";", "this", ".", "bitlen", "=", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "4", ")", ";", "this", ".", "flags", "=", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "6", ")", ";", "this", ".", "rcount", "=", "ZipLong", ".", "getValue", "(", "data", ",", "offset", "+", "8", ")", ";", "if", "(", "rcount", ">", "0", ")", "{", "this", ".", "hashAlg", "=", "HashAlgorithm", ".", "getAlgorithmByCode", "(", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "12", ")", ")", ";", "this", ".", "hashSize", "=", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "14", ")", ";", "for", "(", "long", "i", "=", "0", ";", "i", "<", "this", ".", "rcount", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "this", ".", "hashSize", ";", "j", "++", ")", "{", "}", "}", "}", "}"], "idx": 82758, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "2a2f1dc48e22a34ddb72321a4db211da91aa933b", "function_name": "parseCentralDirectoryFormat", "body_hash": "58b72ec4a48892a99f81983aaaec4a6760f6cbaa"}
{"code": "public static boolean isSecureZooKeeper(Configuration conf) {\n    // Detection for embedded HBase client with jaas configuration\n    // defined for third party programs.\n    try {\n      javax.security.auth.login.Configuration testConfig =\n          javax.security.auth.login.Configuration.getConfiguration();\n      if (testConfig.getAppConfigurationEntry(\"Client\") == null\n          && testConfig.getAppConfigurationEntry(\n            JaasConfiguration.CLIENT_KEYTAB_KERBEROS_CONFIG_NAME) == null\n          && testConfig.getAppConfigurationEntry(\n            JaasConfiguration.SERVER_KEYTAB_KERBEROS_CONFIG_NAME) == null) {\n        return false;\n      }\n    } catch(Exception e) {\n      // No Jaas configuration defined.\n      return false;\n    }\n\n    // Master & RSs uses hbase.zookeeper.client.*\n    return(\"kerberos\".equalsIgnoreCase(conf.get(\"hbase.security.authentication\")));\n  }", "code_tokens": ["public", "static", "boolean", "isSecureZooKeeper", "(", "Configuration", "conf", ")", "{", "try", "{", "javax", ".", "security", ".", "auth", ".", "login", ".", "Configuration", "testConfig", "=", "javax", ".", "security", ".", "auth", ".", "login", ".", "Configuration", ".", "getConfiguration", "(", ")", ";", "if", "(", "testConfig", ".", "getAppConfigurationEntry", "(", "\"", "Client", "\"", ")", "==", "null", "&&", "testConfig", ".", "getAppConfigurationEntry", "(", "JaasConfiguration", ".", "CLIENT_KEYTAB_KERBEROS_CONFIG_NAME", ")", "==", "null", "&&", "testConfig", ".", "getAppConfigurationEntry", "(", "JaasConfiguration", ".", "SERVER_KEYTAB_KERBEROS_CONFIG_NAME", ")", "==", "null", ")", "{", "return", "false", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "return", "false", ";", "}", "return", "(", "\"", "kerberos", "\"", ".", "equalsIgnoreCase", "(", "conf", ".", "get", "(", "\"", "hbase.security.authentication", "\"", ")", ")", ")", ";", "}"], "idx": 36936, "cwe": "CWE-284", "target": 0, "status": "FIXED", "commit": "5b5f976", "function_name": "isSecureZooKeeper", "body_hash": "d3a33652f1ae8dbf9541380580424b1f3dc81d93"}
{"code": "@Override\n    public boolean checkObjectExecutePermission(Class clazz, String methodName)\n    {\n        Boolean result = null;\n        if (methodName != null) {\n            for (Map.Entry<Class, Set<String>> classSetEntry : this.whitelistedMethods.entrySet()) {\n                if (classSetEntry.getKey().isAssignableFrom(clazz)) {\n                    result = classSetEntry.getValue().contains(methodName.toLowerCase());\n                    break;\n                }\n            }\n        }\n\n        if (result == null) {\n            result = super.checkObjectExecutePermission(clazz, methodName);\n        }\n        return result;\n    }", "code_tokens": ["@", "Override", "public", "boolean", "checkObjectExecutePermission", "(", "Class", "clazz", ",", "String", "methodName", ")", "{", "Boolean", "result", "=", "null", ";", "if", "(", "methodName", "!=", "null", ")", "{", "for", "(", "Map", ".", "Entry", "<", "Class", ",", "Set", "<", "String", ">", ">", "classSetEntry", ":", "this", ".", "whitelistedMethods", ".", "entrySet", "(", ")", ")", "{", "if", "(", "classSetEntry", ".", "getKey", "(", ")", ".", "isAssignableFrom", "(", "clazz", ")", ")", "{", "result", "=", "classSetEntry", ".", "getValue", "(", ")", ".", "contains", "(", "methodName", ".", "toLowerCase", "(", ")", ")", ";", "break", ";", "}", "}", "}", "if", "(", "result", "==", "null", ")", "{", "result", "=", "super", ".", "checkObjectExecutePermission", "(", "clazz", ",", "methodName", ")", ";", "}", "return", "result", ";", "}"], "idx": 72464, "cwe": "CWE-668", "target": 0, "status": "FIXED", "commit": "215951cfb0f808d0bf5b1097c9e7d1e503449ab8", "function_name": "checkObjectExecutePermission", "body_hash": "63b02e4db99ec6b92682ba387dc3b0779d91e247"}
{"code": "protected boolean isRestrictedClass(Object o) {\n    if (o == null) {\n      return false;\n    }\n\n    return (\n      (\n        o.getClass().getPackage() != null &&\n        o.getClass().getPackage().getName().startsWith(\"java.lang.reflect\")\n      ) ||\n      o instanceof Class ||\n      o instanceof ClassLoader ||\n      o instanceof Thread ||\n      o instanceof Method ||\n      o instanceof Field ||\n      o instanceof Constructor\n    );\n  }", "code_tokens": ["protected", "boolean", "isRestrictedClass", "(", "Object", "o", ")", "{", "if", "(", "o", "==", "null", ")", "{", "return", "false", ";", "}", "return", "(", "(", "o", ".", "getClass", "(", ")", ".", "getPackage", "(", ")", "!=", "null", "&&", "o", ".", "getClass", "(", ")", ".", "getPackage", "(", ")", ".", "getName", "(", ")", ".", "startsWith", "(", "\"", "java.lang.reflect", "\"", ")", ")", "||", "o", "instanceof", "Class", "||", "o", "instanceof", "ClassLoader", "||", "o", "instanceof", "Thread", "||", "o", "instanceof", "Method", "||", "o", "instanceof", "Field", "||", "o", "instanceof", "Constructor", ")", ";", "}"], "idx": 89713, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "1b9aaa4b420c58b4a301cf4b7d26207f1c8d1165", "function_name": "isRestrictedClass", "body_hash": "86914d201c0c1122d8b78265799bd1e86b6dd090"}
{"code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }\n        return factory;\n    }", "code_tokens": ["protected", "SchemaFactory", "createSchemaFactory", "(", ")", "{", "SchemaFactory", "factory", "=", "SchemaFactory", ".", "newInstance", "(", "schemaLanguage", ")", ";", "if", "(", "getResourceResolver", "(", ")", "!=", "null", ")", "{", "factory", ".", "setResourceResolver", "(", "getResourceResolver", "(", ")", ")", ";", "}", "return", "factory", ";", "}"], "idx": 66948, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "2c6964ae94d8f9a9c9a32e5ae5a0b794e8b8d3b", "function_name": "createSchemaFactory", "body_hash": "6f4715a46af3c205d4a7de5e4c47ff8f288670fb"}
{"code": "@Override\n    public IdentityZoneConfiguration validate(IdentityZone zone, IdentityZoneValidator.Mode mode) throws InvalidIdentityZoneConfigurationException {\n        IdentityZoneConfiguration config = zone.getConfig();\n        if (mode == IdentityZoneValidator.Mode.CREATE || mode == IdentityZoneValidator.Mode.MODIFY) {\n            String currentKeyId = null;\n            try {\n                SamlConfig samlConfig;\n                if ((samlConfig = config.getSamlConfig()) != null && samlConfig.getKeys().size()>0) {\n                    String activeKeyId = samlConfig.getActiveKeyId();\n                    if ( (activeKeyId == null || samlConfig.getKeys().get(activeKeyId) == null)) {\n\n                        throw new InvalidIdentityZoneConfigurationException(String.format(\"Invalid SAML active key ID: '%s'. Couldn't find any matching keys.\", activeKeyId));\n                    }\n\n                    for (Map.Entry<String, SamlKey> entry : samlConfig.getKeys().entrySet()) {\n                        currentKeyId = entry.getKey();\n                        String samlSpCert = entry.getValue().getCertificate();\n                        String samlSpKey = entry.getValue().getKey();\n                        String samlSpkeyPassphrase = entry.getValue().getPassphrase();\n                        if (samlSpKey != null && samlSpCert != null) {\n                            new KeyWithCert(samlSpKey, samlSpkeyPassphrase, samlSpCert);\n                        }\n                        failIfPartialCertKeyInfo(samlSpCert, samlSpKey, samlSpkeyPassphrase);\n                    }\n                }\n            } catch (GeneralSecurityException ex) {\n                throw new InvalidIdentityZoneConfigurationException(String.format(\"There is a security problem with the SAML SP Key configuration for key '%s'.\", currentKeyId), ex);\n            }\n\n            TokenPolicy tokenPolicy = config.getTokenPolicy();\n            if (tokenPolicy != null) {\n                String activeKeyId = tokenPolicy.getActiveKeyId();\n                if (StringUtils.hasText(activeKeyId)) {\n                    Map<String, String> jwtKeys = tokenPolicy.getKeys();\n\n                    if (jwtKeys == null || jwtKeys.isEmpty()) {\n                        throw new InvalidIdentityZoneConfigurationException(\"Identity zone cannot specify an active key ID with no keys configured for the zone.\", null);\n                    } else {\n                        if (!jwtKeys.containsKey(activeKeyId)) {\n                            throw new InvalidIdentityZoneConfigurationException(\"The specified active key ID is not present in the configured keys: \" + activeKeyId, null);\n                        }\n                    }\n                }\n            }\n            if (!StringUtils.isEmpty(config.getIssuer())) {\n                if (tokenPolicy == null || StringUtils.isEmpty(tokenPolicy.getActiveKeyId())) {\n                    throw new InvalidIdentityZoneConfigurationException(\"You cannot set issuer value unless you have set your own signing key for this identity zone.\");\n                }\n            }\n        }\n\n        if(config.getBranding() != null && config.getBranding().getBanner() != null) {\n           BannerValidator.validate(config.getBranding().getBanner());\n        }\n\n        if(config.getMfaConfig() != null) {\n            mfaConfigValidator.validate(config.getMfaConfig(), zone.getId());\n        }\n\n        return config;\n    }", "code_tokens": ["@", "Override", "public", "IdentityZoneConfiguration", "validate", "(", "IdentityZone", "zone", ",", "IdentityZoneValidator", ".", "Mode", "mode", ")", "throws", "InvalidIdentityZoneConfigurationException", "{", "IdentityZoneConfiguration", "config", "=", "zone", ".", "getConfig", "(", ")", ";", "if", "(", "mode", "==", "IdentityZoneValidator", ".", "Mode", ".", "CREATE", "||", "mode", "==", "IdentityZoneValidator", ".", "Mode", ".", "MODIFY", ")", "{", "String", "currentKeyId", "=", "null", ";", "try", "{", "SamlConfig", "samlConfig", ";", "if", "(", "(", "samlConfig", "=", "config", ".", "getSamlConfig", "(", ")", ")", "!=", "null", "&&", "samlConfig", ".", "getKeys", "(", ")", ".", "size", "(", ")", ">", "0", ")", "{", "String", "activeKeyId", "=", "samlConfig", ".", "getActiveKeyId", "(", ")", ";", "if", "(", "(", "activeKeyId", "==", "null", "||", "samlConfig", ".", "getKeys", "(", ")", ".", "get", "(", "activeKeyId", ")", "==", "null", ")", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "String", ".", "format", "(", "\"", "Invalid SAML active key ID: '%s'. Couldn't find any matching keys.", "\"", ",", "activeKeyId", ")", ")", ";", "}", "for", "(", "Map", ".", "Entry", "<", "String", ",", "SamlKey", ">", "entry", ":", "samlConfig", ".", "getKeys", "(", ")", ".", "entrySet", "(", ")", ")", "{", "currentKeyId", "=", "entry", ".", "getKey", "(", ")", ";", "String", "samlSpCert", "=", "entry", ".", "getValue", "(", ")", ".", "getCertificate", "(", ")", ";", "String", "samlSpKey", "=", "entry", ".", "getValue", "(", ")", ".", "getKey", "(", ")", ";", "String", "samlSpkeyPassphrase", "=", "entry", ".", "getValue", "(", ")", ".", "getPassphrase", "(", ")", ";", "if", "(", "samlSpKey", "!=", "null", "&&", "samlSpCert", "!=", "null", ")", "{", "new", "KeyWithCert", "(", "samlSpKey", ",", "samlSpkeyPassphrase", ",", "samlSpCert", ")", ";", "}", "failIfPartialCertKeyInfo", "(", "samlSpCert", ",", "samlSpKey", ",", "samlSpkeyPassphrase", ")", ";", "}", "}", "}", "catch", "(", "GeneralSecurityException", "ex", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "String", ".", "format", "(", "\"", "There is a security problem with the SAML SP Key configuration for key '%s'.", "\"", ",", "currentKeyId", ")", ",", "ex", ")", ";", "}", "TokenPolicy", "tokenPolicy", "=", "config", ".", "getTokenPolicy", "(", ")", ";", "if", "(", "tokenPolicy", "!=", "null", ")", "{", "String", "activeKeyId", "=", "tokenPolicy", ".", "getActiveKeyId", "(", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "activeKeyId", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "jwtKeys", "=", "tokenPolicy", ".", "getKeys", "(", ")", ";", "if", "(", "jwtKeys", "==", "null", "||", "jwtKeys", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "\"", "Identity zone cannot specify an active key ID with no keys configured for the zone.", "\"", ",", "null", ")", ";", "}", "else", "{", "if", "(", "!", "jwtKeys", ".", "containsKey", "(", "activeKeyId", ")", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "\"", "The specified active key ID is not present in the configured keys: ", "\"", "+", "activeKeyId", ",", "null", ")", ";", "}", "}", "}", "}", "if", "(", "!", "StringUtils", ".", "isEmpty", "(", "config", ".", "getIssuer", "(", ")", ")", ")", "{", "if", "(", "tokenPolicy", "==", "null", "||", "StringUtils", ".", "isEmpty", "(", "tokenPolicy", ".", "getActiveKeyId", "(", ")", ")", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "\"", "You cannot set issuer value unless you have set your own signing key for this identity zone.", "\"", ")", ";", "}", "}", "}", "if", "(", "config", ".", "getBranding", "(", ")", "!=", "null", "&&", "config", ".", "getBranding", "(", ")", ".", "getBanner", "(", ")", "!=", "null", ")", "{", "BannerValidator", ".", "validate", "(", "config", ".", "getBranding", "(", ")", ".", "getBanner", "(", ")", ")", ";", "}", "if", "(", "config", ".", "getMfaConfig", "(", ")", "!=", "null", ")", "{", "mfaConfigValidator", ".", "validate", "(", "config", ".", "getMfaConfig", "(", ")", ",", "zone", ".", "getId", "(", ")", ")", ";", "}", "return", "config", ";", "}"], "idx": 102681, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "14c745aa293b8d3ce9cdd6bfbc6c0ef3f269b21", "function_name": "validate", "body_hash": "9a9cd81ed78fac847b89450fbc40a27c42ae8b3c"}
{"code": "@Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        String secret = getSecret();\n        Key key = new SecretKeySpec(Decoders.BASE64.decode(secret), getSignatureAlgorithm().getJcaName());\n        \n        Jwt jwt = Jwts.parser().\n                setSigningKey(key).\n                parse((String) token.getPrincipal());\n        Map<String, Serializable> principal = getPrincipal(jwt);\n        return new SimpleAuthenticationInfo(principal, ((String) token.getCredentials()).toCharArray(), getName());\n    }", "code_tokens": ["@", "Override", "protected", "AuthenticationInfo", "doGetAuthenticationInfo", "(", "AuthenticationToken", "token", ")", "throws", "AuthenticationException", "{", "String", "secret", "=", "getSecret", "(", ")", ";", "Key", "key", "=", "new", "SecretKeySpec", "(", "Decoders", ".", "BASE64", ".", "decode", "(", "secret", ")", ",", "getSignatureAlgorithm", "(", ")", ".", "getJcaName", "(", ")", ")", ";", "Jwt", "jwt", "=", "Jwts", ".", "parser", "(", ")", ".", "setSigningKey", "(", "key", ")", ".", "parse", "(", "(", "String", ")", "token", ".", "getPrincipal", "(", ")", ")", ";", "Map", "<", "String", ",", "Serializable", ">", "principal", "=", "getPrincipal", "(", "jwt", ")", ";", "return", "new", "SimpleAuthenticationInfo", "(", "principal", ",", "(", "(", "String", ")", "token", ".", "getCredentials", "(", ")", ")", ".", "toCharArray", "(", ")", ",", "getName", "(", ")", ")", ";", "}"], "idx": 43480, "cwe": "CWE-347", "target": 1, "status": "VULNERABLE", "commit": "8c754a0ad234555e813dcbf9e57d637f9f23d8fb", "function_name": "doGetAuthenticationInfo", "body_hash": "f9200bc9ae64f408525018fec96147efd4e77a17"}
{"code": "protected boolean isRestrictedClass(Object o) {\n    if (o == null) {\n      return false;\n    }\n\n    return (\n      (\n        o.getClass().getPackage() != null &&\n        o.getClass().getPackage().getName().startsWith(\"java.lang.reflect\")\n      ) ||\n      o instanceof Class ||\n      o instanceof ClassLoader ||\n      o instanceof Thread ||\n      o instanceof Method ||\n      o instanceof Field ||\n      o instanceof Constructor ||\n      o instanceof JinjavaInterpreter\n    );\n  }", "code_tokens": ["protected", "boolean", "isRestrictedClass", "(", "Object", "o", ")", "{", "if", "(", "o", "==", "null", ")", "{", "return", "false", ";", "}", "return", "(", "(", "o", ".", "getClass", "(", ")", ".", "getPackage", "(", ")", "!=", "null", "&&", "o", ".", "getClass", "(", ")", ".", "getPackage", "(", ")", ".", "getName", "(", ")", ".", "startsWith", "(", "\"", "java.lang.reflect", "\"", ")", ")", "||", "o", "instanceof", "Class", "||", "o", "instanceof", "ClassLoader", "||", "o", "instanceof", "Thread", "||", "o", "instanceof", "Method", "||", "o", "instanceof", "Field", "||", "o", "instanceof", "Constructor", "||", "o", "instanceof", "JinjavaInterpreter", ")", ";", "}"], "idx": 89714, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "1b9aaa4b420c58b4a301cf4b7d26207f1c8d1165", "function_name": "isRestrictedClass", "body_hash": "d29e90add5cfd2bb34442b47baa1a91a2c82abb2"}
{"code": "private Exception doRequest() {\n\n            Tomcat tomcat = getTomcatInstance();\n\n            Context root = tomcat.addContext(\"\", TEMP_DIR);\n            Tomcat.addServlet(root, \"Bug51557\",\n                    new Bug51557Servlet(headerName));\n            root.addServletMapping(\"/test\", \"Bug51557\");\n\n            try {\n                Connector connector = tomcat.getConnector();\n                Assert.assertTrue(connector.setProperty(\n                        \"rejectIllegalHeader\", Boolean.toString(rejectIllegalHeader)));\n                tomcat.start();\n                setPort(connector.getLocalPort());\n\n                // Open connection\n                connect();\n\n                String[] request = new String[1];\n                request[0] =\n                    \"GET /test HTTP/1.1\" + CRLF +\n                    \"host: localhost:8080\" + CRLF +\n                    headerLine + CRLF +\n                    \"X-Bug51557: abcd\" + CRLF +\n                    \"Connection: close\" + CRLF +\n                    CRLF;\n\n                setRequest(request);\n                processRequest(); // blocks until response has been read\n\n                // Close the connection\n                disconnect();\n            } catch (Exception e) {\n                return e;\n            }\n            return null;\n        }", "code_tokens": ["private", "Exception", "doRequest", "(", ")", "{", "Tomcat", "tomcat", "=", "getTomcatInstance", "(", ")", ";", "Context", "root", "=", "tomcat", ".", "addContext", "(", "\"", "\"", ",", "TEMP_DIR", ")", ";", "Tomcat", ".", "addServlet", "(", "root", ",", "\"", "Bug51557", "\"", ",", "new", "Bug51557Servlet", "(", "headerName", ")", ")", ";", "root", ".", "addServletMapping", "(", "\"", "/test", "\"", ",", "\"", "Bug51557", "\"", ")", ";", "try", "{", "Connector", "connector", "=", "tomcat", ".", "getConnector", "(", ")", ";", "Assert", ".", "assertTrue", "(", "connector", ".", "setProperty", "(", "\"", "rejectIllegalHeader", "\"", ",", "Boolean", ".", "toString", "(", "rejectIllegalHeader", ")", ")", ")", ";", "tomcat", ".", "start", "(", ")", ";", "setPort", "(", "connector", ".", "getLocalPort", "(", ")", ")", ";", "connect", "(", ")", ";", "String", "[", "]", "request", "=", "new", "String", "[", "1", "]", ";", "request", "[", "0", "]", "=", "\"", "GET /test HTTP/1.1", "\"", "+", "CRLF", "+", "\"", "host: localhost:8080", "\"", "+", "CRLF", "+", "headerLine", "+", "CRLF", "+", "\"", "X-Bug51557: abcd", "\"", "+", "CRLF", "+", "\"", "Connection: close", "\"", "+", "CRLF", "+", "CRLF", ";", "setRequest", "(", "request", ")", ";", "processRequest", "(", ")", ";", "disconnect", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "return", "e", ";", "}", "return", "null", ";", "}"], "idx": 56014, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "702bf15", "function_name": "doRequest", "body_hash": "87b02709a89ba5df60b9a67393b88912b660e409"}
{"code": "private void doDirectoryRedirect(HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n        StringBuilder location = new StringBuilder(request.getRequestURI());\n        location.append('/');\n        if (request.getQueryString() != null) {\n            location.append('?');\n            location.append(request.getQueryString());\n        }\n        // Avoid protocol relative redirects\n        while (location.length() > 1 && location.charAt(1) == '/') {\n            location.deleteCharAt(0);\n        }\n        response.sendRedirect(response.encodeRedirectURL(location.toString()));\n    }", "code_tokens": ["private", "void", "doDirectoryRedirect", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "IOException", "{", "StringBuilder", "location", "=", "new", "StringBuilder", "(", "request", ".", "getRequestURI", "(", ")", ")", ";", "location", ".", "append", "(", "'/'", ")", ";", "if", "(", "request", ".", "getQueryString", "(", ")", "!=", "null", ")", "{", "location", ".", "append", "(", "'?'", ")", ";", "location", ".", "append", "(", "request", ".", "getQueryString", "(", ")", ")", ";", "}", "while", "(", "location", ".", "length", "(", ")", ">", "1", "&&", "location", ".", "charAt", "(", "1", ")", "==", "'/'", ")", "{", "location", ".", "deleteCharAt", "(", "0", ")", ";", "}", "response", ".", "sendRedirect", "(", "response", ".", "encodeRedirectURL", "(", "location", ".", "toString", "(", ")", ")", ")", ";", "}"], "idx": 65601, "cwe": "CWE-601", "target": 0, "status": "FIXED", "commit": "efb860b3ff8ebcf606199b8d0d432f76898040da", "function_name": "doDirectoryRedirect", "body_hash": "117c0cfa6650c9c8b1d087d3a07d85bbcdaf8bd3"}
{"code": "@Before\n    public void init() {\n        parser = new TldParser(true, true, null, true);\n    }", "code_tokens": ["@", "Before", "public", "void", "init", "(", ")", "{", "parser", "=", "new", "TldParser", "(", "true", ",", "true", ",", "null", ",", "true", ")", ";", "}"], "idx": 19698, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "05c84ff8304a69a30b251f207a7b93c2c882564d", "function_name": "init", "body_hash": "999fa3ad8eaea5f1713f9052aec501eb7da77e98"}
{"code": "public String verifyAndExtract(String signedStr) {\n    int index = signedStr.lastIndexOf(SIGNATURE);\n    if (index == -1) {\n      throw new IllegalArgumentException(\"Invalid input sign: \" + signedStr);\n    }\n    String originalSignature = signedStr.substring(index + SIGNATURE.length());\n    String rawValue = signedStr.substring(0, index);\n    String currentSignature = getSignature(rawValue);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Signature generated for \" + rawValue + \" inside verify is \" + currentSignature);\n    }\n    if (!MessageDigest.isEqual(originalSignature.getBytes(), currentSignature.getBytes())) {\n      throw new IllegalArgumentException(\"Invalid sign, original = \" + originalSignature +\n        \" current = \" + currentSignature);\n    }\n    return rawValue;\n  }", "code_tokens": ["public", "String", "verifyAndExtract", "(", "String", "signedStr", ")", "{", "int", "index", "=", "signedStr", ".", "lastIndexOf", "(", "SIGNATURE", ")", ";", "if", "(", "index", "==", "-", "1", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Invalid input sign: ", "\"", "+", "signedStr", ")", ";", "}", "String", "originalSignature", "=", "signedStr", ".", "substring", "(", "index", "+", "SIGNATURE", ".", "length", "(", ")", ")", ";", "String", "rawValue", "=", "signedStr", ".", "substring", "(", "0", ",", "index", ")", ";", "String", "currentSignature", "=", "getSignature", "(", "rawValue", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Signature generated for ", "\"", "+", "rawValue", "+", "\"", " inside verify is ", "\"", "+", "currentSignature", ")", ";", "}", "if", "(", "!", "MessageDigest", ".", "isEqual", "(", "originalSignature", ".", "getBytes", "(", ")", ",", "currentSignature", ".", "getBytes", "(", ")", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Invalid sign, original = ", "\"", "+", "originalSignature", "+", "\"", " current = ", "\"", "+", "currentSignature", ")", ";", "}", "return", "rawValue", ";", "}"], "idx": 20519, "cwe": "CWE-203", "target": 0, "status": "FIXED", "commit": "4de6ddc99a36f7ce8f6aa040dbe6f5b623349bb0", "function_name": "verifyAndExtract", "body_hash": "ca1c9480184ffb8780699e47019eb995617d360a"}
{"code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        LOGGER.entering(HudsonFilter.class.getName(), \"doFilter\");\n\n        // this is not the best place to do it, but doing it here makes the patch smaller.\n        ((HttpServletResponse)response).setHeader(\"X-Content-Type-Options\", \"nosniff\");\n\n        // to deal with concurrency, we need to capture the object.\n        Filter f = filter;\n\n        if(f==null) {\n            // Hudson is starting up.\n            chain.doFilter(request,response);\n        } else {\n            f.doFilter(request,response,chain);\n        }\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "LOGGER", ".", "entering", "(", "HudsonFilter", ".", "class", ".", "getName", "(", ")", ",", "\"", "doFilter", "\"", ")", ";", "(", "(", "HttpServletResponse", ")", "response", ")", ".", "setHeader", "(", "\"", "X-Content-Type-Options", "\"", ",", "\"", "nosniff", "\"", ")", ";", "Filter", "f", "=", "filter", ";", "if", "(", "f", "==", "null", ")", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}", "else", "{", "f", ".", "doFilter", "(", "request", ",", "response", ",", "chain", ")", ";", "}", "}"], "idx": 77698, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "1699e2c1f36a22d6a149e71c80937e9972ef6224", "function_name": "doFilter", "body_hash": "5ba0238eaf22b1cf92572308f2fe5dc3970aaee0"}
{"code": "public AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {\n        Key key = getJWTKey();\n        Jws<Claims> jwt;\n        try {\n            jwt = Jwts.parser().setSigningKey(key).parseClaimsJws(token.getPrincipal());\n        } catch (JwtException e) {\n            throw new AuthenticationException(e);\n        }\n        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());\n        Object principal = extractPrincipalFromWebToken(jwt);\n        return new SimpleAuthenticationInfo(principal, credentials, getName());\n    }", "code_tokens": ["public", "AuthenticationInfo", "loadAuthenticationInfo", "(", "JSONWebToken", "token", ")", "{", "Key", "key", "=", "getJWTKey", "(", ")", ";", "Jws", "<", "Claims", ">", "jwt", ";", "try", "{", "jwt", "=", "Jwts", ".", "parser", "(", ")", ".", "setSigningKey", "(", "key", ")", ".", "parseClaimsJws", "(", "token", ".", "getPrincipal", "(", ")", ")", ";", "}", "catch", "(", "JwtException", "e", ")", "{", "throw", "new", "AuthenticationException", "(", "e", ")", ";", "}", "String", "credentials", "=", "legacyHashing", "?", "token", ".", "getCredentials", "(", ")", ":", "encryptPassword", "(", "token", ".", "getCredentials", "(", ")", ")", ";", "Object", "principal", "=", "extractPrincipalFromWebToken", "(", "jwt", ")", ";", "return", "new", "SimpleAuthenticationInfo", "(", "principal", ",", "credentials", ",", "getName", "(", ")", ")", ";", "}"], "idx": 43595, "cwe": "CWE-347", "target": 0, "status": "FIXED", "commit": "8c754a0ad234555e813dcbf9e57d637f9f23d8fb", "function_name": "loadAuthenticationInfo", "body_hash": "9090bd463a6ae61ee1c3cdd0c7fcb9fca7d08b2a"}
{"code": "private void prepareRequest() throws IOException {\n\n        contentDelimitation = false;\n\n        if (endpoint.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents != null &&\n                        restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    // Invalid transfer encoding\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n                }\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n                keepAlive = false;\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "contentDelimitation", "=", "false", ";", "if", "(", "endpoint", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEP_ALIVE_HEADER_VALUE_TOKEN", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "inputBuffer", ".", "setSwallowInput", "(", "false", ")", ";", "request", ".", "setExpectation", "(", "true", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "(", "http11", "||", "keepAlive", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "protocol", ".", "getAllowHostHeaderMismatch", "(", ")", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "inputBuffer", ".", "getFilters", "(", ")", ";", "if", "(", "http11", ")", "{", "MessageBytes", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ")", "{", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidTransferEncoding", "\"", ")", ";", "}", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 55773, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "da0e7cb093cf68b052d9175e469dbd0464441b0b", "function_name": "prepareRequest", "body_hash": "5b69f814e1a21bab0bdb8d222a688365270027da"}
{"code": "private Optional<Style> tryLoadSLD(\n            final byte[] bytes, final Integer styleIndex,\n            final ClientHttpRequestFactory clientHttpRequestFactory) {\n        Assert.isTrue(styleIndex == null || styleIndex > -1,\n                      \"styleIndex must be > -1 but was: \" + styleIndex);\n\n        final Style[] styles;\n        try {\n\n            // check if the XML is valid\n            // this is only done in a separate step to avoid that fatal errors show up in the logs\n            // by setting a custom error handler.\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            db.setErrorHandler(new ErrorHandler());\n            db.parse(new ByteArrayInputStream(bytes));\n\n            // then read the styles\n            final SLDParser sldParser = new SLDParser(CommonFactoryFinder.getStyleFactory());\n            sldParser.setOnLineResourceLocator(new DefaultResourceLocator() {\n                @Override\n                public URL locateResource(final String uri) {\n                    try {\n                        final URL theUrl = super.locateResource(uri);\n                        final URI theUri;\n                        if (theUrl != null) {\n                            theUri = theUrl.toURI();\n                        } else {\n                            theUri = URI.create(uri);\n                        }\n                        if (theUri.getScheme().startsWith(\"http\")) {\n                            final ClientHttpRequest request = clientHttpRequestFactory.createRequest(\n                                    theUri, HttpMethod.GET);\n                            return request.getURI().toURL();\n                        }\n                        return null;\n                    } catch (IOException | URISyntaxException e) {\n                        return null;\n                    }\n                }\n            });\n            sldParser.setInput(new ByteArrayInputStream(bytes));\n            styles = sldParser.readXML();\n\n        } catch (Throwable e) {\n            return Optional.empty();\n        }\n\n        if (styleIndex != null) {\n            Assert.isTrue(styleIndex < styles.length, String.format(\"There where %s styles in file but \" +\n                                                                            \"requested index was: %s\",\n                                                                    styles.length, styleIndex + 1));\n        } else {\n            Assert.isTrue(styles.length < 2, String.format(\"There are %s therefore the styleRef must \" +\n                                                                   \"contain an index identifying the style.\" +\n                                                                   \"  The index starts at 1 for the first \" +\n                                                                   \"style.\\n\" +\n                                                                   \"\\tExample: thinline.sld##1\",\n                                                           styles.length));\n        }\n\n        if (styleIndex == null) {\n            return Optional.of(styles[0]);\n        } else {\n            return Optional.of(styles[styleIndex]);\n        }\n    }", "code_tokens": ["private", "Optional", "<", "Style", ">", "tryLoadSLD", "(", "final", "byte", "[", "]", "bytes", ",", "final", "Integer", "styleIndex", ",", "final", "ClientHttpRequestFactory", "clientHttpRequestFactory", ")", "{", "Assert", ".", "isTrue", "(", "styleIndex", "==", "null", "||", "styleIndex", ">", "-", "1", ",", "\"", "styleIndex must be > -1 but was: ", "\"", "+", "styleIndex", ")", ";", "final", "Style", "[", "]", "styles", ";", "try", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "dbf", ".", "setNamespaceAware", "(", "true", ")", ";", "DocumentBuilder", "db", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "db", ".", "setErrorHandler", "(", "new", "ErrorHandler", "(", ")", ")", ";", "db", ".", "parse", "(", "new", "ByteArrayInputStream", "(", "bytes", ")", ")", ";", "final", "SLDParser", "sldParser", "=", "new", "SLDParser", "(", "CommonFactoryFinder", ".", "getStyleFactory", "(", ")", ")", ";", "sldParser", ".", "setOnLineResourceLocator", "(", "new", "DefaultResourceLocator", "(", ")", "{", "@", "Override", "public", "URL", "locateResource", "(", "final", "String", "uri", ")", "{", "try", "{", "final", "URL", "theUrl", "=", "super", ".", "locateResource", "(", "uri", ")", ";", "final", "URI", "theUri", ";", "if", "(", "theUrl", "!=", "null", ")", "{", "theUri", "=", "theUrl", ".", "toURI", "(", ")", ";", "}", "else", "{", "theUri", "=", "URI", ".", "create", "(", "uri", ")", ";", "}", "if", "(", "theUri", ".", "getScheme", "(", ")", ".", "startsWith", "(", "\"", "http", "\"", ")", ")", "{", "final", "ClientHttpRequest", "request", "=", "clientHttpRequestFactory", ".", "createRequest", "(", "theUri", ",", "HttpMethod", ".", "GET", ")", ";", "return", "request", ".", "getURI", "(", ")", ".", "toURL", "(", ")", ";", "}", "return", "null", ";", "}", "catch", "(", "IOException", "|", "URISyntaxException", "e", ")", "{", "return", "null", ";", "}", "}", "}", ")", ";", "sldParser", ".", "setInput", "(", "new", "ByteArrayInputStream", "(", "bytes", ")", ")", ";", "styles", "=", "sldParser", ".", "readXML", "(", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "return", "Optional", ".", "empty", "(", ")", ";", "}", "if", "(", "styleIndex", "!=", "null", ")", "{", "Assert", ".", "isTrue", "(", "styleIndex", "<", "styles", ".", "length", ",", "String", ".", "format", "(", "\"", "There where %s styles in file but ", "\"", "+", "\"", "requested index was: %s", "\"", ",", "styles", ".", "length", ",", "styleIndex", "+", "1", ")", ")", ";", "}", "else", "{", "Assert", ".", "isTrue", "(", "styles", ".", "length", "<", "2", ",", "String", ".", "format", "(", "\"", "There are %s therefore the styleRef must ", "\"", "+", "\"", "contain an index identifying the style.", "\"", "+", "\"", "  The index starts at 1 for the first ", "\"", "+", "\"", "style.", "\\n", "\"", "+", "\"", "\\t", "Example: thinline.sld##1", "\"", ",", "styles", ".", "length", ")", ")", ";", "}", "if", "(", "styleIndex", "==", "null", ")", "{", "return", "Optional", ".", "of", "(", "styles", "[", "0", "]", ")", ";", "}", "else", "{", "return", "Optional", ".", "of", "(", "styles", "[", "styleIndex", "]", ")", ";", "}", "}"], "idx": 67342, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "e1d0527d13db06b2b62ca7d6afb9e97dacd67a0e", "function_name": "tryLoadSLD", "body_hash": "6e7456c463186b5ed1d092697568f4d841ee081f"}
{"code": "void resumeReadsInternal(boolean wakeup) {\n        synchronized (lock) {\n            boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n            state |= STATE_READS_RESUMED;\n            if (!alreadyResumed || wakeup) {\n                if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                    state |= STATE_IN_LISTENER_LOOP;\n                    getFramedChannel().runInIoThread(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            try {\n                                boolean moreData;\n                                do {\n                                    ChannelListener<? super R> listener = getReadListener();\n                                    if (listener == null || !isReadResumed()) {\n                                        return;\n                                    }\n                                    ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                    //if writes are shutdown or we become active then we stop looping\n                                    //we stop when writes are shutdown because we can't flush until we are active\n                                    //although we may be flushed as part of a batch\n                                    moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                                }\n                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);\n                            } finally {\n                                state &= ~STATE_IN_LISTENER_LOOP;\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }", "code_tokens": ["void", "resumeReadsInternal", "(", "boolean", "wakeup", ")", "{", "synchronized", "(", "lock", ")", "{", "boolean", "alreadyResumed", "=", "anyAreSet", "(", "state", ",", "STATE_READS_RESUMED", ")", ";", "state", "|=", "STATE_READS_RESUMED", ";", "if", "(", "!", "alreadyResumed", "||", "wakeup", ")", "{", "if", "(", "!", "anyAreSet", "(", "state", ",", "STATE_IN_LISTENER_LOOP", ")", ")", "{", "state", "|=", "STATE_IN_LISTENER_LOOP", ";", "getFramedChannel", "(", ")", ".", "runInIoThread", "(", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "try", "{", "boolean", "moreData", ";", "do", "{", "ChannelListener", "<", "?", "super", "R", ">", "listener", "=", "getReadListener", "(", ")", ";", "if", "(", "listener", "==", "null", "||", "!", "isReadResumed", "(", ")", ")", "{", "return", ";", "}", "ChannelListeners", ".", "invokeChannelListener", "(", "(", "R", ")", "AbstractFramedStreamSourceChannel", ".", "this", ",", "listener", ")", ";", "moreData", "=", "(", "frameDataRemaining", ">", "0", "&&", "data", "!=", "null", ")", "||", "!", "pendingFrameData", ".", "isEmpty", "(", ")", "||", "anyAreSet", "(", "state", ",", "STATE_WAITNG_MINUS_ONE", ")", ";", "}", "while", "(", "allAreSet", "(", "state", ",", "STATE_READS_RESUMED", ")", "&&", "allAreClear", "(", "state", ",", "STATE_CLOSED", ")", "&&", "moreData", ")", ";", "}", "finally", "{", "state", "&=", "~", "STATE_IN_LISTENER_LOOP", ";", "}", "}", "}", ")", ";", "}", "}", "}", "}"], "idx": 82207, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "9bfe9fbbb595d51157b61693f072895f7dbadd1d", "function_name": "resumeReadsInternal", "body_hash": "762a73dab071d011aaf216d2dde748e8a8d8df24"}
{"code": "protected synchronized void authenticatorConfig() {\n\n        // Always need an authenticator to support @ServletSecurity annotations\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null)\n            return;\n        \n        if (!(context instanceof ContainerBase)) {\n            return;     // Cannot install a Valve even if it would be needed\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve)\n                customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n        if (authenticator == null) {\n            // Load our mapping properties if necessary\n            if (authenticators == null) {\n                try {\n                    InputStream is=this.getClass().getClassLoader().getResourceAsStream(\"org/apache/catalina/startup/Authenticators.properties\");\n                    if( is!=null ) {\n                        authenticators = new Properties();\n                        authenticators.load(is);\n                    } else {\n                        log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"));\n                        ok=false;\n                        return;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"), e);\n                    ok = false;\n                    return;\n                }\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = null;\n            authenticatorName =\n                    authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null && context instanceof ContainerBase) {\n            Pipeline pipeline = ((ContainerBase) context).getPipeline();\n            if (pipeline != null) {\n                ((ContainerBase) context).getPipeline().addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n\n    }", "code_tokens": ["protected", "synchronized", "void", "authenticatorConfig", "(", ")", "{", "LoginConfig", "loginConfig", "=", "context", ".", "getLoginConfig", "(", ")", ";", "if", "(", "loginConfig", "==", "null", ")", "{", "loginConfig", "=", "DUMMY_LOGIN_CONFIG", ";", "context", ".", "setLoginConfig", "(", "loginConfig", ")", ";", "}", "if", "(", "context", ".", "getAuthenticator", "(", ")", "!=", "null", ")", "return", ";", "if", "(", "!", "(", "context", "instanceof", "ContainerBase", ")", ")", "{", "return", ";", "}", "if", "(", "context", ".", "getRealm", "(", ")", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.missingRealm", "\"", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "Valve", "authenticator", "=", "null", ";", "if", "(", "customAuthenticators", "!=", "null", ")", "{", "authenticator", "=", "(", "Valve", ")", "customAuthenticators", ".", "get", "(", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ";", "}", "if", "(", "authenticator", "==", "null", ")", "{", "if", "(", "authenticators", "==", "null", ")", "{", "try", "{", "InputStream", "is", "=", "this", ".", "getClass", "(", ")", ".", "getClassLoader", "(", ")", ".", "getResourceAsStream", "(", "\"", "org/apache/catalina/startup/Authenticators.properties", "\"", ")", ";", "if", "(", "is", "!=", "null", ")", "{", "authenticators", "=", "new", "Properties", "(", ")", ";", "authenticators", ".", "load", "(", "is", ")", ";", "}", "else", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorResources", "\"", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorResources", "\"", ")", ",", "e", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "}", "String", "authenticatorName", "=", "null", ";", "authenticatorName", "=", "authenticators", ".", "getProperty", "(", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ";", "if", "(", "authenticatorName", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorMissing", "\"", ",", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "try", "{", "Class", "<", "?", ">", "authenticatorClass", "=", "Class", ".", "forName", "(", "authenticatorName", ")", ";", "authenticator", "=", "(", "Valve", ")", "authenticatorClass", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "t", ")", ";", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorInstantiate", "\"", ",", "authenticatorName", ")", ",", "t", ")", ";", "ok", "=", "false", ";", "}", "}", "if", "(", "authenticator", "!=", "null", "&&", "context", "instanceof", "ContainerBase", ")", "{", "Pipeline", "pipeline", "=", "(", "(", "ContainerBase", ")", "context", ")", ".", "getPipeline", "(", ")", ";", "if", "(", "pipeline", "!=", "null", ")", "{", "(", "(", "ContainerBase", ")", "context", ")", ".", "getPipeline", "(", ")", ".", "addValve", "(", "authenticator", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorConfigured", "\"", ",", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ")", ";", "}", "}", "}", "}"], "idx": 111167, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "0ff4905158b77787a7f3aca55c9dec93456665dc", "function_name": "authenticatorConfig", "body_hash": "f0c0ef5798d66d50a74b2a78bf2d21aca0d4b9dc"}
{"code": "public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 || isSeparator(fileName.charAt(2)) == false) {\n                    return 2;\n                }\n                return 3;\n            } else if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        } else if (isSeparator(ch0) && isSeparator(ch1)) {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n                return NOT_FOUND;\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            int pos = Math.min(posUnix, posWin) + 1;\n            String hostnamePart = fileName.substring(2, pos - 1);\n            return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n        } else {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n    }", "code_tokens": ["public", "static", "int", "getPrefixLength", "(", "final", "String", "fileName", ")", "{", "if", "(", "fileName", "==", "null", ")", "{", "return", "NOT_FOUND", ";", "}", "final", "int", "len", "=", "fileName", ".", "length", "(", ")", ";", "if", "(", "len", "==", "0", ")", "{", "return", "0", ";", "}", "char", "ch0", "=", "fileName", ".", "charAt", "(", "0", ")", ";", "if", "(", "ch0", "==", "':'", ")", "{", "return", "NOT_FOUND", ";", "}", "if", "(", "len", "==", "1", ")", "{", "if", "(", "ch0", "==", "'~'", ")", "{", "return", "2", ";", "}", "return", "isSeparator", "(", "ch0", ")", "?", "1", ":", "0", ";", "}", "if", "(", "ch0", "==", "'~'", ")", "{", "int", "posUnix", "=", "fileName", ".", "indexOf", "(", "UNIX_SEPARATOR", ",", "1", ")", ";", "int", "posWin", "=", "fileName", ".", "indexOf", "(", "WINDOWS_SEPARATOR", ",", "1", ")", ";", "if", "(", "posUnix", "==", "NOT_FOUND", "&&", "posWin", "==", "NOT_FOUND", ")", "{", "return", "len", "+", "1", ";", "}", "posUnix", "=", "posUnix", "==", "NOT_FOUND", "?", "posWin", ":", "posUnix", ";", "posWin", "=", "posWin", "==", "NOT_FOUND", "?", "posUnix", ":", "posWin", ";", "return", "Math", ".", "min", "(", "posUnix", ",", "posWin", ")", "+", "1", ";", "}", "final", "char", "ch1", "=", "fileName", ".", "charAt", "(", "1", ")", ";", "if", "(", "ch1", "==", "':'", ")", "{", "ch0", "=", "Character", ".", "toUpperCase", "(", "ch0", ")", ";", "if", "(", "ch0", ">=", "'A'", "&&", "ch0", "<=", "'Z'", ")", "{", "if", "(", "len", "==", "2", "||", "isSeparator", "(", "fileName", ".", "charAt", "(", "2", ")", ")", "==", "false", ")", "{", "return", "2", ";", "}", "return", "3", ";", "}", "else", "if", "(", "ch0", "==", "UNIX_SEPARATOR", ")", "{", "return", "1", ";", "}", "return", "NOT_FOUND", ";", "}", "else", "if", "(", "isSeparator", "(", "ch0", ")", "&&", "isSeparator", "(", "ch1", ")", ")", "{", "int", "posUnix", "=", "fileName", ".", "indexOf", "(", "UNIX_SEPARATOR", ",", "2", ")", ";", "int", "posWin", "=", "fileName", ".", "indexOf", "(", "WINDOWS_SEPARATOR", ",", "2", ")", ";", "if", "(", "posUnix", "==", "NOT_FOUND", "&&", "posWin", "==", "NOT_FOUND", "||", "posUnix", "==", "2", "||", "posWin", "==", "2", ")", "{", "return", "NOT_FOUND", ";", "}", "posUnix", "=", "posUnix", "==", "NOT_FOUND", "?", "posWin", ":", "posUnix", ";", "posWin", "=", "posWin", "==", "NOT_FOUND", "?", "posUnix", ":", "posWin", ";", "int", "pos", "=", "Math", ".", "min", "(", "posUnix", ",", "posWin", ")", "+", "1", ";", "String", "hostnamePart", "=", "fileName", ".", "substring", "(", "2", ",", "pos", "-", "1", ")", ";", "return", "isValidHostName", "(", "hostnamePart", ")", "?", "pos", ":", "NOT_FOUND", ";", "}", "else", "{", "return", "isSeparator", "(", "ch0", ")", "?", "1", ":", "0", ";", "}", "}"], "idx": 27046, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "2736b6fe", "function_name": "getPrefixLength", "body_hash": "a7fb0805decc99f376aad08a6f837e2d18a91d84"}
{"code": "@Override\n    public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n        }\n\n        if(hasCurrentMessage())\n        {\n            if(bodySize > _connection.getMaxMessageSize())\n            {\n                properties.dispose();\n                closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                             \"Message size of \" + bodySize + \" greater than allowed maximum of \" + _connection.getMaxMessageSize());\n            }\n            else\n            {\n                publishContentHeader(new ContentHeaderBody(properties, bodySize));\n            }\n        }\n        else\n        {\n            properties.dispose();\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"Attempt to send a content header without first sending a publish frame\",\n                                            _channelId);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "receiveMessageHeader", "(", "final", "BasicContentHeaderProperties", "properties", ",", "final", "long", "bodySize", ")", "{", "if", "(", "LOGGER", ".", "isDebugEnabled", "(", ")", ")", "{", "LOGGER", ".", "debug", "(", "\"", "RECV[", "\"", "+", "_channelId", "+", "\"", "] MessageHeader[ properties: {", "\"", "+", "properties", "+", "\"", "} bodySize: ", "\"", "+", "bodySize", "+", "\"", " ]", "\"", ")", ";", "}", "if", "(", "hasCurrentMessage", "(", ")", ")", "{", "if", "(", "bodySize", ">", "_connection", ".", "getMaxMessageSize", "(", ")", ")", "{", "properties", ".", "dispose", "(", ")", ";", "closeChannel", "(", "ErrorCodes", ".", "MESSAGE_TOO_LARGE", ",", "\"", "Message size of ", "\"", "+", "bodySize", "+", "\"", " greater than allowed maximum of ", "\"", "+", "_connection", ".", "getMaxMessageSize", "(", ")", ")", ";", "}", "else", "{", "publishContentHeader", "(", "new", "ContentHeaderBody", "(", "properties", ",", "bodySize", ")", ")", ";", "}", "}", "else", "{", "properties", ".", "dispose", "(", ")", ";", "_connection", ".", "sendConnectionClose", "(", "ErrorCodes", ".", "COMMAND_INVALID", ",", "\"", "Attempt to send a content header without first sending a publish frame", "\"", ",", "_channelId", ")", ";", "}", "}"], "idx": 5664, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "025b48f3193e2b10b1c41d2bc3bcfc9cfc238a27", "function_name": "receiveMessageHeader", "body_hash": "8064ce4bd30efaeb3b063930869c4cc537194401"}
{"code": "private String resolveToken(HttpServletRequest request) {\n        String bearerToken = request.getHeader(NacosAuthConfig.AUTHORIZATION_HEADER);\n        if (StringUtils.isNotBlank(bearerToken) && bearerToken.startsWith(TOKEN_PREFIX)) {\n            return bearerToken.substring(7);\n        }\n        String jwt = request.getParameter(Constants.ACCESS_TOKEN);\n        if (StringUtils.isNotBlank(jwt)) {\n            return jwt;\n        }\n        return null;\n    }", "code_tokens": ["private", "String", "resolveToken", "(", "HttpServletRequest", "request", ")", "{", "String", "bearerToken", "=", "request", ".", "getHeader", "(", "NacosAuthConfig", ".", "AUTHORIZATION_HEADER", ")", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "bearerToken", ")", "&&", "bearerToken", ".", "startsWith", "(", "TOKEN_PREFIX", ")", ")", "{", "return", "bearerToken", ".", "substring", "(", "7", ")", ";", "}", "String", "jwt", "=", "request", ".", "getParameter", "(", "Constants", ".", "ACCESS_TOKEN", ")", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "jwt", ")", ")", "{", "return", "jwt", ";", "}", "return", "null", ";", "}"], "idx": 98065, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "13f5810751485de07d8746f21fe1e271e24e3473", "function_name": "resolveToken", "body_hash": "7493623755338d2b6ad373319f3f0f83cd465588"}
{"code": "public static void securityClassLoad(ClassLoader loader){\n\n        if( System.getSecurityManager() == null ){\n            return;\n        }\n\n        final String basePackage = \"org.apache.jasper.\";\n        try {\n            loader.loadClass( basePackage +\n                \"runtime.JspFactoryImpl$PrivilegedGetPageContext\");\n            loader.loadClass( basePackage +\n                \"runtime.JspFactoryImpl$PrivilegedReleasePageContext\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspRuntimeLibrary\");\n            loader.loadClass( basePackage +\n                \"runtime.JspRuntimeLibrary$PrivilegedIntrospectHelper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.ServletResponseWrapperInclude\");\n            loader.loadClass( basePackage +\n                \"runtime.TagHandlerPool\");\n            loader.loadClass( basePackage +\n                \"runtime.JspFragmentHelper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.ProtectedFunctionMapper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$1\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$2\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$3\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$4\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$5\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$6\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$7\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$8\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$9\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$10\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$11\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$12\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspContextWrapper\");\n\n            // Trigger loading of class and reading of property\n            SecurityUtil.isPackageProtectionEnabled();\n\n            loader.loadClass( basePackage +\n                \"servlet.JspServletWrapper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspWriterImpl$1\");\n        } catch (ClassNotFoundException ex) {\n            log.error(\"SecurityClassLoad\", ex);\n        }\n    }", "code_tokens": ["public", "static", "void", "securityClassLoad", "(", "ClassLoader", "loader", ")", "{", "if", "(", "System", ".", "getSecurityManager", "(", ")", "==", "null", ")", "{", "return", ";", "}", "final", "String", "basePackage", "=", "\"", "org.apache.jasper.", "\"", ";", "try", "{", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspFactoryImpl$PrivilegedGetPageContext", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspFactoryImpl$PrivilegedReleasePageContext", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspRuntimeLibrary", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspRuntimeLibrary$PrivilegedIntrospectHelper", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.ServletResponseWrapperInclude", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.TagHandlerPool", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspFragmentHelper", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.ProtectedFunctionMapper", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$1", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$2", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$3", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$4", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$5", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$6", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$7", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$8", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$9", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$10", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$11", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.PageContextImpl$12", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspContextWrapper", "\"", ")", ";", "SecurityUtil", ".", "isPackageProtectionEnabled", "(", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "servlet.JspServletWrapper", "\"", ")", ";", "loader", ".", "loadClass", "(", "basePackage", "+", "\"", "runtime.JspWriterImpl$1", "\"", ")", ";", "}", "catch", "(", "ClassNotFoundException", "ex", ")", "{", "log", ".", "error", "(", "\"", "SecurityClassLoad", "\"", ",", "ex", ")", ";", "}", "}"], "idx": 99754, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "3adf2d614bce0fb9587b0eb7a4a9fbb7ac8e6d82", "function_name": "securityClassLoad", "body_hash": "972f9ab5d2b5847f8c17a138dca0373fac01cf21"}
{"code": "public static Document xmlText2GenericDom(InputStream is, Document emptyDoc)\n            throws SAXException, ParserConfigurationException, IOException\n    {\n        SAXParser parser = SAXHelper.saxFactory.newSAXParser();\n\n        Sax2Dom handler = new Sax2Dom(emptyDoc);\n\n        parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\n        parser.parse(is, handler);\n\n        return (Document) handler.getDOM();\n    }", "code_tokens": ["public", "static", "Document", "xmlText2GenericDom", "(", "InputStream", "is", ",", "Document", "emptyDoc", ")", "throws", "SAXException", ",", "ParserConfigurationException", ",", "IOException", "{", "SAXParser", "parser", "=", "SAXHelper", ".", "saxFactory", ".", "newSAXParser", "(", ")", ";", "Sax2Dom", "handler", "=", "new", "Sax2Dom", "(", "emptyDoc", ")", ";", "parser", ".", "setProperty", "(", "\"", "http://xml.org/sax/properties/lexical-handler", "\"", ",", "handler", ")", ";", "parser", ".", "parse", "(", "is", ",", "handler", ")", ";", "return", "(", "Document", ")", "handler", ".", "getDOM", "(", ")", ";", "}"], "idx": 76387, "cwe": "CWE-776", "target": 0, "status": "FIXED", "commit": "80cb805eb1488ba3a16c427866fa8ae1f52ff0c5", "function_name": "xmlText2GenericDom", "body_hash": "2745bc286922fe95739c9170243c618d2a7500aa"}
{"code": "static public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n        }\n        \n        File file = new File(dir, name);     \n        // For CVE-2018-19859, issue #1840\n        if (!file.toPath().normalize().startsWith(dir.toPath().normalize())) {\n        \tthrow new IllegalArgumentException(\"Zip archives with files escaping their root directory are not allowed.\");\n        }\n        \n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n        }\n        \n        file.getParentFile().mkdirs();\n        \n        return file;\n    }", "code_tokens": ["static", "public", "File", "allocateFile", "(", "File", "dir", ",", "String", "name", ")", "{", "int", "q", "=", "name", ".", "indexOf", "(", "'?'", ")", ";", "if", "(", "q", ">", "0", ")", "{", "name", "=", "name", ".", "substring", "(", "0", ",", "q", ")", ";", "}", "File", "file", "=", "new", "File", "(", "dir", ",", "name", ")", ";", "if", "(", "!", "file", ".", "toPath", "(", ")", ".", "normalize", "(", ")", ".", "startsWith", "(", "dir", ".", "toPath", "(", ")", ".", "normalize", "(", ")", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Zip archives with files escaping their root directory are not allowed.", "\"", ")", ";", "}", "int", "dot", "=", "name", ".", "indexOf", "(", "'.'", ")", ";", "String", "prefix", "=", "dot", "<", "0", "?", "name", ":", "name", ".", "substring", "(", "0", ",", "dot", ")", ";", "String", "suffix", "=", "dot", "<", "0", "?", "\"", "\"", ":", "name", ".", "substring", "(", "dot", ")", ";", "int", "index", "=", "2", ";", "while", "(", "file", ".", "exists", "(", ")", ")", "{", "file", "=", "new", "File", "(", "dir", ",", "prefix", "+", "\"", "-", "\"", "+", "index", "++", "+", "suffix", ")", ";", "}", "file", ".", "getParentFile", "(", ")", ".", "mkdirs", "(", ")", ";", "return", "file", ";", "}"], "idx": 25761, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "e243e73e4064de87a913946bd320fbbe246da656", "function_name": "allocateFile", "body_hash": "e1b42cd4019867bf82fd77a54564fd0f55c524d7"}
{"code": "@Override\n\tprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tHttpServletRequest requestToUse = request;\n\n\t\tif (\"POST\".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n\t\t\tString paramValue = request.getParameter(this.methodParam);\n\t\t\tif (StringUtils.hasLength(paramValue)) {\n\t\t\t\trequestToUse = new HttpMethodRequestWrapper(request, paramValue);\n\t\t\t}\n\t\t}\n\n\t\tfilterChain.doFilter(requestToUse, response);\n\t}", "code_tokens": ["@", "Override", "protected", "void", "doFilterInternal", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "FilterChain", "filterChain", ")", "throws", "ServletException", ",", "IOException", "{", "HttpServletRequest", "requestToUse", "=", "request", ";", "if", "(", "\"", "POST", "\"", ".", "equals", "(", "request", ".", "getMethod", "(", ")", ")", "&&", "request", ".", "getAttribute", "(", "WebUtils", ".", "ERROR_EXCEPTION_ATTRIBUTE", ")", "==", "null", ")", "{", "String", "paramValue", "=", "request", ".", "getParameter", "(", "this", ".", "methodParam", ")", ";", "if", "(", "StringUtils", ".", "hasLength", "(", "paramValue", ")", ")", "{", "requestToUse", "=", "new", "HttpMethodRequestWrapper", "(", "request", ",", "paramValue", ")", ";", "}", "}", "filterChain", ".", "doFilter", "(", "requestToUse", ",", "response", ")", ";", "}"], "idx": 103426, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "f2694a8ed93f1f63f87ce45d0bb638478b426acd", "function_name": "doFilterInternal", "body_hash": "e6fa260da875429dbb08f1912e3f46a7eeeb4b94"}
{"code": "@RequestMapping(\"/module/htmlformentry/htmlFormFromFile.form\")\n\tpublic void handleRequest(Model model, @RequestParam(value = \"filePath\", required = false) String filePath,\n\t                          @RequestParam(value = \"patientId\", required = false) Integer pId,\n\t                          @RequestParam(value = \"isFileUpload\", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"In reference data...\");\n\t\t\n\t\tmodel.addAttribute(\"previewHtml\", \"\");\n\t\tString message = \"\";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\"htmlFormFile\");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \"You must specify a file path to preview from file\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\"filePath\", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \"UTF-8\");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \"<script>\" + fes.getFieldAccessorJavascript() + \"</script>\";\n                }\n\t\t\t\tmodel.addAttribute(\"previewHtml\", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \"\";\n\t\t\t} else {\n\t\t\t\tmessage = \"Please specify a valid file path or select a valid file.\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"An error occurred while loading the html.\", e);\n\t\t\tmessage = \"An error occurred while loading the html. \" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"message\", message);\n\t\tmodel.addAttribute(\"isFileUpload\", isFileUpload);\n\t}", "code_tokens": ["@", "RequestMapping", "(", "\"", "/module/htmlformentry/htmlFormFromFile.form", "\"", ")", "public", "void", "handleRequest", "(", "Model", "model", ",", "@", "RequestParam", "(", "value", "=", "\"", "filePath", "\"", ",", "required", "=", "false", ")", "String", "filePath", ",", "@", "RequestParam", "(", "value", "=", "\"", "patientId", "\"", ",", "required", "=", "false", ")", "Integer", "pId", ",", "@", "RequestParam", "(", "value", "=", "\"", "isFileUpload", "\"", ",", "required", "=", "false", ")", "boolean", "isFileUpload", ",", "HttpServletRequest", "request", ")", "throws", "Exception", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "In reference data...", "\"", ")", ";", "model", ".", "addAttribute", "(", "\"", "previewHtml", "\"", ",", "\"", "\"", ")", ";", "String", "message", "=", "\"", "\"", ";", "File", "f", "=", "null", ";", "try", "{", "if", "(", "isFileUpload", ")", "{", "MultipartHttpServletRequest", "multipartRequest", "=", "(", "MultipartHttpServletRequest", ")", "request", ";", "MultipartFile", "multipartFile", "=", "multipartRequest", ".", "getFile", "(", "\"", "htmlFormFile", "\"", ")", ";", "if", "(", "multipartFile", "!=", "null", ")", "{", "f", "=", "new", "File", "(", "SystemUtils", ".", "JAVA_IO_TMPDIR", ",", "TEMP_HTML_FORM_FILE_PREFIX", "+", "Context", ".", "getAuthenticatedUser", "(", ")", ".", "getSystemId", "(", ")", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "f", ".", "createNewFile", "(", ")", ";", "filePath", "=", "f", ".", "getAbsolutePath", "(", ")", ";", "FileOutputStream", "fileOut", "=", "new", "FileOutputStream", "(", "f", ")", ";", "IOUtils", ".", "copy", "(", "multipartFile", ".", "getInputStream", "(", ")", ",", "fileOut", ")", ";", "fileOut", ".", "close", "(", ")", ";", "}", "}", "else", "{", "if", "(", "StringUtils", ".", "hasText", "(", "filePath", ")", ")", "{", "f", "=", "new", "File", "(", "filePath", ")", ";", "}", "else", "{", "message", "=", "\"", "You must specify a file path to preview from file", "\"", ";", "}", "}", "if", "(", "f", "!=", "null", "&&", "f", ".", "exists", "(", ")", "&&", "f", ".", "canRead", "(", ")", ")", "{", "model", ".", "addAttribute", "(", "\"", "filePath", "\"", ",", "filePath", ")", ";", "StringWriter", "writer", "=", "new", "StringWriter", "(", ")", ";", "IOUtils", ".", "copy", "(", "new", "FileInputStream", "(", "f", ")", ",", "writer", ",", "\"", "UTF-8", "\"", ")", ";", "String", "xml", "=", "writer", ".", "toString", "(", ")", ";", "Patient", "p", "=", "null", ";", "if", "(", "pId", "!=", "null", ")", "{", "p", "=", "Context", ".", "getPatientService", "(", ")", ".", "getPatient", "(", "pId", ")", ";", "}", "else", "{", "p", "=", "HtmlFormEntryUtil", ".", "getFakePerson", "(", ")", ";", "}", "HtmlForm", "fakeForm", "=", "new", "HtmlForm", "(", ")", ";", "fakeForm", ".", "setXmlData", "(", "xml", ")", ";", "FormEntrySession", "fes", "=", "new", "FormEntrySession", "(", "p", ",", "null", ",", "Mode", ".", "ENTER", ",", "fakeForm", ",", "request", ".", "getSession", "(", ")", ")", ";", "String", "html", "=", "fes", ".", "getHtmlToDisplay", "(", ")", ";", "if", "(", "fes", ".", "getFieldAccessorJavascript", "(", ")", "!=", "null", ")", "{", "html", "+=", "\"", "<script>", "\"", "+", "fes", ".", "getFieldAccessorJavascript", "(", ")", "+", "\"", "</script>", "\"", ";", "}", "model", ".", "addAttribute", "(", "\"", "previewHtml", "\"", ",", "html", ")", ";", "message", "=", "\"", "\"", ";", "}", "else", "{", "message", "=", "\"", "Please specify a valid file path or select a valid file.", "\"", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "An error occurred while loading the html.", "\"", ",", "e", ")", ";", "message", "=", "\"", "An error occurred while loading the html. ", "\"", "+", "e", ".", "getMessage", "(", ")", ";", "}", "model", ".", "addAttribute", "(", "\"", "message", "\"", ",", "message", ")", ";", "model", ".", "addAttribute", "(", "\"", "isFileUpload", "\"", ",", "isFileUpload", ")", ";", "}"], "idx": 10438, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "86f35221c8a57cdd7557ce731a56b90db216c8e0", "function_name": "handleRequest", "body_hash": "496211715a338823ca20a017f1748c6b0eca45ac"}
{"code": "public static void unzipFileTo(String file, String dest) throws IOException {\n        File target = new File(file);\n        if (!target.exists())\n            throw new IllegalArgumentException(\"Archive doesnt exist\");\n        FileInputStream fin = new FileInputStream(target);\n        int BUFFER = 2048;\n        byte data[] = new byte[BUFFER];\n\n        if (file.endsWith(\".zip\") || file.endsWith(\".jar\")) {\n            try(ZipInputStream zis = new ZipInputStream(fin)) {\n                //get the zipped file list entry\n                ZipEntry ze = zis.getNextEntry();\n\n                while (ze != null) {\n                    String fileName = ze.getName();\n                    File newFile = new File(dest + File.separator + fileName);\n\n                    if (ze.isDirectory()) {\n                        newFile.mkdirs();\n                        zis.closeEntry();\n                        ze = zis.getNextEntry();\n                        continue;\n                    }\n\n                    FileOutputStream fos = new FileOutputStream(newFile);\n\n                    int len;\n                    while ((len = zis.read(data)) > 0) {\n                        fos.write(data, 0, len);\n                    }\n\n                    fos.close();\n                    ze = zis.getNextEntry();\n                    log.debug(\"File extracted: \" + newFile.getAbsoluteFile());\n                }\n\n                zis.closeEntry();\n            }\n        } else if (file.endsWith(\".tar.gz\") || file.endsWith(\".tgz\")) {\n\n            BufferedInputStream in = new BufferedInputStream(fin);\n            GzipCompressorInputStream gzIn = new GzipCompressorInputStream(in);\n            TarArchiveInputStream tarIn = new TarArchiveInputStream(gzIn);\n\n            TarArchiveEntry entry;\n            /* Read the tar entries using the getNextEntry method **/\n            while ((entry = (TarArchiveEntry) tarIn.getNextEntry()) != null) {\n                log.info(\"Extracting: \" + entry.getName());\n                /* If the entry is a directory, create the directory. */\n\n                if (entry.isDirectory()) {\n                    File f = new File(dest + File.separator + entry.getName());\n                    f.mkdirs();\n                }\n                /*\n                 * If the entry is a file,write the decompressed file to the disk\n                 * and close destination stream.\n                 */\n                else {\n                    int count;\n                    try(FileOutputStream fos = new FileOutputStream(dest + File.separator + entry.getName());\n                        BufferedOutputStream destStream = new BufferedOutputStream(fos, BUFFER);) {\n                        while ((count = tarIn.read(data, 0, BUFFER)) != -1) {\n                            destStream.write(data, 0, count);\n                        }\n\n                        destStream.flush();\n                        IOUtils.closeQuietly(destStream);\n                    }\n                }\n            }\n\n            // Close the input stream\n            tarIn.close();\n        } else if (file.endsWith(\".gz\")) {\n            File extracted = new File(target.getParent(), target.getName().replace(\".gz\", \"\"));\n            if (extracted.exists())\n                extracted.delete();\n            extracted.createNewFile();\n            try(GZIPInputStream is2 = new GZIPInputStream(fin); OutputStream fos = FileUtils.openOutputStream(extracted)) {\n                IOUtils.copyLarge(is2, fos);\n                fos.flush();\n            }\n        } else {\n            throw new IllegalStateException(\"Unable to infer file type (compression format) from source file name: \" +\n                    file);\n        }\n        target.delete();\n    }", "code_tokens": ["public", "static", "void", "unzipFileTo", "(", "String", "file", ",", "String", "dest", ")", "throws", "IOException", "{", "File", "target", "=", "new", "File", "(", "file", ")", ";", "if", "(", "!", "target", ".", "exists", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"", "Archive doesnt exist", "\"", ")", ";", "FileInputStream", "fin", "=", "new", "FileInputStream", "(", "target", ")", ";", "int", "BUFFER", "=", "2048", ";", "byte", "data", "[", "]", "=", "new", "byte", "[", "BUFFER", "]", ";", "if", "(", "file", ".", "endsWith", "(", "\"", ".zip", "\"", ")", "||", "file", ".", "endsWith", "(", "\"", ".jar", "\"", ")", ")", "{", "try", "(", "ZipInputStream", "zis", "=", "new", "ZipInputStream", "(", "fin", ")", ")", "{", "ZipEntry", "ze", "=", "zis", ".", "getNextEntry", "(", ")", ";", "while", "(", "ze", "!=", "null", ")", "{", "String", "fileName", "=", "ze", ".", "getName", "(", ")", ";", "File", "newFile", "=", "new", "File", "(", "dest", "+", "File", ".", "separator", "+", "fileName", ")", ";", "if", "(", "ze", ".", "isDirectory", "(", ")", ")", "{", "newFile", ".", "mkdirs", "(", ")", ";", "zis", ".", "closeEntry", "(", ")", ";", "ze", "=", "zis", ".", "getNextEntry", "(", ")", ";", "continue", ";", "}", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "newFile", ")", ";", "int", "len", ";", "while", "(", "(", "len", "=", "zis", ".", "read", "(", "data", ")", ")", ">", "0", ")", "{", "fos", ".", "write", "(", "data", ",", "0", ",", "len", ")", ";", "}", "fos", ".", "close", "(", ")", ";", "ze", "=", "zis", ".", "getNextEntry", "(", ")", ";", "log", ".", "debug", "(", "\"", "File extracted: ", "\"", "+", "newFile", ".", "getAbsoluteFile", "(", ")", ")", ";", "}", "zis", ".", "closeEntry", "(", ")", ";", "}", "}", "else", "if", "(", "file", ".", "endsWith", "(", "\"", ".tar.gz", "\"", ")", "||", "file", ".", "endsWith", "(", "\"", ".tgz", "\"", ")", ")", "{", "BufferedInputStream", "in", "=", "new", "BufferedInputStream", "(", "fin", ")", ";", "GzipCompressorInputStream", "gzIn", "=", "new", "GzipCompressorInputStream", "(", "in", ")", ";", "TarArchiveInputStream", "tarIn", "=", "new", "TarArchiveInputStream", "(", "gzIn", ")", ";", "TarArchiveEntry", "entry", ";", "while", "(", "(", "entry", "=", "(", "TarArchiveEntry", ")", "tarIn", ".", "getNextEntry", "(", ")", ")", "!=", "null", ")", "{", "log", ".", "info", "(", "\"", "Extracting: ", "\"", "+", "entry", ".", "getName", "(", ")", ")", ";", "if", "(", "entry", ".", "isDirectory", "(", ")", ")", "{", "File", "f", "=", "new", "File", "(", "dest", "+", "File", ".", "separator", "+", "entry", ".", "getName", "(", ")", ")", ";", "f", ".", "mkdirs", "(", ")", ";", "}", "else", "{", "int", "count", ";", "try", "(", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "dest", "+", "File", ".", "separator", "+", "entry", ".", "getName", "(", ")", ")", ";", "BufferedOutputStream", "destStream", "=", "new", "BufferedOutputStream", "(", "fos", ",", "BUFFER", ")", ";", ")", "{", "while", "(", "(", "count", "=", "tarIn", ".", "read", "(", "data", ",", "0", ",", "BUFFER", ")", ")", "!=", "-", "1", ")", "{", "destStream", ".", "write", "(", "data", ",", "0", ",", "count", ")", ";", "}", "destStream", ".", "flush", "(", ")", ";", "IOUtils", ".", "closeQuietly", "(", "destStream", ")", ";", "}", "}", "}", "tarIn", ".", "close", "(", ")", ";", "}", "else", "if", "(", "file", ".", "endsWith", "(", "\"", ".gz", "\"", ")", ")", "{", "File", "extracted", "=", "new", "File", "(", "target", ".", "getParent", "(", ")", ",", "target", ".", "getName", "(", ")", ".", "replace", "(", "\"", ".gz", "\"", ",", "\"", "\"", ")", ")", ";", "if", "(", "extracted", ".", "exists", "(", ")", ")", "extracted", ".", "delete", "(", ")", ";", "extracted", ".", "createNewFile", "(", ")", ";", "try", "(", "GZIPInputStream", "is2", "=", "new", "GZIPInputStream", "(", "fin", ")", ";", "OutputStream", "fos", "=", "FileUtils", ".", "openOutputStream", "(", "extracted", ")", ")", "{", "IOUtils", ".", "copyLarge", "(", "is2", ",", "fos", ")", ";", "fos", ".", "flush", "(", ")", ";", "}", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Unable to infer file type (compression format) from source file name: ", "\"", "+", "file", ")", ";", "}", "target", ".", "delete", "(", ")", ";", "}"], "idx": 45000, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "f51f4242d67eed9c97a46051cc0c6c72d0830a27", "function_name": "unzipFileTo", "body_hash": "3f3d65838b4c2f0617c57750485758f1d4ffa8c7"}
{"code": "public synchronized void download(StaplerRequest req, StaplerResponse rsp) throws InterruptedException, IOException {\n        rsp.setStatus(HttpServletResponse.SC_OK);\n\n        // server->client channel.\n        // this is created first, and this controls the lifespan of the channel\n        rsp.addHeader(\"Transfer-Encoding\", \"chunked\");\n        OutputStream out = rsp.getOutputStream();\n        if (DIY_CHUNKING) out = new ChunkedOutputStream(out);\n\n        // send something out so that the client will see the HTTP headers\n        out.write(\"Starting HTTP duplex channel\".getBytes());\n        out.flush();\n\n        {// wait until we have the other channel\n            long end = System.currentTimeMillis() + CONNECTION_TIMEOUT;\n            while (upload == null && System.currentTimeMillis()<end)\n                wait(1000);\n\n            if (upload==null)\n                throw new IOException(\"HTTP full-duplex channel timeout: \"+uuid);\n        }\n\n        try {\n            channel = new Channel(\"HTTP full-duplex channel \" + uuid,\n                    Computer.threadPoolForRemoting, Mode.BINARY, upload, out, null, restricted);\n\n            // so that we can detect dead clients, periodically send something\n            PingThread ping = new PingThread(channel) {\n                @Override\n                protected void onDead(Throwable diagnosis) {\n                    LOGGER.log(Level.INFO,\"Duplex-HTTP session \" + uuid + \" is terminated\",diagnosis);\n                    // this will cause the channel to abort and subsequently clean up\n                    try {\n                        upload.close();\n                    } catch (IOException e) {\n                        // this can never happen\n                        throw new AssertionError(e);\n                    }\n                }\n\n                @Override\n                protected void onDead() {\n                    onDead(null);\n                }\n            };\n            ping.start();\n            main(channel);\n            channel.join();\n            ping.interrupt();\n        } finally {\n            // publish that we are done\n            completed=true;\n            notify();\n        }\n    }", "code_tokens": ["public", "synchronized", "void", "download", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "InterruptedException", ",", "IOException", "{", "rsp", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_OK", ")", ";", "rsp", ".", "addHeader", "(", "\"", "Transfer-Encoding", "\"", ",", "\"", "chunked", "\"", ")", ";", "OutputStream", "out", "=", "rsp", ".", "getOutputStream", "(", ")", ";", "if", "(", "DIY_CHUNKING", ")", "out", "=", "new", "ChunkedOutputStream", "(", "out", ")", ";", "out", ".", "write", "(", "\"", "Starting HTTP duplex channel", "\"", ".", "getBytes", "(", ")", ")", ";", "out", ".", "flush", "(", ")", ";", "{", "long", "end", "=", "System", ".", "currentTimeMillis", "(", ")", "+", "CONNECTION_TIMEOUT", ";", "while", "(", "upload", "==", "null", "&&", "System", ".", "currentTimeMillis", "(", ")", "<", "end", ")", "wait", "(", "1000", ")", ";", "if", "(", "upload", "==", "null", ")", "throw", "new", "IOException", "(", "\"", "HTTP full-duplex channel timeout: ", "\"", "+", "uuid", ")", ";", "}", "try", "{", "channel", "=", "new", "Channel", "(", "\"", "HTTP full-duplex channel ", "\"", "+", "uuid", ",", "Computer", ".", "threadPoolForRemoting", ",", "Mode", ".", "BINARY", ",", "upload", ",", "out", ",", "null", ",", "restricted", ")", ";", "PingThread", "ping", "=", "new", "PingThread", "(", "channel", ")", "{", "@", "Override", "protected", "void", "onDead", "(", "Throwable", "diagnosis", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "INFO", ",", "\"", "Duplex-HTTP session ", "\"", "+", "uuid", "+", "\"", " is terminated", "\"", ",", "diagnosis", ")", ";", "try", "{", "upload", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "AssertionError", "(", "e", ")", ";", "}", "}", "@", "Override", "protected", "void", "onDead", "(", ")", "{", "onDead", "(", "null", ")", ";", "}", "}", ";", "ping", ".", "start", "(", ")", ";", "main", "(", "channel", ")", ";", "channel", ".", "join", "(", ")", ";", "ping", ".", "interrupt", "(", ")", ";", "}", "finally", "{", "completed", "=", "true", ";", "notify", "(", ")", ";", "}", "}"], "idx": 51160, "cwe": "CWE-399", "target": 0, "status": "FIXED", "commit": "880e101b1a449355db6eb91f662aab9e5df75769", "function_name": "download", "body_hash": "2e047ec390388b22e8b9b101a75fbb9ff29c352d"}
{"code": "public void update(long done, long total, int item) {\n    if (exceptionTrhown) { return; }\n\n    // To avoid cache overloading, this object is saved when the upload starts,\n    // when it has finished, or when the interval from the last save is significant.\n    boolean save = bytesRead == 0 && done > 0 || done >= total || (new Date()).getTime() - saved.getTime() > DEFAULT_SAVE_INTERVAL;\n    bytesRead = done;\n    contentLength = total;\n    if (save) {\n      save();\n    }\n\n    // If other request has set an exception, it is thrown so the commons-fileupload's\n    // parser stops and the connection is closed.\n    if (isCanceled()) {\n      String eName = exception.getClass().getName().replaceAll(\"^.+\\\\.\", \"\");\n      logger.info(className + \" \" + sessionId + \" The upload has been canceled after \" + bytesRead + \" bytes received, raising an exception (\" + eName + \") to close the socket\");\n      exceptionTrhown = true;\n      throw exception;\n    }\n\n    // Just a way to slow down the upload process and see the progress bar in fast networks.\n    if (slowUploads > 0 && done < total) {\n      try {\n        Thread.sleep(slowUploads);\n      } catch (Exception e) {\n        exception = new RuntimeException(e);\n      }\n    }\n  }", "code_tokens": ["public", "void", "update", "(", "long", "done", ",", "long", "total", ",", "int", "item", ")", "{", "if", "(", "exceptionTrhown", ")", "{", "return", ";", "}", "boolean", "save", "=", "bytesRead", "==", "0", "&&", "done", ">", "0", "||", "done", ">=", "total", "||", "(", "new", "Date", "(", ")", ")", ".", "getTime", "(", ")", "-", "saved", ".", "getTime", "(", ")", ">", "DEFAULT_SAVE_INTERVAL", ";", "bytesRead", "=", "done", ";", "contentLength", "=", "total", ";", "if", "(", "save", ")", "{", "save", "(", ")", ";", "}", "if", "(", "isCanceled", "(", ")", ")", "{", "String", "eName", "=", "exception", ".", "getClass", "(", ")", ".", "getName", "(", ")", ".", "replaceAll", "(", "\"", "^.+", "\\\\", ".", "\"", ",", "\"", "\"", ")", ";", "logger", ".", "info", "(", "className", "+", "\"", " ", "\"", "+", "sessionId", "+", "\"", " The upload has been canceled after ", "\"", "+", "bytesRead", "+", "\"", " bytes received, raising an exception (", "\"", "+", "eName", "+", "\"", ") to close the socket", "\"", ")", ";", "exceptionTrhown", "=", "true", ";", "throw", "exception", ";", "}", "if", "(", "slowUploads", ">", "0", "&&", "done", "<", "total", ")", "{", "try", "{", "Thread", ".", "sleep", "(", "slowUploads", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "exception", "=", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "}"], "idx": 53714, "cwe": "CWE-434", "target": 1, "status": "VULNERABLE", "commit": "aca1a97", "function_name": "update", "body_hash": "cbd2fc97d72207495f9bfab29f85da67080e0161"}
{"code": "@Override\n        public void processPacket(PacketContext context) {\n            // TODO filter packets sent to processors based on registrations\n            for (ProcessorEntry entry : processors) {\n                try {\n                    long start = System.nanoTime();\n                    entry.processor().process(context);\n                    entry.addNanos(System.nanoTime() - start);\n                } catch (Exception e) {\n                    log.warn(\"Packet processor {} threw an exception\", entry.processor(), e);\n                }\n            }\n        }", "code_tokens": ["@", "Override", "public", "void", "processPacket", "(", "PacketContext", "context", ")", "{", "for", "(", "ProcessorEntry", "entry", ":", "processors", ")", "{", "try", "{", "long", "start", "=", "System", ".", "nanoTime", "(", ")", ";", "entry", ".", "processor", "(", ")", ".", "process", "(", "context", ")", ";", "entry", ".", "addNanos", "(", "System", ".", "nanoTime", "(", ")", "-", "start", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "warn", "(", "\"", "Packet processor {} threw an exception", "\"", ",", "entry", ".", "processor", "(", ")", ",", "e", ")", ";", "}", "}", "}"], "idx": 56725, "cwe": "CWE-476", "target": 0, "status": "FIXED", "commit": "f563830299f152e04717ef32fef84dadcd0ed54d", "function_name": "processPacket", "body_hash": "1959bdb92cdda745ae8a756cb9af6168dc160113"}
{"code": "@Override\n    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String path = baseRequest.getPathInfo();\n        int soff = 0, eoff;\n        // We're handling this request\n        baseRequest.setHandled(true);\n\n        if (path.charAt(0) == '/') soff = 1;\n        eoff = path.indexOf('/', soff);\n        if (soff < 0) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        String world = path.substring(soff, eoff);\n        String uri = path.substring(eoff+1);\n        // If faces directory, handle faces\n        if (world.equals(\"faces\")) {\n            handleFace(response, uri);\n            return;\n        }\n        // If markers directory, handle markers\n        if (world.equals(\"_markers_\")) {\n            handleMarkers(response, uri);\n            return;\n        }\n\n        DynmapWorld w = null;\n        if (core.mapManager != null) {\n            w = core.mapManager.getWorld(world);\n        }\n        // If world not found quit\n        if (w == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        MapStorage store = w.getMapStorage();    // Get storage handler\n        // Get tile reference, based on URI and world\n        MapStorageTile tile = store.getTile(w, uri);\n        if (tile == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Read tile\n        TileRead tr = null;\n        if (tile.getReadLock(5000)) {\n            tr = tile.read();\n            tile.releaseReadLock();\n        }\n        response.setHeader(\"Cache-Control\", \"max-age=0,must-revalidate\");\n        String etag;\n        if (tr == null) {\n        \tetag = \"\\\"\" + blankpnghash + \"\\\"\";\n        }\n        else {\n        \tetag = \"\\\"\" + tr.hashCode + \"\\\"\";\n        }\n        response.setHeader(\"ETag\", etag);\n        String ifnullmatch = request.getHeader(\"If-None-Match\");\n        if ((ifnullmatch != null) && ifnullmatch.equals(etag)) {\n            response.sendError(HttpStatus.NOT_MODIFIED_304);\n        \treturn;\n        }\n        if (tr == null) {\n            response.setContentType(\"image/png\");\n            response.setIntHeader(\"Content-Length\", blankpng.length);\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Got tile, package up for response\n        response.setDateHeader(\"Last-Modified\", tr.lastModified);\n        response.setIntHeader(\"Content-Length\", tr.image.length());\n        if (tr.format == ImageEncoding.PNG) {\n            response.setContentType(\"image/png\");\n        }\n        else {\n            response.setContentType(\"image/jpeg\");\n        }\n        ServletOutputStream out = response.getOutputStream();\n        out.write(tr.image.buffer(), 0, tr.image.length());\n        out.flush();\n\n    }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "String", "target", ",", "Request", "baseRequest", ",", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "baseRequest", ".", "getPathInfo", "(", ")", ";", "int", "soff", "=", "0", ",", "eoff", ";", "baseRequest", ".", "setHandled", "(", "true", ")", ";", "if", "(", "path", ".", "charAt", "(", "0", ")", "==", "'/'", ")", "soff", "=", "1", ";", "eoff", "=", "path", ".", "indexOf", "(", "'/'", ",", "soff", ")", ";", "if", "(", "soff", "<", "0", ")", "{", "response", ".", "sendError", "(", "HttpStatus", ".", "NOT_FOUND_404", ")", ";", "return", ";", "}", "String", "world", "=", "path", ".", "substring", "(", "soff", ",", "eoff", ")", ";", "String", "uri", "=", "path", ".", "substring", "(", "eoff", "+", "1", ")", ";", "if", "(", "world", ".", "equals", "(", "\"", "faces", "\"", ")", ")", "{", "handleFace", "(", "response", ",", "uri", ")", ";", "return", ";", "}", "if", "(", "world", ".", "equals", "(", "\"", "_markers_", "\"", ")", ")", "{", "handleMarkers", "(", "response", ",", "uri", ")", ";", "return", ";", "}", "DynmapWorld", "w", "=", "null", ";", "if", "(", "core", ".", "mapManager", "!=", "null", ")", "{", "w", "=", "core", ".", "mapManager", ".", "getWorld", "(", "world", ")", ";", "}", "if", "(", "w", "==", "null", ")", "{", "response", ".", "setContentType", "(", "\"", "image/png", "\"", ")", ";", "OutputStream", "os", "=", "response", ".", "getOutputStream", "(", ")", ";", "os", ".", "write", "(", "blankpng", ")", ";", "return", ";", "}", "MapStorage", "store", "=", "w", ".", "getMapStorage", "(", ")", ";", "MapStorageTile", "tile", "=", "store", ".", "getTile", "(", "w", ",", "uri", ")", ";", "if", "(", "tile", "==", "null", ")", "{", "response", ".", "setContentType", "(", "\"", "image/png", "\"", ")", ";", "OutputStream", "os", "=", "response", ".", "getOutputStream", "(", ")", ";", "os", ".", "write", "(", "blankpng", ")", ";", "return", ";", "}", "TileRead", "tr", "=", "null", ";", "if", "(", "tile", ".", "getReadLock", "(", "5000", ")", ")", "{", "tr", "=", "tile", ".", "read", "(", ")", ";", "tile", ".", "releaseReadLock", "(", ")", ";", "}", "response", ".", "setHeader", "(", "\"", "Cache-Control", "\"", ",", "\"", "max-age=0,must-revalidate", "\"", ")", ";", "String", "etag", ";", "if", "(", "tr", "==", "null", ")", "{", "etag", "=", "\"", "\\\"", "\"", "+", "blankpnghash", "+", "\"", "\\\"", "\"", ";", "}", "else", "{", "etag", "=", "\"", "\\\"", "\"", "+", "tr", ".", "hashCode", "+", "\"", "\\\"", "\"", ";", "}", "response", ".", "setHeader", "(", "\"", "ETag", "\"", ",", "etag", ")", ";", "String", "ifnullmatch", "=", "request", ".", "getHeader", "(", "\"", "If-None-Match", "\"", ")", ";", "if", "(", "(", "ifnullmatch", "!=", "null", ")", "&&", "ifnullmatch", ".", "equals", "(", "etag", ")", ")", "{", "response", ".", "sendError", "(", "HttpStatus", ".", "NOT_MODIFIED_304", ")", ";", "return", ";", "}", "if", "(", "tr", "==", "null", ")", "{", "response", ".", "setContentType", "(", "\"", "image/png", "\"", ")", ";", "response", ".", "setIntHeader", "(", "\"", "Content-Length", "\"", ",", "blankpng", ".", "length", ")", ";", "OutputStream", "os", "=", "response", ".", "getOutputStream", "(", ")", ";", "os", ".", "write", "(", "blankpng", ")", ";", "return", ";", "}", "response", ".", "setDateHeader", "(", "\"", "Last-Modified", "\"", ",", "tr", ".", "lastModified", ")", ";", "response", ".", "setIntHeader", "(", "\"", "Content-Length", "\"", ",", "tr", ".", "image", ".", "length", "(", ")", ")", ";", "if", "(", "tr", ".", "format", "==", "ImageEncoding", ".", "PNG", ")", "{", "response", ".", "setContentType", "(", "\"", "image/png", "\"", ")", ";", "}", "else", "{", "response", ".", "setContentType", "(", "\"", "image/jpeg", "\"", ")", ";", "}", "ServletOutputStream", "out", "=", "response", ".", "getOutputStream", "(", ")", ";", "out", ".", "write", "(", "tr", ".", "image", ".", "buffer", "(", ")", ",", "0", ",", "tr", ".", "image", ".", "length", "(", ")", ")", ";", "out", ".", "flush", "(", ")", ";", "}"], "idx": 38721, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "641f142cd3ccdcbfb04eda3059be22dd9ed93783", "function_name": "handle", "body_hash": "64b3b550d1cb5bb1629628a7961db68445a75877"}
{"code": "private File tempFile() throws IOException {\n        String newpostfix;\n        String diskFilename = getDiskFilename();\n        if (diskFilename != null) {\n            newpostfix = '_' + diskFilename;\n        } else {\n            newpostfix = getPostfix();\n        }\n        File tmpFile;\n        if (getBaseDirectory() == null) {\n            // create a temporary file\n            tmpFile = File.createTempFile(getPrefix(), newpostfix);\n        } else {\n            tmpFile = File.createTempFile(getPrefix(), newpostfix, new File(\n                    getBaseDirectory()));\n        }\n        if (deleteOnExit()) {\n            // See https://github.com/netty/netty/issues/10351\n            DeleteFileOnExitHook.add(tmpFile.getPath());\n        }\n        return tmpFile;\n    }", "code_tokens": ["private", "File", "tempFile", "(", ")", "throws", "IOException", "{", "String", "newpostfix", ";", "String", "diskFilename", "=", "getDiskFilename", "(", ")", ";", "if", "(", "diskFilename", "!=", "null", ")", "{", "newpostfix", "=", "'_'", "+", "diskFilename", ";", "}", "else", "{", "newpostfix", "=", "getPostfix", "(", ")", ";", "}", "File", "tmpFile", ";", "if", "(", "getBaseDirectory", "(", ")", "==", "null", ")", "{", "tmpFile", "=", "File", ".", "createTempFile", "(", "getPrefix", "(", ")", ",", "newpostfix", ")", ";", "}", "else", "{", "tmpFile", "=", "File", ".", "createTempFile", "(", "getPrefix", "(", ")", ",", "newpostfix", ",", "new", "File", "(", "getBaseDirectory", "(", ")", ")", ")", ";", "}", "if", "(", "deleteOnExit", "(", ")", ")", "{", "DeleteFileOnExitHook", ".", "add", "(", "tmpFile", ".", "getPath", "(", ")", ")", ";", "}", "return", "tmpFile", ";", "}"], "idx": 49792, "cwe": "CWE-378", "target": 1, "status": "VULNERABLE", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "tempFile", "body_hash": "d1eaac02f9cfdafbf539954274d04facf67efd2b"}
{"code": "@Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter<NotFoundException> parameter) {\n        String path = event.getLocation().getPath();\n        String additionalInfo = \"\";\n        if (parameter.hasCustomMessage()) {\n            additionalInfo = \"Reason: \" + parameter.getCustomMessage();\n        }\n        path = Jsoup.clean(path, Whitelist.none());\n        additionalInfo = Jsoup.clean(additionalInfo, Whitelist.none());\n\n        boolean productionMode = event.getUI().getSession().getConfiguration()\n                .isProductionMode();\n\n        String template = getErrorHtml(productionMode);\n        // {{routes}} should be replaced first so that it's not possible to\n        // insert {{routes}} snippet via other template values which may result\n        // in the listing of all available routes when this shouldn't not happen\n        if (template.contains(\"{{routes}}\")) {\n            template = template.replace(\"{{routes}}\", getRoutes(event));\n        }\n        template = template.replace(\"{{additionalInfo}}\", additionalInfo);\n        template = template.replace(\"{{path}}\", path);\n\n        getElement().appendChild(new Html(template).getElement());\n        return HttpServletResponse.SC_NOT_FOUND;\n    }", "code_tokens": ["@", "Override", "public", "int", "setErrorParameter", "(", "BeforeEnterEvent", "event", ",", "ErrorParameter", "<", "NotFoundException", ">", "parameter", ")", "{", "String", "path", "=", "event", ".", "getLocation", "(", ")", ".", "getPath", "(", ")", ";", "String", "additionalInfo", "=", "\"", "\"", ";", "if", "(", "parameter", ".", "hasCustomMessage", "(", ")", ")", "{", "additionalInfo", "=", "\"", "Reason: ", "\"", "+", "parameter", ".", "getCustomMessage", "(", ")", ";", "}", "path", "=", "Jsoup", ".", "clean", "(", "path", ",", "Whitelist", ".", "none", "(", ")", ")", ";", "additionalInfo", "=", "Jsoup", ".", "clean", "(", "additionalInfo", ",", "Whitelist", ".", "none", "(", ")", ")", ";", "boolean", "productionMode", "=", "event", ".", "getUI", "(", ")", ".", "getSession", "(", ")", ".", "getConfiguration", "(", ")", ".", "isProductionMode", "(", ")", ";", "String", "template", "=", "getErrorHtml", "(", "productionMode", ")", ";", "if", "(", "template", ".", "contains", "(", "\"", "{{routes}}", "\"", ")", ")", "{", "template", "=", "template", ".", "replace", "(", "\"", "{{routes}}", "\"", ",", "getRoutes", "(", "event", ")", ")", ";", "}", "template", "=", "template", ".", "replace", "(", "\"", "{{additionalInfo}}", "\"", ",", "additionalInfo", ")", ";", "template", "=", "template", ".", "replace", "(", "\"", "{{path}}", "\"", ",", "path", ")", ";", "getElement", "(", ")", ".", "appendChild", "(", "new", "Html", "(", "template", ")", ".", "getElement", "(", ")", ")", ";", "return", "HttpServletResponse", ".", "SC_NOT_FOUND", ";", "}"], "idx": 7712, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "a1533dc", "function_name": "setErrorParameter", "body_hash": "30e6c1bc30e47c025a0bc5b5698cb740b2e10c86"}
{"code": "@Override\n    public void setupRoutes() {\n        path(controllerBasePath(), () -> {\n            before(\"\", mimeType, this::setContentType);\n\n\n            // change the line below to enable appropriate security\n            before(\"\", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);\n\n            get(\"\", mimeType, this::show);\n\n            post(\"\", mimeType, this::createOrUpdate);\n            put(\"\", mimeType, this::createOrUpdate);\n\n            delete(\"\", mimeType, this::deleteBackupConfig);\n        });\n    }", "code_tokens": ["@", "Override", "public", "void", "setupRoutes", "(", ")", "{", "path", "(", "controllerBasePath", "(", ")", ",", "(", ")", "->", "{", "before", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "setContentType", ")", ";", "before", "(", "\"", "\"", ",", "mimeType", ",", "this", ".", "apiAuthenticationHelper", "::", "checkAdminUserAnd403", ")", ";", "get", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "show", ")", ";", "post", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "createOrUpdate", ")", ";", "put", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "createOrUpdate", ")", ";", "delete", "(", "\"", "\"", ",", "mimeType", ",", "this", "::", "deleteBackupConfig", ")", ";", "}", ")", ";", "}"], "idx": 43964, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "7d0baab0d361c377af84994f95ba76c280048548", "function_name": "setupRoutes", "body_hash": "ef2559639a3b0fe2670fd2daf97673789d23616a"}
{"code": "@Override\n    public void init(ServletConfig config) throws ServletException {\n\n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n\n        // Initialize the JSP Runtime Context\n        // Check for a custom Options implementation\n        String engineOptionsName = config.getInitParameter(\"engineOptionsClass\");\n        if (Constants.IS_SECURITY_ENABLED && engineOptionsName != null) {\n            log.info(Localizer.getMessage(\n                    \"jsp.info.ignoreSetting\", \"engineOptionsClass\", engineOptionsName));\n            engineOptionsName = null;\n        }\n        if (engineOptionsName != null) {\n            // Instantiate the indicated Options implementation\n            try {\n                ClassLoader loader = Thread.currentThread().getContextClassLoader();\n                Class<?> engineOptionsClass = loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig = { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor = engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                // Need to localize this.\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                // Use the default Options implementation\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            // Use the default Options implementation\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    return;\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"cannot locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "init", "(", "ServletConfig", "config", ")", "throws", "ServletException", "{", "super", ".", "init", "(", "config", ")", ";", "this", ".", "config", "=", "config", ";", "this", ".", "context", "=", "config", ".", "getServletContext", "(", ")", ";", "String", "engineOptionsName", "=", "config", ".", "getInitParameter", "(", "\"", "engineOptionsClass", "\"", ")", ";", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", "&&", "engineOptionsName", "!=", "null", ")", "{", "log", ".", "info", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.info.ignoreSetting", "\"", ",", "\"", "engineOptionsClass", "\"", ",", "engineOptionsName", ")", ")", ";", "engineOptionsName", "=", "null", ";", "}", "if", "(", "engineOptionsName", "!=", "null", ")", "{", "try", "{", "ClassLoader", "loader", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "Class", "<", "?", ">", "engineOptionsClass", "=", "loader", ".", "loadClass", "(", "engineOptionsName", ")", ";", "Class", "<", "?", ">", "[", "]", "ctorSig", "=", "{", "ServletConfig", ".", "class", ",", "ServletContext", ".", "class", "}", ";", "Constructor", "<", "?", ">", "ctor", "=", "engineOptionsClass", ".", "getConstructor", "(", "ctorSig", ")", ";", "Object", "[", "]", "args", "=", "{", "config", ",", "context", "}", ";", "options", "=", "(", "Options", ")", "ctor", ".", "newInstance", "(", "args", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "e", "=", "ExceptionUtils", ".", "unwrapInvocationTargetException", "(", "e", ")", ";", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "log", ".", "warn", "(", "\"", "Failed to load engineOptionsClass", "\"", ",", "e", ")", ";", "options", "=", "new", "EmbeddedServletOptions", "(", "config", ",", "context", ")", ";", "}", "}", "else", "{", "options", "=", "new", "EmbeddedServletOptions", "(", "config", ",", "context", ")", ";", "}", "rctxt", "=", "new", "JspRuntimeContext", "(", "context", ",", "options", ")", ";", "if", "(", "config", ".", "getInitParameter", "(", "\"", "jspFile", "\"", ")", "!=", "null", ")", "{", "jspFile", "=", "config", ".", "getInitParameter", "(", "\"", "jspFile", "\"", ")", ";", "try", "{", "if", "(", "null", "==", "context", ".", "getResource", "(", "jspFile", ")", ")", "{", "return", ";", "}", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "throw", "new", "ServletException", "(", "\"", "cannot locate jsp file", "\"", ",", "e", ")", ";", "}", "try", "{", "if", "(", "SecurityUtil", ".", "isPackageProtectionEnabled", "(", ")", ")", "{", "AccessController", ".", "doPrivileged", "(", "new", "PrivilegedExceptionAction", "<", "Object", ">", "(", ")", "{", "@", "Override", "public", "Object", "run", "(", ")", "throws", "IOException", ",", "ServletException", "{", "serviceJspFile", "(", "null", ",", "null", ",", "jspFile", ",", "true", ")", ";", "return", "null", ";", "}", "}", ")", ";", "}", "else", "{", "serviceJspFile", "(", "null", ",", "null", ",", "jspFile", ",", "true", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "ServletException", "(", "\"", "Could not precompile jsp: ", "\"", "+", "jspFile", ",", "e", ")", ";", "}", "catch", "(", "PrivilegedActionException", "e", ")", "{", "Throwable", "t", "=", "e", ".", "getCause", "(", ")", ";", "if", "(", "t", "instanceof", "ServletException", ")", "throw", "(", "ServletException", ")", "t", ";", "throw", "new", "ServletException", "(", "\"", "Could not precompile jsp: ", "\"", "+", "jspFile", ",", "e", ")", ";", "}", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.message.scratch.dir.is", "\"", ",", "options", ".", "getScratchDir", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "log", ".", "debug", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.message.dont.modify.servlets", "\"", ")", ")", ";", "}", "}"], "idx": 101832, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "f603f2f4595073f9490e01699d2083112a7c09a7", "function_name": "init", "body_hash": "ddb296d19de38f28cc65b4a57216324bef21420a"}
{"code": "@Override\n    public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {\n        if (cloud != null) return;\n        try {\n            cloud = new CloudFactory().getCloud();\n        } catch (CloudException e) {\n            return; // not running on a known cloud environment, so nothing to do\n        }\n\n        for (ServiceInfo serviceInfo : cloud.getServiceInfos()) {\n            if (serviceInfo instanceof SsoServiceInfo) {\n                Map<String, Object> map = new HashMap<>();\n                SsoServiceInfo ssoServiceInfo = (SsoServiceInfo) serviceInfo;\n                map.put(\"security.oauth2.client.clientId\", ssoServiceInfo.getClientId());\n                map.put(\"security.oauth2.client.clientSecret\", ssoServiceInfo.getClientSecret());\n                map.put(\"security.oauth2.client.accessTokenUri\", ssoServiceInfo.getAuthDomain() + \"/oauth/token\");\n                map.put(\"security.oauth2.client.userAuthorizationUri\", ssoServiceInfo.getAuthDomain() + \"/oauth/authorize\");\n                map.put(\"ssoServiceUrl\", ssoServiceInfo.getAuthDomain());\n                map.put(\"security.oauth2.resource.userInfoUri\", ssoServiceInfo.getAuthDomain() + \"/userinfo\");\n                map.put(\"security.oauth2.resource.tokenInfoUri\", ssoServiceInfo.getAuthDomain() + \"/check_token\");\n                map.put(\"security.oauth2.resource.jwk.key-set-uri\", ssoServiceInfo.getAuthDomain() + \"/token_keys\");\n                map.put(\"sso.connector.cloud.available\", \"success\");\n                MapPropertySource mapPropertySource = new MapPropertySource(\"vcapPivotalSso\", map);\n\n                event.getEnvironment().getPropertySources().addFirst(mapPropertySource);\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "onApplicationEvent", "(", "ApplicationEnvironmentPreparedEvent", "event", ")", "{", "if", "(", "cloud", "!=", "null", ")", "return", ";", "try", "{", "cloud", "=", "new", "CloudFactory", "(", ")", ".", "getCloud", "(", ")", ";", "}", "catch", "(", "CloudException", "e", ")", "{", "return", ";", "}", "for", "(", "ServiceInfo", "serviceInfo", ":", "cloud", ".", "getServiceInfos", "(", ")", ")", "{", "if", "(", "serviceInfo", "instanceof", "SsoServiceInfo", ")", "{", "Map", "<", "String", ",", "Object", ">", "map", "=", "new", "HashMap", "<", ">", "(", ")", ";", "SsoServiceInfo", "ssoServiceInfo", "=", "(", "SsoServiceInfo", ")", "serviceInfo", ";", "map", ".", "put", "(", "\"", "security.oauth2.client.clientId", "\"", ",", "ssoServiceInfo", ".", "getClientId", "(", ")", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.client.clientSecret", "\"", ",", "ssoServiceInfo", ".", "getClientSecret", "(", ")", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.client.accessTokenUri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/oauth/token", "\"", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.client.userAuthorizationUri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/oauth/authorize", "\"", ")", ";", "map", ".", "put", "(", "\"", "ssoServiceUrl", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.resource.userInfoUri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/userinfo", "\"", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.resource.tokenInfoUri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/check_token", "\"", ")", ";", "map", ".", "put", "(", "\"", "security.oauth2.resource.jwk.key-set-uri", "\"", ",", "ssoServiceInfo", ".", "getAuthDomain", "(", ")", "+", "\"", "/token_keys", "\"", ")", ";", "map", ".", "put", "(", "\"", "sso.connector.cloud.available", "\"", ",", "\"", "success", "\"", ")", ";", "MapPropertySource", "mapPropertySource", "=", "new", "MapPropertySource", "(", "\"", "vcapPivotalSso", "\"", ",", "map", ")", ";", "event", ".", "getEnvironment", "(", ")", ".", "getPropertySources", "(", ")", ".", "addFirst", "(", "mapPropertySource", ")", ";", "}", "}", "}"], "idx": 105668, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "ef647a2acf2363c6018e8543d665ac8862593372", "function_name": "onApplicationEvent", "body_hash": "f799ad884693a4b04c1714417f61fc73d5a58532"}
{"code": "@Override\n\tpublic Environment setUp(@SuppressWarnings(\"rawtypes\")AbstractBuild build, Launcher launcher,\n\t\t\tfinal BuildListener listener) throws IOException, InterruptedException\n\t{\n\t\tDescriptorImpl DESCRIPTOR = Hudson.getInstance().getDescriptorByType(DescriptorImpl.class);\n\t\tString vnc2swf = Util.escape(Util.nullify(DESCRIPTOR.getVnc2swf()));\n\t\tif(vnc2swf.equals(CANT_FIND_VNC2SWF))\n\t\t{\n\t\t\tlistener.fatalError(\"VNC Recorder: can't find 'vnc2swf' please check your jenkins global settings!\");\n\t\t\treturn null;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tFile vnc2swfFile = new File(vnc2swf);\n\t\t\tif (!vnc2swfFile.exists())\n\t\t\t{\n\t\t\t\tlistener.fatalError(\"VNC Recorder: can't find '\" + vnc2swf + \"' please check your jenkins global settings!\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tfinal VncRecorder vr = new VncRecorder();\n\t\tvr.setLoggingStream(listener.getLogger());\n//\t\tfinal Logger vncLogger = vr.getLoggerForPrintStream(listener.getLogger());\n\t\tif (!SystemUtils.IS_OS_UNIX)\n\t\t{\n\t\t\tlistener.fatalError(\"Feature \\\"Record VNC session\\\" works only under Unix/Linux!\");\n\t\t\treturn null;\n\t\t}\n\t\tString vncServReplaced = Util.replaceMacro(vncServ,build.getEnvironment(listener));\n\t\tif (vncServReplaced.indexOf(\":\") > 0 && vncServReplaced.split(\":\")[1].length() == 4 && vncServReplaced.split(\":\")[1].startsWith(\"59\") )\n\t\t{\n\t\t\tvncServReplaced = vncServReplaced.replace(\":59\", \":\");\n\t\t}\n\t\t\n\t\tString vncPasswFilePathReplaced = Util.replaceMacro(vncPasswFilePath,build.getEnvironment(listener));\n\t\t//String outFileBase = build.getEnvironment(listener).get(\"JOB_NAME\") + \"_\" +  build.getEnvironment(listener).get(\"BUILD_NUMBER\") + \".swf\";\n\t\tif (outFileName == null || outFileName.equalsIgnoreCase(\"null\"))\n\t\t{\n\t\t\toutFileName = \"${JOB_NAME}_${BUILD_NUMBER}\";\n\t\t}\n\t\tString outFileBase =  Util.replaceMacro(outFileName,build.getEnvironment(listener)) + \".swf\";\n\t\tlistener.getLogger().println(\"Recording from vnc server: \" + vncServReplaced);\n\t\tlistener.getLogger().println(\"Using vnc passwd file: \" + vncPasswFilePathReplaced);\n\t\t//\t\tlistener.getLogger().printf(\"Using vnc passwd file: %s\\n\",vncPasswFilePath);\t\n\n\n\t\tFile vncPasswFile = new File(vncPasswFilePathReplaced);\n\t\tif (vncPasswFilePathReplaced.isEmpty())\n\t\t{\n\t\t\tlistener.getLogger().println(\"VNC password file is an empty string, trying vnc connection without password\");\n\t\t\tvncPasswFile = null;\n\t\t}\n\t\telse if (!vncPasswFile.exists())\n\t\t{\n\t\t\tlistener.getLogger().println(\"Can't find \" +vncPasswFile  +\", trying vnc connection without password \");\n\t\t\tvncPasswFile = null;\n\t\t}\n\n\t\tFile artifactsDir = build.getArtifactsDir();\n\t\tlistener.getLogger().print(build.getUrl());\n\t\tif(!artifactsDir.exists())\n\t\t{\n\t\t\tif (!artifactsDir.mkdir())\n\t\t\t{\n\t\t\t  listener.error(\"Can't create \" + artifactsDir.getAbsolutePath());\n\t\t\t}\n\t\t}\n\n\t\tif (outFileBase == null || outFileBase.equalsIgnoreCase(\"null.swf\"))\n\t\t{\n\t\t\toutFileBase = build.getNumber() + \".swf\";\n\n\t\t}\n\t\tfinal File outFileSwf = new File(artifactsDir,outFileBase); \n\t\tfinal File outFileHtml = new File(outFileSwf.getAbsolutePath().replace(\".swf\", \".html\"));\n\n\t\tfinal Date from = new Date();\n\t\tfinal Future<Integer> recordState = vr.record(vncServReplaced, outFileSwf.getAbsolutePath(), vncPasswFile,vnc2swf);\n\n\t\treturn new Environment() {\n\t\t\t@Override\n\t\t\tpublic void buildEnvVars(Map<String, String> env) {\n\t\t\t\t//\t\t\t\tenv.put(\"PATH\",env.get(\"PATH\"));\n\t\t\t\t//\t\t\t\tenv.put(\"DISPLAY\", vncServ);\n\t\t\t\tif (setDisplay && env != null && vncServ != null)\n\t\t\t\t\tenv.put(\"DISPLAY\",Util.replaceMacro(vncServ,env));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean tearDown(AbstractBuild build, BuildListener listener)\n\t\t\t\t\tthrows IOException, InterruptedException {\n\t\t\t\tfinal Date to = new Date();\n\t\t\t\tif (recordState != null)\n\t\t\t\t{\t\n\t\t\t\t\trecordState.cancel(true);\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\t\t\t\tif (removeIfSuccessful == null)\n\t\t\t\t\tremoveIfSuccessful = false;\n\n\n\t\t\t\tif ((removeIfSuccessful && outFileSwf.exists()) && (build == null || build.getResult() == Result.SUCCESS || build.getResult() == null)  )\n\t\t\t\t{\n\t\t\t\t\tlistener.getLogger().println(\"Build successful: Removing video file \" + outFileSwf.getAbsolutePath() + \" \\n\");\n\t\t\t\t\t\n\t\t\t\t\tif(!outFileSwf.delete())\n\t\t\t\t\t listener.error(\"Can't delete \" + outFileSwf.getAbsolutePath());\n\t\t\t\t\t\n\t\t\t\t\tif(!outFileHtml.delete())\n\t                     listener.error(\"Can't delete \" + outFileHtml.getAbsolutePath());\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (!outFileSwf.exists())\n\t\t\t\t{\n\t\t\t\t\tlistener.error(\"File \" + outFileSwf.getAbsolutePath() +\" doesn't exist. \\nFeature \\\"Record VNC session\\\" failed!\");\n\t\t\t\t\tif (failJobIfFailed)\n\t\t\t\t\t    return false;\n\t\t\t\t\telse\n\t\t\t\t\t  return true;\n\t\t\t\t}  \n\n\n\t\t\t\tSimpleDateFormat sf = new SimpleDateFormat(\"yyyy-MM-dd 'T' HH:mm:ss\");\n\t\t\t\tlistener.hyperlink(\"artifact/\" + outFileHtml.getName(),\"Video from \" + sf.format(from) + \" to \" + sf.format(to));\n\t\t\t\tlistener.getLogger().print(\"\\n\");\n\t\t\t\t//\t\t\t\t\tString con = com.google.common.io.Files.toString(outFileHtml, Charset.forName(\"utf-8\"));\n\t\t\t\t//\t\t\t\t\tcon = con.replaceAll(\"<embed src=\\\"\"+ outFileSwf.getName() +\"\\\"\", \"<embed src=\\\"\"+ \"artifact/\" + outFileSwf.getName()  +\"\\\"\");\n\t\t\t\t//\t\t\t\t\tExpandableDetailsNote dn = new ExpandableDetailsNote(new Date().toString(),con);\n\t\t\t\t//\t\t\t\t\tlistener.annotate(dn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\t}", "code_tokens": ["@", "Override", "public", "Environment", "setUp", "(", "@", "SuppressWarnings", "(", "\"", "rawtypes", "\"", ")", "AbstractBuild", "build", ",", "Launcher", "launcher", ",", "final", "BuildListener", "listener", ")", "throws", "IOException", ",", "InterruptedException", "{", "DescriptorImpl", "DESCRIPTOR", "=", "Hudson", ".", "getInstance", "(", ")", ".", "getDescriptorByType", "(", "DescriptorImpl", ".", "class", ")", ";", "String", "vnc2swf", "=", "Util", ".", "escape", "(", "Util", ".", "nullify", "(", "DESCRIPTOR", ".", "getVnc2swf", "(", ")", ")", ")", ";", "if", "(", "vnc2swf", ".", "equals", "(", "CANT_FIND_VNC2SWF", ")", ")", "{", "listener", ".", "fatalError", "(", "\"", "VNC Recorder: can't find 'vnc2swf' please check your jenkins global settings!", "\"", ")", ";", "return", "null", ";", "}", "else", "{", "File", "vnc2swfFile", "=", "new", "File", "(", "vnc2swf", ")", ";", "if", "(", "!", "vnc2swfFile", ".", "exists", "(", ")", ")", "{", "listener", ".", "fatalError", "(", "\"", "VNC Recorder: can't find '", "\"", "+", "vnc2swf", "+", "\"", "' please check your jenkins global settings!", "\"", ")", ";", "return", "null", ";", "}", "}", "final", "VncRecorder", "vr", "=", "new", "VncRecorder", "(", ")", ";", "vr", ".", "setLoggingStream", "(", "listener", ".", "getLogger", "(", ")", ")", ";", "if", "(", "!", "SystemUtils", ".", "IS_OS_UNIX", ")", "{", "listener", ".", "fatalError", "(", "\"", "Feature ", "\\\"", "Record VNC session", "\\\"", " works only under Unix/Linux!", "\"", ")", ";", "return", "null", ";", "}", "String", "vncServReplaced", "=", "Util", ".", "replaceMacro", "(", "vncServ", ",", "build", ".", "getEnvironment", "(", "listener", ")", ")", ";", "if", "(", "vncServReplaced", ".", "indexOf", "(", "\"", ":", "\"", ")", ">", "0", "&&", "vncServReplaced", ".", "split", "(", "\"", ":", "\"", ")", "[", "1", "]", ".", "length", "(", ")", "==", "4", "&&", "vncServReplaced", ".", "split", "(", "\"", ":", "\"", ")", "[", "1", "]", ".", "startsWith", "(", "\"", "59", "\"", ")", ")", "{", "vncServReplaced", "=", "vncServReplaced", ".", "replace", "(", "\"", ":59", "\"", ",", "\"", ":", "\"", ")", ";", "}", "String", "vncPasswFilePathReplaced", "=", "Util", ".", "replaceMacro", "(", "vncPasswFilePath", ",", "build", ".", "getEnvironment", "(", "listener", ")", ")", ";", "if", "(", "outFileName", "==", "null", "||", "outFileName", ".", "equalsIgnoreCase", "(", "\"", "null", "\"", ")", ")", "{", "outFileName", "=", "\"", "${JOB_NAME}_${BUILD_NUMBER}", "\"", ";", "}", "String", "outFileBase", "=", "Util", ".", "replaceMacro", "(", "outFileName", ",", "build", ".", "getEnvironment", "(", "listener", ")", ")", "+", "\"", ".swf", "\"", ";", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Recording from vnc server: ", "\"", "+", "vncServReplaced", ")", ";", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Using vnc passwd file: ", "\"", "+", "vncPasswFilePathReplaced", ")", ";", "File", "vncPasswFile", "=", "new", "File", "(", "vncPasswFilePathReplaced", ")", ";", "if", "(", "vncPasswFilePathReplaced", ".", "isEmpty", "(", ")", ")", "{", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "VNC password file is an empty string, trying vnc connection without password", "\"", ")", ";", "vncPasswFile", "=", "null", ";", "}", "else", "if", "(", "!", "vncPasswFile", ".", "exists", "(", ")", ")", "{", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Can't find ", "\"", "+", "vncPasswFile", "+", "\"", ", trying vnc connection without password ", "\"", ")", ";", "vncPasswFile", "=", "null", ";", "}", "File", "artifactsDir", "=", "build", ".", "getArtifactsDir", "(", ")", ";", "listener", ".", "getLogger", "(", ")", ".", "print", "(", "build", ".", "getUrl", "(", ")", ")", ";", "if", "(", "!", "artifactsDir", ".", "exists", "(", ")", ")", "{", "if", "(", "!", "artifactsDir", ".", "mkdir", "(", ")", ")", "{", "listener", ".", "error", "(", "\"", "Can't create ", "\"", "+", "artifactsDir", ".", "getAbsolutePath", "(", ")", ")", ";", "}", "}", "if", "(", "outFileBase", "==", "null", "||", "outFileBase", ".", "equalsIgnoreCase", "(", "\"", "null.swf", "\"", ")", ")", "{", "outFileBase", "=", "build", ".", "getNumber", "(", ")", "+", "\"", ".swf", "\"", ";", "}", "final", "File", "outFileSwf", "=", "new", "File", "(", "artifactsDir", ",", "outFileBase", ")", ";", "final", "File", "outFileHtml", "=", "new", "File", "(", "outFileSwf", ".", "getAbsolutePath", "(", ")", ".", "replace", "(", "\"", ".swf", "\"", ",", "\"", ".html", "\"", ")", ")", ";", "final", "Date", "from", "=", "new", "Date", "(", ")", ";", "final", "Future", "<", "Integer", ">", "recordState", "=", "vr", ".", "record", "(", "vncServReplaced", ",", "outFileSwf", ".", "getAbsolutePath", "(", ")", ",", "vncPasswFile", ",", "vnc2swf", ")", ";", "return", "new", "Environment", "(", ")", "{", "@", "Override", "public", "void", "buildEnvVars", "(", "Map", "<", "String", ",", "String", ">", "env", ")", "{", "if", "(", "setDisplay", "&&", "env", "!=", "null", "&&", "vncServ", "!=", "null", ")", "env", ".", "put", "(", "\"", "DISPLAY", "\"", ",", "Util", ".", "replaceMacro", "(", "vncServ", ",", "env", ")", ")", ";", "}", "@", "Override", "public", "boolean", "tearDown", "(", "AbstractBuild", "build", ",", "BuildListener", "listener", ")", "throws", "IOException", ",", "InterruptedException", "{", "final", "Date", "to", "=", "new", "Date", "(", ")", ";", "if", "(", "recordState", "!=", "null", ")", "{", "recordState", ".", "cancel", "(", "true", ")", ";", "Thread", ".", "sleep", "(", "1000", ")", ";", "}", "if", "(", "removeIfSuccessful", "==", "null", ")", "removeIfSuccessful", "=", "false", ";", "if", "(", "(", "removeIfSuccessful", "&&", "outFileSwf", ".", "exists", "(", ")", ")", "&&", "(", "build", "==", "null", "||", "build", ".", "getResult", "(", ")", "==", "Result", ".", "SUCCESS", "||", "build", ".", "getResult", "(", ")", "==", "null", ")", ")", "{", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Build successful: Removing video file ", "\"", "+", "outFileSwf", ".", "getAbsolutePath", "(", ")", "+", "\"", " ", "\\n", "\"", ")", ";", "if", "(", "!", "outFileSwf", ".", "delete", "(", ")", ")", "listener", ".", "error", "(", "\"", "Can't delete ", "\"", "+", "outFileSwf", ".", "getAbsolutePath", "(", ")", ")", ";", "if", "(", "!", "outFileHtml", ".", "delete", "(", ")", ")", "listener", ".", "error", "(", "\"", "Can't delete ", "\"", "+", "outFileHtml", ".", "getAbsolutePath", "(", ")", ")", ";", "return", "true", ";", "}", "if", "(", "!", "outFileSwf", ".", "exists", "(", ")", ")", "{", "listener", ".", "error", "(", "\"", "File ", "\"", "+", "outFileSwf", ".", "getAbsolutePath", "(", ")", "+", "\"", " doesn't exist. ", "\\n", "Feature ", "\\\"", "Record VNC session", "\\\"", " failed!", "\"", ")", ";", "if", "(", "failJobIfFailed", ")", "return", "false", ";", "else", "return", "true", ";", "}", "SimpleDateFormat", "sf", "=", "new", "SimpleDateFormat", "(", "\"", "yyyy-MM-dd 'T' HH:mm:ss", "\"", ")", ";", "listener", ".", "hyperlink", "(", "\"", "artifact/", "\"", "+", "outFileHtml", ".", "getName", "(", ")", ",", "\"", "Video from ", "\"", "+", "sf", ".", "format", "(", "from", ")", "+", "\"", " to ", "\"", "+", "sf", ".", "format", "(", "to", ")", ")", ";", "listener", ".", "getLogger", "(", ")", ".", "print", "(", "\"", "\\n", "\"", ")", ";", "return", "true", ";", "}", "}", ";", "}"], "idx": 80642, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "42f720d", "function_name": "setUp", "body_hash": "2a89f0fac44a16c8bfdf9e6fce1c35c12537db40"}
{"code": "private void prepareRequest() throws IOException {\n\n        http11 = true;\n        http09 = false;\n        contentDelimitation = false;\n\n        if (protocol.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n        MessageBytes protocolMB = request.protocol();\n        if (protocolMB.equals(Constants.HTTP_11)) {\n            protocolMB.setString(Constants.HTTP_11);\n        } else if (protocolMB.equals(Constants.HTTP_10)) {\n            http11 = false;\n            keepAlive = false;\n            protocolMB.setString(Constants.HTTP_10);\n        } else if (protocolMB.equals(\"\")) {\n            // HTTP/0.9\n            http09 = true;\n            http11 = false;\n            keepAlive = false;\n        } else {\n            // Unsupported protocol\n            http11 = false;\n            // Send 505; Unsupported HTTP version\n            response.setStatus(505);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n            }\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        Pattern restrictedUserAgents = protocol.getRestrictedUserAgentsPattern();\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames);\n                for (String encodingName : encodingNames) {\n                    // \"identity\" codings are ignored\n                    addInputFilter(inputFilters, encodingName);\n                }\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "http11", "=", "true", ";", "http09", "=", "false", ";", "contentDelimitation", "=", "false", ";", "if", "(", "protocol", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MessageBytes", "protocolMB", "=", "request", ".", "protocol", "(", ")", ";", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_11", ")", ")", "{", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_11", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_10", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_10", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "\"", "\"", ")", ")", "{", "http09", "=", "true", ";", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "http11", "=", "false", ";", "response", ".", "setStatus", "(", "505", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Unsupported HTTP version ", "\\\"", "\"", "+", "protocolMB", "+", "\"", "\\\"", "\"", ")", ";", "}", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEP_ALIVE_HEADER_VALUE_TOKEN", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "inputBuffer", ".", "setSwallowInput", "(", "false", ")", ";", "request", ".", "setExpectation", "(", "true", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "Pattern", "restrictedUserAgents", "=", "protocol", ".", "getRestrictedUserAgentsPattern", "(", ")", ";", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "(", "http11", "||", "keepAlive", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "protocol", ".", "getAllowHostHeaderMismatch", "(", ")", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "inputBuffer", ".", "getFilters", "(", ")", ";", "if", "(", "http11", ")", "{", "MessageBytes", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ";", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "}", "else", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 54453, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "060ecc5", "function_name": "prepareRequest", "body_hash": "e2e244d1452068aa88ff1cbcc61d9387dec58a9f"}
{"code": "private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \"foo\"\n        // or internal quotes that might need to be escaped : f\"o -> f\\\"o.\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\"' as closing regardless.\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string\n        // literals so that the output can be embedded in HTML script elements\n        // and in XML CDATA sections without affecting the parser state.\n        // References:\n        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements\n        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state\n        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state\n        // https://www.w3.org/TR/xml/#sec-cdata-sect\n        case '<':\n          // Disallow <!--, which lets the HTML parser switch into the \"script\n          // data escaped\" state.\n          // Disallow <script, which followed by various characters lets the\n          // HTML parser switch into or out of the \"script data double escaped\"\n          // state.\n          // Disallow </script, which ends a script block.\n          if (i + 3 >= end)\n            break;\n          char c1 = jsonish.charAt(i + 1);\n          char c2 = jsonish.charAt(i + 2);\n          char c3 = jsonish.charAt(i + 3);\n          char lc1 = (char) (c1 | 32);\n          char lc2 = (char) (c2 | 32);\n          char lc3 = (char) (c3 | 32);\n          if ((c1 == '!' && c2 == '-' && c3 == '-') ||\n              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {\n            replace(i, i + 1, \"\\\\u003c\"); // Escaped <\n          }\n          break;\n        case '>':\n          // Disallow -->, which lets the HTML parser switch out of the \"script\n          // data escaped\" or \"script data double escaped\" state.\n          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)\n              && '-' == jsonish.charAt(i - 1)) {\n            replace(i, i + 1, \"\\\\u003e\"); // Escaped >\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \"u00\");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \"\\-\" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\"'); }\n  }", "code_tokens": ["private", "void", "sanitizeString", "(", "int", "start", ",", "int", "end", ")", "{", "boolean", "closed", "=", "false", ";", "for", "(", "int", "i", "=", "start", ";", "i", "<", "end", ";", "++", "i", ")", "{", "char", "ch", "=", "jsonish", ".", "charAt", "(", "i", ")", ";", "switch", "(", "ch", ")", "{", "case", "'\\n'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "n", "\"", ")", ";", "break", ";", "case", "'\\r'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "r", "\"", ")", ";", "break", ";", "case", "'\\u2028'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2028", "\"", ")", ";", "break", ";", "case", "'\\u2029'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2029", "\"", ")", ";", "break", ";", "case", "'\"'", ":", "case", "'\\''", ":", "if", "(", "i", "==", "start", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "{", "if", "(", "i", "+", "1", "==", "end", ")", "{", "char", "startDelim", "=", "jsonish", ".", "charAt", "(", "start", ")", ";", "if", "(", "startDelim", "!=", "'\\''", ")", "{", "startDelim", "=", "'\"'", ";", "}", "closed", "=", "startDelim", "==", "ch", ";", "}", "if", "(", "closed", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "if", "(", "ch", "==", "'\"'", ")", "{", "insert", "(", "i", ",", "'\\\\'", ")", ";", "}", "}", "break", ";", "case", "'<'", ":", "if", "(", "i", "+", "3", ">=", "end", ")", "break", ";", "char", "c1", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "char", "c2", "=", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ";", "char", "c3", "=", "jsonish", ".", "charAt", "(", "i", "+", "3", ")", ";", "char", "lc1", "=", "(", "char", ")", "(", "c1", "|", "32", ")", ";", "char", "lc2", "=", "(", "char", ")", "(", "c2", "|", "32", ")", ";", "char", "lc3", "=", "(", "char", ")", "(", "c3", "|", "32", ")", ";", "if", "(", "(", "c1", "==", "'!'", "&&", "c2", "==", "'-'", "&&", "c3", "==", "'-'", ")", "||", "(", "lc1", "==", "'s'", "&&", "lc2", "==", "'c'", "&&", "lc3", "==", "'r'", ")", "||", "(", "c1", "==", "'/'", "&&", "lc2", "==", "'s'", "&&", "lc3", "==", "'c'", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u003c", "\"", ")", ";", "}", "break", ";", "case", "'>'", ":", "if", "(", "(", "i", "-", "2", ")", ">=", "start", "&&", "'-'", "==", "jsonish", ".", "charAt", "(", "i", "-", "2", ")", "&&", "'-'", "==", "jsonish", ".", "charAt", "(", "i", "-", "1", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u003e", "\"", ")", ";", "}", "break", ";", "case", "']'", ":", "if", "(", "i", "+", "2", "<", "end", "&&", "']'", "==", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", "&&", "'>'", "==", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u005d", "\"", ")", ";", "}", "break", ";", "case", "'\\\\'", ":", "if", "(", "i", "+", "1", "==", "end", ")", "{", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "char", "sch", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "switch", "(", "sch", ")", "{", "case", "'b'", ":", "case", "'f'", ":", "case", "'n'", ":", "case", "'r'", ":", "case", "'t'", ":", "case", "'\\\\'", ":", "case", "'/'", ":", "case", "'\"'", ":", "++", "i", ";", "break", ";", "case", "'v'", ":", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u0008", "\"", ")", ";", "++", "i", ";", "break", ";", "case", "'x'", ":", "if", "(", "i", "+", "4", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u00", "\"", ")", ";", "i", "+=", "3", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'u'", ":", "if", "(", "i", "+", "6", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", "&&", "isHexAt", "(", "i", "+", "4", ")", "&&", "isHexAt", "(", "i", "+", "5", ")", ")", "{", "i", "+=", "5", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'0'", ":", "case", "'1'", ":", "case", "'2'", ":", "case", "'3'", ":", "case", "'4'", ":", "case", "'5'", ":", "case", "'6'", ":", "case", "'7'", ":", "int", "octalEnd", "=", "i", "+", "1", ";", "if", "(", "octalEnd", "+", "1", "<", "end", "&&", "isOctAt", "(", "octalEnd", "+", "1", ")", ")", "{", "++", "octalEnd", ";", "if", "(", "ch", "<=", "'3'", "&&", "octalEnd", "+", "1", "<", "end", "&&", "isOctAt", "(", "octalEnd", "+", "1", ")", ")", "{", "++", "octalEnd", ";", "}", "int", "value", "=", "0", ";", "for", "(", "int", "j", "=", "i", ";", "j", "<", "octalEnd", ";", "++", "j", ")", "{", "value", "=", "(", "value", "<<", "3", ")", "|", "(", "jsonish", ".", "charAt", "(", "j", ")", "-", "'0'", ")", ";", "}", "replace", "(", "i", "+", "1", ",", "octalEnd", ",", "\"", "u00", "\"", ")", ";", "appendHex", "(", "value", ",", "2", ")", ";", "}", "i", "=", "octalEnd", "-", "1", ";", "break", ";", "default", ":", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "break", ";", "default", ":", "if", "(", "ch", "<", "0x20", ")", "{", "if", "(", "ch", "==", "9", "||", "ch", "==", "0xa", "||", "ch", "==", "0xd", ")", "{", "continue", ";", "}", "}", "else", "if", "(", "ch", "<", "0xd800", ")", "{", "continue", ";", "}", "else", "if", "(", "ch", "<", "0xe000", ")", "{", "if", "(", "Character", ".", "isHighSurrogate", "(", "ch", ")", "&&", "i", "+", "1", "<", "end", "&&", "Character", ".", "isLowSurrogate", "(", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "continue", ";", "}", "}", "else", "if", "(", "ch", "<=", "0xfffd", ")", "{", "continue", ";", "}", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u", "\"", ")", ";", "for", "(", "int", "j", "=", "4", ";", "--", "j", ">=", "0", ";", ")", "{", "sanitizedJson", ".", "append", "(", "HEX_DIGITS", "[", "(", "ch", ">>>", "(", "j", "<<", "2", ")", ")", "&", "0xf", "]", ")", ";", "}", "break", ";", "}", "}", "if", "(", "!", "closed", ")", "{", "insert", "(", "end", ",", "'\"'", ")", ";", "}", "}"], "idx": 70003, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "f2c9858c02cf521dd05f2c6f8f9450f2e1343090", "function_name": "sanitizeString", "body_hash": "6875cf1368bdaec5c56d42aa3729623c430310f1"}
{"code": "public void updateByXml(Source source) throws IOException {\n        checkPermission(CONFIGURE);\n        XmlFile configXmlFile = getConfigFile();\n        AtomicFileWriter out = new AtomicFileWriter(configXmlFile.getFile());\n        try {\n            try {\n                // this allows us to use UTF-8 for storing data,\n                // plus it checks any well-formedness issue in the submitted\n                // data\n                Transformer t = TransformerFactory.newInstance()\n                        .newTransformer();\n                t.transform(source,\n                        new StreamResult(out));\n                out.close();\n            } catch (TransformerException e) {\n                throw new IOException2(\"Failed to persist configuration.xml\", e);\n            }\n\n            // try to reflect the changes by reloading\n            Object o = new XmlFile(Items.XSTREAM, out.getTemporaryFile()).unmarshal(this);\n            if (o!=this) {\n                // ensure that we've got the same job type. extending this code to support updating\n                // to different job type requires destroying & creating a new job type\n                throw new IOException(\"Expecting \"+this.getClass()+\" but got \"+o.getClass()+\" instead\");\n            }\n\n            Items.updatingByXml.set(true);\n            try {\n                onLoad(getParent(), getRootDir().getName());\n            } finally {\n                Items.updatingByXml.set(false);\n            }\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            // if everything went well, commit this new version\n            out.commit();\n            SaveableListener.fireOnChange(this, getConfigFile());\n        } finally {\n            out.abort(); // don't leave anything behind\n        }\n    }", "code_tokens": ["public", "void", "updateByXml", "(", "Source", "source", ")", "throws", "IOException", "{", "checkPermission", "(", "CONFIGURE", ")", ";", "XmlFile", "configXmlFile", "=", "getConfigFile", "(", ")", ";", "AtomicFileWriter", "out", "=", "new", "AtomicFileWriter", "(", "configXmlFile", ".", "getFile", "(", ")", ")", ";", "try", "{", "try", "{", "Transformer", "t", "=", "TransformerFactory", ".", "newInstance", "(", ")", ".", "newTransformer", "(", ")", ";", "t", ".", "transform", "(", "source", ",", "new", "StreamResult", "(", "out", ")", ")", ";", "out", ".", "close", "(", ")", ";", "}", "catch", "(", "TransformerException", "e", ")", "{", "throw", "new", "IOException2", "(", "\"", "Failed to persist configuration.xml", "\"", ",", "e", ")", ";", "}", "Object", "o", "=", "new", "XmlFile", "(", "Items", ".", "XSTREAM", ",", "out", ".", "getTemporaryFile", "(", ")", ")", ".", "unmarshal", "(", "this", ")", ";", "if", "(", "o", "!=", "this", ")", "{", "throw", "new", "IOException", "(", "\"", "Expecting ", "\"", "+", "this", ".", "getClass", "(", ")", "+", "\"", " but got ", "\"", "+", "o", ".", "getClass", "(", ")", "+", "\"", " instead", "\"", ")", ";", "}", "Items", ".", "updatingByXml", ".", "set", "(", "true", ")", ";", "try", "{", "onLoad", "(", "getParent", "(", ")", ",", "getRootDir", "(", ")", ".", "getName", "(", ")", ")", ";", "}", "finally", "{", "Items", ".", "updatingByXml", ".", "set", "(", "false", ")", ";", "}", "Jenkins", ".", "getInstance", "(", ")", ".", "rebuildDependencyGraphAsync", "(", ")", ";", "out", ".", "commit", "(", ")", ";", "SaveableListener", ".", "fireOnChange", "(", "this", ",", "getConfigFile", "(", ")", ")", ";", "}", "finally", "{", "out", ".", "abort", "(", ")", ";", "}", "}"], "idx": 30478, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "54d44502bd6ec8df23bf8ef0413bdad650ef321e", "function_name": "updateByXml", "body_hash": "da4050f726b2b4e52b0653245826dbc4ddb9e643"}
{"code": "@Override\n    public boolean checkObjectExecutePermission(Class clazz, String methodName)\n    {\n        if (Class.class.isAssignableFrom(clazz) && methodName != null && this.secureClassMethods.contains(methodName)) {\n            return true;\n        } else {\n            return super.checkObjectExecutePermission(clazz, methodName);\n        }\n    }", "code_tokens": ["@", "Override", "public", "boolean", "checkObjectExecutePermission", "(", "Class", "clazz", ",", "String", "methodName", ")", "{", "if", "(", "Class", ".", "class", ".", "isAssignableFrom", "(", "clazz", ")", "&&", "methodName", "!=", "null", "&&", "this", ".", "secureClassMethods", ".", "contains", "(", "methodName", ")", ")", "{", "return", "true", ";", "}", "else", "{", "return", "super", ".", "checkObjectExecutePermission", "(", "clazz", ",", "methodName", ")", ";", "}", "}"], "idx": 72463, "cwe": "CWE-668", "target": 1, "status": "VULNERABLE", "commit": "215951cfb0f808d0bf5b1097c9e7d1e503449ab8", "function_name": "checkObjectExecutePermission", "body_hash": "5aabc26d50bf34a30314acb1172db817b159154b"}
{"code": "private JMXConnectorServer createServer(String serverName,\n            String bindAddress, int theRmiRegistryPort, int theRmiServerPort,\n            Map<String,Object> theEnv,\n            RMIClientSocketFactory registryCsf, RMIServerSocketFactory registrySsf,\n            RMIClientSocketFactory serverCsf, RMIServerSocketFactory serverSsf) {\n\n        if (bindAddress == null) {\n            bindAddress = \"localhost\";\n        }\n\n        String url = \"service:jmx:rmi://\" + bindAddress;\n        JMXServiceURL serviceUrl;\n        try {\n            serviceUrl = new JMXServiceURL(url);\n        } catch (MalformedURLException e) {\n            log.error(sm.getString(\"jmxRemoteLifecycleListener.invalidURL\", serverName, url), e);\n            return null;\n        }\n\n        RMIConnectorServer cs = null;\n        try {\n            RMIJRMPServerImpl server = new RMIJRMPServerImpl(\n                    rmiServerPortPlatform, serverCsf, serverSsf, theEnv);\n            cs = new RMIConnectorServer(serviceUrl, theEnv, server,\n                    ManagementFactory.getPlatformMBeanServer());\n            cs.start();\n            Remote jmxServer = server.toStub();\n            // Create the RMI registry\n            try {\n                new JmxRegistry(theRmiRegistryPort, registryCsf, registrySsf, \"jmxrmi\", jmxServer);\n            } catch (RemoteException e) {\n                log.error(sm.getString(\n                        \"jmxRemoteLifecycleListener.createRegistryFailed\",\n                        serverName, Integer.toString(theRmiRegistryPort)), e);\n                return null;\n            }\n            log.info(sm.getString(\"jmxRemoteLifecycleListener.start\",\n                    Integer.toString(theRmiRegistryPort),\n                    Integer.toString(theRmiServerPort), serverName));\n        } catch (IOException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createServerFailed\",\n                    serverName), e);\n        }\n        return cs;\n    }", "code_tokens": ["private", "JMXConnectorServer", "createServer", "(", "String", "serverName", ",", "String", "bindAddress", ",", "int", "theRmiRegistryPort", ",", "int", "theRmiServerPort", ",", "Map", "<", "String", ",", "Object", ">", "theEnv", ",", "RMIClientSocketFactory", "registryCsf", ",", "RMIServerSocketFactory", "registrySsf", ",", "RMIClientSocketFactory", "serverCsf", ",", "RMIServerSocketFactory", "serverSsf", ")", "{", "if", "(", "bindAddress", "==", "null", ")", "{", "bindAddress", "=", "\"", "localhost", "\"", ";", "}", "String", "url", "=", "\"", "service:jmx:rmi://", "\"", "+", "bindAddress", ";", "JMXServiceURL", "serviceUrl", ";", "try", "{", "serviceUrl", "=", "new", "JMXServiceURL", "(", "url", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.invalidURL", "\"", ",", "serverName", ",", "url", ")", ",", "e", ")", ";", "return", "null", ";", "}", "RMIConnectorServer", "cs", "=", "null", ";", "try", "{", "RMIJRMPServerImpl", "server", "=", "new", "RMIJRMPServerImpl", "(", "rmiServerPortPlatform", ",", "serverCsf", ",", "serverSsf", ",", "theEnv", ")", ";", "cs", "=", "new", "RMIConnectorServer", "(", "serviceUrl", ",", "theEnv", ",", "server", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "cs", ".", "start", "(", ")", ";", "Remote", "jmxServer", "=", "server", ".", "toStub", "(", ")", ";", "try", "{", "new", "JmxRegistry", "(", "theRmiRegistryPort", ",", "registryCsf", ",", "registrySsf", ",", "\"", "jmxrmi", "\"", ",", "jmxServer", ")", ";", "}", "catch", "(", "RemoteException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.createRegistryFailed", "\"", ",", "serverName", ",", "Integer", ".", "toString", "(", "theRmiRegistryPort", ")", ")", ",", "e", ")", ";", "return", "null", ";", "}", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.start", "\"", ",", "Integer", ".", "toString", "(", "theRmiRegistryPort", ")", ",", "Integer", ".", "toString", "(", "theRmiServerPort", ")", ",", "serverName", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.createServerFailed", "\"", ",", "serverName", ")", ",", "e", ")", ";", "}", "return", "cs", ";", "}"], "idx": 99747, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "1fc9f58", "function_name": "createServer", "body_hash": "d9f1dc17c2f7e0f0182d358161ce34f8ca946c2b"}
{"code": "@Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        String secret = getSecret();\n        Key key = new SecretKeySpec(Decoders.BASE64.decode(secret), getSignatureAlgorithm().getJcaName());\n        \n        Jws<Claims> jwt = Jwts.parser().\n                setSigningKey(key).\n                parseClaimsJws((String) token.getPrincipal());\n        Map<String, Serializable> principal = getPrincipal(jwt);\n        return new SimpleAuthenticationInfo(principal, ((String) token.getCredentials()).toCharArray(), getName());\n    }", "code_tokens": ["@", "Override", "protected", "AuthenticationInfo", "doGetAuthenticationInfo", "(", "AuthenticationToken", "token", ")", "throws", "AuthenticationException", "{", "String", "secret", "=", "getSecret", "(", ")", ";", "Key", "key", "=", "new", "SecretKeySpec", "(", "Decoders", ".", "BASE64", ".", "decode", "(", "secret", ")", ",", "getSignatureAlgorithm", "(", ")", ".", "getJcaName", "(", ")", ")", ";", "Jws", "<", "Claims", ">", "jwt", "=", "Jwts", ".", "parser", "(", ")", ".", "setSigningKey", "(", "key", ")", ".", "parseClaimsJws", "(", "(", "String", ")", "token", ".", "getPrincipal", "(", ")", ")", ";", "Map", "<", "String", ",", "Serializable", ">", "principal", "=", "getPrincipal", "(", "jwt", ")", ";", "return", "new", "SimpleAuthenticationInfo", "(", "principal", ",", "(", "(", "String", ")", "token", ".", "getCredentials", "(", ")", ")", ".", "toCharArray", "(", ")", ",", "getName", "(", ")", ")", ";", "}"], "idx": 43481, "cwe": "CWE-347", "target": 0, "status": "FIXED", "commit": "8c754a0ad234555e813dcbf9e57d637f9f23d8fb", "function_name": "doGetAuthenticationInfo", "body_hash": "b2a335fede99f774048a81f9e9533e28ef5238d4"}
{"code": "public byte[] toXML() throws TransformerException {\n        removeEmptyNodes(doc);\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n\tDOMSource source = new DOMSource(doc);\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        Result result = new StreamResult(out);\n        transformer.transform(source, result);\n        return out.toByteArray();\n    }", "code_tokens": ["public", "byte", "[", "]", "toXML", "(", ")", "throws", "TransformerException", "{", "removeEmptyNodes", "(", "doc", ")", ";", "TransformerFactory", "transformerFactory", "=", "TransformerFactory", ".", "newInstance", "(", ")", ";", "Transformer", "transformer", "=", "transformerFactory", ".", "newTransformer", "(", ")", ";", "transformer", ".", "setOutputProperty", "(", "OutputKeys", ".", "METHOD", ",", "\"", "xml", "\"", ")", ";", "transformer", ".", "setOutputProperty", "(", "OutputKeys", ".", "INDENT", ",", "\"", "yes", "\"", ")", ";", "transformer", ".", "setOutputProperty", "(", "\"", "{http://xml.apache.org/xslt}indent-amount", "\"", ",", "\"", "4", "\"", ")", ";", "DOMSource", "source", "=", "new", "DOMSource", "(", "doc", ")", ";", "ByteArrayOutputStream", "out", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "Result", "result", "=", "new", "StreamResult", "(", "out", ")", ";", "transformer", ".", "transform", "(", "source", ",", "result", ")", ";", "return", "out", ".", "toByteArray", "(", ")", ";", "}"], "idx": 52001, "cwe": "CWE-399", "target": 1, "status": "VULNERABLE", "commit": "ad38371c396ac5ffbfb28056809e8ffaa5a18ccd", "function_name": "toXML", "body_hash": "bd731da46e44c4e396af6a0fcbac4f1e7381e479"}
{"code": "protected void throwable(BodyWriter w, Throwable throwable, boolean isCause) {\n    if (throwable != null) {\n      if (isCause) {\n        w.escape(\"Caused by: \");\n      }\n\n      w.escapeln(throwable.toString());\n      for (StackTraceElement ste : throwable.getStackTrace()) {\n        String className = ste.getClassName();\n        if (className.startsWith(\"ratpack\")\n          || className.startsWith(\"io.netty\")\n          || className.startsWith(\"com.google\")\n          || className.startsWith(\"java\")\n          || className.startsWith(\"org.springsource.loaded\")\n          ) {\n          w.print(\"<span class='stack-core'>  at \").escape(ste.toString()).println(\"</span>\");\n        } else {\n          w.print(\"  at \").escape(ste.toString()).println(\"\");\n        }\n      }\n\n      throwable(w, throwable.getCause(), true);\n    }\n  }", "code_tokens": ["protected", "void", "throwable", "(", "BodyWriter", "w", ",", "Throwable", "throwable", ",", "boolean", "isCause", ")", "{", "if", "(", "throwable", "!=", "null", ")", "{", "if", "(", "isCause", ")", "{", "w", ".", "escape", "(", "\"", "Caused by: ", "\"", ")", ";", "}", "w", ".", "escapeln", "(", "throwable", ".", "toString", "(", ")", ")", ";", "for", "(", "StackTraceElement", "ste", ":", "throwable", ".", "getStackTrace", "(", ")", ")", "{", "String", "className", "=", "ste", ".", "getClassName", "(", ")", ";", "if", "(", "className", ".", "startsWith", "(", "\"", "ratpack", "\"", ")", "||", "className", ".", "startsWith", "(", "\"", "io.netty", "\"", ")", "||", "className", ".", "startsWith", "(", "\"", "com.google", "\"", ")", "||", "className", ".", "startsWith", "(", "\"", "java", "\"", ")", "||", "className", ".", "startsWith", "(", "\"", "org.springsource.loaded", "\"", ")", ")", "{", "w", ".", "print", "(", "\"", "<span class='stack-core'>  at ", "\"", ")", ".", "escape", "(", "ste", ".", "toString", "(", ")", ")", ".", "println", "(", "\"", "</span>", "\"", ")", ";", "}", "else", "{", "w", ".", "print", "(", "\"", "  at ", "\"", ")", ".", "escape", "(", "ste", ".", "toString", "(", ")", ")", ".", "println", "(", "\"", "\"", ")", ";", "}", "}", "throwable", "(", "w", ",", "throwable", ".", "getCause", "(", ")", ",", "true", ")", ";", "}", "}"], "idx": 79873, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "a3cbb13be1527874528c3b99fc33517c0297b6d3", "function_name": "throwable", "body_hash": "cef695989540bcbb6af205865250f35b0790f0fc"}
{"code": "@Parameterized.Parameters(name = \"{index}: user[{3}], pwd[{4}]\")\n    public static Collection<Object[]> parameters() {\n        List<Object[]> parameterSets = new ArrayList<>();\n        for (String roleSearch : new String[] { ROLE_SEARCH_A, ROLE_SEARCH_B }) {\n            addUsers(USER_PATTERN, null, null, roleSearch, parameterSets);\n            addUsers(null, USER_SEARCH, USER_BASE, roleSearch, parameterSets);\n        }\n        return parameterSets;\n    }", "code_tokens": ["@", "Parameterized", ".", "Parameters", "(", "name", "=", "\"", "{index}: user[{3}], pwd[{4}]", "\"", ")", "public", "static", "Collection", "<", "Object", "[", "]", ">", "parameters", "(", ")", "{", "List", "<", "Object", "[", "]", ">", "parameterSets", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "for", "(", "String", "roleSearch", ":", "new", "String", "[", "]", "{", "ROLE_SEARCH_A", ",", "ROLE_SEARCH_B", "}", ")", "{", "addUsers", "(", "USER_PATTERN", ",", "null", ",", "null", ",", "roleSearch", ",", "parameterSets", ")", ";", "addUsers", "(", "null", ",", "USER_SEARCH", ",", "USER_BASE", ",", "roleSearch", ",", "parameterSets", ")", ";", "}", "return", "parameterSets", ";", "}"], "idx": 1112, "cwe": "CWE-116", "target": 0, "status": "FIXED", "commit": "b930d0b3161d9ec78d5fa57f886ed2de4680518b", "function_name": "parameters", "body_hash": "b95fe7343ec744704d05a65dbdd8f065cdab3ad9"}
{"code": "@Override\n        public void handle( String target,\n                            Request baseRequest,\n                            HttpServletRequest request,\n                            HttpServletResponse response ) throws IOException,\n                                                          ServletException\n        {\n            // define small medium and large.\n            // This should be turned for your content, JVM and OS, but we will\n            // huge HTTP response buffer size as a measure\n            final int SMALL = response.getBufferSize();\n            final int MEDIUM = 8 * SMALL;\n\n            // What file to serve?\n            final File file = new File(this.dir, request.getPathInfo());\n\n            // Only handle existing files\n            if (!file.exists())\n                return;\n\n            // we will handle this request\n            baseRequest.setHandled(true);\n\n            // Handle directories\n            if (file.isDirectory())\n            {\n                if (!request.getPathInfo().endsWith(URIUtil.SLASH))\n                {\n                    response.sendRedirect(response.encodeRedirectURL(URIUtil\n                            .addPaths(request.getRequestURI(), URIUtil.SLASH)));\n                    return;\n                }\n                String listing = Resource.newResource(file).getListHTML(\n                        request.getRequestURI(),\n                        request.getPathInfo().lastIndexOf(\"/\") > 0);\n                response.setContentType(\"text/html; charset=utf-8\");\n                response.getWriter().println(listing);\n                return;\n            }\n\n            // Set some content headers.\n            \n            // Jetty DefaultServlet will cache formatted date strings, but we\n            // will reformat for each request here\n            response.setDateHeader(\"Last-Modified\", file.lastModified());\n            response.setDateHeader(\"Content-Length\", file.length());\n            response.setContentType(mimeTypes.getMimeByExtension(file.getName()));\n\n            // send \"small\" files blocking directly from an input stream\n            if (file.length() < SMALL)\n            {\n                // need to caste to Jetty output stream for best API\n                ((HttpOutput) response.getOutputStream())\n                        .sendContent(FileChannel.open(file.toPath(),\n                                StandardOpenOption.READ));\n                return;\n            }\n\n            // send not \"small\" files asynchronously so we don't hold threads if\n            // the client is slow\n            final AsyncContext async = request.startAsync();\n            Callback completionCB = new Callback()\n            {\n                @Override\n                public void succeeded()\n                {\n                    // Async content write succeeded, so complete async response\n                    async.complete();\n                }\n\n                @Override\n                public void failed( Throwable x )\n                {\n                    // log error and complete async response;\n                    x.printStackTrace();\n                    async.complete();\n                }\n            };\n\n            // send \"medium\" files from an input stream\n            if (file.length() < MEDIUM)\n            {\n                // the file channel is closed by the async send\n                ((HttpOutput) response.getOutputStream())\n                        .sendContent(FileChannel.open(file.toPath(),\n                                StandardOpenOption.READ), completionCB);\n                return;\n            }\n\n            // for \"large\" files get the file mapped buffer to send Typically\n            // the resulting buffer should be cached as allocating kernel memory\n            // can be hard to GC on some JVMs. But for this example we will\n            // create a new buffer per file\n            ByteBuffer buffer;\n            try ( RandomAccessFile raf = new RandomAccessFile(file, \"r\"); )\n            {\n                buffer = raf.getChannel().map(MapMode.READ_ONLY, 0,\n                        raf.length());\n            }\n\n            // Assuming the file buffer might be shared cached version, so lets\n            // take our own view of it\n            buffer = buffer.asReadOnlyBuffer();\n\n            // send the content as a buffer with a callback to complete the\n            // async request need to caste to Jetty output stream for best API\n            ((HttpOutput) response.getOutputStream()).sendContent(buffer,\n                    completionCB);\n        }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "String", "target", ",", "Request", "baseRequest", ",", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "IOException", ",", "ServletException", "{", "final", "int", "SMALL", "=", "response", ".", "getBufferSize", "(", ")", ";", "final", "int", "MEDIUM", "=", "8", "*", "SMALL", ";", "final", "File", "file", "=", "new", "File", "(", "this", ".", "dir", ",", "request", ".", "getPathInfo", "(", ")", ")", ";", "if", "(", "!", "file", ".", "exists", "(", ")", ")", "return", ";", "baseRequest", ".", "setHandled", "(", "true", ")", ";", "if", "(", "file", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "request", ".", "getPathInfo", "(", ")", ".", "endsWith", "(", "URIUtil", ".", "SLASH", ")", ")", "{", "response", ".", "sendRedirect", "(", "response", ".", "encodeRedirectURL", "(", "URIUtil", ".", "addPaths", "(", "request", ".", "getRequestURI", "(", ")", ",", "URIUtil", ".", "SLASH", ")", ")", ")", ";", "return", ";", "}", "String", "listing", "=", "Resource", ".", "newResource", "(", "file", ")", ".", "getListHTML", "(", "request", ".", "getRequestURI", "(", ")", ",", "request", ".", "getPathInfo", "(", ")", ".", "lastIndexOf", "(", "\"", "/", "\"", ")", ">", "0", ")", ";", "response", ".", "setContentType", "(", "\"", "text/html; charset=utf-8", "\"", ")", ";", "response", ".", "getWriter", "(", ")", ".", "println", "(", "listing", ")", ";", "return", ";", "}", "response", ".", "setDateHeader", "(", "\"", "Last-Modified", "\"", ",", "file", ".", "lastModified", "(", ")", ")", ";", "response", ".", "setDateHeader", "(", "\"", "Content-Length", "\"", ",", "file", ".", "length", "(", ")", ")", ";", "response", ".", "setContentType", "(", "mimeTypes", ".", "getMimeByExtension", "(", "file", ".", "getName", "(", ")", ")", ")", ";", "if", "(", "file", ".", "length", "(", ")", "<", "SMALL", ")", "{", "(", "(", "HttpOutput", ")", "response", ".", "getOutputStream", "(", ")", ")", ".", "sendContent", "(", "FileChannel", ".", "open", "(", "file", ".", "toPath", "(", ")", ",", "StandardOpenOption", ".", "READ", ")", ")", ";", "return", ";", "}", "final", "AsyncContext", "async", "=", "request", ".", "startAsync", "(", ")", ";", "Callback", "completionCB", "=", "new", "Callback", "(", ")", "{", "@", "Override", "public", "void", "succeeded", "(", ")", "{", "async", ".", "complete", "(", ")", ";", "}", "@", "Override", "public", "void", "failed", "(", "Throwable", "x", ")", "{", "x", ".", "printStackTrace", "(", ")", ";", "async", ".", "complete", "(", ")", ";", "}", "}", ";", "if", "(", "file", ".", "length", "(", ")", "<", "MEDIUM", ")", "{", "(", "(", "HttpOutput", ")", "response", ".", "getOutputStream", "(", ")", ")", ".", "sendContent", "(", "FileChannel", ".", "open", "(", "file", ".", "toPath", "(", ")", ",", "StandardOpenOption", ".", "READ", ")", ",", "completionCB", ")", ";", "return", ";", "}", "ByteBuffer", "buffer", ";", "try", "(", "RandomAccessFile", "raf", "=", "new", "RandomAccessFile", "(", "file", ",", "\"", "r", "\"", ")", ";", ")", "{", "buffer", "=", "raf", ".", "getChannel", "(", ")", ".", "map", "(", "MapMode", ".", "READ_ONLY", ",", "0", ",", "raf", ".", "length", "(", ")", ")", ";", "}", "buffer", "=", "buffer", ".", "asReadOnlyBuffer", "(", ")", ";", "(", "(", "HttpOutput", ")", "response", ".", "getOutputStream", "(", ")", ")", ".", "sendContent", "(", "buffer", ",", "completionCB", ")", ";", "}"], "idx": 79150, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "ca77bd384a2970cabbbdab25cf6251c6fb76cd21", "function_name": "handle", "body_hash": "edb77cd4321ef146e9b7934fbbb2af9141133682"}
{"code": "@After\n    public void cleanUpDomainList() throws Exception {\n        IdentityProvider<UaaIdentityProviderDefinition> uaaProvider = getWebApplicationContext().getBean(JdbcIdentityProviderProvisioning.class).retrieveByOrigin(UAA, IdentityZone.getUaa().getId());\n        uaaProvider.getConfig().setEmailDomain(null);\n        getWebApplicationContext().getBean(JdbcIdentityProviderProvisioning.class).update(uaaProvider);\n    }", "code_tokens": ["@", "After", "public", "void", "cleanUpDomainList", "(", ")", "throws", "Exception", "{", "IdentityProvider", "<", "UaaIdentityProviderDefinition", ">", "uaaProvider", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "JdbcIdentityProviderProvisioning", ".", "class", ")", ".", "retrieveByOrigin", "(", "UAA", ",", "IdentityZone", ".", "getUaa", "(", ")", ".", "getId", "(", ")", ")", ";", "uaaProvider", ".", "getConfig", "(", ")", ".", "setEmailDomain", "(", "null", ")", ";", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "JdbcIdentityProviderProvisioning", ".", "class", ")", ".", "update", "(", "uaaProvider", ")", ";", "}"], "idx": 35961, "cwe": "CWE-269", "target": 1, "status": "VULNERABLE", "commit": "2ca35f1723e039aa7d2318134b05d02e40072a18", "function_name": "cleanUpDomainList", "body_hash": "6b42e30eb47a66754a3e670c4d66ec854f64ad7e"}
{"code": "public static Map<String, Object> userLogin(DispatchContext ctx, Map<String, ?> context) {\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Locale locale = (Locale) context.get(\"locale\");\n        Delegator delegator = ctx.getDelegator();\n\n        // load the external auth modules -- note: this will only run once and cache the objects\n        if (!AuthHelper.authenticatorsLoaded()) {\n            AuthHelper.loadAuthenticators(dispatcher);\n        }\n\n        // Authenticate to LDAP if configured to do so\n        // TODO: this should be moved to using the NEW Authenticator API\n        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.enable\", delegator))) {\n            if (!LdapAuthenticationServices.userLogin(ctx, context)) {\n                String errMsg = UtilProperties.getMessage(resource, \"loginservices.ldap_authentication_failed\", locale);\n                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.fail.login\", delegator))) {\n                    return ServiceUtil.returnError(errMsg);\n                }\n                Debug.logInfo(errMsg, module);\n            }\n        }\n\n        Map<String, Object> result =  new LinkedHashMap<>();\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        // if isServiceAuth is not specified, default to not a service auth\n        boolean isServiceAuth = context.get(\"isServiceAuth\") != null && ((Boolean) context.get(\"isServiceAuth\")).booleanValue();\n\n        String username = (String) context.get(\"login.username\");\n        if (username == null) {\n            username = (String) context.get(\"username\");\n        }\n        String password = (String) context.get(\"login.password\");\n        if (password == null) {\n            password = (String) context.get(\"password\");\n        }\n\n        // get the visitId for the history entity\n        String visitId = (String) context.get(\"visitId\");\n\n        String errMsg = \"\";\n        if (UtilValidate.isEmpty(username)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.username_missing\", locale);\n        } else if (UtilValidate.isEmpty(password)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_missing\", locale);\n        } else {\n\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator))) {\n                username = username.toLowerCase(Locale.getDefault());\n            }\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {\n                password = password.toLowerCase(Locale.getDefault());\n            }\n\n            boolean repeat = true;\n            // starts at zero but it incremented at the beginning so in the first pass passNumber will be 1\n            int passNumber = 0;\n\n            while (repeat) {\n                repeat = false;\n                // pass number is incremented here because there are continues in this loop so it may never get to the end\n                passNumber++;\n\n                GenericValue userLogin = null;\n\n                try {\n                    // only get userLogin from cache for service calls; for web and other manual logins there is less time sensitivity\n                    userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                } catch (GenericEntityException e) {\n                    Debug.logWarning(e, \"\", module);\n                }\n\n\n                // see if any external auth modules want to sync the user info\n                if (userLogin == null) {\n                    try {\n                        AuthHelper.syncUser(username);\n                    } catch (AuthenticatorException e) {\n                        Debug.logWarning(e, module);\n                    }\n\n                    // check the user login object again\n                    try {\n                        userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                    } catch (GenericEntityException e) {\n                        Debug.logWarning(e, \"\", module);\n                    }\n                }\n\n                if (userLogin != null) {\n                    String ldmStr = EntityUtilProperties.getPropertyValue(\"security\", \"login.disable.minutes\", delegator);\n                    long loginDisableMinutes;\n\n                    try {\n                        loginDisableMinutes = Long.parseLong(ldmStr);\n                    } catch (Exception e) {\n                        loginDisableMinutes = 30;\n                        Debug.logWarning(\"Could not parse login.disable.minutes from security.properties, using default of 30\", module);\n                    }\n\n                    Timestamp disabledDateTime = userLogin.getTimestamp(\"disabledDateTime\");\n                    Timestamp reEnableTime = null;\n\n                    if (loginDisableMinutes > 0 && disabledDateTime != null) {\n                        reEnableTime = new Timestamp(disabledDateTime.getTime() + loginDisableMinutes * 60000);\n                    }\n\n                    boolean doStore = true;\n                    // we might change & store this userLogin, so we should clone it here to get a mutable copy\n                    userLogin = GenericValue.create(userLogin);\n\n                    // get the is system flag -- system accounts can only be used for service authentication\n                    boolean isSystem = (isServiceAuth && userLogin.get(\"isSystem\") != null) ?\n                            \"Y\".equalsIgnoreCase(userLogin.getString(\"isSystem\")) : false;\n\n                    // grab the hasLoggedOut flag\n                    Boolean hasLoggedOut = userLogin.getBoolean(\"hasLoggedOut\");\n\n                    if ((UtilValidate.isEmpty(userLogin.getString(\"enabled\")) || \"Y\".equals(userLogin.getString(\"enabled\")) ||\n                            (reEnableTime != null && reEnableTime.before(UtilDateTime.nowTimestamp())) || (isSystem)) && UtilValidate.isEmpty(userLogin.getString(\"disabledBy\"))) {\n\n                        String successfulLogin;\n\n                        if (!isSystem) {\n                            userLogin.set(\"enabled\", \"Y\");\n                            userLogin.set(\"disabledBy\", null);\n                        }\n\n                        // attempt to authenticate with Authenticator class(es)\n                        boolean authFatalError = false;\n                        boolean externalAuth = false;\n                        try {\n                            externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                        } catch (AuthenticatorException e) {\n                            // fatal error -- or single authenticator found -- fail now\n                            Debug.logWarning(e, module);\n                            authFatalError = true;\n\n                        }\n\n                        // check whether to sign in with Tomcat SSO\n                        boolean useTomcatSSO = EntityUtilProperties.propertyValueEquals(\"security\", \"security.login.tomcat.sso\", \"true\");\n                        HttpServletRequest request = (javax.servlet.http.HttpServletRequest) context.get(\"request\");\n                        // when request is not supplied, we will treat that SSO is not required as\n                        // in the usage of userLogin service in ICalWorker.java and XmlRpcEventHandler.java.\n                        useTomcatSSO = useTomcatSSO && (request!=null);\n\n                        // if the password.accept.encrypted.and.plain property in security is set to true allow plain or encrypted passwords\n                        // if this is a system account don't bother checking the passwords\n                        // if externalAuth passed; this is run as well\n                        if ((!authFatalError && externalAuth) || (useTomcatSSO ? TomcatSSOLogin(request, username, password) : checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, password) )) {\n                            Debug.logVerbose(\"[LoginServices.userLogin] : Password Matched\", module);\n\n                            // update the hasLoggedOut flag\n                            if (hasLoggedOut == null || hasLoggedOut) {\n                                userLogin.set(\"hasLoggedOut\", \"N\");\n                            }\n\n                            // reset failed login count if necessry\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n                            if (currentFailedLogins != null && currentFailedLogins.longValue() > 0) {\n                                userLogin.set(\"successiveFailedLogins\", Long.valueOf(0));\n                            } else if (hasLoggedOut != null && !hasLoggedOut) {\n                                // successful login & no loggout flag, no need to change anything, so don't do the store\n                                doStore = false;\n                            }\n\n                            successfulLogin = \"Y\";\n\n                            if (!isServiceAuth) {\n                                // get the UserLoginSession if this is not a service auth\n                                Map<?, ?> userLoginSessionMap = LoginWorker.getUserLoginSession(userLogin);\n\n                                // return the UserLoginSession Map\n                                if (userLoginSessionMap != null) {\n                                    result.put(\"userLoginSession\", userLoginSessionMap);\n                                }\n                            }\n\n                            result.put(\"userLogin\", userLogin);\n                            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        } else {\n                            // password is incorrect, but this may be the result of a stale cache entry,\n                            // so lets clear the cache and try again if this is the first pass\n                            // but only if authFatalError is not true; this would mean the single authenticator failed\n                            if (!authFatalError && isServiceAuth && passNumber <= 1) {\n                                delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                                repeat = true;\n                                continue;\n                            }\n\n                            Debug.logInfo(\"[LoginServices.userLogin] : Password Incorrect\", module);\n                            // password invalid...\n                            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_incorrect\", locale);\n\n                            // increment failed login count\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n\n                            if (currentFailedLogins == null) {\n                                currentFailedLogins = Long.valueOf(1);\n                            } else {\n                                currentFailedLogins = Long.valueOf(currentFailedLogins.longValue() + 1);\n                            }\n                            userLogin.set(\"successiveFailedLogins\", currentFailedLogins);\n\n                            // if failed logins over amount in properties file, disable account\n                            String mflStr = EntityUtilProperties.getPropertyValue(\"security\", \"max.failed.logins\", delegator);\n                            long maxFailedLogins = 3;\n                            try {\n                                maxFailedLogins = Long.parseLong(mflStr);\n                            } catch (Exception e) {\n                                maxFailedLogins = 3;\n                                Debug.logWarning(\"Could not parse max.failed.logins from security.properties, using default of 3\", module);\n                            }\n\n                            if (maxFailedLogins > 0 && currentFailedLogins.longValue() >= maxFailedLogins) {\n                                userLogin.set(\"enabled\", \"N\");\n                                userLogin.set(\"disabledDateTime\", UtilDateTime.nowTimestamp());\n                            }\n\n                            successfulLogin = \"N\";\n                        }\n\n                        // this section is being done in its own transaction rather than in the\n                        //current/existing transaction because we may return error and we don't\n                        //want that to stop this from getting stored\n                        Transaction parentTx = null;\n                        boolean beganTransaction = false;\n\n                        try {\n                            try {\n                                parentTx = TransactionUtil.suspend();\n                            } catch (GenericTransactionException e) {\n                                Debug.logError(e, \"Could not suspend transaction: \" + e.getMessage(), module);\n                            }\n\n                            try {\n                                beganTransaction = TransactionUtil.begin();\n\n                                if (doStore) {\n                                    userLogin.store();\n                                }\n\n                                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history\", delegator))) {\n                                    boolean createHistory = true;\n\n                                    // only save info on service auth if option set to true to do so\n                                    if (isServiceAuth && !\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.on.service.auth\", delegator))) {\n                                        createHistory = false;\n                                    }\n\n                                    if (createHistory) {\n                                        Map<String, Object> ulhCreateMap = UtilMisc.toMap(\"userLoginId\", username, \"visitId\", visitId,\n                                                \"fromDate\", UtilDateTime.nowTimestamp(), \"successfulLogin\", successfulLogin);\n\n                                        ModelEntity modelUserLogin = userLogin.getModelEntity();\n                                        if (modelUserLogin.isField(\"partyId\")) {\n                                            ulhCreateMap.put(\"partyId\", userLogin.get(\"partyId\"));\n                                        }\n\n                                        // ONLY save the password if it was incorrect\n                                        if (\"N\".equals(successfulLogin) && !\"false\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.incorrect.password\", delegator))) {\n                                            ulhCreateMap.put(\"passwordUsed\", password);\n                                        }\n\n                                        delegator.create(\"UserLoginHistory\", ulhCreateMap);\n                                    }\n                                }\n                            } catch (GenericEntityException e) {\n                                String geeErrMsg = \"Error saving UserLoginHistory\";\n                                if (doStore) {\n                                    geeErrMsg += \" and updating login status to reset hasLoggedOut, unsuccessful login count, etc.\";\n                                }\n                                geeErrMsg += \": \" + e.toString();\n                                try {\n                                    TransactionUtil.rollback(beganTransaction, geeErrMsg, e);\n                                } catch (GenericTransactionException e2) {\n                                    Debug.logError(e2, \"Could not rollback nested transaction: \" + e2.getMessage(), module);\n                                }\n\n                                // if doStore is true then this error should not be ignored and we shouldn't consider it a successful login if this happens as there is something very wrong lower down that will bite us again later\n                                if (doStore) {\n                                    return ServiceUtil.returnError(geeErrMsg);\n                                }\n                            } finally {\n                                try {\n                                    TransactionUtil.commit(beganTransaction);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not commit nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        } finally {\n                            // resume/restore parent transaction\n                            if (parentTx != null) {\n                                try {\n                                    TransactionUtil.resume(parentTx);\n                                    Debug.logVerbose(\"Resumed the parent transaction.\", module);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not resume parent nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        }\n                    } else {\n                        // account is disabled, but this may be the result of a stale cache entry,\n                        // so lets clear the cache and try again if this is the first pass\n                        if (isServiceAuth && passNumber <= 1) {\n                            delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                            repeat = true;\n                            continue;\n                        }\n\n                        Map<String, Object> messageMap = UtilMisc.<String, Object>toMap(\"username\", username);\n                        errMsg = UtilProperties.getMessage(resource,\"loginservices.account_for_user_login_id_disabled\",messageMap ,locale);\n                        if (disabledDateTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"disabledDateTime\", disabledDateTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.since_datetime\",messageMap ,locale);\n                        } else {\n                            errMsg += \".\";\n                        }\n\n                        if (loginDisableMinutes > 0 && reEnableTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"reEnableTime\", reEnableTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.will_be_reenabled\",messageMap ,locale);\n                        } else {\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.not_scheduled_to_be_reenabled\",locale);\n                        }\n                    }\n                } else {\n                    // no userLogin object; there may be a non-syncing authenticator\n                    boolean externalAuth = false;\n                    try {\n                        externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                    } catch (AuthenticatorException e) {\n                        errMsg = e.getMessage();\n                        Debug.logError(e, \"External Authenticator had fatal exception : \" + e.getMessage(), module);\n                    }\n                    if (externalAuth) {\n                        // external auth passed - create a placeholder object for session\n                        userLogin = delegator.makeValue(\"UserLogin\");\n                        userLogin.set(\"userLoginId\", username);\n                        userLogin.set(\"enabled\", \"Y\");\n                        userLogin.set(\"hasLoggedOut\", \"N\");\n                        result.put(\"userLogin\", userLogin);\n                        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        //TODO: more than this is needed to support 100% external authentication\n                        //TODO: party + security information is needed; Userlogin will need to be stored\n                    } else {\n                        // userLogin record not found, user does not exist\n                        errMsg = UtilProperties.getMessage(resource, \"loginservices.user_not_found\", locale);\n                        Debug.logInfo(\"[LoginServices.userLogin] Invalid User : '\" + username + \"'; \" + errMsg, module);\n                    }\n                }\n            }\n        }\n\n        if (errMsg.length() > 0) {\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_FAIL);\n            result.put(ModelService.ERROR_MESSAGE, errMsg);\n        }\n        return result;\n    }", "code_tokens": ["public", "static", "Map", "<", "String", ",", "Object", ">", "userLogin", "(", "DispatchContext", "ctx", ",", "Map", "<", "String", ",", "?", ">", "context", ")", "{", "LocalDispatcher", "dispatcher", "=", "ctx", ".", "getDispatcher", "(", ")", ";", "Locale", "locale", "=", "(", "Locale", ")", "context", ".", "get", "(", "\"", "locale", "\"", ")", ";", "Delegator", "delegator", "=", "ctx", ".", "getDelegator", "(", ")", ";", "if", "(", "!", "AuthHelper", ".", "authenticatorsLoaded", "(", ")", ")", "{", "AuthHelper", ".", "loadAuthenticators", "(", "dispatcher", ")", ";", "}", "if", "(", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "security.ldap.enable", "\"", ",", "delegator", ")", ")", ")", "{", "if", "(", "!", "LdapAuthenticationServices", ".", "userLogin", "(", "ctx", ",", "context", ")", ")", "{", "String", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.ldap_authentication_failed", "\"", ",", "locale", ")", ";", "if", "(", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "security.ldap.fail.login", "\"", ",", "delegator", ")", ")", ")", "{", "return", "ServiceUtil", ".", "returnError", "(", "errMsg", ")", ";", "}", "Debug", ".", "logInfo", "(", "errMsg", ",", "module", ")", ";", "}", "}", "Map", "<", "String", ",", "Object", ">", "result", "=", "new", "LinkedHashMap", "<", ">", "(", ")", ";", "boolean", "useEncryption", "=", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "password.encrypt", "\"", ",", "delegator", ")", ")", ";", "boolean", "isServiceAuth", "=", "context", ".", "get", "(", "\"", "isServiceAuth", "\"", ")", "!=", "null", "&&", "(", "(", "Boolean", ")", "context", ".", "get", "(", "\"", "isServiceAuth", "\"", ")", ")", ".", "booleanValue", "(", ")", ";", "String", "username", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "login.username", "\"", ")", ";", "if", "(", "username", "==", "null", ")", "{", "username", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "username", "\"", ")", ";", "}", "String", "password", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "login.password", "\"", ")", ";", "if", "(", "password", "==", "null", ")", "{", "password", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "password", "\"", ")", ";", "}", "String", "visitId", "=", "(", "String", ")", "context", ".", "get", "(", "\"", "visitId", "\"", ")", ";", "String", "errMsg", "=", "\"", "\"", ";", "if", "(", "UtilValidate", ".", "isEmpty", "(", "username", ")", ")", "{", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.username_missing", "\"", ",", "locale", ")", ";", "}", "else", "if", "(", "UtilValidate", ".", "isEmpty", "(", "password", ")", ")", "{", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.password_missing", "\"", ",", "locale", ")", ";", "}", "else", "{", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "username.lowercase", "\"", ",", "delegator", ")", ")", ")", "{", "username", "=", "username", ".", "toLowerCase", "(", "Locale", ".", "getDefault", "(", ")", ")", ";", "}", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "password.lowercase", "\"", ",", "delegator", ")", ")", ")", "{", "password", "=", "password", ".", "toLowerCase", "(", "Locale", ".", "getDefault", "(", ")", ")", ";", "}", "boolean", "repeat", "=", "true", ";", "int", "passNumber", "=", "0", ";", "while", "(", "repeat", ")", "{", "repeat", "=", "false", ";", "passNumber", "++", ";", "GenericValue", "userLogin", "=", "null", ";", "try", "{", "userLogin", "=", "EntityQuery", ".", "use", "(", "delegator", ")", ".", "from", "(", "\"", "UserLogin", "\"", ")", ".", "where", "(", "\"", "userLoginId", "\"", ",", "username", ")", ".", "cache", "(", "isServiceAuth", ")", ".", "queryOne", "(", ")", ";", "}", "catch", "(", "GenericEntityException", "e", ")", "{", "Debug", ".", "logWarning", "(", "e", ",", "\"", "\"", ",", "module", ")", ";", "}", "if", "(", "userLogin", "==", "null", ")", "{", "try", "{", "AuthHelper", ".", "syncUser", "(", "username", ")", ";", "}", "catch", "(", "AuthenticatorException", "e", ")", "{", "Debug", ".", "logWarning", "(", "e", ",", "module", ")", ";", "}", "try", "{", "userLogin", "=", "EntityQuery", ".", "use", "(", "delegator", ")", ".", "from", "(", "\"", "UserLogin", "\"", ")", ".", "where", "(", "\"", "userLoginId", "\"", ",", "username", ")", ".", "cache", "(", "isServiceAuth", ")", ".", "queryOne", "(", ")", ";", "}", "catch", "(", "GenericEntityException", "e", ")", "{", "Debug", ".", "logWarning", "(", "e", ",", "\"", "\"", ",", "module", ")", ";", "}", "}", "if", "(", "userLogin", "!=", "null", ")", "{", "String", "ldmStr", "=", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "login.disable.minutes", "\"", ",", "delegator", ")", ";", "long", "loginDisableMinutes", ";", "try", "{", "loginDisableMinutes", "=", "Long", ".", "parseLong", "(", "ldmStr", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "loginDisableMinutes", "=", "30", ";", "Debug", ".", "logWarning", "(", "\"", "Could not parse login.disable.minutes from security.properties, using default of 30", "\"", ",", "module", ")", ";", "}", "Timestamp", "disabledDateTime", "=", "userLogin", ".", "getTimestamp", "(", "\"", "disabledDateTime", "\"", ")", ";", "Timestamp", "reEnableTime", "=", "null", ";", "if", "(", "loginDisableMinutes", ">", "0", "&&", "disabledDateTime", "!=", "null", ")", "{", "reEnableTime", "=", "new", "Timestamp", "(", "disabledDateTime", ".", "getTime", "(", ")", "+", "loginDisableMinutes", "*", "60000", ")", ";", "}", "boolean", "doStore", "=", "true", ";", "userLogin", "=", "GenericValue", ".", "create", "(", "userLogin", ")", ";", "boolean", "isSystem", "=", "(", "isServiceAuth", "&&", "userLogin", ".", "get", "(", "\"", "isSystem", "\"", ")", "!=", "null", ")", "?", "\"", "Y", "\"", ".", "equalsIgnoreCase", "(", "userLogin", ".", "getString", "(", "\"", "isSystem", "\"", ")", ")", ":", "false", ";", "Boolean", "hasLoggedOut", "=", "userLogin", ".", "getBoolean", "(", "\"", "hasLoggedOut", "\"", ")", ";", "if", "(", "(", "UtilValidate", ".", "isEmpty", "(", "userLogin", ".", "getString", "(", "\"", "enabled", "\"", ")", ")", "||", "\"", "Y", "\"", ".", "equals", "(", "userLogin", ".", "getString", "(", "\"", "enabled", "\"", ")", ")", "||", "(", "reEnableTime", "!=", "null", "&&", "reEnableTime", ".", "before", "(", "UtilDateTime", ".", "nowTimestamp", "(", ")", ")", ")", "||", "(", "isSystem", ")", ")", "&&", "UtilValidate", ".", "isEmpty", "(", "userLogin", ".", "getString", "(", "\"", "disabledBy", "\"", ")", ")", ")", "{", "String", "successfulLogin", ";", "if", "(", "!", "isSystem", ")", "{", "userLogin", ".", "set", "(", "\"", "enabled", "\"", ",", "\"", "Y", "\"", ")", ";", "userLogin", ".", "set", "(", "\"", "disabledBy", "\"", ",", "null", ")", ";", "}", "boolean", "authFatalError", "=", "false", ";", "boolean", "externalAuth", "=", "false", ";", "try", "{", "externalAuth", "=", "AuthHelper", ".", "authenticate", "(", "username", ",", "password", ",", "isServiceAuth", ")", ";", "}", "catch", "(", "AuthenticatorException", "e", ")", "{", "Debug", ".", "logWarning", "(", "e", ",", "module", ")", ";", "authFatalError", "=", "true", ";", "}", "boolean", "useTomcatSSO", "=", "EntityUtilProperties", ".", "propertyValueEquals", "(", "\"", "security", "\"", ",", "\"", "security.login.tomcat.sso", "\"", ",", "\"", "true", "\"", ")", ";", "HttpServletRequest", "request", "=", "(", "javax", ".", "servlet", ".", "http", ".", "HttpServletRequest", ")", "context", ".", "get", "(", "\"", "request", "\"", ")", ";", "useTomcatSSO", "=", "useTomcatSSO", "&&", "(", "request", "!=", "null", ")", ";", "if", "(", "(", "!", "authFatalError", "&&", "externalAuth", ")", "||", "(", "useTomcatSSO", "?", "TomcatSSOLogin", "(", "request", ",", "username", ",", "password", ")", ":", "checkPassword", "(", "userLogin", ".", "getString", "(", "\"", "currentPassword", "\"", ")", ",", "useEncryption", ",", "password", ")", ")", ")", "{", "Debug", ".", "logVerbose", "(", "\"", "[LoginServices.userLogin] : Password Matched", "\"", ",", "module", ")", ";", "if", "(", "hasLoggedOut", "==", "null", "||", "hasLoggedOut", ")", "{", "userLogin", ".", "set", "(", "\"", "hasLoggedOut", "\"", ",", "\"", "N", "\"", ")", ";", "}", "Long", "currentFailedLogins", "=", "userLogin", ".", "getLong", "(", "\"", "successiveFailedLogins", "\"", ")", ";", "if", "(", "currentFailedLogins", "!=", "null", "&&", "currentFailedLogins", ".", "longValue", "(", ")", ">", "0", ")", "{", "userLogin", ".", "set", "(", "\"", "successiveFailedLogins", "\"", ",", "Long", ".", "valueOf", "(", "0", ")", ")", ";", "}", "else", "if", "(", "hasLoggedOut", "!=", "null", "&&", "!", "hasLoggedOut", ")", "{", "doStore", "=", "false", ";", "}", "successfulLogin", "=", "\"", "Y", "\"", ";", "if", "(", "!", "isServiceAuth", ")", "{", "Map", "<", "?", ",", "?", ">", "userLoginSessionMap", "=", "LoginWorker", ".", "getUserLoginSession", "(", "userLogin", ")", ";", "if", "(", "userLoginSessionMap", "!=", "null", ")", "{", "result", ".", "put", "(", "\"", "userLoginSession", "\"", ",", "userLoginSessionMap", ")", ";", "}", "}", "result", ".", "put", "(", "\"", "userLogin", "\"", ",", "userLogin", ")", ";", "result", ".", "put", "(", "ModelService", ".", "RESPONSE_MESSAGE", ",", "ModelService", ".", "RESPOND_SUCCESS", ")", ";", "}", "else", "{", "if", "(", "!", "authFatalError", "&&", "isServiceAuth", "&&", "passNumber", "<=", "1", ")", "{", "delegator", ".", "clearCacheLine", "(", "\"", "UserLogin", "\"", ",", "UtilMisc", ".", "toMap", "(", "\"", "userLoginId", "\"", ",", "username", ")", ")", ";", "repeat", "=", "true", ";", "continue", ";", "}", "Debug", ".", "logInfo", "(", "\"", "[LoginServices.userLogin] : Password Incorrect", "\"", ",", "module", ")", ";", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.password_incorrect", "\"", ",", "locale", ")", ";", "Long", "currentFailedLogins", "=", "userLogin", ".", "getLong", "(", "\"", "successiveFailedLogins", "\"", ")", ";", "if", "(", "currentFailedLogins", "==", "null", ")", "{", "currentFailedLogins", "=", "Long", ".", "valueOf", "(", "1", ")", ";", "}", "else", "{", "currentFailedLogins", "=", "Long", ".", "valueOf", "(", "currentFailedLogins", ".", "longValue", "(", ")", "+", "1", ")", ";", "}", "userLogin", ".", "set", "(", "\"", "successiveFailedLogins", "\"", ",", "currentFailedLogins", ")", ";", "String", "mflStr", "=", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "max.failed.logins", "\"", ",", "delegator", ")", ";", "long", "maxFailedLogins", "=", "3", ";", "try", "{", "maxFailedLogins", "=", "Long", ".", "parseLong", "(", "mflStr", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "maxFailedLogins", "=", "3", ";", "Debug", ".", "logWarning", "(", "\"", "Could not parse max.failed.logins from security.properties, using default of 3", "\"", ",", "module", ")", ";", "}", "if", "(", "maxFailedLogins", ">", "0", "&&", "currentFailedLogins", ".", "longValue", "(", ")", ">=", "maxFailedLogins", ")", "{", "userLogin", ".", "set", "(", "\"", "enabled", "\"", ",", "\"", "N", "\"", ")", ";", "userLogin", ".", "set", "(", "\"", "disabledDateTime", "\"", ",", "UtilDateTime", ".", "nowTimestamp", "(", ")", ")", ";", "}", "successfulLogin", "=", "\"", "N", "\"", ";", "}", "Transaction", "parentTx", "=", "null", ";", "boolean", "beganTransaction", "=", "false", ";", "try", "{", "try", "{", "parentTx", "=", "TransactionUtil", ".", "suspend", "(", ")", ";", "}", "catch", "(", "GenericTransactionException", "e", ")", "{", "Debug", ".", "logError", "(", "e", ",", "\"", "Could not suspend transaction: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "try", "{", "beganTransaction", "=", "TransactionUtil", ".", "begin", "(", ")", ";", "if", "(", "doStore", ")", "{", "userLogin", ".", "store", "(", ")", ";", "}", "if", "(", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "store.login.history", "\"", ",", "delegator", ")", ")", ")", "{", "boolean", "createHistory", "=", "true", ";", "if", "(", "isServiceAuth", "&&", "!", "\"", "true", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "store.login.history.on.service.auth", "\"", ",", "delegator", ")", ")", ")", "{", "createHistory", "=", "false", ";", "}", "if", "(", "createHistory", ")", "{", "Map", "<", "String", ",", "Object", ">", "ulhCreateMap", "=", "UtilMisc", ".", "toMap", "(", "\"", "userLoginId", "\"", ",", "username", ",", "\"", "visitId", "\"", ",", "visitId", ",", "\"", "fromDate", "\"", ",", "UtilDateTime", ".", "nowTimestamp", "(", ")", ",", "\"", "successfulLogin", "\"", ",", "successfulLogin", ")", ";", "ModelEntity", "modelUserLogin", "=", "userLogin", ".", "getModelEntity", "(", ")", ";", "if", "(", "modelUserLogin", ".", "isField", "(", "\"", "partyId", "\"", ")", ")", "{", "ulhCreateMap", ".", "put", "(", "\"", "partyId", "\"", ",", "userLogin", ".", "get", "(", "\"", "partyId", "\"", ")", ")", ";", "}", "if", "(", "\"", "N", "\"", ".", "equals", "(", "successfulLogin", ")", "&&", "!", "\"", "false", "\"", ".", "equals", "(", "EntityUtilProperties", ".", "getPropertyValue", "(", "\"", "security", "\"", ",", "\"", "store.login.history.incorrect.password", "\"", ",", "delegator", ")", ")", ")", "{", "ulhCreateMap", ".", "put", "(", "\"", "passwordUsed", "\"", ",", "password", ")", ";", "}", "delegator", ".", "create", "(", "\"", "UserLoginHistory", "\"", ",", "ulhCreateMap", ")", ";", "}", "}", "}", "catch", "(", "GenericEntityException", "e", ")", "{", "String", "geeErrMsg", "=", "\"", "Error saving UserLoginHistory", "\"", ";", "if", "(", "doStore", ")", "{", "geeErrMsg", "+=", "\"", " and updating login status to reset hasLoggedOut, unsuccessful login count, etc.", "\"", ";", "}", "geeErrMsg", "+=", "\"", ": ", "\"", "+", "e", ".", "toString", "(", ")", ";", "try", "{", "TransactionUtil", ".", "rollback", "(", "beganTransaction", ",", "geeErrMsg", ",", "e", ")", ";", "}", "catch", "(", "GenericTransactionException", "e2", ")", "{", "Debug", ".", "logError", "(", "e2", ",", "\"", "Could not rollback nested transaction: ", "\"", "+", "e2", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "if", "(", "doStore", ")", "{", "return", "ServiceUtil", ".", "returnError", "(", "geeErrMsg", ")", ";", "}", "}", "finally", "{", "try", "{", "TransactionUtil", ".", "commit", "(", "beganTransaction", ")", ";", "}", "catch", "(", "GenericTransactionException", "e", ")", "{", "Debug", ".", "logError", "(", "e", ",", "\"", "Could not commit nested transaction: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "}", "}", "finally", "{", "if", "(", "parentTx", "!=", "null", ")", "{", "try", "{", "TransactionUtil", ".", "resume", "(", "parentTx", ")", ";", "Debug", ".", "logVerbose", "(", "\"", "Resumed the parent transaction.", "\"", ",", "module", ")", ";", "}", "catch", "(", "GenericTransactionException", "e", ")", "{", "Debug", ".", "logError", "(", "e", ",", "\"", "Could not resume parent nested transaction: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "}", "}", "}", "else", "{", "if", "(", "isServiceAuth", "&&", "passNumber", "<=", "1", ")", "{", "delegator", ".", "clearCacheLine", "(", "\"", "UserLogin", "\"", ",", "UtilMisc", ".", "toMap", "(", "\"", "userLoginId", "\"", ",", "username", ")", ")", ";", "repeat", "=", "true", ";", "continue", ";", "}", "Map", "<", "String", ",", "Object", ">", "messageMap", "=", "UtilMisc", ".", "<", "String", ",", "Object", ">", "toMap", "(", "\"", "username", "\"", ",", "username", ")", ";", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.account_for_user_login_id_disabled", "\"", ",", "messageMap", ",", "locale", ")", ";", "if", "(", "disabledDateTime", "!=", "null", ")", "{", "messageMap", "=", "UtilMisc", ".", "<", "String", ",", "Object", ">", "toMap", "(", "\"", "disabledDateTime", "\"", ",", "disabledDateTime", ")", ";", "errMsg", "+=", "\"", " ", "\"", "+", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.since_datetime", "\"", ",", "messageMap", ",", "locale", ")", ";", "}", "else", "{", "errMsg", "+=", "\"", ".", "\"", ";", "}", "if", "(", "loginDisableMinutes", ">", "0", "&&", "reEnableTime", "!=", "null", ")", "{", "messageMap", "=", "UtilMisc", ".", "<", "String", ",", "Object", ">", "toMap", "(", "\"", "reEnableTime", "\"", ",", "reEnableTime", ")", ";", "errMsg", "+=", "\"", " ", "\"", "+", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.will_be_reenabled", "\"", ",", "messageMap", ",", "locale", ")", ";", "}", "else", "{", "errMsg", "+=", "\"", " ", "\"", "+", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.not_scheduled_to_be_reenabled", "\"", ",", "locale", ")", ";", "}", "}", "}", "else", "{", "boolean", "externalAuth", "=", "false", ";", "try", "{", "externalAuth", "=", "AuthHelper", ".", "authenticate", "(", "username", ",", "password", ",", "isServiceAuth", ")", ";", "}", "catch", "(", "AuthenticatorException", "e", ")", "{", "errMsg", "=", "e", ".", "getMessage", "(", ")", ";", "Debug", ".", "logError", "(", "e", ",", "\"", "External Authenticator had fatal exception : ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "module", ")", ";", "}", "if", "(", "externalAuth", ")", "{", "userLogin", "=", "delegator", ".", "makeValue", "(", "\"", "UserLogin", "\"", ")", ";", "userLogin", ".", "set", "(", "\"", "userLoginId", "\"", ",", "username", ")", ";", "userLogin", ".", "set", "(", "\"", "enabled", "\"", ",", "\"", "Y", "\"", ")", ";", "userLogin", ".", "set", "(", "\"", "hasLoggedOut", "\"", ",", "\"", "N", "\"", ")", ";", "result", ".", "put", "(", "\"", "userLogin", "\"", ",", "userLogin", ")", ";", "result", ".", "put", "(", "ModelService", ".", "RESPONSE_MESSAGE", ",", "ModelService", ".", "RESPOND_SUCCESS", ")", ";", "}", "else", "{", "errMsg", "=", "UtilProperties", ".", "getMessage", "(", "resource", ",", "\"", "loginservices.user_not_found", "\"", ",", "locale", ")", ";", "Debug", ".", "logInfo", "(", "\"", "[LoginServices.userLogin] Invalid User : '", "\"", "+", "username", "+", "\"", "'; ", "\"", "+", "errMsg", ",", "module", ")", ";", "}", "}", "}", "}", "if", "(", "errMsg", ".", "length", "(", ")", ">", "0", ")", "{", "result", ".", "put", "(", "ModelService", ".", "RESPONSE_MESSAGE", ",", "ModelService", ".", "RESPOND_FAIL", ")", ";", "result", ".", "put", "(", "ModelService", ".", "ERROR_MESSAGE", ",", "errMsg", ")", ";", "}", "return", "result", ";", "}"], "idx": 20526, "cwe": "CWE-209", "target": 1, "status": "VULNERABLE", "commit": "2f5b8d33e32c4d9a48243cf9e503236acd5aec5c", "function_name": "userLogin", "body_hash": "4774cd5451161faa752afaa4a0eebbc0bc6e4702"}
{"code": "private static void processHeaderConfig(MultivaluedMap<String, String> httpHeaders, Object object, String key, String prefix) {\n\n        try {String property = StringUtils.removeStart(key, prefix);\n            Field field = null;\n            try {\n                field = object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n            } catch (NoSuchFieldException e) {\n                //swallow\n            }\n            String setter = property;\n            setter = \"set\"+setter.substring(0,1).toUpperCase(Locale.US)+setter.substring(1);\n            //default assume string class\n            //if there's a more specific type, e.g. double, int, boolean\n            //try that.\n            Class clazz = String.class;\n            if (field != null) {\n                if (field.getType() == int.class || field.getType() == Integer.class) {\n                    clazz = int.class;\n                } else if (field.getType() == double.class) {\n                    clazz = double.class;\n                } else if (field.getType() == Double.class) {\n                    clazz = Double.class;\n                } else if (field.getType() == float.class) {\n                    clazz = float.class;\n                } else if (field.getType() == Float.class) {\n                    clazz = Float.class;\n                } else if (field.getType() == boolean.class) {\n                    clazz = boolean.class;\n                } else if (field.getType() == Boolean.class) {\n                    clazz = Boolean.class;\n                }\n            }\n\n            Method m = tryToGetMethod(object, setter, clazz);\n            //if you couldn't find more specific setter, back off\n            //to string setter and try that.\n            if (m == null && clazz != String.class) {\n                m = tryToGetMethod(object, setter, String.class);\n            }\n\n            if (m != null) {\n                String val = httpHeaders.getFirst(key);\n                val = val.trim();\n                if (clazz == String.class) {\n                    checkTrustWorthy(setter, val);\n                    m.invoke(object, val);\n                } else if (clazz == int.class || clazz == Integer.class) {\n                    m.invoke(object, Integer.parseInt(val));\n                } else if (clazz == double.class || clazz == Double.class) {\n                    m.invoke(object, Double.parseDouble(val));\n                } else if (clazz == boolean.class || clazz == Boolean.class) {\n                    m.invoke(object, Boolean.parseBoolean(val));\n                } else if (clazz == float.class || clazz == Float.class) {\n                    m.invoke(object, Float.parseFloat(val));\n                } else {\n                    throw new IllegalArgumentException(\"setter must be String, int, float, double or boolean...for now\");\n                }\n            } else {\n                throw new NoSuchMethodException(\"Couldn't find: \"+setter);\n            }\n\n        } catch (Throwable ex) {\n            throw new WebApplicationException(String.format(Locale.ROOT,\n                    \"%s is an invalid %s header\", key, X_TIKA_OCR_HEADER_PREFIX));\n        }\n    }", "code_tokens": ["private", "static", "void", "processHeaderConfig", "(", "MultivaluedMap", "<", "String", ",", "String", ">", "httpHeaders", ",", "Object", "object", ",", "String", "key", ",", "String", "prefix", ")", "{", "try", "{", "String", "property", "=", "StringUtils", ".", "removeStart", "(", "key", ",", "prefix", ")", ";", "Field", "field", "=", "null", ";", "try", "{", "field", "=", "object", ".", "getClass", "(", ")", ".", "getDeclaredField", "(", "StringUtils", ".", "uncapitalize", "(", "property", ")", ")", ";", "}", "catch", "(", "NoSuchFieldException", "e", ")", "{", "}", "String", "setter", "=", "property", ";", "setter", "=", "\"", "set", "\"", "+", "setter", ".", "substring", "(", "0", ",", "1", ")", ".", "toUpperCase", "(", "Locale", ".", "US", ")", "+", "setter", ".", "substring", "(", "1", ")", ";", "Class", "clazz", "=", "String", ".", "class", ";", "if", "(", "field", "!=", "null", ")", "{", "if", "(", "field", ".", "getType", "(", ")", "==", "int", ".", "class", "||", "field", ".", "getType", "(", ")", "==", "Integer", ".", "class", ")", "{", "clazz", "=", "int", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "double", ".", "class", ")", "{", "clazz", "=", "double", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "Double", ".", "class", ")", "{", "clazz", "=", "Double", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "float", ".", "class", ")", "{", "clazz", "=", "float", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "Float", ".", "class", ")", "{", "clazz", "=", "Float", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "boolean", ".", "class", ")", "{", "clazz", "=", "boolean", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "Boolean", ".", "class", ")", "{", "clazz", "=", "Boolean", ".", "class", ";", "}", "}", "Method", "m", "=", "tryToGetMethod", "(", "object", ",", "setter", ",", "clazz", ")", ";", "if", "(", "m", "==", "null", "&&", "clazz", "!=", "String", ".", "class", ")", "{", "m", "=", "tryToGetMethod", "(", "object", ",", "setter", ",", "String", ".", "class", ")", ";", "}", "if", "(", "m", "!=", "null", ")", "{", "String", "val", "=", "httpHeaders", ".", "getFirst", "(", "key", ")", ";", "val", "=", "val", ".", "trim", "(", ")", ";", "if", "(", "clazz", "==", "String", ".", "class", ")", "{", "checkTrustWorthy", "(", "setter", ",", "val", ")", ";", "m", ".", "invoke", "(", "object", ",", "val", ")", ";", "}", "else", "if", "(", "clazz", "==", "int", ".", "class", "||", "clazz", "==", "Integer", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Integer", ".", "parseInt", "(", "val", ")", ")", ";", "}", "else", "if", "(", "clazz", "==", "double", ".", "class", "||", "clazz", "==", "Double", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Double", ".", "parseDouble", "(", "val", ")", ")", ";", "}", "else", "if", "(", "clazz", "==", "boolean", ".", "class", "||", "clazz", "==", "Boolean", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Boolean", ".", "parseBoolean", "(", "val", ")", ")", ";", "}", "else", "if", "(", "clazz", "==", "float", ".", "class", "||", "clazz", "==", "Float", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Float", ".", "parseFloat", "(", "val", ")", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "setter must be String, int, float, double or boolean...for now", "\"", ")", ";", "}", "}", "else", "{", "throw", "new", "NoSuchMethodException", "(", "\"", "Couldn't find: ", "\"", "+", "setter", ")", ";", "}", "}", "catch", "(", "Throwable", "ex", ")", "{", "throw", "new", "WebApplicationException", "(", "String", ".", "format", "(", "Locale", ".", "ROOT", ",", "\"", "%s is an invalid %s header", "\"", ",", "key", ",", "X_TIKA_OCR_HEADER_PREFIX", ")", ")", ";", "}", "}"], "idx": 109125, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "d1bc09386405d28d6b0f0a29ce8c3e7efd72d6c7", "function_name": "processHeaderConfig", "body_hash": "b57572f7f8d6efc8ddc70667396a184ae4b7130c"}
{"code": "protected Class<?> resolveClass(ObjectStreamClass desc)\n            throws IOException,\n            ClassNotFoundException\n        {\n            if (!found)\n            {\n                if (!desc.getName().equals(mainClass.getName()))\n                {\n                    throw new InvalidClassException(\n                        \"unexpected class: \", desc.getName());\n                }\n                else\n                {\n                    found = true;\n                }\n            }\n            return super.resolveClass(desc);\n        }", "code_tokens": ["protected", "Class", "<", "?", ">", "resolveClass", "(", "ObjectStreamClass", "desc", ")", "throws", "IOException", ",", "ClassNotFoundException", "{", "if", "(", "!", "found", ")", "{", "if", "(", "!", "desc", ".", "getName", "(", ")", ".", "equals", "(", "mainClass", ".", "getName", "(", ")", ")", ")", "{", "throw", "new", "InvalidClassException", "(", "\"", "unexpected class: ", "\"", ",", "desc", ".", "getName", "(", ")", ")", ";", "}", "else", "{", "found", "=", "true", ";", "}", "}", "return", "super", ".", "resolveClass", "(", "desc", ")", ";", "}"], "idx": 59121, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "cd98322b171b15b3f88c5ec871175147893c31e6", "function_name": "resolveClass", "body_hash": "55c1c92dbb30a2241fd6556b0fef8c68b98bb95b"}
{"code": "private void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser;\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n        } else {\n            original = Thread.currentThread().getContextClassLoader();\n        }\n        try {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa =\n                        new PrivilegedSetTccl(TagPluginManager.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(\n                        TagPluginManager.class.getClassLoader());\n            }\n\n            parser = new TagPluginParser(ctxt, blockExternal);\n\n        } finally {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n            }\n        }\n\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }", "code_tokens": ["private", "void", "init", "(", "ErrorDispatcher", "err", ")", "throws", "JasperException", "{", "if", "(", "initialized", ")", "return", ";", "String", "blockExternalString", "=", "ctxt", ".", "getInitParameter", "(", "Constants", ".", "XML_BLOCK_EXTERNAL_INIT_PARAM", ")", ";", "boolean", "blockExternal", ";", "if", "(", "blockExternalString", "==", "null", ")", "{", "blockExternal", "=", "true", ";", "}", "else", "{", "blockExternal", "=", "Boolean", ".", "parseBoolean", "(", "blockExternalString", ")", ";", "}", "TagPluginParser", "parser", ";", "ClassLoader", "original", ";", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedGetTccl", "pa", "=", "new", "PrivilegedGetTccl", "(", ")", ";", "original", "=", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "original", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "}", "try", "{", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedSetTccl", "pa", "=", "new", "PrivilegedSetTccl", "(", "TagPluginManager", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "Thread", ".", "currentThread", "(", ")", ".", "setContextClassLoader", "(", "TagPluginManager", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "}", "parser", "=", "new", "TagPluginParser", "(", "ctxt", ",", "blockExternal", ")", ";", "}", "finally", "{", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedSetTccl", "pa", "=", "new", "PrivilegedSetTccl", "(", "original", ")", ";", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "Thread", ".", "currentThread", "(", ")", ".", "setContextClassLoader", "(", "original", ")", ";", "}", "}", "try", "{", "Enumeration", "<", "URL", ">", "urls", "=", "ctxt", ".", "getClassLoader", "(", ")", ".", "getResources", "(", "META_INF_JASPER_TAG_PLUGINS_XML", ")", ";", "if", "(", "urls", "!=", "null", ")", "{", "while", "(", "urls", ".", "hasMoreElements", "(", ")", ")", "{", "URL", "url", "=", "urls", ".", "nextElement", "(", ")", ";", "parser", ".", "parse", "(", "url", ")", ";", "}", "}", "URL", "url", "=", "ctxt", ".", "getResource", "(", "TAG_PLUGINS_XML", ")", ";", "if", "(", "url", "!=", "null", ")", "{", "parser", ".", "parse", "(", "url", ")", ";", "}", "}", "catch", "(", "IOException", "|", "SAXException", "e", ")", "{", "throw", "new", "JasperException", "(", "e", ")", ";", "}", "Map", "<", "String", ",", "String", ">", "plugins", "=", "parser", ".", "getPlugins", "(", ")", ";", "tagPlugins", "=", "new", "HashMap", "<", ">", "(", "plugins", ".", "size", "(", ")", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "entry", ":", "plugins", ".", "entrySet", "(", ")", ")", "{", "try", "{", "String", "tagClass", "=", "entry", ".", "getKey", "(", ")", ";", "String", "pluginName", "=", "entry", ".", "getValue", "(", ")", ";", "Class", "<", "?", ">", "pluginClass", "=", "ctxt", ".", "getClassLoader", "(", ")", ".", "loadClass", "(", "pluginName", ")", ";", "TagPlugin", "plugin", "=", "(", "TagPlugin", ")", "pluginClass", ".", "newInstance", "(", ")", ";", "tagPlugins", ".", "put", "(", "tagClass", ",", "plugin", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "err", ".", "jspError", "(", "e", ")", ";", "}", "}", "initialized", "=", "true", ";", "}"], "idx": 32720, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "ad3b34a290a0255d2a4c356a3611ab41ed9d04f5", "function_name": "init", "body_hash": "8a2cc8506c462acb11e19d1439b71f90601eb23c"}
{"code": "@SuppressWarnings(\"unchecked\") // deserialization is unsafe\n  public static CompoundOrdering<Object> instantiate(SerializationStreamReader reader)\n      throws SerializationException {\n    int n = reader.readInt();\n    List<Comparator<Object>> comparators = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      comparators.add((Comparator<Object>) reader.readObject());\n    }\n    return new CompoundOrdering<>(comparators);\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "public", "static", "CompoundOrdering", "<", "Object", ">", "instantiate", "(", "SerializationStreamReader", "reader", ")", "throws", "SerializationException", "{", "int", "n", "=", "reader", ".", "readInt", "(", ")", ";", "List", "<", "Comparator", "<", "Object", ">", ">", "comparators", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n", ";", "i", "++", ")", "{", "comparators", ".", "add", "(", "(", "Comparator", "<", "Object", ">", ")", "reader", ".", "readObject", "(", ")", ")", ";", "}", "return", "new", "CompoundOrdering", "<", ">", "(", "comparators", ")", ";", "}"], "idx": 76107, "cwe": "CWE-770", "target": 0, "status": "FIXED", "commit": "f89ece5721b2f637fe754937ff1f3c86d80bb196", "function_name": "instantiate", "body_hash": "8969657b2144807bf6a4146ce8f7b63b2e012429"}
{"code": "protected boolean evaluate(InputSource inputSource) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            setupFeatures(factory);\n            factory.setNamespaceAware(true);\n            factory.setIgnoringElementContentWhitespace(true);\n            factory.setIgnoringComments(true);\n            DocumentBuilder dbuilder = factory.newDocumentBuilder();\n            Document doc = dbuilder.parse(inputSource);\n\n            //An XPath expression could return a true or false value instead of a node.\n            //eval() is a better way to determine the boolean value of the exp.\n            //For compliance with legacy behavior where selecting an empty node returns true,\n            //selectNodeIterator is attempted in case of a failure.\n\n            CachedXPathAPI cachedXPathAPI = new CachedXPathAPI();\n            XObject result = cachedXPathAPI.eval(doc, xpath);\n            if (result.bool())\n            \treturn true;\n            else {\n            \tNodeIterator iterator = cachedXPathAPI.selectNodeIterator(doc, xpath);\n            \treturn (iterator.nextNode() != null);\n            }\n\n        } catch (Throwable e) {\n            return false;\n        }\n    }", "code_tokens": ["protected", "boolean", "evaluate", "(", "InputSource", "inputSource", ")", "{", "try", "{", "DocumentBuilderFactory", "factory", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "setupFeatures", "(", "factory", ")", ";", "factory", ".", "setNamespaceAware", "(", "true", ")", ";", "factory", ".", "setIgnoringElementContentWhitespace", "(", "true", ")", ";", "factory", ".", "setIgnoringComments", "(", "true", ")", ";", "DocumentBuilder", "dbuilder", "=", "factory", ".", "newDocumentBuilder", "(", ")", ";", "Document", "doc", "=", "dbuilder", ".", "parse", "(", "inputSource", ")", ";", "CachedXPathAPI", "cachedXPathAPI", "=", "new", "CachedXPathAPI", "(", ")", ";", "XObject", "result", "=", "cachedXPathAPI", ".", "eval", "(", "doc", ",", "xpath", ")", ";", "if", "(", "result", ".", "bool", "(", ")", ")", "return", "true", ";", "else", "{", "NodeIterator", "iterator", "=", "cachedXPathAPI", ".", "selectNodeIterator", "(", "doc", ",", "xpath", ")", ";", "return", "(", "iterator", ".", "nextNode", "(", ")", "!=", "null", ")", ";", "}", "}", "catch", "(", "Throwable", "e", ")", "{", "return", "false", ";", "}", "}"], "idx": 66016, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "e5647554e6801a522c508a8eb457979a9af8c398", "function_name": "evaluate", "body_hash": "b8164c722fed3e1fe01b5a36ce6550917f4ee885"}
{"code": "public UploadFileResponse getCloudUrl(String contextPath, String uri, String finalFilePath, HttpServletRequest request) {\n        UploadFileResponse uploadFileResponse = new UploadFileResponse();\n        // try push to cloud\n        Map<String, String[]> map = new HashMap<>();\n        map.put(\"fileInfo\", new String[]{finalFilePath + \",\" + uri});\n        map.put(\"name\", new String[]{\"uploadService\"});\n        String url;\n        try {\n            List<Map> urls = HttpUtil.getInstance().sendGetRequest(Constants.pluginServer + \"/service\", map\n                    , new HttpJsonArrayHandle<Map>(), PluginHelper.genHeaderMapByRequest(request)).getT();\n            if (urls != null && !urls.isEmpty()) {\n                url = (String) urls.get(0).get(\"url\");\n                if (!url.startsWith(\"https://\") && !url.startsWith(\"http://\")) {\n                    String tUrl = url;\n                    if (!url.startsWith(\"/\")) {\n                        tUrl = \"/\" + url;\n                    }\n                    url = contextPath + tUrl;\n                }\n            } else {\n                url = contextPath + uri;\n            }\n        } catch (Exception e) {\n            url = contextPath + uri;\n            LOGGER.error(e);\n        }\n        uploadFileResponse.setUrl(url);\n        return uploadFileResponse;\n    }", "code_tokens": ["public", "UploadFileResponse", "getCloudUrl", "(", "String", "contextPath", ",", "String", "uri", ",", "String", "finalFilePath", ",", "HttpServletRequest", "request", ")", "{", "UploadFileResponse", "uploadFileResponse", "=", "new", "UploadFileResponse", "(", ")", ";", "Map", "<", "String", ",", "String", "[", "]", ">", "map", "=", "new", "HashMap", "<", ">", "(", ")", ";", "map", ".", "put", "(", "\"", "fileInfo", "\"", ",", "new", "String", "[", "]", "{", "finalFilePath", "+", "\"", ",", "\"", "+", "uri", "}", ")", ";", "map", ".", "put", "(", "\"", "name", "\"", ",", "new", "String", "[", "]", "{", "\"", "uploadService", "\"", "}", ")", ";", "String", "url", ";", "try", "{", "List", "<", "Map", ">", "urls", "=", "HttpUtil", ".", "getInstance", "(", ")", ".", "sendGetRequest", "(", "Constants", ".", "pluginServer", "+", "\"", "/service", "\"", ",", "map", ",", "new", "HttpJsonArrayHandle", "<", "Map", ">", "(", ")", ",", "PluginHelper", ".", "genHeaderMapByRequest", "(", "request", ")", ")", ".", "getT", "(", ")", ";", "if", "(", "urls", "!=", "null", "&&", "!", "urls", ".", "isEmpty", "(", ")", ")", "{", "url", "=", "(", "String", ")", "urls", ".", "get", "(", "0", ")", ".", "get", "(", "\"", "url", "\"", ")", ";", "if", "(", "!", "url", ".", "startsWith", "(", "\"", "https://", "\"", ")", "&&", "!", "url", ".", "startsWith", "(", "\"", "http://", "\"", ")", ")", "{", "String", "tUrl", "=", "url", ";", "if", "(", "!", "url", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "{", "tUrl", "=", "\"", "/", "\"", "+", "url", ";", "}", "url", "=", "contextPath", "+", "tUrl", ";", "}", "}", "else", "{", "url", "=", "contextPath", "+", "uri", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "url", "=", "contextPath", "+", "uri", ";", "LOGGER", ".", "error", "(", "e", ")", ";", "}", "uploadFileResponse", ".", "setUrl", "(", "url", ")", ";", "return", "uploadFileResponse", ";", "}"], "idx": 89511, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "b2b4415e2e59b6f18b0a62b633e71c96d63c43ba", "function_name": "getCloudUrl", "body_hash": "e767b2b6103401ff57e485c08d7d4b35862ad299"}
{"code": "public void testBasics() throws Exception {\n        jenkins.setSecurityRealm(createDummySecurityRealm());\n        User u = User.get(\"foo\");\n        ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n        final String token = t.getApiToken();\n\n        // make sure the UI shows the token\n        HtmlPage config = createWebClient().goTo(u.getUrl() + \"/configure\");\n        HtmlForm form = config.getFormByName(\"config\");\n        assertEquals(token, form.getInputByName(\"_.apiToken\").getValueAttribute());\n\n        // round-trip shouldn't change the API token\n        submit(form);\n        assertSame(t, u.getProperty(ApiTokenProperty.class));\n\n        WebClient wc = createWebClient();\n        wc.setCredentialsProvider(new CredentialsProvider() {\n            public Credentials getCredentials(AuthScheme scheme, String host, int port, boolean proxy) throws CredentialsNotAvailableException {\n                return new UsernamePasswordCredentials(\"foo\", token);\n            }\n        });\n        wc.setWebConnection(new HttpWebConnection(wc) {\n            @Override\n            protected HttpClient getHttpClient() {\n                HttpClient c = super.getHttpClient();\n                c.getParams().setAuthenticationPreemptive(true);\n                c.getState().setCredentials(new AuthScope(\"localhost\", localPort, AuthScope.ANY_REALM), new UsernamePasswordCredentials(\"foo\", token));\n                return c;\n            }\n        });\n\n        // test the authentication\n        assertEquals(u,wc.executeOnServer(new Callable<User>() {\n            public User call() throws Exception {\n                return User.current();\n            }\n        }));\n    }", "code_tokens": ["public", "void", "testBasics", "(", ")", "throws", "Exception", "{", "jenkins", ".", "setSecurityRealm", "(", "createDummySecurityRealm", "(", ")", ")", ";", "User", "u", "=", "User", ".", "get", "(", "\"", "foo", "\"", ")", ";", "ApiTokenProperty", "t", "=", "u", ".", "getProperty", "(", "ApiTokenProperty", ".", "class", ")", ";", "final", "String", "token", "=", "t", ".", "getApiToken", "(", ")", ";", "HtmlPage", "config", "=", "createWebClient", "(", ")", ".", "goTo", "(", "u", ".", "getUrl", "(", ")", "+", "\"", "/configure", "\"", ")", ";", "HtmlForm", "form", "=", "config", ".", "getFormByName", "(", "\"", "config", "\"", ")", ";", "assertEquals", "(", "token", ",", "form", ".", "getInputByName", "(", "\"", "_.apiToken", "\"", ")", ".", "getValueAttribute", "(", ")", ")", ";", "submit", "(", "form", ")", ";", "assertSame", "(", "t", ",", "u", ".", "getProperty", "(", "ApiTokenProperty", ".", "class", ")", ")", ";", "WebClient", "wc", "=", "createWebClient", "(", ")", ";", "wc", ".", "setCredentialsProvider", "(", "new", "CredentialsProvider", "(", ")", "{", "public", "Credentials", "getCredentials", "(", "AuthScheme", "scheme", ",", "String", "host", ",", "int", "port", ",", "boolean", "proxy", ")", "throws", "CredentialsNotAvailableException", "{", "return", "new", "UsernamePasswordCredentials", "(", "\"", "foo", "\"", ",", "token", ")", ";", "}", "}", ")", ";", "wc", ".", "setWebConnection", "(", "new", "HttpWebConnection", "(", "wc", ")", "{", "@", "Override", "protected", "HttpClient", "getHttpClient", "(", ")", "{", "HttpClient", "c", "=", "super", ".", "getHttpClient", "(", ")", ";", "c", ".", "getParams", "(", ")", ".", "setAuthenticationPreemptive", "(", "true", ")", ";", "c", ".", "getState", "(", ")", ".", "setCredentials", "(", "new", "AuthScope", "(", "\"", "localhost", "\"", ",", "localPort", ",", "AuthScope", ".", "ANY_REALM", ")", ",", "new", "UsernamePasswordCredentials", "(", "\"", "foo", "\"", ",", "token", ")", ")", ";", "return", "c", ";", "}", "}", ")", ";", "assertEquals", "(", "u", ",", "wc", ".", "executeOnServer", "(", "new", "Callable", "<", "User", ">", "(", ")", "{", "public", "User", "call", "(", ")", "throws", "Exception", "{", "return", "User", ".", "current", "(", ")", ";", "}", "}", ")", ")", ";", "}"], "idx": 35165, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "b3f16489ad5f15c3e749ed066cf6b4251f6668c6", "function_name": "testBasics", "body_hash": "9329947be1647e312fd600e0d0ef6061182cb8af"}
{"code": "private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        // form field validation\n        // this pattern needs to be generalized and moved to stapler\n        SignupInfo si = new SignupInfo(req);\n\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else {\n            // do not create the user - we just want to check if the user already exists but is not a \"login\" user.\n            User user = User.getById(si.username, false); \n            if (null != user)\n                // Allow sign up. SCM people has no such property.\n                if (user.getProperty(Details.class) != null)\n                    si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n        }\n\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(isMailerPluginPresent() && (si.email==null || !si.email.contains(\"@\")))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if (! User.isIdOrFullnameAllowed(si.username)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalUsername(si.username);\n        }\n\n        if (! User.isIdOrFullnameAllowed(si.fullname)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalFullname(si.fullname);\n        }\n\n        if(si.errorMessage!=null) {\n            // failed. ask the user to try again.\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        // register the user\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        if(isMailerPluginPresent()) {\n            try {\n                // legacy hack. mail support has moved out to a separate plugin\n                Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n                Constructor<?> c = up.getDeclaredConstructor(String.class);\n                user.addProperty((UserProperty)c.newInstance(si.email));\n            } catch (ReflectiveOperationException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        user.save();\n        return user;\n    }", "code_tokens": ["private", "User", "createAccount", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ",", "boolean", "selfRegistration", ",", "String", "formView", ")", "throws", "ServletException", ",", "IOException", "{", "SignupInfo", "si", "=", "new", "SignupInfo", "(", "req", ")", ";", "if", "(", "selfRegistration", "&&", "!", "validateCaptcha", "(", "si", ".", "captcha", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage", "(", ")", ";", "if", "(", "si", ".", "password1", "!=", "null", "&&", "!", "si", ".", "password1", ".", "equals", "(", "si", ".", "password2", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch", "(", ")", ";", "if", "(", "!", "(", "si", ".", "password1", "!=", "null", "&&", "si", ".", "password1", ".", "length", "(", ")", "!=", "0", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired", "(", ")", ";", "if", "(", "si", ".", "username", "==", "null", "||", "si", ".", "username", ".", "length", "(", ")", "==", "0", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired", "(", ")", ";", "else", "{", "User", "user", "=", "User", ".", "getById", "(", "si", ".", "username", ",", "false", ")", ";", "if", "(", "null", "!=", "user", ")", "if", "(", "user", ".", "getProperty", "(", "Details", ".", "class", ")", "!=", "null", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken", "(", ")", ";", "}", "if", "(", "si", ".", "fullname", "==", "null", "||", "si", ".", "fullname", ".", "length", "(", ")", "==", "0", ")", "si", ".", "fullname", "=", "si", ".", "username", ";", "if", "(", "isMailerPluginPresent", "(", ")", "&&", "(", "si", ".", "email", "==", "null", "||", "!", "si", ".", "email", ".", "contains", "(", "\"", "@", "\"", ")", ")", ")", "si", ".", "errorMessage", "=", "Messages", ".", "HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress", "(", ")", ";", "if", "(", "!", "User", ".", "isIdOrFullnameAllowed", "(", "si", ".", "username", ")", ")", "{", "si", ".", "errorMessage", "=", "hudson", ".", "model", ".", "Messages", ".", "User_IllegalUsername", "(", "si", ".", "username", ")", ";", "}", "if", "(", "!", "User", ".", "isIdOrFullnameAllowed", "(", "si", ".", "fullname", ")", ")", "{", "si", ".", "errorMessage", "=", "hudson", ".", "model", ".", "Messages", ".", "User_IllegalFullname", "(", "si", ".", "fullname", ")", ";", "}", "if", "(", "si", ".", "errorMessage", "!=", "null", ")", "{", "req", ".", "setAttribute", "(", "\"", "data", "\"", ",", "si", ")", ";", "req", ".", "getView", "(", "this", ",", "formView", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "return", "null", ";", "}", "User", "user", "=", "createAccount", "(", "si", ".", "username", ",", "si", ".", "password1", ")", ";", "user", ".", "setFullName", "(", "si", ".", "fullname", ")", ";", "if", "(", "isMailerPluginPresent", "(", ")", ")", "{", "try", "{", "Class", "<", "?", ">", "up", "=", "Jenkins", ".", "getInstance", "(", ")", ".", "pluginManager", ".", "uberClassLoader", ".", "loadClass", "(", "\"", "hudson.tasks.Mailer$UserProperty", "\"", ")", ";", "Constructor", "<", "?", ">", "c", "=", "up", ".", "getDeclaredConstructor", "(", "String", ".", "class", ")", ";", "user", ".", "addProperty", "(", "(", "UserProperty", ")", "c", ".", "newInstance", "(", "si", ".", "email", ")", ")", ";", "}", "catch", "(", "ReflectiveOperationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "user", ".", "save", "(", ")", ";", "return", "user", ";", "}"], "idx": 73232, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "de7aaab441151fb1760855fec83681c6a8756a45", "function_name": "createAccount", "body_hash": "58f2514eb1b72abaa1b05be4fc4c3da0ed012dc0"}
{"code": "private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        // http://www.openwall.com/lists/oss-security/2017/04/03/4\n        denyTypes(new Class[] { void.class, Void.class });\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n        // SECURITY-637 against URL deserialization\n        registerConverter(new SafeURLConverter(),10); \n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); // SECURITY-247 defense\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }", "code_tokens": ["private", "void", "init", "(", ")", "{", "addImmutableType", "(", "Result", ".", "class", ")", ";", "denyTypes", "(", "new", "Class", "[", "]", "{", "void", ".", "class", ",", "Void", ".", "class", "}", ")", ";", "registerConverter", "(", "new", "RobustCollectionConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "RobustMapConverter", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableMapConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSortedSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableListConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "CopyOnWriteMap", ".", "Tree", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "DescribableList", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "Label", ".", "ConverterImpl", "(", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "SafeURLConverter", "(", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "AssociatedConverterImpl", "(", "this", ")", ",", "-", "10", ")", ";", "registerConverter", "(", "new", "BlacklistedTypesConverter", "(", ")", ",", "PRIORITY_VERY_HIGH", ")", ";", "registerConverter", "(", "new", "DynamicProxyConverter", "(", "getMapper", "(", ")", ")", "{", "@", "Override", "public", "boolean", "canConvert", "(", "Class", "type", ")", "{", "return", "type", "!=", "null", "&&", "super", ".", "canConvert", "(", "type", ")", ";", "}", "@", "Override", "public", "Object", "unmarshal", "(", "HierarchicalStreamReader", "reader", ",", "UnmarshallingContext", "context", ")", "{", "throw", "new", "ConversionException", "(", "\"", "<dynamic-proxy> not supported", "\"", ")", ";", "}", "}", ",", "PRIORITY_VERY_HIGH", ")", ";", "}"], "idx": 59076, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "727d58f690abf64f543407e1de3545eca76ad30e", "function_name": "init", "body_hash": "9b2bad17c507276da0fe2661a1170857e4135b01"}
{"code": "public static void setGlobalContext(Context newGlobalContext) {\n        globalContext = newGlobalContext;\n    }", "code_tokens": ["public", "static", "void", "setGlobalContext", "(", "Context", "newGlobalContext", ")", "{", "globalContext", "=", "newGlobalContext", ";", "}"], "idx": 31569, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "0531f7aeff1999d362e0a68512a3517f2cf1a6ae", "function_name": "setGlobalContext", "body_hash": "c05c136343de325b377ef8f5d4bd5e596adfb713"}
{"code": "private void introspectInterfaces(Class<?> beanClass, Class<?> currClass) throws IntrospectionException {\n\t\tfor (Class<?> ifc : currClass.getInterfaces()) {\n\t\t\tif (!ClassUtils.isJavaLanguageInterface(ifc)) {\n\t\t\t\tfor (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {\n\t\t\t\t\tPropertyDescriptor existingPd = this.propertyDescriptors.get(pd.getName());\n\t\t\t\t\tif (existingPd == null ||\n\t\t\t\t\t\t\t(existingPd.getReadMethod() == null && pd.getReadMethod() != null)) {\n\t\t\t\t\t\t// GenericTypeAwarePropertyDescriptor leniently resolves a set* write method\n\t\t\t\t\t\t// against a declared read method, so we prefer read method descriptors here.\n\t\t\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n\t\t\t\t\t\tif (pd.getPropertyType() != null && (ClassLoader.class.isAssignableFrom(pd.getPropertyType())\n\t\t\t\t\t\t\t\t|| ProtectionDomain.class.isAssignableFrom(pd.getPropertyType()))) {\n\t\t\t\t\t\t\t// Ignore ClassLoader and ProtectionDomain types - nobody needs to bind to those\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.propertyDescriptors.put(pd.getName(), pd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tintrospectInterfaces(ifc, ifc);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "introspectInterfaces", "(", "Class", "<", "?", ">", "beanClass", ",", "Class", "<", "?", ">", "currClass", ")", "throws", "IntrospectionException", "{", "for", "(", "Class", "<", "?", ">", "ifc", ":", "currClass", ".", "getInterfaces", "(", ")", ")", "{", "if", "(", "!", "ClassUtils", ".", "isJavaLanguageInterface", "(", "ifc", ")", ")", "{", "for", "(", "PropertyDescriptor", "pd", ":", "getBeanInfo", "(", "ifc", ")", ".", "getPropertyDescriptors", "(", ")", ")", "{", "PropertyDescriptor", "existingPd", "=", "this", ".", "propertyDescriptors", ".", "get", "(", "pd", ".", "getName", "(", ")", ")", ";", "if", "(", "existingPd", "==", "null", "||", "(", "existingPd", ".", "getReadMethod", "(", ")", "==", "null", "&&", "pd", ".", "getReadMethod", "(", ")", "!=", "null", ")", ")", "{", "pd", "=", "buildGenericTypeAwarePropertyDescriptor", "(", "beanClass", ",", "pd", ")", ";", "if", "(", "pd", ".", "getPropertyType", "(", ")", "!=", "null", "&&", "(", "ClassLoader", ".", "class", ".", "isAssignableFrom", "(", "pd", ".", "getPropertyType", "(", ")", ")", "||", "ProtectionDomain", ".", "class", ".", "isAssignableFrom", "(", "pd", ".", "getPropertyType", "(", ")", ")", ")", ")", "{", "continue", ";", "}", "this", ".", "propertyDescriptors", ".", "put", "(", "pd", ".", "getName", "(", ")", ",", "pd", ")", ";", "}", "}", "introspectInterfaces", "(", "ifc", ",", "ifc", ")", ";", "}", "}", "}"], "idx": 95364, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "996f701a1916d10202c1d0d281f06ab1f2e1117e", "function_name": "introspectInterfaces", "body_hash": "993736c1407c2fe55fc95f7cd220d336b4e6d2e4"}
{"code": "@Override\n    public void validate() {\n        final String filter = format(ldapConfiguration.getUserSearchFilter(), \"test\");\n        ldapConnectionTemplate.searchFirst(ldapConfiguration.getSearchBases().get(0), filter, SearchScope.SUBTREE, entry -> entry);\n    }", "code_tokens": ["@", "Override", "public", "void", "validate", "(", ")", "{", "final", "String", "filter", "=", "format", "(", "ldapConfiguration", ".", "getUserSearchFilter", "(", ")", ",", "\"", "test", "\"", ")", ";", "ldapConnectionTemplate", ".", "searchFirst", "(", "ldapConfiguration", ".", "getSearchBases", "(", ")", ".", "get", "(", "0", ")", ",", "filter", ",", "SearchScope", ".", "SUBTREE", ",", "entry", "->", "entry", ")", ";", "}"], "idx": 73837, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "87fa7dac5d899b3960ab48e151881da4793cfcc3", "function_name": "validate", "body_hash": "e81ba5455a48fc768784aaf26013430d762129f1"}
{"code": "@Override\n    public void init(ServletConfig config) throws ServletException {\n\n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n\n        // Initialize the JSP Runtime Context\n        // Check for a custom Options implementation\n        String engineOptionsName = config.getInitParameter(\"engineOptionsClass\");\n        if (engineOptionsName != null) {\n            // Instantiate the indicated Options implementation\n            try {\n                ClassLoader loader = Thread.currentThread().getContextClassLoader();\n                Class<?> engineOptionsClass = loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig = { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor = engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                // Need to localize this.\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                // Use the default Options implementation\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            // Use the default Options implementation\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    return;\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"Can not locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "init", "(", "ServletConfig", "config", ")", "throws", "ServletException", "{", "super", ".", "init", "(", "config", ")", ";", "this", ".", "config", "=", "config", ";", "this", ".", "context", "=", "config", ".", "getServletContext", "(", ")", ";", "String", "engineOptionsName", "=", "config", ".", "getInitParameter", "(", "\"", "engineOptionsClass", "\"", ")", ";", "if", "(", "engineOptionsName", "!=", "null", ")", "{", "try", "{", "ClassLoader", "loader", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "Class", "<", "?", ">", "engineOptionsClass", "=", "loader", ".", "loadClass", "(", "engineOptionsName", ")", ";", "Class", "<", "?", ">", "[", "]", "ctorSig", "=", "{", "ServletConfig", ".", "class", ",", "ServletContext", ".", "class", "}", ";", "Constructor", "<", "?", ">", "ctor", "=", "engineOptionsClass", ".", "getConstructor", "(", "ctorSig", ")", ";", "Object", "[", "]", "args", "=", "{", "config", ",", "context", "}", ";", "options", "=", "(", "Options", ")", "ctor", ".", "newInstance", "(", "args", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "e", "=", "ExceptionUtils", ".", "unwrapInvocationTargetException", "(", "e", ")", ";", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "log", ".", "warn", "(", "\"", "Failed to load engineOptionsClass", "\"", ",", "e", ")", ";", "options", "=", "new", "EmbeddedServletOptions", "(", "config", ",", "context", ")", ";", "}", "}", "else", "{", "options", "=", "new", "EmbeddedServletOptions", "(", "config", ",", "context", ")", ";", "}", "rctxt", "=", "new", "JspRuntimeContext", "(", "context", ",", "options", ")", ";", "if", "(", "config", ".", "getInitParameter", "(", "\"", "jspFile", "\"", ")", "!=", "null", ")", "{", "jspFile", "=", "config", ".", "getInitParameter", "(", "\"", "jspFile", "\"", ")", ";", "try", "{", "if", "(", "null", "==", "context", ".", "getResource", "(", "jspFile", ")", ")", "{", "return", ";", "}", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "throw", "new", "ServletException", "(", "\"", "Can not locate jsp file", "\"", ",", "e", ")", ";", "}", "try", "{", "if", "(", "SecurityUtil", ".", "isPackageProtectionEnabled", "(", ")", ")", "{", "AccessController", ".", "doPrivileged", "(", "new", "PrivilegedExceptionAction", "<", "Object", ">", "(", ")", "{", "@", "Override", "public", "Object", "run", "(", ")", "throws", "IOException", ",", "ServletException", "{", "serviceJspFile", "(", "null", ",", "null", ",", "jspFile", ",", "true", ")", ";", "return", "null", ";", "}", "}", ")", ";", "}", "else", "{", "serviceJspFile", "(", "null", ",", "null", ",", "jspFile", ",", "true", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "ServletException", "(", "\"", "Could not precompile jsp: ", "\"", "+", "jspFile", ",", "e", ")", ";", "}", "catch", "(", "PrivilegedActionException", "e", ")", "{", "Throwable", "t", "=", "e", ".", "getCause", "(", ")", ";", "if", "(", "t", "instanceof", "ServletException", ")", "throw", "(", "ServletException", ")", "t", ";", "throw", "new", "ServletException", "(", "\"", "Could not precompile jsp: ", "\"", "+", "jspFile", ",", "e", ")", ";", "}", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.message.scratch.dir.is", "\"", ",", "options", ".", "getScratchDir", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "log", ".", "debug", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.message.dont.modify.servlets", "\"", ")", ")", ";", "}", "}"], "idx": 101780, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "d98fa92b9dfc90fe1ffdaa3cce1be3be84532260", "function_name": "init", "body_hash": "b1c8a985f75759bbd2b84f501afd41b81e519320"}
{"code": "private void processParameters(byte bytes[], int start, int len,\n                                  Charset charset) {\n        \n        if(log.isDebugEnabled()) {\n            try {\n                log.debug(sm.getString(\"parameters.bytes\",\n                        new String(bytes, start, len, DEFAULT_CHARSET.name())));\n            } catch (UnsupportedEncodingException uee) {\n                // Not possible. All JVMs must support ISO-8859-1\n            }\n        }\n\n        int decodeFailCount = 0;\n            \n        int pos = start;\n        int end = start + len;\n\n        while(pos < end) {\n            parameterCount ++;\n\n            if (limit > -1 && parameterCount >= limit) {\n                parseFailed = true;\n                log.warn(sm.getString(\"parameters.maxCountFail\",\n                        Integer.toString(limit)));\n                break;\n            }\n            int nameStart = pos;\n            int nameEnd = -1;\n            int valueStart = -1;\n            int valueEnd = -1;\n\n            boolean parsingName = true;\n            boolean decodeName = false;\n            boolean decodeValue = false;\n            boolean parameterComplete = false;\n\n            do {\n                switch(bytes[pos]) {\n                    case '=':\n                        if (parsingName) {\n                            // Name finished. Value starts from next character\n                            nameEnd = pos;\n                            parsingName = false;\n                            valueStart = ++pos;\n                        } else {\n                            // Equals character in value\n                            pos++;\n                        }\n                        break;\n                    case '&':\n                        if (parsingName) {\n                            // Name finished. No value.\n                            nameEnd = pos;\n                        } else {\n                            // Value finished\n                            valueEnd  = pos;\n                        }\n                        parameterComplete = true;\n                        pos++;\n                        break;\n                    case '%':\n                    case '+':\n                        // Decoding required\n                        if (parsingName) {\n                            decodeName = true;\n                        } else {\n                            decodeValue = true;\n                        }\n                        pos ++;\n                        break;\n                    default:\n                        pos ++;\n                        break;\n                }\n            } while (!parameterComplete && pos < end);\n\n            if (pos == end) {\n                if (nameEnd == -1) {\n                    nameEnd = pos;\n                } else if (valueStart > -1 && valueEnd == -1){\n                    valueEnd = pos;\n                }\n            }\n            \n            if (log.isDebugEnabled() && valueStart == -1) {\n                try {\n                    log.debug(sm.getString(\"parameters.noequal\",\n                            Integer.toString(nameStart),\n                            Integer.toString(nameEnd),\n                            new String(bytes, nameStart, nameEnd-nameStart,\n                                    DEFAULT_CHARSET.name())));\n                } catch (UnsupportedEncodingException uee) {\n                    // Not possible. All JVMs must support ISO-8859-1\n                }\n            }\n            \n            if (nameEnd <= nameStart ) {\n                if (log.isInfoEnabled()) {\n                    if (valueEnd >= nameStart && log.isDebugEnabled()) {\n                        String extract = null;\n                        try {\n                            extract = new String(bytes, nameStart,\n                                    valueEnd - nameStart,\n                                    DEFAULT_CHARSET.name());\n                        } catch (UnsupportedEncodingException uee) {\n                            // Not possible. All JVMs must support ISO-8859-1\n                        }\n                        log.info(sm.getString(\"parameters.invalidChunk\",\n                                Integer.toString(nameStart),\n                                Integer.toString(valueEnd),\n                                extract));\n                    } else {\n                        log.info(sm.getString(\"parameters.invalidChunk\",\n                                Integer.toString(nameStart),\n                                Integer.toString(nameEnd),\n                                null));\n                    }\n                }\n                parseFailed = true;\n                continue;\n                // invalid chunk - it's better to ignore\n            }\n            \n            tmpName.setBytes(bytes, nameStart, nameEnd - nameStart);\n            tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart);\n\n            // Take copies as if anything goes wrong originals will be\n            // corrupted. This means original values can be logged.\n            // For performance - only done for debug\n            if (log.isDebugEnabled()) {\n                try {\n                    origName.append(bytes, nameStart, nameEnd - nameStart);\n                    origValue.append(bytes, valueStart, valueEnd - valueStart);\n                } catch (IOException ioe) {\n                    // Should never happen...\n                    log.error(sm.getString(\"parameters.copyFail\"), ioe);\n                }\n            }\n            \n            try {\n                String name;\n                String value;\n\n                if (decodeName) {\n                    urlDecode(tmpName);\n                }\n                tmpName.setCharset(charset);\n                name = tmpName.toString();\n\n                if (decodeValue) {\n                    urlDecode(tmpValue);\n                }\n                tmpValue.setCharset(charset);\n                value = tmpValue.toString();\n\n                addParam(name, value);\n            } catch (IOException e) {\n                parseFailed = true;\n                decodeFailCount++;\n                if (decodeFailCount == 1 || log.isDebugEnabled()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"parameters.decodeFail.debug\",\n                                origName.toString(), origValue.toString()), e);\n                    } else if (log.isInfoEnabled()) {\n                        log.info(sm.getString(\"parameters.decodeFail.info\",\n                                tmpName.toString(), tmpValue.toString()), e);\n                    }\n                }\n            }\n\n            tmpName.recycle();\n            tmpValue.recycle();\n            // Only recycle copies if we used them\n            if (log.isDebugEnabled()) {\n                origName.recycle();\n                origValue.recycle();\n            }\n        }\n\n        if (decodeFailCount > 1 && !log.isDebugEnabled()) {\n            log.info(sm.getString(\"parameters.multipleDecodingFail\",\n                    Integer.toString(decodeFailCount)));\n        }\n    }", "code_tokens": ["private", "void", "processParameters", "(", "byte", "bytes", "[", "]", ",", "int", "start", ",", "int", "len", ",", "Charset", "charset", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "try", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "parameters.bytes", "\"", ",", "new", "String", "(", "bytes", ",", "start", ",", "len", ",", "DEFAULT_CHARSET", ".", "name", "(", ")", ")", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "uee", ")", "{", "}", "}", "int", "decodeFailCount", "=", "0", ";", "int", "pos", "=", "start", ";", "int", "end", "=", "start", "+", "len", ";", "while", "(", "pos", "<", "end", ")", "{", "parameterCount", "++", ";", "if", "(", "limit", ">", "-", "1", "&&", "parameterCount", ">=", "limit", ")", "{", "parseFailed", "=", "true", ";", "log", ".", "warn", "(", "sm", ".", "getString", "(", "\"", "parameters.maxCountFail", "\"", ",", "Integer", ".", "toString", "(", "limit", ")", ")", ")", ";", "break", ";", "}", "int", "nameStart", "=", "pos", ";", "int", "nameEnd", "=", "-", "1", ";", "int", "valueStart", "=", "-", "1", ";", "int", "valueEnd", "=", "-", "1", ";", "boolean", "parsingName", "=", "true", ";", "boolean", "decodeName", "=", "false", ";", "boolean", "decodeValue", "=", "false", ";", "boolean", "parameterComplete", "=", "false", ";", "do", "{", "switch", "(", "bytes", "[", "pos", "]", ")", "{", "case", "'='", ":", "if", "(", "parsingName", ")", "{", "nameEnd", "=", "pos", ";", "parsingName", "=", "false", ";", "valueStart", "=", "++", "pos", ";", "}", "else", "{", "pos", "++", ";", "}", "break", ";", "case", "'&'", ":", "if", "(", "parsingName", ")", "{", "nameEnd", "=", "pos", ";", "}", "else", "{", "valueEnd", "=", "pos", ";", "}", "parameterComplete", "=", "true", ";", "pos", "++", ";", "break", ";", "case", "'%'", ":", "case", "'+'", ":", "if", "(", "parsingName", ")", "{", "decodeName", "=", "true", ";", "}", "else", "{", "decodeValue", "=", "true", ";", "}", "pos", "++", ";", "break", ";", "default", ":", "pos", "++", ";", "break", ";", "}", "}", "while", "(", "!", "parameterComplete", "&&", "pos", "<", "end", ")", ";", "if", "(", "pos", "==", "end", ")", "{", "if", "(", "nameEnd", "==", "-", "1", ")", "{", "nameEnd", "=", "pos", ";", "}", "else", "if", "(", "valueStart", ">", "-", "1", "&&", "valueEnd", "==", "-", "1", ")", "{", "valueEnd", "=", "pos", ";", "}", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", "&&", "valueStart", "==", "-", "1", ")", "{", "try", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "parameters.noequal", "\"", ",", "Integer", ".", "toString", "(", "nameStart", ")", ",", "Integer", ".", "toString", "(", "nameEnd", ")", ",", "new", "String", "(", "bytes", ",", "nameStart", ",", "nameEnd", "-", "nameStart", ",", "DEFAULT_CHARSET", ".", "name", "(", ")", ")", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "uee", ")", "{", "}", "}", "if", "(", "nameEnd", "<=", "nameStart", ")", "{", "if", "(", "log", ".", "isInfoEnabled", "(", ")", ")", "{", "if", "(", "valueEnd", ">=", "nameStart", "&&", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "String", "extract", "=", "null", ";", "try", "{", "extract", "=", "new", "String", "(", "bytes", ",", "nameStart", ",", "valueEnd", "-", "nameStart", ",", "DEFAULT_CHARSET", ".", "name", "(", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "uee", ")", "{", "}", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "parameters.invalidChunk", "\"", ",", "Integer", ".", "toString", "(", "nameStart", ")", ",", "Integer", ".", "toString", "(", "valueEnd", ")", ",", "extract", ")", ")", ";", "}", "else", "{", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "parameters.invalidChunk", "\"", ",", "Integer", ".", "toString", "(", "nameStart", ")", ",", "Integer", ".", "toString", "(", "nameEnd", ")", ",", "null", ")", ")", ";", "}", "}", "parseFailed", "=", "true", ";", "continue", ";", "}", "tmpName", ".", "setBytes", "(", "bytes", ",", "nameStart", ",", "nameEnd", "-", "nameStart", ")", ";", "tmpValue", ".", "setBytes", "(", "bytes", ",", "valueStart", ",", "valueEnd", "-", "valueStart", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "try", "{", "origName", ".", "append", "(", "bytes", ",", "nameStart", ",", "nameEnd", "-", "nameStart", ")", ";", "origValue", ".", "append", "(", "bytes", ",", "valueStart", ",", "valueEnd", "-", "valueStart", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "parameters.copyFail", "\"", ")", ",", "ioe", ")", ";", "}", "}", "try", "{", "String", "name", ";", "String", "value", ";", "if", "(", "decodeName", ")", "{", "urlDecode", "(", "tmpName", ")", ";", "}", "tmpName", ".", "setCharset", "(", "charset", ")", ";", "name", "=", "tmpName", ".", "toString", "(", ")", ";", "if", "(", "decodeValue", ")", "{", "urlDecode", "(", "tmpValue", ")", ";", "}", "tmpValue", ".", "setCharset", "(", "charset", ")", ";", "value", "=", "tmpValue", ".", "toString", "(", ")", ";", "addParam", "(", "name", ",", "value", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "parseFailed", "=", "true", ";", "decodeFailCount", "++", ";", "if", "(", "decodeFailCount", "==", "1", "||", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "parameters.decodeFail.debug", "\"", ",", "origName", ".", "toString", "(", ")", ",", "origValue", ".", "toString", "(", ")", ")", ",", "e", ")", ";", "}", "else", "if", "(", "log", ".", "isInfoEnabled", "(", ")", ")", "{", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "parameters.decodeFail.info", "\"", ",", "tmpName", ".", "toString", "(", ")", ",", "tmpValue", ".", "toString", "(", ")", ")", ",", "e", ")", ";", "}", "}", "}", "tmpName", ".", "recycle", "(", ")", ";", "tmpValue", ".", "recycle", "(", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "origName", ".", "recycle", "(", ")", ";", "origValue", ".", "recycle", "(", ")", ";", "}", "}", "if", "(", "decodeFailCount", ">", "1", "&&", "!", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "parameters.multipleDecodingFail", "\"", ",", "Integer", ".", "toString", "(", "decodeFailCount", ")", ")", ")", ";", "}", "}"], "idx": 2866, "cwe": "CWE-189", "target": 0, "status": "FIXED", "commit": "7a1cfb6bd2f849806e7c060dda8648409ad8714e", "function_name": "processParameters", "body_hash": "d89cb5e8b9734c6ac3d5e069ff0950a5de67aefd"}
{"code": "private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    // Read in array length and allocate array\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    // Read in all elements in the proper order.\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n    }\n  }", "code_tokens": ["private", "void", "readObject", "(", "java", ".", "io", ".", "ObjectInputStream", "s", ")", "throws", "java", ".", "io", ".", "IOException", ",", "ClassNotFoundException", "{", "s", ".", "defaultReadObject", "(", ")", ";", "int", "length", "=", "s", ".", "readInt", "(", ")", ";", "this", ".", "longs", "=", "new", "AtomicLongArray", "(", "length", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "length", ";", "i", "++", ")", "{", "set", "(", "i", ",", "s", ".", "readDouble", "(", ")", ")", ";", "}", "}"], "idx": 75356, "cwe": "CWE-770", "target": 1, "status": "VULNERABLE", "commit": "f89ece5721b2f637fe754937ff1f3c86d80bb196", "function_name": "readObject", "body_hash": "aaa74f5b0117e3e7c1ffd23153a63622bdc6272d"}
{"code": "@Override\n    public void log(org.apache.coyote.Request req,\n            org.apache.coyote.Response res, long time) {\n\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n        boolean create = false;\n        \n        if (request == null) {\n            create = true;\n            // Create objects\n            request = connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            // Link objects\n            request.setResponse(response);\n            response.setRequest(request);\n\n            // Set as notes\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            // Set query string encoding\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n        }\n        \n        connector.getService().getContainer().logAccess(\n                request, response, time, true);\n        \n        if (create) {\n            request.recycle();\n            response.recycle();\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "log", "(", "org", ".", "apache", ".", "coyote", ".", "Request", "req", ",", "org", ".", "apache", ".", "coyote", ".", "Response", "res", ",", "long", "time", ")", "{", "Request", "request", "=", "(", "Request", ")", "req", ".", "getNote", "(", "ADAPTER_NOTES", ")", ";", "Response", "response", "=", "(", "Response", ")", "res", ".", "getNote", "(", "ADAPTER_NOTES", ")", ";", "boolean", "create", "=", "false", ";", "if", "(", "request", "==", "null", ")", "{", "create", "=", "true", ";", "request", "=", "connector", ".", "createRequest", "(", ")", ";", "request", ".", "setCoyoteRequest", "(", "req", ")", ";", "response", "=", "connector", ".", "createResponse", "(", ")", ";", "response", ".", "setCoyoteResponse", "(", "res", ")", ";", "request", ".", "setResponse", "(", "response", ")", ";", "response", ".", "setRequest", "(", "request", ")", ";", "req", ".", "setNote", "(", "ADAPTER_NOTES", ",", "request", ")", ";", "res", ".", "setNote", "(", "ADAPTER_NOTES", ",", "response", ")", ";", "req", ".", "getParameters", "(", ")", ".", "setQueryStringEncoding", "(", "connector", ".", "getURIEncoding", "(", ")", ")", ";", "}", "connector", ".", "getService", "(", ")", ".", "getContainer", "(", ")", ".", "logAccess", "(", "request", ",", "response", ",", "time", ",", "true", ")", ";", "if", "(", "create", ")", "{", "request", ".", "recycle", "(", ")", ";", "response", ".", "recycle", "(", ")", ";", "}", "}"], "idx": 9056, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "fd8a579e0e2379a84826b11700adf396e4ed2041", "function_name": "log", "body_hash": "6f84404742b7de3b0ba10d17e2cdb959a5949cfb"}
{"code": "public void recycle() {\n        bytesRead=0;\n\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        errorException = null;\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTime = -1;\n    }", "code_tokens": ["public", "void", "recycle", "(", ")", "{", "bytesRead", "=", "0", ";", "contentLength", "=", "-", "1", ";", "contentTypeMB", "=", "null", ";", "charset", "=", "null", ";", "characterEncoding", "=", "null", ";", "expectation", "=", "false", ";", "headers", ".", "recycle", "(", ")", ";", "serverNameMB", ".", "recycle", "(", ")", ";", "serverPort", "=", "-", "1", ";", "localAddrMB", ".", "recycle", "(", ")", ";", "localNameMB", ".", "recycle", "(", ")", ";", "localPort", "=", "-", "1", ";", "peerAddrMB", ".", "recycle", "(", ")", ";", "remoteAddrMB", ".", "recycle", "(", ")", ";", "remoteHostMB", ".", "recycle", "(", ")", ";", "remotePort", "=", "-", "1", ";", "available", "=", "0", ";", "sendfile", "=", "true", ";", "serverCookies", ".", "recycle", "(", ")", ";", "parameters", ".", "recycle", "(", ")", ";", "pathParameters", ".", "clear", "(", ")", ";", "uriMB", ".", "recycle", "(", ")", ";", "decodedUriMB", ".", "recycle", "(", ")", ";", "queryMB", ".", "recycle", "(", ")", ";", "methodMB", ".", "recycle", "(", ")", ";", "protoMB", ".", "recycle", "(", ")", ";", "schemeMB", ".", "recycle", "(", ")", ";", "remoteUser", ".", "recycle", "(", ")", ";", "remoteUserNeedsAuthorization", "=", "false", ";", "authType", ".", "recycle", "(", ")", ";", "attributes", ".", "clear", "(", ")", ";", "errorException", "=", "null", ";", "listener", "=", "null", ";", "synchronized", "(", "nonBlockingStateLock", ")", "{", "fireListener", "=", "false", ";", "registeredForRead", "=", "false", ";", "}", "allDataReadEventSent", ".", "set", "(", "false", ")", ";", "startTime", "=", "-", "1", ";", "}"], "idx": 74435, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "411caf29ac1c16e6ac291b6e5543b2371dbd25e2", "function_name": "recycle", "body_hash": "8d2ec9dc048d3d188a727c864936e4386e90f70d"}
{"code": "public R execute(HttpResponseProcessor<R> responseProcessor) {\n        byte[] bytes = null;\n\n        try {\n            for (Map.Entry<String, String> header : this.headers.entrySet()) {\n                this.builder.setHeader(header.getKey(), header.getValue());\n            }\n\n            preExecute(this.builder);\n\n            HttpResponse response = this.httpClient.execute(this.builder.build());\n            HttpEntity entity = response.getEntity();\n\n            if (entity != null) {\n                bytes = EntityUtils.toByteArray(entity);\n            }\n\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n\n            if (statusCode < 200 || statusCode >= 300) {\n                throw new HttpResponseException(\"Unexpected response from server: \" + statusCode + \" / \" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);\n            }\n\n            if (bytes == null) {\n                return null;\n            }\n\n            return responseProcessor.process(bytes);\n        } catch (HttpResponseException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing http method [\" + builder + \"]. Response : \" + String.valueOf(bytes), e);\n        }\n    }", "code_tokens": ["public", "R", "execute", "(", "HttpResponseProcessor", "<", "R", ">", "responseProcessor", ")", "{", "byte", "[", "]", "bytes", "=", "null", ";", "try", "{", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "header", ":", "this", ".", "headers", ".", "entrySet", "(", ")", ")", "{", "this", ".", "builder", ".", "setHeader", "(", "header", ".", "getKey", "(", ")", ",", "header", ".", "getValue", "(", ")", ")", ";", "}", "preExecute", "(", "this", ".", "builder", ")", ";", "HttpResponse", "response", "=", "this", ".", "httpClient", ".", "execute", "(", "this", ".", "builder", ".", "build", "(", ")", ")", ";", "HttpEntity", "entity", "=", "response", ".", "getEntity", "(", ")", ";", "if", "(", "entity", "!=", "null", ")", "{", "bytes", "=", "EntityUtils", ".", "toByteArray", "(", "entity", ")", ";", "}", "StatusLine", "statusLine", "=", "response", ".", "getStatusLine", "(", ")", ";", "int", "statusCode", "=", "statusLine", ".", "getStatusCode", "(", ")", ";", "if", "(", "statusCode", "<", "200", "||", "statusCode", ">=", "300", ")", "{", "throw", "new", "HttpResponseException", "(", "\"", "Unexpected response from server: ", "\"", "+", "statusCode", "+", "\"", " / ", "\"", "+", "statusLine", ".", "getReasonPhrase", "(", ")", ",", "statusCode", ",", "statusLine", ".", "getReasonPhrase", "(", ")", ",", "bytes", ")", ";", "}", "if", "(", "bytes", "==", "null", ")", "{", "return", "null", ";", "}", "return", "responseProcessor", ".", "process", "(", "bytes", ")", ";", "}", "catch", "(", "HttpResponseException", "e", ")", "{", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Error executing http method [", "\"", "+", "builder", "+", "\"", "]. Response : ", "\"", "+", "String", ".", "valueOf", "(", "bytes", ")", ",", "e", ")", ";", "}", "}"], "idx": 63950, "cwe": "CWE-532", "target": 1, "status": "VULNERABLE", "commit": "62c9e15776", "function_name": "execute", "body_hash": "e3f9d20b3027fd0fa5d3db3df1803a5dc1ba9ef5"}
{"code": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n    if (!nettyRequest.decoderResult().isSuccess()) {\n      LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n      sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n      return;\n    }\n\n    Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n\n    //Find the content length we will use this as an indicator of a body\n    Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n    String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n\n    //If there is a content length or transfer encoding that indicates there is a body\n    boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n\n    RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n\n    Channel channel = ctx.channel();\n\n    if (requestBody != null) {\n      channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n    }\n    InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n    InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n\n    ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n\n    DefaultRequest request = new DefaultRequest(\n      clock.instant(),\n      requestHeaders,\n      nettyRequest.method(),\n      nettyRequest.protocolVersion(),\n      nettyRequest.uri(),\n      remoteAddress,\n      socketAddress,\n      serverRegistry.get(ServerConfig.class),\n      requestBody,\n      connectionIdleTimeout,\n      channel.attr(CLIENT_CERT_KEY).get()\n    );\n\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders();\n    MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n    AtomicBoolean transmitted = new AtomicBoolean(false);\n\n    DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n\n    ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n\n    Action<Action<Object>> subscribeHandler = thing -> {\n      transmitted.set(true);\n      ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n    };\n\n    DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n      applicationConstants,\n      request,\n      channel,\n      responseTransmitter,\n      subscribeHandler\n    );\n\n    Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n    requestConstants.response = response;\n\n    DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n      if (!transmitted.get()) {\n        Handler lastHandler = requestConstants.handler;\n        StringBuilder description = new StringBuilder();\n        description\n          .append(\"No response sent for \")\n          .append(request.getMethod().getName())\n          .append(\" request to \")\n          .append(request.getUri());\n\n        if (lastHandler != null) {\n          description.append(\" (last handler: \");\n\n          if (lastHandler instanceof DescribingHandler) {\n            ((DescribingHandler) lastHandler).describeTo(description);\n          } else {\n            DescribingHandlers.describeTo(lastHandler, description);\n          }\n          description.append(\")\");\n        }\n\n        String message = description.toString();\n        LOGGER.warn(message);\n\n        response.getHeaders().clear();\n\n        ByteBuf body;\n        if (development) {\n          CharBuffer charBuffer = CharBuffer.wrap(message);\n          body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n          response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n        } else {\n          body = Unpooled.EMPTY_BUFFER;\n        }\n\n        response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n        responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n      }\n    });\n  }", "code_tokens": ["private", "void", "newRequest", "(", "ChannelHandlerContext", "ctx", ",", "HttpRequest", "nettyRequest", ")", "throws", "Exception", "{", "if", "(", "!", "nettyRequest", ".", "decoderResult", "(", ")", ".", "isSuccess", "(", ")", ")", "{", "LOGGER", ".", "debug", "(", "\"", "Failed to decode HTTP request.", "\"", ",", "nettyRequest", ".", "decoderResult", "(", ")", ".", "cause", "(", ")", ")", ";", "sendError", "(", "ctx", ",", "HttpResponseStatus", ".", "BAD_REQUEST", ")", ";", "return", ";", "}", "Headers", "requestHeaders", "=", "new", "NettyHeadersBackedHeaders", "(", "nettyRequest", ".", "headers", "(", ")", ")", ";", "Long", "contentLength", "=", "HttpUtil", ".", "getContentLength", "(", "nettyRequest", ",", "-", "1L", ")", ";", "String", "transferEncoding", "=", "requestHeaders", ".", "get", "(", "HttpHeaderNames", ".", "TRANSFER_ENCODING", ")", ";", "boolean", "hasBody", "=", "(", "contentLength", ">", "0", ")", "||", "(", "transferEncoding", "!=", "null", ")", ";", "RequestBody", "requestBody", "=", "hasBody", "?", "new", "RequestBody", "(", "contentLength", ",", "nettyRequest", ",", "ctx", ")", ":", "null", ";", "Channel", "channel", "=", "ctx", ".", "channel", "(", ")", ";", "if", "(", "requestBody", "!=", "null", ")", "{", "channel", ".", "attr", "(", "BODY_ACCUMULATOR_KEY", ")", ".", "set", "(", "requestBody", ")", ";", "}", "InetSocketAddress", "remoteAddress", "=", "(", "InetSocketAddress", ")", "channel", ".", "remoteAddress", "(", ")", ";", "InetSocketAddress", "socketAddress", "=", "(", "InetSocketAddress", ")", "channel", ".", "localAddress", "(", ")", ";", "ConnectionIdleTimeout", "connectionIdleTimeout", "=", "ConnectionIdleTimeout", ".", "of", "(", "channel", ")", ";", "DefaultRequest", "request", "=", "new", "DefaultRequest", "(", "clock", ".", "instant", "(", ")", ",", "requestHeaders", ",", "nettyRequest", ".", "method", "(", ")", ",", "nettyRequest", ".", "protocolVersion", "(", ")", ",", "nettyRequest", ".", "uri", "(", ")", ",", "remoteAddress", ",", "socketAddress", ",", "serverRegistry", ".", "get", "(", "ServerConfig", ".", "class", ")", ",", "requestBody", ",", "connectionIdleTimeout", ",", "channel", ".", "attr", "(", "CLIENT_CERT_KEY", ")", ".", "get", "(", ")", ")", ";", "HttpHeaders", "nettyHeaders", "=", "new", "DefaultHttpHeaders", "(", ")", ";", "MutableHeaders", "responseHeaders", "=", "new", "NettyHeadersBackedMutableHeaders", "(", "nettyHeaders", ")", ";", "AtomicBoolean", "transmitted", "=", "new", "AtomicBoolean", "(", "false", ")", ";", "DefaultResponseTransmitter", "responseTransmitter", "=", "new", "DefaultResponseTransmitter", "(", "transmitted", ",", "channel", ",", "clock", ",", "nettyRequest", ",", "request", ",", "nettyHeaders", ",", "requestBody", ")", ";", "ctx", ".", "channel", "(", ")", ".", "attr", "(", "DefaultResponseTransmitter", ".", "ATTRIBUTE_KEY", ")", ".", "set", "(", "responseTransmitter", ")", ";", "Action", "<", "Action", "<", "Object", ">", ">", "subscribeHandler", "=", "thing", "->", "{", "transmitted", ".", "set", "(", "true", ")", ";", "ctx", ".", "channel", "(", ")", ".", "attr", "(", "CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY", ")", ".", "set", "(", "thing", ")", ";", "}", ";", "DefaultContext", ".", "RequestConstants", "requestConstants", "=", "new", "DefaultContext", ".", "RequestConstants", "(", "applicationConstants", ",", "request", ",", "channel", ",", "responseTransmitter", ",", "subscribeHandler", ")", ";", "Response", "response", "=", "new", "DefaultResponse", "(", "responseHeaders", ",", "ctx", ".", "alloc", "(", ")", ",", "responseTransmitter", ")", ";", "requestConstants", ".", "response", "=", "response", ";", "DefaultContext", ".", "start", "(", "channel", ".", "eventLoop", "(", ")", ",", "requestConstants", ",", "serverRegistry", ",", "handlers", ",", "execution", "->", "{", "if", "(", "!", "transmitted", ".", "get", "(", ")", ")", "{", "Handler", "lastHandler", "=", "requestConstants", ".", "handler", ";", "StringBuilder", "description", "=", "new", "StringBuilder", "(", ")", ";", "description", ".", "append", "(", "\"", "No response sent for ", "\"", ")", ".", "append", "(", "request", ".", "getMethod", "(", ")", ".", "getName", "(", ")", ")", ".", "append", "(", "\"", " request to ", "\"", ")", ".", "append", "(", "request", ".", "getUri", "(", ")", ")", ";", "if", "(", "lastHandler", "!=", "null", ")", "{", "description", ".", "append", "(", "\"", " (last handler: ", "\"", ")", ";", "if", "(", "lastHandler", "instanceof", "DescribingHandler", ")", "{", "(", "(", "DescribingHandler", ")", "lastHandler", ")", ".", "describeTo", "(", "description", ")", ";", "}", "else", "{", "DescribingHandlers", ".", "describeTo", "(", "lastHandler", ",", "description", ")", ";", "}", "description", ".", "append", "(", "\"", ")", "\"", ")", ";", "}", "String", "message", "=", "description", ".", "toString", "(", ")", ";", "LOGGER", ".", "warn", "(", "message", ")", ";", "response", ".", "getHeaders", "(", ")", ".", "clear", "(", ")", ";", "ByteBuf", "body", ";", "if", "(", "development", ")", "{", "CharBuffer", "charBuffer", "=", "CharBuffer", ".", "wrap", "(", "message", ")", ";", "body", "=", "ByteBufUtil", ".", "encodeString", "(", "ctx", ".", "alloc", "(", ")", ",", "charBuffer", ",", "CharsetUtil", ".", "UTF_8", ")", ";", "response", ".", "contentType", "(", "HttpHeaderConstants", ".", "PLAIN_TEXT_UTF8", ")", ";", "}", "else", "{", "body", "=", "Unpooled", ".", "EMPTY_BUFFER", ";", "}", "response", ".", "getHeaders", "(", ")", ".", "set", "(", "HttpHeaderConstants", ".", "CONTENT_LENGTH", ",", "body", ".", "readableBytes", "(", ")", ")", ";", "responseTransmitter", ".", "transmit", "(", "HttpResponseStatus", ".", "INTERNAL_SERVER_ERROR", ",", "body", ")", ";", "}", "}", ")", ";", "}"], "idx": 73762, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "efb910d38a96494256f36675ef0e5061097dd77d", "function_name": "newRequest", "body_hash": "9245e32a19063d731cc6a2bf865a8c71aaee9331"}
{"code": "@Before\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        Connector c = getTomcatInstance().getConnector();\n        c.setProperty(\"secretRequired\", \"false\");\n        c.setProperty(\"allowedRequestAttributesPattern\", \"MYATTRIBUTE.*\");\n    }", "code_tokens": ["@", "Before", "@", "Override", "public", "void", "setUp", "(", ")", "throws", "Exception", "{", "super", ".", "setUp", "(", ")", ";", "Connector", "c", "=", "getTomcatInstance", "(", ")", ".", "getConnector", "(", ")", ";", "c", ".", "setProperty", "(", "\"", "secretRequired", "\"", ",", "\"", "false", "\"", ")", ";", "c", ".", "setProperty", "(", "\"", "allowedRequestAttributesPattern", "\"", ",", "\"", "MYATTRIBUTE.*", "\"", ")", ";", "}"], "idx": 115773, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "64159aa", "function_name": "setUp", "body_hash": "4e1320b68a5109892dfbce5273e7d24ee4f3d1ea"}
{"code": "@SuppressFBWarnings(\n            value = \"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\",\n            justification = \"False positive for try-with-resources in Java 11\")\n    public void doSlaveInfo(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        Jenkins jenkins = Jenkins.get();\n        jenkins.checkPermission(SlaveComputer.CREATE);\n\n        rsp.setContentType(\"text/xml\");\n        try (Writer w = rsp.getCompressedWriter(req)) {\n            w.write(\"<slaveInfo><swarmSecret>\" + getSwarmSecret() + \"</swarmSecret></slaveInfo>\");\n        }\n    }", "code_tokens": ["@", "SuppressFBWarnings", "(", "value", "=", "\"", "RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE", "\"", ",", "justification", "=", "\"", "False positive for try-with-resources in Java 11", "\"", ")", "public", "void", "doSlaveInfo", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", "{", "Jenkins", "jenkins", "=", "Jenkins", ".", "get", "(", ")", ";", "jenkins", ".", "checkPermission", "(", "SlaveComputer", ".", "CREATE", ")", ";", "rsp", ".", "setContentType", "(", "\"", "text/xml", "\"", ")", ";", "try", "(", "Writer", "w", "=", "rsp", ".", "getCompressedWriter", "(", "req", ")", ")", "{", "w", ".", "write", "(", "\"", "<slaveInfo><swarmSecret>", "\"", "+", "getSwarmSecret", "(", ")", "+", "\"", "</swarmSecret></slaveInfo>", "\"", ")", ";", "}", "}"], "idx": 45083, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "4d18f98", "function_name": "doSlaveInfo", "body_hash": "bb1c7e3706f2ee2b4bddff3de6f467fd9c27a64e"}
{"code": "@RequirePOST\n    public HttpResponse doForcePromotion(@QueryParameter(\"name\") String name) throws IOException {\n        JobPropertyImpl pp = getProject().getProperty(JobPropertyImpl.class);\n        if(pp==null)\n            throw new IllegalStateException(\"This project doesn't have any promotion criteria set\");\n\n        PromotionProcess p = pp.getItem(name);\n        if(p==null)\n            throw new IllegalStateException(\"This project doesn't have the promotion criterion called \"+name);\n\n        ManualCondition manualCondition = (ManualCondition) p.getPromotionCondition(ManualCondition.class.getName());\n        PromotionPermissionHelper.checkPermission(getProject(), manualCondition);\n\n        p.promote(owner,new UserCause(),new ManualPromotionBadge());\n\n        return HttpResponses.redirectToDot();\n    }", "code_tokens": ["@", "RequirePOST", "public", "HttpResponse", "doForcePromotion", "(", "@", "QueryParameter", "(", "\"", "name", "\"", ")", "String", "name", ")", "throws", "IOException", "{", "JobPropertyImpl", "pp", "=", "getProject", "(", ")", ".", "getProperty", "(", "JobPropertyImpl", ".", "class", ")", ";", "if", "(", "pp", "==", "null", ")", "throw", "new", "IllegalStateException", "(", "\"", "This project doesn't have any promotion criteria set", "\"", ")", ";", "PromotionProcess", "p", "=", "pp", ".", "getItem", "(", "name", ")", ";", "if", "(", "p", "==", "null", ")", "throw", "new", "IllegalStateException", "(", "\"", "This project doesn't have the promotion criterion called ", "\"", "+", "name", ")", ";", "ManualCondition", "manualCondition", "=", "(", "ManualCondition", ")", "p", ".", "getPromotionCondition", "(", "ManualCondition", ".", "class", ".", "getName", "(", ")", ")", ";", "PromotionPermissionHelper", ".", "checkPermission", "(", "getProject", "(", ")", ",", "manualCondition", ")", ";", "p", ".", "promote", "(", "owner", ",", "new", "UserCause", "(", ")", ",", "new", "ManualPromotionBadge", "(", ")", ")", ";", "return", "HttpResponses", ".", "redirectToDot", "(", ")", ";", "}"], "idx": 46509, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "46086a74891d620042c3d28a19cba3510c5dbf6a", "function_name": "doForcePromotion", "body_hash": "a34dd6a0d2b04b7cc3ef00c62bfd67368934bb5e"}
{"code": "private void addSort(\n            final SearchRequestBuilder builder,\n            final AnyTypeKind kind,\n            final List<OrderByClause> orderBy) {\n\n        AnyUtils attrUtils = anyUtilsFactory.getInstance(kind);\n\n        for (OrderByClause clause : orderBy) {\n            String sortName = null;\n\n            // Manage difference among external key attribute and internal JPA @Id\n            String fieldName = \"key\".equals(clause.getField()) ? \"id\" : clause.getField();\n\n            Field anyField = ReflectionUtils.findField(attrUtils.anyClass(), fieldName);\n            if (anyField == null) {\n                PlainSchema schema = schemaDAO.find(fieldName);\n                if (schema != null) {\n                    sortName = fieldName;\n                }\n            } else {\n                sortName = fieldName;\n            }\n\n            if (sortName == null) {\n                LOG.warn(\"Cannot build any valid clause from {}\", clause);\n            } else {\n                builder.addSort(sortName, SortOrder.valueOf(clause.getDirection().name()));\n            }\n        }\n    }", "code_tokens": ["private", "void", "addSort", "(", "final", "SearchRequestBuilder", "builder", ",", "final", "AnyTypeKind", "kind", ",", "final", "List", "<", "OrderByClause", ">", "orderBy", ")", "{", "AnyUtils", "attrUtils", "=", "anyUtilsFactory", ".", "getInstance", "(", "kind", ")", ";", "for", "(", "OrderByClause", "clause", ":", "orderBy", ")", "{", "String", "sortName", "=", "null", ";", "String", "fieldName", "=", "\"", "key", "\"", ".", "equals", "(", "clause", ".", "getField", "(", ")", ")", "?", "\"", "id", "\"", ":", "clause", ".", "getField", "(", ")", ";", "Field", "anyField", "=", "ReflectionUtils", ".", "findField", "(", "attrUtils", ".", "anyClass", "(", ")", ",", "fieldName", ")", ";", "if", "(", "anyField", "==", "null", ")", "{", "PlainSchema", "schema", "=", "schemaDAO", ".", "find", "(", "fieldName", ")", ";", "if", "(", "schema", "!=", "null", ")", "{", "sortName", "=", "fieldName", ";", "}", "}", "else", "{", "sortName", "=", "fieldName", ";", "}", "if", "(", "sortName", "==", "null", ")", "{", "LOG", ".", "warn", "(", "\"", "Cannot build any valid clause from {}", "\"", ",", "clause", ")", ";", "}", "else", "{", "builder", ".", "addSort", "(", "sortName", ",", "SortOrder", ".", "valueOf", "(", "clause", ".", "getDirection", "(", ")", ".", "name", "(", ")", ")", ")", ";", "}", "}", "}"], "idx": 15742, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "735579b6f987b407049ac1f1da08e675d957c3e", "function_name": "addSort", "body_hash": "aa99034910ebe870337daa83955e2b00f2056aa3"}
{"code": "@Override\n  public ExitCode runWithoutHelp(CommandRunnerParams params)\n      throws IOException, InterruptedException {\n\n    if (saveFilename != null && loadFilename != null) {\n      params.getConsole().printErrorText(\"Can't use both --load and --save\");\n      return ExitCode.COMMANDLINE_ERROR;\n    }\n\n    if (saveFilename != null) {\n      invalidateChanges(params);\n      RemoteDaemonicParserState state = params.getParser().storeParserState(params.getCell());\n      try (FileOutputStream fos = new FileOutputStream(saveFilename);\n          ZipOutputStream zipos = new ZipOutputStream(fos)) {\n        zipos.putNextEntry(new ZipEntry(\"parser_data\"));\n        try (ObjectOutputStream oos = new ObjectOutputStream(zipos)) {\n          oos.writeObject(state);\n        }\n      }\n    } else if (loadFilename != null) {\n      try (FileInputStream fis = new FileInputStream(loadFilename);\n          ZipInputStream zipis = new ZipInputStream(fis)) {\n        ZipEntry entry = zipis.getNextEntry();\n        Preconditions.checkState(entry.getName().equals(\"parser_data\"));\n        try (ObjectInputStream ois = new ParserStateObjectInputStream(zipis)) {\n          RemoteDaemonicParserState state;\n          try {\n            state = (RemoteDaemonicParserState) ois.readObject();\n          } catch (ClassNotFoundException e) {\n            params.getConsole().printErrorText(\"Invalid file format\");\n            return ExitCode.COMMANDLINE_ERROR;\n          }\n          params.getParser().restoreParserState(state, params.getCell());\n        }\n      }\n      invalidateChanges(params);\n\n      ParserConfig configView = params.getBuckConfig().getView(ParserConfig.class);\n      if (configView.isParserCacheMutationWarningEnabled()) {\n        params\n            .getConsole()\n            .printErrorText(\n                params\n                    .getConsole()\n                    .getAnsi()\n                    .asWarningText(\n                        \"WARNING: Buck injected a parser state that may not match the local state.\"));\n      }\n    }\n\n    return ExitCode.SUCCESS;\n  }", "code_tokens": ["@", "Override", "public", "ExitCode", "runWithoutHelp", "(", "CommandRunnerParams", "params", ")", "throws", "IOException", ",", "InterruptedException", "{", "if", "(", "saveFilename", "!=", "null", "&&", "loadFilename", "!=", "null", ")", "{", "params", ".", "getConsole", "(", ")", ".", "printErrorText", "(", "\"", "Can't use both --load and --save", "\"", ")", ";", "return", "ExitCode", ".", "COMMANDLINE_ERROR", ";", "}", "if", "(", "saveFilename", "!=", "null", ")", "{", "invalidateChanges", "(", "params", ")", ";", "RemoteDaemonicParserState", "state", "=", "params", ".", "getParser", "(", ")", ".", "storeParserState", "(", "params", ".", "getCell", "(", ")", ")", ";", "try", "(", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "saveFilename", ")", ";", "ZipOutputStream", "zipos", "=", "new", "ZipOutputStream", "(", "fos", ")", ")", "{", "zipos", ".", "putNextEntry", "(", "new", "ZipEntry", "(", "\"", "parser_data", "\"", ")", ")", ";", "try", "(", "ObjectOutputStream", "oos", "=", "new", "ObjectOutputStream", "(", "zipos", ")", ")", "{", "oos", ".", "writeObject", "(", "state", ")", ";", "}", "}", "}", "else", "if", "(", "loadFilename", "!=", "null", ")", "{", "try", "(", "FileInputStream", "fis", "=", "new", "FileInputStream", "(", "loadFilename", ")", ";", "ZipInputStream", "zipis", "=", "new", "ZipInputStream", "(", "fis", ")", ")", "{", "ZipEntry", "entry", "=", "zipis", ".", "getNextEntry", "(", ")", ";", "Preconditions", ".", "checkState", "(", "entry", ".", "getName", "(", ")", ".", "equals", "(", "\"", "parser_data", "\"", ")", ")", ";", "try", "(", "ObjectInputStream", "ois", "=", "new", "ParserStateObjectInputStream", "(", "zipis", ")", ")", "{", "RemoteDaemonicParserState", "state", ";", "try", "{", "state", "=", "(", "RemoteDaemonicParserState", ")", "ois", ".", "readObject", "(", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "params", ".", "getConsole", "(", ")", ".", "printErrorText", "(", "\"", "Invalid file format", "\"", ")", ";", "return", "ExitCode", ".", "COMMANDLINE_ERROR", ";", "}", "params", ".", "getParser", "(", ")", ".", "restoreParserState", "(", "state", ",", "params", ".", "getCell", "(", ")", ")", ";", "}", "}", "invalidateChanges", "(", "params", ")", ";", "ParserConfig", "configView", "=", "params", ".", "getBuckConfig", "(", ")", ".", "getView", "(", "ParserConfig", ".", "class", ")", ";", "if", "(", "configView", ".", "isParserCacheMutationWarningEnabled", "(", ")", ")", "{", "params", ".", "getConsole", "(", ")", ".", "printErrorText", "(", "params", ".", "getConsole", "(", ")", ".", "getAnsi", "(", ")", ".", "asWarningText", "(", "\"", "WARNING: Buck injected a parser state that may not match the local state.", "\"", ")", ")", ";", "}", "}", "return", "ExitCode", ".", "SUCCESS", ";", "}"], "idx": 62169, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "8c5500981812564877bd122c0f8fab48d3528ddf", "function_name": "runWithoutHelp", "body_hash": "71012ebfe09c26e03db5286d543d7d27b9b94c2d"}
{"code": "protected User getUserByPattern(JNDIConnection connection, String username, String credentials, String[] attrIds,\n            int curUserPattern) throws NamingException {\n\n        User user = null;\n\n        if (username == null || userPatternArray[curUserPattern] == null) {\n            return null;\n        }\n\n        // Form the DistinguishedName from the user pattern.\n        // Escape in case username contains a character with special meaning in\n        // an attribute value.\n        String dn = connection.userPatternFormatArray[curUserPattern].format(\n                new String[] { doAttributeValueEscaping(username) });\n\n        try {\n            user = getUserByPattern(connection.context, username, attrIds, dn);\n        } catch (NameNotFoundException e) {\n            return null;\n        } catch (NamingException e) {\n            // If the getUserByPattern() call fails, try it again with the\n            // credentials of the user that we're searching for\n            try {\n                userCredentialsAdd(connection.context, dn, credentials);\n\n                user = getUserByPattern(connection.context, username, attrIds, dn);\n            } finally {\n                userCredentialsRemove(connection.context);\n            }\n        }\n        return user;\n    }", "code_tokens": ["protected", "User", "getUserByPattern", "(", "JNDIConnection", "connection", ",", "String", "username", ",", "String", "credentials", ",", "String", "[", "]", "attrIds", ",", "int", "curUserPattern", ")", "throws", "NamingException", "{", "User", "user", "=", "null", ";", "if", "(", "username", "==", "null", "||", "userPatternArray", "[", "curUserPattern", "]", "==", "null", ")", "{", "return", "null", ";", "}", "String", "dn", "=", "connection", ".", "userPatternFormatArray", "[", "curUserPattern", "]", ".", "format", "(", "new", "String", "[", "]", "{", "doAttributeValueEscaping", "(", "username", ")", "}", ")", ";", "try", "{", "user", "=", "getUserByPattern", "(", "connection", ".", "context", ",", "username", ",", "attrIds", ",", "dn", ")", ";", "}", "catch", "(", "NameNotFoundException", "e", ")", "{", "return", "null", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "try", "{", "userCredentialsAdd", "(", "connection", ".", "context", ",", "dn", ",", "credentials", ")", ";", "user", "=", "getUserByPattern", "(", "connection", ".", "context", ",", "username", ",", "attrIds", ",", "dn", ")", ";", "}", "finally", "{", "userCredentialsRemove", "(", "connection", ".", "context", ")", ";", "}", "}", "return", "user", ";", "}"], "idx": 1059, "cwe": "CWE-116", "target": 0, "status": "FIXED", "commit": "f4d9bdef53ec009b7717620d890465fa273721a6", "function_name": "getUserByPattern", "body_hash": "5dbbb32c0eb726c0864ec9fb4ce5218b4a3f09e5"}
{"code": "protected User getUserByPattern(JNDIConnection connection, String username, String credentials, String[] attrIds,\n            int curUserPattern) throws NamingException {\n\n        User user = null;\n\n        if (username == null || userPatternArray[curUserPattern] == null) {\n            return null;\n        }\n\n        // Form the dn from the user pattern\n        String dn = connection.userPatternFormatArray[curUserPattern].format(new String[] { username });\n\n        try {\n            user = getUserByPattern(connection.context, username, attrIds, dn);\n        } catch (NameNotFoundException e) {\n            return null;\n        } catch (NamingException e) {\n            // If the getUserByPattern() call fails, try it again with the\n            // credentials of the user that we're searching for\n            try {\n                userCredentialsAdd(connection.context, dn, credentials);\n\n                user = getUserByPattern(connection.context, username, attrIds, dn);\n            } finally {\n                userCredentialsRemove(connection.context);\n            }\n        }\n        return user;\n    }", "code_tokens": ["protected", "User", "getUserByPattern", "(", "JNDIConnection", "connection", ",", "String", "username", ",", "String", "credentials", ",", "String", "[", "]", "attrIds", ",", "int", "curUserPattern", ")", "throws", "NamingException", "{", "User", "user", "=", "null", ";", "if", "(", "username", "==", "null", "||", "userPatternArray", "[", "curUserPattern", "]", "==", "null", ")", "{", "return", "null", ";", "}", "String", "dn", "=", "connection", ".", "userPatternFormatArray", "[", "curUserPattern", "]", ".", "format", "(", "new", "String", "[", "]", "{", "username", "}", ")", ";", "try", "{", "user", "=", "getUserByPattern", "(", "connection", ".", "context", ",", "username", ",", "attrIds", ",", "dn", ")", ";", "}", "catch", "(", "NameNotFoundException", "e", ")", "{", "return", "null", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "try", "{", "userCredentialsAdd", "(", "connection", ".", "context", ",", "dn", ",", "credentials", ")", ";", "user", "=", "getUserByPattern", "(", "connection", ".", "context", ",", "username", ",", "attrIds", ",", "dn", ")", ";", "}", "finally", "{", "userCredentialsRemove", "(", "connection", ".", "context", ")", ";", "}", "}", "return", "user", ";", "}"], "idx": 1058, "cwe": "CWE-116", "target": 1, "status": "VULNERABLE", "commit": "f4d9bdef53ec009b7717620d890465fa273721a6", "function_name": "getUserByPattern", "body_hash": "338de06e45ee59f47272c214251e39f72ade2416"}
{"code": "@Override\n    public void awaitWritable() throws IOException {\n        if(Thread.currentThread() == getIoThread()) {\n            throw UndertowMessages.MESSAGES.awaitCalledFromIoThread();\n        }\n        synchronized (lock) {\n            if (anyAreSet(state, STATE_CLOSED) || broken) {\n                return;\n            }\n            if (readyForFlush) {\n                try {\n                    waiterCount++;\n                    //we need to re-check after incrementing the waiters count\n\n                    if(readyForFlush && !anyAreSet(state, STATE_CLOSED) && !broken) {\n                        lock.wait();\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new InterruptedIOException();\n                } finally {\n                    waiterCount--;\n                }\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "awaitWritable", "(", ")", "throws", "IOException", "{", "if", "(", "Thread", ".", "currentThread", "(", ")", "==", "getIoThread", "(", ")", ")", "{", "throw", "UndertowMessages", ".", "MESSAGES", ".", "awaitCalledFromIoThread", "(", ")", ";", "}", "synchronized", "(", "lock", ")", "{", "if", "(", "anyAreSet", "(", "state", ",", "STATE_CLOSED", ")", "||", "broken", ")", "{", "return", ";", "}", "if", "(", "readyForFlush", ")", "{", "try", "{", "waiterCount", "++", ";", "if", "(", "readyForFlush", "&&", "!", "anyAreSet", "(", "state", ",", "STATE_CLOSED", ")", "&&", "!", "broken", ")", "{", "lock", ".", "wait", "(", ")", ";", "}", "}", "catch", "(", "InterruptedException", "e", ")", "{", "Thread", ".", "currentThread", "(", ")", ".", "interrupt", "(", ")", ";", "throw", "new", "InterruptedIOException", "(", ")", ";", "}", "finally", "{", "waiterCount", "--", ";", "}", "}", "}", "}"], "idx": 52350, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "40efb45a5ee92b8fd6a12757c59ee7e8d0dfa090", "function_name": "awaitWritable", "body_hash": "d4179fbd8348ad35e04d165cc1efb2643d77fefe"}
{"code": "@Override\n\tpublic void configure(ServletContextHandler context) {\n\t\tcontext.setContextPath(\"/\");\n\t\t\n\t\tcontext.getSessionHandler().setMaxInactiveInterval(serverConfig.getSessionTimeout());\n\t\t\n\t\tcontext.setInitParameter(EnvironmentLoader.ENVIRONMENT_CLASS_PARAM, DefaultWebEnvironment.class.getName());\n\t\tcontext.addEventListener(new EnvironmentLoaderListener());\n\t\tcontext.addFilter(new FilterHolder(shiroFilter), \"/*\", EnumSet.allOf(DispatcherType.class));\n\t\t\n        context.addFilter(new FilterHolder(gitFilter), \"/*\", EnumSet.allOf(DispatcherType.class));\n\t\t\n\t\tcontext.addServlet(new ServletHolder(preReceiveServlet), GitPreReceiveCallback.PATH + \"/*\");\n        \n        context.addServlet(new ServletHolder(postReceiveServlet), GitPostReceiveCallback.PATH + \"/*\");\n        \n\t\t/*\n\t\t * Add wicket servlet as the default servlet which will serve all requests failed to \n\t\t * match a path pattern\n\t\t */\n\t\tcontext.addServlet(new ServletHolder(wicketServlet), \"/\");\n\t\t\n\t\tcontext.addServlet(new ServletHolder(new ClasspathAssetServlet(ImageScope.class)), \"/img/*\");\n\t\tcontext.addServlet(new ServletHolder(new ClasspathAssetServlet(IconScope.class)), \"/icon/*\");\n\t\t\n\t\tcontext.getSessionHandler().addEventListener(new HttpSessionListener() {\n\n\t\t\t@Override\n\t\t\tpublic void sessionCreated(HttpSessionEvent se) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void sessionDestroyed(HttpSessionEvent se) {\n\t\t\t\twebSocketManager.onDestroySession(se.getSession().getId());\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t/*\n\t\t * Configure a servlet to serve contents under site folder. Site folder can be used \n\t\t * to hold site specific web assets.   \n\t\t */\n\t\tServletHolder fileServletHolder = new ServletHolder(new FileAssetServlet(Bootstrap.getSiteDir()));\n\t\tcontext.addServlet(fileServletHolder, \"/site/*\");\n\t\tcontext.addServlet(fileServletHolder, \"/robots.txt\");\n\t\t\n\t\tcontext.addServlet(new ServletHolder(jerseyServlet), \"/rest/*\");\t\t\n\t}", "code_tokens": ["@", "Override", "public", "void", "configure", "(", "ServletContextHandler", "context", ")", "{", "context", ".", "setContextPath", "(", "\"", "/", "\"", ")", ";", "context", ".", "getSessionHandler", "(", ")", ".", "setMaxInactiveInterval", "(", "serverConfig", ".", "getSessionTimeout", "(", ")", ")", ";", "context", ".", "setInitParameter", "(", "EnvironmentLoader", ".", "ENVIRONMENT_CLASS_PARAM", ",", "DefaultWebEnvironment", ".", "class", ".", "getName", "(", ")", ")", ";", "context", ".", "addEventListener", "(", "new", "EnvironmentLoaderListener", "(", ")", ")", ";", "context", ".", "addFilter", "(", "new", "FilterHolder", "(", "shiroFilter", ")", ",", "\"", "/*", "\"", ",", "EnumSet", ".", "allOf", "(", "DispatcherType", ".", "class", ")", ")", ";", "context", ".", "addFilter", "(", "new", "FilterHolder", "(", "gitFilter", ")", ",", "\"", "/*", "\"", ",", "EnumSet", ".", "allOf", "(", "DispatcherType", ".", "class", ")", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "preReceiveServlet", ")", ",", "GitPreReceiveCallback", ".", "PATH", "+", "\"", "/*", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "postReceiveServlet", ")", ",", "GitPostReceiveCallback", ".", "PATH", "+", "\"", "/*", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "wicketServlet", ")", ",", "\"", "/", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "new", "ClasspathAssetServlet", "(", "ImageScope", ".", "class", ")", ")", ",", "\"", "/img/*", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "new", "ClasspathAssetServlet", "(", "IconScope", ".", "class", ")", ")", ",", "\"", "/icon/*", "\"", ")", ";", "context", ".", "getSessionHandler", "(", ")", ".", "addEventListener", "(", "new", "HttpSessionListener", "(", ")", "{", "@", "Override", "public", "void", "sessionCreated", "(", "HttpSessionEvent", "se", ")", "{", "}", "@", "Override", "public", "void", "sessionDestroyed", "(", "HttpSessionEvent", "se", ")", "{", "webSocketManager", ".", "onDestroySession", "(", "se", ".", "getSession", "(", ")", ".", "getId", "(", ")", ")", ";", "}", "}", ")", ";", "ServletHolder", "fileServletHolder", "=", "new", "ServletHolder", "(", "new", "FileAssetServlet", "(", "Bootstrap", ".", "getSiteDir", "(", ")", ")", ")", ";", "context", ".", "addServlet", "(", "fileServletHolder", ",", "\"", "/site/*", "\"", ")", ";", "context", ".", "addServlet", "(", "fileServletHolder", ",", "\"", "/robots.txt", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "jerseyServlet", ")", ",", "\"", "/rest/*", "\"", ")", ";", "}"], "idx": 61667, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "f864053176c08f59ef2d97fea192ceca46a4d9be", "function_name": "configure", "body_hash": "c738e8ff2a938484704263e2f1da86a347fc1f92"}
{"code": "public <T> T readObject() throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(in);\n        return (T)ois.readObject();\n    }", "code_tokens": ["public", "<", "T", ">", "T", "readObject", "(", ")", "throws", "IOException", ",", "ClassNotFoundException", "{", "ObjectInputStream", "ois", "=", "new", "ObjectInputStream", "(", "in", ")", ";", "return", "(", "T", ")", "ois", ".", "readObject", "(", ")", ";", "}"], "idx": 74878, "cwe": "CWE-77", "target": 1, "status": "VULNERABLE", "commit": "5bd9b55a2a3249939fd78c501b8959a804c1164b", "function_name": "readObject", "body_hash": "329f2a6995801a784e27bee9b1b3130f1a907842"}
{"code": "@SuppressWarnings(\"unchecked\")\n    public This transformObject(Saml2ObjectTransformer<T> tr) {\n        final StringTransformer original = this.transformer;\n        this.transformer = s -> {\n            final String originalTransformed = original.transform(s);\n\n            if (originalTransformed == null) {\n                return null;\n            }\n\n            final ByteArrayInputStream baos = new ByteArrayInputStream(originalTransformed.getBytes());\n            final T saml2Object = (T) new SAML2Response().getSAML2ObjectFromStream(baos);\n            final T transformed = tr.transform(saml2Object);\n\n            if (transformed == null) {\n                return null;\n            }\n\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            XMLStreamWriter xmlStreamWriter = StaxUtil.getXMLStreamWriter(bos);\n\n            if (transformed instanceof AuthnRequestType) {\n                new SAMLRequestWriter(xmlStreamWriter).write((AuthnRequestType) transformed);\n            } else if (transformed instanceof LogoutRequestType) {\n                new SAMLRequestWriter(xmlStreamWriter).write((LogoutRequestType) transformed);\n            } else if (transformed instanceof ArtifactResolveType) {\n                new SAMLRequestWriter(xmlStreamWriter).write((ArtifactResolveType) transformed);\n            } else if (transformed instanceof AttributeQueryType) {\n                new SAMLRequestWriter(xmlStreamWriter).write((AttributeQueryType) transformed);\n            } else if (transformed instanceof ResponseType) {\n                new SAMLResponseWriter(xmlStreamWriter).write((ResponseType) transformed);\n            } else if (transformed instanceof ArtifactResponseType) {\n                new SAMLResponseWriter(xmlStreamWriter).write((ArtifactResponseType) transformed);\n            } else if (transformed instanceof StatusResponseType) {\n                new SAMLResponseWriter(xmlStreamWriter).write((StatusResponseType) transformed, SAMLProtocolQNames.LOGOUT_RESPONSE.getQName(\"samlp\"));\n            } else {\n                Assert.assertNotNull(\"Unknown type: <null>\", transformed);\n                Assert.fail(\"Unknown type: \" + transformed.getClass().getName());\n            }\n            return new String(bos.toByteArray(), GeneralConstants.SAML_CHARSET);\n        };\n        return (This) this;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "public", "This", "transformObject", "(", "Saml2ObjectTransformer", "<", "T", ">", "tr", ")", "{", "final", "StringTransformer", "original", "=", "this", ".", "transformer", ";", "this", ".", "transformer", "=", "s", "->", "{", "final", "String", "originalTransformed", "=", "original", ".", "transform", "(", "s", ")", ";", "if", "(", "originalTransformed", "==", "null", ")", "{", "return", "null", ";", "}", "final", "ByteArrayInputStream", "baos", "=", "new", "ByteArrayInputStream", "(", "originalTransformed", ".", "getBytes", "(", ")", ")", ";", "final", "T", "saml2Object", "=", "(", "T", ")", "new", "SAML2Response", "(", ")", ".", "getSAML2ObjectFromStream", "(", "baos", ")", ";", "final", "T", "transformed", "=", "tr", ".", "transform", "(", "saml2Object", ")", ";", "if", "(", "transformed", "==", "null", ")", "{", "return", "null", ";", "}", "ByteArrayOutputStream", "bos", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "XMLStreamWriter", "xmlStreamWriter", "=", "StaxUtil", ".", "getXMLStreamWriter", "(", "bos", ")", ";", "if", "(", "transformed", "instanceof", "AuthnRequestType", ")", "{", "new", "SAMLRequestWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "AuthnRequestType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "LogoutRequestType", ")", "{", "new", "SAMLRequestWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "LogoutRequestType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "ArtifactResolveType", ")", "{", "new", "SAMLRequestWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "ArtifactResolveType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "AttributeQueryType", ")", "{", "new", "SAMLRequestWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "AttributeQueryType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "ResponseType", ")", "{", "new", "SAMLResponseWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "ResponseType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "ArtifactResponseType", ")", "{", "new", "SAMLResponseWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "ArtifactResponseType", ")", "transformed", ")", ";", "}", "else", "if", "(", "transformed", "instanceof", "StatusResponseType", ")", "{", "new", "SAMLResponseWriter", "(", "xmlStreamWriter", ")", ".", "write", "(", "(", "StatusResponseType", ")", "transformed", ",", "SAMLProtocolQNames", ".", "LOGOUT_RESPONSE", ".", "getQName", "(", "\"", "samlp", "\"", ")", ")", ";", "}", "else", "{", "Assert", ".", "assertNotNull", "(", "\"", "Unknown type: <null>", "\"", ",", "transformed", ")", ";", "Assert", ".", "fail", "(", "\"", "Unknown type: ", "\"", "+", "transformed", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ";", "}", "return", "new", "String", "(", "bos", ".", "toByteArray", "(", ")", ",", "GeneralConstants", ".", "SAML_CHARSET", ")", ";", "}", ";", "return", "(", "This", ")", "this", ";", "}"], "idx": 39592, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "0fe0b875d63cce3d2855d85d25bb8757bce13eb1", "function_name": "transformObject", "body_hash": "833c90267496899e9b753b564bb355e62fee1780"}
{"code": "protected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,\n                                                   byte[] encryptedPreMasterSecret)\n    {\n        SecureRandom secureRandom = crypto.getSecureRandom();\n\n        /*\n         * RFC 5246 7.4.7.1.\n         */\n        ProtocolVersion clientVersion = cryptoParams.getClientVersion();\n\n        // TODO Provide as configuration option?\n        boolean versionNumberCheckDisabled = false;\n\n        /*\n         * Generate 48 random bytes we can use as a Pre-Master-Secret, if the\n         * PKCS1 padding check should fail.\n         */\n        byte[] fallback = new byte[48];\n        secureRandom.nextBytes(fallback);\n\n        byte[] M = Arrays.clone(fallback);\n        try\n        {\n            Cipher c = crypto.createRSAEncryptionCipher();\n            c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);\n            M = c.doFinal(encryptedPreMasterSecret);\n        }\n        catch (Exception e)\n        {\n            /*\n             * A TLS server MUST NOT generate an alert if processing an\n             * RSA-encrypted premaster secret message fails, or the version number is not as\n             * expected. Instead, it MUST continue the handshake with a randomly generated\n             * premaster secret.\n             */\n        }\n\n        /*\n         * If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST\n         * check the version number [..].\n         */\n        if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))\n        {\n            /*\n             * If the version number is TLS 1.0 or earlier, server\n             * implementations SHOULD check the version number, but MAY have a\n             * configuration option to disable the check.\n             *\n             * So there is nothing to do here.\n             */\n        }\n        else\n        {\n            /*\n             * OK, we need to compare the version number in the decrypted Pre-Master-Secret with the\n             * clientVersion received during the handshake. If they don't match, we replace the\n             * decrypted Pre-Master-Secret with a random one.\n             */\n            int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))\n                | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));\n            correct |= correct >> 1;\n            correct |= correct >> 2;\n            correct |= correct >> 4;\n            int mask = ~((correct & 1) - 1);\n\n            /*\n             * mask will be all bits set to 0xff if the version number differed.\n             */\n            for (int i = 0; i < 48; i++)\n            {\n                M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));\n            }\n        }\n        return crypto.createSecret(M);\n    }", "code_tokens": ["protected", "TlsSecret", "safeDecryptPreMasterSecret", "(", "TlsCryptoParameters", "cryptoParams", ",", "PrivateKey", "rsaServerPrivateKey", ",", "byte", "[", "]", "encryptedPreMasterSecret", ")", "{", "SecureRandom", "secureRandom", "=", "crypto", ".", "getSecureRandom", "(", ")", ";", "ProtocolVersion", "clientVersion", "=", "cryptoParams", ".", "getClientVersion", "(", ")", ";", "boolean", "versionNumberCheckDisabled", "=", "false", ";", "byte", "[", "]", "fallback", "=", "new", "byte", "[", "48", "]", ";", "secureRandom", ".", "nextBytes", "(", "fallback", ")", ";", "byte", "[", "]", "M", "=", "Arrays", ".", "clone", "(", "fallback", ")", ";", "try", "{", "Cipher", "c", "=", "crypto", ".", "createRSAEncryptionCipher", "(", ")", ";", "c", ".", "init", "(", "Cipher", ".", "DECRYPT_MODE", ",", "rsaServerPrivateKey", ")", ";", "M", "=", "c", ".", "doFinal", "(", "encryptedPreMasterSecret", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "}", "if", "(", "versionNumberCheckDisabled", "&&", "clientVersion", ".", "isEqualOrEarlierVersionOf", "(", "ProtocolVersion", ".", "TLSv10", ")", ")", "{", "}", "else", "{", "int", "correct", "=", "(", "clientVersion", ".", "getMajorVersion", "(", ")", "^", "(", "M", "[", "0", "]", "&", "0xff", ")", ")", "|", "(", "clientVersion", ".", "getMinorVersion", "(", ")", "^", "(", "M", "[", "1", "]", "&", "0xff", ")", ")", ";", "correct", "|=", "correct", ">>", "1", ";", "correct", "|=", "correct", ">>", "2", ";", "correct", "|=", "correct", ">>", "4", ";", "int", "mask", "=", "~", "(", "(", "correct", "&", "1", ")", "-", "1", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "48", ";", "i", "++", ")", "{", "M", "[", "i", "]", "=", "(", "byte", ")", "(", "(", "M", "[", "i", "]", "&", "(", "~", "mask", ")", ")", "|", "(", "fallback", "[", "i", "]", "&", "mask", ")", ")", ";", "}", "}", "return", "crypto", ".", "createSecret", "(", "M", ")", ";", "}"], "idx": 20523, "cwe": "CWE-203", "target": 1, "status": "VULNERABLE", "commit": "a00b684465b38d722ca9a3543b8af8568e6bad5c", "function_name": "safeDecryptPreMasterSecret", "body_hash": "ecd8ebb2a14c482e42633925002af739058383a9"}
{"code": "private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            // do a lookup of the user to trigger authentication\n            ctx.lookup( principal.toString() );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }", "code_tokens": ["private", "LdapContext", "getLdapContextUsingStartTls", "(", "LdapContextFactory", "ldapContextFactory", ",", "Object", "principal", ",", "Object", "credentials", ")", "throws", "NamingException", "{", "JndiLdapContextFactory", "jndiLdapContextFactory", "=", "(", "JndiLdapContextFactory", ")", "ldapContextFactory", ";", "Hashtable", "<", "String", ",", "Object", ">", "env", "=", "new", "Hashtable", "<", ">", "(", ")", ";", "env", ".", "put", "(", "Context", ".", "INITIAL_CONTEXT_FACTORY", ",", "jndiLdapContextFactory", ".", "getContextFactoryClassName", "(", ")", ")", ";", "env", ".", "put", "(", "Context", ".", "PROVIDER_URL", ",", "jndiLdapContextFactory", ".", "getUrl", "(", ")", ")", ";", "LdapContext", "ctx", "=", "null", ";", "try", "{", "ctx", "=", "new", "InitialLdapContext", "(", "env", ",", "null", ")", ";", "StartTlsRequest", "startTlsRequest", "=", "new", "StartTlsRequest", "(", ")", ";", "StartTlsResponse", "tls", "=", "(", "StartTlsResponse", ")", "ctx", ".", "extendedOperation", "(", "startTlsRequest", ")", ";", "tls", ".", "negotiate", "(", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "jndiLdapContextFactory", ".", "getAuthenticationMechanism", "(", ")", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "principal", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "credentials", ")", ";", "ctx", ".", "lookup", "(", "principal", ".", "toString", "(", ")", ")", ";", "return", "ctx", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LdapUtils", ".", "closeContext", "(", "ctx", ")", ";", "securityLog", ".", "error", "(", "withRealm", "(", "\"", "Failed to negotiate TLS connection with '%s': ", "\"", ",", "server", "(", "jndiLdapContextFactory", ")", ",", "e", ")", ")", ";", "throw", "new", "CommunicationException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "LdapUtils", ".", "closeContext", "(", "ctx", ")", ";", "securityLog", ".", "error", "(", "withRealm", "(", "\"", "Unexpected failure to negotiate TLS connection with '%s': ", "\"", ",", "server", "(", "jndiLdapContextFactory", ")", ",", "t", ")", ")", ";", "throw", "t", ";", "}", "}"], "idx": 38731, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "46de5d01ae2741ffe04c36270fc62c6d490f65c9", "function_name": "getLdapContextUsingStartTls", "body_hash": "c5ee778f297724c59ea6567fe484a6ffc498a664"}
{"code": "public ResponseEntity<Void> postForRedirect(String path, HttpHeaders headers, MultiValueMap<String, String> params) {\n        ResponseEntity<Void> exchange = postForResponse(path, headers, params);\n\n        if (exchange.getStatusCode() != HttpStatus.FOUND) {\n            throw new IllegalStateException(\"Expected 302 but server returned status code \" + exchange.getStatusCode());\n        }\n\n        headers.remove(\"Cookie\");\n        if (exchange.getHeaders().containsKey(\"Set-Cookie\")) {\n            for (String cookie : exchange.getHeaders().get(\"Set-Cookie\")) {\n                headers.add(\"Cookie\", cookie);\n            }\n        }\n\n        String location = exchange.getHeaders().getLocation().toString();\n\n        return client.exchange(location, HttpMethod.GET, new HttpEntity<Void>(null, headers), Void.class);\n    }", "code_tokens": ["public", "ResponseEntity", "<", "Void", ">", "postForRedirect", "(", "String", "path", ",", "HttpHeaders", "headers", ",", "MultiValueMap", "<", "String", ",", "String", ">", "params", ")", "{", "ResponseEntity", "<", "Void", ">", "exchange", "=", "postForResponse", "(", "path", ",", "headers", ",", "params", ")", ";", "if", "(", "exchange", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "FOUND", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "Expected 302 but server returned status code ", "\"", "+", "exchange", ".", "getStatusCode", "(", ")", ")", ";", "}", "headers", ".", "remove", "(", "\"", "Cookie", "\"", ")", ";", "if", "(", "exchange", ".", "getHeaders", "(", ")", ".", "containsKey", "(", "\"", "Set-Cookie", "\"", ")", ")", "{", "for", "(", "String", "cookie", ":", "exchange", ".", "getHeaders", "(", ")", ".", "get", "(", "\"", "Set-Cookie", "\"", ")", ")", "{", "headers", ".", "add", "(", "\"", "Cookie", "\"", ",", "cookie", ")", ";", "}", "}", "String", "location", "=", "exchange", ".", "getHeaders", "(", ")", ".", "getLocation", "(", ")", ".", "toString", "(", ")", ";", "return", "client", ".", "exchange", "(", "location", ",", "HttpMethod", ".", "GET", ",", "new", "HttpEntity", "<", "Void", ">", "(", "null", ",", "headers", ")", ",", "Void", ".", "class", ")", ";", "}"], "idx": 44176, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "a54f3fb8225ef7d5021ca7d4fb52bef1e884568e", "function_name": "postForRedirect", "body_hash": "8acc1704ce65e0e057296a63b95a692d93eb12f6"}
{"code": "public static void unJar(File jarFile, File toDir, Pattern unpackRegex)\n      throws IOException {\n    try (JarFile jar = new JarFile(jarFile)) {\n      int numOfFailedLastModifiedSet = 0;\n      Enumeration<JarEntry> entries = jar.entries();\n      while (entries.hasMoreElements()) {\n        final JarEntry entry = entries.nextElement();\n        if (!entry.isDirectory() &&\n            unpackRegex.matcher(entry.getName()).matches()) {\n          try (InputStream in = jar.getInputStream(entry)) {\n            File file = new File(toDir, entry.getName());\n            ensureDirectory(file.getParentFile());\n            try (OutputStream out = new FileOutputStream(file)) {\n              IOUtils.copyBytes(in, out, BUFFER_SIZE);\n            }\n            if (!file.setLastModified(entry.getTime())) {\n              numOfFailedLastModifiedSet++;\n            }\n          }\n        }\n      }\n      if (numOfFailedLastModifiedSet > 0) {\n        LOG.warn(\"Could not set last modfied time for {} file(s)\",\n            numOfFailedLastModifiedSet);\n      }\n    }\n  }", "code_tokens": ["public", "static", "void", "unJar", "(", "File", "jarFile", ",", "File", "toDir", ",", "Pattern", "unpackRegex", ")", "throws", "IOException", "{", "try", "(", "JarFile", "jar", "=", "new", "JarFile", "(", "jarFile", ")", ")", "{", "int", "numOfFailedLastModifiedSet", "=", "0", ";", "Enumeration", "<", "JarEntry", ">", "entries", "=", "jar", ".", "entries", "(", ")", ";", "while", "(", "entries", ".", "hasMoreElements", "(", ")", ")", "{", "final", "JarEntry", "entry", "=", "entries", ".", "nextElement", "(", ")", ";", "if", "(", "!", "entry", ".", "isDirectory", "(", ")", "&&", "unpackRegex", ".", "matcher", "(", "entry", ".", "getName", "(", ")", ")", ".", "matches", "(", ")", ")", "{", "try", "(", "InputStream", "in", "=", "jar", ".", "getInputStream", "(", "entry", ")", ")", "{", "File", "file", "=", "new", "File", "(", "toDir", ",", "entry", ".", "getName", "(", ")", ")", ";", "ensureDirectory", "(", "file", ".", "getParentFile", "(", ")", ")", ";", "try", "(", "OutputStream", "out", "=", "new", "FileOutputStream", "(", "file", ")", ")", "{", "IOUtils", ".", "copyBytes", "(", "in", ",", "out", ",", "BUFFER_SIZE", ")", ";", "}", "if", "(", "!", "file", ".", "setLastModified", "(", "entry", ".", "getTime", "(", ")", ")", ")", "{", "numOfFailedLastModifiedSet", "++", ";", "}", "}", "}", "}", "if", "(", "numOfFailedLastModifiedSet", ">", "0", ")", "{", "LOG", ".", "warn", "(", "\"", "Could not set last modfied time for {} file(s)", "\"", ",", "numOfFailedLastModifiedSet", ")", ";", "}", "}", "}"], "idx": 22162, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "65e55097da2bb3f2fbdf9ba1946da25fe58bec9", "function_name": "unJar", "body_hash": "71be44421fb8ac01c8c8dfb255f9728677ae8851"}
{"code": "public static void setFeaturesBySystemProperty(SAXParserFactory factory)\n                throws SAXException, ParserConfigurationException {\n\n            final boolean enableExternalDtdLoad = Boolean.parseBoolean(\n                System.getProperty(ENABLE_EXTERNAL_DTD_LOAD, \"false\"));\n\n            factory.setFeature(LOAD_EXTERNAL_DTD, enableExternalDtdLoad);\n            factory.setFeature(EXTERNAL_GENERAL_ENTITIES, enableExternalDtdLoad);\n            factory.setFeature(EXTERNAL_PARAMETER_ENTITIES, enableExternalDtdLoad);\n        }", "code_tokens": ["public", "static", "void", "setFeaturesBySystemProperty", "(", "SAXParserFactory", "factory", ")", "throws", "SAXException", ",", "ParserConfigurationException", "{", "final", "boolean", "enableExternalDtdLoad", "=", "Boolean", ".", "parseBoolean", "(", "System", ".", "getProperty", "(", "ENABLE_EXTERNAL_DTD_LOAD", ",", "\"", "false", "\"", ")", ")", ";", "factory", ".", "setFeature", "(", "LOAD_EXTERNAL_DTD", ",", "enableExternalDtdLoad", ")", ";", "factory", ".", "setFeature", "(", "EXTERNAL_GENERAL_ENTITIES", ",", "enableExternalDtdLoad", ")", ";", "factory", ".", "setFeature", "(", "EXTERNAL_PARAMETER_ENTITIES", ",", "enableExternalDtdLoad", ")", ";", "}"], "idx": 69879, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "c46a16d177e6797895b195c288ae9a9a096254b8", "function_name": "setFeaturesBySystemProperty", "body_hash": "e32cc1d54f77c925bba2ee7f44fe32857d7e85f3"}
{"code": "@Override\n    protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n        log.trace(\"Service: {}\", request);\n\n        // is there a consumer registered for the request.\n        HttpConsumer consumer = getServletResolveConsumerStrategy().resolve(request, getConsumers());\n        if (consumer == null) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n\n        if (consumer.getEndpoint().getHttpMethodRestrict() != null) {\n            Iterator it = ObjectHelper.createIterable(consumer.getEndpoint().getHttpMethodRestrict()).iterator();\n            boolean match = false;\n            while (it.hasNext()) {\n                String method = it.next().toString();\n                if (method.equalsIgnoreCase(request.getMethod())) {\n                    match = true;\n                    break;\n                }\n            }\n            if (!match) {\n                response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n                return;\n            }\n        }\n\n        if (\"TRACE\".equals(request.getMethod()) && !consumer.isTraceEnabled()) {\n            response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n            return;\n        }\n\n        // we do not support java serialized objects unless explicit enabled\n        String contentType = request.getContentType();\n        if (HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType) && !consumer.getEndpoint().getComponent().isAllowJavaSerializedObject()) {\n            response.sendError(HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);\n            return;\n        }\n        \n        final Exchange result = (Exchange) request.getAttribute(EXCHANGE_ATTRIBUTE_NAME);\n        if (result == null) {\n            // no asynchronous result so leverage continuation\n            final Continuation continuation = ContinuationSupport.getContinuation(request);\n            if (continuation.isInitial() && continuationTimeout != null) {\n                // set timeout on initial\n                continuation.setTimeout(continuationTimeout);\n            }\n\n            // are we suspended and a request is dispatched initially?\n            if (consumer.isSuspended() && continuation.isInitial()) {\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n                return;\n            }\n\n            if (continuation.isExpired()) {\n                String id = (String) continuation.getAttribute(EXCHANGE_ATTRIBUTE_ID);\n                // remember this id as expired\n                expiredExchanges.put(id, id);\n                log.warn(\"Continuation expired of exchangeId: {}\", id);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n                return;\n            }\n\n            // a new request so create an exchange\n            final Exchange exchange = new DefaultExchange(consumer.getEndpoint(), ExchangePattern.InOut);\n\n            if (consumer.getEndpoint().isBridgeEndpoint()) {\n                exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n                exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n            }\n            if (consumer.getEndpoint().isDisableStreamCache()) {\n                exchange.setProperty(Exchange.DISABLE_HTTP_STREAM_CACHE, Boolean.TRUE);\n            }\n            \n            HttpHelper.setCharsetFromContentType(request.getContentType(), exchange);\n            \n            exchange.setIn(new HttpMessage(exchange, request, response));\n            // set context path as header\n            String contextPath = consumer.getEndpoint().getPath();\n            exchange.getIn().setHeader(\"CamelServletContextPath\", contextPath);\n            \n            String httpPath = (String)exchange.getIn().getHeader(Exchange.HTTP_PATH);\n            // here we just remove the CamelServletContextPath part from the HTTP_PATH\n            if (contextPath != null\n                && httpPath.startsWith(contextPath)) {\n                exchange.getIn().setHeader(Exchange.HTTP_PATH,\n                        httpPath.substring(contextPath.length()));\n            }\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"Suspending continuation of exchangeId: {}\", exchange.getExchangeId());\n            }\n            continuation.setAttribute(EXCHANGE_ATTRIBUTE_ID, exchange.getExchangeId());\n\n            // we want to handle the UoW\n            try {\n                consumer.createUoW(exchange);\n            } catch (Exception e) {\n                log.error(\"Error processing request\", e);\n                throw new ServletException(e);\n            }\n\n            // must suspend before we process the exchange\n            continuation.suspend();\n\n            ClassLoader oldTccl = overrideTccl(exchange);\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"Processing request for exchangeId: {}\", exchange.getExchangeId());\n            }\n            // use the asynchronous API to process the exchange\n            \n            consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {\n                public void done(boolean doneSync) {\n                    // check if the exchange id is already expired\n                    boolean expired = expiredExchanges.remove(exchange.getExchangeId()) != null;\n                    if (!expired) {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Resuming continuation of exchangeId: {}\", exchange.getExchangeId());\n                        }\n                        // resume processing after both, sync and async callbacks\n                        continuation.setAttribute(EXCHANGE_ATTRIBUTE_NAME, exchange);\n                        continuation.resume();\n                    } else {\n                        log.warn(\"Cannot resume expired continuation of exchangeId: {}\", exchange.getExchangeId());\n                    }\n                }\n            });\n\n            if (oldTccl != null) {\n                restoreTccl(exchange, oldTccl);\n            }\n            \n            // return to let Jetty continuation to work as it will resubmit and invoke the service\n            // method again when its resumed\n            return;\n        }\n\n        try {\n            // now lets output to the response\n            if (log.isTraceEnabled()) {\n                log.trace(\"Resumed continuation and writing response for exchangeId: {}\", result.getExchangeId());\n            }\n            Integer bs = consumer.getEndpoint().getResponseBufferSize();\n            if (bs != null) {\n                log.trace(\"Using response buffer size: {}\", bs);\n                response.setBufferSize(bs);\n            }\n            consumer.getBinding().writeResponse(result, response);\n        } catch (IOException e) {\n            log.error(\"Error processing request\", e);\n            throw e;\n        } catch (Exception e) {\n            log.error(\"Error processing request\", e);\n            throw new ServletException(e);\n        } finally {\n            consumer.doneUoW(result);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "service", "(", "final", "HttpServletRequest", "request", ",", "final", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "log", ".", "trace", "(", "\"", "Service: {}", "\"", ",", "request", ")", ";", "HttpConsumer", "consumer", "=", "getServletResolveConsumerStrategy", "(", ")", ".", "resolve", "(", "request", ",", "getConsumers", "(", ")", ")", ";", "if", "(", "consumer", "==", "null", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ")", ";", "return", ";", "}", "if", "(", "consumer", ".", "getEndpoint", "(", ")", ".", "getHttpMethodRestrict", "(", ")", "!=", "null", ")", "{", "Iterator", "it", "=", "ObjectHelper", ".", "createIterable", "(", "consumer", ".", "getEndpoint", "(", ")", ".", "getHttpMethodRestrict", "(", ")", ")", ".", "iterator", "(", ")", ";", "boolean", "match", "=", "false", ";", "while", "(", "it", ".", "hasNext", "(", ")", ")", "{", "String", "method", "=", "it", ".", "next", "(", ")", ".", "toString", "(", ")", ";", "if", "(", "method", ".", "equalsIgnoreCase", "(", "request", ".", "getMethod", "(", ")", ")", ")", "{", "match", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "match", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_METHOD_NOT_ALLOWED", ")", ";", "return", ";", "}", "}", "if", "(", "\"", "TRACE", "\"", ".", "equals", "(", "request", ".", "getMethod", "(", ")", ")", "&&", "!", "consumer", ".", "isTraceEnabled", "(", ")", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_METHOD_NOT_ALLOWED", ")", ";", "return", ";", "}", "String", "contentType", "=", "request", ".", "getContentType", "(", ")", ";", "if", "(", "HttpConstants", ".", "CONTENT_TYPE_JAVA_SERIALIZED_OBJECT", ".", "equals", "(", "contentType", ")", "&&", "!", "consumer", ".", "getEndpoint", "(", ")", ".", "getComponent", "(", ")", ".", "isAllowJavaSerializedObject", "(", ")", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_UNSUPPORTED_MEDIA_TYPE", ")", ";", "return", ";", "}", "final", "Exchange", "result", "=", "(", "Exchange", ")", "request", ".", "getAttribute", "(", "EXCHANGE_ATTRIBUTE_NAME", ")", ";", "if", "(", "result", "==", "null", ")", "{", "final", "Continuation", "continuation", "=", "ContinuationSupport", ".", "getContinuation", "(", "request", ")", ";", "if", "(", "continuation", ".", "isInitial", "(", ")", "&&", "continuationTimeout", "!=", "null", ")", "{", "continuation", ".", "setTimeout", "(", "continuationTimeout", ")", ";", "}", "if", "(", "consumer", ".", "isSuspended", "(", ")", "&&", "continuation", ".", "isInitial", "(", ")", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_SERVICE_UNAVAILABLE", ")", ";", "return", ";", "}", "if", "(", "continuation", ".", "isExpired", "(", ")", ")", "{", "String", "id", "=", "(", "String", ")", "continuation", ".", "getAttribute", "(", "EXCHANGE_ATTRIBUTE_ID", ")", ";", "expiredExchanges", ".", "put", "(", "id", ",", "id", ")", ";", "log", ".", "warn", "(", "\"", "Continuation expired of exchangeId: {}", "\"", ",", "id", ")", ";", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_SERVICE_UNAVAILABLE", ")", ";", "return", ";", "}", "final", "Exchange", "exchange", "=", "new", "DefaultExchange", "(", "consumer", ".", "getEndpoint", "(", ")", ",", "ExchangePattern", ".", "InOut", ")", ";", "if", "(", "consumer", ".", "getEndpoint", "(", ")", ".", "isBridgeEndpoint", "(", ")", ")", "{", "exchange", ".", "setProperty", "(", "Exchange", ".", "SKIP_GZIP_ENCODING", ",", "Boolean", ".", "TRUE", ")", ";", "exchange", ".", "setProperty", "(", "Exchange", ".", "SKIP_WWW_FORM_URLENCODED", ",", "Boolean", ".", "TRUE", ")", ";", "}", "if", "(", "consumer", ".", "getEndpoint", "(", ")", ".", "isDisableStreamCache", "(", ")", ")", "{", "exchange", ".", "setProperty", "(", "Exchange", ".", "DISABLE_HTTP_STREAM_CACHE", ",", "Boolean", ".", "TRUE", ")", ";", "}", "HttpHelper", ".", "setCharsetFromContentType", "(", "request", ".", "getContentType", "(", ")", ",", "exchange", ")", ";", "exchange", ".", "setIn", "(", "new", "HttpMessage", "(", "exchange", ",", "request", ",", "response", ")", ")", ";", "String", "contextPath", "=", "consumer", ".", "getEndpoint", "(", ")", ".", "getPath", "(", ")", ";", "exchange", ".", "getIn", "(", ")", ".", "setHeader", "(", "\"", "CamelServletContextPath", "\"", ",", "contextPath", ")", ";", "String", "httpPath", "=", "(", "String", ")", "exchange", ".", "getIn", "(", ")", ".", "getHeader", "(", "Exchange", ".", "HTTP_PATH", ")", ";", "if", "(", "contextPath", "!=", "null", "&&", "httpPath", ".", "startsWith", "(", "contextPath", ")", ")", "{", "exchange", ".", "getIn", "(", ")", ".", "setHeader", "(", "Exchange", ".", "HTTP_PATH", ",", "httpPath", ".", "substring", "(", "contextPath", ".", "length", "(", ")", ")", ")", ";", "}", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Suspending continuation of exchangeId: {}", "\"", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "}", "continuation", ".", "setAttribute", "(", "EXCHANGE_ATTRIBUTE_ID", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "try", "{", "consumer", ".", "createUoW", "(", "exchange", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "Error processing request", "\"", ",", "e", ")", ";", "throw", "new", "ServletException", "(", "e", ")", ";", "}", "continuation", ".", "suspend", "(", ")", ";", "ClassLoader", "oldTccl", "=", "overrideTccl", "(", "exchange", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Processing request for exchangeId: {}", "\"", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "}", "consumer", ".", "getAsyncProcessor", "(", ")", ".", "process", "(", "exchange", ",", "new", "AsyncCallback", "(", ")", "{", "public", "void", "done", "(", "boolean", "doneSync", ")", "{", "boolean", "expired", "=", "expiredExchanges", ".", "remove", "(", "exchange", ".", "getExchangeId", "(", ")", ")", "!=", "null", ";", "if", "(", "!", "expired", ")", "{", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Resuming continuation of exchangeId: {}", "\"", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "}", "continuation", ".", "setAttribute", "(", "EXCHANGE_ATTRIBUTE_NAME", ",", "exchange", ")", ";", "continuation", ".", "resume", "(", ")", ";", "}", "else", "{", "log", ".", "warn", "(", "\"", "Cannot resume expired continuation of exchangeId: {}", "\"", ",", "exchange", ".", "getExchangeId", "(", ")", ")", ";", "}", "}", "}", ")", ";", "if", "(", "oldTccl", "!=", "null", ")", "{", "restoreTccl", "(", "exchange", ",", "oldTccl", ")", ";", "}", "return", ";", "}", "try", "{", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Resumed continuation and writing response for exchangeId: {}", "\"", ",", "result", ".", "getExchangeId", "(", ")", ")", ";", "}", "Integer", "bs", "=", "consumer", ".", "getEndpoint", "(", ")", ".", "getResponseBufferSize", "(", ")", ";", "if", "(", "bs", "!=", "null", ")", "{", "log", ".", "trace", "(", "\"", "Using response buffer size: {}", "\"", ",", "bs", ")", ";", "response", ".", "setBufferSize", "(", "bs", ")", ";", "}", "consumer", ".", "getBinding", "(", ")", ".", "writeResponse", "(", "result", ",", "response", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"", "Error processing request", "\"", ",", "e", ")", ";", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "Error processing request", "\"", ",", "e", ")", ";", "throw", "new", "ServletException", "(", "e", ")", ";", "}", "finally", "{", "consumer", ".", "doneUoW", "(", "result", ")", ";", "}", "}"], "idx": 3333, "cwe": "CWE-19", "target": 0, "status": "FIXED", "commit": "0afcf721ff209eb10a24c5e4b48ca9d6727ea99a", "function_name": "service", "body_hash": "3bfd05797552fc3d5a22fc81020892043c192e21"}
{"code": "void nextRequest() {\n        request.recycle();\n\n        // Copy leftover bytes to the beginning of the buffer\n        if (byteBuffer.remaining() > 0 && byteBuffer.position() > 0) {\n            byteBuffer.compact();\n        }\n        // Always reset pos to zero\n        byteBuffer.limit(byteBuffer.limit() - byteBuffer.position()).position(0);\n\n        // Recycle filters\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        // Reset pointers\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        parsingRequestLinePhase = 0;\n        parsingRequestLineEol = false;\n        parsingRequestLineStart = 0;\n        parsingRequestLineQPos = -1;\n        headerData.recycle();\n    }", "code_tokens": ["void", "nextRequest", "(", ")", "{", "request", ".", "recycle", "(", ")", ";", "if", "(", "byteBuffer", ".", "remaining", "(", ")", ">", "0", "&&", "byteBuffer", ".", "position", "(", ")", ">", "0", ")", "{", "byteBuffer", ".", "compact", "(", ")", ";", "}", "byteBuffer", ".", "limit", "(", "byteBuffer", ".", "limit", "(", ")", "-", "byteBuffer", ".", "position", "(", ")", ")", ".", "position", "(", "0", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<=", "lastActiveFilter", ";", "i", "++", ")", "{", "activeFilters", "[", "i", "]", ".", "recycle", "(", ")", ";", "}", "lastActiveFilter", "=", "-", "1", ";", "parsingHeader", "=", "true", ";", "swallowInput", "=", "true", ";", "headerParsePos", "=", "HeaderParsePosition", ".", "HEADER_START", ";", "parsingRequestLine", "=", "true", ";", "parsingRequestLinePhase", "=", "0", ";", "parsingRequestLineEol", "=", "false", ";", "parsingRequestLineStart", "=", "0", ";", "parsingRequestLineQPos", "=", "-", "1", ";", "headerData", ".", "recycle", "(", ")", ";", "}"], "idx": 17059, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "452c8094a665ef6375530e81c033da4eeb2e4865", "function_name": "nextRequest", "body_hash": "2f6f9200aff98658e30903f1db7e35af32e39525"}
{"code": "@Override\n        public int fill(ByteBuffer buffer) throws IOException\n        {\n            try\n            {\n                try (AutoLock l = _lock.lock())\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\">fill {}\", SslConnection.this);\n\n                    int filled = -2;\n                    try\n                    {\n                        if (_fillState != FillState.IDLE)\n                            return filled = 0;\n\n                        // Do we already have some decrypted data?\n                        if (BufferUtil.hasContent(_decryptedInput))\n                            return filled = BufferUtil.append(buffer, _decryptedInput);\n\n                        // loop filling and unwrapping until we have something\n                        while (true)\n                        {\n                            HandshakeStatus status = _sslEngine.getHandshakeStatus();\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"fill {}\", status);\n                            switch (status)\n                            {\n                                case NEED_UNWRAP:\n                                case NOT_HANDSHAKING:\n                                    break;\n\n                                case NEED_TASK:\n                                    _sslEngine.getDelegatedTask().run();\n                                    continue;\n\n                                case NEED_WRAP:\n                                    if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER))\n                                    {\n                                        Throwable failure = _failure;\n                                        if (failure != null)\n                                            rethrow(failure);\n                                        if (_sslEngine.isInboundDone())\n                                            return filled = -1;\n                                        continue;\n                                    }\n                                    // Handle in needsFillInterest().\n                                    return filled = 0;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected HandshakeStatus \" + status);\n                            }\n\n                            acquireEncryptedInput();\n\n                            // can we use the passed buffer if it is big enough\n                            ByteBuffer appIn;\n                            int appBufferSize = getApplicationBufferSize();\n                            if (_decryptedInput == null)\n                            {\n                                if (BufferUtil.space(buffer) > appBufferSize)\n                                    appIn = buffer;\n                                else\n                                    appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);\n                            }\n                            else\n                            {\n                                appIn = _decryptedInput;\n                                BufferUtil.compact(_encryptedInput);\n                            }\n\n                            // Let's try reading some encrypted data... even if we have some already.\n                            int netFilled = networkFill(_encryptedInput);\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"net filled={}\", netFilled);\n\n                            // Workaround for Java 11 behavior.\n                            if (netFilled < 0 && isHandshakeInitial() && BufferUtil.isEmpty(_encryptedInput))\n                                closeInbound();\n\n                            if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone())\n                                throw new SSLHandshakeException(\"Closed during handshake\");\n\n                            if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE))\n                            {\n                                if (LOG.isDebugEnabled())\n                                    LOG.debug(\"fill starting handshake {}\", SslConnection.this);\n                            }\n\n                            // Let's unwrap even if we have no net data because in that\n                            // case we want to fall through to the handshake handling\n                            int pos = BufferUtil.flipToFill(appIn);\n                            SSLEngineResult unwrapResult;\n                            try\n                            {\n                                _underflown = false;\n                                unwrapResult = SslConnection.this.unwrap(_sslEngine, _encryptedInput, appIn);\n                            }\n                            finally\n                            {\n                                BufferUtil.flipToFlush(appIn, pos);\n                            }\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}\",\n                                    netFilled,\n                                    StringUtil.replace(unwrapResult.toString(), '\\n', ' '),\n                                    BufferUtil.toSummaryString(_encryptedInput),\n                                    BufferUtil.toDetailString(appIn),\n                                    BufferUtil.toDetailString(buffer));\n\n                            SSLEngineResult.Status unwrap = unwrapResult.getStatus();\n\n                            // Extra check on unwrapResultStatus == OK with zero bytes consumed\n                            // or produced is due to an SSL client on Android (see bug #454773).\n                            if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0)\n                                unwrap = Status.BUFFER_UNDERFLOW;\n\n                            switch (unwrap)\n                            {\n                                case CLOSED:\n                                    Throwable failure = _failure;\n                                    if (failure != null)\n                                        rethrow(failure);\n                                    return filled = -1;\n\n                                case BUFFER_UNDERFLOW:\n                                    if (netFilled > 0)\n                                        continue; // try filling some more\n                                    _underflown = true;\n                                    if (netFilled < 0 && _sslEngine.getUseClientMode())\n                                    {\n                                        Throwable closeFailure = closeInbound();\n                                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                                        {\n                                            Throwable handshakeFailure = new SSLHandshakeException(\"Abruptly closed by peer\");\n                                            if (closeFailure != null)\n                                                handshakeFailure.initCause(closeFailure);\n                                            throw handshakeFailure;\n                                        }\n                                        return filled = -1;\n                                    }\n                                    return filled = netFilled;\n\n                                case BUFFER_OVERFLOW:\n                                    // It's possible that SSLSession.applicationBufferSize has been expanded\n                                    // by the SSLEngine implementation. Unwrapping a large encrypted buffer\n                                    // causes BUFFER_OVERFLOW because the (old) applicationBufferSize is\n                                    // too small. Release the decrypted input buffer so it will be re-acquired\n                                    // with the larger capacity.\n                                    // See also system property \"jsse.SSLEngine.acceptLargeFragments\".\n                                    if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize())\n                                    {\n                                        releaseDecryptedInputBuffer();\n                                        continue;\n                                    }\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n\n                                case OK:\n                                    if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED)\n                                        handshakeSucceeded();\n\n                                    if (isRenegotiating() && !allowRenegotiate())\n                                        return filled = -1;\n\n                                    // If bytes were produced, don't bother with the handshake status;\n                                    // pass the decrypted data to the application, which will perform\n                                    // another call to fill() or flush().\n                                    if (unwrapResult.bytesProduced() > 0)\n                                    {\n                                        if (appIn == buffer)\n                                            return filled = unwrapResult.bytesProduced();\n                                        return filled = BufferUtil.append(buffer, _decryptedInput);\n                                    }\n\n                                    break;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n                            }\n                        }\n                    }\n                    catch (Throwable x)\n                    {\n                        Throwable f = handleException(x, \"fill\");\n                        Throwable failure = handshakeFailed(f);\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));\n                        }\n                        throw failure;\n                    }\n                    finally\n                    {\n                        releaseEncryptedInputBuffer();\n                        releaseDecryptedInputBuffer();\n\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());\n                        }\n\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"<fill f={} uf={} {}\", filled, _underflown, SslConnection.this);\n                    }\n                }\n            }\n            catch (Throwable x)\n            {\n                close(x);\n                rethrow(x);\n                // Never reached.\n                throw new AssertionError();\n            }\n        }", "code_tokens": ["@", "Override", "public", "int", "fill", "(", "ByteBuffer", "buffer", ")", "throws", "IOException", "{", "try", "{", "try", "(", "AutoLock", "l", "=", "_lock", ".", "lock", "(", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", ">fill {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "int", "filled", "=", "-", "2", ";", "try", "{", "if", "(", "_fillState", "!=", "FillState", ".", "IDLE", ")", "return", "filled", "=", "0", ";", "if", "(", "BufferUtil", ".", "hasContent", "(", "_decryptedInput", ")", ")", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "while", "(", "true", ")", "{", "HandshakeStatus", "status", "=", "_sslEngine", ".", "getHandshakeStatus", "(", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill {}", "\"", ",", "status", ")", ";", "switch", "(", "status", ")", "{", "case", "NEED_UNWRAP", ":", "case", "NOT_HANDSHAKING", ":", "break", ";", "case", "NEED_TASK", ":", "_sslEngine", ".", "getDelegatedTask", "(", ")", ".", "run", "(", ")", ";", "continue", ";", "case", "NEED_WRAP", ":", "if", "(", "_flushState", "==", "FlushState", ".", "IDLE", "&&", "flush", "(", "BufferUtil", ".", "EMPTY_BUFFER", ")", ")", "{", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "if", "(", "_sslEngine", ".", "isInboundDone", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "continue", ";", "}", "return", "filled", "=", "0", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected HandshakeStatus ", "\"", "+", "status", ")", ";", "}", "acquireEncryptedInput", "(", ")", ";", "ByteBuffer", "appIn", ";", "int", "appBufferSize", "=", "getApplicationBufferSize", "(", ")", ";", "if", "(", "_decryptedInput", "==", "null", ")", "{", "if", "(", "BufferUtil", ".", "space", "(", "buffer", ")", ">", "appBufferSize", ")", "appIn", "=", "buffer", ";", "else", "appIn", "=", "_decryptedInput", "=", "_bufferPool", ".", "acquire", "(", "appBufferSize", ",", "_decryptedDirectBuffers", ")", ";", "}", "else", "{", "appIn", "=", "_decryptedInput", ";", "BufferUtil", ".", "compact", "(", "_encryptedInput", ")", ";", "}", "int", "netFilled", "=", "networkFill", "(", "_encryptedInput", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "net filled={}", "\"", ",", "netFilled", ")", ";", "if", "(", "netFilled", "<", "0", "&&", "isHandshakeInitial", "(", ")", "&&", "BufferUtil", ".", "isEmpty", "(", "_encryptedInput", ")", ")", "closeInbound", "(", ")", ";", "if", "(", "netFilled", ">", "0", "&&", "!", "isHandshakeComplete", "(", ")", "&&", "isOutboundDone", "(", ")", ")", "throw", "new", "SSLHandshakeException", "(", "\"", "Closed during handshake", "\"", ")", ";", "if", "(", "_handshake", ".", "compareAndSet", "(", "HandshakeState", ".", "INITIAL", ",", "HandshakeState", ".", "HANDSHAKE", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill starting handshake {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "}", "int", "pos", "=", "BufferUtil", ".", "flipToFill", "(", "appIn", ")", ";", "SSLEngineResult", "unwrapResult", ";", "try", "{", "_underflown", "=", "false", ";", "unwrapResult", "=", "SslConnection", ".", "this", ".", "unwrap", "(", "_sslEngine", ",", "_encryptedInput", ",", "appIn", ")", ";", "}", "finally", "{", "BufferUtil", ".", "flipToFlush", "(", "appIn", ",", "pos", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}", "\"", ",", "netFilled", ",", "StringUtil", ".", "replace", "(", "unwrapResult", ".", "toString", "(", ")", ",", "'\\n'", ",", "' '", ")", ",", "BufferUtil", ".", "toSummaryString", "(", "_encryptedInput", ")", ",", "BufferUtil", ".", "toDetailString", "(", "appIn", ")", ",", "BufferUtil", ".", "toDetailString", "(", "buffer", ")", ")", ";", "SSLEngineResult", ".", "Status", "unwrap", "=", "unwrapResult", ".", "getStatus", "(", ")", ";", "if", "(", "unwrap", "==", "Status", ".", "OK", "&&", "unwrapResult", ".", "bytesConsumed", "(", ")", "==", "0", "&&", "unwrapResult", ".", "bytesProduced", "(", ")", "==", "0", ")", "unwrap", "=", "Status", ".", "BUFFER_UNDERFLOW", ";", "switch", "(", "unwrap", ")", "{", "case", "CLOSED", ":", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "return", "filled", "=", "-", "1", ";", "case", "BUFFER_UNDERFLOW", ":", "if", "(", "netFilled", ">", "0", ")", "continue", ";", "_underflown", "=", "true", ";", "if", "(", "netFilled", "<", "0", "&&", "_sslEngine", ".", "getUseClientMode", "(", ")", ")", "{", "Throwable", "closeFailure", "=", "closeInbound", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "Throwable", "handshakeFailure", "=", "new", "SSLHandshakeException", "(", "\"", "Abruptly closed by peer", "\"", ")", ";", "if", "(", "closeFailure", "!=", "null", ")", "handshakeFailure", ".", "initCause", "(", "closeFailure", ")", ";", "throw", "handshakeFailure", ";", "}", "return", "filled", "=", "-", "1", ";", "}", "return", "filled", "=", "netFilled", ";", "case", "BUFFER_OVERFLOW", ":", "if", "(", "BufferUtil", ".", "isEmpty", "(", "_decryptedInput", ")", "&&", "appBufferSize", "<", "getApplicationBufferSize", "(", ")", ")", "{", "releaseDecryptedInputBuffer", "(", ")", ";", "continue", ";", "}", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "case", "OK", ":", "if", "(", "unwrapResult", ".", "getHandshakeStatus", "(", ")", "==", "HandshakeStatus", ".", "FINISHED", ")", "handshakeSucceeded", "(", ")", ";", "if", "(", "isRenegotiating", "(", ")", "&&", "!", "allowRenegotiate", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "if", "(", "unwrapResult", ".", "bytesProduced", "(", ")", ">", "0", ")", "{", "if", "(", "appIn", "==", "buffer", ")", "return", "filled", "=", "unwrapResult", ".", "bytesProduced", "(", ")", ";", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "}", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "Throwable", "f", "=", "handleException", "(", "x", ",", "\"", "fill", "\"", ")", ";", "Throwable", "failure", "=", "handshakeFailed", "(", "f", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "onFail", "(", "failure", ")", ")", ";", "}", "throw", "failure", ";", "}", "finally", "{", "releaseEncryptedInputBuffer", "(", ")", ";", "releaseDecryptedInputBuffer", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "completeWrite", "(", ")", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "<fill f={} uf={} {}", "\"", ",", "filled", ",", "_underflown", ",", "SslConnection", ".", "this", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "close", "(", "x", ")", ";", "rethrow", "(", "x", ")", ";", "throw", "new", "AssertionError", "(", ")", ";", "}", "}"], "idx": 65347, "cwe": "CWE-59", "target": 1, "status": "VULNERABLE", "commit": "be22761a20a1685365c8e0356bf09b47e574cfd9", "function_name": "fill", "body_hash": "1489695c3d95003f6b64d0c36e90f584f9a0ef0e"}
{"code": "public void renameUser(final String oldName, final String newName) throws Exception {\n        update();\n\n        m_writeLock.lock();\n        \n        try {\n            // Get the old data\n            if (m_users.containsKey(oldName)) {\n                final User data = m_users.get(oldName);\n                if (data == null) {\n                    m_users.remove(oldName);\n                    throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n                } else {\n                    // Rename the user in the user map.\n                    m_users.remove(oldName);\n                    data.setUserId(newName);\n                    m_users.put(newName, data);\n        \n                    // Refresh the groups config first\n                    m_groupManager.update();\n                    \n                    // Rename the user in the group.\n                    m_groupManager.renameUser(oldName, newName);\n        \n                    // Rename the user in the view.\n                    // viewFactory.renameUser(oldName, newName);\n                }\n            } else {\n                throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n            }\n        \n            _saveCurrent();\n        } finally {\n            m_writeLock.unlock();\n        }\n    }", "code_tokens": ["public", "void", "renameUser", "(", "final", "String", "oldName", ",", "final", "String", "newName", ")", "throws", "Exception", "{", "update", "(", ")", ";", "m_writeLock", ".", "lock", "(", ")", ";", "try", "{", "if", "(", "m_users", ".", "containsKey", "(", "oldName", ")", ")", "{", "final", "User", "data", "=", "m_users", ".", "get", "(", "oldName", ")", ";", "if", "(", "data", "==", "null", ")", "{", "m_users", ".", "remove", "(", "oldName", ")", ";", "throw", "new", "Exception", "(", "\"", "UserFactory:rename the data contained for old user ", "\"", "+", "oldName", "+", "\"", " is null", "\"", ")", ";", "}", "else", "{", "m_users", ".", "remove", "(", "oldName", ")", ";", "data", ".", "setUserId", "(", "newName", ")", ";", "m_users", ".", "put", "(", "newName", ",", "data", ")", ";", "m_groupManager", ".", "update", "(", ")", ";", "m_groupManager", ".", "renameUser", "(", "oldName", ",", "newName", ")", ";", "}", "}", "else", "{", "throw", "new", "Exception", "(", "\"", "UserFactory:rename the old user name ", "\"", "+", "oldName", "+", "\"", " is not found", "\"", ")", ";", "}", "_saveCurrent", "(", ")", ";", "}", "finally", "{", "m_writeLock", ".", "unlock", "(", ")", ";", "}", "}"], "idx": 45060, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "607151ea8f90212a3fb37c977fa57c7d58d26a84", "function_name": "renameUser", "body_hash": "4f9f5eaf4cbe99c4dfa120cf40bfcb83cbc30b23"}
{"code": "public static String canonicalPath(String path)\n    {\n        if (path==null || path.length()==0)\n            return path;\n\n        int end=path.length();\n        int start = path.lastIndexOf('/', end);\n\n    search:\n        while (end>0)\n        {\n            switch(end-start)\n            {\n              case 2: // possible single dot\n                  if (path.charAt(start+1)!='.')\n                      break;\n                  break search;\n              case 3: // possible double dot\n                  if (path.charAt(start+1)!='.' || path.charAt(start+2)!='.')\n                      break;\n                  break search;\n            }\n            \n            end=start;\n            start=path.lastIndexOf('/',end-1);\n        }\n\n        // If we have checked the entire string\n        if (start>=end)\n            return path;\n        \n        StringBuffer buf = new StringBuffer(path);\n        int delStart=-1;\n        int delEnd=-1;\n        int skip=0;\n        \n        while (end>0)\n        {\n            switch(end-start)\n            {       \n              case 2: // possible single dot\n                  if (buf.charAt(start+1)!='.')\n                  {\n                      if (skip>0 && --skip==0)\n                      {   \n                          delStart=start>=0?start:0;\n                          if(delStart>0 && delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                              delStart++;\n                      }\n                      break;\n                  }\n                  \n                  if(start<0 && buf.length()>2 && buf.charAt(1)=='/' && buf.charAt(2)=='/')\n                      break;\n                  \n                  if(delEnd<0)\n                      delEnd=end;\n                  delStart=start;\n                  if (delStart<0 || delStart==0&&buf.charAt(delStart)=='/')\n                  {\n                      delStart++;\n                      if (delEnd<buf.length() && buf.charAt(delEnd)=='/')\n                          delEnd++;\n                      break;\n                  }\n                  if (end==buf.length())\n                      delStart++;\n                  \n                  end=start--;\n                  while (start>=0 && buf.charAt(start)!='/')\n                      start--;\n                  continue;\n                  \n              case 3: // possible double dot\n                  if (buf.charAt(start+1)!='.' || buf.charAt(start+2)!='.')\n                  {\n                      if (skip>0 && --skip==0)\n                      {   delStart=start>=0?start:0;\n                          if(delStart>0 && delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                              delStart++;\n                      }\n                      break;\n                  }\n                  \n                  delStart=start;\n                  if (delEnd<0)\n                      delEnd=end;\n\n                  skip++;\n                  end=start--;\n                  while (start>=0 && buf.charAt(start)!='/')\n                      start--;\n                  continue;\n\n              default:\n                  if (skip>0 && --skip==0)\n                  {\n                      delStart=start>=0?start:0;\n                      if(delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                          delStart++;\n                  }\n            }     \n            \n            // Do the delete\n            if (skip<=0 && delStart>=0 && delStart>=0)\n            {  \n                buf.delete(delStart,delEnd);\n                delStart=delEnd=-1;\n                if (skip>0)\n                    delEnd=end;\n            }\n            \n            end=start--;\n            while (start>=0 && buf.charAt(start)!='/')\n                start--;\n        }      \n\n        // Too many ..\n        if (skip>0)\n            return null;\n        \n        // Do the delete\n        if (delEnd>=0)\n            buf.delete(delStart,delEnd);\n\n        return buf.toString();\n    }", "code_tokens": ["public", "static", "String", "canonicalPath", "(", "String", "path", ")", "{", "if", "(", "path", "==", "null", "||", "path", ".", "length", "(", ")", "==", "0", ")", "return", "path", ";", "int", "end", "=", "path", ".", "length", "(", ")", ";", "int", "start", "=", "path", ".", "lastIndexOf", "(", "'/'", ",", "end", ")", ";", "search", ":", "while", "(", "end", ">", "0", ")", "{", "switch", "(", "end", "-", "start", ")", "{", "case", "2", ":", "if", "(", "path", ".", "charAt", "(", "start", "+", "1", ")", "!=", "'.'", ")", "break", ";", "break", "search", ";", "case", "3", ":", "if", "(", "path", ".", "charAt", "(", "start", "+", "1", ")", "!=", "'.'", "||", "path", ".", "charAt", "(", "start", "+", "2", ")", "!=", "'.'", ")", "break", ";", "break", "search", ";", "}", "end", "=", "start", ";", "start", "=", "path", ".", "lastIndexOf", "(", "'/'", ",", "end", "-", "1", ")", ";", "}", "if", "(", "start", ">=", "end", ")", "return", "path", ";", "StringBuffer", "buf", "=", "new", "StringBuffer", "(", "path", ")", ";", "int", "delStart", "=", "-", "1", ";", "int", "delEnd", "=", "-", "1", ";", "int", "skip", "=", "0", ";", "while", "(", "end", ">", "0", ")", "{", "switch", "(", "end", "-", "start", ")", "{", "case", "2", ":", "if", "(", "buf", ".", "charAt", "(", "start", "+", "1", ")", "!=", "'.'", ")", "{", "if", "(", "skip", ">", "0", "&&", "--", "skip", "==", "0", ")", "{", "delStart", "=", "start", ">=", "0", "?", "start", ":", "0", ";", "if", "(", "delStart", ">", "0", "&&", "delEnd", "==", "buf", ".", "length", "(", ")", "&&", "buf", ".", "charAt", "(", "delEnd", "-", "1", ")", "==", "'.'", ")", "delStart", "++", ";", "}", "break", ";", "}", "if", "(", "start", "<", "0", "&&", "buf", ".", "length", "(", ")", ">", "2", "&&", "buf", ".", "charAt", "(", "1", ")", "==", "'/'", "&&", "buf", ".", "charAt", "(", "2", ")", "==", "'/'", ")", "break", ";", "if", "(", "delEnd", "<", "0", ")", "delEnd", "=", "end", ";", "delStart", "=", "start", ";", "if", "(", "delStart", "<", "0", "||", "delStart", "==", "0", "&&", "buf", ".", "charAt", "(", "delStart", ")", "==", "'/'", ")", "{", "delStart", "++", ";", "if", "(", "delEnd", "<", "buf", ".", "length", "(", ")", "&&", "buf", ".", "charAt", "(", "delEnd", ")", "==", "'/'", ")", "delEnd", "++", ";", "break", ";", "}", "if", "(", "end", "==", "buf", ".", "length", "(", ")", ")", "delStart", "++", ";", "end", "=", "start", "--", ";", "while", "(", "start", ">=", "0", "&&", "buf", ".", "charAt", "(", "start", ")", "!=", "'/'", ")", "start", "--", ";", "continue", ";", "case", "3", ":", "if", "(", "buf", ".", "charAt", "(", "start", "+", "1", ")", "!=", "'.'", "||", "buf", ".", "charAt", "(", "start", "+", "2", ")", "!=", "'.'", ")", "{", "if", "(", "skip", ">", "0", "&&", "--", "skip", "==", "0", ")", "{", "delStart", "=", "start", ">=", "0", "?", "start", ":", "0", ";", "if", "(", "delStart", ">", "0", "&&", "delEnd", "==", "buf", ".", "length", "(", ")", "&&", "buf", ".", "charAt", "(", "delEnd", "-", "1", ")", "==", "'.'", ")", "delStart", "++", ";", "}", "break", ";", "}", "delStart", "=", "start", ";", "if", "(", "delEnd", "<", "0", ")", "delEnd", "=", "end", ";", "skip", "++", ";", "end", "=", "start", "--", ";", "while", "(", "start", ">=", "0", "&&", "buf", ".", "charAt", "(", "start", ")", "!=", "'/'", ")", "start", "--", ";", "continue", ";", "default", ":", "if", "(", "skip", ">", "0", "&&", "--", "skip", "==", "0", ")", "{", "delStart", "=", "start", ">=", "0", "?", "start", ":", "0", ";", "if", "(", "delEnd", "==", "buf", ".", "length", "(", ")", "&&", "buf", ".", "charAt", "(", "delEnd", "-", "1", ")", "==", "'.'", ")", "delStart", "++", ";", "}", "}", "if", "(", "skip", "<=", "0", "&&", "delStart", ">=", "0", "&&", "delStart", ">=", "0", ")", "{", "buf", ".", "delete", "(", "delStart", ",", "delEnd", ")", ";", "delStart", "=", "delEnd", "=", "-", "1", ";", "if", "(", "skip", ">", "0", ")", "delEnd", "=", "end", ";", "}", "end", "=", "start", "--", ";", "while", "(", "start", ">=", "0", "&&", "buf", ".", "charAt", "(", "start", ")", "!=", "'/'", ")", "start", "--", ";", "}", "if", "(", "skip", ">", "0", ")", "return", "null", ";", "if", "(", "delEnd", ">=", "0", ")", "buf", ".", "delete", "(", "delStart", ",", "delEnd", ")", ";", "return", "buf", ".", "toString", "(", ")", ";", "}"], "idx": 20940, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "038ce0f5c29a60263e23aec544ecec516c043f98", "function_name": "canonicalPath", "body_hash": "fb0d24d9c85f05d406e4963bc330e1fa254c9ea9"}
{"code": "public HttpResponse doForcePromotion(@QueryParameter(\"name\") String name) throws IOException {\n//        if(!req.getMethod().equals(\"POST\")) {// require post,\n//            rsp.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n//            return;\n//        }\n\n        JobPropertyImpl pp = getProject().getProperty(JobPropertyImpl.class);\n        if(pp==null)\n            throw new IllegalStateException(\"This project doesn't have any promotion criteria set\");\n\n        PromotionProcess p = pp.getItem(name);\n        if(p==null)\n            throw new IllegalStateException(\"This project doesn't have the promotion criterion called \"+name);\n\n        ManualCondition manualCondition = (ManualCondition) p.getPromotionCondition(ManualCondition.class.getName());\n        PromotionPermissionHelper.checkPermission(getProject(), manualCondition);\n\n        p.promote(owner,new UserCause(),new ManualPromotionBadge());\n\n        return HttpResponses.redirectToDot();\n    }", "code_tokens": ["public", "HttpResponse", "doForcePromotion", "(", "@", "QueryParameter", "(", "\"", "name", "\"", ")", "String", "name", ")", "throws", "IOException", "{", "JobPropertyImpl", "pp", "=", "getProject", "(", ")", ".", "getProperty", "(", "JobPropertyImpl", ".", "class", ")", ";", "if", "(", "pp", "==", "null", ")", "throw", "new", "IllegalStateException", "(", "\"", "This project doesn't have any promotion criteria set", "\"", ")", ";", "PromotionProcess", "p", "=", "pp", ".", "getItem", "(", "name", ")", ";", "if", "(", "p", "==", "null", ")", "throw", "new", "IllegalStateException", "(", "\"", "This project doesn't have the promotion criterion called ", "\"", "+", "name", ")", ";", "ManualCondition", "manualCondition", "=", "(", "ManualCondition", ")", "p", ".", "getPromotionCondition", "(", "ManualCondition", ".", "class", ".", "getName", "(", ")", ")", ";", "PromotionPermissionHelper", ".", "checkPermission", "(", "getProject", "(", ")", ",", "manualCondition", ")", ";", "p", ".", "promote", "(", "owner", ",", "new", "UserCause", "(", ")", ",", "new", "ManualPromotionBadge", "(", ")", ")", ";", "return", "HttpResponses", ".", "redirectToDot", "(", ")", ";", "}"], "idx": 46508, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "46086a74891d620042c3d28a19cba3510c5dbf6a", "function_name": "doForcePromotion", "body_hash": "e25dd8c3c386a4f6b245da7445b5c6afc829dec0"}
{"code": "@RequestMapping(value = \"/accept.do\", method = POST)\n    public String acceptInvitation(@RequestParam(\"password\") String password,\n                                   @RequestParam(\"password_confirmation\") String passwordConfirmation,\n                                   @RequestParam(\"code\") String code,\n                                   Model model,\n                                   HttpServletRequest request,\n                                   HttpServletResponse response) throws IOException {\n\n        PasswordConfirmationValidation validation = new PasswordConfirmationValidation(password, passwordConfirmation);\n\n        UaaPrincipal principal =  (UaaPrincipal) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n\n        final ExpiringCode expiringCode = expiringCodeStore.retrieveCode(code);\n\n        if (expiringCode == null || expiringCode.getData() == null) {\n            logger.debug(\"Failing invitation. Code not found.\");\n            SecurityContextHolder.clearContext();\n            return handleUnprocessableEntity(model, response, \"error_message_code\", \"code_expired\", \"invitations/accept_invite\");\n        }\n        Map<String,String> data = JsonUtils.readValue(expiringCode.getData(), new TypeReference<Map<String,String>>() {});\n        if (principal == null || data.get(\"user_id\") == null || !data.get(\"user_id\").equals(principal.getId())) {\n            logger.debug(\"Failing invitation. Code and user ID mismatch.\");\n            SecurityContextHolder.clearContext();\n            return handleUnprocessableEntity(model, response, \"error_message_code\", \"code_expired\", \"invitations/accept_invite\");\n        }\n\n        final String newCode = expiringCodeStore.generateCode(expiringCode.getData(), new Timestamp(System.currentTimeMillis() + (10 * 60 * 1000)), expiringCode.getIntent()).getCode();\n        if (!validation.valid()) {\n           return processErrorReload(newCode, model, principal.getEmail(), response, \"error_message_code\", validation.getMessageCode());\n//           return handleUnprocessableEntity(model, response, \"error_message_code\", validation.getMessageCode(), \"invitations/accept_invite\");\n        }\n        try {\n            passwordValidator.validate(password);\n        } catch (InvalidPasswordException e) {\n            return processErrorReload(newCode, model, principal.getEmail(), response, \"error_message\", e.getMessagesAsOneString());\n//            return handleUnprocessableEntity(model, response, \"error_message\", e.getMessagesAsOneString(), \"invitations/accept_invite\");\n        }\n        AcceptedInvitation invitation;\n        try {\n            invitation = invitationsService.acceptInvitation(newCode, password);\n        } catch (HttpClientErrorException e) {\n            return handleUnprocessableEntity(model, response, \"error_message_code\", \"code_expired\", \"invitations/accept_invite\");\n        }\n        principal = new UaaPrincipal(\n            invitation.getUser().getId(),\n            invitation.getUser().getUserName(),\n            invitation.getUser().getPrimaryEmail(),\n            invitation.getUser().getOrigin(),\n            invitation.getUser().getExternalId(),\n            IdentityZoneHolder.get().getId()\n        );\n        UaaAuthentication authentication = new UaaAuthentication(principal, UaaAuthority.USER_AUTHORITIES, new UaaAuthenticationDetails(request));\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        return \"redirect:\" + invitation.getRedirectUri();\n    }", "code_tokens": ["@", "RequestMapping", "(", "value", "=", "\"", "/accept.do", "\"", ",", "method", "=", "POST", ")", "public", "String", "acceptInvitation", "(", "@", "RequestParam", "(", "\"", "password", "\"", ")", "String", "password", ",", "@", "RequestParam", "(", "\"", "password_confirmation", "\"", ")", "String", "passwordConfirmation", ",", "@", "RequestParam", "(", "\"", "code", "\"", ")", "String", "code", ",", "Model", "model", ",", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "IOException", "{", "PasswordConfirmationValidation", "validation", "=", "new", "PasswordConfirmationValidation", "(", "password", ",", "passwordConfirmation", ")", ";", "UaaPrincipal", "principal", "=", "(", "UaaPrincipal", ")", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "getAuthentication", "(", ")", ".", "getPrincipal", "(", ")", ";", "final", "ExpiringCode", "expiringCode", "=", "expiringCodeStore", ".", "retrieveCode", "(", "code", ")", ";", "if", "(", "expiringCode", "==", "null", "||", "expiringCode", ".", "getData", "(", ")", "==", "null", ")", "{", "logger", ".", "debug", "(", "\"", "Failing invitation. Code not found.", "\"", ")", ";", "SecurityContextHolder", ".", "clearContext", "(", ")", ";", "return", "handleUnprocessableEntity", "(", "model", ",", "response", ",", "\"", "error_message_code", "\"", ",", "\"", "code_expired", "\"", ",", "\"", "invitations/accept_invite", "\"", ")", ";", "}", "Map", "<", "String", ",", "String", ">", "data", "=", "JsonUtils", ".", "readValue", "(", "expiringCode", ".", "getData", "(", ")", ",", "new", "TypeReference", "<", "Map", "<", "String", ",", "String", ">", ">", "(", ")", "{", "}", ")", ";", "if", "(", "principal", "==", "null", "||", "data", ".", "get", "(", "\"", "user_id", "\"", ")", "==", "null", "||", "!", "data", ".", "get", "(", "\"", "user_id", "\"", ")", ".", "equals", "(", "principal", ".", "getId", "(", ")", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Failing invitation. Code and user ID mismatch.", "\"", ")", ";", "SecurityContextHolder", ".", "clearContext", "(", ")", ";", "return", "handleUnprocessableEntity", "(", "model", ",", "response", ",", "\"", "error_message_code", "\"", ",", "\"", "code_expired", "\"", ",", "\"", "invitations/accept_invite", "\"", ")", ";", "}", "final", "String", "newCode", "=", "expiringCodeStore", ".", "generateCode", "(", "expiringCode", ".", "getData", "(", ")", ",", "new", "Timestamp", "(", "System", ".", "currentTimeMillis", "(", ")", "+", "(", "10", "*", "60", "*", "1000", ")", ")", ",", "expiringCode", ".", "getIntent", "(", ")", ")", ".", "getCode", "(", ")", ";", "if", "(", "!", "validation", ".", "valid", "(", ")", ")", "{", "return", "processErrorReload", "(", "newCode", ",", "model", ",", "principal", ".", "getEmail", "(", ")", ",", "response", ",", "\"", "error_message_code", "\"", ",", "validation", ".", "getMessageCode", "(", ")", ")", ";", "}", "try", "{", "passwordValidator", ".", "validate", "(", "password", ")", ";", "}", "catch", "(", "InvalidPasswordException", "e", ")", "{", "return", "processErrorReload", "(", "newCode", ",", "model", ",", "principal", ".", "getEmail", "(", ")", ",", "response", ",", "\"", "error_message", "\"", ",", "e", ".", "getMessagesAsOneString", "(", ")", ")", ";", "}", "AcceptedInvitation", "invitation", ";", "try", "{", "invitation", "=", "invitationsService", ".", "acceptInvitation", "(", "newCode", ",", "password", ")", ";", "}", "catch", "(", "HttpClientErrorException", "e", ")", "{", "return", "handleUnprocessableEntity", "(", "model", ",", "response", ",", "\"", "error_message_code", "\"", ",", "\"", "code_expired", "\"", ",", "\"", "invitations/accept_invite", "\"", ")", ";", "}", "principal", "=", "new", "UaaPrincipal", "(", "invitation", ".", "getUser", "(", ")", ".", "getId", "(", ")", ",", "invitation", ".", "getUser", "(", ")", ".", "getUserName", "(", ")", ",", "invitation", ".", "getUser", "(", ")", ".", "getPrimaryEmail", "(", ")", ",", "invitation", ".", "getUser", "(", ")", ".", "getOrigin", "(", ")", ",", "invitation", ".", "getUser", "(", ")", ".", "getExternalId", "(", ")", ",", "IdentityZoneHolder", ".", "get", "(", ")", ".", "getId", "(", ")", ")", ";", "UaaAuthentication", "authentication", "=", "new", "UaaAuthentication", "(", "principal", ",", "UaaAuthority", ".", "USER_AUTHORITIES", ",", "new", "UaaAuthenticationDetails", "(", "request", ")", ")", ";", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "setAuthentication", "(", "authentication", ")", ";", "return", "\"", "redirect:", "\"", "+", "invitation", ".", "getRedirectUri", "(", ")", ";", "}"], "idx": 35654, "cwe": "CWE-269", "target": 0, "status": "FIXED", "commit": "4f942064d85454a4bcc4da04cd482d114816c14a", "function_name": "acceptInvitation", "body_hash": "19cccce2523c46d0655fbe8ccaf3fdbfe51bd6de"}
{"code": "private void checkPrivileges(HiveOperationType hiveOpType, List<HivePrivilegeObject> hiveObjects,\n                               String userName, Operation2Privilege.IOType ioType, List<String> deniedMessages) {\n\n    if (hiveObjects == null) {\n      return;\n    }\n    if (admins != null && Arrays.stream(admins).parallel().anyMatch(n -> n.equals(userName))) {\n      return; // Skip rest of checks if user is admin\n    }\n\n    // Special-casing for ADMIN-level operations that do not require object checking.\n    if (Operation2Privilege.isAdminPrivOperation(hiveOpType)) {\n      // Require ADMIN privilege\n      deniedMessages.add(SQLPrivTypeGrant.ADMIN_PRIV.toString() + \" on \" + ioType);\n      return; // Ignore object, fail if not admin, succeed if admin.\n    }\n\n    boolean needAdmin = false;\n    for (HivePrivilegeObject hiveObj : hiveObjects) {\n      // If involving local file system\n      if (hiveObj.getType() == HivePrivilegeObject.HivePrivilegeObjectType.LOCAL_URI) {\n        needAdmin = true;\n        break;\n      }\n    }\n    if (!needAdmin) {\n      switch (hiveOpType) {\n        case ADD:\n        case DFS:\n        case COMPILE:\n          needAdmin = true;\n          break;\n        default:\n          break;\n      }\n    }\n    if (needAdmin) {\n      deniedMessages.add(\"ADMIN\");\n    }\n  }", "code_tokens": ["private", "void", "checkPrivileges", "(", "HiveOperationType", "hiveOpType", ",", "List", "<", "HivePrivilegeObject", ">", "hiveObjects", ",", "String", "userName", ",", "Operation2Privilege", ".", "IOType", "ioType", ",", "List", "<", "String", ">", "deniedMessages", ")", "{", "if", "(", "hiveObjects", "==", "null", ")", "{", "return", ";", "}", "if", "(", "admins", "!=", "null", "&&", "Arrays", ".", "stream", "(", "admins", ")", ".", "parallel", "(", ")", ".", "anyMatch", "(", "n", "->", "n", ".", "equals", "(", "userName", ")", ")", ")", "{", "return", ";", "}", "if", "(", "Operation2Privilege", ".", "isAdminPrivOperation", "(", "hiveOpType", ")", ")", "{", "deniedMessages", ".", "add", "(", "SQLPrivTypeGrant", ".", "ADMIN_PRIV", ".", "toString", "(", ")", "+", "\"", " on ", "\"", "+", "ioType", ")", ";", "return", ";", "}", "boolean", "needAdmin", "=", "false", ";", "for", "(", "HivePrivilegeObject", "hiveObj", ":", "hiveObjects", ")", "{", "if", "(", "hiveObj", ".", "getType", "(", ")", "==", "HivePrivilegeObject", ".", "HivePrivilegeObjectType", ".", "LOCAL_URI", ")", "{", "needAdmin", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "needAdmin", ")", "{", "switch", "(", "hiveOpType", ")", "{", "case", "ADD", ":", "case", "DFS", ":", "case", "COMPILE", ":", "needAdmin", "=", "true", ";", "break", ";", "default", ":", "break", ";", "}", "}", "if", "(", "needAdmin", ")", "{", "deniedMessages", ".", "add", "(", "\"", "ADMIN", "\"", ")", ";", "}", "}"], "idx": 102454, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "00c0ee7bc4b8492476b377a6edafcc33411f14b", "function_name": "checkPrivileges", "body_hash": "00756ba9706b0482e47090be438512a703e84d4a"}
{"code": "private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath();\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n    }", "code_tokens": ["private", "void", "expand", "(", "ArchiveEntrySupplier", "supplier", ",", "EntryWriter", "writer", ",", "File", "targetDirectory", ")", "throws", "IOException", "{", "String", "targetDirPath", "=", "targetDirectory", ".", "getCanonicalPath", "(", ")", ";", "ArchiveEntry", "nextEntry", "=", "supplier", ".", "getNextReadableEntry", "(", ")", ";", "while", "(", "nextEntry", "!=", "null", ")", "{", "File", "f", "=", "new", "File", "(", "targetDirectory", ",", "nextEntry", ".", "getName", "(", ")", ")", ";", "if", "(", "!", "f", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "targetDirPath", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "expanding ", "\"", "+", "nextEntry", ".", "getName", "(", ")", "+", "\"", " would create file outside of ", "\"", "+", "targetDirectory", ")", ";", "}", "if", "(", "nextEntry", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "f", ".", "isDirectory", "(", ")", "&&", "!", "f", ".", "mkdirs", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "failed to create directory ", "\"", "+", "f", ")", ";", "}", "}", "else", "{", "File", "parent", "=", "f", ".", "getParentFile", "(", ")", ";", "if", "(", "!", "parent", ".", "isDirectory", "(", ")", "&&", "!", "parent", ".", "mkdirs", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "failed to create directory ", "\"", "+", "parent", ")", ";", "}", "try", "(", "OutputStream", "o", "=", "Files", ".", "newOutputStream", "(", "f", ".", "toPath", "(", ")", ")", ")", "{", "writer", ".", "writeEntryDataTo", "(", "nextEntry", ",", "o", ")", ";", "}", "}", "nextEntry", "=", "supplier", ".", "getNextReadableEntry", "(", ")", ";", "}", "}"], "idx": 11719, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "a080293da69f3fe3d11d5214432e1469ee195870", "function_name": "expand", "body_hash": "1e17f154f656c2fde7081be5a93d44a3f9bcb550"}
{"code": "private static void processZipStream(File dir, InputStream inputStream) throws IOException\n   {\n      ZipInputStream zip = new ZipInputStream(inputStream);\n      while (true)\n      {\n         ZipEntry entry = zip.getNextEntry();\n         if (entry == null)\n         {\n            break;\n         }\n\n         File file = new File(dir, entry.getName());\n         if (entry.isDirectory())\n         {\n            FileHelper.mkdirsQuietly(file);\n            continue;\n         }\n\n         File parent = file.getParentFile();\n         if (parent != null)\n         {\n            FileHelper.mkdirsQuietly(parent);\n         }\n\n         FileOutputStream fos = new FileOutputStream(file);\n         byte[] bytes = new byte[1024];\n         int length;\n         while ((length = zip.read(bytes)) >= 0)\n         {\n            fos.write(bytes, 0, length);\n         }\n         fos.close();\n      }\n   }", "code_tokens": ["private", "static", "void", "processZipStream", "(", "File", "dir", ",", "InputStream", "inputStream", ")", "throws", "IOException", "{", "ZipInputStream", "zip", "=", "new", "ZipInputStream", "(", "inputStream", ")", ";", "while", "(", "true", ")", "{", "ZipEntry", "entry", "=", "zip", ".", "getNextEntry", "(", ")", ";", "if", "(", "entry", "==", "null", ")", "{", "break", ";", "}", "File", "file", "=", "new", "File", "(", "dir", ",", "entry", ".", "getName", "(", ")", ")", ";", "if", "(", "entry", ".", "isDirectory", "(", ")", ")", "{", "FileHelper", ".", "mkdirsQuietly", "(", "file", ")", ";", "continue", ";", "}", "File", "parent", "=", "file", ".", "getParentFile", "(", ")", ";", "if", "(", "parent", "!=", "null", ")", "{", "FileHelper", ".", "mkdirsQuietly", "(", "parent", ")", ";", "}", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "file", ")", ";", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "1024", "]", ";", "int", "length", ";", "while", "(", "(", "length", "=", "zip", ".", "read", "(", "bytes", ")", ")", ">=", "0", ")", "{", "fos", ".", "write", "(", "bytes", ",", "0", ",", "length", ")", ";", "}", "fos", ".", "close", "(", ")", ";", "}", "}"], "idx": 27287, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "8eaf4225048ea5ba7e59ef4556dab2098fcc4a1d", "function_name": "processZipStream", "body_hash": "9635b196246db8d70b79931b2e6ab3a4edb89ec3"}
{"code": "public static boolean isSecureZooKeeper(Configuration conf) {\n    // Detection for embedded HBase client with jaas configuration\n    // defined for third party programs.\n    try {\n      javax.security.auth.login.Configuration testConfig =\n          javax.security.auth.login.Configuration.getConfiguration();\n      if(testConfig.getAppConfigurationEntry(\"Client\") == null) {\n        return false;\n      }\n    } catch(Exception e) {\n      // No Jaas configuration defined.\n      return false;\n    }\n\n    // Master & RSs uses hbase.zookeeper.client.*\n    return(\"kerberos\".equalsIgnoreCase(conf.get(\"hbase.security.authentication\")) &&\n         conf.get(\"hbase.zookeeper.client.keytab.file\") != null);\n  }", "code_tokens": ["public", "static", "boolean", "isSecureZooKeeper", "(", "Configuration", "conf", ")", "{", "try", "{", "javax", ".", "security", ".", "auth", ".", "login", ".", "Configuration", "testConfig", "=", "javax", ".", "security", ".", "auth", ".", "login", ".", "Configuration", ".", "getConfiguration", "(", ")", ";", "if", "(", "testConfig", ".", "getAppConfigurationEntry", "(", "\"", "Client", "\"", ")", "==", "null", ")", "{", "return", "false", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "return", "false", ";", "}", "return", "(", "\"", "kerberos", "\"", ".", "equalsIgnoreCase", "(", "conf", ".", "get", "(", "\"", "hbase.security.authentication", "\"", ")", ")", "&&", "conf", ".", "get", "(", "\"", "hbase.zookeeper.client.keytab.file", "\"", ")", "!=", "null", ")", ";", "}"], "idx": 36935, "cwe": "CWE-284", "target": 1, "status": "VULNERABLE", "commit": "5b5f976", "function_name": "isSecureZooKeeper", "body_hash": "5e4a76087bfe719c00a397aa02f8e1596acd659c"}
{"code": "public void encode(FacesContext facesContext) throws IOException {\n        OutputStream outStream = facesContext.getExternalContext().getResponseOutputStream();\n        contentProducer.invoke(facesContext.getELContext(), new Object[] { outStream, userData });\n    }", "code_tokens": ["public", "void", "encode", "(", "FacesContext", "facesContext", ")", "throws", "IOException", "{", "OutputStream", "outStream", "=", "facesContext", ".", "getExternalContext", "(", ")", ".", "getResponseOutputStream", "(", ")", ";", "contentProducer", ".", "invoke", "(", "facesContext", ".", "getELContext", "(", ")", ",", "new", "Object", "[", "]", "{", "outStream", ",", "userData", "}", ")", ";", "}"], "idx": 94850, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "4c5ddae4d6ddcea591fa949762c1c79ac11cac99", "function_name": "encode", "body_hash": "73956343aa3dc2abc653648530969de2bbf247b3"}
{"code": "protected void addDefaultMapping(DefaultMapper mapper, String parameter, Object model) {\n\t\tExpression source = new RequestParameterExpression(parameter);\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tif (expressionParser instanceof BeanWrapperExpressionParser || checkModelProperty(parameter, model)) {\n\t\t\tExpression target = expressionParser.parseExpression(parameter, parserContext);\n\t\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Adding default mapping for parameter '\" + parameter + \"'\");\n\t\t\t}\n\t\t\tmapper.addMapping(mapping);\n\t\t}\n\t}", "code_tokens": ["protected", "void", "addDefaultMapping", "(", "DefaultMapper", "mapper", ",", "String", "parameter", ",", "Object", "model", ")", "{", "Expression", "source", "=", "new", "RequestParameterExpression", "(", "parameter", ")", ";", "ParserContext", "parserContext", "=", "new", "FluentParserContext", "(", ")", ".", "evaluate", "(", "model", ".", "getClass", "(", ")", ")", ";", "if", "(", "expressionParser", "instanceof", "BeanWrapperExpressionParser", "||", "checkModelProperty", "(", "parameter", ",", "model", ")", ")", "{", "Expression", "target", "=", "expressionParser", ".", "parseExpression", "(", "parameter", ",", "parserContext", ")", ";", "DefaultMapping", "mapping", "=", "new", "DefaultMapping", "(", "source", ",", "target", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Adding default mapping for parameter '", "\"", "+", "parameter", "+", "\"", "'", "\"", ")", ";", "}", "mapper", ".", "addMapping", "(", "mapping", ")", ";", "}", "}"], "idx": 1274, "cwe": "CWE-1188", "target": 0, "status": "FIXED", "commit": "084b4", "function_name": "addDefaultMapping", "body_hash": "d007d976cfb5d1e0c5150226f89b812c2c81d416"}
{"code": "private static void writeString(ByteBuffer buffer, String string) {\n        int length = string.length();\n        for (int charIndex = 0; charIndex < length; charIndex++) {\n            char c = string.charAt(charIndex);\n            byte b = (byte) c;\n            if(b != '\\r' && b != '\\n') {\n                buffer.put(b);\n            } else {\n                buffer.put((byte) ' ');\n            }\n        }\n    }", "code_tokens": ["private", "static", "void", "writeString", "(", "ByteBuffer", "buffer", ",", "String", "string", ")", "{", "int", "length", "=", "string", ".", "length", "(", ")", ";", "for", "(", "int", "charIndex", "=", "0", ";", "charIndex", "<", "length", ";", "charIndex", "++", ")", "{", "char", "c", "=", "string", ".", "charAt", "(", "charIndex", ")", ";", "byte", "b", "=", "(", "byte", ")", "c", ";", "if", "(", "b", "!=", "'\\r'", "&&", "b", "!=", "'\\n'", ")", "{", "buffer", ".", "put", "(", "b", ")", ";", "}", "else", "{", "buffer", ".", "put", "(", "(", "byte", ")", "' '", ")", ";", "}", "}", "}"], "idx": 35, "cwe": "CWE-113", "target": 0, "status": "FIXED", "commit": "85d4478e598105fe94ac152d3e11e388374e8b8", "function_name": "writeString", "body_hash": "0a86fd5ee2fed7dac8a0178959ac3ce311135101"}
{"code": "@Override\n    public BuildWrapper createBuildWrapper(AbstractBuild<?,?> build) {\n        return new BuildWrapper() {\n            @Override\n            public Environment setUp(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {\n            \tif (!StringUtils.isEmpty(location) && !StringUtils.isEmpty(file.getName())) {\n            \t    listener.getLogger().println(\"Copying file to \"+location);\n                    FilePath ws = build.getWorkspace();\n                    if (ws == null) {\n                        throw new IllegalStateException(\"The workspace should be created when setUp method is called\");\n                    }\n                    if (!ALLOW_FOLDER_TRAVERSAL_OUTSIDE_WORKSPACE && !ws.isDescendant(location)) {\n                        listener.error(\"Rejecting file path escaping base directory with relative path: \" + location);\n                        // force the build to fail\n                        return null;\n                    }\n                    FilePath locationFilePath = ws.child(location);\n                    locationFilePath.getParent().mkdirs();\n            \t    locationFilePath.copyFrom(file);\n                    locationFilePath.copyTo(new FilePath(getLocationUnderBuild(build)));\n            \t}\n                return new Environment() {};\n            }\n        };\n    }", "code_tokens": ["@", "Override", "public", "BuildWrapper", "createBuildWrapper", "(", "AbstractBuild", "<", "?", ",", "?", ">", "build", ")", "{", "return", "new", "BuildWrapper", "(", ")", "{", "@", "Override", "public", "Environment", "setUp", "(", "AbstractBuild", "build", ",", "Launcher", "launcher", ",", "BuildListener", "listener", ")", "throws", "IOException", ",", "InterruptedException", "{", "if", "(", "!", "StringUtils", ".", "isEmpty", "(", "location", ")", "&&", "!", "StringUtils", ".", "isEmpty", "(", "file", ".", "getName", "(", ")", ")", ")", "{", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Copying file to ", "\"", "+", "location", ")", ";", "FilePath", "ws", "=", "build", ".", "getWorkspace", "(", ")", ";", "if", "(", "ws", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "The workspace should be created when setUp method is called", "\"", ")", ";", "}", "if", "(", "!", "ALLOW_FOLDER_TRAVERSAL_OUTSIDE_WORKSPACE", "&&", "!", "ws", ".", "isDescendant", "(", "location", ")", ")", "{", "listener", ".", "error", "(", "\"", "Rejecting file path escaping base directory with relative path: ", "\"", "+", "location", ")", ";", "return", "null", ";", "}", "FilePath", "locationFilePath", "=", "ws", ".", "child", "(", "location", ")", ";", "locationFilePath", ".", "getParent", "(", ")", ".", "mkdirs", "(", ")", ";", "locationFilePath", ".", "copyFrom", "(", "file", ")", ";", "locationFilePath", ".", "copyTo", "(", "new", "FilePath", "(", "getLocationUnderBuild", "(", "build", ")", ")", ")", ";", "}", "return", "new", "Environment", "(", ")", "{", "}", ";", "}", "}", ";", "}"], "idx": 21307, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "18fc7c0b466553cbd4f790db3270964305bee7f9", "function_name": "createBuildWrapper", "body_hash": "091c9f1c699bb88ed3b18b42216a9f9e77773bb3"}
{"code": "@BeforeEach\n    public void startServer() throws Exception\n    {\n        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore.p12\").getAbsolutePath();\n        sslContextFactory = new SslContextFactory.Server();\n        sslContextFactory.setKeyStorePath(keystore);\n        sslContextFactory.setKeyStorePassword(\"storepwd\");\n\n        server = new Server();\n        HttpConnectionFactory http = new HttpConnectionFactory();\n        http.setInputBufferSize(512);\n        http.getHttpConfiguration().setRequestHeaderSize(512);\n        connector = new ServerConnector(server, sslContextFactory, http);\n        connector.setPort(0);\n        connector.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n\n        server.addConnector(connector);\n    }", "code_tokens": ["@", "BeforeEach", "public", "void", "startServer", "(", ")", "throws", "Exception", "{", "String", "keystore", "=", "MavenTestingUtils", ".", "getTestResourceFile", "(", "\"", "keystore.p12", "\"", ")", ".", "getAbsolutePath", "(", ")", ";", "sslContextFactory", "=", "new", "SslContextFactory", ".", "Server", "(", ")", ";", "sslContextFactory", ".", "setKeyStorePath", "(", "keystore", ")", ";", "sslContextFactory", ".", "setKeyStorePassword", "(", "\"", "storepwd", "\"", ")", ";", "server", "=", "new", "Server", "(", ")", ";", "HttpConnectionFactory", "http", "=", "new", "HttpConnectionFactory", "(", ")", ";", "http", ".", "setInputBufferSize", "(", "512", ")", ";", "http", ".", "getHttpConfiguration", "(", ")", ".", "setRequestHeaderSize", "(", "512", ")", ";", "connector", "=", "new", "ServerConnector", "(", "server", ",", "sslContextFactory", ",", "http", ")", ";", "connector", ".", "setPort", "(", "0", ")", ";", "connector", ".", "getConnectionFactory", "(", "HttpConnectionFactory", ".", "class", ")", ".", "getHttpConfiguration", "(", ")", ".", "setSendDateHeader", "(", "false", ")", ";", "server", ".", "addConnector", "(", "connector", ")", ";", "}"], "idx": 65388, "cwe": "CWE-59", "target": 0, "status": "FIXED", "commit": "be22761a20a1685365c8e0356bf09b47e574cfd9", "function_name": "startServer", "body_hash": "3dcc39f100fe4a9bfe4dc5bfc440855f8b1105fb"}
{"code": "@Override\n    public void setAttribute(String name, Object value) {\n\n        // Name cannot be null\n        if (name == null)\n            throw new IllegalArgumentException\n                (sm.getString(\"coyoteRequest.setAttribute.namenull\"));\n\n        // Null value is the same as removeAttribute()\n        if (value == null) {\n            removeAttribute(name);\n            return;\n        }\n\n        if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {\n            internalDispatcherType = (DispatcherType)value;\n            return;\n        } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {\n            requestDispatcherPath = value;\n            return;\n        }\n        \n        if (name.equals(Globals.ASYNC_SUPPORTED_ATTR)) {\n            this.asyncSupported = (Boolean)value;\n        }\n\n        Object oldValue = null;\n        boolean replaced = false;\n\n        // Add or replace the specified attribute\n        // Check for read only attribute\n        // requests are per thread so synchronization unnecessary\n        if (readOnlyAttributes.containsKey(name)) {\n            return;\n        }\n\n        oldValue = attributes.put(name, value);\n        if (oldValue != null) {\n            replaced = true;\n        }\n\n        // Pass special attributes to the native layer\n        if (name.startsWith(\"org.apache.tomcat.\")) {\n            coyoteRequest.setAttribute(name, value);\n        }\n        \n        // Notify interested application event listeners\n        Object listeners[] = context.getApplicationEventListeners();\n        if ((listeners == null) || (listeners.length == 0))\n            return;\n        ServletRequestAttributeEvent event = null;\n        if (replaced)\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, oldValue);\n        else\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, value);\n\n        for (int i = 0; i < listeners.length; i++) {\n            if (!(listeners[i] instanceof ServletRequestAttributeListener))\n                continue;\n            ServletRequestAttributeListener listener =\n                (ServletRequestAttributeListener) listeners[i];\n            try {\n                if (replaced) {\n                    listener.attributeReplaced(event);\n                } else {\n                    listener.attributeAdded(event);\n                }\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                context.getLogger().error(sm.getString(\"coyoteRequest.attributeEvent\"), t);\n                // Error valve will pick this exception up and display it to user\n                attributes.put(RequestDispatcher.ERROR_EXCEPTION, t );\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "setAttribute", "(", "String", "name", ",", "Object", "value", ")", "{", "if", "(", "name", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "sm", ".", "getString", "(", "\"", "coyoteRequest.setAttribute.namenull", "\"", ")", ")", ";", "if", "(", "value", "==", "null", ")", "{", "removeAttribute", "(", "name", ")", ";", "return", ";", "}", "if", "(", "name", ".", "equals", "(", "Globals", ".", "DISPATCHER_TYPE_ATTR", ")", ")", "{", "internalDispatcherType", "=", "(", "DispatcherType", ")", "value", ";", "return", ";", "}", "else", "if", "(", "name", ".", "equals", "(", "Globals", ".", "DISPATCHER_REQUEST_PATH_ATTR", ")", ")", "{", "requestDispatcherPath", "=", "value", ";", "return", ";", "}", "if", "(", "name", ".", "equals", "(", "Globals", ".", "ASYNC_SUPPORTED_ATTR", ")", ")", "{", "this", ".", "asyncSupported", "=", "(", "Boolean", ")", "value", ";", "}", "Object", "oldValue", "=", "null", ";", "boolean", "replaced", "=", "false", ";", "if", "(", "readOnlyAttributes", ".", "containsKey", "(", "name", ")", ")", "{", "return", ";", "}", "oldValue", "=", "attributes", ".", "put", "(", "name", ",", "value", ")", ";", "if", "(", "oldValue", "!=", "null", ")", "{", "replaced", "=", "true", ";", "}", "if", "(", "name", ".", "startsWith", "(", "\"", "org.apache.tomcat.", "\"", ")", ")", "{", "coyoteRequest", ".", "setAttribute", "(", "name", ",", "value", ")", ";", "}", "Object", "listeners", "[", "]", "=", "context", ".", "getApplicationEventListeners", "(", ")", ";", "if", "(", "(", "listeners", "==", "null", ")", "||", "(", "listeners", ".", "length", "==", "0", ")", ")", "return", ";", "ServletRequestAttributeEvent", "event", "=", "null", ";", "if", "(", "replaced", ")", "event", "=", "new", "ServletRequestAttributeEvent", "(", "context", ".", "getServletContext", "(", ")", ",", "getRequest", "(", ")", ",", "name", ",", "oldValue", ")", ";", "else", "event", "=", "new", "ServletRequestAttributeEvent", "(", "context", ".", "getServletContext", "(", ")", ",", "getRequest", "(", ")", ",", "name", ",", "value", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "listeners", ".", "length", ";", "i", "++", ")", "{", "if", "(", "!", "(", "listeners", "[", "i", "]", "instanceof", "ServletRequestAttributeListener", ")", ")", "continue", ";", "ServletRequestAttributeListener", "listener", "=", "(", "ServletRequestAttributeListener", ")", "listeners", "[", "i", "]", ";", "try", "{", "if", "(", "replaced", ")", "{", "listener", ".", "attributeReplaced", "(", "event", ")", ";", "}", "else", "{", "listener", ".", "attributeAdded", "(", "event", ")", ";", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "t", ")", ";", "context", ".", "getLogger", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "coyoteRequest.attributeEvent", "\"", ")", ",", "t", ")", ";", "attributes", ".", "put", "(", "RequestDispatcher", ".", "ERROR_EXCEPTION", ",", "t", ")", ";", "}", "}", "}"], "idx": 8100, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "2e69497fa7b1444632c6dadb64a4a82e18478ee6", "function_name": "setAttribute", "body_hash": "c19007b560411b6d30a027c9bbebd94e77a3596c"}
{"code": "private File createTemporaryFolderIn(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < TEMP_DIR_ATTEMPTS; ++i) {\n            // Use createTempFile to get a suitable folder name.\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);\n            String tmpName = tmpFile.toString();\n            // Discard .tmp suffix of tmpName.\n            String folderName = tmpName.substring(0, tmpName.length() - suffix.length());\n            createdFolder = new File(folderName);\n            if (createdFolder.mkdir()) {\n                tmpFile.delete();\n                return createdFolder;\n            }\n            tmpFile.delete();\n        }\n        throw new IOException(\"Unable to create temporary directory in: \"\n            + parentFolder.toString() + \". Tried \" + TEMP_DIR_ATTEMPTS + \" times. \"\n            + \"Last attempted to create: \" + createdFolder.toString());\n    }", "code_tokens": ["private", "File", "createTemporaryFolderIn", "(", "File", "parentFolder", ")", "throws", "IOException", "{", "File", "createdFolder", "=", "null", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "TEMP_DIR_ATTEMPTS", ";", "++", "i", ")", "{", "String", "suffix", "=", "\"", ".tmp", "\"", ";", "File", "tmpFile", "=", "File", ".", "createTempFile", "(", "TMP_PREFIX", ",", "suffix", ",", "parentFolder", ")", ";", "String", "tmpName", "=", "tmpFile", ".", "toString", "(", ")", ";", "String", "folderName", "=", "tmpName", ".", "substring", "(", "0", ",", "tmpName", ".", "length", "(", ")", "-", "suffix", ".", "length", "(", ")", ")", ";", "createdFolder", "=", "new", "File", "(", "folderName", ")", ";", "if", "(", "createdFolder", ".", "mkdir", "(", ")", ")", "{", "tmpFile", ".", "delete", "(", ")", ";", "return", "createdFolder", ";", "}", "tmpFile", ".", "delete", "(", ")", ";", "}", "throw", "new", "IOException", "(", "\"", "Unable to create temporary directory in: ", "\"", "+", "parentFolder", ".", "toString", "(", ")", "+", "\"", ". Tried ", "\"", "+", "TEMP_DIR_ATTEMPTS", "+", "\"", " times. ", "\"", "+", "\"", "Last attempted to create: ", "\"", "+", "createdFolder", ".", "toString", "(", ")", ")", ";", "}"], "idx": 72810, "cwe": "CWE-732", "target": 1, "status": "VULNERABLE", "commit": "610155b8c22138329f0723eec22521627dbc52ae", "function_name": "createTemporaryFolderIn", "body_hash": "cb9627657d0420311d47763b169fd32688d49add"}
{"code": "public static @Nonnull ConfidentialStore get() {\n        if (TEST!=null) return TEST.get();\n        return Jenkins.getInstance().getExtensionList(ConfidentialStore.class).get(0);\n    }", "code_tokens": ["public", "static", "@", "Nonnull", "ConfidentialStore", "get", "(", ")", "{", "if", "(", "TEST", "!=", "null", ")", "return", "TEST", ".", "get", "(", ")", ";", "return", "Jenkins", ".", "getInstance", "(", ")", ".", "getExtensionList", "(", "ConfidentialStore", ".", "class", ")", ".", "get", "(", "0", ")", ";", "}"], "idx": 99419, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "c3d8e05a1b3d58b6c4dcff97394cb3a79608b4b2", "function_name": "get", "body_hash": "8359baceb8bb790692a4b832a487ab08bff9b308"}
{"code": "protected void run() {\n        JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();\n        sf.setResourceClasses(MultipartStore.class);\n        \n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(AttachmentDeserializer.ATTACHMENT_MAX_SIZE, String.valueOf(1024 * 10));\n        props.put(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD, String.valueOf(1024 * 5));\n        sf.setProperties(props);\n        //default lifecycle is per-request, change it to singleton\n        sf.setResourceProvider(MultipartStore.class,\n                               new SingletonResourceProvider(new MultipartStore()));\n        sf.setAddress(\"http://localhost:\" + PORT + \"/\");\n\n        server = sf.create();        \n    }", "code_tokens": ["protected", "void", "run", "(", ")", "{", "JAXRSServerFactoryBean", "sf", "=", "new", "JAXRSServerFactoryBean", "(", ")", ";", "sf", ".", "setResourceClasses", "(", "MultipartStore", ".", "class", ")", ";", "Map", "<", "String", ",", "Object", ">", "props", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MAX_SIZE", ",", "String", ".", "valueOf", "(", "1024", "*", "10", ")", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MEMORY_THRESHOLD", ",", "String", ".", "valueOf", "(", "1024", "*", "5", ")", ")", ";", "sf", ".", "setProperties", "(", "props", ")", ";", "sf", ".", "setResourceProvider", "(", "MultipartStore", ".", "class", ",", "new", "SingletonResourceProvider", "(", "new", "MultipartStore", "(", ")", ")", ")", ";", "sf", ".", "setAddress", "(", "\"", "http://localhost:", "\"", "+", "PORT", "+", "\"", "/", "\"", ")", ";", "server", "=", "sf", ".", "create", "(", ")", ";", "}"], "idx": 107979, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "896bd961cbbb6b8569700e5b70229f78f94ad9d", "function_name": "run", "body_hash": "444940b912432c8467d61f58c39c0ab7a68a97ad"}
{"code": "@Override\n    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName) throws InvocationTargetException {\n        try {\n            SecureDigester digester = new SecureDigester(PmdParser.class);\n\n            String rootXPath = \"pmd\";\n            digester.addObjectCreate(rootXPath, Pmd.class);\n            digester.addSetProperties(rootXPath);\n\n            String fileXPath = \"pmd/file\";\n            digester.addObjectCreate(fileXPath, hudson.plugins.pmd.parser.File.class);\n            digester.addSetProperties(fileXPath);\n            digester.addSetNext(fileXPath, \"addFile\", hudson.plugins.pmd.parser.File.class.getName());\n\n            String bugXPath = \"pmd/file/violation\";\n            digester.addObjectCreate(bugXPath, Violation.class);\n            digester.addSetProperties(bugXPath);\n            digester.addCallMethod(bugXPath, \"setMessage\", 0);\n            digester.addSetNext(bugXPath, \"addViolation\", Violation.class.getName());\n\n            Pmd module = (Pmd)digester.parse(file);\n            if (module == null) {\n                throw new SAXException(\"Input stream is not a PMD file.\");\n            }\n\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }", "code_tokens": ["@", "Override", "public", "Collection", "<", "FileAnnotation", ">", "parse", "(", "final", "InputStream", "file", ",", "final", "String", "moduleName", ")", "throws", "InvocationTargetException", "{", "try", "{", "SecureDigester", "digester", "=", "new", "SecureDigester", "(", "PmdParser", ".", "class", ")", ";", "String", "rootXPath", "=", "\"", "pmd", "\"", ";", "digester", ".", "addObjectCreate", "(", "rootXPath", ",", "Pmd", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "rootXPath", ")", ";", "String", "fileXPath", "=", "\"", "pmd/file", "\"", ";", "digester", ".", "addObjectCreate", "(", "fileXPath", ",", "hudson", ".", "plugins", ".", "pmd", ".", "parser", ".", "File", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "fileXPath", ")", ";", "digester", ".", "addSetNext", "(", "fileXPath", ",", "\"", "addFile", "\"", ",", "hudson", ".", "plugins", ".", "pmd", ".", "parser", ".", "File", ".", "class", ".", "getName", "(", ")", ")", ";", "String", "bugXPath", "=", "\"", "pmd/file/violation", "\"", ";", "digester", ".", "addObjectCreate", "(", "bugXPath", ",", "Violation", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "bugXPath", ")", ";", "digester", ".", "addCallMethod", "(", "bugXPath", ",", "\"", "setMessage", "\"", ",", "0", ")", ";", "digester", ".", "addSetNext", "(", "bugXPath", ",", "\"", "addViolation", "\"", ",", "Violation", ".", "class", ".", "getName", "(", ")", ")", ";", "Pmd", "module", "=", "(", "Pmd", ")", "digester", ".", "parse", "(", "file", ")", ";", "if", "(", "module", "==", "null", ")", "{", "throw", "new", "SAXException", "(", "\"", "Input stream is not a PMD file.", "\"", ")", ";", "}", "return", "convert", "(", "module", ",", "moduleName", ")", ";", "}", "catch", "(", "IOException", "exception", ")", "{", "throw", "new", "InvocationTargetException", "(", "exception", ")", ";", "}", "catch", "(", "SAXException", "exception", ")", "{", "throw", "new", "InvocationTargetException", "(", "exception", ")", ";", "}", "}"], "idx": 70025, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "f88399a021c22e30cb8fbac5200471d69f1b6224", "function_name": "parse", "body_hash": "389774599bdeb49cb355f8b48af72b0ae7391d0f"}
{"code": "public void doDisable(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        disable(true);\n        rsp.sendRedirect2(req.getContextPath()+\"/manage\");\n    }", "code_tokens": ["public", "void", "doDisable", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", "{", "Jenkins", ".", "getInstance", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "disable", "(", "true", ")", ";", "rsp", ".", "sendRedirect2", "(", "req", ".", "getContextPath", "(", ")", "+", "\"", "/manage", "\"", ")", ";", "}"], "idx": 38603, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "6efcf6c2ac39bc5c59ac7251822be8ddf67ceaf8", "function_name": "doDisable", "body_hash": "82a9623e9495a72c597b28fdc52e937de2755f76"}
{"code": "private String getSkinResourcePath(String resource)\n    {\n        String skinFolder = getSkinFolder();\n        String resourcePath = skinFolder + resource;\n\n        // Prevent access to resources from other directories\n        Path normalizedResource = Paths.get(resourcePath).normalize();\n        // Protect against directory attacks.\n        if (!normalizedResource.startsWith(skinFolder)) {\n            LOGGER.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);\n            return null;\n        }\n\n        return resourcePath;\n    }", "code_tokens": ["private", "String", "getSkinResourcePath", "(", "String", "resource", ")", "{", "String", "skinFolder", "=", "getSkinFolder", "(", ")", ";", "String", "resourcePath", "=", "skinFolder", "+", "resource", ";", "Path", "normalizedResource", "=", "Paths", ".", "get", "(", "resourcePath", ")", ".", "normalize", "(", ")", ";", "if", "(", "!", "normalizedResource", ".", "startsWith", "(", "skinFolder", ")", ")", "{", "LOGGER", ".", "warn", "(", "\"", "Direct access to skin file [{}] refused. Possible break-in attempt!", "\"", ",", "normalizedResource", ")", ";", "return", "null", ";", "}", "return", "resourcePath", ";", "}"], "idx": 28850, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "4917c8f355717bb636d763844528b1fe0f95e8e2", "function_name": "getSkinResourcePath", "body_hash": "c6930989dd9b8e55a63aa78f721bdb5c3f5812e2"}
{"code": "protected void serveResource(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 boolean content,\n                                 String encoding)\n        throws IOException, ServletException {\n\n        boolean serveContent = content;\n\n        // Identify the requested resource path\n        String path = getRelativePath(request, true);\n\n        if (debug > 0) {\n            if (serveContent)\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers and data\");\n            else\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers only\");\n        }\n\n        if (path.length() == 0) {\n            // Context root redirect\n            doDirectoryRedirect(request, response);\n            return;\n        }\n\n        WebResource resource = resources.getResource(path);\n\n        if (!resource.exists()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // SRV.9.3 says we must throw a FNFE\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        if (!resource.canRead()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // Spec doesn't say what to do in this case but a FNFE seems\n                // reasonable\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestUri);\n            return;\n        }\n\n        // If the resource is not a collection, and the resource path\n        // ends with \"/\" or \"\\\", return NOT FOUND\n        if (resource.isFile() && (path.endsWith(\"/\") || path.endsWith(\"\\\\\"))) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            }\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        boolean isError = response.getStatus() >= HttpServletResponse.SC_BAD_REQUEST;\n\n        boolean included = false;\n        // Check if the conditions specified in the optional If headers are\n        // satisfied.\n        if (resource.isFile()) {\n            // Checking If headers\n            included = (request.getAttribute(\n                    RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\n            if (!included && !isError && !checkIfHeaders(request, response, resource)) {\n                return;\n            }\n        }\n\n        // Find content type.\n        String contentType = resource.getMimeType();\n        if (contentType == null) {\n            contentType = getServletContext().getMimeType(resource.getName());\n            resource.setMimeType(contentType);\n        }\n\n        // These need to reflect the original resource, not the potentially\n        // precompressed version of the resource so get them now if they are going to\n        // be needed later\n        String eTag = null;\n        String lastModifiedHttp = null;\n        if (resource.isFile() && !isError) {\n            eTag = resource.getETag();\n            lastModifiedHttp = resource.getLastModifiedHttp();\n        }\n\n\n        // Serve a precompressed version of the file if present\n        boolean usingPrecompressedVersion = false;\n        if (compressionFormats.length > 0 && !included && resource.isFile() &&\n                !pathEndsWithCompressedExtension(path)) {\n            List<PrecompressedResource> precompressedResources =\n                    getAvailablePrecompressedResources(path);\n            if (!precompressedResources.isEmpty()) {\n                Collection<String> varyHeaders = response.getHeaders(\"Vary\");\n                boolean addRequired = true;\n                for (String varyHeader : varyHeaders) {\n                    if (\"*\".equals(varyHeader) ||\n                            \"accept-encoding\".equalsIgnoreCase(varyHeader)) {\n                        addRequired = false;\n                        break;\n                    }\n                }\n                if (addRequired) {\n                    response.addHeader(\"Vary\", \"accept-encoding\");\n                }\n                PrecompressedResource bestResource =\n                        getBestPrecompressedResource(request, precompressedResources);\n                if (bestResource != null) {\n                    response.addHeader(\"Content-Encoding\", bestResource.format.encoding);\n                    resource = bestResource.resource;\n                    usingPrecompressedVersion = true;\n                }\n            }\n        }\n\n        ArrayList<Range> ranges = null;\n        long contentLength = -1L;\n\n        if (resource.isDirectory()) {\n            if (!path.endsWith(\"/\")) {\n                doDirectoryRedirect(request, response);\n                return;\n            }\n\n            // Skip directory listings if we have been configured to\n            // suppress them\n            if (!listings) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                   request.getRequestURI());\n                return;\n            }\n            contentType = \"text/html;charset=UTF-8\";\n        } else {\n            if (!isError) {\n                if (useAcceptRanges) {\n                    // Accept ranges header\n                    response.setHeader(\"Accept-Ranges\", \"bytes\");\n                }\n\n                // Parse range specifier\n                ranges = parseRange(request, response, resource);\n\n                // ETag header\n                response.setHeader(\"ETag\", eTag);\n\n                // Last-Modified header\n                response.setHeader(\"Last-Modified\", lastModifiedHttp);\n            }\n\n            // Get content length\n            contentLength = resource.getContentLength();\n            // Special case for zero length files, which would cause a\n            // (silent) ISE when setting the output buffer size\n            if (contentLength == 0L) {\n                serveContent = false;\n            }\n        }\n\n        ServletOutputStream ostream = null;\n        PrintWriter writer = null;\n\n        if (serveContent) {\n            // Trying to retrieve the servlet output stream\n            try {\n                ostream = response.getOutputStream();\n            } catch (IllegalStateException e) {\n                // If it fails, we try to get a Writer instead if we're\n                // trying to serve a text file\n                if (!usingPrecompressedVersion &&\n                        ((contentType == null) ||\n                                (contentType.startsWith(\"text\")) ||\n                                (contentType.endsWith(\"xml\")) ||\n                                (contentType.contains(\"/javascript\")))\n                        ) {\n                    writer = response.getWriter();\n                    // Cannot reliably serve partial content with a Writer\n                    ranges = FULL;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // Check to see if a Filter, Valve of wrapper has written some content.\n        // If it has, disable range requests and setting of a content length\n        // since neither can be done reliably.\n        ServletResponse r = response;\n        long contentWritten = 0;\n        while (r instanceof ServletResponseWrapper) {\n            r = ((ServletResponseWrapper) r).getResponse();\n        }\n        if (r instanceof ResponseFacade) {\n            contentWritten = ((ResponseFacade) r).getContentWritten();\n        }\n        if (contentWritten > 0) {\n            ranges = FULL;\n        }\n\n        if (resource.isDirectory() ||\n                isError ||\n                ( (ranges == null || ranges.isEmpty())\n                        && request.getHeader(\"Range\") == null ) ||\n                ranges == FULL ) {\n\n            // Set the appropriate output headers\n            if (contentType != null) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentType='\" +\n                        contentType + \"'\");\n                response.setContentType(contentType);\n            }\n            if (resource.isFile() && contentLength >= 0 &&\n                    (!serveContent || ostream != null)) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentLength=\" +\n                        contentLength);\n                // Don't set a content length if something else has already\n                // written to the response.\n                if (contentWritten == 0) {\n                    response.setContentLengthLong(contentLength);\n                }\n            }\n\n            if (serveContent) {\n                try {\n                    response.setBufferSize(output);\n                } catch (IllegalStateException e) {\n                    // Silent catch\n                }\n                InputStream renderResult = null;\n                if (ostream == null) {\n                    // Output via a writer so can't use sendfile or write\n                    // content directly.\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        renderResult = resource.getInputStream();\n                    }\n                    copy(resource, renderResult, writer, encoding);\n                } else {\n                    // Output is via an InputStream\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        // Output is content of resource\n                        if (!checkSendfile(request, response, resource,\n                                contentLength, null)) {\n                            // sendfile not possible so check if resource\n                            // content is available directly\n                            byte[] resourceBody = resource.getContent();\n                            if (resourceBody == null) {\n                                // Resource content not available, use\n                                // inputstream\n                                renderResult = resource.getInputStream();\n                            } else {\n                                // Use the resource content directly\n                                ostream.write(resourceBody);\n                            }\n                        }\n                    }\n                    // If a stream was configured, it needs to be copied to\n                    // the output (this method closes the stream)\n                    if (renderResult != null) {\n                        copy(resource, renderResult, ostream);\n                    }\n                }\n            }\n\n        } else {\n\n            if ((ranges == null) || (ranges.isEmpty()))\n                return;\n\n            // Partial content response.\n\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n            if (ranges.size() == 1) {\n\n                Range range = ranges.get(0);\n                response.addHeader(\"Content-Range\", \"bytes \"\n                                   + range.start\n                                   + \"-\" + range.end + \"/\"\n                                   + range.length);\n                long length = range.end - range.start + 1;\n                response.setContentLengthLong(length);\n\n                if (contentType != null) {\n                    if (debug > 0)\n                        log(\"DefaultServlet.serveFile:  contentType='\" +\n                            contentType + \"'\");\n                    response.setContentType(contentType);\n                }\n\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        if (!checkSendfile(request, response, resource,\n                                range.end - range.start + 1, range))\n                            copy(resource, ostream, range);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            } else {\n                response.setContentType(\"multipart/byteranges; boundary=\"\n                                        + mimeSeparation);\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        copy(resource, ostream, ranges.iterator(), contentType);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "serveResource", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "boolean", "content", ",", "String", "encoding", ")", "throws", "IOException", ",", "ServletException", "{", "boolean", "serveContent", "=", "content", ";", "String", "path", "=", "getRelativePath", "(", "request", ",", "true", ")", ";", "if", "(", "debug", ">", "0", ")", "{", "if", "(", "serveContent", ")", "log", "(", "\"", "DefaultServlet.serveResource:  Serving resource '", "\"", "+", "path", "+", "\"", "' headers and data", "\"", ")", ";", "else", "log", "(", "\"", "DefaultServlet.serveResource:  Serving resource '", "\"", "+", "path", "+", "\"", "' headers only", "\"", ")", ";", "}", "if", "(", "path", ".", "length", "(", ")", "==", "0", ")", "{", "doDirectoryRedirect", "(", "request", ",", "response", ")", ";", "return", ";", "}", "WebResource", "resource", "=", "resources", ".", "getResource", "(", "path", ")", ";", "if", "(", "!", "resource", ".", "exists", "(", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "else", "{", "throw", "new", "FileNotFoundException", "(", "sm", ".", "getString", "(", "\"", "defaultServlet.missingResource", "\"", ",", "requestUri", ")", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "requestUri", ")", ";", "return", ";", "}", "if", "(", "!", "resource", ".", "canRead", "(", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "else", "{", "throw", "new", "FileNotFoundException", "(", "sm", ".", "getString", "(", "\"", "defaultServlet.missingResource", "\"", ",", "requestUri", ")", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ",", "requestUri", ")", ";", "return", ";", "}", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "(", "path", ".", "endsWith", "(", "\"", "/", "\"", ")", "||", "path", ".", "endsWith", "(", "\"", "\\\\", "\"", ")", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "requestUri", ")", ";", "return", ";", "}", "boolean", "isError", "=", "response", ".", "getStatus", "(", ")", ">=", "HttpServletResponse", ".", "SC_BAD_REQUEST", ";", "boolean", "included", "=", "false", ";", "if", "(", "resource", ".", "isFile", "(", ")", ")", "{", "included", "=", "(", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_CONTEXT_PATH", ")", "!=", "null", ")", ";", "if", "(", "!", "included", "&&", "!", "isError", "&&", "!", "checkIfHeaders", "(", "request", ",", "response", ",", "resource", ")", ")", "{", "return", ";", "}", "}", "String", "contentType", "=", "resource", ".", "getMimeType", "(", ")", ";", "if", "(", "contentType", "==", "null", ")", "{", "contentType", "=", "getServletContext", "(", ")", ".", "getMimeType", "(", "resource", ".", "getName", "(", ")", ")", ";", "resource", ".", "setMimeType", "(", "contentType", ")", ";", "}", "String", "eTag", "=", "null", ";", "String", "lastModifiedHttp", "=", "null", ";", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "!", "isError", ")", "{", "eTag", "=", "resource", ".", "getETag", "(", ")", ";", "lastModifiedHttp", "=", "resource", ".", "getLastModifiedHttp", "(", ")", ";", "}", "boolean", "usingPrecompressedVersion", "=", "false", ";", "if", "(", "compressionFormats", ".", "length", ">", "0", "&&", "!", "included", "&&", "resource", ".", "isFile", "(", ")", "&&", "!", "pathEndsWithCompressedExtension", "(", "path", ")", ")", "{", "List", "<", "PrecompressedResource", ">", "precompressedResources", "=", "getAvailablePrecompressedResources", "(", "path", ")", ";", "if", "(", "!", "precompressedResources", ".", "isEmpty", "(", ")", ")", "{", "Collection", "<", "String", ">", "varyHeaders", "=", "response", ".", "getHeaders", "(", "\"", "Vary", "\"", ")", ";", "boolean", "addRequired", "=", "true", ";", "for", "(", "String", "varyHeader", ":", "varyHeaders", ")", "{", "if", "(", "\"", "*", "\"", ".", "equals", "(", "varyHeader", ")", "||", "\"", "accept-encoding", "\"", ".", "equalsIgnoreCase", "(", "varyHeader", ")", ")", "{", "addRequired", "=", "false", ";", "break", ";", "}", "}", "if", "(", "addRequired", ")", "{", "response", ".", "addHeader", "(", "\"", "Vary", "\"", ",", "\"", "accept-encoding", "\"", ")", ";", "}", "PrecompressedResource", "bestResource", "=", "getBestPrecompressedResource", "(", "request", ",", "precompressedResources", ")", ";", "if", "(", "bestResource", "!=", "null", ")", "{", "response", ".", "addHeader", "(", "\"", "Content-Encoding", "\"", ",", "bestResource", ".", "format", ".", "encoding", ")", ";", "resource", "=", "bestResource", ".", "resource", ";", "usingPrecompressedVersion", "=", "true", ";", "}", "}", "}", "ArrayList", "<", "Range", ">", "ranges", "=", "null", ";", "long", "contentLength", "=", "-", "1L", ";", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "path", ".", "endsWith", "(", "\"", "/", "\"", ")", ")", "{", "doDirectoryRedirect", "(", "request", ",", "response", ")", ";", "return", ";", "}", "if", "(", "!", "listings", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "request", ".", "getRequestURI", "(", ")", ")", ";", "return", ";", "}", "contentType", "=", "\"", "text/html;charset=UTF-8", "\"", ";", "}", "else", "{", "if", "(", "!", "isError", ")", "{", "if", "(", "useAcceptRanges", ")", "{", "response", ".", "setHeader", "(", "\"", "Accept-Ranges", "\"", ",", "\"", "bytes", "\"", ")", ";", "}", "ranges", "=", "parseRange", "(", "request", ",", "response", ",", "resource", ")", ";", "response", ".", "setHeader", "(", "\"", "ETag", "\"", ",", "eTag", ")", ";", "response", ".", "setHeader", "(", "\"", "Last-Modified", "\"", ",", "lastModifiedHttp", ")", ";", "}", "contentLength", "=", "resource", ".", "getContentLength", "(", ")", ";", "if", "(", "contentLength", "==", "0L", ")", "{", "serveContent", "=", "false", ";", "}", "}", "ServletOutputStream", "ostream", "=", "null", ";", "PrintWriter", "writer", "=", "null", ";", "if", "(", "serveContent", ")", "{", "try", "{", "ostream", "=", "response", ".", "getOutputStream", "(", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "if", "(", "!", "usingPrecompressedVersion", "&&", "(", "(", "contentType", "==", "null", ")", "||", "(", "contentType", ".", "startsWith", "(", "\"", "text", "\"", ")", ")", "||", "(", "contentType", ".", "endsWith", "(", "\"", "xml", "\"", ")", ")", "||", "(", "contentType", ".", "contains", "(", "\"", "/javascript", "\"", ")", ")", ")", ")", "{", "writer", "=", "response", ".", "getWriter", "(", ")", ";", "ranges", "=", "FULL", ";", "}", "else", "{", "throw", "e", ";", "}", "}", "}", "ServletResponse", "r", "=", "response", ";", "long", "contentWritten", "=", "0", ";", "while", "(", "r", "instanceof", "ServletResponseWrapper", ")", "{", "r", "=", "(", "(", "ServletResponseWrapper", ")", "r", ")", ".", "getResponse", "(", ")", ";", "}", "if", "(", "r", "instanceof", "ResponseFacade", ")", "{", "contentWritten", "=", "(", "(", "ResponseFacade", ")", "r", ")", ".", "getContentWritten", "(", ")", ";", "}", "if", "(", "contentWritten", ">", "0", ")", "{", "ranges", "=", "FULL", ";", "}", "if", "(", "resource", ".", "isDirectory", "(", ")", "||", "isError", "||", "(", "(", "ranges", "==", "null", "||", "ranges", ".", "isEmpty", "(", ")", ")", "&&", "request", ".", "getHeader", "(", "\"", "Range", "\"", ")", "==", "null", ")", "||", "ranges", "==", "FULL", ")", "{", "if", "(", "contentType", "!=", "null", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentType='", "\"", "+", "contentType", "+", "\"", "'", "\"", ")", ";", "response", ".", "setContentType", "(", "contentType", ")", ";", "}", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "contentLength", ">=", "0", "&&", "(", "!", "serveContent", "||", "ostream", "!=", "null", ")", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentLength=", "\"", "+", "contentLength", ")", ";", "if", "(", "contentWritten", "==", "0", ")", "{", "response", ".", "setContentLengthLong", "(", "contentLength", ")", ";", "}", "}", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "InputStream", "renderResult", "=", "null", ";", "if", "(", "ostream", "==", "null", ")", "{", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "renderResult", "=", "render", "(", "getPathPrefix", "(", "request", ")", ",", "resource", ",", "encoding", ")", ";", "}", "else", "{", "renderResult", "=", "resource", ".", "getInputStream", "(", ")", ";", "}", "copy", "(", "resource", ",", "renderResult", ",", "writer", ",", "encoding", ")", ";", "}", "else", "{", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "renderResult", "=", "render", "(", "getPathPrefix", "(", "request", ")", ",", "resource", ",", "encoding", ")", ";", "}", "else", "{", "if", "(", "!", "checkSendfile", "(", "request", ",", "response", ",", "resource", ",", "contentLength", ",", "null", ")", ")", "{", "byte", "[", "]", "resourceBody", "=", "resource", ".", "getContent", "(", ")", ";", "if", "(", "resourceBody", "==", "null", ")", "{", "renderResult", "=", "resource", ".", "getInputStream", "(", ")", ";", "}", "else", "{", "ostream", ".", "write", "(", "resourceBody", ")", ";", "}", "}", "}", "if", "(", "renderResult", "!=", "null", ")", "{", "copy", "(", "resource", ",", "renderResult", ",", "ostream", ")", ";", "}", "}", "}", "}", "else", "{", "if", "(", "(", "ranges", "==", "null", ")", "||", "(", "ranges", ".", "isEmpty", "(", ")", ")", ")", "return", ";", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_PARTIAL_CONTENT", ")", ";", "if", "(", "ranges", ".", "size", "(", ")", "==", "1", ")", "{", "Range", "range", "=", "ranges", ".", "get", "(", "0", ")", ";", "response", ".", "addHeader", "(", "\"", "Content-Range", "\"", ",", "\"", "bytes ", "\"", "+", "range", ".", "start", "+", "\"", "-", "\"", "+", "range", ".", "end", "+", "\"", "/", "\"", "+", "range", ".", "length", ")", ";", "long", "length", "=", "range", ".", "end", "-", "range", ".", "start", "+", "1", ";", "response", ".", "setContentLengthLong", "(", "length", ")", ";", "if", "(", "contentType", "!=", "null", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentType='", "\"", "+", "contentType", "+", "\"", "'", "\"", ")", ";", "response", ".", "setContentType", "(", "contentType", ")", ";", "}", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "if", "(", "ostream", "!=", "null", ")", "{", "if", "(", "!", "checkSendfile", "(", "request", ",", "response", ",", "resource", ",", "range", ".", "end", "-", "range", ".", "start", "+", "1", ",", "range", ")", ")", "copy", "(", "resource", ",", "ostream", ",", "range", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "}", "}", "else", "{", "response", ".", "setContentType", "(", "\"", "multipart/byteranges; boundary=", "\"", "+", "mimeSeparation", ")", ";", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "if", "(", "ostream", "!=", "null", ")", "{", "copy", "(", "resource", ",", "ostream", ",", "ranges", ".", "iterator", "(", ")", ",", "contentType", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "}", "}", "}", "}"], "idx": 74456, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "4545dcce444aa619374a659cb450dbbd0be3c921", "function_name": "serveResource", "body_hash": "dbf8533f39b8ec007726b5730224eca399e6df98"}
{"code": "public void processPacket(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return;\n\n            org.jivesoftware.smack.packet.Message msg =\n                (org.jivesoftware.smack.packet.Message)packet;\n\n            boolean isForwardedSentMessage = false;\n            if(msg.getBody() == null)\n            {\n\n                CarbonPacketExtension carbonExt\n                    = (CarbonPacketExtension) msg.getExtension(\n                        CarbonPacketExtension.NAMESPACE);\n                if(carbonExt == null)\n                    return;\n\n                isForwardedSentMessage\n                    = (carbonExt.getElementName()\n                        == CarbonPacketExtension.SENT_ELEMENT_NAME);\n                List<ForwardedPacketExtension> extensions\n                    = carbonExt.getChildExtensionsOfType(\n                        ForwardedPacketExtension.class);\n                if(extensions.isEmpty())\n                    return;\n                ForwardedPacketExtension forwardedExt = extensions.get(0);\n                msg = forwardedExt.getMessage();\n                if(msg == null || msg.getBody() == null)\n                    return;\n\n            }\n\n            Object multiChatExtension =\n                msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\n            // its not for us\n            if(multiChatExtension != null)\n                return;\n\n            String userFullId\n                = isForwardedSentMessage? msg.getTo() : msg.getFrom();\n\n            String userBareID = StringUtils.parseBareAddress(userFullId);\n\n            boolean isPrivateMessaging = false;\n            ChatRoom privateContactRoom = null;\n            OperationSetMultiUserChatJabberImpl mucOpSet =\n                (OperationSetMultiUserChatJabberImpl)jabberProvider\n                    .getOperationSet(OperationSetMultiUserChat.class);\n            if(mucOpSet != null)\n                privateContactRoom = mucOpSet.getChatRoom(userBareID);\n\n            if(privateContactRoom != null)\n            {\n                isPrivateMessaging = true;\n            }\n\n            if(logger.isDebugEnabled())\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Received from \"\n                             + userBareID\n                             + \" the message \"\n                             + msg.toXML());\n            }\n\n            Message newMessage = createMessage(msg.getBody(),\n                    DEFAULT_MIME_TYPE, msg.getPacketID());\n\n            //check if the message is available in xhtml\n            PacketExtension ext = msg.getExtension(\n                            \"http://jabber.org/protocol/xhtml-im\");\n\n            if(ext != null)\n            {\n                XHTMLExtension xhtmlExt\n                    = (XHTMLExtension)ext;\n\n                //parse all bodies\n                Iterator<String> bodies = xhtmlExt.getBodies();\n                StringBuffer messageBuff = new StringBuffer();\n                while (bodies.hasNext())\n                {\n                    String body = bodies.next();\n                    messageBuff.append(body);\n                }\n\n                if (messageBuff.length() > 0)\n                {\n                    // we remove body tags around message cause their\n                    // end body tag is breaking\n                    // the visualization as html in the UI\n                    String receivedMessage =\n                        messageBuff.toString()\n                        // removes body start tag\n                        .replaceAll(\"\\\\<[bB][oO][dD][yY].*?>\",\"\")\n                        // removes body end tag\n                        .replaceAll(\"\\\\</[bB][oO][dD][yY].*?>\",\"\");\n\n                    // for some reason &apos; is not rendered correctly\n                    // from our ui, lets use its equivalent. Other\n                    // similar chars(< > & \") seem ok.\n                    receivedMessage =\n                            receivedMessage.replaceAll(\"&apos;\", \"&#39;\");\n\n                    newMessage = createMessage(receivedMessage,\n                            HTML_MIME_TYPE, msg.getPacketID());\n                }\n            }\n\n            PacketExtension correctionExtension =\n                    msg.getExtension(MessageCorrectionExtension.NAMESPACE);\n            String correctedMessageUID = null;\n            if (correctionExtension != null)\n            {\n                correctedMessageUID = ((MessageCorrectionExtension)\n                        correctionExtension).getCorrectedMessageUID();\n            }\n\n            Contact sourceContact\n                = opSetPersPresence.findContactByID(\n                    (isPrivateMessaging? userFullId : userBareID));\n            if(msg.getType()\n                            == org.jivesoftware.smack.packet.Message.Type.error)\n            {\n                // error which is multichat and we don't know about the contact\n                // is a muc message error which is missing muc extension\n                // and is coming from the room, when we try to send message to\n                // room which was deleted or offline on the server\n                if(isPrivateMessaging && sourceContact == null)\n                {\n                    if(privateContactRoom != null)\n                    {\n                        XMPPError error = packet.getError();\n                        int errorResultCode\n                            = ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                        if(error != null && error.getCode() == 403)\n                        {\n                            errorResultCode\n                                = ChatRoomMessageDeliveryFailedEvent.FORBIDDEN;\n                        }\n\n                        String errorReason = error.getMessage();\n\n                        ChatRoomMessageDeliveryFailedEvent evt =\n                            new ChatRoomMessageDeliveryFailedEvent(\n                                privateContactRoom,\n                                null,\n                                errorResultCode,\n                                errorReason,\n                                new Date(),\n                                newMessage);\n                        ((ChatRoomJabberImpl)privateContactRoom)\n                            .fireMessageEvent(evt);\n                    }\n\n                    return;\n                }\n\n                if (logger.isInfoEnabled())\n                    logger.info(\"Message error received from \" + userBareID);\n\n                int errorResultCode = MessageDeliveryFailedEvent.UNKNOWN_ERROR;\n                if (packet.getError() != null)\n                {\n                    int errorCode = packet.getError().getCode();\n    \n                    if(errorCode == 503)\n                    {\n                        org.jivesoftware.smackx.packet.MessageEvent msgEvent =\n                            (org.jivesoftware.smackx.packet.MessageEvent)\n                                packet.getExtension(\"x\", \"jabber:x:event\");\n                        if(msgEvent != null && msgEvent.isOffline())\n                        {\n                            errorResultCode =\n                                MessageDeliveryFailedEvent\n                                    .OFFLINE_MESSAGES_NOT_SUPPORTED;\n                        }\n                    }\n                }\n\n                if (sourceContact == null)\n                {\n                    sourceContact = opSetPersPresence.createVolatileContact(\n                        userFullId, isPrivateMessaging);\n                }\n\n                MessageDeliveryFailedEvent ev\n                    = new MessageDeliveryFailedEvent(newMessage,\n                                                     sourceContact,\n                                                     correctedMessageUID,\n                                                     errorResultCode);\n\n                // ev = messageDeliveryFailedTransform(ev);\n\n                if (ev != null)\n                    fireMessageEvent(ev);\n                return;\n            }\n            putJidForAddress(userFullId, msg.getThread());\n\n            // In the second condition we filter all group chat messages,\n            // because they are managed by the multi user chat operation set.\n            if(sourceContact == null)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"received a message from an unknown contact: \"\n                                   + userBareID);\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(\n                        userFullId,\n                        isPrivateMessaging);\n            }\n\n            Date timestamp = new Date();\n            //Check for XEP-0091 timestamp (deprecated)\n            PacketExtension delay = msg.getExtension(\"x\", \"jabber:x:delay\");\n            if(delay != null && delay instanceof DelayInformation)\n            {\n                timestamp = ((DelayInformation)delay).getStamp();\n            }\n            //check for XEP-0203 timestamp\n            delay = msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n            if(delay != null && delay instanceof DelayInfo)\n            {\n                timestamp = ((DelayInfo)delay).getStamp();\n            }\n\n            ContactResource resource = ((ContactJabberImpl) sourceContact)\n                    .getResourceFromJid(userFullId);\n\n            EventObject msgEvt = null;\n            if(!isForwardedSentMessage)\n                msgEvt\n                    = new MessageReceivedEvent( newMessage,\n                                                sourceContact,\n                                                resource,\n                                                timestamp,\n                                                correctedMessageUID,\n                                                isPrivateMessaging,\n                                                privateContactRoom);\n            else\n                msgEvt = new MessageDeliveredEvent(newMessage, sourceContact, timestamp);\n            // msgReceivedEvt = messageReceivedTransform(msgReceivedEvt);\n            if (msgEvt != null)\n                fireMessageEvent(msgEvt);\n        }", "code_tokens": ["public", "void", "processPacket", "(", "Packet", "packet", ")", "{", "if", "(", "!", "(", "packet", "instanceof", "org", ".", "jivesoftware", ".", "smack", ".", "packet", ".", "Message", ")", ")", "return", ";", "org", ".", "jivesoftware", ".", "smack", ".", "packet", ".", "Message", "msg", "=", "(", "org", ".", "jivesoftware", ".", "smack", ".", "packet", ".", "Message", ")", "packet", ";", "boolean", "isForwardedSentMessage", "=", "false", ";", "if", "(", "msg", ".", "getBody", "(", ")", "==", "null", ")", "{", "CarbonPacketExtension", "carbonExt", "=", "(", "CarbonPacketExtension", ")", "msg", ".", "getExtension", "(", "CarbonPacketExtension", ".", "NAMESPACE", ")", ";", "if", "(", "carbonExt", "==", "null", ")", "return", ";", "isForwardedSentMessage", "=", "(", "carbonExt", ".", "getElementName", "(", ")", "==", "CarbonPacketExtension", ".", "SENT_ELEMENT_NAME", ")", ";", "List", "<", "ForwardedPacketExtension", ">", "extensions", "=", "carbonExt", ".", "getChildExtensionsOfType", "(", "ForwardedPacketExtension", ".", "class", ")", ";", "if", "(", "extensions", ".", "isEmpty", "(", ")", ")", "return", ";", "ForwardedPacketExtension", "forwardedExt", "=", "extensions", ".", "get", "(", "0", ")", ";", "msg", "=", "forwardedExt", ".", "getMessage", "(", ")", ";", "if", "(", "msg", "==", "null", "||", "msg", ".", "getBody", "(", ")", "==", "null", ")", "return", ";", "}", "Object", "multiChatExtension", "=", "msg", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "http://jabber.org/protocol/muc#user", "\"", ")", ";", "if", "(", "multiChatExtension", "!=", "null", ")", "return", ";", "String", "userFullId", "=", "isForwardedSentMessage", "?", "msg", ".", "getTo", "(", ")", ":", "msg", ".", "getFrom", "(", ")", ";", "String", "userBareID", "=", "StringUtils", ".", "parseBareAddress", "(", "userFullId", ")", ";", "boolean", "isPrivateMessaging", "=", "false", ";", "ChatRoom", "privateContactRoom", "=", "null", ";", "OperationSetMultiUserChatJabberImpl", "mucOpSet", "=", "(", "OperationSetMultiUserChatJabberImpl", ")", "jabberProvider", ".", "getOperationSet", "(", "OperationSetMultiUserChat", ".", "class", ")", ";", "if", "(", "mucOpSet", "!=", "null", ")", "privateContactRoom", "=", "mucOpSet", ".", "getChatRoom", "(", "userBareID", ")", ";", "if", "(", "privateContactRoom", "!=", "null", ")", "{", "isPrivateMessaging", "=", "true", ";", "}", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "logger", ".", "debug", "(", "\"", "Received from ", "\"", "+", "userBareID", "+", "\"", " the message ", "\"", "+", "msg", ".", "toXML", "(", ")", ")", ";", "}", "Message", "newMessage", "=", "createMessage", "(", "msg", ".", "getBody", "(", ")", ",", "DEFAULT_MIME_TYPE", ",", "msg", ".", "getPacketID", "(", ")", ")", ";", "PacketExtension", "ext", "=", "msg", ".", "getExtension", "(", "\"", "http://jabber.org/protocol/xhtml-im", "\"", ")", ";", "if", "(", "ext", "!=", "null", ")", "{", "XHTMLExtension", "xhtmlExt", "=", "(", "XHTMLExtension", ")", "ext", ";", "Iterator", "<", "String", ">", "bodies", "=", "xhtmlExt", ".", "getBodies", "(", ")", ";", "StringBuffer", "messageBuff", "=", "new", "StringBuffer", "(", ")", ";", "while", "(", "bodies", ".", "hasNext", "(", ")", ")", "{", "String", "body", "=", "bodies", ".", "next", "(", ")", ";", "messageBuff", ".", "append", "(", "body", ")", ";", "}", "if", "(", "messageBuff", ".", "length", "(", ")", ">", "0", ")", "{", "String", "receivedMessage", "=", "messageBuff", ".", "toString", "(", ")", ".", "replaceAll", "(", "\"", "\\\\", "<[bB][oO][dD][yY].*?>", "\"", ",", "\"", "\"", ")", ".", "replaceAll", "(", "\"", "\\\\", "</[bB][oO][dD][yY].*?>", "\"", ",", "\"", "\"", ")", ";", "receivedMessage", "=", "receivedMessage", ".", "replaceAll", "(", "\"", "&apos;", "\"", ",", "\"", "&#39;", "\"", ")", ";", "newMessage", "=", "createMessage", "(", "receivedMessage", ",", "HTML_MIME_TYPE", ",", "msg", ".", "getPacketID", "(", ")", ")", ";", "}", "}", "PacketExtension", "correctionExtension", "=", "msg", ".", "getExtension", "(", "MessageCorrectionExtension", ".", "NAMESPACE", ")", ";", "String", "correctedMessageUID", "=", "null", ";", "if", "(", "correctionExtension", "!=", "null", ")", "{", "correctedMessageUID", "=", "(", "(", "MessageCorrectionExtension", ")", "correctionExtension", ")", ".", "getCorrectedMessageUID", "(", ")", ";", "}", "Contact", "sourceContact", "=", "opSetPersPresence", ".", "findContactByID", "(", "(", "isPrivateMessaging", "?", "userFullId", ":", "userBareID", ")", ")", ";", "if", "(", "msg", ".", "getType", "(", ")", "==", "org", ".", "jivesoftware", ".", "smack", ".", "packet", ".", "Message", ".", "Type", ".", "error", ")", "{", "if", "(", "isPrivateMessaging", "&&", "sourceContact", "==", "null", ")", "{", "if", "(", "privateContactRoom", "!=", "null", ")", "{", "XMPPError", "error", "=", "packet", ".", "getError", "(", ")", ";", "int", "errorResultCode", "=", "ChatRoomMessageDeliveryFailedEvent", ".", "UNKNOWN_ERROR", ";", "if", "(", "error", "!=", "null", "&&", "error", ".", "getCode", "(", ")", "==", "403", ")", "{", "errorResultCode", "=", "ChatRoomMessageDeliveryFailedEvent", ".", "FORBIDDEN", ";", "}", "String", "errorReason", "=", "error", ".", "getMessage", "(", ")", ";", "ChatRoomMessageDeliveryFailedEvent", "evt", "=", "new", "ChatRoomMessageDeliveryFailedEvent", "(", "privateContactRoom", ",", "null", ",", "errorResultCode", ",", "errorReason", ",", "new", "Date", "(", ")", ",", "newMessage", ")", ";", "(", "(", "ChatRoomJabberImpl", ")", "privateContactRoom", ")", ".", "fireMessageEvent", "(", "evt", ")", ";", "}", "return", ";", "}", "if", "(", "logger", ".", "isInfoEnabled", "(", ")", ")", "logger", ".", "info", "(", "\"", "Message error received from ", "\"", "+", "userBareID", ")", ";", "int", "errorResultCode", "=", "MessageDeliveryFailedEvent", ".", "UNKNOWN_ERROR", ";", "if", "(", "packet", ".", "getError", "(", ")", "!=", "null", ")", "{", "int", "errorCode", "=", "packet", ".", "getError", "(", ")", ".", "getCode", "(", ")", ";", "if", "(", "errorCode", "==", "503", ")", "{", "org", ".", "jivesoftware", ".", "smackx", ".", "packet", ".", "MessageEvent", "msgEvent", "=", "(", "org", ".", "jivesoftware", ".", "smackx", ".", "packet", ".", "MessageEvent", ")", "packet", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "jabber:x:event", "\"", ")", ";", "if", "(", "msgEvent", "!=", "null", "&&", "msgEvent", ".", "isOffline", "(", ")", ")", "{", "errorResultCode", "=", "MessageDeliveryFailedEvent", ".", "OFFLINE_MESSAGES_NOT_SUPPORTED", ";", "}", "}", "}", "if", "(", "sourceContact", "==", "null", ")", "{", "sourceContact", "=", "opSetPersPresence", ".", "createVolatileContact", "(", "userFullId", ",", "isPrivateMessaging", ")", ";", "}", "MessageDeliveryFailedEvent", "ev", "=", "new", "MessageDeliveryFailedEvent", "(", "newMessage", ",", "sourceContact", ",", "correctedMessageUID", ",", "errorResultCode", ")", ";", "if", "(", "ev", "!=", "null", ")", "fireMessageEvent", "(", "ev", ")", ";", "return", ";", "}", "putJidForAddress", "(", "userFullId", ",", "msg", ".", "getThread", "(", ")", ")", ";", "if", "(", "sourceContact", "==", "null", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "logger", ".", "debug", "(", "\"", "received a message from an unknown contact: ", "\"", "+", "userBareID", ")", ";", "sourceContact", "=", "opSetPersPresence", ".", "createVolatileContact", "(", "userFullId", ",", "isPrivateMessaging", ")", ";", "}", "Date", "timestamp", "=", "new", "Date", "(", ")", ";", "PacketExtension", "delay", "=", "msg", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "jabber:x:delay", "\"", ")", ";", "if", "(", "delay", "!=", "null", "&&", "delay", "instanceof", "DelayInformation", ")", "{", "timestamp", "=", "(", "(", "DelayInformation", ")", "delay", ")", ".", "getStamp", "(", ")", ";", "}", "delay", "=", "msg", ".", "getExtension", "(", "\"", "delay", "\"", ",", "\"", "urn:xmpp:delay", "\"", ")", ";", "if", "(", "delay", "!=", "null", "&&", "delay", "instanceof", "DelayInfo", ")", "{", "timestamp", "=", "(", "(", "DelayInfo", ")", "delay", ")", ".", "getStamp", "(", ")", ";", "}", "ContactResource", "resource", "=", "(", "(", "ContactJabberImpl", ")", "sourceContact", ")", ".", "getResourceFromJid", "(", "userFullId", ")", ";", "EventObject", "msgEvt", "=", "null", ";", "if", "(", "!", "isForwardedSentMessage", ")", "msgEvt", "=", "new", "MessageReceivedEvent", "(", "newMessage", ",", "sourceContact", ",", "resource", ",", "timestamp", ",", "correctedMessageUID", ",", "isPrivateMessaging", ",", "privateContactRoom", ")", ";", "else", "msgEvt", "=", "new", "MessageDeliveredEvent", "(", "newMessage", ",", "sourceContact", ",", "timestamp", ")", ";", "if", "(", "msgEvt", "!=", "null", ")", "fireMessageEvent", "(", "msgEvt", ")", ";", "}"], "idx": 11698, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "7d66da61b316c9480b63000f831b6de723b87315", "function_name": "processPacket", "body_hash": "f227e9c02507deabb1b21a8aa72ecb371f2bb747"}
{"code": "protected static File getTmpFolder() {\n        try {\n            File outputFolder = File.createTempFile(\"codegen-\", \"-tmp\");\n            outputFolder.delete();\n            outputFolder.mkdir();\n            outputFolder.deleteOnExit();\n            return outputFolder;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }", "code_tokens": ["protected", "static", "File", "getTmpFolder", "(", ")", "{", "try", "{", "File", "outputFolder", "=", "File", ".", "createTempFile", "(", "\"", "codegen-", "\"", ",", "\"", "-tmp", "\"", ")", ";", "outputFolder", ".", "delete", "(", ")", ";", "outputFolder", ".", "mkdir", "(", ")", ";", "outputFolder", ".", "deleteOnExit", "(", ")", ";", "return", "outputFolder", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "return", "null", ";", "}", "}"], "idx": 50010, "cwe": "CWE-378", "target": 1, "status": "VULNERABLE", "commit": "987ea7a30b463cc239580d6ad166c707ae942a89", "function_name": "getTmpFolder", "body_hash": "fd3f175cd871af5a608a1cf1027ce2f10f22140e"}
{"code": "@RequirePOST\n    public void doNotifyCommit(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        // compute the affected paths\n        Set<String> affectedPath = new HashSet<String>();\n        String line;\n        BufferedReader r = new BufferedReader(req.getReader());\n        \n        try {\n\t        while((line=r.readLine())!=null) {\n\t        \tif (LOGGER.isLoggable(FINER)) {\n\t        \t\tLOGGER.finer(\"Reading line: \"+line);\n\t        \t}\n\t            affectedPath.add(line.substring(4));\n\t            if (line.startsWith(\"svnlook changed --revision \")) {\n\t                String msg = \"Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: \" + line;\n\t                LOGGER.warning(msg);\n\t                throw new IllegalArgumentException(msg);\n\t            }\n\t        }\n        } finally {\n        \tIOUtils.closeQuietly(r);\n        }\n\n        if(LOGGER.isLoggable(FINE))\n            LOGGER.fine(\"Change reported to Subversion repository \"+uuid+\" on \"+affectedPath);\n\n        // we can't reliably use req.getParameter() as it can try to parse the payload, which we've already consumed above.\n        // servlet container relies on Content-type to decide if it wants to parse the payload or not, and at least\n        // in case of Jetty, it doesn't check if the payload is\n        QueryParameterMap query = new QueryParameterMap(req);\n        String revParam = query.get(\"rev\");\n        if (revParam == null) {\n            revParam = req.getHeader(\"X-Hudson-Subversion-Revision\");\n        }\n\n        long rev = -1;\n        if (revParam != null) {\n            rev = Long.parseLong(revParam);\n        }\n\n        boolean listenerDidSomething = false;\n        for (Listener listener : ExtensionList.lookup(Listener.class)) {\n            try {\n                if (listener.onNotify(uuid, rev, affectedPath)) {\n                    listenerDidSomething = true;\n                }\n            } catch (Throwable t) {\n                LOGGER.log(WARNING, \"Listener \" + listener.getClass().getName() + \" threw an uncaught exception\", t);\n            }\n        }\n\n        if (!listenerDidSomething) LOGGER.log(Level.WARNING, \"No interest in change to repository UUID {0} found\", uuid);\n\n        rsp.setStatus(SC_OK);\n    }", "code_tokens": ["@", "RequirePOST", "public", "void", "doNotifyCommit", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "ServletException", ",", "IOException", "{", "Set", "<", "String", ">", "affectedPath", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "String", "line", ";", "BufferedReader", "r", "=", "new", "BufferedReader", "(", "req", ".", "getReader", "(", ")", ")", ";", "try", "{", "while", "(", "(", "line", "=", "r", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "if", "(", "LOGGER", ".", "isLoggable", "(", "FINER", ")", ")", "{", "LOGGER", ".", "finer", "(", "\"", "Reading line: ", "\"", "+", "line", ")", ";", "}", "affectedPath", ".", "add", "(", "line", ".", "substring", "(", "4", ")", ")", ";", "if", "(", "line", ".", "startsWith", "(", "\"", "svnlook changed --revision ", "\"", ")", ")", "{", "String", "msg", "=", "\"", "Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: ", "\"", "+", "line", ";", "LOGGER", ".", "warning", "(", "msg", ")", ";", "throw", "new", "IllegalArgumentException", "(", "msg", ")", ";", "}", "}", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "r", ")", ";", "}", "if", "(", "LOGGER", ".", "isLoggable", "(", "FINE", ")", ")", "LOGGER", ".", "fine", "(", "\"", "Change reported to Subversion repository ", "\"", "+", "uuid", "+", "\"", " on ", "\"", "+", "affectedPath", ")", ";", "QueryParameterMap", "query", "=", "new", "QueryParameterMap", "(", "req", ")", ";", "String", "revParam", "=", "query", ".", "get", "(", "\"", "rev", "\"", ")", ";", "if", "(", "revParam", "==", "null", ")", "{", "revParam", "=", "req", ".", "getHeader", "(", "\"", "X-Hudson-Subversion-Revision", "\"", ")", ";", "}", "long", "rev", "=", "-", "1", ";", "if", "(", "revParam", "!=", "null", ")", "{", "rev", "=", "Long", ".", "parseLong", "(", "revParam", ")", ";", "}", "boolean", "listenerDidSomething", "=", "false", ";", "for", "(", "Listener", "listener", ":", "ExtensionList", ".", "lookup", "(", "Listener", ".", "class", ")", ")", "{", "try", "{", "if", "(", "listener", ".", "onNotify", "(", "uuid", ",", "rev", ",", "affectedPath", ")", ")", "{", "listenerDidSomething", "=", "true", ";", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "LOGGER", ".", "log", "(", "WARNING", ",", "\"", "Listener ", "\"", "+", "listener", ".", "getClass", "(", ")", ".", "getName", "(", ")", "+", "\"", " threw an uncaught exception", "\"", ",", "t", ")", ";", "}", "}", "if", "(", "!", "listenerDidSomething", ")", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "No interest in change to repository UUID {0} found", "\"", ",", "uuid", ")", ";", "rsp", ".", "setStatus", "(", "SC_OK", ")", ";", "}"], "idx": 89717, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "25f6afbb02a5863f363b0a2f664ac717ace743b4", "function_name": "doNotifyCommit", "body_hash": "53f9d137d6e0ea56f44e095917d78c6899414d73"}
{"code": "private boolean processRemainingHeader() throws IOException {\n        // Ignore the 2 bytes already read. 4 for the mask\n        int headerLength;\n        if (isMasked()) {\n            headerLength = 4;\n        } else {\n            headerLength = 0;\n        }\n        // Add additional bytes depending on length\n        if (payloadLength == 126) {\n            headerLength += 2;\n        } else if (payloadLength == 127) {\n            headerLength += 8;\n        }\n        if (writePos - readPos < headerLength) {\n            return false;\n        }\n        // Calculate new payload length if necessary\n        if (payloadLength == 126) {\n            payloadLength = byteArrayToLong(inputBuffer, readPos, 2);\n            readPos += 2;\n        } else if (payloadLength == 127) {\n            payloadLength = byteArrayToLong(inputBuffer, readPos, 8);\n            readPos += 8;\n        }\n        if (Util.isControl(opCode)) {\n            if (payloadLength > 125) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlPayloadTooBig\",\n                                Long.valueOf(payloadLength))));\n            }\n            if (!fin) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlNoFin\")));\n            }\n        }\n        if (isMasked()) {\n            System.arraycopy(inputBuffer, readPos, mask, 0, 4);\n            readPos += 4;\n        }\n        state = State.DATA;\n        return true;\n    }", "code_tokens": ["private", "boolean", "processRemainingHeader", "(", ")", "throws", "IOException", "{", "int", "headerLength", ";", "if", "(", "isMasked", "(", ")", ")", "{", "headerLength", "=", "4", ";", "}", "else", "{", "headerLength", "=", "0", ";", "}", "if", "(", "payloadLength", "==", "126", ")", "{", "headerLength", "+=", "2", ";", "}", "else", "if", "(", "payloadLength", "==", "127", ")", "{", "headerLength", "+=", "8", ";", "}", "if", "(", "writePos", "-", "readPos", "<", "headerLength", ")", "{", "return", "false", ";", "}", "if", "(", "payloadLength", "==", "126", ")", "{", "payloadLength", "=", "byteArrayToLong", "(", "inputBuffer", ",", "readPos", ",", "2", ")", ";", "readPos", "+=", "2", ";", "}", "else", "if", "(", "payloadLength", "==", "127", ")", "{", "payloadLength", "=", "byteArrayToLong", "(", "inputBuffer", ",", "readPos", ",", "8", ")", ";", "readPos", "+=", "8", ";", "}", "if", "(", "Util", ".", "isControl", "(", "opCode", ")", ")", "{", "if", "(", "payloadLength", ">", "125", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.controlPayloadTooBig", "\"", ",", "Long", ".", "valueOf", "(", "payloadLength", ")", ")", ")", ")", ";", "}", "if", "(", "!", "fin", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.controlNoFin", "\"", ")", ")", ")", ";", "}", "}", "if", "(", "isMasked", "(", ")", ")", "{", "System", ".", "arraycopy", "(", "inputBuffer", ",", "readPos", ",", "mask", ",", "0", ",", "4", ")", ";", "readPos", "+=", "4", ";", "}", "state", "=", "State", ".", "DATA", ";", "return", "true", ";", "}"], "idx": 82567, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "f9f75c14678b68633f79030ddf4ff827f014cc84", "function_name": "processRemainingHeader", "body_hash": "cda0d9505895370e4819f5f991418e683ffc885a"}
{"code": "static Set<String> keysWithVariableValues(Map<String, String> rawConfig, Pattern pattern) {\n        Set<String> keys = new HashSet<>();\n        for (Map.Entry<String, String> config : rawConfig.entrySet()) {\n            if (config.getValue() != null) {\n                Matcher matcher = pattern.matcher(config.getValue());\n                if (matcher.find()) {\n                    keys.add(config.getKey());\n                }\n            }\n        }\n        return keys;\n    }", "code_tokens": ["static", "Set", "<", "String", ">", "keysWithVariableValues", "(", "Map", "<", "String", ",", "String", ">", "rawConfig", ",", "Pattern", "pattern", ")", "{", "Set", "<", "String", ">", "keys", "=", "new", "HashSet", "<", ">", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "config", ":", "rawConfig", ".", "entrySet", "(", ")", ")", "{", "if", "(", "config", ".", "getValue", "(", ")", "!=", "null", ")", "{", "Matcher", "matcher", "=", "pattern", ".", "matcher", "(", "config", ".", "getValue", "(", ")", ")", ";", "if", "(", "matcher", ".", "find", "(", ")", ")", "{", "keys", ".", "add", "(", "config", ".", "getKey", "(", ")", ")", ";", "}", "}", "}", "return", "keys", ";", "}"], "idx": 41836, "cwe": "CWE-319", "target": 0, "status": "FIXED", "commit": "5d2a6dc531150423a40f77783a4a09e1b0f90178", "function_name": "keysWithVariableValues", "body_hash": "24d3e39a58ae9de1d88ba6f5925fc060f22862bb"}
{"code": "public synchronized TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        acl.checkPermission(Item.CREATE);\n\n        Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n        if (parent.getItem(name) != null) {\n            throw new IllegalArgumentException(parent.getDisplayName() + \" already contains an item '\" + name + \"'\");\n        }\n        // TODO what if we have no DISCOVER permission on the existing job?\n\n        // place it as config.xml\n        File configXml = Items.getConfigFile(getRootDirFor(name)).getFile();\n        final File dir = configXml.getParentFile();\n        dir.mkdirs();\n        final AtomicFileWriter out = new AtomicFileWriter(configXml);\n\n        try {\n            XMLUtils.safeTransform((Source)new StreamSource(xml), new StreamResult(out));\n            out.close();\n            out.commit();\n\n            // load it\n            TopLevelItem result = Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<TopLevelItem,IOException>() {\n                @Override public TopLevelItem call() throws IOException {\n                    return (TopLevelItem) Items.load(parent, dir);\n                }\n            });\n            add(result);\n\n            ItemListener.fireOnCreated(result);\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            return result;\n        } catch (TransformerException e) {\n            // if anything fails, delete the config file to avoid further confusion\n            Util.deleteRecursive(dir);\n            throw new IOException(\"Failed to persist config.xml\", e);\n        } catch (SAXException e) {\n            // if anything fails, delete the config file to avoid further confusion\n            Util.deleteRecursive(dir);\n            throw new IOException(\"Failed to persist config.xml\", e);\n        } catch (IOException e) {\n            // if anything fails, delete the config file to avoid further confusion\n            Util.deleteRecursive(dir);\n            throw e;\n        } finally {\n            // don't leave anything behind\n            out.abort();\n        }\n    }", "code_tokens": ["public", "synchronized", "TopLevelItem", "createProjectFromXML", "(", "String", "name", ",", "InputStream", "xml", ")", "throws", "IOException", "{", "acl", ".", "checkPermission", "(", "Item", ".", "CREATE", ")", ";", "Jenkins", ".", "getInstance", "(", ")", ".", "getProjectNamingStrategy", "(", ")", ".", "checkName", "(", "name", ")", ";", "if", "(", "parent", ".", "getItem", "(", "name", ")", "!=", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "parent", ".", "getDisplayName", "(", ")", "+", "\"", " already contains an item '", "\"", "+", "name", "+", "\"", "'", "\"", ")", ";", "}", "File", "configXml", "=", "Items", ".", "getConfigFile", "(", "getRootDirFor", "(", "name", ")", ")", ".", "getFile", "(", ")", ";", "final", "File", "dir", "=", "configXml", ".", "getParentFile", "(", ")", ";", "dir", ".", "mkdirs", "(", ")", ";", "final", "AtomicFileWriter", "out", "=", "new", "AtomicFileWriter", "(", "configXml", ")", ";", "try", "{", "XMLUtils", ".", "safeTransform", "(", "(", "Source", ")", "new", "StreamSource", "(", "xml", ")", ",", "new", "StreamResult", "(", "out", ")", ")", ";", "out", ".", "close", "(", ")", ";", "out", ".", "commit", "(", ")", ";", "TopLevelItem", "result", "=", "Items", ".", "whileUpdatingByXml", "(", "new", "NotReallyRoleSensitiveCallable", "<", "TopLevelItem", ",", "IOException", ">", "(", ")", "{", "@", "Override", "public", "TopLevelItem", "call", "(", ")", "throws", "IOException", "{", "return", "(", "TopLevelItem", ")", "Items", ".", "load", "(", "parent", ",", "dir", ")", ";", "}", "}", ")", ";", "add", "(", "result", ")", ";", "ItemListener", ".", "fireOnCreated", "(", "result", ")", ";", "Jenkins", ".", "getInstance", "(", ")", ".", "rebuildDependencyGraphAsync", "(", ")", ";", "return", "result", ";", "}", "catch", "(", "TransformerException", "e", ")", "{", "Util", ".", "deleteRecursive", "(", "dir", ")", ";", "throw", "new", "IOException", "(", "\"", "Failed to persist config.xml", "\"", ",", "e", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "Util", ".", "deleteRecursive", "(", "dir", ")", ";", "throw", "new", "IOException", "(", "\"", "Failed to persist config.xml", "\"", ",", "e", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "Util", ".", "deleteRecursive", "(", "dir", ")", ";", "throw", "e", ";", "}", "finally", "{", "out", ".", "abort", "(", ")", ";", "}", "}"], "idx": 110766, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "e78e9e8144f7304cf274cd4b756f458cf63a3556", "function_name": "createProjectFromXML", "body_hash": "025fc5fe9b9ec9ab04df4ee2f71fddd58145fba4"}
{"code": "@Override\n\t\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\t\tthrows ServletException, IOException {\n\t\t\tString origin = request.getParameter(\"origin\");\n\t\t\tif (origin == null) {\n\t\t\t\tresponse.setStatus(500);\n\t\t\t\tresponse.getWriter().println(\n\t\t\t\t\t\t\"Required parameter 'origin' missing. Example: 107.20.175.135:7001\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\torigin = origin.trim();\n\n\t\t\tHttpGet httpget = null;\n\t\t\tInputStream is = null;\n\t\t\tboolean hasFirstParameter = false;\n\t\t\tStringBuilder url = new StringBuilder();\n\t\t\tif (!origin.startsWith(\"http\")) {\n\t\t\t\turl.append(\"http://\");\n\t\t\t}\n\t\t\turl.append(origin);\n\t\t\tif (origin.contains(\"?\")) {\n\t\t\t\thasFirstParameter = true;\n\t\t\t}\n\t\t\tMap<String, String[]> params = request.getParameterMap();\n\t\t\tfor (String key : params.keySet()) {\n\t\t\t\tif (!key.equals(\"origin\")) {\n\t\t\t\t\tString[] values = params.get(key);\n\t\t\t\t\tString value = values[0].trim();\n\t\t\t\t\tif (hasFirstParameter) {\n\t\t\t\t\t\turl.append(\"&\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\turl.append(\"?\");\n\t\t\t\t\t\thasFirstParameter = true;\n\t\t\t\t\t}\n\t\t\t\t\turl.append(key).append(\"=\").append(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString proxyUrl = url.toString();\n\t\t\tlog.info(\"\\n\\nProxy opening connection to: \" + proxyUrl + \"\\n\\n\");\n\t\t\ttry {\n\t\t\t\thttpget = new HttpGet(proxyUrl);\n\t\t\t\tHttpClient client = ProxyConnectionManager.httpClient;\n\t\t\t\tHttpResponse httpResponse = client.execute(httpget);\n\t\t\t\tint statusCode = httpResponse.getStatusLine().getStatusCode();\n\t\t\t\tif (statusCode == HttpStatus.SC_OK) {\n\t\t\t\t\t// writeTo swallows exceptions and never quits even if outputstream is\n\t\t\t\t\t// throwing IOExceptions (such as broken pipe) ... since the\n\t\t\t\t\t// inputstream is infinite\n\t\t\t\t\t// httpResponse.getEntity().writeTo(new\n\t\t\t\t\t// OutputStreamWrapper(response.getOutputStream()));\n\t\t\t\t\t// so I copy it manually ...\n\t\t\t\t\tis = httpResponse.getEntity().getContent();\n\n\t\t\t\t\t// set headers\n\t\t\t\t\tcopyHeadersToServletResponse(httpResponse.getAllHeaders(), response);\n\n\t\t\t\t\t// copy data from source to response\n\t\t\t\t\tOutputStream os = response.getOutputStream();\n\t\t\t\t\tint b = -1;\n\t\t\t\t\twhile ((b = is.read()) != -1) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tos.write(b);\n\t\t\t\t\t\t\tif (b == 10 /** flush buffer on line feed */\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tos.flush();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (ex.getClass().getSimpleName()\n\t\t\t\t\t\t\t\t\t.equalsIgnoreCase(\"ClientAbortException\")) {\n\t\t\t\t\t\t\t\t// don't throw an exception as this means the user closed\n\t\t\t\t\t\t\t\t// the connection\n\t\t\t\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t\t\t\t\"Connection closed by client. Will stop proxying ...\");\n\t\t\t\t\t\t\t\t// break out of the while loop\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// received unknown error while writing so throw an\n\t\t\t\t\t\t\t\t// exception\n\t\t\t\t\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.warn(\"Failed opening connection to \" + proxyUrl + \" : \"\n\t\t\t\t\t\t\t+ statusCode + \" : \" + httpResponse.getStatusLine());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlog.error(\"Error proxying request: \" + url, ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (httpget != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thttpget.abort();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tlog.error(\"failed aborting proxy connection.\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// httpget.abort() MUST be called first otherwise is.close() hangs\n\t\t\t\t// (because data is still streaming?)\n\t\t\t\tif (is != null) {\n\t\t\t\t\t// this should already be closed by httpget.abort() above\n\t\t\t\t\ttry {\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t// ignore errors on close\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}", "code_tokens": ["@", "Override", "protected", "void", "doGet", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "String", "origin", "=", "request", ".", "getParameter", "(", "\"", "origin", "\"", ")", ";", "if", "(", "origin", "==", "null", ")", "{", "response", ".", "setStatus", "(", "500", ")", ";", "response", ".", "getWriter", "(", ")", ".", "println", "(", "\"", "Required parameter 'origin' missing. Example: 107.20.175.135:7001", "\"", ")", ";", "return", ";", "}", "origin", "=", "origin", ".", "trim", "(", ")", ";", "HttpGet", "httpget", "=", "null", ";", "InputStream", "is", "=", "null", ";", "boolean", "hasFirstParameter", "=", "false", ";", "StringBuilder", "url", "=", "new", "StringBuilder", "(", ")", ";", "if", "(", "!", "origin", ".", "startsWith", "(", "\"", "http", "\"", ")", ")", "{", "url", ".", "append", "(", "\"", "http://", "\"", ")", ";", "}", "url", ".", "append", "(", "origin", ")", ";", "if", "(", "origin", ".", "contains", "(", "\"", "?", "\"", ")", ")", "{", "hasFirstParameter", "=", "true", ";", "}", "Map", "<", "String", ",", "String", "[", "]", ">", "params", "=", "request", ".", "getParameterMap", "(", ")", ";", "for", "(", "String", "key", ":", "params", ".", "keySet", "(", ")", ")", "{", "if", "(", "!", "key", ".", "equals", "(", "\"", "origin", "\"", ")", ")", "{", "String", "[", "]", "values", "=", "params", ".", "get", "(", "key", ")", ";", "String", "value", "=", "values", "[", "0", "]", ".", "trim", "(", ")", ";", "if", "(", "hasFirstParameter", ")", "{", "url", ".", "append", "(", "\"", "&", "\"", ")", ";", "}", "else", "{", "url", ".", "append", "(", "\"", "?", "\"", ")", ";", "hasFirstParameter", "=", "true", ";", "}", "url", ".", "append", "(", "key", ")", ".", "append", "(", "\"", "=", "\"", ")", ".", "append", "(", "value", ")", ";", "}", "}", "String", "proxyUrl", "=", "url", ".", "toString", "(", ")", ";", "log", ".", "info", "(", "\"", "\\n", "\\n", "Proxy opening connection to: ", "\"", "+", "proxyUrl", "+", "\"", "\\n", "\\n", "\"", ")", ";", "try", "{", "httpget", "=", "new", "HttpGet", "(", "proxyUrl", ")", ";", "HttpClient", "client", "=", "ProxyConnectionManager", ".", "httpClient", ";", "HttpResponse", "httpResponse", "=", "client", ".", "execute", "(", "httpget", ")", ";", "int", "statusCode", "=", "httpResponse", ".", "getStatusLine", "(", ")", ".", "getStatusCode", "(", ")", ";", "if", "(", "statusCode", "==", "HttpStatus", ".", "SC_OK", ")", "{", "is", "=", "httpResponse", ".", "getEntity", "(", ")", ".", "getContent", "(", ")", ";", "copyHeadersToServletResponse", "(", "httpResponse", ".", "getAllHeaders", "(", ")", ",", "response", ")", ";", "OutputStream", "os", "=", "response", ".", "getOutputStream", "(", ")", ";", "int", "b", "=", "-", "1", ";", "while", "(", "(", "b", "=", "is", ".", "read", "(", ")", ")", "!=", "-", "1", ")", "{", "try", "{", "os", ".", "write", "(", "b", ")", ";", "if", "(", "b", "==", "10", ")", "{", "os", ".", "flush", "(", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "if", "(", "ex", ".", "getClass", "(", ")", ".", "getSimpleName", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "ClientAbortException", "\"", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection closed by client. Will stop proxying ...", "\"", ")", ";", "break", ";", "}", "else", "{", "throw", "new", "RuntimeException", "(", "ex", ")", ";", "}", "}", "}", "}", "else", "{", "log", ".", "warn", "(", "\"", "Failed opening connection to ", "\"", "+", "proxyUrl", "+", "\"", " : ", "\"", "+", "statusCode", "+", "\"", " : ", "\"", "+", "httpResponse", ".", "getStatusLine", "(", ")", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "log", ".", "error", "(", "\"", "Error proxying request: ", "\"", "+", "url", ",", "ex", ")", ";", "}", "finally", "{", "if", "(", "httpget", "!=", "null", ")", "{", "try", "{", "httpget", ".", "abort", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "log", ".", "error", "(", "\"", "failed aborting proxy connection.", "\"", ",", "ex", ")", ";", "}", "}", "if", "(", "is", "!=", "null", ")", "{", "try", "{", "is", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "}", "}", "}", "}"], "idx": 65988, "cwe": "CWE-610", "target": 1, "status": "VULNERABLE", "commit": "a9f0315aa", "function_name": "doGet", "body_hash": "c2491f46bb971b64cc17b8817dcac446f3817318"}
{"code": "@Parameterized.Parameters(name = \"{index}: user[{3}], pwd[{4}]\")\n    public static Collection<Object[]> parameters() {\n        List<Object[]> parameterSets = new ArrayList<>();\n        addUsers(USER_PATTERN, null, null, parameterSets);\n        addUsers(null, USER_SEARCH, USER_BASE, parameterSets);\n        return parameterSets;\n    }", "code_tokens": ["@", "Parameterized", ".", "Parameters", "(", "name", "=", "\"", "{index}: user[{3}], pwd[{4}]", "\"", ")", "public", "static", "Collection", "<", "Object", "[", "]", ">", "parameters", "(", ")", "{", "List", "<", "Object", "[", "]", ">", "parameterSets", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "addUsers", "(", "USER_PATTERN", ",", "null", ",", "null", ",", "parameterSets", ")", ";", "addUsers", "(", "null", ",", "USER_SEARCH", ",", "USER_BASE", ",", "parameterSets", ")", ";", "return", "parameterSets", ";", "}"], "idx": 1111, "cwe": "CWE-116", "target": 1, "status": "VULNERABLE", "commit": "b930d0b3161d9ec78d5fa57f886ed2de4680518b", "function_name": "parameters", "body_hash": "c665c3b8bf0b22102a2e30aa67ff7b2ec8b25139"}
{"code": "@RequestMapping(value = \"/oauth/authorize\", method = RequestMethod.POST, params = OAuth2Utils.USER_OAUTH_APPROVAL)\n    public View approveOrDeny(@RequestParam Map<String, String> approvalParameters, Map<String, ?> model,\n                              SessionStatus sessionStatus, Principal principal) {\n\n        if (!(principal instanceof Authentication)) {\n            sessionStatus.setComplete();\n            throw new InsufficientAuthenticationException(\n              \"User must be authenticated with Spring Security before authorizing an access token.\");\n        }\n\n        AuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get(\"authorizationRequest\");\n\n        if (authorizationRequest == null) {\n            sessionStatus.setComplete();\n            throw new InvalidRequestException(\"Cannot approve uninitialized authorization request.\");\n        }\n\n        // Check to ensure the Authorization Request was not modified during the user approval step\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> originalAuthorizationRequest = (Map<String, Object>) model.get(\"org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.ORIGINAL_AUTHORIZATION_REQUEST\");\n        if (isAuthorizationRequestModified(authorizationRequest, originalAuthorizationRequest)) {\n            throw new InvalidRequestException(\"Changes were detected from the original authorization request.\");\n        }\n\n        for (String approvalParameter : approvalParameters.keySet()) {\n            if (approvalParameter.startsWith(SCOPE_PREFIX)) {\n                String scope = approvalParameters.get(approvalParameter).substring(SCOPE_PREFIX.length());\n                Set<String> originalScopes = (Set<String>) originalAuthorizationRequest.get(\"scope\");\n                if (!originalScopes.contains(scope)) {\n                    sessionStatus.setComplete();\n\n                    return new RedirectView(getUnsuccessfulRedirect(authorizationRequest,\n                            new InvalidScopeException(\"The requested scopes are invalid. Please use valid scope names in the request.\"), false), false, true, false);\n                }\n            }\n        }\n\n        try {\n            Set<String> responseTypes = authorizationRequest.getResponseTypes();\n            String grantType = deriveGrantTypeFromResponseType(responseTypes);\n\n            authorizationRequest.setApprovalParameters(approvalParameters);\n            authorizationRequest = userApprovalHandler.updateAfterApproval(authorizationRequest,\n              (Authentication) principal);\n            boolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);\n            authorizationRequest.setApproved(approved);\n\n            if (authorizationRequest.getRedirectUri() == null) {\n                sessionStatus.setComplete();\n                throw new InvalidRequestException(\"Cannot approve request when no redirect URI is provided.\");\n            }\n\n            if (!authorizationRequest.isApproved()) {\n                return new RedirectView(getUnsuccessfulRedirect(authorizationRequest,\n                  new UserDeniedAuthorizationException(\"User denied access\"), responseTypes.contains(\"token\")),\n                  false, true, false);\n            }\n\n            if (responseTypes.contains(\"token\") || responseTypes.contains(\"id_token\")) {\n                return getImplicitGrantOrHybridResponse(\n                  authorizationRequest,\n                  (Authentication) principal,\n                  grantType\n                ).getView();\n            }\n\n            return getAuthorizationCodeResponse(authorizationRequest, (Authentication) principal);\n        } finally {\n            sessionStatus.setComplete();\n        }\n\n    }", "code_tokens": ["@", "RequestMapping", "(", "value", "=", "\"", "/oauth/authorize", "\"", ",", "method", "=", "RequestMethod", ".", "POST", ",", "params", "=", "OAuth2Utils", ".", "USER_OAUTH_APPROVAL", ")", "public", "View", "approveOrDeny", "(", "@", "RequestParam", "Map", "<", "String", ",", "String", ">", "approvalParameters", ",", "Map", "<", "String", ",", "?", ">", "model", ",", "SessionStatus", "sessionStatus", ",", "Principal", "principal", ")", "{", "if", "(", "!", "(", "principal", "instanceof", "Authentication", ")", ")", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "throw", "new", "InsufficientAuthenticationException", "(", "\"", "User must be authenticated with Spring Security before authorizing an access token.", "\"", ")", ";", "}", "AuthorizationRequest", "authorizationRequest", "=", "(", "AuthorizationRequest", ")", "model", ".", "get", "(", "\"", "authorizationRequest", "\"", ")", ";", "if", "(", "authorizationRequest", "==", "null", ")", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "throw", "new", "InvalidRequestException", "(", "\"", "Cannot approve uninitialized authorization request.", "\"", ")", ";", "}", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Map", "<", "String", ",", "Object", ">", "originalAuthorizationRequest", "=", "(", "Map", "<", "String", ",", "Object", ">", ")", "model", ".", "get", "(", "\"", "org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.ORIGINAL_AUTHORIZATION_REQUEST", "\"", ")", ";", "if", "(", "isAuthorizationRequestModified", "(", "authorizationRequest", ",", "originalAuthorizationRequest", ")", ")", "{", "throw", "new", "InvalidRequestException", "(", "\"", "Changes were detected from the original authorization request.", "\"", ")", ";", "}", "for", "(", "String", "approvalParameter", ":", "approvalParameters", ".", "keySet", "(", ")", ")", "{", "if", "(", "approvalParameter", ".", "startsWith", "(", "SCOPE_PREFIX", ")", ")", "{", "String", "scope", "=", "approvalParameters", ".", "get", "(", "approvalParameter", ")", ".", "substring", "(", "SCOPE_PREFIX", ".", "length", "(", ")", ")", ";", "Set", "<", "String", ">", "originalScopes", "=", "(", "Set", "<", "String", ">", ")", "originalAuthorizationRequest", ".", "get", "(", "\"", "scope", "\"", ")", ";", "if", "(", "!", "originalScopes", ".", "contains", "(", "scope", ")", ")", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "return", "new", "RedirectView", "(", "getUnsuccessfulRedirect", "(", "authorizationRequest", ",", "new", "InvalidScopeException", "(", "\"", "The requested scopes are invalid. Please use valid scope names in the request.", "\"", ")", ",", "false", ")", ",", "false", ",", "true", ",", "false", ")", ";", "}", "}", "}", "try", "{", "Set", "<", "String", ">", "responseTypes", "=", "authorizationRequest", ".", "getResponseTypes", "(", ")", ";", "String", "grantType", "=", "deriveGrantTypeFromResponseType", "(", "responseTypes", ")", ";", "authorizationRequest", ".", "setApprovalParameters", "(", "approvalParameters", ")", ";", "authorizationRequest", "=", "userApprovalHandler", ".", "updateAfterApproval", "(", "authorizationRequest", ",", "(", "Authentication", ")", "principal", ")", ";", "boolean", "approved", "=", "userApprovalHandler", ".", "isApproved", "(", "authorizationRequest", ",", "(", "Authentication", ")", "principal", ")", ";", "authorizationRequest", ".", "setApproved", "(", "approved", ")", ";", "if", "(", "authorizationRequest", ".", "getRedirectUri", "(", ")", "==", "null", ")", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "throw", "new", "InvalidRequestException", "(", "\"", "Cannot approve request when no redirect URI is provided.", "\"", ")", ";", "}", "if", "(", "!", "authorizationRequest", ".", "isApproved", "(", ")", ")", "{", "return", "new", "RedirectView", "(", "getUnsuccessfulRedirect", "(", "authorizationRequest", ",", "new", "UserDeniedAuthorizationException", "(", "\"", "User denied access", "\"", ")", ",", "responseTypes", ".", "contains", "(", "\"", "token", "\"", ")", ")", ",", "false", ",", "true", ",", "false", ")", ";", "}", "if", "(", "responseTypes", ".", "contains", "(", "\"", "token", "\"", ")", "||", "responseTypes", ".", "contains", "(", "\"", "id_token", "\"", ")", ")", "{", "return", "getImplicitGrantOrHybridResponse", "(", "authorizationRequest", ",", "(", "Authentication", ")", "principal", ",", "grantType", ")", ".", "getView", "(", ")", ";", "}", "return", "getAuthorizationCodeResponse", "(", "authorizationRequest", ",", "(", "Authentication", ")", "principal", ")", ";", "}", "finally", "{", "sessionStatus", ".", "setComplete", "(", ")", ";", "}", "}"], "idx": 102827, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "95b7d9e7fae534a362b98de1df5bf501cd52c481", "function_name": "approveOrDeny", "body_hash": "19e6dd00b090f47321b3b6e9082f0bc5a456b34e"}
{"code": "private void doEncryptBeforeSign() {\n        try {\n            AbstractTokenWrapper encryptionWrapper = getEncryptionToken();\n            assertTokenWrapper(encryptionWrapper);\n            AbstractToken encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n            \n            if (encryptionToken != null) {\n                //The encryption token can be an IssuedToken or a \n                //SecureConversationToken\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken \n                    || encryptionToken instanceof KerberosToken\n                    || encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken\n                    || encryptionToken instanceof SpnegoContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                } else if (encryptionToken instanceof UsernameToken) {\n                    if (isRequestor()) {\n                        tokenId = setupUTDerivedKey((UsernameToken)encryptionToken);\n                    } else {\n                        tokenId = getUTDerivedKey();\n                    }\n                }\n                assertToken(encryptionToken);\n                if (tok == null) {\n                    //if (tokenId == null || tokenId.length() == 0) {\n                        //REVISIT - no tokenId?   Exception?\n                    //}\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n                    \n                    /*\n                     * Get hold of the token from the token storage\n                     */\n                    tok = tokenStore.getToken(tokenId);\n                }\n    \n                boolean attached = false;\n                if (isTokenRequired(encryptionToken.getIncludeTokenType())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n                \n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n                \n                handleEncryptedSignedHeaders(encrParts, sigParts);\n                \n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);        \n                }\n                \n                addSupportingTokens(sigParts);\n                if (!isRequestor()) {\n                    addSignatureConfirmation(sigParts);\n                }\n                \n                //Sign the message\n                //We should use the same key in the case of EncryptBeforeSig\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken, \n                                                    tok, attached));\n                }\n                \n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n                \n                //Check for signature protection and encryption of UsernameToken\n                if (sbinding.isEncryptSignature() \n                    || encryptedTokensList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n                    \n                    //Now encrypt the signature using the above token\n                    if (sbinding.isEncryptSignature()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart = \n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n                        }\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                        assertPolicy(\n                            new QName(sbinding.getName().getNamespaceURI(), SPConstants.ENCRYPT_SIGNATURE));\n                    }\n                    \n                    if (isRequestor()) {\n                        secondEncrParts.addAll(encryptedTokensList);\n                    }\n                    \n                    Element secondRefList = null;\n                    \n                    if (encryptionToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys \n                        && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null, \n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        //Encrypt, get hold of the ref list and add it\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, encrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw ex;\n        } catch (Exception ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw new Fault(ex);\n        }\n    }", "code_tokens": ["private", "void", "doEncryptBeforeSign", "(", ")", "{", "try", "{", "AbstractTokenWrapper", "encryptionWrapper", "=", "getEncryptionToken", "(", ")", ";", "assertTokenWrapper", "(", "encryptionWrapper", ")", ";", "AbstractToken", "encryptionToken", "=", "encryptionWrapper", ".", "getToken", "(", ")", ";", "List", "<", "WSEncryptionPart", ">", "encrParts", "=", "getEncryptedParts", "(", ")", ";", "List", "<", "WSEncryptionPart", ">", "sigParts", "=", "getSignedParts", "(", ")", ";", "if", "(", "encryptionToken", "!=", "null", ")", "{", "String", "tokenId", "=", "null", ";", "SecurityToken", "tok", "=", "null", ";", "if", "(", "encryptionToken", "instanceof", "IssuedToken", "||", "encryptionToken", "instanceof", "KerberosToken", "||", "encryptionToken", "instanceof", "SecureConversationToken", "||", "encryptionToken", "instanceof", "SecurityContextToken", "||", "encryptionToken", "instanceof", "SpnegoContextToken", ")", "{", "tok", "=", "getSecurityToken", "(", ")", ";", "}", "else", "if", "(", "encryptionToken", "instanceof", "X509Token", ")", "{", "if", "(", "isRequestor", "(", ")", ")", "{", "tokenId", "=", "setupEncryptedKey", "(", "encryptionWrapper", ",", "encryptionToken", ")", ";", "}", "else", "{", "tokenId", "=", "getEncryptedKey", "(", ")", ";", "}", "}", "else", "if", "(", "encryptionToken", "instanceof", "UsernameToken", ")", "{", "if", "(", "isRequestor", "(", ")", ")", "{", "tokenId", "=", "setupUTDerivedKey", "(", "(", "UsernameToken", ")", "encryptionToken", ")", ";", "}", "else", "{", "tokenId", "=", "getUTDerivedKey", "(", ")", ";", "}", "}", "assertToken", "(", "encryptionToken", ")", ";", "if", "(", "tok", "==", "null", ")", "{", "if", "(", "tokenId", "!=", "null", "&&", "tokenId", ".", "startsWith", "(", "\"", "#", "\"", ")", ")", "{", "tokenId", "=", "tokenId", ".", "substring", "(", "1", ")", ";", "}", "tok", "=", "tokenStore", ".", "getToken", "(", "tokenId", ")", ";", "}", "boolean", "attached", "=", "false", ";", "if", "(", "isTokenRequired", "(", "encryptionToken", ".", "getIncludeTokenType", "(", ")", ")", ")", "{", "Element", "el", "=", "tok", ".", "getToken", "(", ")", ";", "this", ".", "addEncryptedKeyElement", "(", "cloneElement", "(", "el", ")", ")", ";", "attached", "=", "true", ";", "}", "else", "if", "(", "encryptionToken", "instanceof", "X509Token", "&&", "isRequestor", "(", ")", ")", "{", "Element", "el", "=", "tok", ".", "getToken", "(", ")", ";", "this", ".", "addEncryptedKeyElement", "(", "cloneElement", "(", "el", ")", ")", ";", "attached", "=", "true", ";", "}", "WSSecBase", "encr", "=", "doEncryption", "(", "encryptionWrapper", ",", "tok", ",", "attached", ",", "encrParts", ",", "true", ")", ";", "handleEncryptedSignedHeaders", "(", "encrParts", ",", "sigParts", ")", ";", "if", "(", "timestampEl", "!=", "null", ")", "{", "WSEncryptionPart", "timestampPart", "=", "convertToEncryptionPart", "(", "timestampEl", ".", "getElement", "(", ")", ")", ";", "sigParts", ".", "add", "(", "timestampPart", ")", ";", "}", "addSupportingTokens", "(", "sigParts", ")", ";", "if", "(", "!", "isRequestor", "(", ")", ")", "{", "addSignatureConfirmation", "(", "sigParts", ")", ";", "}", "if", "(", "sigParts", ".", "size", "(", ")", ">", "0", ")", "{", "signatures", ".", "add", "(", "this", ".", "doSignature", "(", "sigParts", ",", "encryptionWrapper", ",", "encryptionToken", ",", "tok", ",", "attached", ")", ")", ";", "}", "if", "(", "isRequestor", "(", ")", ")", "{", "this", ".", "doEndorse", "(", ")", ";", "}", "if", "(", "sbinding", ".", "isEncryptSignature", "(", ")", "||", "encryptedTokensList", ".", "size", "(", ")", ">", "0", "&&", "isRequestor", "(", ")", ")", "{", "List", "<", "WSEncryptionPart", ">", "secondEncrParts", "=", "new", "ArrayList", "<", "WSEncryptionPart", ">", "(", ")", ";", "if", "(", "sbinding", ".", "isEncryptSignature", "(", ")", ")", "{", "if", "(", "this", ".", "mainSigId", "!=", "null", ")", "{", "WSEncryptionPart", "sigPart", "=", "new", "WSEncryptionPart", "(", "this", ".", "mainSigId", ",", "\"", "Element", "\"", ")", ";", "sigPart", ".", "setElement", "(", "bottomUpElement", ")", ";", "secondEncrParts", ".", "add", "(", "sigPart", ")", ";", "}", "if", "(", "sigConfList", "!=", "null", "&&", "!", "sigConfList", ".", "isEmpty", "(", ")", ")", "{", "secondEncrParts", ".", "addAll", "(", "sigConfList", ")", ";", "}", "assertPolicy", "(", "new", "QName", "(", "sbinding", ".", "getName", "(", ")", ".", "getNamespaceURI", "(", ")", ",", "SPConstants", ".", "ENCRYPT_SIGNATURE", ")", ")", ";", "}", "if", "(", "isRequestor", "(", ")", ")", "{", "secondEncrParts", ".", "addAll", "(", "encryptedTokensList", ")", ";", "}", "Element", "secondRefList", "=", "null", ";", "if", "(", "encryptionToken", ".", "getDerivedKeys", "(", ")", "==", "DerivedKeys", ".", "RequireDerivedKeys", "&&", "!", "secondEncrParts", ".", "isEmpty", "(", ")", ")", "{", "secondRefList", "=", "(", "(", "WSSecDKEncrypt", ")", "encr", ")", ".", "encryptForExternalRef", "(", "null", ",", "secondEncrParts", ")", ";", "this", ".", "addDerivedKeyElement", "(", "secondRefList", ")", ";", "}", "else", "if", "(", "!", "secondEncrParts", ".", "isEmpty", "(", ")", ")", "{", "secondRefList", "=", "(", "(", "WSSecEncrypt", ")", "encr", ")", ".", "encryptForRef", "(", "null", ",", "encrParts", ")", ";", "this", ".", "addDerivedKeyElement", "(", "secondRefList", ")", ";", "}", "}", "}", "}", "catch", "(", "RuntimeException", "ex", ")", "{", "LOG", ".", "log", "(", "Level", ".", "FINE", ",", "ex", ".", "getMessage", "(", ")", ",", "ex", ")", ";", "throw", "ex", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "LOG", ".", "log", "(", "Level", ".", "FINE", ",", "ex", ".", "getMessage", "(", ")", ",", "ex", ")", ";", "throw", "new", "Fault", "(", "ex", ")", ";", "}", "}"], "idx": 41585, "cwe": "CWE-310", "target": 1, "status": "VULNERABLE", "commit": "5df3f72f1a26b7c9ac2888ab65e41f4105706580", "function_name": "doEncryptBeforeSign", "body_hash": "ec5693a87156ad2d23ed4aa78e38d7afdbb25393"}
{"code": "@Override\n    public String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        Object redirectAttribute = request.getAttribute(URI_OVERRIDE_ATTRIBUTE);\n        String redirectFormParam = request.getParameter(FORM_REDIRECT_PARAMETER);\n        if (redirectAttribute !=null) {\n            logger.debug(\"Returning redirectAttribute saved URI:\"+redirectAttribute);\n            return (String) redirectAttribute;\n        } else if (isApprovedFormRedirectUri(request, redirectFormParam)) {\n            return redirectFormParam;\n        } else {\n            return super.determineTargetUrl(request, response);\n        }\n    }", "code_tokens": ["@", "Override", "public", "String", "determineTargetUrl", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "{", "Object", "redirectAttribute", "=", "request", ".", "getAttribute", "(", "URI_OVERRIDE_ATTRIBUTE", ")", ";", "String", "redirectFormParam", "=", "request", ".", "getParameter", "(", "FORM_REDIRECT_PARAMETER", ")", ";", "if", "(", "redirectAttribute", "!=", "null", ")", "{", "logger", ".", "debug", "(", "\"", "Returning redirectAttribute saved URI:", "\"", "+", "redirectAttribute", ")", ";", "return", "(", "String", ")", "redirectAttribute", ";", "}", "else", "if", "(", "isApprovedFormRedirectUri", "(", "request", ",", "redirectFormParam", ")", ")", "{", "return", "redirectFormParam", ";", "}", "else", "{", "return", "super", ".", "determineTargetUrl", "(", "request", ",", "response", ")", ";", "}", "}"], "idx": 65630, "cwe": "CWE-601", "target": 0, "status": "FIXED", "commit": "57a15dfb7e0e3a59019ebe951793b586512b196", "function_name": "determineTargetUrl", "body_hash": "2ec970c5ffe833003bb4a635ea0cdc20dc02d9d2"}
{"code": "public static String[] validateObject(ParaObject content) {\n\t\tif (content == null) {\n\t\t\treturn new String[]{\"Object cannot be null.\"};\n\t\t}\n\t\tLinkedList<String> list = new LinkedList<>();\n\t\ttry {\n\t\t\tfor (ConstraintViolation<ParaObject> constraintViolation : getValidator().validate(content)) {\n\t\t\t\tString prop = \"'\".concat(constraintViolation.getPropertyPath().toString()).concat(\"'\");\n\t\t\t\tlist.add(prop.concat(\" \").concat(constraintViolation.getMessage()));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(null, e);\n\t\t}\n\t\treturn list.toArray(new String[]{});\n\t}", "code_tokens": ["public", "static", "String", "[", "]", "validateObject", "(", "ParaObject", "content", ")", "{", "if", "(", "content", "==", "null", ")", "{", "return", "new", "String", "[", "]", "{", "\"", "Object cannot be null.", "\"", "}", ";", "}", "LinkedList", "<", "String", ">", "list", "=", "new", "LinkedList", "<", ">", "(", ")", ";", "try", "{", "for", "(", "ConstraintViolation", "<", "ParaObject", ">", "constraintViolation", ":", "getValidator", "(", ")", ".", "validate", "(", "content", ")", ")", "{", "String", "prop", "=", "\"", "'", "\"", ".", "concat", "(", "constraintViolation", ".", "getPropertyPath", "(", ")", ".", "toString", "(", ")", ")", ".", "concat", "(", "\"", "'", "\"", ")", ";", "list", ".", "add", "(", "prop", ".", "concat", "(", "\"", " ", "\"", ")", ".", "concat", "(", "constraintViolation", ".", "getMessage", "(", ")", ")", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "logger", ".", "error", "(", "null", ",", "e", ")", ";", "}", "return", "list", ".", "toArray", "(", "new", "String", "[", "]", "{", "}", ")", ";", "}"], "idx": 102373, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "fa677c629842df60099daa9c23bd802bc41b48d1", "function_name": "validateObject", "body_hash": "d6996489be8d655bf5193e5cd25ee0632df82a4c"}
{"code": "public String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}", "code_tokens": ["public", "String", "encodeCharacter", "(", "char", "[", "]", "immune", ",", "Character", "c", ")", "{", "String", "cStr", "=", "String", ".", "valueOf", "(", "c", ".", "charValue", "(", ")", ")", ";", "byte", "[", "]", "bytes", ";", "StringBuilder", "sb", ";", "if", "(", "UNENCODED_SET", ".", "contains", "(", "c", ")", ")", "return", "cStr", ";", "bytes", "=", "toUtf8Bytes", "(", "cStr", ")", ";", "sb", "=", "new", "StringBuilder", "(", "bytes", ".", "length", "*", "3", ")", ";", "for", "(", "byte", "b", ":", "bytes", ")", "appendTwoUpperHex", "(", "sb", ".", "append", "(", "'%'", ")", ",", "b", ")", ";", "return", "sb", ".", "toString", "(", ")", ";", "}"], "idx": 41693, "cwe": "CWE-310", "target": 1, "status": "VULNERABLE", "commit": "b7cbc53f9cc967cf1a5a9463d8c6fef9ed6ef4f7", "function_name": "encodeCharacter", "body_hash": "8577b4941f52f7ae3c4dfb7ae9b2edcf81cc90f5"}
{"code": "public SecurityWebFilterChain build() {\n\t\tif(this.built != null) {\n\t\t\tthrow new IllegalStateException(\"This has already been built with the following stacktrace. \" + buildToString());\n\t\t}\n\t\tthis.built = new RuntimeException(\"First Build Invocation\").fillInStackTrace();\n\t\tif(this.headers != null) {\n\t\t\tthis.headers.configure(this);\n\t\t}\n\t\tWebFilter securityContextRepositoryWebFilter = securityContextRepositoryWebFilter();\n\t\tif(securityContextRepositoryWebFilter != null) {\n\t\t\tthis.webFilters.add(securityContextRepositoryWebFilter);\n\t\t}\n\t\tif(this.csrf != null) {\n\t\t\tthis.csrf.configure(this);\n\t\t}\n\t\tif(this.httpBasic != null) {\n\t\t\tthis.httpBasic.authenticationManager(this.authenticationManager);\n\t\t\tthis.httpBasic.configure(this);\n\t\t}\n\t\tif(this.formLogin != null) {\n\t\t\tthis.formLogin.authenticationManager(this.authenticationManager);\n\t\t\tif(this.securityContextRepository != null) {\n\t\t\t\tthis.formLogin.securityContextRepository(this.securityContextRepository);\n\t\t\t}\n\t\t\tif(this.formLogin.authenticationEntryPoint == null) {\n\t\t\t\tthis.webFilters.add(new OrderedWebFilter(new LoginPageGeneratingWebFilter(), SecurityWebFiltersOrder.LOGIN_PAGE_GENERATING.getOrder()));\n\t\t\t\tthis.webFilters.add(new OrderedWebFilter(new LogoutPageGeneratingWebFilter(), SecurityWebFiltersOrder.LOGOUT_PAGE_GENERATING.getOrder()));\n\t\t\t}\n\t\t\tthis.formLogin.configure(this);\n\t\t}\n\t\tif(this.logout != null) {\n\t\t\tthis.logout.configure(this);\n\t\t}\n\t\tthis.requestCache.configure(this);\n\t\tthis.addFilterAt(new SecurityContextServerWebExchangeWebFilter(), SecurityWebFiltersOrder.SECURITY_CONTEXT_SERVER_WEB_EXCHANGE);\n\t\tif(this.authorizeExchange != null) {\n\t\t\tServerAuthenticationEntryPoint authenticationEntryPoint = getAuthenticationEntryPoint();\n\t\t\tExceptionTranslationWebFilter exceptionTranslationWebFilter = new ExceptionTranslationWebFilter();\n\t\t\tif(authenticationEntryPoint != null) {\n\t\t\t\texceptionTranslationWebFilter.setAuthenticationEntryPoint(\n\t\t\t\t\tauthenticationEntryPoint);\n\t\t\t}\n\t\t\tthis.addFilterAt(exceptionTranslationWebFilter, SecurityWebFiltersOrder.EXCEPTION_TRANSLATION);\n\t\t\tthis.authorizeExchange.configure(this);\n\t\t}\n\t\tAnnotationAwareOrderComparator.sort(this.webFilters);\n\t\tList<WebFilter> sortedWebFilters = new ArrayList<>();\n\t\tthis.webFilters.forEach( f -> {\n\t\t\tif(f instanceof OrderedWebFilter) {\n\t\t\t\tf = ((OrderedWebFilter) f).webFilter;\n\t\t\t}\n\t\t\tsortedWebFilters.add(f);\n\t\t});\n\t\treturn new MatcherSecurityWebFilterChain(getSecurityMatcher(), sortedWebFilters);\n\t}", "code_tokens": ["public", "SecurityWebFilterChain", "build", "(", ")", "{", "if", "(", "this", ".", "built", "!=", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "This has already been built with the following stacktrace. ", "\"", "+", "buildToString", "(", ")", ")", ";", "}", "this", ".", "built", "=", "new", "RuntimeException", "(", "\"", "First Build Invocation", "\"", ")", ".", "fillInStackTrace", "(", ")", ";", "if", "(", "this", ".", "headers", "!=", "null", ")", "{", "this", ".", "headers", ".", "configure", "(", "this", ")", ";", "}", "WebFilter", "securityContextRepositoryWebFilter", "=", "securityContextRepositoryWebFilter", "(", ")", ";", "if", "(", "securityContextRepositoryWebFilter", "!=", "null", ")", "{", "this", ".", "webFilters", ".", "add", "(", "securityContextRepositoryWebFilter", ")", ";", "}", "if", "(", "this", ".", "csrf", "!=", "null", ")", "{", "this", ".", "csrf", ".", "configure", "(", "this", ")", ";", "}", "if", "(", "this", ".", "httpBasic", "!=", "null", ")", "{", "this", ".", "httpBasic", ".", "authenticationManager", "(", "this", ".", "authenticationManager", ")", ";", "this", ".", "httpBasic", ".", "configure", "(", "this", ")", ";", "}", "if", "(", "this", ".", "formLogin", "!=", "null", ")", "{", "this", ".", "formLogin", ".", "authenticationManager", "(", "this", ".", "authenticationManager", ")", ";", "if", "(", "this", ".", "securityContextRepository", "!=", "null", ")", "{", "this", ".", "formLogin", ".", "securityContextRepository", "(", "this", ".", "securityContextRepository", ")", ";", "}", "if", "(", "this", ".", "formLogin", ".", "authenticationEntryPoint", "==", "null", ")", "{", "this", ".", "webFilters", ".", "add", "(", "new", "OrderedWebFilter", "(", "new", "LoginPageGeneratingWebFilter", "(", ")", ",", "SecurityWebFiltersOrder", ".", "LOGIN_PAGE_GENERATING", ".", "getOrder", "(", ")", ")", ")", ";", "this", ".", "webFilters", ".", "add", "(", "new", "OrderedWebFilter", "(", "new", "LogoutPageGeneratingWebFilter", "(", ")", ",", "SecurityWebFiltersOrder", ".", "LOGOUT_PAGE_GENERATING", ".", "getOrder", "(", ")", ")", ")", ";", "}", "this", ".", "formLogin", ".", "configure", "(", "this", ")", ";", "}", "if", "(", "this", ".", "logout", "!=", "null", ")", "{", "this", ".", "logout", ".", "configure", "(", "this", ")", ";", "}", "this", ".", "requestCache", ".", "configure", "(", "this", ")", ";", "this", ".", "addFilterAt", "(", "new", "SecurityContextServerWebExchangeWebFilter", "(", ")", ",", "SecurityWebFiltersOrder", ".", "SECURITY_CONTEXT_SERVER_WEB_EXCHANGE", ")", ";", "if", "(", "this", ".", "authorizeExchange", "!=", "null", ")", "{", "ServerAuthenticationEntryPoint", "authenticationEntryPoint", "=", "getAuthenticationEntryPoint", "(", ")", ";", "ExceptionTranslationWebFilter", "exceptionTranslationWebFilter", "=", "new", "ExceptionTranslationWebFilter", "(", ")", ";", "if", "(", "authenticationEntryPoint", "!=", "null", ")", "{", "exceptionTranslationWebFilter", ".", "setAuthenticationEntryPoint", "(", "authenticationEntryPoint", ")", ";", "}", "this", ".", "addFilterAt", "(", "exceptionTranslationWebFilter", ",", "SecurityWebFiltersOrder", ".", "EXCEPTION_TRANSLATION", ")", ";", "this", ".", "authorizeExchange", ".", "configure", "(", "this", ")", ";", "}", "AnnotationAwareOrderComparator", ".", "sort", "(", "this", ".", "webFilters", ")", ";", "List", "<", "WebFilter", ">", "sortedWebFilters", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "this", ".", "webFilters", ".", "forEach", "(", "f", "->", "{", "if", "(", "f", "instanceof", "OrderedWebFilter", ")", "{", "f", "=", "(", "(", "OrderedWebFilter", ")", "f", ")", ".", "webFilter", ";", "}", "sortedWebFilters", ".", "add", "(", "f", ")", ";", "}", ")", ";", "return", "new", "MatcherSecurityWebFilterChain", "(", "getSecurityMatcher", "(", ")", ",", "sortedWebFilters", ")", ";", "}"], "idx": 86264, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "7b8fa90d96aaf751a3256fa755d5f17e081c20f", "function_name": "build", "body_hash": "177fe0b273ca499eed25cf840a0fecca9d9db9a5"}
{"code": "protected void run() {\n        JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();\n        sf.setResourceClasses(MultipartStore.class);\n        \n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(AttachmentDeserializer.ATTACHMENT_MAX_SIZE, String.valueOf(1024 * 10));\n        props.put(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD, String.valueOf(1024 * 5));\n        props.put(AttachmentDeserializer.ATTACHMENT_MAX_HEADER_SIZE, String.valueOf(400));\n        sf.setProperties(props);\n        //default lifecycle is per-request, change it to singleton\n        sf.setResourceProvider(MultipartStore.class,\n                               new SingletonResourceProvider(new MultipartStore()));\n        sf.setAddress(\"http://localhost:\" + PORT + \"/\");\n\n        server = sf.create();        \n    }", "code_tokens": ["protected", "void", "run", "(", ")", "{", "JAXRSServerFactoryBean", "sf", "=", "new", "JAXRSServerFactoryBean", "(", ")", ";", "sf", ".", "setResourceClasses", "(", "MultipartStore", ".", "class", ")", ";", "Map", "<", "String", ",", "Object", ">", "props", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MAX_SIZE", ",", "String", ".", "valueOf", "(", "1024", "*", "10", ")", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MEMORY_THRESHOLD", ",", "String", ".", "valueOf", "(", "1024", "*", "5", ")", ")", ";", "props", ".", "put", "(", "AttachmentDeserializer", ".", "ATTACHMENT_MAX_HEADER_SIZE", ",", "String", ".", "valueOf", "(", "400", ")", ")", ";", "sf", ".", "setProperties", "(", "props", ")", ";", "sf", ".", "setResourceProvider", "(", "MultipartStore", ".", "class", ",", "new", "SingletonResourceProvider", "(", "new", "MultipartStore", "(", ")", ")", ")", ";", "sf", ".", "setAddress", "(", "\"", "http://localhost:", "\"", "+", "PORT", "+", "\"", "/", "\"", ")", ";", "server", "=", "sf", ".", "create", "(", ")", ";", "}"], "idx": 107980, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "896bd961cbbb6b8569700e5b70229f78f94ad9d", "function_name": "run", "body_hash": "818f860c27ab981b0d2304ae4853c4de25b75b2f"}
{"code": "public FormValidation doCheckUrl(@QueryParameter String value) {\n            try {\n                URLConnection conn = ProxyConfiguration.open(new URL(value));\n                conn.connect();\n                if (conn instanceof HttpURLConnection) {\n                    if (((HttpURLConnection) conn).getResponseCode() != HttpURLConnection.HTTP_OK) {\n                        return FormValidation.error(Messages.ZipExtractionInstaller_bad_connection());\n                    }\n                }\n                return FormValidation.ok();\n            } catch (MalformedURLException x) {\n                return FormValidation.error(Messages.ZipExtractionInstaller_malformed_url());\n            } catch (IOException x) {\n                return FormValidation.error(x,Messages.ZipExtractionInstaller_could_not_connect());\n            }\n        }", "code_tokens": ["public", "FormValidation", "doCheckUrl", "(", "@", "QueryParameter", "String", "value", ")", "{", "try", "{", "URLConnection", "conn", "=", "ProxyConfiguration", ".", "open", "(", "new", "URL", "(", "value", ")", ")", ";", "conn", ".", "connect", "(", ")", ";", "if", "(", "conn", "instanceof", "HttpURLConnection", ")", "{", "if", "(", "(", "(", "HttpURLConnection", ")", "conn", ")", ".", "getResponseCode", "(", ")", "!=", "HttpURLConnection", ".", "HTTP_OK", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ZipExtractionInstaller_bad_connection", "(", ")", ")", ";", "}", "}", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "catch", "(", "MalformedURLException", "x", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ZipExtractionInstaller_malformed_url", "(", ")", ")", ";", "}", "catch", "(", "IOException", "x", ")", "{", "return", "FormValidation", ".", "error", "(", "x", ",", "Messages", ".", "ZipExtractionInstaller_could_not_connect", "(", ")", ")", ";", "}", "}"], "idx": 44413, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "6eea1e97840b5623829b2c1fd2e363c045bdc230", "function_name": "doCheckUrl", "body_hash": "667ef130321d0f7cdae1783c579cd0f855901809"}
{"code": "final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }", "code_tokens": ["final", "static", "private", "XMLStreamReader", "createXMLStreamReader", "(", "InputStream", "inputStream", ")", "throws", "XMLStreamException", ",", "IOException", "{", "XMLInputFactory", "factory", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "IS_COALESCING", ",", "true", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "IS_REPLACING_ENTITY_REFERENCES", ",", "true", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "SUPPORT_DTD", ",", "false", ")", ";", "return", "factory", ".", "createXMLStreamReader", "(", "wrapPrefixRemovingInputStream", "(", "inputStream", ")", ")", ";", "}"], "idx": 67857, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "6a0d7d56e4ffb420316ce7849fde881344fbf881", "function_name": "createXMLStreamReader", "body_hash": "fa48e106456a7238b90ac5b847b33fa15efcfbc3"}
{"code": "public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null)\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", Functions.validateIconSize(qs));\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }", "code_tokens": ["public", "void", "doIconSize", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "qs", "=", "req", ".", "getQueryString", "(", ")", ";", "if", "(", "qs", "==", "null", ")", "throw", "new", "ServletException", "(", ")", ";", "Cookie", "cookie", "=", "new", "Cookie", "(", "\"", "iconSize", "\"", ",", "Functions", ".", "validateIconSize", "(", "qs", ")", ")", ";", "cookie", ".", "setMaxAge", "(", "9999999", ")", ";", "rsp", ".", "addCookie", "(", "cookie", ")", ";", "String", "ref", "=", "req", ".", "getHeader", "(", "\"", "Referer", "\"", ")", ";", "if", "(", "ref", "==", "null", ")", "ref", "=", "\"", ".", "\"", ";", "rsp", ".", "sendRedirect2", "(", "ref", ")", ";", "}"], "idx": 78497, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "a0b00508eeb74d7033dc4100eb382df4e8fa72e7", "function_name": "doIconSize", "body_hash": "ac1504ef06bdfbcc6c60dde05168a66be1b3f5eb"}
{"code": "@Override\n\t\tpublic void setPropertyValue(String propertyName, Object value) throws BeansException {\n\n\t\t\tif (!isWritableProperty(propertyName)) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName);\n\t\t\t}\n\n\t\t\tPropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();\n\t\t\tTypeInformation<?> owningType = leafProperty.getOwningType();\n\t\t\tTypeInformation<?> propertyType = owningType.getProperty(leafProperty.getSegment());\n\n\t\t\tpropertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n\n\t\t\tif (conversionRequired(value, propertyType.getType())) {\n\n\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),\n\t\t\t\t\t\tleafProperty.getSegment());\n\t\t\t\tMethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n\n\t\t\t\tvalue = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n\t\t\t}\n\n\t\t\tEvaluationContext context = SimpleEvaluationContext //\n\n\t\t\t\t\t.forPropertyAccessors(new PropertyTraversingMapAccessor(type, conversionService)) //\n\t\t\t\t\t.withConversionService(conversionService) //\n\t\t\t\t\t.withRootObject(map) //\n\t\t\t\t\t.build();\n\n\t\t\tExpression expression = PARSER.parseExpression(propertyName);\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(context, value);\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O);\n\t\t\t}\n\t\t}", "code_tokens": ["@", "Override", "public", "void", "setPropertyValue", "(", "String", "propertyName", ",", "Object", "value", ")", "throws", "BeansException", "{", "if", "(", "!", "isWritableProperty", "(", "propertyName", ")", ")", "{", "throw", "new", "NotWritablePropertyException", "(", "type", ",", "propertyName", ")", ";", "}", "PropertyPath", "leafProperty", "=", "getPropertyPath", "(", "propertyName", ")", ".", "getLeafProperty", "(", ")", ";", "TypeInformation", "<", "?", ">", "owningType", "=", "leafProperty", ".", "getOwningType", "(", ")", ";", "TypeInformation", "<", "?", ">", "propertyType", "=", "owningType", ".", "getProperty", "(", "leafProperty", ".", "getSegment", "(", ")", ")", ";", "propertyType", "=", "propertyName", ".", "endsWith", "(", "\"", "]", "\"", ")", "?", "propertyType", ".", "getActualType", "(", ")", ":", "propertyType", ";", "if", "(", "conversionRequired", "(", "value", ",", "propertyType", ".", "getType", "(", ")", ")", ")", "{", "PropertyDescriptor", "descriptor", "=", "BeanUtils", ".", "getPropertyDescriptor", "(", "owningType", ".", "getType", "(", ")", ",", "leafProperty", ".", "getSegment", "(", ")", ")", ";", "MethodParameter", "methodParameter", "=", "new", "MethodParameter", "(", "descriptor", ".", "getReadMethod", "(", ")", ",", "-", "1", ")", ";", "TypeDescriptor", "typeDescriptor", "=", "TypeDescriptor", ".", "nested", "(", "methodParameter", ",", "0", ")", ";", "value", "=", "conversionService", ".", "convert", "(", "value", ",", "TypeDescriptor", ".", "forObject", "(", "value", ")", ",", "typeDescriptor", ")", ";", "}", "EvaluationContext", "context", "=", "SimpleEvaluationContext", ".", "forPropertyAccessors", "(", "new", "PropertyTraversingMapAccessor", "(", "type", ",", "conversionService", ")", ")", ".", "withConversionService", "(", "conversionService", ")", ".", "withRootObject", "(", "map", ")", ".", "build", "(", ")", ";", "Expression", "expression", "=", "PARSER", ".", "parseExpression", "(", "propertyName", ")", ";", "try", "{", "expression", ".", "setValue", "(", "context", ",", "value", ")", ";", "}", "catch", "(", "SpelEvaluationException", "o_O", ")", "{", "throw", "new", "NotWritablePropertyException", "(", "type", ",", "propertyName", ",", "\"", "Could not write property!", "\"", ",", "o_O", ")", ";", "}", "}"], "idx": 11868, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "b1a20ae1e82a63f99b3afc6f2aaedb3bf4dc432", "function_name": "setPropertyValue", "body_hash": "4f8dc5d42290a4268cfd0f9ac0db1c33f72c3c03"}
{"code": "public List<String> getUserList(JdbcRealm obj) {\n    List<String> userlist = new ArrayList<>();\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    DataSource dataSource = null;\n    String authQuery = \"\";\n    String retval[];\n    String tablename = \"\";\n    String username = \"\";\n    String userquery = \"\";\n    try {\n      dataSource = (DataSource) FieldUtils.readField(obj, \"dataSource\", true);\n      authQuery = (String) FieldUtils.readField(obj, \"authenticationQuery\", true);\n      LOG.info(authQuery);\n      String authQueryLowerCase = authQuery.toLowerCase();\n      retval = authQueryLowerCase.split(\"from\", 2);\n      if (retval.length >= 2) {\n        retval = retval[1].split(\"with|where\", 2);\n        tablename = retval[0];\n        retval = retval[1].split(\"where\", 2);\n        if (retval.length >= 2)\n          retval = retval[1].split(\"=\", 2);\n        else\n          retval = retval[0].split(\"=\", 2);\n        username = retval[0];\n      }\n\n      if (StringUtils.isBlank(username) || StringUtils.isBlank(tablename)) {\n        return userlist;\n      }\n\n      userquery = \"select ? from ?\";\n\n    } catch (IllegalAccessException e) {\n      LOG.error(\"Error while accessing dataSource for JDBC Realm\", e);\n      return null;\n    }\n\n    try {\n      Connection con = dataSource.getConnection();\n      ps = con.prepareStatement(userquery);\n      ps.setString(1, username);\n      ps.setString(2, tablename);\n      rs = ps.executeQuery();\n      while (rs.next()) {\n        userlist.add(rs.getString(1).trim());\n      }\n    } catch (Exception e) {\n      LOG.error(\"Error retrieving User list from JDBC Realm\", e);\n    } finally {\n      JdbcUtils.closeResultSet(rs);\n      JdbcUtils.closeStatement(ps);\n    }\n    return userlist;\n  }", "code_tokens": ["public", "List", "<", "String", ">", "getUserList", "(", "JdbcRealm", "obj", ")", "{", "List", "<", "String", ">", "userlist", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "PreparedStatement", "ps", "=", "null", ";", "ResultSet", "rs", "=", "null", ";", "DataSource", "dataSource", "=", "null", ";", "String", "authQuery", "=", "\"", "\"", ";", "String", "retval", "[", "]", ";", "String", "tablename", "=", "\"", "\"", ";", "String", "username", "=", "\"", "\"", ";", "String", "userquery", "=", "\"", "\"", ";", "try", "{", "dataSource", "=", "(", "DataSource", ")", "FieldUtils", ".", "readField", "(", "obj", ",", "\"", "dataSource", "\"", ",", "true", ")", ";", "authQuery", "=", "(", "String", ")", "FieldUtils", ".", "readField", "(", "obj", ",", "\"", "authenticationQuery", "\"", ",", "true", ")", ";", "LOG", ".", "info", "(", "authQuery", ")", ";", "String", "authQueryLowerCase", "=", "authQuery", ".", "toLowerCase", "(", ")", ";", "retval", "=", "authQueryLowerCase", ".", "split", "(", "\"", "from", "\"", ",", "2", ")", ";", "if", "(", "retval", ".", "length", ">=", "2", ")", "{", "retval", "=", "retval", "[", "1", "]", ".", "split", "(", "\"", "with|where", "\"", ",", "2", ")", ";", "tablename", "=", "retval", "[", "0", "]", ";", "retval", "=", "retval", "[", "1", "]", ".", "split", "(", "\"", "where", "\"", ",", "2", ")", ";", "if", "(", "retval", ".", "length", ">=", "2", ")", "retval", "=", "retval", "[", "1", "]", ".", "split", "(", "\"", "=", "\"", ",", "2", ")", ";", "else", "retval", "=", "retval", "[", "0", "]", ".", "split", "(", "\"", "=", "\"", ",", "2", ")", ";", "username", "=", "retval", "[", "0", "]", ";", "}", "if", "(", "StringUtils", ".", "isBlank", "(", "username", ")", "||", "StringUtils", ".", "isBlank", "(", "tablename", ")", ")", "{", "return", "userlist", ";", "}", "userquery", "=", "\"", "select ? from ?", "\"", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "LOG", ".", "error", "(", "\"", "Error while accessing dataSource for JDBC Realm", "\"", ",", "e", ")", ";", "return", "null", ";", "}", "try", "{", "Connection", "con", "=", "dataSource", ".", "getConnection", "(", ")", ";", "ps", "=", "con", ".", "prepareStatement", "(", "userquery", ")", ";", "ps", ".", "setString", "(", "1", ",", "username", ")", ";", "ps", ".", "setString", "(", "2", ",", "tablename", ")", ";", "rs", "=", "ps", ".", "executeQuery", "(", ")", ";", "while", "(", "rs", ".", "next", "(", ")", ")", "{", "userlist", ".", "add", "(", "rs", ".", "getString", "(", "1", ")", ".", "trim", "(", ")", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "error", "(", "\"", "Error retrieving User list from JDBC Realm", "\"", ",", "e", ")", ";", "}", "finally", "{", "JdbcUtils", ".", "closeResultSet", "(", "rs", ")", ";", "JdbcUtils", ".", "closeStatement", "(", "ps", ")", ";", "}", "return", "userlist", ";", "}"], "idx": 12402, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "709c5a70a8f37277c9eea0a1c0c9195b5eb21a74", "function_name": "getUserList", "body_hash": "afc2fa6d3ced5987247b8aa45cacf84aaabd32bb"}
{"code": "protected Number extractFloat() throws ParseException {\n\t\tif (!acceptLeadinZero)\n\t\t\tcheckLeadinZero();\n\t\tif (!useHiPrecisionFloat)\n\t\t\treturn Float.parseFloat(xs);\n\t\tif (xs.length() > 18) // follow JSonIJ parsing method\n\t\t\treturn new BigDecimal(xs);\n\t\treturn Double.parseDouble(xs);\n\t}", "code_tokens": ["protected", "Number", "extractFloat", "(", ")", "throws", "ParseException", "{", "if", "(", "!", "acceptLeadinZero", ")", "checkLeadinZero", "(", ")", ";", "if", "(", "!", "useHiPrecisionFloat", ")", "return", "Float", ".", "parseFloat", "(", "xs", ")", ";", "if", "(", "xs", ".", "length", "(", ")", ">", "18", ")", "return", "new", "BigDecimal", "(", "xs", ")", ";", "return", "Double", ".", "parseDouble", "(", "xs", ")", ";", "}"], "idx": 74248, "cwe": "CWE-754", "target": 1, "status": "VULNERABLE", "commit": "7304d1e9fee8af72c93e7e31bb3f91445e479d53", "function_name": "extractFloat", "body_hash": "ad23500e6ba6d26fc87c980694360d060053ae8b"}
{"code": "protected DocumentBuilder getDocumentBuilder() throws IOException {\n        DocumentBuilder result = null;\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(isNamespaceAware());\n            dbf.setValidating(isValidatingDtd());\n            dbf.setCoalescing(isCoalescing());\n            dbf.setExpandEntityReferences(isExpandingEntityRefs());\n            dbf.setIgnoringComments(isIgnoringComments());\n            dbf.setIgnoringElementContentWhitespace(isIgnoringExtraWhitespaces());\n\n            try {\n                dbf.setXIncludeAware(isXIncludeAware());\n            } catch (UnsupportedOperationException uoe) {\n                Context.getCurrentLogger().log(Level.FINE,\n                        \"The JAXP parser doesn't support XInclude.\", uoe);\n            }\n\n            // [ifndef android]\n            javax.xml.validation.Schema xsd = getSchema();\n\n            if (xsd != null) {\n                dbf.setSchema(xsd);\n            }\n            // [enddef]\n\n            result = dbf.newDocumentBuilder();\n            result.setEntityResolver(getEntityResolver());\n            result.setErrorHandler(getErrorHandler());\n        } catch (ParserConfigurationException pce) {\n            throw new IOException(\"Couldn't create the empty document: \"\n                    + pce.getMessage());\n        }\n\n        return result;\n    }", "code_tokens": ["protected", "DocumentBuilder", "getDocumentBuilder", "(", ")", "throws", "IOException", "{", "DocumentBuilder", "result", "=", "null", ";", "try", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "dbf", ".", "setNamespaceAware", "(", "isNamespaceAware", "(", ")", ")", ";", "dbf", ".", "setValidating", "(", "isValidatingDtd", "(", ")", ")", ";", "dbf", ".", "setCoalescing", "(", "isCoalescing", "(", ")", ")", ";", "dbf", ".", "setExpandEntityReferences", "(", "isExpandingEntityRefs", "(", ")", ")", ";", "dbf", ".", "setIgnoringComments", "(", "isIgnoringComments", "(", ")", ")", ";", "dbf", ".", "setIgnoringElementContentWhitespace", "(", "isIgnoringExtraWhitespaces", "(", ")", ")", ";", "try", "{", "dbf", ".", "setXIncludeAware", "(", "isXIncludeAware", "(", ")", ")", ";", "}", "catch", "(", "UnsupportedOperationException", "uoe", ")", "{", "Context", ".", "getCurrentLogger", "(", ")", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "The JAXP parser doesn't support XInclude.", "\"", ",", "uoe", ")", ";", "}", "javax", ".", "xml", ".", "validation", ".", "Schema", "xsd", "=", "getSchema", "(", ")", ";", "if", "(", "xsd", "!=", "null", ")", "{", "dbf", ".", "setSchema", "(", "xsd", ")", ";", "}", "result", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "result", ".", "setEntityResolver", "(", "getEntityResolver", "(", ")", ")", ";", "result", ".", "setErrorHandler", "(", "getErrorHandler", "(", ")", ")", ";", "}", "catch", "(", "ParserConfigurationException", "pce", ")", "{", "throw", "new", "IOException", "(", "\"", "Couldn't create the empty document: ", "\"", "+", "pce", ".", "getMessage", "(", ")", ")", ";", "}", "return", "result", ";", "}"], "idx": 67900, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "97a8d1d62612683817c785e99c4166bcde8cf1c", "function_name": "getDocumentBuilder", "body_hash": "0138e3dc0e29607bb4ca6d428297ab73157b8676"}
{"code": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }", "code_tokens": ["public", "void", "validateSubType", "(", "DeserializationContext", "ctxt", ",", "JavaType", "type", ")", "throws", "JsonMappingException", "{", "final", "Class", "<", "?", ">", "raw", "=", "type", ".", "getRawClass", "(", ")", ";", "String", "full", "=", "raw", ".", "getName", "(", ")", ";", "main_check", ":", "do", "{", "if", "(", "_cfgIllegalClassNames", ".", "contains", "(", "full", ")", ")", "{", "break", ";", "}", "if", "(", "raw", ".", "isInterface", "(", ")", ")", "{", ";", "}", "else", "if", "(", "full", ".", "startsWith", "(", "PREFIX_SPRING", ")", ")", "{", "for", "(", "Class", "<", "?", ">", "cls", "=", "raw", ";", "(", "cls", "!=", "null", ")", "&&", "(", "cls", "!=", "Object", ".", "class", ")", ";", "cls", "=", "cls", ".", "getSuperclass", "(", ")", ")", "{", "String", "name", "=", "cls", ".", "getSimpleName", "(", ")", ";", "if", "(", "\"", "AbstractPointcutAdvisor", "\"", ".", "equals", "(", "name", ")", "||", "\"", "AbstractApplicationContext", "\"", ".", "equals", "(", "name", ")", ")", "{", "break", "main_check", ";", "}", "}", "}", "else", "if", "(", "full", ".", "startsWith", "(", "PREFIX_C3P0", ")", ")", "{", "if", "(", "full", ".", "endsWith", "(", "\"", "DataSource", "\"", ")", ")", "{", "break", "main_check", ";", "}", "}", "return", ";", "}", "while", "(", "false", ")", ";", "throw", "JsonMappingException", ".", "from", "(", "ctxt", ",", "String", ".", "format", "(", "\"", "Illegal type (%s) to deserialize: prevented for security reasons", "\"", ",", "full", ")", ")", ";", "}"], "idx": 2554, "cwe": "CWE-184", "target": 0, "status": "FIXED", "commit": "6799f8f10cc78e9af6d443ed6982d00a13f2e7d2", "function_name": "validateSubType", "body_hash": "7706fc6e8060adb22657b4bbfdc39d12cad1a8f0"}
{"code": "public static String javaScriptEscape(String input) {\n\t\tif (input == null) {\n\t\t\treturn input;\n\t\t}\n\n\t\tStringBuilder filtered = new StringBuilder(input.length());\n\t\tchar prevChar = '\\u0000';\n\t\tchar c;\n\t\tfor (int i = 0; i < input.length(); i++) {\n\t\t\tc = input.charAt(i);\n\t\t\tif (c == '\"') {\n\t\t\t\tfiltered.append(\"\\\\\\\"\");\n\t\t\t}\n\t\t\telse if (c == '\\'') {\n\t\t\t\tfiltered.append(\"\\\\'\");\n\t\t\t}\n\t\t\telse if (c == '\\\\') {\n\t\t\t\tfiltered.append(\"\\\\\\\\\");\n\t\t\t}\n\t\t\telse if (c == '/') {\n\t\t\t\tfiltered.append(\"\\\\/\");\n\t\t\t}\n\t\t\telse if (c == '\\t') {\n\t\t\t\tfiltered.append(\"\\\\t\");\n\t\t\t}\n\t\t\telse if (c == '\\n') {\n\t\t\t\tif (prevChar != '\\r') {\n\t\t\t\t\tfiltered.append(\"\\\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == '\\r') {\n\t\t\t\tfiltered.append(\"\\\\n\");\n\t\t\t}\n\t\t\telse if (c == '\\f') {\n\t\t\t\tfiltered.append(\"\\\\f\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfiltered.append(c);\n\t\t\t}\n\t\t\tprevChar = c;\n\n\t\t}\n\t\treturn filtered.toString();\n\t}", "code_tokens": ["public", "static", "String", "javaScriptEscape", "(", "String", "input", ")", "{", "if", "(", "input", "==", "null", ")", "{", "return", "input", ";", "}", "StringBuilder", "filtered", "=", "new", "StringBuilder", "(", "input", ".", "length", "(", ")", ")", ";", "char", "prevChar", "=", "'\\u0000'", ";", "char", "c", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "input", ".", "length", "(", ")", ";", "i", "++", ")", "{", "c", "=", "input", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "'\"'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "\\\"", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\''", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "'", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\\\'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "\\\\", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'/'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "/", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\t'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "t", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\n'", ")", "{", "if", "(", "prevChar", "!=", "'\\r'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "n", "\"", ")", ";", "}", "}", "else", "if", "(", "c", "==", "'\\r'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "n", "\"", ")", ";", "}", "else", "if", "(", "c", "==", "'\\f'", ")", "{", "filtered", ".", "append", "(", "\"", "\\\\", "f", "\"", ")", ";", "}", "else", "{", "filtered", ".", "append", "(", "c", ")", ";", "}", "prevChar", "=", "c", ";", "}", "return", "filtered", ".", "toString", "(", ")", ";", "}"], "idx": 79725, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "7a7df6637478607bef0277bf52a4e0a03e20a248", "function_name": "javaScriptEscape", "body_hash": "811804797bed97c7fa3e4a555317862d1a796296"}
{"code": "public static ClusterNodeInformation unmarshal(final InputStream is) throws JAXBException {\n        final Unmarshaller unmarshaller = JAXB_CONTEXT.createUnmarshaller();\n        return (ClusterNodeInformation) unmarshaller.unmarshal(is);\n    }", "code_tokens": ["public", "static", "ClusterNodeInformation", "unmarshal", "(", "final", "InputStream", "is", ")", "throws", "JAXBException", "{", "final", "Unmarshaller", "unmarshaller", "=", "JAXB_CONTEXT", ".", "createUnmarshaller", "(", ")", ";", "return", "(", "ClusterNodeInformation", ")", "unmarshaller", ".", "unmarshal", "(", "is", ")", ";", "}"], "idx": 67994, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "9e2c7be7d3c6a380c5f61074d9a5a690b617c3dc", "function_name": "unmarshal", "body_hash": "d2411b0601326461f4cfccf79776282f8f636a11"}
{"code": "private void signIn(String userName, String password) {\n        webDriver.get(baseUrl + \"/logout.do\");\n        webDriver.get(baseUrl + \"/login\");\n        webDriver.findElement(By.name(\"username\")).sendKeys(userName);\n        webDriver.findElement(By.name(\"password\")).sendKeys(password);\n        webDriver.findElement(By.xpath(\"//input[@value='Sign in']\")).click();\n        assertThat(webDriver.findElement(By.cssSelector(\"h1\")).getText(), containsString(\"Where to?\"));\n    }", "code_tokens": ["private", "void", "signIn", "(", "String", "userName", ",", "String", "password", ")", "{", "webDriver", ".", "get", "(", "baseUrl", "+", "\"", "/logout.do", "\"", ")", ";", "webDriver", ".", "get", "(", "baseUrl", "+", "\"", "/login", "\"", ")", ";", "webDriver", ".", "findElement", "(", "By", ".", "name", "(", "\"", "username", "\"", ")", ")", ".", "sendKeys", "(", "userName", ")", ";", "webDriver", ".", "findElement", "(", "By", ".", "name", "(", "\"", "password", "\"", ")", ")", ".", "sendKeys", "(", "password", ")", ";", "webDriver", ".", "findElement", "(", "By", ".", "xpath", "(", "\"", "//input[@value='Sign in']", "\"", ")", ")", ".", "click", "(", ")", ";", "assertThat", "(", "webDriver", ".", "findElement", "(", "By", ".", "cssSelector", "(", "\"", "h1", "\"", ")", ")", ".", "getText", "(", ")", ",", "containsString", "(", "\"", "Where to?", "\"", ")", ")", ";", "}"], "idx": 35172, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "14350228989e2aee900b8d48a848293bb5152b6f", "function_name": "signIn", "body_hash": "fed5a29d8370b9925ecea894ceb2327e39ba259d"}
{"code": "private void prepareRequest() throws IOException {\n\n        http11 = true;\n        http09 = false;\n        contentDelimitation = false;\n\n        if (protocol.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n        MessageBytes protocolMB = request.protocol();\n        if (protocolMB.equals(Constants.HTTP_11)) {\n            protocolMB.setString(Constants.HTTP_11);\n        } else if (protocolMB.equals(Constants.HTTP_10)) {\n            http11 = false;\n            keepAlive = false;\n            protocolMB.setString(Constants.HTTP_10);\n        } else if (protocolMB.equals(\"\")) {\n            // HTTP/0.9\n            http09 = true;\n            http11 = false;\n            keepAlive = false;\n        } else {\n            // Unsupported protocol\n            http11 = false;\n            // Send 505; Unsupported HTTP version\n            response.setStatus(505);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n            }\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        Pattern restrictedUserAgents = protocol.getRestrictedUserAgentsPattern();\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        // \"identity\" codings are ignored\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    // Invalid transfer encoding\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n                }\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "http11", "=", "true", ";", "http09", "=", "false", ";", "contentDelimitation", "=", "false", ";", "if", "(", "protocol", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MessageBytes", "protocolMB", "=", "request", ".", "protocol", "(", ")", ";", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_11", ")", ")", "{", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_11", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_10", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_10", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "\"", "\"", ")", ")", "{", "http09", "=", "true", ";", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "http11", "=", "false", ";", "response", ".", "setStatus", "(", "505", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Unsupported HTTP version ", "\\\"", "\"", "+", "protocolMB", "+", "\"", "\\\"", "\"", ")", ";", "}", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEP_ALIVE_HEADER_VALUE_TOKEN", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "inputBuffer", ".", "setSwallowInput", "(", "false", ")", ";", "request", ".", "setExpectation", "(", "true", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "Pattern", "restrictedUserAgents", "=", "protocol", ".", "getRestrictedUserAgentsPattern", "(", ")", ";", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "(", "http11", "||", "keepAlive", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "protocol", ".", "getAllowHostHeaderMismatch", "(", ")", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "inputBuffer", ".", "getFilters", "(", ")", ";", "if", "(", "http11", ")", "{", "MessageBytes", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ")", "{", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidTransferEncoding", "\"", ")", ";", "}", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "}", "else", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 54454, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "060ecc5", "function_name": "prepareRequest", "body_hash": "b8444a5ef7a4d3e2e610dc65226af3ac053a0aa0"}
{"code": "@Path(\"{id}\")\n    @PUT\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response updateUser(final @PathParam(\"id\") String id, final UserRepresentation rep) {\n        auth.requireManage();\n\n        try {\n            UserModel user = session.users().getUserById(id, realm);\n            if (user == null) {\n                throw new NotFoundException(\"User not found\");\n            }\n\n             Set<String> attrsToRemove;\n            if (rep.getAttributes() != null) {\n                attrsToRemove = new HashSet<>(user.getAttributes().keySet());\n                attrsToRemove.removeAll(rep.getAttributes().keySet());\n            } else {\n                attrsToRemove = Collections.emptySet();\n            }\n\n            if (rep.isEnabled() != null && rep.isEnabled()) {\n                UserLoginFailureModel failureModel = session.sessions().getUserLoginFailure(realm, id);\n                if (failureModel != null) {\n                    failureModel.clearFailures();\n                }\n            }\n\n            updateUserFromRep(user, rep, attrsToRemove, realm, session, true);\n            adminEvent.operation(OperationType.UPDATE).resourcePath(uriInfo).representation(rep).success();\n\n            if (session.getTransactionManager().isActive()) {\n                session.getTransactionManager().commit();\n            }\n            return Response.noContent().build();\n        } catch (ModelDuplicateException e) {\n            return ErrorResponse.exists(\"User exists with same username or email\");\n        } catch (ModelReadOnlyException re) {\n            return ErrorResponse.exists(\"User is read only!\");\n        } catch (ModelException me) {\n            return ErrorResponse.exists(\"Could not update user!\");\n        } catch (Exception me) { // JPA may be committed by JTA which can't \n            return ErrorResponse.exists(\"Could not update user!\");\n        }\n    }", "code_tokens": ["@", "Path", "(", "\"", "{id}", "\"", ")", "@", "PUT", "@", "Consumes", "(", "MediaType", ".", "APPLICATION_JSON", ")", "public", "Response", "updateUser", "(", "final", "@", "PathParam", "(", "\"", "id", "\"", ")", "String", "id", ",", "final", "UserRepresentation", "rep", ")", "{", "auth", ".", "requireManage", "(", ")", ";", "try", "{", "UserModel", "user", "=", "session", ".", "users", "(", ")", ".", "getUserById", "(", "id", ",", "realm", ")", ";", "if", "(", "user", "==", "null", ")", "{", "throw", "new", "NotFoundException", "(", "\"", "User not found", "\"", ")", ";", "}", "Set", "<", "String", ">", "attrsToRemove", ";", "if", "(", "rep", ".", "getAttributes", "(", ")", "!=", "null", ")", "{", "attrsToRemove", "=", "new", "HashSet", "<", ">", "(", "user", ".", "getAttributes", "(", ")", ".", "keySet", "(", ")", ")", ";", "attrsToRemove", ".", "removeAll", "(", "rep", ".", "getAttributes", "(", ")", ".", "keySet", "(", ")", ")", ";", "}", "else", "{", "attrsToRemove", "=", "Collections", ".", "emptySet", "(", ")", ";", "}", "if", "(", "rep", ".", "isEnabled", "(", ")", "!=", "null", "&&", "rep", ".", "isEnabled", "(", ")", ")", "{", "UserLoginFailureModel", "failureModel", "=", "session", ".", "sessions", "(", ")", ".", "getUserLoginFailure", "(", "realm", ",", "id", ")", ";", "if", "(", "failureModel", "!=", "null", ")", "{", "failureModel", ".", "clearFailures", "(", ")", ";", "}", "}", "updateUserFromRep", "(", "user", ",", "rep", ",", "attrsToRemove", ",", "realm", ",", "session", ",", "true", ")", ";", "adminEvent", ".", "operation", "(", "OperationType", ".", "UPDATE", ")", ".", "resourcePath", "(", "uriInfo", ")", ".", "representation", "(", "rep", ")", ".", "success", "(", ")", ";", "if", "(", "session", ".", "getTransactionManager", "(", ")", ".", "isActive", "(", ")", ")", "{", "session", ".", "getTransactionManager", "(", ")", ".", "commit", "(", ")", ";", "}", "return", "Response", ".", "noContent", "(", ")", ".", "build", "(", ")", ";", "}", "catch", "(", "ModelDuplicateException", "e", ")", "{", "return", "ErrorResponse", ".", "exists", "(", "\"", "User exists with same username or email", "\"", ")", ";", "}", "catch", "(", "ModelReadOnlyException", "re", ")", "{", "return", "ErrorResponse", ".", "exists", "(", "\"", "User is read only!", "\"", ")", ";", "}", "catch", "(", "ModelException", "me", ")", "{", "return", "ErrorResponse", ".", "exists", "(", "\"", "Could not update user!", "\"", ")", ";", "}", "catch", "(", "Exception", "me", ")", "{", "return", "ErrorResponse", ".", "exists", "(", "\"", "Could not update user!", "\"", ")", ";", "}", "}"], "idx": 34072, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "a78cfa4b2ca979a1981fb371cfdf2c7212f7b6e2", "function_name": "updateUser", "body_hash": "99ada040b4ea63132a60d490add1e03e3b4b9ace"}
{"code": "@Nullable\n  SearchResult getLdapUserObject(BasicAuthLDAPConfig ldapConfig, DirContext context, String username)\n  {\n    try {\n      SearchControls sc = new SearchControls();\n      sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n      sc.setReturningAttributes(new String[] {ldapConfig.getUserAttribute(), \"memberOf\" });\n      NamingEnumeration<SearchResult> results = context.search(\n          ldapConfig.getBaseDn(),\n          StringUtils.format(ldapConfig.getUserSearch(), username),\n          sc);\n      try {\n        if (!results.hasMore()) {\n          return null;\n        }\n        return results.next();\n      }\n      finally {\n        results.close();\n      }\n    }\n    catch (NamingException e) {\n      LOG.debug(e, \"Unable to find user '%s'\", username);\n      return null;\n    }\n  }", "code_tokens": ["@", "Nullable", "SearchResult", "getLdapUserObject", "(", "BasicAuthLDAPConfig", "ldapConfig", ",", "DirContext", "context", ",", "String", "username", ")", "{", "try", "{", "SearchControls", "sc", "=", "new", "SearchControls", "(", ")", ";", "sc", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "sc", ".", "setReturningAttributes", "(", "new", "String", "[", "]", "{", "ldapConfig", ".", "getUserAttribute", "(", ")", ",", "\"", "memberOf", "\"", "}", ")", ";", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "context", ".", "search", "(", "ldapConfig", ".", "getBaseDn", "(", ")", ",", "StringUtils", ".", "format", "(", "ldapConfig", ".", "getUserSearch", "(", ")", ",", "username", ")", ",", "sc", ")", ";", "try", "{", "if", "(", "!", "results", ".", "hasMore", "(", ")", ")", "{", "return", "null", ";", "}", "return", "results", ".", "next", "(", ")", ";", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "NamingException", "e", ")", "{", "LOG", ".", "debug", "(", "e", ",", "\"", "Unable to find user '%s'", "\"", ",", "username", ")", ";", "return", "null", ";", "}", "}"], "idx": 73453, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "dbaabdd24710fef726c5730c609937706f456a44", "function_name": "getLdapUserObject", "body_hash": "b61089d3d9ff0442b03f6b70e785362bd299a3f9"}
{"code": "private static Secret tryDecrypt(Cipher cipher, byte[] in) throws UnsupportedEncodingException {\n        try {\n            String plainText = new String(cipher.doFinal(in), \"UTF-8\");\n            if(plainText.endsWith(MAGIC))\n                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));\n            return null;\n        } catch (GeneralSecurityException e) {\n            return null;\n        }\n    }", "code_tokens": ["private", "static", "Secret", "tryDecrypt", "(", "Cipher", "cipher", ",", "byte", "[", "]", "in", ")", "throws", "UnsupportedEncodingException", "{", "try", "{", "String", "plainText", "=", "new", "String", "(", "cipher", ".", "doFinal", "(", "in", ")", ",", "\"", "UTF-8", "\"", ")", ";", "if", "(", "plainText", ".", "endsWith", "(", "MAGIC", ")", ")", "return", "new", "Secret", "(", "plainText", ".", "substring", "(", "0", ",", "plainText", ".", "length", "(", ")", "-", "MAGIC", ".", "length", "(", ")", ")", ")", ";", "return", "null", ";", "}", "catch", "(", "GeneralSecurityException", "e", ")", "{", "return", "null", ";", "}", "}"], "idx": 98778, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "4895eaafca468b7f0f1a3166b2fca7414f0d5da5", "function_name": "tryDecrypt", "body_hash": "75bb49814958845cb7e3c2093be9b78e5fc19261"}
{"code": "public String createPackagesTable(final String serverUrl, final String authenticationToken, final String project) {\n\t\tList<String> packageNames = new ArrayList<String>();\n\t\ttry {\n\t\t\tpackageNames = RapidDeployConnector.invokeRapidDeployListPackages(authenticationToken, serverUrl, project);\n\t\t} catch (final Exception e) {\n\t\t\tlogger.warn(e.getMessage());\n\t\t}\n\t\tif (!packageNames.isEmpty()) {\n\t\t\tfinal StringBuffer sb = new StringBuffer();\n\t\t\tsb.append(\"<table>\");\n\t\t\tint index = 0;\n\t\t\tfinal int limit = 10;\n\t\t\tfor (final String packageName : packageNames) {\n\t\t\t\tif (!\"null\".equals(packageName) && !packageName.startsWith(\"Deployment\")) {\n\t\t\t\t\tsb.append(\"<tr><td class=\\\"setting-main\\\">\");\n\t\t\t\t\tsb.append(packageName);\n\t\t\t\t\tsb.append(\"</td></tr>\");\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (index >= limit) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"</table>\");\n\t\t\treturn sb.toString();\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["public", "String", "createPackagesTable", "(", "final", "String", "serverUrl", ",", "final", "String", "authenticationToken", ",", "final", "String", "project", ")", "{", "List", "<", "String", ">", "packageNames", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "try", "{", "packageNames", "=", "RapidDeployConnector", ".", "invokeRapidDeployListPackages", "(", "authenticationToken", ",", "serverUrl", ",", "project", ")", ";", "}", "catch", "(", "final", "Exception", "e", ")", "{", "logger", ".", "warn", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "if", "(", "!", "packageNames", ".", "isEmpty", "(", ")", ")", "{", "final", "StringBuffer", "sb", "=", "new", "StringBuffer", "(", ")", ";", "sb", ".", "append", "(", "\"", "<table>", "\"", ")", ";", "int", "index", "=", "0", ";", "final", "int", "limit", "=", "10", ";", "for", "(", "final", "String", "packageName", ":", "packageNames", ")", "{", "if", "(", "!", "\"", "null", "\"", ".", "equals", "(", "packageName", ")", "&&", "!", "packageName", ".", "startsWith", "(", "\"", "Deployment", "\"", ")", ")", "{", "sb", ".", "append", "(", "\"", "<tr><td class=", "\\\"", "setting-main", "\\\"", ">", "\"", ")", ";", "sb", ".", "append", "(", "packageName", ")", ";", "sb", ".", "append", "(", "\"", "</td></tr>", "\"", ")", ";", "index", "++", ";", "if", "(", "index", ">=", "limit", ")", "{", "break", ";", "}", "}", "}", "sb", ".", "append", "(", "\"", "</table>", "\"", ")", ";", "return", "sb", ".", "toString", "(", ")", ";", "}", "return", "null", ";", "}"], "idx": 80547, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "38ec64b", "function_name": "createPackagesTable", "body_hash": "a638eee743f4ede7d47808c850515377c308a5ce"}
{"code": "protected COSDictionary parseXref(long startXRefOffset) throws IOException\n    {\n        source.seek(startXRefOffset);\n        long startXrefOffset = Math.max(0, parseStartXref());\n        // check the startxref offset\n        long fixedOffset = checkXRefOffset(startXrefOffset);\n        if (fixedOffset > -1)\n        {\n            startXrefOffset = fixedOffset;\n        }\n        document.setStartXref(startXrefOffset);\n        long prev = startXrefOffset;\n        // ---- parse whole chain of xref tables/object streams using PREV reference\n        Set<Long> prevSet = new HashSet<Long>();\n        COSDictionary trailer = null;\n        while (prev > 0)\n        {\n            // seek to xref table\n            source.seek(prev);\n\n            // skip white spaces\n            skipSpaces();\n            // -- parse xref\n            if (source.peek() == X)\n            {\n                // xref table and trailer\n                // use existing parser to parse xref table\n                if (!parseXrefTable(prev) || !parseTrailer())\n                {\n                    throw new IOException(\"Expected trailer object at offset \"\n                            + source.getPosition());\n                }\n                trailer = xrefTrailerResolver.getCurrentTrailer();\n                // check for a XRef stream, it may contain some object ids of compressed objects \n                if(trailer.containsKey(COSName.XREF_STM))\n                {\n                    int streamOffset = trailer.getInt(COSName.XREF_STM);\n                    // check the xref stream reference\n                    fixedOffset = checkXRefOffset(streamOffset);\n                    if (fixedOffset > -1 && fixedOffset != streamOffset)\n                    {\n                        LOG.warn(\"/XRefStm offset \" + streamOffset + \" is incorrect, corrected to \" + fixedOffset);\n                        streamOffset = (int)fixedOffset;\n                        trailer.setInt(COSName.XREF_STM, streamOffset);\n                    }\n                    if (streamOffset > 0)\n                    {\n                        source.seek(streamOffset);\n                        skipSpaces();\n                        try\n                        {\n                            parseXrefObjStream(prev, false);\n                        }\n                        catch (IOException ex)\n                        {\n                            if (isLenient)\n                            {\n                                LOG.error(\"Failed to parse /XRefStm at offset \" + streamOffset, ex);\n                            }\n                            else\n                            {\n                                throw ex;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if(isLenient)\n                        {\n                            LOG.error(\"Skipped XRef stream due to a corrupt offset:\"+streamOffset);\n                        }\n                        else\n                        {\n                            throw new IOException(\"Skipped XRef stream due to a corrupt offset:\"+streamOffset);\n                        }\n                    }\n                }\n                prev = trailer.getLong(COSName.PREV);\n            }\n            else\n            {\n                // parse xref stream\n                prev = parseXrefObjStream(prev, true);\n                trailer = xrefTrailerResolver.getCurrentTrailer();\n            }\n            if (prev > 0)\n            {\n                // check the xref table reference\n                fixedOffset = checkXRefOffset(prev);\n                if (fixedOffset > -1 && fixedOffset != prev)\n                {\n                    prev = fixedOffset;\n                    trailer.setLong(COSName.PREV, prev);\n                }\n            }\n            if (prevSet.contains(prev))\n            {\n                throw new IOException(\"/Prev loop at offset \" + prev);\n            }\n            prevSet.add(prev);\n        }\n        // ---- build valid xrefs out of the xref chain\n        xrefTrailerResolver.setStartxref(startXrefOffset);\n        trailer = xrefTrailerResolver.getTrailer();\n        document.setTrailer(trailer);\n        document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());\n        // check the offsets of all referenced objects\n        checkXrefOffsets();\n        // copy xref table\n        document.addXRefTable(xrefTrailerResolver.getXrefTable());\n        return trailer;\n    }", "code_tokens": ["protected", "COSDictionary", "parseXref", "(", "long", "startXRefOffset", ")", "throws", "IOException", "{", "source", ".", "seek", "(", "startXRefOffset", ")", ";", "long", "startXrefOffset", "=", "Math", ".", "max", "(", "0", ",", "parseStartXref", "(", ")", ")", ";", "long", "fixedOffset", "=", "checkXRefOffset", "(", "startXrefOffset", ")", ";", "if", "(", "fixedOffset", ">", "-", "1", ")", "{", "startXrefOffset", "=", "fixedOffset", ";", "}", "document", ".", "setStartXref", "(", "startXrefOffset", ")", ";", "long", "prev", "=", "startXrefOffset", ";", "Set", "<", "Long", ">", "prevSet", "=", "new", "HashSet", "<", "Long", ">", "(", ")", ";", "COSDictionary", "trailer", "=", "null", ";", "while", "(", "prev", ">", "0", ")", "{", "source", ".", "seek", "(", "prev", ")", ";", "skipSpaces", "(", ")", ";", "if", "(", "source", ".", "peek", "(", ")", "==", "X", ")", "{", "if", "(", "!", "parseXrefTable", "(", "prev", ")", "||", "!", "parseTrailer", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "Expected trailer object at offset ", "\"", "+", "source", ".", "getPosition", "(", ")", ")", ";", "}", "trailer", "=", "xrefTrailerResolver", ".", "getCurrentTrailer", "(", ")", ";", "if", "(", "trailer", ".", "containsKey", "(", "COSName", ".", "XREF_STM", ")", ")", "{", "int", "streamOffset", "=", "trailer", ".", "getInt", "(", "COSName", ".", "XREF_STM", ")", ";", "fixedOffset", "=", "checkXRefOffset", "(", "streamOffset", ")", ";", "if", "(", "fixedOffset", ">", "-", "1", "&&", "fixedOffset", "!=", "streamOffset", ")", "{", "LOG", ".", "warn", "(", "\"", "/XRefStm offset ", "\"", "+", "streamOffset", "+", "\"", " is incorrect, corrected to ", "\"", "+", "fixedOffset", ")", ";", "streamOffset", "=", "(", "int", ")", "fixedOffset", ";", "trailer", ".", "setInt", "(", "COSName", ".", "XREF_STM", ",", "streamOffset", ")", ";", "}", "if", "(", "streamOffset", ">", "0", ")", "{", "source", ".", "seek", "(", "streamOffset", ")", ";", "skipSpaces", "(", ")", ";", "try", "{", "parseXrefObjStream", "(", "prev", ",", "false", ")", ";", "}", "catch", "(", "IOException", "ex", ")", "{", "if", "(", "isLenient", ")", "{", "LOG", ".", "error", "(", "\"", "Failed to parse /XRefStm at offset ", "\"", "+", "streamOffset", ",", "ex", ")", ";", "}", "else", "{", "throw", "ex", ";", "}", "}", "}", "else", "{", "if", "(", "isLenient", ")", "{", "LOG", ".", "error", "(", "\"", "Skipped XRef stream due to a corrupt offset:", "\"", "+", "streamOffset", ")", ";", "}", "else", "{", "throw", "new", "IOException", "(", "\"", "Skipped XRef stream due to a corrupt offset:", "\"", "+", "streamOffset", ")", ";", "}", "}", "}", "prev", "=", "trailer", ".", "getLong", "(", "COSName", ".", "PREV", ")", ";", "}", "else", "{", "prev", "=", "parseXrefObjStream", "(", "prev", ",", "true", ")", ";", "trailer", "=", "xrefTrailerResolver", ".", "getCurrentTrailer", "(", ")", ";", "}", "if", "(", "prev", ">", "0", ")", "{", "fixedOffset", "=", "checkXRefOffset", "(", "prev", ")", ";", "if", "(", "fixedOffset", ">", "-", "1", "&&", "fixedOffset", "!=", "prev", ")", "{", "prev", "=", "fixedOffset", ";", "trailer", ".", "setLong", "(", "COSName", ".", "PREV", ",", "prev", ")", ";", "}", "}", "if", "(", "prevSet", ".", "contains", "(", "prev", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "/Prev loop at offset ", "\"", "+", "prev", ")", ";", "}", "prevSet", ".", "add", "(", "prev", ")", ";", "}", "xrefTrailerResolver", ".", "setStartxref", "(", "startXrefOffset", ")", ";", "trailer", "=", "xrefTrailerResolver", ".", "getTrailer", "(", ")", ";", "document", ".", "setTrailer", "(", "trailer", ")", ";", "document", ".", "setIsXRefStream", "(", "XRefType", ".", "STREAM", "==", "xrefTrailerResolver", ".", "getXrefType", "(", ")", ")", ";", "checkXrefOffsets", "(", ")", ";", "document", ".", "addXRefTable", "(", "xrefTrailerResolver", ".", "getXrefTable", "(", ")", ")", ";", "return", "trailer", ";", "}"], "idx": 82597, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "c682f73503e78332c14fec5f88f2003ba4a04328", "function_name": "parseXref", "body_hash": "9345ac2cf405889007d737587902c1f3041157df"}
{"code": "@RequestMapping(\"/oauth/token/revoke/client/{clientId}\")\n    public ResponseEntity<Void> revokeTokensForClient(@PathVariable String clientId) {\n        logger.debug(\"Revoking tokens for client: \" + clientId);\n        BaseClientDetails client = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId, IdentityZoneHolder.get().getId());\n        client.addAdditionalInformation(ClientConstants.TOKEN_SALT,generator.generate());\n        clientDetailsService.updateClientDetails(client, IdentityZoneHolder.get().getId());\n        logger.debug(\"Tokens revoked for client: \" + clientId);\n        return new ResponseEntity<>(OK);\n    }", "code_tokens": ["@", "RequestMapping", "(", "\"", "/oauth/token/revoke/client/{clientId}", "\"", ")", "public", "ResponseEntity", "<", "Void", ">", "revokeTokensForClient", "(", "@", "PathVariable", "String", "clientId", ")", "{", "logger", ".", "debug", "(", "\"", "Revoking tokens for client: ", "\"", "+", "clientId", ")", ";", "BaseClientDetails", "client", "=", "(", "BaseClientDetails", ")", "clientDetailsService", ".", "loadClientByClientId", "(", "clientId", ",", "IdentityZoneHolder", ".", "get", "(", ")", ".", "getId", "(", ")", ")", ";", "client", ".", "addAdditionalInformation", "(", "ClientConstants", ".", "TOKEN_SALT", ",", "generator", ".", "generate", "(", ")", ")", ";", "clientDetailsService", ".", "updateClientDetails", "(", "client", ",", "IdentityZoneHolder", ".", "get", "(", ")", ".", "getId", "(", ")", ")", ";", "logger", ".", "debug", "(", "\"", "Tokens revoked for client: ", "\"", "+", "clientId", ")", ";", "return", "new", "ResponseEntity", "<", ">", "(", "OK", ")", ";", "}"], "idx": 102711, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "20808046de8bbdc6fb2ac62829d4cc9d7a19f37", "function_name": "revokeTokensForClient", "body_hash": "cc3e05a6422fa98a3a5bacbb8c75ba10aa3c486f"}
{"code": "protected Object getHandlerInternal(HttpServletRequest request) throws Exception {\n        Object object = super.getHandlerInternal(request);\n\n        if (object instanceof String) {\n            String handlerName = (String) object;\n            object = getApplicationContext().getBean(handlerName);\n        }\n        if (object instanceof HandlerExecutionChain) {\n            HandlerExecutionChain handlerExecutionChain = (HandlerExecutionChain) object;\n            object = handlerExecutionChain.getHandler();\n        }\n        \n        if (object != null) {\n        \t// prevent CSRF attacks\n        \tif (object instanceof DestinationFacade) {\n        \t\t// check supported methods\n        \t\tif (!Arrays.asList(((DestinationFacade)object).getSupportedHttpMethods()).contains(request.getMethod())) {\n        \t\t\tthrow new UnsupportedOperationException(\"Unsupported method \" + request.getMethod() + \" for path \" + request.getRequestURI());\n        \t\t}\n        \t\t// check the 'secret'\n        \t\tif (!request.getSession().getAttribute(\"secret\").equals(request.getParameter(\"secret\"))) {\n        \t\t\tthrow new UnsupportedOperationException(\"Possible CSRF attack\");\n        \t\t}\n        \t}\n        \t\n        \t\n            ServletRequestDataBinder binder = new ServletRequestDataBinder(object, \"request\");\n            try {\n                binder.bind(request);\n                binder.setIgnoreUnknownFields(true);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Bound POJO is now: \" + object);\n                }\n            }\n            catch (Exception e) {\n                LOG.warn(\"Caught: \" + e, e);\n                throw e;\n            }\n        }\n        \n        return object;\n    }", "code_tokens": ["protected", "Object", "getHandlerInternal", "(", "HttpServletRequest", "request", ")", "throws", "Exception", "{", "Object", "object", "=", "super", ".", "getHandlerInternal", "(", "request", ")", ";", "if", "(", "object", "instanceof", "String", ")", "{", "String", "handlerName", "=", "(", "String", ")", "object", ";", "object", "=", "getApplicationContext", "(", ")", ".", "getBean", "(", "handlerName", ")", ";", "}", "if", "(", "object", "instanceof", "HandlerExecutionChain", ")", "{", "HandlerExecutionChain", "handlerExecutionChain", "=", "(", "HandlerExecutionChain", ")", "object", ";", "object", "=", "handlerExecutionChain", ".", "getHandler", "(", ")", ";", "}", "if", "(", "object", "!=", "null", ")", "{", "if", "(", "object", "instanceof", "DestinationFacade", ")", "{", "if", "(", "!", "Arrays", ".", "asList", "(", "(", "(", "DestinationFacade", ")", "object", ")", ".", "getSupportedHttpMethods", "(", ")", ")", ".", "contains", "(", "request", ".", "getMethod", "(", ")", ")", ")", "{", "throw", "new", "UnsupportedOperationException", "(", "\"", "Unsupported method ", "\"", "+", "request", ".", "getMethod", "(", ")", "+", "\"", " for path ", "\"", "+", "request", ".", "getRequestURI", "(", ")", ")", ";", "}", "if", "(", "!", "request", ".", "getSession", "(", ")", ".", "getAttribute", "(", "\"", "secret", "\"", ")", ".", "equals", "(", "request", ".", "getParameter", "(", "\"", "secret", "\"", ")", ")", ")", "{", "throw", "new", "UnsupportedOperationException", "(", "\"", "Possible CSRF attack", "\"", ")", ";", "}", "}", "ServletRequestDataBinder", "binder", "=", "new", "ServletRequestDataBinder", "(", "object", ",", "\"", "request", "\"", ")", ";", "try", "{", "binder", ".", "bind", "(", "request", ")", ";", "binder", ".", "setIgnoreUnknownFields", "(", "true", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Bound POJO is now: ", "\"", "+", "object", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Caught: ", "\"", "+", "e", ",", "e", ")", ";", "throw", "e", ";", "}", "}", "return", "object", ";", "}"], "idx": 43808, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "1f464b9412e1b1c08d40c8ffac40edd52731da48", "function_name": "getHandlerInternal", "body_hash": "8fabe85912384c9ce2cc6cac703f2022cd8e66e1"}
{"code": "public static int versionCompare(String fromVersion, String toVersion) {\n        if (fromVersion == null || toVersion == null) {\n            return -1;\n        }\n        String[] fromArr = fromVersion.split(\"\\\\.\");\n        String[] toArr = toVersion.split(\"\\\\.\");\n        if (fromArr.length != 3 || toArr.length != 3) {\n            return -1;\n        }\n        try {\n            int fromFirst = Integer.parseInt(fromArr[0]);\n            int fromMiddle = Integer.parseInt(fromArr[1]);\n            int fromEnd = Integer.parseInt(fromArr[2]);\n            int toFirst = Integer.parseInt(toArr[0]);\n            int toMiddle = Integer.parseInt(toArr[1]);\n            int toEnd = Integer.parseInt(toArr[2]);\n            if (fromFirst - toFirst != 0) {\n                return fromFirst - toFirst;\n            } else if (fromMiddle - toMiddle != 0) {\n                return fromMiddle - toMiddle;\n            } else {\n                return fromEnd - toEnd;\n            }\n        } catch (NumberFormatException nfe) {\n            return -1;\n        }\n    }", "code_tokens": ["public", "static", "int", "versionCompare", "(", "String", "fromVersion", ",", "String", "toVersion", ")", "{", "if", "(", "fromVersion", "==", "null", "||", "toVersion", "==", "null", ")", "{", "return", "-", "1", ";", "}", "String", "[", "]", "fromArr", "=", "fromVersion", ".", "split", "(", "\"", "\\\\", ".", "\"", ")", ";", "String", "[", "]", "toArr", "=", "toVersion", ".", "split", "(", "\"", "\\\\", ".", "\"", ")", ";", "if", "(", "fromArr", ".", "length", "!=", "3", "||", "toArr", ".", "length", "!=", "3", ")", "{", "return", "-", "1", ";", "}", "try", "{", "int", "fromFirst", "=", "Integer", ".", "parseInt", "(", "fromArr", "[", "0", "]", ")", ";", "int", "fromMiddle", "=", "Integer", ".", "parseInt", "(", "fromArr", "[", "1", "]", ")", ";", "int", "fromEnd", "=", "Integer", ".", "parseInt", "(", "fromArr", "[", "2", "]", ")", ";", "int", "toFirst", "=", "Integer", ".", "parseInt", "(", "toArr", "[", "0", "]", ")", ";", "int", "toMiddle", "=", "Integer", ".", "parseInt", "(", "toArr", "[", "1", "]", ")", ";", "int", "toEnd", "=", "Integer", ".", "parseInt", "(", "toArr", "[", "2", "]", ")", ";", "if", "(", "fromFirst", "-", "toFirst", "!=", "0", ")", "{", "return", "fromFirst", "-", "toFirst", ";", "}", "else", "if", "(", "fromMiddle", "-", "toMiddle", "!=", "0", ")", "{", "return", "fromMiddle", "-", "toMiddle", ";", "}", "else", "{", "return", "fromEnd", "-", "toEnd", ";", "}", "}", "catch", "(", "NumberFormatException", "nfe", ")", "{", "return", "-", "1", ";", "}", "}"], "idx": 102442, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "1a783729a1d7e0cd59d59a8dd3a73cdd6ac0f30d", "function_name": "versionCompare", "body_hash": "ebd15344aee728b7169764109ca00a0e858bdf9d"}
{"code": "private Environment getRemoteEnvironment(RestTemplate restTemplate,\n\t\t\tConfigClientProperties properties, String label, String state) {\n\t\tString path = \"/{name}/{profile}\";\n\t\tString name = properties.getName();\n\t\tString profile = properties.getProfile();\n\t\tString token = properties.getToken();\n\t\tint noOfUrls = properties.getUri().length;\n\t\tif (noOfUrls > 1) {\n\t\t\tlogger.info(\"Multiple Config Server Urls found listed.\");\n\t\t}\n\n\t\tObject[] args = new String[] { name, profile };\n\t\tif (StringUtils.hasText(label)) {\n\t\t\t// workaround for Spring MVC matching / in paths\n\t\t\tlabel = Environment.denormalize(label);\n\t\t\targs = new String[] { name, profile, label };\n\t\t\tpath = path + \"/{label}\";\n\t\t}\n\t\tResponseEntity<Environment> response = null;\n\n\t\tfor (int i = 0; i < noOfUrls; i++) {\n\t\t\tCredentials credentials = properties.getCredentials(i);\n\t\t\tString uri = credentials.getUri();\n\t\t\tString username = credentials.getUsername();\n\t\t\tString password = credentials.getPassword();\n\n\t\t\tlogger.info(\"Fetching config from server at : \" + uri);\n\n\t\t\ttry {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.setAccept(\n\t\t\t\t\t\tCollections.singletonList(MediaType.parseMediaType(V2_JSON)));\n\t\t\t\taddAuthorizationToken(properties, headers, username, password);\n\t\t\t\tif (StringUtils.hasText(token)) {\n\t\t\t\t\theaders.add(TOKEN_HEADER, token);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasText(state) && properties.isSendState()) {\n\t\t\t\t\theaders.add(STATE_HEADER, state);\n\t\t\t\t}\n\n\t\t\t\tfinal HttpEntity<Void> entity = new HttpEntity<>((Void) null, headers);\n\t\t\t\tresponse = restTemplate.exchange(uri + path, HttpMethod.GET, entity,\n\t\t\t\t\t\tEnvironment.class, args);\n\t\t\t}\n\t\t\tcatch (HttpClientErrorException e) {\n\t\t\t\tif (e.getStatusCode() != HttpStatus.NOT_FOUND) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ResourceAccessException e) {\n\t\t\t\tlogger.info(\"Connect Timeout Exception on Url - \" + uri\n\t\t\t\t\t\t+ \". Will be trying the next url if available\");\n\t\t\t\tif (i == noOfUrls - 1) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (response == null || response.getStatusCode() != HttpStatus.OK) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tEnvironment result = response.getBody();\n\t\t\treturn result;\n\t\t}\n\n\t\treturn null;\n\t}", "code_tokens": ["private", "Environment", "getRemoteEnvironment", "(", "RestTemplate", "restTemplate", ",", "ConfigClientProperties", "properties", ",", "String", "label", ",", "String", "state", ")", "{", "String", "path", "=", "\"", "/{name}/{profile}", "\"", ";", "String", "name", "=", "properties", ".", "getName", "(", ")", ";", "String", "profile", "=", "properties", ".", "getProfile", "(", ")", ";", "String", "token", "=", "properties", ".", "getToken", "(", ")", ";", "int", "noOfUrls", "=", "properties", ".", "getUri", "(", ")", ".", "length", ";", "if", "(", "noOfUrls", ">", "1", ")", "{", "logger", ".", "info", "(", "\"", "Multiple Config Server Urls found listed.", "\"", ")", ";", "}", "Object", "[", "]", "args", "=", "new", "String", "[", "]", "{", "name", ",", "profile", "}", ";", "if", "(", "StringUtils", ".", "hasText", "(", "label", ")", ")", "{", "label", "=", "Environment", ".", "denormalize", "(", "label", ")", ";", "args", "=", "new", "String", "[", "]", "{", "name", ",", "profile", ",", "label", "}", ";", "path", "=", "path", "+", "\"", "/{label}", "\"", ";", "}", "ResponseEntity", "<", "Environment", ">", "response", "=", "null", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "noOfUrls", ";", "i", "++", ")", "{", "Credentials", "credentials", "=", "properties", ".", "getCredentials", "(", "i", ")", ";", "String", "uri", "=", "credentials", ".", "getUri", "(", ")", ";", "String", "username", "=", "credentials", ".", "getUsername", "(", ")", ";", "String", "password", "=", "credentials", ".", "getPassword", "(", ")", ";", "logger", ".", "info", "(", "\"", "Fetching config from server at : ", "\"", "+", "uri", ")", ";", "try", "{", "HttpHeaders", "headers", "=", "new", "HttpHeaders", "(", ")", ";", "headers", ".", "setAccept", "(", "Collections", ".", "singletonList", "(", "MediaType", ".", "parseMediaType", "(", "V2_JSON", ")", ")", ")", ";", "addAuthorizationToken", "(", "properties", ",", "headers", ",", "username", ",", "password", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "token", ")", ")", "{", "headers", ".", "add", "(", "TOKEN_HEADER", ",", "token", ")", ";", "}", "if", "(", "StringUtils", ".", "hasText", "(", "state", ")", "&&", "properties", ".", "isSendState", "(", ")", ")", "{", "headers", ".", "add", "(", "STATE_HEADER", ",", "state", ")", ";", "}", "final", "HttpEntity", "<", "Void", ">", "entity", "=", "new", "HttpEntity", "<", ">", "(", "(", "Void", ")", "null", ",", "headers", ")", ";", "response", "=", "restTemplate", ".", "exchange", "(", "uri", "+", "path", ",", "HttpMethod", ".", "GET", ",", "entity", ",", "Environment", ".", "class", ",", "args", ")", ";", "}", "catch", "(", "HttpClientErrorException", "e", ")", "{", "if", "(", "e", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "NOT_FOUND", ")", "{", "throw", "e", ";", "}", "}", "catch", "(", "ResourceAccessException", "e", ")", "{", "logger", ".", "info", "(", "\"", "Connect Timeout Exception on Url - ", "\"", "+", "uri", "+", "\"", ". Will be trying the next url if available", "\"", ")", ";", "if", "(", "i", "==", "noOfUrls", "-", "1", ")", "{", "throw", "e", ";", "}", "else", "{", "continue", ";", "}", "}", "if", "(", "response", "==", "null", "||", "response", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "OK", ")", "{", "return", "null", ";", "}", "Environment", "result", "=", "response", ".", "getBody", "(", ")", ";", "return", "result", ";", "}", "return", "null", ";", "}"], "idx": 26302, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "651f458919c40ef9a5e93e7d76bf98575910fad0", "function_name": "getRemoteEnvironment", "body_hash": "65f895985627a3bd111ea79a4385ffa3461029c9"}
{"code": "public SerializedInfoflowResults readResults(String fileName) throws XMLStreamException, IOException {\n\t\tSerializedInfoflowResults results = new SerializedInfoflowResults();\n\t\tInfoflowPerformanceData perfData = null;\n\n\t\tXMLStreamReader reader = null;\n\t\ttry (InputStream in = new FileInputStream(fileName)) {\n\t\t\tXMLInputFactory factory = XMLInputFactory.newInstance();\n\t\t\tfactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n\t\t\tfactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n\t\t\treader = factory.createXMLStreamReader(in);\n\n\t\t\tString statement = null;\n\t\t\tString method = null;\n\t\t\tString apValue = null;\n\t\t\tString apValueType = null;\n\t\t\tboolean apTaintSubFields = false;\n\t\t\tList<String> apFields = new ArrayList<>();\n\t\t\tList<String> apTypes = new ArrayList<>();\n\t\t\tSerializedAccessPath ap = null;\n\t\t\tSerializedSinkInfo sink = null;\n\t\t\tSerializedSourceInfo source = null;\n\t\t\tList<SerializedPathElement> pathElements = new ArrayList<>();\n\n\t\t\tStack<State> stateStack = new Stack<>();\n\t\t\tstateStack.push(State.init);\n\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\t// Read the next tag\n\t\t\t\treader.next();\n\t\t\t\tif (!reader.hasName())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (reader.getLocalName().equals(XmlConstants.Tags.root) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.init) {\n\t\t\t\t\tstateStack.push(State.dataFlowResults);\n\n\t\t\t\t\t// Load the attributes of the root node\n\t\t\t\t\tresults.setFileFormatVersion(\n\t\t\t\t\t\t\tint2Str(getAttributeByName(reader, XmlConstants.Attributes.fileFormatVersion)));\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.results) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.dataFlowResults) {\n\t\t\t\t\tstateStack.push(State.results);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.result) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.results) {\n\t\t\t\t\tstateStack.push(State.result);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.sink) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.result) {\n\t\t\t\t\tstateStack.push(State.sink);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.accessPath) && reader.isStartElement()) {\n\t\t\t\t\tstateStack.push(State.accessPath);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tapValue = getAttributeByName(reader, XmlConstants.Attributes.value);\n\t\t\t\t\tapValueType = getAttributeByName(reader, XmlConstants.Attributes.type);\n\t\t\t\t\tapTaintSubFields = getAttributeByName(reader, XmlConstants.Attributes.taintSubFields)\n\t\t\t\t\t\t\t.equals(XmlConstants.Values.TRUE);\n\n\t\t\t\t\t// Clear the fields\n\t\t\t\t\tapFields.clear();\n\t\t\t\t\tapTypes.clear();\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.fields) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.accessPath) {\n\t\t\t\t\tstateStack.push(State.fields);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.field) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.fields) {\n\t\t\t\t\tstateStack.push(State.field);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tString value = getAttributeByName(reader, XmlConstants.Attributes.value);\n\t\t\t\t\tString type = getAttributeByName(reader, XmlConstants.Attributes.type);\n\t\t\t\t\tif (value != null && !value.isEmpty() && type != null && !type.isEmpty()) {\n\t\t\t\t\t\tapFields.add(value);\n\t\t\t\t\t\tapTypes.add(value);\n\t\t\t\t\t}\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.sources) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.result) {\n\t\t\t\t\tstateStack.push(State.sources);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.source) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.sources) {\n\t\t\t\t\tstateStack.push(State.source);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t\tmethod = getAttributeByName(reader, XmlConstants.Attributes.method);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.taintPath) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.source) {\n\t\t\t\t\tstateStack.push(State.taintPath);\n\n\t\t\t\t\t// Clear the old state\n\t\t\t\t\tpathElements.clear();\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.pathElement) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.source) {\n\t\t\t\t\tstateStack.push(State.taintPath);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t\tmethod = getAttributeByName(reader, XmlConstants.Attributes.method);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.performanceData) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.dataFlowResults) {\n\t\t\t\t\tstateStack.push(State.performanceData);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.performanceEntry) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.performanceData) {\n\t\t\t\t\tstateStack.push(State.performanceEntry);\n\n\t\t\t\t\t// We need a performance data object\n\t\t\t\t\tif (perfData == null)\n\t\t\t\t\t\tperfData = results.getOrCreatePerformanceData();\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tString perfName = getAttributeByName(reader, XmlConstants.Attributes.name);\n\t\t\t\t\tString perfValue = getAttributeByName(reader, XmlConstants.Attributes.value);\n\n\t\t\t\t\tswitch (perfName) {\n\t\t\t\t\tcase XmlConstants.Values.PERF_CALLGRAPH_SECONDS:\n\t\t\t\t\t\tperfData.setCallgraphConstructionSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_PATH_RECONSTRUCTION_SECONDS:\n\t\t\t\t\t\tperfData.setPathReconstructionSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_TAINT_PROPAGATION_SECONDS:\n\t\t\t\t\t\tperfData.setTaintPropagationSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_TOTAL_RUNTIME_SECONDS:\n\t\t\t\t\t\tperfData.setTotalRuntimeSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_MAX_MEMORY_CONSUMPTION:\n\t\t\t\t\t\tperfData.setMaxMemoryConsumption(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_SOURCE_COUNT:\n\t\t\t\t\t\tperfData.setSourceCount(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_SINK_COUNT:\n\t\t\t\t\t\tperfData.setSinkCount(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (reader.isEndElement()) {\n\t\t\t\t\tstateStack.pop();\n\n\t\t\t\t\tif (reader.getLocalName().equals(XmlConstants.Tags.accessPath))\n\t\t\t\t\t\tap = new SerializedAccessPath(apValue, apValueType, apTaintSubFields,\n\t\t\t\t\t\t\t\tapFields.toArray(new String[apFields.size()]),\n\t\t\t\t\t\t\t\tapTypes.toArray(new String[apTypes.size()]));\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.sink))\n\t\t\t\t\t\tsink = new SerializedSinkInfo(ap, statement, method);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.source))\n\t\t\t\t\t\tsource = new SerializedSourceInfo(ap, statement, method, pathElements);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.result))\n\t\t\t\t\t\tresults.addResult(source, sink);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.pathElement))\n\t\t\t\t\t\tpathElements.add(new SerializedPathElement(ap, statement, method));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn results;\n\t\t} finally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();\n\t\t}\n\t}", "code_tokens": ["public", "SerializedInfoflowResults", "readResults", "(", "String", "fileName", ")", "throws", "XMLStreamException", ",", "IOException", "{", "SerializedInfoflowResults", "results", "=", "new", "SerializedInfoflowResults", "(", ")", ";", "InfoflowPerformanceData", "perfData", "=", "null", ";", "XMLStreamReader", "reader", "=", "null", ";", "try", "(", "InputStream", "in", "=", "new", "FileInputStream", "(", "fileName", ")", ")", "{", "XMLInputFactory", "factory", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "IS_SUPPORTING_EXTERNAL_ENTITIES", ",", "false", ")", ";", "factory", ".", "setProperty", "(", "XMLInputFactory", ".", "SUPPORT_DTD", ",", "false", ")", ";", "reader", "=", "factory", ".", "createXMLStreamReader", "(", "in", ")", ";", "String", "statement", "=", "null", ";", "String", "method", "=", "null", ";", "String", "apValue", "=", "null", ";", "String", "apValueType", "=", "null", ";", "boolean", "apTaintSubFields", "=", "false", ";", "List", "<", "String", ">", "apFields", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "String", ">", "apTypes", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "SerializedAccessPath", "ap", "=", "null", ";", "SerializedSinkInfo", "sink", "=", "null", ";", "SerializedSourceInfo", "source", "=", "null", ";", "List", "<", "SerializedPathElement", ">", "pathElements", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Stack", "<", "State", ">", "stateStack", "=", "new", "Stack", "<", ">", "(", ")", ";", "stateStack", ".", "push", "(", "State", ".", "init", ")", ";", "while", "(", "reader", ".", "hasNext", "(", ")", ")", "{", "reader", ".", "next", "(", ")", ";", "if", "(", "!", "reader", ".", "hasName", "(", ")", ")", "continue", ";", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "root", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "init", ")", "{", "stateStack", ".", "push", "(", "State", ".", "dataFlowResults", ")", ";", "results", ".", "setFileFormatVersion", "(", "int2Str", "(", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "fileFormatVersion", ")", ")", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "results", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "dataFlowResults", ")", "{", "stateStack", ".", "push", "(", "State", ".", "results", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "result", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "results", ")", "{", "stateStack", ".", "push", "(", "State", ".", "result", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "sink", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "result", ")", "{", "stateStack", ".", "push", "(", "State", ".", "sink", ")", ";", "statement", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "statement", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "accessPath", ")", "&&", "reader", ".", "isStartElement", "(", ")", ")", "{", "stateStack", ".", "push", "(", "State", ".", "accessPath", ")", ";", "apValue", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "value", ")", ";", "apValueType", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "type", ")", ";", "apTaintSubFields", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "taintSubFields", ")", ".", "equals", "(", "XmlConstants", ".", "Values", ".", "TRUE", ")", ";", "apFields", ".", "clear", "(", ")", ";", "apTypes", ".", "clear", "(", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "fields", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "accessPath", ")", "{", "stateStack", ".", "push", "(", "State", ".", "fields", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "field", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "fields", ")", "{", "stateStack", ".", "push", "(", "State", ".", "field", ")", ";", "String", "value", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "value", ")", ";", "String", "type", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "type", ")", ";", "if", "(", "value", "!=", "null", "&&", "!", "value", ".", "isEmpty", "(", ")", "&&", "type", "!=", "null", "&&", "!", "type", ".", "isEmpty", "(", ")", ")", "{", "apFields", ".", "add", "(", "value", ")", ";", "apTypes", ".", "add", "(", "value", ")", ";", "}", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "sources", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "result", ")", "{", "stateStack", ".", "push", "(", "State", ".", "sources", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "source", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "sources", ")", "{", "stateStack", ".", "push", "(", "State", ".", "source", ")", ";", "statement", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "statement", ")", ";", "method", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "method", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "taintPath", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "source", ")", "{", "stateStack", ".", "push", "(", "State", ".", "taintPath", ")", ";", "pathElements", ".", "clear", "(", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "pathElement", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "source", ")", "{", "stateStack", ".", "push", "(", "State", ".", "taintPath", ")", ";", "statement", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "statement", ")", ";", "method", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "method", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "performanceData", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "dataFlowResults", ")", "{", "stateStack", ".", "push", "(", "State", ".", "performanceData", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "performanceEntry", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "performanceData", ")", "{", "stateStack", ".", "push", "(", "State", ".", "performanceEntry", ")", ";", "if", "(", "perfData", "==", "null", ")", "perfData", "=", "results", ".", "getOrCreatePerformanceData", "(", ")", ";", "String", "perfName", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "name", ")", ";", "String", "perfValue", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "value", ")", ";", "switch", "(", "perfName", ")", "{", "case", "XmlConstants", ".", "Values", ".", "PERF_CALLGRAPH_SECONDS", ":", "perfData", ".", "setCallgraphConstructionSeconds", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_PATH_RECONSTRUCTION_SECONDS", ":", "perfData", ".", "setPathReconstructionSeconds", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_TAINT_PROPAGATION_SECONDS", ":", "perfData", ".", "setTaintPropagationSeconds", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_TOTAL_RUNTIME_SECONDS", ":", "perfData", ".", "setTotalRuntimeSeconds", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_MAX_MEMORY_CONSUMPTION", ":", "perfData", ".", "setMaxMemoryConsumption", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_SOURCE_COUNT", ":", "perfData", ".", "setSourceCount", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_SINK_COUNT", ":", "perfData", ".", "setSinkCount", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "}", "}", "else", "if", "(", "reader", ".", "isEndElement", "(", ")", ")", "{", "stateStack", ".", "pop", "(", ")", ";", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "accessPath", ")", ")", "ap", "=", "new", "SerializedAccessPath", "(", "apValue", ",", "apValueType", ",", "apTaintSubFields", ",", "apFields", ".", "toArray", "(", "new", "String", "[", "apFields", ".", "size", "(", ")", "]", ")", ",", "apTypes", ".", "toArray", "(", "new", "String", "[", "apTypes", ".", "size", "(", ")", "]", ")", ")", ";", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "sink", ")", ")", "sink", "=", "new", "SerializedSinkInfo", "(", "ap", ",", "statement", ",", "method", ")", ";", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "source", ")", ")", "source", "=", "new", "SerializedSourceInfo", "(", "ap", ",", "statement", ",", "method", ",", "pathElements", ")", ";", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "result", ")", ")", "results", ".", "addResult", "(", "source", ",", "sink", ")", ";", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "pathElement", ")", ")", "pathElements", ".", "add", "(", "new", "SerializedPathElement", "(", "ap", ",", "statement", ",", "method", ")", ")", ";", "}", "}", "return", "results", ";", "}", "finally", "{", "if", "(", "reader", "!=", "null", ")", "reader", ".", "close", "(", ")", ";", "}", "}"], "idx": 69021, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "b119180df13d69cc2fe3c84409e9e616d0eda653", "function_name": "readResults", "body_hash": "a1bb3e138026c58a0cb8cd7b62c70d2ff07d5551"}
{"code": "protected void addEmptyValueMapping(DefaultMapper mapper, String field, Object model) {\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tExpression target = emptyValueExpressionParser.parseExpression(field, parserContext);\n\t\ttry {\n\t\t\tClass<?> propertyType = target.getValueType(model);\n\t\t\tExpression source = new StaticExpression(getEmptyValue(propertyType));\n\t\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Adding empty value mapping for parameter '\" + field + \"'\");\n\t\t\t}\n\t\t\tmapper.addMapping(mapping);\n\t\t} catch (EvaluationException e) {\n\t\t}\n\t}", "code_tokens": ["protected", "void", "addEmptyValueMapping", "(", "DefaultMapper", "mapper", ",", "String", "field", ",", "Object", "model", ")", "{", "ParserContext", "parserContext", "=", "new", "FluentParserContext", "(", ")", ".", "evaluate", "(", "model", ".", "getClass", "(", ")", ")", ";", "Expression", "target", "=", "emptyValueExpressionParser", ".", "parseExpression", "(", "field", ",", "parserContext", ")", ";", "try", "{", "Class", "<", "?", ">", "propertyType", "=", "target", ".", "getValueType", "(", "model", ")", ";", "Expression", "source", "=", "new", "StaticExpression", "(", "getEmptyValue", "(", "propertyType", ")", ")", ";", "DefaultMapping", "mapping", "=", "new", "DefaultMapping", "(", "source", ",", "target", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Adding empty value mapping for parameter '", "\"", "+", "field", "+", "\"", "'", "\"", ")", ";", "}", "mapper", ".", "addMapping", "(", "mapping", ")", ";", "}", "catch", "(", "EvaluationException", "e", ")", "{", "}", "}"], "idx": 1326, "cwe": "CWE-1188", "target": 0, "status": "FIXED", "commit": "57f2ccb66946943fbf3b3f2165eac1c8eb6b1523", "function_name": "addEmptyValueMapping", "body_hash": "12eed1b09ec5c670787398c6bcd0c681fac819e2"}
{"code": "public static void setGlobalContext(Context newGlobalContext) {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new RuntimePermission(\n                   ResourceLinkFactory.class.getName() + \".setGlobalContext\"));\n        }\n        globalContext = newGlobalContext;\n    }", "code_tokens": ["public", "static", "void", "setGlobalContext", "(", "Context", "newGlobalContext", ")", "{", "SecurityManager", "sm", "=", "System", ".", "getSecurityManager", "(", ")", ";", "if", "(", "sm", "!=", "null", ")", "{", "sm", ".", "checkPermission", "(", "new", "RuntimePermission", "(", "ResourceLinkFactory", ".", "class", ".", "getName", "(", ")", "+", "\"", ".setGlobalContext", "\"", ")", ")", ";", "}", "globalContext", "=", "newGlobalContext", ";", "}"], "idx": 31570, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "0531f7aeff1999d362e0a68512a3517f2cf1a6ae", "function_name": "setGlobalContext", "body_hash": "5f956dd03865692c48440da431dfdf92f9fe6bfc"}
{"code": "@Override\n  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container = ctx.getContainer();\n    Map<String, String> environment = container.getLaunchContext()\n        .getEnvironment();\n    String imageName = environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n\n    validateImageName(imageName);\n\n    String containerIdStr = container.getContainerId().toString();\n    String runAsUser = ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir = ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List<String> -> stored as List -> fetched/converted to List<String>\n    //we can't do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List<String> localDirs = ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> logDirs = ctx.getExecutionAttribute(LOG_DIRS);\n    Set<String> capabilities = new HashSet<>(Arrays.asList(conf.getStrings(\n        YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n        YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand = new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(\"host\")\n        .setCapabilities(capabilities)\n        .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n    List<String> allDirs = new ArrayList<>(localDirs);\n\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(logDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir);\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts = ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    /** Disabling docker's cgroup parent support for the time being. Docker\n     * needs to use a more recent libcontainer that supports net_cls. In\n     * addition we also need to revisit current cgroup creation in YARN.\n     */\n    //addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n   Path nmPrivateContainerScriptPath = ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride = environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride != null && disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List<String> overrideCommands = new ArrayList<>();\n      Path launchDst =\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile = dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp = new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile = ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile != null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "launchContainer", "(", "ContainerRuntimeContext", "ctx", ")", "throws", "ContainerExecutionException", "{", "Container", "container", "=", "ctx", ".", "getContainer", "(", ")", ";", "Map", "<", "String", ",", "String", ">", "environment", "=", "container", ".", "getLaunchContext", "(", ")", ".", "getEnvironment", "(", ")", ";", "String", "imageName", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_IMAGE", ")", ";", "validateImageName", "(", "imageName", ")", ";", "String", "containerIdStr", "=", "container", ".", "getContainerId", "(", ")", ".", "toString", "(", ")", ";", "String", "runAsUser", "=", "ctx", ".", "getExecutionAttribute", "(", "RUN_AS_USER", ")", ";", "Path", "containerWorkDir", "=", "ctx", ".", "getExecutionAttribute", "(", "CONTAINER_WORK_DIR", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "localDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "LOCAL_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "logDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "LOG_DIRS", ")", ";", "Set", "<", "String", ">", "capabilities", "=", "new", "HashSet", "<", ">", "(", "Arrays", ".", "asList", "(", "conf", ".", "getStrings", "(", "YarnConfiguration", ".", "NM_DOCKER_CONTAINER_CAPABILITIES", ",", "YarnConfiguration", ".", "DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES", ")", ")", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "DockerRunCommand", "runCommand", "=", "new", "DockerRunCommand", "(", "containerIdStr", ",", "runAsUser", ",", "imageName", ")", ".", "detachOnRun", "(", ")", ".", "setContainerWorkDir", "(", "containerWorkDir", ".", "toString", "(", ")", ")", ".", "setNetworkType", "(", "\"", "host", "\"", ")", ".", "setCapabilities", "(", "capabilities", ")", ".", "addMountLocation", "(", "\"", "/etc/passwd", "\"", ",", "\"", "/etc/password:ro", "\"", ")", ";", "List", "<", "String", ">", "allDirs", "=", "new", "ArrayList", "<", ">", "(", "localDirs", ")", ";", "allDirs", ".", "add", "(", "containerWorkDir", ".", "toString", "(", ")", ")", ";", "allDirs", ".", "addAll", "(", "logDirs", ")", ";", "for", "(", "String", "dir", ":", "allDirs", ")", "{", "runCommand", ".", "addMountLocation", "(", "dir", ",", "dir", ")", ";", "}", "if", "(", "allowPrivilegedContainerExecution", "(", "container", ")", ")", "{", "runCommand", ".", "setPrivileged", "(", ")", ";", "}", "String", "resourcesOpts", "=", "ctx", ".", "getExecutionAttribute", "(", "RESOURCES_OPTIONS", ")", ";", "Path", "nmPrivateContainerScriptPath", "=", "ctx", ".", "getExecutionAttribute", "(", "NM_PRIVATE_CONTAINER_SCRIPT_PATH", ")", ";", "String", "disableOverride", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE", ")", ";", "if", "(", "disableOverride", "!=", "null", "&&", "disableOverride", ".", "equals", "(", "\"", "true", "\"", ")", ")", "{", "if", "(", "LOG", ".", "isInfoEnabled", "(", ")", ")", "{", "LOG", ".", "info", "(", "\"", "command override disabled", "\"", ")", ";", "}", "}", "else", "{", "List", "<", "String", ">", "overrideCommands", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Path", "launchDst", "=", "new", "Path", "(", "containerWorkDir", ",", "ContainerLaunch", ".", "CONTAINER_SCRIPT", ")", ";", "overrideCommands", ".", "add", "(", "\"", "bash", "\"", ")", ";", "overrideCommands", ".", "add", "(", "launchDst", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ")", ";", "runCommand", ".", "setOverrideCommandWithArgs", "(", "overrideCommands", ")", ";", "}", "String", "commandFile", "=", "dockerClient", ".", "writeCommandToTempFile", "(", "runCommand", ",", "containerIdStr", ")", ";", "PrivilegedOperation", "launchOp", "=", "new", "PrivilegedOperation", "(", "PrivilegedOperation", ".", "OperationType", ".", "LAUNCH_DOCKER_CONTAINER", ")", ";", "launchOp", ".", "appendArgs", "(", "runAsUser", ",", "ctx", ".", "getExecutionAttribute", "(", "USER", ")", ",", "Integer", ".", "toString", "(", "PrivilegedOperation", ".", "RunAsUserCommand", ".", "LAUNCH_DOCKER_CONTAINER", ".", "getValue", "(", ")", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "APPID", ")", ",", "containerIdStr", ",", "containerWorkDir", ".", "toString", "(", ")", ",", "nmPrivateContainerScriptPath", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "NM_PRIVATE_TOKENS_PATH", ")", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "PID_FILE_PATH", ")", ".", "toString", "(", ")", ",", "StringUtils", ".", "join", "(", "PrivilegedOperation", ".", "LINUX_FILE_PATH_SEPARATOR", ",", "localDirs", ")", ",", "StringUtils", ".", "join", "(", "PrivilegedOperation", ".", "LINUX_FILE_PATH_SEPARATOR", ",", "logDirs", ")", ",", "commandFile", ",", "resourcesOpts", ")", ";", "String", "tcCommandFile", "=", "ctx", ".", "getExecutionAttribute", "(", "TC_COMMAND_FILE", ")", ";", "if", "(", "tcCommandFile", "!=", "null", ")", "{", "launchOp", ".", "appendArgs", "(", "tcCommandFile", ")", ";", "}", "try", "{", "privilegedOperationExecutor", ".", "executePrivilegedOperation", "(", "null", ",", "launchOp", ",", "null", ",", "container", ".", "getLaunchContext", "(", ")", ".", "getEnvironment", "(", ")", ",", "false", ",", "false", ")", ";", "}", "catch", "(", "PrivilegedOperationException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Launch container failed. Exception: ", "\"", ",", "e", ")", ";", "throw", "new", "ContainerExecutionException", "(", "\"", "Launch container failed", "\"", ",", "e", ".", "getExitCode", "(", ")", ",", "e", ".", "getOutput", "(", ")", ",", "e", ".", "getErrorOutput", "(", ")", ")", ";", "}", "}"], "idx": 7756, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "bbe3b0857d383c5e4dc4a7ade90a88a3e24338b", "function_name": "launchContainer", "body_hash": "69da1773b4657b7fe857859f7acddd815aec9626"}
{"code": "private void initialJpsClassList(String packageName) throws Exception {\n                Package pk = Package.getPackage(packageName);\n                List<Class> classesForPackage = new ArrayList<>();\n                if (pk != null) {\n                        classesForPackage.addAll(getClassesForPackage(pk));\n                } else {\n                        classesForPackage.addAll(getClassesForPackage(packageName));\n                }\n                for (Class<Object> clazz : classesForPackage) {\n\n                        jpaClasses.add(clazz);\n                }\n        }", "code_tokens": ["private", "void", "initialJpsClassList", "(", "String", "packageName", ")", "throws", "Exception", "{", "Package", "pk", "=", "Package", ".", "getPackage", "(", "packageName", ")", ";", "List", "<", "Class", ">", "classesForPackage", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "pk", "!=", "null", ")", "{", "classesForPackage", ".", "addAll", "(", "getClassesForPackage", "(", "pk", ")", ")", ";", "}", "else", "{", "classesForPackage", ".", "addAll", "(", "getClassesForPackage", "(", "packageName", ")", ")", ";", "}", "for", "(", "Class", "<", "Object", ">", "clazz", ":", "classesForPackage", ")", "{", "jpaClasses", ".", "add", "(", "clazz", ")", ";", "}", "}"], "idx": 59481, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "e6ae0f4ce39e73ba29ab1c2926a41ac71e68574a", "function_name": "initialJpsClassList", "body_hash": "42bfc8a244e3920dca3551cf3ee19f30b1679de3"}
{"code": "protected void serveResource(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 boolean content,\n                                 String encoding)\n        throws IOException, ServletException {\n\n        boolean serveContent = content;\n\n        // Identify the requested resource path\n        String path = getRelativePath(request, true);\n\n        if (debug > 0) {\n            if (serveContent)\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers and data\");\n            else\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers only\");\n        }\n\n        if (path.length() == 0) {\n            // Context root redirect\n            doDirectoryRedirect(request, response);\n            return;\n        }\n\n        WebResource resource = resources.getResource(path);\n\n        if (!resource.exists()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // SRV.9.3 says we must throw a FNFE\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        if (!resource.canRead()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // Spec doesn't say what to do in this case but a FNFE seems\n                // reasonable\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestUri);\n            return;\n        }\n\n        // If the resource is not a collection, and the resource path\n        // ends with \"/\" or \"\\\", return NOT FOUND\n        if (resource.isFile() && (path.endsWith(\"/\") || path.endsWith(\"\\\\\"))) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            }\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        boolean isError = DispatcherType.ERROR == request.getDispatcherType();\n\n        boolean included = false;\n        // Check if the conditions specified in the optional If headers are\n        // satisfied.\n        if (resource.isFile()) {\n            // Checking If headers\n            included = (request.getAttribute(\n                    RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\n            if (!included && !isError && !checkIfHeaders(request, response, resource)) {\n                return;\n            }\n        }\n\n        // Find content type.\n        String contentType = resource.getMimeType();\n        if (contentType == null) {\n            contentType = getServletContext().getMimeType(resource.getName());\n            resource.setMimeType(contentType);\n        }\n\n        // These need to reflect the original resource, not the potentially\n        // precompressed version of the resource so get them now if they are going to\n        // be needed later\n        String eTag = null;\n        String lastModifiedHttp = null;\n        if (resource.isFile() && !isError) {\n            eTag = resource.getETag();\n            lastModifiedHttp = resource.getLastModifiedHttp();\n        }\n\n\n        // Serve a precompressed version of the file if present\n        boolean usingPrecompressedVersion = false;\n        if (compressionFormats.length > 0 && !included && resource.isFile() &&\n                !pathEndsWithCompressedExtension(path)) {\n            List<PrecompressedResource> precompressedResources =\n                    getAvailablePrecompressedResources(path);\n            if (!precompressedResources.isEmpty()) {\n                Collection<String> varyHeaders = response.getHeaders(\"Vary\");\n                boolean addRequired = true;\n                for (String varyHeader : varyHeaders) {\n                    if (\"*\".equals(varyHeader) ||\n                            \"accept-encoding\".equalsIgnoreCase(varyHeader)) {\n                        addRequired = false;\n                        break;\n                    }\n                }\n                if (addRequired) {\n                    response.addHeader(\"Vary\", \"accept-encoding\");\n                }\n                PrecompressedResource bestResource =\n                        getBestPrecompressedResource(request, precompressedResources);\n                if (bestResource != null) {\n                    response.addHeader(\"Content-Encoding\", bestResource.format.encoding);\n                    resource = bestResource.resource;\n                    usingPrecompressedVersion = true;\n                }\n            }\n        }\n\n        ArrayList<Range> ranges = null;\n        long contentLength = -1L;\n\n        if (resource.isDirectory()) {\n            if (!path.endsWith(\"/\")) {\n                doDirectoryRedirect(request, response);\n                return;\n            }\n\n            // Skip directory listings if we have been configured to\n            // suppress them\n            if (!listings) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                   request.getRequestURI());\n                return;\n            }\n            contentType = \"text/html;charset=UTF-8\";\n        } else {\n            if (!isError) {\n                if (useAcceptRanges) {\n                    // Accept ranges header\n                    response.setHeader(\"Accept-Ranges\", \"bytes\");\n                }\n\n                // Parse range specifier\n                ranges = parseRange(request, response, resource);\n\n                // ETag header\n                response.setHeader(\"ETag\", eTag);\n\n                // Last-Modified header\n                response.setHeader(\"Last-Modified\", lastModifiedHttp);\n            }\n\n            // Get content length\n            contentLength = resource.getContentLength();\n            // Special case for zero length files, which would cause a\n            // (silent) ISE when setting the output buffer size\n            if (contentLength == 0L) {\n                serveContent = false;\n            }\n        }\n\n        ServletOutputStream ostream = null;\n        PrintWriter writer = null;\n\n        if (serveContent) {\n            // Trying to retrieve the servlet output stream\n            try {\n                ostream = response.getOutputStream();\n            } catch (IllegalStateException e) {\n                // If it fails, we try to get a Writer instead if we're\n                // trying to serve a text file\n                if (!usingPrecompressedVersion &&\n                        ((contentType == null) ||\n                                (contentType.startsWith(\"text\")) ||\n                                (contentType.endsWith(\"xml\")) ||\n                                (contentType.contains(\"/javascript\")))\n                        ) {\n                    writer = response.getWriter();\n                    // Cannot reliably serve partial content with a Writer\n                    ranges = FULL;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // Check to see if a Filter, Valve of wrapper has written some content.\n        // If it has, disable range requests and setting of a content length\n        // since neither can be done reliably.\n        ServletResponse r = response;\n        long contentWritten = 0;\n        while (r instanceof ServletResponseWrapper) {\n            r = ((ServletResponseWrapper) r).getResponse();\n        }\n        if (r instanceof ResponseFacade) {\n            contentWritten = ((ResponseFacade) r).getContentWritten();\n        }\n        if (contentWritten > 0) {\n            ranges = FULL;\n        }\n\n        if (resource.isDirectory() ||\n                isError ||\n                ( (ranges == null || ranges.isEmpty())\n                        && request.getHeader(\"Range\") == null ) ||\n                ranges == FULL ) {\n\n            // Set the appropriate output headers\n            if (contentType != null) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentType='\" +\n                        contentType + \"'\");\n                response.setContentType(contentType);\n            }\n            if (resource.isFile() && contentLength >= 0 &&\n                    (!serveContent || ostream != null)) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentLength=\" +\n                        contentLength);\n                // Don't set a content length if something else has already\n                // written to the response.\n                if (contentWritten == 0) {\n                    response.setContentLengthLong(contentLength);\n                }\n            }\n\n            if (serveContent) {\n                try {\n                    response.setBufferSize(output);\n                } catch (IllegalStateException e) {\n                    // Silent catch\n                }\n                InputStream renderResult = null;\n                if (ostream == null) {\n                    // Output via a writer so can't use sendfile or write\n                    // content directly.\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        renderResult = resource.getInputStream();\n                    }\n                    copy(resource, renderResult, writer, encoding);\n                } else {\n                    // Output is via an InputStream\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        // Output is content of resource\n                        if (!checkSendfile(request, response, resource,\n                                contentLength, null)) {\n                            // sendfile not possible so check if resource\n                            // content is available directly\n                            byte[] resourceBody = resource.getContent();\n                            if (resourceBody == null) {\n                                // Resource content not available, use\n                                // inputstream\n                                renderResult = resource.getInputStream();\n                            } else {\n                                // Use the resource content directly\n                                ostream.write(resourceBody);\n                            }\n                        }\n                    }\n                    // If a stream was configured, it needs to be copied to\n                    // the output (this method closes the stream)\n                    if (renderResult != null) {\n                        copy(resource, renderResult, ostream);\n                    }\n                }\n            }\n\n        } else {\n\n            if ((ranges == null) || (ranges.isEmpty()))\n                return;\n\n            // Partial content response.\n\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n            if (ranges.size() == 1) {\n\n                Range range = ranges.get(0);\n                response.addHeader(\"Content-Range\", \"bytes \"\n                                   + range.start\n                                   + \"-\" + range.end + \"/\"\n                                   + range.length);\n                long length = range.end - range.start + 1;\n                response.setContentLengthLong(length);\n\n                if (contentType != null) {\n                    if (debug > 0)\n                        log(\"DefaultServlet.serveFile:  contentType='\" +\n                            contentType + \"'\");\n                    response.setContentType(contentType);\n                }\n\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        if (!checkSendfile(request, response, resource,\n                                range.end - range.start + 1, range))\n                            copy(resource, ostream, range);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            } else {\n                response.setContentType(\"multipart/byteranges; boundary=\"\n                                        + mimeSeparation);\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        copy(resource, ostream, ranges.iterator(), contentType);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "serveResource", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "boolean", "content", ",", "String", "encoding", ")", "throws", "IOException", ",", "ServletException", "{", "boolean", "serveContent", "=", "content", ";", "String", "path", "=", "getRelativePath", "(", "request", ",", "true", ")", ";", "if", "(", "debug", ">", "0", ")", "{", "if", "(", "serveContent", ")", "log", "(", "\"", "DefaultServlet.serveResource:  Serving resource '", "\"", "+", "path", "+", "\"", "' headers and data", "\"", ")", ";", "else", "log", "(", "\"", "DefaultServlet.serveResource:  Serving resource '", "\"", "+", "path", "+", "\"", "' headers only", "\"", ")", ";", "}", "if", "(", "path", ".", "length", "(", ")", "==", "0", ")", "{", "doDirectoryRedirect", "(", "request", ",", "response", ")", ";", "return", ";", "}", "WebResource", "resource", "=", "resources", ".", "getResource", "(", "path", ")", ";", "if", "(", "!", "resource", ".", "exists", "(", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "else", "{", "throw", "new", "FileNotFoundException", "(", "sm", ".", "getString", "(", "\"", "defaultServlet.missingResource", "\"", ",", "requestUri", ")", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "requestUri", ")", ";", "return", ";", "}", "if", "(", "!", "resource", ".", "canRead", "(", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "else", "{", "throw", "new", "FileNotFoundException", "(", "sm", ".", "getString", "(", "\"", "defaultServlet.missingResource", "\"", ",", "requestUri", ")", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ",", "requestUri", ")", ";", "return", ";", "}", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "(", "path", ".", "endsWith", "(", "\"", "/", "\"", ")", "||", "path", ".", "endsWith", "(", "\"", "\\\\", "\"", ")", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "requestUri", ")", ";", "return", ";", "}", "boolean", "isError", "=", "DispatcherType", ".", "ERROR", "==", "request", ".", "getDispatcherType", "(", ")", ";", "boolean", "included", "=", "false", ";", "if", "(", "resource", ".", "isFile", "(", ")", ")", "{", "included", "=", "(", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_CONTEXT_PATH", ")", "!=", "null", ")", ";", "if", "(", "!", "included", "&&", "!", "isError", "&&", "!", "checkIfHeaders", "(", "request", ",", "response", ",", "resource", ")", ")", "{", "return", ";", "}", "}", "String", "contentType", "=", "resource", ".", "getMimeType", "(", ")", ";", "if", "(", "contentType", "==", "null", ")", "{", "contentType", "=", "getServletContext", "(", ")", ".", "getMimeType", "(", "resource", ".", "getName", "(", ")", ")", ";", "resource", ".", "setMimeType", "(", "contentType", ")", ";", "}", "String", "eTag", "=", "null", ";", "String", "lastModifiedHttp", "=", "null", ";", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "!", "isError", ")", "{", "eTag", "=", "resource", ".", "getETag", "(", ")", ";", "lastModifiedHttp", "=", "resource", ".", "getLastModifiedHttp", "(", ")", ";", "}", "boolean", "usingPrecompressedVersion", "=", "false", ";", "if", "(", "compressionFormats", ".", "length", ">", "0", "&&", "!", "included", "&&", "resource", ".", "isFile", "(", ")", "&&", "!", "pathEndsWithCompressedExtension", "(", "path", ")", ")", "{", "List", "<", "PrecompressedResource", ">", "precompressedResources", "=", "getAvailablePrecompressedResources", "(", "path", ")", ";", "if", "(", "!", "precompressedResources", ".", "isEmpty", "(", ")", ")", "{", "Collection", "<", "String", ">", "varyHeaders", "=", "response", ".", "getHeaders", "(", "\"", "Vary", "\"", ")", ";", "boolean", "addRequired", "=", "true", ";", "for", "(", "String", "varyHeader", ":", "varyHeaders", ")", "{", "if", "(", "\"", "*", "\"", ".", "equals", "(", "varyHeader", ")", "||", "\"", "accept-encoding", "\"", ".", "equalsIgnoreCase", "(", "varyHeader", ")", ")", "{", "addRequired", "=", "false", ";", "break", ";", "}", "}", "if", "(", "addRequired", ")", "{", "response", ".", "addHeader", "(", "\"", "Vary", "\"", ",", "\"", "accept-encoding", "\"", ")", ";", "}", "PrecompressedResource", "bestResource", "=", "getBestPrecompressedResource", "(", "request", ",", "precompressedResources", ")", ";", "if", "(", "bestResource", "!=", "null", ")", "{", "response", ".", "addHeader", "(", "\"", "Content-Encoding", "\"", ",", "bestResource", ".", "format", ".", "encoding", ")", ";", "resource", "=", "bestResource", ".", "resource", ";", "usingPrecompressedVersion", "=", "true", ";", "}", "}", "}", "ArrayList", "<", "Range", ">", "ranges", "=", "null", ";", "long", "contentLength", "=", "-", "1L", ";", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "path", ".", "endsWith", "(", "\"", "/", "\"", ")", ")", "{", "doDirectoryRedirect", "(", "request", ",", "response", ")", ";", "return", ";", "}", "if", "(", "!", "listings", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "request", ".", "getRequestURI", "(", ")", ")", ";", "return", ";", "}", "contentType", "=", "\"", "text/html;charset=UTF-8", "\"", ";", "}", "else", "{", "if", "(", "!", "isError", ")", "{", "if", "(", "useAcceptRanges", ")", "{", "response", ".", "setHeader", "(", "\"", "Accept-Ranges", "\"", ",", "\"", "bytes", "\"", ")", ";", "}", "ranges", "=", "parseRange", "(", "request", ",", "response", ",", "resource", ")", ";", "response", ".", "setHeader", "(", "\"", "ETag", "\"", ",", "eTag", ")", ";", "response", ".", "setHeader", "(", "\"", "Last-Modified", "\"", ",", "lastModifiedHttp", ")", ";", "}", "contentLength", "=", "resource", ".", "getContentLength", "(", ")", ";", "if", "(", "contentLength", "==", "0L", ")", "{", "serveContent", "=", "false", ";", "}", "}", "ServletOutputStream", "ostream", "=", "null", ";", "PrintWriter", "writer", "=", "null", ";", "if", "(", "serveContent", ")", "{", "try", "{", "ostream", "=", "response", ".", "getOutputStream", "(", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "if", "(", "!", "usingPrecompressedVersion", "&&", "(", "(", "contentType", "==", "null", ")", "||", "(", "contentType", ".", "startsWith", "(", "\"", "text", "\"", ")", ")", "||", "(", "contentType", ".", "endsWith", "(", "\"", "xml", "\"", ")", ")", "||", "(", "contentType", ".", "contains", "(", "\"", "/javascript", "\"", ")", ")", ")", ")", "{", "writer", "=", "response", ".", "getWriter", "(", ")", ";", "ranges", "=", "FULL", ";", "}", "else", "{", "throw", "e", ";", "}", "}", "}", "ServletResponse", "r", "=", "response", ";", "long", "contentWritten", "=", "0", ";", "while", "(", "r", "instanceof", "ServletResponseWrapper", ")", "{", "r", "=", "(", "(", "ServletResponseWrapper", ")", "r", ")", ".", "getResponse", "(", ")", ";", "}", "if", "(", "r", "instanceof", "ResponseFacade", ")", "{", "contentWritten", "=", "(", "(", "ResponseFacade", ")", "r", ")", ".", "getContentWritten", "(", ")", ";", "}", "if", "(", "contentWritten", ">", "0", ")", "{", "ranges", "=", "FULL", ";", "}", "if", "(", "resource", ".", "isDirectory", "(", ")", "||", "isError", "||", "(", "(", "ranges", "==", "null", "||", "ranges", ".", "isEmpty", "(", ")", ")", "&&", "request", ".", "getHeader", "(", "\"", "Range", "\"", ")", "==", "null", ")", "||", "ranges", "==", "FULL", ")", "{", "if", "(", "contentType", "!=", "null", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentType='", "\"", "+", "contentType", "+", "\"", "'", "\"", ")", ";", "response", ".", "setContentType", "(", "contentType", ")", ";", "}", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "contentLength", ">=", "0", "&&", "(", "!", "serveContent", "||", "ostream", "!=", "null", ")", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentLength=", "\"", "+", "contentLength", ")", ";", "if", "(", "contentWritten", "==", "0", ")", "{", "response", ".", "setContentLengthLong", "(", "contentLength", ")", ";", "}", "}", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "InputStream", "renderResult", "=", "null", ";", "if", "(", "ostream", "==", "null", ")", "{", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "renderResult", "=", "render", "(", "getPathPrefix", "(", "request", ")", ",", "resource", ",", "encoding", ")", ";", "}", "else", "{", "renderResult", "=", "resource", ".", "getInputStream", "(", ")", ";", "}", "copy", "(", "resource", ",", "renderResult", ",", "writer", ",", "encoding", ")", ";", "}", "else", "{", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "renderResult", "=", "render", "(", "getPathPrefix", "(", "request", ")", ",", "resource", ",", "encoding", ")", ";", "}", "else", "{", "if", "(", "!", "checkSendfile", "(", "request", ",", "response", ",", "resource", ",", "contentLength", ",", "null", ")", ")", "{", "byte", "[", "]", "resourceBody", "=", "resource", ".", "getContent", "(", ")", ";", "if", "(", "resourceBody", "==", "null", ")", "{", "renderResult", "=", "resource", ".", "getInputStream", "(", ")", ";", "}", "else", "{", "ostream", ".", "write", "(", "resourceBody", ")", ";", "}", "}", "}", "if", "(", "renderResult", "!=", "null", ")", "{", "copy", "(", "resource", ",", "renderResult", ",", "ostream", ")", ";", "}", "}", "}", "}", "else", "{", "if", "(", "(", "ranges", "==", "null", ")", "||", "(", "ranges", ".", "isEmpty", "(", ")", ")", ")", "return", ";", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_PARTIAL_CONTENT", ")", ";", "if", "(", "ranges", ".", "size", "(", ")", "==", "1", ")", "{", "Range", "range", "=", "ranges", ".", "get", "(", "0", ")", ";", "response", ".", "addHeader", "(", "\"", "Content-Range", "\"", ",", "\"", "bytes ", "\"", "+", "range", ".", "start", "+", "\"", "-", "\"", "+", "range", ".", "end", "+", "\"", "/", "\"", "+", "range", ".", "length", ")", ";", "long", "length", "=", "range", ".", "end", "-", "range", ".", "start", "+", "1", ";", "response", ".", "setContentLengthLong", "(", "length", ")", ";", "if", "(", "contentType", "!=", "null", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentType='", "\"", "+", "contentType", "+", "\"", "'", "\"", ")", ";", "response", ".", "setContentType", "(", "contentType", ")", ";", "}", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "if", "(", "ostream", "!=", "null", ")", "{", "if", "(", "!", "checkSendfile", "(", "request", ",", "response", ",", "resource", ",", "range", ".", "end", "-", "range", ".", "start", "+", "1", ",", "range", ")", ")", "copy", "(", "resource", ",", "ostream", ",", "range", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "}", "}", "else", "{", "response", ".", "setContentType", "(", "\"", "multipart/byteranges; boundary=", "\"", "+", "mimeSeparation", ")", ";", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "if", "(", "ostream", "!=", "null", ")", "{", "copy", "(", "resource", ",", "ostream", ",", "ranges", ".", "iterator", "(", ")", ",", "contentType", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "}", "}", "}", "}"], "idx": 74457, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "4545dcce444aa619374a659cb450dbbd0be3c921", "function_name": "serveResource", "body_hash": "ff358ca3dd465868b1b30dbc66c082340a0d35d2"}
{"code": "public static void load(String originalName, ClassLoader loader) {\n        // Adjust expected name to support shading of native libraries.\n        String packagePrefix = calculatePackagePrefix().replace('.', '_');\n        String name = packagePrefix + originalName;\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        try {\n            // first try to load from java.library.path\n            loadLibrary(loader, name, false);\n            return;\n        } catch (Throwable ex) {\n            suppressed.add(ex);\n        }\n\n        String libname = System.mapLibraryName(name);\n        String path = NATIVE_RESOURCE_HOME + libname;\n\n        InputStream in = null;\n        OutputStream out = null;\n        File tmpFile = null;\n        URL url;\n        if (loader == null) {\n            url = ClassLoader.getSystemResource(path);\n        } else {\n            url = loader.getResource(path);\n        }\n        try {\n            if (url == null) {\n                if (PlatformDependent.isOsx()) {\n                    String fileName = path.endsWith(\".jnilib\") ? NATIVE_RESOURCE_HOME + \"lib\" + name + \".dynlib\" :\n                            NATIVE_RESOURCE_HOME + \"lib\" + name + \".jnilib\";\n                    if (loader == null) {\n                        url = ClassLoader.getSystemResource(fileName);\n                    } else {\n                        url = loader.getResource(fileName);\n                    }\n                    if (url == null) {\n                        FileNotFoundException fnf = new FileNotFoundException(fileName);\n                        ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                        throw fnf;\n                    }\n                } else {\n                    FileNotFoundException fnf = new FileNotFoundException(path);\n                    ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                    throw fnf;\n                }\n            }\n\n            int index = libname.lastIndexOf('.');\n            String prefix = libname.substring(0, index);\n            String suffix = libname.substring(index);\n\n            tmpFile = PlatformDependent.createTempFile(prefix, suffix, WORKDIR);\n            in = url.openStream();\n            out = new FileOutputStream(tmpFile);\n\n            if (shouldShadedLibraryIdBePatched(packagePrefix)) {\n                patchShadedLibraryId(in, out, originalName, name);\n            } else {\n                byte[] buffer = new byte[8192];\n                int length;\n                while ((length = in.read(buffer)) > 0) {\n                    out.write(buffer, 0, length);\n                }\n            }\n\n            out.flush();\n\n            // Close the output stream before loading the unpacked library,\n            // because otherwise Windows will refuse to load it when it's in use by other process.\n            closeQuietly(out);\n            out = null;\n            loadLibrary(loader, tmpFile.getPath(), true);\n        } catch (UnsatisfiedLinkError e) {\n            try {\n                if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&\n                    !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {\n                    // Pass \"io.netty.native.workdir\" as an argument to allow shading tools to see\n                    // the string. Since this is printed out to users to tell them what to do next,\n                    // we want the value to be correct even when shading.\n                    logger.info(\"{} exists but cannot be executed even when execute permissions set; \" +\n                                \"check volume for \\\"noexec\\\" flag; use -D{}=[path] \" +\n                                \"to set native working directory separately.\",\n                                tmpFile.getPath(), \"io.netty.native.workdir\");\n                }\n            } catch (Throwable t) {\n                suppressed.add(t);\n                logger.debug(\"Error checking if {} is on a file store mounted with noexec\", tmpFile, t);\n            }\n            // Re-throw to fail the load\n            ThrowableUtil.addSuppressedAndClear(e, suppressed);\n            throw e;\n        } catch (Exception e) {\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(\"could not load a native library: \" + name);\n            ule.initCause(e);\n            ThrowableUtil.addSuppressedAndClear(ule, suppressed);\n            throw ule;\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n            // After we load the library it is safe to delete the file.\n            // We delete the file immediately to free up resources as soon as possible,\n            // and if this fails fallback to deleting on JVM exit.\n            if (tmpFile != null && (!DELETE_NATIVE_LIB_AFTER_LOADING || !tmpFile.delete())) {\n                tmpFile.deleteOnExit();\n            }\n        }\n    }", "code_tokens": ["public", "static", "void", "load", "(", "String", "originalName", ",", "ClassLoader", "loader", ")", "{", "String", "packagePrefix", "=", "calculatePackagePrefix", "(", ")", ".", "replace", "(", "'.'", ",", "'_'", ")", ";", "String", "name", "=", "packagePrefix", "+", "originalName", ";", "List", "<", "Throwable", ">", "suppressed", "=", "new", "ArrayList", "<", "Throwable", ">", "(", ")", ";", "try", "{", "loadLibrary", "(", "loader", ",", "name", ",", "false", ")", ";", "return", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "suppressed", ".", "add", "(", "ex", ")", ";", "}", "String", "libname", "=", "System", ".", "mapLibraryName", "(", "name", ")", ";", "String", "path", "=", "NATIVE_RESOURCE_HOME", "+", "libname", ";", "InputStream", "in", "=", "null", ";", "OutputStream", "out", "=", "null", ";", "File", "tmpFile", "=", "null", ";", "URL", "url", ";", "if", "(", "loader", "==", "null", ")", "{", "url", "=", "ClassLoader", ".", "getSystemResource", "(", "path", ")", ";", "}", "else", "{", "url", "=", "loader", ".", "getResource", "(", "path", ")", ";", "}", "try", "{", "if", "(", "url", "==", "null", ")", "{", "if", "(", "PlatformDependent", ".", "isOsx", "(", ")", ")", "{", "String", "fileName", "=", "path", ".", "endsWith", "(", "\"", ".jnilib", "\"", ")", "?", "NATIVE_RESOURCE_HOME", "+", "\"", "lib", "\"", "+", "name", "+", "\"", ".dynlib", "\"", ":", "NATIVE_RESOURCE_HOME", "+", "\"", "lib", "\"", "+", "name", "+", "\"", ".jnilib", "\"", ";", "if", "(", "loader", "==", "null", ")", "{", "url", "=", "ClassLoader", ".", "getSystemResource", "(", "fileName", ")", ";", "}", "else", "{", "url", "=", "loader", ".", "getResource", "(", "fileName", ")", ";", "}", "if", "(", "url", "==", "null", ")", "{", "FileNotFoundException", "fnf", "=", "new", "FileNotFoundException", "(", "fileName", ")", ";", "ThrowableUtil", ".", "addSuppressedAndClear", "(", "fnf", ",", "suppressed", ")", ";", "throw", "fnf", ";", "}", "}", "else", "{", "FileNotFoundException", "fnf", "=", "new", "FileNotFoundException", "(", "path", ")", ";", "ThrowableUtil", ".", "addSuppressedAndClear", "(", "fnf", ",", "suppressed", ")", ";", "throw", "fnf", ";", "}", "}", "int", "index", "=", "libname", ".", "lastIndexOf", "(", "'.'", ")", ";", "String", "prefix", "=", "libname", ".", "substring", "(", "0", ",", "index", ")", ";", "String", "suffix", "=", "libname", ".", "substring", "(", "index", ")", ";", "tmpFile", "=", "PlatformDependent", ".", "createTempFile", "(", "prefix", ",", "suffix", ",", "WORKDIR", ")", ";", "in", "=", "url", ".", "openStream", "(", ")", ";", "out", "=", "new", "FileOutputStream", "(", "tmpFile", ")", ";", "if", "(", "shouldShadedLibraryIdBePatched", "(", "packagePrefix", ")", ")", "{", "patchShadedLibraryId", "(", "in", ",", "out", ",", "originalName", ",", "name", ")", ";", "}", "else", "{", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "8192", "]", ";", "int", "length", ";", "while", "(", "(", "length", "=", "in", ".", "read", "(", "buffer", ")", ")", ">", "0", ")", "{", "out", ".", "write", "(", "buffer", ",", "0", ",", "length", ")", ";", "}", "}", "out", ".", "flush", "(", ")", ";", "closeQuietly", "(", "out", ")", ";", "out", "=", "null", ";", "loadLibrary", "(", "loader", ",", "tmpFile", ".", "getPath", "(", ")", ",", "true", ")", ";", "}", "catch", "(", "UnsatisfiedLinkError", "e", ")", "{", "try", "{", "if", "(", "tmpFile", "!=", "null", "&&", "tmpFile", ".", "isFile", "(", ")", "&&", "tmpFile", ".", "canRead", "(", ")", "&&", "!", "NoexecVolumeDetector", ".", "canExecuteExecutable", "(", "tmpFile", ")", ")", "{", "logger", ".", "info", "(", "\"", "{} exists but cannot be executed even when execute permissions set; ", "\"", "+", "\"", "check volume for ", "\\\"", "noexec", "\\\"", " flag; use -D{}=[path] ", "\"", "+", "\"", "to set native working directory separately.", "\"", ",", "tmpFile", ".", "getPath", "(", ")", ",", "\"", "io.netty.native.workdir", "\"", ")", ";", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "suppressed", ".", "add", "(", "t", ")", ";", "logger", ".", "debug", "(", "\"", "Error checking if {} is on a file store mounted with noexec", "\"", ",", "tmpFile", ",", "t", ")", ";", "}", "ThrowableUtil", ".", "addSuppressedAndClear", "(", "e", ",", "suppressed", ")", ";", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "UnsatisfiedLinkError", "ule", "=", "new", "UnsatisfiedLinkError", "(", "\"", "could not load a native library: ", "\"", "+", "name", ")", ";", "ule", ".", "initCause", "(", "e", ")", ";", "ThrowableUtil", ".", "addSuppressedAndClear", "(", "ule", ",", "suppressed", ")", ";", "throw", "ule", ";", "}", "finally", "{", "closeQuietly", "(", "in", ")", ";", "closeQuietly", "(", "out", ")", ";", "if", "(", "tmpFile", "!=", "null", "&&", "(", "!", "DELETE_NATIVE_LIB_AFTER_LOADING", "||", "!", "tmpFile", ".", "delete", "(", ")", ")", ")", "{", "tmpFile", ".", "deleteOnExit", "(", ")", ";", "}", "}", "}"], "idx": 49836, "cwe": "CWE-378", "target": 0, "status": "FIXED", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "load", "body_hash": "531073b80ed62ea236e9072a515ae7ba71a0af4a"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (xmlMapper != null) {\n            // must be a reference value\n            String ref = xmlMapper.startsWith(\"#\") ? xmlMapper : \"#\" + xmlMapper;\n            setProperty(camelContext, dataFormat, \"xmlMapper\", ref);\n        }\n        if (unmarshalType != null) {\n            setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n        }\n        if (prettyPrint != null) {\n            setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n        }\n        if (jsonView != null) {\n            setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n        }\n        if (include != null) {\n            setProperty(camelContext, dataFormat, \"include\", include);\n        }\n        if (allowJmsType != null) {\n            setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n        }\n        if (collectionType != null) {\n            setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n        }\n        if (useList != null) {\n            setProperty(camelContext, dataFormat, \"useList\", useList);\n        }\n        if (enableJaxbAnnotationModule != null) {\n            setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n        }\n        if (moduleClassNames != null) {\n            setProperty(camelContext, dataFormat, \"modulesClassNames\", moduleClassNames);\n        }\n        if (moduleRefs != null) {\n            setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n        }\n        if (enableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n        }\n        if (disableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n        }\n        if (allowUnmarshallType != null) {\n            setProperty(camelContext, dataFormat, \"allowUnmarshallType\", allowUnmarshallType);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "xmlMapper", "!=", "null", ")", "{", "String", "ref", "=", "xmlMapper", ".", "startsWith", "(", "\"", "#", "\"", ")", "?", "xmlMapper", ":", "\"", "#", "\"", "+", "xmlMapper", ";", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "xmlMapper", "\"", ",", "ref", ")", ";", "}", "if", "(", "unmarshalType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "unmarshalType", "\"", ",", "unmarshalType", ")", ";", "}", "if", "(", "prettyPrint", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "prettyPrint", "\"", ",", "prettyPrint", ")", ";", "}", "if", "(", "jsonView", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "jsonView", "\"", ",", "jsonView", ")", ";", "}", "if", "(", "include", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "include", "\"", ",", "include", ")", ";", "}", "if", "(", "allowJmsType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowJmsType", "\"", ",", "allowJmsType", ")", ";", "}", "if", "(", "collectionType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "collectionType", "\"", ",", "collectionType", ")", ";", "}", "if", "(", "useList", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "useList", "\"", ",", "useList", ")", ";", "}", "if", "(", "enableJaxbAnnotationModule", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableJaxbAnnotationModule", "\"", ",", "enableJaxbAnnotationModule", ")", ";", "}", "if", "(", "moduleClassNames", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "modulesClassNames", "\"", ",", "moduleClassNames", ")", ";", "}", "if", "(", "moduleRefs", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "moduleRefs", "\"", ",", "moduleRefs", ")", ";", "}", "if", "(", "enableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableFeatures", "\"", ",", "enableFeatures", ")", ";", "}", "if", "(", "disableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "disableFeatures", "\"", ",", "disableFeatures", ")", ";", "}", "if", "(", "allowUnmarshallType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowUnmarshallType", "\"", ",", "allowUnmarshallType", ")", ";", "}", "}"], "idx": 57369, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "5ae9c0dcc4843347cd01ffb58ce5dd0687755a1", "function_name": "configureDataFormat", "body_hash": "878be313f0b53a94f36574d3e4c55b0635d6996c"}
{"code": "public void copyDirectoryFromPod(\n      String namespace,\n      String pod,\n      String container,\n      String srcPath,\n      Path destination,\n      boolean enableTarCompressing)\n      throws IOException, ApiException {\n    if (!enableTarCompressing) {\n      TreeNode tree = new TreeNode(true, srcPath, true);\n      createDirectoryTree(tree, namespace, pod, container, srcPath);\n      createDirectoryStructureFromTree(tree, namespace, pod, container, srcPath, destination);\n      return;\n    }\n    final Process proc =\n        this.exec(\n            namespace,\n            pod,\n            new String[] {\"sh\", \"-c\", \"tar cz - \" + srcPath + \" | base64\"},\n            container,\n            false,\n            false);\n    try (InputStream is = new Base64InputStream(new BufferedInputStream(proc.getInputStream()));\n        ArchiveInputStream archive = new TarArchiveInputStream(new GzipCompressorInputStream(is))) {\n      for (ArchiveEntry entry = archive.getNextEntry();\n          entry != null;\n          entry = archive.getNextEntry()) {\n        if (!archive.canReadEntryData(entry)) {\n          log.error(\"Can't read: \" + entry);\n          continue;\n        }\n        String normalName = FilenameUtils.normalize(entry.getName());\n        if (normalName == null) {\n          throw new IOException(\"Invalid entry: \" + entry.getName());\n        }\n        File f = new File(destination.toFile(), normalName);\n        if (entry.isDirectory()) {\n          if (!f.isDirectory() && !f.mkdirs()) {\n            throw new IOException(\"create directory failed: \" + f);\n          }\n        } else {\n          File parent = f.getParentFile();\n          if (!parent.isDirectory() && !parent.mkdirs()) {\n            throw new IOException(\"create directory failed: \" + parent);\n          }\n          try (OutputStream fs = new FileOutputStream(f)) {\n            ByteStreams.copy(archive, fs);\n            fs.flush();\n          }\n        }\n      }\n    }\n    try {\n      int status = proc.waitFor();\n      if (status != 0) {\n        throw new IOException(\"Copy command failed with status \" + status);\n      }\n    } catch (InterruptedException ex) {\n      throw new IOException(ex);\n    }\n  }", "code_tokens": ["public", "void", "copyDirectoryFromPod", "(", "String", "namespace", ",", "String", "pod", ",", "String", "container", ",", "String", "srcPath", ",", "Path", "destination", ",", "boolean", "enableTarCompressing", ")", "throws", "IOException", ",", "ApiException", "{", "if", "(", "!", "enableTarCompressing", ")", "{", "TreeNode", "tree", "=", "new", "TreeNode", "(", "true", ",", "srcPath", ",", "true", ")", ";", "createDirectoryTree", "(", "tree", ",", "namespace", ",", "pod", ",", "container", ",", "srcPath", ")", ";", "createDirectoryStructureFromTree", "(", "tree", ",", "namespace", ",", "pod", ",", "container", ",", "srcPath", ",", "destination", ")", ";", "return", ";", "}", "final", "Process", "proc", "=", "this", ".", "exec", "(", "namespace", ",", "pod", ",", "new", "String", "[", "]", "{", "\"", "sh", "\"", ",", "\"", "-c", "\"", ",", "\"", "tar cz - ", "\"", "+", "srcPath", "+", "\"", " | base64", "\"", "}", ",", "container", ",", "false", ",", "false", ")", ";", "try", "(", "InputStream", "is", "=", "new", "Base64InputStream", "(", "new", "BufferedInputStream", "(", "proc", ".", "getInputStream", "(", ")", ")", ")", ";", "ArchiveInputStream", "archive", "=", "new", "TarArchiveInputStream", "(", "new", "GzipCompressorInputStream", "(", "is", ")", ")", ")", "{", "for", "(", "ArchiveEntry", "entry", "=", "archive", ".", "getNextEntry", "(", ")", ";", "entry", "!=", "null", ";", "entry", "=", "archive", ".", "getNextEntry", "(", ")", ")", "{", "if", "(", "!", "archive", ".", "canReadEntryData", "(", "entry", ")", ")", "{", "log", ".", "error", "(", "\"", "Can't read: ", "\"", "+", "entry", ")", ";", "continue", ";", "}", "String", "normalName", "=", "FilenameUtils", ".", "normalize", "(", "entry", ".", "getName", "(", ")", ")", ";", "if", "(", "normalName", "==", "null", ")", "{", "throw", "new", "IOException", "(", "\"", "Invalid entry: ", "\"", "+", "entry", ".", "getName", "(", ")", ")", ";", "}", "File", "f", "=", "new", "File", "(", "destination", ".", "toFile", "(", ")", ",", "normalName", ")", ";", "if", "(", "entry", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "f", ".", "isDirectory", "(", ")", "&&", "!", "f", ".", "mkdirs", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "create directory failed: ", "\"", "+", "f", ")", ";", "}", "}", "else", "{", "File", "parent", "=", "f", ".", "getParentFile", "(", ")", ";", "if", "(", "!", "parent", ".", "isDirectory", "(", ")", "&&", "!", "parent", ".", "mkdirs", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "create directory failed: ", "\"", "+", "parent", ")", ";", "}", "try", "(", "OutputStream", "fs", "=", "new", "FileOutputStream", "(", "f", ")", ")", "{", "ByteStreams", ".", "copy", "(", "archive", ",", "fs", ")", ";", "fs", ".", "flush", "(", ")", ";", "}", "}", "}", "}", "try", "{", "int", "status", "=", "proc", ".", "waitFor", "(", ")", ";", "if", "(", "status", "!=", "0", ")", "{", "throw", "new", "IOException", "(", "\"", "Copy command failed with status ", "\"", "+", "status", ")", ";", "}", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "throw", "new", "IOException", "(", "ex", ")", ";", "}", "}"], "idx": 28737, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "eb2cfe945c1492503b086606734530550630d31f", "function_name": "copyDirectoryFromPod", "body_hash": "6852d9a01e9708f7eb0383ba2751912ce0e23a81"}
{"code": "private static Set<String> keysWithVariableValues(Map<String, String> rawConfig, Pattern pattern) {\n        Set<String> keys = new HashSet<>();\n        for (Map.Entry<String, String> config : rawConfig.entrySet()) {\n            if (config.getValue() != null) {\n                Matcher matcher = pattern.matcher(config.getValue());\n                if (matcher.matches()) {\n                    keys.add(config.getKey());\n                }\n            }\n        }\n        return keys;\n    }", "code_tokens": ["private", "static", "Set", "<", "String", ">", "keysWithVariableValues", "(", "Map", "<", "String", ",", "String", ">", "rawConfig", ",", "Pattern", "pattern", ")", "{", "Set", "<", "String", ">", "keys", "=", "new", "HashSet", "<", ">", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "config", ":", "rawConfig", ".", "entrySet", "(", ")", ")", "{", "if", "(", "config", ".", "getValue", "(", ")", "!=", "null", ")", "{", "Matcher", "matcher", "=", "pattern", ".", "matcher", "(", "config", ".", "getValue", "(", ")", ")", ";", "if", "(", "matcher", ".", "matches", "(", ")", ")", "{", "keys", ".", "add", "(", "config", ".", "getKey", "(", ")", ")", ";", "}", "}", "}", "return", "keys", ";", "}"], "idx": 41835, "cwe": "CWE-319", "target": 1, "status": "VULNERABLE", "commit": "5d2a6dc531150423a40f77783a4a09e1b0f90178", "function_name": "keysWithVariableValues", "body_hash": "06cbbd92d35c5324926fb8dbc8385041816c9d77"}
{"code": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }", "code_tokens": ["public", "void", "validateSubType", "(", "DeserializationContext", "ctxt", ",", "JavaType", "type", ")", "throws", "JsonMappingException", "{", "final", "Class", "<", "?", ">", "raw", "=", "type", ".", "getRawClass", "(", ")", ";", "String", "full", "=", "raw", ".", "getName", "(", ")", ";", "main_check", ":", "do", "{", "if", "(", "_cfgIllegalClassNames", ".", "contains", "(", "full", ")", ")", "{", "break", ";", "}", "if", "(", "!", "raw", ".", "isInterface", "(", ")", "&&", "full", ".", "startsWith", "(", "PREFIX_STRING", ")", ")", "{", "for", "(", "Class", "<", "?", ">", "cls", "=", "raw", ";", "(", "cls", "!=", "null", ")", "&&", "(", "cls", "!=", "Object", ".", "class", ")", ";", "cls", "=", "cls", ".", "getSuperclass", "(", ")", ")", "{", "String", "name", "=", "cls", ".", "getSimpleName", "(", ")", ";", "if", "(", "\"", "AbstractPointcutAdvisor", "\"", ".", "equals", "(", "name", ")", "||", "\"", "AbstractApplicationContext", "\"", ".", "equals", "(", "name", ")", ")", "{", "break", "main_check", ";", "}", "}", "}", "return", ";", "}", "while", "(", "false", ")", ";", "throw", "JsonMappingException", ".", "from", "(", "ctxt", ",", "String", ".", "format", "(", "\"", "Illegal type (%s) to deserialize: prevented for security reasons", "\"", ",", "full", ")", ")", ";", "}"], "idx": 2553, "cwe": "CWE-184", "target": 1, "status": "VULNERABLE", "commit": "6799f8f10cc78e9af6d443ed6982d00a13f2e7d2", "function_name": "validateSubType", "body_hash": "7b79e569cb8f770396d7773d1703b2cc4192099c"}
{"code": "protected InputStream findXsltInputStream(WebResource directory)\n        throws IOException {\n\n        if (localXsltFile != null) {\n            WebResource resource = resources.getResource(\n                    directory.getWebappPath() + localXsltFile);\n            if (resource.isFile()) {\n                InputStream is = resource.getInputStream();\n                if (is != null) {\n                    return is;\n                }\n            }\n            if (debug > 10) {\n                log(\"localXsltFile '\" + localXsltFile + \"' not found\");\n            }\n        }\n\n        if (contextXsltFile != null) {\n            InputStream is =\n                getServletContext().getResourceAsStream(contextXsltFile);\n            if (is != null)\n                return is;\n\n            if (debug > 10)\n                log(\"contextXsltFile '\" + contextXsltFile + \"' not found\");\n        }\n\n        /*  Open and read in file in one fell swoop to reduce chance\n         *  chance of leaving handle open.\n         */\n        if (globalXsltFile != null) {\n            File f = validateGlobalXsltFile();\n            if (f != null && f.exists()){\n                try (FileInputStream fis = new FileInputStream(f)){\n                    byte b[] = new byte[(int)f.length()]; /* danger! */\n                    fis.read(b);\n                    return new ByteArrayInputStream(b);\n                }\n            }\n        }\n\n        return null;\n    }", "code_tokens": ["protected", "InputStream", "findXsltInputStream", "(", "WebResource", "directory", ")", "throws", "IOException", "{", "if", "(", "localXsltFile", "!=", "null", ")", "{", "WebResource", "resource", "=", "resources", ".", "getResource", "(", "directory", ".", "getWebappPath", "(", ")", "+", "localXsltFile", ")", ";", "if", "(", "resource", ".", "isFile", "(", ")", ")", "{", "InputStream", "is", "=", "resource", ".", "getInputStream", "(", ")", ";", "if", "(", "is", "!=", "null", ")", "{", "return", "is", ";", "}", "}", "if", "(", "debug", ">", "10", ")", "{", "log", "(", "\"", "localXsltFile '", "\"", "+", "localXsltFile", "+", "\"", "' not found", "\"", ")", ";", "}", "}", "if", "(", "contextXsltFile", "!=", "null", ")", "{", "InputStream", "is", "=", "getServletContext", "(", ")", ".", "getResourceAsStream", "(", "contextXsltFile", ")", ";", "if", "(", "is", "!=", "null", ")", "return", "is", ";", "if", "(", "debug", ">", "10", ")", "log", "(", "\"", "contextXsltFile '", "\"", "+", "contextXsltFile", "+", "\"", "' not found", "\"", ")", ";", "}", "if", "(", "globalXsltFile", "!=", "null", ")", "{", "File", "f", "=", "validateGlobalXsltFile", "(", ")", ";", "if", "(", "f", "!=", "null", "&&", "f", ".", "exists", "(", ")", ")", "{", "try", "(", "FileInputStream", "fis", "=", "new", "FileInputStream", "(", "f", ")", ")", "{", "byte", "b", "[", "]", "=", "new", "byte", "[", "(", "int", ")", "f", ".", "length", "(", ")", "]", ";", "fis", ".", "read", "(", "b", ")", ";", "return", "new", "ByteArrayInputStream", "(", "b", ")", ";", "}", "}", "}", "return", "null", ";", "}"], "idx": 32430, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "970c23bfd24dfa1dcb86ed917e6c8b47dcfb4433", "function_name": "findXsltInputStream", "body_hash": "e6cb6acb4e9b468411e6a7292512d1be8b94e344"}
{"code": "private boolean instanceMethodParametersResolveToSameTypes(Method subTypeMethod, Method superTypeMethod) {\n\t\tif ( subTypeMethod.getParameterTypes().length == 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tResolvedType resolvedSubType = typeResolver.resolve( subTypeMethod.getDeclaringClass() );\n\n\t\tMemberResolver memberResolver = new MemberResolver( typeResolver );\n\t\tmemberResolver.setMethodFilter( new SimpleMethodFilter( subTypeMethod, superTypeMethod ) );\n\t\tResolvedTypeWithMembers typeWithMembers = memberResolver.resolve(\n\t\t\t\tresolvedSubType,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t);\n\n\t\tResolvedMethod[] resolvedMethods = typeWithMembers.getMemberMethods();\n\n\t\t// The ClassMate doc says that overridden methods are flattened to one\n\t\t// resolved method. But that is the case only for methods without any\n\t\t// generic parameters.\n\t\tif ( resolvedMethods.length == 1 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// For methods with generic parameters I have to compare the argument\n\t\t// types (which are resolved) of the two filtered member methods.\n\t\tfor ( int i = 0; i < resolvedMethods[0].getArgumentCount(); i++ ) {\n\n\t\t\tif ( !resolvedMethods[0].getArgumentType( i )\n\t\t\t\t\t.equals( resolvedMethods[1].getArgumentType( i ) ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}", "code_tokens": ["private", "boolean", "instanceMethodParametersResolveToSameTypes", "(", "Method", "subTypeMethod", ",", "Method", "superTypeMethod", ")", "{", "if", "(", "subTypeMethod", ".", "getParameterTypes", "(", ")", ".", "length", "==", "0", ")", "{", "return", "true", ";", "}", "ResolvedType", "resolvedSubType", "=", "typeResolver", ".", "resolve", "(", "subTypeMethod", ".", "getDeclaringClass", "(", ")", ")", ";", "MemberResolver", "memberResolver", "=", "new", "MemberResolver", "(", "typeResolver", ")", ";", "memberResolver", ".", "setMethodFilter", "(", "new", "SimpleMethodFilter", "(", "subTypeMethod", ",", "superTypeMethod", ")", ")", ";", "ResolvedTypeWithMembers", "typeWithMembers", "=", "memberResolver", ".", "resolve", "(", "resolvedSubType", ",", "null", ",", "null", ")", ";", "ResolvedMethod", "[", "]", "resolvedMethods", "=", "typeWithMembers", ".", "getMemberMethods", "(", ")", ";", "if", "(", "resolvedMethods", ".", "length", "==", "1", ")", "{", "return", "true", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "resolvedMethods", "[", "0", "]", ".", "getArgumentCount", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "resolvedMethods", "[", "0", "]", ".", "getArgumentType", "(", "i", ")", ".", "equals", "(", "resolvedMethods", "[", "1", "]", ".", "getArgumentType", "(", "i", ")", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "idx": 30740, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "67fdff14831c035c25e098fe14bd86523d17f726", "function_name": "instanceMethodParametersResolveToSameTypes", "body_hash": "e669e22aab5e89fdba056673384e0c7d1ec9a550"}
{"code": "public static Map<String, Lookup> getDefaultPrefixLookups() {\n        return DefaultPrefixLookupsHolder.INSTANCE.getDefaultPrefixLookups();\n    }", "code_tokens": ["public", "static", "Map", "<", "String", ",", "Lookup", ">", "getDefaultPrefixLookups", "(", ")", "{", "return", "DefaultPrefixLookupsHolder", ".", "INSTANCE", ".", "getDefaultPrefixLookups", "(", ")", ";", "}"], "idx": 105782, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "f025bc399e8125ffc7701ac74f09b833c5b5e152", "function_name": "getDefaultPrefixLookups", "body_hash": "eb63fdffb73c0273d40f67a28b5a19cb10973cb2"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (objectMapper != null) {\n            // must be a reference value\n            String ref = objectMapper.startsWith(\"#\") ? objectMapper : \"#\" + objectMapper;\n            setProperty(camelContext, dataFormat, \"objectMapper\", ref);\n        }\n        if (unmarshalType != null) {\n            setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n        }\n        if (prettyPrint != null) {\n            setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n        }\n        if (jsonView != null) {\n            setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n        }\n        if (include != null) {\n            setProperty(camelContext, dataFormat, \"include\", include);\n        }\n        if (allowJmsType != null) {\n            setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n        }\n        if (collectionType != null) {\n            setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n        }\n        if (useList != null) {\n            setProperty(camelContext, dataFormat, \"useList\", useList);\n        }\n        if (enableJaxbAnnotationModule != null) {\n            setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n        }\n        if (moduleClassNames != null) {\n            setProperty(camelContext, dataFormat, \"moduleClassNames\", moduleClassNames);\n        }\n        if (moduleRefs != null) {\n            setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n        }\n        if (enableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n        }\n        if (disableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n        }\n        if (permissions != null) {\n            setProperty(camelContext, dataFormat, \"permissions\", permissions);\n        }\n        // if we have the unmarshal type, but no permission set, then use it to be allowed\n        if (permissions == null && unmarshalType != null) {\n            String allow = \"+\" + unmarshalType.getName();\n            setProperty(camelContext, dataFormat, \"permissions\", allow);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "objectMapper", "!=", "null", ")", "{", "String", "ref", "=", "objectMapper", ".", "startsWith", "(", "\"", "#", "\"", ")", "?", "objectMapper", ":", "\"", "#", "\"", "+", "objectMapper", ";", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "objectMapper", "\"", ",", "ref", ")", ";", "}", "if", "(", "unmarshalType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "unmarshalType", "\"", ",", "unmarshalType", ")", ";", "}", "if", "(", "prettyPrint", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "prettyPrint", "\"", ",", "prettyPrint", ")", ";", "}", "if", "(", "jsonView", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "jsonView", "\"", ",", "jsonView", ")", ";", "}", "if", "(", "include", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "include", "\"", ",", "include", ")", ";", "}", "if", "(", "allowJmsType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowJmsType", "\"", ",", "allowJmsType", ")", ";", "}", "if", "(", "collectionType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "collectionType", "\"", ",", "collectionType", ")", ";", "}", "if", "(", "useList", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "useList", "\"", ",", "useList", ")", ";", "}", "if", "(", "enableJaxbAnnotationModule", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableJaxbAnnotationModule", "\"", ",", "enableJaxbAnnotationModule", ")", ";", "}", "if", "(", "moduleClassNames", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "moduleClassNames", "\"", ",", "moduleClassNames", ")", ";", "}", "if", "(", "moduleRefs", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "moduleRefs", "\"", ",", "moduleRefs", ")", ";", "}", "if", "(", "enableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableFeatures", "\"", ",", "enableFeatures", ")", ";", "}", "if", "(", "disableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "disableFeatures", "\"", ",", "disableFeatures", ")", ";", "}", "if", "(", "permissions", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "permissions", "\"", ",", "permissions", ")", ";", "}", "if", "(", "permissions", "==", "null", "&&", "unmarshalType", "!=", "null", ")", "{", "String", "allow", "=", "\"", "+", "\"", "+", "unmarshalType", ".", "getName", "(", ")", ";", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "permissions", "\"", ",", "allow", ")", ";", "}", "}"], "idx": 57270, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "02270ab9c90ac0d59b85dbd59fb9c1007eb44a1", "function_name": "configureDataFormat", "body_hash": "ff618847051bb79308ee4dd132dbe13d41681ffc"}
{"code": "private static File createTemporaryFolderIn(File parentFolder) throws IOException {\n        try {\n            return createTemporaryFolderWithNioApi(parentFolder);\n        } catch (ClassNotFoundException ignore) {\n            // Fallback for Java 5 and 6\n            return createTemporaryFolderWithFileApi(parentFolder);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof IOException) {\n                throw (IOException) cause;\n            }\n            if (cause instanceof RuntimeException) {\n                throw (RuntimeException) cause;\n            }\n            IOException exception = new IOException(\"Failed to create temporary folder in \" + parentFolder);\n            exception.initCause(cause);\n            throw exception;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to create temporary folder in \" + parentFolder, e);\n        }\n    }", "code_tokens": ["private", "static", "File", "createTemporaryFolderIn", "(", "File", "parentFolder", ")", "throws", "IOException", "{", "try", "{", "return", "createTemporaryFolderWithNioApi", "(", "parentFolder", ")", ";", "}", "catch", "(", "ClassNotFoundException", "ignore", ")", "{", "return", "createTemporaryFolderWithFileApi", "(", "parentFolder", ")", ";", "}", "catch", "(", "InvocationTargetException", "e", ")", "{", "Throwable", "cause", "=", "e", ".", "getCause", "(", ")", ";", "if", "(", "cause", "instanceof", "IOException", ")", "{", "throw", "(", "IOException", ")", "cause", ";", "}", "if", "(", "cause", "instanceof", "RuntimeException", ")", "{", "throw", "(", "RuntimeException", ")", "cause", ";", "}", "IOException", "exception", "=", "new", "IOException", "(", "\"", "Failed to create temporary folder in ", "\"", "+", "parentFolder", ")", ";", "exception", ".", "initCause", "(", "cause", ")", ";", "throw", "exception", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Failed to create temporary folder in ", "\"", "+", "parentFolder", ",", "e", ")", ";", "}", "}"], "idx": 72811, "cwe": "CWE-732", "target": 0, "status": "FIXED", "commit": "610155b8c22138329f0723eec22521627dbc52ae", "function_name": "createTemporaryFolderIn", "body_hash": "e14218f6174a9e9b77c12bb1f4dfcf5cefff4cd2"}
{"code": "@Override\n        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.process\",\n                        wrapper.getSocket(), status));\n            }\n            if (wrapper == null) {\n                // Nothing to do. Socket has been closed.\n                return SocketState.CLOSED;\n            }\n\n            S socket = wrapper.getSocket();\n\n            Processor processor = (Processor) wrapper.getCurrentProcessor();\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.connectionsGet\",\n                        processor, socket));\n            }\n\n            // Timeouts are calculated on a dedicated thread and then\n            // dispatched. Because of delays in the dispatch process, the\n            // timeout may no longer be required. Check here and avoid\n            // unnecessary processing.\n            if (SocketEvent.TIMEOUT == status &&\n                    (processor == null ||\n                    !processor.isAsync() && !processor.isUpgrade() ||\n                    processor.isAsync() && !processor.checkAsyncTimeoutGeneration())) {\n                // This is effectively a NO-OP\n                return SocketState.OPEN;\n            }\n\n            if (processor != null) {\n                // Make sure an async timeout doesn't fire\n                getProtocol().removeWaitingProcessor(processor);\n            } else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) {\n                // Nothing to do. Endpoint requested a close and there is no\n                // longer a processor associated with this socket.\n                return SocketState.CLOSED;\n            }\n\n            ContainerThreadMarker.set();\n\n            try {\n                if (processor == null) {\n                    String negotiatedProtocol = wrapper.getNegotiatedProtocol();\n                    // OpenSSL typically returns null whereas JSSE typically\n                    // returns \"\" when no protocol is negotiated\n                    if (negotiatedProtocol != null && negotiatedProtocol.length() > 0) {\n                        UpgradeProtocol upgradeProtocol = getProtocol().getNegotiatedProtocol(negotiatedProtocol);\n                        if (upgradeProtocol != null) {\n                            processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                            }\n                        } else if (negotiatedProtocol.equals(\"http/1.1\")) {\n                            // Explicitly negotiated the default protocol.\n                            // Obtain a processor below.\n                        } else {\n                            // TODO:\n                            // OpenSSL 1.0.2's ALPN callback doesn't support\n                            // failing the handshake with an error if no\n                            // protocol can be negotiated. Therefore, we need to\n                            // fail the connection here. Once this is fixed,\n                            // replace the code below with the commented out\n                            // block.\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        negotiatedProtocol));\n                            }\n                            return SocketState.CLOSED;\n                            /*\n                             * To replace the code above once OpenSSL 1.1.0 is\n                             * used.\n                            // Failed to create processor. This is a bug.\n                            throw new IllegalStateException(sm.getString(\n                                    \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                    negotiatedProtocol));\n                            */\n                        }\n                    }\n                }\n                if (processor == null) {\n                    processor = recycledProcessors.pop();\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorPop\", processor));\n                    }\n                }\n                if (processor == null) {\n                    processor = getProtocol().createProcessor();\n                    register(processor);\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                    }\n                }\n\n                processor.setSslSupport(\n                        wrapper.getSslSupport(getProtocol().getClientCertProvider()));\n\n                // Associate the processor with the connection\n                wrapper.setCurrentProcessor(processor);\n\n                SocketState state = SocketState.CLOSED;\n                do {\n                    state = processor.process(wrapper, status);\n\n                    if (state == SocketState.UPGRADING) {\n                        // Get the HTTP upgrade handler\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        // Retrieve leftover input\n                        ByteBuffer leftOverInput = processor.getLeftoverInput();\n                        if (upgradeToken == null) {\n                            // Assume direct HTTP/2 connection\n                            UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(\"h2c\");\n                            if (upgradeProtocol != null) {\n                                processor = upgradeProtocol.getProcessor(\n                                        wrapper, getProtocol().getAdapter());\n                                wrapper.unRead(leftOverInput);\n                                // Associate with the processor with the connection\n                                wrapper.setCurrentProcessor(processor);\n                            } else {\n                                if (getLog().isDebugEnabled()) {\n                                    getLog().debug(sm.getString(\n                                        \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        \"h2c\"));\n                                }\n                                return SocketState.CLOSED;\n                            }\n                        } else {\n                            HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                            // Release the Http11 processor to be re-used\n                            release(processor);\n                            // Create the upgrade processor\n                            processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.upgradeCreate\",\n                                        processor, wrapper));\n                            }\n                            wrapper.unRead(leftOverInput);\n                            // Mark the connection as upgraded\n                            wrapper.setUpgraded(true);\n                            // Associate with the processor with the connection\n                            wrapper.setCurrentProcessor(processor);\n                            // Initialise the upgrade handler (which may trigger\n                            // some IO using the new protocol which is why the lines\n                            // above are necessary)\n                            // This cast should be safe. If it fails the error\n                            // handling for the surrounding try/catch will deal with\n                            // it.\n                            if (upgradeToken.getInstanceManager() == null) {\n                                httpUpgradeHandler.init((WebConnection) processor);\n                            } else {\n                                ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                                try {\n                                    httpUpgradeHandler.init((WebConnection) processor);\n                                } finally {\n                                    upgradeToken.getContextBind().unbind(false, oldCL);\n                                }\n                            }\n                            if (httpUpgradeHandler instanceof InternalHttpUpgradeHandler) {\n                                if (((InternalHttpUpgradeHandler) httpUpgradeHandler).hasAsyncIO()) {\n                                    // The handler will initiate all further I/O\n                                    state = SocketState.LONG;\n                                }\n                            }\n                        }\n                    }\n                } while ( state == SocketState.UPGRADING);\n\n                if (state == SocketState.LONG) {\n                    // In the middle of processing a request/response. Keep the\n                    // socket associated with the processor. Exact requirements\n                    // depend on type of long poll\n                    longPoll(wrapper, processor);\n                    if (processor.isAsync()) {\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.OPEN) {\n                    // In keep-alive but between requests. OK to recycle\n                    // processor. Continue to poll for the next request.\n                    wrapper.setCurrentProcessor(null);\n                    release(processor);\n                    wrapper.registerReadInterest();\n                } else if (state == SocketState.SENDFILE) {\n                    // Sendfile in progress. If it fails, the socket will be\n                    // closed. If it works, the socket either be added to the\n                    // poller (or equivalent) to await more data or processed\n                    // if there are any pipe-lined requests remaining.\n                } else if (state == SocketState.UPGRADED) {\n                    // Don't add sockets back to the poller if this was a\n                    // non-blocking write otherwise the poller may trigger\n                    // multiple read events which may lead to thread starvation\n                    // in the connector. The write() method will add this socket\n                    // to the poller if necessary.\n                    if (status != SocketEvent.OPEN_WRITE) {\n                        longPoll(wrapper, processor);\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.SUSPENDED) {\n                    // Don't add sockets back to the poller.\n                    // The resumeProcessing() method will add this socket\n                    // to the poller.\n                } else {\n                    // Connection closed. OK to recycle the processor.\n                    // Processors handling upgrades require additional clean-up\n                    // before release.\n                    wrapper.setCurrentProcessor(null);\n                    if (processor.isUpgrade()) {\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                        InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                        if (instanceManager == null) {\n                            httpUpgradeHandler.destroy();\n                        } else {\n                            ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                            try {\n                                httpUpgradeHandler.destroy();\n                            } finally {\n                                try {\n                                    instanceManager.destroyInstance(httpUpgradeHandler);\n                                } catch (Throwable e) {\n                                    ExceptionUtils.handleThrowable(e);\n                                    getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n                                }\n                                upgradeToken.getContextBind().unbind(false, oldCL);\n                            }\n                        }\n                    }\n                    release(processor);\n                }\n                return state;\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.ioexception.debug\"), e);\n            } catch (ProtocolException e) {\n                // Protocol exceptions normally mean the client sent invalid or\n                // incomplete data.\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.protocolexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (OutOfMemoryError oome) {\n                // Try and handle this here to give Tomcat a chance to close the\n                // connection and prevent clients waiting until they time out.\n                // Worst case, it isn't recoverable and the attempt at logging\n                // will trigger another OOME.\n                getLog().error(sm.getString(\"abstractConnectionHandler.oome\"), oome);\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n            } finally {\n                ContainerThreadMarker.clear();\n            }\n\n            // Make sure socket/processor is removed from the list of current\n            // connections\n            wrapper.setCurrentProcessor(null);\n            release(processor);\n            return SocketState.CLOSED;\n        }", "code_tokens": ["@", "Override", "public", "SocketState", "process", "(", "SocketWrapperBase", "<", "S", ">", "wrapper", ",", "SocketEvent", "status", ")", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.process", "\"", ",", "wrapper", ".", "getSocket", "(", ")", ",", "status", ")", ")", ";", "}", "if", "(", "wrapper", "==", "null", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "S", "socket", "=", "wrapper", ".", "getSocket", "(", ")", ";", "Processor", "processor", "=", "(", "Processor", ")", "wrapper", ".", "getCurrentProcessor", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.connectionsGet", "\"", ",", "processor", ",", "socket", ")", ")", ";", "}", "if", "(", "SocketEvent", ".", "TIMEOUT", "==", "status", "&&", "(", "processor", "==", "null", "||", "!", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "isUpgrade", "(", ")", "||", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "checkAsyncTimeoutGeneration", "(", ")", ")", ")", "{", "return", "SocketState", ".", "OPEN", ";", "}", "if", "(", "processor", "!=", "null", ")", "{", "getProtocol", "(", ")", ".", "removeWaitingProcessor", "(", "processor", ")", ";", "}", "else", "if", "(", "status", "==", "SocketEvent", ".", "DISCONNECT", "||", "status", "==", "SocketEvent", ".", "ERROR", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "ContainerThreadMarker", ".", "set", "(", ")", ";", "try", "{", "if", "(", "processor", "==", "null", ")", "{", "String", "negotiatedProtocol", "=", "wrapper", ".", "getNegotiatedProtocol", "(", ")", ";", "if", "(", "negotiatedProtocol", "!=", "null", "&&", "negotiatedProtocol", ".", "length", "(", ")", ">", "0", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getNegotiatedProtocol", "(", "negotiatedProtocol", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "else", "if", "(", "negotiatedProtocol", ".", "equals", "(", "\"", "http/1.1", "\"", ")", ")", "{", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "negotiatedProtocol", ")", ")", ";", "}", "return", "SocketState", ".", "CLOSED", ";", "}", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "recycledProcessors", ".", "pop", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorPop", "\"", ",", "processor", ")", ")", ";", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "getProtocol", "(", ")", ".", "createProcessor", "(", ")", ";", "register", "(", "processor", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "processor", ".", "setSslSupport", "(", "wrapper", ".", "getSslSupport", "(", "getProtocol", "(", ")", ".", "getClientCertProvider", "(", ")", ")", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "SocketState", "state", "=", "SocketState", ".", "CLOSED", ";", "do", "{", "state", "=", "processor", ".", "process", "(", "wrapper", ",", "status", ")", ";", "if", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "ByteBuffer", "leftOverInput", "=", "processor", ".", "getLeftoverInput", "(", ")", ";", "if", "(", "upgradeToken", "==", "null", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getUpgradeProtocol", "(", "\"", "h2c", "\"", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "\"", "h2c", "\"", ")", ")", ";", "}", "return", "SocketState", ".", "CLOSED", ";", "}", "}", "else", "{", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "release", "(", "processor", ")", ";", "processor", "=", "getProtocol", "(", ")", ".", "createUpgradeProcessor", "(", "wrapper", ",", "upgradeToken", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.upgradeCreate", "\"", ",", "processor", ",", "wrapper", ")", ")", ";", "}", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "wrapper", ".", "setUpgraded", "(", "true", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "if", "(", "upgradeToken", ".", "getInstanceManager", "(", ")", "==", "null", ")", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "finally", "{", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "if", "(", "httpUpgradeHandler", "instanceof", "InternalHttpUpgradeHandler", ")", "{", "if", "(", "(", "(", "InternalHttpUpgradeHandler", ")", "httpUpgradeHandler", ")", ".", "hasAsyncIO", "(", ")", ")", "{", "state", "=", "SocketState", ".", "LONG", ";", "}", "}", "}", "}", "}", "while", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", ";", "if", "(", "state", "==", "SocketState", ".", "LONG", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "if", "(", "processor", ".", "isAsync", "(", ")", ")", "{", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "OPEN", ")", "{", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "release", "(", "processor", ")", ";", "wrapper", ".", "registerReadInterest", "(", ")", ";", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SENDFILE", ")", "{", "}", "else", "if", "(", "state", "==", "SocketState", ".", "UPGRADED", ")", "{", "if", "(", "status", "!=", "SocketEvent", ".", "OPEN_WRITE", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SUSPENDED", ")", "{", "}", "else", "{", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "if", "(", "processor", ".", "isUpgrade", "(", ")", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "InstanceManager", "instanceManager", "=", "upgradeToken", ".", "getInstanceManager", "(", ")", ";", "if", "(", "instanceManager", "==", "null", ")", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "finally", "{", "try", "{", "instanceManager", ".", "destroyInstance", "(", "httpUpgradeHandler", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "}", "release", "(", "processor", ")", ";", "}", "return", "state", ";", "}", "catch", "(", "java", ".", "net", ".", "SocketException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.socketexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "java", ".", "io", ".", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.ioexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "ProtocolException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.protocolexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "OutOfMemoryError", "oome", ")", "{", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.oome", "\"", ")", ",", "oome", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "finally", "{", "ContainerThreadMarker", ".", "clear", "(", ")", ";", "}", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "release", "(", "processor", ")", ";", "return", "SocketState", ".", "CLOSED", ";", "}"], "idx": 56813, "cwe": "CWE-476", "target": 1, "status": "VULNERABLE", "commit": "172977f04a5215128f1e278a688983dcd230f399", "function_name": "process", "body_hash": "84ad003496ef4142549a7c75211d0d2351ed8e21"}
{"code": "private Document parse(String configFile) {\n    Document doc = null;\n    try {\n\n      SAXParserFactory factory = SAXParserFactory.newInstance();\n      factory.setValidating(false);\n\n      // Create the builder and parse the file\n      SAXParser parser = factory.newSAXParser();\n      parser.parse(configFile, this);\n\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Resource::\" + getResourceSpecifierPath());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Instance Count::\" + getInstanceCount());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Service Name::\" + getServiceName());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Filter String::\" + getFilterString());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Naming Service Host::\" + getNamingServiceHost());\n      UIMAFramework.getLogger().log(Level.CONFIG,\n              \"Server Socket Timeout::\" + getServerSocketTimeout());\n\n    } catch (Exception ex) {\n      ex.printStackTrace();\n    }\n    return doc;\n  }", "code_tokens": ["private", "Document", "parse", "(", "String", "configFile", ")", "{", "Document", "doc", "=", "null", ";", "try", "{", "SAXParserFactory", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setValidating", "(", "false", ")", ";", "SAXParser", "parser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "parser", ".", "parse", "(", "configFile", ",", "this", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Resource::", "\"", "+", "getResourceSpecifierPath", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Instance Count::", "\"", "+", "getInstanceCount", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Service Name::", "\"", "+", "getServiceName", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Filter String::", "\"", "+", "getFilterString", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Naming Service Host::", "\"", "+", "getNamingServiceHost", "(", ")", ")", ";", "UIMAFramework", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "CONFIG", ",", "\"", "Server Socket Timeout::", "\"", "+", "getServerSocketTimeout", "(", ")", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "}", "return", "doc", ";", "}"], "idx": 70225, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "39909bf21fd694f4fb792d1de8adc72562ead25e", "function_name": "parse", "body_hash": "27de2ee96d0050ce6c6e24c4cf1b3b3a5cd4fbb4"}
{"code": "@Override\n    public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException {\n        String function = uri.getQueryParameters().getFirst(callbackQueryParameter);\n        if (function != null && !function.trim().isEmpty() && !jsonpCompatibleMediaTypes.getPossible(context.getMediaType()).isEmpty()){\n\n            OutputStreamWriter writer = new OutputStreamWriter(context.getOutputStream());\n\n            if (wrapInTryCatch) writer.write(\"try{\");\n            writer.write(function + \"(\");\n            writer.flush();\n\n            // Disable the close method before calling context.proceed()\n            OutputStream old = context.getOutputStream();\n            DoNotCloseDelegateOutputStream wrappedOutputStream = new DoNotCloseDelegateOutputStream(old);\n            context.setOutputStream(wrappedOutputStream);\n\n            try {\n                context.proceed();\n                wrappedOutputStream.flush();\n                writer.write(\")\");\n                if (wrapInTryCatch) writer.write(\"}catch(e){}\");\n                writer.flush();\n            } finally {\n                context.setOutputStream(old);\n            }\n        } else {\n            context.proceed();\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "aroundWriteTo", "(", "WriterInterceptorContext", "context", ")", "throws", "IOException", ",", "WebApplicationException", "{", "String", "function", "=", "uri", ".", "getQueryParameters", "(", ")", ".", "getFirst", "(", "callbackQueryParameter", ")", ";", "if", "(", "function", "!=", "null", "&&", "!", "function", ".", "trim", "(", ")", ".", "isEmpty", "(", ")", "&&", "!", "jsonpCompatibleMediaTypes", ".", "getPossible", "(", "context", ".", "getMediaType", "(", ")", ")", ".", "isEmpty", "(", ")", ")", "{", "OutputStreamWriter", "writer", "=", "new", "OutputStreamWriter", "(", "context", ".", "getOutputStream", "(", ")", ")", ";", "if", "(", "wrapInTryCatch", ")", "writer", ".", "write", "(", "\"", "try{", "\"", ")", ";", "writer", ".", "write", "(", "function", "+", "\"", "(", "\"", ")", ";", "writer", ".", "flush", "(", ")", ";", "OutputStream", "old", "=", "context", ".", "getOutputStream", "(", ")", ";", "DoNotCloseDelegateOutputStream", "wrappedOutputStream", "=", "new", "DoNotCloseDelegateOutputStream", "(", "old", ")", ";", "context", ".", "setOutputStream", "(", "wrappedOutputStream", ")", ";", "try", "{", "context", ".", "proceed", "(", ")", ";", "wrappedOutputStream", ".", "flush", "(", ")", ";", "writer", ".", "write", "(", "\"", ")", "\"", ")", ";", "if", "(", "wrapInTryCatch", ")", "writer", ".", "write", "(", "\"", "}catch(e){}", "\"", ")", ";", "writer", ".", "flush", "(", ")", ";", "}", "finally", "{", "context", ".", "setOutputStream", "(", "old", ")", ";", "}", "}", "else", "{", "context", ".", "proceed", "(", ")", ";", "}", "}"], "idx": 79860, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "7cc46c65b11de69b87ef8850dc68cca3de8cd7c6", "function_name": "aroundWriteTo", "body_hash": "11044c0763b36260889b6821a505aa32cdc8287c"}
{"code": "public UnixUser authenticate(String username, String password) throws PAMException {\n        this.password = password;\n        try {\n            check(libpam.pam_set_item(pht,PAM_USER,username),\"pam_set_item failed\");\n            check(libpam.pam_authenticate(pht,0),\"pam_authenticate failed\");\n            check(libpam.pam_setcred(pht,0),\"pam_setcred failed\");\n            // several different error code seem to be used to represent authentication failures\n//            check(libpam.pam_acct_mgmt(pht,0),\"pam_acct_mgmt failed\");\n\n            PointerByReference r = new PointerByReference();\n            check(libpam.pam_get_item(pht,PAM_USER,r),\"pam_get_item failed\");\n            String userName = r.getValue().getString(0);\n            passwd pwd = libc.getpwnam(userName);\n            if(pwd==null)\n                throw new PAMException(\"Authentication succeeded but no user information is available\");\n            return new UnixUser(userName,pwd);\n        } finally {\n            this.password = null;\n        }\n    }", "code_tokens": ["public", "UnixUser", "authenticate", "(", "String", "username", ",", "String", "password", ")", "throws", "PAMException", "{", "this", ".", "password", "=", "password", ";", "try", "{", "check", "(", "libpam", ".", "pam_set_item", "(", "pht", ",", "PAM_USER", ",", "username", ")", ",", "\"", "pam_set_item failed", "\"", ")", ";", "check", "(", "libpam", ".", "pam_authenticate", "(", "pht", ",", "0", ")", ",", "\"", "pam_authenticate failed", "\"", ")", ";", "check", "(", "libpam", ".", "pam_setcred", "(", "pht", ",", "0", ")", ",", "\"", "pam_setcred failed", "\"", ")", ";", "PointerByReference", "r", "=", "new", "PointerByReference", "(", ")", ";", "check", "(", "libpam", ".", "pam_get_item", "(", "pht", ",", "PAM_USER", ",", "r", ")", ",", "\"", "pam_get_item failed", "\"", ")", ";", "String", "userName", "=", "r", ".", "getValue", "(", ")", ".", "getString", "(", "0", ")", ";", "passwd", "pwd", "=", "libc", ".", "getpwnam", "(", "userName", ")", ";", "if", "(", "pwd", "==", "null", ")", "throw", "new", "PAMException", "(", "\"", "Authentication succeeded but no user information is available", "\"", ")", ";", "return", "new", "UnixUser", "(", "userName", ",", "pwd", ")", ";", "}", "finally", "{", "this", ".", "password", "=", "null", ";", "}", "}"], "idx": 11704, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "84f32f4001fc6bdcc125ccc959081de022d18b6d", "function_name": "authenticate", "body_hash": "2d92e44a7e6c2fa457f6e7d15288f49724271752"}
{"code": "@Override\n    public void setAllowJavaSerializedObject(boolean allowJavaSerializedObject) {\n        // need to override and call super for component docs\n        super.setAllowJavaSerializedObject(allowJavaSerializedObject);\n    }", "code_tokens": ["@", "Override", "public", "void", "setAllowJavaSerializedObject", "(", "boolean", "allowJavaSerializedObject", ")", "{", "super", ".", "setAllowJavaSerializedObject", "(", "allowJavaSerializedObject", ")", ";", "}"], "idx": 4128, "cwe": "CWE-19", "target": 1, "status": "VULNERABLE", "commit": "9cbd5867fe73ef07ecba6f16d64689632e3f2a16", "function_name": "setAllowJavaSerializedObject", "body_hash": "d7098bfba8d617b92e0d966c7631c84b40806cd5"}
{"code": "protected String sanitiseWindowId(String windowId)\n    {\n        return windowId.replace('(', '_').replace('<', '_').replace('&', '_');\n    }", "code_tokens": ["protected", "String", "sanitiseWindowId", "(", "String", "windowId", ")", "{", "return", "windowId", ".", "replace", "(", "'('", ",", "'_'", ")", ".", "replace", "(", "'<'", ",", "'_'", ")", ".", "replace", "(", "'&'", ",", "'_'", ")", ";", "}"], "idx": 73328, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "beae6e12f64e1a0066c3add17a4bfcca2ee0fb2c", "function_name": "sanitiseWindowId", "body_hash": "ae6de954bb35b34ad6bd242bc646e033ca8b2c6c"}
{"code": "private Session connectToServerRecursive(Endpoint endpoint,\n            ClientEndpointConfig clientEndpointConfiguration, URI path,\n            Set<URI> redirectSet)\n            throws DeploymentException {\n\n        boolean secure = false;\n        ByteBuffer proxyConnect = null;\n        URI proxyPath;\n\n        // Validate scheme (and build proxyPath)\n        String scheme = path.getScheme();\n        if (\"ws\".equalsIgnoreCase(scheme)) {\n            proxyPath = URI.create(\"http\" + path.toString().substring(2));\n        } else if (\"wss\".equalsIgnoreCase(scheme)) {\n            proxyPath = URI.create(\"https\" + path.toString().substring(3));\n            secure = true;\n        } else {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.pathWrongScheme\", scheme));\n        }\n\n        // Validate host\n        String host = path.getHost();\n        if (host == null) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.pathNoHost\"));\n        }\n        int port = path.getPort();\n\n        SocketAddress sa = null;\n\n        // Check to see if a proxy is configured. Javadoc indicates return value\n        // will never be null\n        List<Proxy> proxies = ProxySelector.getDefault().select(proxyPath);\n        Proxy selectedProxy = null;\n        for (Proxy proxy : proxies) {\n            if (proxy.type().equals(Proxy.Type.HTTP)) {\n                sa = proxy.address();\n                if (sa instanceof InetSocketAddress) {\n                    InetSocketAddress inet = (InetSocketAddress) sa;\n                    if (inet.isUnresolved()) {\n                        sa = new InetSocketAddress(inet.getHostName(), inet.getPort());\n                    }\n                }\n                selectedProxy = proxy;\n                break;\n            }\n        }\n\n        // If the port is not explicitly specified, compute it based on the\n        // scheme\n        if (port == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else {\n                // Must be wss due to scheme validation above\n                port = 443;\n            }\n        }\n\n        // If sa is null, no proxy is configured so need to create sa\n        if (sa == null) {\n            sa = new InetSocketAddress(host, port);\n        } else {\n            proxyConnect = createProxyRequest(host, port);\n        }\n\n        // Create the initial HTTP request to open the WebSocket connection\n        Map<String, List<String>> reqHeaders = createRequestHeaders(host, port,\n                clientEndpointConfiguration);\n        clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);\n        if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null\n                && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {\n            List<String> originValues = new ArrayList<>(1);\n            originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);\n            reqHeaders.put(Constants.ORIGIN_HEADER_NAME, originValues);\n        }\n        ByteBuffer request = createRequest(path, reqHeaders);\n\n        AsynchronousSocketChannel socketChannel;\n        try {\n            socketChannel = AsynchronousSocketChannel.open(getAsynchronousChannelGroup());\n        } catch (IOException ioe) {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.asynchronousSocketChannelFail\"), ioe);\n        }\n\n        Map<String,Object> userProperties = clientEndpointConfiguration.getUserProperties();\n\n        // Get the connection timeout\n        long timeout = Constants.IO_TIMEOUT_MS_DEFAULT;\n        String timeoutValue = (String) userProperties.get(Constants.IO_TIMEOUT_MS_PROPERTY);\n        if (timeoutValue != null) {\n            timeout = Long.valueOf(timeoutValue).intValue();\n        }\n\n        // Set-up\n        // Same size as the WsFrame input buffer\n        ByteBuffer response = ByteBuffer.allocate(getDefaultMaxBinaryMessageBufferSize());\n        String subProtocol;\n        boolean success = false;\n        List<Extension> extensionsAgreed = new ArrayList<>();\n        Transformation transformation = null;\n\n        // Open the connection\n        Future<Void> fConnect = socketChannel.connect(sa);\n        AsyncChannelWrapper channel = null;\n\n        if (proxyConnect != null) {\n            try {\n                fConnect.get(timeout, TimeUnit.MILLISECONDS);\n                // Proxy CONNECT is clear text\n                channel = new AsyncChannelWrapperNonSecure(socketChannel);\n                writeRequest(channel, proxyConnect, timeout);\n                HttpResponse httpResponse = processResponse(response, channel, timeout);\n                if (httpResponse.getStatus() != 200) {\n                    throw new DeploymentException(sm.getString(\n                            \"wsWebSocketContainer.proxyConnectFail\", selectedProxy,\n                            Integer.toString(httpResponse.getStatus())));\n                }\n            } catch (TimeoutException | InterruptedException | ExecutionException |\n                    EOFException e) {\n                if (channel != null) {\n                    channel.close();\n                }\n                throw new DeploymentException(\n                        sm.getString(\"wsWebSocketContainer.httpRequestFailed\"), e);\n            }\n        }\n\n        if (secure) {\n            // Regardless of whether a non-secure wrapper was created for a\n            // proxy CONNECT, need to use TLS from this point on so wrap the\n            // original AsynchronousSocketChannel\n            SSLEngine sslEngine = createSSLEngine(userProperties, host, port);\n            channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine);\n        } else if (channel == null) {\n            // Only need to wrap as this point if it wasn't wrapped to process a\n            // proxy CONNECT\n            channel = new AsyncChannelWrapperNonSecure(socketChannel);\n        }\n\n        try {\n            fConnect.get(timeout, TimeUnit.MILLISECONDS);\n\n            Future<Void> fHandshake = channel.handshake();\n            fHandshake.get(timeout, TimeUnit.MILLISECONDS);\n\n            writeRequest(channel, request, timeout);\n\n            HttpResponse httpResponse = processResponse(response, channel, timeout);\n\n            // Check maximum permitted redirects\n            int maxRedirects = Constants.MAX_REDIRECTIONS_DEFAULT;\n            String maxRedirectsValue =\n                    (String) userProperties.get(Constants.MAX_REDIRECTIONS_PROPERTY);\n            if (maxRedirectsValue != null) {\n                maxRedirects = Integer.parseInt(maxRedirectsValue);\n            }\n\n            if (httpResponse.status != 101) {\n                if(isRedirectStatus(httpResponse.status)){\n                    List<String> locationHeader =\n                            httpResponse.getHandshakeResponse().getHeaders().get(\n                                    Constants.LOCATION_HEADER_NAME);\n\n                    if (locationHeader == null || locationHeader.isEmpty() ||\n                            locationHeader.get(0) == null || locationHeader.get(0).isEmpty()) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.missingLocationHeader\",\n                                Integer.toString(httpResponse.status)));\n                    }\n\n                    URI redirectLocation = URI.create(locationHeader.get(0)).normalize();\n\n                    if (!redirectLocation.isAbsolute()) {\n                        redirectLocation = path.resolve(redirectLocation);\n                    }\n\n                    String redirectScheme = redirectLocation.getScheme().toLowerCase();\n\n                    if (redirectScheme.startsWith(\"http\")) {\n                        redirectLocation = new URI(redirectScheme.replace(\"http\", \"ws\"),\n                                redirectLocation.getUserInfo(), redirectLocation.getHost(),\n                                redirectLocation.getPort(), redirectLocation.getPath(),\n                                redirectLocation.getQuery(), redirectLocation.getFragment());\n                    }\n\n                    if (!redirectSet.add(redirectLocation) || redirectSet.size() > maxRedirects) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.redirectThreshold\", redirectLocation,\n                                Integer.toString(redirectSet.size()),\n                                Integer.toString(maxRedirects)));\n                    }\n\n                    return connectToServerRecursive(endpoint, clientEndpointConfiguration, redirectLocation, redirectSet);\n\n                }\n\n                else if (httpResponse.status == 401) {\n\n                    if (userProperties.get(Constants.AUTHORIZATION_HEADER_NAME) != null) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.failedAuthentication\",\n                                Integer.valueOf(httpResponse.status)));\n                    }\n\n                    List<String> wwwAuthenticateHeaders = httpResponse.getHandshakeResponse()\n                            .getHeaders().get(Constants.WWW_AUTHENTICATE_HEADER_NAME);\n\n                    if (wwwAuthenticateHeaders == null || wwwAuthenticateHeaders.isEmpty() ||\n                            wwwAuthenticateHeaders.get(0) == null || wwwAuthenticateHeaders.get(0).isEmpty()) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.missingWWWAuthenticateHeader\",\n                                Integer.toString(httpResponse.status)));\n                    }\n\n                    String authScheme = wwwAuthenticateHeaders.get(0).split(\"\\\\s+\", 2)[0];\n                    String requestUri = new String(request.array(), StandardCharsets.ISO_8859_1)\n                            .split(\"\\\\s\", 3)[1];\n\n                    Authenticator auth = AuthenticatorFactory.getAuthenticator(authScheme);\n\n                    if (auth == null) {\n                        throw new DeploymentException(\n                                sm.getString(\"wsWebSocketContainer.unsupportedAuthScheme\",\n                                        Integer.valueOf(httpResponse.status), authScheme));\n                    }\n\n                    userProperties.put(Constants.AUTHORIZATION_HEADER_NAME, auth.getAuthorization(\n                            requestUri, wwwAuthenticateHeaders.get(0), userProperties));\n\n                    return connectToServerRecursive(endpoint, clientEndpointConfiguration, path, redirectSet);\n\n                }\n\n                else {\n                    throw new DeploymentException(sm.getString(\"wsWebSocketContainer.invalidStatus\",\n                            Integer.toString(httpResponse.status)));\n                }\n            }\n            HandshakeResponse handshakeResponse = httpResponse.getHandshakeResponse();\n            clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);\n\n            // Sub-protocol\n            List<String> protocolHeaders = handshakeResponse.getHeaders().get(\n                    Constants.WS_PROTOCOL_HEADER_NAME);\n            if (protocolHeaders == null || protocolHeaders.size() == 0) {\n                subProtocol = null;\n            } else if (protocolHeaders.size() == 1) {\n                subProtocol = protocolHeaders.get(0);\n            } else {\n                throw new DeploymentException(\n                        sm.getString(\"wsWebSocketContainer.invalidSubProtocol\"));\n            }\n\n            // Extensions\n            // Should normally only be one header but handle the case of\n            // multiple headers\n            List<String> extHeaders = handshakeResponse.getHeaders().get(\n                    Constants.WS_EXTENSIONS_HEADER_NAME);\n            if (extHeaders != null) {\n                for (String extHeader : extHeaders) {\n                    Util.parseExtensionHeader(extensionsAgreed, extHeader);\n                }\n            }\n\n            // Build the transformations\n            TransformationFactory factory = TransformationFactory.getInstance();\n            for (Extension extension : extensionsAgreed) {\n                List<List<Extension.Parameter>> wrapper = new ArrayList<>(1);\n                wrapper.add(extension.getParameters());\n                Transformation t = factory.create(extension.getName(), wrapper, false);\n                if (t == null) {\n                    throw new DeploymentException(sm.getString(\n                            \"wsWebSocketContainer.invalidExtensionParameters\"));\n                }\n                if (transformation == null) {\n                    transformation = t;\n                } else {\n                    transformation.setNext(t);\n                }\n            }\n\n            success = true;\n        } catch (ExecutionException | InterruptedException | SSLException |\n                EOFException | TimeoutException | URISyntaxException | AuthenticationException e) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.httpRequestFailed\"), e);\n        } finally {\n            if (!success) {\n                channel.close();\n            }\n        }\n\n        // Switch to WebSocket\n        WsRemoteEndpointImplClient wsRemoteEndpointClient = new WsRemoteEndpointImplClient(channel);\n\n        WsSession wsSession = new WsSession(endpoint, wsRemoteEndpointClient,\n                this, null, null, null, null, null, extensionsAgreed,\n                subProtocol, Collections.<String,String>emptyMap(), secure,\n                clientEndpointConfiguration);\n\n        WsFrameClient wsFrameClient = new WsFrameClient(response, channel,\n                wsSession, transformation);\n        // WsFrame adds the necessary final transformations. Copy the\n        // completed transformation chain to the remote end point.\n        wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());\n\n        endpoint.onOpen(wsSession, clientEndpointConfiguration);\n        registerSession(endpoint, wsSession);\n\n        /* It is possible that the server sent one or more messages as soon as\n         * the WebSocket connection was established. Depending on the exact\n         * timing of when those messages were sent they could be sat in the\n         * input buffer waiting to be read and will not trigger a \"data\n         * available to read\" event. Therefore, it is necessary to process the\n         * input buffer here. Note that this happens on the current thread which\n         * means that this thread will be used for any onMessage notifications.\n         * This is a special case. Subsequent \"data available to read\" events\n         * will be handled by threads from the AsyncChannelGroup's executor.\n         */\n        wsFrameClient.startInputProcessing();\n\n        return wsSession;\n    }", "code_tokens": ["private", "Session", "connectToServerRecursive", "(", "Endpoint", "endpoint", ",", "ClientEndpointConfig", "clientEndpointConfiguration", ",", "URI", "path", ",", "Set", "<", "URI", ">", "redirectSet", ")", "throws", "DeploymentException", "{", "boolean", "secure", "=", "false", ";", "ByteBuffer", "proxyConnect", "=", "null", ";", "URI", "proxyPath", ";", "String", "scheme", "=", "path", ".", "getScheme", "(", ")", ";", "if", "(", "\"", "ws", "\"", ".", "equalsIgnoreCase", "(", "scheme", ")", ")", "{", "proxyPath", "=", "URI", ".", "create", "(", "\"", "http", "\"", "+", "path", ".", "toString", "(", ")", ".", "substring", "(", "2", ")", ")", ";", "}", "else", "if", "(", "\"", "wss", "\"", ".", "equalsIgnoreCase", "(", "scheme", ")", ")", "{", "proxyPath", "=", "URI", ".", "create", "(", "\"", "https", "\"", "+", "path", ".", "toString", "(", ")", ".", "substring", "(", "3", ")", ")", ";", "secure", "=", "true", ";", "}", "else", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.pathWrongScheme", "\"", ",", "scheme", ")", ")", ";", "}", "String", "host", "=", "path", ".", "getHost", "(", ")", ";", "if", "(", "host", "==", "null", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.pathNoHost", "\"", ")", ")", ";", "}", "int", "port", "=", "path", ".", "getPort", "(", ")", ";", "SocketAddress", "sa", "=", "null", ";", "List", "<", "Proxy", ">", "proxies", "=", "ProxySelector", ".", "getDefault", "(", ")", ".", "select", "(", "proxyPath", ")", ";", "Proxy", "selectedProxy", "=", "null", ";", "for", "(", "Proxy", "proxy", ":", "proxies", ")", "{", "if", "(", "proxy", ".", "type", "(", ")", ".", "equals", "(", "Proxy", ".", "Type", ".", "HTTP", ")", ")", "{", "sa", "=", "proxy", ".", "address", "(", ")", ";", "if", "(", "sa", "instanceof", "InetSocketAddress", ")", "{", "InetSocketAddress", "inet", "=", "(", "InetSocketAddress", ")", "sa", ";", "if", "(", "inet", ".", "isUnresolved", "(", ")", ")", "{", "sa", "=", "new", "InetSocketAddress", "(", "inet", ".", "getHostName", "(", ")", ",", "inet", ".", "getPort", "(", ")", ")", ";", "}", "}", "selectedProxy", "=", "proxy", ";", "break", ";", "}", "}", "if", "(", "port", "==", "-", "1", ")", "{", "if", "(", "\"", "ws", "\"", ".", "equalsIgnoreCase", "(", "scheme", ")", ")", "{", "port", "=", "80", ";", "}", "else", "{", "port", "=", "443", ";", "}", "}", "if", "(", "sa", "==", "null", ")", "{", "sa", "=", "new", "InetSocketAddress", "(", "host", ",", "port", ")", ";", "}", "else", "{", "proxyConnect", "=", "createProxyRequest", "(", "host", ",", "port", ")", ";", "}", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "reqHeaders", "=", "createRequestHeaders", "(", "host", ",", "port", ",", "clientEndpointConfiguration", ")", ";", "clientEndpointConfiguration", ".", "getConfigurator", "(", ")", ".", "beforeRequest", "(", "reqHeaders", ")", ";", "if", "(", "Constants", ".", "DEFAULT_ORIGIN_HEADER_VALUE", "!=", "null", "&&", "!", "reqHeaders", ".", "containsKey", "(", "Constants", ".", "ORIGIN_HEADER_NAME", ")", ")", "{", "List", "<", "String", ">", "originValues", "=", "new", "ArrayList", "<", ">", "(", "1", ")", ";", "originValues", ".", "add", "(", "Constants", ".", "DEFAULT_ORIGIN_HEADER_VALUE", ")", ";", "reqHeaders", ".", "put", "(", "Constants", ".", "ORIGIN_HEADER_NAME", ",", "originValues", ")", ";", "}", "ByteBuffer", "request", "=", "createRequest", "(", "path", ",", "reqHeaders", ")", ";", "AsynchronousSocketChannel", "socketChannel", ";", "try", "{", "socketChannel", "=", "AsynchronousSocketChannel", ".", "open", "(", "getAsynchronousChannelGroup", "(", ")", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.asynchronousSocketChannelFail", "\"", ")", ",", "ioe", ")", ";", "}", "Map", "<", "String", ",", "Object", ">", "userProperties", "=", "clientEndpointConfiguration", ".", "getUserProperties", "(", ")", ";", "long", "timeout", "=", "Constants", ".", "IO_TIMEOUT_MS_DEFAULT", ";", "String", "timeoutValue", "=", "(", "String", ")", "userProperties", ".", "get", "(", "Constants", ".", "IO_TIMEOUT_MS_PROPERTY", ")", ";", "if", "(", "timeoutValue", "!=", "null", ")", "{", "timeout", "=", "Long", ".", "valueOf", "(", "timeoutValue", ")", ".", "intValue", "(", ")", ";", "}", "ByteBuffer", "response", "=", "ByteBuffer", ".", "allocate", "(", "getDefaultMaxBinaryMessageBufferSize", "(", ")", ")", ";", "String", "subProtocol", ";", "boolean", "success", "=", "false", ";", "List", "<", "Extension", ">", "extensionsAgreed", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Transformation", "transformation", "=", "null", ";", "Future", "<", "Void", ">", "fConnect", "=", "socketChannel", ".", "connect", "(", "sa", ")", ";", "AsyncChannelWrapper", "channel", "=", "null", ";", "if", "(", "proxyConnect", "!=", "null", ")", "{", "try", "{", "fConnect", ".", "get", "(", "timeout", ",", "TimeUnit", ".", "MILLISECONDS", ")", ";", "channel", "=", "new", "AsyncChannelWrapperNonSecure", "(", "socketChannel", ")", ";", "writeRequest", "(", "channel", ",", "proxyConnect", ",", "timeout", ")", ";", "HttpResponse", "httpResponse", "=", "processResponse", "(", "response", ",", "channel", ",", "timeout", ")", ";", "if", "(", "httpResponse", ".", "getStatus", "(", ")", "!=", "200", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.proxyConnectFail", "\"", ",", "selectedProxy", ",", "Integer", ".", "toString", "(", "httpResponse", ".", "getStatus", "(", ")", ")", ")", ")", ";", "}", "}", "catch", "(", "TimeoutException", "|", "InterruptedException", "|", "ExecutionException", "|", "EOFException", "e", ")", "{", "if", "(", "channel", "!=", "null", ")", "{", "channel", ".", "close", "(", ")", ";", "}", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.httpRequestFailed", "\"", ")", ",", "e", ")", ";", "}", "}", "if", "(", "secure", ")", "{", "SSLEngine", "sslEngine", "=", "createSSLEngine", "(", "userProperties", ",", "host", ",", "port", ")", ";", "channel", "=", "new", "AsyncChannelWrapperSecure", "(", "socketChannel", ",", "sslEngine", ")", ";", "}", "else", "if", "(", "channel", "==", "null", ")", "{", "channel", "=", "new", "AsyncChannelWrapperNonSecure", "(", "socketChannel", ")", ";", "}", "try", "{", "fConnect", ".", "get", "(", "timeout", ",", "TimeUnit", ".", "MILLISECONDS", ")", ";", "Future", "<", "Void", ">", "fHandshake", "=", "channel", ".", "handshake", "(", ")", ";", "fHandshake", ".", "get", "(", "timeout", ",", "TimeUnit", ".", "MILLISECONDS", ")", ";", "writeRequest", "(", "channel", ",", "request", ",", "timeout", ")", ";", "HttpResponse", "httpResponse", "=", "processResponse", "(", "response", ",", "channel", ",", "timeout", ")", ";", "int", "maxRedirects", "=", "Constants", ".", "MAX_REDIRECTIONS_DEFAULT", ";", "String", "maxRedirectsValue", "=", "(", "String", ")", "userProperties", ".", "get", "(", "Constants", ".", "MAX_REDIRECTIONS_PROPERTY", ")", ";", "if", "(", "maxRedirectsValue", "!=", "null", ")", "{", "maxRedirects", "=", "Integer", ".", "parseInt", "(", "maxRedirectsValue", ")", ";", "}", "if", "(", "httpResponse", ".", "status", "!=", "101", ")", "{", "if", "(", "isRedirectStatus", "(", "httpResponse", ".", "status", ")", ")", "{", "List", "<", "String", ">", "locationHeader", "=", "httpResponse", ".", "getHandshakeResponse", "(", ")", ".", "getHeaders", "(", ")", ".", "get", "(", "Constants", ".", "LOCATION_HEADER_NAME", ")", ";", "if", "(", "locationHeader", "==", "null", "||", "locationHeader", ".", "isEmpty", "(", ")", "||", "locationHeader", ".", "get", "(", "0", ")", "==", "null", "||", "locationHeader", ".", "get", "(", "0", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.missingLocationHeader", "\"", ",", "Integer", ".", "toString", "(", "httpResponse", ".", "status", ")", ")", ")", ";", "}", "URI", "redirectLocation", "=", "URI", ".", "create", "(", "locationHeader", ".", "get", "(", "0", ")", ")", ".", "normalize", "(", ")", ";", "if", "(", "!", "redirectLocation", ".", "isAbsolute", "(", ")", ")", "{", "redirectLocation", "=", "path", ".", "resolve", "(", "redirectLocation", ")", ";", "}", "String", "redirectScheme", "=", "redirectLocation", ".", "getScheme", "(", ")", ".", "toLowerCase", "(", ")", ";", "if", "(", "redirectScheme", ".", "startsWith", "(", "\"", "http", "\"", ")", ")", "{", "redirectLocation", "=", "new", "URI", "(", "redirectScheme", ".", "replace", "(", "\"", "http", "\"", ",", "\"", "ws", "\"", ")", ",", "redirectLocation", ".", "getUserInfo", "(", ")", ",", "redirectLocation", ".", "getHost", "(", ")", ",", "redirectLocation", ".", "getPort", "(", ")", ",", "redirectLocation", ".", "getPath", "(", ")", ",", "redirectLocation", ".", "getQuery", "(", ")", ",", "redirectLocation", ".", "getFragment", "(", ")", ")", ";", "}", "if", "(", "!", "redirectSet", ".", "add", "(", "redirectLocation", ")", "||", "redirectSet", ".", "size", "(", ")", ">", "maxRedirects", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.redirectThreshold", "\"", ",", "redirectLocation", ",", "Integer", ".", "toString", "(", "redirectSet", ".", "size", "(", ")", ")", ",", "Integer", ".", "toString", "(", "maxRedirects", ")", ")", ")", ";", "}", "return", "connectToServerRecursive", "(", "endpoint", ",", "clientEndpointConfiguration", ",", "redirectLocation", ",", "redirectSet", ")", ";", "}", "else", "if", "(", "httpResponse", ".", "status", "==", "401", ")", "{", "if", "(", "userProperties", ".", "get", "(", "Constants", ".", "AUTHORIZATION_HEADER_NAME", ")", "!=", "null", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.failedAuthentication", "\"", ",", "Integer", ".", "valueOf", "(", "httpResponse", ".", "status", ")", ")", ")", ";", "}", "List", "<", "String", ">", "wwwAuthenticateHeaders", "=", "httpResponse", ".", "getHandshakeResponse", "(", ")", ".", "getHeaders", "(", ")", ".", "get", "(", "Constants", ".", "WWW_AUTHENTICATE_HEADER_NAME", ")", ";", "if", "(", "wwwAuthenticateHeaders", "==", "null", "||", "wwwAuthenticateHeaders", ".", "isEmpty", "(", ")", "||", "wwwAuthenticateHeaders", ".", "get", "(", "0", ")", "==", "null", "||", "wwwAuthenticateHeaders", ".", "get", "(", "0", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.missingWWWAuthenticateHeader", "\"", ",", "Integer", ".", "toString", "(", "httpResponse", ".", "status", ")", ")", ")", ";", "}", "String", "authScheme", "=", "wwwAuthenticateHeaders", ".", "get", "(", "0", ")", ".", "split", "(", "\"", "\\\\", "s+", "\"", ",", "2", ")", "[", "0", "]", ";", "String", "requestUri", "=", "new", "String", "(", "request", ".", "array", "(", ")", ",", "StandardCharsets", ".", "ISO_8859_1", ")", ".", "split", "(", "\"", "\\\\", "s", "\"", ",", "3", ")", "[", "1", "]", ";", "Authenticator", "auth", "=", "AuthenticatorFactory", ".", "getAuthenticator", "(", "authScheme", ")", ";", "if", "(", "auth", "==", "null", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.unsupportedAuthScheme", "\"", ",", "Integer", ".", "valueOf", "(", "httpResponse", ".", "status", ")", ",", "authScheme", ")", ")", ";", "}", "userProperties", ".", "put", "(", "Constants", ".", "AUTHORIZATION_HEADER_NAME", ",", "auth", ".", "getAuthorization", "(", "requestUri", ",", "wwwAuthenticateHeaders", ".", "get", "(", "0", ")", ",", "userProperties", ")", ")", ";", "return", "connectToServerRecursive", "(", "endpoint", ",", "clientEndpointConfiguration", ",", "path", ",", "redirectSet", ")", ";", "}", "else", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.invalidStatus", "\"", ",", "Integer", ".", "toString", "(", "httpResponse", ".", "status", ")", ")", ")", ";", "}", "}", "HandshakeResponse", "handshakeResponse", "=", "httpResponse", ".", "getHandshakeResponse", "(", ")", ";", "clientEndpointConfiguration", ".", "getConfigurator", "(", ")", ".", "afterResponse", "(", "handshakeResponse", ")", ";", "List", "<", "String", ">", "protocolHeaders", "=", "handshakeResponse", ".", "getHeaders", "(", ")", ".", "get", "(", "Constants", ".", "WS_PROTOCOL_HEADER_NAME", ")", ";", "if", "(", "protocolHeaders", "==", "null", "||", "protocolHeaders", ".", "size", "(", ")", "==", "0", ")", "{", "subProtocol", "=", "null", ";", "}", "else", "if", "(", "protocolHeaders", ".", "size", "(", ")", "==", "1", ")", "{", "subProtocol", "=", "protocolHeaders", ".", "get", "(", "0", ")", ";", "}", "else", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.invalidSubProtocol", "\"", ")", ")", ";", "}", "List", "<", "String", ">", "extHeaders", "=", "handshakeResponse", ".", "getHeaders", "(", ")", ".", "get", "(", "Constants", ".", "WS_EXTENSIONS_HEADER_NAME", ")", ";", "if", "(", "extHeaders", "!=", "null", ")", "{", "for", "(", "String", "extHeader", ":", "extHeaders", ")", "{", "Util", ".", "parseExtensionHeader", "(", "extensionsAgreed", ",", "extHeader", ")", ";", "}", "}", "TransformationFactory", "factory", "=", "TransformationFactory", ".", "getInstance", "(", ")", ";", "for", "(", "Extension", "extension", ":", "extensionsAgreed", ")", "{", "List", "<", "List", "<", "Extension", ".", "Parameter", ">", ">", "wrapper", "=", "new", "ArrayList", "<", ">", "(", "1", ")", ";", "wrapper", ".", "add", "(", "extension", ".", "getParameters", "(", ")", ")", ";", "Transformation", "t", "=", "factory", ".", "create", "(", "extension", ".", "getName", "(", ")", ",", "wrapper", ",", "false", ")", ";", "if", "(", "t", "==", "null", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.invalidExtensionParameters", "\"", ")", ")", ";", "}", "if", "(", "transformation", "==", "null", ")", "{", "transformation", "=", "t", ";", "}", "else", "{", "transformation", ".", "setNext", "(", "t", ")", ";", "}", "}", "success", "=", "true", ";", "}", "catch", "(", "ExecutionException", "|", "InterruptedException", "|", "SSLException", "|", "EOFException", "|", "TimeoutException", "|", "URISyntaxException", "|", "AuthenticationException", "e", ")", "{", "throw", "new", "DeploymentException", "(", "sm", ".", "getString", "(", "\"", "wsWebSocketContainer.httpRequestFailed", "\"", ")", ",", "e", ")", ";", "}", "finally", "{", "if", "(", "!", "success", ")", "{", "channel", ".", "close", "(", ")", ";", "}", "}", "WsRemoteEndpointImplClient", "wsRemoteEndpointClient", "=", "new", "WsRemoteEndpointImplClient", "(", "channel", ")", ";", "WsSession", "wsSession", "=", "new", "WsSession", "(", "endpoint", ",", "wsRemoteEndpointClient", ",", "this", ",", "null", ",", "null", ",", "null", ",", "null", ",", "null", ",", "extensionsAgreed", ",", "subProtocol", ",", "Collections", ".", "<", "String", ",", "String", ">", "emptyMap", "(", ")", ",", "secure", ",", "clientEndpointConfiguration", ")", ";", "WsFrameClient", "wsFrameClient", "=", "new", "WsFrameClient", "(", "response", ",", "channel", ",", "wsSession", ",", "transformation", ")", ";", "wsRemoteEndpointClient", ".", "setTransformation", "(", "wsFrameClient", ".", "getTransformation", "(", ")", ")", ";", "endpoint", ".", "onOpen", "(", "wsSession", ",", "clientEndpointConfiguration", ")", ";", "registerSession", "(", "endpoint", ",", "wsSession", ")", ";", "wsFrameClient", ".", "startInputProcessing", "(", ")", ";", "return", "wsSession", ";", "}"], "idx": 40074, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "2835bb4e030c1c741ed0847bb3b9c3822e4fbc8a", "function_name": "connectToServerRecursive", "body_hash": "88db9a5e604ef26bb549c2bd992c293a93e1fb4a"}
{"code": "@RequestMapping(value=\"/change_password.do\", method = POST)\n    public String changePassword(\n            Model model,\n            @RequestParam(\"current_password\") String currentPassword,\n            @RequestParam(\"new_password\") String newPassword,\n            @RequestParam(\"confirm_password\") String confirmPassword,\n            HttpServletResponse response,\n            HttpServletRequest request) {\n\n        PasswordConfirmationValidation validation = new PasswordConfirmationValidation(newPassword, confirmPassword);\n        if (!validation.valid()) {\n            model.addAttribute(\"message_code\", validation.getMessageCode());\n            response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());\n            return \"change_password\";\n        }\n\n        SecurityContext securityContext = SecurityContextHolder.getContext();\n        Authentication authentication = securityContext.getAuthentication();\n        String username = authentication.getName();\n\n        try {\n            changePasswordService.changePassword(username, currentPassword, newPassword);\n            request.getSession().invalidate();\n            request.getSession(true);\n            if (authentication instanceof UaaAuthentication) {\n                UaaAuthentication uaaAuthentication = (UaaAuthentication)authentication;\n                authentication = new UaaAuthentication(\n                    uaaAuthentication.getPrincipal(),\n                    new LinkedList<>(uaaAuthentication.getAuthorities()),\n                    new UaaAuthenticationDetails(request)\n                );\n            }\n            securityContext.setAuthentication(authentication);\n            return \"redirect:profile\";\n        } catch (BadCredentialsException e) {\n            model.addAttribute(\"message_code\", \"unauthorized\");\n        } catch (InvalidPasswordException e) {\n            model.addAttribute(\"message\", e.getMessagesAsOneString());\n        }\n        response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());\n        return \"change_password\";\n    }", "code_tokens": ["@", "RequestMapping", "(", "value", "=", "\"", "/change_password.do", "\"", ",", "method", "=", "POST", ")", "public", "String", "changePassword", "(", "Model", "model", ",", "@", "RequestParam", "(", "\"", "current_password", "\"", ")", "String", "currentPassword", ",", "@", "RequestParam", "(", "\"", "new_password", "\"", ")", "String", "newPassword", ",", "@", "RequestParam", "(", "\"", "confirm_password", "\"", ")", "String", "confirmPassword", ",", "HttpServletResponse", "response", ",", "HttpServletRequest", "request", ")", "{", "PasswordConfirmationValidation", "validation", "=", "new", "PasswordConfirmationValidation", "(", "newPassword", ",", "confirmPassword", ")", ";", "if", "(", "!", "validation", ".", "valid", "(", ")", ")", "{", "model", ".", "addAttribute", "(", "\"", "message_code", "\"", ",", "validation", ".", "getMessageCode", "(", ")", ")", ";", "response", ".", "setStatus", "(", "HttpStatus", ".", "UNPROCESSABLE_ENTITY", ".", "value", "(", ")", ")", ";", "return", "\"", "change_password", "\"", ";", "}", "SecurityContext", "securityContext", "=", "SecurityContextHolder", ".", "getContext", "(", ")", ";", "Authentication", "authentication", "=", "securityContext", ".", "getAuthentication", "(", ")", ";", "String", "username", "=", "authentication", ".", "getName", "(", ")", ";", "try", "{", "changePasswordService", ".", "changePassword", "(", "username", ",", "currentPassword", ",", "newPassword", ")", ";", "request", ".", "getSession", "(", ")", ".", "invalidate", "(", ")", ";", "request", ".", "getSession", "(", "true", ")", ";", "if", "(", "authentication", "instanceof", "UaaAuthentication", ")", "{", "UaaAuthentication", "uaaAuthentication", "=", "(", "UaaAuthentication", ")", "authentication", ";", "authentication", "=", "new", "UaaAuthentication", "(", "uaaAuthentication", ".", "getPrincipal", "(", ")", ",", "new", "LinkedList", "<", ">", "(", "uaaAuthentication", ".", "getAuthorities", "(", ")", ")", ",", "new", "UaaAuthenticationDetails", "(", "request", ")", ")", ";", "}", "securityContext", ".", "setAuthentication", "(", "authentication", ")", ";", "return", "\"", "redirect:profile", "\"", ";", "}", "catch", "(", "BadCredentialsException", "e", ")", "{", "model", ".", "addAttribute", "(", "\"", "message_code", "\"", ",", "\"", "unauthorized", "\"", ")", ";", "}", "catch", "(", "InvalidPasswordException", "e", ")", "{", "model", ".", "addAttribute", "(", "\"", "message", "\"", ",", "e", ".", "getMessagesAsOneString", "(", ")", ")", ";", "}", "response", ".", "setStatus", "(", "HttpStatus", ".", "UNPROCESSABLE_ENTITY", ".", "value", "(", ")", ")", ";", "return", "\"", "change_password", "\"", ";", "}"], "idx": 70898, "cwe": "CWE-613", "target": 0, "status": "FIXED", "commit": "9730cd6a3bbb481ee4e400b51952b537589c469d", "function_name": "changePassword", "body_hash": "29e23b3023de2ac55bf038c53406af0db0ac2ac4"}
{"code": "@Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T fromString(String content, Class<T> classOfT) {\n        try (StringReader reader = new StringReader(content)) {\n            JAXBContext jaxbContext = JAXBContext.newInstance(classOfT);\n            Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();\n\n            return (T) jaxbUnmarshaller.unmarshal(reader);\n        } catch (JAXBException e) {\n            throw new PippoRuntimeException(e, \"Failed to deserialize content to '{}'\", classOfT.getName());\n        }\n    }", "code_tokens": ["@", "Override", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "public", "<", "T", ">", "T", "fromString", "(", "String", "content", ",", "Class", "<", "T", ">", "classOfT", ")", "{", "try", "(", "StringReader", "reader", "=", "new", "StringReader", "(", "content", ")", ")", "{", "JAXBContext", "jaxbContext", "=", "JAXBContext", ".", "newInstance", "(", "classOfT", ")", ";", "Unmarshaller", "jaxbUnmarshaller", "=", "jaxbContext", ".", "createUnmarshaller", "(", ")", ";", "return", "(", "T", ")", "jaxbUnmarshaller", ".", "unmarshal", "(", "reader", ")", ";", "}", "catch", "(", "JAXBException", "e", ")", "{", "throw", "new", "PippoRuntimeException", "(", "e", ",", "\"", "Failed to deserialize content to '{}'", "\"", ",", "classOfT", ".", "getName", "(", ")", ")", ";", "}", "}"], "idx": 68625, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "9f36e5891c0b11f840e1e1561ae96d83ba9ce759", "function_name": "fromString", "body_hash": "36cebd17f56bcd3e50b751a96d45b7ac35544f73"}
{"code": "public static String migrate(String xml) {\n\t\tDocument xmlDoc;\n\t\ttry {\n\t\t\tSAXReader reader = new SAXReader();\n\t\t\t// Prevent XXE attack as the xml might be provided by malicious users\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\txmlDoc = reader.read(new StringReader(xml));\n\t\t} catch (DocumentException | SAXException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t\tList<NodeTuple> tuples = new ArrayList<>();\n\t\tNode keyNode = new ScalarNode(Tag.STR, \"version\");\n\t\tNode valueNode = new ScalarNode(Tag.INT, \"0\");\n\t\ttuples.add(new NodeTuple(keyNode, valueNode));\n\t\t\n\t\tList<Node> jobNodes = new ArrayList<>();\n\t\tfor (Element jobElement: xmlDoc.getRootElement().element(\"jobs\").elements()) \n\t\t\tjobNodes.add(migrateJob(jobElement));\n\t\t\n\t\tif (!jobNodes.isEmpty()) {\n\t\t\tkeyNode = new ScalarNode(Tag.STR, \"jobs\");\n\t\t\ttuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, jobNodes, FlowStyle.BLOCK)));\n\t\t}\n\t\t\n\t\tList<Node> propertyNodes = new ArrayList<>();\n\t\tElement propertiesElement = xmlDoc.getRootElement().element(\"properties\");\n\t\tif (propertiesElement != null) {\n\t\t\tfor (Element propertyElement: propertiesElement.elements()) {\n\t\t\t\tNode nameNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"name\").trim());\n\t\t\t\tvalueNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"value\").trim());\n\t\t\t\tList<NodeTuple> propertyTuples = Lists.newArrayList(\n\t\t\t\t\t\tnew NodeTuple(new ScalarNode(Tag.STR, \"name\"), nameNode), \n\t\t\t\t\t\tnew NodeTuple(new ScalarNode(Tag.STR, \"value\"), valueNode));\n\t\t\t\tpropertyNodes.add(new MappingNode(Tag.MAP, propertyTuples, FlowStyle.BLOCK));\n\t\t\t}\n\t\t}\n\t\tif(!propertyNodes.isEmpty()) {\n\t\t\tkeyNode = new ScalarNode(Tag.STR, \"properties\");\n\t\t\ttuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, propertyNodes, FlowStyle.BLOCK)));\n\t\t}\n\t\t\n\t\tMappingNode rootNode = new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);\n\t\tStringWriter writer = new StringWriter();\n\t\tDumperOptions dumperOptions = new DumperOptions();\n\t\tSerializer serializer = new Serializer(new Emitter(writer, dumperOptions), \n\t\t\t\tnew Resolver(), dumperOptions, Tag.MAP);\n\t\ttry {\n\t\t\tserializer.open();\n\t\t\tserializer.serialize(rootNode);\n\t\t\tserializer.close();\n\t\t\treturn writer.toString();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t}", "code_tokens": ["public", "static", "String", "migrate", "(", "String", "xml", ")", "{", "Document", "xmlDoc", ";", "try", "{", "SAXReader", "reader", "=", "new", "SAXReader", "(", ")", ";", "reader", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "xmlDoc", "=", "reader", ".", "read", "(", "new", "StringReader", "(", "xml", ")", ")", ";", "}", "catch", "(", "DocumentException", "|", "SAXException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "List", "<", "NodeTuple", ">", "tuples", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Node", "keyNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "version", "\"", ")", ";", "Node", "valueNode", "=", "new", "ScalarNode", "(", "Tag", ".", "INT", ",", "\"", "0", "\"", ")", ";", "tuples", ".", "add", "(", "new", "NodeTuple", "(", "keyNode", ",", "valueNode", ")", ")", ";", "List", "<", "Node", ">", "jobNodes", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "for", "(", "Element", "jobElement", ":", "xmlDoc", ".", "getRootElement", "(", ")", ".", "element", "(", "\"", "jobs", "\"", ")", ".", "elements", "(", ")", ")", "jobNodes", ".", "add", "(", "migrateJob", "(", "jobElement", ")", ")", ";", "if", "(", "!", "jobNodes", ".", "isEmpty", "(", ")", ")", "{", "keyNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "jobs", "\"", ")", ";", "tuples", ".", "add", "(", "new", "NodeTuple", "(", "keyNode", ",", "new", "SequenceNode", "(", "Tag", ".", "SEQ", ",", "jobNodes", ",", "FlowStyle", ".", "BLOCK", ")", ")", ")", ";", "}", "List", "<", "Node", ">", "propertyNodes", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Element", "propertiesElement", "=", "xmlDoc", ".", "getRootElement", "(", ")", ".", "element", "(", "\"", "properties", "\"", ")", ";", "if", "(", "propertiesElement", "!=", "null", ")", "{", "for", "(", "Element", "propertyElement", ":", "propertiesElement", ".", "elements", "(", ")", ")", "{", "Node", "nameNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "propertyElement", ".", "elementText", "(", "\"", "name", "\"", ")", ".", "trim", "(", ")", ")", ";", "valueNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "propertyElement", ".", "elementText", "(", "\"", "value", "\"", ")", ".", "trim", "(", ")", ")", ";", "List", "<", "NodeTuple", ">", "propertyTuples", "=", "Lists", ".", "newArrayList", "(", "new", "NodeTuple", "(", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "name", "\"", ")", ",", "nameNode", ")", ",", "new", "NodeTuple", "(", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "value", "\"", ")", ",", "valueNode", ")", ")", ";", "propertyNodes", ".", "add", "(", "new", "MappingNode", "(", "Tag", ".", "MAP", ",", "propertyTuples", ",", "FlowStyle", ".", "BLOCK", ")", ")", ";", "}", "}", "if", "(", "!", "propertyNodes", ".", "isEmpty", "(", ")", ")", "{", "keyNode", "=", "new", "ScalarNode", "(", "Tag", ".", "STR", ",", "\"", "properties", "\"", ")", ";", "tuples", ".", "add", "(", "new", "NodeTuple", "(", "keyNode", ",", "new", "SequenceNode", "(", "Tag", ".", "SEQ", ",", "propertyNodes", ",", "FlowStyle", ".", "BLOCK", ")", ")", ")", ";", "}", "MappingNode", "rootNode", "=", "new", "MappingNode", "(", "Tag", ".", "MAP", ",", "tuples", ",", "FlowStyle", ".", "BLOCK", ")", ";", "StringWriter", "writer", "=", "new", "StringWriter", "(", ")", ";", "DumperOptions", "dumperOptions", "=", "new", "DumperOptions", "(", ")", ";", "Serializer", "serializer", "=", "new", "Serializer", "(", "new", "Emitter", "(", "writer", ",", "dumperOptions", ")", ",", "new", "Resolver", "(", ")", ",", "dumperOptions", ",", "Tag", ".", "MAP", ")", ";", "try", "{", "serializer", ".", "open", "(", ")", ";", "serializer", ".", "serialize", "(", "rootNode", ")", ";", "serializer", ".", "close", "(", ")", ";", "return", "writer", ".", "toString", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}"], "idx": 64236, "cwe": "CWE-538", "target": 0, "status": "FIXED", "commit": "9196fd795e87dab069b4260a3590a0ea886e770f", "function_name": "migrate", "body_hash": "38a6050ea30b0649dc55e736bf30bc725a7422a5"}
{"code": "public void handleMessage(Message message) throws Fault {\n        if (isServerGet(message)) {\n            return;\n        }\n        prepareMessage(message);\n        message.getInterceptorChain().add(\n              new StaxActionInInterceptor(requireSignature, requireEncryption));\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "throws", "Fault", "{", "if", "(", "isServerGet", "(", "message", ")", ")", "{", "return", ";", "}", "prepareMessage", "(", "message", ")", ";", "message", ".", "getInterceptorChain", "(", ")", ".", "add", "(", "new", "StaxActionInInterceptor", "(", "requireSignature", ",", "requireEncryption", ")", ")", ";", "}"], "idx": 40420, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "fade9b81dabe27f864ca38e7b40f28fb44d6f165", "function_name": "handleMessage", "body_hash": "2f58fb6a8ade18f801c11b53ff88681a18281a3c"}
{"code": "private void prepareRequest() throws IOException {\n\n        contentDelimitation = false;\n\n        if (protocol.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        Pattern restrictedUserAgents = protocol.getRestrictedUserAgentsPattern();\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        // HTTP specs say an HTTP 1.1 server should accept any recognised\n        // HTTP 1.x header from a 1.x client unless the specs says otherwise.\n        if (!http09) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    // Invalid transfer encoding\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n                }\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n                keepAlive = false;\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "contentDelimitation", "=", "false", ";", "if", "(", "protocol", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEP_ALIVE_HEADER_VALUE_TOKEN", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "inputBuffer", ".", "setSwallowInput", "(", "false", ")", ";", "request", ".", "setExpectation", "(", "true", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "Pattern", "restrictedUserAgents", "=", "protocol", ".", "getRestrictedUserAgentsPattern", "(", ")", ";", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "(", "http11", "||", "keepAlive", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "protocol", ".", "getAllowHostHeaderMismatch", "(", ")", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "inputBuffer", ".", "getFilters", "(", ")", ";", "if", "(", "!", "http09", ")", "{", "MessageBytes", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ")", "{", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidTransferEncoding", "\"", ")", ";", "}", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 54415, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "05f9e8b00f5d9251fcd3c95dcfd6cf84177f46c8", "function_name": "prepareRequest", "body_hash": "2778340c4bb863d09996f12e1b3316c2da260e7d"}
{"code": "protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)\n    {\n        int iterations = getNumberOfIterations(bitlength, param.getCertainty());\n\n        for (int i = 0; i != 5 * bitlength; i++)\n        {\n            BigInteger p = new BigInteger(bitlength, 1, param.getRandom());\n\n            if (p.mod(e).equals(ONE))\n            {\n                continue;\n            }\n\n            if (p.multiply(p).compareTo(sqrdBound) < 0)\n            {\n                continue;\n            }\n\n            if (!isProbablePrime(p, iterations))\n            {\n                continue;\n            }\n\n            if (!e.gcd(p.subtract(ONE)).equals(ONE))\n            {\n                continue;\n            }\n\n            return p;\n        }\n\n        throw new IllegalStateException(\"unable to generate prime number for RSA key\");\n    }", "code_tokens": ["protected", "BigInteger", "chooseRandomPrime", "(", "int", "bitlength", ",", "BigInteger", "e", ",", "BigInteger", "sqrdBound", ")", "{", "int", "iterations", "=", "getNumberOfIterations", "(", "bitlength", ",", "param", ".", "getCertainty", "(", ")", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "5", "*", "bitlength", ";", "i", "++", ")", "{", "BigInteger", "p", "=", "new", "BigInteger", "(", "bitlength", ",", "1", ",", "param", ".", "getRandom", "(", ")", ")", ";", "if", "(", "p", ".", "mod", "(", "e", ")", ".", "equals", "(", "ONE", ")", ")", "{", "continue", ";", "}", "if", "(", "p", ".", "multiply", "(", "p", ")", ".", "compareTo", "(", "sqrdBound", ")", "<", "0", ")", "{", "continue", ";", "}", "if", "(", "!", "isProbablePrime", "(", "p", ",", "iterations", ")", ")", "{", "continue", ";", "}", "if", "(", "!", "e", ".", "gcd", "(", "p", ".", "subtract", "(", "ONE", ")", ")", ".", "equals", "(", "ONE", ")", ")", "{", "continue", ";", "}", "return", "p", ";", "}", "throw", "new", "IllegalStateException", "(", "\"", "unable to generate prime number for RSA key", "\"", ")", ";", "}"], "idx": 42144, "cwe": "CWE-327", "target": 1, "status": "VULNERABLE", "commit": "22467b6e8fe19717ecdf201c0cf91bacf04a55ad", "function_name": "chooseRandomPrime", "body_hash": "78cb7e2940c08ebc863c4cac3ffc9e9a833ff53c"}
{"code": "public static DomainSocketAddress newSocketAddress() {\n        try {\n            File file;\n            do {\n                file = PlatformDependent.createTempFile(\"NETTY\", \"UDS\", null);\n                if (!file.delete()) {\n                    throw new IOException(\"failed to delete: \" + file);\n                }\n            } while (file.getAbsolutePath().length() > 128);\n            return new DomainSocketAddress(file);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }", "code_tokens": ["public", "static", "DomainSocketAddress", "newSocketAddress", "(", ")", "{", "try", "{", "File", "file", ";", "do", "{", "file", "=", "PlatformDependent", ".", "createTempFile", "(", "\"", "NETTY", "\"", ",", "\"", "UDS", "\"", ",", "null", ")", ";", "if", "(", "!", "file", ".", "delete", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "failed to delete: ", "\"", "+", "file", ")", ";", "}", "}", "while", "(", "file", ".", "getAbsolutePath", "(", ")", ".", "length", "(", ")", ">", "128", ")", ";", "return", "new", "DomainSocketAddress", "(", "file", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}"], "idx": 50050, "cwe": "CWE-378", "target": 0, "status": "FIXED", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "newSocketAddress", "body_hash": "d883409ea089a55d70f9c7f9e071bca3cdae85eb"}
{"code": "@VisibleForTesting\n  public static void setupJackson(Injector injector, final ObjectMapper mapper)\n  {\n    mapper.setInjectableValues(new GuiceInjectableValues(injector));\n    setupAnnotationIntrospector(mapper, new GuiceAnnotationIntrospector());\n  }", "code_tokens": ["@", "VisibleForTesting", "public", "static", "void", "setupJackson", "(", "Injector", "injector", ",", "final", "ObjectMapper", "mapper", ")", "{", "mapper", ".", "setInjectableValues", "(", "new", "GuiceInjectableValues", "(", "injector", ")", ")", ";", "setupAnnotationIntrospector", "(", "mapper", ",", "new", "GuiceAnnotationIntrospector", "(", ")", ")", ";", "}"], "idx": 98770, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "3f8f00a231c4b47981e0e2e48f18f1221249e6f3", "function_name": "setupJackson", "body_hash": "58a31b1035b863eb53d27beedc09791b998f08f1"}
{"code": "public void execute(ActionInvocation invocation) throws Exception {\r\n\t\tactionName = conditionalParse(actionName, invocation);\r\n\t\tparseLocation = false;\r\n\r\n\t\tString portletNamespace = (String)invocation.getInvocationContext().get(PortletConstants.PORTLET_NAMESPACE);\r\n\t\tif (portletMode != null) {\r\n\t\t\tMap<PortletMode, String> namespaceMap = getNamespaceMap(invocation);\r\n\t\t\tnamespace = namespaceMap.get(portletMode);\r\n\t\t}\r\n\t\tif (namespace == null) {\r\n\t\t\tnamespace = invocation.getProxy().getNamespace();\r\n\t\t} else {\r\n\t\t\tnamespace = conditionalParse(namespace, invocation);\r\n\t\t}\r\n\t\tif (method == null) {\r\n\t\t\tmethod = \"\";\r\n\t\t} else {\r\n\t\t\tmethod = conditionalParse(method, invocation);\r\n\t\t}\r\n\r\n\t\tString resultCode = invocation.getResultCode();\r\n\t\tif (resultCode != null) {\r\n\t\t\tResultConfig resultConfig = invocation.getProxy().getConfig().getResults().get(resultCode);\r\n\t\t\tMap<String, String> resultConfigParams = resultConfig.getParams();\r\n            for (Map.Entry<String, String> e : resultConfigParams.entrySet()) {\r\n                if (!prohibitedResultParam.contains(e.getKey())) {\r\n                    requestParameters.put(e.getKey(), e.getValue() == null ? \"\" : conditionalParse(e.getValue(), invocation));\r\n                }\r\n            }\r\n\t\t}\r\n\r\n\t\tStringBuilder tmpLocation = new StringBuilder(actionMapper.getUriFromActionMapping(new ActionMapping(actionName,\r\n\t\t\t\t(portletNamespace == null ? namespace : portletNamespace + namespace), method, null)));\r\n\t\turlHelper.buildParametersString(requestParameters, tmpLocation, \"&\");\r\n\r\n\t\tsetLocation(tmpLocation.toString());\r\n\r\n\t\tsuper.execute(invocation);\r\n\t}", "code_tokens": ["public", "void", "execute", "(", "ActionInvocation", "invocation", ")", "throws", "Exception", "{", "actionName", "=", "conditionalParse", "(", "actionName", ",", "invocation", ")", ";", "parseLocation", "=", "false", ";", "String", "portletNamespace", "=", "(", "String", ")", "invocation", ".", "getInvocationContext", "(", ")", ".", "get", "(", "PortletConstants", ".", "PORTLET_NAMESPACE", ")", ";", "if", "(", "portletMode", "!=", "null", ")", "{", "Map", "<", "PortletMode", ",", "String", ">", "namespaceMap", "=", "getNamespaceMap", "(", "invocation", ")", ";", "namespace", "=", "namespaceMap", ".", "get", "(", "portletMode", ")", ";", "}", "if", "(", "namespace", "==", "null", ")", "{", "namespace", "=", "invocation", ".", "getProxy", "(", ")", ".", "getNamespace", "(", ")", ";", "}", "else", "{", "namespace", "=", "conditionalParse", "(", "namespace", ",", "invocation", ")", ";", "}", "if", "(", "method", "==", "null", ")", "{", "method", "=", "\"", "\"", ";", "}", "else", "{", "method", "=", "conditionalParse", "(", "method", ",", "invocation", ")", ";", "}", "String", "resultCode", "=", "invocation", ".", "getResultCode", "(", ")", ";", "if", "(", "resultCode", "!=", "null", ")", "{", "ResultConfig", "resultConfig", "=", "invocation", ".", "getProxy", "(", ")", ".", "getConfig", "(", ")", ".", "getResults", "(", ")", ".", "get", "(", "resultCode", ")", ";", "Map", "<", "String", ",", "String", ">", "resultConfigParams", "=", "resultConfig", ".", "getParams", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "e", ":", "resultConfigParams", ".", "entrySet", "(", ")", ")", "{", "if", "(", "!", "prohibitedResultParam", ".", "contains", "(", "e", ".", "getKey", "(", ")", ")", ")", "{", "requestParameters", ".", "put", "(", "e", ".", "getKey", "(", ")", ",", "e", ".", "getValue", "(", ")", "==", "null", "?", "\"", "\"", ":", "conditionalParse", "(", "e", ".", "getValue", "(", ")", ",", "invocation", ")", ")", ";", "}", "}", "}", "StringBuilder", "tmpLocation", "=", "new", "StringBuilder", "(", "actionMapper", ".", "getUriFromActionMapping", "(", "new", "ActionMapping", "(", "actionName", ",", "(", "portletNamespace", "==", "null", "?", "namespace", ":", "portletNamespace", "+", "namespace", ")", ",", "method", ",", "null", ")", ")", ")", ";", "urlHelper", ".", "buildParametersString", "(", "requestParameters", ",", "tmpLocation", ",", "\"", "&", "\"", ")", ";", "setLocation", "(", "tmpLocation", ".", "toString", "(", ")", ")", ";", "super", ".", "execute", "(", "invocation", ")", ";", "}"], "idx": 10558, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "4a3917176de2df7f33a85511d067f31e50dcc1b", "function_name": "execute", "body_hash": "665b628c98f50799688c15a98fb3d9ec28c43012"}
{"code": "private static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n\n\t\tif (base.size() > 1000) {\n\t\t\tthrow new IllegalArgumentException(PARSE_DEPTH_EXCEEDED);\n\t\t}\n\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n\n\t\ttry {\n\n\t\t\tcurrent = new PropertyPath(source, type, base);\n\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n\n\t\t\tList<PropertyPath> newBase = new ArrayList<>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.actualTypeInformation, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}", "code_tokens": ["private", "static", "PropertyPath", "create", "(", "String", "source", ",", "TypeInformation", "<", "?", ">", "type", ",", "String", "addTail", ",", "List", "<", "PropertyPath", ">", "base", ")", "{", "if", "(", "base", ".", "size", "(", ")", ">", "1000", ")", "{", "throw", "new", "IllegalArgumentException", "(", "PARSE_DEPTH_EXCEEDED", ")", ";", "}", "PropertyReferenceException", "exception", "=", "null", ";", "PropertyPath", "current", "=", "null", ";", "try", "{", "current", "=", "new", "PropertyPath", "(", "source", ",", "type", ",", "base", ")", ";", "if", "(", "!", "base", ".", "isEmpty", "(", ")", ")", "{", "base", ".", "get", "(", "base", ".", "size", "(", ")", "-", "1", ")", ".", "next", "=", "current", ";", "}", "List", "<", "PropertyPath", ">", "newBase", "=", "new", "ArrayList", "<", ">", "(", "base", ")", ";", "newBase", ".", "add", "(", "current", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "addTail", ")", ")", "{", "current", ".", "next", "=", "create", "(", "addTail", ",", "current", ".", "actualTypeInformation", ",", "newBase", ")", ";", "}", "return", "current", ";", "}", "catch", "(", "PropertyReferenceException", "e", ")", "{", "if", "(", "current", "!=", "null", ")", "{", "throw", "e", ";", "}", "exception", "=", "e", ";", "}", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "\"", "\\\\", "p{Lu}+", "\\\\", "p{Ll}*$", "\"", ")", ";", "Matcher", "matcher", "=", "pattern", ".", "matcher", "(", "source", ")", ";", "if", "(", "matcher", ".", "find", "(", ")", "&&", "matcher", ".", "start", "(", ")", "!=", "0", ")", "{", "int", "position", "=", "matcher", ".", "start", "(", ")", ";", "String", "head", "=", "source", ".", "substring", "(", "0", ",", "position", ")", ";", "String", "tail", "=", "source", ".", "substring", "(", "position", ")", ";", "try", "{", "return", "create", "(", "head", ",", "type", ",", "tail", "+", "addTail", ",", "base", ")", ";", "}", "catch", "(", "PropertyReferenceException", "e", ")", "{", "throw", "e", ".", "hasDeeperResolutionDepthThan", "(", "exception", ")", "?", "e", ":", "exception", ";", "}", "}", "throw", "exception", ";", "}"], "idx": 76332, "cwe": "CWE-770", "target": 0, "status": "FIXED", "commit": "3d8576fe4e4e71c23b9e6796b32fd56e51182ee", "function_name": "create", "body_hash": "580fc9ad5d3f1c76060d53fd4ef07388dff8cf0e"}
{"code": "@BeforeEach\n    public void startServer() throws Exception\n    {\n        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore.p12\").getAbsolutePath();\n        SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n        sslContextFactory.setKeyStorePath(keystore);\n        sslContextFactory.setKeyStorePassword(\"storepwd\");\n\n        server = new Server();\n        HttpConnectionFactory http = new HttpConnectionFactory();\n        http.setInputBufferSize(512);\n        http.getHttpConfiguration().setRequestHeaderSize(512);\n        connector = new ServerConnector(server, sslContextFactory, http);\n        connector.setPort(0);\n        connector.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n\n        server.addConnector(connector);\n    }", "code_tokens": ["@", "BeforeEach", "public", "void", "startServer", "(", ")", "throws", "Exception", "{", "String", "keystore", "=", "MavenTestingUtils", ".", "getTestResourceFile", "(", "\"", "keystore.p12", "\"", ")", ".", "getAbsolutePath", "(", ")", ";", "SslContextFactory", ".", "Server", "sslContextFactory", "=", "new", "SslContextFactory", ".", "Server", "(", ")", ";", "sslContextFactory", ".", "setKeyStorePath", "(", "keystore", ")", ";", "sslContextFactory", ".", "setKeyStorePassword", "(", "\"", "storepwd", "\"", ")", ";", "server", "=", "new", "Server", "(", ")", ";", "HttpConnectionFactory", "http", "=", "new", "HttpConnectionFactory", "(", ")", ";", "http", ".", "setInputBufferSize", "(", "512", ")", ";", "http", ".", "getHttpConfiguration", "(", ")", ".", "setRequestHeaderSize", "(", "512", ")", ";", "connector", "=", "new", "ServerConnector", "(", "server", ",", "sslContextFactory", ",", "http", ")", ";", "connector", ".", "setPort", "(", "0", ")", ";", "connector", ".", "getConnectionFactory", "(", "HttpConnectionFactory", ".", "class", ")", ".", "getHttpConfiguration", "(", ")", ".", "setSendDateHeader", "(", "false", ")", ";", "server", ".", "addConnector", "(", "connector", ")", ";", "}"], "idx": 65387, "cwe": "CWE-59", "target": 1, "status": "VULNERABLE", "commit": "be22761a20a1685365c8e0356bf09b47e574cfd9", "function_name": "startServer", "body_hash": "05a4d29240807d11b588f64ef0d47e710a5cfed7"}
{"code": "private boolean processRemainingHeader() throws IOException {\n        // Ignore the 2 bytes already read. 4 for the mask\n        int headerLength;\n        if (isMasked()) {\n            headerLength = 4;\n        } else {\n            headerLength = 0;\n        }\n        // Add additional bytes depending on length\n        if (payloadLength == 126) {\n            headerLength += 2;\n        } else if (payloadLength == 127) {\n            headerLength += 8;\n        }\n        if (writePos - readPos < headerLength) {\n            return false;\n        }\n        // Calculate new payload length if necessary\n        if (payloadLength == 126) {\n            payloadLength = byteArrayToLong(inputBuffer, readPos, 2);\n            readPos += 2;\n        } else if (payloadLength == 127) {\n            payloadLength = byteArrayToLong(inputBuffer, readPos, 8);\n            // The most significant bit of those 8 bytes is required to be zero\n            // (see RFC 6455, section 5.2). If the most significant bit is set,\n            // the resulting payload length will be negative so test for that.\n            if (payloadLength < 0) {\n                throw new WsIOException(\n                        new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString(\"wsFrame.payloadMsbInvalid\")));\n            }\n            readPos += 8;\n        }\n        if (Util.isControl(opCode)) {\n            if (payloadLength > 125) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlPayloadTooBig\",\n                                Long.valueOf(payloadLength))));\n            }\n            if (!fin) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlNoFin\")));\n            }\n        }\n        if (isMasked()) {\n            System.arraycopy(inputBuffer, readPos, mask, 0, 4);\n            readPos += 4;\n        }\n        state = State.DATA;\n        return true;\n    }", "code_tokens": ["private", "boolean", "processRemainingHeader", "(", ")", "throws", "IOException", "{", "int", "headerLength", ";", "if", "(", "isMasked", "(", ")", ")", "{", "headerLength", "=", "4", ";", "}", "else", "{", "headerLength", "=", "0", ";", "}", "if", "(", "payloadLength", "==", "126", ")", "{", "headerLength", "+=", "2", ";", "}", "else", "if", "(", "payloadLength", "==", "127", ")", "{", "headerLength", "+=", "8", ";", "}", "if", "(", "writePos", "-", "readPos", "<", "headerLength", ")", "{", "return", "false", ";", "}", "if", "(", "payloadLength", "==", "126", ")", "{", "payloadLength", "=", "byteArrayToLong", "(", "inputBuffer", ",", "readPos", ",", "2", ")", ";", "readPos", "+=", "2", ";", "}", "else", "if", "(", "payloadLength", "==", "127", ")", "{", "payloadLength", "=", "byteArrayToLong", "(", "inputBuffer", ",", "readPos", ",", "8", ")", ";", "if", "(", "payloadLength", "<", "0", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.payloadMsbInvalid", "\"", ")", ")", ")", ";", "}", "readPos", "+=", "8", ";", "}", "if", "(", "Util", ".", "isControl", "(", "opCode", ")", ")", "{", "if", "(", "payloadLength", ">", "125", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.controlPayloadTooBig", "\"", ",", "Long", ".", "valueOf", "(", "payloadLength", ")", ")", ")", ")", ";", "}", "if", "(", "!", "fin", ")", "{", "throw", "new", "WsIOException", "(", "new", "CloseReason", "(", "CloseCodes", ".", "PROTOCOL_ERROR", ",", "sm", ".", "getString", "(", "\"", "wsFrame.controlNoFin", "\"", ")", ")", ")", ";", "}", "}", "if", "(", "isMasked", "(", ")", ")", "{", "System", ".", "arraycopy", "(", "inputBuffer", ",", "readPos", ",", "mask", ",", "0", ",", "4", ")", ";", "readPos", "+=", "4", ";", "}", "state", "=", "State", ".", "DATA", ";", "return", "true", ";", "}"], "idx": 82568, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "f9f75c14678b68633f79030ddf4ff827f014cc84", "function_name": "processRemainingHeader", "body_hash": "0ab4b5fdceb587e412b7f0f54fd1945ddbb741f9"}
{"code": "private void sendEntityMessage(Object message) throws Exception {\n        \n        MockEndpoint endpoint = getMockEndpoint(\"mock:result\");\n        endpoint.reset();\n        endpoint.expectedMessageCount(1);\n        \n        template.sendBody(\"direct:start1\", message);\n\n        assertMockEndpointsSatisfied();\n        \n        List<Exchange> list = endpoint.getReceivedExchanges();\n        Exchange exchange = list.get(0);\n        String xml = exchange.getIn().getBody(String.class);\n        assertTrue(\"Get a wrong transformed message\", xml.indexOf(\"<transformed subject=\\\"\\\">\") > 0);\n\n        endpoint.reset();\n        endpoint.expectedMessageCount(1);\n        \n        try {\n            template.sendBody(\"direct:start2\", message);\n            list = endpoint.getReceivedExchanges();\n            exchange = list.get(0);\n            xml = exchange.getIn().getBody(String.class);\n            assertTrue(\"Get a wrong transformed message\", xml.indexOf(\"<transformed subject=\\\"\\\">\") > 0);\n        } catch (Exception ex) {\n            // expect an exception here\n            assertTrue(\"Get a wrong exception\", ex instanceof CamelExecutionException);\n            // the file could not be found\n            assertTrue(\"Get a wrong exception cause\", ex.getCause() instanceof TransformerException);\n        }\n    }", "code_tokens": ["private", "void", "sendEntityMessage", "(", "Object", "message", ")", "throws", "Exception", "{", "MockEndpoint", "endpoint", "=", "getMockEndpoint", "(", "\"", "mock:result", "\"", ")", ";", "endpoint", ".", "reset", "(", ")", ";", "endpoint", ".", "expectedMessageCount", "(", "1", ")", ";", "template", ".", "sendBody", "(", "\"", "direct:start1", "\"", ",", "message", ")", ";", "assertMockEndpointsSatisfied", "(", ")", ";", "List", "<", "Exchange", ">", "list", "=", "endpoint", ".", "getReceivedExchanges", "(", ")", ";", "Exchange", "exchange", "=", "list", ".", "get", "(", "0", ")", ";", "String", "xml", "=", "exchange", ".", "getIn", "(", ")", ".", "getBody", "(", "String", ".", "class", ")", ";", "assertTrue", "(", "\"", "Get a wrong transformed message", "\"", ",", "xml", ".", "indexOf", "(", "\"", "<transformed subject=", "\\\"", "\\\"", ">", "\"", ")", ">", "0", ")", ";", "endpoint", ".", "reset", "(", ")", ";", "endpoint", ".", "expectedMessageCount", "(", "1", ")", ";", "try", "{", "template", ".", "sendBody", "(", "\"", "direct:start2", "\"", ",", "message", ")", ";", "list", "=", "endpoint", ".", "getReceivedExchanges", "(", ")", ";", "exchange", "=", "list", ".", "get", "(", "0", ")", ";", "xml", "=", "exchange", ".", "getIn", "(", ")", ".", "getBody", "(", "String", ".", "class", ")", ";", "assertTrue", "(", "\"", "Get a wrong transformed message", "\"", ",", "xml", ".", "indexOf", "(", "\"", "<transformed subject=", "\\\"", "\\\"", ">", "\"", ")", ">", "0", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "assertTrue", "(", "\"", "Get a wrong exception", "\"", ",", "ex", "instanceof", "CamelExecutionException", ")", ";", "assertTrue", "(", "\"", "Get a wrong exception cause", "\"", ",", "ex", ".", "getCause", "(", ")", "instanceof", "TransformerException", ")", ";", "}", "}"], "idx": 110304, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "1df559649a96a1ca0368373387e542f46e4820da", "function_name": "sendEntityMessage", "body_hash": "42493b7b57f8523384008f270a2dd719e0fa246b"}
{"code": "protected static byte[] readFully(InputStream inp, int length, boolean shortDataIsFatal)\n            throws IOException {\n        if (length > MAX_RECORD_SIZE) {\n            throw new IOException(\"Record size (\"+length+\n                    \" bytes) is larger than the allowed record size: \"+MAX_RECORD_SIZE);\n        }\n        byte[] b = new byte[length];\n\n        int pos = 0;\n        int read;\n        while (pos < length) {\n            read = inp.read(b, pos, length-pos);\n            if (read == -1) {\n                if(shortDataIsFatal) {\n                   throw new IOException(\"Tried to read \" + length + \" bytes, but only \" + pos + \" bytes present\");\n                } else {\n                   // Give them what we found\n                   // TODO Log the short read\n                   return b;\n                }\n            }\n            pos += read;\n        }\n\n        return b;\n    }", "code_tokens": ["protected", "static", "byte", "[", "]", "readFully", "(", "InputStream", "inp", ",", "int", "length", ",", "boolean", "shortDataIsFatal", ")", "throws", "IOException", "{", "if", "(", "length", ">", "MAX_RECORD_SIZE", ")", "{", "throw", "new", "IOException", "(", "\"", "Record size (", "\"", "+", "length", "+", "\"", " bytes) is larger than the allowed record size: ", "\"", "+", "MAX_RECORD_SIZE", ")", ";", "}", "byte", "[", "]", "b", "=", "new", "byte", "[", "length", "]", ";", "int", "pos", "=", "0", ";", "int", "read", ";", "while", "(", "pos", "<", "length", ")", "{", "read", "=", "inp", ".", "read", "(", "b", ",", "pos", ",", "length", "-", "pos", ")", ";", "if", "(", "read", "==", "-", "1", ")", "{", "if", "(", "shortDataIsFatal", ")", "{", "throw", "new", "IOException", "(", "\"", "Tried to read ", "\"", "+", "length", "+", "\"", " bytes, but only ", "\"", "+", "pos", "+", "\"", " bytes present", "\"", ")", ";", "}", "else", "{", "return", "b", ";", "}", "}", "pos", "+=", "read", ";", "}", "return", "b", ";", "}"], "idx": 83037, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "57193f5", "function_name": "readFully", "body_hash": "4426f7048e0e8a1cdf67b8ab9c15c28f08377a7f"}
{"code": "protected String cleanupActionName(final String rawActionName) {\n        if (rawActionName.matches(allowedActionNames)) {\n            return rawActionName;\n        } else {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Action [#0] do not match allowed action names pattern [#1], cleaning it up!\",\n                        rawActionName, allowedActionNames);\n            }\n            String cleanActionName = rawActionName;\n            for(String chunk : rawActionName.split(allowedActionNames)) {\n                cleanActionName = cleanActionName.replace(chunk, \"\");\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Cleaned action name [#0]\", cleanActionName);\n            }\n            return cleanActionName;\n        }\n    }", "code_tokens": ["protected", "String", "cleanupActionName", "(", "final", "String", "rawActionName", ")", "{", "if", "(", "rawActionName", ".", "matches", "(", "allowedActionNames", ")", ")", "{", "return", "rawActionName", ";", "}", "else", "{", "if", "(", "LOG", ".", "isWarnEnabled", "(", ")", ")", "{", "LOG", ".", "warn", "(", "\"", "Action [#0] do not match allowed action names pattern [#1], cleaning it up!", "\"", ",", "rawActionName", ",", "allowedActionNames", ")", ";", "}", "String", "cleanActionName", "=", "rawActionName", ";", "for", "(", "String", "chunk", ":", "rawActionName", ".", "split", "(", "allowedActionNames", ")", ")", "{", "cleanActionName", "=", "cleanActionName", ".", "replace", "(", "chunk", ",", "\"", "\"", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Cleaned action name [#0]", "\"", ",", "cleanActionName", ")", ";", "}", "return", "cleanActionName", ";", "}", "}"], "idx": 95161, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "cfb6e9afbae320a4dd5bdd655154ab9fe5a92c1", "function_name": "cleanupActionName", "body_hash": "ce0efb8eeace0b590a36a2212c6dc0190b7be038"}
{"code": "public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        String pathUC = path.toUpperCase(Locale.ENGLISH);\n        if (path.isEmpty() || path.contains(\"..\") || path.contains(\"%\") || pathUC.contains(\"META-INF\") || pathUC.contains(\"WEB-INF\")) {\n            LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n    }", "code_tokens": ["public", "void", "doDynamic", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "req", ".", "getRestOfPath", "(", ")", ";", "String", "pathUC", "=", "path", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ";", "if", "(", "path", ".", "isEmpty", "(", ")", "||", "path", ".", "contains", "(", "\"", "..", "\"", ")", "||", "path", ".", "contains", "(", "\"", "%", "\"", ")", "||", "pathUC", ".", "contains", "(", "\"", "META-INF", "\"", ")", "||", "pathUC", ".", "contains", "(", "\"", "WEB-INF", "\"", ")", ")", "{", "LOGGER", ".", "warning", "(", "\"", "rejecting possibly malicious ", "\"", "+", "req", ".", "getRequestURIWithQueryString", "(", ")", ")", ";", "rsp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "String", "requestPath", "=", "req", ".", "getRequestURI", "(", ")", ".", "substring", "(", "req", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "boolean", "staticLink", "=", "requestPath", ".", "startsWith", "(", "\"", "/static/", "\"", ")", ";", "long", "expires", "=", "staticLink", "?", "TimeUnit2", ".", "DAYS", ".", "toMillis", "(", "365", ")", ":", "-", "1", ";", "rsp", ".", "serveLocalizedFile", "(", "req", ",", "new", "URL", "(", "wrapper", ".", "baseResourceURL", ",", "'.'", "+", "path", ")", ",", "expires", ")", ";", "}"], "idx": 15088, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "8830d68f5fe21f344be3496984bc4470bfcd0564", "function_name": "doDynamic", "body_hash": "f247d2a32bfb8487f315b2137cae7513dbbd0046"}
{"code": "protected void doSend(HttpServletResponse response)\n            throws IOException {\n\n        response.setContentType(\"text/html\");\n        response.setCharacterEncoding(\"UTF-8\");\n\n        // get changelog\n        changes.insert(0, \"<pre>\");\n        changes.append(\"</pre>\");\n        setProperty(PN_CHANGE_LOG, changes.toString());\n\n        Writer out = response.getWriter();\n        InputStream template = getClass().getResourceAsStream(TEMPLATE_NAME);\n        Reader in = new BufferedReader(new InputStreamReader(template));\n        StringBuffer varBuffer = new StringBuffer();\n        int state = 0;\n        int read;\n        while ((read = in.read()) >= 0) {\n            char c = (char) read;\n            switch (state) {\n                // initial\n                case 0:\n                    if (c == '$') {\n                        state = 1;\n                    } else {\n                        out.write(c);\n                    }\n                    break;\n                // $ read\n                case 1:\n                    if (c == '{') {\n                        state = 2;\n                    } else {\n                        state = 0;\n                        out.write('$');\n                        out.write(c);\n                    }\n                    break;\n                // { read\n                case 2:\n                    if (c == '}') {\n                        state = 0;\n                        Object prop = getProperty(varBuffer.toString());\n                        if (prop != null) {\n                            out.write(ResponseUtil.escapeXml(prop.toString()));\n                        }\n                        varBuffer.setLength(0);\n                    } else {\n                        varBuffer.append(c);\n                    }\n            }\n        }\n        in.close();\n        out.flush();\n    }", "code_tokens": ["protected", "void", "doSend", "(", "HttpServletResponse", "response", ")", "throws", "IOException", "{", "response", ".", "setContentType", "(", "\"", "text/html", "\"", ")", ";", "response", ".", "setCharacterEncoding", "(", "\"", "UTF-8", "\"", ")", ";", "changes", ".", "insert", "(", "0", ",", "\"", "<pre>", "\"", ")", ";", "changes", ".", "append", "(", "\"", "</pre>", "\"", ")", ";", "setProperty", "(", "PN_CHANGE_LOG", ",", "changes", ".", "toString", "(", ")", ")", ";", "Writer", "out", "=", "response", ".", "getWriter", "(", ")", ";", "InputStream", "template", "=", "getClass", "(", ")", ".", "getResourceAsStream", "(", "TEMPLATE_NAME", ")", ";", "Reader", "in", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "template", ")", ")", ";", "StringBuffer", "varBuffer", "=", "new", "StringBuffer", "(", ")", ";", "int", "state", "=", "0", ";", "int", "read", ";", "while", "(", "(", "read", "=", "in", ".", "read", "(", ")", ")", ">=", "0", ")", "{", "char", "c", "=", "(", "char", ")", "read", ";", "switch", "(", "state", ")", "{", "case", "0", ":", "if", "(", "c", "==", "'$'", ")", "{", "state", "=", "1", ";", "}", "else", "{", "out", ".", "write", "(", "c", ")", ";", "}", "break", ";", "case", "1", ":", "if", "(", "c", "==", "'{'", ")", "{", "state", "=", "2", ";", "}", "else", "{", "state", "=", "0", ";", "out", ".", "write", "(", "'$'", ")", ";", "out", ".", "write", "(", "c", ")", ";", "}", "break", ";", "case", "2", ":", "if", "(", "c", "==", "'}'", ")", "{", "state", "=", "0", ";", "Object", "prop", "=", "getProperty", "(", "varBuffer", ".", "toString", "(", ")", ")", ";", "if", "(", "prop", "!=", "null", ")", "{", "out", ".", "write", "(", "ResponseUtil", ".", "escapeXml", "(", "prop", ".", "toString", "(", ")", ")", ")", ";", "}", "varBuffer", ".", "setLength", "(", "0", ")", ";", "}", "else", "{", "varBuffer", ".", "append", "(", "c", ")", ";", "}", "}", "}", "in", ".", "close", "(", ")", ";", "out", ".", "flush", "(", ")", ";", "}"], "idx": 81318, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "fef65236bd9567e2982a43e3d188c425a1cb7537", "function_name": "doSend", "body_hash": "6495d6e56999f47e453543954275295b57f5c40f"}
{"code": "protected String parseFor(final String infoName) throws ParserConfigurationException, SAXException, IOException {\n            SAXParserFactory factory = SAXParserFactory.newInstance();\n            factory.setValidating(false);\n            factory.setNamespaceAware(false);\n\n            SAXParser saxParser = factory.newSAXParser();\n            ReadInfoHandler riHandler = new ReadInfoHandler(infoName);\n            try {\n                saxParser.parse(this.reportFile, riHandler);\n            } catch (BreakParsingException e) {\n                // break parsing\n            }\n            return riHandler.getInfo();\n        }", "code_tokens": ["protected", "String", "parseFor", "(", "final", "String", "infoName", ")", "throws", "ParserConfigurationException", ",", "SAXException", ",", "IOException", "{", "SAXParserFactory", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setValidating", "(", "false", ")", ";", "factory", ".", "setNamespaceAware", "(", "false", ")", ";", "SAXParser", "saxParser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "ReadInfoHandler", "riHandler", "=", "new", "ReadInfoHandler", "(", "infoName", ")", ";", "try", "{", "saxParser", ".", "parse", "(", "this", ".", "reportFile", ",", "riHandler", ")", ";", "}", "catch", "(", "BreakParsingException", "e", ")", "{", "}", "return", "riHandler", ".", "getInfo", "(", ")", ";", "}"], "idx": 69646, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "5ca59b8c7d23af4450dc7f19c1b4107d59063ae1", "function_name": "parseFor", "body_hash": "551970ec557fa469b480aff0c8dc42ee8c774389"}
{"code": "public void setMetaData(MetaData.Request request)\n    {\n        if (_metaData == null && _input != null && _channel != null)\n        {\n            _input.reopen();\n            _channel.getResponse().getHttpOutput().reopen();\n        }\n        _metaData = request;\n        _method = request.getMethod();\n        _httpFields = request.getFields();\n        final HttpURI uri = request.getURI();\n\n        if (uri.isAmbiguous())\n        {\n            UriCompliance compliance = _channel == null || _channel.getHttpConfiguration() == null ? null : _channel.getHttpConfiguration().getUriCompliance();\n            if (uri.hasAmbiguousSegment() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_SEGMENT)))\n                throw new BadMessageException(\"Ambiguous segment in URI\");\n            if (uri.hasAmbiguousSeparator() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_SEPARATOR)))\n                throw new BadMessageException(\"Ambiguous segment in URI\");\n            if (uri.hasAmbiguousParameter() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_PARAMETER)))\n                throw new BadMessageException(\"Ambiguous path parameter in URI\");\n        }\n\n        if (uri.isAbsolute() && uri.hasAuthority() && uri.getPath() != null)\n        {\n            _uri = uri;\n        }\n        else\n        {\n            HttpURI.Mutable builder = HttpURI.build(uri);\n\n            if (!uri.isAbsolute())\n                builder.scheme(HttpScheme.HTTP.asString());\n\n            if (uri.getPath() == null)\n                builder.path(\"/\");\n\n            if (!uri.hasAuthority())\n            {\n                HttpField field = getHttpFields().getField(HttpHeader.HOST);\n                if (field instanceof HostPortHttpField)\n                {\n                    HostPortHttpField authority = (HostPortHttpField)field;\n                    builder.host(authority.getHost()).port(authority.getPort());\n                }\n                else\n                {\n                    builder.host(findServerName()).port(findServerPort());\n                }\n            }\n            _uri = builder.asImmutable();\n        }\n\n        setSecure(HttpScheme.HTTPS.is(_uri.getScheme()));\n\n        String encoded = _uri.getPath();\n        String path;\n        if (encoded == null)\n            // TODO this is not really right for CONNECT\n            path = _uri.isAbsolute() ? \"/\" : null;\n        else if (encoded.startsWith(\"/\"))\n            path = (encoded.length() == 1) ? \"/\" : _uri.getDecodedPath();\n        else if (\"*\".equals(encoded) || HttpMethod.CONNECT.is(getMethod()))\n            path = encoded;\n        else\n            path = null;\n\n        if (path == null || path.isEmpty())\n        {\n            _pathInContext = encoded == null ? \"\" : encoded;\n            throw new BadMessageException(400, \"Bad URI\");\n        }\n        _pathInContext = path;\n    }", "code_tokens": ["public", "void", "setMetaData", "(", "MetaData", ".", "Request", "request", ")", "{", "if", "(", "_metaData", "==", "null", "&&", "_input", "!=", "null", "&&", "_channel", "!=", "null", ")", "{", "_input", ".", "reopen", "(", ")", ";", "_channel", ".", "getResponse", "(", ")", ".", "getHttpOutput", "(", ")", ".", "reopen", "(", ")", ";", "}", "_metaData", "=", "request", ";", "_method", "=", "request", ".", "getMethod", "(", ")", ";", "_httpFields", "=", "request", ".", "getFields", "(", ")", ";", "final", "HttpURI", "uri", "=", "request", ".", "getURI", "(", ")", ";", "if", "(", "uri", ".", "isAmbiguous", "(", ")", ")", "{", "UriCompliance", "compliance", "=", "_channel", "==", "null", "||", "_channel", ".", "getHttpConfiguration", "(", ")", "==", "null", "?", "null", ":", "_channel", ".", "getHttpConfiguration", "(", ")", ".", "getUriCompliance", "(", ")", ";", "if", "(", "uri", ".", "hasAmbiguousSegment", "(", ")", "&&", "(", "compliance", "==", "null", "||", "!", "compliance", ".", "allows", "(", "UriCompliance", ".", "Violation", ".", "AMBIGUOUS_PATH_SEGMENT", ")", ")", ")", "throw", "new", "BadMessageException", "(", "\"", "Ambiguous segment in URI", "\"", ")", ";", "if", "(", "uri", ".", "hasAmbiguousSeparator", "(", ")", "&&", "(", "compliance", "==", "null", "||", "!", "compliance", ".", "allows", "(", "UriCompliance", ".", "Violation", ".", "AMBIGUOUS_PATH_SEPARATOR", ")", ")", ")", "throw", "new", "BadMessageException", "(", "\"", "Ambiguous segment in URI", "\"", ")", ";", "if", "(", "uri", ".", "hasAmbiguousParameter", "(", ")", "&&", "(", "compliance", "==", "null", "||", "!", "compliance", ".", "allows", "(", "UriCompliance", ".", "Violation", ".", "AMBIGUOUS_PATH_PARAMETER", ")", ")", ")", "throw", "new", "BadMessageException", "(", "\"", "Ambiguous path parameter in URI", "\"", ")", ";", "}", "if", "(", "uri", ".", "isAbsolute", "(", ")", "&&", "uri", ".", "hasAuthority", "(", ")", "&&", "uri", ".", "getPath", "(", ")", "!=", "null", ")", "{", "_uri", "=", "uri", ";", "}", "else", "{", "HttpURI", ".", "Mutable", "builder", "=", "HttpURI", ".", "build", "(", "uri", ")", ";", "if", "(", "!", "uri", ".", "isAbsolute", "(", ")", ")", "builder", ".", "scheme", "(", "HttpScheme", ".", "HTTP", ".", "asString", "(", ")", ")", ";", "if", "(", "uri", ".", "getPath", "(", ")", "==", "null", ")", "builder", ".", "path", "(", "\"", "/", "\"", ")", ";", "if", "(", "!", "uri", ".", "hasAuthority", "(", ")", ")", "{", "HttpField", "field", "=", "getHttpFields", "(", ")", ".", "getField", "(", "HttpHeader", ".", "HOST", ")", ";", "if", "(", "field", "instanceof", "HostPortHttpField", ")", "{", "HostPortHttpField", "authority", "=", "(", "HostPortHttpField", ")", "field", ";", "builder", ".", "host", "(", "authority", ".", "getHost", "(", ")", ")", ".", "port", "(", "authority", ".", "getPort", "(", ")", ")", ";", "}", "else", "{", "builder", ".", "host", "(", "findServerName", "(", ")", ")", ".", "port", "(", "findServerPort", "(", ")", ")", ";", "}", "}", "_uri", "=", "builder", ".", "asImmutable", "(", ")", ";", "}", "setSecure", "(", "HttpScheme", ".", "HTTPS", ".", "is", "(", "_uri", ".", "getScheme", "(", ")", ")", ")", ";", "String", "encoded", "=", "_uri", ".", "getPath", "(", ")", ";", "String", "path", ";", "if", "(", "encoded", "==", "null", ")", "path", "=", "_uri", ".", "isAbsolute", "(", ")", "?", "\"", "/", "\"", ":", "null", ";", "else", "if", "(", "encoded", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "path", "=", "(", "encoded", ".", "length", "(", ")", "==", "1", ")", "?", "\"", "/", "\"", ":", "_uri", ".", "getDecodedPath", "(", ")", ";", "else", "if", "(", "\"", "*", "\"", ".", "equals", "(", "encoded", ")", "||", "HttpMethod", ".", "CONNECT", ".", "is", "(", "getMethod", "(", ")", ")", ")", "path", "=", "encoded", ";", "else", "path", "=", "null", ";", "if", "(", "path", "==", "null", "||", "path", ".", "isEmpty", "(", ")", ")", "{", "_pathInContext", "=", "encoded", "==", "null", "?", "\"", "\"", ":", "encoded", ";", "throw", "new", "BadMessageException", "(", "400", ",", "\"", "Bad URI", "\"", ")", ";", "}", "_pathInContext", "=", "path", ";", "}"], "idx": 114807, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "d80c622b005c044e93f585c231b420a29371f6e0", "function_name": "setMetaData", "body_hash": "a69087f58c15e2fc3e1a58587a4d3e89da2742cf"}
{"code": "@Nullable\n  SearchResult getLdapUserObject(BasicAuthLDAPConfig ldapConfig, DirContext context, String username)\n  {\n    try {\n      SearchControls sc = new SearchControls();\n      sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n      sc.setReturningAttributes(new String[] {ldapConfig.getUserAttribute(), \"memberOf\" });\n      String encodedUsername = encodeForLDAP(username, true);\n      NamingEnumeration<SearchResult> results = context.search(\n          ldapConfig.getBaseDn(),\n          StringUtils.format(ldapConfig.getUserSearch(), encodedUsername),\n          sc);\n      try {\n        if (!results.hasMore()) {\n          return null;\n        }\n        return results.next();\n      }\n      finally {\n        results.close();\n      }\n    }\n    catch (NamingException e) {\n      LOG.debug(e, \"Unable to find user '%s'\", username);\n      return null;\n    }\n  }", "code_tokens": ["@", "Nullable", "SearchResult", "getLdapUserObject", "(", "BasicAuthLDAPConfig", "ldapConfig", ",", "DirContext", "context", ",", "String", "username", ")", "{", "try", "{", "SearchControls", "sc", "=", "new", "SearchControls", "(", ")", ";", "sc", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "sc", ".", "setReturningAttributes", "(", "new", "String", "[", "]", "{", "ldapConfig", ".", "getUserAttribute", "(", ")", ",", "\"", "memberOf", "\"", "}", ")", ";", "String", "encodedUsername", "=", "encodeForLDAP", "(", "username", ",", "true", ")", ";", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "context", ".", "search", "(", "ldapConfig", ".", "getBaseDn", "(", ")", ",", "StringUtils", ".", "format", "(", "ldapConfig", ".", "getUserSearch", "(", ")", ",", "encodedUsername", ")", ",", "sc", ")", ";", "try", "{", "if", "(", "!", "results", ".", "hasMore", "(", ")", ")", "{", "return", "null", ";", "}", "return", "results", ".", "next", "(", ")", ";", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "NamingException", "e", ")", "{", "LOG", ".", "debug", "(", "e", ",", "\"", "Unable to find user '%s'", "\"", ",", "username", ")", ";", "return", "null", ";", "}", "}"], "idx": 73454, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "dbaabdd24710fef726c5730c609937706f456a44", "function_name": "getLdapUserObject", "body_hash": "b77672916c17ccfee7295ebc995f2ba20ac929c3"}
{"code": "@Override\n    public ScmServerEndpoint create(JSONObject request) {\n        List<ErrorMessage.Error> errors = Lists.newLinkedList();\n\n        // Validate name\n        final String name = (String) request.get(ScmServerEndpoint.NAME);\n        if(StringUtils.isBlank(name)){\n            errors.add(new ErrorMessage.Error(ScmServerEndpoint.NAME, ErrorMessage.Error.ErrorCodes.MISSING.toString(), ScmServerEndpoint.NAME + \" is required\"));\n        }\n\n        String url = (String) request.get(ScmServerEndpoint.API_URL);\n        final BitbucketEndpointConfiguration endpointConfiguration = BitbucketEndpointConfiguration.get();\n        if(StringUtils.isBlank(url)){\n            errors.add(new ErrorMessage.Error(ScmServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.MISSING.toString(), ScmServerEndpoint.API_URL + \" is required\"));\n        }else {\n            try {\n                String version = BitbucketServerApi.getVersion(url);\n                if (!BitbucketServerApi.isSupportedVersion(version)) {\n                    errors.add(new ErrorMessage.Error(BitbucketServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.INVALID.toString(),\n                            Messages.bbserver_version_validation_error(\n                                    version, BitbucketServerApi.MINIMUM_SUPPORTED_VERSION)));\n                } else {\n                    //validate presence of endpoint with same name\n                    url = BitbucketEndpointConfiguration.normalizeServerUrl(url);\n                    for (AbstractBitbucketEndpoint endpoint : endpointConfiguration.getEndpoints()) {\n                        if (url.equals(endpoint.getServerUrl())) {\n                            errors.add(new ErrorMessage.Error(ScmServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.ALREADY_EXISTS.toString(), ScmServerEndpoint.API_URL + \" already exists\"));\n                            break;\n                        }\n                    }\n                }\n            } catch (ServiceException e) {\n                errors.add(new ErrorMessage.Error(BitbucketServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.INVALID.toString(), StringUtils.isBlank(e.getMessage()) ? \"Invalid URL\" : e.getMessage()));\n            }\n        }\n\n        if(!errors.isEmpty()){\n            throw new ServiceException.BadRequestException(new ErrorMessage(400, \"Failed to create Bitbucket server endpoint\").addAll(errors));\n        }\n        final com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketServerEndpoint endpoint = new com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketServerEndpoint(name, url, false, null);\n        SecurityContext old=null;\n        try {\n            // We need to escalate privilege to add user defined endpoint to\n            old = ACL.impersonate(ACL.SYSTEM);\n            endpointConfiguration.addEndpoint(endpoint);\n        }finally {\n            //reset back to original privilege level\n            if(old != null){\n                SecurityContextHolder.setContext(old);\n            }\n        }\n        return new BitbucketServerEndpoint(endpoint, this);\n    }", "code_tokens": ["@", "Override", "public", "ScmServerEndpoint", "create", "(", "JSONObject", "request", ")", "{", "List", "<", "ErrorMessage", ".", "Error", ">", "errors", "=", "Lists", ".", "newLinkedList", "(", ")", ";", "final", "String", "name", "=", "(", "String", ")", "request", ".", "get", "(", "ScmServerEndpoint", ".", "NAME", ")", ";", "if", "(", "StringUtils", ".", "isBlank", "(", "name", ")", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "ScmServerEndpoint", ".", "NAME", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "MISSING", ".", "toString", "(", ")", ",", "ScmServerEndpoint", ".", "NAME", "+", "\"", " is required", "\"", ")", ")", ";", "}", "String", "url", "=", "(", "String", ")", "request", ".", "get", "(", "ScmServerEndpoint", ".", "API_URL", ")", ";", "final", "BitbucketEndpointConfiguration", "endpointConfiguration", "=", "BitbucketEndpointConfiguration", ".", "get", "(", ")", ";", "if", "(", "StringUtils", ".", "isBlank", "(", "url", ")", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "ScmServerEndpoint", ".", "API_URL", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "MISSING", ".", "toString", "(", ")", ",", "ScmServerEndpoint", ".", "API_URL", "+", "\"", " is required", "\"", ")", ")", ";", "}", "else", "{", "try", "{", "String", "version", "=", "BitbucketServerApi", ".", "getVersion", "(", "url", ")", ";", "if", "(", "!", "BitbucketServerApi", ".", "isSupportedVersion", "(", "version", ")", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "BitbucketServerEndpoint", ".", "API_URL", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "INVALID", ".", "toString", "(", ")", ",", "Messages", ".", "bbserver_version_validation_error", "(", "version", ",", "BitbucketServerApi", ".", "MINIMUM_SUPPORTED_VERSION", ")", ")", ")", ";", "}", "else", "{", "url", "=", "BitbucketEndpointConfiguration", ".", "normalizeServerUrl", "(", "url", ")", ";", "for", "(", "AbstractBitbucketEndpoint", "endpoint", ":", "endpointConfiguration", ".", "getEndpoints", "(", ")", ")", "{", "if", "(", "url", ".", "equals", "(", "endpoint", ".", "getServerUrl", "(", ")", ")", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "ScmServerEndpoint", ".", "API_URL", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "ALREADY_EXISTS", ".", "toString", "(", ")", ",", "ScmServerEndpoint", ".", "API_URL", "+", "\"", " already exists", "\"", ")", ")", ";", "break", ";", "}", "}", "}", "}", "catch", "(", "ServiceException", "e", ")", "{", "errors", ".", "add", "(", "new", "ErrorMessage", ".", "Error", "(", "BitbucketServerEndpoint", ".", "API_URL", ",", "ErrorMessage", ".", "Error", ".", "ErrorCodes", ".", "INVALID", ".", "toString", "(", ")", ",", "StringUtils", ".", "isBlank", "(", "e", ".", "getMessage", "(", ")", ")", "?", "\"", "Invalid URL", "\"", ":", "e", ".", "getMessage", "(", ")", ")", ")", ";", "}", "}", "if", "(", "!", "errors", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "ServiceException", ".", "BadRequestException", "(", "new", "ErrorMessage", "(", "400", ",", "\"", "Failed to create Bitbucket server endpoint", "\"", ")", ".", "addAll", "(", "errors", ")", ")", ";", "}", "final", "com", ".", "cloudbees", ".", "jenkins", ".", "plugins", ".", "bitbucket", ".", "endpoints", ".", "BitbucketServerEndpoint", "endpoint", "=", "new", "com", ".", "cloudbees", ".", "jenkins", ".", "plugins", ".", "bitbucket", ".", "endpoints", ".", "BitbucketServerEndpoint", "(", "name", ",", "url", ",", "false", ",", "null", ")", ";", "SecurityContext", "old", "=", "null", ";", "try", "{", "old", "=", "ACL", ".", "impersonate", "(", "ACL", ".", "SYSTEM", ")", ";", "endpointConfiguration", ".", "addEndpoint", "(", "endpoint", ")", ";", "}", "finally", "{", "if", "(", "old", "!=", "null", ")", "{", "SecurityContextHolder", ".", "setContext", "(", "old", ")", ";", "}", "}", "return", "new", "BitbucketServerEndpoint", "(", "endpoint", ",", "this", ")", ";", "}"], "idx": 83829, "cwe": "CWE-862", "target": 1, "status": "VULNERABLE", "commit": "659a66aff", "function_name": "create", "body_hash": "9ec85566a66a07fa85099954570bda8ea951addf"}
{"code": "public void doCommand(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        final Jenkins jenkins = Jenkins.getInstance();\n        jenkins.checkPermission(Jenkins.READ);\n\n        // Strip trailing slash\n        final String commandName = req.getRestOfPath().substring(1);\n        CLICommand command = CLICommand.clone(commandName);\n        if (command == null) {\n            rsp.sendError(HttpServletResponse.SC_NOT_FOUND, \"No such command\");\n            return;\n        }\n\n        req.setAttribute(\"command\", command);\n        req.getView(this, \"command.jelly\").forward(req, rsp);\n    }", "code_tokens": ["public", "void", "doCommand", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "ServletException", ",", "IOException", "{", "final", "Jenkins", "jenkins", "=", "Jenkins", ".", "getInstance", "(", ")", ";", "jenkins", ".", "checkPermission", "(", "Jenkins", ".", "READ", ")", ";", "final", "String", "commandName", "=", "req", ".", "getRestOfPath", "(", ")", ".", "substring", "(", "1", ")", ";", "CLICommand", "command", "=", "CLICommand", ".", "clone", "(", "commandName", ")", ";", "if", "(", "command", "==", "null", ")", "{", "rsp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "\"", "No such command", "\"", ")", ";", "return", ";", "}", "req", ".", "setAttribute", "(", "\"", "command", "\"", ",", "command", ")", ";", "req", ".", "getView", "(", "this", ",", "\"", "command.jelly", "\"", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "}"], "idx": 7676, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "f5c51fbad2b62b81dc1e0402aeee058a4a478046", "function_name": "doCommand", "body_hash": "b89438d48213830fbabf6be8ac6999f917f0ba4f"}
{"code": "public void processPacket(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return;\n\n            org.jivesoftware.smack.packet.Message msg =\n                (org.jivesoftware.smack.packet.Message)packet;\n\n            boolean isForwardedSentMessage = false;\n            if(msg.getBody() == null)\n            {\n\n                CarbonPacketExtension carbonExt\n                    = (CarbonPacketExtension) msg.getExtension(\n                        CarbonPacketExtension.NAMESPACE);\n                if(carbonExt == null)\n                    return;\n\n                isForwardedSentMessage\n                    = (carbonExt.getElementName()\n                        == CarbonPacketExtension.SENT_ELEMENT_NAME);\n                List<ForwardedPacketExtension> extensions\n                    = carbonExt.getChildExtensionsOfType(\n                        ForwardedPacketExtension.class);\n                if(extensions.isEmpty())\n                    return;\n\n                // according to xep-0280 all carbons should come from\n                // our bare jid\n                if (!msg.getFrom().equals(\n                        StringUtils.parseBareAddress(\n                            jabberProvider.getOurJID())))\n                {\n                    logger.info(\"Received a carbon copy with wrong from!\");\n                    return;\n                }\n\n                ForwardedPacketExtension forwardedExt = extensions.get(0);\n                msg = forwardedExt.getMessage();\n                if(msg == null || msg.getBody() == null)\n                    return;\n\n            }\n\n            Object multiChatExtension =\n                msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\n            // its not for us\n            if(multiChatExtension != null)\n                return;\n\n            String userFullId\n                = isForwardedSentMessage? msg.getTo() : msg.getFrom();\n\n            String userBareID = StringUtils.parseBareAddress(userFullId);\n\n            boolean isPrivateMessaging = false;\n            ChatRoom privateContactRoom = null;\n            OperationSetMultiUserChatJabberImpl mucOpSet =\n                (OperationSetMultiUserChatJabberImpl)jabberProvider\n                    .getOperationSet(OperationSetMultiUserChat.class);\n            if(mucOpSet != null)\n                privateContactRoom = mucOpSet.getChatRoom(userBareID);\n\n            if(privateContactRoom != null)\n            {\n                isPrivateMessaging = true;\n            }\n\n            if(logger.isDebugEnabled())\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Received from \"\n                             + userBareID\n                             + \" the message \"\n                             + msg.toXML());\n            }\n\n            Message newMessage = createMessage(msg.getBody(),\n                    DEFAULT_MIME_TYPE, msg.getPacketID());\n\n            //check if the message is available in xhtml\n            PacketExtension ext = msg.getExtension(\n                            \"http://jabber.org/protocol/xhtml-im\");\n\n            if(ext != null)\n            {\n                XHTMLExtension xhtmlExt\n                    = (XHTMLExtension)ext;\n\n                //parse all bodies\n                Iterator<String> bodies = xhtmlExt.getBodies();\n                StringBuffer messageBuff = new StringBuffer();\n                while (bodies.hasNext())\n                {\n                    String body = bodies.next();\n                    messageBuff.append(body);\n                }\n\n                if (messageBuff.length() > 0)\n                {\n                    // we remove body tags around message cause their\n                    // end body tag is breaking\n                    // the visualization as html in the UI\n                    String receivedMessage =\n                        messageBuff.toString()\n                        // removes body start tag\n                        .replaceAll(\"\\\\<[bB][oO][dD][yY].*?>\",\"\")\n                        // removes body end tag\n                        .replaceAll(\"\\\\</[bB][oO][dD][yY].*?>\",\"\");\n\n                    // for some reason &apos; is not rendered correctly\n                    // from our ui, lets use its equivalent. Other\n                    // similar chars(< > & \") seem ok.\n                    receivedMessage =\n                            receivedMessage.replaceAll(\"&apos;\", \"&#39;\");\n\n                    newMessage = createMessage(receivedMessage,\n                            HTML_MIME_TYPE, msg.getPacketID());\n                }\n            }\n\n            PacketExtension correctionExtension =\n                    msg.getExtension(MessageCorrectionExtension.NAMESPACE);\n            String correctedMessageUID = null;\n            if (correctionExtension != null)\n            {\n                correctedMessageUID = ((MessageCorrectionExtension)\n                        correctionExtension).getCorrectedMessageUID();\n            }\n\n            Contact sourceContact\n                = opSetPersPresence.findContactByID(\n                    (isPrivateMessaging? userFullId : userBareID));\n            if(msg.getType()\n                            == org.jivesoftware.smack.packet.Message.Type.error)\n            {\n                // error which is multichat and we don't know about the contact\n                // is a muc message error which is missing muc extension\n                // and is coming from the room, when we try to send message to\n                // room which was deleted or offline on the server\n                if(isPrivateMessaging && sourceContact == null)\n                {\n                    if(privateContactRoom != null)\n                    {\n                        XMPPError error = packet.getError();\n                        int errorResultCode\n                            = ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                        if(error != null && error.getCode() == 403)\n                        {\n                            errorResultCode\n                                = ChatRoomMessageDeliveryFailedEvent.FORBIDDEN;\n                        }\n\n                        String errorReason = error.getMessage();\n\n                        ChatRoomMessageDeliveryFailedEvent evt =\n                            new ChatRoomMessageDeliveryFailedEvent(\n                                privateContactRoom,\n                                null,\n                                errorResultCode,\n                                errorReason,\n                                new Date(),\n                                newMessage);\n                        ((ChatRoomJabberImpl)privateContactRoom)\n                            .fireMessageEvent(evt);\n                    }\n\n                    return;\n                }\n\n                if (logger.isInfoEnabled())\n                    logger.info(\"Message error received from \" + userBareID);\n\n                int errorResultCode = MessageDeliveryFailedEvent.UNKNOWN_ERROR;\n                if (packet.getError() != null)\n                {\n                    int errorCode = packet.getError().getCode();\n    \n                    if(errorCode == 503)\n                    {\n                        org.jivesoftware.smackx.packet.MessageEvent msgEvent =\n                            (org.jivesoftware.smackx.packet.MessageEvent)\n                                packet.getExtension(\"x\", \"jabber:x:event\");\n                        if(msgEvent != null && msgEvent.isOffline())\n                        {\n                            errorResultCode =\n                                MessageDeliveryFailedEvent\n                                    .OFFLINE_MESSAGES_NOT_SUPPORTED;\n                        }\n                    }\n                }\n\n                if (sourceContact == null)\n                {\n                    sourceContact = opSetPersPresence.createVolatileContact(\n                        userFullId, isPrivateMessaging);\n                }\n\n                MessageDeliveryFailedEvent ev\n                    = new MessageDeliveryFailedEvent(newMessage,\n                                                     sourceContact,\n                                                     correctedMessageUID,\n                                                     errorResultCode);\n\n                // ev = messageDeliveryFailedTransform(ev);\n\n                if (ev != null)\n                    fireMessageEvent(ev);\n                return;\n            }\n            putJidForAddress(userFullId, msg.getThread());\n\n            // In the second condition we filter all group chat messages,\n            // because they are managed by the multi user chat operation set.\n            if(sourceContact == null)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"received a message from an unknown contact: \"\n                                   + userBareID);\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(\n                        userFullId,\n                        isPrivateMessaging);\n            }\n\n            Date timestamp = new Date();\n            //Check for XEP-0091 timestamp (deprecated)\n            PacketExtension delay = msg.getExtension(\"x\", \"jabber:x:delay\");\n            if(delay != null && delay instanceof DelayInformation)\n            {\n                timestamp = ((DelayInformation)delay).getStamp();\n            }\n            //check for XEP-0203 timestamp\n            delay = msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n            if(delay != null && delay instanceof DelayInfo)\n            {\n                timestamp = ((DelayInfo)delay).getStamp();\n            }\n\n            ContactResource resource = ((ContactJabberImpl) sourceContact)\n                    .getResourceFromJid(userFullId);\n\n            EventObject msgEvt = null;\n            if(!isForwardedSentMessage)\n                msgEvt\n                    = new MessageReceivedEvent( newMessage,\n                                                sourceContact,\n                                                resource,\n                                                timestamp,\n                                                correctedMessageUID,\n                                                isPrivateMessaging,\n                                                privateContactRoom);\n            else\n                msgEvt = new MessageDeliveredEvent(newMessage, sourceContact, timestamp);\n            // msgReceivedEvt = messageReceivedTransform(msgReceivedEvt);\n            if (msgEvt != null)\n                fireMessageEvent(msgEvt);\n        }", "code_tokens": ["public", "void", "processPacket", "(", "Packet", "packet", ")", "{", "if", "(", "!", "(", "packet", "instanceof", "org", ".", "jivesoftware", ".", "smack", ".", "packet", ".", "Message", ")", ")", "return", ";", "org", ".", "jivesoftware", ".", "smack", ".", "packet", ".", "Message", "msg", "=", "(", "org", ".", "jivesoftware", ".", "smack", ".", "packet", ".", "Message", ")", "packet", ";", "boolean", "isForwardedSentMessage", "=", "false", ";", "if", "(", "msg", ".", "getBody", "(", ")", "==", "null", ")", "{", "CarbonPacketExtension", "carbonExt", "=", "(", "CarbonPacketExtension", ")", "msg", ".", "getExtension", "(", "CarbonPacketExtension", ".", "NAMESPACE", ")", ";", "if", "(", "carbonExt", "==", "null", ")", "return", ";", "isForwardedSentMessage", "=", "(", "carbonExt", ".", "getElementName", "(", ")", "==", "CarbonPacketExtension", ".", "SENT_ELEMENT_NAME", ")", ";", "List", "<", "ForwardedPacketExtension", ">", "extensions", "=", "carbonExt", ".", "getChildExtensionsOfType", "(", "ForwardedPacketExtension", ".", "class", ")", ";", "if", "(", "extensions", ".", "isEmpty", "(", ")", ")", "return", ";", "if", "(", "!", "msg", ".", "getFrom", "(", ")", ".", "equals", "(", "StringUtils", ".", "parseBareAddress", "(", "jabberProvider", ".", "getOurJID", "(", ")", ")", ")", ")", "{", "logger", ".", "info", "(", "\"", "Received a carbon copy with wrong from!", "\"", ")", ";", "return", ";", "}", "ForwardedPacketExtension", "forwardedExt", "=", "extensions", ".", "get", "(", "0", ")", ";", "msg", "=", "forwardedExt", ".", "getMessage", "(", ")", ";", "if", "(", "msg", "==", "null", "||", "msg", ".", "getBody", "(", ")", "==", "null", ")", "return", ";", "}", "Object", "multiChatExtension", "=", "msg", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "http://jabber.org/protocol/muc#user", "\"", ")", ";", "if", "(", "multiChatExtension", "!=", "null", ")", "return", ";", "String", "userFullId", "=", "isForwardedSentMessage", "?", "msg", ".", "getTo", "(", ")", ":", "msg", ".", "getFrom", "(", ")", ";", "String", "userBareID", "=", "StringUtils", ".", "parseBareAddress", "(", "userFullId", ")", ";", "boolean", "isPrivateMessaging", "=", "false", ";", "ChatRoom", "privateContactRoom", "=", "null", ";", "OperationSetMultiUserChatJabberImpl", "mucOpSet", "=", "(", "OperationSetMultiUserChatJabberImpl", ")", "jabberProvider", ".", "getOperationSet", "(", "OperationSetMultiUserChat", ".", "class", ")", ";", "if", "(", "mucOpSet", "!=", "null", ")", "privateContactRoom", "=", "mucOpSet", ".", "getChatRoom", "(", "userBareID", ")", ";", "if", "(", "privateContactRoom", "!=", "null", ")", "{", "isPrivateMessaging", "=", "true", ";", "}", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "logger", ".", "debug", "(", "\"", "Received from ", "\"", "+", "userBareID", "+", "\"", " the message ", "\"", "+", "msg", ".", "toXML", "(", ")", ")", ";", "}", "Message", "newMessage", "=", "createMessage", "(", "msg", ".", "getBody", "(", ")", ",", "DEFAULT_MIME_TYPE", ",", "msg", ".", "getPacketID", "(", ")", ")", ";", "PacketExtension", "ext", "=", "msg", ".", "getExtension", "(", "\"", "http://jabber.org/protocol/xhtml-im", "\"", ")", ";", "if", "(", "ext", "!=", "null", ")", "{", "XHTMLExtension", "xhtmlExt", "=", "(", "XHTMLExtension", ")", "ext", ";", "Iterator", "<", "String", ">", "bodies", "=", "xhtmlExt", ".", "getBodies", "(", ")", ";", "StringBuffer", "messageBuff", "=", "new", "StringBuffer", "(", ")", ";", "while", "(", "bodies", ".", "hasNext", "(", ")", ")", "{", "String", "body", "=", "bodies", ".", "next", "(", ")", ";", "messageBuff", ".", "append", "(", "body", ")", ";", "}", "if", "(", "messageBuff", ".", "length", "(", ")", ">", "0", ")", "{", "String", "receivedMessage", "=", "messageBuff", ".", "toString", "(", ")", ".", "replaceAll", "(", "\"", "\\\\", "<[bB][oO][dD][yY].*?>", "\"", ",", "\"", "\"", ")", ".", "replaceAll", "(", "\"", "\\\\", "</[bB][oO][dD][yY].*?>", "\"", ",", "\"", "\"", ")", ";", "receivedMessage", "=", "receivedMessage", ".", "replaceAll", "(", "\"", "&apos;", "\"", ",", "\"", "&#39;", "\"", ")", ";", "newMessage", "=", "createMessage", "(", "receivedMessage", ",", "HTML_MIME_TYPE", ",", "msg", ".", "getPacketID", "(", ")", ")", ";", "}", "}", "PacketExtension", "correctionExtension", "=", "msg", ".", "getExtension", "(", "MessageCorrectionExtension", ".", "NAMESPACE", ")", ";", "String", "correctedMessageUID", "=", "null", ";", "if", "(", "correctionExtension", "!=", "null", ")", "{", "correctedMessageUID", "=", "(", "(", "MessageCorrectionExtension", ")", "correctionExtension", ")", ".", "getCorrectedMessageUID", "(", ")", ";", "}", "Contact", "sourceContact", "=", "opSetPersPresence", ".", "findContactByID", "(", "(", "isPrivateMessaging", "?", "userFullId", ":", "userBareID", ")", ")", ";", "if", "(", "msg", ".", "getType", "(", ")", "==", "org", ".", "jivesoftware", ".", "smack", ".", "packet", ".", "Message", ".", "Type", ".", "error", ")", "{", "if", "(", "isPrivateMessaging", "&&", "sourceContact", "==", "null", ")", "{", "if", "(", "privateContactRoom", "!=", "null", ")", "{", "XMPPError", "error", "=", "packet", ".", "getError", "(", ")", ";", "int", "errorResultCode", "=", "ChatRoomMessageDeliveryFailedEvent", ".", "UNKNOWN_ERROR", ";", "if", "(", "error", "!=", "null", "&&", "error", ".", "getCode", "(", ")", "==", "403", ")", "{", "errorResultCode", "=", "ChatRoomMessageDeliveryFailedEvent", ".", "FORBIDDEN", ";", "}", "String", "errorReason", "=", "error", ".", "getMessage", "(", ")", ";", "ChatRoomMessageDeliveryFailedEvent", "evt", "=", "new", "ChatRoomMessageDeliveryFailedEvent", "(", "privateContactRoom", ",", "null", ",", "errorResultCode", ",", "errorReason", ",", "new", "Date", "(", ")", ",", "newMessage", ")", ";", "(", "(", "ChatRoomJabberImpl", ")", "privateContactRoom", ")", ".", "fireMessageEvent", "(", "evt", ")", ";", "}", "return", ";", "}", "if", "(", "logger", ".", "isInfoEnabled", "(", ")", ")", "logger", ".", "info", "(", "\"", "Message error received from ", "\"", "+", "userBareID", ")", ";", "int", "errorResultCode", "=", "MessageDeliveryFailedEvent", ".", "UNKNOWN_ERROR", ";", "if", "(", "packet", ".", "getError", "(", ")", "!=", "null", ")", "{", "int", "errorCode", "=", "packet", ".", "getError", "(", ")", ".", "getCode", "(", ")", ";", "if", "(", "errorCode", "==", "503", ")", "{", "org", ".", "jivesoftware", ".", "smackx", ".", "packet", ".", "MessageEvent", "msgEvent", "=", "(", "org", ".", "jivesoftware", ".", "smackx", ".", "packet", ".", "MessageEvent", ")", "packet", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "jabber:x:event", "\"", ")", ";", "if", "(", "msgEvent", "!=", "null", "&&", "msgEvent", ".", "isOffline", "(", ")", ")", "{", "errorResultCode", "=", "MessageDeliveryFailedEvent", ".", "OFFLINE_MESSAGES_NOT_SUPPORTED", ";", "}", "}", "}", "if", "(", "sourceContact", "==", "null", ")", "{", "sourceContact", "=", "opSetPersPresence", ".", "createVolatileContact", "(", "userFullId", ",", "isPrivateMessaging", ")", ";", "}", "MessageDeliveryFailedEvent", "ev", "=", "new", "MessageDeliveryFailedEvent", "(", "newMessage", ",", "sourceContact", ",", "correctedMessageUID", ",", "errorResultCode", ")", ";", "if", "(", "ev", "!=", "null", ")", "fireMessageEvent", "(", "ev", ")", ";", "return", ";", "}", "putJidForAddress", "(", "userFullId", ",", "msg", ".", "getThread", "(", ")", ")", ";", "if", "(", "sourceContact", "==", "null", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "logger", ".", "debug", "(", "\"", "received a message from an unknown contact: ", "\"", "+", "userBareID", ")", ";", "sourceContact", "=", "opSetPersPresence", ".", "createVolatileContact", "(", "userFullId", ",", "isPrivateMessaging", ")", ";", "}", "Date", "timestamp", "=", "new", "Date", "(", ")", ";", "PacketExtension", "delay", "=", "msg", ".", "getExtension", "(", "\"", "x", "\"", ",", "\"", "jabber:x:delay", "\"", ")", ";", "if", "(", "delay", "!=", "null", "&&", "delay", "instanceof", "DelayInformation", ")", "{", "timestamp", "=", "(", "(", "DelayInformation", ")", "delay", ")", ".", "getStamp", "(", ")", ";", "}", "delay", "=", "msg", ".", "getExtension", "(", "\"", "delay", "\"", ",", "\"", "urn:xmpp:delay", "\"", ")", ";", "if", "(", "delay", "!=", "null", "&&", "delay", "instanceof", "DelayInfo", ")", "{", "timestamp", "=", "(", "(", "DelayInfo", ")", "delay", ")", ".", "getStamp", "(", ")", ";", "}", "ContactResource", "resource", "=", "(", "(", "ContactJabberImpl", ")", "sourceContact", ")", ".", "getResourceFromJid", "(", "userFullId", ")", ";", "EventObject", "msgEvt", "=", "null", ";", "if", "(", "!", "isForwardedSentMessage", ")", "msgEvt", "=", "new", "MessageReceivedEvent", "(", "newMessage", ",", "sourceContact", ",", "resource", ",", "timestamp", ",", "correctedMessageUID", ",", "isPrivateMessaging", ",", "privateContactRoom", ")", ";", "else", "msgEvt", "=", "new", "MessageDeliveredEvent", "(", "newMessage", ",", "sourceContact", ",", "timestamp", ")", ";", "if", "(", "msgEvt", "!=", "null", ")", "fireMessageEvent", "(", "msgEvt", ")", ";", "}"], "idx": 11699, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "7d66da61b316c9480b63000f831b6de723b87315", "function_name": "processPacket", "body_hash": "ad23f44b1f0659e2aa69facc559eb814ffcab40f"}
{"code": "@Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (origin != null) {\n            sb.append(\"remoteAddress=\").append(origin);\n        }\n        if (clientId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"clientId=\").append(clientId);\n        }\n        if (sessionId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"sessionId=\").append(sessionId);\n        }\n        return sb.toString();\n    }", "code_tokens": ["@", "Override", "public", "String", "toString", "(", ")", "{", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", ")", ";", "if", "(", "origin", "!=", "null", ")", "{", "sb", ".", "append", "(", "\"", "remoteAddress=", "\"", ")", ".", "append", "(", "origin", ")", ";", "}", "if", "(", "clientId", "!=", "null", ")", "{", "if", "(", "sb", ".", "length", "(", ")", ">", "0", ")", "{", "sb", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "sb", ".", "append", "(", "\"", "clientId=", "\"", ")", ".", "append", "(", "clientId", ")", ";", "}", "if", "(", "sessionId", "!=", "null", ")", "{", "if", "(", "sb", ".", "length", "(", ")", ">", "0", ")", "{", "sb", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "sb", ".", "append", "(", "\"", "sessionId=", "\"", ")", ".", "append", "(", "sessionId", ")", ";", "}", "return", "sb", ".", "toString", "(", ")", ";", "}"], "idx": 18721, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "a61bfabbad22f646ecf1f00016b448b26a60daf", "function_name": "toString", "body_hash": "36a2d5e0fadaf52115b9c2d53308fc15e16934bf"}
{"code": "public void changeApiToken() throws IOException {\n        user.checkPermission(Jenkins.ADMINISTER);\n        _changeApiToken();\n        if (user!=null)\n            user.save();\n    }", "code_tokens": ["public", "void", "changeApiToken", "(", ")", "throws", "IOException", "{", "user", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "_changeApiToken", "(", ")", ";", "if", "(", "user", "!=", "null", ")", "user", ".", "save", "(", ")", ";", "}"], "idx": 2511, "cwe": "CWE-17", "target": 0, "status": "FIXED", "commit": "57e78880cc035874bda916ef4d8d7fd7642af9db", "function_name": "changeApiToken", "body_hash": "415f03ebb08fef307e87455c256c0aead648c9cc"}
{"code": "public SendfileState processSendfile(SelectionKey sk, KeyAttachment attachment,\n                boolean calledByProcessor) {\n            NioChannel sc = null;\n            try {\n                unreg(sk, attachment, sk.readyOps());\n                SendfileData sd = attachment.getSendfileData();\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing send file for: \" + sd.fileName);\n                }\n\n                if (sd.fchannel == null) {\n                    // Setup the file channel\n                    File f = new File(sd.fileName);\n                    if (!f.exists()) {\n                        cancelledKey(sk,SocketStatus.ERROR);\n                        return SendfileState.ERROR;\n                    }\n                    @SuppressWarnings(\"resource\") // Closed when channel is closed\n                    FileInputStream fis = new FileInputStream(f);\n                    sd.fchannel = fis.getChannel();\n                }\n\n                // Configure output channel\n                sc = attachment.getSocket();\n                // TLS/SSL channel is slightly different\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n\n                // We still have data in the buffer\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if (written > 0) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for: \"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {\n                        sd.fchannel.close();\n                    } catch (Exception ignore) {\n                    }\n                    // For calls from outside the Poller, the caller is\n                    // responsible for registering the socket for the\n                    // appropriate event(s) if sendfile completes.\n                    if (!calledByProcessor) {\n                        if (sd.keepAlive) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            reg(sk,attachment,SelectionKey.OP_READ);\n                        } else {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Send file connection is being closed\");\n                            }\n                            cancelledKey(sk,SocketStatus.STOP);\n                        }\n                    }\n                    return SendfileState.DONE;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                    }\n                    if (calledByProcessor) {\n                        add(attachment.getSocket(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                    return SendfileState.PENDING;\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR);\n                return SendfileState.ERROR;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR);\n                return SendfileState.ERROR;\n            }\n        }", "code_tokens": ["public", "SendfileState", "processSendfile", "(", "SelectionKey", "sk", ",", "KeyAttachment", "attachment", ",", "boolean", "calledByProcessor", ")", "{", "NioChannel", "sc", "=", "null", ";", "try", "{", "unreg", "(", "sk", ",", "attachment", ",", "sk", ".", "readyOps", "(", ")", ")", ";", "SendfileData", "sd", "=", "attachment", ".", "getSendfileData", "(", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Processing send file for: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "sd", ".", "fchannel", "==", "null", ")", "{", "File", "f", "=", "new", "File", "(", "sd", ".", "fileName", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ")", ";", "return", "SendfileState", ".", "ERROR", ";", "}", "@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "FileInputStream", "fis", "=", "new", "FileInputStream", "(", "f", ")", ";", "sd", ".", "fchannel", "=", "fis", ".", "getChannel", "(", ")", ";", "}", "sc", "=", "attachment", ".", "getSocket", "(", ")", ";", "WritableByteChannel", "wc", "=", "(", "(", "sc", "instanceof", "SecureNioChannel", ")", "?", "sc", ":", "sc", ".", "getIOChannel", "(", ")", ")", ";", "if", "(", "sc", ".", "getOutboundRemaining", "(", ")", ">", "0", ")", "{", "if", "(", "sc", ".", "flushOutbound", "(", ")", ")", "{", "attachment", ".", "access", "(", ")", ";", "}", "}", "else", "{", "long", "written", "=", "sd", ".", "fchannel", ".", "transferTo", "(", "sd", ".", "pos", ",", "sd", ".", "length", ",", "wc", ")", ";", "if", "(", "written", ">", "0", ")", "{", "sd", ".", "pos", "+=", "written", ";", "sd", ".", "length", "-=", "written", ";", "attachment", ".", "access", "(", ")", ";", "}", "else", "{", "if", "(", "sd", ".", "fchannel", ".", "size", "(", ")", "<=", "sd", ".", "pos", ")", "{", "throw", "new", "IOException", "(", "\"", "Sendfile configured to ", "\"", "+", "\"", "send more data than was available", "\"", ")", ";", "}", "}", "}", "if", "(", "sd", ".", "length", "<=", "0", "&&", "sc", ".", "getOutboundRemaining", "(", ")", "<=", "0", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file complete for: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "attachment", ".", "setSendfileData", "(", "null", ")", ";", "try", "{", "sd", ".", "fchannel", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "}", "if", "(", "!", "calledByProcessor", ")", "{", "if", "(", "sd", ".", "keepAlive", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection is keep alive, registering back for OP_READ", "\"", ")", ";", "}", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file connection is being closed", "\"", ")", ";", "}", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "STOP", ")", ";", "}", "}", "return", "SendfileState", ".", "DONE", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "OP_WRITE for sendfile: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "calledByProcessor", ")", "{", "add", "(", "attachment", ".", "getSocket", "(", ")", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "return", "SendfileState", ".", "PENDING", ";", "}", "}", "catch", "(", "IOException", "x", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Unable to complete sendfile request:", "\"", ",", "x", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ")", ";", "return", "SendfileState", ".", "ERROR", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"", "\"", ",", "t", ")", ";", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ")", ";", "return", "SendfileState", ".", "ERROR", ";", "}", "}"], "idx": 50716, "cwe": "CWE-388", "target": 1, "status": "VULNERABLE", "commit": "3dd2fec73e0de1edc1d3eb1c52a01255fdfc84e7", "function_name": "processSendfile", "body_hash": "2490ce82021dd628cde33e8195c2835380bc99bf"}
{"code": "public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 || isSeparator(fileName.charAt(2)) == false) {\n                    return 2;\n                }\n                return 3;\n            } else if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        } else if (isSeparator(ch0) && isSeparator(ch1)) {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n                return NOT_FOUND;\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        } else {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n    }", "code_tokens": ["public", "static", "int", "getPrefixLength", "(", "final", "String", "fileName", ")", "{", "if", "(", "fileName", "==", "null", ")", "{", "return", "NOT_FOUND", ";", "}", "final", "int", "len", "=", "fileName", ".", "length", "(", ")", ";", "if", "(", "len", "==", "0", ")", "{", "return", "0", ";", "}", "char", "ch0", "=", "fileName", ".", "charAt", "(", "0", ")", ";", "if", "(", "ch0", "==", "':'", ")", "{", "return", "NOT_FOUND", ";", "}", "if", "(", "len", "==", "1", ")", "{", "if", "(", "ch0", "==", "'~'", ")", "{", "return", "2", ";", "}", "return", "isSeparator", "(", "ch0", ")", "?", "1", ":", "0", ";", "}", "if", "(", "ch0", "==", "'~'", ")", "{", "int", "posUnix", "=", "fileName", ".", "indexOf", "(", "UNIX_SEPARATOR", ",", "1", ")", ";", "int", "posWin", "=", "fileName", ".", "indexOf", "(", "WINDOWS_SEPARATOR", ",", "1", ")", ";", "if", "(", "posUnix", "==", "NOT_FOUND", "&&", "posWin", "==", "NOT_FOUND", ")", "{", "return", "len", "+", "1", ";", "}", "posUnix", "=", "posUnix", "==", "NOT_FOUND", "?", "posWin", ":", "posUnix", ";", "posWin", "=", "posWin", "==", "NOT_FOUND", "?", "posUnix", ":", "posWin", ";", "return", "Math", ".", "min", "(", "posUnix", ",", "posWin", ")", "+", "1", ";", "}", "final", "char", "ch1", "=", "fileName", ".", "charAt", "(", "1", ")", ";", "if", "(", "ch1", "==", "':'", ")", "{", "ch0", "=", "Character", ".", "toUpperCase", "(", "ch0", ")", ";", "if", "(", "ch0", ">=", "'A'", "&&", "ch0", "<=", "'Z'", ")", "{", "if", "(", "len", "==", "2", "||", "isSeparator", "(", "fileName", ".", "charAt", "(", "2", ")", ")", "==", "false", ")", "{", "return", "2", ";", "}", "return", "3", ";", "}", "else", "if", "(", "ch0", "==", "UNIX_SEPARATOR", ")", "{", "return", "1", ";", "}", "return", "NOT_FOUND", ";", "}", "else", "if", "(", "isSeparator", "(", "ch0", ")", "&&", "isSeparator", "(", "ch1", ")", ")", "{", "int", "posUnix", "=", "fileName", ".", "indexOf", "(", "UNIX_SEPARATOR", ",", "2", ")", ";", "int", "posWin", "=", "fileName", ".", "indexOf", "(", "WINDOWS_SEPARATOR", ",", "2", ")", ";", "if", "(", "posUnix", "==", "NOT_FOUND", "&&", "posWin", "==", "NOT_FOUND", "||", "posUnix", "==", "2", "||", "posWin", "==", "2", ")", "{", "return", "NOT_FOUND", ";", "}", "posUnix", "=", "posUnix", "==", "NOT_FOUND", "?", "posWin", ":", "posUnix", ";", "posWin", "=", "posWin", "==", "NOT_FOUND", "?", "posUnix", ":", "posWin", ";", "return", "Math", ".", "min", "(", "posUnix", ",", "posWin", ")", "+", "1", ";", "}", "else", "{", "return", "isSeparator", "(", "ch0", ")", "?", "1", ":", "0", ";", "}", "}"], "idx": 27045, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "2736b6fe", "function_name": "getPrefixLength", "body_hash": "2a1d6314368aec5fa4f76f0181377c97f2e6a358"}
{"code": "public static boolean isCsrfTokenValid(VaadinSession session,\n            String requestToken) {\n\n        if (session.getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String sessionToken = session.getCsrfToken();\n\n            if (sessionToken == null || !MessageDigest.isEqual(\n                    sessionToken.getBytes(StandardCharsets.UTF_8),\n                    requestToken.getBytes(StandardCharsets.UTF_8))) {\n                return false;\n            }\n        }\n        return true;\n    }", "code_tokens": ["public", "static", "boolean", "isCsrfTokenValid", "(", "VaadinSession", "session", ",", "String", "requestToken", ")", "{", "if", "(", "session", ".", "getService", "(", ")", ".", "getDeploymentConfiguration", "(", ")", ".", "isXsrfProtectionEnabled", "(", ")", ")", "{", "String", "sessionToken", "=", "session", ".", "getCsrfToken", "(", ")", ";", "if", "(", "sessionToken", "==", "null", "||", "!", "MessageDigest", ".", "isEqual", "(", "sessionToken", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ",", "requestToken", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "idx": 20424, "cwe": "CWE-203", "target": 0, "status": "FIXED", "commit": "232961bb05c787b0355c74f08b7939f2ec9b294a", "function_name": "isCsrfTokenValid", "body_hash": "3ac4f862c60463a65ad71e75c3f8c9ac64f9dc35"}
{"code": "static Document parseXML(InputStream pXmlFile) throws ParserException {\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    DocumentBuilder db = null;\n    try {\n      db = dbf.newDocumentBuilder();\n    }\n    catch (Exception se) {\n      throw new ParserException(\"XML Parser configuration error\", se);\n    }\n    org.w3c.dom.Document doc = null;\n    try {\n      doc = db.parse(pXmlFile);\n    }\n    catch (Exception se) {\n      throw new ParserException(\"Error parsing XML stream:\" + se, se);\n    }\n    return doc;\n  }", "code_tokens": ["static", "Document", "parseXML", "(", "InputStream", "pXmlFile", ")", "throws", "ParserException", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "DocumentBuilder", "db", "=", "null", ";", "try", "{", "db", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "}", "catch", "(", "Exception", "se", ")", "{", "throw", "new", "ParserException", "(", "\"", "XML Parser configuration error", "\"", ",", "se", ")", ";", "}", "org", ".", "w3c", ".", "dom", ".", "Document", "doc", "=", "null", ";", "try", "{", "doc", "=", "db", ".", "parse", "(", "pXmlFile", ")", ";", "}", "catch", "(", "Exception", "se", ")", "{", "throw", "new", "ParserException", "(", "\"", "Error parsing XML stream:", "\"", "+", "se", ",", "se", ")", ";", "}", "return", "doc", ";", "}"], "idx": 67654, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "3bba91131b5257e64b9d0a2193e1e32a145b2a2", "function_name": "parseXML", "body_hash": "cd831a7e1f2a0ce4cfb1ff88e8b8eb223900c305"}
{"code": "@SuppressWarnings(\"unchecked\")\n\tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n\n\t\tClass<?> returnValueClass = returnValue.getClass();\n\t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n\n\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n\t\t}\n\n\t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType = null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType = mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType != null) {\n\t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n\t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n\t}", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "protected", "<", "T", ">", "void", "writeWithMessageConverters", "(", "T", "returnValue", ",", "MethodParameter", "returnType", ",", "ServletServerHttpRequest", "inputMessage", ",", "ServletServerHttpResponse", "outputMessage", ")", "throws", "IOException", ",", "HttpMediaTypeNotAcceptableException", "{", "Class", "<", "?", ">", "returnValueClass", "=", "returnValue", ".", "getClass", "(", ")", ";", "HttpServletRequest", "servletRequest", "=", "inputMessage", ".", "getServletRequest", "(", ")", ";", "List", "<", "MediaType", ">", "requestedMediaTypes", "=", "getAcceptableMediaTypes", "(", "servletRequest", ")", ";", "List", "<", "MediaType", ">", "producibleMediaTypes", "=", "getProducibleMediaTypes", "(", "servletRequest", ",", "returnValueClass", ")", ";", "Set", "<", "MediaType", ">", "compatibleMediaTypes", "=", "new", "LinkedHashSet", "<", "MediaType", ">", "(", ")", ";", "for", "(", "MediaType", "requestedType", ":", "requestedMediaTypes", ")", "{", "for", "(", "MediaType", "producibleType", ":", "producibleMediaTypes", ")", "{", "if", "(", "requestedType", ".", "isCompatibleWith", "(", "producibleType", ")", ")", "{", "compatibleMediaTypes", ".", "add", "(", "getMostSpecificMediaType", "(", "requestedType", ",", "producibleType", ")", ")", ";", "}", "}", "}", "if", "(", "compatibleMediaTypes", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "HttpMediaTypeNotAcceptableException", "(", "producibleMediaTypes", ")", ";", "}", "List", "<", "MediaType", ">", "mediaTypes", "=", "new", "ArrayList", "<", "MediaType", ">", "(", "compatibleMediaTypes", ")", ";", "MediaType", ".", "sortBySpecificityAndQuality", "(", "mediaTypes", ")", ";", "MediaType", "selectedMediaType", "=", "null", ";", "for", "(", "MediaType", "mediaType", ":", "mediaTypes", ")", "{", "if", "(", "mediaType", ".", "isConcrete", "(", ")", ")", "{", "selectedMediaType", "=", "mediaType", ";", "break", ";", "}", "else", "if", "(", "mediaType", ".", "equals", "(", "MediaType", ".", "ALL", ")", "||", "mediaType", ".", "equals", "(", "MEDIA_TYPE_APPLICATION", ")", ")", "{", "selectedMediaType", "=", "MediaType", ".", "APPLICATION_OCTET_STREAM", ";", "break", ";", "}", "}", "if", "(", "selectedMediaType", "!=", "null", ")", "{", "selectedMediaType", "=", "selectedMediaType", ".", "removeQualityValue", "(", ")", ";", "for", "(", "HttpMessageConverter", "<", "?", ">", "messageConverter", ":", "this", ".", "messageConverters", ")", "{", "if", "(", "messageConverter", ".", "canWrite", "(", "returnValueClass", ",", "selectedMediaType", ")", ")", "{", "addContentDispositionHeader", "(", "inputMessage", ",", "outputMessage", ")", ";", "(", "(", "HttpMessageConverter", "<", "T", ">", ")", "messageConverter", ")", ".", "write", "(", "returnValue", ",", "selectedMediaType", ",", "outputMessage", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Written [", "\"", "+", "returnValue", "+", "\"", "] as ", "\\\"", "\"", "+", "selectedMediaType", "+", "\"", "\\\"", " using [", "\"", "+", "messageConverter", "+", "\"", "]", "\"", ")", ";", "}", "return", ";", "}", "}", "}", "throw", "new", "HttpMediaTypeNotAcceptableException", "(", "this", ".", "allSupportedMediaTypes", ")", ";", "}"], "idx": 64799, "cwe": "CWE-552", "target": 0, "status": "FIXED", "commit": "03f547eb9868f48f44d59b56067d4ac4740672c3", "function_name": "writeWithMessageConverters", "body_hash": "4250dc92ef51c219a84f9e13575c6d95b47503c4"}
{"code": "public SerializedInfoflowResults readResults(String fileName) throws XMLStreamException, IOException {\n\t\tSerializedInfoflowResults results = new SerializedInfoflowResults();\n\t\tInfoflowPerformanceData perfData = null;\n\n\t\tXMLStreamReader reader = null;\n\t\ttry (InputStream in = new FileInputStream(fileName)) {\n\t\t\treader = XMLInputFactory.newInstance().createXMLStreamReader(in);\n\n\t\t\tString statement = null;\n\t\t\tString method = null;\n\t\t\tString apValue = null;\n\t\t\tString apValueType = null;\n\t\t\tboolean apTaintSubFields = false;\n\t\t\tList<String> apFields = new ArrayList<>();\n\t\t\tList<String> apTypes = new ArrayList<>();\n\t\t\tSerializedAccessPath ap = null;\n\t\t\tSerializedSinkInfo sink = null;\n\t\t\tSerializedSourceInfo source = null;\n\t\t\tList<SerializedPathElement> pathElements = new ArrayList<>();\n\n\t\t\tStack<State> stateStack = new Stack<>();\n\t\t\tstateStack.push(State.init);\n\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\t// Read the next tag\n\t\t\t\treader.next();\n\t\t\t\tif (!reader.hasName())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (reader.getLocalName().equals(XmlConstants.Tags.root) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.init) {\n\t\t\t\t\tstateStack.push(State.dataFlowResults);\n\n\t\t\t\t\t// Load the attributes of the root node\n\t\t\t\t\tresults.setFileFormatVersion(\n\t\t\t\t\t\t\tint2Str(getAttributeByName(reader, XmlConstants.Attributes.fileFormatVersion)));\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.results) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.dataFlowResults) {\n\t\t\t\t\tstateStack.push(State.results);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.result) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.results) {\n\t\t\t\t\tstateStack.push(State.result);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.sink) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.result) {\n\t\t\t\t\tstateStack.push(State.sink);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.accessPath) && reader.isStartElement()) {\n\t\t\t\t\tstateStack.push(State.accessPath);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tapValue = getAttributeByName(reader, XmlConstants.Attributes.value);\n\t\t\t\t\tapValueType = getAttributeByName(reader, XmlConstants.Attributes.type);\n\t\t\t\t\tapTaintSubFields = getAttributeByName(reader, XmlConstants.Attributes.taintSubFields)\n\t\t\t\t\t\t\t.equals(XmlConstants.Values.TRUE);\n\n\t\t\t\t\t// Clear the fields\n\t\t\t\t\tapFields.clear();\n\t\t\t\t\tapTypes.clear();\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.fields) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.accessPath) {\n\t\t\t\t\tstateStack.push(State.fields);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.field) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.fields) {\n\t\t\t\t\tstateStack.push(State.field);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tString value = getAttributeByName(reader, XmlConstants.Attributes.value);\n\t\t\t\t\tString type = getAttributeByName(reader, XmlConstants.Attributes.type);\n\t\t\t\t\tif (value != null && !value.isEmpty() && type != null && !type.isEmpty()) {\n\t\t\t\t\t\tapFields.add(value);\n\t\t\t\t\t\tapTypes.add(value);\n\t\t\t\t\t}\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.sources) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.result) {\n\t\t\t\t\tstateStack.push(State.sources);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.source) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.sources) {\n\t\t\t\t\tstateStack.push(State.source);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t\tmethod = getAttributeByName(reader, XmlConstants.Attributes.method);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.taintPath) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.source) {\n\t\t\t\t\tstateStack.push(State.taintPath);\n\n\t\t\t\t\t// Clear the old state\n\t\t\t\t\tpathElements.clear();\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.pathElement) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.source) {\n\t\t\t\t\tstateStack.push(State.taintPath);\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t\tmethod = getAttributeByName(reader, XmlConstants.Attributes.method);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.performanceData) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.dataFlowResults) {\n\t\t\t\t\tstateStack.push(State.performanceData);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.performanceEntry) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.performanceData) {\n\t\t\t\t\tstateStack.push(State.performanceEntry);\n\n\t\t\t\t\t// We need a performance data object\n\t\t\t\t\tif (perfData == null)\n\t\t\t\t\t\tperfData = results.getOrCreatePerformanceData();\n\n\t\t\t\t\t// Read the attributes\n\t\t\t\t\tString perfName = getAttributeByName(reader, XmlConstants.Attributes.name);\n\t\t\t\t\tString perfValue = getAttributeByName(reader, XmlConstants.Attributes.value);\n\n\t\t\t\t\tswitch (perfName) {\n\t\t\t\t\tcase XmlConstants.Values.PERF_CALLGRAPH_SECONDS:\n\t\t\t\t\t\tperfData.setCallgraphConstructionSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_PATH_RECONSTRUCTION_SECONDS:\n\t\t\t\t\t\tperfData.setPathReconstructionSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_TAINT_PROPAGATION_SECONDS:\n\t\t\t\t\t\tperfData.setTaintPropagationSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_TOTAL_RUNTIME_SECONDS:\n\t\t\t\t\t\tperfData.setTotalRuntimeSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_MAX_MEMORY_CONSUMPTION:\n\t\t\t\t\t\tperfData.setMaxMemoryConsumption(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_SOURCE_COUNT:\n\t\t\t\t\t\tperfData.setSourceCount(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_SINK_COUNT:\n\t\t\t\t\t\tperfData.setSinkCount(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (reader.isEndElement()) {\n\t\t\t\t\tstateStack.pop();\n\n\t\t\t\t\tif (reader.getLocalName().equals(XmlConstants.Tags.accessPath))\n\t\t\t\t\t\tap = new SerializedAccessPath(apValue, apValueType, apTaintSubFields,\n\t\t\t\t\t\t\t\tapFields.toArray(new String[apFields.size()]),\n\t\t\t\t\t\t\t\tapTypes.toArray(new String[apTypes.size()]));\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.sink))\n\t\t\t\t\t\tsink = new SerializedSinkInfo(ap, statement, method);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.source))\n\t\t\t\t\t\tsource = new SerializedSourceInfo(ap, statement, method, pathElements);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.result))\n\t\t\t\t\t\tresults.addResult(source, sink);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.pathElement))\n\t\t\t\t\t\tpathElements.add(new SerializedPathElement(ap, statement, method));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn results;\n\t\t} finally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();\n\t\t}\n\t}", "code_tokens": ["public", "SerializedInfoflowResults", "readResults", "(", "String", "fileName", ")", "throws", "XMLStreamException", ",", "IOException", "{", "SerializedInfoflowResults", "results", "=", "new", "SerializedInfoflowResults", "(", ")", ";", "InfoflowPerformanceData", "perfData", "=", "null", ";", "XMLStreamReader", "reader", "=", "null", ";", "try", "(", "InputStream", "in", "=", "new", "FileInputStream", "(", "fileName", ")", ")", "{", "reader", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ".", "createXMLStreamReader", "(", "in", ")", ";", "String", "statement", "=", "null", ";", "String", "method", "=", "null", ";", "String", "apValue", "=", "null", ";", "String", "apValueType", "=", "null", ";", "boolean", "apTaintSubFields", "=", "false", ";", "List", "<", "String", ">", "apFields", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "String", ">", "apTypes", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "SerializedAccessPath", "ap", "=", "null", ";", "SerializedSinkInfo", "sink", "=", "null", ";", "SerializedSourceInfo", "source", "=", "null", ";", "List", "<", "SerializedPathElement", ">", "pathElements", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Stack", "<", "State", ">", "stateStack", "=", "new", "Stack", "<", ">", "(", ")", ";", "stateStack", ".", "push", "(", "State", ".", "init", ")", ";", "while", "(", "reader", ".", "hasNext", "(", ")", ")", "{", "reader", ".", "next", "(", ")", ";", "if", "(", "!", "reader", ".", "hasName", "(", ")", ")", "continue", ";", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "root", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "init", ")", "{", "stateStack", ".", "push", "(", "State", ".", "dataFlowResults", ")", ";", "results", ".", "setFileFormatVersion", "(", "int2Str", "(", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "fileFormatVersion", ")", ")", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "results", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "dataFlowResults", ")", "{", "stateStack", ".", "push", "(", "State", ".", "results", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "result", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "results", ")", "{", "stateStack", ".", "push", "(", "State", ".", "result", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "sink", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "result", ")", "{", "stateStack", ".", "push", "(", "State", ".", "sink", ")", ";", "statement", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "statement", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "accessPath", ")", "&&", "reader", ".", "isStartElement", "(", ")", ")", "{", "stateStack", ".", "push", "(", "State", ".", "accessPath", ")", ";", "apValue", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "value", ")", ";", "apValueType", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "type", ")", ";", "apTaintSubFields", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "taintSubFields", ")", ".", "equals", "(", "XmlConstants", ".", "Values", ".", "TRUE", ")", ";", "apFields", ".", "clear", "(", ")", ";", "apTypes", ".", "clear", "(", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "fields", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "accessPath", ")", "{", "stateStack", ".", "push", "(", "State", ".", "fields", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "field", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "fields", ")", "{", "stateStack", ".", "push", "(", "State", ".", "field", ")", ";", "String", "value", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "value", ")", ";", "String", "type", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "type", ")", ";", "if", "(", "value", "!=", "null", "&&", "!", "value", ".", "isEmpty", "(", ")", "&&", "type", "!=", "null", "&&", "!", "type", ".", "isEmpty", "(", ")", ")", "{", "apFields", ".", "add", "(", "value", ")", ";", "apTypes", ".", "add", "(", "value", ")", ";", "}", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "sources", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "result", ")", "{", "stateStack", ".", "push", "(", "State", ".", "sources", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "source", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "sources", ")", "{", "stateStack", ".", "push", "(", "State", ".", "source", ")", ";", "statement", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "statement", ")", ";", "method", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "method", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "taintPath", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "source", ")", "{", "stateStack", ".", "push", "(", "State", ".", "taintPath", ")", ";", "pathElements", ".", "clear", "(", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "pathElement", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "source", ")", "{", "stateStack", ".", "push", "(", "State", ".", "taintPath", ")", ";", "statement", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "statement", ")", ";", "method", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "method", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "performanceData", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "dataFlowResults", ")", "{", "stateStack", ".", "push", "(", "State", ".", "performanceData", ")", ";", "}", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "performanceEntry", ")", "&&", "reader", ".", "isStartElement", "(", ")", "&&", "stateStack", ".", "peek", "(", ")", "==", "State", ".", "performanceData", ")", "{", "stateStack", ".", "push", "(", "State", ".", "performanceEntry", ")", ";", "if", "(", "perfData", "==", "null", ")", "perfData", "=", "results", ".", "getOrCreatePerformanceData", "(", ")", ";", "String", "perfName", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "name", ")", ";", "String", "perfValue", "=", "getAttributeByName", "(", "reader", ",", "XmlConstants", ".", "Attributes", ".", "value", ")", ";", "switch", "(", "perfName", ")", "{", "case", "XmlConstants", ".", "Values", ".", "PERF_CALLGRAPH_SECONDS", ":", "perfData", ".", "setCallgraphConstructionSeconds", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_PATH_RECONSTRUCTION_SECONDS", ":", "perfData", ".", "setPathReconstructionSeconds", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_TAINT_PROPAGATION_SECONDS", ":", "perfData", ".", "setTaintPropagationSeconds", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_TOTAL_RUNTIME_SECONDS", ":", "perfData", ".", "setTotalRuntimeSeconds", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_MAX_MEMORY_CONSUMPTION", ":", "perfData", ".", "setMaxMemoryConsumption", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_SOURCE_COUNT", ":", "perfData", ".", "setSourceCount", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "case", "XmlConstants", ".", "Values", ".", "PERF_SINK_COUNT", ":", "perfData", ".", "setSinkCount", "(", "Integer", ".", "parseInt", "(", "perfValue", ")", ")", ";", "break", ";", "}", "}", "else", "if", "(", "reader", ".", "isEndElement", "(", ")", ")", "{", "stateStack", ".", "pop", "(", ")", ";", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "accessPath", ")", ")", "ap", "=", "new", "SerializedAccessPath", "(", "apValue", ",", "apValueType", ",", "apTaintSubFields", ",", "apFields", ".", "toArray", "(", "new", "String", "[", "apFields", ".", "size", "(", ")", "]", ")", ",", "apTypes", ".", "toArray", "(", "new", "String", "[", "apTypes", ".", "size", "(", ")", "]", ")", ")", ";", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "sink", ")", ")", "sink", "=", "new", "SerializedSinkInfo", "(", "ap", ",", "statement", ",", "method", ")", ";", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "source", ")", ")", "source", "=", "new", "SerializedSourceInfo", "(", "ap", ",", "statement", ",", "method", ",", "pathElements", ")", ";", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "result", ")", ")", "results", ".", "addResult", "(", "source", ",", "sink", ")", ";", "else", "if", "(", "reader", ".", "getLocalName", "(", ")", ".", "equals", "(", "XmlConstants", ".", "Tags", ".", "pathElement", ")", ")", "pathElements", ".", "add", "(", "new", "SerializedPathElement", "(", "ap", ",", "statement", ",", "method", ")", ")", ";", "}", "}", "return", "results", ";", "}", "finally", "{", "if", "(", "reader", "!=", "null", ")", "reader", ".", "close", "(", ")", ";", "}", "}"], "idx": 69020, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "b119180df13d69cc2fe3c84409e9e616d0eda653", "function_name": "readResults", "body_hash": "acf5bd9ea9880c7b98f7a03e9be31f730674920a"}
{"code": "@Test(timeout = 10000)\n    public void spliceToFile() throws Throwable {\n        EventLoopGroup group = new EpollEventLoopGroup(1);\n        File file = File.createTempFile(\"netty-splice\", null);\n        file.deleteOnExit();\n\n        SpliceHandler sh = new SpliceHandler(file);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.channel(EpollServerSocketChannel.class);\n        bs.group(group).childHandler(sh);\n        bs.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n        Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        Bootstrap cb = new Bootstrap();\n        cb.group(group);\n        cb.channel(EpollSocketChannel.class);\n        cb.handler(new ChannelInboundHandlerAdapter());\n        Channel cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();\n\n        for (int i = 0; i < data.length;) {\n            int length = Math.min(random.nextInt(1024 * 64), data.length - i);\n            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);\n            cc.writeAndFlush(buf);\n            i += length;\n        }\n\n        while (sh.future2 == null || !sh.future2.isDone() || !sh.future.isDone()) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        sc.close().sync();\n        cc.close().sync();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n\n        byte[] written = new byte[data.length];\n        FileInputStream in = new FileInputStream(file);\n\n        try {\n            Assert.assertEquals(written.length, in.read(written));\n            Assert.assertArrayEquals(data, written);\n        } finally {\n            in.close();\n            group.shutdownGracefully();\n        }\n    }", "code_tokens": ["@", "Test", "(", "timeout", "=", "10000", ")", "public", "void", "spliceToFile", "(", ")", "throws", "Throwable", "{", "EventLoopGroup", "group", "=", "new", "EpollEventLoopGroup", "(", "1", ")", ";", "File", "file", "=", "File", ".", "createTempFile", "(", "\"", "netty-splice", "\"", ",", "null", ")", ";", "file", ".", "deleteOnExit", "(", ")", ";", "SpliceHandler", "sh", "=", "new", "SpliceHandler", "(", "file", ")", ";", "ServerBootstrap", "bs", "=", "new", "ServerBootstrap", "(", ")", ";", "bs", ".", "channel", "(", "EpollServerSocketChannel", ".", "class", ")", ";", "bs", ".", "group", "(", "group", ")", ".", "childHandler", "(", "sh", ")", ";", "bs", ".", "childOption", "(", "EpollChannelOption", ".", "EPOLL_MODE", ",", "EpollMode", ".", "LEVEL_TRIGGERED", ")", ";", "Channel", "sc", "=", "bs", ".", "bind", "(", "NetUtil", ".", "LOCALHOST", ",", "0", ")", ".", "syncUninterruptibly", "(", ")", ".", "channel", "(", ")", ";", "Bootstrap", "cb", "=", "new", "Bootstrap", "(", ")", ";", "cb", ".", "group", "(", "group", ")", ";", "cb", ".", "channel", "(", "EpollSocketChannel", ".", "class", ")", ";", "cb", ".", "handler", "(", "new", "ChannelInboundHandlerAdapter", "(", ")", ")", ";", "Channel", "cc", "=", "cb", ".", "connect", "(", "sc", ".", "localAddress", "(", ")", ")", ".", "syncUninterruptibly", "(", ")", ".", "channel", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "data", ".", "length", ";", ")", "{", "int", "length", "=", "Math", ".", "min", "(", "random", ".", "nextInt", "(", "1024", "*", "64", ")", ",", "data", ".", "length", "-", "i", ")", ";", "ByteBuf", "buf", "=", "Unpooled", ".", "wrappedBuffer", "(", "data", ",", "i", ",", "length", ")", ";", "cc", ".", "writeAndFlush", "(", "buf", ")", ";", "i", "+=", "length", ";", "}", "while", "(", "sh", ".", "future2", "==", "null", "||", "!", "sh", ".", "future2", ".", "isDone", "(", ")", "||", "!", "sh", ".", "future", ".", "isDone", "(", ")", ")", "{", "if", "(", "sh", ".", "exception", ".", "get", "(", ")", "!=", "null", ")", "{", "break", ";", "}", "try", "{", "Thread", ".", "sleep", "(", "50", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "}", "}", "sc", ".", "close", "(", ")", ".", "sync", "(", ")", ";", "cc", ".", "close", "(", ")", ".", "sync", "(", ")", ";", "if", "(", "sh", ".", "exception", ".", "get", "(", ")", "!=", "null", "&&", "!", "(", "sh", ".", "exception", ".", "get", "(", ")", "instanceof", "IOException", ")", ")", "{", "throw", "sh", ".", "exception", ".", "get", "(", ")", ";", "}", "byte", "[", "]", "written", "=", "new", "byte", "[", "data", ".", "length", "]", ";", "FileInputStream", "in", "=", "new", "FileInputStream", "(", "file", ")", ";", "try", "{", "Assert", ".", "assertEquals", "(", "written", ".", "length", ",", "in", ".", "read", "(", "written", ")", ")", ";", "Assert", ".", "assertArrayEquals", "(", "data", ",", "written", ")", ";", "}", "finally", "{", "in", ".", "close", "(", ")", ";", "group", ".", "shutdownGracefully", "(", ")", ";", "}", "}"], "idx": 50041, "cwe": "CWE-378", "target": 1, "status": "VULNERABLE", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "spliceToFile", "body_hash": "dd383b09a95ea61b2bdfe843d09d2d173c1efe15"}
{"code": "public void sendFile(String url, Object body, String fileName) {\n        template.sendBodyAndHeader(url, body, Exchange.FILE_NAME, simple(fileName));\n    }", "code_tokens": ["public", "void", "sendFile", "(", "String", "url", ",", "Object", "body", ",", "String", "fileName", ")", "{", "template", ".", "sendBodyAndHeader", "(", "url", ",", "body", ",", "Exchange", ".", "FILE_NAME", ",", "simple", "(", "fileName", ")", ")", ";", "}"], "idx": 94837, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "2281b1f365c50ee1a470fb9990b753eadee9095", "function_name": "sendFile", "body_hash": "e6daf588c606d4fa64dcf7ee52bb150f2d214398"}
{"code": "@Override\n    public synchronized SSLEngineResult wrap(\n            final ByteBuffer[] srcs, final int offset, final int length, final ByteBuffer dst) throws SSLException {\n\n        // Check to make sure the engine has not been closed\n        if (isDestroyed()) {\n            return CLOSED_NOT_HANDSHAKING;\n        }\n\n        // Throw required runtime exceptions\n        if (srcs == null) {\n            throw new IllegalArgumentException(\"srcs is null\");\n        }\n        if (dst == null) {\n            throw new IllegalArgumentException(\"dst is null\");\n        }\n\n        if (offset >= srcs.length || offset + length > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + offset + \", length: \" + length +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n\n        if (dst.isReadOnly()) {\n            throw new ReadOnlyBufferException();\n        }\n\n        HandshakeStatus status = NOT_HANDSHAKING;\n        // Prepare OpenSSL to work in server mode and receive handshake\n        if (handshakeState != HandshakeState.FINISHED) {\n            if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                // Update accepted so we know we triggered the handshake via wrap\n                handshakeState = HandshakeState.STARTED_IMPLICITLY;\n            }\n\n            status = handshake();\n            if (status == NEED_UNWRAP) {\n                return NEED_UNWRAP_OK;\n            }\n\n            if (engineClosed) {\n                return NEED_UNWRAP_CLOSED;\n            }\n        }\n\n        int bytesProduced = 0;\n\n        // There was no pending data in the network BIO -- encrypt any application data\n        int bytesConsumed = 0;\n        int endOffset = offset + length;\n        for (int i = offset; i < endOffset; ++ i) {\n            final ByteBuffer src = srcs[i];\n            if (src == null) {\n                throw new IllegalArgumentException(\"srcs[\" + i + \"] is null\");\n            }\n            while (src.hasRemaining()) {\n\n                // Write plaintext application data to the SSL engine\n                int result = writePlaintextData(src);\n                if (result > 0) {\n                    bytesConsumed += result;\n                } else {\n                    int sslError = SSL.getError(ssl, result);\n                    switch (sslError) {\n                    case SSL.SSL_ERROR_ZERO_RETURN:\n                        // This means the connection was shutdown correctly, close inbound and outbound\n                        if (!receivedShutdown) {\n                            closeAll();\n                        }\n                        // fall-trough!\n                    case SSL.SSL_ERROR_WANT_READ:\n                    case SSL.SSL_ERROR_WANT_WRITE:\n                        // Break here as this means we need check if there is something pending in the BIO\n                        break;\n                    default:\n                        // Everything else is considered as error\n                        throw shutdownWithError(\"SSL_write\");\n                    }\n                }\n\n                SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                if (pendingNetResult != null) {\n                    return pendingNetResult;\n                }\n            }\n        }\n        // We need to check if pendingWrittenBytesInBIO was checked yet, as we may not checked if the srcs was empty,\n        // or only contained empty buffers.\n        if (bytesConsumed == 0) {\n            SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, bytesProduced, status);\n            if (pendingNetResult != null) {\n                return pendingNetResult;\n            }\n        }\n\n        return newResult(bytesConsumed, bytesProduced, status);\n    }", "code_tokens": ["@", "Override", "public", "synchronized", "SSLEngineResult", "wrap", "(", "final", "ByteBuffer", "[", "]", "srcs", ",", "final", "int", "offset", ",", "final", "int", "length", ",", "final", "ByteBuffer", "dst", ")", "throws", "SSLException", "{", "if", "(", "isDestroyed", "(", ")", ")", "{", "return", "CLOSED_NOT_HANDSHAKING", ";", "}", "if", "(", "srcs", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "srcs is null", "\"", ")", ";", "}", "if", "(", "dst", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "dst is null", "\"", ")", ";", "}", "if", "(", "offset", ">=", "srcs", ".", "length", "||", "offset", "+", "length", ">", "srcs", ".", "length", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", "\"", "offset: ", "\"", "+", "offset", "+", "\"", ", length: ", "\"", "+", "length", "+", "\"", " (expected: offset <= offset + length <= srcs.length (", "\"", "+", "srcs", ".", "length", "+", "\"", "))", "\"", ")", ";", "}", "if", "(", "dst", ".", "isReadOnly", "(", ")", ")", "{", "throw", "new", "ReadOnlyBufferException", "(", ")", ";", "}", "HandshakeStatus", "status", "=", "NOT_HANDSHAKING", ";", "if", "(", "handshakeState", "!=", "HandshakeState", ".", "FINISHED", ")", "{", "if", "(", "handshakeState", "!=", "HandshakeState", ".", "STARTED_EXPLICITLY", ")", "{", "handshakeState", "=", "HandshakeState", ".", "STARTED_IMPLICITLY", ";", "}", "status", "=", "handshake", "(", ")", ";", "if", "(", "status", "==", "NEED_UNWRAP", ")", "{", "return", "NEED_UNWRAP_OK", ";", "}", "if", "(", "engineClosed", ")", "{", "return", "NEED_UNWRAP_CLOSED", ";", "}", "}", "int", "bytesProduced", "=", "0", ";", "int", "bytesConsumed", "=", "0", ";", "int", "endOffset", "=", "offset", "+", "length", ";", "for", "(", "int", "i", "=", "offset", ";", "i", "<", "endOffset", ";", "++", "i", ")", "{", "final", "ByteBuffer", "src", "=", "srcs", "[", "i", "]", ";", "if", "(", "src", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "srcs[", "\"", "+", "i", "+", "\"", "] is null", "\"", ")", ";", "}", "while", "(", "src", ".", "hasRemaining", "(", ")", ")", "{", "int", "result", "=", "writePlaintextData", "(", "src", ")", ";", "if", "(", "result", ">", "0", ")", "{", "bytesConsumed", "+=", "result", ";", "}", "else", "{", "int", "sslError", "=", "SSL", ".", "getError", "(", "ssl", ",", "result", ")", ";", "switch", "(", "sslError", ")", "{", "case", "SSL", ".", "SSL_ERROR_ZERO_RETURN", ":", "if", "(", "!", "receivedShutdown", ")", "{", "closeAll", "(", ")", ";", "}", "case", "SSL", ".", "SSL_ERROR_WANT_READ", ":", "case", "SSL", ".", "SSL_ERROR_WANT_WRITE", ":", "break", ";", "default", ":", "throw", "shutdownWithError", "(", "\"", "SSL_write", "\"", ")", ";", "}", "}", "SSLEngineResult", "pendingNetResult", "=", "readPendingBytesFromBIO", "(", "dst", ",", "bytesConsumed", ",", "bytesProduced", ",", "status", ")", ";", "if", "(", "pendingNetResult", "!=", "null", ")", "{", "return", "pendingNetResult", ";", "}", "}", "}", "if", "(", "bytesConsumed", "==", "0", ")", "{", "SSLEngineResult", "pendingNetResult", "=", "readPendingBytesFromBIO", "(", "dst", ",", "0", ",", "bytesProduced", ",", "status", ")", ";", "if", "(", "pendingNetResult", "!=", "null", ")", "{", "return", "pendingNetResult", ";", "}", "}", "return", "newResult", "(", "bytesConsumed", ",", "bytesProduced", ",", "status", ")", ";", "}"], "idx": 82272, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "524156f164a910b8b0978d27a2c700a19cd8048", "function_name": "wrap", "body_hash": "3cb0f7d493a4b19b31b6513297a596139625fd4e"}
{"code": "protected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n        }\n\n        String dn = user.getDN();\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        // Start with roles retrieved from the user entry\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        // Are we configured to do role searches?\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        // Set up parameters for an appropriate search\n        String filter = connection.roleFormat.format(new String[] { doFilterEscaping(dn), username, userRoleId });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                nameParts[i] = name.get(i);\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        // Perform the configured search and process the results\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;  // Should never happen, but just in case ...\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n                }\n                String dname = getDistinguishedName(connection.context, roleBase, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n                }\n            }\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        // if nested group search is enabled, perform searches for nested groups until no new group is found\n        if (getRoleNested()) {\n\n            // The following efficient algorithm is known as memberOf Algorithm, as described in \"Practices in\n            // Directory Groups\". It avoids group slurping and handles cyclic group memberships as well.\n            // See http://middleware.internet2.edu/dir/ for details\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>(); // Stores the groups we find in this iteration\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    filter = connection.roleFormat.format(new String[] { doFilterEscaping(group.getKey()),\n                            group.getValue(), group.getValue() });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, roleBase, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n    }", "code_tokens": ["protected", "List", "<", "String", ">", "getRoles", "(", "JNDIConnection", "connection", ",", "User", "user", ")", "throws", "NamingException", "{", "if", "(", "user", "==", "null", ")", "{", "return", "null", ";", "}", "String", "dn", "=", "user", ".", "getDN", "(", ")", ";", "String", "username", "=", "user", ".", "getUserName", "(", ")", ";", "String", "userRoleId", "=", "user", ".", "getUserRoleId", "(", ")", ";", "if", "(", "dn", "==", "null", "||", "username", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  getRoles(", "\"", "+", "dn", "+", "\"", ")", "\"", ")", ";", "}", "List", "<", "String", ">", "list", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "String", ">", "userRoles", "=", "user", ".", "getRoles", "(", ")", ";", "if", "(", "userRoles", "!=", "null", ")", "{", "list", ".", "addAll", "(", "userRoles", ")", ";", "}", "if", "(", "commonRole", "!=", "null", ")", "{", "list", ".", "add", "(", "commonRole", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "list", ".", "size", "(", ")", "+", "\"", " user internal roles", "\"", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found user internal roles ", "\"", "+", "list", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "(", "connection", ".", "roleFormat", "==", "null", ")", "||", "(", "roleName", "==", "null", ")", ")", "{", "return", "list", ";", "}", "String", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "dn", ")", ",", "username", ",", "userRoleId", "}", ")", ";", "SearchControls", "controls", "=", "new", "SearchControls", "(", ")", ";", "if", "(", "roleSubtree", ")", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "}", "else", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "ONELEVEL_SCOPE", ")", ";", "}", "controls", ".", "setReturningAttributes", "(", "new", "String", "[", "]", "{", "roleName", "}", ")", ";", "String", "base", "=", "null", ";", "if", "(", "connection", ".", "roleBaseFormat", "!=", "null", ")", "{", "NameParser", "np", "=", "connection", ".", "context", ".", "getNameParser", "(", "\"", "\"", ")", ";", "Name", "name", "=", "np", ".", "parse", "(", "dn", ")", ";", "String", "nameParts", "[", "]", "=", "new", "String", "[", "name", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "name", ".", "size", "(", ")", ";", "i", "++", ")", "{", "nameParts", "[", "i", "]", "=", "name", ".", "get", "(", "i", ")", ";", "}", "base", "=", "connection", ".", "roleBaseFormat", ".", "format", "(", "nameParts", ")", ";", "}", "else", "{", "base", "=", "\"", "\"", ";", "}", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "base", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "if", "(", "results", "==", "null", ")", "{", "return", "list", ";", "}", "Map", "<", "String", ",", "String", ">", "groupMap", "=", "new", "HashMap", "<", ">", "(", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "Set", "<", "Entry", "<", "String", ",", "String", ">", ">", "entries", "=", "groupMap", ".", "entrySet", "(", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "entries", ".", "size", "(", ")", "+", "\"", " direct roles", "\"", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "entry", ":", "entries", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found direct role ", "\"", "+", "entry", ".", "getKey", "(", ")", "+", "\"", " -> ", "\"", "+", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}", "if", "(", "getRoleNested", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newGroups", "=", "new", "HashMap", "<", ">", "(", "groupMap", ")", ";", "while", "(", "!", "newGroups", ".", "isEmpty", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newThisRound", "=", "new", "HashMap", "<", ">", "(", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "group", ":", "newGroups", ".", "entrySet", "(", ")", ")", "{", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "group", ".", "getKey", "(", ")", ")", ",", "group", ".", "getValue", "(", ")", ",", "group", ".", "getValue", "(", ")", "}", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "Perform a nested group search with base ", "\"", "+", "roleBase", "+", "\"", " and filter ", "\"", "+", "filter", ")", ";", "}", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "roleBase", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", "&&", "!", "groupMap", ".", "keySet", "(", ")", ".", "contains", "(", "dname", ")", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "newThisRound", ".", "put", "(", "dname", ",", "name", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found nested role ", "\"", "+", "dname", "+", "\"", " -> ", "\"", "+", "name", ")", ";", "}", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "}", "newGroups", "=", "newThisRound", ";", "}", "}", "list", ".", "addAll", "(", "groupMap", ".", "values", "(", ")", ")", ";", "return", "list", ";", "}"], "idx": 548, "cwe": "CWE-116", "target": 1, "status": "VULNERABLE", "commit": "b930d0b3161d9ec78d5fa57f886ed2de4680518b", "function_name": "getRoles", "body_hash": "65acbc7a36d3efa2f73aaa48460df3644d0cb372"}
{"code": "private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                // If first byte is invalid, tail will be set to -1\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                // Additional checks to detect invalid sequences ASAP\n                // Checks derived from Unicode 6.2, Chapter 3, Table 3-7\n                // Check 2nd byte\n                int tailAvailable = inIndexLimit - inIndex - 1;\n                if (tailAvailable > 0) {\n                    // First byte C2..DF, second byte 80..BF\n                    if (jchar > 0x41 && jchar < 0x60 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E0, second byte A0..BF\n                    if (jchar == 0x60 && (bArr[inIndex + 1] & 0xE0) != 0xA0) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E1..EC, second byte 80..BF\n                    if (jchar > 0x60 && jchar < 0x6D &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte ED, second byte 80..9F\n                    if (jchar == 0x6D && (bArr[inIndex + 1] & 0xE0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte EE..EF, second byte 80..BF\n                    if (jchar > 0x6D && jchar < 0x70 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F0, second byte 90..BF\n                    if (jchar == 0x70 &&\n                            ((bArr[inIndex + 1] & 0xFF) < 0x90 ||\n                            (bArr[inIndex + 1] & 0xFF) > 0xBF)) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F1..F3, second byte 80..BF\n                    if (jchar > 0x70 && jchar < 0x74 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F4, second byte 80..8F\n                    if (jchar == 0x74 &&\n                            (bArr[inIndex + 1] & 0xF0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                }\n                // Check third byte if present and expected\n                if (tailAvailable > 1 && tail > 1) {\n                    if ((bArr[inIndex + 2] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(2);\n                    }\n                }\n                // Check fourth byte if present and expected\n                if (tailAvailable > 2 && tail > 2) {\n                    if ((bArr[inIndex + 3] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(3);\n                    }\n                }\n                if (tailAvailable < tail) {\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ?\n                CoderResult.OVERFLOW :\n                CoderResult.UNDERFLOW;\n    }", "code_tokens": ["private", "CoderResult", "decodeHasArray", "(", "ByteBuffer", "in", ",", "CharBuffer", "out", ")", "{", "int", "outRemaining", "=", "out", ".", "remaining", "(", ")", ";", "int", "pos", "=", "in", ".", "position", "(", ")", ";", "int", "limit", "=", "in", ".", "limit", "(", ")", ";", "final", "byte", "[", "]", "bArr", "=", "in", ".", "array", "(", ")", ";", "final", "char", "[", "]", "cArr", "=", "out", ".", "array", "(", ")", ";", "final", "int", "inIndexLimit", "=", "limit", "+", "in", ".", "arrayOffset", "(", ")", ";", "int", "inIndex", "=", "pos", "+", "in", ".", "arrayOffset", "(", ")", ";", "int", "outIndex", "=", "out", ".", "position", "(", ")", "+", "out", ".", "arrayOffset", "(", ")", ";", "for", "(", ";", "inIndex", "<", "inIndexLimit", "&&", "outRemaining", ">", "0", ";", "inIndex", "++", ")", "{", "int", "jchar", "=", "bArr", "[", "inIndex", "]", ";", "if", "(", "jchar", "<", "0", ")", "{", "jchar", "=", "jchar", "&", "0x7F", ";", "int", "tail", "=", "remainingBytes", "[", "jchar", "]", ";", "if", "(", "tail", "==", "-", "1", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "int", "tailAvailable", "=", "inIndexLimit", "-", "inIndex", "-", "1", ";", "if", "(", "tailAvailable", ">", "0", ")", "{", "if", "(", "jchar", ">", "0x41", "&&", "jchar", "<", "0x60", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", "==", "0x60", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xE0", ")", "!=", "0xA0", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", ">", "0x60", "&&", "jchar", "<", "0x6D", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", "==", "0x6D", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xE0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", ">", "0x6D", "&&", "jchar", "<", "0x70", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", "==", "0x70", "&&", "(", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xFF", ")", "<", "0x90", "||", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xFF", ")", ">", "0xBF", ")", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", ">", "0x70", "&&", "jchar", "<", "0x74", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "jchar", "==", "0x74", "&&", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xF0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "}", "if", "(", "tailAvailable", ">", "1", "&&", "tail", ">", "1", ")", "{", "if", "(", "(", "bArr", "[", "inIndex", "+", "2", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "2", ")", ";", "}", "}", "if", "(", "tailAvailable", ">", "2", "&&", "tail", ">", "2", ")", "{", "if", "(", "(", "bArr", "[", "inIndex", "+", "3", "]", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "3", ")", ";", "}", "}", "if", "(", "tailAvailable", "<", "tail", ")", "{", "break", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "tail", ";", "i", "++", ")", "{", "int", "nextByte", "=", "bArr", "[", "inIndex", "+", "i", "+", "1", "]", "&", "0xFF", ";", "if", "(", "(", "nextByte", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", "+", "i", ")", ";", "}", "jchar", "=", "(", "jchar", "<<", "6", ")", "+", "nextByte", ";", "}", "jchar", "-=", "remainingNumbers", "[", "tail", "]", ";", "if", "(", "jchar", "<", "lowerEncodingLimit", "[", "tail", "]", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "inIndex", "+=", "tail", ";", "}", "if", "(", "jchar", ">=", "0xD800", "&&", "jchar", "<=", "0xDFFF", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "3", ")", ";", "}", "if", "(", "jchar", ">", "0x10FFFF", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "4", ")", ";", "}", "if", "(", "jchar", "<=", "0xffff", ")", "{", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "jchar", ";", "outRemaining", "--", ";", "}", "else", "{", "if", "(", "outRemaining", "<", "2", ")", "{", "return", "CoderResult", ".", "OVERFLOW", ";", "}", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "(", "(", "jchar", ">>", "0xA", ")", "+", "0xD7C0", ")", ";", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "(", "(", "jchar", "&", "0x3FF", ")", "+", "0xDC00", ")", ";", "outRemaining", "-=", "2", ";", "}", "}", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "(", "outRemaining", "==", "0", "&&", "inIndex", "<", "inIndexLimit", ")", "?", "CoderResult", ".", "OVERFLOW", ":", "CoderResult", ".", "UNDERFLOW", ";", "}"], "idx": 82481, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "156d76a6afeef440d14044a560d6ad1d029361c4", "function_name": "decodeHasArray", "body_hash": "89ea854438f27541630c781a5d5aac7a5e4fee4a"}
{"code": "public SSOValidatorResponse validateSamlResponse(\n        org.opensaml.saml.saml2.core.Response samlResponse,\n        boolean postBinding\n    ) throws WSSecurityException {\n        // Check the Issuer\n        validateIssuer(samlResponse.getIssuer());\n\n        // The Response must contain at least one Assertion.\n        if (samlResponse.getAssertions() == null || samlResponse.getAssertions().isEmpty()) {\n            LOG.fine(\"The Response must contain at least one Assertion\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // The Response must contain a Destination that matches the assertionConsumerURL if it is\n        // signed\n        String destination = samlResponse.getDestination();\n        if (samlResponse.isSigned()\n            && (destination == null || !destination.equals(assertionConsumerURL))) {\n            LOG.fine(\"The Response must contain a destination that matches the assertion consumer URL\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Validate Assertions\n        boolean foundValidSubject = false;\n        Date sessionNotOnOrAfter = null;\n        for (org.opensaml.saml.saml2.core.Assertion assertion : samlResponse.getAssertions()) {\n            // Check the Issuer\n            if (assertion.getIssuer() == null) {\n                LOG.fine(\"Assertion Issuer must not be null\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            validateIssuer(assertion.getIssuer());\n            \n            if (enforceAssertionsSigned && postBinding && assertion.getSignature() == null) {\n                LOG.fine(\"If the HTTP Post binding is used to deliver the Response, \"\n                         + \"the enclosed assertions must be signed\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            \n            // Check for AuthnStatements and validate the Subject accordingly\n            if (assertion.getAuthnStatements() != null\n                && !assertion.getAuthnStatements().isEmpty()) {\n                org.opensaml.saml.saml2.core.Subject subject = assertion.getSubject();\n                if (validateAuthenticationSubject(subject, assertion.getID(), postBinding)) {\n                    validateAudienceRestrictionCondition(assertion.getConditions());\n                    foundValidSubject = true;\n                    // Store Session NotOnOrAfter\n                    for (AuthnStatement authnStatment : assertion.getAuthnStatements()) {\n                        if (authnStatment.getSessionNotOnOrAfter() != null) {\n                            sessionNotOnOrAfter = authnStatment.getSessionNotOnOrAfter().toDate();\n                        }\n                    }\n                }\n            }\n            \n        }\n        \n        if (!foundValidSubject) {\n            LOG.fine(\"The Response did not contain any Authentication Statement that matched \"\n                     + \"the Subject Confirmation criteria\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        SSOValidatorResponse validatorResponse = new SSOValidatorResponse();\n        validatorResponse.setResponseId(samlResponse.getID());\n        validatorResponse.setSessionNotOnOrAfter(sessionNotOnOrAfter);\n        if (samlResponse.getIssueInstant() != null) {\n            validatorResponse.setCreated(samlResponse.getIssueInstant().toDate());\n        }\n        \n        // the assumption for now is that SAMLResponse will contain only a single assertion\n        Element assertionElement = samlResponse.getAssertions().get(0).getDOM();\n        Element clonedAssertionElement = (Element)assertionElement.cloneNode(true);\n        validatorResponse.setAssertionElement(clonedAssertionElement);\n        validatorResponse.setAssertion(DOM2Writer.nodeToString(clonedAssertionElement));\n        \n        return validatorResponse;\n    }", "code_tokens": ["public", "SSOValidatorResponse", "validateSamlResponse", "(", "org", ".", "opensaml", ".", "saml", ".", "saml2", ".", "core", ".", "Response", "samlResponse", ",", "boolean", "postBinding", ")", "throws", "WSSecurityException", "{", "validateIssuer", "(", "samlResponse", ".", "getIssuer", "(", ")", ")", ";", "if", "(", "samlResponse", ".", "getAssertions", "(", ")", "==", "null", "||", "samlResponse", ".", "getAssertions", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "The Response must contain at least one Assertion", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "String", "destination", "=", "samlResponse", ".", "getDestination", "(", ")", ";", "if", "(", "samlResponse", ".", "isSigned", "(", ")", "&&", "(", "destination", "==", "null", "||", "!", "destination", ".", "equals", "(", "assertionConsumerURL", ")", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "The Response must contain a destination that matches the assertion consumer URL", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "boolean", "foundValidSubject", "=", "false", ";", "Date", "sessionNotOnOrAfter", "=", "null", ";", "for", "(", "org", ".", "opensaml", ".", "saml", ".", "saml2", ".", "core", ".", "Assertion", "assertion", ":", "samlResponse", ".", "getAssertions", "(", ")", ")", "{", "if", "(", "assertion", ".", "getIssuer", "(", ")", "==", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "Assertion Issuer must not be null", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "validateIssuer", "(", "assertion", ".", "getIssuer", "(", ")", ")", ";", "if", "(", "enforceAssertionsSigned", "&&", "postBinding", "&&", "assertion", ".", "getSignature", "(", ")", "==", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "If the HTTP Post binding is used to deliver the Response, ", "\"", "+", "\"", "the enclosed assertions must be signed", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "if", "(", "assertion", ".", "getAuthnStatements", "(", ")", "!=", "null", "&&", "!", "assertion", ".", "getAuthnStatements", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "org", ".", "opensaml", ".", "saml", ".", "saml2", ".", "core", ".", "Subject", "subject", "=", "assertion", ".", "getSubject", "(", ")", ";", "if", "(", "validateAuthenticationSubject", "(", "subject", ",", "assertion", ".", "getID", "(", ")", ",", "postBinding", ")", ")", "{", "validateAudienceRestrictionCondition", "(", "assertion", ".", "getConditions", "(", ")", ")", ";", "foundValidSubject", "=", "true", ";", "for", "(", "AuthnStatement", "authnStatment", ":", "assertion", ".", "getAuthnStatements", "(", ")", ")", "{", "if", "(", "authnStatment", ".", "getSessionNotOnOrAfter", "(", ")", "!=", "null", ")", "{", "sessionNotOnOrAfter", "=", "authnStatment", ".", "getSessionNotOnOrAfter", "(", ")", ".", "toDate", "(", ")", ";", "}", "}", "}", "}", "}", "if", "(", "!", "foundValidSubject", ")", "{", "LOG", ".", "fine", "(", "\"", "The Response did not contain any Authentication Statement that matched ", "\"", "+", "\"", "the Subject Confirmation criteria", "\"", ")", ";", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILURE", ",", "\"", "invalidSAMLsecurity", "\"", ")", ";", "}", "SSOValidatorResponse", "validatorResponse", "=", "new", "SSOValidatorResponse", "(", ")", ";", "validatorResponse", ".", "setResponseId", "(", "samlResponse", ".", "getID", "(", ")", ")", ";", "validatorResponse", ".", "setSessionNotOnOrAfter", "(", "sessionNotOnOrAfter", ")", ";", "if", "(", "samlResponse", ".", "getIssueInstant", "(", ")", "!=", "null", ")", "{", "validatorResponse", ".", "setCreated", "(", "samlResponse", ".", "getIssueInstant", "(", ")", ".", "toDate", "(", ")", ")", ";", "}", "Element", "assertionElement", "=", "samlResponse", ".", "getAssertions", "(", ")", ".", "get", "(", "0", ")", ".", "getDOM", "(", ")", ";", "Element", "clonedAssertionElement", "=", "(", "Element", ")", "assertionElement", ".", "cloneNode", "(", "true", ")", ";", "validatorResponse", ".", "setAssertionElement", "(", "clonedAssertionElement", ")", ";", "validatorResponse", ".", "setAssertion", "(", "DOM2Writer", ".", "nodeToString", "(", "clonedAssertionElement", ")", ")", ";", "return", "validatorResponse", ";", "}"], "idx": 33785, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "845eccb6484b43ba02875c71e824db23ae4f20c0", "function_name": "validateSamlResponse", "body_hash": "c68fcc7f1a4e242d2e1d88b675204c2d1feb2efa"}
{"code": "private void writeSession(SessionInformations session, boolean displayUser) throws IOException {\r\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\r\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\r\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\r\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\r\n\t\twrite(\"'>\");\r\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\r\n\t\twrite(\"</a>\");\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(durationFormat.format(session.getLastAccess()));\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(durationFormat.format(session.getAge()));\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\r\n\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(integerFormat.format(session.getAttributeCount()));\r\n\t\twrite(nextColumnAlignCenter);\r\n\t\tif (session.isSerializable()) {\r\n\t\t\twrite(\"#oui#\");\r\n\t\t} else {\r\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\r\n\t\t}\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(integerFormat.format(session.getSerializedSize()));\r\n\t\tfinal String nextColumn = \"</td><td>\";\r\n\t\twrite(nextColumn);\r\n\t\tfinal String remoteAddr = session.getRemoteAddr();\r\n\t\tif (remoteAddr == null) {\r\n\t\t\twrite(\"&nbsp;\");\r\n\t\t} else {\r\n\t\t\twrite(remoteAddr);\r\n\t\t}\r\n\t\twrite(nextColumnAlignCenter);\r\n\t\twriteCountry(session);\r\n\t\tif (displayUser) {\r\n\t\t\twrite(nextColumn);\r\n\t\t\tfinal String remoteUser = session.getRemoteUser();\r\n\t\t\tif (remoteUser == null) {\r\n\t\t\t\twrite(\"&nbsp;\");\r\n\t\t\t} else {\r\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\r\n\t\t\t}\r\n\t\t}\r\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\r\n\t\twrite(A_HREF_PART_SESSIONS);\r\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\r\n\t\twrite(urlEncode(session.getId()));\r\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\r\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\r\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\r\n\t\twrite(\"</a>\");\r\n\t\twrite(\"</td>\");\r\n\t}", "code_tokens": ["private", "void", "writeSession", "(", "SessionInformations", "session", ",", "boolean", "displayUser", ")", "throws", "IOException", "{", "final", "String", "nextColumnAlignRight", "=", "\"", "</td><td align='right'>", "\"", ";", "final", "String", "nextColumnAlignCenter", "=", "\"", "</td><td align='center'>", "\"", ";", "write", "(", "\"", "<td><a href='?part=sessions&amp;sessionId=", "\"", ")", ";", "write", "(", "htmlEncodeButNotSpace", "(", "session", ".", "getId", "(", ")", ")", ")", ";", "write", "(", "\"", "'>", "\"", ")", ";", "write", "(", "htmlEncodeButNotSpace", "(", "session", ".", "getId", "(", ")", ")", ")", ";", "write", "(", "\"", "</a>", "\"", ")", ";", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "durationFormat", ".", "format", "(", "session", ".", "getLastAccess", "(", ")", ")", ")", ";", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "durationFormat", ".", "format", "(", "session", ".", "getAge", "(", ")", ")", ")", ";", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "expiryFormat", ".", "format", "(", "session", ".", "getExpirationDate", "(", ")", ")", ")", ";", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "integerFormat", ".", "format", "(", "session", ".", "getAttributeCount", "(", ")", ")", ")", ";", "write", "(", "nextColumnAlignCenter", ")", ";", "if", "(", "session", ".", "isSerializable", "(", ")", ")", "{", "write", "(", "\"", "#oui#", "\"", ")", ";", "}", "else", "{", "write", "(", "\"", "<span class='severe'>#non#</span>", "\"", ")", ";", "}", "write", "(", "nextColumnAlignRight", ")", ";", "write", "(", "integerFormat", ".", "format", "(", "session", ".", "getSerializedSize", "(", ")", ")", ")", ";", "final", "String", "nextColumn", "=", "\"", "</td><td>", "\"", ";", "write", "(", "nextColumn", ")", ";", "final", "String", "remoteAddr", "=", "session", ".", "getRemoteAddr", "(", ")", ";", "if", "(", "remoteAddr", "==", "null", ")", "{", "write", "(", "\"", "&nbsp;", "\"", ")", ";", "}", "else", "{", "write", "(", "remoteAddr", ")", ";", "}", "write", "(", "nextColumnAlignCenter", ")", ";", "writeCountry", "(", "session", ")", ";", "if", "(", "displayUser", ")", "{", "write", "(", "nextColumn", ")", ";", "final", "String", "remoteUser", "=", "session", ".", "getRemoteUser", "(", ")", ";", "if", "(", "remoteUser", "==", "null", ")", "{", "write", "(", "\"", "&nbsp;", "\"", ")", ";", "}", "else", "{", "writeDirectly", "(", "htmlEncodeButNotSpace", "(", "remoteUser", ")", ")", ";", "}", "}", "write", "(", "\"", "</td><td align='center' class='noPrint'>", "\"", ")", ";", "write", "(", "A_HREF_PART_SESSIONS", ")", ";", "write", "(", "\"", "&amp;action=invalidate_session&amp;sessionId=", "\"", ")", ";", "write", "(", "urlEncode", "(", "session", ".", "getId", "(", ")", ")", ")", ";", "write", "(", "\"", "' onclick=", "\\\"", "javascript:return confirm('", "\"", "+", "getStringForJavascript", "(", "\"", "confirm_invalidate_session", "\"", ")", "+", "\"", "');", "\\\"", ">", "\"", ")", ";", "write", "(", "\"", "<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />", "\"", ")", ";", "write", "(", "\"", "</a>", "\"", ")", ";", "write", "(", "\"", "</td>", "\"", ")", ";", "}"], "idx": 79341, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "aacbc46151ff4ac1ca34ce0899c2a6113071c66e", "function_name": "writeSession", "body_hash": "7d83c80f83482d492d12b05f9f2107a344650dd2"}
{"code": "@Override\n        public void doFilter(final ServletRequest req, final ServletResponse resp, final FilterChain filterChain)\n                throws IOException, ServletException {\n\n            // set frame options accordingly\n            final HttpServletResponse response = (HttpServletResponse) resp;\n            response.addHeader(FRAME_OPTIONS, SAME_ORIGIN);\n\n            filterChain.doFilter(req, resp);\n        }", "code_tokens": ["@", "Override", "public", "void", "doFilter", "(", "final", "ServletRequest", "req", ",", "final", "ServletResponse", "resp", ",", "final", "FilterChain", "filterChain", ")", "throws", "IOException", ",", "ServletException", "{", "final", "HttpServletResponse", "response", "=", "(", "HttpServletResponse", ")", "resp", ";", "response", ".", "addHeader", "(", "FRAME_OPTIONS", ",", "SAME_ORIGIN", ")", ";", "filterChain", ".", "doFilter", "(", "req", ",", "resp", ")", ";", "}"], "idx": 27, "cwe": "CWE-1021", "target": 1, "status": "VULNERABLE", "commit": "dbf259508c2b8e176d8cb837177aaadbf44f0670", "function_name": "doFilter", "body_hash": "00c76ec500ef97ff4ea5767639b85268733466ab"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (xmlMapper != null) {\n            // must be a reference value\n            String ref = xmlMapper.startsWith(\"#\") ? xmlMapper : \"#\" + xmlMapper;\n            setProperty(camelContext, dataFormat, \"xmlMapper\", ref);\n        }\n        if (unmarshalType != null) {\n            setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n        }\n        if (prettyPrint != null) {\n            setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n        }\n        if (jsonView != null) {\n            setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n        }\n        if (include != null) {\n            setProperty(camelContext, dataFormat, \"include\", include);\n        }\n        if (allowJmsType != null) {\n            setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n        }\n        if (collectionType != null) {\n            setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n        }\n        if (useList != null) {\n            setProperty(camelContext, dataFormat, \"useList\", useList);\n        }\n        if (enableJaxbAnnotationModule != null) {\n            setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n        }\n        if (moduleClassNames != null) {\n            setProperty(camelContext, dataFormat, \"modulesClassNames\", moduleClassNames);\n        }\n        if (moduleRefs != null) {\n            setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n        }\n        if (enableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n        }\n        if (disableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "xmlMapper", "!=", "null", ")", "{", "String", "ref", "=", "xmlMapper", ".", "startsWith", "(", "\"", "#", "\"", ")", "?", "xmlMapper", ":", "\"", "#", "\"", "+", "xmlMapper", ";", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "xmlMapper", "\"", ",", "ref", ")", ";", "}", "if", "(", "unmarshalType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "unmarshalType", "\"", ",", "unmarshalType", ")", ";", "}", "if", "(", "prettyPrint", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "prettyPrint", "\"", ",", "prettyPrint", ")", ";", "}", "if", "(", "jsonView", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "jsonView", "\"", ",", "jsonView", ")", ";", "}", "if", "(", "include", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "include", "\"", ",", "include", ")", ";", "}", "if", "(", "allowJmsType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowJmsType", "\"", ",", "allowJmsType", ")", ";", "}", "if", "(", "collectionType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "collectionType", "\"", ",", "collectionType", ")", ";", "}", "if", "(", "useList", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "useList", "\"", ",", "useList", ")", ";", "}", "if", "(", "enableJaxbAnnotationModule", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableJaxbAnnotationModule", "\"", ",", "enableJaxbAnnotationModule", ")", ";", "}", "if", "(", "moduleClassNames", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "modulesClassNames", "\"", ",", "moduleClassNames", ")", ";", "}", "if", "(", "moduleRefs", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "moduleRefs", "\"", ",", "moduleRefs", ")", ";", "}", "if", "(", "enableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableFeatures", "\"", ",", "enableFeatures", ")", ";", "}", "if", "(", "disableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "disableFeatures", "\"", ",", "disableFeatures", ")", ";", "}", "}"], "idx": 57368, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "5ae9c0dcc4843347cd01ffb58ce5dd0687755a1", "function_name": "configureDataFormat", "body_hash": "b6631563e66dab8175088dff4c28c53d9cad9567"}
{"code": "protected void doSend(HttpServletResponse response)\n            throws IOException {\n\n        response.setContentType(\"text/html\");\n        response.setCharacterEncoding(\"UTF-8\");\n\n        // get changelog\n        changes.insert(0, \"<pre>\");\n        changes.append(\"</pre>\");\n        setProperty(PN_CHANGE_LOG, changes.toString());\n\n        Writer out = response.getWriter();\n        InputStream template = getClass().getResourceAsStream(TEMPLATE_NAME);\n        Reader in = new BufferedReader(new InputStreamReader(template));\n        StringBuffer varBuffer = new StringBuffer();\n        int state = 0;\n        int read;\n        while ((read = in.read()) >= 0) {\n            char c = (char) read;\n            switch (state) {\n                // initial\n                case 0:\n                    if (c == '$') {\n                        state = 1;\n                    } else {\n                        out.write(c);\n                    }\n                    break;\n                // $ read\n                case 1:\n                    if (c == '{') {\n                        state = 2;\n                    } else {\n                        state = 0;\n                        out.write('$');\n                        out.write(c);\n                    }\n                    break;\n                // { read\n                case 2:\n                    if (c == '}') {\n                        state = 0;\n                        Object prop = getProperty(varBuffer.toString());\n                        if (prop != null) {\n                            out.write(htmlEscape(prop.toString()));\n                        }\n                        varBuffer.setLength(0);\n                    } else {\n                        varBuffer.append(c);\n                    }\n            }\n        }\n        in.close();\n        out.flush();\n    }", "code_tokens": ["protected", "void", "doSend", "(", "HttpServletResponse", "response", ")", "throws", "IOException", "{", "response", ".", "setContentType", "(", "\"", "text/html", "\"", ")", ";", "response", ".", "setCharacterEncoding", "(", "\"", "UTF-8", "\"", ")", ";", "changes", ".", "insert", "(", "0", ",", "\"", "<pre>", "\"", ")", ";", "changes", ".", "append", "(", "\"", "</pre>", "\"", ")", ";", "setProperty", "(", "PN_CHANGE_LOG", ",", "changes", ".", "toString", "(", ")", ")", ";", "Writer", "out", "=", "response", ".", "getWriter", "(", ")", ";", "InputStream", "template", "=", "getClass", "(", ")", ".", "getResourceAsStream", "(", "TEMPLATE_NAME", ")", ";", "Reader", "in", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "template", ")", ")", ";", "StringBuffer", "varBuffer", "=", "new", "StringBuffer", "(", ")", ";", "int", "state", "=", "0", ";", "int", "read", ";", "while", "(", "(", "read", "=", "in", ".", "read", "(", ")", ")", ">=", "0", ")", "{", "char", "c", "=", "(", "char", ")", "read", ";", "switch", "(", "state", ")", "{", "case", "0", ":", "if", "(", "c", "==", "'$'", ")", "{", "state", "=", "1", ";", "}", "else", "{", "out", ".", "write", "(", "c", ")", ";", "}", "break", ";", "case", "1", ":", "if", "(", "c", "==", "'{'", ")", "{", "state", "=", "2", ";", "}", "else", "{", "state", "=", "0", ";", "out", ".", "write", "(", "'$'", ")", ";", "out", ".", "write", "(", "c", ")", ";", "}", "break", ";", "case", "2", ":", "if", "(", "c", "==", "'}'", ")", "{", "state", "=", "0", ";", "Object", "prop", "=", "getProperty", "(", "varBuffer", ".", "toString", "(", ")", ")", ";", "if", "(", "prop", "!=", "null", ")", "{", "out", ".", "write", "(", "htmlEscape", "(", "prop", ".", "toString", "(", ")", ")", ")", ";", "}", "varBuffer", ".", "setLength", "(", "0", ")", ";", "}", "else", "{", "varBuffer", ".", "append", "(", "c", ")", ";", "}", "}", "}", "in", ".", "close", "(", ")", ";", "out", ".", "flush", "(", ")", ";", "}"], "idx": 81317, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "fef65236bd9567e2982a43e3d188c425a1cb7537", "function_name": "doSend", "body_hash": "09fe59c33fa9830c8669e9c0c87c9ac7eb036ac1"}
{"code": "protected void scanExternalID(String[] identifiers,\n                                  boolean optionalSystemId)\n        throws IOException, XNIException {\n\n        String systemId = null;\n        String publicId = null;\n        if (fEntityScanner.skipString(\"PUBLIC\")) {\n            if (!fEntityScanner.skipSpaces()) {\n                reportFatalError(\"SpaceRequiredAfterPUBLIC\", null);\n            }\n            scanPubidLiteral(fString);\n            publicId = fString.toString();\n\n            if (!fEntityScanner.skipSpaces() && !optionalSystemId) {\n                reportFatalError(\"SpaceRequiredBetweenPublicAndSystem\", null);\n            }\n        }\n\n        if (publicId != null || fEntityScanner.skipString(\"SYSTEM\")) {\n            if (publicId == null && !fEntityScanner.skipSpaces()) {\n                reportFatalError(\"SpaceRequiredAfterSYSTEM\", null);\n            }\n            int quote = fEntityScanner.peekChar();\n            if (quote != '\\'' && quote != '\"') {\n                if (publicId != null && optionalSystemId) {\n                    // looks like we don't have any system id\n                    // simply return the public id\n                    identifiers[0] = null;\n                    identifiers[1] = publicId;\n                    return;\n                }\n                reportFatalError(\"QuoteRequiredInSystemID\", null);\n            }\n            fEntityScanner.scanChar();\n            XMLString ident = fString;\n            if (fEntityScanner.scanLiteral(quote, ident) != quote) {\n                fStringBuffer.clear();\n                do {\n                    fStringBuffer.append(ident);\n                    int c = fEntityScanner.peekChar();\n                    if (XMLChar.isMarkup(c) || c == ']') {\n                        fStringBuffer.append((char)fEntityScanner.scanChar());\n                    }\n                    else if (XMLChar.isHighSurrogate(c)) {\n                        scanSurrogates(fStringBuffer);\n                    }\n                    else if (isInvalidLiteral(c)) {\n                        reportFatalError(\"InvalidCharInSystemID\",\n                                new Object[] { Integer.toHexString(c) }); \n                        fEntityScanner.scanChar();\n                    }\n                } while (fEntityScanner.scanLiteral(quote, ident) != quote);\n                fStringBuffer.append(ident);\n                ident = fStringBuffer;\n            }\n            systemId = ident.toString();\n            if (!fEntityScanner.skipChar(quote)) {\n                reportFatalError(\"SystemIDUnterminated\", null);\n            }\n        }\n\n        // store result in array\n        identifiers[0] = systemId;\n        identifiers[1] = publicId;\n    }", "code_tokens": ["protected", "void", "scanExternalID", "(", "String", "[", "]", "identifiers", ",", "boolean", "optionalSystemId", ")", "throws", "IOException", ",", "XNIException", "{", "String", "systemId", "=", "null", ";", "String", "publicId", "=", "null", ";", "if", "(", "fEntityScanner", ".", "skipString", "(", "\"", "PUBLIC", "\"", ")", ")", "{", "if", "(", "!", "fEntityScanner", ".", "skipSpaces", "(", ")", ")", "{", "reportFatalError", "(", "\"", "SpaceRequiredAfterPUBLIC", "\"", ",", "null", ")", ";", "}", "scanPubidLiteral", "(", "fString", ")", ";", "publicId", "=", "fString", ".", "toString", "(", ")", ";", "if", "(", "!", "fEntityScanner", ".", "skipSpaces", "(", ")", "&&", "!", "optionalSystemId", ")", "{", "reportFatalError", "(", "\"", "SpaceRequiredBetweenPublicAndSystem", "\"", ",", "null", ")", ";", "}", "}", "if", "(", "publicId", "!=", "null", "||", "fEntityScanner", ".", "skipString", "(", "\"", "SYSTEM", "\"", ")", ")", "{", "if", "(", "publicId", "==", "null", "&&", "!", "fEntityScanner", ".", "skipSpaces", "(", ")", ")", "{", "reportFatalError", "(", "\"", "SpaceRequiredAfterSYSTEM", "\"", ",", "null", ")", ";", "}", "int", "quote", "=", "fEntityScanner", ".", "peekChar", "(", ")", ";", "if", "(", "quote", "!=", "'\\''", "&&", "quote", "!=", "'\"'", ")", "{", "if", "(", "publicId", "!=", "null", "&&", "optionalSystemId", ")", "{", "identifiers", "[", "0", "]", "=", "null", ";", "identifiers", "[", "1", "]", "=", "publicId", ";", "return", ";", "}", "reportFatalError", "(", "\"", "QuoteRequiredInSystemID", "\"", ",", "null", ")", ";", "}", "fEntityScanner", ".", "scanChar", "(", ")", ";", "XMLString", "ident", "=", "fString", ";", "if", "(", "fEntityScanner", ".", "scanLiteral", "(", "quote", ",", "ident", ")", "!=", "quote", ")", "{", "fStringBuffer", ".", "clear", "(", ")", ";", "do", "{", "fStringBuffer", ".", "append", "(", "ident", ")", ";", "int", "c", "=", "fEntityScanner", ".", "peekChar", "(", ")", ";", "if", "(", "XMLChar", ".", "isMarkup", "(", "c", ")", "||", "c", "==", "']'", ")", "{", "fStringBuffer", ".", "append", "(", "(", "char", ")", "fEntityScanner", ".", "scanChar", "(", ")", ")", ";", "}", "else", "if", "(", "XMLChar", ".", "isHighSurrogate", "(", "c", ")", ")", "{", "scanSurrogates", "(", "fStringBuffer", ")", ";", "}", "else", "if", "(", "isInvalidLiteral", "(", "c", ")", ")", "{", "reportFatalError", "(", "\"", "InvalidCharInSystemID", "\"", ",", "new", "Object", "[", "]", "{", "Integer", ".", "toHexString", "(", "c", ")", "}", ")", ";", "fEntityScanner", ".", "scanChar", "(", ")", ";", "}", "}", "while", "(", "fEntityScanner", ".", "scanLiteral", "(", "quote", ",", "ident", ")", "!=", "quote", ")", ";", "fStringBuffer", ".", "append", "(", "ident", ")", ";", "ident", "=", "fStringBuffer", ";", "}", "systemId", "=", "ident", ".", "toString", "(", ")", ";", "if", "(", "!", "fEntityScanner", ".", "skipChar", "(", "quote", ")", ")", "{", "reportFatalError", "(", "\"", "SystemIDUnterminated", "\"", ",", "null", ")", ";", "}", "}", "identifiers", "[", "0", "]", "=", "systemId", ";", "identifiers", "[", "1", "]", "=", "publicId", ";", "}"], "idx": 115351, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "0bdf77af1d4fd26ec2e630fb6d12e2dfa77bc12b", "function_name": "scanExternalID", "body_hash": "b0db00a4d8af3ad2af3fd002f7cf737d5f787499"}
{"code": "@Path(\"{id}\")\n    @PUT\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response updateUser(final @PathParam(\"id\") String id, final UserRepresentation rep) {\n        auth.requireManage();\n\n        try {\n            UserModel user = session.users().getUserById(id, realm);\n            if (user == null) {\n                return Response.status(Status.NOT_FOUND).build();\n            }\n\n            Set<String> attrsToRemove;\n            if (rep.getAttributes() != null) {\n                attrsToRemove = new HashSet<>(user.getAttributes().keySet());\n                attrsToRemove.removeAll(rep.getAttributes().keySet());\n            } else {\n                attrsToRemove = Collections.emptySet();\n            }\n\n            if (rep.isEnabled() != null && rep.isEnabled()) {\n                UserLoginFailureModel failureModel = session.sessions().getUserLoginFailure(realm, id);\n                if (failureModel != null) {\n                    failureModel.clearFailures();\n                }\n            }\n\n            updateUserFromRep(user, rep, attrsToRemove, realm, session, true);\n            adminEvent.operation(OperationType.UPDATE).resourcePath(uriInfo).representation(rep).success();\n\n            if (session.getTransactionManager().isActive()) {\n                session.getTransactionManager().commit();\n            }\n            return Response.noContent().build();\n        } catch (ModelDuplicateException e) {\n            return ErrorResponse.exists(\"User exists with same username or email\");\n        } catch (ModelReadOnlyException re) {\n            return ErrorResponse.exists(\"User is read only!\");\n        } catch (ModelException me) {\n            return ErrorResponse.exists(\"Could not update user!\");\n        } catch (Exception me) { // JPA may be committed by JTA which can't \n            return ErrorResponse.exists(\"Could not update user!\");\n        }\n    }", "code_tokens": ["@", "Path", "(", "\"", "{id}", "\"", ")", "@", "PUT", "@", "Consumes", "(", "MediaType", ".", "APPLICATION_JSON", ")", "public", "Response", "updateUser", "(", "final", "@", "PathParam", "(", "\"", "id", "\"", ")", "String", "id", ",", "final", "UserRepresentation", "rep", ")", "{", "auth", ".", "requireManage", "(", ")", ";", "try", "{", "UserModel", "user", "=", "session", ".", "users", "(", ")", ".", "getUserById", "(", "id", ",", "realm", ")", ";", "if", "(", "user", "==", "null", ")", "{", "return", "Response", ".", "status", "(", "Status", ".", "NOT_FOUND", ")", ".", "build", "(", ")", ";", "}", "Set", "<", "String", ">", "attrsToRemove", ";", "if", "(", "rep", ".", "getAttributes", "(", ")", "!=", "null", ")", "{", "attrsToRemove", "=", "new", "HashSet", "<", ">", "(", "user", ".", "getAttributes", "(", ")", ".", "keySet", "(", ")", ")", ";", "attrsToRemove", ".", "removeAll", "(", "rep", ".", "getAttributes", "(", ")", ".", "keySet", "(", ")", ")", ";", "}", "else", "{", "attrsToRemove", "=", "Collections", ".", "emptySet", "(", ")", ";", "}", "if", "(", "rep", ".", "isEnabled", "(", ")", "!=", "null", "&&", "rep", ".", "isEnabled", "(", ")", ")", "{", "UserLoginFailureModel", "failureModel", "=", "session", ".", "sessions", "(", ")", ".", "getUserLoginFailure", "(", "realm", ",", "id", ")", ";", "if", "(", "failureModel", "!=", "null", ")", "{", "failureModel", ".", "clearFailures", "(", ")", ";", "}", "}", "updateUserFromRep", "(", "user", ",", "rep", ",", "attrsToRemove", ",", "realm", ",", "session", ",", "true", ")", ";", "adminEvent", ".", "operation", "(", "OperationType", ".", "UPDATE", ")", ".", "resourcePath", "(", "uriInfo", ")", ".", "representation", "(", "rep", ")", ".", "success", "(", ")", ";", "if", "(", "session", ".", "getTransactionManager", "(", ")", ".", "isActive", "(", ")", ")", "{", "session", ".", "getTransactionManager", "(", ")", ".", "commit", "(", ")", ";", "}", "return", "Response", ".", "noContent", "(", ")", ".", "build", "(", ")", ";", "}", "catch", "(", "ModelDuplicateException", "e", ")", "{", "return", "ErrorResponse", ".", "exists", "(", "\"", "User exists with same username or email", "\"", ")", ";", "}", "catch", "(", "ModelReadOnlyException", "re", ")", "{", "return", "ErrorResponse", ".", "exists", "(", "\"", "User is read only!", "\"", ")", ";", "}", "catch", "(", "ModelException", "me", ")", "{", "return", "ErrorResponse", ".", "exists", "(", "\"", "Could not update user!", "\"", ")", ";", "}", "catch", "(", "Exception", "me", ")", "{", "return", "ErrorResponse", ".", "exists", "(", "\"", "Could not update user!", "\"", ")", ";", "}", "}"], "idx": 34073, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "a78cfa4b2ca979a1981fb371cfdf2c7212f7b6e2", "function_name": "updateUser", "body_hash": "fee7c8a428debdfb7d45eff6d7004830b09c015f"}
{"code": "private void unzip(File dir, File zipFile) throws IOException {\n        dir = dir.getAbsoluteFile();    // without absolutization, getParentFile below seems to fail\n        ZipFile zip = new ZipFile(zipFile);\n        @SuppressWarnings(\"unchecked\")\n        Enumeration<ZipEntry> entries = zip.getEntries();\n\n        try {\n            while (entries.hasMoreElements()) {\n                ZipEntry e = entries.nextElement();\n                File f = new File(dir, e.getName());\n                if (!f.toPath().normalize().startsWith(dir.toPath())) {\n                    throw new IOException(\n                        \"Zip \" + zipFile.getPath() + \" contains illegal file name that breaks out of the target directory: \" + e.getName());\n                }\n                if (e.isDirectory()) {\n                    mkdirs(f);\n                } else {\n                    File p = f.getParentFile();\n                    if (p != null) {\n                        mkdirs(p);\n                    }\n                    try (InputStream input = zip.getInputStream(e)) {\n                        IOUtils.copy(input, writing(f));\n                    }\n                    try {\n                        FilePath target = new FilePath(f);\n                        int mode = e.getUnixMode();\n                        if (mode!=0)    // Ant returns 0 if the archive doesn't record the access mode\n                            target.chmod(mode);\n                    } catch (InterruptedException ex) {\n                        LOGGER.log(Level.WARNING, \"unable to set permissions\", ex);\n                    }\n                    f.setLastModified(e.getTime());\n                }\n            }\n        } finally {\n            zip.close();\n        }\n    }", "code_tokens": ["private", "void", "unzip", "(", "File", "dir", ",", "File", "zipFile", ")", "throws", "IOException", "{", "dir", "=", "dir", ".", "getAbsoluteFile", "(", ")", ";", "ZipFile", "zip", "=", "new", "ZipFile", "(", "zipFile", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Enumeration", "<", "ZipEntry", ">", "entries", "=", "zip", ".", "getEntries", "(", ")", ";", "try", "{", "while", "(", "entries", ".", "hasMoreElements", "(", ")", ")", "{", "ZipEntry", "e", "=", "entries", ".", "nextElement", "(", ")", ";", "File", "f", "=", "new", "File", "(", "dir", ",", "e", ".", "getName", "(", ")", ")", ";", "if", "(", "!", "f", ".", "toPath", "(", ")", ".", "normalize", "(", ")", ".", "startsWith", "(", "dir", ".", "toPath", "(", ")", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "Zip ", "\"", "+", "zipFile", ".", "getPath", "(", ")", "+", "\"", " contains illegal file name that breaks out of the target directory: ", "\"", "+", "e", ".", "getName", "(", ")", ")", ";", "}", "if", "(", "e", ".", "isDirectory", "(", ")", ")", "{", "mkdirs", "(", "f", ")", ";", "}", "else", "{", "File", "p", "=", "f", ".", "getParentFile", "(", ")", ";", "if", "(", "p", "!=", "null", ")", "{", "mkdirs", "(", "p", ")", ";", "}", "try", "(", "InputStream", "input", "=", "zip", ".", "getInputStream", "(", "e", ")", ")", "{", "IOUtils", ".", "copy", "(", "input", ",", "writing", "(", "f", ")", ")", ";", "}", "try", "{", "FilePath", "target", "=", "new", "FilePath", "(", "f", ")", ";", "int", "mode", "=", "e", ".", "getUnixMode", "(", ")", ";", "if", "(", "mode", "!=", "0", ")", "target", ".", "chmod", "(", "mode", ")", ";", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "unable to set permissions", "\"", ",", "ex", ")", ";", "}", "f", ".", "setLastModified", "(", "e", ".", "getTime", "(", ")", ")", ";", "}", "}", "}", "finally", "{", "zip", ".", "close", "(", ")", ";", "}", "}"], "idx": 77924, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "8ede53387ec060a7c343e32efe808b1016f0c10c", "function_name": "unzip", "body_hash": "74ae6335e5c77acf2e3809a146a1cfcd9c0430ed"}
{"code": "@Override\n    public void deactivate() {\n        // Disassociate from the current conversation\n        if (isActive()) {\n            if (!isAssociated()) {\n                throw ConversationLogger.LOG.mustCallAssociateBeforeDeactivate();\n            }\n\n            try {\n                if (getCurrentConversation().isTransient() && getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) != null) {\n                    // WELD-1746 Don't destroy ended conversations - these must be destroyed in a synchronized block - see also cleanUpConversationMap()\n                    destroy();\n                } else {\n                    // Update the conversation timestamp\n                    getCurrentConversation().touch();\n                    if (!getBeanStore().isAttached()) {\n                        /*\n                         * This was a transient conversation at the beginning of the request, so we need to update the CID it uses, and attach it. We also add\n                         * it to the conversations the session knows about.\n                         */\n                        if (!(getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) instanceof ConversationNamingScheme)) {\n                            throw ConversationLogger.LOG.conversationNamingSchemeNotFound();\n                        }\n                        ((ConversationNamingScheme) getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME)).setCid(getCurrentConversation()\n                                .getId());\n\n                        getBeanStore().attach();\n                        getConversationMap().put(getCurrentConversation().getId(), getCurrentConversation());\n                    }\n                }\n            } finally {\n                // WELD-1690 always try to unlock the current conversation\n                getCurrentConversation().unlock();\n                // WELD-1802\n                setBeanStore(null);\n                // Clean up any expired/ended conversations\n                cleanUpConversationMap();\n                // deactivate the context\n                super.setActive(false);\n            }\n        } else {\n            throw ConversationLogger.LOG.contextNotActive();\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "deactivate", "(", ")", "{", "if", "(", "isActive", "(", ")", ")", "{", "if", "(", "!", "isAssociated", "(", ")", ")", "{", "throw", "ConversationLogger", ".", "LOG", ".", "mustCallAssociateBeforeDeactivate", "(", ")", ";", "}", "try", "{", "if", "(", "getCurrentConversation", "(", ")", ".", "isTransient", "(", ")", "&&", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", "!=", "null", ")", "{", "destroy", "(", ")", ";", "}", "else", "{", "getCurrentConversation", "(", ")", ".", "touch", "(", ")", ";", "if", "(", "!", "getBeanStore", "(", ")", ".", "isAttached", "(", ")", ")", "{", "if", "(", "!", "(", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", "instanceof", "ConversationNamingScheme", ")", ")", "{", "throw", "ConversationLogger", ".", "LOG", ".", "conversationNamingSchemeNotFound", "(", ")", ";", "}", "(", "(", "ConversationNamingScheme", ")", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", ")", ".", "setCid", "(", "getCurrentConversation", "(", ")", ".", "getId", "(", ")", ")", ";", "getBeanStore", "(", ")", ".", "attach", "(", ")", ";", "getConversationMap", "(", ")", ".", "put", "(", "getCurrentConversation", "(", ")", ".", "getId", "(", ")", ",", "getCurrentConversation", "(", ")", ")", ";", "}", "}", "}", "finally", "{", "getCurrentConversation", "(", ")", ".", "unlock", "(", ")", ";", "setBeanStore", "(", "null", ")", ";", "cleanUpConversationMap", "(", ")", ";", "super", ".", "setActive", "(", "false", ")", ";", "}", "}", "else", "{", "throw", "ConversationLogger", ".", "LOG", ".", "contextNotActive", "(", ")", ";", "}", "}"], "idx": 49000, "cwe": "CWE-362", "target": 1, "status": "VULNERABLE", "commit": "311dd79", "function_name": "deactivate", "body_hash": "ce4c6dd8e8bbb8d74ee5755de93b0ee2f9437d74"}
{"code": "public Object read(final InputSource in) throws SAXException,\n                                            IOException {\n        if ( this.docFragment == null ) {\n            DocumentBuilderFactory f;\n            try {\n                f =  DocumentBuilderFactory.newInstance();\n            } catch ( FactoryConfigurationError e ) {\n                // obscure JDK1.5 bug where FactoryFinder in the JRE returns a null ClassLoader, so fall back to hard coded xerces.\n                // https://stg.network.org/bugzilla/show_bug.cgi?id=47169\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4633368\n                try {\n                    f = (DocumentBuilderFactory) Class.forName( \"org.apache.xerces.jaxp.DocumentBuilderFactoryImpl\" ).newInstance();\n                } catch ( Exception e1 ) {\n                    throw new RuntimeException( \"Unable to create new DOM Document\",\n                                                e1 );\n                }\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            // XXE protection start\n            try {\n                f.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                f.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            } catch (ParserConfigurationException e) {\n                logger.warn(\"Unable to set parser features due to {}\", e.getMessage());\n            }\n            // XXE protection end\n            try {\n                this.document = f.newDocumentBuilder().newDocument();\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            this.docFragment = this.document.createDocumentFragment();\n        }\n\n        SAXParser localParser = null;\n        if ( this.parser == null ) {\n            SAXParserFactory factory = null;\n            try {\n                factory = SAXParserFactory.newInstance();\n            } catch ( FactoryConfigurationError e) {\n                // obscure JDK1.5 bug where FactoryFinder in the JRE returns a null ClassLoader, so fall back to hard coded xerces.\n                // https://stg.network.org/bugzilla/show_bug.cgi?id=47169\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4633368                \n                try {\n                    factory = (SAXParserFactory) Class.forName( \"org.apache.xerces.jaxp.SAXParserFactoryImpl\" ).newInstance();\n                } catch ( Exception e1 ) {\n                    throw new RuntimeException( \"Unable to create new DOM Document\",\n                                                e1 );\n                }\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            \n            factory.setNamespaceAware( true );\n            // XXE protection start\n            try {\n                factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            } catch (ParserConfigurationException e) {\n                logger.warn(\"Unable to set parser features due to {}\", e.getMessage());\n            }\n            // XXE protection end\n\n            final String isValidatingString = System.getProperty( \"drools.schema.validating\" );\n            if ( System.getProperty( \"drools.schema.validating\" ) != null ) {\n                this.isValidating = Boolean.getBoolean( \"drools.schema.validating\" );\n            }\n\n            if ( this.isValidating == true ) {\n                factory.setValidating( true );\n                try {\n                    localParser = factory.newSAXParser();\n                } catch ( final ParserConfigurationException e ) {\n                    throw new RuntimeException( e.getMessage() );\n                }\n\n                try {\n                    localParser.setProperty( ExtensibleXmlParser.JAXP_SCHEMA_LANGUAGE,\n                                             ExtensibleXmlParser.W3C_XML_SCHEMA );\n                } catch ( final SAXNotRecognizedException e ) {\n                    boolean hideWarnings = Boolean.getBoolean( \"drools.schema.hidewarnings\" );\n                    if ( !hideWarnings ) {\n                        logger.warn( \"Your SAX parser is not JAXP 1.2 compliant - turning off validation.\" );\n                    }\n                    localParser = null;\n                }\n            }\n\n            if ( localParser == null ) {\n                // not jaxp1.2 compliant so turn off validation\n                try {\n                    this.isValidating = false;\n                    factory.setValidating( this.isValidating );\n                    localParser = factory.newSAXParser();\n                } catch ( final ParserConfigurationException e ) {\n                    throw new RuntimeException( e.getMessage() );\n                }\n            }\n        } else {\n            localParser = this.parser;\n        }\n\n        if ( !localParser.isNamespaceAware() ) {\n            throw new RuntimeException( \"parser must be namespace-aware\" );\n        }\n\n        localParser.parse( in,\n                           this );\n\n        return this.data;\n    }", "code_tokens": ["public", "Object", "read", "(", "final", "InputSource", "in", ")", "throws", "SAXException", ",", "IOException", "{", "if", "(", "this", ".", "docFragment", "==", "null", ")", "{", "DocumentBuilderFactory", "f", ";", "try", "{", "f", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "FactoryConfigurationError", "e", ")", "{", "try", "{", "f", "=", "(", "DocumentBuilderFactory", ")", "Class", ".", "forName", "(", "\"", "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl", "\"", ")", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "Exception", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e1", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e", ")", ";", "}", "try", "{", "f", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "f", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e", ")", "{", "logger", ".", "warn", "(", "\"", "Unable to set parser features due to {}", "\"", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "try", "{", "this", ".", "document", "=", "f", ".", "newDocumentBuilder", "(", ")", ".", "newDocument", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e", ")", ";", "}", "this", ".", "docFragment", "=", "this", ".", "document", ".", "createDocumentFragment", "(", ")", ";", "}", "SAXParser", "localParser", "=", "null", ";", "if", "(", "this", ".", "parser", "==", "null", ")", "{", "SAXParserFactory", "factory", "=", "null", ";", "try", "{", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "FactoryConfigurationError", "e", ")", "{", "try", "{", "factory", "=", "(", "SAXParserFactory", ")", "Class", ".", "forName", "(", "\"", "org.apache.xerces.jaxp.SAXParserFactoryImpl", "\"", ")", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "Exception", "e1", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e1", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Unable to create new DOM Document", "\"", ",", "e", ")", ";", "}", "factory", ".", "setNamespaceAware", "(", "true", ")", ";", "try", "{", "factory", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "}", "catch", "(", "ParserConfigurationException", "e", ")", "{", "logger", ".", "warn", "(", "\"", "Unable to set parser features due to {}", "\"", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "final", "String", "isValidatingString", "=", "System", ".", "getProperty", "(", "\"", "drools.schema.validating", "\"", ")", ";", "if", "(", "System", ".", "getProperty", "(", "\"", "drools.schema.validating", "\"", ")", "!=", "null", ")", "{", "this", ".", "isValidating", "=", "Boolean", ".", "getBoolean", "(", "\"", "drools.schema.validating", "\"", ")", ";", "}", "if", "(", "this", ".", "isValidating", "==", "true", ")", "{", "factory", ".", "setValidating", "(", "true", ")", ";", "try", "{", "localParser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "}", "catch", "(", "final", "ParserConfigurationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "try", "{", "localParser", ".", "setProperty", "(", "ExtensibleXmlParser", ".", "JAXP_SCHEMA_LANGUAGE", ",", "ExtensibleXmlParser", ".", "W3C_XML_SCHEMA", ")", ";", "}", "catch", "(", "final", "SAXNotRecognizedException", "e", ")", "{", "boolean", "hideWarnings", "=", "Boolean", ".", "getBoolean", "(", "\"", "drools.schema.hidewarnings", "\"", ")", ";", "if", "(", "!", "hideWarnings", ")", "{", "logger", ".", "warn", "(", "\"", "Your SAX parser is not JAXP 1.2 compliant - turning off validation.", "\"", ")", ";", "}", "localParser", "=", "null", ";", "}", "}", "if", "(", "localParser", "==", "null", ")", "{", "try", "{", "this", ".", "isValidating", "=", "false", ";", "factory", ".", "setValidating", "(", "this", ".", "isValidating", ")", ";", "localParser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "}", "catch", "(", "final", "ParserConfigurationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "else", "{", "localParser", "=", "this", ".", "parser", ";", "}", "if", "(", "!", "localParser", ".", "isNamespaceAware", "(", ")", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "parser must be namespace-aware", "\"", ")", ";", "}", "localParser", ".", "parse", "(", "in", ",", "this", ")", ";", "return", "this", ".", "data", ";", "}"], "idx": 110774, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "5b850e8c121be994dbbc5ecba3de4e7355ac4331", "function_name": "read", "body_hash": "ed5605bf9bd27fa64e36a3276d75c409bafdda98"}
{"code": "private static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n\n\t\ttry {\n\n\t\t\tcurrent = new PropertyPath(source, type, base);\n\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n\n\t\t\tList<PropertyPath> newBase = new ArrayList<>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.actualTypeInformation, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}", "code_tokens": ["private", "static", "PropertyPath", "create", "(", "String", "source", ",", "TypeInformation", "<", "?", ">", "type", ",", "String", "addTail", ",", "List", "<", "PropertyPath", ">", "base", ")", "{", "PropertyReferenceException", "exception", "=", "null", ";", "PropertyPath", "current", "=", "null", ";", "try", "{", "current", "=", "new", "PropertyPath", "(", "source", ",", "type", ",", "base", ")", ";", "if", "(", "!", "base", ".", "isEmpty", "(", ")", ")", "{", "base", ".", "get", "(", "base", ".", "size", "(", ")", "-", "1", ")", ".", "next", "=", "current", ";", "}", "List", "<", "PropertyPath", ">", "newBase", "=", "new", "ArrayList", "<", ">", "(", "base", ")", ";", "newBase", ".", "add", "(", "current", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "addTail", ")", ")", "{", "current", ".", "next", "=", "create", "(", "addTail", ",", "current", ".", "actualTypeInformation", ",", "newBase", ")", ";", "}", "return", "current", ";", "}", "catch", "(", "PropertyReferenceException", "e", ")", "{", "if", "(", "current", "!=", "null", ")", "{", "throw", "e", ";", "}", "exception", "=", "e", ";", "}", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "\"", "\\\\", "p{Lu}+", "\\\\", "p{Ll}*$", "\"", ")", ";", "Matcher", "matcher", "=", "pattern", ".", "matcher", "(", "source", ")", ";", "if", "(", "matcher", ".", "find", "(", ")", "&&", "matcher", ".", "start", "(", ")", "!=", "0", ")", "{", "int", "position", "=", "matcher", ".", "start", "(", ")", ";", "String", "head", "=", "source", ".", "substring", "(", "0", ",", "position", ")", ";", "String", "tail", "=", "source", ".", "substring", "(", "position", ")", ";", "try", "{", "return", "create", "(", "head", ",", "type", ",", "tail", "+", "addTail", ",", "base", ")", ";", "}", "catch", "(", "PropertyReferenceException", "e", ")", "{", "throw", "e", ".", "hasDeeperResolutionDepthThan", "(", "exception", ")", "?", "e", ":", "exception", ";", "}", "}", "throw", "exception", ";", "}"], "idx": 76331, "cwe": "CWE-770", "target": 1, "status": "VULNERABLE", "commit": "3d8576fe4e4e71c23b9e6796b32fd56e51182ee", "function_name": "create", "body_hash": "a343f7b6c860f10e5e6e27b18fc6d89f26de7867"}
{"code": "protected Configuration createConfiguration(ServletContext servletContext) throws TemplateException {\n        Configuration configuration = new Configuration(Configuration.VERSION_2_3_0);\n\n        configuration.setTemplateExceptionHandler(TemplateExceptionHandler.HTML_DEBUG_HANDLER);\n\n        if (mruMaxStrongSize > 0) {\n            LOG.debug(\"Sets Configuration.CACHE_STORAGE_KEY to strong:{}\", mruMaxStrongSize);\n            configuration.setSetting(Configuration.CACHE_STORAGE_KEY, \"strong:\" + mruMaxStrongSize);\n        }\n        if (templateUpdateDelay != null) {\n            LOG.debug(\"Sets Configuration.TEMPLATE_UPDATE_DELAY_KEY to {}\", templateUpdateDelay);\n            configuration.setSetting(Configuration.TEMPLATE_UPDATE_DELAY_KEY, templateUpdateDelay);\n        }\n        if (encoding != null) {\n            LOG.debug(\"Sets DefaultEncoding to {}\", encoding);\n            configuration.setDefaultEncoding(encoding);\n        }\n        LOG.debug(\"Disabled localized lookups\");\n        configuration.setLocalizedLookup(false);\n        LOG.debug(\"Enabled whitespace stripping\");\n        configuration.setWhitespaceStripping(true);\n        LOG.debug(\"Sets NewBuiltinClassResolver to TemplateClassResolver.SAFER_RESOLVER\");\n        configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);\n\n        return configuration;\n    }", "code_tokens": ["protected", "Configuration", "createConfiguration", "(", "ServletContext", "servletContext", ")", "throws", "TemplateException", "{", "Configuration", "configuration", "=", "new", "Configuration", "(", "Configuration", ".", "VERSION_2_3_0", ")", ";", "configuration", ".", "setTemplateExceptionHandler", "(", "TemplateExceptionHandler", ".", "HTML_DEBUG_HANDLER", ")", ";", "if", "(", "mruMaxStrongSize", ">", "0", ")", "{", "LOG", ".", "debug", "(", "\"", "Sets Configuration.CACHE_STORAGE_KEY to strong:{}", "\"", ",", "mruMaxStrongSize", ")", ";", "configuration", ".", "setSetting", "(", "Configuration", ".", "CACHE_STORAGE_KEY", ",", "\"", "strong:", "\"", "+", "mruMaxStrongSize", ")", ";", "}", "if", "(", "templateUpdateDelay", "!=", "null", ")", "{", "LOG", ".", "debug", "(", "\"", "Sets Configuration.TEMPLATE_UPDATE_DELAY_KEY to {}", "\"", ",", "templateUpdateDelay", ")", ";", "configuration", ".", "setSetting", "(", "Configuration", ".", "TEMPLATE_UPDATE_DELAY_KEY", ",", "templateUpdateDelay", ")", ";", "}", "if", "(", "encoding", "!=", "null", ")", "{", "LOG", ".", "debug", "(", "\"", "Sets DefaultEncoding to {}", "\"", ",", "encoding", ")", ";", "configuration", ".", "setDefaultEncoding", "(", "encoding", ")", ";", "}", "LOG", ".", "debug", "(", "\"", "Disabled localized lookups", "\"", ")", ";", "configuration", ".", "setLocalizedLookup", "(", "false", ")", ";", "LOG", ".", "debug", "(", "\"", "Enabled whitespace stripping", "\"", ")", ";", "configuration", ".", "setWhitespaceStripping", "(", "true", ")", ";", "LOG", ".", "debug", "(", "\"", "Sets NewBuiltinClassResolver to TemplateClassResolver.SAFER_RESOLVER", "\"", ")", ";", "configuration", ".", "setNewBuiltinClassResolver", "(", "TemplateClassResolver", ".", "SAFER_RESOLVER", ")", ";", "return", "configuration", ";", "}"], "idx": 6621, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "637ad1c3707266c33daabb18d7754e795e6681f", "function_name": "createConfiguration", "body_hash": "30c7c76cc2e78e0d2e5fbd37cd03402cecb2776d"}
{"code": "@Override\n    public Resource getResource(String pathInContext)\n    {\n        Resource r=null;\n        if (_relativeResourceBase!=null)\n            pathInContext=URIUtil.addPaths(_relativeResourceBase,pathInContext);\n\n        try\n        {\n            if (_resourceBase!=null)\n            {\n                r = _resourceBase.addPath(pathInContext);\n                if (!_contextHandler.checkAlias(pathInContext,r))\n                    r=null;\n            }\n            else if (_servletContext instanceof ContextHandler.Context)\n            {\n                r = _contextHandler.getResource(pathInContext);\n            }\n            else\n            {\n                URL u = _servletContext.getResource(pathInContext);\n                r = _contextHandler.newResource(u);\n            }\n\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Resource \"+pathInContext+\"=\"+r);\n        }\n        catch (IOException e)\n        {\n            LOG.ignore(e);\n        }\n\n        if((r==null || !r.exists()) && pathInContext.endsWith(\"/jetty-dir.css\"))\n            r=_stylesheet;\n\n        return r;\n    }", "code_tokens": ["@", "Override", "public", "Resource", "getResource", "(", "String", "pathInContext", ")", "{", "Resource", "r", "=", "null", ";", "if", "(", "_relativeResourceBase", "!=", "null", ")", "pathInContext", "=", "URIUtil", ".", "addPaths", "(", "_relativeResourceBase", ",", "pathInContext", ")", ";", "try", "{", "if", "(", "_resourceBase", "!=", "null", ")", "{", "r", "=", "_resourceBase", ".", "addPath", "(", "pathInContext", ")", ";", "if", "(", "!", "_contextHandler", ".", "checkAlias", "(", "pathInContext", ",", "r", ")", ")", "r", "=", "null", ";", "}", "else", "if", "(", "_servletContext", "instanceof", "ContextHandler", ".", "Context", ")", "{", "r", "=", "_contextHandler", ".", "getResource", "(", "pathInContext", ")", ";", "}", "else", "{", "URL", "u", "=", "_servletContext", ".", "getResource", "(", "pathInContext", ")", ";", "r", "=", "_contextHandler", ".", "newResource", "(", "u", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "Resource ", "\"", "+", "pathInContext", "+", "\"", "=", "\"", "+", "r", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LOG", ".", "ignore", "(", "e", ")", ";", "}", "if", "(", "(", "r", "==", "null", "||", "!", "r", ".", "exists", "(", ")", ")", "&&", "pathInContext", ".", "endsWith", "(", "\"", "/jetty-dir.css", "\"", ")", ")", "r", "=", "_stylesheet", ";", "return", "r", ";", "}"], "idx": 101970, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "53e8bc2a636707e896fd106fbee3596823c2cdc", "function_name": "getResource", "body_hash": "b5e05aa89e6b9f4ace36ccf2737ea7a9102b99be"}
{"code": "private void doEncryptBeforeSign() {\n        try {\n            AbstractTokenWrapper encryptionWrapper = getEncryptionToken();\n            assertTokenWrapper(encryptionWrapper);\n            AbstractToken encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n            \n            if (encryptionToken != null) {\n                //The encryption token can be an IssuedToken or a \n                //SecureConversationToken\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken \n                    || encryptionToken instanceof KerberosToken\n                    || encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken\n                    || encryptionToken instanceof SpnegoContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                } else if (encryptionToken instanceof UsernameToken) {\n                    if (isRequestor()) {\n                        tokenId = setupUTDerivedKey((UsernameToken)encryptionToken);\n                    } else {\n                        tokenId = getUTDerivedKey();\n                    }\n                }\n                assertToken(encryptionToken);\n                if (tok == null) {\n                    //if (tokenId == null || tokenId.length() == 0) {\n                        //REVISIT - no tokenId?   Exception?\n                    //}\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n                    \n                    /*\n                     * Get hold of the token from the token storage\n                     */\n                    tok = tokenStore.getToken(tokenId);\n                }\n    \n                boolean attached = false;\n                if (isTokenRequired(encryptionToken.getIncludeTokenType())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n                \n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n                \n                handleEncryptedSignedHeaders(encrParts, sigParts);\n                \n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);        \n                }\n                \n                addSupportingTokens(sigParts);\n                if (!isRequestor()) {\n                    addSignatureConfirmation(sigParts);\n                }\n                \n                //Sign the message\n                //We should use the same key in the case of EncryptBeforeSig\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken, \n                                                    tok, attached));\n                }\n                \n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n                \n                //Check for signature protection and encryption of UsernameToken\n                if (sbinding.isEncryptSignature() \n                    || encryptedTokensList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n                    \n                    //Now encrypt the signature using the above token\n                    if (sbinding.isEncryptSignature()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart = \n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n                        }\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                        assertPolicy(\n                            new QName(sbinding.getName().getNamespaceURI(), SPConstants.ENCRYPT_SIGNATURE));\n                    }\n                    \n                    if (isRequestor()) {\n                        secondEncrParts.addAll(encryptedTokensList);\n                    }\n                    \n                    Element secondRefList = null;\n                    \n                    if (encryptionToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys \n                        && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null, \n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        //Encrypt, get hold of the ref list and add it\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw ex;\n        } catch (Exception ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw new Fault(ex);\n        }\n    }", "code_tokens": ["private", "void", "doEncryptBeforeSign", "(", ")", "{", "try", "{", "AbstractTokenWrapper", "encryptionWrapper", "=", "getEncryptionToken", "(", ")", ";", "assertTokenWrapper", "(", "encryptionWrapper", ")", ";", "AbstractToken", "encryptionToken", "=", "encryptionWrapper", ".", "getToken", "(", ")", ";", "List", "<", "WSEncryptionPart", ">", "encrParts", "=", "getEncryptedParts", "(", ")", ";", "List", "<", "WSEncryptionPart", ">", "sigParts", "=", "getSignedParts", "(", ")", ";", "if", "(", "encryptionToken", "!=", "null", ")", "{", "String", "tokenId", "=", "null", ";", "SecurityToken", "tok", "=", "null", ";", "if", "(", "encryptionToken", "instanceof", "IssuedToken", "||", "encryptionToken", "instanceof", "KerberosToken", "||", "encryptionToken", "instanceof", "SecureConversationToken", "||", "encryptionToken", "instanceof", "SecurityContextToken", "||", "encryptionToken", "instanceof", "SpnegoContextToken", ")", "{", "tok", "=", "getSecurityToken", "(", ")", ";", "}", "else", "if", "(", "encryptionToken", "instanceof", "X509Token", ")", "{", "if", "(", "isRequestor", "(", ")", ")", "{", "tokenId", "=", "setupEncryptedKey", "(", "encryptionWrapper", ",", "encryptionToken", ")", ";", "}", "else", "{", "tokenId", "=", "getEncryptedKey", "(", ")", ";", "}", "}", "else", "if", "(", "encryptionToken", "instanceof", "UsernameToken", ")", "{", "if", "(", "isRequestor", "(", ")", ")", "{", "tokenId", "=", "setupUTDerivedKey", "(", "(", "UsernameToken", ")", "encryptionToken", ")", ";", "}", "else", "{", "tokenId", "=", "getUTDerivedKey", "(", ")", ";", "}", "}", "assertToken", "(", "encryptionToken", ")", ";", "if", "(", "tok", "==", "null", ")", "{", "if", "(", "tokenId", "!=", "null", "&&", "tokenId", ".", "startsWith", "(", "\"", "#", "\"", ")", ")", "{", "tokenId", "=", "tokenId", ".", "substring", "(", "1", ")", ";", "}", "tok", "=", "tokenStore", ".", "getToken", "(", "tokenId", ")", ";", "}", "boolean", "attached", "=", "false", ";", "if", "(", "isTokenRequired", "(", "encryptionToken", ".", "getIncludeTokenType", "(", ")", ")", ")", "{", "Element", "el", "=", "tok", ".", "getToken", "(", ")", ";", "this", ".", "addEncryptedKeyElement", "(", "cloneElement", "(", "el", ")", ")", ";", "attached", "=", "true", ";", "}", "else", "if", "(", "encryptionToken", "instanceof", "X509Token", "&&", "isRequestor", "(", ")", ")", "{", "Element", "el", "=", "tok", ".", "getToken", "(", ")", ";", "this", ".", "addEncryptedKeyElement", "(", "cloneElement", "(", "el", ")", ")", ";", "attached", "=", "true", ";", "}", "WSSecBase", "encr", "=", "doEncryption", "(", "encryptionWrapper", ",", "tok", ",", "attached", ",", "encrParts", ",", "true", ")", ";", "handleEncryptedSignedHeaders", "(", "encrParts", ",", "sigParts", ")", ";", "if", "(", "timestampEl", "!=", "null", ")", "{", "WSEncryptionPart", "timestampPart", "=", "convertToEncryptionPart", "(", "timestampEl", ".", "getElement", "(", ")", ")", ";", "sigParts", ".", "add", "(", "timestampPart", ")", ";", "}", "addSupportingTokens", "(", "sigParts", ")", ";", "if", "(", "!", "isRequestor", "(", ")", ")", "{", "addSignatureConfirmation", "(", "sigParts", ")", ";", "}", "if", "(", "sigParts", ".", "size", "(", ")", ">", "0", ")", "{", "signatures", ".", "add", "(", "this", ".", "doSignature", "(", "sigParts", ",", "encryptionWrapper", ",", "encryptionToken", ",", "tok", ",", "attached", ")", ")", ";", "}", "if", "(", "isRequestor", "(", ")", ")", "{", "this", ".", "doEndorse", "(", ")", ";", "}", "if", "(", "sbinding", ".", "isEncryptSignature", "(", ")", "||", "encryptedTokensList", ".", "size", "(", ")", ">", "0", "&&", "isRequestor", "(", ")", ")", "{", "List", "<", "WSEncryptionPart", ">", "secondEncrParts", "=", "new", "ArrayList", "<", "WSEncryptionPart", ">", "(", ")", ";", "if", "(", "sbinding", ".", "isEncryptSignature", "(", ")", ")", "{", "if", "(", "this", ".", "mainSigId", "!=", "null", ")", "{", "WSEncryptionPart", "sigPart", "=", "new", "WSEncryptionPart", "(", "this", ".", "mainSigId", ",", "\"", "Element", "\"", ")", ";", "sigPart", ".", "setElement", "(", "bottomUpElement", ")", ";", "secondEncrParts", ".", "add", "(", "sigPart", ")", ";", "}", "if", "(", "sigConfList", "!=", "null", "&&", "!", "sigConfList", ".", "isEmpty", "(", ")", ")", "{", "secondEncrParts", ".", "addAll", "(", "sigConfList", ")", ";", "}", "assertPolicy", "(", "new", "QName", "(", "sbinding", ".", "getName", "(", ")", ".", "getNamespaceURI", "(", ")", ",", "SPConstants", ".", "ENCRYPT_SIGNATURE", ")", ")", ";", "}", "if", "(", "isRequestor", "(", ")", ")", "{", "secondEncrParts", ".", "addAll", "(", "encryptedTokensList", ")", ";", "}", "Element", "secondRefList", "=", "null", ";", "if", "(", "encryptionToken", ".", "getDerivedKeys", "(", ")", "==", "DerivedKeys", ".", "RequireDerivedKeys", "&&", "!", "secondEncrParts", ".", "isEmpty", "(", ")", ")", "{", "secondRefList", "=", "(", "(", "WSSecDKEncrypt", ")", "encr", ")", ".", "encryptForExternalRef", "(", "null", ",", "secondEncrParts", ")", ";", "this", ".", "addDerivedKeyElement", "(", "secondRefList", ")", ";", "}", "else", "if", "(", "!", "secondEncrParts", ".", "isEmpty", "(", ")", ")", "{", "secondRefList", "=", "(", "(", "WSSecEncrypt", ")", "encr", ")", ".", "encryptForRef", "(", "null", ",", "secondEncrParts", ")", ";", "this", ".", "addDerivedKeyElement", "(", "secondRefList", ")", ";", "}", "}", "}", "}", "catch", "(", "RuntimeException", "ex", ")", "{", "LOG", ".", "log", "(", "Level", ".", "FINE", ",", "ex", ".", "getMessage", "(", ")", ",", "ex", ")", ";", "throw", "ex", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "LOG", ".", "log", "(", "Level", ".", "FINE", ",", "ex", ".", "getMessage", "(", ")", ",", "ex", ")", ";", "throw", "new", "Fault", "(", "ex", ")", ";", "}", "}"], "idx": 41586, "cwe": "CWE-310", "target": 0, "status": "FIXED", "commit": "5df3f72f1a26b7c9ac2888ab65e41f4105706580", "function_name": "doEncryptBeforeSign", "body_hash": "c2430b529a9ea05ada3d4e4fbaa117b018488096"}
{"code": "@Override\n    public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n        }\n\n        if(hasCurrentMessage())\n        {\n            if(bodySize > _connection.getMaxMessageSize())\n            {\n                properties.dispose();\n                closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                             \"Message size of \" + bodySize + \" greater than allowed maximum of \" + _connection.getMaxMessageSize());\n            }\n            publishContentHeader(new ContentHeaderBody(properties, bodySize));\n        }\n        else\n        {\n            properties.dispose();\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"Attempt to send a content header without first sending a publish frame\",\n                                            _channelId);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "receiveMessageHeader", "(", "final", "BasicContentHeaderProperties", "properties", ",", "final", "long", "bodySize", ")", "{", "if", "(", "LOGGER", ".", "isDebugEnabled", "(", ")", ")", "{", "LOGGER", ".", "debug", "(", "\"", "RECV[", "\"", "+", "_channelId", "+", "\"", "] MessageHeader[ properties: {", "\"", "+", "properties", "+", "\"", "} bodySize: ", "\"", "+", "bodySize", "+", "\"", " ]", "\"", ")", ";", "}", "if", "(", "hasCurrentMessage", "(", ")", ")", "{", "if", "(", "bodySize", ">", "_connection", ".", "getMaxMessageSize", "(", ")", ")", "{", "properties", ".", "dispose", "(", ")", ";", "closeChannel", "(", "ErrorCodes", ".", "MESSAGE_TOO_LARGE", ",", "\"", "Message size of ", "\"", "+", "bodySize", "+", "\"", " greater than allowed maximum of ", "\"", "+", "_connection", ".", "getMaxMessageSize", "(", ")", ")", ";", "}", "publishContentHeader", "(", "new", "ContentHeaderBody", "(", "properties", ",", "bodySize", ")", ")", ";", "}", "else", "{", "properties", ".", "dispose", "(", ")", ";", "_connection", ".", "sendConnectionClose", "(", "ErrorCodes", ".", "COMMAND_INVALID", ",", "\"", "Attempt to send a content header without first sending a publish frame", "\"", ",", "_channelId", ")", ";", "}", "}"], "idx": 5663, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "025b48f3193e2b10b1c41d2bc3bcfc9cfc238a27", "function_name": "receiveMessageHeader", "body_hash": "342e49ff5ef2d53abb99a3457c409a4a7e291ae4"}
{"code": "public UnixUser authenticate(String username, String password) throws PAMException {\n        this.password = password;\n        try {\n            check(libpam.pam_set_item(pht,PAM_USER,username),\"pam_set_item failed\");\n            check(libpam.pam_authenticate(pht,0),\"pam_authenticate failed\");\n            check(libpam.pam_setcred(pht,0),\"pam_setcred failed\");\n            check(libpam.pam_acct_mgmt(pht,0),\"pam_acct_mgmt failed\");\n\n            PointerByReference r = new PointerByReference();\n            check(libpam.pam_get_item(pht,PAM_USER,r),\"pam_get_item failed\");\n            String userName = r.getValue().getString(0);\n            passwd pwd = libc.getpwnam(userName);\n            if(pwd==null)\n                throw new PAMException(\"Authentication succeeded but no user information is available\");\n            return new UnixUser(userName,pwd);\n        } finally {\n            this.password = null;\n        }\n    }", "code_tokens": ["public", "UnixUser", "authenticate", "(", "String", "username", ",", "String", "password", ")", "throws", "PAMException", "{", "this", ".", "password", "=", "password", ";", "try", "{", "check", "(", "libpam", ".", "pam_set_item", "(", "pht", ",", "PAM_USER", ",", "username", ")", ",", "\"", "pam_set_item failed", "\"", ")", ";", "check", "(", "libpam", ".", "pam_authenticate", "(", "pht", ",", "0", ")", ",", "\"", "pam_authenticate failed", "\"", ")", ";", "check", "(", "libpam", ".", "pam_setcred", "(", "pht", ",", "0", ")", ",", "\"", "pam_setcred failed", "\"", ")", ";", "check", "(", "libpam", ".", "pam_acct_mgmt", "(", "pht", ",", "0", ")", ",", "\"", "pam_acct_mgmt failed", "\"", ")", ";", "PointerByReference", "r", "=", "new", "PointerByReference", "(", ")", ";", "check", "(", "libpam", ".", "pam_get_item", "(", "pht", ",", "PAM_USER", ",", "r", ")", ",", "\"", "pam_get_item failed", "\"", ")", ";", "String", "userName", "=", "r", ".", "getValue", "(", ")", ".", "getString", "(", "0", ")", ";", "passwd", "pwd", "=", "libc", ".", "getpwnam", "(", "userName", ")", ";", "if", "(", "pwd", "==", "null", ")", "throw", "new", "PAMException", "(", "\"", "Authentication succeeded but no user information is available", "\"", ")", ";", "return", "new", "UnixUser", "(", "userName", ",", "pwd", ")", ";", "}", "finally", "{", "this", ".", "password", "=", "null", ";", "}", "}"], "idx": 11705, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "84f32f4001fc6bdcc125ccc959081de022d18b6d", "function_name": "authenticate", "body_hash": "0aa8ca25d0ed4ec5cbf9a421d2a7cbe454214ea6"}
{"code": "public AsciiString generateSessionId() {\n    return AsciiString.cached(UUID.randomUUID().toString());\n  }", "code_tokens": ["public", "AsciiString", "generateSessionId", "(", ")", "{", "return", "AsciiString", ".", "cached", "(", "UUID", ".", "randomUUID", "(", ")", ".", "toString", "(", ")", ")", ";", "}"], "idx": 42658, "cwe": "CWE-338", "target": 0, "status": "FIXED", "commit": "f2b63eb82dd71194319fd3945f5edf29b8f3a42d", "function_name": "generateSessionId", "body_hash": "2e2a441e461b6374f09c7341b83158286e92d380"}
{"code": "private void renewSeedInternal() {\n        String currentSeed = this.seed;\n        String newSeed = currentSeed;\n        while (Objects.equals(newSeed, currentSeed)) {\n            newSeed = new String(Hex.encodeHex(RANDOM.generateSeed(SEED_NUM_BYTES)));\n        }\n        this.seed = newSeed;\n    }", "code_tokens": ["private", "void", "renewSeedInternal", "(", ")", "{", "String", "currentSeed", "=", "this", ".", "seed", ";", "String", "newSeed", "=", "currentSeed", ";", "while", "(", "Objects", ".", "equals", "(", "newSeed", ",", "currentSeed", ")", ")", "{", "newSeed", "=", "new", "String", "(", "Hex", ".", "encodeHex", "(", "RANDOM", ".", "generateSeed", "(", "SEED_NUM_BYTES", ")", ")", ")", ";", "}", "this", ".", "seed", "=", "newSeed", ";", "}"], "idx": 110754, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "da135e7ecb", "function_name": "renewSeedInternal", "body_hash": "3898f7f2cd85dc78c9c8bbd356cdd02b5cdd512b"}
{"code": "public static ListBoxModel doFillCredentialsIdItems(ItemGroup context) {\n        return new StandardListBoxModel()\n                .withEmptySelection()\n                .withMatching(\n                        CredentialsMatchers.always(),\n                        CredentialsProvider.lookupCredentials(AmazonWebServicesCredentials.class,\n                                context,\n                                ACL.SYSTEM,\n                                Collections.EMPTY_LIST));\n    }", "code_tokens": ["public", "static", "ListBoxModel", "doFillCredentialsIdItems", "(", "ItemGroup", "context", ")", "{", "return", "new", "StandardListBoxModel", "(", ")", ".", "withEmptySelection", "(", ")", ".", "withMatching", "(", "CredentialsMatchers", ".", "always", "(", ")", ",", "CredentialsProvider", ".", "lookupCredentials", "(", "AmazonWebServicesCredentials", ".", "class", ",", "context", ",", "ACL", ".", "SYSTEM", ",", "Collections", ".", "EMPTY_LIST", ")", ")", ";", "}"], "idx": 85425, "cwe": "CWE-862", "target": 1, "status": "VULNERABLE", "commit": "dd477a071bd633d9118c63dc3f19a2fd0590aecb", "function_name": "doFillCredentialsIdItems", "body_hash": "4fb77a1f67b458fd4fcc00f5ce412275abb71160"}
{"code": "private final void internalMapWrapper(ContextVersion contextVersion,\n                                          CharChunk path,\n                                          MappingData mappingData) throws IOException {\n\n        int pathOffset = path.getOffset();\n        int pathEnd = path.getEnd();\n        boolean noServletPath = false;\n\n        int length = contextVersion.path.length();\n        if (length == (pathEnd - pathOffset)) {\n            noServletPath = true;\n        }\n        int servletPath = pathOffset + length;\n        path.setOffset(servletPath);\n\n        // Rule 1 -- Exact Match\n        MappedWrapper[] exactWrappers = contextVersion.exactWrappers;\n        internalMapExactWrapper(exactWrappers, path, mappingData);\n\n        // Rule 2 -- Prefix Match\n        boolean checkJspWelcomeFiles = false;\n        MappedWrapper[] wildcardWrappers = contextVersion.wildcardWrappers;\n        if (mappingData.wrapper == null) {\n            internalMapWildcardWrapper(wildcardWrappers, contextVersion.nesting,\n                                       path, mappingData);\n            if (mappingData.wrapper != null && mappingData.jspWildCard) {\n                char[] buf = path.getBuffer();\n                if (buf[pathEnd - 1] == '/') {\n                    /*\n                     * Path ending in '/' was mapped to JSP servlet based on\n                     * wildcard match (e.g., as specified in url-pattern of a\n                     * jsp-property-group.\n                     * Force the context's welcome files, which are interpreted\n                     * as JSP files (since they match the url-pattern), to be\n                     * considered. See Bugzilla 27664.\n                     */\n                    mappingData.wrapper = null;\n                    checkJspWelcomeFiles = true;\n                } else {\n                    // See Bugzilla 27704\n                    mappingData.wrapperPath.setChars(buf, path.getStart(),\n                                                     path.getLength());\n                    mappingData.pathInfo.recycle();\n                }\n            }\n        }\n\n        if(mappingData.wrapper == null && noServletPath &&\n                mappingData.context.getMapperContextRootRedirectEnabled()) {\n            // The path is empty, redirect to \"/\"\n            path.append('/');\n            pathEnd = path.getEnd();\n            mappingData.redirectPath.setChars\n                (path.getBuffer(), pathOffset, pathEnd - pathOffset);\n            path.setEnd(pathEnd - 1);\n            return;\n        }\n\n        // Rule 3 -- Extension Match\n        MappedWrapper[] extensionWrappers = contextVersion.extensionWrappers;\n        if (mappingData.wrapper == null && !checkJspWelcomeFiles) {\n            internalMapExtensionWrapper(extensionWrappers, path, mappingData,\n                    true);\n        }\n\n        // Rule 4 -- Welcome resources processing for servlets\n        if (mappingData.wrapper == null) {\n            boolean checkWelcomeFiles = checkJspWelcomeFiles;\n            if (!checkWelcomeFiles) {\n                char[] buf = path.getBuffer();\n                checkWelcomeFiles = (buf[pathEnd - 1] == '/');\n            }\n            if (checkWelcomeFiles) {\n                for (int i = 0; (i < contextVersion.welcomeResources.length)\n                         && (mappingData.wrapper == null); i++) {\n                    path.setOffset(pathOffset);\n                    path.setEnd(pathEnd);\n                    path.append(contextVersion.welcomeResources[i], 0,\n                            contextVersion.welcomeResources[i].length());\n                    path.setOffset(servletPath);\n\n                    // Rule 4a -- Welcome resources processing for exact macth\n                    internalMapExactWrapper(exactWrappers, path, mappingData);\n\n                    // Rule 4b -- Welcome resources processing for prefix match\n                    if (mappingData.wrapper == null) {\n                        internalMapWildcardWrapper\n                            (wildcardWrappers, contextVersion.nesting,\n                             path, mappingData);\n                    }\n\n                    // Rule 4c -- Welcome resources processing\n                    //            for physical folder\n                    if (mappingData.wrapper == null\n                        && contextVersion.resources != null) {\n                        String pathStr = path.toString();\n                        WebResource file =\n                                contextVersion.resources.getResource(pathStr);\n                        if (file != null && file.isFile()) {\n                            internalMapExtensionWrapper(extensionWrappers, path,\n                                                        mappingData, true);\n                            if (mappingData.wrapper == null\n                                && contextVersion.defaultWrapper != null) {\n                                mappingData.wrapper =\n                                    contextVersion.defaultWrapper.object;\n                                mappingData.requestPath.setChars\n                                    (path.getBuffer(), path.getStart(),\n                                     path.getLength());\n                                mappingData.wrapperPath.setChars\n                                    (path.getBuffer(), path.getStart(),\n                                     path.getLength());\n                                mappingData.requestPath.setString(pathStr);\n                                mappingData.wrapperPath.setString(pathStr);\n                            }\n                        }\n                    }\n                }\n\n                path.setOffset(servletPath);\n                path.setEnd(pathEnd);\n            }\n\n        }\n\n        /* welcome file processing - take 2\n         * Now that we have looked for welcome files with a physical\n         * backing, now look for an extension mapping listed\n         * but may not have a physical backing to it. This is for\n         * the case of index.jsf, index.do, etc.\n         * A watered down version of rule 4\n         */\n        if (mappingData.wrapper == null) {\n            boolean checkWelcomeFiles = checkJspWelcomeFiles;\n            if (!checkWelcomeFiles) {\n                char[] buf = path.getBuffer();\n                checkWelcomeFiles = (buf[pathEnd - 1] == '/');\n            }\n            if (checkWelcomeFiles) {\n                for (int i = 0; (i < contextVersion.welcomeResources.length)\n                         && (mappingData.wrapper == null); i++) {\n                    path.setOffset(pathOffset);\n                    path.setEnd(pathEnd);\n                    path.append(contextVersion.welcomeResources[i], 0,\n                                contextVersion.welcomeResources[i].length());\n                    path.setOffset(servletPath);\n                    internalMapExtensionWrapper(extensionWrappers, path,\n                                                mappingData, false);\n                }\n\n                path.setOffset(servletPath);\n                path.setEnd(pathEnd);\n            }\n        }\n\n\n        // Rule 7 -- Default servlet\n        if (mappingData.wrapper == null && !checkJspWelcomeFiles) {\n            if (contextVersion.defaultWrapper != null) {\n                mappingData.wrapper = contextVersion.defaultWrapper.object;\n                mappingData.requestPath.setChars\n                    (path.getBuffer(), path.getStart(), path.getLength());\n                mappingData.wrapperPath.setChars\n                    (path.getBuffer(), path.getStart(), path.getLength());\n            }\n            // Redirection to a folder\n            char[] buf = path.getBuffer();\n            if (contextVersion.resources != null && buf[pathEnd -1 ] != '/') {\n                String pathStr = path.toString();\n                WebResource file;\n                // Handle context root\n                if (pathStr.length() == 0) {\n                    file = contextVersion.resources.getResource(\"/\");\n                } else {\n                    file = contextVersion.resources.getResource(pathStr);\n                }\n                if (file != null && file.isDirectory() &&\n                        mappingData.context.getMapperDirectoryRedirectEnabled()) {\n                    // Note: this mutates the path: do not do any processing\n                    // after this (since we set the redirectPath, there\n                    // shouldn't be any)\n                    path.setOffset(pathOffset);\n                    path.append('/');\n                    mappingData.redirectPath.setChars\n                        (path.getBuffer(), path.getStart(), path.getLength());\n                } else {\n                    mappingData.requestPath.setString(pathStr);\n                    mappingData.wrapperPath.setString(pathStr);\n                }\n            }\n        }\n\n        path.setOffset(pathOffset);\n        path.setEnd(pathEnd);\n    }", "code_tokens": ["private", "final", "void", "internalMapWrapper", "(", "ContextVersion", "contextVersion", ",", "CharChunk", "path", ",", "MappingData", "mappingData", ")", "throws", "IOException", "{", "int", "pathOffset", "=", "path", ".", "getOffset", "(", ")", ";", "int", "pathEnd", "=", "path", ".", "getEnd", "(", ")", ";", "boolean", "noServletPath", "=", "false", ";", "int", "length", "=", "contextVersion", ".", "path", ".", "length", "(", ")", ";", "if", "(", "length", "==", "(", "pathEnd", "-", "pathOffset", ")", ")", "{", "noServletPath", "=", "true", ";", "}", "int", "servletPath", "=", "pathOffset", "+", "length", ";", "path", ".", "setOffset", "(", "servletPath", ")", ";", "MappedWrapper", "[", "]", "exactWrappers", "=", "contextVersion", ".", "exactWrappers", ";", "internalMapExactWrapper", "(", "exactWrappers", ",", "path", ",", "mappingData", ")", ";", "boolean", "checkJspWelcomeFiles", "=", "false", ";", "MappedWrapper", "[", "]", "wildcardWrappers", "=", "contextVersion", ".", "wildcardWrappers", ";", "if", "(", "mappingData", ".", "wrapper", "==", "null", ")", "{", "internalMapWildcardWrapper", "(", "wildcardWrappers", ",", "contextVersion", ".", "nesting", ",", "path", ",", "mappingData", ")", ";", "if", "(", "mappingData", ".", "wrapper", "!=", "null", "&&", "mappingData", ".", "jspWildCard", ")", "{", "char", "[", "]", "buf", "=", "path", ".", "getBuffer", "(", ")", ";", "if", "(", "buf", "[", "pathEnd", "-", "1", "]", "==", "'/'", ")", "{", "mappingData", ".", "wrapper", "=", "null", ";", "checkJspWelcomeFiles", "=", "true", ";", "}", "else", "{", "mappingData", ".", "wrapperPath", ".", "setChars", "(", "buf", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "mappingData", ".", "pathInfo", ".", "recycle", "(", ")", ";", "}", "}", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "noServletPath", "&&", "mappingData", ".", "context", ".", "getMapperContextRootRedirectEnabled", "(", ")", ")", "{", "path", ".", "append", "(", "'/'", ")", ";", "pathEnd", "=", "path", ".", "getEnd", "(", ")", ";", "mappingData", ".", "redirectPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "pathOffset", ",", "pathEnd", "-", "pathOffset", ")", ";", "path", ".", "setEnd", "(", "pathEnd", "-", "1", ")", ";", "return", ";", "}", "MappedWrapper", "[", "]", "extensionWrappers", "=", "contextVersion", ".", "extensionWrappers", ";", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "!", "checkJspWelcomeFiles", ")", "{", "internalMapExtensionWrapper", "(", "extensionWrappers", ",", "path", ",", "mappingData", ",", "true", ")", ";", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", ")", "{", "boolean", "checkWelcomeFiles", "=", "checkJspWelcomeFiles", ";", "if", "(", "!", "checkWelcomeFiles", ")", "{", "char", "[", "]", "buf", "=", "path", ".", "getBuffer", "(", ")", ";", "checkWelcomeFiles", "=", "(", "buf", "[", "pathEnd", "-", "1", "]", "==", "'/'", ")", ";", "}", "if", "(", "checkWelcomeFiles", ")", "{", "for", "(", "int", "i", "=", "0", ";", "(", "i", "<", "contextVersion", ".", "welcomeResources", ".", "length", ")", "&&", "(", "mappingData", ".", "wrapper", "==", "null", ")", ";", "i", "++", ")", "{", "path", ".", "setOffset", "(", "pathOffset", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "path", ".", "append", "(", "contextVersion", ".", "welcomeResources", "[", "i", "]", ",", "0", ",", "contextVersion", ".", "welcomeResources", "[", "i", "]", ".", "length", "(", ")", ")", ";", "path", ".", "setOffset", "(", "servletPath", ")", ";", "internalMapExactWrapper", "(", "exactWrappers", ",", "path", ",", "mappingData", ")", ";", "if", "(", "mappingData", ".", "wrapper", "==", "null", ")", "{", "internalMapWildcardWrapper", "(", "wildcardWrappers", ",", "contextVersion", ".", "nesting", ",", "path", ",", "mappingData", ")", ";", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "contextVersion", ".", "resources", "!=", "null", ")", "{", "String", "pathStr", "=", "path", ".", "toString", "(", ")", ";", "WebResource", "file", "=", "contextVersion", ".", "resources", ".", "getResource", "(", "pathStr", ")", ";", "if", "(", "file", "!=", "null", "&&", "file", ".", "isFile", "(", ")", ")", "{", "internalMapExtensionWrapper", "(", "extensionWrappers", ",", "path", ",", "mappingData", ",", "true", ")", ";", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "contextVersion", ".", "defaultWrapper", "!=", "null", ")", "{", "mappingData", ".", "wrapper", "=", "contextVersion", ".", "defaultWrapper", ".", "object", ";", "mappingData", ".", "requestPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "mappingData", ".", "wrapperPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "mappingData", ".", "requestPath", ".", "setString", "(", "pathStr", ")", ";", "mappingData", ".", "wrapperPath", ".", "setString", "(", "pathStr", ")", ";", "}", "}", "}", "}", "path", ".", "setOffset", "(", "servletPath", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "}", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", ")", "{", "boolean", "checkWelcomeFiles", "=", "checkJspWelcomeFiles", ";", "if", "(", "!", "checkWelcomeFiles", ")", "{", "char", "[", "]", "buf", "=", "path", ".", "getBuffer", "(", ")", ";", "checkWelcomeFiles", "=", "(", "buf", "[", "pathEnd", "-", "1", "]", "==", "'/'", ")", ";", "}", "if", "(", "checkWelcomeFiles", ")", "{", "for", "(", "int", "i", "=", "0", ";", "(", "i", "<", "contextVersion", ".", "welcomeResources", ".", "length", ")", "&&", "(", "mappingData", ".", "wrapper", "==", "null", ")", ";", "i", "++", ")", "{", "path", ".", "setOffset", "(", "pathOffset", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "path", ".", "append", "(", "contextVersion", ".", "welcomeResources", "[", "i", "]", ",", "0", ",", "contextVersion", ".", "welcomeResources", "[", "i", "]", ".", "length", "(", ")", ")", ";", "path", ".", "setOffset", "(", "servletPath", ")", ";", "internalMapExtensionWrapper", "(", "extensionWrappers", ",", "path", ",", "mappingData", ",", "false", ")", ";", "}", "path", ".", "setOffset", "(", "servletPath", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "}", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "!", "checkJspWelcomeFiles", ")", "{", "if", "(", "contextVersion", ".", "defaultWrapper", "!=", "null", ")", "{", "mappingData", ".", "wrapper", "=", "contextVersion", ".", "defaultWrapper", ".", "object", ";", "mappingData", ".", "requestPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "mappingData", ".", "wrapperPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "}", "char", "[", "]", "buf", "=", "path", ".", "getBuffer", "(", ")", ";", "if", "(", "contextVersion", ".", "resources", "!=", "null", "&&", "buf", "[", "pathEnd", "-", "1", "]", "!=", "'/'", ")", "{", "String", "pathStr", "=", "path", ".", "toString", "(", ")", ";", "WebResource", "file", ";", "if", "(", "pathStr", ".", "length", "(", ")", "==", "0", ")", "{", "file", "=", "contextVersion", ".", "resources", ".", "getResource", "(", "\"", "/", "\"", ")", ";", "}", "else", "{", "file", "=", "contextVersion", ".", "resources", ".", "getResource", "(", "pathStr", ")", ";", "}", "if", "(", "file", "!=", "null", "&&", "file", ".", "isDirectory", "(", ")", "&&", "mappingData", ".", "context", ".", "getMapperDirectoryRedirectEnabled", "(", ")", ")", "{", "path", ".", "setOffset", "(", "pathOffset", ")", ";", "path", ".", "append", "(", "'/'", ")", ";", "mappingData", ".", "redirectPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "}", "else", "{", "mappingData", ".", "requestPath", ".", "setString", "(", "pathStr", ")", ";", "mappingData", ".", "wrapperPath", ".", "setString", "(", "pathStr", ")", ";", "}", "}", "}", "path", ".", "setOffset", "(", "pathOffset", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "}"], "idx": 25640, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "c584c7c4ab0686e4125eefcd0afb32fb8269da3d", "function_name": "internalMapWrapper", "body_hash": "7f6b2712ed15143777673f6c87386569399e474a"}
{"code": "@Override\n    public SessionData decode(String data) {\n        byte[] bytes = Base64.getDecoder().decode(data);\n        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);\n                ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n            return (SessionData) objectInputStream.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            throw new PippoRuntimeException(e, \"Cannot deserialize session. A new one will be created.\");\n        }\n    }", "code_tokens": ["@", "Override", "public", "SessionData", "decode", "(", "String", "data", ")", "{", "byte", "[", "]", "bytes", "=", "Base64", ".", "getDecoder", "(", ")", ".", "decode", "(", "data", ")", ";", "try", "(", "ByteArrayInputStream", "inputStream", "=", "new", "ByteArrayInputStream", "(", "bytes", ")", ";", "ObjectInputStream", "objectInputStream", "=", "new", "ObjectInputStream", "(", "inputStream", ")", ")", "{", "return", "(", "SessionData", ")", "objectInputStream", ".", "readObject", "(", ")", ";", "}", "catch", "(", "IOException", "|", "ClassNotFoundException", "e", ")", "{", "throw", "new", "PippoRuntimeException", "(", "e", ",", "\"", "Cannot deserialize session. A new one will be created.", "\"", ")", ";", "}", "}"], "idx": 61521, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "c6b26551a82d2dd32097fcb17c13c3b830916296", "function_name": "decode", "body_hash": "75416521d4ad8e9c8a86733e26187b0b17a33ece"}
{"code": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // cannot get from ParameterizedJob back to ParameterizedJobMixIn trivially\n    @Override\n    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        item.checkPermission(Item.BUILD);\n        if (step.getWait() && !(item instanceof Job)) {\n            // TODO find some way of allowing ComputedFolders to hook into the listener code\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            // TODO use new convenience method in 1.621\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // ignore, best effort only\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "{", "\"", "unchecked", "\"", ",", "\"", "rawtypes", "\"", "}", ")", "@", "Override", "public", "boolean", "start", "(", ")", "throws", "Exception", "{", "String", "job", "=", "step", ".", "getJob", "(", ")", ";", "Item", "item", "=", "Jenkins", ".", "getActiveInstance", "(", ")", ".", "getItem", "(", "job", ",", "invokingRun", ".", "getParent", "(", ")", ",", "Item", ".", "class", ")", ";", "if", "(", "item", "==", "null", ")", "{", "throw", "new", "AbortException", "(", "\"", "No item named ", "\"", "+", "job", "+", "\"", " found", "\"", ")", ";", "}", "item", ".", "checkPermission", "(", "Item", ".", "BUILD", ")", ";", "if", "(", "step", ".", "getWait", "(", ")", "&&", "!", "(", "item", "instanceof", "Job", ")", ")", "{", "throw", "new", "AbortException", "(", "\"", "Waiting for non-job items is not supported", "\"", ")", ";", "}", "if", "(", "item", "instanceof", "ParameterizedJobMixIn", ".", "ParameterizedJob", ")", "{", "final", "ParameterizedJobMixIn", ".", "ParameterizedJob", "project", "=", "(", "ParameterizedJobMixIn", ".", "ParameterizedJob", ")", "item", ";", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Scheduling project: ", "\"", "+", "ModelHyperlinkNote", ".", "encodeTo", "(", "project", ")", ")", ";", "node", ".", "addAction", "(", "new", "LabelAction", "(", "Messages", ".", "BuildTriggerStepExecution_building_", "(", "project", ".", "getFullDisplayName", "(", ")", ")", ")", ")", ";", "List", "<", "Action", ">", "actions", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "step", ".", "getWait", "(", ")", ")", "{", "StepContext", "context", "=", "getContext", "(", ")", ";", "actions", ".", "add", "(", "new", "BuildTriggerAction", "(", "context", ",", "step", ".", "isPropagate", "(", ")", ")", ")", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINER", ",", "\"", "scheduling a build of {0} from {1}", "\"", ",", "new", "Object", "[", "]", "{", "project", ",", "context", "}", ")", ";", "}", "actions", ".", "add", "(", "new", "CauseAction", "(", "new", "Cause", ".", "UpstreamCause", "(", "invokingRun", ")", ")", ")", ";", "List", "<", "ParameterValue", ">", "parameters", "=", "step", ".", "getParameters", "(", ")", ";", "if", "(", "parameters", "!=", "null", ")", "{", "parameters", "=", "completeDefaultParameters", "(", "parameters", ",", "(", "Job", ")", "project", ")", ";", "actions", ".", "add", "(", "new", "ParametersAction", "(", "parameters", ")", ")", ";", "}", "Integer", "quietPeriod", "=", "step", ".", "getQuietPeriod", "(", ")", ";", "if", "(", "quietPeriod", "==", "null", ")", "{", "quietPeriod", "=", "project", ".", "getQuietPeriod", "(", ")", ";", "}", "QueueTaskFuture", "<", "?", ">", "f", "=", "new", "ParameterizedJobMixIn", "(", ")", "{", "@", "Override", "protected", "Job", "asJob", "(", ")", "{", "return", "(", "Job", ")", "project", ";", "}", "}", ".", "scheduleBuild2", "(", "quietPeriod", ",", "actions", ".", "toArray", "(", "new", "Action", "[", "actions", ".", "size", "(", ")", "]", ")", ")", ";", "if", "(", "f", "==", "null", ")", "{", "throw", "new", "AbortException", "(", "\"", "Failed to trigger build of ", "\"", "+", "project", ".", "getFullName", "(", ")", ")", ";", "}", "}", "else", "if", "(", "item", "instanceof", "Queue", ".", "Task", ")", "{", "if", "(", "step", ".", "getParameters", "(", ")", "!=", "null", "&&", "!", "step", ".", "getParameters", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "AbortException", "(", "\"", "Item type does not support parameters", "\"", ")", ";", "}", "Queue", ".", "Task", "task", "=", "(", "Queue", ".", "Task", ")", "item", ";", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Scheduling item: ", "\"", "+", "ModelHyperlinkNote", ".", "encodeTo", "(", "item", ")", ")", ";", "node", ".", "addAction", "(", "new", "LabelAction", "(", "Messages", ".", "BuildTriggerStepExecution_building_", "(", "task", ".", "getFullDisplayName", "(", ")", ")", ")", ")", ";", "List", "<", "Action", ">", "actions", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "step", ".", "getWait", "(", ")", ")", "{", "StepContext", "context", "=", "getContext", "(", ")", ";", "actions", ".", "add", "(", "new", "BuildTriggerAction", "(", "context", ",", "step", ".", "isPropagate", "(", ")", ")", ")", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINER", ",", "\"", "scheduling a build of {0} from {1}", "\"", ",", "new", "Object", "[", "]", "{", "task", ",", "context", "}", ")", ";", "}", "actions", ".", "add", "(", "new", "CauseAction", "(", "new", "Cause", ".", "UpstreamCause", "(", "invokingRun", ")", ")", ")", ";", "Integer", "quietPeriod", "=", "step", ".", "getQuietPeriod", "(", ")", ";", "if", "(", "quietPeriod", "==", "null", ")", "{", "try", "{", "Method", "getQuietPeriod", "=", "task", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "getQuietPeriod", "\"", ")", ";", "if", "(", "getQuietPeriod", ".", "getReturnType", "(", ")", ".", "equals", "(", "int", ".", "class", ")", ")", "{", "quietPeriod", "=", "(", "Integer", ")", "getQuietPeriod", ".", "invoke", "(", "task", ")", ";", "}", "}", "catch", "(", "NoSuchMethodException", "e", ")", "{", "}", "catch", "(", "IllegalAccessError", "|", "IllegalArgumentException", "|", "InvocationTargetException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Could not determine quiet period of ", "\"", "+", "item", ".", "getFullName", "(", ")", ",", "e", ")", ";", "}", "}", "if", "(", "quietPeriod", "==", "null", ")", "{", "quietPeriod", "=", "Jenkins", ".", "getActiveInstance", "(", ")", ".", "getQuietPeriod", "(", ")", ";", "}", "ScheduleResult", "scheduleResult", "=", "Jenkins", ".", "getActiveInstance", "(", ")", ".", "getQueue", "(", ")", ".", "schedule2", "(", "task", ",", "quietPeriod", ",", "actions", ")", ";", "if", "(", "scheduleResult", ".", "isRefused", "(", ")", ")", "{", "throw", "new", "AbortException", "(", "\"", "Failed to trigger build of ", "\"", "+", "item", ".", "getFullName", "(", ")", ")", ";", "}", "}", "else", "{", "throw", "new", "AbortException", "(", "\"", "The item named ", "\"", "+", "job", "+", "\"", " is a ", "\"", "+", "(", "item", "instanceof", "Describable", "?", "(", "(", "Describable", ")", "item", ")", ".", "getDescriptor", "(", ")", ".", "getDisplayName", "(", ")", ":", "item", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", "+", "\"", " which is not something that can be built", "\"", ")", ";", "}", "if", "(", "step", ".", "getWait", "(", ")", ")", "{", "return", "false", ";", "}", "else", "{", "getContext", "(", ")", ".", "onSuccess", "(", "null", ")", ";", "return", "true", ";", "}", "}"], "idx": 64208, "cwe": "CWE-532", "target": 0, "status": "FIXED", "commit": "3dfefdec1f7b2a4ee0ef8902afdea720b1572cb3", "function_name": "start", "body_hash": "e613783d5a3c62f3216514ba268e1d9c27cb8395"}
{"code": "private void prepareRequest() throws IOException {\n\n        contentDelimitation = false;\n\n        if (endpoint.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents != null &&\n                        restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        // HTTP specs say an HTTP 1.1 server should accept any recognised\n        // HTTP 1.x header from a 1.x client unless the specs says otherwise.\n        if (!http09) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    // Invalid transfer encoding\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n                }\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n                keepAlive = false;\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "contentDelimitation", "=", "false", ";", "if", "(", "endpoint", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEP_ALIVE_HEADER_VALUE_TOKEN", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "inputBuffer", ".", "setSwallowInput", "(", "false", ")", ";", "request", ".", "setExpectation", "(", "true", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "(", "http11", "||", "keepAlive", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", "!=", "null", "&&", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "protocol", ".", "getAllowHostHeaderMismatch", "(", ")", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "inputBuffer", ".", "getFilters", "(", ")", ";", "if", "(", "!", "http09", ")", "{", "MessageBytes", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ")", "{", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidTransferEncoding", "\"", ")", ";", "}", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 55774, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "da0e7cb093cf68b052d9175e469dbd0464441b0b", "function_name": "prepareRequest", "body_hash": "655e24f425e9340f0d577422c79db092ab9c516d"}
{"code": "public T newInstance(@Nullable StaplerRequest req, @Nonnull JSONObject formData) throws FormException {\n        try {\n            Method m = getClass().getMethod(\"newInstance\", StaplerRequest.class);\n\n            if(!Modifier.isAbstract(m.getDeclaringClass().getModifiers())) {\n                // this class overrides newInstance(StaplerRequest).\n                // maintain the backward compatible behavior\n                return verifyNewInstance(newInstance(req));\n            } else {\n                if (req==null) {\n                    // yes, req is supposed to be always non-null, but see the note above\n                    return verifyNewInstance(clazz.newInstance());\n                }\n\n                // new behavior as of 1.206\n                BindInterceptor oldInterceptor = req.getBindInterceptor();\n                try {\n                    NewInstanceBindInterceptor interceptor;\n                    if (oldInterceptor instanceof NewInstanceBindInterceptor) {\n                        interceptor = (NewInstanceBindInterceptor) oldInterceptor;\n                    } else {\n                        interceptor = new NewInstanceBindInterceptor(oldInterceptor);\n                        req.setBindInterceptor(interceptor);\n                    }\n                    interceptor.processed.put(formData, true);\n                    return verifyNewInstance(req.bindJSON(clazz, formData));\n                } finally {\n                    req.setBindInterceptor(oldInterceptor);\n                }\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(e); // impossible\n        } catch (InstantiationException | IllegalAccessException | RuntimeException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+RedactSecretJsonInErrorMessageSanitizer.INSTANCE.sanitize(formData),e);\n        }\n    }", "code_tokens": ["public", "T", "newInstance", "(", "@", "Nullable", "StaplerRequest", "req", ",", "@", "Nonnull", "JSONObject", "formData", ")", "throws", "FormException", "{", "try", "{", "Method", "m", "=", "getClass", "(", ")", ".", "getMethod", "(", "\"", "newInstance", "\"", ",", "StaplerRequest", ".", "class", ")", ";", "if", "(", "!", "Modifier", ".", "isAbstract", "(", "m", ".", "getDeclaringClass", "(", ")", ".", "getModifiers", "(", ")", ")", ")", "{", "return", "verifyNewInstance", "(", "newInstance", "(", "req", ")", ")", ";", "}", "else", "{", "if", "(", "req", "==", "null", ")", "{", "return", "verifyNewInstance", "(", "clazz", ".", "newInstance", "(", ")", ")", ";", "}", "BindInterceptor", "oldInterceptor", "=", "req", ".", "getBindInterceptor", "(", ")", ";", "try", "{", "NewInstanceBindInterceptor", "interceptor", ";", "if", "(", "oldInterceptor", "instanceof", "NewInstanceBindInterceptor", ")", "{", "interceptor", "=", "(", "NewInstanceBindInterceptor", ")", "oldInterceptor", ";", "}", "else", "{", "interceptor", "=", "new", "NewInstanceBindInterceptor", "(", "oldInterceptor", ")", ";", "req", ".", "setBindInterceptor", "(", "interceptor", ")", ";", "}", "interceptor", ".", "processed", ".", "put", "(", "formData", ",", "true", ")", ";", "return", "verifyNewInstance", "(", "req", ".", "bindJSON", "(", "clazz", ",", "formData", ")", ")", ";", "}", "finally", "{", "req", ".", "setBindInterceptor", "(", "oldInterceptor", ")", ";", "}", "}", "}", "catch", "(", "NoSuchMethodException", "e", ")", "{", "throw", "new", "AssertionError", "(", "e", ")", ";", "}", "catch", "(", "InstantiationException", "|", "IllegalAccessException", "|", "RuntimeException", "e", ")", "{", "throw", "new", "Error", "(", "\"", "Failed to instantiate ", "\"", "+", "clazz", "+", "\"", " from ", "\"", "+", "RedactSecretJsonInErrorMessageSanitizer", ".", "INSTANCE", ".", "sanitize", "(", "formData", ")", ",", "e", ")", ";", "}", "}"], "idx": 14420, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "7366cc50106442a021c5178cd101057ecc08f2c2", "function_name": "newInstance", "body_hash": "3705057c5be723b2eec3237835f374c893f4cebb"}
{"code": "protected void addEmptyValueMapping(DefaultMapper mapper, String field, Object model) {\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tExpression target = expressionParser.parseExpression(field, parserContext);\n\t\ttry {\n\t\t\tClass<?> propertyType = target.getValueType(model);\n\t\t\tExpression source = new StaticExpression(getEmptyValue(propertyType));\n\t\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Adding empty value mapping for parameter '\" + field + \"'\");\n\t\t\t}\n\t\t\tmapper.addMapping(mapping);\n\t\t} catch (EvaluationException e) {\n\t\t}\n\t}", "code_tokens": ["protected", "void", "addEmptyValueMapping", "(", "DefaultMapper", "mapper", ",", "String", "field", ",", "Object", "model", ")", "{", "ParserContext", "parserContext", "=", "new", "FluentParserContext", "(", ")", ".", "evaluate", "(", "model", ".", "getClass", "(", ")", ")", ";", "Expression", "target", "=", "expressionParser", ".", "parseExpression", "(", "field", ",", "parserContext", ")", ";", "try", "{", "Class", "<", "?", ">", "propertyType", "=", "target", ".", "getValueType", "(", "model", ")", ";", "Expression", "source", "=", "new", "StaticExpression", "(", "getEmptyValue", "(", "propertyType", ")", ")", ";", "DefaultMapping", "mapping", "=", "new", "DefaultMapping", "(", "source", ",", "target", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Adding empty value mapping for parameter '", "\"", "+", "field", "+", "\"", "'", "\"", ")", ";", "}", "mapper", ".", "addMapping", "(", "mapping", ")", ";", "}", "catch", "(", "EvaluationException", "e", ")", "{", "}", "}"], "idx": 1325, "cwe": "CWE-1188", "target": 1, "status": "VULNERABLE", "commit": "57f2ccb66946943fbf3b3f2165eac1c8eb6b1523", "function_name": "addEmptyValueMapping", "body_hash": "eb4d29a2d3ceff0dd965d397e0bd0f0469aeb21f"}
{"code": "@RequestMapping(\"/module/htmlformentry/htmlFormFromFile.form\")\n\tpublic void handleRequest(Model model, @RequestParam(value = \"filePath\", required = false) String filePath,\n\t                          @RequestParam(value = \"patientId\", required = false) Integer pId,\n\t                          @RequestParam(value = \"isFileUpload\", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\n        Context.requirePrivilege(\"Manage Forms\");\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"In reference data...\");\n\t\t\n\t\tmodel.addAttribute(\"previewHtml\", \"\");\n\t\tString message = \"\";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\"htmlFormFile\");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \"You must specify a file path to preview from file\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\"filePath\", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \"UTF-8\");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \"<script>\" + fes.getFieldAccessorJavascript() + \"</script>\";\n                }\n\t\t\t\tmodel.addAttribute(\"previewHtml\", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \"\";\n\t\t\t} else {\n\t\t\t\tmessage = \"Please specify a valid file path or select a valid file.\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"An error occurred while loading the html.\", e);\n\t\t\tmessage = \"An error occurred while loading the html. \" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"message\", message);\n\t\tmodel.addAttribute(\"isFileUpload\", isFileUpload);\n\t}", "code_tokens": ["@", "RequestMapping", "(", "\"", "/module/htmlformentry/htmlFormFromFile.form", "\"", ")", "public", "void", "handleRequest", "(", "Model", "model", ",", "@", "RequestParam", "(", "value", "=", "\"", "filePath", "\"", ",", "required", "=", "false", ")", "String", "filePath", ",", "@", "RequestParam", "(", "value", "=", "\"", "patientId", "\"", ",", "required", "=", "false", ")", "Integer", "pId", ",", "@", "RequestParam", "(", "value", "=", "\"", "isFileUpload", "\"", ",", "required", "=", "false", ")", "boolean", "isFileUpload", ",", "HttpServletRequest", "request", ")", "throws", "Exception", "{", "Context", ".", "requirePrivilege", "(", "\"", "Manage Forms", "\"", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "In reference data...", "\"", ")", ";", "model", ".", "addAttribute", "(", "\"", "previewHtml", "\"", ",", "\"", "\"", ")", ";", "String", "message", "=", "\"", "\"", ";", "File", "f", "=", "null", ";", "try", "{", "if", "(", "isFileUpload", ")", "{", "MultipartHttpServletRequest", "multipartRequest", "=", "(", "MultipartHttpServletRequest", ")", "request", ";", "MultipartFile", "multipartFile", "=", "multipartRequest", ".", "getFile", "(", "\"", "htmlFormFile", "\"", ")", ";", "if", "(", "multipartFile", "!=", "null", ")", "{", "f", "=", "new", "File", "(", "SystemUtils", ".", "JAVA_IO_TMPDIR", ",", "TEMP_HTML_FORM_FILE_PREFIX", "+", "Context", ".", "getAuthenticatedUser", "(", ")", ".", "getSystemId", "(", ")", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "f", ".", "createNewFile", "(", ")", ";", "filePath", "=", "f", ".", "getAbsolutePath", "(", ")", ";", "FileOutputStream", "fileOut", "=", "new", "FileOutputStream", "(", "f", ")", ";", "IOUtils", ".", "copy", "(", "multipartFile", ".", "getInputStream", "(", ")", ",", "fileOut", ")", ";", "fileOut", ".", "close", "(", ")", ";", "}", "}", "else", "{", "if", "(", "StringUtils", ".", "hasText", "(", "filePath", ")", ")", "{", "f", "=", "new", "File", "(", "filePath", ")", ";", "}", "else", "{", "message", "=", "\"", "You must specify a file path to preview from file", "\"", ";", "}", "}", "if", "(", "f", "!=", "null", "&&", "f", ".", "exists", "(", ")", "&&", "f", ".", "canRead", "(", ")", ")", "{", "model", ".", "addAttribute", "(", "\"", "filePath", "\"", ",", "filePath", ")", ";", "StringWriter", "writer", "=", "new", "StringWriter", "(", ")", ";", "IOUtils", ".", "copy", "(", "new", "FileInputStream", "(", "f", ")", ",", "writer", ",", "\"", "UTF-8", "\"", ")", ";", "String", "xml", "=", "writer", ".", "toString", "(", ")", ";", "Patient", "p", "=", "null", ";", "if", "(", "pId", "!=", "null", ")", "{", "p", "=", "Context", ".", "getPatientService", "(", ")", ".", "getPatient", "(", "pId", ")", ";", "}", "else", "{", "p", "=", "HtmlFormEntryUtil", ".", "getFakePerson", "(", ")", ";", "}", "HtmlForm", "fakeForm", "=", "new", "HtmlForm", "(", ")", ";", "fakeForm", ".", "setXmlData", "(", "xml", ")", ";", "FormEntrySession", "fes", "=", "new", "FormEntrySession", "(", "p", ",", "null", ",", "Mode", ".", "ENTER", ",", "fakeForm", ",", "request", ".", "getSession", "(", ")", ")", ";", "String", "html", "=", "fes", ".", "getHtmlToDisplay", "(", ")", ";", "if", "(", "fes", ".", "getFieldAccessorJavascript", "(", ")", "!=", "null", ")", "{", "html", "+=", "\"", "<script>", "\"", "+", "fes", ".", "getFieldAccessorJavascript", "(", ")", "+", "\"", "</script>", "\"", ";", "}", "model", ".", "addAttribute", "(", "\"", "previewHtml", "\"", ",", "html", ")", ";", "message", "=", "\"", "\"", ";", "}", "else", "{", "message", "=", "\"", "Please specify a valid file path or select a valid file.", "\"", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "An error occurred while loading the html.", "\"", ",", "e", ")", ";", "message", "=", "\"", "An error occurred while loading the html. ", "\"", "+", "e", ".", "getMessage", "(", ")", ";", "}", "model", ".", "addAttribute", "(", "\"", "message", "\"", ",", "message", ")", ";", "model", ".", "addAttribute", "(", "\"", "isFileUpload", "\"", ",", "isFileUpload", ")", ";", "}"], "idx": 10439, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "86f35221c8a57cdd7557ce731a56b90db216c8e0", "function_name": "handleRequest", "body_hash": "10e47015b85b62b6f0eafaf4cc271d863edbf0c9"}
{"code": "public ResourceInvoker match(HttpRequest request, int start)\r\n   {\r\n      if (!CACHE) {\r\n         return root.match(request, start).invoker;\r\n      }\r\n      MatchCache.Key key = new MatchCache.Key(request, start);\r\n      MatchCache match = cache.get(key);\r\n      if (match != null) {\r\n         //System.out.println(\"*** cache hit: \" + key.method + \" \" + key.path);\r\n         request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\r\n      } else {\r\n         match = root.match(request, start);\r\n         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\r\n            //System.out.println(\"*** caching: \" + key.method + \" \" + key.path);\r\n            match.match = null;\r\n            cache.putIfAbsent(key, match);\r\n         }\r\n      }\r\n      return match.invoker;\r\n   }", "code_tokens": ["public", "ResourceInvoker", "match", "(", "HttpRequest", "request", ",", "int", "start", ")", "{", "if", "(", "!", "CACHE", ")", "{", "return", "root", ".", "match", "(", "request", ",", "start", ")", ".", "invoker", ";", "}", "MatchCache", ".", "Key", "key", "=", "new", "MatchCache", ".", "Key", "(", "request", ",", "start", ")", ";", "MatchCache", "match", "=", "cache", ".", "get", "(", "key", ")", ";", "if", "(", "match", "!=", "null", ")", "{", "request", ".", "setAttribute", "(", "RESTEASY_CHOSEN_ACCEPT", ",", "match", ".", "chosen", ")", ";", "}", "else", "{", "match", "=", "root", ".", "match", "(", "request", ",", "start", ")", ";", "if", "(", "match", ".", "match", "!=", "null", "&&", "match", ".", "match", ".", "expression", ".", "getNumGroups", "(", ")", "==", "0", "&&", "match", ".", "invoker", "instanceof", "ResourceMethodInvoker", ")", "{", "match", ".", "match", "=", "null", ";", "cache", ".", "putIfAbsent", "(", "key", ",", "match", ")", ";", "}", "}", "return", "match", ".", "invoker", ";", "}"], "idx": 115267, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "dd255d654f15b5b270a166d695f8813dc08675d4", "function_name": "match", "body_hash": "56ae060f417212ba88509a02c5fa19746fad1c50"}
{"code": "private void enumerateChmDirectoryListingList(ChmItsfHeader chmItsHeader,\n            ChmItspHeader chmItspHeader) throws TikaException {\n        try {\n            int startPmgl = chmItspHeader.getIndex_head();\n            int stopPmgl = chmItspHeader.getUnknown_0024();\n            int dir_offset = (int) (chmItsHeader.getDirOffset() + chmItspHeader\n                    .getHeader_len());\n            setDataOffset(chmItsHeader.getDataOffset());\n\n            /* loops over all pmgls */\n            byte[] dir_chunk = null;\n            for (int i = startPmgl; i>=0; ) {\n                dir_chunk = new byte[(int) chmItspHeader.getBlock_len()];\n                int start = i * (int) chmItspHeader.getBlock_len() + dir_offset;\n                dir_chunk = ChmCommons\n                        .copyOfRange(getData(), start,\n                                start +(int) chmItspHeader.getBlock_len());\n\n                PMGLheader = new ChmPmglHeader();\n                PMGLheader.parse(dir_chunk, PMGLheader);\n                enumerateOneSegment(dir_chunk);\n                \n                i=PMGLheader.getBlockNext();\n                dir_chunk = null;\n            }\n        } catch (ChmParsingException e) {\n            LOG.warn(\"Chm parse exception\", e);\n        } finally {\n            setData(null);\n        }\n    }", "code_tokens": ["private", "void", "enumerateChmDirectoryListingList", "(", "ChmItsfHeader", "chmItsHeader", ",", "ChmItspHeader", "chmItspHeader", ")", "throws", "TikaException", "{", "try", "{", "int", "startPmgl", "=", "chmItspHeader", ".", "getIndex_head", "(", ")", ";", "int", "stopPmgl", "=", "chmItspHeader", ".", "getUnknown_0024", "(", ")", ";", "int", "dir_offset", "=", "(", "int", ")", "(", "chmItsHeader", ".", "getDirOffset", "(", ")", "+", "chmItspHeader", ".", "getHeader_len", "(", ")", ")", ";", "setDataOffset", "(", "chmItsHeader", ".", "getDataOffset", "(", ")", ")", ";", "byte", "[", "]", "dir_chunk", "=", "null", ";", "for", "(", "int", "i", "=", "startPmgl", ";", "i", ">=", "0", ";", ")", "{", "dir_chunk", "=", "new", "byte", "[", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", "]", ";", "int", "start", "=", "i", "*", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", "+", "dir_offset", ";", "dir_chunk", "=", "ChmCommons", ".", "copyOfRange", "(", "getData", "(", ")", ",", "start", ",", "start", "+", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", ")", ";", "PMGLheader", "=", "new", "ChmPmglHeader", "(", ")", ";", "PMGLheader", ".", "parse", "(", "dir_chunk", ",", "PMGLheader", ")", ";", "enumerateOneSegment", "(", "dir_chunk", ")", ";", "i", "=", "PMGLheader", ".", "getBlockNext", "(", ")", ";", "dir_chunk", "=", "null", ";", "}", "}", "catch", "(", "ChmParsingException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Chm parse exception", "\"", ",", "e", ")", ";", "}", "finally", "{", "setData", "(", "null", ")", ";", "}", "}"], "idx": 109048, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "ffb48dd29d0c2009490caefda75e5b57c7958c51", "function_name": "enumerateChmDirectoryListingList", "body_hash": "5657d7fdf98e11541cdea77eaf21bc4c8cd245aa"}
{"code": "@Override\n    public void init(ServletConfig config) throws ServletException {\n\n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n\n        // Initialize the JSP Runtime Context\n        // Check for a custom Options implementation\n        String engineOptionsName = config.getInitParameter(\"engineOptionsClass\");\n        if (Constants.IS_SECURITY_ENABLED && engineOptionsName != null) {\n            log.info(Localizer.getMessage(\n                    \"jsp.info.ignoreSetting\", \"engineOptionsClass\", engineOptionsName));\n            engineOptionsName = null;\n        }\n        if (engineOptionsName != null) {\n            // Instantiate the indicated Options implementation\n            try {\n                ClassLoader loader = Thread.currentThread().getContextClassLoader();\n                Class<?> engineOptionsClass = loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig = { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor = engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                // Need to localize this.\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                // Use the default Options implementation\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            // Use the default Options implementation\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    return;\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"Can not locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "init", "(", "ServletConfig", "config", ")", "throws", "ServletException", "{", "super", ".", "init", "(", "config", ")", ";", "this", ".", "config", "=", "config", ";", "this", ".", "context", "=", "config", ".", "getServletContext", "(", ")", ";", "String", "engineOptionsName", "=", "config", ".", "getInitParameter", "(", "\"", "engineOptionsClass", "\"", ")", ";", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", "&&", "engineOptionsName", "!=", "null", ")", "{", "log", ".", "info", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.info.ignoreSetting", "\"", ",", "\"", "engineOptionsClass", "\"", ",", "engineOptionsName", ")", ")", ";", "engineOptionsName", "=", "null", ";", "}", "if", "(", "engineOptionsName", "!=", "null", ")", "{", "try", "{", "ClassLoader", "loader", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "Class", "<", "?", ">", "engineOptionsClass", "=", "loader", ".", "loadClass", "(", "engineOptionsName", ")", ";", "Class", "<", "?", ">", "[", "]", "ctorSig", "=", "{", "ServletConfig", ".", "class", ",", "ServletContext", ".", "class", "}", ";", "Constructor", "<", "?", ">", "ctor", "=", "engineOptionsClass", ".", "getConstructor", "(", "ctorSig", ")", ";", "Object", "[", "]", "args", "=", "{", "config", ",", "context", "}", ";", "options", "=", "(", "Options", ")", "ctor", ".", "newInstance", "(", "args", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "e", "=", "ExceptionUtils", ".", "unwrapInvocationTargetException", "(", "e", ")", ";", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "log", ".", "warn", "(", "\"", "Failed to load engineOptionsClass", "\"", ",", "e", ")", ";", "options", "=", "new", "EmbeddedServletOptions", "(", "config", ",", "context", ")", ";", "}", "}", "else", "{", "options", "=", "new", "EmbeddedServletOptions", "(", "config", ",", "context", ")", ";", "}", "rctxt", "=", "new", "JspRuntimeContext", "(", "context", ",", "options", ")", ";", "if", "(", "config", ".", "getInitParameter", "(", "\"", "jspFile", "\"", ")", "!=", "null", ")", "{", "jspFile", "=", "config", ".", "getInitParameter", "(", "\"", "jspFile", "\"", ")", ";", "try", "{", "if", "(", "null", "==", "context", ".", "getResource", "(", "jspFile", ")", ")", "{", "return", ";", "}", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "throw", "new", "ServletException", "(", "\"", "Can not locate jsp file", "\"", ",", "e", ")", ";", "}", "try", "{", "if", "(", "SecurityUtil", ".", "isPackageProtectionEnabled", "(", ")", ")", "{", "AccessController", ".", "doPrivileged", "(", "new", "PrivilegedExceptionAction", "<", "Object", ">", "(", ")", "{", "@", "Override", "public", "Object", "run", "(", ")", "throws", "IOException", ",", "ServletException", "{", "serviceJspFile", "(", "null", ",", "null", ",", "jspFile", ",", "true", ")", ";", "return", "null", ";", "}", "}", ")", ";", "}", "else", "{", "serviceJspFile", "(", "null", ",", "null", ",", "jspFile", ",", "true", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "ServletException", "(", "\"", "Could not precompile jsp: ", "\"", "+", "jspFile", ",", "e", ")", ";", "}", "catch", "(", "PrivilegedActionException", "e", ")", "{", "Throwable", "t", "=", "e", ".", "getCause", "(", ")", ";", "if", "(", "t", "instanceof", "ServletException", ")", "throw", "(", "ServletException", ")", "t", ";", "throw", "new", "ServletException", "(", "\"", "Could not precompile jsp: ", "\"", "+", "jspFile", ",", "e", ")", ";", "}", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.message.scratch.dir.is", "\"", ",", "options", ".", "getScratchDir", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "log", ".", "debug", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.message.dont.modify.servlets", "\"", ")", ")", ";", "}", "}"], "idx": 101781, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "d98fa92b9dfc90fe1ffdaa3cce1be3be84532260", "function_name": "init", "body_hash": "1b2f98da7f8642a0b93319d0968e9a6440e345f7"}
{"code": "@Override\n        public void handle( String target,\n                            Request baseRequest,\n                            HttpServletRequest request,\n                            HttpServletResponse response ) throws IOException,\n                                                          ServletException\n        {\n            // define small medium and large.\n            // This should be turned for your content, JVM and OS, but we will\n            // huge HTTP response buffer size as a measure\n            final int SMALL = response.getBufferSize();\n            final int MEDIUM = 8 * SMALL;\n\n            // What file to serve?\n            final File file = new File(this.dir, request.getPathInfo());\n\n            // Only handle existing files\n            if (!file.exists())\n                return;\n\n            // we will handle this request\n            baseRequest.setHandled(true);\n\n            // Handle directories\n            if (file.isDirectory())\n            {\n                if (!request.getPathInfo().endsWith(URIUtil.SLASH))\n                {\n                    response.sendRedirect(response.encodeRedirectURL(URIUtil\n                            .addPaths(request.getRequestURI(), URIUtil.SLASH)));\n                    return;\n                }\n                String listing = Resource.newResource(file).getListHTML(\n                        request.getRequestURI(),\n                        request.getPathInfo().lastIndexOf(\"/\") > 0,\n                        request.getQueryString());\n                response.setContentType(\"text/html; charset=utf-8\");\n                response.getWriter().println(listing);\n                return;\n            }\n\n            // Set some content headers.\n            \n            // Jetty DefaultServlet will cache formatted date strings, but we\n            // will reformat for each request here\n            response.setDateHeader(\"Last-Modified\", file.lastModified());\n            response.setDateHeader(\"Content-Length\", file.length());\n            response.setContentType(mimeTypes.getMimeByExtension(file.getName()));\n\n            // send \"small\" files blocking directly from an input stream\n            if (file.length() < SMALL)\n            {\n                // need to caste to Jetty output stream for best API\n                ((HttpOutput) response.getOutputStream())\n                        .sendContent(FileChannel.open(file.toPath(),\n                                StandardOpenOption.READ));\n                return;\n            }\n\n            // send not \"small\" files asynchronously so we don't hold threads if\n            // the client is slow\n            final AsyncContext async = request.startAsync();\n            Callback completionCB = new Callback()\n            {\n                @Override\n                public void succeeded()\n                {\n                    // Async content write succeeded, so complete async response\n                    async.complete();\n                }\n\n                @Override\n                public void failed( Throwable x )\n                {\n                    // log error and complete async response;\n                    x.printStackTrace();\n                    async.complete();\n                }\n            };\n\n            // send \"medium\" files from an input stream\n            if (file.length() < MEDIUM)\n            {\n                // the file channel is closed by the async send\n                ((HttpOutput) response.getOutputStream())\n                        .sendContent(FileChannel.open(file.toPath(),\n                                StandardOpenOption.READ), completionCB);\n                return;\n            }\n\n            // for \"large\" files get the file mapped buffer to send Typically\n            // the resulting buffer should be cached as allocating kernel memory\n            // can be hard to GC on some JVMs. But for this example we will\n            // create a new buffer per file\n            ByteBuffer buffer;\n            try ( RandomAccessFile raf = new RandomAccessFile(file, \"r\"); )\n            {\n                buffer = raf.getChannel().map(MapMode.READ_ONLY, 0,\n                        raf.length());\n            }\n\n            // Assuming the file buffer might be shared cached version, so lets\n            // take our own view of it\n            buffer = buffer.asReadOnlyBuffer();\n\n            // send the content as a buffer with a callback to complete the\n            // async request need to caste to Jetty output stream for best API\n            ((HttpOutput) response.getOutputStream()).sendContent(buffer,\n                    completionCB);\n        }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "String", "target", ",", "Request", "baseRequest", ",", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "IOException", ",", "ServletException", "{", "final", "int", "SMALL", "=", "response", ".", "getBufferSize", "(", ")", ";", "final", "int", "MEDIUM", "=", "8", "*", "SMALL", ";", "final", "File", "file", "=", "new", "File", "(", "this", ".", "dir", ",", "request", ".", "getPathInfo", "(", ")", ")", ";", "if", "(", "!", "file", ".", "exists", "(", ")", ")", "return", ";", "baseRequest", ".", "setHandled", "(", "true", ")", ";", "if", "(", "file", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "request", ".", "getPathInfo", "(", ")", ".", "endsWith", "(", "URIUtil", ".", "SLASH", ")", ")", "{", "response", ".", "sendRedirect", "(", "response", ".", "encodeRedirectURL", "(", "URIUtil", ".", "addPaths", "(", "request", ".", "getRequestURI", "(", ")", ",", "URIUtil", ".", "SLASH", ")", ")", ")", ";", "return", ";", "}", "String", "listing", "=", "Resource", ".", "newResource", "(", "file", ")", ".", "getListHTML", "(", "request", ".", "getRequestURI", "(", ")", ",", "request", ".", "getPathInfo", "(", ")", ".", "lastIndexOf", "(", "\"", "/", "\"", ")", ">", "0", ",", "request", ".", "getQueryString", "(", ")", ")", ";", "response", ".", "setContentType", "(", "\"", "text/html; charset=utf-8", "\"", ")", ";", "response", ".", "getWriter", "(", ")", ".", "println", "(", "listing", ")", ";", "return", ";", "}", "response", ".", "setDateHeader", "(", "\"", "Last-Modified", "\"", ",", "file", ".", "lastModified", "(", ")", ")", ";", "response", ".", "setDateHeader", "(", "\"", "Content-Length", "\"", ",", "file", ".", "length", "(", ")", ")", ";", "response", ".", "setContentType", "(", "mimeTypes", ".", "getMimeByExtension", "(", "file", ".", "getName", "(", ")", ")", ")", ";", "if", "(", "file", ".", "length", "(", ")", "<", "SMALL", ")", "{", "(", "(", "HttpOutput", ")", "response", ".", "getOutputStream", "(", ")", ")", ".", "sendContent", "(", "FileChannel", ".", "open", "(", "file", ".", "toPath", "(", ")", ",", "StandardOpenOption", ".", "READ", ")", ")", ";", "return", ";", "}", "final", "AsyncContext", "async", "=", "request", ".", "startAsync", "(", ")", ";", "Callback", "completionCB", "=", "new", "Callback", "(", ")", "{", "@", "Override", "public", "void", "succeeded", "(", ")", "{", "async", ".", "complete", "(", ")", ";", "}", "@", "Override", "public", "void", "failed", "(", "Throwable", "x", ")", "{", "x", ".", "printStackTrace", "(", ")", ";", "async", ".", "complete", "(", ")", ";", "}", "}", ";", "if", "(", "file", ".", "length", "(", ")", "<", "MEDIUM", ")", "{", "(", "(", "HttpOutput", ")", "response", ".", "getOutputStream", "(", ")", ")", ".", "sendContent", "(", "FileChannel", ".", "open", "(", "file", ".", "toPath", "(", ")", ",", "StandardOpenOption", ".", "READ", ")", ",", "completionCB", ")", ";", "return", ";", "}", "ByteBuffer", "buffer", ";", "try", "(", "RandomAccessFile", "raf", "=", "new", "RandomAccessFile", "(", "file", ",", "\"", "r", "\"", ")", ";", ")", "{", "buffer", "=", "raf", ".", "getChannel", "(", ")", ".", "map", "(", "MapMode", ".", "READ_ONLY", ",", "0", ",", "raf", ".", "length", "(", ")", ")", ";", "}", "buffer", "=", "buffer", ".", "asReadOnlyBuffer", "(", ")", ";", "(", "(", "HttpOutput", ")", "response", ".", "getOutputStream", "(", ")", ")", ".", "sendContent", "(", "buffer", ",", "completionCB", ")", ";", "}"], "idx": 79151, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "ca77bd384a2970cabbbdab25cf6251c6fb76cd21", "function_name": "handle", "body_hash": "4e5cc02908d0827eb64d1aad85ec85696e59021e"}
{"code": "private void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser;\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n            } else {\n                original = Thread.currentThread().getContextClassLoader();\n            }\n        try {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa =\n                        new PrivilegedSetTccl(JspDocumentParser.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(\n                        JspDocumentParser.class.getClassLoader());\n            }\n\n            parser = new TagPluginParser(ctxt, blockExternal);\n\n        } finally {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n            }\n        }\n\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }", "code_tokens": ["private", "void", "init", "(", "ErrorDispatcher", "err", ")", "throws", "JasperException", "{", "if", "(", "initialized", ")", "return", ";", "String", "blockExternalString", "=", "ctxt", ".", "getInitParameter", "(", "Constants", ".", "XML_BLOCK_EXTERNAL_INIT_PARAM", ")", ";", "boolean", "blockExternal", ";", "if", "(", "blockExternalString", "==", "null", ")", "{", "blockExternal", "=", "true", ";", "}", "else", "{", "blockExternal", "=", "Boolean", ".", "parseBoolean", "(", "blockExternalString", ")", ";", "}", "TagPluginParser", "parser", ";", "ClassLoader", "original", ";", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedGetTccl", "pa", "=", "new", "PrivilegedGetTccl", "(", ")", ";", "original", "=", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "original", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "}", "try", "{", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedSetTccl", "pa", "=", "new", "PrivilegedSetTccl", "(", "JspDocumentParser", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "Thread", ".", "currentThread", "(", ")", ".", "setContextClassLoader", "(", "JspDocumentParser", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "}", "parser", "=", "new", "TagPluginParser", "(", "ctxt", ",", "blockExternal", ")", ";", "}", "finally", "{", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedSetTccl", "pa", "=", "new", "PrivilegedSetTccl", "(", "original", ")", ";", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "Thread", ".", "currentThread", "(", ")", ".", "setContextClassLoader", "(", "original", ")", ";", "}", "}", "try", "{", "Enumeration", "<", "URL", ">", "urls", "=", "ctxt", ".", "getClassLoader", "(", ")", ".", "getResources", "(", "META_INF_JASPER_TAG_PLUGINS_XML", ")", ";", "if", "(", "urls", "!=", "null", ")", "{", "while", "(", "urls", ".", "hasMoreElements", "(", ")", ")", "{", "URL", "url", "=", "urls", ".", "nextElement", "(", ")", ";", "parser", ".", "parse", "(", "url", ")", ";", "}", "}", "URL", "url", "=", "ctxt", ".", "getResource", "(", "TAG_PLUGINS_XML", ")", ";", "if", "(", "url", "!=", "null", ")", "{", "parser", ".", "parse", "(", "url", ")", ";", "}", "}", "catch", "(", "IOException", "|", "SAXException", "e", ")", "{", "throw", "new", "JasperException", "(", "e", ")", ";", "}", "Map", "<", "String", ",", "String", ">", "plugins", "=", "parser", ".", "getPlugins", "(", ")", ";", "tagPlugins", "=", "new", "HashMap", "<", ">", "(", "plugins", ".", "size", "(", ")", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "entry", ":", "plugins", ".", "entrySet", "(", ")", ")", "{", "try", "{", "String", "tagClass", "=", "entry", ".", "getKey", "(", ")", ";", "String", "pluginName", "=", "entry", ".", "getValue", "(", ")", ";", "Class", "<", "?", ">", "pluginClass", "=", "ctxt", ".", "getClassLoader", "(", ")", ".", "loadClass", "(", "pluginName", ")", ";", "TagPlugin", "plugin", "=", "(", "TagPlugin", ")", "pluginClass", ".", "newInstance", "(", ")", ";", "tagPlugins", ".", "put", "(", "tagClass", ",", "plugin", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "err", ".", "jspError", "(", "e", ")", ";", "}", "}", "initialized", "=", "true", ";", "}"], "idx": 32134, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "5517c5517e8a7ddb994504f0c5c05001a376b10c", "function_name": "init", "body_hash": "37688aa7db8c6d9f1bec985926f30b7612ac1ed1"}
{"code": "public static String resolvePath(String uri) {\n\t\tif (uri.isEmpty()) {\n\t\t\treturn uri;\n\t\t}\n\n\t\tString path;\n\t\tif (uri.charAt(0) == '/') {\n\t\t\tpath = uri;\n\t\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\t\tchar c = path.charAt(i);\n\t\t\t\tif (c == '?' || c == '#') {\n\t\t\t\t\tpath = path.substring(0, i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpath = URI.create(uri).getPath();\n\t\t}\n\t\tif (!path.isEmpty()) {\n\t\t\tif (path.charAt(0) == '/') {\n\t\t\t\tpath = path.substring(1);\n\t\t\t\tif (path.length() <= 1) {\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path.charAt(path.length() - 1) == '/') {\n\t\t\t\treturn path.substring(0, path.length() - 1);\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}", "code_tokens": ["public", "static", "String", "resolvePath", "(", "String", "uri", ")", "{", "if", "(", "uri", ".", "isEmpty", "(", ")", ")", "{", "return", "uri", ";", "}", "String", "path", ";", "if", "(", "uri", ".", "charAt", "(", "0", ")", "==", "'/'", ")", "{", "path", "=", "uri", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "path", ".", "length", "(", ")", ";", "i", "++", ")", "{", "char", "c", "=", "path", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "'?'", "||", "c", "==", "'#'", ")", "{", "path", "=", "path", ".", "substring", "(", "0", ",", "i", ")", ";", "break", ";", "}", "}", "}", "else", "{", "path", "=", "URI", ".", "create", "(", "uri", ")", ".", "getPath", "(", ")", ";", "}", "if", "(", "!", "path", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "path", ".", "charAt", "(", "0", ")", "==", "'/'", ")", "{", "path", "=", "path", ".", "substring", "(", "1", ")", ";", "if", "(", "path", ".", "length", "(", ")", "<=", "1", ")", "{", "return", "path", ";", "}", "}", "if", "(", "path", ".", "charAt", "(", "path", ".", "length", "(", ")", "-", "1", ")", "==", "'/'", ")", "{", "return", "path", ".", "substring", "(", "0", ",", "path", ".", "length", "(", ")", "-", "1", ")", ";", "}", "}", "return", "path", ";", "}"], "idx": 74862, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "9131fa0", "function_name": "resolvePath", "body_hash": "8f78a185cf52f284128c126da5921329487c3641"}
{"code": "protected Object readResolve()\r\n        throws ObjectStreamException {\r\n        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);\r\n        if (factory != null)\r\n            return factory;\r\n\r\n        // reset these transient fields to empty values\r\n        _transactional = new ConcurrentHashMap();\r\n        _brokers = newBrokerSet();\r\n\r\n        makeReadOnly();\r\n        return this;\r\n    }", "code_tokens": ["protected", "Object", "readResolve", "(", ")", "throws", "ObjectStreamException", "{", "AbstractBrokerFactory", "factory", "=", "getPooledFactoryForKey", "(", "_poolKey", ")", ";", "if", "(", "factory", "!=", "null", ")", "return", "factory", ";", "_transactional", "=", "new", "ConcurrentHashMap", "(", ")", ";", "_brokers", "=", "newBrokerSet", "(", ")", ";", "makeReadOnly", "(", ")", ";", "return", "this", ";", "}"], "idx": 33094, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "521fecd2d9b91c27e9f90d97e5f5479d17239eb8", "function_name": "readResolve", "body_hash": "4e74f21b219f45ee96a6237547a7f607a7020144"}
{"code": "private String getSkinResourcePath(String resource)\n    {\n        String skinFolder = getSkinFolder();\n        String resourcePath = skinFolder + resource;\n\n        // Prevent inclusion of templates from other directories\n        Path normalizedResource = Paths.get(resourcePath).normalize();\n        // Protect against directory attacks.\n        if (!normalizedResource.startsWith(skinFolder)) {\n            LOGGER.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);\n            return null;\n        }\n\n        return resourcePath;\n    }", "code_tokens": ["private", "String", "getSkinResourcePath", "(", "String", "resource", ")", "{", "String", "skinFolder", "=", "getSkinFolder", "(", ")", ";", "String", "resourcePath", "=", "skinFolder", "+", "resource", ";", "Path", "normalizedResource", "=", "Paths", ".", "get", "(", "resourcePath", ")", ".", "normalize", "(", ")", ";", "if", "(", "!", "normalizedResource", ".", "startsWith", "(", "skinFolder", ")", ")", "{", "LOGGER", ".", "warn", "(", "\"", "Direct access to skin file [{}] refused. Possible break-in attempt!", "\"", ",", "normalizedResource", ")", ";", "return", "null", ";", "}", "return", "resourcePath", ";", "}"], "idx": 28849, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "4917c8f355717bb636d763844528b1fe0f95e8e2", "function_name": "getSkinResourcePath", "body_hash": "723c634126685f268e30482f09f6a61cafc4bd28"}
{"code": "@Override\n  protected void doPost(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    String effectiveUser = request.getRemoteUser();\n    if (securityEnabled) {\n      try {\n        // As Thrift HTTP transport doesn't support SPNEGO yet (THRIFT-889),\n        // Kerberos authentication is being done at servlet level.\n        final RemoteUserIdentity identity = doKerberosAuth(request);\n        effectiveUser = identity.principal;\n        // It is standard for client applications expect this header.\n        // Please see http://tools.ietf.org/html/rfc4559 for more details.\n        response.addHeader(WWW_AUTHENTICATE,  NEGOTIATE + \" \" + identity.outToken);\n      } catch (HttpAuthenticationException e) {\n        LOG.error(\"Kerberos Authentication failed\", e);\n        // Send a 401 to the client\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        response.addHeader(WWW_AUTHENTICATE, NEGOTIATE);\n        response.getWriter().println(\"Authentication Error: \" + e.getMessage());\n        return;\n      }\n    }\n    String doAsUserFromQuery = request.getHeader(\"doAs\");\n    if(effectiveUser == null) {\n      effectiveUser = realUser.getShortUserName();\n    }\n    if (doAsUserFromQuery != null) {\n      if (!doAsEnabled) {\n        throw new ServletException(\"Support for proxyuser is not configured\");\n      }\n      // The authenticated remote user is attempting to perform 'doAs' proxy user.\n      UserGroupInformation remoteUser = UserGroupInformation.createRemoteUser(effectiveUser);\n      // create and attempt to authorize a proxy user (the client is attempting\n      // to do proxy user)\n      UserGroupInformation ugi = UserGroupInformation.createProxyUser(doAsUserFromQuery,\n          remoteUser);\n      // validate the proxy user authorization\n      try {\n        ProxyUsers.authorize(ugi, request.getRemoteAddr(), conf);\n      } catch (AuthorizationException e) {\n        throw new ServletException(e.getMessage());\n      }\n      effectiveUser = doAsUserFromQuery;\n    }\n    hbaseHandler.setEffectiveUser(effectiveUser);\n    super.doPost(request, response);\n  }", "code_tokens": ["@", "Override", "protected", "void", "doPost", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "String", "effectiveUser", "=", "request", ".", "getRemoteUser", "(", ")", ";", "if", "(", "securityEnabled", ")", "{", "try", "{", "final", "RemoteUserIdentity", "identity", "=", "doKerberosAuth", "(", "request", ")", ";", "effectiveUser", "=", "identity", ".", "principal", ";", "response", ".", "addHeader", "(", "WWW_AUTHENTICATE", ",", "NEGOTIATE", "+", "\"", " ", "\"", "+", "identity", ".", "outToken", ")", ";", "}", "catch", "(", "HttpAuthenticationException", "e", ")", "{", "LOG", ".", "error", "(", "\"", "Kerberos Authentication failed", "\"", ",", "e", ")", ";", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_UNAUTHORIZED", ")", ";", "response", ".", "addHeader", "(", "WWW_AUTHENTICATE", ",", "NEGOTIATE", ")", ";", "response", ".", "getWriter", "(", ")", ".", "println", "(", "\"", "Authentication Error: ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "return", ";", "}", "}", "String", "doAsUserFromQuery", "=", "request", ".", "getHeader", "(", "\"", "doAs", "\"", ")", ";", "if", "(", "effectiveUser", "==", "null", ")", "{", "effectiveUser", "=", "realUser", ".", "getShortUserName", "(", ")", ";", "}", "if", "(", "doAsUserFromQuery", "!=", "null", ")", "{", "if", "(", "!", "doAsEnabled", ")", "{", "throw", "new", "ServletException", "(", "\"", "Support for proxyuser is not configured", "\"", ")", ";", "}", "UserGroupInformation", "remoteUser", "=", "UserGroupInformation", ".", "createRemoteUser", "(", "effectiveUser", ")", ";", "UserGroupInformation", "ugi", "=", "UserGroupInformation", ".", "createProxyUser", "(", "doAsUserFromQuery", ",", "remoteUser", ")", ";", "try", "{", "ProxyUsers", ".", "authorize", "(", "ugi", ",", "request", ".", "getRemoteAddr", "(", ")", ",", "conf", ")", ";", "}", "catch", "(", "AuthorizationException", "e", ")", "{", "throw", "new", "ServletException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "effectiveUser", "=", "doAsUserFromQuery", ";", "}", "hbaseHandler", ".", "setEffectiveUser", "(", "effectiveUser", ")", ";", "super", ".", "doPost", "(", "request", ",", "response", ")", ";", "}"], "idx": 48965, "cwe": "CWE-362", "target": 0, "status": "FIXED", "commit": "0c42acbdf86d08af3003105a26a2201f75f2e2c", "function_name": "doPost", "body_hash": "3958248cf2da6abfc7c511147f8b40c95de572c8"}
{"code": "private void renewSeedInternal() {\n        String currentSeed = this.seed;\n        String newSeed = currentSeed;\n        byte[] bytes = new byte[SEED_NUM_BYTES];\n        while (Objects.equals(newSeed, currentSeed)) {\n            RANDOM.nextBytes(bytes);\n            newSeed = new String(Hex.encodeHex(bytes));\n        }\n        this.seed = newSeed;\n    }", "code_tokens": ["private", "void", "renewSeedInternal", "(", ")", "{", "String", "currentSeed", "=", "this", ".", "seed", ";", "String", "newSeed", "=", "currentSeed", ";", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "SEED_NUM_BYTES", "]", ";", "while", "(", "Objects", ".", "equals", "(", "newSeed", ",", "currentSeed", ")", ")", "{", "RANDOM", ".", "nextBytes", "(", "bytes", ")", ";", "newSeed", "=", "new", "String", "(", "Hex", ".", "encodeHex", "(", "bytes", ")", ")", ";", "}", "this", ".", "seed", "=", "newSeed", ";", "}"], "idx": 110755, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "da135e7ecb", "function_name": "renewSeedInternal", "body_hash": "979155adc258aad61897ce6eac0d6ee3402bd245"}
{"code": "public static void setHiveConfWhiteList(HiveConf hiveConf) throws HiveAuthzPluginException {\n\n    String whiteListParamsStr = hiveConf\n        .getVar(ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST);\n\n    if(whiteListParamsStr == null || whiteListParamsStr.trim().isEmpty()) {\n      throw new HiveAuthzPluginException(\"Configuration parameter \"\n          + ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST.varname\n          + \" is not initialized.\");\n    }\n\n    // append regexes that user wanted to add\n    String whiteListAppend = hiveConf\n        .getVar(ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST_APPEND);\n    if (whiteListAppend != null && !whiteListAppend.trim().equals(\"\")) {\n      whiteListParamsStr = whiteListParamsStr + \"|\" + whiteListAppend;\n    }\n\n    hiveConf.setModifiableWhiteListRegex(whiteListParamsStr);\n\n    // disallow udfs that can potentially allow untrusted code execution\n    // if admin has already customized this list, honor that\n    String curBlackList = hiveConf.getVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST);\n    if (curBlackList == null || curBlackList.trim().isEmpty()) {\n      hiveConf.setVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST, \"reflect,reflect2,java_method,in_file\");\n    }\n  }", "code_tokens": ["public", "static", "void", "setHiveConfWhiteList", "(", "HiveConf", "hiveConf", ")", "throws", "HiveAuthzPluginException", "{", "String", "whiteListParamsStr", "=", "hiveConf", ".", "getVar", "(", "ConfVars", ".", "HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST", ")", ";", "if", "(", "whiteListParamsStr", "==", "null", "||", "whiteListParamsStr", ".", "trim", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "HiveAuthzPluginException", "(", "\"", "Configuration parameter ", "\"", "+", "ConfVars", ".", "HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST", ".", "varname", "+", "\"", " is not initialized.", "\"", ")", ";", "}", "String", "whiteListAppend", "=", "hiveConf", ".", "getVar", "(", "ConfVars", ".", "HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST_APPEND", ")", ";", "if", "(", "whiteListAppend", "!=", "null", "&&", "!", "whiteListAppend", ".", "trim", "(", ")", ".", "equals", "(", "\"", "\"", ")", ")", "{", "whiteListParamsStr", "=", "whiteListParamsStr", "+", "\"", "|", "\"", "+", "whiteListAppend", ";", "}", "hiveConf", ".", "setModifiableWhiteListRegex", "(", "whiteListParamsStr", ")", ";", "String", "curBlackList", "=", "hiveConf", ".", "getVar", "(", "ConfVars", ".", "HIVE_SERVER2_BUILTIN_UDF_BLACKLIST", ")", ";", "if", "(", "curBlackList", "==", "null", "||", "curBlackList", ".", "trim", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "hiveConf", ".", "setVar", "(", "ConfVars", ".", "HIVE_SERVER2_BUILTIN_UDF_BLACKLIST", ",", "\"", "reflect,reflect2,java_method,in_file", "\"", ")", ";", "}", "}"], "idx": 102475, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "1a1d6ca1bc3ae840238dc345fa1eb2c7c28c8cb", "function_name": "setHiveConfWhiteList", "body_hash": "3918b4263f7739a0cc1ca4bd3f32db42007e30fe"}
{"code": "@Override\n    public void setAttribute(String name, Object value) {\n\n        // Name cannot be null\n        if (name == null)\n            throw new IllegalArgumentException\n                (sm.getString(\"coyoteRequest.setAttribute.namenull\"));\n\n        // Null value is the same as removeAttribute()\n        if (value == null) {\n            removeAttribute(name);\n            return;\n        }\n\n        if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {\n            internalDispatcherType = (DispatcherType)value;\n            return;\n        } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {\n            requestDispatcherPath = value;\n            return;\n        }\n        \n        if (name.equals(Globals.ASYNC_SUPPORTED_ATTR)) {\n            this.asyncSupported = (Boolean)value;\n        }\n\n        Object oldValue = null;\n        boolean replaced = false;\n\n        // Add or replace the specified attribute\n        // Check for read only attribute\n        // requests are per thread so synchronization unnecessary\n        if (readOnlyAttributes.containsKey(name)) {\n            return;\n        }\n\n        // Do the security check before any updates are made\n        if (Globals.IS_SECURITY_ENABLED &&\n                name.equals(\"org.apache.tomcat.sendfile.filename\")) {\n            // Use the canonical file name to avoid any possible symlink and\n            // relative path issues\n            String canonicalPath;\n            try {\n                canonicalPath = new File(value.toString()).getCanonicalPath();\n            } catch (IOException e) {\n                throw new SecurityException(sm.getString(\n                        \"coyoteRequest.sendfileNotCanonical\", value), e);\n            }\n            // Sendfile is performed in Tomcat's security context so need to\n            // check if the web app is permitted to access the file while still\n            // in the web app's security context\n            System.getSecurityManager().checkRead(canonicalPath);\n            // Update the value so the canonical path is used\n            value = canonicalPath;\n        }\n\n        oldValue = attributes.put(name, value);\n        if (oldValue != null) {\n            replaced = true;\n        }\n\n        // Pass special attributes to the native layer\n        if (name.startsWith(\"org.apache.tomcat.\")) {\n            coyoteRequest.setAttribute(name, value);\n        }\n        \n        // Notify interested application event listeners\n        Object listeners[] = context.getApplicationEventListeners();\n        if ((listeners == null) || (listeners.length == 0))\n            return;\n        ServletRequestAttributeEvent event = null;\n        if (replaced)\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, oldValue);\n        else\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, value);\n\n        for (int i = 0; i < listeners.length; i++) {\n            if (!(listeners[i] instanceof ServletRequestAttributeListener))\n                continue;\n            ServletRequestAttributeListener listener =\n                (ServletRequestAttributeListener) listeners[i];\n            try {\n                if (replaced) {\n                    listener.attributeReplaced(event);\n                } else {\n                    listener.attributeAdded(event);\n                }\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                context.getLogger().error(sm.getString(\"coyoteRequest.attributeEvent\"), t);\n                // Error valve will pick this exception up and display it to user\n                attributes.put(RequestDispatcher.ERROR_EXCEPTION, t );\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "setAttribute", "(", "String", "name", ",", "Object", "value", ")", "{", "if", "(", "name", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "sm", ".", "getString", "(", "\"", "coyoteRequest.setAttribute.namenull", "\"", ")", ")", ";", "if", "(", "value", "==", "null", ")", "{", "removeAttribute", "(", "name", ")", ";", "return", ";", "}", "if", "(", "name", ".", "equals", "(", "Globals", ".", "DISPATCHER_TYPE_ATTR", ")", ")", "{", "internalDispatcherType", "=", "(", "DispatcherType", ")", "value", ";", "return", ";", "}", "else", "if", "(", "name", ".", "equals", "(", "Globals", ".", "DISPATCHER_REQUEST_PATH_ATTR", ")", ")", "{", "requestDispatcherPath", "=", "value", ";", "return", ";", "}", "if", "(", "name", ".", "equals", "(", "Globals", ".", "ASYNC_SUPPORTED_ATTR", ")", ")", "{", "this", ".", "asyncSupported", "=", "(", "Boolean", ")", "value", ";", "}", "Object", "oldValue", "=", "null", ";", "boolean", "replaced", "=", "false", ";", "if", "(", "readOnlyAttributes", ".", "containsKey", "(", "name", ")", ")", "{", "return", ";", "}", "if", "(", "Globals", ".", "IS_SECURITY_ENABLED", "&&", "name", ".", "equals", "(", "\"", "org.apache.tomcat.sendfile.filename", "\"", ")", ")", "{", "String", "canonicalPath", ";", "try", "{", "canonicalPath", "=", "new", "File", "(", "value", ".", "toString", "(", ")", ")", ".", "getCanonicalPath", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "SecurityException", "(", "sm", ".", "getString", "(", "\"", "coyoteRequest.sendfileNotCanonical", "\"", ",", "value", ")", ",", "e", ")", ";", "}", "System", ".", "getSecurityManager", "(", ")", ".", "checkRead", "(", "canonicalPath", ")", ";", "value", "=", "canonicalPath", ";", "}", "oldValue", "=", "attributes", ".", "put", "(", "name", ",", "value", ")", ";", "if", "(", "oldValue", "!=", "null", ")", "{", "replaced", "=", "true", ";", "}", "if", "(", "name", ".", "startsWith", "(", "\"", "org.apache.tomcat.", "\"", ")", ")", "{", "coyoteRequest", ".", "setAttribute", "(", "name", ",", "value", ")", ";", "}", "Object", "listeners", "[", "]", "=", "context", ".", "getApplicationEventListeners", "(", ")", ";", "if", "(", "(", "listeners", "==", "null", ")", "||", "(", "listeners", ".", "length", "==", "0", ")", ")", "return", ";", "ServletRequestAttributeEvent", "event", "=", "null", ";", "if", "(", "replaced", ")", "event", "=", "new", "ServletRequestAttributeEvent", "(", "context", ".", "getServletContext", "(", ")", ",", "getRequest", "(", ")", ",", "name", ",", "oldValue", ")", ";", "else", "event", "=", "new", "ServletRequestAttributeEvent", "(", "context", ".", "getServletContext", "(", ")", ",", "getRequest", "(", ")", ",", "name", ",", "value", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "listeners", ".", "length", ";", "i", "++", ")", "{", "if", "(", "!", "(", "listeners", "[", "i", "]", "instanceof", "ServletRequestAttributeListener", ")", ")", "continue", ";", "ServletRequestAttributeListener", "listener", "=", "(", "ServletRequestAttributeListener", ")", "listeners", "[", "i", "]", ";", "try", "{", "if", "(", "replaced", ")", "{", "listener", ".", "attributeReplaced", "(", "event", ")", ";", "}", "else", "{", "listener", ".", "attributeAdded", "(", "event", ")", ";", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "t", ")", ";", "context", ".", "getLogger", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "coyoteRequest.attributeEvent", "\"", ")", ",", "t", ")", ";", "attributes", ".", "put", "(", "RequestDispatcher", ".", "ERROR_EXCEPTION", ",", "t", ")", ";", "}", "}", "}"], "idx": 8101, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "2e69497fa7b1444632c6dadb64a4a82e18478ee6", "function_name": "setAttribute", "body_hash": "64b069ab5e7fc35cceedfb3080ed29ebbeaef8f4"}
{"code": "public String createPackagesTable(final String serverUrl, final String authenticationToken, final String project) {\n\t\tList<String> packageNames = new ArrayList<String>();\n\t\ttry {\n\t\t\tpackageNames = RapidDeployConnector.invokeRapidDeployListPackages(authenticationToken, serverUrl, project);\n\t\t} catch (final Exception e) {\n\t\t\tlogger.warn(e.getMessage());\n\t\t}\n\t\tif (!packageNames.isEmpty()) {\n\t\t\tfinal StringBuffer sb = new StringBuffer();\n\t\t\tsb.append(\"<table>\");\n\t\t\tint index = 0;\n\t\t\tfinal int limit = 10;\n\t\t\tfor (final String packageName : packageNames) {\n\t\t\t\tif (!\"null\".equals(packageName) && !packageName.startsWith(\"Deployment\")) {\n\t\t\t\t\tsb.append(\"<tr><td class=\\\"setting-main\\\">\");\n\t\t\t\t\tsb.append(Util.escape(packageName));\n\t\t\t\t\tsb.append(\"</td></tr>\");\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (index >= limit) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"</table>\");\n\t\t\treturn sb.toString();\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["public", "String", "createPackagesTable", "(", "final", "String", "serverUrl", ",", "final", "String", "authenticationToken", ",", "final", "String", "project", ")", "{", "List", "<", "String", ">", "packageNames", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "try", "{", "packageNames", "=", "RapidDeployConnector", ".", "invokeRapidDeployListPackages", "(", "authenticationToken", ",", "serverUrl", ",", "project", ")", ";", "}", "catch", "(", "final", "Exception", "e", ")", "{", "logger", ".", "warn", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "if", "(", "!", "packageNames", ".", "isEmpty", "(", ")", ")", "{", "final", "StringBuffer", "sb", "=", "new", "StringBuffer", "(", ")", ";", "sb", ".", "append", "(", "\"", "<table>", "\"", ")", ";", "int", "index", "=", "0", ";", "final", "int", "limit", "=", "10", ";", "for", "(", "final", "String", "packageName", ":", "packageNames", ")", "{", "if", "(", "!", "\"", "null", "\"", ".", "equals", "(", "packageName", ")", "&&", "!", "packageName", ".", "startsWith", "(", "\"", "Deployment", "\"", ")", ")", "{", "sb", ".", "append", "(", "\"", "<tr><td class=", "\\\"", "setting-main", "\\\"", ">", "\"", ")", ";", "sb", ".", "append", "(", "Util", ".", "escape", "(", "packageName", ")", ")", ";", "sb", ".", "append", "(", "\"", "</td></tr>", "\"", ")", ";", "index", "++", ";", "if", "(", "index", ">=", "limit", ")", "{", "break", ";", "}", "}", "}", "sb", ".", "append", "(", "\"", "</table>", "\"", ")", ";", "return", "sb", ".", "toString", "(", ")", ";", "}", "return", "null", ";", "}"], "idx": 80548, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "38ec64b", "function_name": "createPackagesTable", "body_hash": "687d5fe432807ef7435fc1b79efe066f4587ac12"}
{"code": "private static AbstractVariableEvaluationContextPostProcessor createPostProcessor(\n\t\t\tObject request) {\n\t\tif (request instanceof AntPathRequestMatcher) {\n\t\t\treturn new AntPathMatcherEvaluationContextPostProcessor(\n\t\t\t\t\t(AntPathRequestMatcher) request);\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["private", "static", "AbstractVariableEvaluationContextPostProcessor", "createPostProcessor", "(", "Object", "request", ")", "{", "if", "(", "request", "instanceof", "AntPathRequestMatcher", ")", "{", "return", "new", "AntPathMatcherEvaluationContextPostProcessor", "(", "(", "AntPathRequestMatcher", ")", "request", ")", ";", "}", "return", "null", ";", "}"], "idx": 12064, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "e4c13e3c0ee7f06f59d3b43ca6734215ad7d8974", "function_name": "createPostProcessor", "body_hash": "c2afaa62d6b27724b2f4156ffcbdaa50c24d2810"}
{"code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        LOGGER.entering(HudsonFilter.class.getName(), \"doFilter\");\n        \n        // to deal with concurrency, we need to capture the object.\n        Filter f = filter;\n\n        if(f==null) {\n            // Hudson is starting up.\n            chain.doFilter(request,response);\n        } else {\n            f.doFilter(request,response,chain);\n        }\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "LOGGER", ".", "entering", "(", "HudsonFilter", ".", "class", ".", "getName", "(", ")", ",", "\"", "doFilter", "\"", ")", ";", "Filter", "f", "=", "filter", ";", "if", "(", "f", "==", "null", ")", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}", "else", "{", "f", ".", "doFilter", "(", "request", ",", "response", ",", "chain", ")", ";", "}", "}"], "idx": 77697, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "1699e2c1f36a22d6a149e71c80937e9972ef6224", "function_name": "doFilter", "body_hash": "d882a24fd44abfa5b53fed0f889bb26d757551fc"}
{"code": "public Map<String, FileEntry> generatorCode(TableDetails tableDetails, String tablePrefix,\n\t\t\tMap<String, String> customProperties, List<TemplateFile> templateFiles) {\n\n\t\tMap<String, FileEntry> map = new HashMap<>(templateFiles.size());\n\n\t\t// \u6a21\u677f\u6e32\u67d3\n\t\tMap<String, Object> context = GenUtils.getContext(tableDetails, tablePrefix, customProperties);\n\n\t\tfor (TemplateFile templateFile : templateFiles) {\n\t\t\tFileEntry fileEntry = new FileEntry();\n\t\t\tfileEntry.setType(templateFile.getType());\n\n\t\t\t// \u66ff\u6362\u8def\u5f84\u4e2d\u7684\u5360\u4f4d\u7b26\n\t\t\tString filename = StrUtil.format(templateFile.getFilename(), context);\n\t\t\tfileEntry.setFilename(filename);\n\n\t\t\tString parentFilePath = GenUtils.evaluateRealPath(templateFile.getParentFilePath(), context);\n\t\t\tfileEntry.setParentFilePath(parentFilePath);\n\n\t\t\t// \u5982\u679c\u662f\u6587\u4ef6\n\t\t\tif (TemplateEntryTypeEnum.FILE.getType().equals(fileEntry.getType())) {\n\t\t\t\tfileEntry.setFilePath(GenUtils.concatFilePath(parentFilePath, filename));\n\t\t\t\t// \u6587\u4ef6\u5185\u5bb9\u6e32\u67d3\n\t\t\t\tTemplateEngineTypeEnum engineTypeEnum = TemplateEngineTypeEnum.of(templateFile.getEngineType());\n\t\t\t\tString content = templateEngineDelegator.render(engineTypeEnum, templateFile.getContent(), context);\n\t\t\t\tfileEntry.setContent(content);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString currentPath = GenUtils.evaluateRealPath(templateFile.getFilename(), context);\n\t\t\t\tfileEntry.setFilePath(GenUtils.concatFilePath(parentFilePath, currentPath));\n\t\t\t}\n\n\t\t\tmap.put(fileEntry.getFilePath(), fileEntry);\n\t\t}\n\n\t\treturn map;\n\t}", "code_tokens": ["public", "Map", "<", "String", ",", "FileEntry", ">", "generatorCode", "(", "TableDetails", "tableDetails", ",", "String", "tablePrefix", ",", "Map", "<", "String", ",", "String", ">", "customProperties", ",", "List", "<", "TemplateFile", ">", "templateFiles", ")", "{", "Map", "<", "String", ",", "FileEntry", ">", "map", "=", "new", "HashMap", "<", ">", "(", "templateFiles", ".", "size", "(", ")", ")", ";", "Map", "<", "String", ",", "Object", ">", "context", "=", "GenUtils", ".", "getContext", "(", "tableDetails", ",", "tablePrefix", ",", "customProperties", ")", ";", "for", "(", "TemplateFile", "templateFile", ":", "templateFiles", ")", "{", "FileEntry", "fileEntry", "=", "new", "FileEntry", "(", ")", ";", "fileEntry", ".", "setType", "(", "templateFile", ".", "getType", "(", ")", ")", ";", "String", "filename", "=", "StrUtil", ".", "format", "(", "templateFile", ".", "getFilename", "(", ")", ",", "context", ")", ";", "fileEntry", ".", "setFilename", "(", "filename", ")", ";", "String", "parentFilePath", "=", "GenUtils", ".", "evaluateRealPath", "(", "templateFile", ".", "getParentFilePath", "(", ")", ",", "context", ")", ";", "fileEntry", ".", "setParentFilePath", "(", "parentFilePath", ")", ";", "if", "(", "TemplateEntryTypeEnum", ".", "FILE", ".", "getType", "(", ")", ".", "equals", "(", "fileEntry", ".", "getType", "(", ")", ")", ")", "{", "fileEntry", ".", "setFilePath", "(", "GenUtils", ".", "concatFilePath", "(", "parentFilePath", ",", "filename", ")", ")", ";", "TemplateEngineTypeEnum", "engineTypeEnum", "=", "TemplateEngineTypeEnum", ".", "of", "(", "templateFile", ".", "getEngineType", "(", ")", ")", ";", "String", "content", "=", "templateEngineDelegator", ".", "render", "(", "engineTypeEnum", ",", "templateFile", ".", "getContent", "(", ")", ",", "context", ")", ";", "fileEntry", ".", "setContent", "(", "content", ")", ";", "}", "else", "{", "String", "currentPath", "=", "GenUtils", ".", "evaluateRealPath", "(", "templateFile", ".", "getFilename", "(", ")", ",", "context", ")", ";", "fileEntry", ".", "setFilePath", "(", "GenUtils", ".", "concatFilePath", "(", "parentFilePath", ",", "currentPath", ")", ")", ";", "}", "map", ".", "put", "(", "fileEntry", ".", "getFilePath", "(", ")", ",", "fileEntry", ")", ";", "}", "return", "map", ";", "}"], "idx": 5559, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "84a7cb38daf0295b93aba21d562ec627e4eb463b", "function_name": "generatorCode", "body_hash": "48a40f2d77b2180e6a765a3d329f0d18a03d4a22"}
{"code": "@Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScriptSource(source);\n    }", "code_tokens": ["@", "Override", "public", "String", "encodeForJSString", "(", "String", "source", ")", "{", "return", "source", "==", "null", "?", "null", ":", "Encode", ".", "forJavaScriptSource", "(", "source", ")", ";", "}"], "idx": 77619, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "7d2365a248943071a44d8495655186e4f14ea294", "function_name": "encodeForJSString", "body_hash": "9336598d0aa9c068e9c3e3fcf61d4326a3fcbc3d"}
{"code": "@Override\n        public int fill(ByteBuffer buffer) throws IOException\n        {\n            try\n            {\n                synchronized (_decryptedEndPoint)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\">fill {}\", SslConnection.this);\n\n                    int filled = -2;\n                    try\n                    {\n                        if (_fillState != FillState.IDLE)\n                            return filled = 0;\n\n                        // Do we already have some decrypted data?\n                        if (BufferUtil.hasContent(_decryptedInput))\n                            return filled = BufferUtil.append(buffer, _decryptedInput);\n\n                        // loop filling and unwrapping until we have something\n                        while (true)\n                        {\n                            HandshakeStatus status = _sslEngine.getHandshakeStatus();\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"fill {}\", status);\n                            switch (status)\n                            {\n                                case NEED_UNWRAP:\n                                case NOT_HANDSHAKING:\n                                    break;\n\n                                case NEED_TASK:\n                                    _sslEngine.getDelegatedTask().run();\n                                    continue;\n\n                                case NEED_WRAP:\n                                    if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER))\n                                    {\n                                        Throwable failure = _failure;\n                                        if (failure != null)\n                                            rethrow(failure);\n                                        if (_sslEngine.isInboundDone())\n                                            return filled = -1;\n                                        continue;\n                                    }\n                                    // Handle in needsFillInterest().\n                                    return filled = 0;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected HandshakeStatus \" + status);\n                            }\n\n                            acquireEncryptedInput();\n\n                            // can we use the passed buffer if it is big enough\n                            ByteBuffer appIn;\n                            int appBufferSize = getApplicationBufferSize();\n                            if (_decryptedInput == null)\n                            {\n                                if (BufferUtil.space(buffer) > appBufferSize)\n                                    appIn = buffer;\n                                else\n                                    appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);\n                            }\n                            else\n                            {\n                                appIn = _decryptedInput;\n                                BufferUtil.compact(_encryptedInput);\n                            }\n\n                            // Let's try reading some encrypted data... even if we have some already.\n                            int netFilled = networkFill(_encryptedInput);\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"net filled={}\", netFilled);\n\n                            // Workaround for Java 11 behavior.\n                            if (netFilled < 0 && isHandshakeInitial() && BufferUtil.isEmpty(_encryptedInput))\n                                closeInbound();\n\n                            if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone())\n                                throw new SSLHandshakeException(\"Closed during handshake\");\n\n                            if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE))\n                            {\n                                if (LOG.isDebugEnabled())\n                                    LOG.debug(\"fill starting handshake {}\", SslConnection.this);\n                            }\n\n                            // Let's unwrap even if we have no net data because in that\n                            // case we want to fall through to the handshake handling\n                            int pos = BufferUtil.flipToFill(appIn);\n                            SSLEngineResult unwrapResult;\n                            try\n                            {\n                                _underflown = false;\n                                unwrapResult = unwrap(_sslEngine, _encryptedInput, appIn);\n                            }\n                            finally\n                            {\n                                BufferUtil.flipToFlush(appIn, pos);\n                            }\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}\",\n                                    netFilled,\n                                    StringUtil.replace(unwrapResult.toString(), '\\n', ' '),\n                                    BufferUtil.toSummaryString(_encryptedInput),\n                                    BufferUtil.toDetailString(appIn),\n                                    BufferUtil.toDetailString(buffer));\n\n                            SSLEngineResult.Status unwrap = unwrapResult.getStatus();\n\n                            // Extra check on unwrapResultStatus == OK with zero bytes consumed\n                            // or produced is due to an SSL client on Android (see bug #454773).\n                            if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0)\n                                unwrap = Status.BUFFER_UNDERFLOW;\n\n                            switch (unwrap)\n                            {\n                                case CLOSED:\n                                    Throwable failure = _failure;\n                                    if (failure != null)\n                                        rethrow(failure);\n                                    return filled = -1;\n\n                                case BUFFER_UNDERFLOW:\n                                    if (BufferUtil.space(_encryptedInput) == 0)\n                                    {\n                                        BufferUtil.clear(_encryptedInput);\n                                        throw new SSLHandshakeException(\"Encrypted buffer max length exceeded\");\n                                    }\n\n                                    if (netFilled > 0)\n                                        continue; // try filling some more\n\n                                    _underflown = true;\n                                    if (netFilled < 0 && _sslEngine.getUseClientMode())\n                                    {\n                                        Throwable closeFailure = closeInbound();\n                                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                                        {\n                                            Throwable handshakeFailure = new SSLHandshakeException(\"Abruptly closed by peer\");\n                                            if (closeFailure != null)\n                                                handshakeFailure.addSuppressed(closeFailure);\n                                            throw handshakeFailure;\n                                        }\n                                        return filled = -1;\n                                    }\n                                    return filled = netFilled;\n\n                                case BUFFER_OVERFLOW:\n                                    // It's possible that SSLSession.applicationBufferSize has been expanded\n                                    // by the SSLEngine implementation. Unwrapping a large encrypted buffer\n                                    // causes BUFFER_OVERFLOW because the (old) applicationBufferSize is\n                                    // too small. Release the decrypted input buffer so it will be re-acquired\n                                    // with the larger capacity.\n                                    // See also system property \"jsse.SSLEngine.acceptLargeFragments\".\n                                    if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize())\n                                    {\n                                        releaseDecryptedInputBuffer();\n                                        continue;\n                                    }\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n\n                                case OK:\n                                    if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED)\n                                        handshakeSucceeded();\n\n                                    if (isRenegotiating() && !allowRenegotiate())\n                                        return filled = -1;\n\n                                    // If bytes were produced, don't bother with the handshake status;\n                                    // pass the decrypted data to the application, which will perform\n                                    // another call to fill() or flush().\n                                    if (unwrapResult.bytesProduced() > 0)\n                                    {\n                                        if (appIn == buffer)\n                                            return filled = unwrapResult.bytesProduced();\n                                        return filled = BufferUtil.append(buffer, _decryptedInput);\n                                    }\n\n                                    break;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n                            }\n                        }\n                    }\n                    catch (Throwable x)\n                    {\n                        Throwable f = handleException(x, \"fill\");\n                        Throwable failure = handshakeFailed(f);\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));\n                        }\n                        throw failure;\n                    }\n                    finally\n                    {\n                        releaseEncryptedInputBuffer();\n                        releaseDecryptedInputBuffer();\n\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());\n                        }\n\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"<fill f={} uf={} {}\", filled, _underflown, SslConnection.this);\n                    }\n                }\n            }\n            catch (Throwable x)\n            {\n                close(x);\n                rethrow(x);\n                // Never reached.\n                throw new AssertionError();\n            }\n        }", "code_tokens": ["@", "Override", "public", "int", "fill", "(", "ByteBuffer", "buffer", ")", "throws", "IOException", "{", "try", "{", "synchronized", "(", "_decryptedEndPoint", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", ">fill {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "int", "filled", "=", "-", "2", ";", "try", "{", "if", "(", "_fillState", "!=", "FillState", ".", "IDLE", ")", "return", "filled", "=", "0", ";", "if", "(", "BufferUtil", ".", "hasContent", "(", "_decryptedInput", ")", ")", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "while", "(", "true", ")", "{", "HandshakeStatus", "status", "=", "_sslEngine", ".", "getHandshakeStatus", "(", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill {}", "\"", ",", "status", ")", ";", "switch", "(", "status", ")", "{", "case", "NEED_UNWRAP", ":", "case", "NOT_HANDSHAKING", ":", "break", ";", "case", "NEED_TASK", ":", "_sslEngine", ".", "getDelegatedTask", "(", ")", ".", "run", "(", ")", ";", "continue", ";", "case", "NEED_WRAP", ":", "if", "(", "_flushState", "==", "FlushState", ".", "IDLE", "&&", "flush", "(", "BufferUtil", ".", "EMPTY_BUFFER", ")", ")", "{", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "if", "(", "_sslEngine", ".", "isInboundDone", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "continue", ";", "}", "return", "filled", "=", "0", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected HandshakeStatus ", "\"", "+", "status", ")", ";", "}", "acquireEncryptedInput", "(", ")", ";", "ByteBuffer", "appIn", ";", "int", "appBufferSize", "=", "getApplicationBufferSize", "(", ")", ";", "if", "(", "_decryptedInput", "==", "null", ")", "{", "if", "(", "BufferUtil", ".", "space", "(", "buffer", ")", ">", "appBufferSize", ")", "appIn", "=", "buffer", ";", "else", "appIn", "=", "_decryptedInput", "=", "_bufferPool", ".", "acquire", "(", "appBufferSize", ",", "_decryptedDirectBuffers", ")", ";", "}", "else", "{", "appIn", "=", "_decryptedInput", ";", "BufferUtil", ".", "compact", "(", "_encryptedInput", ")", ";", "}", "int", "netFilled", "=", "networkFill", "(", "_encryptedInput", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "net filled={}", "\"", ",", "netFilled", ")", ";", "if", "(", "netFilled", "<", "0", "&&", "isHandshakeInitial", "(", ")", "&&", "BufferUtil", ".", "isEmpty", "(", "_encryptedInput", ")", ")", "closeInbound", "(", ")", ";", "if", "(", "netFilled", ">", "0", "&&", "!", "isHandshakeComplete", "(", ")", "&&", "isOutboundDone", "(", ")", ")", "throw", "new", "SSLHandshakeException", "(", "\"", "Closed during handshake", "\"", ")", ";", "if", "(", "_handshake", ".", "compareAndSet", "(", "HandshakeState", ".", "INITIAL", ",", "HandshakeState", ".", "HANDSHAKE", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill starting handshake {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "}", "int", "pos", "=", "BufferUtil", ".", "flipToFill", "(", "appIn", ")", ";", "SSLEngineResult", "unwrapResult", ";", "try", "{", "_underflown", "=", "false", ";", "unwrapResult", "=", "unwrap", "(", "_sslEngine", ",", "_encryptedInput", ",", "appIn", ")", ";", "}", "finally", "{", "BufferUtil", ".", "flipToFlush", "(", "appIn", ",", "pos", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}", "\"", ",", "netFilled", ",", "StringUtil", ".", "replace", "(", "unwrapResult", ".", "toString", "(", ")", ",", "'\\n'", ",", "' '", ")", ",", "BufferUtil", ".", "toSummaryString", "(", "_encryptedInput", ")", ",", "BufferUtil", ".", "toDetailString", "(", "appIn", ")", ",", "BufferUtil", ".", "toDetailString", "(", "buffer", ")", ")", ";", "SSLEngineResult", ".", "Status", "unwrap", "=", "unwrapResult", ".", "getStatus", "(", ")", ";", "if", "(", "unwrap", "==", "Status", ".", "OK", "&&", "unwrapResult", ".", "bytesConsumed", "(", ")", "==", "0", "&&", "unwrapResult", ".", "bytesProduced", "(", ")", "==", "0", ")", "unwrap", "=", "Status", ".", "BUFFER_UNDERFLOW", ";", "switch", "(", "unwrap", ")", "{", "case", "CLOSED", ":", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "return", "filled", "=", "-", "1", ";", "case", "BUFFER_UNDERFLOW", ":", "if", "(", "BufferUtil", ".", "space", "(", "_encryptedInput", ")", "==", "0", ")", "{", "BufferUtil", ".", "clear", "(", "_encryptedInput", ")", ";", "throw", "new", "SSLHandshakeException", "(", "\"", "Encrypted buffer max length exceeded", "\"", ")", ";", "}", "if", "(", "netFilled", ">", "0", ")", "continue", ";", "_underflown", "=", "true", ";", "if", "(", "netFilled", "<", "0", "&&", "_sslEngine", ".", "getUseClientMode", "(", ")", ")", "{", "Throwable", "closeFailure", "=", "closeInbound", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "Throwable", "handshakeFailure", "=", "new", "SSLHandshakeException", "(", "\"", "Abruptly closed by peer", "\"", ")", ";", "if", "(", "closeFailure", "!=", "null", ")", "handshakeFailure", ".", "addSuppressed", "(", "closeFailure", ")", ";", "throw", "handshakeFailure", ";", "}", "return", "filled", "=", "-", "1", ";", "}", "return", "filled", "=", "netFilled", ";", "case", "BUFFER_OVERFLOW", ":", "if", "(", "BufferUtil", ".", "isEmpty", "(", "_decryptedInput", ")", "&&", "appBufferSize", "<", "getApplicationBufferSize", "(", ")", ")", "{", "releaseDecryptedInputBuffer", "(", ")", ";", "continue", ";", "}", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "case", "OK", ":", "if", "(", "unwrapResult", ".", "getHandshakeStatus", "(", ")", "==", "HandshakeStatus", ".", "FINISHED", ")", "handshakeSucceeded", "(", ")", ";", "if", "(", "isRenegotiating", "(", ")", "&&", "!", "allowRenegotiate", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "if", "(", "unwrapResult", ".", "bytesProduced", "(", ")", ">", "0", ")", "{", "if", "(", "appIn", "==", "buffer", ")", "return", "filled", "=", "unwrapResult", ".", "bytesProduced", "(", ")", ";", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "}", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "Throwable", "f", "=", "handleException", "(", "x", ",", "\"", "fill", "\"", ")", ";", "Throwable", "failure", "=", "handshakeFailed", "(", "f", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "onFail", "(", "failure", ")", ")", ";", "}", "throw", "failure", ";", "}", "finally", "{", "releaseEncryptedInputBuffer", "(", ")", ";", "releaseDecryptedInputBuffer", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "completeWrite", "(", ")", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "<fill f={} uf={} {}", "\"", ",", "filled", ",", "_underflown", ",", "SslConnection", ".", "this", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "close", "(", "x", ")", ";", "rethrow", "(", "x", ")", ";", "throw", "new", "AssertionError", "(", ")", ";", "}", "}"], "idx": 65268, "cwe": "CWE-59", "target": 0, "status": "FIXED", "commit": "294b2ba02b667548617a94cd99592110ac230add", "function_name": "fill", "body_hash": "ff0d3e144a9fd0cb4a54cdea1b5f4c477ab393f0"}
{"code": "protected synchronized void decorateWithTLS(TLSClientParameters tlsClientParameters, \n            HttpURLConnection connection) throws GeneralSecurityException {\n\n        \n        int hash = tlsClientParameters.hashCode();\n        if (hash != lastTlsHash) {\n            lastTlsHash = hash;\n            socketFactory = null;\n        }\n        \n        // always reload socketFactory from HttpsURLConnection.defaultSSLSocketFactory and \n        // tlsClientParameters.sslSocketFactory to allow runtime configuration change\n        if (tlsClientParameters.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            socketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n            \n        } else if (tlsClientParameters.getSSLSocketFactory() != null) {\n            // see if an SSLSocketFactory was set. This allows easy interop\n            // with not-yet-commons-ssl.jar, or even just people who like doing their\n            // own JSSE.\n            socketFactory = tlsClientParameters.getSSLSocketFactory();\n            \n        } else if (socketFactory == null) {\n            // ssl socket factory not yet instantiated, create a new one with tlsClientParameters's Trust\n            // Managers, Key Managers, etc\n\n            SSLContext ctx = \n                org.apache.cxf.transport.https.SSLUtils.getSSLContext(tlsClientParameters);\n\n            String[] cipherSuites = \n                SSLUtils.getCiphersuitesToInclude(tlsClientParameters.getCipherSuites(), \n                                                  tlsClientParameters.getCipherSuitesFilter(), \n                                                  ctx.getSocketFactory().getDefaultCipherSuites(),\n                                                  SSLUtils.getSupportedCipherSuites(ctx), \n                                                  LOG);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null ? tlsClientParameters\n                .getSecureSocketProtocol() : \"TLS\";\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(), cipherSuites,\n                                                        protocol);\n            //recalc the hashcode since some of the above MAY have changed the tlsClientParameters \n            lastTlsHash = tlsClientParameters.hashCode();\n        } else {\n           // ssl socket factory already initialized, reuse it to benefit of keep alive\n        }\n        \n        \n        HostnameVerifier verifier = org.apache.cxf.transport.https.SSLUtils\n            .getHostnameVerifier(tlsClientParameters);\n        \n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            conn.setHostnameVerifier(verifier);\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case and other possible hidden API's \n            // that are similar to the Sun cases\n            try {\n                Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n                \n                InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy, \n                                         Method method, \n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return false;\n                        }\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {method.getReturnType()},\n                                                                        handler);\n\n                method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                method.invoke(connection, proxy);\n            } catch (Exception ex) {\n                //Ignore this one\n            }\n            try {\n                Method getSSLSocketFactory =  connection.getClass().getMethod(\"getSSLSocketFactory\");\n                Method setSSLSocketFactory = connection.getClass()\n                    .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                    setSSLSocketFactory.invoke(connection, socketFactory);\n                } else {\n                    //need to see if we can create one - mostly the weblogic case.   The \n                    //weblogic SSLSocketFactory has a protected constructor that can take\n                    //a JSSE SSLSocketFactory so we'll try and use that\n                    Constructor<?> c = getSSLSocketFactory.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    ReflectionUtil.setAccessible(c);\n                    setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                }\n            } catch (Exception ex) {\n                if (connection.getClass().getName().contains(\"weblogic\")) {\n                    if (!weblogicWarned) {\n                        weblogicWarned = true;\n                        LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                } \n                //if we cannot set the SSLSocketFactor, we're in serious trouble.\n                throw new IllegalArgumentException(\"Error decorating connection class \" \n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }", "code_tokens": ["protected", "synchronized", "void", "decorateWithTLS", "(", "TLSClientParameters", "tlsClientParameters", ",", "HttpURLConnection", "connection", ")", "throws", "GeneralSecurityException", "{", "int", "hash", "=", "tlsClientParameters", ".", "hashCode", "(", ")", ";", "if", "(", "hash", "!=", "lastTlsHash", ")", "{", "lastTlsHash", "=", "hash", ";", "socketFactory", "=", "null", ";", "}", "if", "(", "tlsClientParameters", ".", "isUseHttpsURLConnectionDefaultSslSocketFactory", "(", ")", ")", "{", "socketFactory", "=", "HttpsURLConnection", ".", "getDefaultSSLSocketFactory", "(", ")", ";", "}", "else", "if", "(", "tlsClientParameters", ".", "getSSLSocketFactory", "(", ")", "!=", "null", ")", "{", "socketFactory", "=", "tlsClientParameters", ".", "getSSLSocketFactory", "(", ")", ";", "}", "else", "if", "(", "socketFactory", "==", "null", ")", "{", "SSLContext", "ctx", "=", "org", ".", "apache", ".", "cxf", ".", "transport", ".", "https", ".", "SSLUtils", ".", "getSSLContext", "(", "tlsClientParameters", ")", ";", "String", "[", "]", "cipherSuites", "=", "SSLUtils", ".", "getCiphersuitesToInclude", "(", "tlsClientParameters", ".", "getCipherSuites", "(", ")", ",", "tlsClientParameters", ".", "getCipherSuitesFilter", "(", ")", ",", "ctx", ".", "getSocketFactory", "(", ")", ".", "getDefaultCipherSuites", "(", ")", ",", "SSLUtils", ".", "getSupportedCipherSuites", "(", "ctx", ")", ",", "LOG", ")", ";", "String", "protocol", "=", "tlsClientParameters", ".", "getSecureSocketProtocol", "(", ")", "!=", "null", "?", "tlsClientParameters", ".", "getSecureSocketProtocol", "(", ")", ":", "\"", "TLS", "\"", ";", "socketFactory", "=", "new", "SSLSocketFactoryWrapper", "(", "ctx", ".", "getSocketFactory", "(", ")", ",", "cipherSuites", ",", "protocol", ")", ";", "lastTlsHash", "=", "tlsClientParameters", ".", "hashCode", "(", ")", ";", "}", "else", "{", "}", "HostnameVerifier", "verifier", "=", "org", ".", "apache", ".", "cxf", ".", "transport", ".", "https", ".", "SSLUtils", ".", "getHostnameVerifier", "(", "tlsClientParameters", ")", ";", "if", "(", "connection", "instanceof", "HttpsURLConnection", ")", "{", "HttpsURLConnection", "conn", "=", "(", "HttpsURLConnection", ")", "connection", ";", "conn", ".", "setHostnameVerifier", "(", "verifier", ")", ";", "conn", ".", "setSSLSocketFactory", "(", "socketFactory", ")", ";", "}", "else", "{", "try", "{", "Method", "method", "=", "connection", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "getHostnameVerifier", "\"", ")", ";", "InvocationHandler", "handler", "=", "new", "ReflectionInvokationHandler", "(", "verifier", ")", "{", "public", "Object", "invoke", "(", "Object", "proxy", ",", "Method", "method", ",", "Object", "[", "]", "args", ")", "throws", "Throwable", "{", "try", "{", "return", "super", ".", "invoke", "(", "proxy", ",", "method", ",", "args", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "return", "false", ";", "}", "}", "}", ";", "Object", "proxy", "=", "java", ".", "lang", ".", "reflect", ".", "Proxy", ".", "newProxyInstance", "(", "this", ".", "getClass", "(", ")", ".", "getClassLoader", "(", ")", ",", "new", "Class", "[", "]", "{", "method", ".", "getReturnType", "(", ")", "}", ",", "handler", ")", ";", "method", "=", "connection", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "setHostnameVerifier", "\"", ",", "method", ".", "getReturnType", "(", ")", ")", ";", "method", ".", "invoke", "(", "connection", ",", "proxy", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "}", "try", "{", "Method", "getSSLSocketFactory", "=", "connection", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "getSSLSocketFactory", "\"", ")", ";", "Method", "setSSLSocketFactory", "=", "connection", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "setSSLSocketFactory", "\"", ",", "getSSLSocketFactory", ".", "getReturnType", "(", ")", ")", ";", "if", "(", "getSSLSocketFactory", ".", "getReturnType", "(", ")", ".", "isInstance", "(", "socketFactory", ")", ")", "{", "setSSLSocketFactory", ".", "invoke", "(", "connection", ",", "socketFactory", ")", ";", "}", "else", "{", "Constructor", "<", "?", ">", "c", "=", "getSSLSocketFactory", ".", "getReturnType", "(", ")", ".", "getDeclaredConstructor", "(", "SSLSocketFactory", ".", "class", ")", ";", "ReflectionUtil", ".", "setAccessible", "(", "c", ")", ";", "setSSLSocketFactory", ".", "invoke", "(", "connection", ",", "c", ".", "newInstance", "(", "socketFactory", ")", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "if", "(", "connection", ".", "getClass", "(", ")", ".", "getName", "(", ")", ".", "contains", "(", "\"", "weblogic", "\"", ")", ")", "{", "if", "(", "!", "weblogicWarned", ")", "{", "weblogicWarned", "=", "true", ";", "LOG", ".", "warning", "(", "\"", "Could not configure SSLSocketFactory on Weblogic.  ", "\"", "+", "\"", " Use the Weblogic control panel to configure the SSL settings.", "\"", ")", ";", "}", "return", ";", "}", "throw", "new", "IllegalArgumentException", "(", "\"", "Error decorating connection class ", "\"", "+", "connection", ".", "getClass", "(", ")", ".", "getName", "(", ")", ",", "ex", ")", ";", "}", "}", "}"], "idx": 74790, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "8ed6208f987ff72e4c4d2cf8a6b1ec9b27575d4", "function_name": "decorateWithTLS", "body_hash": "82db9463c8215457787b766843383a03d63cbbcf"}
{"code": "@Override\n\tprotected Object doZipTransform(final Message<?> message) throws Exception {\n\n\t\ttry {\n\t\t\tfinal Object payload = message.getPayload();\n\t\t\tfinal Object unzippedData;\n\n\t\t\tInputStream inputStream = null;\n\n\t\t\ttry {\n\t\t\t\tif (payload instanceof File) {\n\t\t\t\t\tfinal File filePayload = (File) payload;\n\n\t\t\t\t\tif (filePayload.isDirectory()) {\n\t\t\t\t\t\tthrow new UnsupportedOperationException(String.format(\"Cannot unzip a directory: '%s'\",\n\t\t\t\t\t\t\t\tfilePayload.getAbsolutePath()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!SpringZipUtils.isValid(filePayload)) {\n\t\t\t\t\t\tthrow new IllegalStateException(String.format(\"Not a zip file: '%s'.\",\n\t\t\t\t\t\t\t\tfilePayload.getAbsolutePath()));\n\t\t\t\t\t}\n\n\t\t\t\t\tinputStream = new FileInputStream(filePayload);\n\t\t\t\t}\n\t\t\t\telse if (payload instanceof InputStream) {\n\t\t\t\t\tinputStream = (InputStream) payload;\n\t\t\t\t}\n\t\t\t\telse if (payload instanceof byte[]) {\n\t\t\t\t\tinputStream = new ByteArrayInputStream((byte[]) payload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(String.format(\"Unsupported payload type '%s'. \" +\n\t\t\t\t\t\t\t\t\t\"The only supported payload types are java.io.File, byte[] and java.io.InputStream\",\n\t\t\t\t\t\t\tpayload.getClass().getSimpleName()));\n\t\t\t\t}\n\n\t\t\t\tfinal SortedMap<String, Object> uncompressedData = new TreeMap<String, Object>();\n\n\t\t\t\tZipUtil.iterate(inputStream, new ZipEntryCallback() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void process(InputStream zipEntryInputStream, ZipEntry zipEntry) throws IOException {\n\n\t\t\t\t\t\tfinal String zipEntryName = zipEntry.getName();\n\t\t\t\t\t\tfinal long zipEntryTime = zipEntry.getTime();\n\t\t\t\t\t\tfinal long zipEntryCompressedSize = zipEntry.getCompressedSize();\n\t\t\t\t\t\tfinal String type = zipEntry.isDirectory() ? \"directory\" : \"file\";\n\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(String.format(\"Unpacking Zip Entry - Name: '%s',Time: '%s', \" +\n\t\t\t\t\t\t\t\t\t\t\t\"Compressed Size: '%s', Type: '%s'\",\n\t\t\t\t\t\t\t\t\tzipEntryName, zipEntryTime, zipEntryCompressedSize, type));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ZipResultType.FILE.equals(zipResultType)) {\n\t\t\t\t\t\t\tfinal File tempDir = new File(workDirectory, message.getHeaders().getId().toString());\n\t\t\t\t\t\t\ttempDir.mkdirs(); //NOSONAR false positive\n\t\t\t\t\t\t\tfinal File destinationFile = new File(tempDir, zipEntryName);\n\n\t\t\t\t\t\t\t/* If we see the relative traversal string of \"..\" we need to make sure\n\t\t\t\t\t\t\t * that the outputdir + name doesn't leave the outputdir.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (!destinationFile.getCanonicalPath().startsWith(workDirectory.getCanonicalPath())) {\n\t\t\t\t\t\t\t\tthrow new ZipException(\"The file \" + zipEntryName +\n\t\t\t\t\t\t\t\t\t\t\" is trying to leave the target output directory of \" + workDirectory);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (zipEntry.isDirectory()) {\n\t\t\t\t\t\t\t\tdestinationFile.mkdirs(); //NOSONAR false positive\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tSpringZipUtils.copy(zipEntryInputStream, destinationFile);\n\t\t\t\t\t\t\t\tuncompressedData.put(zipEntryName, destinationFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ZipResultType.BYTE_ARRAY.equals(zipResultType)) {\n\t\t\t\t\t\t\tif (!zipEntry.isDirectory()) {\n\t\t\t\t\t\t\t\tbyte[] data = IOUtils.toByteArray(zipEntryInputStream);\n\t\t\t\t\t\t\t\tuncompressedData.put(zipEntryName, data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Unsupported zipResultType \" + zipResultType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (uncompressedData.isEmpty()) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"No data unzipped from payload with message Id \" + message.getHeaders().getId());\n\t\t\t\t\t}\n\t\t\t\t\tunzippedData = null;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tif (this.expectSingleResult) {\n\t\t\t\t\t\tif (uncompressedData.size() == 1) {\n\t\t\t\t\t\t\tunzippedData = uncompressedData.values().iterator().next();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new MessagingException(message,\n\t\t\t\t\t\t\t\t\tString.format(\"The UnZip operation extracted %s \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"result objects but expectSingleResult was 'true'.\", uncompressedData.size()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tunzippedData = uncompressedData;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tIOUtils.closeQuietly(inputStream);\n\t\t\t\tif (payload instanceof File && this.deleteFiles) {\n\t\t\t\t\tfinal File filePayload = (File) payload;\n\t\t\t\t\tif (!filePayload.delete() && logger.isWarnEnabled()) {\n\t\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\t\tlogger.warn(\"failed to delete File '\" + filePayload + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn unzippedData;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new MessageHandlingException(message, \"Failed to apply Zip transformation.\", e);\n\t\t}\n\t}", "code_tokens": ["@", "Override", "protected", "Object", "doZipTransform", "(", "final", "Message", "<", "?", ">", "message", ")", "throws", "Exception", "{", "try", "{", "final", "Object", "payload", "=", "message", ".", "getPayload", "(", ")", ";", "final", "Object", "unzippedData", ";", "InputStream", "inputStream", "=", "null", ";", "try", "{", "if", "(", "payload", "instanceof", "File", ")", "{", "final", "File", "filePayload", "=", "(", "File", ")", "payload", ";", "if", "(", "filePayload", ".", "isDirectory", "(", ")", ")", "{", "throw", "new", "UnsupportedOperationException", "(", "String", ".", "format", "(", "\"", "Cannot unzip a directory: '%s'", "\"", ",", "filePayload", ".", "getAbsolutePath", "(", ")", ")", ")", ";", "}", "if", "(", "!", "SpringZipUtils", ".", "isValid", "(", "filePayload", ")", ")", "{", "throw", "new", "IllegalStateException", "(", "String", ".", "format", "(", "\"", "Not a zip file: '%s'.", "\"", ",", "filePayload", ".", "getAbsolutePath", "(", ")", ")", ")", ";", "}", "inputStream", "=", "new", "FileInputStream", "(", "filePayload", ")", ";", "}", "else", "if", "(", "payload", "instanceof", "InputStream", ")", "{", "inputStream", "=", "(", "InputStream", ")", "payload", ";", "}", "else", "if", "(", "payload", "instanceof", "byte", "[", "]", ")", "{", "inputStream", "=", "new", "ByteArrayInputStream", "(", "(", "byte", "[", "]", ")", "payload", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "String", ".", "format", "(", "\"", "Unsupported payload type '%s'. ", "\"", "+", "\"", "The only supported payload types are java.io.File, byte[] and java.io.InputStream", "\"", ",", "payload", ".", "getClass", "(", ")", ".", "getSimpleName", "(", ")", ")", ")", ";", "}", "final", "SortedMap", "<", "String", ",", "Object", ">", "uncompressedData", "=", "new", "TreeMap", "<", "String", ",", "Object", ">", "(", ")", ";", "ZipUtil", ".", "iterate", "(", "inputStream", ",", "new", "ZipEntryCallback", "(", ")", "{", "@", "Override", "public", "void", "process", "(", "InputStream", "zipEntryInputStream", ",", "ZipEntry", "zipEntry", ")", "throws", "IOException", "{", "final", "String", "zipEntryName", "=", "zipEntry", ".", "getName", "(", ")", ";", "final", "long", "zipEntryTime", "=", "zipEntry", ".", "getTime", "(", ")", ";", "final", "long", "zipEntryCompressedSize", "=", "zipEntry", ".", "getCompressedSize", "(", ")", ";", "final", "String", "type", "=", "zipEntry", ".", "isDirectory", "(", ")", "?", "\"", "directory", "\"", ":", "\"", "file", "\"", ";", "if", "(", "logger", ".", "isInfoEnabled", "(", ")", ")", "{", "logger", ".", "info", "(", "String", ".", "format", "(", "\"", "Unpacking Zip Entry - Name: '%s',Time: '%s', ", "\"", "+", "\"", "Compressed Size: '%s', Type: '%s'", "\"", ",", "zipEntryName", ",", "zipEntryTime", ",", "zipEntryCompressedSize", ",", "type", ")", ")", ";", "}", "if", "(", "ZipResultType", ".", "FILE", ".", "equals", "(", "zipResultType", ")", ")", "{", "final", "File", "tempDir", "=", "new", "File", "(", "workDirectory", ",", "message", ".", "getHeaders", "(", ")", ".", "getId", "(", ")", ".", "toString", "(", ")", ")", ";", "tempDir", ".", "mkdirs", "(", ")", ";", "final", "File", "destinationFile", "=", "new", "File", "(", "tempDir", ",", "zipEntryName", ")", ";", "if", "(", "!", "destinationFile", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "workDirectory", ".", "getCanonicalPath", "(", ")", ")", ")", "{", "throw", "new", "ZipException", "(", "\"", "The file ", "\"", "+", "zipEntryName", "+", "\"", " is trying to leave the target output directory of ", "\"", "+", "workDirectory", ")", ";", "}", "if", "(", "zipEntry", ".", "isDirectory", "(", ")", ")", "{", "destinationFile", ".", "mkdirs", "(", ")", ";", "}", "else", "{", "SpringZipUtils", ".", "copy", "(", "zipEntryInputStream", ",", "destinationFile", ")", ";", "uncompressedData", ".", "put", "(", "zipEntryName", ",", "destinationFile", ")", ";", "}", "}", "else", "if", "(", "ZipResultType", ".", "BYTE_ARRAY", ".", "equals", "(", "zipResultType", ")", ")", "{", "if", "(", "!", "zipEntry", ".", "isDirectory", "(", ")", ")", "{", "byte", "[", "]", "data", "=", "IOUtils", ".", "toByteArray", "(", "zipEntryInputStream", ")", ";", "uncompressedData", ".", "put", "(", "zipEntryName", ",", "data", ")", ";", "}", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Unsupported zipResultType ", "\"", "+", "zipResultType", ")", ";", "}", "}", "}", ")", ";", "if", "(", "uncompressedData", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "logger", ".", "isWarnEnabled", "(", ")", ")", "{", "logger", ".", "warn", "(", "\"", "No data unzipped from payload with message Id ", "\"", "+", "message", ".", "getHeaders", "(", ")", ".", "getId", "(", ")", ")", ";", "}", "unzippedData", "=", "null", ";", "}", "else", "{", "if", "(", "this", ".", "expectSingleResult", ")", "{", "if", "(", "uncompressedData", ".", "size", "(", ")", "==", "1", ")", "{", "unzippedData", "=", "uncompressedData", ".", "values", "(", ")", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "}", "else", "{", "throw", "new", "MessagingException", "(", "message", ",", "String", ".", "format", "(", "\"", "The UnZip operation extracted %s ", "\"", "+", "\"", "result objects but expectSingleResult was 'true'.", "\"", ",", "uncompressedData", ".", "size", "(", ")", ")", ")", ";", "}", "}", "else", "{", "unzippedData", "=", "uncompressedData", ";", "}", "}", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "inputStream", ")", ";", "if", "(", "payload", "instanceof", "File", "&&", "this", ".", "deleteFiles", ")", "{", "final", "File", "filePayload", "=", "(", "File", ")", "payload", ";", "if", "(", "!", "filePayload", ".", "delete", "(", ")", "&&", "logger", ".", "isWarnEnabled", "(", ")", ")", "{", "if", "(", "logger", ".", "isWarnEnabled", "(", ")", ")", "{", "logger", ".", "warn", "(", "\"", "failed to delete File '", "\"", "+", "filePayload", "+", "\"", "'", "\"", ")", ";", "}", "}", "}", "}", "return", "unzippedData", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "MessageHandlingException", "(", "message", ",", "\"", "Failed to apply Zip transformation.", "\"", ",", "e", ")", ";", "}", "}"], "idx": 26487, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "d10f537283d90eabd28af57ac97f860a3913bf9b", "function_name": "doZipTransform", "body_hash": "32e566e91b868b54b60c7e02e9beb5ad3a49f99a"}
{"code": "private void introspectInterfaces(Class<?> beanClass, Class<?> currClass) throws IntrospectionException {\n\t\tfor (Class<?> ifc : currClass.getInterfaces()) {\n\t\t\tif (!ClassUtils.isJavaLanguageInterface(ifc)) {\n\t\t\t\tfor (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {\n\t\t\t\t\tPropertyDescriptor existingPd = this.propertyDescriptors.get(pd.getName());\n\t\t\t\t\tif (existingPd == null ||\n\t\t\t\t\t\t\t(existingPd.getReadMethod() == null && pd.getReadMethod() != null)) {\n\t\t\t\t\t\t// GenericTypeAwarePropertyDescriptor leniently resolves a set* write method\n\t\t\t\t\t\t// against a declared read method, so we prefer read method descriptors here.\n\t\t\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n\t\t\t\t\t\tthis.propertyDescriptors.put(pd.getName(), pd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tintrospectInterfaces(ifc, ifc);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "introspectInterfaces", "(", "Class", "<", "?", ">", "beanClass", ",", "Class", "<", "?", ">", "currClass", ")", "throws", "IntrospectionException", "{", "for", "(", "Class", "<", "?", ">", "ifc", ":", "currClass", ".", "getInterfaces", "(", ")", ")", "{", "if", "(", "!", "ClassUtils", ".", "isJavaLanguageInterface", "(", "ifc", ")", ")", "{", "for", "(", "PropertyDescriptor", "pd", ":", "getBeanInfo", "(", "ifc", ")", ".", "getPropertyDescriptors", "(", ")", ")", "{", "PropertyDescriptor", "existingPd", "=", "this", ".", "propertyDescriptors", ".", "get", "(", "pd", ".", "getName", "(", ")", ")", ";", "if", "(", "existingPd", "==", "null", "||", "(", "existingPd", ".", "getReadMethod", "(", ")", "==", "null", "&&", "pd", ".", "getReadMethod", "(", ")", "!=", "null", ")", ")", "{", "pd", "=", "buildGenericTypeAwarePropertyDescriptor", "(", "beanClass", ",", "pd", ")", ";", "this", ".", "propertyDescriptors", ".", "put", "(", "pd", ".", "getName", "(", ")", ",", "pd", ")", ";", "}", "}", "introspectInterfaces", "(", "ifc", ",", "ifc", ")", ";", "}", "}", "}"], "idx": 95363, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "996f701a1916d10202c1d0d281f06ab1f2e1117e", "function_name": "introspectInterfaces", "body_hash": "d0ab7b625aaffb39434c13b4fda6df90fec03823"}
{"code": "@Override\n    public boolean validateCrumb(ServletRequest request, String salt, String crumb) {\n        if (request instanceof HttpServletRequest) {\n            String newCrumb = issueCrumb(request, salt);\n            if ((newCrumb != null) && (crumb != null)) {\n                return newCrumb.equals(crumb);\n            }\n        }\n        return false;\n    }", "code_tokens": ["@", "Override", "public", "boolean", "validateCrumb", "(", "ServletRequest", "request", ",", "String", "salt", ",", "String", "crumb", ")", "{", "if", "(", "request", "instanceof", "HttpServletRequest", ")", "{", "String", "newCrumb", "=", "issueCrumb", "(", "request", ",", "salt", ")", ";", "if", "(", "(", "newCrumb", "!=", "null", ")", "&&", "(", "crumb", "!=", "null", ")", ")", "{", "return", "newCrumb", ".", "equals", "(", "crumb", ")", ";", "}", "}", "return", "false", ";", "}"], "idx": 13770, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "559566b1ac62ebe966613933baf1714137daeb8c", "function_name": "validateCrumb", "body_hash": "9fb183f5914590b9d292535fa6bf503266af84fa"}
{"code": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // cannot get from ParameterizedJob back to ParameterizedJobMixIn trivially\n    @Override\n    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        if (step.getWait() && !(item instanceof Job)) {\n            // TODO find some way of allowing ComputedFolders to hook into the listener code\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            // TODO use new convenience method in 1.621\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // ignore, best effort only\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "{", "\"", "unchecked", "\"", ",", "\"", "rawtypes", "\"", "}", ")", "@", "Override", "public", "boolean", "start", "(", ")", "throws", "Exception", "{", "String", "job", "=", "step", ".", "getJob", "(", ")", ";", "Item", "item", "=", "Jenkins", ".", "getActiveInstance", "(", ")", ".", "getItem", "(", "job", ",", "invokingRun", ".", "getParent", "(", ")", ",", "Item", ".", "class", ")", ";", "if", "(", "item", "==", "null", ")", "{", "throw", "new", "AbortException", "(", "\"", "No item named ", "\"", "+", "job", "+", "\"", " found", "\"", ")", ";", "}", "if", "(", "step", ".", "getWait", "(", ")", "&&", "!", "(", "item", "instanceof", "Job", ")", ")", "{", "throw", "new", "AbortException", "(", "\"", "Waiting for non-job items is not supported", "\"", ")", ";", "}", "if", "(", "item", "instanceof", "ParameterizedJobMixIn", ".", "ParameterizedJob", ")", "{", "final", "ParameterizedJobMixIn", ".", "ParameterizedJob", "project", "=", "(", "ParameterizedJobMixIn", ".", "ParameterizedJob", ")", "item", ";", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Scheduling project: ", "\"", "+", "ModelHyperlinkNote", ".", "encodeTo", "(", "project", ")", ")", ";", "node", ".", "addAction", "(", "new", "LabelAction", "(", "Messages", ".", "BuildTriggerStepExecution_building_", "(", "project", ".", "getFullDisplayName", "(", ")", ")", ")", ")", ";", "List", "<", "Action", ">", "actions", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "step", ".", "getWait", "(", ")", ")", "{", "StepContext", "context", "=", "getContext", "(", ")", ";", "actions", ".", "add", "(", "new", "BuildTriggerAction", "(", "context", ",", "step", ".", "isPropagate", "(", ")", ")", ")", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINER", ",", "\"", "scheduling a build of {0} from {1}", "\"", ",", "new", "Object", "[", "]", "{", "project", ",", "context", "}", ")", ";", "}", "actions", ".", "add", "(", "new", "CauseAction", "(", "new", "Cause", ".", "UpstreamCause", "(", "invokingRun", ")", ")", ")", ";", "List", "<", "ParameterValue", ">", "parameters", "=", "step", ".", "getParameters", "(", ")", ";", "if", "(", "parameters", "!=", "null", ")", "{", "parameters", "=", "completeDefaultParameters", "(", "parameters", ",", "(", "Job", ")", "project", ")", ";", "actions", ".", "add", "(", "new", "ParametersAction", "(", "parameters", ")", ")", ";", "}", "Integer", "quietPeriod", "=", "step", ".", "getQuietPeriod", "(", ")", ";", "if", "(", "quietPeriod", "==", "null", ")", "{", "quietPeriod", "=", "project", ".", "getQuietPeriod", "(", ")", ";", "}", "QueueTaskFuture", "<", "?", ">", "f", "=", "new", "ParameterizedJobMixIn", "(", ")", "{", "@", "Override", "protected", "Job", "asJob", "(", ")", "{", "return", "(", "Job", ")", "project", ";", "}", "}", ".", "scheduleBuild2", "(", "quietPeriod", ",", "actions", ".", "toArray", "(", "new", "Action", "[", "actions", ".", "size", "(", ")", "]", ")", ")", ";", "if", "(", "f", "==", "null", ")", "{", "throw", "new", "AbortException", "(", "\"", "Failed to trigger build of ", "\"", "+", "project", ".", "getFullName", "(", ")", ")", ";", "}", "}", "else", "if", "(", "item", "instanceof", "Queue", ".", "Task", ")", "{", "if", "(", "step", ".", "getParameters", "(", ")", "!=", "null", "&&", "!", "step", ".", "getParameters", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "AbortException", "(", "\"", "Item type does not support parameters", "\"", ")", ";", "}", "Queue", ".", "Task", "task", "=", "(", "Queue", ".", "Task", ")", "item", ";", "listener", ".", "getLogger", "(", ")", ".", "println", "(", "\"", "Scheduling item: ", "\"", "+", "ModelHyperlinkNote", ".", "encodeTo", "(", "item", ")", ")", ";", "node", ".", "addAction", "(", "new", "LabelAction", "(", "Messages", ".", "BuildTriggerStepExecution_building_", "(", "task", ".", "getFullDisplayName", "(", ")", ")", ")", ")", ";", "List", "<", "Action", ">", "actions", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "if", "(", "step", ".", "getWait", "(", ")", ")", "{", "StepContext", "context", "=", "getContext", "(", ")", ";", "actions", ".", "add", "(", "new", "BuildTriggerAction", "(", "context", ",", "step", ".", "isPropagate", "(", ")", ")", ")", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINER", ",", "\"", "scheduling a build of {0} from {1}", "\"", ",", "new", "Object", "[", "]", "{", "task", ",", "context", "}", ")", ";", "}", "actions", ".", "add", "(", "new", "CauseAction", "(", "new", "Cause", ".", "UpstreamCause", "(", "invokingRun", ")", ")", ")", ";", "Integer", "quietPeriod", "=", "step", ".", "getQuietPeriod", "(", ")", ";", "if", "(", "quietPeriod", "==", "null", ")", "{", "try", "{", "Method", "getQuietPeriod", "=", "task", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"", "getQuietPeriod", "\"", ")", ";", "if", "(", "getQuietPeriod", ".", "getReturnType", "(", ")", ".", "equals", "(", "int", ".", "class", ")", ")", "{", "quietPeriod", "=", "(", "Integer", ")", "getQuietPeriod", ".", "invoke", "(", "task", ")", ";", "}", "}", "catch", "(", "NoSuchMethodException", "e", ")", "{", "}", "catch", "(", "IllegalAccessError", "|", "IllegalArgumentException", "|", "InvocationTargetException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Could not determine quiet period of ", "\"", "+", "item", ".", "getFullName", "(", ")", ",", "e", ")", ";", "}", "}", "if", "(", "quietPeriod", "==", "null", ")", "{", "quietPeriod", "=", "Jenkins", ".", "getActiveInstance", "(", ")", ".", "getQuietPeriod", "(", ")", ";", "}", "ScheduleResult", "scheduleResult", "=", "Jenkins", ".", "getActiveInstance", "(", ")", ".", "getQueue", "(", ")", ".", "schedule2", "(", "task", ",", "quietPeriod", ",", "actions", ")", ";", "if", "(", "scheduleResult", ".", "isRefused", "(", ")", ")", "{", "throw", "new", "AbortException", "(", "\"", "Failed to trigger build of ", "\"", "+", "item", ".", "getFullName", "(", ")", ")", ";", "}", "}", "else", "{", "throw", "new", "AbortException", "(", "\"", "The item named ", "\"", "+", "job", "+", "\"", " is a ", "\"", "+", "(", "item", "instanceof", "Describable", "?", "(", "(", "Describable", ")", "item", ")", ".", "getDescriptor", "(", ")", ".", "getDisplayName", "(", ")", ":", "item", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", "+", "\"", " which is not something that can be built", "\"", ")", ";", "}", "if", "(", "step", ".", "getWait", "(", ")", ")", "{", "return", "false", ";", "}", "else", "{", "getContext", "(", ")", ".", "onSuccess", "(", "null", ")", ";", "return", "true", ";", "}", "}"], "idx": 64207, "cwe": "CWE-532", "target": 1, "status": "VULNERABLE", "commit": "3dfefdec1f7b2a4ee0ef8902afdea720b1572cb3", "function_name": "start", "body_hash": "954b10e3c2f2db3d3a8c59ebb66250ea6e17ee29"}
{"code": "public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (int i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }", "code_tokens": ["public", "void", "parseCentralDirectoryFormat", "(", "final", "byte", "[", "]", "data", ",", "final", "int", "offset", ",", "final", "int", "length", ")", "{", "this", ".", "format", "=", "ZipShort", ".", "getValue", "(", "data", ",", "offset", ")", ";", "this", ".", "algId", "=", "EncryptionAlgorithm", ".", "getAlgorithmByCode", "(", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "2", ")", ")", ";", "this", ".", "bitlen", "=", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "4", ")", ";", "this", ".", "flags", "=", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "6", ")", ";", "this", ".", "rcount", "=", "ZipLong", ".", "getValue", "(", "data", ",", "offset", "+", "8", ")", ";", "if", "(", "rcount", ">", "0", ")", "{", "this", ".", "hashAlg", "=", "HashAlgorithm", ".", "getAlgorithmByCode", "(", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "12", ")", ")", ";", "this", ".", "hashSize", "=", "ZipShort", ".", "getValue", "(", "data", ",", "offset", "+", "14", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "this", ".", "rcount", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "this", ".", "hashSize", ";", "j", "++", ")", "{", "}", "}", "}", "}"], "idx": 82757, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "2a2f1dc48e22a34ddb72321a4db211da91aa933b", "function_name": "parseCentralDirectoryFormat", "body_hash": "ee7569f8ce137a91f16c148a897b675bef76eec8"}
{"code": "private static File newFile() throws IOException {\n        File file = PlatformDependent.createTempFile(\"netty-\", \".tmp\", null);\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n        return file;\n    }", "code_tokens": ["private", "static", "File", "newFile", "(", ")", "throws", "IOException", "{", "File", "file", "=", "PlatformDependent", ".", "createTempFile", "(", "\"", "netty-", "\"", ",", "\"", ".tmp", "\"", ",", "null", ")", ";", "file", ".", "deleteOnExit", "(", ")", ";", "final", "FileOutputStream", "out", "=", "new", "FileOutputStream", "(", "file", ")", ";", "out", ".", "write", "(", "data", ")", ";", "out", ".", "close", "(", ")", ";", "return", "file", ";", "}"], "idx": 50039, "cwe": "CWE-378", "target": 0, "status": "FIXED", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "newFile", "body_hash": "25e0d51f5dccd14c086496cfa941d085c611df15"}
{"code": "@Override\n    public Element handle(Element request, Map<String, Object> context) throws ServiceException {\n        ZimbraSoapContext zsc = getZimbraSoapContext(context);\n        Account account = getRequestedAccount(getZimbraSoapContext(context));\n\n        if (!canAccessAccount(zsc, account))\n            throw ServiceException.PERM_DENIED(\"can not access account\");\n        \n        String name = request.getAttribute(AccountConstants.E_NAME);\n        String typeStr = request.getAttribute(AccountConstants.A_TYPE, \"account\");\n        GalSearchType type = GalSearchType.fromString(typeStr);\n\n        boolean needCanExpand = request.getAttributeBool(AccountConstants.A_NEED_EXP, false);\n\n        String galAcctId = request.getAttribute(AccountConstants.A_GAL_ACCOUNT_ID, null);\n        \n        GalSearchParams params = new GalSearchParams(account, zsc);\n        params.setType(type);\n        params.setRequest(request);\n        params.setQuery(name);\n        params.setLimit(account.getContactAutoCompleteMaxResults());\n        params.setNeedCanExpand(needCanExpand);\n        params.setResponseName(AccountConstants.AUTO_COMPLETE_GAL_RESPONSE);\n        if (galAcctId != null) {\n            Account galAccount = Provisioning.getInstance().getAccountById(galAcctId);\n            if (galAccount != null && (!account.getDomainId().equals(galAccount.getDomainId()))) {\n                throw ServiceException\n                    .PERM_DENIED(\"can not access galsync account of different domain\");\n            }\n            params.setGalSyncAccount(galAccount);\n        }\n        GalSearchControl gal = new GalSearchControl(params);\n        gal.autocomplete();\n        return params.getResultCallback().getResponse();\n    }", "code_tokens": ["@", "Override", "public", "Element", "handle", "(", "Element", "request", ",", "Map", "<", "String", ",", "Object", ">", "context", ")", "throws", "ServiceException", "{", "ZimbraSoapContext", "zsc", "=", "getZimbraSoapContext", "(", "context", ")", ";", "Account", "account", "=", "getRequestedAccount", "(", "getZimbraSoapContext", "(", "context", ")", ")", ";", "if", "(", "!", "canAccessAccount", "(", "zsc", ",", "account", ")", ")", "throw", "ServiceException", ".", "PERM_DENIED", "(", "\"", "can not access account", "\"", ")", ";", "String", "name", "=", "request", ".", "getAttribute", "(", "AccountConstants", ".", "E_NAME", ")", ";", "String", "typeStr", "=", "request", ".", "getAttribute", "(", "AccountConstants", ".", "A_TYPE", ",", "\"", "account", "\"", ")", ";", "GalSearchType", "type", "=", "GalSearchType", ".", "fromString", "(", "typeStr", ")", ";", "boolean", "needCanExpand", "=", "request", ".", "getAttributeBool", "(", "AccountConstants", ".", "A_NEED_EXP", ",", "false", ")", ";", "String", "galAcctId", "=", "request", ".", "getAttribute", "(", "AccountConstants", ".", "A_GAL_ACCOUNT_ID", ",", "null", ")", ";", "GalSearchParams", "params", "=", "new", "GalSearchParams", "(", "account", ",", "zsc", ")", ";", "params", ".", "setType", "(", "type", ")", ";", "params", ".", "setRequest", "(", "request", ")", ";", "params", ".", "setQuery", "(", "name", ")", ";", "params", ".", "setLimit", "(", "account", ".", "getContactAutoCompleteMaxResults", "(", ")", ")", ";", "params", ".", "setNeedCanExpand", "(", "needCanExpand", ")", ";", "params", ".", "setResponseName", "(", "AccountConstants", ".", "AUTO_COMPLETE_GAL_RESPONSE", ")", ";", "if", "(", "galAcctId", "!=", "null", ")", "{", "Account", "galAccount", "=", "Provisioning", ".", "getInstance", "(", ")", ".", "getAccountById", "(", "galAcctId", ")", ";", "if", "(", "galAccount", "!=", "null", "&&", "(", "!", "account", ".", "getDomainId", "(", ")", ".", "equals", "(", "galAccount", ".", "getDomainId", "(", ")", ")", ")", ")", "{", "throw", "ServiceException", ".", "PERM_DENIED", "(", "\"", "can not access galsync account of different domain", "\"", ")", ";", "}", "params", ".", "setGalSyncAccount", "(", "galAccount", ")", ";", "}", "GalSearchControl", "gal", "=", "new", "GalSearchControl", "(", "params", ")", ";", "gal", ".", "autocomplete", "(", ")", ";", "return", "params", ".", "getResultCallback", "(", ")", ".", "getResponse", "(", ")", ";", "}"], "idx": 85458, "cwe": "CWE-862", "target": 0, "status": "FIXED", "commit": "1df440e0efa624d1772a05fb6d397d9beb4bda1e", "function_name": "handle", "body_hash": "da9b6c1c7d1595941af15772e69c54ce2191e1c6"}
{"code": "static protected UTF8Buffer readUTF(DataByteArrayInputStream is) throws ProtocolException {\n        int size = is.readUnsignedShort();\n        if (size < 0) {\n            throw new ProtocolException(\"Invalid message encoding\");\n        }\n        Buffer buffer = is.readBuffer(size);\n        if (buffer == null || buffer.length != size) {\n            throw new ProtocolException(\"Invalid message encoding\");\n        }\n        return buffer.utf8();\n    }", "code_tokens": ["static", "protected", "UTF8Buffer", "readUTF", "(", "DataByteArrayInputStream", "is", ")", "throws", "ProtocolException", "{", "int", "size", "=", "is", ".", "readUnsignedShort", "(", ")", ";", "if", "(", "size", "<", "0", ")", "{", "throw", "new", "ProtocolException", "(", "\"", "Invalid message encoding", "\"", ")", ";", "}", "Buffer", "buffer", "=", "is", ".", "readBuffer", "(", "size", ")", ";", "if", "(", "buffer", "==", "null", "||", "buffer", ".", "length", "!=", "size", ")", "{", "throw", "new", "ProtocolException", "(", "\"", "Invalid message encoding", "\"", ")", ";", "}", "return", "buffer", ".", "utf8", "(", ")", ";", "}"], "idx": 102080, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "2898f10be758decdc85ba6c523cb5be6b9092855", "function_name": "readUTF", "body_hash": "da2a01315a017eb0f70f2070e68e690aae6ac9b6"}
{"code": "@SuppressWarnings(\"unchecked\") // deserialization is unsafe\n  public static CompoundOrdering<Object> instantiate(SerializationStreamReader reader)\n      throws SerializationException {\n    int n = reader.readInt();\n    List<Comparator<Object>> comparators = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) {\n      comparators.add((Comparator<Object>) reader.readObject());\n    }\n    return new CompoundOrdering<>(comparators);\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "public", "static", "CompoundOrdering", "<", "Object", ">", "instantiate", "(", "SerializationStreamReader", "reader", ")", "throws", "SerializationException", "{", "int", "n", "=", "reader", ".", "readInt", "(", ")", ";", "List", "<", "Comparator", "<", "Object", ">", ">", "comparators", "=", "new", "ArrayList", "<", ">", "(", "n", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n", ";", "i", "++", ")", "{", "comparators", ".", "add", "(", "(", "Comparator", "<", "Object", ">", ")", "reader", ".", "readObject", "(", ")", ")", ";", "}", "return", "new", "CompoundOrdering", "<", ">", "(", "comparators", ")", ";", "}"], "idx": 76106, "cwe": "CWE-770", "target": 1, "status": "VULNERABLE", "commit": "f89ece5721b2f637fe754937ff1f3c86d80bb196", "function_name": "instantiate", "body_hash": "18a2247a225e152073b8e6942cbd8dbe82d5b0c0"}
{"code": "@Override\n    public IdentityZoneConfiguration validate(IdentityZone zone, IdentityZoneValidator.Mode mode) throws InvalidIdentityZoneConfigurationException {\n        IdentityZoneConfiguration config = zone.getConfig();\n        if (mode == IdentityZoneValidator.Mode.CREATE || mode == IdentityZoneValidator.Mode.MODIFY) {\n            String currentKeyId = null;\n            try {\n                SamlConfig samlConfig;\n                if ((samlConfig = config.getSamlConfig()) != null && samlConfig.getKeys().size()>0) {\n                    String activeKeyId = samlConfig.getActiveKeyId();\n                    if ( (activeKeyId == null || samlConfig.getKeys().get(activeKeyId) == null)) {\n\n                        throw new InvalidIdentityZoneConfigurationException(String.format(\"Invalid SAML active key ID: '%s'. Couldn't find any matching keys.\", activeKeyId));\n                    }\n\n                    for (Map.Entry<String, SamlKey> entry : samlConfig.getKeys().entrySet()) {\n                        currentKeyId = entry.getKey();\n                        String samlSpCert = entry.getValue().getCertificate();\n                        String samlSpKey = entry.getValue().getKey();\n                        String samlSpkeyPassphrase = entry.getValue().getPassphrase();\n                        if (samlSpKey != null && samlSpCert != null) {\n                            new KeyWithCert(samlSpKey, samlSpkeyPassphrase, samlSpCert);\n                        }\n                        failIfPartialCertKeyInfo(samlSpCert, samlSpKey, samlSpkeyPassphrase);\n                    }\n                }\n            } catch (GeneralSecurityException ex) {\n                throw new InvalidIdentityZoneConfigurationException(String.format(\"There is a security problem with the SAML SP Key configuration for key '%s'.\", currentKeyId), ex);\n            }\n\n            TokenPolicy tokenPolicy = config.getTokenPolicy();\n            if (tokenPolicy != null) {\n                String activeKeyId = tokenPolicy.getActiveKeyId();\n                if (StringUtils.hasText(activeKeyId)) {\n                    Map<String, String> jwtKeys = tokenPolicy.getKeys();\n\n                    if (jwtKeys == null || jwtKeys.isEmpty()) {\n                        throw new InvalidIdentityZoneConfigurationException(\"Identity zone cannot specify an active key ID with no keys configured for the zone.\", null);\n                    } else {\n                        if (!jwtKeys.containsKey(activeKeyId)) {\n                            throw new InvalidIdentityZoneConfigurationException(\"The specified active key ID is not present in the configured keys: \" + activeKeyId, null);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(config.getBranding() != null && config.getBranding().getBanner() != null) {\n           BannerValidator.validate(config.getBranding().getBanner());\n        }\n\n        if(config.getMfaConfig() != null) {\n            mfaConfigValidator.validate(config.getMfaConfig(), zone.getId());\n        }\n\n        return config;\n    }", "code_tokens": ["@", "Override", "public", "IdentityZoneConfiguration", "validate", "(", "IdentityZone", "zone", ",", "IdentityZoneValidator", ".", "Mode", "mode", ")", "throws", "InvalidIdentityZoneConfigurationException", "{", "IdentityZoneConfiguration", "config", "=", "zone", ".", "getConfig", "(", ")", ";", "if", "(", "mode", "==", "IdentityZoneValidator", ".", "Mode", ".", "CREATE", "||", "mode", "==", "IdentityZoneValidator", ".", "Mode", ".", "MODIFY", ")", "{", "String", "currentKeyId", "=", "null", ";", "try", "{", "SamlConfig", "samlConfig", ";", "if", "(", "(", "samlConfig", "=", "config", ".", "getSamlConfig", "(", ")", ")", "!=", "null", "&&", "samlConfig", ".", "getKeys", "(", ")", ".", "size", "(", ")", ">", "0", ")", "{", "String", "activeKeyId", "=", "samlConfig", ".", "getActiveKeyId", "(", ")", ";", "if", "(", "(", "activeKeyId", "==", "null", "||", "samlConfig", ".", "getKeys", "(", ")", ".", "get", "(", "activeKeyId", ")", "==", "null", ")", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "String", ".", "format", "(", "\"", "Invalid SAML active key ID: '%s'. Couldn't find any matching keys.", "\"", ",", "activeKeyId", ")", ")", ";", "}", "for", "(", "Map", ".", "Entry", "<", "String", ",", "SamlKey", ">", "entry", ":", "samlConfig", ".", "getKeys", "(", ")", ".", "entrySet", "(", ")", ")", "{", "currentKeyId", "=", "entry", ".", "getKey", "(", ")", ";", "String", "samlSpCert", "=", "entry", ".", "getValue", "(", ")", ".", "getCertificate", "(", ")", ";", "String", "samlSpKey", "=", "entry", ".", "getValue", "(", ")", ".", "getKey", "(", ")", ";", "String", "samlSpkeyPassphrase", "=", "entry", ".", "getValue", "(", ")", ".", "getPassphrase", "(", ")", ";", "if", "(", "samlSpKey", "!=", "null", "&&", "samlSpCert", "!=", "null", ")", "{", "new", "KeyWithCert", "(", "samlSpKey", ",", "samlSpkeyPassphrase", ",", "samlSpCert", ")", ";", "}", "failIfPartialCertKeyInfo", "(", "samlSpCert", ",", "samlSpKey", ",", "samlSpkeyPassphrase", ")", ";", "}", "}", "}", "catch", "(", "GeneralSecurityException", "ex", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "String", ".", "format", "(", "\"", "There is a security problem with the SAML SP Key configuration for key '%s'.", "\"", ",", "currentKeyId", ")", ",", "ex", ")", ";", "}", "TokenPolicy", "tokenPolicy", "=", "config", ".", "getTokenPolicy", "(", ")", ";", "if", "(", "tokenPolicy", "!=", "null", ")", "{", "String", "activeKeyId", "=", "tokenPolicy", ".", "getActiveKeyId", "(", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "activeKeyId", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "jwtKeys", "=", "tokenPolicy", ".", "getKeys", "(", ")", ";", "if", "(", "jwtKeys", "==", "null", "||", "jwtKeys", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "\"", "Identity zone cannot specify an active key ID with no keys configured for the zone.", "\"", ",", "null", ")", ";", "}", "else", "{", "if", "(", "!", "jwtKeys", ".", "containsKey", "(", "activeKeyId", ")", ")", "{", "throw", "new", "InvalidIdentityZoneConfigurationException", "(", "\"", "The specified active key ID is not present in the configured keys: ", "\"", "+", "activeKeyId", ",", "null", ")", ";", "}", "}", "}", "}", "}", "if", "(", "config", ".", "getBranding", "(", ")", "!=", "null", "&&", "config", ".", "getBranding", "(", ")", ".", "getBanner", "(", ")", "!=", "null", ")", "{", "BannerValidator", ".", "validate", "(", "config", ".", "getBranding", "(", ")", ".", "getBanner", "(", ")", ")", ";", "}", "if", "(", "config", ".", "getMfaConfig", "(", ")", "!=", "null", ")", "{", "mfaConfigValidator", ".", "validate", "(", "config", ".", "getMfaConfig", "(", ")", ",", "zone", ".", "getId", "(", ")", ")", ";", "}", "return", "config", ";", "}"], "idx": 102680, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "14c745aa293b8d3ce9cdd6bfbc6c0ef3f269b21", "function_name": "validate", "body_hash": "b0fe777bac6f1173f5e478ba52a06519afc97371"}
{"code": "private static AbstractVariableEvaluationContextPostProcessor createPostProcessor(\n\t\t\tObject request) {\n\t\tif (request instanceof AntPathRequestMatcher) {\n\t\t\treturn new AntPathMatcherEvaluationContextPostProcessor(\n\t\t\t\t\t(AntPathRequestMatcher) request);\n\t\t}\n\t\tif (request instanceof RequestVariablesExtractor) {\n\t\t\treturn new RequestVariablesExtractorEvaluationContextPostProcessor(\n\t\t\t\t\t(RequestVariablesExtractor) request);\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["private", "static", "AbstractVariableEvaluationContextPostProcessor", "createPostProcessor", "(", "Object", "request", ")", "{", "if", "(", "request", "instanceof", "AntPathRequestMatcher", ")", "{", "return", "new", "AntPathMatcherEvaluationContextPostProcessor", "(", "(", "AntPathRequestMatcher", ")", "request", ")", ";", "}", "if", "(", "request", "instanceof", "RequestVariablesExtractor", ")", "{", "return", "new", "RequestVariablesExtractorEvaluationContextPostProcessor", "(", "(", "RequestVariablesExtractor", ")", "request", ")", ";", "}", "return", "null", ";", "}"], "idx": 12065, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "e4c13e3c0ee7f06f59d3b43ca6734215ad7d8974", "function_name": "createPostProcessor", "body_hash": "da179588008a9fdea6ca3b516ea830c72cdab01e"}
{"code": "@Programming\n    public void resetAuthenticationFailureCounter(String username)\n    {\n        this.authenticationFailureManager.resetAuthenticationFailureCounter(username);\n    }", "code_tokens": ["@", "Programming", "public", "void", "resetAuthenticationFailureCounter", "(", "String", "username", ")", "{", "this", ".", "authenticationFailureManager", ".", "resetAuthenticationFailureCounter", "(", "username", ")", ";", "}"], "idx": 72825, "cwe": "CWE-732", "target": 1, "status": "VULNERABLE", "commit": "0ad11db", "function_name": "resetAuthenticationFailureCounter", "body_hash": "cc69a11abca19cf5adc33699342a7cb2a7872522"}
{"code": "public static Response getErrorResponse(Throwable e, Response.Status status) {\n        String message = e.getMessage() == null ? \"Failed with \" + e.getClass().getName() : e.getMessage();\n        Response response = getErrorResponse(message, status);\n\n        return response;\n    }", "code_tokens": ["public", "static", "Response", "getErrorResponse", "(", "Throwable", "e", ",", "Response", ".", "Status", "status", ")", "{", "String", "message", "=", "e", ".", "getMessage", "(", ")", "==", "null", "?", "\"", "Failed with ", "\"", "+", "e", ".", "getClass", "(", ")", ".", "getName", "(", ")", ":", "e", ".", "getMessage", "(", ")", ";", "Response", "response", "=", "getErrorResponse", "(", "message", ",", "status", ")", ";", "return", "response", ";", "}"], "idx": 19800, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "0dcfd21bbfaac6f037f46b7aaaab0e5546fd2a7", "function_name": "getErrorResponse", "body_hash": "7b45513c83b5959fe73caf7012926b0e2cd3c20a"}
{"code": "@Override\n    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String path = baseRequest.getPathInfo();\n        int soff = 0, eoff;\n        // We're handling this request\n        baseRequest.setHandled(true);\n        if(core.getLoginRequired()\n            && request.getSession(true).getAttribute(LoginServlet.USERID_ATTRIB) == null){\n            response.sendError(HttpStatus.UNAUTHORIZED_401);\n            return;\n        }\n        if (path.charAt(0) == '/') soff = 1;\n        eoff = path.indexOf('/', soff);\n        if (soff < 0) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        String world = path.substring(soff, eoff);\n        String uri = path.substring(eoff+1);\n        // If faces directory, handle faces\n        if (world.equals(\"faces\")) {\n            handleFace(response, uri);\n            return;\n        }\n        // If markers directory, handle markers\n        if (world.equals(\"_markers_\")) {\n            handleMarkers(response, uri);\n            return;\n        }\n\n        DynmapWorld w = null;\n        if (core.mapManager != null) {\n            w = core.mapManager.getWorld(world);\n        }\n        // If world not found quit\n        if (w == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        MapStorage store = w.getMapStorage();    // Get storage handler\n        // Get tile reference, based on URI and world\n        MapStorageTile tile = store.getTile(w, uri);\n        if (tile == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Read tile\n        TileRead tr = null;\n        if (tile.getReadLock(5000)) {\n            tr = tile.read();\n            tile.releaseReadLock();\n        }\n        response.setHeader(\"Cache-Control\", \"max-age=0,must-revalidate\");\n        String etag;\n        if (tr == null) {\n        \tetag = \"\\\"\" + blankpnghash + \"\\\"\";\n        }\n        else {\n        \tetag = \"\\\"\" + tr.hashCode + \"\\\"\";\n        }\n        response.setHeader(\"ETag\", etag);\n        String ifnullmatch = request.getHeader(\"If-None-Match\");\n        if ((ifnullmatch != null) && ifnullmatch.equals(etag)) {\n            response.sendError(HttpStatus.NOT_MODIFIED_304);\n        \treturn;\n        }\n        if (tr == null) {\n            response.setContentType(\"image/png\");\n            response.setIntHeader(\"Content-Length\", blankpng.length);\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Got tile, package up for response\n        response.setDateHeader(\"Last-Modified\", tr.lastModified);\n        response.setIntHeader(\"Content-Length\", tr.image.length());\n        if (tr.format == ImageEncoding.PNG) {\n            response.setContentType(\"image/png\");\n        }\n        else {\n            response.setContentType(\"image/jpeg\");\n        }\n        ServletOutputStream out = response.getOutputStream();\n        out.write(tr.image.buffer(), 0, tr.image.length());\n        out.flush();\n\n    }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "String", "target", ",", "Request", "baseRequest", ",", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "baseRequest", ".", "getPathInfo", "(", ")", ";", "int", "soff", "=", "0", ",", "eoff", ";", "baseRequest", ".", "setHandled", "(", "true", ")", ";", "if", "(", "core", ".", "getLoginRequired", "(", ")", "&&", "request", ".", "getSession", "(", "true", ")", ".", "getAttribute", "(", "LoginServlet", ".", "USERID_ATTRIB", ")", "==", "null", ")", "{", "response", ".", "sendError", "(", "HttpStatus", ".", "UNAUTHORIZED_401", ")", ";", "return", ";", "}", "if", "(", "path", ".", "charAt", "(", "0", ")", "==", "'/'", ")", "soff", "=", "1", ";", "eoff", "=", "path", ".", "indexOf", "(", "'/'", ",", "soff", ")", ";", "if", "(", "soff", "<", "0", ")", "{", "response", ".", "sendError", "(", "HttpStatus", ".", "NOT_FOUND_404", ")", ";", "return", ";", "}", "String", "world", "=", "path", ".", "substring", "(", "soff", ",", "eoff", ")", ";", "String", "uri", "=", "path", ".", "substring", "(", "eoff", "+", "1", ")", ";", "if", "(", "world", ".", "equals", "(", "\"", "faces", "\"", ")", ")", "{", "handleFace", "(", "response", ",", "uri", ")", ";", "return", ";", "}", "if", "(", "world", ".", "equals", "(", "\"", "_markers_", "\"", ")", ")", "{", "handleMarkers", "(", "response", ",", "uri", ")", ";", "return", ";", "}", "DynmapWorld", "w", "=", "null", ";", "if", "(", "core", ".", "mapManager", "!=", "null", ")", "{", "w", "=", "core", ".", "mapManager", ".", "getWorld", "(", "world", ")", ";", "}", "if", "(", "w", "==", "null", ")", "{", "response", ".", "setContentType", "(", "\"", "image/png", "\"", ")", ";", "OutputStream", "os", "=", "response", ".", "getOutputStream", "(", ")", ";", "os", ".", "write", "(", "blankpng", ")", ";", "return", ";", "}", "MapStorage", "store", "=", "w", ".", "getMapStorage", "(", ")", ";", "MapStorageTile", "tile", "=", "store", ".", "getTile", "(", "w", ",", "uri", ")", ";", "if", "(", "tile", "==", "null", ")", "{", "response", ".", "setContentType", "(", "\"", "image/png", "\"", ")", ";", "OutputStream", "os", "=", "response", ".", "getOutputStream", "(", ")", ";", "os", ".", "write", "(", "blankpng", ")", ";", "return", ";", "}", "TileRead", "tr", "=", "null", ";", "if", "(", "tile", ".", "getReadLock", "(", "5000", ")", ")", "{", "tr", "=", "tile", ".", "read", "(", ")", ";", "tile", ".", "releaseReadLock", "(", ")", ";", "}", "response", ".", "setHeader", "(", "\"", "Cache-Control", "\"", ",", "\"", "max-age=0,must-revalidate", "\"", ")", ";", "String", "etag", ";", "if", "(", "tr", "==", "null", ")", "{", "etag", "=", "\"", "\\\"", "\"", "+", "blankpnghash", "+", "\"", "\\\"", "\"", ";", "}", "else", "{", "etag", "=", "\"", "\\\"", "\"", "+", "tr", ".", "hashCode", "+", "\"", "\\\"", "\"", ";", "}", "response", ".", "setHeader", "(", "\"", "ETag", "\"", ",", "etag", ")", ";", "String", "ifnullmatch", "=", "request", ".", "getHeader", "(", "\"", "If-None-Match", "\"", ")", ";", "if", "(", "(", "ifnullmatch", "!=", "null", ")", "&&", "ifnullmatch", ".", "equals", "(", "etag", ")", ")", "{", "response", ".", "sendError", "(", "HttpStatus", ".", "NOT_MODIFIED_304", ")", ";", "return", ";", "}", "if", "(", "tr", "==", "null", ")", "{", "response", ".", "setContentType", "(", "\"", "image/png", "\"", ")", ";", "response", ".", "setIntHeader", "(", "\"", "Content-Length", "\"", ",", "blankpng", ".", "length", ")", ";", "OutputStream", "os", "=", "response", ".", "getOutputStream", "(", ")", ";", "os", ".", "write", "(", "blankpng", ")", ";", "return", ";", "}", "response", ".", "setDateHeader", "(", "\"", "Last-Modified", "\"", ",", "tr", ".", "lastModified", ")", ";", "response", ".", "setIntHeader", "(", "\"", "Content-Length", "\"", ",", "tr", ".", "image", ".", "length", "(", ")", ")", ";", "if", "(", "tr", ".", "format", "==", "ImageEncoding", ".", "PNG", ")", "{", "response", ".", "setContentType", "(", "\"", "image/png", "\"", ")", ";", "}", "else", "{", "response", ".", "setContentType", "(", "\"", "image/jpeg", "\"", ")", ";", "}", "ServletOutputStream", "out", "=", "response", ".", "getOutputStream", "(", ")", ";", "out", ".", "write", "(", "tr", ".", "image", ".", "buffer", "(", ")", ",", "0", ",", "tr", ".", "image", ".", "length", "(", ")", ")", ";", "out", ".", "flush", "(", ")", ";", "}"], "idx": 38722, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "641f142cd3ccdcbfb04eda3059be22dd9ed93783", "function_name": "handle", "body_hash": "6f4651de757babe67335e944f45ec03da42e87d1"}
{"code": "public Object map2bean(final Map map, Class targetType) {\n\t\tObject target = null;\n\n\t\t// create targets type\n\t\tString className = (String) map.get(classMetadataName);\n\n\t\tif (className == null) {\n\t\t\tif (targetType == null) {\n\t\t\t\t// nothing to do, no information about target type found\n\t\t\t\ttarget = map;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcheckClassName(jsonParser.classnameWhitelist, className);\n\n\t\t\ttry {\n\t\t\t\ttargetType = ClassLoaderUtil.loadClass(className);\n\t\t\t} catch (ClassNotFoundException cnfex) {\n\t\t\t\tthrow new JsonException(cnfex);\n\t\t\t}\n\t\t}\n\n\t\tif (target == null) {\n\t\t\ttarget = jsonParser.newObjectInstance(targetType);\n\t\t}\n\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());\n\n\t\tboolean targetIsMap = target instanceof Map;\n\n\t\tfor (Object key : map.keySet()) {\n\t\t\tString keyName = key.toString();\n\n\t\t\tif (classMetadataName != null) {\n\t\t\t\tif (keyName.equals(classMetadataName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared);\n\n\t\t\tif (!targetIsMap && pd == null) {\n\t\t\t\t// target property does not exist, continue\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// value is one of JSON basic types, like Number, Map, List...\n\t\t\tObject value = map.get(key);\n\n\t\t\tClass propertyType = pd == null ? null : pd.getType();\n\t\t\tClass componentType = pd == null ? null : pd.resolveComponentType(true);\n\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof List) {\n\t\t\t\t\tif (componentType != null && componentType != String.class) {\n\t\t\t\t\t\tvalue = generifyList((List) value, componentType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (value instanceof Map) {\n\t\t\t\t\t// if the value we want to inject is a Map...\n\t\t\t\t\tif (!ClassUtil.isTypeOf(propertyType, Map.class)) {\n\t\t\t\t\t\t// ... and if target is NOT a map\n\t\t\t\t\t\tvalue = map2bean((Map) value, propertyType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// target is also a Map, but we might need to generify it\n\t\t\t\t\t\tClass keyType = pd == null ? null : pd.resolveKeyType(true);\n\n\t\t\t\t\t\tif (keyType != String.class || componentType != String.class) {\n\t\t\t\t\t\t\t// generify\n\t\t\t\t\t\t\tvalue = generifyMap((Map) value, keyType, componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (targetIsMap) {\n\t\t\t\t((Map)target).put(keyName, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tsetValue(target, pd, value);\n\t\t\t\t} catch (Exception ignore) {\n\t\t\t\t\tignore.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}", "code_tokens": ["public", "Object", "map2bean", "(", "final", "Map", "map", ",", "Class", "targetType", ")", "{", "Object", "target", "=", "null", ";", "String", "className", "=", "(", "String", ")", "map", ".", "get", "(", "classMetadataName", ")", ";", "if", "(", "className", "==", "null", ")", "{", "if", "(", "targetType", "==", "null", ")", "{", "target", "=", "map", ";", "}", "}", "else", "{", "checkClassName", "(", "jsonParser", ".", "classnameWhitelist", ",", "className", ")", ";", "try", "{", "targetType", "=", "ClassLoaderUtil", ".", "loadClass", "(", "className", ")", ";", "}", "catch", "(", "ClassNotFoundException", "cnfex", ")", "{", "throw", "new", "JsonException", "(", "cnfex", ")", ";", "}", "}", "if", "(", "target", "==", "null", ")", "{", "target", "=", "jsonParser", ".", "newObjectInstance", "(", "targetType", ")", ";", "}", "ClassDescriptor", "cd", "=", "ClassIntrospector", ".", "get", "(", ")", ".", "lookup", "(", "target", ".", "getClass", "(", ")", ")", ";", "boolean", "targetIsMap", "=", "target", "instanceof", "Map", ";", "for", "(", "Object", "key", ":", "map", ".", "keySet", "(", ")", ")", "{", "String", "keyName", "=", "key", ".", "toString", "(", ")", ";", "if", "(", "classMetadataName", "!=", "null", ")", "{", "if", "(", "keyName", ".", "equals", "(", "classMetadataName", ")", ")", "{", "continue", ";", "}", "}", "PropertyDescriptor", "pd", "=", "cd", ".", "getPropertyDescriptor", "(", "keyName", ",", "declared", ")", ";", "if", "(", "!", "targetIsMap", "&&", "pd", "==", "null", ")", "{", "continue", ";", "}", "Object", "value", "=", "map", ".", "get", "(", "key", ")", ";", "Class", "propertyType", "=", "pd", "==", "null", "?", "null", ":", "pd", ".", "getType", "(", ")", ";", "Class", "componentType", "=", "pd", "==", "null", "?", "null", ":", "pd", ".", "resolveComponentType", "(", "true", ")", ";", "if", "(", "value", "!=", "null", ")", "{", "if", "(", "value", "instanceof", "List", ")", "{", "if", "(", "componentType", "!=", "null", "&&", "componentType", "!=", "String", ".", "class", ")", "{", "value", "=", "generifyList", "(", "(", "List", ")", "value", ",", "componentType", ")", ";", "}", "}", "else", "if", "(", "value", "instanceof", "Map", ")", "{", "if", "(", "!", "ClassUtil", ".", "isTypeOf", "(", "propertyType", ",", "Map", ".", "class", ")", ")", "{", "value", "=", "map2bean", "(", "(", "Map", ")", "value", ",", "propertyType", ")", ";", "}", "else", "{", "Class", "keyType", "=", "pd", "==", "null", "?", "null", ":", "pd", ".", "resolveKeyType", "(", "true", ")", ";", "if", "(", "keyType", "!=", "String", ".", "class", "||", "componentType", "!=", "String", ".", "class", ")", "{", "value", "=", "generifyMap", "(", "(", "Map", ")", "value", ",", "keyType", ",", "componentType", ")", ";", "}", "}", "}", "}", "if", "(", "targetIsMap", ")", "{", "(", "(", "Map", ")", "target", ")", ".", "put", "(", "keyName", ",", "value", ")", ";", "}", "else", "{", "try", "{", "setValue", "(", "target", ",", "pd", ",", "value", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "ignore", ".", "printStackTrace", "(", ")", ";", "}", "}", "}", "return", "target", ";", "}"], "idx": 59458, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "9bffc3913aeb8472c11bb543243004b4b4376f16", "function_name": "map2bean", "body_hash": "c8a93dc328c31b5f0079d3eec0ec99c3b9924215"}
{"code": "protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {\n      boolean isValid = false;\n\n      if (logger.isDebugEnabled()) {\n         logger.debug(\"Binding the user.\");\n      }\n      context.addToEnvironment(Context.SECURITY_AUTHENTICATION, \"simple\");\n      context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);\n      context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n      try {\n         context.getAttributes(\"\", null);\n         isValid = true;\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"User \" + dn + \" successfully bound.\");\n         }\n      } catch (AuthenticationException e) {\n         isValid = false;\n         if (logger.isDebugEnabled()) {\n            logger.debug(\"Authentication failed for dn=\" + dn);\n         }\n      }\n\n      if (isLoginPropertySet(CONNECTION_USERNAME)) {\n         context.addToEnvironment(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));\n      } else {\n         context.removeFromEnvironment(Context.SECURITY_PRINCIPAL);\n      }\n      if (isLoginPropertySet(CONNECTION_PASSWORD)) {\n         context.addToEnvironment(Context.SECURITY_CREDENTIALS, getPlainPassword(getLDAPPropertyValue(CONNECTION_PASSWORD)));\n      } else {\n         context.removeFromEnvironment(Context.SECURITY_CREDENTIALS);\n      }\n      context.addToEnvironment(Context.SECURITY_AUTHENTICATION, getLDAPPropertyValue(AUTHENTICATION));\n\n      return isValid;\n   }", "code_tokens": ["protected", "boolean", "bindUser", "(", "DirContext", "context", ",", "String", "dn", ",", "String", "password", ")", "throws", "NamingException", "{", "boolean", "isValid", "=", "false", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Binding the user.", "\"", ")", ";", "}", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "\"", "simple", "\"", ")", ";", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "dn", ")", ";", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "password", ")", ";", "try", "{", "context", ".", "getAttributes", "(", "\"", "\"", ",", "null", ")", ";", "isValid", "=", "true", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "User ", "\"", "+", "dn", "+", "\"", " successfully bound.", "\"", ")", ";", "}", "}", "catch", "(", "AuthenticationException", "e", ")", "{", "isValid", "=", "false", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Authentication failed for dn=", "\"", "+", "dn", ")", ";", "}", "}", "if", "(", "isLoginPropertySet", "(", "CONNECTION_USERNAME", ")", ")", "{", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "getLDAPPropertyValue", "(", "CONNECTION_USERNAME", ")", ")", ";", "}", "else", "{", "context", ".", "removeFromEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ")", ";", "}", "if", "(", "isLoginPropertySet", "(", "CONNECTION_PASSWORD", ")", ")", "{", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "getPlainPassword", "(", "getLDAPPropertyValue", "(", "CONNECTION_PASSWORD", ")", ")", ")", ";", "}", "else", "{", "context", ".", "removeFromEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ")", ";", "}", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "getLDAPPropertyValue", "(", "AUTHENTICATION", ")", ")", ";", "return", "isValid", ";", "}"], "idx": 38281, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "ec1c5a96c7", "function_name": "bindUser", "body_hash": "01cc25b7afd1202b82818d49e6b8a6dd8f2f67dd"}
{"code": "private static CloseableHttpClient getAllTrustClient(HttpHost proxy) {\n\t\t\ttry {\n\t\t\t\tHttpClientBuilder clientBuilder = HttpClientBuilder.create();\n\t\t\t\tSSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {\n\t\t\t\t\tpublic boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}).build();\n\t\t\t\tclientBuilder.setSSLContext(sslContext);\n\t\t\t\t\n\t\t\t\tHostnameVerifier hostnameVerifier = new NoopHostnameVerifier();\n\t\n\t\t\t\tSSLConnectionSocketFactory sslSocketFactory = new SSLConnectionSocketFactory(sslContext, hostnameVerifier);\n\t\t\t\tRegistry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create()\n\t\t\t\t\t\t.register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n\t\t\t\t\t\t.register(\"https\", sslSocketFactory)\n\t\t\t\t\t\t.build();\n\t\t\t \n\t\t\t\tPoolingHttpClientConnectionManager connMgr = new PoolingHttpClientConnectionManager( socketFactoryRegistry);\n\t\t\t\tclientBuilder.setConnectionManager(connMgr);\n\t\t\t \n\t\t\t\treturn clientBuilder.build();\n\t\t\t} catch (GeneralSecurityException e) {\n\t\t\t\t// shouldn't happen\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}", "code_tokens": ["private", "static", "CloseableHttpClient", "getAllTrustClient", "(", "HttpHost", "proxy", ")", "{", "try", "{", "HttpClientBuilder", "clientBuilder", "=", "HttpClientBuilder", ".", "create", "(", ")", ";", "SSLContext", "sslContext", "=", "new", "SSLContextBuilder", "(", ")", ".", "loadTrustMaterial", "(", "null", ",", "new", "TrustStrategy", "(", ")", "{", "public", "boolean", "isTrusted", "(", "X509Certificate", "[", "]", "chain", ",", "String", "authType", ")", "throws", "CertificateException", "{", "return", "true", ";", "}", "}", ")", ".", "build", "(", ")", ";", "clientBuilder", ".", "setSSLContext", "(", "sslContext", ")", ";", "HostnameVerifier", "hostnameVerifier", "=", "new", "NoopHostnameVerifier", "(", ")", ";", "SSLConnectionSocketFactory", "sslSocketFactory", "=", "new", "SSLConnectionSocketFactory", "(", "sslContext", ",", "hostnameVerifier", ")", ";", "Registry", "<", "ConnectionSocketFactory", ">", "socketFactoryRegistry", "=", "RegistryBuilder", ".", "<", "ConnectionSocketFactory", ">", "create", "(", ")", ".", "register", "(", "\"", "http", "\"", ",", "PlainConnectionSocketFactory", ".", "getSocketFactory", "(", ")", ")", ".", "register", "(", "\"", "https", "\"", ",", "sslSocketFactory", ")", ".", "build", "(", ")", ";", "PoolingHttpClientConnectionManager", "connMgr", "=", "new", "PoolingHttpClientConnectionManager", "(", "socketFactoryRegistry", ")", ";", "clientBuilder", ".", "setConnectionManager", "(", "connMgr", ")", ";", "return", "clientBuilder", ".", "build", "(", ")", ";", "}", "catch", "(", "GeneralSecurityException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}"], "idx": 45760, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "5151e115", "function_name": "getAllTrustClient", "body_hash": "b4854f0392d458dc1413962006cd9635dc81ba5d"}
{"code": "@Override\n        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.process\",\n                        wrapper.getSocket(), status));\n            }\n            if (wrapper == null) {\n                // Nothing to do. Socket has been closed.\n                return SocketState.CLOSED;\n            }\n\n            S socket = wrapper.getSocket();\n\n            Processor processor = (Processor) wrapper.getCurrentProcessor();\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.connectionsGet\",\n                        processor, socket));\n            }\n\n            // Timeouts are calculated on a dedicated thread and then\n            // dispatched. Because of delays in the dispatch process, the\n            // timeout may no longer be required. Check here and avoid\n            // unnecessary processing.\n            if (SocketEvent.TIMEOUT == status &&\n                    (processor == null ||\n                    !processor.isAsync() && !processor.isUpgrade() ||\n                    processor.isAsync() && !processor.checkAsyncTimeoutGeneration())) {\n                // This is effectively a NO-OP\n                return SocketState.OPEN;\n            }\n\n            if (processor != null) {\n                // Make sure an async timeout doesn't fire\n                getProtocol().removeWaitingProcessor(processor);\n            } else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) {\n                // Nothing to do. Endpoint requested a close and there is no\n                // longer a processor associated with this socket.\n                return SocketState.CLOSED;\n            }\n\n            ContainerThreadMarker.set();\n\n            try {\n                if (processor == null) {\n                    String negotiatedProtocol = wrapper.getNegotiatedProtocol();\n                    // OpenSSL typically returns null whereas JSSE typically\n                    // returns \"\" when no protocol is negotiated\n                    if (negotiatedProtocol != null && negotiatedProtocol.length() > 0) {\n                        UpgradeProtocol upgradeProtocol = getProtocol().getNegotiatedProtocol(negotiatedProtocol);\n                        if (upgradeProtocol != null) {\n                            processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                            }\n                        } else if (negotiatedProtocol.equals(\"http/1.1\")) {\n                            // Explicitly negotiated the default protocol.\n                            // Obtain a processor below.\n                        } else {\n                            // TODO:\n                            // OpenSSL 1.0.2's ALPN callback doesn't support\n                            // failing the handshake with an error if no\n                            // protocol can be negotiated. Therefore, we need to\n                            // fail the connection here. Once this is fixed,\n                            // replace the code below with the commented out\n                            // block.\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        negotiatedProtocol));\n                            }\n                            return SocketState.CLOSED;\n                            /*\n                             * To replace the code above once OpenSSL 1.1.0 is\n                             * used.\n                            // Failed to create processor. This is a bug.\n                            throw new IllegalStateException(sm.getString(\n                                    \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                    negotiatedProtocol));\n                            */\n                        }\n                    }\n                }\n                if (processor == null) {\n                    processor = recycledProcessors.pop();\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorPop\", processor));\n                    }\n                }\n                if (processor == null) {\n                    processor = getProtocol().createProcessor();\n                    register(processor);\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                    }\n                }\n\n                processor.setSslSupport(\n                        wrapper.getSslSupport(getProtocol().getClientCertProvider()));\n\n                // Associate the processor with the connection\n                wrapper.setCurrentProcessor(processor);\n\n                SocketState state = SocketState.CLOSED;\n                do {\n                    state = processor.process(wrapper, status);\n\n                    if (state == SocketState.UPGRADING) {\n                        // Get the HTTP upgrade handler\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        // Retrieve leftover input\n                        ByteBuffer leftOverInput = processor.getLeftoverInput();\n                        if (upgradeToken == null) {\n                            // Assume direct HTTP/2 connection\n                            UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(\"h2c\");\n                            if (upgradeProtocol != null) {\n                                // Release the Http11 processor to be re-used\n                                release(processor);\n                                // Create the upgrade processor\n                                processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                                wrapper.unRead(leftOverInput);\n                                // Associate with the processor with the connection\n                                wrapper.setCurrentProcessor(processor);\n                            } else {\n                                if (getLog().isDebugEnabled()) {\n                                    getLog().debug(sm.getString(\n                                        \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        \"h2c\"));\n                                }\n                                // Exit loop and trigger appropriate clean-up\n                                state = SocketState.CLOSED;\n                            }\n                        } else {\n                            HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                            // Release the Http11 processor to be re-used\n                            release(processor);\n                            // Create the upgrade processor\n                            processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.upgradeCreate\",\n                                        processor, wrapper));\n                            }\n                            wrapper.unRead(leftOverInput);\n                            // Mark the connection as upgraded\n                            wrapper.setUpgraded(true);\n                            // Associate with the processor with the connection\n                            wrapper.setCurrentProcessor(processor);\n                            // Initialise the upgrade handler (which may trigger\n                            // some IO using the new protocol which is why the lines\n                            // above are necessary)\n                            // This cast should be safe. If it fails the error\n                            // handling for the surrounding try/catch will deal with\n                            // it.\n                            if (upgradeToken.getInstanceManager() == null) {\n                                httpUpgradeHandler.init((WebConnection) processor);\n                            } else {\n                                ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                                try {\n                                    httpUpgradeHandler.init((WebConnection) processor);\n                                } finally {\n                                    upgradeToken.getContextBind().unbind(false, oldCL);\n                                }\n                            }\n                            if (httpUpgradeHandler instanceof InternalHttpUpgradeHandler) {\n                                if (((InternalHttpUpgradeHandler) httpUpgradeHandler).hasAsyncIO()) {\n                                    // The handler will initiate all further I/O\n                                    state = SocketState.LONG;\n                                }\n                            }\n                        }\n                    }\n                } while ( state == SocketState.UPGRADING);\n\n                if (state == SocketState.LONG) {\n                    // In the middle of processing a request/response. Keep the\n                    // socket associated with the processor. Exact requirements\n                    // depend on type of long poll\n                    longPoll(wrapper, processor);\n                    if (processor.isAsync()) {\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.OPEN) {\n                    // In keep-alive but between requests. OK to recycle\n                    // processor. Continue to poll for the next request.\n                    wrapper.setCurrentProcessor(null);\n                    release(processor);\n                    wrapper.registerReadInterest();\n                } else if (state == SocketState.SENDFILE) {\n                    // Sendfile in progress. If it fails, the socket will be\n                    // closed. If it works, the socket either be added to the\n                    // poller (or equivalent) to await more data or processed\n                    // if there are any pipe-lined requests remaining.\n                } else if (state == SocketState.UPGRADED) {\n                    // Don't add sockets back to the poller if this was a\n                    // non-blocking write otherwise the poller may trigger\n                    // multiple read events which may lead to thread starvation\n                    // in the connector. The write() method will add this socket\n                    // to the poller if necessary.\n                    if (status != SocketEvent.OPEN_WRITE) {\n                        longPoll(wrapper, processor);\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.SUSPENDED) {\n                    // Don't add sockets back to the poller.\n                    // The resumeProcessing() method will add this socket\n                    // to the poller.\n                } else {\n                    // Connection closed. OK to recycle the processor.\n                    // Processors handling upgrades require additional clean-up\n                    // before release.\n                    wrapper.setCurrentProcessor(null);\n                    if (processor.isUpgrade()) {\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                        InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                        if (instanceManager == null) {\n                            httpUpgradeHandler.destroy();\n                        } else {\n                            ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                            try {\n                                httpUpgradeHandler.destroy();\n                            } finally {\n                                try {\n                                    instanceManager.destroyInstance(httpUpgradeHandler);\n                                } catch (Throwable e) {\n                                    ExceptionUtils.handleThrowable(e);\n                                    getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n                                }\n                                upgradeToken.getContextBind().unbind(false, oldCL);\n                            }\n                        }\n                    }\n                    release(processor);\n                }\n                return state;\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.ioexception.debug\"), e);\n            } catch (ProtocolException e) {\n                // Protocol exceptions normally mean the client sent invalid or\n                // incomplete data.\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.protocolexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (OutOfMemoryError oome) {\n                // Try and handle this here to give Tomcat a chance to close the\n                // connection and prevent clients waiting until they time out.\n                // Worst case, it isn't recoverable and the attempt at logging\n                // will trigger another OOME.\n                getLog().error(sm.getString(\"abstractConnectionHandler.oome\"), oome);\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n            } finally {\n                ContainerThreadMarker.clear();\n            }\n\n            // Make sure socket/processor is removed from the list of current\n            // connections\n            wrapper.setCurrentProcessor(null);\n            release(processor);\n            return SocketState.CLOSED;\n        }", "code_tokens": ["@", "Override", "public", "SocketState", "process", "(", "SocketWrapperBase", "<", "S", ">", "wrapper", ",", "SocketEvent", "status", ")", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.process", "\"", ",", "wrapper", ".", "getSocket", "(", ")", ",", "status", ")", ")", ";", "}", "if", "(", "wrapper", "==", "null", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "S", "socket", "=", "wrapper", ".", "getSocket", "(", ")", ";", "Processor", "processor", "=", "(", "Processor", ")", "wrapper", ".", "getCurrentProcessor", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.connectionsGet", "\"", ",", "processor", ",", "socket", ")", ")", ";", "}", "if", "(", "SocketEvent", ".", "TIMEOUT", "==", "status", "&&", "(", "processor", "==", "null", "||", "!", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "isUpgrade", "(", ")", "||", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "checkAsyncTimeoutGeneration", "(", ")", ")", ")", "{", "return", "SocketState", ".", "OPEN", ";", "}", "if", "(", "processor", "!=", "null", ")", "{", "getProtocol", "(", ")", ".", "removeWaitingProcessor", "(", "processor", ")", ";", "}", "else", "if", "(", "status", "==", "SocketEvent", ".", "DISCONNECT", "||", "status", "==", "SocketEvent", ".", "ERROR", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "ContainerThreadMarker", ".", "set", "(", ")", ";", "try", "{", "if", "(", "processor", "==", "null", ")", "{", "String", "negotiatedProtocol", "=", "wrapper", ".", "getNegotiatedProtocol", "(", ")", ";", "if", "(", "negotiatedProtocol", "!=", "null", "&&", "negotiatedProtocol", ".", "length", "(", ")", ">", "0", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getNegotiatedProtocol", "(", "negotiatedProtocol", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "else", "if", "(", "negotiatedProtocol", ".", "equals", "(", "\"", "http/1.1", "\"", ")", ")", "{", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "negotiatedProtocol", ")", ")", ";", "}", "return", "SocketState", ".", "CLOSED", ";", "}", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "recycledProcessors", ".", "pop", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorPop", "\"", ",", "processor", ")", ")", ";", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "getProtocol", "(", ")", ".", "createProcessor", "(", ")", ";", "register", "(", "processor", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "processor", ".", "setSslSupport", "(", "wrapper", ".", "getSslSupport", "(", "getProtocol", "(", ")", ".", "getClientCertProvider", "(", ")", ")", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "SocketState", "state", "=", "SocketState", ".", "CLOSED", ";", "do", "{", "state", "=", "processor", ".", "process", "(", "wrapper", ",", "status", ")", ";", "if", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "ByteBuffer", "leftOverInput", "=", "processor", ".", "getLeftoverInput", "(", ")", ";", "if", "(", "upgradeToken", "==", "null", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getUpgradeProtocol", "(", "\"", "h2c", "\"", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "release", "(", "processor", ")", ";", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "\"", "h2c", "\"", ")", ")", ";", "}", "state", "=", "SocketState", ".", "CLOSED", ";", "}", "}", "else", "{", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "release", "(", "processor", ")", ";", "processor", "=", "getProtocol", "(", ")", ".", "createUpgradeProcessor", "(", "wrapper", ",", "upgradeToken", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.upgradeCreate", "\"", ",", "processor", ",", "wrapper", ")", ")", ";", "}", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "wrapper", ".", "setUpgraded", "(", "true", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "if", "(", "upgradeToken", ".", "getInstanceManager", "(", ")", "==", "null", ")", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "finally", "{", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "if", "(", "httpUpgradeHandler", "instanceof", "InternalHttpUpgradeHandler", ")", "{", "if", "(", "(", "(", "InternalHttpUpgradeHandler", ")", "httpUpgradeHandler", ")", ".", "hasAsyncIO", "(", ")", ")", "{", "state", "=", "SocketState", ".", "LONG", ";", "}", "}", "}", "}", "}", "while", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", ";", "if", "(", "state", "==", "SocketState", ".", "LONG", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "if", "(", "processor", ".", "isAsync", "(", ")", ")", "{", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "OPEN", ")", "{", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "release", "(", "processor", ")", ";", "wrapper", ".", "registerReadInterest", "(", ")", ";", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SENDFILE", ")", "{", "}", "else", "if", "(", "state", "==", "SocketState", ".", "UPGRADED", ")", "{", "if", "(", "status", "!=", "SocketEvent", ".", "OPEN_WRITE", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SUSPENDED", ")", "{", "}", "else", "{", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "if", "(", "processor", ".", "isUpgrade", "(", ")", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "InstanceManager", "instanceManager", "=", "upgradeToken", ".", "getInstanceManager", "(", ")", ";", "if", "(", "instanceManager", "==", "null", ")", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "finally", "{", "try", "{", "instanceManager", ".", "destroyInstance", "(", "httpUpgradeHandler", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "}", "release", "(", "processor", ")", ";", "}", "return", "state", ";", "}", "catch", "(", "java", ".", "net", ".", "SocketException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.socketexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "java", ".", "io", ".", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.ioexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "ProtocolException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.protocolexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "OutOfMemoryError", "oome", ")", "{", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.oome", "\"", ")", ",", "oome", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "finally", "{", "ContainerThreadMarker", ".", "clear", "(", ")", ";", "}", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "release", "(", "processor", ")", ";", "return", "SocketState", ".", "CLOSED", ";", "}"], "idx": 56814, "cwe": "CWE-476", "target": 0, "status": "FIXED", "commit": "172977f04a5215128f1e278a688983dcd230f399", "function_name": "process", "body_hash": "95ec474f06a902181dc3210b349ebe5341d7a24a"}
{"code": "public static String resolvePath(String uri) {\n\t\tif (uri.isEmpty()) {\n\t\t\treturn uri;\n\t\t}\n\n\t\tString path = URI.create(uri.charAt(0) == '/' ? \"http://localhost:8080\" + uri : uri)\n\t\t                 .getPath();\n\t\tif (!path.isEmpty()) {\n\t\t\tif (path.charAt(0) == '/') {\n\t\t\t\tpath = path.substring(1);\n\t\t\t\tif (path.isEmpty()) {\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path.charAt(path.length() - 1) == '/') {\n\t\t\t\treturn path.substring(0, path.length() - 1);\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}", "code_tokens": ["public", "static", "String", "resolvePath", "(", "String", "uri", ")", "{", "if", "(", "uri", ".", "isEmpty", "(", ")", ")", "{", "return", "uri", ";", "}", "String", "path", "=", "URI", ".", "create", "(", "uri", ".", "charAt", "(", "0", ")", "==", "'/'", "?", "\"", "http://localhost:8080", "\"", "+", "uri", ":", "uri", ")", ".", "getPath", "(", ")", ";", "if", "(", "!", "path", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "path", ".", "charAt", "(", "0", ")", "==", "'/'", ")", "{", "path", "=", "path", ".", "substring", "(", "1", ")", ";", "if", "(", "path", ".", "isEmpty", "(", ")", ")", "{", "return", "path", ";", "}", "}", "if", "(", "path", ".", "charAt", "(", "path", ".", "length", "(", ")", "-", "1", ")", "==", "'/'", ")", "{", "return", "path", ".", "substring", "(", "0", ",", "path", ".", "length", "(", ")", "-", "1", ")", ";", "}", "}", "return", "path", ";", "}"], "idx": 74863, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "9131fa0", "function_name": "resolvePath", "body_hash": "95482953c7733d3eeb5d82089a54b4a88f341c26"}
{"code": "public static boolean isStaxSource(Source source) {\n\t\treturn (source instanceof StaxSource || (jaxp14Available && Jaxp14StaxHandler.isStaxSource(source)));\n\t}", "code_tokens": ["public", "static", "boolean", "isStaxSource", "(", "Source", "source", ")", "{", "return", "(", "source", "instanceof", "StaxSource", "||", "(", "jaxp14Available", "&&", "Jaxp14StaxHandler", ".", "isStaxSource", "(", "source", ")", ")", ")", ";", "}"], "idx": 45450, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "7387cb990e35b0f1b573faf29d4f9ae183d7a5e", "function_name": "isStaxSource", "body_hash": "b991231bd866d22630d59df8d87ba9cddaac9532"}
{"code": "@Override\n    public HeaderEmitter headersStart(int streamId, boolean headersEndStream)\n            throws Http2Exception, IOException {\n\n        // Check the pause state before processing headers since the pause state\n        // determines if a new stream is created or if this stream is ignored.\n        checkPauseState();\n\n        if (connectionState.get().isNewStreamAllowed()) {\n            Stream stream = getStream(streamId, false);\n            if (stream == null) {\n                stream = createRemoteStream(streamId);\n            }\n            if (streamId < maxActiveRemoteStreamId) {\n                throw new ConnectionException(sm.getString(\"upgradeHandler.stream.old\",\n                        Integer.valueOf(streamId), Integer.valueOf(maxActiveRemoteStreamId)),\n                        Http2Error.PROTOCOL_ERROR);\n            }\n            stream.checkState(FrameType.HEADERS);\n            stream.receivedStartOfHeaders(headersEndStream);\n            closeIdleStreams(streamId);\n            return stream;\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"upgradeHandler.noNewStreams\",\n                        connectionId, Integer.toString(streamId)));\n            }\n            reduceOverheadCount();\n            // Stateless so a static can be used to save on GC\n            return HEADER_SINK;\n        }\n    }", "code_tokens": ["@", "Override", "public", "HeaderEmitter", "headersStart", "(", "int", "streamId", ",", "boolean", "headersEndStream", ")", "throws", "Http2Exception", ",", "IOException", "{", "checkPauseState", "(", ")", ";", "if", "(", "connectionState", ".", "get", "(", ")", ".", "isNewStreamAllowed", "(", ")", ")", "{", "Stream", "stream", "=", "getStream", "(", "streamId", ",", "false", ")", ";", "if", "(", "stream", "==", "null", ")", "{", "stream", "=", "createRemoteStream", "(", "streamId", ")", ";", "}", "if", "(", "streamId", "<", "maxActiveRemoteStreamId", ")", "{", "throw", "new", "ConnectionException", "(", "sm", ".", "getString", "(", "\"", "upgradeHandler.stream.old", "\"", ",", "Integer", ".", "valueOf", "(", "streamId", ")", ",", "Integer", ".", "valueOf", "(", "maxActiveRemoteStreamId", ")", ")", ",", "Http2Error", ".", "PROTOCOL_ERROR", ")", ";", "}", "stream", ".", "checkState", "(", "FrameType", ".", "HEADERS", ")", ";", "stream", ".", "receivedStartOfHeaders", "(", "headersEndStream", ")", ";", "closeIdleStreams", "(", "streamId", ")", ";", "return", "stream", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "upgradeHandler.noNewStreams", "\"", ",", "connectionId", ",", "Integer", ".", "toString", "(", "streamId", ")", ")", ")", ";", "}", "reduceOverheadCount", "(", ")", ";", "return", "HEADER_SINK", ";", "}", "}"], "idx": 99694, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "1bbc650cbc3f08d85a1ec6d803c47ae53a84f3bb", "function_name": "headersStart", "body_hash": "75d02a961fcb717e8f0a879d9e4d949747ab2e30"}
{"code": "protected void parseLocalesHeader(String value) {\n\n        // Store the accumulated languages that have been requested in\n        // a local collection, sorted by the quality value (so we can\n        // add Locales in descending order).  The values will be ArrayLists\n        // containing the corresponding Locales to be added\n        TreeMap<Double, ArrayList<Locale>> locales = new TreeMap<Double, ArrayList<Locale>>();\n\n        // Preprocess the value to remove all whitespace\n        int white = value.indexOf(' ');\n        if (white < 0)\n            white = value.indexOf('\\t');\n        if (white >= 0) {\n            StringBuilder sb = new StringBuilder();\n            int len = value.length();\n            for (int i = 0; i < len; i++) {\n                char ch = value.charAt(i);\n                if ((ch != ' ') && (ch != '\\t'))\n                    sb.append(ch);\n            }\n            parser.setString(sb.toString());\n        } else {\n            parser.setString(value);\n        }\n\n        // Process each comma-delimited language specification\n        int length = parser.getLength();\n        while (true) {\n\n            // Extract the next comma-delimited entry\n            int start = parser.getIndex();\n            if (start >= length)\n                break;\n            int end = parser.findChar(',');\n            String entry = parser.extract(start, end).trim();\n            parser.advance();   // For the following entry\n\n            // Extract the quality factor for this entry\n            double quality = 1.0;\n            int semi = entry.indexOf(\";q=\");\n            if (semi >= 0) {\n                try {\n                    String strQuality = entry.substring(semi + 3);\n                    if (strQuality.length() <= 5) {\n                        quality = Double.parseDouble(strQuality);\n                    } else {\n                        quality = 0.0;\n                    }\n                } catch (NumberFormatException e) {\n                    quality = 0.0;\n                }\n                entry = entry.substring(0, semi);\n            }\n\n            // Skip entries we are not going to keep track of\n            if (quality < 0.00005)\n                continue;       // Zero (or effectively zero) quality factors\n            if (\"*\".equals(entry))\n                continue;       // FIXME - \"*\" entries are not handled\n\n            // Extract the language and country for this entry\n            String language = null;\n            String country = null;\n            String variant = null;\n            int dash = entry.indexOf('-');\n            if (dash < 0) {\n                language = entry;\n                country = \"\";\n                variant = \"\";\n            } else {\n                language = entry.substring(0, dash);\n                country = entry.substring(dash + 1);\n                int vDash = country.indexOf('-');\n                if (vDash > 0) {\n                    String cTemp = country.substring(0, vDash);\n                    variant = country.substring(vDash + 1);\n                    country = cTemp;\n                } else {\n                    variant = \"\";\n                }\n            }\n            if (!isAlpha(language) || !isAlpha(country) || !isAlpha(variant)) {\n                continue;\n            }\n\n            // Add a new Locale to the list of Locales for this quality level\n            Locale locale = new Locale(language, country, variant);\n            Double key = new Double(-quality);  // Reverse the order\n            ArrayList<Locale> values = locales.get(key);\n            if (values == null) {\n                values = new ArrayList<Locale>();\n                locales.put(key, values);\n            }\n            values.add(locale);\n\n        }\n\n        // Process the quality values in highest->lowest order (due to\n        // negating the Double value when creating the key)\n        for (ArrayList<Locale> list : locales.values()) {\n            for (Locale locale : list) {\n                addLocale(locale);\n            }\n        }\n\n    }", "code_tokens": ["protected", "void", "parseLocalesHeader", "(", "String", "value", ")", "{", "TreeMap", "<", "Double", ",", "ArrayList", "<", "Locale", ">", ">", "locales", "=", "new", "TreeMap", "<", "Double", ",", "ArrayList", "<", "Locale", ">", ">", "(", ")", ";", "int", "white", "=", "value", ".", "indexOf", "(", "' '", ")", ";", "if", "(", "white", "<", "0", ")", "white", "=", "value", ".", "indexOf", "(", "'\\t'", ")", ";", "if", "(", "white", ">=", "0", ")", "{", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", ")", ";", "int", "len", "=", "value", ".", "length", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "char", "ch", "=", "value", ".", "charAt", "(", "i", ")", ";", "if", "(", "(", "ch", "!=", "' '", ")", "&&", "(", "ch", "!=", "'\\t'", ")", ")", "sb", ".", "append", "(", "ch", ")", ";", "}", "parser", ".", "setString", "(", "sb", ".", "toString", "(", ")", ")", ";", "}", "else", "{", "parser", ".", "setString", "(", "value", ")", ";", "}", "int", "length", "=", "parser", ".", "getLength", "(", ")", ";", "while", "(", "true", ")", "{", "int", "start", "=", "parser", ".", "getIndex", "(", ")", ";", "if", "(", "start", ">=", "length", ")", "break", ";", "int", "end", "=", "parser", ".", "findChar", "(", "','", ")", ";", "String", "entry", "=", "parser", ".", "extract", "(", "start", ",", "end", ")", ".", "trim", "(", ")", ";", "parser", ".", "advance", "(", ")", ";", "double", "quality", "=", "1.0", ";", "int", "semi", "=", "entry", ".", "indexOf", "(", "\"", ";q=", "\"", ")", ";", "if", "(", "semi", ">=", "0", ")", "{", "try", "{", "String", "strQuality", "=", "entry", ".", "substring", "(", "semi", "+", "3", ")", ";", "if", "(", "strQuality", ".", "length", "(", ")", "<=", "5", ")", "{", "quality", "=", "Double", ".", "parseDouble", "(", "strQuality", ")", ";", "}", "else", "{", "quality", "=", "0.0", ";", "}", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "quality", "=", "0.0", ";", "}", "entry", "=", "entry", ".", "substring", "(", "0", ",", "semi", ")", ";", "}", "if", "(", "quality", "<", "0.00005", ")", "continue", ";", "if", "(", "\"", "*", "\"", ".", "equals", "(", "entry", ")", ")", "continue", ";", "String", "language", "=", "null", ";", "String", "country", "=", "null", ";", "String", "variant", "=", "null", ";", "int", "dash", "=", "entry", ".", "indexOf", "(", "'-'", ")", ";", "if", "(", "dash", "<", "0", ")", "{", "language", "=", "entry", ";", "country", "=", "\"", "\"", ";", "variant", "=", "\"", "\"", ";", "}", "else", "{", "language", "=", "entry", ".", "substring", "(", "0", ",", "dash", ")", ";", "country", "=", "entry", ".", "substring", "(", "dash", "+", "1", ")", ";", "int", "vDash", "=", "country", ".", "indexOf", "(", "'-'", ")", ";", "if", "(", "vDash", ">", "0", ")", "{", "String", "cTemp", "=", "country", ".", "substring", "(", "0", ",", "vDash", ")", ";", "variant", "=", "country", ".", "substring", "(", "vDash", "+", "1", ")", ";", "country", "=", "cTemp", ";", "}", "else", "{", "variant", "=", "\"", "\"", ";", "}", "}", "if", "(", "!", "isAlpha", "(", "language", ")", "||", "!", "isAlpha", "(", "country", ")", "||", "!", "isAlpha", "(", "variant", ")", ")", "{", "continue", ";", "}", "Locale", "locale", "=", "new", "Locale", "(", "language", ",", "country", ",", "variant", ")", ";", "Double", "key", "=", "new", "Double", "(", "-", "quality", ")", ";", "ArrayList", "<", "Locale", ">", "values", "=", "locales", ".", "get", "(", "key", ")", ";", "if", "(", "values", "==", "null", ")", "{", "values", "=", "new", "ArrayList", "<", "Locale", ">", "(", ")", ";", "locales", ".", "put", "(", "key", ",", "values", ")", ";", "}", "values", ".", "add", "(", "locale", ")", ";", "}", "for", "(", "ArrayList", "<", "Locale", ">", "list", ":", "locales", ".", "values", "(", ")", ")", "{", "for", "(", "Locale", "locale", ":", "list", ")", "{", "addLocale", "(", "locale", ")", ";", "}", "}", "}"], "idx": 111584, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "407841c426dc52a4c6b8ccd297df6c484a540056", "function_name": "parseLocalesHeader", "body_hash": "9e9c8aafa5c5ca7fe6e6ae52b008874810027bc8"}
{"code": "public QueryTargetPolicy getQueryTargetPolicyInstance() {\n        if (queryTargetPolicyPlugin.get() == null) {\n            queryTargetPolicyPlugin.instantiate(QueryTargetPolicy.class,\n                    this, true);\n        }\n        return (QueryTargetPolicy) queryTargetPolicyPlugin.get();\n    }", "code_tokens": ["public", "QueryTargetPolicy", "getQueryTargetPolicyInstance", "(", ")", "{", "if", "(", "queryTargetPolicyPlugin", ".", "get", "(", ")", "==", "null", ")", "{", "queryTargetPolicyPlugin", ".", "instantiate", "(", "QueryTargetPolicy", ".", "class", ",", "this", ",", "true", ")", ";", "}", "return", "(", "QueryTargetPolicy", ")", "queryTargetPolicyPlugin", ".", "get", "(", ")", ";", "}"], "idx": 33540, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "7f14c7df6b7c7ef42f0671138b9b5dd062fe99aa", "function_name": "getQueryTargetPolicyInstance", "body_hash": "23fe244eb2433cba4786de2656aac16eabbc18a8"}
{"code": "@RequestMapping(\"/oauth/token/revoke/client/{clientId}\")\n    public ResponseEntity<Void> revokeTokensForClient(@PathVariable String clientId) {\n        logger.debug(\"Revoking tokens for client: \" + clientId);\n        String zoneId = IdentityZoneHolder.get().getId();\n        BaseClientDetails client = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId, zoneId);\n        client.addAdditionalInformation(ClientConstants.TOKEN_SALT,generator.generate());\n        clientDetailsService.updateClientDetails(client, zoneId);\n        logger.debug(\"Tokens revoked for client: \" + clientId);\n        ((SystemDeletable)tokenProvisioning).deleteByClient(clientId, zoneId);\n        return new ResponseEntity<>(OK);\n    }", "code_tokens": ["@", "RequestMapping", "(", "\"", "/oauth/token/revoke/client/{clientId}", "\"", ")", "public", "ResponseEntity", "<", "Void", ">", "revokeTokensForClient", "(", "@", "PathVariable", "String", "clientId", ")", "{", "logger", ".", "debug", "(", "\"", "Revoking tokens for client: ", "\"", "+", "clientId", ")", ";", "String", "zoneId", "=", "IdentityZoneHolder", ".", "get", "(", ")", ".", "getId", "(", ")", ";", "BaseClientDetails", "client", "=", "(", "BaseClientDetails", ")", "clientDetailsService", ".", "loadClientByClientId", "(", "clientId", ",", "zoneId", ")", ";", "client", ".", "addAdditionalInformation", "(", "ClientConstants", ".", "TOKEN_SALT", ",", "generator", ".", "generate", "(", ")", ")", ";", "clientDetailsService", ".", "updateClientDetails", "(", "client", ",", "zoneId", ")", ";", "logger", ".", "debug", "(", "\"", "Tokens revoked for client: ", "\"", "+", "clientId", ")", ";", "(", "(", "SystemDeletable", ")", "tokenProvisioning", ")", ".", "deleteByClient", "(", "clientId", ",", "zoneId", ")", ";", "return", "new", "ResponseEntity", "<", ">", "(", "OK", ")", ";", "}"], "idx": 102712, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "20808046de8bbdc6fb2ac62829d4cc9d7a19f37", "function_name": "revokeTokensForClient", "body_hash": "dd17cc3da1c76a06ab61e1feb69b4834a086990f"}
{"code": "private static void maybeInitJmx()\n    {\n        String jmxPort = System.getProperty(\"com.sun.management.jmxremote.port\");\n\n        if (jmxPort == null)\n        {\n            logger.warn(\"JMX is not enabled to receive remote connections. Please see cassandra-env.sh for more info.\");\n\n            jmxPort = System.getProperty(\"cassandra.jmx.local.port\");\n\n            if (jmxPort == null)\n            {\n                logger.error(\"cassandra.jmx.local.port missing from cassandra-env.sh, unable to start local JMX service.\" + jmxPort);\n            }\n            else\n            {\n                System.setProperty(\"java.rmi.server.hostname\", InetAddress.getLoopbackAddress().getHostAddress());\n\n                try\n                {\n                    RMIServerSocketFactory serverFactory = new RMIServerSocketFactoryImpl();\n                    Map<String, Object> env = new HashMap<>();\n                    env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverFactory);\n                    env.put(\"jmx.remote.rmi.server.credential.types\",\n                        new String[] { String[].class.getName(), String.class.getName() });\n                    Registry registry = new JmxRegistry(Integer.valueOf(jmxPort), null, serverFactory, \"jmxrmi\");\n                    JMXServiceURL url = new JMXServiceURL(String.format(\"service:jmx:rmi://localhost/jndi/rmi://localhost:%s/jmxrmi\", jmxPort));\n                    @SuppressWarnings(\"resource\")\n                    RMIJRMPServerImpl server = new RMIJRMPServerImpl(Integer.valueOf(jmxPort),\n                                                                     null,\n                                                                     (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE),\n                                                                     env);\n                    jmxServer = new RMIConnectorServer(url, env, server, ManagementFactory.getPlatformMBeanServer());\n                    jmxServer.start();\n                    ((JmxRegistry)registry).setRemoteServerStub(server.toStub());\n                }\n                catch (IOException e)\n                {\n                    logger.error(\"Error starting local jmx server: \", e);\n                }\n            }\n        }\n        else\n        {\n            logger.info(\"JMX is enabled to receive remote connections on port: \" + jmxPort);\n        }\n    }", "code_tokens": ["private", "static", "void", "maybeInitJmx", "(", ")", "{", "String", "jmxPort", "=", "System", ".", "getProperty", "(", "\"", "com.sun.management.jmxremote.port", "\"", ")", ";", "if", "(", "jmxPort", "==", "null", ")", "{", "logger", ".", "warn", "(", "\"", "JMX is not enabled to receive remote connections. Please see cassandra-env.sh for more info.", "\"", ")", ";", "jmxPort", "=", "System", ".", "getProperty", "(", "\"", "cassandra.jmx.local.port", "\"", ")", ";", "if", "(", "jmxPort", "==", "null", ")", "{", "logger", ".", "error", "(", "\"", "cassandra.jmx.local.port missing from cassandra-env.sh, unable to start local JMX service.", "\"", "+", "jmxPort", ")", ";", "}", "else", "{", "System", ".", "setProperty", "(", "\"", "java.rmi.server.hostname", "\"", ",", "InetAddress", ".", "getLoopbackAddress", "(", ")", ".", "getHostAddress", "(", ")", ")", ";", "try", "{", "RMIServerSocketFactory", "serverFactory", "=", "new", "RMIServerSocketFactoryImpl", "(", ")", ";", "Map", "<", "String", ",", "Object", ">", "env", "=", "new", "HashMap", "<", ">", "(", ")", ";", "env", ".", "put", "(", "RMIConnectorServer", ".", "RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE", ",", "serverFactory", ")", ";", "env", ".", "put", "(", "\"", "jmx.remote.rmi.server.credential.types", "\"", ",", "new", "String", "[", "]", "{", "String", "[", "]", ".", "class", ".", "getName", "(", ")", ",", "String", ".", "class", ".", "getName", "(", ")", "}", ")", ";", "Registry", "registry", "=", "new", "JmxRegistry", "(", "Integer", ".", "valueOf", "(", "jmxPort", ")", ",", "null", ",", "serverFactory", ",", "\"", "jmxrmi", "\"", ")", ";", "JMXServiceURL", "url", "=", "new", "JMXServiceURL", "(", "String", ".", "format", "(", "\"", "service:jmx:rmi://localhost/jndi/rmi://localhost:%s/jmxrmi", "\"", ",", "jmxPort", ")", ")", ";", "@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "RMIJRMPServerImpl", "server", "=", "new", "RMIJRMPServerImpl", "(", "Integer", ".", "valueOf", "(", "jmxPort", ")", ",", "null", ",", "(", "RMIServerSocketFactory", ")", "env", ".", "get", "(", "RMIConnectorServer", ".", "RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE", ")", ",", "env", ")", ";", "jmxServer", "=", "new", "RMIConnectorServer", "(", "url", ",", "env", ",", "server", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "jmxServer", ".", "start", "(", ")", ";", "(", "(", "JmxRegistry", ")", "registry", ")", ".", "setRemoteServerStub", "(", "server", ".", "toStub", "(", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "logger", ".", "error", "(", "\"", "Error starting local jmx server: ", "\"", ",", "e", ")", ";", "}", "}", "}", "else", "{", "logger", ".", "info", "(", "\"", "JMX is enabled to receive remote connections on port: ", "\"", "+", "jmxPort", ")", ";", "}", "}"], "idx": 72441, "cwe": "CWE-668", "target": 0, "status": "FIXED", "commit": "63f4da90c3c51d230c535265786dbc7a33c1ace9", "function_name": "maybeInitJmx", "body_hash": "60ff7ef2cdf7719463555015684557300ad3322d"}
{"code": "public static Response getErrorResponse(Throwable e, Response.Status status) {\n        String message = e.getMessage() == null ? \"Failed with \" + e.getClass().getName() : e.getMessage();\n        Response response = getErrorResponse(message, status);\n        JSONObject responseJson = (JSONObject) response.getEntity();\n        try {\n            responseJson.put(AtlasClient.STACKTRACE, printStackTrace(e));\n        } catch (JSONException e1) {\n            LOG.warn(\"Could not construct error Json rensponse\", e1);\n        }\n        return response;\n    }", "code_tokens": ["public", "static", "Response", "getErrorResponse", "(", "Throwable", "e", ",", "Response", ".", "Status", "status", ")", "{", "String", "message", "=", "e", ".", "getMessage", "(", ")", "==", "null", "?", "\"", "Failed with ", "\"", "+", "e", ".", "getClass", "(", ")", ".", "getName", "(", ")", ":", "e", ".", "getMessage", "(", ")", ";", "Response", "response", "=", "getErrorResponse", "(", "message", ",", "status", ")", ";", "JSONObject", "responseJson", "=", "(", "JSONObject", ")", "response", ".", "getEntity", "(", ")", ";", "try", "{", "responseJson", ".", "put", "(", "AtlasClient", ".", "STACKTRACE", ",", "printStackTrace", "(", "e", ")", ")", ";", "}", "catch", "(", "JSONException", "e1", ")", "{", "LOG", ".", "warn", "(", "\"", "Could not construct error Json rensponse", "\"", ",", "e1", ")", ";", "}", "return", "response", ";", "}"], "idx": 19799, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "0dcfd21bbfaac6f037f46b7aaaab0e5546fd2a7", "function_name": "getErrorResponse", "body_hash": "80bcf8ae523a9138173103b61740dbd236bf5690"}
{"code": "public static void unzipFilesToPath(String jarPath, String destinationDir) throws IOException {\n        File file = new File(jarPath);\n        try (JarFile jar = new JarFile(file)) {\n\n            // fist get all directories,\n            // then make those directory on the destination Path\n            /*for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {\n                JarEntry entry = (JarEntry) enums.nextElement();\n\n                String fileName = destinationDir + File.separator + entry.getName();\n                File f = new File(fileName);\n\n                if (fileName.endsWith(\"/\")) {\n                    f.mkdirs();\n                }\n\n            }*/\n\n            //now create all files\n            for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {\n                JarEntry entry = enums.nextElement();\n\n                String fileName = destinationDir + File.separator + entry.getName();\n                File f = new File(fileName);\n\n                if (!f.getCanonicalPath().startsWith(destinationDir)) {\n                    System.out.println(\"Zip Slip exploit detected. Skipping entry \" + entry.getName());\n                    continue;\n                }\n\n                File parent = f.getParentFile();\n                if (!parent.exists()) {\n                    parent.mkdirs();\n                }\n\n                if (!fileName.endsWith(\"/\")) {\n                    try (InputStream is = jar.getInputStream(entry);\n                         FileOutputStream fos = new FileOutputStream(f)) {\n                        // write contents of 'is' to 'fos'\n                        while (is.available() > 0) {\n                            fos.write(is.read());\n                        }\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["public", "static", "void", "unzipFilesToPath", "(", "String", "jarPath", ",", "String", "destinationDir", ")", "throws", "IOException", "{", "File", "file", "=", "new", "File", "(", "jarPath", ")", ";", "try", "(", "JarFile", "jar", "=", "new", "JarFile", "(", "file", ")", ")", "{", "for", "(", "Enumeration", "<", "JarEntry", ">", "enums", "=", "jar", ".", "entries", "(", ")", ";", "enums", ".", "hasMoreElements", "(", ")", ";", ")", "{", "JarEntry", "entry", "=", "enums", ".", "nextElement", "(", ")", ";", "String", "fileName", "=", "destinationDir", "+", "File", ".", "separator", "+", "entry", ".", "getName", "(", ")", ";", "File", "f", "=", "new", "File", "(", "fileName", ")", ";", "if", "(", "!", "f", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "destinationDir", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "Zip Slip exploit detected. Skipping entry ", "\"", "+", "entry", ".", "getName", "(", ")", ")", ";", "continue", ";", "}", "File", "parent", "=", "f", ".", "getParentFile", "(", ")", ";", "if", "(", "!", "parent", ".", "exists", "(", ")", ")", "{", "parent", ".", "mkdirs", "(", ")", ";", "}", "if", "(", "!", "fileName", ".", "endsWith", "(", "\"", "/", "\"", ")", ")", "{", "try", "(", "InputStream", "is", "=", "jar", ".", "getInputStream", "(", "entry", ")", ";", "FileOutputStream", "fos", "=", "new", "FileOutputStream", "(", "f", ")", ")", "{", "while", "(", "is", ".", "available", "(", ")", ">", "0", ")", "{", "fos", ".", "write", "(", "is", ".", "read", "(", ")", ")", ";", "}", "}", "}", "}", "}", "}"], "idx": 27024, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "1ec02658fe6858162f5e6a24f97928de6696c5cb", "function_name": "unzipFilesToPath", "body_hash": "1e8ed1b8d581c524437e8be65ba943c6aadfccbb"}
{"code": "@Override\n   public boolean apply(Run<?, ?> run) {\n      boolean retVal = false;\n      M2ReleaseBadgeAction a = run.getAction(M2ReleaseBadgeAction.class);\n      if (a != null) {\n          if (!run.isBuilding()) {\n              if (!a.isDryRun() && run.getResult() == Result.SUCCESS) {\n                  retVal = true;\n              }\n          }\n      }\n      return retVal;\n    }", "code_tokens": ["@", "Override", "public", "boolean", "apply", "(", "Run", "<", "?", ",", "?", ">", "run", ")", "{", "boolean", "retVal", "=", "false", ";", "M2ReleaseBadgeAction", "a", "=", "run", ".", "getAction", "(", "M2ReleaseBadgeAction", ".", "class", ")", ";", "if", "(", "a", "!=", "null", ")", "{", "if", "(", "!", "run", ".", "isBuilding", "(", ")", ")", "{", "if", "(", "!", "a", ".", "isDryRun", "(", ")", "&&", "run", ".", "getResult", "(", ")", "==", "Result", ".", "SUCCESS", ")", "{", "retVal", "=", "true", ";", "}", "}", "}", "return", "retVal", ";", "}"], "idx": 69920, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "c6a6116", "function_name": "apply", "body_hash": "6ad305973131f268cc1df8e5ce910db32ce8b2aa"}
{"code": "public byte[] toXML() throws TransformerException {\n        removeEmptyNodes(doc);\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        try {\n            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        } catch (Exception exc) {}\n        Transformer transformer = transformerFactory.newTransformer();\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n\t    DOMSource source = new DOMSource(doc);\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        Result result = new StreamResult(out);\n        transformer.transform(source, result);\n        return out.toByteArray();\n    }", "code_tokens": ["public", "byte", "[", "]", "toXML", "(", ")", "throws", "TransformerException", "{", "removeEmptyNodes", "(", "doc", ")", ";", "TransformerFactory", "transformerFactory", "=", "TransformerFactory", ".", "newInstance", "(", ")", ";", "try", "{", "transformerFactory", ".", "setFeature", "(", "XMLConstants", ".", "FEATURE_SECURE_PROCESSING", ",", "true", ")", ";", "}", "catch", "(", "Exception", "exc", ")", "{", "}", "Transformer", "transformer", "=", "transformerFactory", ".", "newTransformer", "(", ")", ";", "transformer", ".", "setOutputProperty", "(", "OutputKeys", ".", "METHOD", ",", "\"", "xml", "\"", ")", ";", "transformer", ".", "setOutputProperty", "(", "OutputKeys", ".", "INDENT", ",", "\"", "yes", "\"", ")", ";", "transformer", ".", "setOutputProperty", "(", "\"", "{http://xml.apache.org/xslt}indent-amount", "\"", ",", "\"", "4", "\"", ")", ";", "DOMSource", "source", "=", "new", "DOMSource", "(", "doc", ")", ";", "ByteArrayOutputStream", "out", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "Result", "result", "=", "new", "StreamResult", "(", "out", ")", ";", "transformer", ".", "transform", "(", "source", ",", "result", ")", ";", "return", "out", ".", "toByteArray", "(", ")", ";", "}"], "idx": 52002, "cwe": "CWE-399", "target": 0, "status": "FIXED", "commit": "ad38371c396ac5ffbfb28056809e8ffaa5a18ccd", "function_name": "toXML", "body_hash": "970e49099d61ceddd8ac61866a81cb1438dfe4aa"}
{"code": "public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(?:https?|ftp):\\\\/\\\\/\" +\n                    \"(?:(?:[a-z0-9$_.+!*'(),;?&=\\\\-]|%[0-9a-f]{2})+\" +\n                    \"(?::(?:[a-z0-9$_.+!*'(),;?&=\\\\-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?#?\" +\n                    \"(?:(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|(?:(?:[1-9]?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\\\\.){3}\" +\n                    \"(?:[1-9]?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\" +\n                    \")(?::\\\\d+)?\" +\n                    \")(?:(?:\\\\/(?:[a-z0-9$_.+!*'(),;:@&=\\\\-]|%[0-9a-f]{2})*)*\" +\n                    \"(?:\\\\?(?:[a-z0-9$_.+!*'(),;:@&=\\\\-\\\\/:]|%[0-9a-f]{2})*)?)?\" +\n                    \"(?:#(?:[a-z0-9$_.+!*'(),;:@&=\\\\-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }", "code_tokens": ["public", "String", "getUrlRegex", "(", ")", "{", "if", "(", "StringUtils", ".", "isNotEmpty", "(", "urlRegexExpression", ")", ")", "{", "return", "(", "String", ")", "parse", "(", "urlRegexExpression", ",", "String", ".", "class", ")", ";", "}", "else", "if", "(", "StringUtils", ".", "isNotEmpty", "(", "urlRegex", ")", ")", "{", "return", "urlRegex", ";", "}", "else", "{", "return", "\"", "^(?:https?|ftp):", "\\\\", "/", "\\\\", "/", "\"", "+", "\"", "(?:(?:[a-z0-9$_.+!*'(),;?&=", "\\\\", "-]|%[0-9a-f]{2})+", "\"", "+", "\"", "(?::(?:[a-z0-9$_.+!*'(),;?&=", "\\\\", "-]|%[0-9a-f]{2})+)?", "\"", "+", "\"", "@)?#?", "\"", "+", "\"", "(?:(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?", "\\\\", ".)*", "\"", "+", "\"", "[a-z][a-z0-9-]*[a-z0-9]", "\"", "+", "\"", "|(?:(?:[1-9]?", "\\\\", "d|1", "\\\\", "d{2}|2[0-4]", "\\\\", "d|25[0-5])", "\\\\", ".){3}", "\"", "+", "\"", "(?:[1-9]?", "\\\\", "d|1", "\\\\", "d{2}|2[0-4]", "\\\\", "d|25[0-5])", "\"", "+", "\"", ")(?::", "\\\\", "d+)?", "\"", "+", "\"", ")(?:(?:", "\\\\", "/(?:[a-z0-9$_.+!*'(),;:@&=", "\\\\", "-]|%[0-9a-f]{2})*)*", "\"", "+", "\"", "(?:", "\\\\", "?(?:[a-z0-9$_.+!*'(),;:@&=", "\\\\", "-", "\\\\", "/:]|%[0-9a-f]{2})*)?)?", "\"", "+", "\"", "(?:#(?:[a-z0-9$_.+!*'(),;:@&=", "\\\\", "-]|%[0-9a-f]{2})*)?", "\"", "+", "\"", "$", "\"", ";", "}", "}"], "idx": 12211, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "3fddfb6eb562d597c935084e9e81d43ed6bcd02", "function_name": "getUrlRegex", "body_hash": "d1273ca8fbe098bef08358c7b3b03106b1fdcacd"}
{"code": "@Exported(inline=true)\n    public synchronized Item[] getItems() {\n        List<Item> r = new ArrayList<Item>();\n\n        for(WaitingItem p : waitingList) {\n            r = filterItemListBasedOnPermissions(r, p);\n        }\n        for (BlockedItem p : blockedProjects.values()){\n            r = filterItemListBasedOnPermissions(r, p);\n        }\n        for (BuildableItem p : reverse(buildables.values())) {\n            r = filterItemListBasedOnPermissions(r, p);\n        }\n        for (BuildableItem p : reverse(pendings.values())) {\n            r= filterItemListBasedOnPermissions(r, p);\n        }\n        Item[] items = new Item[r.size()];\n        r.toArray(items);\n        return items;\n    }", "code_tokens": ["@", "Exported", "(", "inline", "=", "true", ")", "public", "synchronized", "Item", "[", "]", "getItems", "(", ")", "{", "List", "<", "Item", ">", "r", "=", "new", "ArrayList", "<", "Item", ">", "(", ")", ";", "for", "(", "WaitingItem", "p", ":", "waitingList", ")", "{", "r", "=", "filterItemListBasedOnPermissions", "(", "r", ",", "p", ")", ";", "}", "for", "(", "BlockedItem", "p", ":", "blockedProjects", ".", "values", "(", ")", ")", "{", "r", "=", "filterItemListBasedOnPermissions", "(", "r", ",", "p", ")", ";", "}", "for", "(", "BuildableItem", "p", ":", "reverse", "(", "buildables", ".", "values", "(", ")", ")", ")", "{", "r", "=", "filterItemListBasedOnPermissions", "(", "r", ",", "p", ")", ";", "}", "for", "(", "BuildableItem", "p", ":", "reverse", "(", "pendings", ".", "values", "(", ")", ")", ")", "{", "r", "=", "filterItemListBasedOnPermissions", "(", "r", ",", "p", ")", ";", "}", "Item", "[", "]", "items", "=", "new", "Item", "[", "r", ".", "size", "(", ")", "]", ";", "r", ".", "toArray", "(", "items", ")", ";", "return", "items", ";", "}"], "idx": 30556, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "581eb9ceb354b8a55c010d0547ff73cb6fd67a75", "function_name": "getItems", "body_hash": "a0284ed15fab5a66d424c5f8ceececcfb1f22dad"}
{"code": "@RequirePOST\n    public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(CONNECT);\n            \n        if(channel!=null) {\n            req.getView(this,\"already-launched.jelly\").forward(req, rsp);\n            return;\n        }\n\n        connect(true);\n\n        // TODO: would be nice to redirect the user to \"launching...\" wait page,\n        // then spend a few seconds there and poll for the completion periodically.\n        rsp.sendRedirect(\"log\");\n    }", "code_tokens": ["@", "RequirePOST", "public", "void", "doLaunchSlaveAgent", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "checkPermission", "(", "CONNECT", ")", ";", "if", "(", "channel", "!=", "null", ")", "{", "req", ".", "getView", "(", "this", ",", "\"", "already-launched.jelly", "\"", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "return", ";", "}", "connect", "(", "true", ")", ";", "rsp", ".", "sendRedirect", "(", "\"", "log", "\"", ")", ";", "}"], "idx": 86452, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "40250f08aca7f3f8816f21870ee23463a52ef2f2", "function_name": "doLaunchSlaveAgent", "body_hash": "f9bcee32a73192f00e4b78f40e8087e6179f3fb1"}
{"code": "private void postWorkDirectory() {\n\n        // Acquire (or calculate) the work directory path\n        String workDir = getWorkDir();\n        if (workDir == null || workDir.length() == 0) {\n\n            // Retrieve our parent (normally a host) name\n            String hostName = null;\n            String engineName = null;\n            String hostWorkDir = null;\n            Container parentHost = getParent();\n            if (parentHost != null) {\n                hostName = parentHost.getName();\n                if (parentHost instanceof StandardHost) {\n                    hostWorkDir = ((StandardHost)parentHost).getWorkDir();\n                }\n                Container parentEngine = parentHost.getParent();\n                if (parentEngine != null) {\n                   engineName = parentEngine.getName();\n                }\n            }\n            if ((hostName == null) || (hostName.length() < 1))\n                hostName = \"_\";\n            if ((engineName == null) || (engineName.length() < 1))\n                engineName = \"_\";\n\n            String temp = getPath();\n            if (temp.startsWith(\"/\"))\n                temp = temp.substring(1);\n            temp = temp.replace('/', '_');\n            temp = temp.replace('\\\\', '_');\n            if (temp.length() < 1)\n                temp = \"_\";\n            if (hostWorkDir != null ) {\n                workDir = hostWorkDir + File.separator + temp;\n            } else {\n                workDir = \"work\" + File.separator + engineName +\n                    File.separator + hostName + File.separator + temp;\n            }\n            setWorkDir(workDir);\n        }\n\n        // Create this directory if necessary\n        File dir = new File(workDir);\n        if (!dir.isAbsolute()) {\n            File catalinaHome = engineBase();\n            String catalinaHomePath = null;\n            try {\n                catalinaHomePath = catalinaHome.getCanonicalPath();\n                dir = new File(catalinaHomePath, workDir);\n            } catch (IOException e) {\n            }\n        }\n        dir.mkdirs();\n\n        // Set the appropriate servlet context attribute\n        getServletContext().setAttribute(ServletContext.TEMPDIR, dir);\n        if (getServletContext() instanceof ApplicationContext)\n            ((ApplicationContext) getServletContext()).setAttributeReadOnly\n                (ServletContext.TEMPDIR);\n\n    }", "code_tokens": ["private", "void", "postWorkDirectory", "(", ")", "{", "String", "workDir", "=", "getWorkDir", "(", ")", ";", "if", "(", "workDir", "==", "null", "||", "workDir", ".", "length", "(", ")", "==", "0", ")", "{", "String", "hostName", "=", "null", ";", "String", "engineName", "=", "null", ";", "String", "hostWorkDir", "=", "null", ";", "Container", "parentHost", "=", "getParent", "(", ")", ";", "if", "(", "parentHost", "!=", "null", ")", "{", "hostName", "=", "parentHost", ".", "getName", "(", ")", ";", "if", "(", "parentHost", "instanceof", "StandardHost", ")", "{", "hostWorkDir", "=", "(", "(", "StandardHost", ")", "parentHost", ")", ".", "getWorkDir", "(", ")", ";", "}", "Container", "parentEngine", "=", "parentHost", ".", "getParent", "(", ")", ";", "if", "(", "parentEngine", "!=", "null", ")", "{", "engineName", "=", "parentEngine", ".", "getName", "(", ")", ";", "}", "}", "if", "(", "(", "hostName", "==", "null", ")", "||", "(", "hostName", ".", "length", "(", ")", "<", "1", ")", ")", "hostName", "=", "\"", "_", "\"", ";", "if", "(", "(", "engineName", "==", "null", ")", "||", "(", "engineName", ".", "length", "(", ")", "<", "1", ")", ")", "engineName", "=", "\"", "_", "\"", ";", "String", "temp", "=", "getPath", "(", ")", ";", "if", "(", "temp", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "temp", "=", "temp", ".", "substring", "(", "1", ")", ";", "temp", "=", "temp", ".", "replace", "(", "'/'", ",", "'_'", ")", ";", "temp", "=", "temp", ".", "replace", "(", "'\\\\'", ",", "'_'", ")", ";", "if", "(", "temp", ".", "length", "(", ")", "<", "1", ")", "temp", "=", "\"", "_", "\"", ";", "if", "(", "hostWorkDir", "!=", "null", ")", "{", "workDir", "=", "hostWorkDir", "+", "File", ".", "separator", "+", "temp", ";", "}", "else", "{", "workDir", "=", "\"", "work", "\"", "+", "File", ".", "separator", "+", "engineName", "+", "File", ".", "separator", "+", "hostName", "+", "File", ".", "separator", "+", "temp", ";", "}", "setWorkDir", "(", "workDir", ")", ";", "}", "File", "dir", "=", "new", "File", "(", "workDir", ")", ";", "if", "(", "!", "dir", ".", "isAbsolute", "(", ")", ")", "{", "File", "catalinaHome", "=", "engineBase", "(", ")", ";", "String", "catalinaHomePath", "=", "null", ";", "try", "{", "catalinaHomePath", "=", "catalinaHome", ".", "getCanonicalPath", "(", ")", ";", "dir", "=", "new", "File", "(", "catalinaHomePath", ",", "workDir", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "}", "dir", ".", "mkdirs", "(", ")", ";", "getServletContext", "(", ")", ".", "setAttribute", "(", "ServletContext", ".", "TEMPDIR", ",", "dir", ")", ";", "if", "(", "getServletContext", "(", ")", "instanceof", "ApplicationContext", ")", "(", "(", "ApplicationContext", ")", "getServletContext", "(", ")", ")", ".", "setAttributeReadOnly", "(", "ServletContext", ".", "TEMPDIR", ")", ";", "}"], "idx": 113205, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "a697f7b52c4e3aea0c6763b33d413b54a518e883", "function_name": "postWorkDirectory", "body_hash": "881c52eda7766d71ecdd718787cc4a9e3e0ad2fc"}
{"code": "private void verifySavedState(HttpServletRequest request) {\n        HttpSession session = request.getSession(false);\n\n        if (session == null) {\n            logger.warn(\"The received state does not match the state saved in the context\");\n            throw new BadCredentialsException(\"The received state does not match the state saved in the context\");\n        }\n\n        String savedContext = (String)session.getAttribute(FederationAuthenticationEntryPoint.SAVED_CONTEXT);\n        String state = getState(request);\n        if (savedContext == null || !savedContext.equals(state)) {\n            logger.warn(\"The received state does not match the state saved in the context\");\n            throw new BadCredentialsException(\"The received state does not match the state saved in the context\");\n        }\n        session.removeAttribute(FederationAuthenticationEntryPoint.SAVED_CONTEXT);\n    }", "code_tokens": ["private", "void", "verifySavedState", "(", "HttpServletRequest", "request", ")", "{", "HttpSession", "session", "=", "request", ".", "getSession", "(", "false", ")", ";", "if", "(", "session", "==", "null", ")", "{", "logger", ".", "warn", "(", "\"", "The received state does not match the state saved in the context", "\"", ")", ";", "throw", "new", "BadCredentialsException", "(", "\"", "The received state does not match the state saved in the context", "\"", ")", ";", "}", "String", "savedContext", "=", "(", "String", ")", "session", ".", "getAttribute", "(", "FederationAuthenticationEntryPoint", ".", "SAVED_CONTEXT", ")", ";", "String", "state", "=", "getState", "(", "request", ")", ";", "if", "(", "savedContext", "==", "null", "||", "!", "savedContext", ".", "equals", "(", "state", ")", ")", "{", "logger", ".", "warn", "(", "\"", "The received state does not match the state saved in the context", "\"", ")", ";", "throw", "new", "BadCredentialsException", "(", "\"", "The received state does not match the state saved in the context", "\"", ")", ";", "}", "session", ".", "removeAttribute", "(", "FederationAuthenticationEntryPoint", ".", "SAVED_CONTEXT", ")", ";", "}"], "idx": 45090, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "48dd9b68d67c6b729376c1ce8886f52a57df6c4", "function_name": "verifySavedState", "body_hash": "bae82b9379b25f6040b07789af2e8e2beb85478b"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (this.converters != null) {\n            setProperty(camelContext, dataFormat, \"converters\", this.converters);\n        }\n        if (this.aliases != null) {\n            setProperty(camelContext, dataFormat, \"aliases\", this.aliases);\n        }\n        if (this.omitFields != null) {\n            setProperty(camelContext, dataFormat, \"omitFields\", this.omitFields);\n        }\n        if (this.implicitCollections != null) {\n            setProperty(camelContext, dataFormat, \"implicitCollections\", this.implicitCollections);\n        }\n        if (this.permissions != null) {\n            setProperty(camelContext, dataFormat, \"permissions\", this.permissions);\n        }\n        if (this.mode != null) {\n            setProperty(camelContext, dataFormat, \"mode\", mode);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "encoding", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "encoding", "\"", ",", "encoding", ")", ";", "}", "if", "(", "this", ".", "converters", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "converters", "\"", ",", "this", ".", "converters", ")", ";", "}", "if", "(", "this", ".", "aliases", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "aliases", "\"", ",", "this", ".", "aliases", ")", ";", "}", "if", "(", "this", ".", "omitFields", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "omitFields", "\"", ",", "this", ".", "omitFields", ")", ";", "}", "if", "(", "this", ".", "implicitCollections", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "implicitCollections", "\"", ",", "this", ".", "implicitCollections", ")", ";", "}", "if", "(", "this", ".", "permissions", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "permissions", "\"", ",", "this", ".", "permissions", ")", ";", "}", "if", "(", "this", ".", "mode", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "mode", "\"", ",", "mode", ")", ";", "}", "}"], "idx": 3122, "cwe": "CWE-19", "target": 0, "status": "FIXED", "commit": "4491c080cb6c8659fc05441e49307b7d4349aa56", "function_name": "configureDataFormat", "body_hash": "fa798ee95b88bea315a746332391fde2d96949b5"}
{"code": "public @CheckForNull User getUser(String name) {\n        return User.get(name, User.ALLOW_USER_CREATION_VIA_URL && hasPermission(ADMINISTER));\n    }", "code_tokens": ["public", "@", "CheckForNull", "User", "getUser", "(", "String", "name", ")", "{", "return", "User", ".", "get", "(", "name", ",", "User", ".", "ALLOW_USER_CREATION_VIA_URL", "&&", "hasPermission", "(", "ADMINISTER", ")", ")", ";", "}"], "idx": 44645, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "b88b20ec473200db35d0a0d29dcf192069106601", "function_name": "getUser", "body_hash": "3d60338aa61e1e02387e46ac153d10a7c14704f6"}
{"code": "public static String[] validateObject(ParaObject content) {\n\t\tif (content == null) {\n\t\t\treturn new String[]{\"Object cannot be null.\"};\n\t\t}\n\t\tLinkedList<String> list = new LinkedList<>();\n\t\ttry {\n\t\t\tfor (ConstraintViolation<ParaObject> constraintViolation : getValidator().validate(content)) {\n\t\t\t\tString prop = \"'\".concat(constraintViolation.getPropertyPath().toString()).concat(\"'\");\n\t\t\t\tlist.add(prop.concat(\" \").concat(constraintViolation.getMessage()));\n\t\t\t}\n\t\t\tif (content instanceof User && StringUtils.length(((User) content).getPassword()) > User.MAX_PASSWORD_LENGTH) {\n\t\t\t\tlist.add(Utils.formatMessage(\"{0} must not be longer than {1}.\", Config._PASSWORD, User.MAX_PASSWORD_LENGTH));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(null, e);\n\t\t}\n\t\treturn list.toArray(new String[]{});\n\t}", "code_tokens": ["public", "static", "String", "[", "]", "validateObject", "(", "ParaObject", "content", ")", "{", "if", "(", "content", "==", "null", ")", "{", "return", "new", "String", "[", "]", "{", "\"", "Object cannot be null.", "\"", "}", ";", "}", "LinkedList", "<", "String", ">", "list", "=", "new", "LinkedList", "<", ">", "(", ")", ";", "try", "{", "for", "(", "ConstraintViolation", "<", "ParaObject", ">", "constraintViolation", ":", "getValidator", "(", ")", ".", "validate", "(", "content", ")", ")", "{", "String", "prop", "=", "\"", "'", "\"", ".", "concat", "(", "constraintViolation", ".", "getPropertyPath", "(", ")", ".", "toString", "(", ")", ")", ".", "concat", "(", "\"", "'", "\"", ")", ";", "list", ".", "add", "(", "prop", ".", "concat", "(", "\"", " ", "\"", ")", ".", "concat", "(", "constraintViolation", ".", "getMessage", "(", ")", ")", ")", ";", "}", "if", "(", "content", "instanceof", "User", "&&", "StringUtils", ".", "length", "(", "(", "(", "User", ")", "content", ")", ".", "getPassword", "(", ")", ")", ">", "User", ".", "MAX_PASSWORD_LENGTH", ")", "{", "list", ".", "add", "(", "Utils", ".", "formatMessage", "(", "\"", "{0} must not be longer than {1}.", "\"", ",", "Config", ".", "_PASSWORD", ",", "User", ".", "MAX_PASSWORD_LENGTH", ")", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "logger", ".", "error", "(", "null", ",", "e", ")", ";", "}", "return", "list", ".", "toArray", "(", "new", "String", "[", "]", "{", "}", ")", ";", "}"], "idx": 102374, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "fa677c629842df60099daa9c23bd802bc41b48d1", "function_name": "validateObject", "body_hash": "e69cea29e764e68e4a4eac2418ebe2fc433c69da"}
{"code": "private void processParameters(byte bytes[], int start, int len,\n                                  Charset charset) {\n        \n        if(log.isDebugEnabled()) {\n            try {\n                log.debug(sm.getString(\"parameters.bytes\",\n                        new String(bytes, start, len, DEFAULT_CHARSET.name())));\n            } catch (UnsupportedEncodingException uee) {\n                // Not possible. All JVMs must support ISO-8859-1\n            }\n        }\n\n        int decodeFailCount = 0;\n            \n        int pos = start;\n        int end = start + len;\n\n        while(pos < end) {\n            parameterCount ++;\n\n            if (limit > -1 && parameterCount >= limit) {\n                parseFailed = true;\n                log.warn(sm.getString(\"parameters.maxCountFail\",\n                        Integer.toString(limit)));\n                break;\n            }\n            int nameStart = pos;\n            int nameEnd = -1;\n            int valueStart = -1;\n            int valueEnd = -1;\n\n            boolean parsingName = true;\n            boolean decodeName = false;\n            boolean decodeValue = false;\n            boolean parameterComplete = false;\n\n            do {\n                switch(bytes[pos]) {\n                    case '=':\n                        if (parsingName) {\n                            // Name finished. Value starts from next character\n                            nameEnd = pos;\n                            parsingName = false;\n                            valueStart = ++pos;\n                        } else {\n                            // Equals character in value\n                            pos++;\n                        }\n                        break;\n                    case '&':\n                        if (parsingName) {\n                            // Name finished. No value.\n                            nameEnd = pos;\n                        } else {\n                            // Value finished\n                            valueEnd  = pos;\n                        }\n                        parameterComplete = true;\n                        pos++;\n                        break;\n                    case '%':\n                    case '+':\n                        // Decoding required\n                        if (parsingName) {\n                            decodeName = true;\n                        } else {\n                            decodeValue = true;\n                        }\n                        pos ++;\n                        break;\n                    default:\n                        pos ++;\n                        break;\n                }\n            } while (!parameterComplete && pos < end);\n\n            if (pos == end) {\n                if (nameEnd == -1) {\n                    nameEnd = pos;\n                } else if (valueStart > -1 && valueEnd == -1){\n                    valueEnd = pos;\n                }\n            }\n            \n            if (log.isDebugEnabled() && valueStart == -1) {\n                try {\n                    log.debug(sm.getString(\"parameters.noequal\",\n                            Integer.toString(nameStart),\n                            Integer.toString(nameEnd),\n                            new String(bytes, nameStart, nameEnd-nameStart,\n                                    DEFAULT_CHARSET.name())));\n                } catch (UnsupportedEncodingException uee) {\n                    // Not possible. All JVMs must support ISO-8859-1\n                }\n            }\n            \n            if (nameEnd <= nameStart ) {\n                if (log.isInfoEnabled()) {\n                    if (valueEnd >= nameStart && log.isDebugEnabled()) {\n                        String extract = null;\n                        try {\n                            extract = new String(bytes, nameStart,\n                                    valueEnd - nameStart,\n                                    DEFAULT_CHARSET.name());\n                        } catch (UnsupportedEncodingException uee) {\n                            // Not possible. All JVMs must support ISO-8859-1\n                        }\n                        log.info(sm.getString(\"parameters.invalidChunk\",\n                                Integer.toString(nameStart),\n                                Integer.toString(valueEnd),\n                                extract));\n                    } else {\n                        log.info(sm.getString(\"parameters.invalidChunk\",\n                                Integer.toString(nameStart),\n                                Integer.toString(nameEnd),\n                                null));\n                    }\n                }\n                parseFailed = true;\n                continue;\n                // invalid chunk - it's better to ignore\n            }\n            \n            tmpName.setBytes(bytes, nameStart, nameEnd - nameStart);\n            tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart);\n\n            // Take copies as if anything goes wrong originals will be\n            // corrupted. This means original values can be logged.\n            // For performance - only done for debug\n            if (log.isDebugEnabled()) {\n                try {\n                    origName.append(bytes, nameStart, nameEnd - nameStart);\n                    origValue.append(bytes, valueStart, valueEnd - valueStart);\n                } catch (IOException ioe) {\n                    // Should never happen...\n                    log.error(sm.getString(\"paramerers.copyFail\"), ioe);\n                }\n            }\n            \n            try {\n                String name;\n                String value;\n\n                if (decodeName) {\n                    urlDecode(tmpName);\n                }\n                tmpName.setCharset(charset);\n                name = tmpName.toString();\n\n                if (decodeValue) {\n                    urlDecode(tmpValue);\n                }\n                tmpValue.setCharset(charset);\n                value = tmpValue.toString();\n\n                addParam(name, value);\n            } catch (IOException e) {\n                parseFailed = true;\n                decodeFailCount++;\n                if (decodeFailCount == 1 || log.isDebugEnabled()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"parameters.decodeFail.debug\",\n                                origName.toString(), origValue.toString()), e);\n                    } else if (log.isInfoEnabled()) {\n                        log.info(sm.getString(\"parameters.decodeFail.info\",\n                                tmpName.toString(), tmpValue.toString()), e);\n                    }\n                }\n            }\n\n            tmpName.recycle();\n            tmpValue.recycle();\n            // Only recycle copies if we used them\n            if (log.isDebugEnabled()) {\n                origName.recycle();\n                origValue.recycle();\n            }\n        }\n\n        if (decodeFailCount > 1 && !log.isDebugEnabled()) {\n            log.info(sm.getString(\"parameters.multipleDecodingFail\",\n                    Integer.toString(decodeFailCount)));\n        }\n    }", "code_tokens": ["private", "void", "processParameters", "(", "byte", "bytes", "[", "]", ",", "int", "start", ",", "int", "len", ",", "Charset", "charset", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "try", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "parameters.bytes", "\"", ",", "new", "String", "(", "bytes", ",", "start", ",", "len", ",", "DEFAULT_CHARSET", ".", "name", "(", ")", ")", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "uee", ")", "{", "}", "}", "int", "decodeFailCount", "=", "0", ";", "int", "pos", "=", "start", ";", "int", "end", "=", "start", "+", "len", ";", "while", "(", "pos", "<", "end", ")", "{", "parameterCount", "++", ";", "if", "(", "limit", ">", "-", "1", "&&", "parameterCount", ">=", "limit", ")", "{", "parseFailed", "=", "true", ";", "log", ".", "warn", "(", "sm", ".", "getString", "(", "\"", "parameters.maxCountFail", "\"", ",", "Integer", ".", "toString", "(", "limit", ")", ")", ")", ";", "break", ";", "}", "int", "nameStart", "=", "pos", ";", "int", "nameEnd", "=", "-", "1", ";", "int", "valueStart", "=", "-", "1", ";", "int", "valueEnd", "=", "-", "1", ";", "boolean", "parsingName", "=", "true", ";", "boolean", "decodeName", "=", "false", ";", "boolean", "decodeValue", "=", "false", ";", "boolean", "parameterComplete", "=", "false", ";", "do", "{", "switch", "(", "bytes", "[", "pos", "]", ")", "{", "case", "'='", ":", "if", "(", "parsingName", ")", "{", "nameEnd", "=", "pos", ";", "parsingName", "=", "false", ";", "valueStart", "=", "++", "pos", ";", "}", "else", "{", "pos", "++", ";", "}", "break", ";", "case", "'&'", ":", "if", "(", "parsingName", ")", "{", "nameEnd", "=", "pos", ";", "}", "else", "{", "valueEnd", "=", "pos", ";", "}", "parameterComplete", "=", "true", ";", "pos", "++", ";", "break", ";", "case", "'%'", ":", "case", "'+'", ":", "if", "(", "parsingName", ")", "{", "decodeName", "=", "true", ";", "}", "else", "{", "decodeValue", "=", "true", ";", "}", "pos", "++", ";", "break", ";", "default", ":", "pos", "++", ";", "break", ";", "}", "}", "while", "(", "!", "parameterComplete", "&&", "pos", "<", "end", ")", ";", "if", "(", "pos", "==", "end", ")", "{", "if", "(", "nameEnd", "==", "-", "1", ")", "{", "nameEnd", "=", "pos", ";", "}", "else", "if", "(", "valueStart", ">", "-", "1", "&&", "valueEnd", "==", "-", "1", ")", "{", "valueEnd", "=", "pos", ";", "}", "}", "if", "(", "log", ".", "isDebugEnabled", "(", ")", "&&", "valueStart", "==", "-", "1", ")", "{", "try", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "parameters.noequal", "\"", ",", "Integer", ".", "toString", "(", "nameStart", ")", ",", "Integer", ".", "toString", "(", "nameEnd", ")", ",", "new", "String", "(", "bytes", ",", "nameStart", ",", "nameEnd", "-", "nameStart", ",", "DEFAULT_CHARSET", ".", "name", "(", ")", ")", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "uee", ")", "{", "}", "}", "if", "(", "nameEnd", "<=", "nameStart", ")", "{", "if", "(", "log", ".", "isInfoEnabled", "(", ")", ")", "{", "if", "(", "valueEnd", ">=", "nameStart", "&&", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "String", "extract", "=", "null", ";", "try", "{", "extract", "=", "new", "String", "(", "bytes", ",", "nameStart", ",", "valueEnd", "-", "nameStart", ",", "DEFAULT_CHARSET", ".", "name", "(", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "uee", ")", "{", "}", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "parameters.invalidChunk", "\"", ",", "Integer", ".", "toString", "(", "nameStart", ")", ",", "Integer", ".", "toString", "(", "valueEnd", ")", ",", "extract", ")", ")", ";", "}", "else", "{", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "parameters.invalidChunk", "\"", ",", "Integer", ".", "toString", "(", "nameStart", ")", ",", "Integer", ".", "toString", "(", "nameEnd", ")", ",", "null", ")", ")", ";", "}", "}", "parseFailed", "=", "true", ";", "continue", ";", "}", "tmpName", ".", "setBytes", "(", "bytes", ",", "nameStart", ",", "nameEnd", "-", "nameStart", ")", ";", "tmpValue", ".", "setBytes", "(", "bytes", ",", "valueStart", ",", "valueEnd", "-", "valueStart", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "try", "{", "origName", ".", "append", "(", "bytes", ",", "nameStart", ",", "nameEnd", "-", "nameStart", ")", ";", "origValue", ".", "append", "(", "bytes", ",", "valueStart", ",", "valueEnd", "-", "valueStart", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "paramerers.copyFail", "\"", ")", ",", "ioe", ")", ";", "}", "}", "try", "{", "String", "name", ";", "String", "value", ";", "if", "(", "decodeName", ")", "{", "urlDecode", "(", "tmpName", ")", ";", "}", "tmpName", ".", "setCharset", "(", "charset", ")", ";", "name", "=", "tmpName", ".", "toString", "(", ")", ";", "if", "(", "decodeValue", ")", "{", "urlDecode", "(", "tmpValue", ")", ";", "}", "tmpValue", ".", "setCharset", "(", "charset", ")", ";", "value", "=", "tmpValue", ".", "toString", "(", ")", ";", "addParam", "(", "name", ",", "value", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "parseFailed", "=", "true", ";", "decodeFailCount", "++", ";", "if", "(", "decodeFailCount", "==", "1", "||", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "parameters.decodeFail.debug", "\"", ",", "origName", ".", "toString", "(", ")", ",", "origValue", ".", "toString", "(", ")", ")", ",", "e", ")", ";", "}", "else", "if", "(", "log", ".", "isInfoEnabled", "(", ")", ")", "{", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "parameters.decodeFail.info", "\"", ",", "tmpName", ".", "toString", "(", ")", ",", "tmpValue", ".", "toString", "(", ")", ")", ",", "e", ")", ";", "}", "}", "}", "tmpName", ".", "recycle", "(", ")", ";", "tmpValue", ".", "recycle", "(", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "origName", ".", "recycle", "(", ")", ";", "origValue", ".", "recycle", "(", ")", ";", "}", "}", "if", "(", "decodeFailCount", ">", "1", "&&", "!", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "parameters.multipleDecodingFail", "\"", ",", "Integer", ".", "toString", "(", "decodeFailCount", ")", ")", ")", ";", "}", "}"], "idx": 2865, "cwe": "CWE-189", "target": 1, "status": "VULNERABLE", "commit": "7a1cfb6bd2f849806e7c060dda8648409ad8714e", "function_name": "processParameters", "body_hash": "59c7102527888e67c203eda99ddb162e8cab6a3d"}
{"code": "@Override\n      public Object getGroup(Object instance) {\n         Object object;\n         if (System.getSecurityManager() == null) {\n            return invokeAccessibly(instance, method, Util.EMPTY_OBJECT_ARRAY);\n         } else {\n            return AccessController.doPrivileged((PrivilegedAction<Object>) () -> invokeAccessibly(instance, method, Util.EMPTY_OBJECT_ARRAY));\n         }\n      }", "code_tokens": ["@", "Override", "public", "Object", "getGroup", "(", "Object", "instance", ")", "{", "Object", "object", ";", "if", "(", "System", ".", "getSecurityManager", "(", ")", "==", "null", ")", "{", "return", "invokeAccessibly", "(", "instance", ",", "method", ",", "Util", ".", "EMPTY_OBJECT_ARRAY", ")", ";", "}", "else", "{", "return", "AccessController", ".", "doPrivileged", "(", "(", "PrivilegedAction", "<", "Object", ">", ")", "(", ")", "->", "invokeAccessibly", "(", "instance", ",", "method", ",", "Util", ".", "EMPTY_OBJECT_ARRAY", ")", ")", ";", "}", "}"], "idx": 56463, "cwe": "CWE-470", "target": 1, "status": "VULNERABLE", "commit": "a7dab68d194989aaa0b0aa0781cf8ee88fbe3439", "function_name": "getGroup", "body_hash": "38d3725a3b885d7457c273324c4844e2ceeb5b16"}
{"code": "@Override\n   public boolean apply(Run<?, ?> run) {\n      if (run == null) {\n         return false;\n      }\n      boolean retVal = false;\n      M2ReleaseBadgeAction a = run.getAction(M2ReleaseBadgeAction.class);\n      if (a != null) {\n          if (!run.isBuilding()) {\n              if (!a.isDryRun() && run.getResult() == Result.SUCCESS) {\n                  retVal = true;\n              }\n          }\n      }\n      return retVal;\n    }", "code_tokens": ["@", "Override", "public", "boolean", "apply", "(", "Run", "<", "?", ",", "?", ">", "run", ")", "{", "if", "(", "run", "==", "null", ")", "{", "return", "false", ";", "}", "boolean", "retVal", "=", "false", ";", "M2ReleaseBadgeAction", "a", "=", "run", ".", "getAction", "(", "M2ReleaseBadgeAction", ".", "class", ")", ";", "if", "(", "a", "!=", "null", ")", "{", "if", "(", "!", "run", ".", "isBuilding", "(", ")", ")", "{", "if", "(", "!", "a", ".", "isDryRun", "(", ")", "&&", "run", ".", "getResult", "(", ")", "==", "Result", ".", "SUCCESS", ")", "{", "retVal", "=", "true", ";", "}", "}", "}", "return", "retVal", ";", "}"], "idx": 69921, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "c6a6116", "function_name": "apply", "body_hash": "f41e91efed4d793bb87bc22c9b88cb8c3870fa13"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (mappingFile != null) {\n            setProperty(camelContext, dataFormat, \"mappingFile\", mappingFile);\n        }\n        // should be true by default\n        boolean isValidation = getValidation() == null || getValidation();\n        setProperty(camelContext, dataFormat, \"validation\", isValidation);\n\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (packages != null) {\n            setProperty(camelContext, dataFormat, \"packages\", packages);\n        }\n        if (classes != null) {\n            setProperty(camelContext, dataFormat, \"classes\", classes);\n        }\n        if (whitelistEnabled != null) {\n            setProperty(camelContext, dataFormat, \"whitelistEnabled\", whitelistEnabled);\n        }\n        if (allowedUnmarshallObjects != null) {\n            setProperty(camelContext, dataFormat, \"allowedUnmarshallObjects\", allowedUnmarshallObjects);\n        }\n        if (deniedUnmarshallObjects != null) {\n            setProperty(camelContext, dataFormat, \"deniedUnmarshallObjects\", deniedUnmarshallObjects);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "mappingFile", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "mappingFile", "\"", ",", "mappingFile", ")", ";", "}", "boolean", "isValidation", "=", "getValidation", "(", ")", "==", "null", "||", "getValidation", "(", ")", ";", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "validation", "\"", ",", "isValidation", ")", ";", "if", "(", "encoding", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "encoding", "\"", ",", "encoding", ")", ";", "}", "if", "(", "packages", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "packages", "\"", ",", "packages", ")", ";", "}", "if", "(", "classes", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "classes", "\"", ",", "classes", ")", ";", "}", "if", "(", "whitelistEnabled", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "whitelistEnabled", "\"", ",", "whitelistEnabled", ")", ";", "}", "if", "(", "allowedUnmarshallObjects", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowedUnmarshallObjects", "\"", ",", "allowedUnmarshallObjects", ")", ";", "}", "if", "(", "deniedUnmarshallObjects", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "deniedUnmarshallObjects", "\"", ",", "deniedUnmarshallObjects", ")", ";", "}", "}"], "idx": 57331, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "573ebd3de810cc7e239f175e1d2d6993f1f2ad0", "function_name": "configureDataFormat", "body_hash": "f67abb0de4e70a2f116e9990be6c85129674d358"}
{"code": "@BeforeClass\n  public static void setupClass() {\n    functionStringMap.put(new AlterRuntimeConfigFunction(), \"*\");\n    functionStringMap.put(new ChangeLogLevelFunction(), \"*\");\n    functionStringMap.put(new CloseDurableClientFunction(), \"*\");\n    functionStringMap.put(new CloseDurableCqFunction(), \"*\");\n    functionStringMap.put(new ContinuousQueryFunction(), \"*\");\n    functionStringMap.put(new CreateAsyncEventQueueFunction(), \"*\");\n    functionStringMap.put(new CreateDefinedIndexesFunction(), \"*\");\n    functionStringMap.put(new CreateDiskStoreFunction(), \"*\");\n    functionStringMap.put(new CreateIndexFunction(), \"*\");\n    functionStringMap.put(new DataCommandFunction(), \"*\");\n    functionStringMap.put(new DeployFunction(), \"*\");\n    functionStringMap.put(new DescribeDiskStoreFunction(), \"*\");\n    functionStringMap.put(new DestroyAsyncEventQueueFunction(), \"*\");\n    functionStringMap.put(new DestroyDiskStoreFunction(), \"*\");\n    functionStringMap.put(new DestroyIndexFunction(), \"*\");\n    functionStringMap.put(new ExportConfigFunction(), \"*\");\n    functionStringMap.put(new ExportDataFunction(), \"*\");\n    functionStringMap.put(new ExportLogsFunction(), \"*\");\n    functionStringMap.put(new FetchRegionAttributesFunction(), \"*\");\n    functionStringMap.put(new FetchSharedConfigurationStatusFunction(), \"*\");\n    functionStringMap.put(new GarbageCollectionFunction(), \"*\");\n    functionStringMap.put(new GatewayReceiverCreateFunction(), \"*\");\n    functionStringMap.put(new GatewaySenderCreateFunction(), \"*\");\n    functionStringMap.put(new GatewaySenderDestroyFunction(), \"*\");\n    functionStringMap.put(new GetClusterConfigurationFunction(), \"*\");\n    functionStringMap.put(new GetMemberConfigInformationFunction(), \"*\");\n    functionStringMap.put(new GetMemberInformationFunction(), \"*\");\n    functionStringMap.put(new GetRegionDescriptionFunction(), \"*\");\n    functionStringMap.put(new GetRegionsFunction(), \"*\");\n    functionStringMap.put(new GetStackTracesFunction(), \"*\");\n    functionStringMap.put(new GetSubscriptionQueueSizeFunction(), \"*\");\n    functionStringMap.put(new ImportDataFunction(), \"*\");\n    functionStringMap.put(new ListAsyncEventQueuesFunction(), \"*\");\n    functionStringMap.put(new ListDeployedFunction(), \"*\");\n    functionStringMap.put(new ListDiskStoresFunction(), \"*\");\n    functionStringMap.put(new ListDurableCqNamesFunction(), \"*\");\n    functionStringMap.put(new ListFunctionFunction(), \"*\");\n    functionStringMap.put(new ListIndexFunction(), \"*\");\n    functionStringMap.put(new NetstatFunction(), \"*\");\n    functionStringMap.put(new RebalanceFunction(), \"*\");\n    functionStringMap.put(new RegionAlterFunction(), \"*\");\n    functionStringMap.put(new RegionCreateFunction(), \"*\");\n    functionStringMap.put(new RegionDestroyFunction(), \"*\");\n    functionStringMap.put(new ShowMissingDiskStoresFunction(), \"*\");\n    functionStringMap.put(new ShutDownFunction(), \"*\");\n    functionStringMap.put(new SizeExportLogsFunction(), \"*\");\n    functionStringMap.put(new UndeployFunction(), \"*\");\n    functionStringMap.put(new UnregisterFunction(), \"*\");\n    functionStringMap.put(new GetRegionNamesFunction(), \"*\");\n    functionStringMap.put(new RecreateCacheFunction(), \"*\");\n    functionStringMap.put(new DownloadJarFunction(), \"*\");\n\n    functionStringMap.keySet().forEach(FunctionService::registerFunction);\n  }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "setupClass", "(", ")", "{", "functionStringMap", ".", "put", "(", "new", "AlterRuntimeConfigFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ChangeLogLevelFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CloseDurableClientFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CloseDurableCqFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ContinuousQueryFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateAsyncEventQueueFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateDefinedIndexesFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateDiskStoreFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateIndexFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DataCommandFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DeployFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DescribeDiskStoreFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyAsyncEventQueueFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyDiskStoreFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyIndexFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ExportConfigFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ExportDataFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ExportLogsFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "FetchRegionAttributesFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "FetchSharedConfigurationStatusFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GarbageCollectionFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GatewayReceiverCreateFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GatewaySenderCreateFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GatewaySenderDestroyFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetClusterConfigurationFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetMemberConfigInformationFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetMemberInformationFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetRegionDescriptionFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetRegionsFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetStackTracesFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetSubscriptionQueueSizeFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ImportDataFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListAsyncEventQueuesFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListDeployedFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListDiskStoresFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListDurableCqNamesFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListFunctionFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListIndexFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "NetstatFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RebalanceFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RegionAlterFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RegionCreateFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RegionDestroyFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ShowMissingDiskStoresFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ShutDownFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "SizeExportLogsFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "UndeployFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "UnregisterFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "GetRegionNamesFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "RecreateCacheFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DownloadJarFunction", "(", ")", ",", "\"", "*", "\"", ")", ";", "functionStringMap", ".", "keySet", "(", ")", ".", "forEach", "(", "FunctionService", "::", "registerFunction", ")", ";", "}"], "idx": 88190, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "aa469239860778eb46e09dd7b390aee08f152480", "function_name": "setupClass", "body_hash": "7b1101cc01435a1541e96d0245c6583371a412b5"}
{"code": "@Deprecated\n    @SuppressFBWarnings(\n            value = \"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\",\n            justification = \"False positive for try-with-resources in Java 11\")\n    public void doSlaveInfo(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        Jenkins jenkins = Jenkins.get();\n        jenkins.checkPermission(SlaveComputer.CREATE);\n\n        rsp.setContentType(\"text/xml\");\n        try (Writer w = rsp.getCompressedWriter(req)) {\n            w.write(\"<slaveInfo><swarmSecret>\" + UUID.randomUUID().toString() + \"</swarmSecret></slaveInfo>\");\n        }\n    }", "code_tokens": ["@", "Deprecated", "@", "SuppressFBWarnings", "(", "value", "=", "\"", "RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE", "\"", ",", "justification", "=", "\"", "False positive for try-with-resources in Java 11", "\"", ")", "public", "void", "doSlaveInfo", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", "{", "Jenkins", "jenkins", "=", "Jenkins", ".", "get", "(", ")", ";", "jenkins", ".", "checkPermission", "(", "SlaveComputer", ".", "CREATE", ")", ";", "rsp", ".", "setContentType", "(", "\"", "text/xml", "\"", ")", ";", "try", "(", "Writer", "w", "=", "rsp", ".", "getCompressedWriter", "(", "req", ")", ")", "{", "w", ".", "write", "(", "\"", "<slaveInfo><swarmSecret>", "\"", "+", "UUID", ".", "randomUUID", "(", ")", ".", "toString", "(", ")", "+", "\"", "</swarmSecret></slaveInfo>", "\"", ")", ";", "}", "}"], "idx": 45084, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "4d18f98", "function_name": "doSlaveInfo", "body_hash": "0ab0359fbd9306309fb91959905309376c15f470"}
{"code": "@Override\n        public String getProperty( String key ) {\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            if (cl instanceof PermissionCheck) {\n                Permission p = new PropertyPermission(key, \"read\");\n                if (!((PermissionCheck) cl).check(p)) {\n                    return null;\n                }\n            }\n            return System.getProperty(key);\n        }", "code_tokens": ["@", "Override", "public", "String", "getProperty", "(", "String", "key", ")", "{", "ClassLoader", "cl", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "if", "(", "cl", "instanceof", "PermissionCheck", ")", "{", "Permission", "p", "=", "new", "PropertyPermission", "(", "key", ",", "\"", "read", "\"", ")", ";", "if", "(", "!", "(", "(", "PermissionCheck", ")", "cl", ")", ".", "check", "(", "p", ")", ")", "{", "return", "null", ";", "}", "}", "return", "System", ".", "getProperty", "(", "key", ")", ";", "}"], "idx": 101465, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "ae6163a4f230bc679abfc93e048ff92996badad6", "function_name": "getProperty", "body_hash": "48c035f21484b432ec72c3a827de65ab4ce30449"}
{"code": "protected final File file(String name, boolean mustExist) {\n\n        if (name.equals(\"/\")) {\n            name = \"\";\n        }\n        File file = new File(fileBase, name);\n\n        // If the requested names ends in '/', the Java File API will return a\n        // matching file if one exists. This isn't what we want as it is not\n        // consistent with the Servlet spec rules for request mapping.\n        if (name.endsWith(\"/\") && file.isFile()) {\n            return null;\n        }\n\n        // If the file/dir must exist but the identified file/dir can't be read\n        // then signal that the resource was not found\n        if (mustExist && !file.canRead()) {\n            return null;\n        }\n\n        // If allow linking is enabled, files are not limited to being located\n        // under the fileBase so all further checks are disabled.\n        if (getRoot().getAllowLinking()) {\n            return file;\n        }\n\n        // Additional Windows specific checks to handle known problems with\n        // File.getCanonicalPath()\n        if (JrePlatform.IS_WINDOWS && isInvalidWindowsFilename(name)) {\n            return null;\n        }\n\n        // Check that this file is located under the WebResourceSet's base\n        String canPath = null;\n        try {\n            canPath = file.getCanonicalPath();\n        } catch (IOException e) {\n            // Ignore\n        }\n        if (canPath == null || !canPath.startsWith(canonicalBase)) {\n            return null;\n        }\n\n        // Ensure that the file is not outside the fileBase. This should not be\n        // possible for standard requests (the request is normalized early in\n        // the request processing) but might be possible for some access via the\n        // Servlet API (RequestDispatcher, HTTP/2 push etc.) therefore these\n        // checks are retained as an additional safety measure\n        // absoluteBase has been normalized so absPath needs to be normalized as\n        // well.\n        String absPath = normalize(file.getAbsolutePath());\n        if (absoluteBase.length() > absPath.length()) {\n            return null;\n        }\n\n        // Remove the fileBase location from the start of the paths since that\n        // was not part of the requested path and the remaining check only\n        // applies to the request path\n        absPath = absPath.substring(absoluteBase.length());\n        canPath = canPath.substring(canonicalBase.length());\n\n        // Case sensitivity check\n        // The normalized requested path should be an exact match the equivalent\n        // canonical path. If it is not, possible reasons include:\n        // - case differences on case insensitive file systems\n        // - Windows removing a trailing ' ' or '.' from the file name\n        //\n        // In all cases, a mis-match here results in the resource not being\n        // found\n        //\n        // absPath is normalized so canPath needs to be normalized as well\n        // Can't normalize canPath earlier as canonicalBase is not normalized\n        if (canPath.length() > 0) {\n            canPath = normalize(canPath);\n        }\n        if (!canPath.equals(absPath)) {\n            return null;\n        }\n\n        return file;\n    }", "code_tokens": ["protected", "final", "File", "file", "(", "String", "name", ",", "boolean", "mustExist", ")", "{", "if", "(", "name", ".", "equals", "(", "\"", "/", "\"", ")", ")", "{", "name", "=", "\"", "\"", ";", "}", "File", "file", "=", "new", "File", "(", "fileBase", ",", "name", ")", ";", "if", "(", "name", ".", "endsWith", "(", "\"", "/", "\"", ")", "&&", "file", ".", "isFile", "(", ")", ")", "{", "return", "null", ";", "}", "if", "(", "mustExist", "&&", "!", "file", ".", "canRead", "(", ")", ")", "{", "return", "null", ";", "}", "if", "(", "getRoot", "(", ")", ".", "getAllowLinking", "(", ")", ")", "{", "return", "file", ";", "}", "if", "(", "JrePlatform", ".", "IS_WINDOWS", "&&", "isInvalidWindowsFilename", "(", "name", ")", ")", "{", "return", "null", ";", "}", "String", "canPath", "=", "null", ";", "try", "{", "canPath", "=", "file", ".", "getCanonicalPath", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "if", "(", "canPath", "==", "null", "||", "!", "canPath", ".", "startsWith", "(", "canonicalBase", ")", ")", "{", "return", "null", ";", "}", "String", "absPath", "=", "normalize", "(", "file", ".", "getAbsolutePath", "(", ")", ")", ";", "if", "(", "absoluteBase", ".", "length", "(", ")", ">", "absPath", ".", "length", "(", ")", ")", "{", "return", "null", ";", "}", "absPath", "=", "absPath", ".", "substring", "(", "absoluteBase", ".", "length", "(", ")", ")", ";", "canPath", "=", "canPath", ".", "substring", "(", "canonicalBase", ".", "length", "(", ")", ")", ";", "if", "(", "canPath", ".", "length", "(", ")", ">", "0", ")", "{", "canPath", "=", "normalize", "(", "canPath", ")", ";", "}", "if", "(", "!", "canPath", ".", "equals", "(", "absPath", ")", ")", "{", "return", "null", ";", "}", "return", "file", ";", "}"], "idx": 53721, "cwe": "CWE-434", "target": 0, "status": "FIXED", "commit": "a9dd96046d7acb0357c6b7b9e6cc70d186fae663", "function_name": "file", "body_hash": "460ce106ea656075acf61568b43e14b9fb6606c2"}
{"code": "protected Class<?> resolveClass(ObjectStreamClass desc)\n            throws IOException,\n            ClassNotFoundException\n        {\n            if (!found)\n            {\n                if (!desc.getName().equals(mainClass.getName()))\n                {\n                    throw new InvalidClassException(\n                        \"unexpected class: \", desc.getName());\n                }\n                else\n                {\n                    found = true;\n                }\n            }\n            else\n            {\n                if (!components.contains(desc.getName()))\n                {\n                    throw new InvalidClassException(\n                          \"unexpected class: \", desc.getName());\n                }\n            }\n            return super.resolveClass(desc);\n        }", "code_tokens": ["protected", "Class", "<", "?", ">", "resolveClass", "(", "ObjectStreamClass", "desc", ")", "throws", "IOException", ",", "ClassNotFoundException", "{", "if", "(", "!", "found", ")", "{", "if", "(", "!", "desc", ".", "getName", "(", ")", ".", "equals", "(", "mainClass", ".", "getName", "(", ")", ")", ")", "{", "throw", "new", "InvalidClassException", "(", "\"", "unexpected class: ", "\"", ",", "desc", ".", "getName", "(", ")", ")", ";", "}", "else", "{", "found", "=", "true", ";", "}", "}", "else", "{", "if", "(", "!", "components", ".", "contains", "(", "desc", ".", "getName", "(", ")", ")", ")", "{", "throw", "new", "InvalidClassException", "(", "\"", "unexpected class: ", "\"", ",", "desc", ".", "getName", "(", ")", ")", ";", "}", "}", "return", "super", ".", "resolveClass", "(", "desc", ")", ";", "}"], "idx": 59122, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "cd98322b171b15b3f88c5ec871175147893c31e6", "function_name": "resolveClass", "body_hash": "0d48bf1a3560844de94d52beac82ed3d3ac8ada1"}
{"code": "private javax.crypto.Cipher initNewCipher(int jcaCipherMode, byte[] key, byte[] iv, boolean streaming)\n            throws CryptoException {\n\n        javax.crypto.Cipher cipher = newCipherInstance(streaming);\n        java.security.Key jdkKey = new SecretKeySpec(key, getAlgorithmName());\n        AlgorithmParameterSpec ivSpec = null;\n\n        if (iv != null && iv.length > 0) {\n            ivSpec = createParameterSpec(iv, streaming);\n        }\n\n        init(cipher, jcaCipherMode, jdkKey, ivSpec, getSecureRandom());\n\n        return cipher;\n    }", "code_tokens": ["private", "javax", ".", "crypto", ".", "Cipher", "initNewCipher", "(", "int", "jcaCipherMode", ",", "byte", "[", "]", "key", ",", "byte", "[", "]", "iv", ",", "boolean", "streaming", ")", "throws", "CryptoException", "{", "javax", ".", "crypto", ".", "Cipher", "cipher", "=", "newCipherInstance", "(", "streaming", ")", ";", "java", ".", "security", ".", "Key", "jdkKey", "=", "new", "SecretKeySpec", "(", "key", ",", "getAlgorithmName", "(", ")", ")", ";", "AlgorithmParameterSpec", "ivSpec", "=", "null", ";", "if", "(", "iv", "!=", "null", "&&", "iv", ".", "length", ">", "0", ")", "{", "ivSpec", "=", "createParameterSpec", "(", "iv", ",", "streaming", ")", ";", "}", "init", "(", "cipher", ",", "jcaCipherMode", ",", "jdkKey", ",", "ivSpec", ",", "getSecureRandom", "(", ")", ")", ";", "return", "cipher", ";", "}"], "idx": 99491, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "a8018783373ff5e5210225069c9919e071597d5e", "function_name": "initNewCipher", "body_hash": "02ce1a6a0e305c621aac16e5faaf37da095041e7"}
{"code": "@Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                .rememberMe().disable()\n                .authorizeRequests()\n                    .anyRequest().fullyAuthenticated()\n                    .and()\n                .sessionManagement()\n                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n\n        // x509\n        http.addFilterBefore(x509FilterBean(), AnonymousAuthenticationFilter.class);\n\n        // jwt\n        http.addFilterBefore(jwtFilterBean(), AnonymousAuthenticationFilter.class);\n\n        // otp\n        http.addFilterBefore(otpFilterBean(), AnonymousAuthenticationFilter.class);\n\n        // knox\n        http.addFilterBefore(knoxFilterBean(), AnonymousAuthenticationFilter.class);\n\n        // anonymous\n        http.anonymous().authenticationFilter(anonymousFilterBean());\n    }", "code_tokens": ["@", "Override", "protected", "void", "configure", "(", "HttpSecurity", "http", ")", "throws", "Exception", "{", "http", ".", "rememberMe", "(", ")", ".", "disable", "(", ")", ".", "authorizeRequests", "(", ")", ".", "anyRequest", "(", ")", ".", "fullyAuthenticated", "(", ")", ".", "and", "(", ")", ".", "sessionManagement", "(", ")", ".", "sessionCreationPolicy", "(", "SessionCreationPolicy", ".", "STATELESS", ")", ";", "http", ".", "addFilterBefore", "(", "x509FilterBean", "(", ")", ",", "AnonymousAuthenticationFilter", ".", "class", ")", ";", "http", ".", "addFilterBefore", "(", "jwtFilterBean", "(", ")", ",", "AnonymousAuthenticationFilter", ".", "class", ")", ";", "http", ".", "addFilterBefore", "(", "otpFilterBean", "(", ")", ",", "AnonymousAuthenticationFilter", ".", "class", ")", ";", "http", ".", "addFilterBefore", "(", "knoxFilterBean", "(", ")", ",", "AnonymousAuthenticationFilter", ".", "class", ")", ";", "http", ".", "anonymous", "(", ")", ".", "authenticationFilter", "(", "anonymousFilterBean", "(", ")", ")", ";", "}"], "idx": 41939, "cwe": "CWE-319", "target": 1, "status": "VULNERABLE", "commit": "246c090526143943557b15868db6e8fe3fb30cf6", "function_name": "configure", "body_hash": "cfd1eaff3e0754198419eb9bf264968e773ad9a6"}
{"code": "public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null || !ICON_SIZE.matcher(qs).matches())\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", qs);\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }", "code_tokens": ["public", "void", "doIconSize", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "qs", "=", "req", ".", "getQueryString", "(", ")", ";", "if", "(", "qs", "==", "null", "||", "!", "ICON_SIZE", ".", "matcher", "(", "qs", ")", ".", "matches", "(", ")", ")", "throw", "new", "ServletException", "(", ")", ";", "Cookie", "cookie", "=", "new", "Cookie", "(", "\"", "iconSize", "\"", ",", "qs", ")", ";", "cookie", ".", "setMaxAge", "(", "9999999", ")", ";", "rsp", ".", "addCookie", "(", "cookie", ")", ";", "String", "ref", "=", "req", ".", "getHeader", "(", "\"", "Referer", "\"", ")", ";", "if", "(", "ref", "==", "null", ")", "ref", "=", "\"", ".", "\"", ";", "rsp", ".", "sendRedirect2", "(", "ref", ")", ";", "}"], "idx": 78496, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "a0b00508eeb74d7033dc4100eb382df4e8fa72e7", "function_name": "doIconSize", "body_hash": "90e436060345a9d6c7f5f02fc22d688b713f8956"}
{"code": "public static String substituteEnv(String s) {\n        return replaceMacro(s, System.getenv());\n    }", "code_tokens": ["public", "static", "String", "substituteEnv", "(", "String", "s", ")", "{", "return", "replaceMacro", "(", "s", ",", "System", ".", "getenv", "(", ")", ")", ";", "}"], "idx": 19190, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "8dadc2168b108eb45c68037fa941d2594da46d79", "function_name": "substituteEnv", "body_hash": "51d41795397ced5f797d648f5e8eaf8af2dedabb"}
{"code": "@Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                .cors().and()\n                .rememberMe().disable()\n                .authorizeRequests()\n                    .anyRequest().fullyAuthenticated()\n                    .and()\n                .sessionManagement()\n                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n\n        // x509\n        http.addFilterBefore(x509FilterBean(), AnonymousAuthenticationFilter.class);\n\n        // jwt\n        http.addFilterBefore(jwtFilterBean(), AnonymousAuthenticationFilter.class);\n\n        // otp\n        http.addFilterBefore(otpFilterBean(), AnonymousAuthenticationFilter.class);\n\n        // knox\n        http.addFilterBefore(knoxFilterBean(), AnonymousAuthenticationFilter.class);\n\n        // anonymous\n        http.anonymous().authenticationFilter(anonymousFilterBean());\n    }", "code_tokens": ["@", "Override", "protected", "void", "configure", "(", "HttpSecurity", "http", ")", "throws", "Exception", "{", "http", ".", "cors", "(", ")", ".", "and", "(", ")", ".", "rememberMe", "(", ")", ".", "disable", "(", ")", ".", "authorizeRequests", "(", ")", ".", "anyRequest", "(", ")", ".", "fullyAuthenticated", "(", ")", ".", "and", "(", ")", ".", "sessionManagement", "(", ")", ".", "sessionCreationPolicy", "(", "SessionCreationPolicy", ".", "STATELESS", ")", ";", "http", ".", "addFilterBefore", "(", "x509FilterBean", "(", ")", ",", "AnonymousAuthenticationFilter", ".", "class", ")", ";", "http", ".", "addFilterBefore", "(", "jwtFilterBean", "(", ")", ",", "AnonymousAuthenticationFilter", ".", "class", ")", ";", "http", ".", "addFilterBefore", "(", "otpFilterBean", "(", ")", ",", "AnonymousAuthenticationFilter", ".", "class", ")", ";", "http", ".", "addFilterBefore", "(", "knoxFilterBean", "(", ")", ",", "AnonymousAuthenticationFilter", ".", "class", ")", ";", "http", ".", "anonymous", "(", ")", ".", "authenticationFilter", "(", "anonymousFilterBean", "(", ")", ")", ";", "}"], "idx": 41940, "cwe": "CWE-319", "target": 0, "status": "FIXED", "commit": "246c090526143943557b15868db6e8fe3fb30cf6", "function_name": "configure", "body_hash": "05d3ca4b92a12257f16b6f015cebcf12e5e6f64e"}
{"code": "@Override\n    protected void handleMessage(Http1xServerConnection conn, ContextImpl context, ChannelHandlerContext chctx, Object msg) throws Exception {\n      Channel ch = chctx.channel();\n      if (msg instanceof HttpRequest) {\n        final HttpRequest request = (HttpRequest) msg;\n\n        if (log.isTraceEnabled()) log.trace(\"Server received request: \" + request.getUri());\n\n        if (request.headers().contains(io.vertx.core.http.HttpHeaders.UPGRADE, io.vertx.core.http.HttpHeaders.WEBSOCKET, true)) {\n\n          // As a fun part, Firefox 6.0.2 supports Websockets protocol '7'. But,\n          // it doesn't send a normal 'Connection: Upgrade' header. Instead it\n          // sends: 'Connection: keep-alive, Upgrade'. Brilliant.\n          String connectionHeader = request.headers().get(io.vertx.core.http.HttpHeaders.CONNECTION);\n          if (connectionHeader == null || !connectionHeader.toLowerCase().contains(\"upgrade\")) {\n            handshakeErrorStatus = BAD_REQUEST;\n            handshakeErrorMsg = \"\\\"Connection\\\" must be \\\"Upgrade\\\".\";\n            return;\n          }\n\n          if (request.getMethod() != HttpMethod.GET) {\n            handshakeErrorStatus = METHOD_NOT_ALLOWED;\n            sendError(null, METHOD_NOT_ALLOWED, ch);\n            return;\n          }\n\n          if (wsRequest == null) {\n            if (request instanceof FullHttpRequest) {\n              handshake(conn, (FullHttpRequest) request, ch, chctx);\n            } else {\n              wsRequest = new DefaultFullHttpRequest(request.getProtocolVersion(), request.getMethod(), request.getUri());\n              wsRequest.headers().set(request.headers());\n            }\n          }\n        } else {\n          //HTTP request\n          conn.handleMessage(msg);\n        }\n      } else if (msg instanceof WebSocketFrameInternal) {\n        //Websocket frame\n        WebSocketFrameInternal wsFrame = (WebSocketFrameInternal) msg;\n        switch (wsFrame.type()) {\n          case BINARY:\n          case CONTINUATION:\n          case TEXT:\n          case PONG:\n            conn.handleMessage(msg);\n            break;\n          case PING:\n            // Echo back the content of the PING frame as PONG frame as specified in RFC 6455 Section 5.5.2\n            conn.channel().writeAndFlush(new PongWebSocketFrame(wsFrame.getBinaryData().copy()));\n            break;\n          case CLOSE:\n            if (!closeFrameSent) {\n              // Echo back close frame and close the connection once it was written.\n              // This is specified in the WebSockets RFC 6455 Section  5.4.1\n              CloseWebSocketFrame closeFrame = new CloseWebSocketFrame(wsFrame.closeStatusCode(), wsFrame.closeReason());\n              ch.writeAndFlush(closeFrame).addListener(ChannelFutureListener.CLOSE);\n              closeFrameSent = true;\n            }\n            conn.handleMessage(msg);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid type: \" + wsFrame.type());\n        }\n      } else if (msg instanceof HttpContent) {\n        if (wsRequest != null) {\n          ByteBuf content = wsRequest.content();\n          boolean overflow = content.readableBytes() > 8192;\n          content.writeBytes(((HttpContent) msg).content());\n          if (content.readableBytes() > 8192) {\n            if (!overflow) {\n              FullHttpResponse resp = new DefaultFullHttpResponse(\n                io.netty.handler.codec.http.HttpVersion.HTTP_1_1,\n                HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE\n              );\n              chctx.writeAndFlush(resp);\n              chctx.close();\n            }\n            if (msg instanceof LastHttpContent) {\n              wsRequest = null;\n              return;\n            }\n          }\n          if (msg instanceof LastHttpContent) {\n            FullHttpRequest req = wsRequest;\n            wsRequest = null;\n            handshake(conn, req, ch, chctx);\n            return;\n          }\n        } else if (handshakeErrorStatus != null) {\n          if (msg instanceof LastHttpContent) {\n            sendError(handshakeErrorMsg, handshakeErrorStatus, ch);\n            handshakeErrorMsg = null;\n            handshakeErrorMsg = null;\n          }\n          return;\n        }\n        conn.handleMessage(msg);\n      } else {\n        throw new IllegalStateException(\"Invalid message \" + msg);\n      }\n    }", "code_tokens": ["@", "Override", "protected", "void", "handleMessage", "(", "Http1xServerConnection", "conn", ",", "ContextImpl", "context", ",", "ChannelHandlerContext", "chctx", ",", "Object", "msg", ")", "throws", "Exception", "{", "Channel", "ch", "=", "chctx", ".", "channel", "(", ")", ";", "if", "(", "msg", "instanceof", "HttpRequest", ")", "{", "final", "HttpRequest", "request", "=", "(", "HttpRequest", ")", "msg", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "log", ".", "trace", "(", "\"", "Server received request: ", "\"", "+", "request", ".", "getUri", "(", ")", ")", ";", "if", "(", "request", ".", "headers", "(", ")", ".", "contains", "(", "io", ".", "vertx", ".", "core", ".", "http", ".", "HttpHeaders", ".", "UPGRADE", ",", "io", ".", "vertx", ".", "core", ".", "http", ".", "HttpHeaders", ".", "WEBSOCKET", ",", "true", ")", ")", "{", "String", "connectionHeader", "=", "request", ".", "headers", "(", ")", ".", "get", "(", "io", ".", "vertx", ".", "core", ".", "http", ".", "HttpHeaders", ".", "CONNECTION", ")", ";", "if", "(", "connectionHeader", "==", "null", "||", "!", "connectionHeader", ".", "toLowerCase", "(", ")", ".", "contains", "(", "\"", "upgrade", "\"", ")", ")", "{", "handshakeErrorStatus", "=", "BAD_REQUEST", ";", "handshakeErrorMsg", "=", "\"", "\\\"", "Connection", "\\\"", " must be ", "\\\"", "Upgrade", "\\\"", ".", "\"", ";", "return", ";", "}", "if", "(", "request", ".", "getMethod", "(", ")", "!=", "HttpMethod", ".", "GET", ")", "{", "handshakeErrorStatus", "=", "METHOD_NOT_ALLOWED", ";", "sendError", "(", "null", ",", "METHOD_NOT_ALLOWED", ",", "ch", ")", ";", "return", ";", "}", "if", "(", "wsRequest", "==", "null", ")", "{", "if", "(", "request", "instanceof", "FullHttpRequest", ")", "{", "handshake", "(", "conn", ",", "(", "FullHttpRequest", ")", "request", ",", "ch", ",", "chctx", ")", ";", "}", "else", "{", "wsRequest", "=", "new", "DefaultFullHttpRequest", "(", "request", ".", "getProtocolVersion", "(", ")", ",", "request", ".", "getMethod", "(", ")", ",", "request", ".", "getUri", "(", ")", ")", ";", "wsRequest", ".", "headers", "(", ")", ".", "set", "(", "request", ".", "headers", "(", ")", ")", ";", "}", "}", "}", "else", "{", "conn", ".", "handleMessage", "(", "msg", ")", ";", "}", "}", "else", "if", "(", "msg", "instanceof", "WebSocketFrameInternal", ")", "{", "WebSocketFrameInternal", "wsFrame", "=", "(", "WebSocketFrameInternal", ")", "msg", ";", "switch", "(", "wsFrame", ".", "type", "(", ")", ")", "{", "case", "BINARY", ":", "case", "CONTINUATION", ":", "case", "TEXT", ":", "case", "PONG", ":", "conn", ".", "handleMessage", "(", "msg", ")", ";", "break", ";", "case", "PING", ":", "conn", ".", "channel", "(", ")", ".", "writeAndFlush", "(", "new", "PongWebSocketFrame", "(", "wsFrame", ".", "getBinaryData", "(", ")", ".", "copy", "(", ")", ")", ")", ";", "break", ";", "case", "CLOSE", ":", "if", "(", "!", "closeFrameSent", ")", "{", "CloseWebSocketFrame", "closeFrame", "=", "new", "CloseWebSocketFrame", "(", "wsFrame", ".", "closeStatusCode", "(", ")", ",", "wsFrame", ".", "closeReason", "(", ")", ")", ";", "ch", ".", "writeAndFlush", "(", "closeFrame", ")", ".", "addListener", "(", "ChannelFutureListener", ".", "CLOSE", ")", ";", "closeFrameSent", "=", "true", ";", "}", "conn", ".", "handleMessage", "(", "msg", ")", ";", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Invalid type: ", "\"", "+", "wsFrame", ".", "type", "(", ")", ")", ";", "}", "}", "else", "if", "(", "msg", "instanceof", "HttpContent", ")", "{", "if", "(", "wsRequest", "!=", "null", ")", "{", "ByteBuf", "content", "=", "wsRequest", ".", "content", "(", ")", ";", "boolean", "overflow", "=", "content", ".", "readableBytes", "(", ")", ">", "8192", ";", "content", ".", "writeBytes", "(", "(", "(", "HttpContent", ")", "msg", ")", ".", "content", "(", ")", ")", ";", "if", "(", "content", ".", "readableBytes", "(", ")", ">", "8192", ")", "{", "if", "(", "!", "overflow", ")", "{", "FullHttpResponse", "resp", "=", "new", "DefaultFullHttpResponse", "(", "io", ".", "netty", ".", "handler", ".", "codec", ".", "http", ".", "HttpVersion", ".", "HTTP_1_1", ",", "HttpResponseStatus", ".", "REQUEST_ENTITY_TOO_LARGE", ")", ";", "chctx", ".", "writeAndFlush", "(", "resp", ")", ";", "chctx", ".", "close", "(", ")", ";", "}", "if", "(", "msg", "instanceof", "LastHttpContent", ")", "{", "wsRequest", "=", "null", ";", "return", ";", "}", "}", "if", "(", "msg", "instanceof", "LastHttpContent", ")", "{", "FullHttpRequest", "req", "=", "wsRequest", ";", "wsRequest", "=", "null", ";", "handshake", "(", "conn", ",", "req", ",", "ch", ",", "chctx", ")", ";", "return", ";", "}", "}", "else", "if", "(", "handshakeErrorStatus", "!=", "null", ")", "{", "if", "(", "msg", "instanceof", "LastHttpContent", ")", "{", "sendError", "(", "handshakeErrorMsg", ",", "handshakeErrorStatus", ",", "ch", ")", ";", "handshakeErrorMsg", "=", "null", ";", "handshakeErrorMsg", "=", "null", ";", "}", "return", ";", "}", "conn", ".", "handleMessage", "(", "msg", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Invalid message ", "\"", "+", "msg", ")", ";", "}", "}"], "idx": 2041, "cwe": "CWE-119", "target": 0, "status": "FIXED", "commit": "269a583330695d1418a4f5578f7169350b2e1332", "function_name": "handleMessage", "body_hash": "4ec98a11f8af5b7413dc2d38ac706cb39c1e0268"}
{"code": "protected void sendDirectory(HttpServletRequest request,\n            HttpServletResponse response,\n            Resource resource,\n            String pathInContext)\n    throws IOException\n    {\n        if (!_dirAllowed)\n        {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n\n        byte[] data=null;\n        String base = URIUtil.addPaths(request.getRequestURI(),URIUtil.SLASH);\n\n        //If the DefaultServlet has a resource base set, use it\n        if (_resourceBase != null)\n        {\n            // handle ResourceCollection\n            if (_resourceBase instanceof ResourceCollection)\n                resource=_resourceBase.addPath(pathInContext);\n        }\n        //Otherwise, try using the resource base of its enclosing context handler\n        else if (_contextHandler.getBaseResource() instanceof ResourceCollection)\n            resource=_contextHandler.getBaseResource().addPath(pathInContext);\n\n        String dir = resource.getListHTML(base,pathInContext.length()>1, request.getQueryString());\n        if (dir==null)\n        {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN,\n            \"No directory\");\n            return;\n        }\n\n        data=dir.getBytes(\"UTF-8\");\n        response.setContentType(\"text/html; charset=UTF-8\");\n        response.setContentLength(data.length);\n        response.getOutputStream().write(data);\n    }", "code_tokens": ["protected", "void", "sendDirectory", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Resource", "resource", ",", "String", "pathInContext", ")", "throws", "IOException", "{", "if", "(", "!", "_dirAllowed", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ")", ";", "return", ";", "}", "byte", "[", "]", "data", "=", "null", ";", "String", "base", "=", "URIUtil", ".", "addPaths", "(", "request", ".", "getRequestURI", "(", ")", ",", "URIUtil", ".", "SLASH", ")", ";", "if", "(", "_resourceBase", "!=", "null", ")", "{", "if", "(", "_resourceBase", "instanceof", "ResourceCollection", ")", "resource", "=", "_resourceBase", ".", "addPath", "(", "pathInContext", ")", ";", "}", "else", "if", "(", "_contextHandler", ".", "getBaseResource", "(", ")", "instanceof", "ResourceCollection", ")", "resource", "=", "_contextHandler", ".", "getBaseResource", "(", ")", ".", "addPath", "(", "pathInContext", ")", ";", "String", "dir", "=", "resource", ".", "getListHTML", "(", "base", ",", "pathInContext", ".", "length", "(", ")", ">", "1", ",", "request", ".", "getQueryString", "(", ")", ")", ";", "if", "(", "dir", "==", "null", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ",", "\"", "No directory", "\"", ")", ";", "return", ";", "}", "data", "=", "dir", ".", "getBytes", "(", "\"", "UTF-8", "\"", ")", ";", "response", ".", "setContentType", "(", "\"", "text/html; charset=UTF-8", "\"", ")", ";", "response", ".", "setContentLength", "(", "data", ".", "length", ")", ";", "response", ".", "getOutputStream", "(", ")", ".", "write", "(", "data", ")", ";", "}"], "idx": 79547, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "ca77bd384a2970cabbbdab25cf6251c6fb76cd21", "function_name": "sendDirectory", "body_hash": "0438ae3232b43c3ee8ea1768681447743c3ab528"}
{"code": "protected synchronized void authenticatorConfig() {\n\n        // Does this Context require an Authenticator?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0))\n            return;\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null)\n            return;\n        \n        if (!(context instanceof ContainerBase)) {\n            return;     // Cannot install a Valve even if it would be needed\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve)\n                customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n        if (authenticator == null) {\n            // Load our mapping properties if necessary\n            if (authenticators == null) {\n                try {\n                    InputStream is=this.getClass().getClassLoader().getResourceAsStream(\"org/apache/catalina/startup/Authenticators.properties\");\n                    if( is!=null ) {\n                        authenticators = new Properties();\n                        authenticators.load(is);\n                    } else {\n                        log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"));\n                        ok=false;\n                        return;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"), e);\n                    ok = false;\n                    return;\n                }\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = null;\n            authenticatorName =\n                    authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null && context instanceof ContainerBase) {\n            Pipeline pipeline = ((ContainerBase) context).getPipeline();\n            if (pipeline != null) {\n                ((ContainerBase) context).getPipeline().addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n\n    }", "code_tokens": ["protected", "synchronized", "void", "authenticatorConfig", "(", ")", "{", "SecurityConstraint", "constraints", "[", "]", "=", "context", ".", "findConstraints", "(", ")", ";", "if", "(", "(", "constraints", "==", "null", ")", "||", "(", "constraints", ".", "length", "==", "0", ")", ")", "return", ";", "LoginConfig", "loginConfig", "=", "context", ".", "getLoginConfig", "(", ")", ";", "if", "(", "loginConfig", "==", "null", ")", "{", "loginConfig", "=", "DUMMY_LOGIN_CONFIG", ";", "context", ".", "setLoginConfig", "(", "loginConfig", ")", ";", "}", "if", "(", "context", ".", "getAuthenticator", "(", ")", "!=", "null", ")", "return", ";", "if", "(", "!", "(", "context", "instanceof", "ContainerBase", ")", ")", "{", "return", ";", "}", "if", "(", "context", ".", "getRealm", "(", ")", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.missingRealm", "\"", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "Valve", "authenticator", "=", "null", ";", "if", "(", "customAuthenticators", "!=", "null", ")", "{", "authenticator", "=", "(", "Valve", ")", "customAuthenticators", ".", "get", "(", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ";", "}", "if", "(", "authenticator", "==", "null", ")", "{", "if", "(", "authenticators", "==", "null", ")", "{", "try", "{", "InputStream", "is", "=", "this", ".", "getClass", "(", ")", ".", "getClassLoader", "(", ")", ".", "getResourceAsStream", "(", "\"", "org/apache/catalina/startup/Authenticators.properties", "\"", ")", ";", "if", "(", "is", "!=", "null", ")", "{", "authenticators", "=", "new", "Properties", "(", ")", ";", "authenticators", ".", "load", "(", "is", ")", ";", "}", "else", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorResources", "\"", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorResources", "\"", ")", ",", "e", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "}", "String", "authenticatorName", "=", "null", ";", "authenticatorName", "=", "authenticators", ".", "getProperty", "(", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ";", "if", "(", "authenticatorName", "==", "null", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorMissing", "\"", ",", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ")", ";", "ok", "=", "false", ";", "return", ";", "}", "try", "{", "Class", "<", "?", ">", "authenticatorClass", "=", "Class", ".", "forName", "(", "authenticatorName", ")", ";", "authenticator", "=", "(", "Valve", ")", "authenticatorClass", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "t", ")", ";", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorInstantiate", "\"", ",", "authenticatorName", ")", ",", "t", ")", ";", "ok", "=", "false", ";", "}", "}", "if", "(", "authenticator", "!=", "null", "&&", "context", "instanceof", "ContainerBase", ")", "{", "Pipeline", "pipeline", "=", "(", "(", "ContainerBase", ")", "context", ")", ".", "getPipeline", "(", ")", ";", "if", "(", "pipeline", "!=", "null", ")", "{", "(", "(", "ContainerBase", ")", "context", ")", ".", "getPipeline", "(", ")", ".", "addValve", "(", "authenticator", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "contextConfig.authenticatorConfigured", "\"", ",", "loginConfig", ".", "getAuthMethod", "(", ")", ")", ")", ";", "}", "}", "}", "}"], "idx": 111166, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "0ff4905158b77787a7f3aca55c9dec93456665dc", "function_name": "authenticatorConfig", "body_hash": "a2b14021fd0202035c03e053a005d23d549fd17c"}
{"code": "public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        if(path.length()==0)\n            path = \"/\";\n\n        if(path.indexOf(\"..\")!=-1 || path.length()<1) {\n            // don't serve anything other than files in the sub directory.\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL,'.'+path),expires);\n    }", "code_tokens": ["public", "void", "doDynamic", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "req", ".", "getRestOfPath", "(", ")", ";", "if", "(", "path", ".", "length", "(", ")", "==", "0", ")", "path", "=", "\"", "/", "\"", ";", "if", "(", "path", ".", "indexOf", "(", "\"", "..", "\"", ")", "!=", "-", "1", "||", "path", ".", "length", "(", ")", "<", "1", ")", "{", "rsp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "String", "requestPath", "=", "req", ".", "getRequestURI", "(", ")", ".", "substring", "(", "req", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "boolean", "staticLink", "=", "requestPath", ".", "startsWith", "(", "\"", "/static/", "\"", ")", ";", "long", "expires", "=", "staticLink", "?", "TimeUnit2", ".", "DAYS", ".", "toMillis", "(", "365", ")", ":", "-", "1", ";", "rsp", ".", "serveLocalizedFile", "(", "req", ",", "new", "URL", "(", "wrapper", ".", "baseResourceURL", ",", "'.'", "+", "path", ")", ",", "expires", ")", ";", "}"], "idx": 21461, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "71a28615e33fe42e3cc7a34ef86e31ed5d87bc74", "function_name": "doDynamic", "body_hash": "f376040d6d50294912f9b64b37e99703bfbfaa7d"}
{"code": "@Before\n    public void setUp() throws Exception {\n        SecurityContextHolder.clearContext();\n        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();\n\n        Map<String, List<DescribedApproval>> approvalsByClientId = new HashMap<String, List<DescribedApproval>>();\n\n        DescribedApproval readApproval = new DescribedApproval();\n        readApproval.setUserId(\"userId\");\n        readApproval.setClientId(\"app\");\n        readApproval.setScope(\"thing.read\");\n        readApproval.setStatus(APPROVED);\n        readApproval.setDescription(\"Read your thing resources\");\n\n        DescribedApproval writeApproval = new DescribedApproval();\n        writeApproval.setUserId(\"userId\");\n        writeApproval.setClientId(\"app\");\n        writeApproval.setScope(\"thing.write\");\n        writeApproval.setStatus(APPROVED);\n        writeApproval.setDescription(\"Write to your thing resources\");\n\n        approvalsByClientId.put(\"app\", Arrays.asList(readApproval, writeApproval));\n\n        Mockito.when(approvalsService.getCurrentApprovalsByClientId()).thenReturn(approvalsByClientId);\n        Mockito.doThrow(new NoSuchClientException(\"invalidId\")).when(approvalsService).deleteApprovalsForClient(\"invalidId\");\n\n        BaseClientDetails appClient = new BaseClientDetails(\"app\",\"thing\",\"thing.read,thing.write\",\"authorization_code\", \"\");\n        appClient.addAdditionalInformation(ClientConstants.CLIENT_NAME, THE_ULTIMATE_APP);\n        Mockito.when(clientDetailsService.loadClientByClientId(\"app\")).thenReturn(appClient);\n    }", "code_tokens": ["@", "Before", "public", "void", "setUp", "(", ")", "throws", "Exception", "{", "SecurityContextHolder", ".", "clearContext", "(", ")", ";", "mockMvc", "=", "MockMvcBuilders", ".", "webAppContextSetup", "(", "webApplicationContext", ")", ".", "build", "(", ")", ";", "Map", "<", "String", ",", "List", "<", "DescribedApproval", ">", ">", "approvalsByClientId", "=", "new", "HashMap", "<", "String", ",", "List", "<", "DescribedApproval", ">", ">", "(", ")", ";", "DescribedApproval", "readApproval", "=", "new", "DescribedApproval", "(", ")", ";", "readApproval", ".", "setUserId", "(", "\"", "userId", "\"", ")", ";", "readApproval", ".", "setClientId", "(", "\"", "app", "\"", ")", ";", "readApproval", ".", "setScope", "(", "\"", "thing.read", "\"", ")", ";", "readApproval", ".", "setStatus", "(", "APPROVED", ")", ";", "readApproval", ".", "setDescription", "(", "\"", "Read your thing resources", "\"", ")", ";", "DescribedApproval", "writeApproval", "=", "new", "DescribedApproval", "(", ")", ";", "writeApproval", ".", "setUserId", "(", "\"", "userId", "\"", ")", ";", "writeApproval", ".", "setClientId", "(", "\"", "app", "\"", ")", ";", "writeApproval", ".", "setScope", "(", "\"", "thing.write", "\"", ")", ";", "writeApproval", ".", "setStatus", "(", "APPROVED", ")", ";", "writeApproval", ".", "setDescription", "(", "\"", "Write to your thing resources", "\"", ")", ";", "approvalsByClientId", ".", "put", "(", "\"", "app", "\"", ",", "Arrays", ".", "asList", "(", "readApproval", ",", "writeApproval", ")", ")", ";", "Mockito", ".", "when", "(", "approvalsService", ".", "getCurrentApprovalsByClientId", "(", ")", ")", ".", "thenReturn", "(", "approvalsByClientId", ")", ";", "Mockito", ".", "doThrow", "(", "new", "NoSuchClientException", "(", "\"", "invalidId", "\"", ")", ")", ".", "when", "(", "approvalsService", ")", ".", "deleteApprovalsForClient", "(", "\"", "invalidId", "\"", ")", ";", "BaseClientDetails", "appClient", "=", "new", "BaseClientDetails", "(", "\"", "app", "\"", ",", "\"", "thing", "\"", ",", "\"", "thing.read,thing.write", "\"", ",", "\"", "authorization_code", "\"", ",", "\"", "\"", ")", ";", "appClient", ".", "addAdditionalInformation", "(", "ClientConstants", ".", "CLIENT_NAME", ",", "THE_ULTIMATE_APP", ")", ";", "Mockito", ".", "when", "(", "clientDetailsService", ".", "loadClientByClientId", "(", "\"", "app", "\"", ")", ")", ".", "thenReturn", "(", "appClient", ")", ";", "}"], "idx": 35397, "cwe": "CWE-269", "target": 0, "status": "FIXED", "commit": "24bc5ade80560cedb9300940d2b398163ab0dc6", "function_name": "setUp", "body_hash": "e9433c339e4bb43aba275a069ad537d8d22834d3"}
{"code": "protected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,\n                                                   byte[] encryptedPreMasterSecret)\n    {\n        SecureRandom secureRandom = crypto.getSecureRandom();\n\n        /*\n         * RFC 5246 7.4.7.1.\n         */\n        ProtocolVersion clientVersion = cryptoParams.getClientVersion();\n\n        // TODO Provide as configuration option?\n        boolean versionNumberCheckDisabled = false;\n\n        /*\n         * Generate 48 random bytes we can use as a Pre-Master-Secret, if the\n         * PKCS1 padding check should fail.\n         */\n        byte[] fallback = new byte[48];\n        secureRandom.nextBytes(fallback);\n\n        byte[] M = Arrays.clone(fallback);\n        try\n        {\n            Cipher c = crypto.createRSAEncryptionCipher();\n            c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);\n            byte[] m = c.doFinal(encryptedPreMasterSecret);\n            if (m != null && m.length == 48)\n            {\n                M = m;\n            }\n        }\n        catch (Exception e)\n        {\n            /*\n             * A TLS server MUST NOT generate an alert if processing an\n             * RSA-encrypted premaster secret message fails, or the version number is not as\n             * expected. Instead, it MUST continue the handshake with a randomly generated\n             * premaster secret.\n             */\n        }\n\n        /*\n         * If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST\n         * check the version number [..].\n         */\n        if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))\n        {\n            /*\n             * If the version number is TLS 1.0 or earlier, server\n             * implementations SHOULD check the version number, but MAY have a\n             * configuration option to disable the check.\n             *\n             * So there is nothing to do here.\n             */\n        }\n        else\n        {\n            /*\n             * OK, we need to compare the version number in the decrypted Pre-Master-Secret with the\n             * clientVersion received during the handshake. If they don't match, we replace the\n             * decrypted Pre-Master-Secret with a random one.\n             */\n            int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))\n                | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));\n            correct |= correct >> 1;\n            correct |= correct >> 2;\n            correct |= correct >> 4;\n            int mask = ~((correct & 1) - 1);\n\n            /*\n             * mask will be all bits set to 0xff if the version number differed.\n             */\n            for (int i = 0; i < 48; i++)\n            {\n                M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));\n            }\n        }\n        return crypto.createSecret(M);\n    }", "code_tokens": ["protected", "TlsSecret", "safeDecryptPreMasterSecret", "(", "TlsCryptoParameters", "cryptoParams", ",", "PrivateKey", "rsaServerPrivateKey", ",", "byte", "[", "]", "encryptedPreMasterSecret", ")", "{", "SecureRandom", "secureRandom", "=", "crypto", ".", "getSecureRandom", "(", ")", ";", "ProtocolVersion", "clientVersion", "=", "cryptoParams", ".", "getClientVersion", "(", ")", ";", "boolean", "versionNumberCheckDisabled", "=", "false", ";", "byte", "[", "]", "fallback", "=", "new", "byte", "[", "48", "]", ";", "secureRandom", ".", "nextBytes", "(", "fallback", ")", ";", "byte", "[", "]", "M", "=", "Arrays", ".", "clone", "(", "fallback", ")", ";", "try", "{", "Cipher", "c", "=", "crypto", ".", "createRSAEncryptionCipher", "(", ")", ";", "c", ".", "init", "(", "Cipher", ".", "DECRYPT_MODE", ",", "rsaServerPrivateKey", ")", ";", "byte", "[", "]", "m", "=", "c", ".", "doFinal", "(", "encryptedPreMasterSecret", ")", ";", "if", "(", "m", "!=", "null", "&&", "m", ".", "length", "==", "48", ")", "{", "M", "=", "m", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "}", "if", "(", "versionNumberCheckDisabled", "&&", "clientVersion", ".", "isEqualOrEarlierVersionOf", "(", "ProtocolVersion", ".", "TLSv10", ")", ")", "{", "}", "else", "{", "int", "correct", "=", "(", "clientVersion", ".", "getMajorVersion", "(", ")", "^", "(", "M", "[", "0", "]", "&", "0xff", ")", ")", "|", "(", "clientVersion", ".", "getMinorVersion", "(", ")", "^", "(", "M", "[", "1", "]", "&", "0xff", ")", ")", ";", "correct", "|=", "correct", ">>", "1", ";", "correct", "|=", "correct", ">>", "2", ";", "correct", "|=", "correct", ">>", "4", ";", "int", "mask", "=", "~", "(", "(", "correct", "&", "1", ")", "-", "1", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "48", ";", "i", "++", ")", "{", "M", "[", "i", "]", "=", "(", "byte", ")", "(", "(", "M", "[", "i", "]", "&", "(", "~", "mask", ")", ")", "|", "(", "fallback", "[", "i", "]", "&", "mask", ")", ")", ";", "}", "}", "return", "crypto", ".", "createSecret", "(", "M", ")", ";", "}"], "idx": 20524, "cwe": "CWE-203", "target": 0, "status": "FIXED", "commit": "a00b684465b38d722ca9a3543b8af8568e6bad5c", "function_name": "safeDecryptPreMasterSecret", "body_hash": "a1a11a087059acc94d3f83500f841aa9fd987b15"}
{"code": "@Override\n    public boolean willAttributeDistribute(String name, Object value) {\n        Pattern sessionAttributeNamePattern = getSessionAttributeNamePattern();\n        if (sessionAttributeNamePattern == null) {\n            return true;\n        }\n        return sessionAttributeNamePattern.matcher(name).matches();\n    }", "code_tokens": ["@", "Override", "public", "boolean", "willAttributeDistribute", "(", "String", "name", ",", "Object", "value", ")", "{", "Pattern", "sessionAttributeNamePattern", "=", "getSessionAttributeNamePattern", "(", ")", ";", "if", "(", "sessionAttributeNamePattern", "==", "null", ")", "{", "return", "true", ";", "}", "return", "sessionAttributeNamePattern", ".", "matcher", "(", "name", ")", ".", "matches", "(", ")", ";", "}"], "idx": 31990, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "50f1b1da794cd93b70ab5456d3c2c984408e1506", "function_name": "willAttributeDistribute", "body_hash": "b8fae530b18a39adb9ee66b197d04d4b622612aa"}
{"code": "@Configuration\n    public Option[] config() throws InterruptedException {\n\n        MavenArtifactUrlReference karafUrl = maven()\n                .groupId(\"org.apache.unomi\")\n                .artifactId(\"unomi\")\n                .type(\"tar.gz\")\n                .versionAsInProject();\n\n        MavenUrlReference routerRepo = maven()\n                .groupId(\"org.apache.unomi\")\n                .artifactId(\"unomi-router-karaf-feature\")\n                .classifier(\"features\")\n                .type(\"xml\")\n                .versionAsInProject();\n\n        List<Option> options = new ArrayList<>();\n\n        Option[] commonOptions = new Option[]{\n                karafDistributionConfiguration()\n                        .frameworkUrl(karafUrl)\n                        .unpackDirectory(new File(KARAF_DIR))\n                        .useDeployFolder(true),\n                replaceConfigurationFile(\"etc/org.apache.unomi.router.cfg\", new File(\n                        \"src/test/resources/org.apache.unomi.router.cfg\")),\n                replaceConfigurationFile(\"data/tmp/1-basic-test.csv\", new File(\n                        \"src/test/resources/1-basic-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/2-surfers-test.csv\", new File(\n                        \"src/test/resources/2-surfers-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/3-surfers-overwrite-test.csv\", new File(\n                        \"src/test/resources/3-surfers-overwrite-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/4-surfers-delete-test.csv\", new File(\n                        \"src/test/resources/4-surfers-delete-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/5-ranking-test.csv\", new File(\n                        \"src/test/resources/5-ranking-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/6-actors-test.csv\", new File(\n                        \"src/test/resources/6-actors-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/testLogin.json\", new File(\n                        \"src/test/resources/testLogin.json\")),\n                replaceConfigurationFile(\"data/tmp/testLoginEventCondition.json\", new File(\n                        \"src/test/resources/testLoginEventCondition.json\")),\n                keepRuntimeFolder(),\n                // configureConsole().ignoreLocalConsole(),\n                logLevel(LogLevel.INFO),\n                editConfigurationFilePut(\"etc/org.ops4j.pax.logging.cfg\", \"log4j2.rootLogger.level\", \"INFO\"),\n                editConfigurationFilePut(\"etc/org.apache.karaf.features.cfg\", \"serviceRequirements\", \"disable\"),\n//                editConfigurationFilePut(\"etc/org.ops4j.pax.web.cfg\", \"org.osgi.service.http.port\", HTTP_PORT),\n//                systemProperty(\"org.osgi.service.http.port\").value(HTTP_PORT),\n                systemProperty(\"org.ops4j.pax.exam.rbc.rmi.port\").value(\"1199\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.transport.port\").value(\"9500\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.cluster.name\").value(\"contextElasticSearchITests\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.http.port\").value(\"9400\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.bootstrap.seccomp\").value(\"false\"),\n                systemProperty(\"org.apache.unomi.hazelcast.group.name\").value(\"cellar\"),\n                systemProperty(\"org.apache.unomi.hazelcast.group.password\").value(\"pass\"),\n                systemProperty(\"org.apache.unomi.hazelcast.network.port\").value(\"5701\"),\n                systemProperty(\"org.apache.unomi.hazelcast.tcp-ip.members\").value(\"127.0.0.1\"),\n                systemProperty(\"org.apache.unomi.hazelcast.tcp-ip.interface\").value(\"127.0.0.1\"),\n                systemProperty(\"unomi.autoStart\").value(\"true\"),\n                features(routerRepo, \"unomi-router-karaf-feature\"),\n                CoreOptions.bundleStartLevel(100),\n                CoreOptions.frameworkStartLevel(100)\n        };\n\n        options.addAll(Arrays.asList(commonOptions));\n\n        String karafDebug = System.getProperty(\"it.karaf.debug\");\n        if (karafDebug != null) {\n            System.out.println(\"Found system Karaf Debug system property, activating configuration: \" + karafDebug);\n            String port = \"5006\";\n            boolean hold = true;\n            if (karafDebug.trim().length() > 0) {\n                String[] debugOptions = karafDebug.split(\",\");\n                for (String debugOption : debugOptions) {\n                    String[] debugOptionParts = debugOption.split(\":\");\n                    if (\"hold\".equals(debugOptionParts[0])) {\n                        hold = Boolean.parseBoolean(debugOptionParts[1].trim());\n                    }\n                    if (\"port\".equals(debugOptionParts[0])) {\n                        port = debugOptionParts[1].trim();\n                    }\n                }\n            }\n            options.add(0, debugConfiguration(port, hold));\n        }\n\n        if (JavaVersionUtil.getMajorVersion() >= 9) {\n            Option[] jdk9PlusOptions = new Option[]{\n                    new VMOption(\"--add-reads=java.xml=java.logging\"),\n                    new VMOption(\"--add-exports=java.base/org.apache.karaf.specs.locator=java.xml,ALL-UNNAMED\"),\n                    new VMOption(\"--patch-module\"),\n                    new VMOption(\"java.base=lib/endorsed/org.apache.karaf.specs.locator-\"\n                            + System.getProperty(\"karaf.version\") + \".jar\"),\n                    new VMOption(\"--patch-module\"), new VMOption(\"java.xml=lib/endorsed/org.apache.karaf.specs.java.xml-\"\n                    + System.getProperty(\"karaf.version\") + \".jar\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.security=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.net=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.lang=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.util=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.naming/javax.naming.spi=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.rmi/sun.rmi.transport.tcp=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.http=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.https=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.jar=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=jdk.naming.rmi/com.sun.jndi.url.rmi=ALL-UNNAMED\"),\n                    new VMOption(\"-classpath\"),\n                    new VMOption(\"lib/jdk9plus/*\" + File.pathSeparator + \"lib/boot/*\")\n\n            };\n            options.addAll(Arrays.asList(jdk9PlusOptions));\n        }\n\n        return options.toArray(new Option[0]);\n    }", "code_tokens": ["@", "Configuration", "public", "Option", "[", "]", "config", "(", ")", "throws", "InterruptedException", "{", "MavenArtifactUrlReference", "karafUrl", "=", "maven", "(", ")", ".", "groupId", "(", "\"", "org.apache.unomi", "\"", ")", ".", "artifactId", "(", "\"", "unomi", "\"", ")", ".", "type", "(", "\"", "tar.gz", "\"", ")", ".", "versionAsInProject", "(", ")", ";", "MavenUrlReference", "routerRepo", "=", "maven", "(", ")", ".", "groupId", "(", "\"", "org.apache.unomi", "\"", ")", ".", "artifactId", "(", "\"", "unomi-router-karaf-feature", "\"", ")", ".", "classifier", "(", "\"", "features", "\"", ")", ".", "type", "(", "\"", "xml", "\"", ")", ".", "versionAsInProject", "(", ")", ";", "List", "<", "Option", ">", "options", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Option", "[", "]", "commonOptions", "=", "new", "Option", "[", "]", "{", "karafDistributionConfiguration", "(", ")", ".", "frameworkUrl", "(", "karafUrl", ")", ".", "unpackDirectory", "(", "new", "File", "(", "KARAF_DIR", ")", ")", ".", "useDeployFolder", "(", "true", ")", ",", "replaceConfigurationFile", "(", "\"", "etc/org.apache.unomi.router.cfg", "\"", ",", "new", "File", "(", "\"", "src/test/resources/org.apache.unomi.router.cfg", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/1-basic-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/1-basic-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/2-surfers-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/2-surfers-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/3-surfers-overwrite-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/3-surfers-overwrite-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/4-surfers-delete-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/4-surfers-delete-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/5-ranking-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/5-ranking-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/recurrent_import/6-actors-test.csv", "\"", ",", "new", "File", "(", "\"", "src/test/resources/6-actors-test.csv", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/testLogin.json", "\"", ",", "new", "File", "(", "\"", "src/test/resources/testLogin.json", "\"", ")", ")", ",", "replaceConfigurationFile", "(", "\"", "data/tmp/testLoginEventCondition.json", "\"", ",", "new", "File", "(", "\"", "src/test/resources/testLoginEventCondition.json", "\"", ")", ")", ",", "keepRuntimeFolder", "(", ")", ",", "logLevel", "(", "LogLevel", ".", "INFO", ")", ",", "editConfigurationFilePut", "(", "\"", "etc/org.ops4j.pax.logging.cfg", "\"", ",", "\"", "log4j2.rootLogger.level", "\"", ",", "\"", "INFO", "\"", ")", ",", "editConfigurationFilePut", "(", "\"", "etc/org.apache.karaf.features.cfg", "\"", ",", "\"", "serviceRequirements", "\"", ",", "\"", "disable", "\"", ")", ",", "systemProperty", "(", "\"", "org.ops4j.pax.exam.rbc.rmi.port", "\"", ")", ".", "value", "(", "\"", "1199", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.itests.elasticsearch.transport.port", "\"", ")", ".", "value", "(", "\"", "9500", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.itests.elasticsearch.cluster.name", "\"", ")", ".", "value", "(", "\"", "contextElasticSearchITests", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.itests.elasticsearch.http.port", "\"", ")", ".", "value", "(", "\"", "9400", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.itests.elasticsearch.bootstrap.seccomp", "\"", ")", ".", "value", "(", "\"", "false", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.group.name", "\"", ")", ".", "value", "(", "\"", "cellar", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.group.password", "\"", ")", ".", "value", "(", "\"", "pass", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.network.port", "\"", ")", ".", "value", "(", "\"", "5701", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.tcp-ip.members", "\"", ")", ".", "value", "(", "\"", "127.0.0.1", "\"", ")", ",", "systemProperty", "(", "\"", "org.apache.unomi.hazelcast.tcp-ip.interface", "\"", ")", ".", "value", "(", "\"", "127.0.0.1", "\"", ")", ",", "systemProperty", "(", "\"", "unomi.autoStart", "\"", ")", ".", "value", "(", "\"", "true", "\"", ")", ",", "features", "(", "routerRepo", ",", "\"", "unomi-router-karaf-feature", "\"", ")", ",", "CoreOptions", ".", "bundleStartLevel", "(", "100", ")", ",", "CoreOptions", ".", "frameworkStartLevel", "(", "100", ")", "}", ";", "options", ".", "addAll", "(", "Arrays", ".", "asList", "(", "commonOptions", ")", ")", ";", "String", "karafDebug", "=", "System", ".", "getProperty", "(", "\"", "it.karaf.debug", "\"", ")", ";", "if", "(", "karafDebug", "!=", "null", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "Found system Karaf Debug system property, activating configuration: ", "\"", "+", "karafDebug", ")", ";", "String", "port", "=", "\"", "5006", "\"", ";", "boolean", "hold", "=", "true", ";", "if", "(", "karafDebug", ".", "trim", "(", ")", ".", "length", "(", ")", ">", "0", ")", "{", "String", "[", "]", "debugOptions", "=", "karafDebug", ".", "split", "(", "\"", ",", "\"", ")", ";", "for", "(", "String", "debugOption", ":", "debugOptions", ")", "{", "String", "[", "]", "debugOptionParts", "=", "debugOption", ".", "split", "(", "\"", ":", "\"", ")", ";", "if", "(", "\"", "hold", "\"", ".", "equals", "(", "debugOptionParts", "[", "0", "]", ")", ")", "{", "hold", "=", "Boolean", ".", "parseBoolean", "(", "debugOptionParts", "[", "1", "]", ".", "trim", "(", ")", ")", ";", "}", "if", "(", "\"", "port", "\"", ".", "equals", "(", "debugOptionParts", "[", "0", "]", ")", ")", "{", "port", "=", "debugOptionParts", "[", "1", "]", ".", "trim", "(", ")", ";", "}", "}", "}", "options", ".", "add", "(", "0", ",", "debugConfiguration", "(", "port", ",", "hold", ")", ")", ";", "}", "if", "(", "JavaVersionUtil", ".", "getMajorVersion", "(", ")", ">=", "9", ")", "{", "Option", "[", "]", "jdk9PlusOptions", "=", "new", "Option", "[", "]", "{", "new", "VMOption", "(", "\"", "--add-reads=java.xml=java.logging", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=java.base/org.apache.karaf.specs.locator=java.xml,ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--patch-module", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base=lib/endorsed/org.apache.karaf.specs.locator-", "\"", "+", "System", ".", "getProperty", "(", "\"", "karaf.version", "\"", ")", "+", "\"", ".jar", "\"", ")", ",", "new", "VMOption", "(", "\"", "--patch-module", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.xml=lib/endorsed/org.apache.karaf.specs.java.xml-", "\"", "+", "System", ".", "getProperty", "(", "\"", "karaf.version", "\"", ")", "+", "\"", ".jar", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base/java.security=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base/java.net=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base/java.lang=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.base/java.util=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.naming/javax.naming.spi=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-opens", "\"", ")", ",", "new", "VMOption", "(", "\"", "java.rmi/sun.rmi.transport.tcp=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=java.base/sun.net.www.protocol.http=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=java.base/sun.net.www.protocol.https=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=java.base/sun.net.www.protocol.jar=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "--add-exports=jdk.naming.rmi/com.sun.jndi.url.rmi=ALL-UNNAMED", "\"", ")", ",", "new", "VMOption", "(", "\"", "-classpath", "\"", ")", ",", "new", "VMOption", "(", "\"", "lib/jdk9plus/*", "\"", "+", "File", ".", "pathSeparator", "+", "\"", "lib/boot/*", "\"", ")", "}", ";", "options", ".", "addAll", "(", "Arrays", ".", "asList", "(", "jdk9PlusOptions", ")", ")", ";", "}", "return", "options", ".", "toArray", "(", "new", "Option", "[", "0", "]", ")", ";", "}"], "idx": 99569, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "789ae8e820c507866b9c91590feebffa4e996f5e", "function_name": "config", "body_hash": "9effd3e75aaa720005537987b545d250d6469203"}
{"code": "@Override\n    protected void connectInternal() throws SmackException, IOException, XMPPException {\n        // Establishes the TCP connection to the server and does setup the reader and writer. Throws an exception if\n        // there is an error establishing the connection\n        connectUsingConfiguration();\n\n        // We connected successfully to the servers TCP port\n        socketClosed = false;\n        initConnection();\n\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        // If TLS is required but the server doesn't offer it, disconnect\n        // from the server and throw an error. First check if we've already negotiated TLS\n        // and are secure, however (features get parsed a second time after TLS is established).\n        if (!isSecureConnection() && getConfiguration().getSecurityMode() == SecurityMode.required) {\n            shutdown();\n            throw new SecurityRequiredByClientException();\n        }\n\n        // Make note of the fact that we're now connected.\n        connected = true;\n        callConnectionConnectedListener();\n\n        // Automatically makes the login if the user was previously connected successfully\n        // to the server and the connection was terminated abruptly\n        if (wasAuthenticated) {\n            login();\n            notifyReconnection();\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "connectInternal", "(", ")", "throws", "SmackException", ",", "IOException", ",", "XMPPException", "{", "connectUsingConfiguration", "(", ")", ";", "socketClosed", "=", "false", ";", "initConnection", "(", ")", ";", "saslFeatureReceived", ".", "checkIfSuccessOrWaitOrThrow", "(", ")", ";", "if", "(", "!", "isSecureConnection", "(", ")", "&&", "getConfiguration", "(", ")", ".", "getSecurityMode", "(", ")", "==", "SecurityMode", ".", "required", ")", "{", "shutdown", "(", ")", ";", "throw", "new", "SecurityRequiredByClientException", "(", ")", ";", "}", "connected", "=", "true", ";", "callConnectionConnectedListener", "(", ")", ";", "if", "(", "wasAuthenticated", ")", "{", "login", "(", ")", ";", "notifyReconnection", "(", ")", ";", "}", "}"], "idx": 49380, "cwe": "CWE-362", "target": 0, "status": "FIXED", "commit": "059ee99ba0d5ff7758829acf5a9aeede09ec820b", "function_name": "connectInternal", "body_hash": "4ebefa6cdd5c3da262749957a487bd8452bd4f17"}
{"code": "public UploadFileResponse getCloudUrl(String contextPath, String uri, String finalFilePath, HttpServletRequest request) {\n        UploadFileResponse uploadFileResponse = new UploadFileResponse();\n        // try push to cloud\n        Map<String, String[]> map = new HashMap<>();\n        map.put(\"fileInfo\", new String[]{finalFilePath + \",\" + uri});\n        map.put(\"name\", new String[]{\"uploadService\"});\n        String url;\n        try {\n            List<Map> urls = HttpUtil.getInstance().sendGetRequest(Constants.pluginServer + \"/service\", map\n                    , new HttpJsonArrayHandle<Map>(), PluginHelper.genHeaderMapByRequest(request, AdminTokenThreadLocal.getUser())).getT();\n            if (urls != null && !urls.isEmpty()) {\n                url = (String) urls.get(0).get(\"url\");\n                if (!url.startsWith(\"https://\") && !url.startsWith(\"http://\")) {\n                    String tUrl = url;\n                    if (!url.startsWith(\"/\")) {\n                        tUrl = \"/\" + url;\n                    }\n                    url = contextPath + tUrl;\n                }\n            } else {\n                url = contextPath + uri;\n            }\n        } catch (Exception e) {\n            url = contextPath + uri;\n            LOGGER.error(e);\n        }\n        uploadFileResponse.setUrl(url);\n        return uploadFileResponse;\n    }", "code_tokens": ["public", "UploadFileResponse", "getCloudUrl", "(", "String", "contextPath", ",", "String", "uri", ",", "String", "finalFilePath", ",", "HttpServletRequest", "request", ")", "{", "UploadFileResponse", "uploadFileResponse", "=", "new", "UploadFileResponse", "(", ")", ";", "Map", "<", "String", ",", "String", "[", "]", ">", "map", "=", "new", "HashMap", "<", ">", "(", ")", ";", "map", ".", "put", "(", "\"", "fileInfo", "\"", ",", "new", "String", "[", "]", "{", "finalFilePath", "+", "\"", ",", "\"", "+", "uri", "}", ")", ";", "map", ".", "put", "(", "\"", "name", "\"", ",", "new", "String", "[", "]", "{", "\"", "uploadService", "\"", "}", ")", ";", "String", "url", ";", "try", "{", "List", "<", "Map", ">", "urls", "=", "HttpUtil", ".", "getInstance", "(", ")", ".", "sendGetRequest", "(", "Constants", ".", "pluginServer", "+", "\"", "/service", "\"", ",", "map", ",", "new", "HttpJsonArrayHandle", "<", "Map", ">", "(", ")", ",", "PluginHelper", ".", "genHeaderMapByRequest", "(", "request", ",", "AdminTokenThreadLocal", ".", "getUser", "(", ")", ")", ")", ".", "getT", "(", ")", ";", "if", "(", "urls", "!=", "null", "&&", "!", "urls", ".", "isEmpty", "(", ")", ")", "{", "url", "=", "(", "String", ")", "urls", ".", "get", "(", "0", ")", ".", "get", "(", "\"", "url", "\"", ")", ";", "if", "(", "!", "url", ".", "startsWith", "(", "\"", "https://", "\"", ")", "&&", "!", "url", ".", "startsWith", "(", "\"", "http://", "\"", ")", ")", "{", "String", "tUrl", "=", "url", ";", "if", "(", "!", "url", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "{", "tUrl", "=", "\"", "/", "\"", "+", "url", ";", "}", "url", "=", "contextPath", "+", "tUrl", ";", "}", "}", "else", "{", "url", "=", "contextPath", "+", "uri", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "url", "=", "contextPath", "+", "uri", ";", "LOGGER", ".", "error", "(", "e", ")", ";", "}", "uploadFileResponse", ".", "setUrl", "(", "url", ")", ";", "return", "uploadFileResponse", ";", "}"], "idx": 89512, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "b2b4415e2e59b6f18b0a62b633e71c96d63c43ba", "function_name": "getCloudUrl", "body_hash": "7c860512a4548326cde15647cd53a76ca8f4f95b"}
{"code": "@Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (StringUtils.isNotEmpty(url)) {\n            try {\n                String unescapedURL = URLDecoder.decode(url, StandardCharsets.UTF_8.name());\n                /*\n                    StringEscapeUtils is deprecated starting with version 3.6 of commons-lang3, however the indicated replacement comes from\n                    commons-text, which is not an OSGi bundle\n                */\n                unescapedURL = StringEscapeUtils.unescapeXml(unescapedURL);\n                // Percent-encode characters that are not allowed in unquoted\n                // HTML attributes: \", ', >, <, ` and space. We don't encode =\n                // since this would break links with query parameters.\n                String encodedUrl = unescapedURL.replaceAll(\"\\\"\", \"%22\")\n                        .replaceAll(\"'\", \"%27\")\n                        .replaceAll(\">\", \"%3E\")\n                        .replaceAll(\"<\", \"%3C\")\n                        .replaceAll(\"`\", \"%60\")\n                        .replaceAll(\" \", \"%20\");\n                int qMarkIx = encodedUrl.indexOf('?');\n                if (qMarkIx > 0) {\n                    encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n                }\n\n                encodedUrl = mangleNamespaces(encodedUrl);\n                if (xssFilter.isValidHref(encodedUrl)) {\n                    return encodedUrl;\n                }\n            } catch (UnsupportedEncodingException e) {\n                LOGGER.error(\"Unable to decode url: {}.\", url);\n            }\n        }\n        // fall through to empty string\n        return \"\";\n    }", "code_tokens": ["@", "Override", "@", "Nonnull", "public", "String", "getValidHref", "(", "final", "String", "url", ")", "{", "if", "(", "StringUtils", ".", "isNotEmpty", "(", "url", ")", ")", "{", "try", "{", "String", "unescapedURL", "=", "URLDecoder", ".", "decode", "(", "url", ",", "StandardCharsets", ".", "UTF_8", ".", "name", "(", ")", ")", ";", "unescapedURL", "=", "StringEscapeUtils", ".", "unescapeXml", "(", "unescapedURL", ")", ";", "String", "encodedUrl", "=", "unescapedURL", ".", "replaceAll", "(", "\"", "\\\"", "\"", ",", "\"", "%22", "\"", ")", ".", "replaceAll", "(", "\"", "'", "\"", ",", "\"", "%27", "\"", ")", ".", "replaceAll", "(", "\"", ">", "\"", ",", "\"", "%3E", "\"", ")", ".", "replaceAll", "(", "\"", "<", "\"", ",", "\"", "%3C", "\"", ")", ".", "replaceAll", "(", "\"", "`", "\"", ",", "\"", "%60", "\"", ")", ".", "replaceAll", "(", "\"", " ", "\"", ",", "\"", "%20", "\"", ")", ";", "int", "qMarkIx", "=", "encodedUrl", ".", "indexOf", "(", "'?'", ")", ";", "if", "(", "qMarkIx", ">", "0", ")", "{", "encodedUrl", "=", "encodedUrl", ".", "substring", "(", "0", ",", "qMarkIx", ")", "+", "encodedUrl", ".", "substring", "(", "qMarkIx", ")", ".", "replaceAll", "(", "\"", ":", "\"", ",", "\"", "%3A", "\"", ")", ";", "}", "encodedUrl", "=", "mangleNamespaces", "(", "encodedUrl", ")", ";", "if", "(", "xssFilter", ".", "isValidHref", "(", "encodedUrl", ")", ")", "{", "return", "encodedUrl", ";", "}", "}", "catch", "(", "UnsupportedEncodingException", "e", ")", "{", "LOGGER", ".", "error", "(", "\"", "Unable to decode url: {}.", "\"", ",", "url", ")", ";", "}", "}", "return", "\"", "\"", ";", "}"], "idx": 80968, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "ec6764d165abc4df8cffd8439761bb2228887db9", "function_name": "getValidHref", "body_hash": "168c3a550ff6a5d6b318c0a7c476a04e779eb662"}
{"code": "protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #{}: {}\", i, part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #{}: is mimetype: multipart/*\", i);\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = FileUtil.stripPath(part.getFileName());\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                        final DataHandler dataHandler = part.getDataHandler();\n                        final DataSource dataSource = dataHandler.getDataSource();\n\n                        final DataHandler replacement = new DataHandler(new DelegatingDataSource(fileName, dataSource));\n                        DefaultAttachment camelAttachment = new DefaultAttachment(replacement);\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "extractAttachmentsFromMultipart", "(", "Multipart", "mp", ",", "Map", "<", "String", ",", "Attachment", ">", "map", ")", "throws", "MessagingException", ",", "IOException", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "mp", ".", "getCount", "(", ")", ";", "i", "++", ")", "{", "Part", "part", "=", "mp", ".", "getBodyPart", "(", "i", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: {}", "\"", ",", "i", ",", "part", ")", ";", "if", "(", "part", ".", "isMimeType", "(", "\"", "multipart/*", "\"", ")", ")", "{", "LOG", ".", "trace", "(", "\"", "Part #{}: is mimetype: multipart/*", "\"", ",", "i", ")", ";", "extractAttachmentsFromMultipart", "(", "(", "Multipart", ")", "part", ".", "getContent", "(", ")", ",", "map", ")", ";", "}", "else", "{", "String", "disposition", "=", "part", ".", "getDisposition", "(", ")", ";", "String", "fileName", "=", "FileUtil", ".", "stripPath", "(", "part", ".", "getFileName", "(", ")", ")", ";", "if", "(", "LOG", ".", "isTraceEnabled", "(", ")", ")", "{", "LOG", ".", "trace", "(", "\"", "Part #{}: Disposition: {}", "\"", ",", "i", ",", "disposition", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: Description: {}", "\"", ",", "i", ",", "part", ".", "getDescription", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: ContentType: {}", "\"", ",", "i", ",", "part", ".", "getContentType", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: FileName: {}", "\"", ",", "i", ",", "fileName", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: Size: {}", "\"", ",", "i", ",", "part", ".", "getSize", "(", ")", ")", ";", "LOG", ".", "trace", "(", "\"", "Part #{}: LineCount: {}", "\"", ",", "i", ",", "part", ".", "getLineCount", "(", ")", ")", ";", "}", "if", "(", "validDisposition", "(", "disposition", ",", "fileName", ")", "||", "fileName", "!=", "null", ")", "{", "LOG", ".", "debug", "(", "\"", "Mail contains file attachment: {}", "\"", ",", "fileName", ")", ";", "if", "(", "!", "map", ".", "containsKey", "(", "fileName", ")", ")", "{", "final", "DataHandler", "dataHandler", "=", "part", ".", "getDataHandler", "(", ")", ";", "final", "DataSource", "dataSource", "=", "dataHandler", ".", "getDataSource", "(", ")", ";", "final", "DataHandler", "replacement", "=", "new", "DataHandler", "(", "new", "DelegatingDataSource", "(", "fileName", ",", "dataSource", ")", ")", ";", "DefaultAttachment", "camelAttachment", "=", "new", "DefaultAttachment", "(", "replacement", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Enumeration", "<", "Header", ">", "headers", "=", "part", ".", "getAllHeaders", "(", ")", ";", "while", "(", "headers", ".", "hasMoreElements", "(", ")", ")", "{", "Header", "header", "=", "headers", ".", "nextElement", "(", ")", ";", "camelAttachment", ".", "addHeader", "(", "header", ".", "getName", "(", ")", ",", "header", ".", "getValue", "(", ")", ")", ";", "}", "map", ".", "put", "(", "fileName", ",", "camelAttachment", ")", ";", "}", "else", "{", "LOG", ".", "warn", "(", "\"", "Cannot extract duplicate file attachment: {}.", "\"", ",", "fileName", ")", ";", "}", "}", "}", "}", "}"], "idx": 21184, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "4580e4d6c65cfd544c1791c824b5819477c583c", "function_name": "extractAttachmentsFromMultipart", "body_hash": "8b46554d7bf2c64732200376b5e7bc727c2c4a53"}
{"code": "private ResetPasswordResponse changePasswordCodeAuthenticated(String code, String newPassword) {\n        ExpiringCode expiringCode = expiringCodeStore.retrieveCode(code);\n        if (expiringCode == null) {\n            throw new InvalidCodeException(\"invalid_code\", \"Sorry, your reset password link is no longer valid. Please request a new one\", 422);\n        }\n        String userId;\n        String userName = null;\n        Date passwordLastModified = null;\n        String clientId = null;\n        String redirectUri = null;\n        try {\n            PasswordChange change = JsonUtils.readValue(expiringCode.getData(), PasswordChange.class);\n            userId = change.getUserId();\n            userName = change.getUsername();\n            passwordLastModified = change.getPasswordModifiedTime();\n            clientId = change.getClientId();\n            redirectUri = change.getRedirectUri();\n        } catch (JsonUtils.JsonUtilException x) {\n            userId = expiringCode.getData();\n        }\n        ScimUser user = scimUserProvisioning.retrieve(userId);\n        try {\n            if (isUserModified(user, expiringCode.getExpiresAt(), userName, passwordLastModified)) {\n                throw new UaaException(\"Invalid password reset request.\");\n            }\n            if (!user.isVerified()) {\n                scimUserProvisioning.verifyUser(userId, -1);\n            }\n            if (scimUserProvisioning.checkPasswordMatches(userId, newPassword)) {\n                throw new InvalidPasswordException(\"Your new password cannot be the same as the old password.\", UNPROCESSABLE_ENTITY);\n            }\n            scimUserProvisioning.changePassword(userId, null, newPassword);\n            publish(new PasswordChangeEvent(\"Password changed\", getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n\n            String redirectLocation = \"home\";\n            if (!isEmpty(clientId) && !isEmpty(redirectUri)) {\n                try {\n                    ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n                    Set<String> redirectUris = clientDetails.getRegisteredRedirectUri() == null ? Collections.emptySet() :\n                        clientDetails.getRegisteredRedirectUri();\n                    String matchingRedirectUri = UaaUrlUtils.findMatchingRedirectUri(redirectUris, redirectUri, null);\n                    if (matchingRedirectUri != null) {\n                        redirectLocation = matchingRedirectUri;\n                    }\n                } catch (NoSuchClientException nsce) {}\n            }\n            return new ResetPasswordResponse(user, redirectLocation, clientId);\n        } catch (Exception e) {\n            publish(new PasswordChangeFailureEvent(e.getMessage(), getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n            throw e;\n        }\n    }", "code_tokens": ["private", "ResetPasswordResponse", "changePasswordCodeAuthenticated", "(", "String", "code", ",", "String", "newPassword", ")", "{", "ExpiringCode", "expiringCode", "=", "expiringCodeStore", ".", "retrieveCode", "(", "code", ")", ";", "if", "(", "expiringCode", "==", "null", ")", "{", "throw", "new", "InvalidCodeException", "(", "\"", "invalid_code", "\"", ",", "\"", "Sorry, your reset password link is no longer valid. Please request a new one", "\"", ",", "422", ")", ";", "}", "String", "userId", ";", "String", "userName", "=", "null", ";", "Date", "passwordLastModified", "=", "null", ";", "String", "clientId", "=", "null", ";", "String", "redirectUri", "=", "null", ";", "try", "{", "PasswordChange", "change", "=", "JsonUtils", ".", "readValue", "(", "expiringCode", ".", "getData", "(", ")", ",", "PasswordChange", ".", "class", ")", ";", "userId", "=", "change", ".", "getUserId", "(", ")", ";", "userName", "=", "change", ".", "getUsername", "(", ")", ";", "passwordLastModified", "=", "change", ".", "getPasswordModifiedTime", "(", ")", ";", "clientId", "=", "change", ".", "getClientId", "(", ")", ";", "redirectUri", "=", "change", ".", "getRedirectUri", "(", ")", ";", "}", "catch", "(", "JsonUtils", ".", "JsonUtilException", "x", ")", "{", "userId", "=", "expiringCode", ".", "getData", "(", ")", ";", "}", "ScimUser", "user", "=", "scimUserProvisioning", ".", "retrieve", "(", "userId", ")", ";", "try", "{", "if", "(", "isUserModified", "(", "user", ",", "expiringCode", ".", "getExpiresAt", "(", ")", ",", "userName", ",", "passwordLastModified", ")", ")", "{", "throw", "new", "UaaException", "(", "\"", "Invalid password reset request.", "\"", ")", ";", "}", "if", "(", "!", "user", ".", "isVerified", "(", ")", ")", "{", "scimUserProvisioning", ".", "verifyUser", "(", "userId", ",", "-", "1", ")", ";", "}", "if", "(", "scimUserProvisioning", ".", "checkPasswordMatches", "(", "userId", ",", "newPassword", ")", ")", "{", "throw", "new", "InvalidPasswordException", "(", "\"", "Your new password cannot be the same as the old password.", "\"", ",", "UNPROCESSABLE_ENTITY", ")", ";", "}", "scimUserProvisioning", ".", "changePassword", "(", "userId", ",", "null", ",", "newPassword", ")", ";", "publish", "(", "new", "PasswordChangeEvent", "(", "\"", "Password changed", "\"", ",", "getUaaUser", "(", "user", ")", ",", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "getAuthentication", "(", ")", ")", ")", ";", "String", "redirectLocation", "=", "\"", "home", "\"", ";", "if", "(", "!", "isEmpty", "(", "clientId", ")", "&&", "!", "isEmpty", "(", "redirectUri", ")", ")", "{", "try", "{", "ClientDetails", "clientDetails", "=", "clientDetailsService", ".", "loadClientByClientId", "(", "clientId", ")", ";", "Set", "<", "String", ">", "redirectUris", "=", "clientDetails", ".", "getRegisteredRedirectUri", "(", ")", "==", "null", "?", "Collections", ".", "emptySet", "(", ")", ":", "clientDetails", ".", "getRegisteredRedirectUri", "(", ")", ";", "String", "matchingRedirectUri", "=", "UaaUrlUtils", ".", "findMatchingRedirectUri", "(", "redirectUris", ",", "redirectUri", ",", "null", ")", ";", "if", "(", "matchingRedirectUri", "!=", "null", ")", "{", "redirectLocation", "=", "matchingRedirectUri", ";", "}", "}", "catch", "(", "NoSuchClientException", "nsce", ")", "{", "}", "}", "return", "new", "ResetPasswordResponse", "(", "user", ",", "redirectLocation", ",", "clientId", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "publish", "(", "new", "PasswordChangeFailureEvent", "(", "e", ".", "getMessage", "(", ")", ",", "getUaaUser", "(", "user", ")", ",", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "getAuthentication", "(", ")", ")", ")", ";", "throw", "e", ";", "}", "}"], "idx": 33898, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "66132926f1bac0b878da5841be2f93fa5075d88f", "function_name": "changePasswordCodeAuthenticated", "body_hash": "0a12cba52a2b0c7cb5e09e1d714f5313253c6ce2"}
{"code": "protected DocumentBuilder getDocumentBuilder() throws IOException {\n        DocumentBuilder result = null;\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(isNamespaceAware());\n            dbf.setValidating(isValidatingDtd());\n            dbf.setCoalescing(isCoalescing());\n            dbf.setExpandEntityReferences(false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\",isExpandingEntityRefs());\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\",isExpandingEntityRefs());\n            \n            dbf.setIgnoringComments(isIgnoringComments());\n            dbf.setIgnoringElementContentWhitespace(isIgnoringExtraWhitespaces());\n\n            try {\n                dbf.setXIncludeAware(isXIncludeAware());\n            } catch (UnsupportedOperationException uoe) {\n                Context.getCurrentLogger().log(Level.FINE,\n                        \"The JAXP parser doesn't support XInclude.\", uoe);\n            }\n\n            // [ifndef android]\n            javax.xml.validation.Schema xsd = getSchema();\n\n            if (xsd != null) {\n                dbf.setSchema(xsd);\n            }\n            // [enddef]\n\n            result = dbf.newDocumentBuilder();\n            result.setEntityResolver(getEntityResolver());\n            result.setErrorHandler(getErrorHandler());\n        } catch (ParserConfigurationException pce) {\n            throw new IOException(\"Couldn't create the empty document: \"\n                    + pce.getMessage());\n        }\n\n        return result;\n    }", "code_tokens": ["protected", "DocumentBuilder", "getDocumentBuilder", "(", ")", "throws", "IOException", "{", "DocumentBuilder", "result", "=", "null", ";", "try", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "dbf", ".", "setNamespaceAware", "(", "isNamespaceAware", "(", ")", ")", ";", "dbf", ".", "setValidating", "(", "isValidatingDtd", "(", ")", ")", ";", "dbf", ".", "setCoalescing", "(", "isCoalescing", "(", ")", ")", ";", "dbf", ".", "setExpandEntityReferences", "(", "false", ")", ";", "dbf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "isExpandingEntityRefs", "(", ")", ")", ";", "dbf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "isExpandingEntityRefs", "(", ")", ")", ";", "dbf", ".", "setIgnoringComments", "(", "isIgnoringComments", "(", ")", ")", ";", "dbf", ".", "setIgnoringElementContentWhitespace", "(", "isIgnoringExtraWhitespaces", "(", ")", ")", ";", "try", "{", "dbf", ".", "setXIncludeAware", "(", "isXIncludeAware", "(", ")", ")", ";", "}", "catch", "(", "UnsupportedOperationException", "uoe", ")", "{", "Context", ".", "getCurrentLogger", "(", ")", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "The JAXP parser doesn't support XInclude.", "\"", ",", "uoe", ")", ";", "}", "javax", ".", "xml", ".", "validation", ".", "Schema", "xsd", "=", "getSchema", "(", ")", ";", "if", "(", "xsd", "!=", "null", ")", "{", "dbf", ".", "setSchema", "(", "xsd", ")", ";", "}", "result", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "result", ".", "setEntityResolver", "(", "getEntityResolver", "(", ")", ")", ";", "result", ".", "setErrorHandler", "(", "getErrorHandler", "(", ")", ")", ";", "}", "catch", "(", "ParserConfigurationException", "pce", ")", "{", "throw", "new", "IOException", "(", "\"", "Couldn't create the empty document: ", "\"", "+", "pce", ".", "getMessage", "(", ")", ")", ";", "}", "return", "result", ";", "}"], "idx": 67901, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "97a8d1d62612683817c785e99c4166bcde8cf1c", "function_name": "getDocumentBuilder", "body_hash": "ac20807a5e3efdc3edb305c86766e15e8ed44f07"}
{"code": "@Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }\n                protected Collection<TopLevelItem> all() { return getAllItems(TopLevelItem.class); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {// for computers\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {// for users\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {// for views\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return views; }\n            });\n    }", "code_tokens": ["@", "Override", "public", "SearchIndexBuilder", "makeSearchIndex", "(", ")", "{", "return", "super", ".", "makeSearchIndex", "(", ")", ".", "add", "(", "\"", "configure", "\"", ",", "\"", "config", "\"", ",", "\"", "configure", "\"", ")", ".", "add", "(", "\"", "manage", "\"", ")", ".", "add", "(", "\"", "log", "\"", ")", ".", "add", "(", "new", "CollectionSearchIndex", "<", "TopLevelItem", ">", "(", ")", "{", "protected", "SearchItem", "get", "(", "String", "key", ")", "{", "return", "getItemByFullName", "(", "key", ",", "TopLevelItem", ".", "class", ")", ";", "}", "protected", "Collection", "<", "TopLevelItem", ">", "all", "(", ")", "{", "return", "getAllItems", "(", "TopLevelItem", ".", "class", ")", ";", "}", "}", ")", ".", "add", "(", "getPrimaryView", "(", ")", ".", "makeSearchIndex", "(", ")", ")", ".", "add", "(", "new", "CollectionSearchIndex", "(", ")", "{", "protected", "Computer", "get", "(", "String", "key", ")", "{", "return", "getComputer", "(", "key", ")", ";", "}", "protected", "Collection", "<", "Computer", ">", "all", "(", ")", "{", "return", "computers", ".", "values", "(", ")", ";", "}", "}", ")", ".", "add", "(", "new", "CollectionSearchIndex", "(", ")", "{", "protected", "User", "get", "(", "String", "key", ")", "{", "return", "User", ".", "get", "(", "key", ",", "false", ")", ";", "}", "protected", "Collection", "<", "User", ">", "all", "(", ")", "{", "return", "User", ".", "getAll", "(", ")", ";", "}", "}", ")", ".", "add", "(", "new", "CollectionSearchIndex", "(", ")", "{", "protected", "View", "get", "(", "String", "key", ")", "{", "return", "getView", "(", "key", ")", ";", "}", "protected", "Collection", "<", "View", ">", "all", "(", ")", "{", "return", "views", ";", "}", "}", ")", ";", "}"], "idx": 13364, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "246a0fa90a05b729eaabca6d697016015f622e57", "function_name": "makeSearchIndex", "body_hash": "9acfeb6ccc53e513f75879ad96d39aa7d78bbe5a"}
{"code": "private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n        String url = httpServletRequest.getRequestURI();\n        String urlStart = \"/navigate/directions/v5/gh/\" + profile + \"/\";\n        if (!url.startsWith(urlStart)) throw new IllegalArgumentException(\"Incorrect URL \" + url);\n        url = url.substring(urlStart.length());\n        String[] pointStrings = url.split(\";\");\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n    }", "code_tokens": ["private", "List", "<", "GHPoint", ">", "getPointsFromRequest", "(", "HttpServletRequest", "httpServletRequest", ",", "String", "profile", ")", "{", "String", "url", "=", "httpServletRequest", ".", "getRequestURI", "(", ")", ";", "String", "urlStart", "=", "\"", "/navigate/directions/v5/gh/", "\"", "+", "profile", "+", "\"", "/", "\"", ";", "if", "(", "!", "url", ".", "startsWith", "(", "urlStart", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"", "Incorrect URL ", "\"", "+", "url", ")", ";", "url", "=", "url", ".", "substring", "(", "urlStart", ".", "length", "(", ")", ")", ";", "String", "[", "]", "pointStrings", "=", "url", ".", "split", "(", "\"", ";", "\"", ")", ";", "List", "<", "GHPoint", ">", "points", "=", "new", "ArrayList", "<", ">", "(", "pointStrings", ".", "length", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pointStrings", ".", "length", ";", "i", "++", ")", "{", "points", ".", "add", "(", "GHPoint", ".", "fromStringLonLat", "(", "pointStrings", "[", "i", "]", ")", ")", ";", "}", "return", "points", ";", "}"], "idx": 52625, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "eb189be1fa7443ebf4ae881e737a18f818c95f41", "function_name": "getPointsFromRequest", "body_hash": "ef66fec83415afc9f650f94e818941b4782cdb35"}
{"code": "@Test(expected = CryptoException.class)\n    public void getRememberedPrincipalsNoMoreDefaultCipher() {\n        HttpServletRequest mockRequest = createMock(HttpServletRequest.class);\n        HttpServletResponse mockResponse = createMock(HttpServletResponse.class);\n        WebSubjectContext context = new DefaultWebSubjectContext();\n        context.setServletRequest(mockRequest);\n        context.setServletResponse(mockResponse);\n\n        expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);\n        expect(mockRequest.getContextPath()).andReturn( \"/test\" );\n\n\n        //The following base64 string was determined from the log output of the above 'onSuccessfulLogin' test.\n        //This will have to change any time the PrincipalCollection implementation changes:\n        final String userPCAesBase64 = \"WlD5MLzzZznN3dQ1lPJO/eScSuY245k29aECNmjUs31o7Yu478hWhaM5Sj\" +\n            \"jmoe900/72JNu3hcJaPG6Q17Vuz4F8x0kBjbFnPVx4PqzsZYT6yreeS2jwO6OwfI+efqXOKyB2a5KPtnr\" +\n            \"7jt5kZsyH38XJISb81cf6xqTGUru8zC+kNqJFz7E5RpO0kraBofS5jhMm45gDVjDRkjgPJAzocVWMtrza\" +\n            \"zy67P8eb+kMSBCqGI251JTNAGboVgQ28KjfaAJ/6LXRJUj7kB7CGia7mgRk+hxzEJGDs81at5VOPqODJr\" +\n            \"xb8tcIdemFUFIkiYVP9bGs4dP3ECtmw7aNrCzv+84sx3vRFUrd5DbDYpEuE12hF2Y9owDK9sxStbXoF0y\" +\n            \"A32dhfGDIqS+agsass0sWn8WX2TM9i8SxrUjiFbxqyIG49HbqGrZp5QLM9IuIwO+TzGfF1FzumQGdwmWT\" +\n            \"xkVapw5UESl34YvA615cb+82ue1I=\";\n\n        Cookie[] cookies = new Cookie[]{\n            new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64)\n        };\n\n        expect(mockRequest.getCookies()).andReturn(cookies);\n        replay(mockRequest);\n\n        CookieRememberMeManager mgr = new CookieRememberMeManager();\n        // without the old default cipher set, this will fail (expected)\n        // mgr.setCipherKey( Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"));\n        // this will throw a CryptoException\n        mgr.getRememberedPrincipals(context);\n    }", "code_tokens": ["@", "Test", "(", "expected", "=", "CryptoException", ".", "class", ")", "public", "void", "getRememberedPrincipalsNoMoreDefaultCipher", "(", ")", "{", "HttpServletRequest", "mockRequest", "=", "createMock", "(", "HttpServletRequest", ".", "class", ")", ";", "HttpServletResponse", "mockResponse", "=", "createMock", "(", "HttpServletResponse", ".", "class", ")", ";", "WebSubjectContext", "context", "=", "new", "DefaultWebSubjectContext", "(", ")", ";", "context", ".", "setServletRequest", "(", "mockRequest", ")", ";", "context", ".", "setServletResponse", "(", "mockResponse", ")", ";", "expect", "(", "mockRequest", ".", "getAttribute", "(", "ShiroHttpServletRequest", ".", "IDENTITY_REMOVED_KEY", ")", ")", ".", "andReturn", "(", "null", ")", ";", "expect", "(", "mockRequest", ".", "getContextPath", "(", ")", ")", ".", "andReturn", "(", "\"", "/test", "\"", ")", ";", "final", "String", "userPCAesBase64", "=", "\"", "WlD5MLzzZznN3dQ1lPJO/eScSuY245k29aECNmjUs31o7Yu478hWhaM5Sj", "\"", "+", "\"", "jmoe900/72JNu3hcJaPG6Q17Vuz4F8x0kBjbFnPVx4PqzsZYT6yreeS2jwO6OwfI+efqXOKyB2a5KPtnr", "\"", "+", "\"", "7jt5kZsyH38XJISb81cf6xqTGUru8zC+kNqJFz7E5RpO0kraBofS5jhMm45gDVjDRkjgPJAzocVWMtrza", "\"", "+", "\"", "zy67P8eb+kMSBCqGI251JTNAGboVgQ28KjfaAJ/6LXRJUj7kB7CGia7mgRk+hxzEJGDs81at5VOPqODJr", "\"", "+", "\"", "xb8tcIdemFUFIkiYVP9bGs4dP3ECtmw7aNrCzv+84sx3vRFUrd5DbDYpEuE12hF2Y9owDK9sxStbXoF0y", "\"", "+", "\"", "A32dhfGDIqS+agsass0sWn8WX2TM9i8SxrUjiFbxqyIG49HbqGrZp5QLM9IuIwO+TzGfF1FzumQGdwmWT", "\"", "+", "\"", "xkVapw5UESl34YvA615cb+82ue1I=", "\"", ";", "Cookie", "[", "]", "cookies", "=", "new", "Cookie", "[", "]", "{", "new", "Cookie", "(", "CookieRememberMeManager", ".", "DEFAULT_REMEMBER_ME_COOKIE_NAME", ",", "userPCAesBase64", ")", "}", ";", "expect", "(", "mockRequest", ".", "getCookies", "(", ")", ")", ".", "andReturn", "(", "cookies", ")", ";", "replay", "(", "mockRequest", ")", ";", "CookieRememberMeManager", "mgr", "=", "new", "CookieRememberMeManager", "(", ")", ";", "mgr", ".", "getRememberedPrincipals", "(", "context", ")", ";", "}"], "idx": 109403, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "a8018783373ff5e5210225069c9919e071597d5e", "function_name": "getRememberedPrincipalsNoMoreDefaultCipher", "body_hash": "3c5a9053a42ef787bd4b212b449969d9aa99fc45"}
{"code": "public Object getBody() throws JMSException {\n        Message message = getMessage();\n        if (message instanceof TextMessage) {\n            return ((TextMessage) message).getText();\n        }\n        if (message instanceof ObjectMessage) {\n            try {\n                return ((ObjectMessage) message).getObject();\n            } catch (JMSException e) {\n                //message could not be parsed, make the reason available\n                return e;\n            }\n        }\n        if (message instanceof MapMessage) {\n            return createMapBody((MapMessage) message);\n        }\n        if (message instanceof BytesMessage) {\n            BytesMessage msg = (BytesMessage) message;\n            int len = (int) msg.getBodyLength();\n            if (len > -1) {\n                byte[] data = new byte[len];\n                msg.readBytes(data);\n                return new String(data);\n            } else {\n                return \"\";\n            }\n        }\n        if (message instanceof StreamMessage) {\n            return \"StreamMessage is not viewable\";\n        }\n\n        // unknown message type\n        if (message != null) {\n            return \"Unknown message type [\" + message.getClass().getName() + \"] \" + message;\n        }\n\n        return null;\n    }", "code_tokens": ["public", "Object", "getBody", "(", ")", "throws", "JMSException", "{", "Message", "message", "=", "getMessage", "(", ")", ";", "if", "(", "message", "instanceof", "TextMessage", ")", "{", "return", "(", "(", "TextMessage", ")", "message", ")", ".", "getText", "(", ")", ";", "}", "if", "(", "message", "instanceof", "ObjectMessage", ")", "{", "try", "{", "return", "(", "(", "ObjectMessage", ")", "message", ")", ".", "getObject", "(", ")", ";", "}", "catch", "(", "JMSException", "e", ")", "{", "return", "e", ";", "}", "}", "if", "(", "message", "instanceof", "MapMessage", ")", "{", "return", "createMapBody", "(", "(", "MapMessage", ")", "message", ")", ";", "}", "if", "(", "message", "instanceof", "BytesMessage", ")", "{", "BytesMessage", "msg", "=", "(", "BytesMessage", ")", "message", ";", "int", "len", "=", "(", "int", ")", "msg", ".", "getBodyLength", "(", ")", ";", "if", "(", "len", ">", "-", "1", ")", "{", "byte", "[", "]", "data", "=", "new", "byte", "[", "len", "]", ";", "msg", ".", "readBytes", "(", "data", ")", ";", "return", "new", "String", "(", "data", ")", ";", "}", "else", "{", "return", "\"", "\"", ";", "}", "}", "if", "(", "message", "instanceof", "StreamMessage", ")", "{", "return", "\"", "StreamMessage is not viewable", "\"", ";", "}", "if", "(", "message", "!=", "null", ")", "{", "return", "\"", "Unknown message type [", "\"", "+", "message", ".", "getClass", "(", ")", ".", "getName", "(", ")", "+", "\"", "] ", "\"", "+", "message", ";", "}", "return", "null", ";", "}"], "idx": 5522, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "6f03921b31d9fefeddb0f4fa63150ed1f94a14b", "function_name": "getBody", "body_hash": "f336a1454e3f2a14f642333e502725d9afa5e14f"}
{"code": "@SuppressWarnings(\"unchecked\")\n    private static Object parseParameter(Map<String, Object> context, Object value) {\n        if (value instanceof String) {\n            if (((String) value).startsWith(\"parameter::\") || ((String) value).startsWith(\"script::\")) {\n                String s = (String) value;\n                if (s.startsWith(\"parameter::\")) {\n                    return context.get(StringUtils.substringAfter(s, \"parameter::\"));\n                } else if (s.startsWith(\"script::\")) {\n                    String script = StringUtils.substringAfter(s, \"script::\");\n                    if (!mvelExpressions.containsKey(script)) {\n                        ParserConfiguration parserConfiguration = new ParserConfiguration();\n                        parserConfiguration.setClassLoader(ConditionContextHelper.class.getClassLoader());\n                        mvelExpressions.put(script,MVEL.compileExpression(script, new ParserContext(parserConfiguration)));\n                    }\n                    return MVEL.executeExpression(mvelExpressions.get(script), context);\n                }\n            }\n        } else if (value instanceof Map) {\n            Map<String, Object> values = new HashMap<String, Object>();\n            for (Map.Entry<String, Object> entry : ((Map<String, Object>) value).entrySet()) {\n                Object parameter = parseParameter(context, entry.getValue());\n                if (parameter == null) {\n                    return null;\n                }\n                values.put(entry.getKey(), parameter);\n            }\n            return values;\n        } else if (value instanceof List) {\n            List<Object> values = new ArrayList<Object>();\n            for (Object o : ((List<?>) value)) {\n                Object parameter = parseParameter(context, o);\n                if (parameter != null) {\n                    values.add(parameter);\n                }\n            }\n            return values;\n        }\n        return value;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "private", "static", "Object", "parseParameter", "(", "Map", "<", "String", ",", "Object", ">", "context", ",", "Object", "value", ")", "{", "if", "(", "value", "instanceof", "String", ")", "{", "if", "(", "(", "(", "String", ")", "value", ")", ".", "startsWith", "(", "\"", "parameter::", "\"", ")", "||", "(", "(", "String", ")", "value", ")", ".", "startsWith", "(", "\"", "script::", "\"", ")", ")", "{", "String", "s", "=", "(", "String", ")", "value", ";", "if", "(", "s", ".", "startsWith", "(", "\"", "parameter::", "\"", ")", ")", "{", "return", "context", ".", "get", "(", "StringUtils", ".", "substringAfter", "(", "s", ",", "\"", "parameter::", "\"", ")", ")", ";", "}", "else", "if", "(", "s", ".", "startsWith", "(", "\"", "script::", "\"", ")", ")", "{", "String", "script", "=", "StringUtils", ".", "substringAfter", "(", "s", ",", "\"", "script::", "\"", ")", ";", "if", "(", "!", "mvelExpressions", ".", "containsKey", "(", "script", ")", ")", "{", "ParserConfiguration", "parserConfiguration", "=", "new", "ParserConfiguration", "(", ")", ";", "parserConfiguration", ".", "setClassLoader", "(", "ConditionContextHelper", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "mvelExpressions", ".", "put", "(", "script", ",", "MVEL", ".", "compileExpression", "(", "script", ",", "new", "ParserContext", "(", "parserConfiguration", ")", ")", ")", ";", "}", "return", "MVEL", ".", "executeExpression", "(", "mvelExpressions", ".", "get", "(", "script", ")", ",", "context", ")", ";", "}", "}", "}", "else", "if", "(", "value", "instanceof", "Map", ")", "{", "Map", "<", "String", ",", "Object", ">", "values", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "entry", ":", "(", "(", "Map", "<", "String", ",", "Object", ">", ")", "value", ")", ".", "entrySet", "(", ")", ")", "{", "Object", "parameter", "=", "parseParameter", "(", "context", ",", "entry", ".", "getValue", "(", ")", ")", ";", "if", "(", "parameter", "==", "null", ")", "{", "return", "null", ";", "}", "values", ".", "put", "(", "entry", ".", "getKey", "(", ")", ",", "parameter", ")", ";", "}", "return", "values", ";", "}", "else", "if", "(", "value", "instanceof", "List", ")", "{", "List", "<", "Object", ">", "values", "=", "new", "ArrayList", "<", "Object", ">", "(", ")", ";", "for", "(", "Object", "o", ":", "(", "(", "List", "<", "?", ">", ")", "value", ")", ")", "{", "Object", "parameter", "=", "parseParameter", "(", "context", ",", "o", ")", ";", "if", "(", "parameter", "!=", "null", ")", "{", "values", ".", "add", "(", "parameter", ")", ";", "}", "}", "return", "values", ";", "}", "return", "value", ";", "}"], "idx": 102380, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "789ae8e820c507866b9c91590feebffa4e996f5e", "function_name": "parseParameter", "body_hash": "c507c836b42e9c30f58d932db3ed2813ab1b01a1"}
{"code": "@Override\n    public void validate() {\n        final String filter = FilterEncoder.format(ldapConfiguration.getUserSearchFilter(), \"test\");\n        ldapConnectionTemplate.searchFirst(ldapConfiguration.getSearchBases().get(0), filter, SearchScope.SUBTREE, entry -> entry);\n    }", "code_tokens": ["@", "Override", "public", "void", "validate", "(", ")", "{", "final", "String", "filter", "=", "FilterEncoder", ".", "format", "(", "ldapConfiguration", ".", "getUserSearchFilter", "(", ")", ",", "\"", "test", "\"", ")", ";", "ldapConnectionTemplate", ".", "searchFirst", "(", "ldapConfiguration", ".", "getSearchBases", "(", ")", ".", "get", "(", "0", ")", ",", "filter", ",", "SearchScope", ".", "SUBTREE", ",", "entry", "->", "entry", ")", ";", "}"], "idx": 73838, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "87fa7dac5d899b3960ab48e151881da4793cfcc3", "function_name": "validate", "body_hash": "eb886ddec31275d32bac10d7245a99bf495fc925"}
{"code": "@Override\n\tpublic OAuth2TokenValidatorResult validate(Jwt token) {\n\t\tAssert.notNull(token, \"token cannot be null\");\n\n\t\tif (this.issuer.equals(token.getIssuer())) {\n\t\t\treturn OAuth2TokenValidatorResult.success();\n\t\t} else {\n\t\t\treturn OAuth2TokenValidatorResult.failure(INVALID_ISSUER);\n\t\t}\n\t}", "code_tokens": ["@", "Override", "public", "OAuth2TokenValidatorResult", "validate", "(", "Jwt", "token", ")", "{", "Assert", ".", "notNull", "(", "token", ",", "\"", "token cannot be null", "\"", ")", ";", "if", "(", "this", ".", "issuer", ".", "equals", "(", "token", ".", "getIssuer", "(", ")", ")", ")", "{", "return", "OAuth2TokenValidatorResult", ".", "success", "(", ")", ";", "}", "else", "{", "return", "OAuth2TokenValidatorResult", ".", "failure", "(", "INVALID_ISSUER", ")", ";", "}", "}"], "idx": 42939, "cwe": "CWE-345", "target": 1, "status": "VULNERABLE", "commit": "c70b65c5df0e170a2d34d812b83db0b7bc71ea25", "function_name": "validate", "body_hash": "73b67af2782f467a37d54d67ad3cf670a604a01b"}
{"code": "@Test(timeout = 10000)\n    public void spliceToFile() throws Throwable {\n        EventLoopGroup group = new EpollEventLoopGroup(1);\n        File file = PlatformDependent.createTempFile(\"netty-splice\", null, null);\n        file.deleteOnExit();\n\n        SpliceHandler sh = new SpliceHandler(file);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.channel(EpollServerSocketChannel.class);\n        bs.group(group).childHandler(sh);\n        bs.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n        Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        Bootstrap cb = new Bootstrap();\n        cb.group(group);\n        cb.channel(EpollSocketChannel.class);\n        cb.handler(new ChannelInboundHandlerAdapter());\n        Channel cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();\n\n        for (int i = 0; i < data.length;) {\n            int length = Math.min(random.nextInt(1024 * 64), data.length - i);\n            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);\n            cc.writeAndFlush(buf);\n            i += length;\n        }\n\n        while (sh.future2 == null || !sh.future2.isDone() || !sh.future.isDone()) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        sc.close().sync();\n        cc.close().sync();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n\n        byte[] written = new byte[data.length];\n        FileInputStream in = new FileInputStream(file);\n\n        try {\n            Assert.assertEquals(written.length, in.read(written));\n            Assert.assertArrayEquals(data, written);\n        } finally {\n            in.close();\n            group.shutdownGracefully();\n        }\n    }", "code_tokens": ["@", "Test", "(", "timeout", "=", "10000", ")", "public", "void", "spliceToFile", "(", ")", "throws", "Throwable", "{", "EventLoopGroup", "group", "=", "new", "EpollEventLoopGroup", "(", "1", ")", ";", "File", "file", "=", "PlatformDependent", ".", "createTempFile", "(", "\"", "netty-splice", "\"", ",", "null", ",", "null", ")", ";", "file", ".", "deleteOnExit", "(", ")", ";", "SpliceHandler", "sh", "=", "new", "SpliceHandler", "(", "file", ")", ";", "ServerBootstrap", "bs", "=", "new", "ServerBootstrap", "(", ")", ";", "bs", ".", "channel", "(", "EpollServerSocketChannel", ".", "class", ")", ";", "bs", ".", "group", "(", "group", ")", ".", "childHandler", "(", "sh", ")", ";", "bs", ".", "childOption", "(", "EpollChannelOption", ".", "EPOLL_MODE", ",", "EpollMode", ".", "LEVEL_TRIGGERED", ")", ";", "Channel", "sc", "=", "bs", ".", "bind", "(", "NetUtil", ".", "LOCALHOST", ",", "0", ")", ".", "syncUninterruptibly", "(", ")", ".", "channel", "(", ")", ";", "Bootstrap", "cb", "=", "new", "Bootstrap", "(", ")", ";", "cb", ".", "group", "(", "group", ")", ";", "cb", ".", "channel", "(", "EpollSocketChannel", ".", "class", ")", ";", "cb", ".", "handler", "(", "new", "ChannelInboundHandlerAdapter", "(", ")", ")", ";", "Channel", "cc", "=", "cb", ".", "connect", "(", "sc", ".", "localAddress", "(", ")", ")", ".", "syncUninterruptibly", "(", ")", ".", "channel", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "data", ".", "length", ";", ")", "{", "int", "length", "=", "Math", ".", "min", "(", "random", ".", "nextInt", "(", "1024", "*", "64", ")", ",", "data", ".", "length", "-", "i", ")", ";", "ByteBuf", "buf", "=", "Unpooled", ".", "wrappedBuffer", "(", "data", ",", "i", ",", "length", ")", ";", "cc", ".", "writeAndFlush", "(", "buf", ")", ";", "i", "+=", "length", ";", "}", "while", "(", "sh", ".", "future2", "==", "null", "||", "!", "sh", ".", "future2", ".", "isDone", "(", ")", "||", "!", "sh", ".", "future", ".", "isDone", "(", ")", ")", "{", "if", "(", "sh", ".", "exception", ".", "get", "(", ")", "!=", "null", ")", "{", "break", ";", "}", "try", "{", "Thread", ".", "sleep", "(", "50", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "}", "}", "sc", ".", "close", "(", ")", ".", "sync", "(", ")", ";", "cc", ".", "close", "(", ")", ".", "sync", "(", ")", ";", "if", "(", "sh", ".", "exception", ".", "get", "(", ")", "!=", "null", "&&", "!", "(", "sh", ".", "exception", ".", "get", "(", ")", "instanceof", "IOException", ")", ")", "{", "throw", "sh", ".", "exception", ".", "get", "(", ")", ";", "}", "byte", "[", "]", "written", "=", "new", "byte", "[", "data", ".", "length", "]", ";", "FileInputStream", "in", "=", "new", "FileInputStream", "(", "file", ")", ";", "try", "{", "Assert", ".", "assertEquals", "(", "written", ".", "length", ",", "in", ".", "read", "(", "written", ")", ")", ";", "Assert", ".", "assertArrayEquals", "(", "data", ",", "written", ")", ";", "}", "finally", "{", "in", ".", "close", "(", ")", ";", "group", ".", "shutdownGracefully", "(", ")", ";", "}", "}"], "idx": 50042, "cwe": "CWE-378", "target": 0, "status": "FIXED", "commit": "c735357bf29d07856ad171c6611a2e1a0e0000ec", "function_name": "spliceToFile", "body_hash": "1191dcaa9767ee639dd50e3ff25c1e5f93eaeadf"}
{"code": "public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        // if there is no value - don't do comparison\n        // if a value is required, a required validator should be added to the field\n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value)).matches()) {\n            addFieldError(fieldName, object);\n        }\n    }", "code_tokens": ["public", "void", "validate", "(", "Object", "object", ")", "throws", "ValidationException", "{", "String", "fieldName", "=", "getFieldName", "(", ")", ";", "Object", "value", "=", "this", ".", "getFieldValue", "(", "fieldName", ",", "object", ")", ";", "if", "(", "value", "==", "null", "||", "value", ".", "toString", "(", ")", ".", "length", "(", ")", "==", "0", ")", "{", "return", ";", "}", "if", "(", "!", "(", "value", ".", "getClass", "(", ")", ".", "equals", "(", "String", ".", "class", ")", ")", "||", "!", "Pattern", ".", "compile", "(", "getUrlRegex", "(", ")", ",", "Pattern", ".", "CASE_INSENSITIVE", ")", ".", "matcher", "(", "String", ".", "valueOf", "(", "value", ")", ")", ".", "matches", "(", ")", ")", "{", "addFieldError", "(", "fieldName", ",", "object", ")", ";", "}", "}"], "idx": 6430, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "554b9dddb0fbd1e581ef577dd62a7c22955ad0f6", "function_name": "validate", "body_hash": "983117b2633338677f7c7cce13c50c5f5e2025a7"}
{"code": "private static byte[] getRandomKey(List<String> dataRefURIs, Document doc, WSDocInfo wsDocInfo) throws WSSecurityException {\n        try {\n            String alg = \"AES\";\n            int size = 128;\n            if (!dataRefURIs.isEmpty()) {\n                String uri = dataRefURIs.iterator().next();\n                Element ee = ReferenceListProcessor.findEncryptedDataElement(doc, wsDocInfo, uri);\n                String algorithmURI = X509Util.getEncAlgo(ee);\n                alg = JCEMapper.getJCEKeyAlgorithmFromURI(algorithmURI);\n                size = KeyUtils.getKeyLength(algorithmURI);\n            }\n            KeyGenerator kgen = KeyGenerator.getInstance(alg);\n            kgen.init(size * 8);\n            SecretKey k = kgen.generateKey();\n            return k.getEncoded();\n        } catch (Exception ex) {\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILED_CHECK, ex);\n        }\n    }", "code_tokens": ["private", "static", "byte", "[", "]", "getRandomKey", "(", "List", "<", "String", ">", "dataRefURIs", ",", "Document", "doc", ",", "WSDocInfo", "wsDocInfo", ")", "throws", "WSSecurityException", "{", "try", "{", "String", "alg", "=", "\"", "AES", "\"", ";", "int", "size", "=", "128", ";", "if", "(", "!", "dataRefURIs", ".", "isEmpty", "(", ")", ")", "{", "String", "uri", "=", "dataRefURIs", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "Element", "ee", "=", "ReferenceListProcessor", ".", "findEncryptedDataElement", "(", "doc", ",", "wsDocInfo", ",", "uri", ")", ";", "String", "algorithmURI", "=", "X509Util", ".", "getEncAlgo", "(", "ee", ")", ";", "alg", "=", "JCEMapper", ".", "getJCEKeyAlgorithmFromURI", "(", "algorithmURI", ")", ";", "size", "=", "KeyUtils", ".", "getKeyLength", "(", "algorithmURI", ")", ";", "}", "KeyGenerator", "kgen", "=", "KeyGenerator", ".", "getInstance", "(", "alg", ")", ";", "kgen", ".", "init", "(", "size", "*", "8", ")", ";", "SecretKey", "k", "=", "kgen", ".", "generateKey", "(", ")", ";", "return", "k", ".", "getEncoded", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILED_CHECK", ",", "ex", ")", ";", "}", "}"], "idx": 42558, "cwe": "CWE-327", "target": 1, "status": "VULNERABLE", "commit": "de5104b30", "function_name": "getRandomKey", "body_hash": "1b33813b73d99b75dd034211c289b70087af8a2c"}
{"code": "public void execute(ActionInvocation invocation) throws Exception {\n        ValueStack stack = ActionContext.getContext().getValueStack();\n        String finalNamespace = this.namespace != null\n            ? TextParseUtil.translateVariables(namespace, stack)\n            : invocation.getProxy().getNamespace();\n        String finalActionName = TextParseUtil.translateVariables(actionName, stack);\n        String finalMethodName = this.methodName != null\n            ? TextParseUtil.translateVariables(this.methodName, stack)\n            : null;\n\n        if (isInChainHistory(finalNamespace, finalActionName, finalMethodName)) {\n            addToHistory(finalNamespace, finalActionName, finalMethodName);\n            throw new XWorkException(\"Infinite recursion detected: \"\n                    + ActionChainResult.getChainHistory().toString());\n        }\n\n        if (ActionChainResult.getChainHistory().isEmpty() && invocation != null && invocation.getProxy() != null) {\n            addToHistory(finalNamespace, invocation.getProxy().getActionName(), invocation.getProxy().getMethod());\n        }\n        addToHistory(finalNamespace, finalActionName, finalMethodName);\n\n        HashMap<String, Object> extraContext = new HashMap<String, Object>();\n        extraContext.put(ActionContext.VALUE_STACK, ActionContext.getContext().getValueStack());\n        extraContext.put(ActionContext.PARAMETERS, ActionContext.getContext().getParameters());\n        extraContext.put(CHAIN_HISTORY, ActionChainResult.getChainHistory());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Chaining to action \" + finalActionName);\n        }\n\n        proxy = actionProxyFactory.createActionProxy(finalNamespace, finalActionName, finalMethodName, extraContext);\n        proxy.execute();\n    }", "code_tokens": ["public", "void", "execute", "(", "ActionInvocation", "invocation", ")", "throws", "Exception", "{", "ValueStack", "stack", "=", "ActionContext", ".", "getContext", "(", ")", ".", "getValueStack", "(", ")", ";", "String", "finalNamespace", "=", "this", ".", "namespace", "!=", "null", "?", "TextParseUtil", ".", "translateVariables", "(", "namespace", ",", "stack", ")", ":", "invocation", ".", "getProxy", "(", ")", ".", "getNamespace", "(", ")", ";", "String", "finalActionName", "=", "TextParseUtil", ".", "translateVariables", "(", "actionName", ",", "stack", ")", ";", "String", "finalMethodName", "=", "this", ".", "methodName", "!=", "null", "?", "TextParseUtil", ".", "translateVariables", "(", "this", ".", "methodName", ",", "stack", ")", ":", "null", ";", "if", "(", "isInChainHistory", "(", "finalNamespace", ",", "finalActionName", ",", "finalMethodName", ")", ")", "{", "addToHistory", "(", "finalNamespace", ",", "finalActionName", ",", "finalMethodName", ")", ";", "throw", "new", "XWorkException", "(", "\"", "Infinite recursion detected: ", "\"", "+", "ActionChainResult", ".", "getChainHistory", "(", ")", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "ActionChainResult", ".", "getChainHistory", "(", ")", ".", "isEmpty", "(", ")", "&&", "invocation", "!=", "null", "&&", "invocation", ".", "getProxy", "(", ")", "!=", "null", ")", "{", "addToHistory", "(", "finalNamespace", ",", "invocation", ".", "getProxy", "(", ")", ".", "getActionName", "(", ")", ",", "invocation", ".", "getProxy", "(", ")", ".", "getMethod", "(", ")", ")", ";", "}", "addToHistory", "(", "finalNamespace", ",", "finalActionName", ",", "finalMethodName", ")", ";", "HashMap", "<", "String", ",", "Object", ">", "extraContext", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "extraContext", ".", "put", "(", "ActionContext", ".", "VALUE_STACK", ",", "ActionContext", ".", "getContext", "(", ")", ".", "getValueStack", "(", ")", ")", ";", "extraContext", ".", "put", "(", "ActionContext", ".", "PARAMETERS", ",", "ActionContext", ".", "getContext", "(", ")", ".", "getParameters", "(", ")", ")", ";", "extraContext", ".", "put", "(", "CHAIN_HISTORY", ",", "ActionChainResult", ".", "getChainHistory", "(", ")", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Chaining to action ", "\"", "+", "finalActionName", ")", ";", "}", "proxy", "=", "actionProxyFactory", ".", "createActionProxy", "(", "finalNamespace", ",", "finalActionName", ",", "finalMethodName", ",", "extraContext", ")", ";", "proxy", ".", "execute", "(", ")", ";", "}"], "idx": 12222, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "4a3917176de2df7f33a85511d067f31e50dcc1b", "function_name": "execute", "body_hash": "e8fcea6b92c4449783b43765f295ad5e92f63eca"}
{"code": "protected boolean evaluate(InputSource inputSource) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            DocumentBuilder dbuilder = factory.newDocumentBuilder();\n            Document doc = dbuilder.parse(inputSource);\n\n            //An XPath expression could return a true or false value instead of a node.\n            //eval() is a better way to determine the boolean value of the exp.\n            //For compliance with legacy behavior where selecting an empty node returns true,\n            //selectNodeIterator is attempted in case of a failure.\n\n            CachedXPathAPI cachedXPathAPI = new CachedXPathAPI();\n            XObject result = cachedXPathAPI.eval(doc, xpath);\n            if (result.bool())\n            \treturn true;\n            else {\n            \tNodeIterator iterator = cachedXPathAPI.selectNodeIterator(doc, xpath);\n            \treturn (iterator.nextNode() != null);\n            }\n\n        } catch (Throwable e) {\n            return false;\n        }\n    }", "code_tokens": ["protected", "boolean", "evaluate", "(", "InputSource", "inputSource", ")", "{", "try", "{", "DocumentBuilderFactory", "factory", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setNamespaceAware", "(", "true", ")", ";", "DocumentBuilder", "dbuilder", "=", "factory", ".", "newDocumentBuilder", "(", ")", ";", "Document", "doc", "=", "dbuilder", ".", "parse", "(", "inputSource", ")", ";", "CachedXPathAPI", "cachedXPathAPI", "=", "new", "CachedXPathAPI", "(", ")", ";", "XObject", "result", "=", "cachedXPathAPI", ".", "eval", "(", "doc", ",", "xpath", ")", ";", "if", "(", "result", ".", "bool", "(", ")", ")", "return", "true", ";", "else", "{", "NodeIterator", "iterator", "=", "cachedXPathAPI", ".", "selectNodeIterator", "(", "doc", ",", "xpath", ")", ";", "return", "(", "iterator", ".", "nextNode", "(", ")", "!=", "null", ")", ";", "}", "}", "catch", "(", "Throwable", "e", ")", "{", "return", "false", ";", "}", "}"], "idx": 66015, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "e5647554e6801a522c508a8eb457979a9af8c398", "function_name": "evaluate", "body_hash": "747a9a6ab2dd2985675992c115dc0763748f00b9"}
{"code": "public SendfileState processSendfile(SelectionKey sk, KeyAttachment attachment,\n                boolean calledByProcessor) {\n            NioChannel sc = null;\n            try {\n                unreg(sk, attachment, sk.readyOps());\n                SendfileData sd = attachment.getSendfileData();\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing send file for: \" + sd.fileName);\n                }\n\n                if (sd.fchannel == null) {\n                    // Setup the file channel\n                    File f = new File(sd.fileName);\n                    if (!f.exists()) {\n                        cancelledKey(sk,SocketStatus.ERROR);\n                        return SendfileState.ERROR;\n                    }\n                    @SuppressWarnings(\"resource\") // Closed when channel is closed\n                    FileInputStream fis = new FileInputStream(f);\n                    sd.fchannel = fis.getChannel();\n                }\n\n                // Configure output channel\n                sc = attachment.getSocket();\n                // TLS/SSL channel is slightly different\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n\n                // We still have data in the buffer\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if (written > 0) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for: \"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {\n                        sd.fchannel.close();\n                    } catch (Exception ignore) {\n                    }\n                    // For calls from outside the Poller, the caller is\n                    // responsible for registering the socket for the\n                    // appropriate event(s) if sendfile completes.\n                    if (!calledByProcessor) {\n                        if (sd.keepAlive) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            reg(sk,attachment,SelectionKey.OP_READ);\n                        } else {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Send file connection is being closed\");\n                            }\n                            cancelledKey(sk,SocketStatus.STOP);\n                        }\n                    }\n                    return SendfileState.DONE;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                    }\n                    if (calledByProcessor) {\n                        add(attachment.getSocket(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                    return SendfileState.PENDING;\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                if (!calledByProcessor) {\n                    cancelledKey(sk,SocketStatus.ERROR);\n                }\n                return SendfileState.ERROR;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                if (!calledByProcessor) {\n                    cancelledKey(sk, SocketStatus.ERROR);\n                }\n                return SendfileState.ERROR;\n            }\n        }", "code_tokens": ["public", "SendfileState", "processSendfile", "(", "SelectionKey", "sk", ",", "KeyAttachment", "attachment", ",", "boolean", "calledByProcessor", ")", "{", "NioChannel", "sc", "=", "null", ";", "try", "{", "unreg", "(", "sk", ",", "attachment", ",", "sk", ".", "readyOps", "(", ")", ")", ";", "SendfileData", "sd", "=", "attachment", ".", "getSendfileData", "(", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Processing send file for: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "sd", ".", "fchannel", "==", "null", ")", "{", "File", "f", "=", "new", "File", "(", "sd", ".", "fileName", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ")", ";", "return", "SendfileState", ".", "ERROR", ";", "}", "@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "FileInputStream", "fis", "=", "new", "FileInputStream", "(", "f", ")", ";", "sd", ".", "fchannel", "=", "fis", ".", "getChannel", "(", ")", ";", "}", "sc", "=", "attachment", ".", "getSocket", "(", ")", ";", "WritableByteChannel", "wc", "=", "(", "(", "sc", "instanceof", "SecureNioChannel", ")", "?", "sc", ":", "sc", ".", "getIOChannel", "(", ")", ")", ";", "if", "(", "sc", ".", "getOutboundRemaining", "(", ")", ">", "0", ")", "{", "if", "(", "sc", ".", "flushOutbound", "(", ")", ")", "{", "attachment", ".", "access", "(", ")", ";", "}", "}", "else", "{", "long", "written", "=", "sd", ".", "fchannel", ".", "transferTo", "(", "sd", ".", "pos", ",", "sd", ".", "length", ",", "wc", ")", ";", "if", "(", "written", ">", "0", ")", "{", "sd", ".", "pos", "+=", "written", ";", "sd", ".", "length", "-=", "written", ";", "attachment", ".", "access", "(", ")", ";", "}", "else", "{", "if", "(", "sd", ".", "fchannel", ".", "size", "(", ")", "<=", "sd", ".", "pos", ")", "{", "throw", "new", "IOException", "(", "\"", "Sendfile configured to ", "\"", "+", "\"", "send more data than was available", "\"", ")", ";", "}", "}", "}", "if", "(", "sd", ".", "length", "<=", "0", "&&", "sc", ".", "getOutboundRemaining", "(", ")", "<=", "0", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file complete for: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "attachment", ".", "setSendfileData", "(", "null", ")", ";", "try", "{", "sd", ".", "fchannel", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "ignore", ")", "{", "}", "if", "(", "!", "calledByProcessor", ")", "{", "if", "(", "sd", ".", "keepAlive", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Connection is keep alive, registering back for OP_READ", "\"", ")", ";", "}", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_READ", ")", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Send file connection is being closed", "\"", ")", ";", "}", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "STOP", ")", ";", "}", "}", "return", "SendfileState", ".", "DONE", ";", "}", "else", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "OP_WRITE for sendfile: ", "\"", "+", "sd", ".", "fileName", ")", ";", "}", "if", "(", "calledByProcessor", ")", "{", "add", "(", "attachment", ".", "getSocket", "(", ")", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "else", "{", "reg", "(", "sk", ",", "attachment", ",", "SelectionKey", ".", "OP_WRITE", ")", ";", "}", "return", "SendfileState", ".", "PENDING", ";", "}", "}", "catch", "(", "IOException", "x", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "log", ".", "debug", "(", "\"", "Unable to complete sendfile request:", "\"", ",", "x", ")", ";", "if", "(", "!", "calledByProcessor", ")", "{", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ")", ";", "}", "return", "SendfileState", ".", "ERROR", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "log", ".", "error", "(", "\"", "\"", ",", "t", ")", ";", "if", "(", "!", "calledByProcessor", ")", "{", "cancelledKey", "(", "sk", ",", "SocketStatus", ".", "ERROR", ")", ";", "}", "return", "SendfileState", ".", "ERROR", ";", "}", "}"], "idx": 50717, "cwe": "CWE-388", "target": 0, "status": "FIXED", "commit": "3dd2fec73e0de1edc1d3eb1c52a01255fdfc84e7", "function_name": "processSendfile", "body_hash": "4aa16403abbc5944c99194261a316191e7a64652"}
{"code": "public void handleMessage(Message message) {\n        if (isGET(message) || message.getContent(XMLStreamReader.class) != null) {\n            LOG.fine(\"StaxInInterceptor skipped.\");\n            return;\n        }\n        InputStream is = message.getContent(InputStream.class);\n        Reader reader = null;\n        if (is == null) {\n            reader = message.getContent(Reader.class);\n            if (reader == null) {\n                return;\n            }\n        }\n        String contentType = (String)message.get(Message.CONTENT_TYPE);\n        \n        if (contentType != null && contentType.contains(\"text/html\")) {\n            String htmlMessage = null;\n            try {\n                htmlMessage = IOUtils.toString(is, 500);\n            } catch (IOException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVALID_HTML_RESPONSETYPE\",\n                        LOG, \"(none)\"));\n            }\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVALID_HTML_RESPONSETYPE\",\n                    LOG, (htmlMessage == null || htmlMessage.length() == 0) ? \"(none)\" : htmlMessage));\n        }\n        if (contentType == null) {\n            //if contentType is null, this is likely a an empty post/put/delete/similar, lets see if it's\n            //detectable at all\n            Map<String, List<String>> m = CastUtils.cast((Map<?, ?>)message.get(Message.PROTOCOL_HEADERS));\n            if (m != null) {\n                List<String> contentLen = HttpHeaderHelper\n                    .getHeader(m, HttpHeaderHelper.CONTENT_LENGTH);\n                List<String> contentTE = HttpHeaderHelper\n                    .getHeader(m, HttpHeaderHelper.CONTENT_TRANSFER_ENCODING);\n                if ((StringUtils.isEmpty(contentLen) || \"0\".equals(contentLen.get(0)))\n                    && StringUtils.isEmpty(contentTE)) {\n                    return;\n                }\n            }\n        }\n\n        String encoding = (String)message.get(Message.ENCODING);\n\n        XMLStreamReader xreader;\n        try {\n            XMLInputFactory factory = getXMLInputFactory(message);\n            if (factory == null) {\n                if (reader != null) {\n                    xreader = StaxUtils.createXMLStreamReader(reader);\n                } else {\n                    xreader = StaxUtils.createXMLStreamReader(is, encoding);\n                }\n            } else {\n                synchronized (factory) {\n                    if (reader != null) {\n                        xreader = factory.createXMLStreamReader(reader);\n                    } else {\n                        xreader = factory.createXMLStreamReader(is, encoding);\n                    }\n                }                \n            }\n            xreader = configureRestrictions(xreader, message);\n        } catch (XMLStreamException e) {\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"STREAM_CREATE_EXC\",\n                                                                   LOG,\n                                                                   encoding), e);\n        }\n        message.setContent(XMLStreamReader.class, xreader);\n        message.getInterceptorChain().add(StaxInEndingInterceptor.INSTANCE);\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "{", "if", "(", "isGET", "(", "message", ")", "||", "message", ".", "getContent", "(", "XMLStreamReader", ".", "class", ")", "!=", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "StaxInInterceptor skipped.", "\"", ")", ";", "return", ";", "}", "InputStream", "is", "=", "message", ".", "getContent", "(", "InputStream", ".", "class", ")", ";", "Reader", "reader", "=", "null", ";", "if", "(", "is", "==", "null", ")", "{", "reader", "=", "message", ".", "getContent", "(", "Reader", ".", "class", ")", ";", "if", "(", "reader", "==", "null", ")", "{", "return", ";", "}", "}", "String", "contentType", "=", "(", "String", ")", "message", ".", "get", "(", "Message", ".", "CONTENT_TYPE", ")", ";", "if", "(", "contentType", "!=", "null", "&&", "contentType", ".", "contains", "(", "\"", "text/html", "\"", ")", ")", "{", "String", "htmlMessage", "=", "null", ";", "try", "{", "htmlMessage", "=", "IOUtils", ".", "toString", "(", "is", ",", "500", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "INVALID_HTML_RESPONSETYPE", "\"", ",", "LOG", ",", "\"", "(none)", "\"", ")", ")", ";", "}", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "INVALID_HTML_RESPONSETYPE", "\"", ",", "LOG", ",", "(", "htmlMessage", "==", "null", "||", "htmlMessage", ".", "length", "(", ")", "==", "0", ")", "?", "\"", "(none)", "\"", ":", "htmlMessage", ")", ")", ";", "}", "if", "(", "contentType", "==", "null", ")", "{", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "m", "=", "CastUtils", ".", "cast", "(", "(", "Map", "<", "?", ",", "?", ">", ")", "message", ".", "get", "(", "Message", ".", "PROTOCOL_HEADERS", ")", ")", ";", "if", "(", "m", "!=", "null", ")", "{", "List", "<", "String", ">", "contentLen", "=", "HttpHeaderHelper", ".", "getHeader", "(", "m", ",", "HttpHeaderHelper", ".", "CONTENT_LENGTH", ")", ";", "List", "<", "String", ">", "contentTE", "=", "HttpHeaderHelper", ".", "getHeader", "(", "m", ",", "HttpHeaderHelper", ".", "CONTENT_TRANSFER_ENCODING", ")", ";", "if", "(", "(", "StringUtils", ".", "isEmpty", "(", "contentLen", ")", "||", "\"", "0", "\"", ".", "equals", "(", "contentLen", ".", "get", "(", "0", ")", ")", ")", "&&", "StringUtils", ".", "isEmpty", "(", "contentTE", ")", ")", "{", "return", ";", "}", "}", "}", "String", "encoding", "=", "(", "String", ")", "message", ".", "get", "(", "Message", ".", "ENCODING", ")", ";", "XMLStreamReader", "xreader", ";", "try", "{", "XMLInputFactory", "factory", "=", "getXMLInputFactory", "(", "message", ")", ";", "if", "(", "factory", "==", "null", ")", "{", "if", "(", "reader", "!=", "null", ")", "{", "xreader", "=", "StaxUtils", ".", "createXMLStreamReader", "(", "reader", ")", ";", "}", "else", "{", "xreader", "=", "StaxUtils", ".", "createXMLStreamReader", "(", "is", ",", "encoding", ")", ";", "}", "}", "else", "{", "synchronized", "(", "factory", ")", "{", "if", "(", "reader", "!=", "null", ")", "{", "xreader", "=", "factory", ".", "createXMLStreamReader", "(", "reader", ")", ";", "}", "else", "{", "xreader", "=", "factory", ".", "createXMLStreamReader", "(", "is", ",", "encoding", ")", ";", "}", "}", "}", "xreader", "=", "configureRestrictions", "(", "xreader", ",", "message", ")", ";", "}", "catch", "(", "XMLStreamException", "e", ")", "{", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "STREAM_CREATE_EXC", "\"", ",", "LOG", ",", "encoding", ")", ",", "e", ")", ";", "}", "message", ".", "setContent", "(", "XMLStreamReader", ".", "class", ",", "xreader", ")", ";", "message", ".", "getInterceptorChain", "(", ")", ".", "add", "(", "StaxInEndingInterceptor", ".", "INSTANCE", ")", ";", "}"], "idx": 51163, "cwe": "CWE-399", "target": 1, "status": "VULNERABLE", "commit": "f8ed98e684c1a67a77ae8726db05a04a4978a445", "function_name": "handleMessage", "body_hash": "d83c70ee5475ee59d4a2af07b765f761f751f264"}
{"code": "private Exception doRequest() {\n\n            Tomcat tomcat = getTomcatInstance();\n\n            Context root = tomcat.addContext(\"\", TEMP_DIR);\n            Tomcat.addServlet(root, \"Bug51557\",\n                    new Bug51557Servlet(headerName));\n            root.addServletMapping(\"/test\", \"Bug51557\");\n\n            try {\n                Connector connector = tomcat.getConnector();\n                connector.setProperty(\"rejectIllegalHeaderName\",\n                        Boolean.toString(rejectIllegalHeaderName));\n                tomcat.start();\n                setPort(connector.getLocalPort());\n\n                // Open connection\n                connect();\n\n                String[] request = new String[1];\n                request[0] =\n                    \"GET /test HTTP/1.1\" + CRLF +\n                    \"host: localhost:8080\" + CRLF +\n                    headerLine + CRLF +\n                    \"X-Bug51557: abcd\" + CRLF +\n                    \"Connection: close\" + CRLF +\n                    CRLF;\n\n                setRequest(request);\n                processRequest(); // blocks until response has been read\n\n                // Close the connection\n                disconnect();\n            } catch (Exception e) {\n                return e;\n            }\n            return null;\n        }", "code_tokens": ["private", "Exception", "doRequest", "(", ")", "{", "Tomcat", "tomcat", "=", "getTomcatInstance", "(", ")", ";", "Context", "root", "=", "tomcat", ".", "addContext", "(", "\"", "\"", ",", "TEMP_DIR", ")", ";", "Tomcat", ".", "addServlet", "(", "root", ",", "\"", "Bug51557", "\"", ",", "new", "Bug51557Servlet", "(", "headerName", ")", ")", ";", "root", ".", "addServletMapping", "(", "\"", "/test", "\"", ",", "\"", "Bug51557", "\"", ")", ";", "try", "{", "Connector", "connector", "=", "tomcat", ".", "getConnector", "(", ")", ";", "connector", ".", "setProperty", "(", "\"", "rejectIllegalHeaderName", "\"", ",", "Boolean", ".", "toString", "(", "rejectIllegalHeaderName", ")", ")", ";", "tomcat", ".", "start", "(", ")", ";", "setPort", "(", "connector", ".", "getLocalPort", "(", ")", ")", ";", "connect", "(", ")", ";", "String", "[", "]", "request", "=", "new", "String", "[", "1", "]", ";", "request", "[", "0", "]", "=", "\"", "GET /test HTTP/1.1", "\"", "+", "CRLF", "+", "\"", "host: localhost:8080", "\"", "+", "CRLF", "+", "headerLine", "+", "CRLF", "+", "\"", "X-Bug51557: abcd", "\"", "+", "CRLF", "+", "\"", "Connection: close", "\"", "+", "CRLF", "+", "CRLF", ";", "setRequest", "(", "request", ")", ";", "processRequest", "(", ")", ";", "disconnect", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "return", "e", ";", "}", "return", "null", ";", "}"], "idx": 56013, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "702bf15", "function_name": "doRequest", "body_hash": "0859f5e7dfec8fdd57f382e8ed33c27eb37d39b8"}
{"code": "public Thread newThread(final Runnable r) {\n            return doPrivileged(new PrivilegedAction<Thread>() {\n                public Thread run() {\n                    final Thread taskThread = new Thread(threadGroup, new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                r.run();\n                            } finally {\n                                xnio.handleThreadExit();\n                            }\n                        }\n                    }, name + \" task-\" + getNextSeq(), stackSize);\n                    // Mark the thread as daemon if the Options.THREAD_DAEMON has been set\n                    if (markThreadAsDaemon) {\n                        taskThread.setDaemon(true);\n                    }\n                    return taskThread;\n                }\n            });\n        }", "code_tokens": ["public", "Thread", "newThread", "(", "final", "Runnable", "r", ")", "{", "return", "doPrivileged", "(", "new", "PrivilegedAction", "<", "Thread", ">", "(", ")", "{", "public", "Thread", "run", "(", ")", "{", "final", "Thread", "taskThread", "=", "new", "Thread", "(", "threadGroup", ",", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "try", "{", "r", ".", "run", "(", ")", ";", "}", "finally", "{", "xnio", ".", "handleThreadExit", "(", ")", ";", "}", "}", "}", ",", "name", "+", "\"", " task-", "\"", "+", "getNextSeq", "(", ")", ",", "stackSize", ")", ";", "if", "(", "markThreadAsDaemon", ")", "{", "taskThread", ".", "setDaemon", "(", "true", ")", ";", "}", "return", "taskThread", ";", "}", "}", ")", ";", "}"], "idx": 109836, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "3a6cde771994ad347edacc13f75fbfefd6c4734d", "function_name": "newThread", "body_hash": "209612de002b233e73694270a1f50d10a0316b3c"}
{"code": "@Override\n        public String getShortDescription() {\n            if(note != null) {\n                try {\n                    return Messages.Cause_RemoteCause_ShortDescriptionWithNote(addr, Jenkins.getInstance().getMarkupFormatter().translate(note));\n                } catch (IOException x) {\n                    // ignore\n                }\n            }\n            return Messages.Cause_RemoteCause_ShortDescription(addr);\n        }", "code_tokens": ["@", "Override", "public", "String", "getShortDescription", "(", ")", "{", "if", "(", "note", "!=", "null", ")", "{", "try", "{", "return", "Messages", ".", "Cause_RemoteCause_ShortDescriptionWithNote", "(", "addr", ",", "Jenkins", ".", "getInstance", "(", ")", ".", "getMarkupFormatter", "(", ")", ".", "translate", "(", "note", ")", ")", ";", "}", "catch", "(", "IOException", "x", ")", "{", "}", "}", "return", "Messages", ".", "Cause_RemoteCause_ShortDescription", "(", "addr", ")", ";", "}"], "idx": 77774, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "5d57c855f3147bfc5e7fda9252317b428a700014", "function_name": "getShortDescription", "body_hash": "1fd6f4a248f3e2d674043d521770236de66b8d53"}
{"code": "public Session createSession(String from) throws MessagingException {\n        Properties props = new Properties(System.getProperties());\n\n        MailAccount acc = mailAccount;\n        if(StringUtils.isNotBlank(from)){\n            InternetAddress fromAddress = new InternetAddress(from);\n            for(MailAccount ma : addAccounts) {\n                if(ma == null || !ma.isValid() || !ma.getAddress().equalsIgnoreCase(fromAddress.getAddress())) continue;\n                acc = ma;\n                break;\n            }\n        }\n\n        if(!acc.isValid()) {\n            // what do we want to do here?\n        }\n\n        if (acc.getSmtpHost() != null) {\n            props.put(\"mail.smtp.host\", acc.getSmtpHost());\n        }\n        if (acc.getSmtpPort() != null) {\n            props.put(\"mail.smtp.port\", acc.getSmtpPort());\n        }\n        if (acc.isUseSsl()) {\n            /* This allows the user to override settings by setting system properties but\n             * also allows us to use the default SMTPs port of 465 if no port is already set.\n             * It would be cleaner to use smtps, but that's done by calling session.getTransport()...\n             * and thats done in mail sender, and it would be a bit of a hack to get it all to\n             * coordinate, and we can make it work through setting mail.smtp properties.\n             */\n            if (props.getProperty(\"mail.smtp.socketFactory.port\") == null) {\n                String port = acc.getSmtpPort() == null ? \"465\" : mailAccount.getSmtpPort();\n                props.put(\"mail.smtp.port\", port);\n                props.put(\"mail.smtp.socketFactory.port\", port);\n            }\n            if (props.getProperty(\"mail.smtp.socketFactory.class\") == null) {\n                props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n            }\n            props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n        }\n        if (!StringUtils.isBlank(acc.getSmtpUsername())) {\n            props.put(\"mail.smtp.auth\", \"true\");\n        }\n\n        // avoid hang by setting some timeout.\n        props.put(\"mail.smtp.timeout\", \"60000\");\n        props.put(\"mail.smtp.connectiontimeout\", \"60000\");\n\n        try {\n            String ap = acc.getAdvProperties();\n            if (ap != null && !isBlank(ap.trim())) {\n                props.load(new StringReader(ap));\n            }\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Parameters parse fail.\", e);\n        }\n\n        return Session.getInstance(props, getAuthenticator(acc));\n    }", "code_tokens": ["public", "Session", "createSession", "(", "String", "from", ")", "throws", "MessagingException", "{", "Properties", "props", "=", "new", "Properties", "(", "System", ".", "getProperties", "(", ")", ")", ";", "MailAccount", "acc", "=", "mailAccount", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "from", ")", ")", "{", "InternetAddress", "fromAddress", "=", "new", "InternetAddress", "(", "from", ")", ";", "for", "(", "MailAccount", "ma", ":", "addAccounts", ")", "{", "if", "(", "ma", "==", "null", "||", "!", "ma", ".", "isValid", "(", ")", "||", "!", "ma", ".", "getAddress", "(", ")", ".", "equalsIgnoreCase", "(", "fromAddress", ".", "getAddress", "(", ")", ")", ")", "continue", ";", "acc", "=", "ma", ";", "break", ";", "}", "}", "if", "(", "!", "acc", ".", "isValid", "(", ")", ")", "{", "}", "if", "(", "acc", ".", "getSmtpHost", "(", ")", "!=", "null", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.host", "\"", ",", "acc", ".", "getSmtpHost", "(", ")", ")", ";", "}", "if", "(", "acc", ".", "getSmtpPort", "(", ")", "!=", "null", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.port", "\"", ",", "acc", ".", "getSmtpPort", "(", ")", ")", ";", "}", "if", "(", "acc", ".", "isUseSsl", "(", ")", ")", "{", "if", "(", "props", ".", "getProperty", "(", "\"", "mail.smtp.socketFactory.port", "\"", ")", "==", "null", ")", "{", "String", "port", "=", "acc", ".", "getSmtpPort", "(", ")", "==", "null", "?", "\"", "465", "\"", ":", "mailAccount", ".", "getSmtpPort", "(", ")", ";", "props", ".", "put", "(", "\"", "mail.smtp.port", "\"", ",", "port", ")", ";", "props", ".", "put", "(", "\"", "mail.smtp.socketFactory.port", "\"", ",", "port", ")", ";", "}", "if", "(", "props", ".", "getProperty", "(", "\"", "mail.smtp.socketFactory.class", "\"", ")", "==", "null", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.socketFactory.class", "\"", ",", "\"", "javax.net.ssl.SSLSocketFactory", "\"", ")", ";", "}", "props", ".", "put", "(", "\"", "mail.smtp.socketFactory.fallback", "\"", ",", "\"", "false", "\"", ")", ";", "}", "if", "(", "!", "StringUtils", ".", "isBlank", "(", "acc", ".", "getSmtpUsername", "(", ")", ")", ")", "{", "props", ".", "put", "(", "\"", "mail.smtp.auth", "\"", ",", "\"", "true", "\"", ")", ";", "}", "props", ".", "put", "(", "\"", "mail.smtp.timeout", "\"", ",", "\"", "60000", "\"", ")", ";", "props", ".", "put", "(", "\"", "mail.smtp.connectiontimeout", "\"", ",", "\"", "60000", "\"", ")", ";", "try", "{", "String", "ap", "=", "acc", ".", "getAdvProperties", "(", ")", ";", "if", "(", "ap", "!=", "null", "&&", "!", "isBlank", "(", "ap", ".", "trim", "(", ")", ")", ")", "{", "props", ".", "load", "(", "new", "StringReader", "(", "ap", ")", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Parameters parse fail.", "\"", ",", "e", ")", ";", "}", "return", "Session", ".", "getInstance", "(", "props", ",", "getAuthenticator", "(", "acc", ")", ")", ";", "}"], "idx": 40750, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "ac039ba5", "function_name": "createSession", "body_hash": "786fb21126088883e68e1672d7b94be855f113db"}
{"code": "public static Document xmlText2GenericDom(InputStream is, Document emptyDoc)\n            throws SAXException, ParserConfigurationException, IOException\n    {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        factory.setNamespaceAware(true);\n\n        SAXParser parser = factory.newSAXParser();\n\n        Sax2Dom handler = new Sax2Dom(emptyDoc);\n\n        parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\n        parser.parse(is, handler);\n\n        return (Document) handler.getDOM();\n    }", "code_tokens": ["public", "static", "Document", "xmlText2GenericDom", "(", "InputStream", "is", ",", "Document", "emptyDoc", ")", "throws", "SAXException", ",", "ParserConfigurationException", ",", "IOException", "{", "SAXParserFactory", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setNamespaceAware", "(", "true", ")", ";", "SAXParser", "parser", "=", "factory", ".", "newSAXParser", "(", ")", ";", "Sax2Dom", "handler", "=", "new", "Sax2Dom", "(", "emptyDoc", ")", ";", "parser", ".", "setProperty", "(", "\"", "http://xml.org/sax/properties/lexical-handler", "\"", ",", "handler", ")", ";", "parser", ".", "parse", "(", "is", ",", "handler", ")", ";", "return", "(", "Document", ")", "handler", ".", "getDOM", "(", ")", ";", "}"], "idx": 76386, "cwe": "CWE-776", "target": 1, "status": "VULNERABLE", "commit": "80cb805eb1488ba3a16c427866fa8ae1f52ff0c5", "function_name": "xmlText2GenericDom", "body_hash": "5fec54f606450bc0b76cc867c5f540c9daedbee8"}
{"code": "private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        case '\\t': replace(i, i + 1, \"\\\\t\"); break;\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \"foo\"\n        // or internal quotes that might need to be escaped : f\"o -> f\\\"o.\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\"' as closing regardless.\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string\n        // literals so that the output can be embedded in HTML script elements\n        // and in XML CDATA sections without affecting the parser state.\n        // References:\n        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements\n        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state\n        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state\n        // https://www.w3.org/TR/xml/#sec-cdata-sect\n        case '<':\n          // Disallow <!--, which lets the HTML parser switch into the \"script\n          // data escaped\" state.\n          // Disallow <script, which followed by various characters lets the\n          // HTML parser switch into or out of the \"script data double escaped\"\n          // state.\n          // Disallow </script, which ends a script block.\n          if (i + 3 >= end)\n            break;\n          char c1 = jsonish.charAt(i + 1);\n          char c2 = jsonish.charAt(i + 2);\n          char c3 = jsonish.charAt(i + 3);\n          char lc1 = (char) (c1 | 32);\n          char lc2 = (char) (c2 | 32);\n          char lc3 = (char) (c3 | 32);\n          if ((c1 == '!' && c2 == '-' && c3 == '-') ||\n              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {\n            replace(i, i + 1, \"\\\\u003c\"); // Escaped <\n          }\n          break;\n        case '>':\n          // Disallow -->, which lets the HTML parser switch out of the \"script\n          // data escaped\" or \"script data double escaped\" state.\n          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)\n              && '-' == jsonish.charAt(i - 1)) {\n            replace(i, i + 1, \"\\\\u003e\"); // Escaped >\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7': {\n              int octalStart = i + 1;\n              int octalEnd = octalStart;\n              ++octalEnd;\n              if (octalEnd < end && isOctAt(octalEnd)) {\n                ++octalEnd;\n                if (sch <= '3' && octalEnd < end && isOctAt(octalEnd)) {\n                  ++octalEnd;\n                }\n              }\n              int value = 0;\n              for (int j = octalStart; j < octalEnd; ++j) {\n                char digit = jsonish.charAt(j);\n                value = (value << 3) | (digit - '0');\n              }\n              replace(octalStart, octalEnd, \"u00\");\n              appendHex(value, 2);\n\n              i = octalEnd - 1;\n              break;\n            }\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \"\\-\" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n             // Proceed to hex-escape below since control characters are\n             // disallowed by ECMA-404 which governs JavaScript's `JSON.parse`.\n             // Common ones like CR, LF, and TAB are given short escape sequences above.\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\"'); }\n  }", "code_tokens": ["private", "void", "sanitizeString", "(", "int", "start", ",", "int", "end", ")", "{", "boolean", "closed", "=", "false", ";", "for", "(", "int", "i", "=", "start", ";", "i", "<", "end", ";", "++", "i", ")", "{", "char", "ch", "=", "jsonish", ".", "charAt", "(", "i", ")", ";", "switch", "(", "ch", ")", "{", "case", "'\\t'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "t", "\"", ")", ";", "break", ";", "case", "'\\n'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "n", "\"", ")", ";", "break", ";", "case", "'\\r'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "r", "\"", ")", ";", "break", ";", "case", "'\\u2028'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2028", "\"", ")", ";", "break", ";", "case", "'\\u2029'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2029", "\"", ")", ";", "break", ";", "case", "'\"'", ":", "case", "'\\''", ":", "if", "(", "i", "==", "start", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "{", "if", "(", "i", "+", "1", "==", "end", ")", "{", "char", "startDelim", "=", "jsonish", ".", "charAt", "(", "start", ")", ";", "if", "(", "startDelim", "!=", "'\\''", ")", "{", "startDelim", "=", "'\"'", ";", "}", "closed", "=", "startDelim", "==", "ch", ";", "}", "if", "(", "closed", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "if", "(", "ch", "==", "'\"'", ")", "{", "insert", "(", "i", ",", "'\\\\'", ")", ";", "}", "}", "break", ";", "case", "'<'", ":", "if", "(", "i", "+", "3", ">=", "end", ")", "break", ";", "char", "c1", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "char", "c2", "=", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ";", "char", "c3", "=", "jsonish", ".", "charAt", "(", "i", "+", "3", ")", ";", "char", "lc1", "=", "(", "char", ")", "(", "c1", "|", "32", ")", ";", "char", "lc2", "=", "(", "char", ")", "(", "c2", "|", "32", ")", ";", "char", "lc3", "=", "(", "char", ")", "(", "c3", "|", "32", ")", ";", "if", "(", "(", "c1", "==", "'!'", "&&", "c2", "==", "'-'", "&&", "c3", "==", "'-'", ")", "||", "(", "lc1", "==", "'s'", "&&", "lc2", "==", "'c'", "&&", "lc3", "==", "'r'", ")", "||", "(", "c1", "==", "'/'", "&&", "lc2", "==", "'s'", "&&", "lc3", "==", "'c'", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u003c", "\"", ")", ";", "}", "break", ";", "case", "'>'", ":", "if", "(", "(", "i", "-", "2", ")", ">=", "start", "&&", "'-'", "==", "jsonish", ".", "charAt", "(", "i", "-", "2", ")", "&&", "'-'", "==", "jsonish", ".", "charAt", "(", "i", "-", "1", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u003e", "\"", ")", ";", "}", "break", ";", "case", "']'", ":", "if", "(", "i", "+", "2", "<", "end", "&&", "']'", "==", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", "&&", "'>'", "==", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u005d", "\"", ")", ";", "}", "break", ";", "case", "'\\\\'", ":", "if", "(", "i", "+", "1", "==", "end", ")", "{", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "char", "sch", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "switch", "(", "sch", ")", "{", "case", "'b'", ":", "case", "'f'", ":", "case", "'n'", ":", "case", "'r'", ":", "case", "'t'", ":", "case", "'\\\\'", ":", "case", "'/'", ":", "case", "'\"'", ":", "++", "i", ";", "break", ";", "case", "'v'", ":", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u0008", "\"", ")", ";", "++", "i", ";", "break", ";", "case", "'x'", ":", "if", "(", "i", "+", "4", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u00", "\"", ")", ";", "i", "+=", "3", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'u'", ":", "if", "(", "i", "+", "6", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", "&&", "isHexAt", "(", "i", "+", "4", ")", "&&", "isHexAt", "(", "i", "+", "5", ")", ")", "{", "i", "+=", "5", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'0'", ":", "case", "'1'", ":", "case", "'2'", ":", "case", "'3'", ":", "case", "'4'", ":", "case", "'5'", ":", "case", "'6'", ":", "case", "'7'", ":", "{", "int", "octalStart", "=", "i", "+", "1", ";", "int", "octalEnd", "=", "octalStart", ";", "++", "octalEnd", ";", "if", "(", "octalEnd", "<", "end", "&&", "isOctAt", "(", "octalEnd", ")", ")", "{", "++", "octalEnd", ";", "if", "(", "sch", "<=", "'3'", "&&", "octalEnd", "<", "end", "&&", "isOctAt", "(", "octalEnd", ")", ")", "{", "++", "octalEnd", ";", "}", "}", "int", "value", "=", "0", ";", "for", "(", "int", "j", "=", "octalStart", ";", "j", "<", "octalEnd", ";", "++", "j", ")", "{", "char", "digit", "=", "jsonish", ".", "charAt", "(", "j", ")", ";", "value", "=", "(", "value", "<<", "3", ")", "|", "(", "digit", "-", "'0'", ")", ";", "}", "replace", "(", "octalStart", ",", "octalEnd", ",", "\"", "u00", "\"", ")", ";", "appendHex", "(", "value", ",", "2", ")", ";", "i", "=", "octalEnd", "-", "1", ";", "break", ";", "}", "default", ":", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "break", ";", "default", ":", "if", "(", "ch", "<", "0x20", ")", "{", "}", "else", "if", "(", "ch", "<", "0xd800", ")", "{", "continue", ";", "}", "else", "if", "(", "ch", "<", "0xe000", ")", "{", "if", "(", "Character", ".", "isHighSurrogate", "(", "ch", ")", "&&", "i", "+", "1", "<", "end", "&&", "Character", ".", "isLowSurrogate", "(", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "continue", ";", "}", "}", "else", "if", "(", "ch", "<=", "0xfffd", ")", "{", "continue", ";", "}", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u", "\"", ")", ";", "for", "(", "int", "j", "=", "4", ";", "--", "j", ">=", "0", ";", ")", "{", "sanitizedJson", ".", "append", "(", "HEX_DIGITS", "[", "(", "ch", ">>>", "(", "j", "<<", "2", ")", ")", "&", "0xf", "]", ")", ";", "}", "break", ";", "}", "}", "if", "(", "!", "closed", ")", "{", "insert", "(", "end", ",", "'\"'", ")", ";", "}", "}"], "idx": 69759, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "89d91f328bd3eb46bee6b8ee78a5fce1e3a11c18", "function_name": "sanitizeString", "body_hash": "901b9ecbfb9ffd4928ae729276fef5fff2989ca0"}
{"code": "@Override\r\n\tprotected void configure() {\r\n\t\tsuper.configure();\r\n\t\t\r\n\t\tbind(JettyRunner.class).to(DefaultJettyRunner.class);\r\n\t\tbind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);\r\n\t\t\r\n\t\tbind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);\r\n\t\t\r\n\t\tbind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic ValidatorFactory get() {\r\n\t\t\t\tConfiguration<?> configuration = Validation\r\n\t\t\t\t\t\t.byDefaultProvider()\r\n\t\t\t\t\t\t.configure()\r\n\t\t\t\t\t\t.messageInterpolator(new ParameterMessageInterpolator());\r\n\t\t\t\treturn configuration.buildValidatorFactory();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}).in(Singleton.class);\r\n\t\t\r\n\t\tbind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);\r\n\r\n\t\t// configure markdown\r\n\t\tbind(MarkdownManager.class).to(DefaultMarkdownManager.class);\t\t\r\n\t\t\r\n\t\tconfigurePersistence();\r\n\t\tconfigureRestServices();\r\n\t\tconfigureWeb();\r\n\t\tconfigureBuild();\r\n\t\t\r\n\t\tbind(GitConfig.class).toProvider(GitConfigProvider.class);\r\n\r\n\t\t/*\r\n\t\t * Declare bindings explicitly instead of using ImplementedBy annotation as\r\n\t\t * HK2 to guice bridge can only search in explicit bindings in Guice   \r\n\t\t */\r\n\t\tbind(StorageManager.class).to(DefaultStorageManager.class);\r\n\t\tbind(SettingManager.class).to(DefaultSettingManager.class);\r\n\t\tbind(DataManager.class).to(DefaultDataManager.class);\r\n\t\tbind(TaskScheduler.class).to(DefaultTaskScheduler.class);\r\n\t\tbind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);\r\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\r\n\t\tbind(PullRequestManager.class).to(DefaultPullRequestManager.class);\r\n\t\tbind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);\r\n\t\tbind(ProjectManager.class).to(DefaultProjectManager.class);\r\n\t\tbind(UserManager.class).to(DefaultUserManager.class);\r\n\t\tbind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);\r\n\t\tbind(BuildManager.class).to(DefaultBuildManager.class);\r\n\t\tbind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);\r\n\t\tbind(JobManager.class).to(DefaultJobManager.class);\r\n\t\tbind(LogManager.class).to(DefaultLogManager.class);\r\n\t\tbind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);\r\n\t\tbind(MailManager.class).to(DefaultMailManager.class);\r\n\t\tbind(IssueManager.class).to(DefaultIssueManager.class);\r\n\t\tbind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);\r\n\t\tbind(BuildParamManager.class).to(DefaultBuildParamManager.class);\r\n\t\tbind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);\r\n\t\tbind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);\r\n\t\tbind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);\r\n\t\tbind(RoleManager.class).to(DefaultRoleManager.class);\r\n\t\tbind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);\r\n\t\tbind(UserInfoManager.class).to(DefaultUserInfoManager.class);\r\n\t\tbind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);\r\n\t\tbind(GroupManager.class).to(DefaultGroupManager.class);\r\n\t\tbind(MembershipManager.class).to(DefaultMembershipManager.class);\r\n\t\tbind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);\r\n\t\tbind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);\r\n\t\tbind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);\r\n\t\tbind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);\r\n\t\tbind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);\r\n\t\tbind(WorkExecutor.class).to(DefaultWorkExecutor.class);\r\n\t\tbind(PullRequestNotificationManager.class);\r\n\t\tbind(CommitNotificationManager.class);\r\n\t\tbind(BuildNotificationManager.class);\r\n\t\tbind(IssueNotificationManager.class);\r\n\t\tbind(EntityReferenceManager.class);\r\n\t\tbind(CodeCommentNotificationManager.class);\r\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\r\n\t\tbind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);\r\n\t\tbind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);\r\n\t\tbind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);\r\n\t\tbind(MilestoneManager.class).to(DefaultMilestoneManager.class);\r\n\t\tbind(Session.class).toProvider(SessionProvider.class);\r\n\t\tbind(EntityManager.class).toProvider(SessionProvider.class);\r\n\t\tbind(SessionFactory.class).toProvider(SessionFactoryProvider.class);\r\n\t\tbind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);\r\n\t\tbind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);\r\n\t\tbind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);\r\n\t\tbind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);\r\n\t\tbind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);\r\n\t\tbind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);\r\n\t\tbind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);\r\n\t\tbind(WebHookManager.class);\r\n\r\n\t\tcontribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);\r\n\t    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);\r\n\t    \r\n\t\tbind(Realm.class).to(OneAuthorizingRealm.class);\r\n\t\tbind(RememberMeManager.class).to(OneRememberMeManager.class);\r\n\t\tbind(WebSecurityManager.class).to(OneWebSecurityManager.class);\r\n\t\tbind(FilterChainResolver.class).to(OneFilterChainResolver.class);\r\n\t\tbind(BasicAuthenticationFilter.class);\r\n\t\tbind(PasswordService.class).to(OnePasswordService.class);\r\n\t\tbind(ShiroFilter.class);\r\n\t\tinstall(new ShiroAopModule());\r\n        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {\r\n\r\n            @Override\r\n            public void configure(FilterChainManager filterChainManager) {\r\n                filterChainManager.createChain(\"/**/info/refs\", \"noSessionCreation, authcBasic\");\r\n                filterChainManager.createChain(\"/**/git-upload-pack\", \"noSessionCreation, authcBasic\");\r\n                filterChainManager.createChain(\"/**/git-receive-pack\", \"noSessionCreation, authcBasic\");\r\n            }\r\n            \r\n        });\r\n        contributeFromPackage(Authenticator.class, Authenticator.class);\r\n        \r\n\t\tcontribute(ImplementationProvider.class, new ImplementationProvider() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic Class<?> getAbstractClass() {\r\n\t\t\t\treturn JobExecutor.class;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic Collection<Class<?>> getImplementations() {\r\n\t\t\t\treturn Sets.newHashSet(AutoDiscoveredJobExecutor.class);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\tcontribute(CodePullAuthorizationSource.class, DefaultJobManager.class);\r\n        \r\n\t\tbind(IndexManager.class).to(DefaultIndexManager.class);\r\n\t\tbind(SearchManager.class).to(DefaultSearchManager.class);\r\n\t\t\r\n\t\tbind(EntityValidator.class).to(DefaultEntityValidator.class);\r\n\t\t\r\n\t\tbind(GitFilter.class);\r\n\t\tbind(GitPreReceiveCallback.class);\r\n\t\tbind(GitPostReceiveCallback.class);\r\n\t\t\r\n\t    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic ExecutorService get() {\r\n\t\t        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, \r\n\t\t        \t\tnew SynchronousQueue<Runnable>()) {\r\n\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void execute(Runnable command) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(command));\r\n\t\t\t\t\t\t} catch (RejectedExecutionException e) {\r\n\t\t\t\t\t\t\tif (!isShutdown())\r\n\t\t\t\t\t\t\t\tthrow ExceptionUtils.unchecked(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t        };\r\n\t\t\t}\r\n\t    \t\r\n\t    }).in(Singleton.class);\r\n\t    \r\n\t    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic ForkJoinTask<?> submit(Runnable task) {\r\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void execute(Runnable task) {\r\n\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(task));\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> ForkJoinTask<T> submit(Callable<T> task) {\r\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> ForkJoinTask<T> submit(Runnable task, T result) {\r\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task), result);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)\r\n\t\t\t\t\tthrows InterruptedException, ExecutionException {\r\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks));\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\r\n\t\t\t\t\tthrows InterruptedException, ExecutionException, TimeoutException {\r\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, \r\n\t\t\t\t\tlong timeout, TimeUnit unit) throws InterruptedException {\r\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\r\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks));\r\n\t\t\t}\r\n\r\n\t    });\r\n\t}", "code_tokens": ["@", "Override", "protected", "void", "configure", "(", ")", "{", "super", ".", "configure", "(", ")", ";", "bind", "(", "JettyRunner", ".", "class", ")", ".", "to", "(", "DefaultJettyRunner", ".", "class", ")", ";", "bind", "(", "ServletContextHandler", ".", "class", ")", ".", "toProvider", "(", "DefaultJettyRunner", ".", "class", ")", ";", "bind", "(", "ObjectMapper", ".", "class", ")", ".", "toProvider", "(", "ObjectMapperProvider", ".", "class", ")", ".", "in", "(", "Singleton", ".", "class", ")", ";", "bind", "(", "ValidatorFactory", ".", "class", ")", ".", "toProvider", "(", "new", "com", ".", "google", ".", "inject", ".", "Provider", "<", "ValidatorFactory", ">", "(", ")", "{", "@", "Override", "public", "ValidatorFactory", "get", "(", ")", "{", "Configuration", "<", "?", ">", "configuration", "=", "Validation", ".", "byDefaultProvider", "(", ")", ".", "configure", "(", ")", ".", "messageInterpolator", "(", "new", "ParameterMessageInterpolator", "(", ")", ")", ";", "return", "configuration", ".", "buildValidatorFactory", "(", ")", ";", "}", "}", ")", ".", "in", "(", "Singleton", ".", "class", ")", ";", "bind", "(", "Validator", ".", "class", ")", ".", "toProvider", "(", "ValidatorProvider", ".", "class", ")", ".", "in", "(", "Singleton", ".", "class", ")", ";", "bind", "(", "MarkdownManager", ".", "class", ")", ".", "to", "(", "DefaultMarkdownManager", ".", "class", ")", ";", "configurePersistence", "(", ")", ";", "configureRestServices", "(", ")", ";", "configureWeb", "(", ")", ";", "configureBuild", "(", ")", ";", "bind", "(", "GitConfig", ".", "class", ")", ".", "toProvider", "(", "GitConfigProvider", ".", "class", ")", ";", "bind", "(", "StorageManager", ".", "class", ")", ".", "to", "(", "DefaultStorageManager", ".", "class", ")", ";", "bind", "(", "SettingManager", ".", "class", ")", ".", "to", "(", "DefaultSettingManager", ".", "class", ")", ";", "bind", "(", "DataManager", ".", "class", ")", ".", "to", "(", "DefaultDataManager", ".", "class", ")", ";", "bind", "(", "TaskScheduler", ".", "class", ")", ".", "to", "(", "DefaultTaskScheduler", ".", "class", ")", ";", "bind", "(", "PullRequestCommentManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestCommentManager", ".", "class", ")", ";", "bind", "(", "CodeCommentManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentManager", ".", "class", ")", ";", "bind", "(", "PullRequestManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestManager", ".", "class", ")", ";", "bind", "(", "PullRequestUpdateManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestUpdateManager", ".", "class", ")", ";", "bind", "(", "ProjectManager", ".", "class", ")", ".", "to", "(", "DefaultProjectManager", ".", "class", ")", ";", "bind", "(", "UserManager", ".", "class", ")", ".", "to", "(", "DefaultUserManager", ".", "class", ")", ";", "bind", "(", "PullRequestReviewManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestReviewManager", ".", "class", ")", ";", "bind", "(", "BuildManager", ".", "class", ")", ".", "to", "(", "DefaultBuildManager", ".", "class", ")", ";", "bind", "(", "BuildDependenceManager", ".", "class", ")", ".", "to", "(", "DefaultBuildDependenceManager", ".", "class", ")", ";", "bind", "(", "JobManager", ".", "class", ")", ".", "to", "(", "DefaultJobManager", ".", "class", ")", ";", "bind", "(", "LogManager", ".", "class", ")", ".", "to", "(", "DefaultLogManager", ".", "class", ")", ";", "bind", "(", "PullRequestBuildManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestBuildManager", ".", "class", ")", ";", "bind", "(", "MailManager", ".", "class", ")", ".", "to", "(", "DefaultMailManager", ".", "class", ")", ";", "bind", "(", "IssueManager", ".", "class", ")", ".", "to", "(", "DefaultIssueManager", ".", "class", ")", ";", "bind", "(", "IssueFieldManager", ".", "class", ")", ".", "to", "(", "DefaultIssueFieldManager", ".", "class", ")", ";", "bind", "(", "BuildParamManager", ".", "class", ")", ".", "to", "(", "DefaultBuildParamManager", ".", "class", ")", ";", "bind", "(", "UserAuthorizationManager", ".", "class", ")", ".", "to", "(", "DefaultUserAuthorizationManager", ".", "class", ")", ";", "bind", "(", "GroupAuthorizationManager", ".", "class", ")", ".", "to", "(", "DefaultGroupAuthorizationManager", ".", "class", ")", ";", "bind", "(", "PullRequestWatchManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestWatchManager", ".", "class", ")", ";", "bind", "(", "RoleManager", ".", "class", ")", ".", "to", "(", "DefaultRoleManager", ".", "class", ")", ";", "bind", "(", "CommitInfoManager", ".", "class", ")", ".", "to", "(", "DefaultCommitInfoManager", ".", "class", ")", ";", "bind", "(", "UserInfoManager", ".", "class", ")", ".", "to", "(", "DefaultUserInfoManager", ".", "class", ")", ";", "bind", "(", "BatchWorkManager", ".", "class", ")", ".", "to", "(", "DefaultBatchWorkManager", ".", "class", ")", ";", "bind", "(", "GroupManager", ".", "class", ")", ".", "to", "(", "DefaultGroupManager", ".", "class", ")", ";", "bind", "(", "MembershipManager", ".", "class", ")", ".", "to", "(", "DefaultMembershipManager", ".", "class", ")", ";", "bind", "(", "PullRequestChangeManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestChangeManager", ".", "class", ")", ";", "bind", "(", "CodeCommentReplyManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentReplyManager", ".", "class", ")", ";", "bind", "(", "AttachmentStorageManager", ".", "class", ")", ".", "to", "(", "DefaultAttachmentStorageManager", ".", "class", ")", ";", "bind", "(", "CodeCommentRelationInfoManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentRelationInfoManager", ".", "class", ")", ";", "bind", "(", "CodeCommentRelationManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentRelationManager", ".", "class", ")", ";", "bind", "(", "WorkExecutor", ".", "class", ")", ".", "to", "(", "DefaultWorkExecutor", ".", "class", ")", ";", "bind", "(", "PullRequestNotificationManager", ".", "class", ")", ";", "bind", "(", "CommitNotificationManager", ".", "class", ")", ";", "bind", "(", "BuildNotificationManager", ".", "class", ")", ";", "bind", "(", "IssueNotificationManager", ".", "class", ")", ";", "bind", "(", "EntityReferenceManager", ".", "class", ")", ";", "bind", "(", "CodeCommentNotificationManager", ".", "class", ")", ";", "bind", "(", "CodeCommentManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentManager", ".", "class", ")", ";", "bind", "(", "IssueWatchManager", ".", "class", ")", ".", "to", "(", "DefaultIssueWatchManager", ".", "class", ")", ";", "bind", "(", "IssueChangeManager", ".", "class", ")", ".", "to", "(", "DefaultIssueChangeManager", ".", "class", ")", ";", "bind", "(", "IssueVoteManager", ".", "class", ")", ".", "to", "(", "DefaultIssueVoteManager", ".", "class", ")", ";", "bind", "(", "MilestoneManager", ".", "class", ")", ".", "to", "(", "DefaultMilestoneManager", ".", "class", ")", ";", "bind", "(", "Session", ".", "class", ")", ".", "toProvider", "(", "SessionProvider", ".", "class", ")", ";", "bind", "(", "EntityManager", ".", "class", ")", ".", "toProvider", "(", "SessionProvider", ".", "class", ")", ";", "bind", "(", "SessionFactory", ".", "class", ")", ".", "toProvider", "(", "SessionFactoryProvider", ".", "class", ")", ";", "bind", "(", "EntityManagerFactory", ".", "class", ")", ".", "toProvider", "(", "SessionFactoryProvider", ".", "class", ")", ";", "bind", "(", "IssueCommentManager", ".", "class", ")", ".", "to", "(", "DefaultIssueCommentManager", ".", "class", ")", ";", "bind", "(", "IssueQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultIssueQuerySettingManager", ".", "class", ")", ";", "bind", "(", "PullRequestQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultPullRequestQuerySettingManager", ".", "class", ")", ";", "bind", "(", "CodeCommentQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultCodeCommentQuerySettingManager", ".", "class", ")", ";", "bind", "(", "CommitQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultCommitQuerySettingManager", ".", "class", ")", ";", "bind", "(", "BuildQuerySettingManager", ".", "class", ")", ".", "to", "(", "DefaultBuildQuerySettingManager", ".", "class", ")", ";", "bind", "(", "WebHookManager", ".", "class", ")", ";", "contribute", "(", "ObjectMapperConfigurator", ".", "class", ",", "GitObjectMapperConfigurator", ".", "class", ")", ";", "contribute", "(", "ObjectMapperConfigurator", ".", "class", ",", "HibernateObjectMapperConfigurator", ".", "class", ")", ";", "bind", "(", "Realm", ".", "class", ")", ".", "to", "(", "OneAuthorizingRealm", ".", "class", ")", ";", "bind", "(", "RememberMeManager", ".", "class", ")", ".", "to", "(", "OneRememberMeManager", ".", "class", ")", ";", "bind", "(", "WebSecurityManager", ".", "class", ")", ".", "to", "(", "OneWebSecurityManager", ".", "class", ")", ";", "bind", "(", "FilterChainResolver", ".", "class", ")", ".", "to", "(", "OneFilterChainResolver", ".", "class", ")", ";", "bind", "(", "BasicAuthenticationFilter", ".", "class", ")", ";", "bind", "(", "PasswordService", ".", "class", ")", ".", "to", "(", "OnePasswordService", ".", "class", ")", ";", "bind", "(", "ShiroFilter", ".", "class", ")", ";", "install", "(", "new", "ShiroAopModule", "(", ")", ")", ";", "contribute", "(", "FilterChainConfigurator", ".", "class", ",", "new", "FilterChainConfigurator", "(", ")", "{", "@", "Override", "public", "void", "configure", "(", "FilterChainManager", "filterChainManager", ")", "{", "filterChainManager", ".", "createChain", "(", "\"", "/**/info/refs", "\"", ",", "\"", "noSessionCreation, authcBasic", "\"", ")", ";", "filterChainManager", ".", "createChain", "(", "\"", "/**/git-upload-pack", "\"", ",", "\"", "noSessionCreation, authcBasic", "\"", ")", ";", "filterChainManager", ".", "createChain", "(", "\"", "/**/git-receive-pack", "\"", ",", "\"", "noSessionCreation, authcBasic", "\"", ")", ";", "}", "}", ")", ";", "contributeFromPackage", "(", "Authenticator", ".", "class", ",", "Authenticator", ".", "class", ")", ";", "contribute", "(", "ImplementationProvider", ".", "class", ",", "new", "ImplementationProvider", "(", ")", "{", "@", "Override", "public", "Class", "<", "?", ">", "getAbstractClass", "(", ")", "{", "return", "JobExecutor", ".", "class", ";", "}", "@", "Override", "public", "Collection", "<", "Class", "<", "?", ">", ">", "getImplementations", "(", ")", "{", "return", "Sets", ".", "newHashSet", "(", "AutoDiscoveredJobExecutor", ".", "class", ")", ";", "}", "}", ")", ";", "contribute", "(", "CodePullAuthorizationSource", ".", "class", ",", "DefaultJobManager", ".", "class", ")", ";", "bind", "(", "IndexManager", ".", "class", ")", ".", "to", "(", "DefaultIndexManager", ".", "class", ")", ";", "bind", "(", "SearchManager", ".", "class", ")", ".", "to", "(", "DefaultSearchManager", ".", "class", ")", ";", "bind", "(", "EntityValidator", ".", "class", ")", ".", "to", "(", "DefaultEntityValidator", ".", "class", ")", ";", "bind", "(", "GitFilter", ".", "class", ")", ";", "bind", "(", "GitPreReceiveCallback", ".", "class", ")", ";", "bind", "(", "GitPostReceiveCallback", ".", "class", ")", ";", "bind", "(", "ExecutorService", ".", "class", ")", ".", "toProvider", "(", "new", "Provider", "<", "ExecutorService", ">", "(", ")", "{", "@", "Override", "public", "ExecutorService", "get", "(", ")", "{", "return", "new", "ThreadPoolExecutor", "(", "0", ",", "Integer", ".", "MAX_VALUE", ",", "60L", ",", "TimeUnit", ".", "SECONDS", ",", "new", "SynchronousQueue", "<", "Runnable", ">", "(", ")", ")", "{", "@", "Override", "public", "void", "execute", "(", "Runnable", "command", ")", "{", "try", "{", "super", ".", "execute", "(", "SecurityUtils", ".", "inheritSubject", "(", "command", ")", ")", ";", "}", "catch", "(", "RejectedExecutionException", "e", ")", "{", "if", "(", "!", "isShutdown", "(", ")", ")", "throw", "ExceptionUtils", ".", "unchecked", "(", "e", ")", ";", "}", "}", "}", ";", "}", "}", ")", ".", "in", "(", "Singleton", ".", "class", ")", ";", "bind", "(", "ForkJoinPool", ".", "class", ")", ".", "toInstance", "(", "new", "ForkJoinPool", "(", ")", "{", "@", "Override", "public", "ForkJoinTask", "<", "?", ">", "submit", "(", "Runnable", "task", ")", "{", "return", "super", ".", "submit", "(", "SecurityUtils", ".", "inheritSubject", "(", "task", ")", ")", ";", "}", "@", "Override", "public", "void", "execute", "(", "Runnable", "task", ")", "{", "super", ".", "execute", "(", "SecurityUtils", ".", "inheritSubject", "(", "task", ")", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "ForkJoinTask", "<", "T", ">", "submit", "(", "Callable", "<", "T", ">", "task", ")", "{", "return", "super", ".", "submit", "(", "SecurityUtils", ".", "inheritSubject", "(", "task", ")", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "ForkJoinTask", "<", "T", ">", "submit", "(", "Runnable", "task", ",", "T", "result", ")", "{", "return", "super", ".", "submit", "(", "SecurityUtils", ".", "inheritSubject", "(", "task", ")", ",", "result", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "T", "invokeAny", "(", "Collection", "<", "?", "extends", "Callable", "<", "T", ">", ">", "tasks", ")", "throws", "InterruptedException", ",", "ExecutionException", "{", "return", "super", ".", "invokeAny", "(", "SecurityUtils", ".", "inheritSubject", "(", "tasks", ")", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "T", "invokeAny", "(", "Collection", "<", "?", "extends", "Callable", "<", "T", ">", ">", "tasks", ",", "long", "timeout", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", ",", "ExecutionException", ",", "TimeoutException", "{", "return", "super", ".", "invokeAny", "(", "SecurityUtils", ".", "inheritSubject", "(", "tasks", ")", ",", "timeout", ",", "unit", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "List", "<", "Future", "<", "T", ">", ">", "invokeAll", "(", "Collection", "<", "?", "extends", "Callable", "<", "T", ">", ">", "tasks", ",", "long", "timeout", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", "{", "return", "super", ".", "invokeAll", "(", "SecurityUtils", ".", "inheritSubject", "(", "tasks", ")", ",", "timeout", ",", "unit", ")", ";", "}", "@", "Override", "public", "<", "T", ">", "List", "<", "Future", "<", "T", ">", ">", "invokeAll", "(", "Collection", "<", "?", "extends", "Callable", "<", "T", ">", ">", "tasks", ")", "{", "return", "super", ".", "invokeAll", "(", "SecurityUtils", ".", "inheritSubject", "(", "tasks", ")", ")", ";", "}", "}", ")", ";", "}"], "idx": 73804, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "4f5dc6fb9e50f2c41c4929b0d8c5824b2cca3d65", "function_name": "configure", "body_hash": "56802210df753b260339af288e0017408895f4c3"}
{"code": "@RequestMapping(\"/session\")\n    public String session(Model model, @RequestParam String clientId, @RequestParam String messageOrigin) {\n        model.addAttribute(\"clientId\", escape(clientId));\n        model.addAttribute(\"messageOrigin\", escape(messageOrigin));\n        return \"session\";\n    }", "code_tokens": ["@", "RequestMapping", "(", "\"", "/session", "\"", ")", "public", "String", "session", "(", "Model", "model", ",", "@", "RequestParam", "String", "clientId", ",", "@", "RequestParam", "String", "messageOrigin", ")", "{", "model", ".", "addAttribute", "(", "\"", "clientId", "\"", ",", "escape", "(", "clientId", ")", ")", ";", "model", ".", "addAttribute", "(", "\"", "messageOrigin", "\"", ",", "escape", "(", "messageOrigin", ")", ")", ";", "return", "\"", "session", "\"", ";", "}"], "idx": 80392, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "96fe26711f8f8855d2994a531447f730afd61844", "function_name": "session", "body_hash": "43153592b6361e9063912377fa21022d5512a2dc"}
{"code": "@Override\n    public Resource getResource(String pathInContext)\n    {\n        Resource r=null;\n        if (_relativeResourceBase!=null)\n            pathInContext=URIUtil.addPaths(_relativeResourceBase,pathInContext);\n\n        try\n        {\n            if (_resourceBase!=null)\n            {\n                r = _resourceBase.addPath(pathInContext);\n                if (!_contextHandler.checkAlias(pathInContext,r))\n                    r=null;\n            }\n            else if (_servletContext instanceof ContextHandler.Context)\n            {\n                r = _contextHandler.getResource(pathInContext);\n            }\n            else\n            {\n                URL u = _servletContext.getResource(pathInContext);\n                r = _contextHandler.newResource(u);\n            }\n\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Resource \"+pathInContext+\"=\"+r);\n        }\n        catch (IOException e)\n        {\n            LOG.ignore(e);\n        }\n        catch (Throwable t)\n        {\n            // Any error has potential to reveal fully qualified path\n            throw (InvalidPathException) new InvalidPathException(pathInContext, \"Invalid PathInContext\").initCause(t);\n        }\n\n        if((r==null || !r.exists()) && pathInContext.endsWith(\"/jetty-dir.css\"))\n            r=_stylesheet;\n\n        return r;\n    }", "code_tokens": ["@", "Override", "public", "Resource", "getResource", "(", "String", "pathInContext", ")", "{", "Resource", "r", "=", "null", ";", "if", "(", "_relativeResourceBase", "!=", "null", ")", "pathInContext", "=", "URIUtil", ".", "addPaths", "(", "_relativeResourceBase", ",", "pathInContext", ")", ";", "try", "{", "if", "(", "_resourceBase", "!=", "null", ")", "{", "r", "=", "_resourceBase", ".", "addPath", "(", "pathInContext", ")", ";", "if", "(", "!", "_contextHandler", ".", "checkAlias", "(", "pathInContext", ",", "r", ")", ")", "r", "=", "null", ";", "}", "else", "if", "(", "_servletContext", "instanceof", "ContextHandler", ".", "Context", ")", "{", "r", "=", "_contextHandler", ".", "getResource", "(", "pathInContext", ")", ";", "}", "else", "{", "URL", "u", "=", "_servletContext", ".", "getResource", "(", "pathInContext", ")", ";", "r", "=", "_contextHandler", ".", "newResource", "(", "u", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "Resource ", "\"", "+", "pathInContext", "+", "\"", "=", "\"", "+", "r", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LOG", ".", "ignore", "(", "e", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "throw", "(", "InvalidPathException", ")", "new", "InvalidPathException", "(", "pathInContext", ",", "\"", "Invalid PathInContext", "\"", ")", ".", "initCause", "(", "t", ")", ";", "}", "if", "(", "(", "r", "==", "null", "||", "!", "r", ".", "exists", "(", ")", ")", "&&", "pathInContext", ".", "endsWith", "(", "\"", "/jetty-dir.css", "\"", ")", ")", "r", "=", "_stylesheet", ";", "return", "r", ";", "}"], "idx": 101971, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "53e8bc2a636707e896fd106fbee3596823c2cdc", "function_name": "getResource", "body_hash": "773a77dc9744ece07086612d7ff22196420ecb1d"}
{"code": "public void doNotifyCommit(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        requirePOST();\n\n        // compute the affected paths\n        Set<String> affectedPath = new HashSet<String>();\n        String line;\n        BufferedReader r = new BufferedReader(req.getReader());\n        \n        try {\n\t        while((line=r.readLine())!=null) {\n\t        \tif (LOGGER.isLoggable(FINER)) {\n\t        \t\tLOGGER.finer(\"Reading line: \"+line);\n\t        \t}\n\t            affectedPath.add(line.substring(4));\n\t            if (line.startsWith(\"svnlook changed --revision \")) {\n\t                String msg = \"Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: \" + line;\n\t                LOGGER.warning(msg);\n\t                throw new IllegalArgumentException(msg);\n\t            }\n\t        }\n        } finally {\n        \tIOUtils.closeQuietly(r);\n        }\n\n        if(LOGGER.isLoggable(FINE))\n            LOGGER.fine(\"Change reported to Subversion repository \"+uuid+\" on \"+affectedPath);\n\n        // we can't reliably use req.getParameter() as it can try to parse the payload, which we've already consumed above.\n        // servlet container relies on Content-type to decide if it wants to parse the payload or not, and at least\n        // in case of Jetty, it doesn't check if the payload is\n        QueryParameterMap query = new QueryParameterMap(req);\n        String revParam = query.get(\"rev\");\n        if (revParam == null) {\n            revParam = req.getHeader(\"X-Hudson-Subversion-Revision\");\n        }\n\n        long rev = -1;\n        if (revParam != null) {\n            rev = Long.parseLong(revParam);\n        }\n\n        boolean listenerDidSomething = false;\n        for (Listener listener : ExtensionList.lookup(Listener.class)) {\n            try {\n                if (listener.onNotify(uuid, rev, affectedPath)) {\n                    listenerDidSomething = true;\n                }\n            } catch (Throwable t) {\n                LOGGER.log(WARNING, \"Listener \" + listener.getClass().getName() + \" threw an uncaught exception\", t);\n            }\n        }\n\n        if (!listenerDidSomething) LOGGER.log(Level.WARNING, \"No interest in change to repository UUID {0} found\", uuid);\n\n        rsp.setStatus(SC_OK);\n    }", "code_tokens": ["public", "void", "doNotifyCommit", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "ServletException", ",", "IOException", "{", "requirePOST", "(", ")", ";", "Set", "<", "String", ">", "affectedPath", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "String", "line", ";", "BufferedReader", "r", "=", "new", "BufferedReader", "(", "req", ".", "getReader", "(", ")", ")", ";", "try", "{", "while", "(", "(", "line", "=", "r", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "if", "(", "LOGGER", ".", "isLoggable", "(", "FINER", ")", ")", "{", "LOGGER", ".", "finer", "(", "\"", "Reading line: ", "\"", "+", "line", ")", ";", "}", "affectedPath", ".", "add", "(", "line", ".", "substring", "(", "4", ")", ")", ";", "if", "(", "line", ".", "startsWith", "(", "\"", "svnlook changed --revision ", "\"", ")", ")", "{", "String", "msg", "=", "\"", "Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: ", "\"", "+", "line", ";", "LOGGER", ".", "warning", "(", "msg", ")", ";", "throw", "new", "IllegalArgumentException", "(", "msg", ")", ";", "}", "}", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "r", ")", ";", "}", "if", "(", "LOGGER", ".", "isLoggable", "(", "FINE", ")", ")", "LOGGER", ".", "fine", "(", "\"", "Change reported to Subversion repository ", "\"", "+", "uuid", "+", "\"", " on ", "\"", "+", "affectedPath", ")", ";", "QueryParameterMap", "query", "=", "new", "QueryParameterMap", "(", "req", ")", ";", "String", "revParam", "=", "query", ".", "get", "(", "\"", "rev", "\"", ")", ";", "if", "(", "revParam", "==", "null", ")", "{", "revParam", "=", "req", ".", "getHeader", "(", "\"", "X-Hudson-Subversion-Revision", "\"", ")", ";", "}", "long", "rev", "=", "-", "1", ";", "if", "(", "revParam", "!=", "null", ")", "{", "rev", "=", "Long", ".", "parseLong", "(", "revParam", ")", ";", "}", "boolean", "listenerDidSomething", "=", "false", ";", "for", "(", "Listener", "listener", ":", "ExtensionList", ".", "lookup", "(", "Listener", ".", "class", ")", ")", "{", "try", "{", "if", "(", "listener", ".", "onNotify", "(", "uuid", ",", "rev", ",", "affectedPath", ")", ")", "{", "listenerDidSomething", "=", "true", ";", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "LOGGER", ".", "log", "(", "WARNING", ",", "\"", "Listener ", "\"", "+", "listener", ".", "getClass", "(", ")", ".", "getName", "(", ")", "+", "\"", " threw an uncaught exception", "\"", ",", "t", ")", ";", "}", "}", "if", "(", "!", "listenerDidSomething", ")", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "No interest in change to repository UUID {0} found", "\"", ",", "uuid", ")", ";", "rsp", ".", "setStatus", "(", "SC_OK", ")", ";", "}"], "idx": 89716, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "25f6afbb02a5863f363b0a2f664ac717ace743b4", "function_name": "doNotifyCommit", "body_hash": "80be2847593eb456a968e196c4b61e7981339504"}
{"code": "@Override\n  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container = ctx.getContainer();\n    Map<String, String> environment = container.getLaunchContext()\n        .getEnvironment();\n    String imageName = environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network = environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network == null || network.isEmpty()) {\n      network = defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    validateImageName(imageName);\n\n    String containerIdStr = container.getContainerId().toString();\n    String runAsUser = ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir = ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List<String> -> stored as List -> fetched/converted to List<String>\n    //we can't do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List<String> localDirs = ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> logDirs = ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> filecacheDirs = ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> containerLocalDirs = ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> containerLogDirs = ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map<Path, List<String>> localizedResources = ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List<String> userLocalDirs = ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set<String> capabilities = new HashSet<>(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand = new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n    List<String> allDirs = new ArrayList<>(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts = environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir = StringUtils.split(mount, ':');\n          if (dir.length != 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src = validateMount(dir[0], localizedResources);\n          String dst = dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts = ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    Path nmPrivateContainerScriptPath = ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride = environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride != null && disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List<String> overrideCommands = new ArrayList<>();\n      Path launchDst =\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile = dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp = new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile = ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile != null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching container with cmd: \" + runCommand\n          .getCommandWithArguments());\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "launchContainer", "(", "ContainerRuntimeContext", "ctx", ")", "throws", "ContainerExecutionException", "{", "Container", "container", "=", "ctx", ".", "getContainer", "(", ")", ";", "Map", "<", "String", ",", "String", ">", "environment", "=", "container", ".", "getLaunchContext", "(", ")", ".", "getEnvironment", "(", ")", ";", "String", "imageName", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_IMAGE", ")", ";", "String", "network", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_NETWORK", ")", ";", "if", "(", "network", "==", "null", "||", "network", ".", "isEmpty", "(", ")", ")", "{", "network", "=", "defaultNetwork", ";", "}", "validateContainerNetworkType", "(", "network", ")", ";", "validateImageName", "(", "imageName", ")", ";", "String", "containerIdStr", "=", "container", ".", "getContainerId", "(", ")", ".", "toString", "(", ")", ";", "String", "runAsUser", "=", "ctx", ".", "getExecutionAttribute", "(", "RUN_AS_USER", ")", ";", "Path", "containerWorkDir", "=", "ctx", ".", "getExecutionAttribute", "(", "CONTAINER_WORK_DIR", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "localDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "LOCAL_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "logDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "LOG_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "filecacheDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "FILECACHE_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "containerLocalDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "CONTAINER_LOCAL_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "containerLogDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "CONTAINER_LOG_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Map", "<", "Path", ",", "List", "<", "String", ">", ">", "localizedResources", "=", "ctx", ".", "getExecutionAttribute", "(", "LOCALIZED_RESOURCES", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "userLocalDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "USER_LOCAL_DIRS", ")", ";", "Set", "<", "String", ">", "capabilities", "=", "new", "HashSet", "<", ">", "(", "Arrays", ".", "asList", "(", "conf", ".", "getTrimmedStrings", "(", "YarnConfiguration", ".", "NM_DOCKER_CONTAINER_CAPABILITIES", ",", "YarnConfiguration", ".", "DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES", ")", ")", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "DockerRunCommand", "runCommand", "=", "new", "DockerRunCommand", "(", "containerIdStr", ",", "runAsUser", ",", "imageName", ")", ".", "detachOnRun", "(", ")", ".", "setContainerWorkDir", "(", "containerWorkDir", ".", "toString", "(", ")", ")", ".", "setNetworkType", "(", "network", ")", ".", "setCapabilities", "(", "capabilities", ")", ".", "addMountLocation", "(", "CGROUPS_ROOT_DIRECTORY", ",", "CGROUPS_ROOT_DIRECTORY", "+", "\"", ":ro", "\"", ",", "false", ")", ";", "List", "<", "String", ">", "allDirs", "=", "new", "ArrayList", "<", ">", "(", "containerLocalDirs", ")", ";", "allDirs", ".", "addAll", "(", "filecacheDirs", ")", ";", "allDirs", ".", "add", "(", "containerWorkDir", ".", "toString", "(", ")", ")", ";", "allDirs", ".", "addAll", "(", "containerLogDirs", ")", ";", "allDirs", ".", "addAll", "(", "userLocalDirs", ")", ";", "for", "(", "String", "dir", ":", "allDirs", ")", "{", "runCommand", ".", "addMountLocation", "(", "dir", ",", "dir", ",", "true", ")", ";", "}", "if", "(", "environment", ".", "containsKey", "(", "ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS", ")", ")", "{", "String", "mounts", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS", ")", ";", "if", "(", "!", "mounts", ".", "isEmpty", "(", ")", ")", "{", "for", "(", "String", "mount", ":", "StringUtils", ".", "split", "(", "mounts", ")", ")", "{", "String", "[", "]", "dir", "=", "StringUtils", ".", "split", "(", "mount", ",", "':'", ")", ";", "if", "(", "dir", ".", "length", "!=", "2", ")", "{", "throw", "new", "ContainerExecutionException", "(", "\"", "Invalid mount : ", "\"", "+", "mount", ")", ";", "}", "String", "src", "=", "validateMount", "(", "dir", "[", "0", "]", ",", "localizedResources", ")", ";", "String", "dst", "=", "dir", "[", "1", "]", ";", "runCommand", ".", "addMountLocation", "(", "src", ",", "dst", "+", "\"", ":ro", "\"", ",", "true", ")", ";", "}", "}", "}", "if", "(", "allowPrivilegedContainerExecution", "(", "container", ")", ")", "{", "runCommand", ".", "setPrivileged", "(", ")", ";", "}", "String", "resourcesOpts", "=", "ctx", ".", "getExecutionAttribute", "(", "RESOURCES_OPTIONS", ")", ";", "addCGroupParentIfRequired", "(", "resourcesOpts", ",", "containerIdStr", ",", "runCommand", ")", ";", "Path", "nmPrivateContainerScriptPath", "=", "ctx", ".", "getExecutionAttribute", "(", "NM_PRIVATE_CONTAINER_SCRIPT_PATH", ")", ";", "String", "disableOverride", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE", ")", ";", "if", "(", "disableOverride", "!=", "null", "&&", "disableOverride", ".", "equals", "(", "\"", "true", "\"", ")", ")", "{", "if", "(", "LOG", ".", "isInfoEnabled", "(", ")", ")", "{", "LOG", ".", "info", "(", "\"", "command override disabled", "\"", ")", ";", "}", "}", "else", "{", "List", "<", "String", ">", "overrideCommands", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Path", "launchDst", "=", "new", "Path", "(", "containerWorkDir", ",", "ContainerLaunch", ".", "CONTAINER_SCRIPT", ")", ";", "overrideCommands", ".", "add", "(", "\"", "bash", "\"", ")", ";", "overrideCommands", ".", "add", "(", "launchDst", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ")", ";", "runCommand", ".", "setOverrideCommandWithArgs", "(", "overrideCommands", ")", ";", "}", "String", "commandFile", "=", "dockerClient", ".", "writeCommandToTempFile", "(", "runCommand", ",", "containerIdStr", ")", ";", "PrivilegedOperation", "launchOp", "=", "new", "PrivilegedOperation", "(", "PrivilegedOperation", ".", "OperationType", ".", "LAUNCH_DOCKER_CONTAINER", ")", ";", "launchOp", ".", "appendArgs", "(", "runAsUser", ",", "ctx", ".", "getExecutionAttribute", "(", "USER", ")", ",", "Integer", ".", "toString", "(", "PrivilegedOperation", ".", "RunAsUserCommand", ".", "LAUNCH_DOCKER_CONTAINER", ".", "getValue", "(", ")", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "APPID", ")", ",", "containerIdStr", ",", "containerWorkDir", ".", "toString", "(", ")", ",", "nmPrivateContainerScriptPath", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "NM_PRIVATE_TOKENS_PATH", ")", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "PID_FILE_PATH", ")", ".", "toString", "(", ")", ",", "StringUtils", ".", "join", "(", "PrivilegedOperation", ".", "LINUX_FILE_PATH_SEPARATOR", ",", "localDirs", ")", ",", "StringUtils", ".", "join", "(", "PrivilegedOperation", ".", "LINUX_FILE_PATH_SEPARATOR", ",", "logDirs", ")", ",", "commandFile", ",", "resourcesOpts", ")", ";", "String", "tcCommandFile", "=", "ctx", ".", "getExecutionAttribute", "(", "TC_COMMAND_FILE", ")", ";", "if", "(", "tcCommandFile", "!=", "null", ")", "{", "launchOp", ".", "appendArgs", "(", "tcCommandFile", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Launching container with cmd: ", "\"", "+", "runCommand", ".", "getCommandWithArguments", "(", ")", ")", ";", "}", "try", "{", "privilegedOperationExecutor", ".", "executePrivilegedOperation", "(", "null", ",", "launchOp", ",", "null", ",", "container", ".", "getLaunchContext", "(", ")", ".", "getEnvironment", "(", ")", ",", "false", ",", "false", ")", ";", "}", "catch", "(", "PrivilegedOperationException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Launch container failed. Exception: ", "\"", ",", "e", ")", ";", "LOG", ".", "info", "(", "\"", "Docker command used: ", "\"", "+", "runCommand", ".", "getCommandWithArguments", "(", ")", ")", ";", "throw", "new", "ContainerExecutionException", "(", "\"", "Launch container failed", "\"", ",", "e", ".", "getExitCode", "(", ")", ",", "e", ".", "getOutput", "(", ")", ",", "e", ".", "getErrorOutput", "(", ")", ")", ";", "}", "}"], "idx": 7739, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "0319e74c2512d47d47ab9df834f5b6455be7d968", "function_name": "launchContainer", "body_hash": "b371a03ddd72737fbdffe931341f8254cffda75c"}
{"code": "private void doTestRewrite(String config, String request, String expectedURI,\n            String expectedQueryString, String expectedAttributeValue) throws Exception {\n\n        Tomcat tomcat = getTomcatInstance();\n\n        // No file system docBase required\n        Context ctx = tomcat.addContext(\"\", null);\n\n        RewriteValve rewriteValve = new RewriteValve();\n        ctx.getPipeline().addValve(rewriteValve);\n\n        rewriteValve.setConfiguration(config);\n\n        Tomcat.addServlet(ctx, \"snoop\", new SnoopServlet());\n        ctx.addServletMappingDecoded(\"/a/%5A\", \"snoop\");\n        ctx.addServletMappingDecoded(\"/c/*\", \"snoop\");\n        Tomcat.addServlet(ctx, \"default\", new DefaultServlet());\n        ctx.addServletMappingDecoded(\"/\", \"default\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + request);\n        res.setCharset(StandardCharsets.UTF_8);\n\n        String body = res.toString();\n        RequestDescriptor requestDesc = SnoopResult.parse(body);\n        String requestURI = requestDesc.getRequestInfo(\"REQUEST-URI\");\n        Assert.assertEquals(expectedURI, requestURI);\n\n        if (expectedQueryString != null) {\n            String queryString = requestDesc.getRequestInfo(\"REQUEST-QUERY-STRING\");\n            Assert.assertEquals(expectedQueryString, queryString);\n        }\n\n        if (expectedAttributeValue != null) {\n            String attributeValue = requestDesc.getAttribute(\"X-Test\");\n            Assert.assertEquals(expectedAttributeValue, attributeValue);\n        }\n    }", "code_tokens": ["private", "void", "doTestRewrite", "(", "String", "config", ",", "String", "request", ",", "String", "expectedURI", ",", "String", "expectedQueryString", ",", "String", "expectedAttributeValue", ")", "throws", "Exception", "{", "Tomcat", "tomcat", "=", "getTomcatInstance", "(", ")", ";", "Context", "ctx", "=", "tomcat", ".", "addContext", "(", "\"", "\"", ",", "null", ")", ";", "RewriteValve", "rewriteValve", "=", "new", "RewriteValve", "(", ")", ";", "ctx", ".", "getPipeline", "(", ")", ".", "addValve", "(", "rewriteValve", ")", ";", "rewriteValve", ".", "setConfiguration", "(", "config", ")", ";", "Tomcat", ".", "addServlet", "(", "ctx", ",", "\"", "snoop", "\"", ",", "new", "SnoopServlet", "(", ")", ")", ";", "ctx", ".", "addServletMappingDecoded", "(", "\"", "/a/%5A", "\"", ",", "\"", "snoop", "\"", ")", ";", "ctx", ".", "addServletMappingDecoded", "(", "\"", "/c/*", "\"", ",", "\"", "snoop", "\"", ")", ";", "Tomcat", ".", "addServlet", "(", "ctx", ",", "\"", "default", "\"", ",", "new", "DefaultServlet", "(", ")", ")", ";", "ctx", ".", "addServletMappingDecoded", "(", "\"", "/", "\"", ",", "\"", "default", "\"", ")", ";", "tomcat", ".", "start", "(", ")", ";", "ByteChunk", "res", "=", "getUrl", "(", "\"", "http://localhost:", "\"", "+", "getPort", "(", ")", "+", "request", ")", ";", "res", ".", "setCharset", "(", "StandardCharsets", ".", "UTF_8", ")", ";", "String", "body", "=", "res", ".", "toString", "(", ")", ";", "RequestDescriptor", "requestDesc", "=", "SnoopResult", ".", "parse", "(", "body", ")", ";", "String", "requestURI", "=", "requestDesc", ".", "getRequestInfo", "(", "\"", "REQUEST-URI", "\"", ")", ";", "Assert", ".", "assertEquals", "(", "expectedURI", ",", "requestURI", ")", ";", "if", "(", "expectedQueryString", "!=", "null", ")", "{", "String", "queryString", "=", "requestDesc", ".", "getRequestInfo", "(", "\"", "REQUEST-QUERY-STRING", "\"", ")", ";", "Assert", ".", "assertEquals", "(", "expectedQueryString", ",", "queryString", ")", ";", "}", "if", "(", "expectedAttributeValue", "!=", "null", ")", "{", "String", "attributeValue", "=", "requestDesc", ".", "getAttribute", "(", "\"", "X-Test", "\"", ")", ";", "Assert", ".", "assertEquals", "(", "expectedAttributeValue", ",", "attributeValue", ")", ";", "}", "}"], "idx": 11921, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "779d5d34e68e50d2f721897050b147106992f566", "function_name": "doTestRewrite", "body_hash": "e946359e2f7d18ae006862f8944c8b24a6cf6469"}
{"code": "public <T> T readObject() throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStreamEx(in,\n                getClass().getClassLoader(), ClassFilter.DEFAULT);\n        return (T)ois.readObject();\n    }", "code_tokens": ["public", "<", "T", ">", "T", "readObject", "(", ")", "throws", "IOException", ",", "ClassNotFoundException", "{", "ObjectInputStream", "ois", "=", "new", "ObjectInputStreamEx", "(", "in", ",", "getClass", "(", ")", ".", "getClassLoader", "(", ")", ",", "ClassFilter", ".", "DEFAULT", ")", ";", "return", "(", "T", ")", "ois", ".", "readObject", "(", ")", ";", "}"], "idx": 74879, "cwe": "CWE-77", "target": 0, "status": "FIXED", "commit": "5bd9b55a2a3249939fd78c501b8959a804c1164b", "function_name": "readObject", "body_hash": "5704a4a0d21bcbdefc9363c79cb3929cc49bfeff"}
{"code": "public void setAllowJavaSerializedObject(boolean allowJavaSerializedObject) {\n        this.allowJavaSerializedObject = allowJavaSerializedObject;\n    }", "code_tokens": ["public", "void", "setAllowJavaSerializedObject", "(", "boolean", "allowJavaSerializedObject", ")", "{", "this", ".", "allowJavaSerializedObject", "=", "allowJavaSerializedObject", ";", "}"], "idx": 4129, "cwe": "CWE-19", "target": 0, "status": "FIXED", "commit": "9cbd5867fe73ef07ecba6f16d64689632e3f2a16", "function_name": "setAllowJavaSerializedObject", "body_hash": "eb2db4828f6bdba88df4c247a4de8f8513c04f9a"}
{"code": "@Override\n\tpublic void configure(ServletContextHandler context) {\n\t\tcontext.setContextPath(\"/\");\n\t\t\n\t\tcontext.getSessionHandler().setMaxInactiveInterval(serverConfig.getSessionTimeout());\n\t\t\n\t\tcontext.setInitParameter(EnvironmentLoader.ENVIRONMENT_CLASS_PARAM, DefaultWebEnvironment.class.getName());\n\t\tcontext.addEventListener(new EnvironmentLoaderListener());\n\t\tcontext.addFilter(new FilterHolder(shiroFilter), \"/*\", EnumSet.allOf(DispatcherType.class));\n\t\t\n        context.addFilter(new FilterHolder(gitFilter), \"/*\", EnumSet.allOf(DispatcherType.class));\n\t\t\n\t\tcontext.addServlet(new ServletHolder(preReceiveServlet), GitPreReceiveCallback.PATH + \"/*\");\n        \n        context.addServlet(new ServletHolder(postReceiveServlet), GitPostReceiveCallback.PATH + \"/*\");\n        \n\t\t/*\n\t\t * Add wicket servlet as the default servlet which will serve all requests failed to \n\t\t * match a path pattern\n\t\t */\n\t\tcontext.addServlet(new ServletHolder(wicketServlet), \"/\");\n\t\t\n\t\tcontext.addServlet(new ServletHolder(attachmentUploadServlet), \"/attachment_upload\");\n\t\t\n\t\tcontext.addServlet(new ServletHolder(new ClasspathAssetServlet(ImageScope.class)), \"/img/*\");\n\t\tcontext.addServlet(new ServletHolder(new ClasspathAssetServlet(IconScope.class)), \"/icon/*\");\n\t\t\n\t\tcontext.getSessionHandler().addEventListener(new HttpSessionListener() {\n\n\t\t\t@Override\n\t\t\tpublic void sessionCreated(HttpSessionEvent se) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void sessionDestroyed(HttpSessionEvent se) {\n\t\t\t\twebSocketManager.onDestroySession(se.getSession().getId());\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t/*\n\t\t * Configure a servlet to serve contents under site folder. Site folder can be used \n\t\t * to hold site specific web assets.   \n\t\t */\n\t\tServletHolder fileServletHolder = new ServletHolder(new FileAssetServlet(Bootstrap.getSiteDir()));\n\t\tcontext.addServlet(fileServletHolder, \"/site/*\");\n\t\tcontext.addServlet(fileServletHolder, \"/robots.txt\");\n\t\t\n\t\tcontext.addServlet(new ServletHolder(jerseyServlet), \"/rest/*\");\t\t\n\t}", "code_tokens": ["@", "Override", "public", "void", "configure", "(", "ServletContextHandler", "context", ")", "{", "context", ".", "setContextPath", "(", "\"", "/", "\"", ")", ";", "context", ".", "getSessionHandler", "(", ")", ".", "setMaxInactiveInterval", "(", "serverConfig", ".", "getSessionTimeout", "(", ")", ")", ";", "context", ".", "setInitParameter", "(", "EnvironmentLoader", ".", "ENVIRONMENT_CLASS_PARAM", ",", "DefaultWebEnvironment", ".", "class", ".", "getName", "(", ")", ")", ";", "context", ".", "addEventListener", "(", "new", "EnvironmentLoaderListener", "(", ")", ")", ";", "context", ".", "addFilter", "(", "new", "FilterHolder", "(", "shiroFilter", ")", ",", "\"", "/*", "\"", ",", "EnumSet", ".", "allOf", "(", "DispatcherType", ".", "class", ")", ")", ";", "context", ".", "addFilter", "(", "new", "FilterHolder", "(", "gitFilter", ")", ",", "\"", "/*", "\"", ",", "EnumSet", ".", "allOf", "(", "DispatcherType", ".", "class", ")", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "preReceiveServlet", ")", ",", "GitPreReceiveCallback", ".", "PATH", "+", "\"", "/*", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "postReceiveServlet", ")", ",", "GitPostReceiveCallback", ".", "PATH", "+", "\"", "/*", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "wicketServlet", ")", ",", "\"", "/", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "attachmentUploadServlet", ")", ",", "\"", "/attachment_upload", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "new", "ClasspathAssetServlet", "(", "ImageScope", ".", "class", ")", ")", ",", "\"", "/img/*", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "new", "ClasspathAssetServlet", "(", "IconScope", ".", "class", ")", ")", ",", "\"", "/icon/*", "\"", ")", ";", "context", ".", "getSessionHandler", "(", ")", ".", "addEventListener", "(", "new", "HttpSessionListener", "(", ")", "{", "@", "Override", "public", "void", "sessionCreated", "(", "HttpSessionEvent", "se", ")", "{", "}", "@", "Override", "public", "void", "sessionDestroyed", "(", "HttpSessionEvent", "se", ")", "{", "webSocketManager", ".", "onDestroySession", "(", "se", ".", "getSession", "(", ")", ".", "getId", "(", ")", ")", ";", "}", "}", ")", ";", "ServletHolder", "fileServletHolder", "=", "new", "ServletHolder", "(", "new", "FileAssetServlet", "(", "Bootstrap", ".", "getSiteDir", "(", ")", ")", ")", ";", "context", ".", "addServlet", "(", "fileServletHolder", ",", "\"", "/site/*", "\"", ")", ";", "context", ".", "addServlet", "(", "fileServletHolder", ",", "\"", "/robots.txt", "\"", ")", ";", "context", ".", "addServlet", "(", "new", "ServletHolder", "(", "jerseyServlet", ")", ",", "\"", "/rest/*", "\"", ")", ";", "}"], "idx": 61666, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "f864053176c08f59ef2d97fea192ceca46a4d9be", "function_name": "configure", "body_hash": "a484525fe334d2ba69637b39773e08c85fa79df8"}
{"code": "private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        if (!contentLengthFields.isEmpty()) {\n            HttpVersion version = message.protocolVersion();\n            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n                    && version.minorVersion() == 0);\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n                    isHttp10OrEarlier, allowDuplicateContentLengths);\n            if (contentLength != -1) {\n                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n            }\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }", "code_tokens": ["private", "State", "readHeaders", "(", "ByteBuf", "buffer", ")", "{", "final", "HttpMessage", "message", "=", "this", ".", "message", ";", "final", "HttpHeaders", "headers", "=", "message", ".", "headers", "(", ")", ";", "AppendableCharSequence", "line", "=", "headerParser", ".", "parse", "(", "buffer", ")", ";", "if", "(", "line", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "line", ".", "length", "(", ")", ">", "0", ")", "{", "do", "{", "char", "firstChar", "=", "line", ".", "charAtUnsafe", "(", "0", ")", ";", "if", "(", "name", "!=", "null", "&&", "(", "firstChar", "==", "' '", "||", "firstChar", "==", "'\\t'", ")", ")", "{", "String", "trimmedLine", "=", "line", ".", "toString", "(", ")", ".", "trim", "(", ")", ";", "String", "valueStr", "=", "String", ".", "valueOf", "(", "value", ")", ";", "value", "=", "valueStr", "+", "' '", "+", "trimmedLine", ";", "}", "else", "{", "if", "(", "name", "!=", "null", ")", "{", "headers", ".", "add", "(", "name", ",", "value", ")", ";", "}", "splitHeader", "(", "line", ")", ";", "}", "line", "=", "headerParser", ".", "parse", "(", "buffer", ")", ";", "if", "(", "line", "==", "null", ")", "{", "return", "null", ";", "}", "}", "while", "(", "line", ".", "length", "(", ")", ">", "0", ")", ";", "}", "if", "(", "name", "!=", "null", ")", "{", "headers", ".", "add", "(", "name", ",", "value", ")", ";", "}", "name", "=", "null", ";", "value", "=", "null", ";", "List", "<", "String", ">", "contentLengthFields", "=", "headers", ".", "getAll", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ")", ";", "if", "(", "!", "contentLengthFields", ".", "isEmpty", "(", ")", ")", "{", "HttpVersion", "version", "=", "message", ".", "protocolVersion", "(", ")", ";", "boolean", "isHttp10OrEarlier", "=", "version", ".", "majorVersion", "(", ")", "<", "1", "||", "(", "version", ".", "majorVersion", "(", ")", "==", "1", "&&", "version", ".", "minorVersion", "(", ")", "==", "0", ")", ";", "contentLength", "=", "HttpUtil", ".", "normalizeAndGetContentLength", "(", "contentLengthFields", ",", "isHttp10OrEarlier", ",", "allowDuplicateContentLengths", ")", ";", "if", "(", "contentLength", "!=", "-", "1", ")", "{", "headers", ".", "set", "(", "HttpHeaderNames", ".", "CONTENT_LENGTH", ",", "contentLength", ")", ";", "}", "}", "if", "(", "isContentAlwaysEmpty", "(", "message", ")", ")", "{", "HttpUtil", ".", "setTransferEncodingChunked", "(", "message", ",", "false", ")", ";", "return", "State", ".", "SKIP_CONTROL_CHARS", ";", "}", "else", "if", "(", "HttpUtil", ".", "isTransferEncodingChunked", "(", "message", ")", ")", "{", "if", "(", "!", "contentLengthFields", ".", "isEmpty", "(", ")", "&&", "message", ".", "protocolVersion", "(", ")", "==", "HttpVersion", ".", "HTTP_1_1", ")", "{", "handleTransferEncodingChunkedWithContentLength", "(", "message", ")", ";", "}", "return", "State", ".", "READ_CHUNK_SIZE", ";", "}", "else", "if", "(", "contentLength", "(", ")", ">=", "0", ")", "{", "return", "State", ".", "READ_FIXED_LENGTH_CONTENT", ";", "}", "else", "{", "return", "State", ".", "READ_VARIABLE_LENGTH_CONTENT", ";", "}", "}"], "idx": 53997, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "89c241e3b1795ff257af4ad6eadc616cb2fb3dc4", "function_name": "readHeaders", "body_hash": "7f101a61c0cb887a7e41b537a1fe3d1b6b837dd6"}
{"code": "public static Connection connectSync(final ProtocolConnectionConfiguration configuration) throws IOException {\n        long timeoutMillis = configuration.getConnectionTimeout();\n        CallbackHandler handler = configuration.getCallbackHandler();\n        final CallbackHandler actualHandler;\n        ProtocolTimeoutHandler timeoutHandler = configuration.getTimeoutHandler();\n        // Note: If a client supplies a ProtocolTimeoutHandler it is taking on full responsibility for timeout management.\n        if (timeoutHandler == null) {\n            GeneralTimeoutHandler defaultTimeoutHandler = new GeneralTimeoutHandler();\n            // No point wrapping our AnonymousCallbackHandler.\n            actualHandler = handler != null ? new WrapperCallbackHandler(defaultTimeoutHandler, handler) : null;\n            timeoutHandler = defaultTimeoutHandler;\n        } else {\n            actualHandler = handler;\n        }\n\n        final IoFuture<Connection> future = connect(actualHandler, configuration);\n\n        IoFuture.Status status = timeoutHandler.await(future, timeoutMillis);\n\n        Connection result = checkFuture(status, future, configuration);\n        if (result == null) {\n            // Did not complete in time; tell remoting we don't want it\n            future.cancel();\n            // In case the future completed between when we waited for it and when we cancelled,\n            // close any connection that was established. We don't want to risk using a\n            // Connection after we told remoting to cancel, and if we don't use it we must close it.\n            Connection toClose = checkFuture(future.getStatus(), future, configuration);\n            StreamUtils.safeClose(toClose);\n\n            throw ProtocolLogger.ROOT_LOGGER.couldNotConnect(configuration.getUri());\n        }\n        return result;\n    }", "code_tokens": ["public", "static", "Connection", "connectSync", "(", "final", "ProtocolConnectionConfiguration", "configuration", ")", "throws", "IOException", "{", "long", "timeoutMillis", "=", "configuration", ".", "getConnectionTimeout", "(", ")", ";", "CallbackHandler", "handler", "=", "configuration", ".", "getCallbackHandler", "(", ")", ";", "final", "CallbackHandler", "actualHandler", ";", "ProtocolTimeoutHandler", "timeoutHandler", "=", "configuration", ".", "getTimeoutHandler", "(", ")", ";", "if", "(", "timeoutHandler", "==", "null", ")", "{", "GeneralTimeoutHandler", "defaultTimeoutHandler", "=", "new", "GeneralTimeoutHandler", "(", ")", ";", "actualHandler", "=", "handler", "!=", "null", "?", "new", "WrapperCallbackHandler", "(", "defaultTimeoutHandler", ",", "handler", ")", ":", "null", ";", "timeoutHandler", "=", "defaultTimeoutHandler", ";", "}", "else", "{", "actualHandler", "=", "handler", ";", "}", "final", "IoFuture", "<", "Connection", ">", "future", "=", "connect", "(", "actualHandler", ",", "configuration", ")", ";", "IoFuture", ".", "Status", "status", "=", "timeoutHandler", ".", "await", "(", "future", ",", "timeoutMillis", ")", ";", "Connection", "result", "=", "checkFuture", "(", "status", ",", "future", ",", "configuration", ")", ";", "if", "(", "result", "==", "null", ")", "{", "future", ".", "cancel", "(", ")", ";", "Connection", "toClose", "=", "checkFuture", "(", "future", ".", "getStatus", "(", ")", ",", "future", ",", "configuration", ")", ";", "StreamUtils", ".", "safeClose", "(", "toClose", ")", ";", "throw", "ProtocolLogger", ".", "ROOT_LOGGER", ".", "couldNotConnect", "(", "configuration", ".", "getUri", "(", ")", ")", ";", "}", "return", "result", ";", "}"], "idx": 52881, "cwe": "CWE-401", "target": 0, "status": "FIXED", "commit": "0332eaa2edb07df770bc429fa46bed9e0f2d1671", "function_name": "connectSync", "body_hash": "65a64cabb6861e0a7d21e80a57eb66571ca719a8"}
{"code": "private static byte[] getRandomKey(List<String> dataRefURIs, Document doc, WSDocInfo wsDocInfo) throws WSSecurityException {\n        try {\n            String alg = \"AES\";\n            int size = 16;\n            if (!dataRefURIs.isEmpty()) {\n                String uri = dataRefURIs.iterator().next();\n                Element ee = ReferenceListProcessor.findEncryptedDataElement(doc, wsDocInfo, uri);\n                String algorithmURI = X509Util.getEncAlgo(ee);\n                alg = JCEMapper.getJCEKeyAlgorithmFromURI(algorithmURI);\n                size = KeyUtils.getKeyLength(algorithmURI);\n            }\n            KeyGenerator kgen = KeyGenerator.getInstance(alg);\n            kgen.init(size * 8);\n            SecretKey k = kgen.generateKey();\n            return k.getEncoded();\n        } catch (Throwable ex) {\n            // Fallback to just using AES to avoid attacks on EncryptedData algorithms\n            try {\n                KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n                kgen.init(128);\n                SecretKey k = kgen.generateKey();\n                return k.getEncoded();\n            } catch (NoSuchAlgorithmException e) {\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILED_CHECK, e);\n            }\n        }\n    }", "code_tokens": ["private", "static", "byte", "[", "]", "getRandomKey", "(", "List", "<", "String", ">", "dataRefURIs", ",", "Document", "doc", ",", "WSDocInfo", "wsDocInfo", ")", "throws", "WSSecurityException", "{", "try", "{", "String", "alg", "=", "\"", "AES", "\"", ";", "int", "size", "=", "16", ";", "if", "(", "!", "dataRefURIs", ".", "isEmpty", "(", ")", ")", "{", "String", "uri", "=", "dataRefURIs", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "Element", "ee", "=", "ReferenceListProcessor", ".", "findEncryptedDataElement", "(", "doc", ",", "wsDocInfo", ",", "uri", ")", ";", "String", "algorithmURI", "=", "X509Util", ".", "getEncAlgo", "(", "ee", ")", ";", "alg", "=", "JCEMapper", ".", "getJCEKeyAlgorithmFromURI", "(", "algorithmURI", ")", ";", "size", "=", "KeyUtils", ".", "getKeyLength", "(", "algorithmURI", ")", ";", "}", "KeyGenerator", "kgen", "=", "KeyGenerator", ".", "getInstance", "(", "alg", ")", ";", "kgen", ".", "init", "(", "size", "*", "8", ")", ";", "SecretKey", "k", "=", "kgen", ".", "generateKey", "(", ")", ";", "return", "k", ".", "getEncoded", "(", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "try", "{", "KeyGenerator", "kgen", "=", "KeyGenerator", ".", "getInstance", "(", "\"", "AES", "\"", ")", ";", "kgen", ".", "init", "(", "128", ")", ";", "SecretKey", "k", "=", "kgen", ".", "generateKey", "(", ")", ";", "return", "k", ".", "getEncoded", "(", ")", ";", "}", "catch", "(", "NoSuchAlgorithmException", "e", ")", "{", "throw", "new", "WSSecurityException", "(", "WSSecurityException", ".", "ErrorCode", ".", "FAILED_CHECK", ",", "e", ")", ";", "}", "}", "}"], "idx": 42559, "cwe": "CWE-327", "target": 0, "status": "FIXED", "commit": "de5104b30", "function_name": "getRandomKey", "body_hash": "9859c4238578e9173ac7186572b94bcfe9bd563e"}
{"code": "private void initialJpsClassList(String packageName) throws Exception {\n                Package pk = Package.getPackage(packageName);\n                List<Class> classesForPackage = new ArrayList<Class>();\n                if (pk != null) {\n                        classesForPackage.addAll(getClassesForPackage(pk));\n                } else {\n                        classesForPackage.addAll(getClassesForPackage(packageName));\n                }\n                for (Class<Object> clazz : classesForPackage) {\n\n                        jpaClasses.add(clazz);\n                }\n        }", "code_tokens": ["private", "void", "initialJpsClassList", "(", "String", "packageName", ")", "throws", "Exception", "{", "Package", "pk", "=", "Package", ".", "getPackage", "(", "packageName", ")", ";", "List", "<", "Class", ">", "classesForPackage", "=", "new", "ArrayList", "<", "Class", ">", "(", ")", ";", "if", "(", "pk", "!=", "null", ")", "{", "classesForPackage", ".", "addAll", "(", "getClassesForPackage", "(", "pk", ")", ")", ";", "}", "else", "{", "classesForPackage", ".", "addAll", "(", "getClassesForPackage", "(", "packageName", ")", ")", ";", "}", "for", "(", "Class", "<", "Object", ">", "clazz", ":", "classesForPackage", ")", "{", "jpaClasses", ".", "add", "(", "clazz", ")", ";", "}", "}"], "idx": 59482, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "e6ae0f4ce39e73ba29ab1c2926a41ac71e68574a", "function_name": "initialJpsClassList", "body_hash": "79cf873f24e082b3d4fdead72728cf6c5dc2e7d8"}
{"code": "private boolean verifySecret(String action, int bridgeSecret) throws IllegalAccessException {\n        if (!jsMessageQueue.isBridgeEnabled()) {\n            if (bridgeSecret == -1) {\n                Log.d(LOG_TAG, action + \" call made before bridge was enabled.\");\n            } else {\n                Log.d(LOG_TAG, \"Ignoring \" + action + \" from previous page load.\");\n            }\n            return false;\n        }\n        // Bridge secret wrong and bridge not due to it being from the previous page.\n        if (expectedBridgeSecret < 0 || bridgeSecret != expectedBridgeSecret) {\n            throw new IllegalAccessException();\n        }\n        return true;\n    }", "code_tokens": ["private", "boolean", "verifySecret", "(", "String", "action", ",", "int", "bridgeSecret", ")", "throws", "IllegalAccessException", "{", "if", "(", "!", "jsMessageQueue", ".", "isBridgeEnabled", "(", ")", ")", "{", "if", "(", "bridgeSecret", "==", "-", "1", ")", "{", "Log", ".", "d", "(", "LOG_TAG", ",", "action", "+", "\"", " call made before bridge was enabled.", "\"", ")", ";", "}", "else", "{", "Log", ".", "d", "(", "LOG_TAG", ",", "\"", "Ignoring ", "\"", "+", "action", "+", "\"", " from previous page load.", "\"", ")", ";", "}", "return", "false", ";", "}", "if", "(", "expectedBridgeSecret", "<", "0", "||", "bridgeSecret", "!=", "expectedBridgeSecret", ")", "{", "throw", "new", "IllegalAccessException", "(", ")", ";", "}", "return", "true", ";", "}"], "idx": 110837, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "032ea8a8d386d8bcffc5de7fd3e4202478effb7d", "function_name": "verifySecret", "body_hash": "f0c7c8b7fd64e5012ad4221f934f14e2ab3ef01e"}
{"code": "public String findFilter( String url_suffix )\n    {\n        if( url_suffix == null )\n        {\n            throw new IllegalArgumentException( \"The url_suffix must not be null.\" );\n        }\n        \n        CaptureType type = em.find( CaptureType.class, url_suffix );\n        \n        if( type == null )\n        {\n            throw new IllegalArgumentException( \"The url_suffix must exist in the database.\" );\n        }\n        \n        // It is okay for the capture filter itself to be null, but the CaptureType\n        // must be in the database, otherwise the user could effectively forge\n        // a capture filter for \"all\" just by requesting a non-existent filter.\n        \n        return type.getCaptureFilter();\n    }", "code_tokens": ["public", "String", "findFilter", "(", "String", "url_suffix", ")", "{", "if", "(", "url_suffix", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "The url_suffix must not be null.", "\"", ")", ";", "}", "CaptureType", "type", "=", "em", ".", "find", "(", "CaptureType", ".", "class", ",", "url_suffix", ")", ";", "if", "(", "type", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "The url_suffix must exist in the database.", "\"", ")", ";", "}", "return", "type", ".", "getCaptureFilter", "(", ")", ";", "}"], "idx": 74270, "cwe": "CWE-754", "target": 0, "status": "FIXED", "commit": "0f74f431e0970a2e5784dbd955cfa4760e3b1ef7", "function_name": "findFilter", "body_hash": "ca891f60e22f7389d0ed5aa403057975c9e19e9f"}
{"code": "private static String localeToString(Locale locale) {\n        if (locale != null) {\n            return escapeXml(locale.toString());//locale.getDisplayName();\n        } else {\n            return \"\";\n        }\n    }", "code_tokens": ["private", "static", "String", "localeToString", "(", "Locale", "locale", ")", "{", "if", "(", "locale", "!=", "null", ")", "{", "return", "escapeXml", "(", "locale", ".", "toString", "(", ")", ")", ";", "}", "else", "{", "return", "\"", "\"", ";", "}", "}"], "idx": 79326, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "5971f9392edc6d70808b2599b062b050fcd11d23", "function_name": "localeToString", "body_hash": "63e600113e37acbcbdd198048516642e0c79fa82"}
{"code": "public List<String> getUserList(JdbcRealm obj) {\n    List<String> userlist = new ArrayList<>();\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    DataSource dataSource = null;\n    String authQuery = \"\";\n    String retval[];\n    String tablename = \"\";\n    String username = \"\";\n    String userquery = \"\";\n    try {\n      dataSource = (DataSource) FieldUtils.readField(obj, \"dataSource\", true);\n      authQuery = (String) FieldUtils.readField(obj, \"authenticationQuery\", true);\n      LOG.info(authQuery);\n      String authQueryLowerCase = authQuery.toLowerCase();\n      retval = authQueryLowerCase.split(\"from\", 2);\n      if (retval.length >= 2) {\n        retval = retval[1].split(\"with|where\", 2);\n        tablename = retval[0];\n        retval = retval[1].split(\"where\", 2);\n        if (retval.length >= 2)\n          retval = retval[1].split(\"=\", 2);\n        else\n          retval = retval[0].split(\"=\", 2);\n        username = retval[0];\n      }\n\n      if (StringUtils.isBlank(username) || StringUtils.isBlank(tablename)) {\n        return userlist;\n      }\n\n      userquery = \"select \" + username + \" from \" + tablename;\n\n    } catch (IllegalAccessException e) {\n      LOG.error(\"Error while accessing dataSource for JDBC Realm\", e);\n      return null;\n    }\n\n    try {\n      Connection con = dataSource.getConnection();\n      ps = con.prepareStatement(userquery);\n      rs = ps.executeQuery();\n      while (rs.next()) {\n        userlist.add(rs.getString(1).trim());\n      }\n    } catch (Exception e) {\n      LOG.error(\"Error retrieving User list from JDBC Realm\", e);\n    } finally {\n      JdbcUtils.closeResultSet(rs);\n      JdbcUtils.closeStatement(ps);\n    }\n    return userlist;\n  }", "code_tokens": ["public", "List", "<", "String", ">", "getUserList", "(", "JdbcRealm", "obj", ")", "{", "List", "<", "String", ">", "userlist", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "PreparedStatement", "ps", "=", "null", ";", "ResultSet", "rs", "=", "null", ";", "DataSource", "dataSource", "=", "null", ";", "String", "authQuery", "=", "\"", "\"", ";", "String", "retval", "[", "]", ";", "String", "tablename", "=", "\"", "\"", ";", "String", "username", "=", "\"", "\"", ";", "String", "userquery", "=", "\"", "\"", ";", "try", "{", "dataSource", "=", "(", "DataSource", ")", "FieldUtils", ".", "readField", "(", "obj", ",", "\"", "dataSource", "\"", ",", "true", ")", ";", "authQuery", "=", "(", "String", ")", "FieldUtils", ".", "readField", "(", "obj", ",", "\"", "authenticationQuery", "\"", ",", "true", ")", ";", "LOG", ".", "info", "(", "authQuery", ")", ";", "String", "authQueryLowerCase", "=", "authQuery", ".", "toLowerCase", "(", ")", ";", "retval", "=", "authQueryLowerCase", ".", "split", "(", "\"", "from", "\"", ",", "2", ")", ";", "if", "(", "retval", ".", "length", ">=", "2", ")", "{", "retval", "=", "retval", "[", "1", "]", ".", "split", "(", "\"", "with|where", "\"", ",", "2", ")", ";", "tablename", "=", "retval", "[", "0", "]", ";", "retval", "=", "retval", "[", "1", "]", ".", "split", "(", "\"", "where", "\"", ",", "2", ")", ";", "if", "(", "retval", ".", "length", ">=", "2", ")", "retval", "=", "retval", "[", "1", "]", ".", "split", "(", "\"", "=", "\"", ",", "2", ")", ";", "else", "retval", "=", "retval", "[", "0", "]", ".", "split", "(", "\"", "=", "\"", ",", "2", ")", ";", "username", "=", "retval", "[", "0", "]", ";", "}", "if", "(", "StringUtils", ".", "isBlank", "(", "username", ")", "||", "StringUtils", ".", "isBlank", "(", "tablename", ")", ")", "{", "return", "userlist", ";", "}", "userquery", "=", "\"", "select ", "\"", "+", "username", "+", "\"", " from ", "\"", "+", "tablename", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "LOG", ".", "error", "(", "\"", "Error while accessing dataSource for JDBC Realm", "\"", ",", "e", ")", ";", "return", "null", ";", "}", "try", "{", "Connection", "con", "=", "dataSource", ".", "getConnection", "(", ")", ";", "ps", "=", "con", ".", "prepareStatement", "(", "userquery", ")", ";", "rs", "=", "ps", ".", "executeQuery", "(", ")", ";", "while", "(", "rs", ".", "next", "(", ")", ")", "{", "userlist", ".", "add", "(", "rs", ".", "getString", "(", "1", ")", ".", "trim", "(", ")", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "error", "(", "\"", "Error retrieving User list from JDBC Realm", "\"", ",", "e", ")", ";", "}", "finally", "{", "JdbcUtils", ".", "closeResultSet", "(", "rs", ")", ";", "JdbcUtils", ".", "closeStatement", "(", "ps", ")", ";", "}", "return", "userlist", ";", "}"], "idx": 12401, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "709c5a70a8f37277c9eea0a1c0c9195b5eb21a74", "function_name": "getUserList", "body_hash": "07dd84c06bc32d304e6ccb6a8c7f7a12e8770841"}
{"code": "private void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\tString path = StringUtils.cleanPath(url);\n\t\t\t// Check whether URL matches allowed resources\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, path)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + path +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + path + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(path);\n\t\t\trd.include(request, response);\n\t\t}\n\t}", "code_tokens": ["private", "void", "doInclude", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "String", "resourceUrl", ")", "throws", "ServletException", ",", "IOException", "{", "if", "(", "this", ".", "contentType", "!=", "null", ")", "{", "response", ".", "setContentType", "(", "this", ".", "contentType", ")", ";", "}", "String", "[", "]", "resourceUrls", "=", "StringUtils", ".", "tokenizeToStringArray", "(", "resourceUrl", ",", "RESOURCE_URL_DELIMITERS", ")", ";", "for", "(", "String", "url", ":", "resourceUrls", ")", "{", "String", "path", "=", "StringUtils", ".", "cleanPath", "(", "url", ")", ";", "if", "(", "this", ".", "allowedResources", "!=", "null", "&&", "!", "this", ".", "pathMatcher", ".", "match", "(", "this", ".", "allowedResources", ",", "path", ")", ")", "{", "throw", "new", "ServletException", "(", "\"", "Resource [", "\"", "+", "path", "+", "\"", "] does not match allowed pattern [", "\"", "+", "this", ".", "allowedResources", "+", "\"", "]", "\"", ")", ";", "}", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Including resource [", "\"", "+", "path", "+", "\"", "]", "\"", ")", ";", "}", "RequestDispatcher", "rd", "=", "request", ".", "getRequestDispatcher", "(", "path", ")", ";", "rd", ".", "include", "(", "request", ",", "response", ")", ";", "}", "}"], "idx": 26771, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "43bf008fbcd0d7945e2fcd5e30039bc4d74c7a98", "function_name": "doInclude", "body_hash": "43e355c93edfa5e131c5672bbec8c929cec832d2"}
{"code": "@RequirePOST\n        public FormValidation doValidateProxy(\n                @QueryParameter(\"testUrl\") String testUrl, @QueryParameter(\"name\") String name, @QueryParameter(\"port\") int port,\n                @QueryParameter(\"userName\") String userName, @QueryParameter(\"password\") String password,\n                @QueryParameter(\"noProxyHost\") String noProxyHost) {\n\n            if (Util.fixEmptyAndTrim(testUrl) == null) {\n                return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());\n            }\n\n            String host = testUrl;\n            try {\n                URL url = new URL(testUrl);\n                host = url.getHost();\n            } catch (MalformedURLException e) {\n                return FormValidation.error(Messages.ProxyConfiguration_MalformedTestUrl(testUrl));\n            }\n\n            GetMethod method = null;\n            try {\n                method = new GetMethod(testUrl);\n                method.getParams().setParameter(\"http.socket.timeout\", DEFAULT_CONNECT_TIMEOUT_MILLIS > 0 ? DEFAULT_CONNECT_TIMEOUT_MILLIS : new Integer(30 * 1000));\n                \n                HttpClient client = new HttpClient();\n                if (Util.fixEmptyAndTrim(name) != null && !isNoProxyHost(host, noProxyHost)) {\n                    client.getHostConfiguration().setProxy(name, port);\n                    Credentials credentials = createCredentials(userName, password);\n                    AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n                    client.getState().setProxyCredentials(scope, credentials);\n                }\n                \n                int code = client.executeMethod(method);\n                if (code != HttpURLConnection.HTTP_OK) {\n                    return FormValidation.error(Messages.ProxyConfiguration_FailedToConnect(testUrl, code));\n                }\n            } catch (IOException e) {\n                return FormValidation.error(e, Messages.ProxyConfiguration_FailedToConnectViaProxy(testUrl));\n            } finally {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n            }\n            \n            return FormValidation.ok(Messages.ProxyConfiguration_Success());\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doValidateProxy", "(", "@", "QueryParameter", "(", "\"", "testUrl", "\"", ")", "String", "testUrl", ",", "@", "QueryParameter", "(", "\"", "name", "\"", ")", "String", "name", ",", "@", "QueryParameter", "(", "\"", "port", "\"", ")", "int", "port", ",", "@", "QueryParameter", "(", "\"", "userName", "\"", ")", "String", "userName", ",", "@", "QueryParameter", "(", "\"", "password", "\"", ")", "String", "password", ",", "@", "QueryParameter", "(", "\"", "noProxyHost", "\"", ")", "String", "noProxyHost", ")", "{", "if", "(", "Util", ".", "fixEmptyAndTrim", "(", "testUrl", ")", "==", "null", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ProxyConfiguration_TestUrlRequired", "(", ")", ")", ";", "}", "String", "host", "=", "testUrl", ";", "try", "{", "URL", "url", "=", "new", "URL", "(", "testUrl", ")", ";", "host", "=", "url", ".", "getHost", "(", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ProxyConfiguration_MalformedTestUrl", "(", "testUrl", ")", ")", ";", "}", "GetMethod", "method", "=", "null", ";", "try", "{", "method", "=", "new", "GetMethod", "(", "testUrl", ")", ";", "method", ".", "getParams", "(", ")", ".", "setParameter", "(", "\"", "http.socket.timeout", "\"", ",", "DEFAULT_CONNECT_TIMEOUT_MILLIS", ">", "0", "?", "DEFAULT_CONNECT_TIMEOUT_MILLIS", ":", "new", "Integer", "(", "30", "*", "1000", ")", ")", ";", "HttpClient", "client", "=", "new", "HttpClient", "(", ")", ";", "if", "(", "Util", ".", "fixEmptyAndTrim", "(", "name", ")", "!=", "null", "&&", "!", "isNoProxyHost", "(", "host", ",", "noProxyHost", ")", ")", "{", "client", ".", "getHostConfiguration", "(", ")", ".", "setProxy", "(", "name", ",", "port", ")", ";", "Credentials", "credentials", "=", "createCredentials", "(", "userName", ",", "password", ")", ";", "AuthScope", "scope", "=", "new", "AuthScope", "(", "AuthScope", ".", "ANY_HOST", ",", "AuthScope", ".", "ANY_PORT", ")", ";", "client", ".", "getState", "(", ")", ".", "setProxyCredentials", "(", "scope", ",", "credentials", ")", ";", "}", "int", "code", "=", "client", ".", "executeMethod", "(", "method", ")", ";", "if", "(", "code", "!=", "HttpURLConnection", ".", "HTTP_OK", ")", "{", "return", "FormValidation", ".", "error", "(", "Messages", ".", "ProxyConfiguration_FailedToConnect", "(", "testUrl", ",", "code", ")", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "e", ",", "Messages", ".", "ProxyConfiguration_FailedToConnectViaProxy", "(", "testUrl", ")", ")", ";", "}", "finally", "{", "if", "(", "method", "!=", "null", ")", "{", "method", ".", "releaseConnection", "(", ")", ";", "}", "}", "return", "FormValidation", ".", "ok", "(", "Messages", ".", "ProxyConfiguration_Success", "(", ")", ")", ";", "}"], "idx": 94362, "cwe": "CWE-918", "target": 1, "status": "VULNERABLE", "commit": "2d16b459205730d85e51499c2457109b234ca9d9", "function_name": "doValidateProxy", "body_hash": "672eb6f84b785a77a15391bcc3185cb627c7d329"}
{"code": "@Override\n      public Object getGroup(Object instance) {\n         if (System.getSecurityManager() == null) {\n            method.setAccessible(true);\n         } else {\n            AccessController.doPrivileged((PrivilegedAction<List<Method>>) () -> {\n               method.setAccessible(true);\n               return null;\n            });\n         }\n         return invokeMethod(instance, method, Util.EMPTY_OBJECT_ARRAY);\n      }", "code_tokens": ["@", "Override", "public", "Object", "getGroup", "(", "Object", "instance", ")", "{", "if", "(", "System", ".", "getSecurityManager", "(", ")", "==", "null", ")", "{", "method", ".", "setAccessible", "(", "true", ")", ";", "}", "else", "{", "AccessController", ".", "doPrivileged", "(", "(", "PrivilegedAction", "<", "List", "<", "Method", ">", ">", ")", "(", ")", "->", "{", "method", ".", "setAccessible", "(", "true", ")", ";", "return", "null", ";", "}", ")", ";", "}", "return", "invokeMethod", "(", "instance", ",", "method", ",", "Util", ".", "EMPTY_OBJECT_ARRAY", ")", ";", "}"], "idx": 56464, "cwe": "CWE-470", "target": 0, "status": "FIXED", "commit": "a7dab68d194989aaa0b0aa0781cf8ee88fbe3439", "function_name": "getGroup", "body_hash": "b23c62a46d79bd2caec1cecb6c63a85d89f1c226"}
{"code": "private void addJsr160DispatcherIfExternallyConfigured(Configuration pConfig) {\n        String dispatchers = pConfig.get(ConfigKey.DISPATCHER_CLASSES);\n        String jsr160DispatcherClass = \"org.jolokia.jsr160.Jsr160RequestDispatcher\";\n\n        if (dispatchers == null || !dispatchers.contains(jsr160DispatcherClass)) {\n            for (String param : new String[]{\n                System.getProperty(\"org.jolokia.jsr160ProxyEnabled\"),\n                System.getenv(\"JOLOKIA_JSR160_PROXY_ENABLED\")\n            }) {\n                if (param != null && (param.isEmpty() || Boolean.parseBoolean(param))) {\n                    {\n                        pConfig.updateGlobalConfiguration(\n                            Collections.singletonMap(\n                                ConfigKey.DISPATCHER_CLASSES.getKeyValue(),\n                                (dispatchers != null ? dispatchers + \",\" : \"\") + jsr160DispatcherClass));\n                    }\n                    return;\n                }\n            }\n            if (dispatchers == null) {\n                // We add a breaking dispatcher to avoid silently ignoring a JSR160 proxy request\n                // when it is now enabled\n                pConfig.updateGlobalConfiguration(Collections.singletonMap(\n                    ConfigKey.DISPATCHER_CLASSES.getKeyValue(),\n                    Jsr160ProxyNotEnabledByDefaultAnymoreDispatcher.class.getCanonicalName()));\n            }\n        }\n    }", "code_tokens": ["private", "void", "addJsr160DispatcherIfExternallyConfigured", "(", "Configuration", "pConfig", ")", "{", "String", "dispatchers", "=", "pConfig", ".", "get", "(", "ConfigKey", ".", "DISPATCHER_CLASSES", ")", ";", "String", "jsr160DispatcherClass", "=", "\"", "org.jolokia.jsr160.Jsr160RequestDispatcher", "\"", ";", "if", "(", "dispatchers", "==", "null", "||", "!", "dispatchers", ".", "contains", "(", "jsr160DispatcherClass", ")", ")", "{", "for", "(", "String", "param", ":", "new", "String", "[", "]", "{", "System", ".", "getProperty", "(", "\"", "org.jolokia.jsr160ProxyEnabled", "\"", ")", ",", "System", ".", "getenv", "(", "\"", "JOLOKIA_JSR160_PROXY_ENABLED", "\"", ")", "}", ")", "{", "if", "(", "param", "!=", "null", "&&", "(", "param", ".", "isEmpty", "(", ")", "||", "Boolean", ".", "parseBoolean", "(", "param", ")", ")", ")", "{", "{", "pConfig", ".", "updateGlobalConfiguration", "(", "Collections", ".", "singletonMap", "(", "ConfigKey", ".", "DISPATCHER_CLASSES", ".", "getKeyValue", "(", ")", ",", "(", "dispatchers", "!=", "null", "?", "dispatchers", "+", "\"", ",", "\"", ":", "\"", "\"", ")", "+", "jsr160DispatcherClass", ")", ")", ";", "}", "return", ";", "}", "}", "if", "(", "dispatchers", "==", "null", ")", "{", "pConfig", ".", "updateGlobalConfiguration", "(", "Collections", ".", "singletonMap", "(", "ConfigKey", ".", "DISPATCHER_CLASSES", ".", "getKeyValue", "(", ")", ",", "Jsr160ProxyNotEnabledByDefaultAnymoreDispatcher", ".", "class", ".", "getCanonicalName", "(", ")", ")", ")", ";", "}", "}", "}"], "idx": 72915, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "fd7b93da30c61a45bac10d8b311f1b79a74910f", "function_name": "addJsr160DispatcherIfExternallyConfigured", "body_hash": "ddeb34002c7c6a5baab38eae6b465e376cc55607"}
{"code": "public void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n\n        // The MP4Parser library accepts either a File, or a byte array\n        // As MP4 video files are typically large, always use a file to\n        //  avoid OOMs that may occur with in-memory buffering\n        TemporaryResources tmp = new TemporaryResources();\n        TikaInputStream tstream = TikaInputStream.get(stream, tmp);\n\n        try (DataSource dataSource = new DirectFileReadDataSource(tstream.getFile())) {\n            try (IsoFile isoFile = new IsoFile(dataSource)) {\n                tmp.addResource(isoFile);\n\n                // Grab the file type box\n                FileTypeBox fileType = getOrNull(isoFile, FileTypeBox.class);\n                if (fileType != null) {\n                    // Identify the type\n                    MediaType type = MediaType.application(\"mp4\");\n                    for (Map.Entry<MediaType, List<String>> e : typesMap.entrySet()) {\n                        if (e.getValue().contains(fileType.getMajorBrand())) {\n                            type = e.getKey();\n                            break;\n                        }\n                    }\n                    metadata.set(Metadata.CONTENT_TYPE, type.toString());\n\n                    if (type.getType().equals(\"audio\")) {\n                        metadata.set(XMPDM.AUDIO_COMPRESSOR, fileType.getMajorBrand().trim());\n                    }\n                } else {\n                    // Some older QuickTime files lack the FileType\n                    metadata.set(Metadata.CONTENT_TYPE, \"video/quicktime\");\n                }\n\n\n                // Get the main MOOV box\n                MovieBox moov = getOrNull(isoFile, MovieBox.class);\n                if (moov == null) {\n                    // Bail out\n                    return;\n                }\n\n\n                XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n                xhtml.startDocument();\n\n\n                // Pull out some information from the header box\n                MovieHeaderBox mHeader = getOrNull(moov, MovieHeaderBox.class);\n                if (mHeader != null) {\n                    // Get the creation and modification dates\n                    metadata.set(Metadata.CREATION_DATE, mHeader.getCreationTime());\n                    metadata.set(TikaCoreProperties.MODIFIED, mHeader.getModificationTime());\n\n                    // Get the duration\n                    double durationSeconds = ((double) mHeader.getDuration()) / mHeader.getTimescale();\n                    metadata.set(XMPDM.DURATION, DURATION_FORMAT.format(durationSeconds));\n\n                    // The timescale is normally the sampling rate\n                    metadata.set(XMPDM.AUDIO_SAMPLE_RATE, (int) mHeader.getTimescale());\n                }\n\n\n                // Get some more information from the track header\n                // TODO Decide how to handle multiple tracks\n                List<TrackBox> tb = moov.getBoxes(TrackBox.class);\n                if (tb.size() > 0) {\n                    TrackBox track = tb.get(0);\n\n                    TrackHeaderBox header = track.getTrackHeaderBox();\n                    // Get the creation and modification dates\n                    metadata.set(TikaCoreProperties.CREATED, header.getCreationTime());\n                    metadata.set(TikaCoreProperties.MODIFIED, header.getModificationTime());\n\n                    // Get the video with and height\n                    metadata.set(Metadata.IMAGE_WIDTH, (int) header.getWidth());\n                    metadata.set(Metadata.IMAGE_LENGTH, (int) header.getHeight());\n\n                    // Get the sample information\n                    SampleTableBox samples = track.getSampleTableBox();\n                    SampleDescriptionBox sampleDesc = samples.getSampleDescriptionBox();\n                    if (sampleDesc != null) {\n                        // Look for the first Audio Sample, if present\n                        AudioSampleEntry sample = getOrNull(sampleDesc, AudioSampleEntry.class);\n                        if (sample != null) {\n                            XMPDM.ChannelTypePropertyConverter.convertAndSet(metadata, sample.getChannelCount());\n                            //metadata.set(XMPDM.AUDIO_SAMPLE_TYPE, sample.getSampleSize());    // TODO Num -> Type mapping\n                            metadata.set(XMPDM.AUDIO_SAMPLE_RATE, (int) sample.getSampleRate());\n                            //metadata.set(XMPDM.AUDIO_, sample.getSamplesPerPacket());\n                            //metadata.set(XMPDM.AUDIO_, sample.getBytesPerSample());\n                        }\n                    }\n                }\n\n                // Get metadata from the User Data Box\n                UserDataBox userData = getOrNull(moov, UserDataBox.class);\n                if (userData != null) {\n                    extractGPS(userData, metadata);\n                    MetaBox meta = getOrNull(userData, MetaBox.class);\n\n                    // Check for iTunes Metadata\n                    // See http://atomicparsley.sourceforge.net/mpeg-4files.html and\n                    //  http://code.google.com/p/mp4v2/wiki/iTunesMetadata for more on these\n                    AppleItemListBox apple = getOrNull(meta, AppleItemListBox.class);\n                    if (apple != null) {\n                        // Title\n                        AppleNameBox title = getOrNull(apple, AppleNameBox.class);\n                        addMetadata(TikaCoreProperties.TITLE, metadata, title);\n\n                        // Artist\n                        AppleArtistBox artist = getOrNull(apple, AppleArtistBox.class);\n                        addMetadata(TikaCoreProperties.CREATOR, metadata, artist);\n                        addMetadata(XMPDM.ARTIST, metadata, artist);\n\n                        // Album Artist\n                        AppleArtist2Box artist2 = getOrNull(apple, AppleArtist2Box.class);\n                        addMetadata(XMPDM.ALBUM_ARTIST, metadata, artist2);\n\n                        // Album\n                        AppleAlbumBox album = getOrNull(apple, AppleAlbumBox.class);\n                        addMetadata(XMPDM.ALBUM, metadata, album);\n\n                        // Composer\n                        AppleTrackAuthorBox composer = getOrNull(apple, AppleTrackAuthorBox.class);\n                        addMetadata(XMPDM.COMPOSER, metadata, composer);\n\n                        // Genre\n                        AppleGenreBox genre = getOrNull(apple, AppleGenreBox.class);\n                        addMetadata(XMPDM.GENRE, metadata, genre);\n\n                        // Year\n                        AppleRecordingYear2Box year = getOrNull(apple, AppleRecordingYear2Box.class);\n                        if (year != null) {\n                            metadata.set(XMPDM.RELEASE_DATE, year.getValue());\n                        }\n\n                        // Track number\n                        AppleTrackNumberBox trackNum = getOrNull(apple, AppleTrackNumberBox.class);\n                        if (trackNum != null) {\n                            metadata.set(XMPDM.TRACK_NUMBER, trackNum.getA());\n                            //metadata.set(XMPDM.NUMBER_OF_TRACKS, trackNum.getB()); // TODO\n                        }\n\n                        // Disc number\n                        AppleDiskNumberBox discNum = getOrNull(apple, AppleDiskNumberBox.class);\n                        if (discNum != null) {\n                            metadata.set(XMPDM.DISC_NUMBER, discNum.getA());\n                        }\n\n                        // Compilation\n                        AppleCompilationBox compilation = getOrNull(apple, AppleCompilationBox.class);\n                        if (compilation != null) {\n                            metadata.set(XMPDM.COMPILATION, (int) compilation.getValue());\n                        }\n\n                        // Comment\n                        AppleCommentBox comment = getOrNull(apple, AppleCommentBox.class);\n                        addMetadata(XMPDM.LOG_COMMENT, metadata, comment);\n\n                        // Encoder\n                        AppleEncoderBox encoder = getOrNull(apple, AppleEncoderBox.class);\n                        if (encoder != null) {\n                            metadata.set(XMP.CREATOR_TOOL, encoder.getValue());\n                        }\n\n\n                        // As text\n                        for (Box box : apple.getBoxes()) {\n                            if (box instanceof Utf8AppleDataBox) {\n                                xhtml.element(\"p\", ((Utf8AppleDataBox) box).getValue());\n                            }\n                        }\n                    }\n\n                    // TODO Check for other kinds too\n                }\n\n\n                // All done\n                xhtml.endDocument();\n            }\n        } finally {\n            tmp.dispose();\n        }\n\n    }", "code_tokens": ["public", "void", "parse", "(", "InputStream", "stream", ",", "ContentHandler", "handler", ",", "Metadata", "metadata", ",", "ParseContext", "context", ")", "throws", "IOException", ",", "SAXException", ",", "TikaException", "{", "TemporaryResources", "tmp", "=", "new", "TemporaryResources", "(", ")", ";", "TikaInputStream", "tstream", "=", "TikaInputStream", ".", "get", "(", "stream", ",", "tmp", ")", ";", "try", "(", "DataSource", "dataSource", "=", "new", "DirectFileReadDataSource", "(", "tstream", ".", "getFile", "(", ")", ")", ")", "{", "try", "(", "IsoFile", "isoFile", "=", "new", "IsoFile", "(", "dataSource", ")", ")", "{", "tmp", ".", "addResource", "(", "isoFile", ")", ";", "FileTypeBox", "fileType", "=", "getOrNull", "(", "isoFile", ",", "FileTypeBox", ".", "class", ")", ";", "if", "(", "fileType", "!=", "null", ")", "{", "MediaType", "type", "=", "MediaType", ".", "application", "(", "\"", "mp4", "\"", ")", ";", "for", "(", "Map", ".", "Entry", "<", "MediaType", ",", "List", "<", "String", ">", ">", "e", ":", "typesMap", ".", "entrySet", "(", ")", ")", "{", "if", "(", "e", ".", "getValue", "(", ")", ".", "contains", "(", "fileType", ".", "getMajorBrand", "(", ")", ")", ")", "{", "type", "=", "e", ".", "getKey", "(", ")", ";", "break", ";", "}", "}", "metadata", ".", "set", "(", "Metadata", ".", "CONTENT_TYPE", ",", "type", ".", "toString", "(", ")", ")", ";", "if", "(", "type", ".", "getType", "(", ")", ".", "equals", "(", "\"", "audio", "\"", ")", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "AUDIO_COMPRESSOR", ",", "fileType", ".", "getMajorBrand", "(", ")", ".", "trim", "(", ")", ")", ";", "}", "}", "else", "{", "metadata", ".", "set", "(", "Metadata", ".", "CONTENT_TYPE", ",", "\"", "video/quicktime", "\"", ")", ";", "}", "MovieBox", "moov", "=", "getOrNull", "(", "isoFile", ",", "MovieBox", ".", "class", ")", ";", "if", "(", "moov", "==", "null", ")", "{", "return", ";", "}", "XHTMLContentHandler", "xhtml", "=", "new", "XHTMLContentHandler", "(", "handler", ",", "metadata", ")", ";", "xhtml", ".", "startDocument", "(", ")", ";", "MovieHeaderBox", "mHeader", "=", "getOrNull", "(", "moov", ",", "MovieHeaderBox", ".", "class", ")", ";", "if", "(", "mHeader", "!=", "null", ")", "{", "metadata", ".", "set", "(", "Metadata", ".", "CREATION_DATE", ",", "mHeader", ".", "getCreationTime", "(", ")", ")", ";", "metadata", ".", "set", "(", "TikaCoreProperties", ".", "MODIFIED", ",", "mHeader", ".", "getModificationTime", "(", ")", ")", ";", "double", "durationSeconds", "=", "(", "(", "double", ")", "mHeader", ".", "getDuration", "(", ")", ")", "/", "mHeader", ".", "getTimescale", "(", ")", ";", "metadata", ".", "set", "(", "XMPDM", ".", "DURATION", ",", "DURATION_FORMAT", ".", "format", "(", "durationSeconds", ")", ")", ";", "metadata", ".", "set", "(", "XMPDM", ".", "AUDIO_SAMPLE_RATE", ",", "(", "int", ")", "mHeader", ".", "getTimescale", "(", ")", ")", ";", "}", "List", "<", "TrackBox", ">", "tb", "=", "moov", ".", "getBoxes", "(", "TrackBox", ".", "class", ")", ";", "if", "(", "tb", ".", "size", "(", ")", ">", "0", ")", "{", "TrackBox", "track", "=", "tb", ".", "get", "(", "0", ")", ";", "TrackHeaderBox", "header", "=", "track", ".", "getTrackHeaderBox", "(", ")", ";", "metadata", ".", "set", "(", "TikaCoreProperties", ".", "CREATED", ",", "header", ".", "getCreationTime", "(", ")", ")", ";", "metadata", ".", "set", "(", "TikaCoreProperties", ".", "MODIFIED", ",", "header", ".", "getModificationTime", "(", ")", ")", ";", "metadata", ".", "set", "(", "Metadata", ".", "IMAGE_WIDTH", ",", "(", "int", ")", "header", ".", "getWidth", "(", ")", ")", ";", "metadata", ".", "set", "(", "Metadata", ".", "IMAGE_LENGTH", ",", "(", "int", ")", "header", ".", "getHeight", "(", ")", ")", ";", "SampleTableBox", "samples", "=", "track", ".", "getSampleTableBox", "(", ")", ";", "SampleDescriptionBox", "sampleDesc", "=", "samples", ".", "getSampleDescriptionBox", "(", ")", ";", "if", "(", "sampleDesc", "!=", "null", ")", "{", "AudioSampleEntry", "sample", "=", "getOrNull", "(", "sampleDesc", ",", "AudioSampleEntry", ".", "class", ")", ";", "if", "(", "sample", "!=", "null", ")", "{", "XMPDM", ".", "ChannelTypePropertyConverter", ".", "convertAndSet", "(", "metadata", ",", "sample", ".", "getChannelCount", "(", ")", ")", ";", "metadata", ".", "set", "(", "XMPDM", ".", "AUDIO_SAMPLE_RATE", ",", "(", "int", ")", "sample", ".", "getSampleRate", "(", ")", ")", ";", "}", "}", "}", "UserDataBox", "userData", "=", "getOrNull", "(", "moov", ",", "UserDataBox", ".", "class", ")", ";", "if", "(", "userData", "!=", "null", ")", "{", "extractGPS", "(", "userData", ",", "metadata", ")", ";", "MetaBox", "meta", "=", "getOrNull", "(", "userData", ",", "MetaBox", ".", "class", ")", ";", "AppleItemListBox", "apple", "=", "getOrNull", "(", "meta", ",", "AppleItemListBox", ".", "class", ")", ";", "if", "(", "apple", "!=", "null", ")", "{", "AppleNameBox", "title", "=", "getOrNull", "(", "apple", ",", "AppleNameBox", ".", "class", ")", ";", "addMetadata", "(", "TikaCoreProperties", ".", "TITLE", ",", "metadata", ",", "title", ")", ";", "AppleArtistBox", "artist", "=", "getOrNull", "(", "apple", ",", "AppleArtistBox", ".", "class", ")", ";", "addMetadata", "(", "TikaCoreProperties", ".", "CREATOR", ",", "metadata", ",", "artist", ")", ";", "addMetadata", "(", "XMPDM", ".", "ARTIST", ",", "metadata", ",", "artist", ")", ";", "AppleArtist2Box", "artist2", "=", "getOrNull", "(", "apple", ",", "AppleArtist2Box", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "ALBUM_ARTIST", ",", "metadata", ",", "artist2", ")", ";", "AppleAlbumBox", "album", "=", "getOrNull", "(", "apple", ",", "AppleAlbumBox", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "ALBUM", ",", "metadata", ",", "album", ")", ";", "AppleTrackAuthorBox", "composer", "=", "getOrNull", "(", "apple", ",", "AppleTrackAuthorBox", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "COMPOSER", ",", "metadata", ",", "composer", ")", ";", "AppleGenreBox", "genre", "=", "getOrNull", "(", "apple", ",", "AppleGenreBox", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "GENRE", ",", "metadata", ",", "genre", ")", ";", "AppleRecordingYear2Box", "year", "=", "getOrNull", "(", "apple", ",", "AppleRecordingYear2Box", ".", "class", ")", ";", "if", "(", "year", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "RELEASE_DATE", ",", "year", ".", "getValue", "(", ")", ")", ";", "}", "AppleTrackNumberBox", "trackNum", "=", "getOrNull", "(", "apple", ",", "AppleTrackNumberBox", ".", "class", ")", ";", "if", "(", "trackNum", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "TRACK_NUMBER", ",", "trackNum", ".", "getA", "(", ")", ")", ";", "}", "AppleDiskNumberBox", "discNum", "=", "getOrNull", "(", "apple", ",", "AppleDiskNumberBox", ".", "class", ")", ";", "if", "(", "discNum", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "DISC_NUMBER", ",", "discNum", ".", "getA", "(", ")", ")", ";", "}", "AppleCompilationBox", "compilation", "=", "getOrNull", "(", "apple", ",", "AppleCompilationBox", ".", "class", ")", ";", "if", "(", "compilation", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "COMPILATION", ",", "(", "int", ")", "compilation", ".", "getValue", "(", ")", ")", ";", "}", "AppleCommentBox", "comment", "=", "getOrNull", "(", "apple", ",", "AppleCommentBox", ".", "class", ")", ";", "addMetadata", "(", "XMPDM", ".", "LOG_COMMENT", ",", "metadata", ",", "comment", ")", ";", "AppleEncoderBox", "encoder", "=", "getOrNull", "(", "apple", ",", "AppleEncoderBox", ".", "class", ")", ";", "if", "(", "encoder", "!=", "null", ")", "{", "metadata", ".", "set", "(", "XMP", ".", "CREATOR_TOOL", ",", "encoder", ".", "getValue", "(", ")", ")", ";", "}", "for", "(", "Box", "box", ":", "apple", ".", "getBoxes", "(", ")", ")", "{", "if", "(", "box", "instanceof", "Utf8AppleDataBox", ")", "{", "xhtml", ".", "element", "(", "\"", "p", "\"", ",", "(", "(", "Utf8AppleDataBox", ")", "box", ")", ".", "getValue", "(", ")", ")", ";", "}", "}", "}", "}", "xhtml", ".", "endDocument", "(", ")", ";", "}", "}", "finally", "{", "tmp", ".", "dispose", "(", ")", ";", "}", "}"], "idx": 83017, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "333d990", "function_name": "parse", "body_hash": "fce6a6635b1135dc1ba5eba5118a89b896403029"}
{"code": "protected COSDictionary parseXref(long startXRefOffset) throws IOException\n    {\n        source.seek(startXRefOffset);\n        long startXrefOffset = Math.max(0, parseStartXref());\n        // check the startxref offset\n        long fixedOffset = checkXRefOffset(startXrefOffset);\n        if (fixedOffset > -1)\n        {\n            startXrefOffset = fixedOffset;\n        }\n        document.setStartXref(startXrefOffset);\n        long prev = startXrefOffset;\n        // ---- parse whole chain of xref tables/object streams using PREV reference\n        Set<Long> prevSet = new HashSet<Long>();\n        COSDictionary trailer = null;\n        while (prev > 0)\n        {\n            // seek to xref table\n            source.seek(prev);\n            // skip white spaces\n            skipSpaces();\n            // save current position instead of prev due to skipped spaces\n            prevSet.add(source.getPosition());\n            // -- parse xref\n            if (source.peek() == X)\n            {\n                // xref table and trailer\n                // use existing parser to parse xref table\n                if (!parseXrefTable(prev) || !parseTrailer())\n                {\n                    throw new IOException(\"Expected trailer object at offset \"\n                            + source.getPosition());\n                }\n                trailer = xrefTrailerResolver.getCurrentTrailer();\n                // check for a XRef stream, it may contain some object ids of compressed objects \n                if(trailer.containsKey(COSName.XREF_STM))\n                {\n                    int streamOffset = trailer.getInt(COSName.XREF_STM);\n                    // check the xref stream reference\n                    fixedOffset = checkXRefOffset(streamOffset);\n                    if (fixedOffset > -1 && fixedOffset != streamOffset)\n                    {\n                        LOG.warn(\"/XRefStm offset \" + streamOffset + \" is incorrect, corrected to \" + fixedOffset);\n                        streamOffset = (int)fixedOffset;\n                        trailer.setInt(COSName.XREF_STM, streamOffset);\n                    }\n                    if (streamOffset > 0)\n                    {\n                        source.seek(streamOffset);\n                        skipSpaces();\n                        try\n                        {\n                            parseXrefObjStream(prev, false);\n                        }\n                        catch (IOException ex)\n                        {\n                            if (isLenient)\n                            {\n                                LOG.error(\"Failed to parse /XRefStm at offset \" + streamOffset, ex);\n                            }\n                            else\n                            {\n                                throw ex;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if(isLenient)\n                        {\n                            LOG.error(\"Skipped XRef stream due to a corrupt offset:\"+streamOffset);\n                        }\n                        else\n                        {\n                            throw new IOException(\"Skipped XRef stream due to a corrupt offset:\"+streamOffset);\n                        }\n                    }\n                }\n                prev = trailer.getLong(COSName.PREV);\n            }\n            else\n            {\n                // parse xref stream\n                prev = parseXrefObjStream(prev, true);\n                trailer = xrefTrailerResolver.getCurrentTrailer();\n            }\n            if (prev > 0)\n            {\n                // check the xref table reference\n                fixedOffset = checkXRefOffset(prev);\n                if (fixedOffset > -1 && fixedOffset != prev)\n                {\n                    prev = fixedOffset;\n                    trailer.setLong(COSName.PREV, prev);\n                }\n            }\n            if (prevSet.contains(prev))\n            {\n                throw new IOException(\"/Prev loop at offset \" + prev);\n            }\n        }\n        // ---- build valid xrefs out of the xref chain\n        xrefTrailerResolver.setStartxref(startXrefOffset);\n        trailer = xrefTrailerResolver.getTrailer();\n        document.setTrailer(trailer);\n        document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());\n        // check the offsets of all referenced objects\n        checkXrefOffsets();\n        // copy xref table\n        document.addXRefTable(xrefTrailerResolver.getXrefTable());\n        return trailer;\n    }", "code_tokens": ["protected", "COSDictionary", "parseXref", "(", "long", "startXRefOffset", ")", "throws", "IOException", "{", "source", ".", "seek", "(", "startXRefOffset", ")", ";", "long", "startXrefOffset", "=", "Math", ".", "max", "(", "0", ",", "parseStartXref", "(", ")", ")", ";", "long", "fixedOffset", "=", "checkXRefOffset", "(", "startXrefOffset", ")", ";", "if", "(", "fixedOffset", ">", "-", "1", ")", "{", "startXrefOffset", "=", "fixedOffset", ";", "}", "document", ".", "setStartXref", "(", "startXrefOffset", ")", ";", "long", "prev", "=", "startXrefOffset", ";", "Set", "<", "Long", ">", "prevSet", "=", "new", "HashSet", "<", "Long", ">", "(", ")", ";", "COSDictionary", "trailer", "=", "null", ";", "while", "(", "prev", ">", "0", ")", "{", "source", ".", "seek", "(", "prev", ")", ";", "skipSpaces", "(", ")", ";", "prevSet", ".", "add", "(", "source", ".", "getPosition", "(", ")", ")", ";", "if", "(", "source", ".", "peek", "(", ")", "==", "X", ")", "{", "if", "(", "!", "parseXrefTable", "(", "prev", ")", "||", "!", "parseTrailer", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "Expected trailer object at offset ", "\"", "+", "source", ".", "getPosition", "(", ")", ")", ";", "}", "trailer", "=", "xrefTrailerResolver", ".", "getCurrentTrailer", "(", ")", ";", "if", "(", "trailer", ".", "containsKey", "(", "COSName", ".", "XREF_STM", ")", ")", "{", "int", "streamOffset", "=", "trailer", ".", "getInt", "(", "COSName", ".", "XREF_STM", ")", ";", "fixedOffset", "=", "checkXRefOffset", "(", "streamOffset", ")", ";", "if", "(", "fixedOffset", ">", "-", "1", "&&", "fixedOffset", "!=", "streamOffset", ")", "{", "LOG", ".", "warn", "(", "\"", "/XRefStm offset ", "\"", "+", "streamOffset", "+", "\"", " is incorrect, corrected to ", "\"", "+", "fixedOffset", ")", ";", "streamOffset", "=", "(", "int", ")", "fixedOffset", ";", "trailer", ".", "setInt", "(", "COSName", ".", "XREF_STM", ",", "streamOffset", ")", ";", "}", "if", "(", "streamOffset", ">", "0", ")", "{", "source", ".", "seek", "(", "streamOffset", ")", ";", "skipSpaces", "(", ")", ";", "try", "{", "parseXrefObjStream", "(", "prev", ",", "false", ")", ";", "}", "catch", "(", "IOException", "ex", ")", "{", "if", "(", "isLenient", ")", "{", "LOG", ".", "error", "(", "\"", "Failed to parse /XRefStm at offset ", "\"", "+", "streamOffset", ",", "ex", ")", ";", "}", "else", "{", "throw", "ex", ";", "}", "}", "}", "else", "{", "if", "(", "isLenient", ")", "{", "LOG", ".", "error", "(", "\"", "Skipped XRef stream due to a corrupt offset:", "\"", "+", "streamOffset", ")", ";", "}", "else", "{", "throw", "new", "IOException", "(", "\"", "Skipped XRef stream due to a corrupt offset:", "\"", "+", "streamOffset", ")", ";", "}", "}", "}", "prev", "=", "trailer", ".", "getLong", "(", "COSName", ".", "PREV", ")", ";", "}", "else", "{", "prev", "=", "parseXrefObjStream", "(", "prev", ",", "true", ")", ";", "trailer", "=", "xrefTrailerResolver", ".", "getCurrentTrailer", "(", ")", ";", "}", "if", "(", "prev", ">", "0", ")", "{", "fixedOffset", "=", "checkXRefOffset", "(", "prev", ")", ";", "if", "(", "fixedOffset", ">", "-", "1", "&&", "fixedOffset", "!=", "prev", ")", "{", "prev", "=", "fixedOffset", ";", "trailer", ".", "setLong", "(", "COSName", ".", "PREV", ",", "prev", ")", ";", "}", "}", "if", "(", "prevSet", ".", "contains", "(", "prev", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "/Prev loop at offset ", "\"", "+", "prev", ")", ";", "}", "}", "xrefTrailerResolver", ".", "setStartxref", "(", "startXrefOffset", ")", ";", "trailer", "=", "xrefTrailerResolver", ".", "getTrailer", "(", ")", ";", "document", ".", "setTrailer", "(", "trailer", ")", ";", "document", ".", "setIsXRefStream", "(", "XRefType", ".", "STREAM", "==", "xrefTrailerResolver", ".", "getXrefType", "(", ")", ")", ";", "checkXrefOffsets", "(", ")", ";", "document", ".", "addXRefTable", "(", "xrefTrailerResolver", ".", "getXrefTable", "(", ")", ")", ";", "return", "trailer", ";", "}"], "idx": 82598, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "c682f73503e78332c14fec5f88f2003ba4a04328", "function_name": "parseXref", "body_hash": "2d51bb3d106a8aadc89ceb033b0aa50feba14b62"}
{"code": "@Restricted(NoExternalUse.class)\n    @RequirePOST public HttpResponse doCheckUpdatesServer() throws IOException {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        for (UpdateSite site : Jenkins.getInstance().getUpdateCenter().getSites()) {\n            FormValidation v = site.updateDirectlyNow(DownloadService.signatureCheck);\n            if (v.kind != FormValidation.Kind.OK) {\n                // TODO crude but enough for now\n                return v;\n            }\n        }\n        for (DownloadService.Downloadable d : DownloadService.Downloadable.all()) {\n            FormValidation v = d.updateNow();\n            if (v.kind != FormValidation.Kind.OK) {\n                return v;\n            }\n        }\n        return HttpResponses.forwardToPreviousPage();\n    }", "code_tokens": ["@", "Restricted", "(", "NoExternalUse", ".", "class", ")", "@", "RequirePOST", "public", "HttpResponse", "doCheckUpdatesServer", "(", ")", "throws", "IOException", "{", "Jenkins", ".", "getInstance", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "for", "(", "UpdateSite", "site", ":", "Jenkins", ".", "getInstance", "(", ")", ".", "getUpdateCenter", "(", ")", ".", "getSites", "(", ")", ")", "{", "FormValidation", "v", "=", "site", ".", "updateDirectlyNow", "(", "DownloadService", ".", "signatureCheck", ")", ";", "if", "(", "v", ".", "kind", "!=", "FormValidation", ".", "Kind", ".", "OK", ")", "{", "return", "v", ";", "}", "}", "for", "(", "DownloadService", ".", "Downloadable", "d", ":", "DownloadService", ".", "Downloadable", ".", "all", "(", ")", ")", "{", "FormValidation", "v", "=", "d", ".", "updateNow", "(", ")", ";", "if", "(", "v", ".", "kind", "!=", "FormValidation", ".", "Kind", ".", "OK", ")", "{", "return", "v", ";", "}", "}", "return", "HttpResponses", ".", "forwardToPreviousPage", "(", ")", ";", "}"], "idx": 30510, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "56be107feb24ab3470efae7603041bbbb9cdf7fb", "function_name": "doCheckUpdatesServer", "body_hash": "0c6012717ef3cc9ef19487f75c8e1c04de930605"}
{"code": "protected InputStream findXsltInputStream(WebResource directory)\n        throws IOException {\n\n        if (localXsltFile != null) {\n            WebResource resource = resources.getResource(\n                    directory.getWebappPath() + localXsltFile);\n            if (resource.isFile()) {\n                InputStream is = resource.getInputStream();\n                if (is != null) {\n                    return is;\n                }\n            }\n            if (debug > 10) {\n                log(\"localXsltFile '\" + localXsltFile + \"' not found\");\n            }\n        }\n\n        if (contextXsltFile != null) {\n            InputStream is =\n                getServletContext().getResourceAsStream(contextXsltFile);\n            if (is != null)\n                return is;\n\n            if (debug > 10)\n                log(\"contextXsltFile '\" + contextXsltFile + \"' not found\");\n        }\n\n        /*  Open and read in file in one fell swoop to reduce chance\n         *  chance of leaving handle open.\n         */\n        if (globalXsltFile!=null) {\n            FileInputStream fis = null;\n\n            try {\n                File f = new File(globalXsltFile);\n                if (f.exists()){\n                    fis =new FileInputStream(f);\n                    byte b[] = new byte[(int)f.length()]; /* danger! */\n                    fis.read(b);\n                    return new ByteArrayInputStream(b);\n                }\n            } finally {\n                if (fis!=null)\n                    fis.close();\n            }\n        }\n\n        return null;\n    }", "code_tokens": ["protected", "InputStream", "findXsltInputStream", "(", "WebResource", "directory", ")", "throws", "IOException", "{", "if", "(", "localXsltFile", "!=", "null", ")", "{", "WebResource", "resource", "=", "resources", ".", "getResource", "(", "directory", ".", "getWebappPath", "(", ")", "+", "localXsltFile", ")", ";", "if", "(", "resource", ".", "isFile", "(", ")", ")", "{", "InputStream", "is", "=", "resource", ".", "getInputStream", "(", ")", ";", "if", "(", "is", "!=", "null", ")", "{", "return", "is", ";", "}", "}", "if", "(", "debug", ">", "10", ")", "{", "log", "(", "\"", "localXsltFile '", "\"", "+", "localXsltFile", "+", "\"", "' not found", "\"", ")", ";", "}", "}", "if", "(", "contextXsltFile", "!=", "null", ")", "{", "InputStream", "is", "=", "getServletContext", "(", ")", ".", "getResourceAsStream", "(", "contextXsltFile", ")", ";", "if", "(", "is", "!=", "null", ")", "return", "is", ";", "if", "(", "debug", ">", "10", ")", "log", "(", "\"", "contextXsltFile '", "\"", "+", "contextXsltFile", "+", "\"", "' not found", "\"", ")", ";", "}", "if", "(", "globalXsltFile", "!=", "null", ")", "{", "FileInputStream", "fis", "=", "null", ";", "try", "{", "File", "f", "=", "new", "File", "(", "globalXsltFile", ")", ";", "if", "(", "f", ".", "exists", "(", ")", ")", "{", "fis", "=", "new", "FileInputStream", "(", "f", ")", ";", "byte", "b", "[", "]", "=", "new", "byte", "[", "(", "int", ")", "f", ".", "length", "(", ")", "]", ";", "fis", ".", "read", "(", "b", ")", ";", "return", "new", "ByteArrayInputStream", "(", "b", ")", ";", "}", "}", "finally", "{", "if", "(", "fis", "!=", "null", ")", "fis", ".", "close", "(", ")", ";", "}", "}", "return", "null", ";", "}"], "idx": 32429, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "970c23bfd24dfa1dcb86ed917e6c8b47dcfb4433", "function_name": "findXsltInputStream", "body_hash": "3b99736efcee30616b7e60673ab954410a67eec5"}
{"code": "@Override\n  public void handle(RoutingContext context) {\n    HttpServerRequest request = context.request();\n    if (request.method() != HttpMethod.GET && request.method() != HttpMethod.HEAD) {\n      if (log.isTraceEnabled()) log.trace(\"Not GET or HEAD so ignoring request\");\n      context.next();\n    } else {\n      // we are trying to match a URL path to a Filesystem path, so the first step\n      // is to url decode the normalized path so avoid misinterpretations\n      String path = Utils.urlDecode(context.normalisedPath(), false);\n\n      if (path == null) {\n        // if the normalized path is null it cannot be resolved\n        log.warn(\"Invalid path: \" + context.request().path());\n        context.next();\n        return;\n      }\n\n      if (File.separatorChar != '/') {\n        // although forward slashes are not path separators according to the rfc3986 if\n        // used directly to access the filesystem on Windows, they would be treated as such\n        // Instead of relying on the usual normalized method, all forward slashes must be\n        // replaced by backslashes in this handler.\n        path = path.replace(File.separatorChar, '/');\n      }\n      // clean the .. sequences according to rfc3986\n      path = Utils.removeDots(path);\n\n      // only root is known for sure to be a directory. all other directories must be identified as such.\n      if (!directoryListing && \"/\".equals(path)) {\n        path = indexPage;\n      }\n\n      // can be called recursive for index pages\n      sendStatic(context, path);\n\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "RoutingContext", "context", ")", "{", "HttpServerRequest", "request", "=", "context", ".", "request", "(", ")", ";", "if", "(", "request", ".", "method", "(", ")", "!=", "HttpMethod", ".", "GET", "&&", "request", ".", "method", "(", ")", "!=", "HttpMethod", ".", "HEAD", ")", "{", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "log", ".", "trace", "(", "\"", "Not GET or HEAD so ignoring request", "\"", ")", ";", "context", ".", "next", "(", ")", ";", "}", "else", "{", "String", "path", "=", "Utils", ".", "urlDecode", "(", "context", ".", "normalisedPath", "(", ")", ",", "false", ")", ";", "if", "(", "path", "==", "null", ")", "{", "log", ".", "warn", "(", "\"", "Invalid path: ", "\"", "+", "context", ".", "request", "(", ")", ".", "path", "(", ")", ")", ";", "context", ".", "next", "(", ")", ";", "return", ";", "}", "if", "(", "File", ".", "separatorChar", "!=", "'/'", ")", "{", "path", "=", "path", ".", "replace", "(", "File", ".", "separatorChar", ",", "'/'", ")", ";", "}", "path", "=", "Utils", ".", "removeDots", "(", "path", ")", ";", "if", "(", "!", "directoryListing", "&&", "\"", "/", "\"", ".", "equals", "(", "path", ")", ")", "{", "path", "=", "indexPage", ";", "}", "sendStatic", "(", "context", ",", "path", ")", ";", "}", "}"], "idx": 28751, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "57a65dce6f4c5aa5e3ce7288685e7f3447eb8f3b", "function_name": "handle", "body_hash": "cedeb7be7aaf010b0676726550dea887c150ec2b"}
{"code": "private File file(String id) throws IOException {\n        if (this.directory == null) {\n            return null;\n        }\n        String filename = id + FILE_EXT;\n        File file = new File(directory(), filename);\n        return file;\n    }", "code_tokens": ["private", "File", "file", "(", "String", "id", ")", "throws", "IOException", "{", "if", "(", "this", ".", "directory", "==", "null", ")", "{", "return", "null", ";", "}", "String", "filename", "=", "id", "+", "FILE_EXT", ";", "File", "file", "=", "new", "File", "(", "directory", "(", ")", ",", "filename", ")", ";", "return", "file", ";", "}"], "idx": 59369, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "3aa8f28db7efb311cdd1b6fe15a9cd3b167a2222", "function_name": "file", "body_hash": "fc7bd632c9923625106a2c489064ec187736e94c"}
{"code": "@Restricted(NoExternalUse.class)\n        public FormValidation doCheckItemPattern(@QueryParameter String itemPattern) {\n            try {\n\n                Pattern.compile(itemPattern);\n                return FormValidation.ok();\n            } catch (PatternSyntaxException ex) {\n\n                // Wrap exception message to <pre> tag as the error messages\n                // uses position indicator (^) prefixed with spaces which work\n                // with monospace fonts only.\n                return FormValidation.error(\"Not a regular expression: \" + ex.getMessage());\n            }\n        }", "code_tokens": ["@", "Restricted", "(", "NoExternalUse", ".", "class", ")", "public", "FormValidation", "doCheckItemPattern", "(", "@", "QueryParameter", "String", "itemPattern", ")", "{", "try", "{", "Pattern", ".", "compile", "(", "itemPattern", ")", ";", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "catch", "(", "PatternSyntaxException", "ex", ")", "{", "return", "FormValidation", ".", "error", "(", "\"", "Not a regular expression: ", "\"", "+", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "}"], "idx": 80872, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "b3e562a", "function_name": "doCheckItemPattern", "body_hash": "f3bbc7ef0fdb9a04d9a1fa40ec087ce87158b855"}
{"code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\"Authorization\");\n\n        if (authorization!=null) {\n            // authenticate the user\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                String password = uidpassword.substring(idx+1);\n\n                // attempt to authenticate as API token\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    // even if we fail to match the password, we aren't rejecting it.\n                    // as the user might be passing in a real password.\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n        }\n\n        chain.doFilter(request,response);\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "HttpServletRequest", "req", "=", "(", "HttpServletRequest", ")", "request", ";", "HttpServletResponse", "rsp", "=", "(", "HttpServletResponse", ")", "response", ";", "String", "authorization", "=", "req", ".", "getHeader", "(", "\"", "Authorization", "\"", ")", ";", "if", "(", "authorization", "!=", "null", ")", "{", "String", "uidpassword", "=", "Scrambler", ".", "descramble", "(", "authorization", ".", "substring", "(", "6", ")", ")", ";", "int", "idx", "=", "uidpassword", ".", "indexOf", "(", "':'", ")", ";", "if", "(", "idx", ">=", "0", ")", "{", "String", "username", "=", "uidpassword", ".", "substring", "(", "0", ",", "idx", ")", ";", "String", "password", "=", "uidpassword", ".", "substring", "(", "idx", "+", "1", ")", ";", "User", "u", "=", "User", ".", "get", "(", "username", ")", ";", "ApiTokenProperty", "t", "=", "u", ".", "getProperty", "(", "ApiTokenProperty", ".", "class", ")", ";", "if", "(", "t", "!=", "null", "&&", "t", ".", "matchesPassword", "(", "password", ")", ")", "{", "SecurityContext", "oldContext", "=", "ACL", ".", "impersonate", "(", "u", ".", "impersonate", "(", ")", ")", ";", "try", "{", "request", ".", "setAttribute", "(", "ApiTokenProperty", ".", "class", ".", "getName", "(", ")", ",", "u", ")", ";", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "return", ";", "}", "finally", "{", "SecurityContextHolder", ".", "setContext", "(", "oldContext", ")", ";", "}", "}", "}", "}", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}"], "idx": 38581, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "5548b5220cfd496831b5721124189ff18fbb12a3", "function_name": "doFilter", "body_hash": "42333e720e0b0eb3bdaac6e54417f79b907f2d8c"}
{"code": "@Override\n    protected void connectInternal() throws SmackException, IOException, XMPPException {\n        // Establishes the TCP connection to the server and does setup the reader and writer. Throws an exception if\n        // there is an error establishing the connection\n        connectUsingConfiguration();\n\n        // We connected successfully to the servers TCP port\n        socketClosed = false;\n        initConnection();\n\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        // Make note of the fact that we're now connected.\n        connected = true;\n        callConnectionConnectedListener();\n\n        // Automatically makes the login if the user was previously connected successfully\n        // to the server and the connection was terminated abruptly\n        if (wasAuthenticated) {\n            login();\n            notifyReconnection();\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "connectInternal", "(", ")", "throws", "SmackException", ",", "IOException", ",", "XMPPException", "{", "connectUsingConfiguration", "(", ")", ";", "socketClosed", "=", "false", ";", "initConnection", "(", ")", ";", "saslFeatureReceived", ".", "checkIfSuccessOrWaitOrThrow", "(", ")", ";", "connected", "=", "true", ";", "callConnectionConnectedListener", "(", ")", ";", "if", "(", "wasAuthenticated", ")", "{", "login", "(", ")", ";", "notifyReconnection", "(", ")", ";", "}", "}"], "idx": 49379, "cwe": "CWE-362", "target": 1, "status": "VULNERABLE", "commit": "059ee99ba0d5ff7758829acf5a9aeede09ec820b", "function_name": "connectInternal", "body_hash": "96ea283eed8830ce83f0b8fa954eae79f6f65f32"}
{"code": "public static boolean isCsrfTokenValid(VaadinSession session,\n            String requestToken) {\n\n        if (session.getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String sessionToken = session.getCsrfToken();\n\n            if (uiToken == null || !MessageDigest.isEqual(\n                    uiToken.getBytes(StandardCharsets.UTF_8),\n                    requestToken.getBytes(StandardCharsets.UTF_8))) {\n                return false;\n            }\n        }\n        return true;\n    }", "code_tokens": ["public", "static", "boolean", "isCsrfTokenValid", "(", "VaadinSession", "session", ",", "String", "requestToken", ")", "{", "if", "(", "session", ".", "getService", "(", ")", ".", "getDeploymentConfiguration", "(", ")", ".", "isXsrfProtectionEnabled", "(", ")", ")", "{", "String", "sessionToken", "=", "session", ".", "getCsrfToken", "(", ")", ";", "if", "(", "uiToken", "==", "null", "||", "!", "MessageDigest", ".", "isEqual", "(", "uiToken", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ",", "requestToken", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "idx": 20048, "cwe": "CWE-203", "target": 0, "status": "FIXED", "commit": "a7ff693", "function_name": "isCsrfTokenValid", "body_hash": "de96b8ef66a506889da0461ea3363f75bca970ea"}
{"code": "@Override\n  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container = ctx.getContainer();\n    Map<String, String> environment = container.getLaunchContext()\n        .getEnvironment();\n    String imageName = environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n    String network = environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n\n    if(network == null || network.isEmpty()) {\n      network = defaultNetwork;\n    }\n\n    validateContainerNetworkType(network);\n\n    if (imageName == null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n\n    String containerIdStr = container.getContainerId().toString();\n    String runAsUser = ctx.getExecutionAttribute(RUN_AS_USER);\n    Path containerWorkDir = ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n    //List<String> -> stored as List -> fetched/converted to List<String>\n    //we can't do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List<String> localDirs = ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> logDirs = ctx.getExecutionAttribute(LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> filecacheDirs = ctx.getExecutionAttribute(FILECACHE_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> containerLocalDirs = ctx.getExecutionAttribute(\n        CONTAINER_LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List<String> containerLogDirs = ctx.getExecutionAttribute(\n        CONTAINER_LOG_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    Map<Path, List<String>> localizedResources = ctx.getExecutionAttribute(\n        LOCALIZED_RESOURCES);\n    @SuppressWarnings(\"unchecked\")\n    List<String> userLocalDirs = ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n    Set<String> capabilities = new HashSet<>(Arrays.asList(\n        conf.getTrimmedStrings(\n            YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n            YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n\n    @SuppressWarnings(\"unchecked\")\n    DockerRunCommand runCommand = new DockerRunCommand(containerIdStr,\n        runAsUser, imageName)\n        .detachOnRun()\n        .setContainerWorkDir(containerWorkDir.toString())\n        .setNetworkType(network)\n        .setCapabilities(capabilities)\n        .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n            CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n    List<String> allDirs = new ArrayList<>(containerLocalDirs);\n\n    allDirs.addAll(filecacheDirs);\n    allDirs.add(containerWorkDir.toString());\n    allDirs.addAll(containerLogDirs);\n    allDirs.addAll(userLocalDirs);\n    for (String dir: allDirs) {\n      runCommand.addMountLocation(dir, dir, true);\n    }\n\n    if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n      String mounts = environment.get(\n          ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n      if (!mounts.isEmpty()) {\n        for (String mount : StringUtils.split(mounts)) {\n          String[] dir = StringUtils.split(mount, ':');\n          if (dir.length != 2) {\n            throw new ContainerExecutionException(\"Invalid mount : \" +\n                mount);\n          }\n          String src = validateMount(dir[0], localizedResources);\n          String dst = dir[1];\n          runCommand.addMountLocation(src, dst + \":ro\", true);\n        }\n      }\n    }\n\n    if (allowPrivilegedContainerExecution(container)) {\n      runCommand.setPrivileged();\n    }\n\n    String resourcesOpts = ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n\n    Path nmPrivateContainerScriptPath = ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    String disableOverride = environment.get(\n        ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n\n    if (disableOverride != null && disableOverride.equals(\"true\")) {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"command override disabled\");\n      }\n    } else {\n      List<String> overrideCommands = new ArrayList<>();\n      Path launchDst =\n          new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n      overrideCommands.add(\"bash\");\n      overrideCommands.add(launchDst.toUri().getPath());\n      runCommand.setOverrideCommandWithArgs(overrideCommands);\n    }\n\n    String commandFile = dockerClient.writeCommandToTempFile(runCommand,\n        containerIdStr);\n    PrivilegedOperation launchOp = new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n\n    launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        containerIdStr, containerWorkDir.toString(),\n        nmPrivateContainerScriptPath.toUri().getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            localDirs),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            logDirs),\n        commandFile,\n        resourcesOpts);\n\n    String tcCommandFile = ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile != null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Launching container with cmd: \" + runCommand\n          .getCommandWithArguments());\n    }\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n      LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "launchContainer", "(", "ContainerRuntimeContext", "ctx", ")", "throws", "ContainerExecutionException", "{", "Container", "container", "=", "ctx", ".", "getContainer", "(", ")", ";", "Map", "<", "String", ",", "String", ">", "environment", "=", "container", ".", "getLaunchContext", "(", ")", ".", "getEnvironment", "(", ")", ";", "String", "imageName", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_IMAGE", ")", ";", "String", "network", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_NETWORK", ")", ";", "if", "(", "network", "==", "null", "||", "network", ".", "isEmpty", "(", ")", ")", "{", "network", "=", "defaultNetwork", ";", "}", "validateContainerNetworkType", "(", "network", ")", ";", "if", "(", "imageName", "==", "null", ")", "{", "throw", "new", "ContainerExecutionException", "(", "ENV_DOCKER_CONTAINER_IMAGE", "+", "\"", " not set!", "\"", ")", ";", "}", "String", "containerIdStr", "=", "container", ".", "getContainerId", "(", ")", ".", "toString", "(", ")", ";", "String", "runAsUser", "=", "ctx", ".", "getExecutionAttribute", "(", "RUN_AS_USER", ")", ";", "Path", "containerWorkDir", "=", "ctx", ".", "getExecutionAttribute", "(", "CONTAINER_WORK_DIR", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "localDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "LOCAL_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "logDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "LOG_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "filecacheDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "FILECACHE_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "containerLocalDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "CONTAINER_LOCAL_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "containerLogDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "CONTAINER_LOG_DIRS", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "Map", "<", "Path", ",", "List", "<", "String", ">", ">", "localizedResources", "=", "ctx", ".", "getExecutionAttribute", "(", "LOCALIZED_RESOURCES", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "List", "<", "String", ">", "userLocalDirs", "=", "ctx", ".", "getExecutionAttribute", "(", "USER_LOCAL_DIRS", ")", ";", "Set", "<", "String", ">", "capabilities", "=", "new", "HashSet", "<", ">", "(", "Arrays", ".", "asList", "(", "conf", ".", "getTrimmedStrings", "(", "YarnConfiguration", ".", "NM_DOCKER_CONTAINER_CAPABILITIES", ",", "YarnConfiguration", ".", "DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES", ")", ")", ")", ";", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "DockerRunCommand", "runCommand", "=", "new", "DockerRunCommand", "(", "containerIdStr", ",", "runAsUser", ",", "imageName", ")", ".", "detachOnRun", "(", ")", ".", "setContainerWorkDir", "(", "containerWorkDir", ".", "toString", "(", ")", ")", ".", "setNetworkType", "(", "network", ")", ".", "setCapabilities", "(", "capabilities", ")", ".", "addMountLocation", "(", "CGROUPS_ROOT_DIRECTORY", ",", "CGROUPS_ROOT_DIRECTORY", "+", "\"", ":ro", "\"", ",", "false", ")", ";", "List", "<", "String", ">", "allDirs", "=", "new", "ArrayList", "<", ">", "(", "containerLocalDirs", ")", ";", "allDirs", ".", "addAll", "(", "filecacheDirs", ")", ";", "allDirs", ".", "add", "(", "containerWorkDir", ".", "toString", "(", ")", ")", ";", "allDirs", ".", "addAll", "(", "containerLogDirs", ")", ";", "allDirs", ".", "addAll", "(", "userLocalDirs", ")", ";", "for", "(", "String", "dir", ":", "allDirs", ")", "{", "runCommand", ".", "addMountLocation", "(", "dir", ",", "dir", ",", "true", ")", ";", "}", "if", "(", "environment", ".", "containsKey", "(", "ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS", ")", ")", "{", "String", "mounts", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS", ")", ";", "if", "(", "!", "mounts", ".", "isEmpty", "(", ")", ")", "{", "for", "(", "String", "mount", ":", "StringUtils", ".", "split", "(", "mounts", ")", ")", "{", "String", "[", "]", "dir", "=", "StringUtils", ".", "split", "(", "mount", ",", "':'", ")", ";", "if", "(", "dir", ".", "length", "!=", "2", ")", "{", "throw", "new", "ContainerExecutionException", "(", "\"", "Invalid mount : ", "\"", "+", "mount", ")", ";", "}", "String", "src", "=", "validateMount", "(", "dir", "[", "0", "]", ",", "localizedResources", ")", ";", "String", "dst", "=", "dir", "[", "1", "]", ";", "runCommand", ".", "addMountLocation", "(", "src", ",", "dst", "+", "\"", ":ro", "\"", ",", "true", ")", ";", "}", "}", "}", "if", "(", "allowPrivilegedContainerExecution", "(", "container", ")", ")", "{", "runCommand", ".", "setPrivileged", "(", ")", ";", "}", "String", "resourcesOpts", "=", "ctx", ".", "getExecutionAttribute", "(", "RESOURCES_OPTIONS", ")", ";", "addCGroupParentIfRequired", "(", "resourcesOpts", ",", "containerIdStr", ",", "runCommand", ")", ";", "Path", "nmPrivateContainerScriptPath", "=", "ctx", ".", "getExecutionAttribute", "(", "NM_PRIVATE_CONTAINER_SCRIPT_PATH", ")", ";", "String", "disableOverride", "=", "environment", ".", "get", "(", "ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE", ")", ";", "if", "(", "disableOverride", "!=", "null", "&&", "disableOverride", ".", "equals", "(", "\"", "true", "\"", ")", ")", "{", "if", "(", "LOG", ".", "isInfoEnabled", "(", ")", ")", "{", "LOG", ".", "info", "(", "\"", "command override disabled", "\"", ")", ";", "}", "}", "else", "{", "List", "<", "String", ">", "overrideCommands", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Path", "launchDst", "=", "new", "Path", "(", "containerWorkDir", ",", "ContainerLaunch", ".", "CONTAINER_SCRIPT", ")", ";", "overrideCommands", ".", "add", "(", "\"", "bash", "\"", ")", ";", "overrideCommands", ".", "add", "(", "launchDst", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ")", ";", "runCommand", ".", "setOverrideCommandWithArgs", "(", "overrideCommands", ")", ";", "}", "String", "commandFile", "=", "dockerClient", ".", "writeCommandToTempFile", "(", "runCommand", ",", "containerIdStr", ")", ";", "PrivilegedOperation", "launchOp", "=", "new", "PrivilegedOperation", "(", "PrivilegedOperation", ".", "OperationType", ".", "LAUNCH_DOCKER_CONTAINER", ")", ";", "launchOp", ".", "appendArgs", "(", "runAsUser", ",", "ctx", ".", "getExecutionAttribute", "(", "USER", ")", ",", "Integer", ".", "toString", "(", "PrivilegedOperation", ".", "RunAsUserCommand", ".", "LAUNCH_DOCKER_CONTAINER", ".", "getValue", "(", ")", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "APPID", ")", ",", "containerIdStr", ",", "containerWorkDir", ".", "toString", "(", ")", ",", "nmPrivateContainerScriptPath", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "NM_PRIVATE_TOKENS_PATH", ")", ".", "toUri", "(", ")", ".", "getPath", "(", ")", ",", "ctx", ".", "getExecutionAttribute", "(", "PID_FILE_PATH", ")", ".", "toString", "(", ")", ",", "StringUtils", ".", "join", "(", "PrivilegedOperation", ".", "LINUX_FILE_PATH_SEPARATOR", ",", "localDirs", ")", ",", "StringUtils", ".", "join", "(", "PrivilegedOperation", ".", "LINUX_FILE_PATH_SEPARATOR", ",", "logDirs", ")", ",", "commandFile", ",", "resourcesOpts", ")", ";", "String", "tcCommandFile", "=", "ctx", ".", "getExecutionAttribute", "(", "TC_COMMAND_FILE", ")", ";", "if", "(", "tcCommandFile", "!=", "null", ")", "{", "launchOp", ".", "appendArgs", "(", "tcCommandFile", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Launching container with cmd: ", "\"", "+", "runCommand", ".", "getCommandWithArguments", "(", ")", ")", ";", "}", "try", "{", "privilegedOperationExecutor", ".", "executePrivilegedOperation", "(", "null", ",", "launchOp", ",", "null", ",", "container", ".", "getLaunchContext", "(", ")", ".", "getEnvironment", "(", ")", ",", "false", ",", "false", ")", ";", "}", "catch", "(", "PrivilegedOperationException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Launch container failed. Exception: ", "\"", ",", "e", ")", ";", "LOG", ".", "info", "(", "\"", "Docker command used: ", "\"", "+", "runCommand", ".", "getCommandWithArguments", "(", ")", ")", ";", "throw", "new", "ContainerExecutionException", "(", "\"", "Launch container failed", "\"", ",", "e", ".", "getExitCode", "(", ")", ",", "e", ".", "getOutput", "(", ")", ",", "e", ".", "getErrorOutput", "(", ")", ")", ";", "}", "}"], "idx": 7738, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "0319e74c2512d47d47ab9df834f5b6455be7d968", "function_name": "launchContainer", "body_hash": "de8a04dcdb09ca675c90d4ba9554466c808cb032"}
{"code": "private final void internalMapWrapper(ContextVersion contextVersion,\n                                          CharChunk path,\n                                          MappingData mappingData) throws IOException {\n\n        int pathOffset = path.getOffset();\n        int pathEnd = path.getEnd();\n        boolean noServletPath = false;\n\n        int length = contextVersion.path.length();\n        if (length == (pathEnd - pathOffset)) {\n            noServletPath = true;\n        }\n        int servletPath = pathOffset + length;\n        path.setOffset(servletPath);\n\n        // Rule 1 -- Exact Match\n        MappedWrapper[] exactWrappers = contextVersion.exactWrappers;\n        internalMapExactWrapper(exactWrappers, path, mappingData);\n\n        // Rule 2 -- Prefix Match\n        boolean checkJspWelcomeFiles = false;\n        MappedWrapper[] wildcardWrappers = contextVersion.wildcardWrappers;\n        if (mappingData.wrapper == null) {\n            internalMapWildcardWrapper(wildcardWrappers, contextVersion.nesting,\n                                       path, mappingData);\n            if (mappingData.wrapper != null && mappingData.jspWildCard) {\n                char[] buf = path.getBuffer();\n                if (buf[pathEnd - 1] == '/') {\n                    /*\n                     * Path ending in '/' was mapped to JSP servlet based on\n                     * wildcard match (e.g., as specified in url-pattern of a\n                     * jsp-property-group.\n                     * Force the context's welcome files, which are interpreted\n                     * as JSP files (since they match the url-pattern), to be\n                     * considered. See Bugzilla 27664.\n                     */\n                    mappingData.wrapper = null;\n                    checkJspWelcomeFiles = true;\n                } else {\n                    // See Bugzilla 27704\n                    mappingData.wrapperPath.setChars(buf, path.getStart(),\n                                                     path.getLength());\n                    mappingData.pathInfo.recycle();\n                }\n            }\n        }\n\n        if(mappingData.wrapper == null && noServletPath &&\n                mappingData.context.getMapperContextRootRedirectEnabled()) {\n            // The path is empty, redirect to \"/\"\n            mappingData.redirectPath.setChars\n                (path.getBuffer(), pathOffset, pathEnd-pathOffset);\n            path.setEnd(pathEnd - 1);\n            return;\n        }\n\n        // Rule 3 -- Extension Match\n        MappedWrapper[] extensionWrappers = contextVersion.extensionWrappers;\n        if (mappingData.wrapper == null && !checkJspWelcomeFiles) {\n            internalMapExtensionWrapper(extensionWrappers, path, mappingData,\n                    true);\n        }\n\n        // Rule 4 -- Welcome resources processing for servlets\n        if (mappingData.wrapper == null) {\n            boolean checkWelcomeFiles = checkJspWelcomeFiles;\n            if (!checkWelcomeFiles) {\n                char[] buf = path.getBuffer();\n                checkWelcomeFiles = (buf[pathEnd - 1] == '/');\n            }\n            if (checkWelcomeFiles) {\n                for (int i = 0; (i < contextVersion.welcomeResources.length)\n                         && (mappingData.wrapper == null); i++) {\n                    path.setOffset(pathOffset);\n                    path.setEnd(pathEnd);\n                    path.append(contextVersion.welcomeResources[i], 0,\n                            contextVersion.welcomeResources[i].length());\n                    path.setOffset(servletPath);\n\n                    // Rule 4a -- Welcome resources processing for exact macth\n                    internalMapExactWrapper(exactWrappers, path, mappingData);\n\n                    // Rule 4b -- Welcome resources processing for prefix match\n                    if (mappingData.wrapper == null) {\n                        internalMapWildcardWrapper\n                            (wildcardWrappers, contextVersion.nesting,\n                             path, mappingData);\n                    }\n\n                    // Rule 4c -- Welcome resources processing\n                    //            for physical folder\n                    if (mappingData.wrapper == null\n                        && contextVersion.resources != null) {\n                        String pathStr = path.toString();\n                        WebResource file =\n                                contextVersion.resources.getResource(pathStr);\n                        if (file != null && file.isFile()) {\n                            internalMapExtensionWrapper(extensionWrappers, path,\n                                                        mappingData, true);\n                            if (mappingData.wrapper == null\n                                && contextVersion.defaultWrapper != null) {\n                                mappingData.wrapper =\n                                    contextVersion.defaultWrapper.object;\n                                mappingData.requestPath.setChars\n                                    (path.getBuffer(), path.getStart(),\n                                     path.getLength());\n                                mappingData.wrapperPath.setChars\n                                    (path.getBuffer(), path.getStart(),\n                                     path.getLength());\n                                mappingData.requestPath.setString(pathStr);\n                                mappingData.wrapperPath.setString(pathStr);\n                            }\n                        }\n                    }\n                }\n\n                path.setOffset(servletPath);\n                path.setEnd(pathEnd);\n            }\n\n        }\n\n        /* welcome file processing - take 2\n         * Now that we have looked for welcome files with a physical\n         * backing, now look for an extension mapping listed\n         * but may not have a physical backing to it. This is for\n         * the case of index.jsf, index.do, etc.\n         * A watered down version of rule 4\n         */\n        if (mappingData.wrapper == null) {\n            boolean checkWelcomeFiles = checkJspWelcomeFiles;\n            if (!checkWelcomeFiles) {\n                char[] buf = path.getBuffer();\n                checkWelcomeFiles = (buf[pathEnd - 1] == '/');\n            }\n            if (checkWelcomeFiles) {\n                for (int i = 0; (i < contextVersion.welcomeResources.length)\n                         && (mappingData.wrapper == null); i++) {\n                    path.setOffset(pathOffset);\n                    path.setEnd(pathEnd);\n                    path.append(contextVersion.welcomeResources[i], 0,\n                                contextVersion.welcomeResources[i].length());\n                    path.setOffset(servletPath);\n                    internalMapExtensionWrapper(extensionWrappers, path,\n                                                mappingData, false);\n                }\n\n                path.setOffset(servletPath);\n                path.setEnd(pathEnd);\n            }\n        }\n\n\n        // Rule 7 -- Default servlet\n        if (mappingData.wrapper == null && !checkJspWelcomeFiles) {\n            if (contextVersion.defaultWrapper != null) {\n                mappingData.wrapper = contextVersion.defaultWrapper.object;\n                mappingData.requestPath.setChars\n                    (path.getBuffer(), path.getStart(), path.getLength());\n                mappingData.wrapperPath.setChars\n                    (path.getBuffer(), path.getStart(), path.getLength());\n            }\n            // Redirection to a folder\n            char[] buf = path.getBuffer();\n            if (contextVersion.resources != null && buf[pathEnd -1 ] != '/') {\n                String pathStr = path.toString();\n                WebResource file;\n                // Handle context root\n                if (pathStr.length() == 0) {\n                    file = contextVersion.resources.getResource(\"/\");\n                } else {\n                    file = contextVersion.resources.getResource(pathStr);\n                }\n                if (file != null && file.isDirectory() &&\n                        mappingData.context.getMapperDirectoryRedirectEnabled()) {\n                    // Note: this mutates the path: do not do any processing\n                    // after this (since we set the redirectPath, there\n                    // shouldn't be any)\n                    path.setOffset(pathOffset);\n                    path.append('/');\n                    mappingData.redirectPath.setChars\n                        (path.getBuffer(), path.getStart(), path.getLength());\n                } else {\n                    mappingData.requestPath.setString(pathStr);\n                    mappingData.wrapperPath.setString(pathStr);\n                }\n            }\n        }\n\n        path.setOffset(pathOffset);\n        path.setEnd(pathEnd);\n    }", "code_tokens": ["private", "final", "void", "internalMapWrapper", "(", "ContextVersion", "contextVersion", ",", "CharChunk", "path", ",", "MappingData", "mappingData", ")", "throws", "IOException", "{", "int", "pathOffset", "=", "path", ".", "getOffset", "(", ")", ";", "int", "pathEnd", "=", "path", ".", "getEnd", "(", ")", ";", "boolean", "noServletPath", "=", "false", ";", "int", "length", "=", "contextVersion", ".", "path", ".", "length", "(", ")", ";", "if", "(", "length", "==", "(", "pathEnd", "-", "pathOffset", ")", ")", "{", "noServletPath", "=", "true", ";", "}", "int", "servletPath", "=", "pathOffset", "+", "length", ";", "path", ".", "setOffset", "(", "servletPath", ")", ";", "MappedWrapper", "[", "]", "exactWrappers", "=", "contextVersion", ".", "exactWrappers", ";", "internalMapExactWrapper", "(", "exactWrappers", ",", "path", ",", "mappingData", ")", ";", "boolean", "checkJspWelcomeFiles", "=", "false", ";", "MappedWrapper", "[", "]", "wildcardWrappers", "=", "contextVersion", ".", "wildcardWrappers", ";", "if", "(", "mappingData", ".", "wrapper", "==", "null", ")", "{", "internalMapWildcardWrapper", "(", "wildcardWrappers", ",", "contextVersion", ".", "nesting", ",", "path", ",", "mappingData", ")", ";", "if", "(", "mappingData", ".", "wrapper", "!=", "null", "&&", "mappingData", ".", "jspWildCard", ")", "{", "char", "[", "]", "buf", "=", "path", ".", "getBuffer", "(", ")", ";", "if", "(", "buf", "[", "pathEnd", "-", "1", "]", "==", "'/'", ")", "{", "mappingData", ".", "wrapper", "=", "null", ";", "checkJspWelcomeFiles", "=", "true", ";", "}", "else", "{", "mappingData", ".", "wrapperPath", ".", "setChars", "(", "buf", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "mappingData", ".", "pathInfo", ".", "recycle", "(", ")", ";", "}", "}", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "noServletPath", "&&", "mappingData", ".", "context", ".", "getMapperContextRootRedirectEnabled", "(", ")", ")", "{", "mappingData", ".", "redirectPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "pathOffset", ",", "pathEnd", "-", "pathOffset", ")", ";", "path", ".", "setEnd", "(", "pathEnd", "-", "1", ")", ";", "return", ";", "}", "MappedWrapper", "[", "]", "extensionWrappers", "=", "contextVersion", ".", "extensionWrappers", ";", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "!", "checkJspWelcomeFiles", ")", "{", "internalMapExtensionWrapper", "(", "extensionWrappers", ",", "path", ",", "mappingData", ",", "true", ")", ";", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", ")", "{", "boolean", "checkWelcomeFiles", "=", "checkJspWelcomeFiles", ";", "if", "(", "!", "checkWelcomeFiles", ")", "{", "char", "[", "]", "buf", "=", "path", ".", "getBuffer", "(", ")", ";", "checkWelcomeFiles", "=", "(", "buf", "[", "pathEnd", "-", "1", "]", "==", "'/'", ")", ";", "}", "if", "(", "checkWelcomeFiles", ")", "{", "for", "(", "int", "i", "=", "0", ";", "(", "i", "<", "contextVersion", ".", "welcomeResources", ".", "length", ")", "&&", "(", "mappingData", ".", "wrapper", "==", "null", ")", ";", "i", "++", ")", "{", "path", ".", "setOffset", "(", "pathOffset", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "path", ".", "append", "(", "contextVersion", ".", "welcomeResources", "[", "i", "]", ",", "0", ",", "contextVersion", ".", "welcomeResources", "[", "i", "]", ".", "length", "(", ")", ")", ";", "path", ".", "setOffset", "(", "servletPath", ")", ";", "internalMapExactWrapper", "(", "exactWrappers", ",", "path", ",", "mappingData", ")", ";", "if", "(", "mappingData", ".", "wrapper", "==", "null", ")", "{", "internalMapWildcardWrapper", "(", "wildcardWrappers", ",", "contextVersion", ".", "nesting", ",", "path", ",", "mappingData", ")", ";", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "contextVersion", ".", "resources", "!=", "null", ")", "{", "String", "pathStr", "=", "path", ".", "toString", "(", ")", ";", "WebResource", "file", "=", "contextVersion", ".", "resources", ".", "getResource", "(", "pathStr", ")", ";", "if", "(", "file", "!=", "null", "&&", "file", ".", "isFile", "(", ")", ")", "{", "internalMapExtensionWrapper", "(", "extensionWrappers", ",", "path", ",", "mappingData", ",", "true", ")", ";", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "contextVersion", ".", "defaultWrapper", "!=", "null", ")", "{", "mappingData", ".", "wrapper", "=", "contextVersion", ".", "defaultWrapper", ".", "object", ";", "mappingData", ".", "requestPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "mappingData", ".", "wrapperPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "mappingData", ".", "requestPath", ".", "setString", "(", "pathStr", ")", ";", "mappingData", ".", "wrapperPath", ".", "setString", "(", "pathStr", ")", ";", "}", "}", "}", "}", "path", ".", "setOffset", "(", "servletPath", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "}", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", ")", "{", "boolean", "checkWelcomeFiles", "=", "checkJspWelcomeFiles", ";", "if", "(", "!", "checkWelcomeFiles", ")", "{", "char", "[", "]", "buf", "=", "path", ".", "getBuffer", "(", ")", ";", "checkWelcomeFiles", "=", "(", "buf", "[", "pathEnd", "-", "1", "]", "==", "'/'", ")", ";", "}", "if", "(", "checkWelcomeFiles", ")", "{", "for", "(", "int", "i", "=", "0", ";", "(", "i", "<", "contextVersion", ".", "welcomeResources", ".", "length", ")", "&&", "(", "mappingData", ".", "wrapper", "==", "null", ")", ";", "i", "++", ")", "{", "path", ".", "setOffset", "(", "pathOffset", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "path", ".", "append", "(", "contextVersion", ".", "welcomeResources", "[", "i", "]", ",", "0", ",", "contextVersion", ".", "welcomeResources", "[", "i", "]", ".", "length", "(", ")", ")", ";", "path", ".", "setOffset", "(", "servletPath", ")", ";", "internalMapExtensionWrapper", "(", "extensionWrappers", ",", "path", ",", "mappingData", ",", "false", ")", ";", "}", "path", ".", "setOffset", "(", "servletPath", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "}", "}", "if", "(", "mappingData", ".", "wrapper", "==", "null", "&&", "!", "checkJspWelcomeFiles", ")", "{", "if", "(", "contextVersion", ".", "defaultWrapper", "!=", "null", ")", "{", "mappingData", ".", "wrapper", "=", "contextVersion", ".", "defaultWrapper", ".", "object", ";", "mappingData", ".", "requestPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "mappingData", ".", "wrapperPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "}", "char", "[", "]", "buf", "=", "path", ".", "getBuffer", "(", ")", ";", "if", "(", "contextVersion", ".", "resources", "!=", "null", "&&", "buf", "[", "pathEnd", "-", "1", "]", "!=", "'/'", ")", "{", "String", "pathStr", "=", "path", ".", "toString", "(", ")", ";", "WebResource", "file", ";", "if", "(", "pathStr", ".", "length", "(", ")", "==", "0", ")", "{", "file", "=", "contextVersion", ".", "resources", ".", "getResource", "(", "\"", "/", "\"", ")", ";", "}", "else", "{", "file", "=", "contextVersion", ".", "resources", ".", "getResource", "(", "pathStr", ")", ";", "}", "if", "(", "file", "!=", "null", "&&", "file", ".", "isDirectory", "(", ")", "&&", "mappingData", ".", "context", ".", "getMapperDirectoryRedirectEnabled", "(", ")", ")", "{", "path", ".", "setOffset", "(", "pathOffset", ")", ";", "path", ".", "append", "(", "'/'", ")", ";", "mappingData", ".", "redirectPath", ".", "setChars", "(", "path", ".", "getBuffer", "(", ")", ",", "path", ".", "getStart", "(", ")", ",", "path", ".", "getLength", "(", ")", ")", ";", "}", "else", "{", "mappingData", ".", "requestPath", ".", "setString", "(", "pathStr", ")", ";", "mappingData", ".", "wrapperPath", ".", "setString", "(", "pathStr", ")", ";", "}", "}", "}", "path", ".", "setOffset", "(", "pathOffset", ")", ";", "path", ".", "setEnd", "(", "pathEnd", ")", ";", "}"], "idx": 25639, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "c584c7c4ab0686e4125eefcd0afb32fb8269da3d", "function_name": "internalMapWrapper", "body_hash": "c0b4a124ca3bd525cb27e22c6fa32a3aa77d0963"}
{"code": "@Bean\n    public Server rsServer() {\n        JAXRSServerFactoryBean endpoint = new JAXRSServerFactoryBean();\n        endpoint.setBus(bus);\n        endpoint.setServiceBeans(Arrays.<Object>asList(new HelloServiceImpl1(), new HelloServiceImpl2()));\n        endpoint.setAddress(\"/a\");\n        endpoint.setFeatures(Arrays.asList(new Swagger2Feature()));\n        return endpoint.create();\n    }", "code_tokens": ["@", "Bean", "public", "Server", "rsServer", "(", ")", "{", "JAXRSServerFactoryBean", "endpoint", "=", "new", "JAXRSServerFactoryBean", "(", ")", ";", "endpoint", ".", "setBus", "(", "bus", ")", ";", "endpoint", ".", "setServiceBeans", "(", "Arrays", ".", "<", "Object", ">", "asList", "(", "new", "HelloServiceImpl1", "(", ")", ",", "new", "HelloServiceImpl2", "(", ")", ")", ")", ";", "endpoint", ".", "setAddress", "(", "\"", "/a", "\"", ")", ";", "endpoint", ".", "setFeatures", "(", "Arrays", ".", "asList", "(", "new", "Swagger2Feature", "(", ")", ")", ")", ";", "return", "endpoint", ".", "create", "(", ")", ";", "}"], "idx": 79119, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "1f824d80", "function_name": "rsServer", "body_hash": "e9619da6f53361793ea0609b33167a132ded2e41"}
{"code": "public static Map<String, String> getSAMLAttributes() {\n        Map<String, String> attributes = new HashMap<>();\n        attributes.put(SAML_CLIENT_SIGNATURE, \"true\");\n        attributes.put(SAML_AUTHNSTATEMENT, \"true\");\n        attributes.put(SAML_FORCE_POST_BINDING, \"true\");\n        attributes.put(SAML_SERVER_SIGNATURE, \"true\");\n        attributes.put(SAML_SIGNATURE_ALGORITHM, \"RSA_SHA256\");\n        attributes.put(SAML_FORCE_NAME_ID_FORMAT, \"false\");\n        attributes.put(SAML_NAME_ID_FORMAT, \"username\");\n        attributes.put(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(\"saml\"));\n        return attributes;\n    }", "code_tokens": ["public", "static", "Map", "<", "String", ",", "String", ">", "getSAMLAttributes", "(", ")", "{", "Map", "<", "String", ",", "String", ">", "attributes", "=", "new", "HashMap", "<", ">", "(", ")", ";", "attributes", ".", "put", "(", "SAML_CLIENT_SIGNATURE", ",", "\"", "true", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_AUTHNSTATEMENT", ",", "\"", "true", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_FORCE_POST_BINDING", ",", "\"", "true", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_SERVER_SIGNATURE", ",", "\"", "true", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_SIGNATURE_ALGORITHM", ",", "\"", "RSA_SHA256", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_FORCE_NAME_ID_FORMAT", ",", "\"", "false", "\"", ")", ";", "attributes", ".", "put", "(", "SAML_NAME_ID_FORMAT", ",", "\"", "username", "\"", ")", ";", "attributes", ".", "put", "(", "SamlConfigAttributes", ".", "SAML_ARTIFACT_BINDING_IDENTIFIER", ",", "ArtifactBindingUtils", ".", "computeArtifactBindingIdentifierString", "(", "\"", "saml", "\"", ")", ")", ";", "return", "attributes", ";", "}"], "idx": 39603, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "44000caaf5051d7f218d1ad79573bd3d175cad0d", "function_name": "getSAMLAttributes", "body_hash": "a6cb9edbd58f0eb271a5ac0d97e797da591ed264"}
{"code": "@Override\n        public String toString() {\n//            StringBuilder buf = new StringBuilder();\n//            for (long l : past5) {\n//                if(buf.length()>0)  buf.append(',');\n//                buf.append(l);\n//            }\n//            return buf.toString();\n            int fc = failureCount();\n            if(fc>0)\n                return Util.wrapToErrorSpan(Messages.ResponseTimeMonitor_TimeOut(fc));\n            return getAverage()+\"ms\";\n        }", "code_tokens": ["@", "Override", "public", "String", "toString", "(", ")", "{", "int", "fc", "=", "failureCount", "(", ")", ";", "if", "(", "fc", ">", "0", ")", "return", "Util", ".", "wrapToErrorSpan", "(", "Messages", ".", "ResponseTimeMonitor_TimeOut", "(", "fc", ")", ")", ";", "return", "getAverage", "(", ")", "+", "\"", "ms", "\"", ";", "}"], "idx": 77707, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "1addc5d0feab0e77bb68e88fc74bb651e45cb462", "function_name": "toString", "body_hash": "1358d07877897dcd9bd348bdd017d17d2c036a58"}
{"code": "@Override\n        public void handleEvent(StreamConnection channel) {\n            final Map<String, String> headers = new HashMap<String, String>();\n            headers.put(UPGRADE, \"jboss-remoting\");\n            final String secKey = createSecKey();\n            headers.put(SEC_JBOSS_REMOTING_KEY, secKey);\n\n            IoFuture<T> upgradeFuture = HttpUpgrade.performUpgrade(type.cast(channel), uri, headers, upgradeChannel -> {\n                ChannelListeners.invokeChannelListener(upgradeChannel, openListener);\n            }, new RemotingHandshakeChecker(secKey));\n\n            futureResult.addCancelHandler(new Cancellable() {\n                @Override\n                public Cancellable cancel() {\n                    if (channel.isOpen()) {\n                        safeClose(channel);\n                    }\n                    return this;\n                }\n            });\n\n            upgradeFuture.addNotifier( new IoFuture.HandlingNotifier<T, FutureResult<T>>() {\n\n                @Override\n                public void handleCancelled(FutureResult<T> attachment) {\n                    attachment.setCancelled();\n                }\n\n                @Override\n                public void handleFailed(IOException exception, FutureResult<T> attachment) {\n                    attachment.setException(exception);\n                }\n\n                @Override\n                public void handleDone(T data, FutureResult<T> attachment) {\n                    attachment.setResult(data);\n                }\n\n            }, futureResult);\n        }", "code_tokens": ["@", "Override", "public", "void", "handleEvent", "(", "StreamConnection", "channel", ")", "{", "final", "Map", "<", "String", ",", "String", ">", "headers", "=", "new", "HashMap", "<", "String", ",", "String", ">", "(", ")", ";", "headers", ".", "put", "(", "UPGRADE", ",", "\"", "jboss-remoting", "\"", ")", ";", "final", "String", "secKey", "=", "createSecKey", "(", ")", ";", "headers", ".", "put", "(", "SEC_JBOSS_REMOTING_KEY", ",", "secKey", ")", ";", "IoFuture", "<", "T", ">", "upgradeFuture", "=", "HttpUpgrade", ".", "performUpgrade", "(", "type", ".", "cast", "(", "channel", ")", ",", "uri", ",", "headers", ",", "upgradeChannel", "->", "{", "ChannelListeners", ".", "invokeChannelListener", "(", "upgradeChannel", ",", "openListener", ")", ";", "}", ",", "new", "RemotingHandshakeChecker", "(", "secKey", ")", ")", ";", "futureResult", ".", "addCancelHandler", "(", "new", "Cancellable", "(", ")", "{", "@", "Override", "public", "Cancellable", "cancel", "(", ")", "{", "if", "(", "channel", ".", "isOpen", "(", ")", ")", "{", "safeClose", "(", "channel", ")", ";", "}", "return", "this", ";", "}", "}", ")", ";", "upgradeFuture", ".", "addNotifier", "(", "new", "IoFuture", ".", "HandlingNotifier", "<", "T", ",", "FutureResult", "<", "T", ">", ">", "(", ")", "{", "@", "Override", "public", "void", "handleCancelled", "(", "FutureResult", "<", "T", ">", "attachment", ")", "{", "attachment", ".", "setCancelled", "(", ")", ";", "}", "@", "Override", "public", "void", "handleFailed", "(", "IOException", "exception", ",", "FutureResult", "<", "T", ">", "attachment", ")", "{", "attachment", ".", "setException", "(", "exception", ")", ";", "}", "@", "Override", "public", "void", "handleDone", "(", "T", "data", ",", "FutureResult", "<", "T", ">", "attachment", ")", "{", "attachment", ".", "setResult", "(", "data", ")", ";", "}", "}", ",", "futureResult", ")", ";", "}"], "idx": 52679, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "7c59d0e89972e855ab21654a12efa012e550f722", "function_name": "handleEvent", "body_hash": "f1ffef81cf49757b790d95f888d72bbec26ceaab"}
{"code": "@SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"False positive\")\n    public synchronized int run(String[] args) throws Exception{\n        if (used) {\n            throw new IllegalStateException(\"CLI instance already used\");\n        }\n\n        used = true;\n\n        CLIParser parser = new CLIParser(\"oozie-setup.sh\", HELP_INFO);\n        String oozieHome = System.getProperty(OOZIE_HOME);\n        parser.addCommand(HELP_CMD, \"\", \"display usage for all commands or specified command\", new Options(), false);\n        parser.addCommand(CREATE_CMD, \"\", \"create a new timestamped version of oozie sharelib\",\n                createUpgradeOptions(CREATE_CMD), false);\n        parser.addCommand(UPGRADE_CMD, \"\",\n                \"[deprecated][use command \\\"create\\\" to create new version]   upgrade oozie sharelib \\n\",\n                createUpgradeOptions(UPGRADE_CMD), false);\n\n        try {\n            final CLIParser.Command command = parser.parse(args);\n            String sharelibAction = command.getName();\n\n            if (sharelibAction.equals(HELP_CMD)){\n                parser.showHelp(command.getCommandLine());\n                return 0;\n            }\n\n            if (!command.getCommandLine().hasOption(FS_OPT)){\n                throw new Exception(\"-fs option must be specified\");\n            }\n\n            int threadPoolSize = Integer.valueOf(command.getCommandLine().getOptionValue(CONCURRENCY_OPT, \"1\"));\n            File srcFile = null;\n\n            //Check whether user provided locallib\n            if (command.getCommandLine().hasOption(LIB_OPT)){\n                srcFile = new File(command.getCommandLine().getOptionValue(LIB_OPT));\n            }\n            else {\n                //Since user did not provide locallib, find the default one under oozie home dir\n                Collection<File> files =\n                        FileUtils.listFiles(new File(oozieHome), new WildcardFileFilter(\"oozie-sharelib*.tar.gz\"), null);\n\n                if (files.size() > 1){\n                    throw new IOException(\"more than one sharelib tar found at \" + oozieHome);\n                }\n\n                if (files.isEmpty()){\n                    throw new IOException(\"default sharelib tar not found in oozie home dir: \" + oozieHome);\n                }\n\n                srcFile = files.iterator().next();\n            }\n\n            Map<String, String> extraLibs = new HashMap<>();\n            if (command.getCommandLine().hasOption(EXTRALIBS)) {\n                String[] param = command.getCommandLine().getOptionValues(EXTRALIBS);\n                extraLibs = getExtraLibs(param);\n            }\n\n           File temp = Files.createTempDirectory(\"oozie\").toFile();\n            temp.deleteOnExit();\n\n            //Check whether the lib is a tar file or folder\n            if (!srcFile.isDirectory()){\n                FileUtil.unTar(srcFile, temp);\n                srcFile = new File(temp.toString() + \"/share/lib\");\n            }\n            else {\n                //Get the lib directory since it's a folder\n                srcFile = new File(srcFile, \"lib\");\n            }\n\n            String hdfsUri = command.getCommandLine().getOptionValue(FS_OPT);\n            Path srcPath = new Path(srcFile.toString());\n\n            Services services = new Services();\n            services.getConf().set(Services.CONF_SERVICE_CLASSES,\n                \"org.apache.oozie.service.LiteWorkflowAppService, org.apache.oozie.service.HadoopAccessorService\");\n            services.getConf().set(Services.CONF_SERVICE_EXT_CLASSES, \"\");\n            services.init();\n            WorkflowAppService lwas = services.get(WorkflowAppService.class);\n            HadoopAccessorService has = services.get(HadoopAccessorService.class);\n            Path dstPath = lwas.getSystemLibPath();\n\n            URI uri = new Path(hdfsUri).toUri();\n            Configuration fsConf = has.createConfiguration(uri.getAuthority());\n            FileSystem fs = FileSystem.get(uri, fsConf);\n\n            if (!fs.exists(dstPath)) {\n                fs.mkdirs(dstPath);\n            }\n            ECPolicyDisabler.tryDisableECPolicyForPath(fs, dstPath);\n\n            if (sharelibAction.equals(CREATE_CMD) || sharelibAction.equals(UPGRADE_CMD)){\n                dstPath= new Path(dstPath.toString() +  Path.SEPARATOR +  SHARE_LIB_PREFIX + getTimestampDirectory()  );\n            }\n\n            System.out.println(\"the destination path for sharelib is: \" + dstPath);\n\n            checkIfSourceFilesExist(srcFile);\n            copyToSharelib(threadPoolSize, srcFile, srcPath, dstPath, fs);\n            copyExtraLibs(threadPoolSize, extraLibs, dstPath, fs);\n\n            if (sharelibAction.equals(CREATE_CMD) || sharelibAction.equals(UPGRADE_CMD)) {\n                applySharelibPermission(fs, dstPath);\n            }\n\n            services.destroy();\n            FileUtils.deleteDirectory(temp);\n\n            return 0;\n        }\n        catch (ParseException ex) {\n            System.err.println(\"Invalid sub-command: \" + ex.getMessage());\n            System.err.println();\n            System.err.println(parser.shortHelp());\n            return 1;\n        }\n        catch (NumberFormatException ex) {\n            logError(\"Invalid configuration value: \", ex);\n            return 1;\n        }\n        catch (Exception ex) {\n            logError(ex.getMessage(), ex);\n            return 1;\n        }\n    }", "code_tokens": ["@", "SuppressFBWarnings", "(", "value", "=", "\"", "PATH_TRAVERSAL_IN", "\"", ",", "justification", "=", "\"", "False positive", "\"", ")", "public", "synchronized", "int", "run", "(", "String", "[", "]", "args", ")", "throws", "Exception", "{", "if", "(", "used", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "CLI instance already used", "\"", ")", ";", "}", "used", "=", "true", ";", "CLIParser", "parser", "=", "new", "CLIParser", "(", "\"", "oozie-setup.sh", "\"", ",", "HELP_INFO", ")", ";", "String", "oozieHome", "=", "System", ".", "getProperty", "(", "OOZIE_HOME", ")", ";", "parser", ".", "addCommand", "(", "HELP_CMD", ",", "\"", "\"", ",", "\"", "display usage for all commands or specified command", "\"", ",", "new", "Options", "(", ")", ",", "false", ")", ";", "parser", ".", "addCommand", "(", "CREATE_CMD", ",", "\"", "\"", ",", "\"", "create a new timestamped version of oozie sharelib", "\"", ",", "createUpgradeOptions", "(", "CREATE_CMD", ")", ",", "false", ")", ";", "parser", ".", "addCommand", "(", "UPGRADE_CMD", ",", "\"", "\"", ",", "\"", "[deprecated][use command ", "\\\"", "create", "\\\"", " to create new version]   upgrade oozie sharelib ", "\\n", "\"", ",", "createUpgradeOptions", "(", "UPGRADE_CMD", ")", ",", "false", ")", ";", "try", "{", "final", "CLIParser", ".", "Command", "command", "=", "parser", ".", "parse", "(", "args", ")", ";", "String", "sharelibAction", "=", "command", ".", "getName", "(", ")", ";", "if", "(", "sharelibAction", ".", "equals", "(", "HELP_CMD", ")", ")", "{", "parser", ".", "showHelp", "(", "command", ".", "getCommandLine", "(", ")", ")", ";", "return", "0", ";", "}", "if", "(", "!", "command", ".", "getCommandLine", "(", ")", ".", "hasOption", "(", "FS_OPT", ")", ")", "{", "throw", "new", "Exception", "(", "\"", "-fs option must be specified", "\"", ")", ";", "}", "int", "threadPoolSize", "=", "Integer", ".", "valueOf", "(", "command", ".", "getCommandLine", "(", ")", ".", "getOptionValue", "(", "CONCURRENCY_OPT", ",", "\"", "1", "\"", ")", ")", ";", "File", "srcFile", "=", "null", ";", "if", "(", "command", ".", "getCommandLine", "(", ")", ".", "hasOption", "(", "LIB_OPT", ")", ")", "{", "srcFile", "=", "new", "File", "(", "command", ".", "getCommandLine", "(", ")", ".", "getOptionValue", "(", "LIB_OPT", ")", ")", ";", "}", "else", "{", "Collection", "<", "File", ">", "files", "=", "FileUtils", ".", "listFiles", "(", "new", "File", "(", "oozieHome", ")", ",", "new", "WildcardFileFilter", "(", "\"", "oozie-sharelib*.tar.gz", "\"", ")", ",", "null", ")", ";", "if", "(", "files", ".", "size", "(", ")", ">", "1", ")", "{", "throw", "new", "IOException", "(", "\"", "more than one sharelib tar found at ", "\"", "+", "oozieHome", ")", ";", "}", "if", "(", "files", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "default sharelib tar not found in oozie home dir: ", "\"", "+", "oozieHome", ")", ";", "}", "srcFile", "=", "files", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "}", "Map", "<", "String", ",", "String", ">", "extraLibs", "=", "new", "HashMap", "<", ">", "(", ")", ";", "if", "(", "command", ".", "getCommandLine", "(", ")", ".", "hasOption", "(", "EXTRALIBS", ")", ")", "{", "String", "[", "]", "param", "=", "command", ".", "getCommandLine", "(", ")", ".", "getOptionValues", "(", "EXTRALIBS", ")", ";", "extraLibs", "=", "getExtraLibs", "(", "param", ")", ";", "}", "File", "temp", "=", "Files", ".", "createTempDirectory", "(", "\"", "oozie", "\"", ")", ".", "toFile", "(", ")", ";", "temp", ".", "deleteOnExit", "(", ")", ";", "if", "(", "!", "srcFile", ".", "isDirectory", "(", ")", ")", "{", "FileUtil", ".", "unTar", "(", "srcFile", ",", "temp", ")", ";", "srcFile", "=", "new", "File", "(", "temp", ".", "toString", "(", ")", "+", "\"", "/share/lib", "\"", ")", ";", "}", "else", "{", "srcFile", "=", "new", "File", "(", "srcFile", ",", "\"", "lib", "\"", ")", ";", "}", "String", "hdfsUri", "=", "command", ".", "getCommandLine", "(", ")", ".", "getOptionValue", "(", "FS_OPT", ")", ";", "Path", "srcPath", "=", "new", "Path", "(", "srcFile", ".", "toString", "(", ")", ")", ";", "Services", "services", "=", "new", "Services", "(", ")", ";", "services", ".", "getConf", "(", ")", ".", "set", "(", "Services", ".", "CONF_SERVICE_CLASSES", ",", "\"", "org.apache.oozie.service.LiteWorkflowAppService, org.apache.oozie.service.HadoopAccessorService", "\"", ")", ";", "services", ".", "getConf", "(", ")", ".", "set", "(", "Services", ".", "CONF_SERVICE_EXT_CLASSES", ",", "\"", "\"", ")", ";", "services", ".", "init", "(", ")", ";", "WorkflowAppService", "lwas", "=", "services", ".", "get", "(", "WorkflowAppService", ".", "class", ")", ";", "HadoopAccessorService", "has", "=", "services", ".", "get", "(", "HadoopAccessorService", ".", "class", ")", ";", "Path", "dstPath", "=", "lwas", ".", "getSystemLibPath", "(", ")", ";", "URI", "uri", "=", "new", "Path", "(", "hdfsUri", ")", ".", "toUri", "(", ")", ";", "Configuration", "fsConf", "=", "has", ".", "createConfiguration", "(", "uri", ".", "getAuthority", "(", ")", ")", ";", "FileSystem", "fs", "=", "FileSystem", ".", "get", "(", "uri", ",", "fsConf", ")", ";", "if", "(", "!", "fs", ".", "exists", "(", "dstPath", ")", ")", "{", "fs", ".", "mkdirs", "(", "dstPath", ")", ";", "}", "ECPolicyDisabler", ".", "tryDisableECPolicyForPath", "(", "fs", ",", "dstPath", ")", ";", "if", "(", "sharelibAction", ".", "equals", "(", "CREATE_CMD", ")", "||", "sharelibAction", ".", "equals", "(", "UPGRADE_CMD", ")", ")", "{", "dstPath", "=", "new", "Path", "(", "dstPath", ".", "toString", "(", ")", "+", "Path", ".", "SEPARATOR", "+", "SHARE_LIB_PREFIX", "+", "getTimestampDirectory", "(", ")", ")", ";", "}", "System", ".", "out", ".", "println", "(", "\"", "the destination path for sharelib is: ", "\"", "+", "dstPath", ")", ";", "checkIfSourceFilesExist", "(", "srcFile", ")", ";", "copyToSharelib", "(", "threadPoolSize", ",", "srcFile", ",", "srcPath", ",", "dstPath", ",", "fs", ")", ";", "copyExtraLibs", "(", "threadPoolSize", ",", "extraLibs", ",", "dstPath", ",", "fs", ")", ";", "if", "(", "sharelibAction", ".", "equals", "(", "CREATE_CMD", ")", "||", "sharelibAction", ".", "equals", "(", "UPGRADE_CMD", ")", ")", "{", "applySharelibPermission", "(", "fs", ",", "dstPath", ")", ";", "}", "services", ".", "destroy", "(", ")", ";", "FileUtils", ".", "deleteDirectory", "(", "temp", ")", ";", "return", "0", ";", "}", "catch", "(", "ParseException", "ex", ")", "{", "System", ".", "err", ".", "println", "(", "\"", "Invalid sub-command: ", "\"", "+", "ex", ".", "getMessage", "(", ")", ")", ";", "System", ".", "err", ".", "println", "(", ")", ";", "System", ".", "err", ".", "println", "(", "parser", ".", "shortHelp", "(", ")", ")", ";", "return", "1", ";", "}", "catch", "(", "NumberFormatException", "ex", ")", "{", "logError", "(", "\"", "Invalid configuration value: ", "\"", ",", "ex", ")", ";", "return", "1", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "logError", "(", "ex", ".", "getMessage", "(", ")", ",", "ex", ")", ";", "return", "1", ";", "}", "}"], "idx": 49428, "cwe": "CWE-362", "target": 0, "status": "FIXED", "commit": "f1e01a9e155692aa5632f4573ab1b3ebeab7ef45", "function_name": "run", "body_hash": "acefe59f2340dca97af5b1649072f7a9b112074f"}
{"code": "@Override\n  public void handle(RoutingContext ctx) {\n\n    if (nagHttps) {\n      String uri = ctx.request().absoluteURI();\n      if (uri != null && !uri.startsWith(\"https:\")) {\n        log.trace(\"Using session cookies without https could make you susceptible to session hijacking: \" + uri);\n      }\n    }\n\n    HttpMethod method = ctx.request().method();\n    Session session = ctx.session();\n\n    // if we're being strict with the origin\n    // ensure that they are always valid\n    if (!isValidOrigin(ctx)) {\n      ctx.fail(403);\n      return;\n    }\n\n    switch (method.name()) {\n      case \"GET\":\n        final String token;\n\n        if (session == null) {\n          // if there's no session to store values, tokens are issued on every request\n          token = generateAndStoreToken(ctx);\n        } else {\n          // get the token from the session, this also considers the fact\n          // that the token might be invalid as it was issued for a previous session id\n          // session id's change on session upgrades (unauthenticated -> authenticated; role change; etc...)\n          String sessionToken = getTokenFromSession(ctx);\n          // when there's no token in the session, then we behave just like when there is no session\n          // create a new token, but we also store it in the session for the next runs\n          if (sessionToken == null) {\n            token = generateAndStoreToken(ctx);\n            // storing will include the session id too. The reason is that if a session is upgraded\n            // we don't want to allow the token to be valid anymore\n            session.put(headerName, session.id() + \"/\" + token);\n          } else {\n            String[] parts = sessionToken.split(\"\\\\.\");\n            final long ts = parseLong(parts[1]);\n\n            if (ts == -1) {\n              // fallback as the token is expired\n              token = generateAndStoreToken(ctx);\n            } else {\n              if (!(System.currentTimeMillis() > ts + timeout)) {\n                // we're still on the same session, no need to regenerate the token\n                // also note that the token isn't expired, so it can be reused\n                token = sessionToken;\n                // in this case specifically we don't issue the token as it is unchanged\n                // the user agent still has it from the previous interaction.\n              } else {\n                // fallback as the token is expired\n                token = generateAndStoreToken(ctx);\n              }\n            }\n          }\n        }\n        // put the token in the context for users who prefer to render the token directly on the HTML\n        ctx.put(headerName, token);\n        ctx.next();\n        break;\n      case \"POST\":\n      case \"PUT\":\n      case \"DELETE\":\n      case \"PATCH\":\n        if (isValidRequest(ctx)) {\n          // it matches, so refresh the token to avoid replay attacks\n          token = generateAndStoreToken(ctx);\n          // put the token in the context for users who prefer to\n          // render the token directly on the HTML\n          ctx.put(headerName, token);\n          ctx.next();\n        } else {\n          ctx.fail(403);\n        }\n        break;\n      default:\n        // ignore other methods\n        ctx.next();\n        break;\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "RoutingContext", "ctx", ")", "{", "if", "(", "nagHttps", ")", "{", "String", "uri", "=", "ctx", ".", "request", "(", ")", ".", "absoluteURI", "(", ")", ";", "if", "(", "uri", "!=", "null", "&&", "!", "uri", ".", "startsWith", "(", "\"", "https:", "\"", ")", ")", "{", "log", ".", "trace", "(", "\"", "Using session cookies without https could make you susceptible to session hijacking: ", "\"", "+", "uri", ")", ";", "}", "}", "HttpMethod", "method", "=", "ctx", ".", "request", "(", ")", ".", "method", "(", ")", ";", "Session", "session", "=", "ctx", ".", "session", "(", ")", ";", "if", "(", "!", "isValidOrigin", "(", "ctx", ")", ")", "{", "ctx", ".", "fail", "(", "403", ")", ";", "return", ";", "}", "switch", "(", "method", ".", "name", "(", ")", ")", "{", "case", "\"", "GET", "\"", ":", "final", "String", "token", ";", "if", "(", "session", "==", "null", ")", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "}", "else", "{", "String", "sessionToken", "=", "getTokenFromSession", "(", "ctx", ")", ";", "if", "(", "sessionToken", "==", "null", ")", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "session", ".", "put", "(", "headerName", ",", "session", ".", "id", "(", ")", "+", "\"", "/", "\"", "+", "token", ")", ";", "}", "else", "{", "String", "[", "]", "parts", "=", "sessionToken", ".", "split", "(", "\"", "\\\\", ".", "\"", ")", ";", "final", "long", "ts", "=", "parseLong", "(", "parts", "[", "1", "]", ")", ";", "if", "(", "ts", "==", "-", "1", ")", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "}", "else", "{", "if", "(", "!", "(", "System", ".", "currentTimeMillis", "(", ")", ">", "ts", "+", "timeout", ")", ")", "{", "token", "=", "sessionToken", ";", "}", "else", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "}", "}", "}", "}", "ctx", ".", "put", "(", "headerName", ",", "token", ")", ";", "ctx", ".", "next", "(", ")", ";", "break", ";", "case", "\"", "POST", "\"", ":", "case", "\"", "PUT", "\"", ":", "case", "\"", "DELETE", "\"", ":", "case", "\"", "PATCH", "\"", ":", "if", "(", "isValidRequest", "(", "ctx", ")", ")", "{", "token", "=", "generateAndStoreToken", "(", "ctx", ")", ";", "ctx", ".", "put", "(", "headerName", ",", "token", ")", ";", "ctx", ".", "next", "(", ")", ";", "}", "else", "{", "ctx", ".", "fail", "(", "403", ")", ";", "}", "break", ";", "default", ":", "ctx", ".", "next", "(", ")", ";", "break", ";", "}", "}"], "idx": 48012, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "41a5534ff95c8bac1c6a0e715d7f0d1ad3c10bc4", "function_name": "handle", "body_hash": "9c9d4c578873767998130507a91b40d3a54378af"}
{"code": "private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \"foo\"\n        // or internal quotes that might need to be escaped : f\"o -> f\\\"o.\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\"' as closing regardless.\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding.  Disallow </script and ]]> in string literals so that\n        // the output can be embedded in HTML script elements and in XML CDATA\n        // sections.\n        case '/':\n          // Don't over escape.  Many JSON bodies contain innocuous HTML\n          // that can be safely embedded.\n          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)\n              && 's' == (jsonish.charAt(i + 1) | 32)\n              && 'c' == (jsonish.charAt(i + 2) | 32)) {\n            insert(i, '\\\\');\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \"u00\");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \"\\-\" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\"'); }\n  }", "code_tokens": ["private", "void", "sanitizeString", "(", "int", "start", ",", "int", "end", ")", "{", "boolean", "closed", "=", "false", ";", "for", "(", "int", "i", "=", "start", ";", "i", "<", "end", ";", "++", "i", ")", "{", "char", "ch", "=", "jsonish", ".", "charAt", "(", "i", ")", ";", "switch", "(", "ch", ")", "{", "case", "'\\n'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "n", "\"", ")", ";", "break", ";", "case", "'\\r'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "r", "\"", ")", ";", "break", ";", "case", "'\\u2028'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2028", "\"", ")", ";", "break", ";", "case", "'\\u2029'", ":", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u2029", "\"", ")", ";", "break", ";", "case", "'\"'", ":", "case", "'\\''", ":", "if", "(", "i", "==", "start", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "{", "if", "(", "i", "+", "1", "==", "end", ")", "{", "char", "startDelim", "=", "jsonish", ".", "charAt", "(", "start", ")", ";", "if", "(", "startDelim", "!=", "'\\''", ")", "{", "startDelim", "=", "'\"'", ";", "}", "closed", "=", "startDelim", "==", "ch", ";", "}", "if", "(", "closed", ")", "{", "if", "(", "ch", "==", "'\\''", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "'\"'", ")", ";", "}", "}", "else", "if", "(", "ch", "==", "'\"'", ")", "{", "insert", "(", "i", ",", "'\\\\'", ")", ";", "}", "}", "break", ";", "case", "'/'", ":", "if", "(", "i", ">", "start", "&&", "i", "+", "2", "<", "end", "&&", "'<'", "==", "jsonish", ".", "charAt", "(", "i", "-", "1", ")", "&&", "'s'", "==", "(", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", "|", "32", ")", "&&", "'c'", "==", "(", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", "|", "32", ")", ")", "{", "insert", "(", "i", ",", "'\\\\'", ")", ";", "}", "break", ";", "case", "']'", ":", "if", "(", "i", "+", "2", "<", "end", "&&", "']'", "==", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", "&&", "'>'", "==", "jsonish", ".", "charAt", "(", "i", "+", "2", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u005d", "\"", ")", ";", "}", "break", ";", "case", "'\\\\'", ":", "if", "(", "i", "+", "1", "==", "end", ")", "{", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "char", "sch", "=", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ";", "switch", "(", "sch", ")", "{", "case", "'b'", ":", "case", "'f'", ":", "case", "'n'", ":", "case", "'r'", ":", "case", "'t'", ":", "case", "'\\\\'", ":", "case", "'/'", ":", "case", "'\"'", ":", "++", "i", ";", "break", ";", "case", "'v'", ":", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u0008", "\"", ")", ";", "++", "i", ";", "break", ";", "case", "'x'", ":", "if", "(", "i", "+", "4", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", ")", "{", "replace", "(", "i", ",", "i", "+", "2", ",", "\"", "\\\\", "u00", "\"", ")", ";", "i", "+=", "3", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'u'", ":", "if", "(", "i", "+", "6", "<", "end", "&&", "isHexAt", "(", "i", "+", "2", ")", "&&", "isHexAt", "(", "i", "+", "3", ")", "&&", "isHexAt", "(", "i", "+", "4", ")", "&&", "isHexAt", "(", "i", "+", "5", ")", ")", "{", "i", "+=", "5", ";", "break", ";", "}", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "case", "'0'", ":", "case", "'1'", ":", "case", "'2'", ":", "case", "'3'", ":", "case", "'4'", ":", "case", "'5'", ":", "case", "'6'", ":", "case", "'7'", ":", "int", "octalEnd", "=", "i", "+", "1", ";", "if", "(", "octalEnd", "+", "1", "<", "end", "&&", "isOctAt", "(", "octalEnd", "+", "1", ")", ")", "{", "++", "octalEnd", ";", "if", "(", "ch", "<=", "'3'", "&&", "octalEnd", "+", "1", "<", "end", "&&", "isOctAt", "(", "octalEnd", "+", "1", ")", ")", "{", "++", "octalEnd", ";", "}", "int", "value", "=", "0", ";", "for", "(", "int", "j", "=", "i", ";", "j", "<", "octalEnd", ";", "++", "j", ")", "{", "value", "=", "(", "value", "<<", "3", ")", "|", "(", "jsonish", ".", "charAt", "(", "j", ")", "-", "'0'", ")", ";", "}", "replace", "(", "i", "+", "1", ",", "octalEnd", ",", "\"", "u00", "\"", ")", ";", "appendHex", "(", "value", ",", "2", ")", ";", "}", "i", "=", "octalEnd", "-", "1", ";", "break", ";", "default", ":", "elide", "(", "i", ",", "i", "+", "1", ")", ";", "break", ";", "}", "break", ";", "default", ":", "if", "(", "ch", "<", "0x20", ")", "{", "if", "(", "ch", "==", "9", "||", "ch", "==", "0xa", "||", "ch", "==", "0xd", ")", "{", "continue", ";", "}", "}", "else", "if", "(", "ch", "<", "0xd800", ")", "{", "continue", ";", "}", "else", "if", "(", "ch", "<", "0xe000", ")", "{", "if", "(", "Character", ".", "isHighSurrogate", "(", "ch", ")", "&&", "i", "+", "1", "<", "end", "&&", "Character", ".", "isLowSurrogate", "(", "jsonish", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "continue", ";", "}", "}", "else", "if", "(", "ch", "<=", "0xfffd", ")", "{", "continue", ";", "}", "replace", "(", "i", ",", "i", "+", "1", ",", "\"", "\\\\", "u", "\"", ")", ";", "for", "(", "int", "j", "=", "4", ";", "--", "j", ">=", "0", ";", ")", "{", "sanitizedJson", ".", "append", "(", "HEX_DIGITS", "[", "(", "ch", ">>>", "(", "j", "<<", "2", ")", ")", "&", "0xf", "]", ")", ";", "}", "break", ";", "}", "}", "if", "(", "!", "closed", ")", "{", "insert", "(", "end", ",", "'\"'", ")", ";", "}", "}"], "idx": 81270, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "f3512ba", "function_name": "sanitizeString", "body_hash": "79884973e55caecdabdb5a6f295c308c7c976bbb"}
{"code": "private int readEncryptedData(final ByteBuffer dst, final int pending) throws SSLException {\n        try {\n            int bytesRead = 0;\n            final int pos = dst.position();\n            if (dst.remaining() >= pending) {\n                final int limit = dst.limit();\n                final int len = min(pending, limit - pos);\n                if (dst.isDirect()) {\n                    bytesRead = readEncryptedDataDirect(dst, pos, len);\n                    // Need to update the position on the dst buffer.\n                    if (bytesRead > 0) {\n                        dst.position(pos + bytesRead);\n                    }\n                } else {\n                    // The heap method will update the position on the dst buffer automatically.\n                    bytesRead = readEncryptedDataHeap(dst, pos, len);\n                }\n            }\n\n            return bytesRead;\n        } catch (Exception e) {\n            throw convertException(e);\n        }\n    }", "code_tokens": ["private", "int", "readEncryptedData", "(", "final", "ByteBuffer", "dst", ",", "final", "int", "pending", ")", "throws", "SSLException", "{", "try", "{", "int", "bytesRead", "=", "0", ";", "final", "int", "pos", "=", "dst", ".", "position", "(", ")", ";", "if", "(", "dst", ".", "remaining", "(", ")", ">=", "pending", ")", "{", "final", "int", "limit", "=", "dst", ".", "limit", "(", ")", ";", "final", "int", "len", "=", "min", "(", "pending", ",", "limit", "-", "pos", ")", ";", "if", "(", "dst", ".", "isDirect", "(", ")", ")", "{", "bytesRead", "=", "readEncryptedDataDirect", "(", "dst", ",", "pos", ",", "len", ")", ";", "if", "(", "bytesRead", ">", "0", ")", "{", "dst", ".", "position", "(", "pos", "+", "bytesRead", ")", ";", "}", "}", "else", "{", "bytesRead", "=", "readEncryptedDataHeap", "(", "dst", ",", "pos", ",", "len", ")", ";", "}", "}", "return", "bytesRead", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "convertException", "(", "e", ")", ";", "}", "}"], "idx": 97862, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "e56958e7dea05c1784317f139e2216e2e707d391", "function_name": "readEncryptedData", "body_hash": "de4244cd516d9ea0432e7bdeb5cb9a7cd5e6c5b5"}
{"code": "@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN\n            + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')\")\n    public void migrateCube(CubeInstance cube, String projectName) {\n        KylinConfig config = KylinConfig.getInstanceFromEnv();\n        if (!config.isAllowAutoMigrateCube()) {\n            throw new InternalErrorException(\"One click migration is disabled, please contact your ADMIN\");\n        }\n\n        for (CubeSegment segment : cube.getSegments()) {\n            if (segment.getStatus() != SegmentStatusEnum.READY) {\n                throw new InternalErrorException(\n                        \"At least one segment is not in READY state. Please check whether there are Running or Error jobs.\");\n            }\n        }\n\n        String srcCfgUri = config.getAutoMigrateCubeSrcConfig();\n        String dstCfgUri = config.getAutoMigrateCubeDestConfig();\n\n        Preconditions.checkArgument(StringUtils.isNotEmpty(srcCfgUri), \"Source configuration should not be empty.\");\n        Preconditions.checkArgument(StringUtils.isNotEmpty(dstCfgUri),\n                \"Destination configuration should not be empty.\");\n\n        String stringBuilder = (\"%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true\");\n        String cmd = String.format(Locale.ROOT, stringBuilder, KylinConfig.getKylinHome(), srcCfgUri, dstCfgUri,\n                cube.getName(), projectName, config.isAutoMigrateCubeCopyAcl(), config.isAutoMigrateCubePurge());\n\n        logger.info(\"One click migration cmd: \" + cmd);\n\n        CliCommandExecutor exec = new CliCommandExecutor();\n        PatternedLogger patternedLogger = new PatternedLogger(logger);\n\n        try {\n            exec.execute(cmd, patternedLogger);\n        } catch (IOException e) {\n            throw new InternalErrorException(\"Failed to perform one-click migrating\", e);\n        }\n    }", "code_tokens": ["@", "PreAuthorize", "(", "Constant", ".", "ACCESS_HAS_ROLE_ADMIN", "+", "\"", " or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')", "\"", ")", "public", "void", "migrateCube", "(", "CubeInstance", "cube", ",", "String", "projectName", ")", "{", "KylinConfig", "config", "=", "KylinConfig", ".", "getInstanceFromEnv", "(", ")", ";", "if", "(", "!", "config", ".", "isAllowAutoMigrateCube", "(", ")", ")", "{", "throw", "new", "InternalErrorException", "(", "\"", "One click migration is disabled, please contact your ADMIN", "\"", ")", ";", "}", "for", "(", "CubeSegment", "segment", ":", "cube", ".", "getSegments", "(", ")", ")", "{", "if", "(", "segment", ".", "getStatus", "(", ")", "!=", "SegmentStatusEnum", ".", "READY", ")", "{", "throw", "new", "InternalErrorException", "(", "\"", "At least one segment is not in READY state. Please check whether there are Running or Error jobs.", "\"", ")", ";", "}", "}", "String", "srcCfgUri", "=", "config", ".", "getAutoMigrateCubeSrcConfig", "(", ")", ";", "String", "dstCfgUri", "=", "config", ".", "getAutoMigrateCubeDestConfig", "(", ")", ";", "Preconditions", ".", "checkArgument", "(", "StringUtils", ".", "isNotEmpty", "(", "srcCfgUri", ")", ",", "\"", "Source configuration should not be empty.", "\"", ")", ";", "Preconditions", ".", "checkArgument", "(", "StringUtils", ".", "isNotEmpty", "(", "dstCfgUri", ")", ",", "\"", "Destination configuration should not be empty.", "\"", ")", ";", "String", "stringBuilder", "=", "(", "\"", "%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true", "\"", ")", ";", "String", "cmd", "=", "String", ".", "format", "(", "Locale", ".", "ROOT", ",", "stringBuilder", ",", "KylinConfig", ".", "getKylinHome", "(", ")", ",", "srcCfgUri", ",", "dstCfgUri", ",", "cube", ".", "getName", "(", ")", ",", "projectName", ",", "config", ".", "isAutoMigrateCubeCopyAcl", "(", ")", ",", "config", ".", "isAutoMigrateCubePurge", "(", ")", ")", ";", "logger", ".", "info", "(", "\"", "One click migration cmd: ", "\"", "+", "cmd", ")", ";", "CliCommandExecutor", "exec", "=", "new", "CliCommandExecutor", "(", ")", ";", "PatternedLogger", "patternedLogger", "=", "new", "PatternedLogger", "(", "logger", ")", ";", "try", "{", "exec", ".", "execute", "(", "cmd", ",", "patternedLogger", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "InternalErrorException", "(", "\"", "Failed to perform one-click migrating", "\"", ",", "e", ")", ";", "}", "}"], "idx": 76733, "cwe": "CWE-78", "target": 1, "status": "VULNERABLE", "commit": "0888c867a52479840a6f3fcd812f9305a95b8dfd", "function_name": "migrateCube", "body_hash": "b9d99abee7b553cce3e42ba9762b77d62a65bb74"}
{"code": "@Override\n        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.process\",\n                        wrapper.getSocket(), status));\n            }\n            if (wrapper == null) {\n                // Nothing to do. Socket has been closed.\n                return SocketState.CLOSED;\n            }\n\n            S socket = wrapper.getSocket();\n\n            Processor processor = connections.get(socket);\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.connectionsGet\",\n                        processor, socket));\n            }\n\n            // Timeouts are calculated on a dedicated thread and then\n            // dispatched. Because of delays in the dispatch process, the\n            // timeout may no longer be required. Check here and avoid\n            // unnecessary processing.\n            if (SocketEvent.TIMEOUT == status &&\n                    (processor == null ||\n                    !processor.isAsync() && !processor.isUpgrade() ||\n                    processor.isAsync() && !processor.checkAsyncTimeoutGeneration())) {\n                // This is effectively a NO-OP\n                return SocketState.OPEN;\n            }\n\n            if (processor != null) {\n                // Make sure an async timeout doesn't fire\n                getProtocol().removeWaitingProcessor(processor);\n            } else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) {\n                // Nothing to do. Endpoint requested a close and there is no\n                // longer a processor associated with this socket.\n                return SocketState.CLOSED;\n            }\n\n            ContainerThreadMarker.set();\n\n            try {\n                if (processor == null) {\n                    String negotiatedProtocol = wrapper.getNegotiatedProtocol();\n                    // OpenSSL typically returns null whereas JSSE typically\n                    // returns \"\" when no protocol is negotiated\n                    if (negotiatedProtocol != null && negotiatedProtocol.length() > 0) {\n                        UpgradeProtocol upgradeProtocol = getProtocol().getNegotiatedProtocol(negotiatedProtocol);\n                        if (upgradeProtocol != null) {\n                            processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                            }\n                        } else if (negotiatedProtocol.equals(\"http/1.1\")) {\n                            // Explicitly negotiated the default protocol.\n                            // Obtain a processor below.\n                        } else {\n                            // TODO:\n                            // OpenSSL 1.0.2's ALPN callback doesn't support\n                            // failing the handshake with an error if no\n                            // protocol can be negotiated. Therefore, we need to\n                            // fail the connection here. Once this is fixed,\n                            // replace the code below with the commented out\n                            // block.\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        negotiatedProtocol));\n                            }\n                            return SocketState.CLOSED;\n                            /*\n                             * To replace the code above once OpenSSL 1.1.0 is\n                             * used.\n                            // Failed to create processor. This is a bug.\n                            throw new IllegalStateException(sm.getString(\n                                    \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                    negotiatedProtocol));\n                            */\n                        }\n                    }\n                }\n                if (processor == null) {\n                    processor = recycledProcessors.pop();\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorPop\", processor));\n                    }\n                }\n                if (processor == null) {\n                    processor = getProtocol().createProcessor();\n                    register(processor);\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                    }\n                }\n\n                processor.setSslSupport(\n                        wrapper.getSslSupport(getProtocol().getClientCertProvider()));\n\n                // Associate the processor with the connection\n                connections.put(socket, processor);\n\n                SocketState state = SocketState.CLOSED;\n                do {\n                    state = processor.process(wrapper, status);\n\n                    if (state == SocketState.UPGRADING) {\n                        // Get the HTTP upgrade handler\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        // Retrieve leftover input\n                        ByteBuffer leftOverInput = processor.getLeftoverInput();\n                        if (upgradeToken == null) {\n                            // Assume direct HTTP/2 connection\n                            UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(\"h2c\");\n                            if (upgradeProtocol != null) {\n                                processor = upgradeProtocol.getProcessor(\n                                        wrapper, getProtocol().getAdapter());\n                                wrapper.unRead(leftOverInput);\n                                // Associate with the processor with the connection\n                                connections.put(socket, processor);\n                            } else {\n                                if (getLog().isDebugEnabled()) {\n                                    getLog().debug(sm.getString(\n                                        \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        \"h2c\"));\n                                }\n                                return SocketState.CLOSED;\n                            }\n                        } else {\n                            HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                            // Release the Http11 processor to be re-used\n                            release(processor);\n                            // Create the upgrade processor\n                            processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.upgradeCreate\",\n                                        processor, wrapper));\n                            }\n                            wrapper.unRead(leftOverInput);\n                            // Mark the connection as upgraded\n                            wrapper.setUpgraded(true);\n                            // Associate with the processor with the connection\n                            connections.put(socket, processor);\n                            // Initialise the upgrade handler (which may trigger\n                            // some IO using the new protocol which is why the lines\n                            // above are necessary)\n                            // This cast should be safe. If it fails the error\n                            // handling for the surrounding try/catch will deal with\n                            // it.\n                            if (upgradeToken.getInstanceManager() == null) {\n                                httpUpgradeHandler.init((WebConnection) processor);\n                            } else {\n                                ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                                try {\n                                    httpUpgradeHandler.init((WebConnection) processor);\n                                } finally {\n                                    upgradeToken.getContextBind().unbind(false, oldCL);\n                                }\n                            }\n                        }\n                    }\n                } while ( state == SocketState.UPGRADING);\n\n                if (state == SocketState.LONG) {\n                    // In the middle of processing a request/response. Keep the\n                    // socket associated with the processor. Exact requirements\n                    // depend on type of long poll\n                    longPoll(wrapper, processor);\n                    if (processor.isAsync()) {\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.OPEN) {\n                    // In keep-alive but between requests. OK to recycle\n                    // processor. Continue to poll for the next request.\n                    connections.remove(socket);\n                    release(processor);\n                    wrapper.registerReadInterest();\n                } else if (state == SocketState.SENDFILE) {\n                    // Sendfile in progress. If it fails, the socket will be\n                    // closed. If it works, the socket either be added to the\n                    // poller (or equivalent) to await more data or processed\n                    // if there are any pipe-lined requests remaining.\n                } else if (state == SocketState.UPGRADED) {\n                    // Don't add sockets back to the poller if this was a\n                    // non-blocking write otherwise the poller may trigger\n                    // multiple read events which may lead to thread starvation\n                    // in the connector. The write() method will add this socket\n                    // to the poller if necessary.\n                    if (status != SocketEvent.OPEN_WRITE) {\n                        longPoll(wrapper, processor);\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.SUSPENDED) {\n                    // Don't add sockets back to the poller.\n                    // The resumeProcessing() method will add this socket\n                    // to the poller.\n                } else {\n                    // Connection closed. OK to recycle the processor.\n                    // Processors handling upgrades require additional clean-up\n                    // before release.\n                    connections.remove(socket);\n                    if (processor.isUpgrade()) {\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                        InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                        if (instanceManager == null) {\n                            httpUpgradeHandler.destroy();\n                        } else {\n                            ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                            try {\n                                httpUpgradeHandler.destroy();\n                            } finally {\n                                try {\n                                    instanceManager.destroyInstance(httpUpgradeHandler);\n                                } catch (Throwable e) {\n                                    ExceptionUtils.handleThrowable(e);\n                                    getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n                                }\n                                upgradeToken.getContextBind().unbind(false, oldCL);\n                            }\n                        }\n                    }\n                    release(processor);\n                }\n                return state;\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.ioexception.debug\"), e);\n            } catch (ProtocolException e) {\n                // Protocol exceptions normally mean the client sent invalid or\n                // incomplete data.\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.protocolexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (OutOfMemoryError oome) {\n                // Try and handle this here to give Tomcat a chance to close the\n                // connection and prevent clients waiting until they time out.\n                // Worst case, it isn't recoverable and the attempt at logging\n                // will trigger another OOME.\n                getLog().error(sm.getString(\"abstractConnectionHandler.oome\"), oome);\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n            } finally {\n                ContainerThreadMarker.clear();\n            }\n\n            // Make sure socket/processor is removed from the list of current\n            // connections\n            connections.remove(socket);\n            release(processor);\n            return SocketState.CLOSED;\n        }", "code_tokens": ["@", "Override", "public", "SocketState", "process", "(", "SocketWrapperBase", "<", "S", ">", "wrapper", ",", "SocketEvent", "status", ")", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.process", "\"", ",", "wrapper", ".", "getSocket", "(", ")", ",", "status", ")", ")", ";", "}", "if", "(", "wrapper", "==", "null", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "S", "socket", "=", "wrapper", ".", "getSocket", "(", ")", ";", "Processor", "processor", "=", "connections", ".", "get", "(", "socket", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.connectionsGet", "\"", ",", "processor", ",", "socket", ")", ")", ";", "}", "if", "(", "SocketEvent", ".", "TIMEOUT", "==", "status", "&&", "(", "processor", "==", "null", "||", "!", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "isUpgrade", "(", ")", "||", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "checkAsyncTimeoutGeneration", "(", ")", ")", ")", "{", "return", "SocketState", ".", "OPEN", ";", "}", "if", "(", "processor", "!=", "null", ")", "{", "getProtocol", "(", ")", ".", "removeWaitingProcessor", "(", "processor", ")", ";", "}", "else", "if", "(", "status", "==", "SocketEvent", ".", "DISCONNECT", "||", "status", "==", "SocketEvent", ".", "ERROR", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "ContainerThreadMarker", ".", "set", "(", ")", ";", "try", "{", "if", "(", "processor", "==", "null", ")", "{", "String", "negotiatedProtocol", "=", "wrapper", ".", "getNegotiatedProtocol", "(", ")", ";", "if", "(", "negotiatedProtocol", "!=", "null", "&&", "negotiatedProtocol", ".", "length", "(", ")", ">", "0", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getNegotiatedProtocol", "(", "negotiatedProtocol", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "else", "if", "(", "negotiatedProtocol", ".", "equals", "(", "\"", "http/1.1", "\"", ")", ")", "{", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "negotiatedProtocol", ")", ")", ";", "}", "return", "SocketState", ".", "CLOSED", ";", "}", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "recycledProcessors", ".", "pop", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorPop", "\"", ",", "processor", ")", ")", ";", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "getProtocol", "(", ")", ".", "createProcessor", "(", ")", ";", "register", "(", "processor", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "processor", ".", "setSslSupport", "(", "wrapper", ".", "getSslSupport", "(", "getProtocol", "(", ")", ".", "getClientCertProvider", "(", ")", ")", ")", ";", "connections", ".", "put", "(", "socket", ",", "processor", ")", ";", "SocketState", "state", "=", "SocketState", ".", "CLOSED", ";", "do", "{", "state", "=", "processor", ".", "process", "(", "wrapper", ",", "status", ")", ";", "if", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "ByteBuffer", "leftOverInput", "=", "processor", ".", "getLeftoverInput", "(", ")", ";", "if", "(", "upgradeToken", "==", "null", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getUpgradeProtocol", "(", "\"", "h2c", "\"", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "connections", ".", "put", "(", "socket", ",", "processor", ")", ";", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "\"", "h2c", "\"", ")", ")", ";", "}", "return", "SocketState", ".", "CLOSED", ";", "}", "}", "else", "{", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "release", "(", "processor", ")", ";", "processor", "=", "getProtocol", "(", ")", ".", "createUpgradeProcessor", "(", "wrapper", ",", "upgradeToken", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.upgradeCreate", "\"", ",", "processor", ",", "wrapper", ")", ")", ";", "}", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "wrapper", ".", "setUpgraded", "(", "true", ")", ";", "connections", ".", "put", "(", "socket", ",", "processor", ")", ";", "if", "(", "upgradeToken", ".", "getInstanceManager", "(", ")", "==", "null", ")", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "finally", "{", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "}", "}", "}", "while", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", ";", "if", "(", "state", "==", "SocketState", ".", "LONG", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "if", "(", "processor", ".", "isAsync", "(", ")", ")", "{", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "OPEN", ")", "{", "connections", ".", "remove", "(", "socket", ")", ";", "release", "(", "processor", ")", ";", "wrapper", ".", "registerReadInterest", "(", ")", ";", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SENDFILE", ")", "{", "}", "else", "if", "(", "state", "==", "SocketState", ".", "UPGRADED", ")", "{", "if", "(", "status", "!=", "SocketEvent", ".", "OPEN_WRITE", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SUSPENDED", ")", "{", "}", "else", "{", "connections", ".", "remove", "(", "socket", ")", ";", "if", "(", "processor", ".", "isUpgrade", "(", ")", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "InstanceManager", "instanceManager", "=", "upgradeToken", ".", "getInstanceManager", "(", ")", ";", "if", "(", "instanceManager", "==", "null", ")", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "finally", "{", "try", "{", "instanceManager", ".", "destroyInstance", "(", "httpUpgradeHandler", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "}", "release", "(", "processor", ")", ";", "}", "return", "state", ";", "}", "catch", "(", "java", ".", "net", ".", "SocketException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.socketexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "java", ".", "io", ".", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.ioexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "ProtocolException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.protocolexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "OutOfMemoryError", "oome", ")", "{", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.oome", "\"", ")", ",", "oome", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "finally", "{", "ContainerThreadMarker", ".", "clear", "(", ")", ";", "}", "connections", ".", "remove", "(", "socket", ")", ";", "release", "(", "processor", ")", ";", "return", "SocketState", ".", "CLOSED", ";", "}"], "idx": 56902, "cwe": "CWE-476", "target": 1, "status": "VULNERABLE", "commit": "923d834500802a61779318911d7898bd85fc950e", "function_name": "process", "body_hash": "7bfacba40c56f258483b0fbe6c398d4e9b8e9f48"}
{"code": "@Deprecated\n    public static String substituteEnv(String s) {\n        return SUBSTITUTE_ENV ? replaceMacro(s, System.getenv()) : s;\n    }", "code_tokens": ["@", "Deprecated", "public", "static", "String", "substituteEnv", "(", "String", "s", ")", "{", "return", "SUBSTITUTE_ENV", "?", "replaceMacro", "(", "s", ",", "System", ".", "getenv", "(", ")", ")", ":", "s", ";", "}"], "idx": 19191, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "8dadc2168b108eb45c68037fa941d2594da46d79", "function_name": "substituteEnv", "body_hash": "89cb707a230c16962ddf57cb6b4576a6def0e6ea"}
{"code": "@Override\n    protected void handleMessage(Http1xServerConnection conn, ContextImpl context, ChannelHandlerContext chctx, Object msg) throws Exception {\n      Channel ch = chctx.channel();\n      if (msg instanceof HttpRequest) {\n        final HttpRequest request = (HttpRequest) msg;\n\n        if (log.isTraceEnabled()) log.trace(\"Server received request: \" + request.getUri());\n\n        if (request.headers().contains(io.vertx.core.http.HttpHeaders.UPGRADE, io.vertx.core.http.HttpHeaders.WEBSOCKET, true)) {\n\n          // As a fun part, Firefox 6.0.2 supports Websockets protocol '7'. But,\n          // it doesn't send a normal 'Connection: Upgrade' header. Instead it\n          // sends: 'Connection: keep-alive, Upgrade'. Brilliant.\n          String connectionHeader = request.headers().get(io.vertx.core.http.HttpHeaders.CONNECTION);\n          if (connectionHeader == null || !connectionHeader.toLowerCase().contains(\"upgrade\")) {\n            handshakeErrorStatus = BAD_REQUEST;\n            handshakeErrorMsg = \"\\\"Connection\\\" must be \\\"Upgrade\\\".\";\n            return;\n          }\n\n          if (request.getMethod() != HttpMethod.GET) {\n            handshakeErrorStatus = METHOD_NOT_ALLOWED;\n            sendError(null, METHOD_NOT_ALLOWED, ch);\n            return;\n          }\n\n          if (wsRequest == null) {\n            if (request instanceof FullHttpRequest) {\n              handshake(conn, (FullHttpRequest) request, ch, chctx);\n            } else {\n              wsRequest = new DefaultFullHttpRequest(request.getProtocolVersion(), request.getMethod(), request.getUri());\n              wsRequest.headers().set(request.headers());\n            }\n          }\n        } else {\n          //HTTP request\n          conn.handleMessage(msg);\n        }\n      } else if (msg instanceof WebSocketFrameInternal) {\n        //Websocket frame\n        WebSocketFrameInternal wsFrame = (WebSocketFrameInternal) msg;\n        switch (wsFrame.type()) {\n          case BINARY:\n          case CONTINUATION:\n          case TEXT:\n          case PONG:\n            conn.handleMessage(msg);\n            break;\n          case PING:\n            // Echo back the content of the PING frame as PONG frame as specified in RFC 6455 Section 5.5.2\n            conn.channel().writeAndFlush(new PongWebSocketFrame(wsFrame.getBinaryData().copy()));\n            break;\n          case CLOSE:\n            if (!closeFrameSent) {\n              // Echo back close frame and close the connection once it was written.\n              // This is specified in the WebSockets RFC 6455 Section  5.4.1\n              CloseWebSocketFrame closeFrame = new CloseWebSocketFrame(wsFrame.closeStatusCode(), wsFrame.closeReason());\n              ch.writeAndFlush(closeFrame).addListener(ChannelFutureListener.CLOSE);\n              closeFrameSent = true;\n            }\n            conn.handleMessage(msg);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid type: \" + wsFrame.type());\n        }\n      } else if (msg instanceof HttpContent) {\n        if (wsRequest != null) {\n          wsRequest.content().writeBytes(((HttpContent) msg).content());\n          if (msg instanceof LastHttpContent) {\n            FullHttpRequest req = wsRequest;\n            wsRequest = null;\n            handshake(conn, req, ch, chctx);\n            return;\n          }\n        } else if (handshakeErrorStatus != null) {\n          if (msg instanceof LastHttpContent) {\n            sendError(handshakeErrorMsg, handshakeErrorStatus, ch);\n            handshakeErrorMsg = null;\n            handshakeErrorMsg = null;\n          }\n          return;\n        }\n        conn.handleMessage(msg);\n      } else {\n        throw new IllegalStateException(\"Invalid message \" + msg);\n      }\n    }", "code_tokens": ["@", "Override", "protected", "void", "handleMessage", "(", "Http1xServerConnection", "conn", ",", "ContextImpl", "context", ",", "ChannelHandlerContext", "chctx", ",", "Object", "msg", ")", "throws", "Exception", "{", "Channel", "ch", "=", "chctx", ".", "channel", "(", ")", ";", "if", "(", "msg", "instanceof", "HttpRequest", ")", "{", "final", "HttpRequest", "request", "=", "(", "HttpRequest", ")", "msg", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "log", ".", "trace", "(", "\"", "Server received request: ", "\"", "+", "request", ".", "getUri", "(", ")", ")", ";", "if", "(", "request", ".", "headers", "(", ")", ".", "contains", "(", "io", ".", "vertx", ".", "core", ".", "http", ".", "HttpHeaders", ".", "UPGRADE", ",", "io", ".", "vertx", ".", "core", ".", "http", ".", "HttpHeaders", ".", "WEBSOCKET", ",", "true", ")", ")", "{", "String", "connectionHeader", "=", "request", ".", "headers", "(", ")", ".", "get", "(", "io", ".", "vertx", ".", "core", ".", "http", ".", "HttpHeaders", ".", "CONNECTION", ")", ";", "if", "(", "connectionHeader", "==", "null", "||", "!", "connectionHeader", ".", "toLowerCase", "(", ")", ".", "contains", "(", "\"", "upgrade", "\"", ")", ")", "{", "handshakeErrorStatus", "=", "BAD_REQUEST", ";", "handshakeErrorMsg", "=", "\"", "\\\"", "Connection", "\\\"", " must be ", "\\\"", "Upgrade", "\\\"", ".", "\"", ";", "return", ";", "}", "if", "(", "request", ".", "getMethod", "(", ")", "!=", "HttpMethod", ".", "GET", ")", "{", "handshakeErrorStatus", "=", "METHOD_NOT_ALLOWED", ";", "sendError", "(", "null", ",", "METHOD_NOT_ALLOWED", ",", "ch", ")", ";", "return", ";", "}", "if", "(", "wsRequest", "==", "null", ")", "{", "if", "(", "request", "instanceof", "FullHttpRequest", ")", "{", "handshake", "(", "conn", ",", "(", "FullHttpRequest", ")", "request", ",", "ch", ",", "chctx", ")", ";", "}", "else", "{", "wsRequest", "=", "new", "DefaultFullHttpRequest", "(", "request", ".", "getProtocolVersion", "(", ")", ",", "request", ".", "getMethod", "(", ")", ",", "request", ".", "getUri", "(", ")", ")", ";", "wsRequest", ".", "headers", "(", ")", ".", "set", "(", "request", ".", "headers", "(", ")", ")", ";", "}", "}", "}", "else", "{", "conn", ".", "handleMessage", "(", "msg", ")", ";", "}", "}", "else", "if", "(", "msg", "instanceof", "WebSocketFrameInternal", ")", "{", "WebSocketFrameInternal", "wsFrame", "=", "(", "WebSocketFrameInternal", ")", "msg", ";", "switch", "(", "wsFrame", ".", "type", "(", ")", ")", "{", "case", "BINARY", ":", "case", "CONTINUATION", ":", "case", "TEXT", ":", "case", "PONG", ":", "conn", ".", "handleMessage", "(", "msg", ")", ";", "break", ";", "case", "PING", ":", "conn", ".", "channel", "(", ")", ".", "writeAndFlush", "(", "new", "PongWebSocketFrame", "(", "wsFrame", ".", "getBinaryData", "(", ")", ".", "copy", "(", ")", ")", ")", ";", "break", ";", "case", "CLOSE", ":", "if", "(", "!", "closeFrameSent", ")", "{", "CloseWebSocketFrame", "closeFrame", "=", "new", "CloseWebSocketFrame", "(", "wsFrame", ".", "closeStatusCode", "(", ")", ",", "wsFrame", ".", "closeReason", "(", ")", ")", ";", "ch", ".", "writeAndFlush", "(", "closeFrame", ")", ".", "addListener", "(", "ChannelFutureListener", ".", "CLOSE", ")", ";", "closeFrameSent", "=", "true", ";", "}", "conn", ".", "handleMessage", "(", "msg", ")", ";", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Invalid type: ", "\"", "+", "wsFrame", ".", "type", "(", ")", ")", ";", "}", "}", "else", "if", "(", "msg", "instanceof", "HttpContent", ")", "{", "if", "(", "wsRequest", "!=", "null", ")", "{", "wsRequest", ".", "content", "(", ")", ".", "writeBytes", "(", "(", "(", "HttpContent", ")", "msg", ")", ".", "content", "(", ")", ")", ";", "if", "(", "msg", "instanceof", "LastHttpContent", ")", "{", "FullHttpRequest", "req", "=", "wsRequest", ";", "wsRequest", "=", "null", ";", "handshake", "(", "conn", ",", "req", ",", "ch", ",", "chctx", ")", ";", "return", ";", "}", "}", "else", "if", "(", "handshakeErrorStatus", "!=", "null", ")", "{", "if", "(", "msg", "instanceof", "LastHttpContent", ")", "{", "sendError", "(", "handshakeErrorMsg", ",", "handshakeErrorStatus", ",", "ch", ")", ";", "handshakeErrorMsg", "=", "null", ";", "handshakeErrorMsg", "=", "null", ";", "}", "return", ";", "}", "conn", ".", "handleMessage", "(", "msg", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Invalid message ", "\"", "+", "msg", ")", ";", "}", "}"], "idx": 2040, "cwe": "CWE-119", "target": 1, "status": "VULNERABLE", "commit": "269a583330695d1418a4f5578f7169350b2e1332", "function_name": "handleMessage", "body_hash": "4e19f15b36d2c24c440b78be000970bd8025a0ee"}
{"code": "protected static byte[] readFully(InputStream inp, int length, boolean shortDataIsFatal)\n            throws IOException {\n        byte[] b = new byte[length];\n\n        int pos = 0;\n        int read;\n        while (pos < length) {\n            read = inp.read(b, pos, length-pos);\n            if (read == -1) {\n                if(shortDataIsFatal) {\n                   throw new IOException(\"Tried to read \" + length + \" bytes, but only \" + pos + \" bytes present\");\n                } else {\n                   // Give them what we found\n                   // TODO Log the short read\n                   return b;\n                }\n            }\n            pos += read;\n        }\n\n        return b;\n    }", "code_tokens": ["protected", "static", "byte", "[", "]", "readFully", "(", "InputStream", "inp", ",", "int", "length", ",", "boolean", "shortDataIsFatal", ")", "throws", "IOException", "{", "byte", "[", "]", "b", "=", "new", "byte", "[", "length", "]", ";", "int", "pos", "=", "0", ";", "int", "read", ";", "while", "(", "pos", "<", "length", ")", "{", "read", "=", "inp", ".", "read", "(", "b", ",", "pos", ",", "length", "-", "pos", ")", ";", "if", "(", "read", "==", "-", "1", ")", "{", "if", "(", "shortDataIsFatal", ")", "{", "throw", "new", "IOException", "(", "\"", "Tried to read ", "\"", "+", "length", "+", "\"", " bytes, but only ", "\"", "+", "pos", "+", "\"", " bytes present", "\"", ")", ";", "}", "else", "{", "return", "b", ";", "}", "}", "pos", "+=", "read", ";", "}", "return", "b", ";", "}"], "idx": 83036, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "57193f5", "function_name": "readFully", "body_hash": "54b99eb212e5b5cbd79bd5c3e2fdfbdc4691a36d"}
{"code": "@Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String newResourceUri = exchange.getIn().getHeader(XsltConstants.XSLT_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(XsltConstants.XSLT_RESOURCE_URI);\n\n            LOG.trace(\"{} set to {} creating new endpoint to handle exchange\", XsltConstants.XSLT_RESOURCE_URI, newResourceUri);\n            XsltEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n        } else {\n            if (!cacheStylesheet || cacheCleared) {\n                loadResource(resourceUri);\n            }\n            super.onExchange(exchange);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "onExchange", "(", "Exchange", "exchange", ")", "throws", "Exception", "{", "String", "newResourceUri", "=", "exchange", ".", "getIn", "(", ")", ".", "getHeader", "(", "XsltConstants", ".", "XSLT_RESOURCE_URI", ",", "String", ".", "class", ")", ";", "if", "(", "newResourceUri", "!=", "null", ")", "{", "exchange", ".", "getIn", "(", ")", ".", "removeHeader", "(", "XsltConstants", ".", "XSLT_RESOURCE_URI", ")", ";", "LOG", ".", "trace", "(", "\"", "{} set to {} creating new endpoint to handle exchange", "\"", ",", "XsltConstants", ".", "XSLT_RESOURCE_URI", ",", "newResourceUri", ")", ";", "XsltEndpoint", "newEndpoint", "=", "findOrCreateEndpoint", "(", "getEndpointUri", "(", ")", ",", "newResourceUri", ")", ";", "newEndpoint", ".", "onExchange", "(", "exchange", ")", ";", "}", "else", "{", "if", "(", "!", "cacheStylesheet", "||", "cacheCleared", ")", "{", "loadResource", "(", "resourceUri", ")", ";", "}", "super", ".", "onExchange", "(", "exchange", ")", ";", "}", "}"], "idx": 29586, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "2ec54fa0c13ae65bdcccff764af081a79fcc05f", "function_name": "onExchange", "body_hash": "6656cebf54531319c0dbf57541e3a4c863e801a1"}
{"code": "public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getParameterTypes().length == 0)\n            return null;\n\n        if (!ObjectName.class.isAssignableFrom(method.getParameterTypes()[0]))\n            return null;\n\n        MBeanServer mbs = (MBeanServer) proxy;\n        if (mbs != null && Proxy.getInvocationHandler(mbs) instanceof MBeanInvocationHandler) {\n            mbs = ((MBeanInvocationHandler) Proxy.getInvocationHandler(mbs)).getDelegate();\n        }\n        if (mbs instanceof EventAdminMBeanServerWrapper) {\n            mbs = ((EventAdminMBeanServerWrapper) mbs).getDelegate();\n        }\n\n        ObjectName objectName = (ObjectName) args[0];\n        if (\"getAttribute\".equals(method.getName())) {\n            handleGetAttribute(mbs, objectName, (String) args[1]);\n        } else if (\"getAttributes\".equals(method.getName())) {\n            handleGetAttributes(mbs, objectName, (String[]) args[1]);\n        } else if (\"setAttribute\".equals(method.getName())) {\n            handleSetAttribute(mbs, objectName, (Attribute) args[1]);\n        } else if (\"setAttributes\".equals(method.getName())) {\n            handleSetAttributes(mbs, objectName, (AttributeList) args[1]);\n        } else if (\"invoke\".equals(method.getName())) {\n            handleInvoke(objectName, (String) args[1], (Object[]) args[2], (String[]) args[3]);\n        }\n\n        return null;\n    }", "code_tokens": ["public", "Object", "invoke", "(", "Object", "proxy", ",", "Method", "method", ",", "Object", "[", "]", "args", ")", "throws", "Throwable", "{", "if", "(", "method", ".", "getParameterTypes", "(", ")", ".", "length", "==", "0", ")", "return", "null", ";", "if", "(", "!", "ObjectName", ".", "class", ".", "isAssignableFrom", "(", "method", ".", "getParameterTypes", "(", ")", "[", "0", "]", ")", ")", "return", "null", ";", "MBeanServer", "mbs", "=", "(", "MBeanServer", ")", "proxy", ";", "if", "(", "mbs", "!=", "null", "&&", "Proxy", ".", "getInvocationHandler", "(", "mbs", ")", "instanceof", "MBeanInvocationHandler", ")", "{", "mbs", "=", "(", "(", "MBeanInvocationHandler", ")", "Proxy", ".", "getInvocationHandler", "(", "mbs", ")", ")", ".", "getDelegate", "(", ")", ";", "}", "if", "(", "mbs", "instanceof", "EventAdminMBeanServerWrapper", ")", "{", "mbs", "=", "(", "(", "EventAdminMBeanServerWrapper", ")", "mbs", ")", ".", "getDelegate", "(", ")", ";", "}", "ObjectName", "objectName", "=", "(", "ObjectName", ")", "args", "[", "0", "]", ";", "if", "(", "\"", "getAttribute", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleGetAttribute", "(", "mbs", ",", "objectName", ",", "(", "String", ")", "args", "[", "1", "]", ")", ";", "}", "else", "if", "(", "\"", "getAttributes", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleGetAttributes", "(", "mbs", ",", "objectName", ",", "(", "String", "[", "]", ")", "args", "[", "1", "]", ")", ";", "}", "else", "if", "(", "\"", "setAttribute", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleSetAttribute", "(", "mbs", ",", "objectName", ",", "(", "Attribute", ")", "args", "[", "1", "]", ")", ";", "}", "else", "if", "(", "\"", "setAttributes", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleSetAttributes", "(", "mbs", ",", "objectName", ",", "(", "AttributeList", ")", "args", "[", "1", "]", ")", ";", "}", "else", "if", "(", "\"", "invoke", "\"", ".", "equals", "(", "method", ".", "getName", "(", ")", ")", ")", "{", "handleInvoke", "(", "objectName", ",", "(", "String", ")", "args", "[", "1", "]", ",", "(", "Object", "[", "]", ")", "args", "[", "2", "]", ",", "(", "String", "[", "]", ")", "args", "[", "3", "]", ")", ";", "}", "return", "null", ";", "}"], "idx": 94393, "cwe": "CWE-918", "target": 1, "status": "VULNERABLE", "commit": "3e4c4bed2d08e81ca5961ab5fcadab23470db1c9", "function_name": "invoke", "body_hash": "0d385b3bc26b37def67f6c42bb2f60162369d360"}
{"code": "@Override\n  public void handle(RoutingContext ctx) {\n\n    if (nagHttps) {\n      String uri = ctx.request().absoluteURI();\n      if (uri != null && !uri.startsWith(\"https:\")) {\n        log.warn(\"Using session cookies without https could make you susceptible to session hijacking: \" + uri);\n      }\n    }\n\n    HttpMethod method = ctx.request().method();\n\n    switch (method) {\n      case GET:\n        final String token = generateToken();\n        // put the token in the context for users who prefer to render the token directly on the HTML\n        ctx.put(headerName, token);\n        ctx.addCookie(Cookie.cookie(cookieName, token).setPath(cookiePath));\n        ctx.next();\n        break;\n      case POST:\n      case PUT:\n      case DELETE:\n      case PATCH:\n        final String header = ctx.request().getHeader(headerName);\n        if (validateToken(header == null ? ctx.request().getFormAttribute(headerName) : header)) {\n          ctx.next();\n        } else {\n          forbidden(ctx);\n        }\n        break;\n      default:\n        // ignore these methods\n        ctx.next();\n        break;\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "handle", "(", "RoutingContext", "ctx", ")", "{", "if", "(", "nagHttps", ")", "{", "String", "uri", "=", "ctx", ".", "request", "(", ")", ".", "absoluteURI", "(", ")", ";", "if", "(", "uri", "!=", "null", "&&", "!", "uri", ".", "startsWith", "(", "\"", "https:", "\"", ")", ")", "{", "log", ".", "warn", "(", "\"", "Using session cookies without https could make you susceptible to session hijacking: ", "\"", "+", "uri", ")", ";", "}", "}", "HttpMethod", "method", "=", "ctx", ".", "request", "(", ")", ".", "method", "(", ")", ";", "switch", "(", "method", ")", "{", "case", "GET", ":", "final", "String", "token", "=", "generateToken", "(", ")", ";", "ctx", ".", "put", "(", "headerName", ",", "token", ")", ";", "ctx", ".", "addCookie", "(", "Cookie", ".", "cookie", "(", "cookieName", ",", "token", ")", ".", "setPath", "(", "cookiePath", ")", ")", ";", "ctx", ".", "next", "(", ")", ";", "break", ";", "case", "POST", ":", "case", "PUT", ":", "case", "DELETE", ":", "case", "PATCH", ":", "final", "String", "header", "=", "ctx", ".", "request", "(", ")", ".", "getHeader", "(", "headerName", ")", ";", "if", "(", "validateToken", "(", "header", "==", "null", "?", "ctx", ".", "request", "(", ")", ".", "getFormAttribute", "(", "headerName", ")", ":", "header", ")", ")", "{", "ctx", ".", "next", "(", ")", ";", "}", "else", "{", "forbidden", "(", "ctx", ")", ";", "}", "break", ";", "default", ":", "ctx", ".", "next", "(", ")", ";", "break", ";", "}", "}"], "idx": 48022, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "98891b1d9e022b467a3e4674aca4d1889849b1d", "function_name": "handle", "body_hash": "bb95408771629e34b2817bd985e966402ab28753"}
{"code": "@Override\n    public synchronized SSLEngineResult wrap(\n            final ByteBuffer[] srcs, final int offset, final int length, final ByteBuffer dst) throws SSLException {\n\n        // Check to make sure the engine has not been closed\n        if (isDestroyed()) {\n            return CLOSED_NOT_HANDSHAKING;\n        }\n\n        // Throw required runtime exceptions\n        if (srcs == null) {\n            throw new IllegalArgumentException(\"srcs is null\");\n        }\n        if (dst == null) {\n            throw new IllegalArgumentException(\"dst is null\");\n        }\n\n        if (offset >= srcs.length || offset + length > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + offset + \", length: \" + length +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n\n        if (dst.isReadOnly()) {\n            throw new ReadOnlyBufferException();\n        }\n\n        HandshakeStatus status = NOT_HANDSHAKING;\n        // Prepare OpenSSL to work in server mode and receive handshake\n        if (handshakeState != HandshakeState.FINISHED) {\n            if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                // Update accepted so we know we triggered the handshake via wrap\n                handshakeState = HandshakeState.STARTED_IMPLICITLY;\n            }\n\n            status = handshake();\n            if (status == NEED_UNWRAP) {\n                return NEED_UNWRAP_OK;\n            }\n\n            if (engineClosed) {\n                return NEED_UNWRAP_CLOSED;\n            }\n        }\n\n        // There was no pending data in the network BIO -- encrypt any application data\n        int bytesProduced = 0;\n        int bytesConsumed = 0;\n        int endOffset = offset + length;\n        for (int i = offset; i < endOffset; ++ i) {\n            final ByteBuffer src = srcs[i];\n            if (src == null) {\n                throw new IllegalArgumentException(\"srcs[\" + i + \"] is null\");\n            }\n            while (src.hasRemaining()) {\n                final SSLEngineResult pendingNetResult;\n                // Write plaintext application data to the SSL engine\n                int result = writePlaintextData(src);\n                if (result > 0) {\n                    bytesConsumed += result;\n\n                    pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                    if (pendingNetResult != null) {\n                        return pendingNetResult;\n                    }\n                } else {\n                    int sslError = SSL.getError(ssl, result);\n                    switch (sslError) {\n                    case SSL.SSL_ERROR_ZERO_RETURN:\n                        // This means the connection was shutdown correctly, close inbound and outbound\n                        if (!receivedShutdown) {\n                            closeAll();\n                        }\n                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                        return pendingNetResult != null ? pendingNetResult : CLOSED_NOT_HANDSHAKING;\n                    case SSL.SSL_ERROR_WANT_READ:\n                        // If there is no pending data to read from BIO we should go back to event loop and try to read\n                        // more data [1]. It is also possible that event loop will detect the socket has been closed.\n                        // [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html\n                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                        return pendingNetResult != null ? pendingNetResult :\n                                new SSLEngineResult(getEngineStatus(), NEED_UNWRAP, bytesConsumed, bytesProduced);\n                    case SSL.SSL_ERROR_WANT_WRITE:\n                        // SSL_ERROR_WANT_WRITE typically means that the underlying transport is not writable and we\n                        // should set the \"want write\" flag on the selector and try again when the underlying transport\n                        // is writable [1]. However we are not directly writing to the underlying transport and instead\n                        // writing to a BIO buffer. The OpenSsl documentation says we should do the following [1]:\n                        //\n                        // \"When using a buffering BIO, like a BIO pair, data must be written into or retrieved out of\n                        // the BIO before being able to continue.\"\n                        //\n                        // So we attempt to drain the BIO buffer below, but if there is no data this condition is\n                        // undefined and we assume their is a fatal error with the openssl engine and close.\n                        // [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html\n                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                        return pendingNetResult != null ? pendingNetResult : NEED_WRAP_CLOSED;\n                    default:\n                        // Everything else is considered as error\n                        throw shutdownWithError(\"SSL_write\");\n                    }\n                }\n            }\n        }\n        // We need to check if pendingWrittenBytesInBIO was checked yet, as we may not checked if the srcs was empty,\n        // or only contained empty buffers.\n        if (bytesConsumed == 0) {\n            SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, bytesProduced, status);\n            if (pendingNetResult != null) {\n                return pendingNetResult;\n            }\n        }\n\n        return newResult(bytesConsumed, bytesProduced, status);\n    }", "code_tokens": ["@", "Override", "public", "synchronized", "SSLEngineResult", "wrap", "(", "final", "ByteBuffer", "[", "]", "srcs", ",", "final", "int", "offset", ",", "final", "int", "length", ",", "final", "ByteBuffer", "dst", ")", "throws", "SSLException", "{", "if", "(", "isDestroyed", "(", ")", ")", "{", "return", "CLOSED_NOT_HANDSHAKING", ";", "}", "if", "(", "srcs", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "srcs is null", "\"", ")", ";", "}", "if", "(", "dst", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "dst is null", "\"", ")", ";", "}", "if", "(", "offset", ">=", "srcs", ".", "length", "||", "offset", "+", "length", ">", "srcs", ".", "length", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", "\"", "offset: ", "\"", "+", "offset", "+", "\"", ", length: ", "\"", "+", "length", "+", "\"", " (expected: offset <= offset + length <= srcs.length (", "\"", "+", "srcs", ".", "length", "+", "\"", "))", "\"", ")", ";", "}", "if", "(", "dst", ".", "isReadOnly", "(", ")", ")", "{", "throw", "new", "ReadOnlyBufferException", "(", ")", ";", "}", "HandshakeStatus", "status", "=", "NOT_HANDSHAKING", ";", "if", "(", "handshakeState", "!=", "HandshakeState", ".", "FINISHED", ")", "{", "if", "(", "handshakeState", "!=", "HandshakeState", ".", "STARTED_EXPLICITLY", ")", "{", "handshakeState", "=", "HandshakeState", ".", "STARTED_IMPLICITLY", ";", "}", "status", "=", "handshake", "(", ")", ";", "if", "(", "status", "==", "NEED_UNWRAP", ")", "{", "return", "NEED_UNWRAP_OK", ";", "}", "if", "(", "engineClosed", ")", "{", "return", "NEED_UNWRAP_CLOSED", ";", "}", "}", "int", "bytesProduced", "=", "0", ";", "int", "bytesConsumed", "=", "0", ";", "int", "endOffset", "=", "offset", "+", "length", ";", "for", "(", "int", "i", "=", "offset", ";", "i", "<", "endOffset", ";", "++", "i", ")", "{", "final", "ByteBuffer", "src", "=", "srcs", "[", "i", "]", ";", "if", "(", "src", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "srcs[", "\"", "+", "i", "+", "\"", "] is null", "\"", ")", ";", "}", "while", "(", "src", ".", "hasRemaining", "(", ")", ")", "{", "final", "SSLEngineResult", "pendingNetResult", ";", "int", "result", "=", "writePlaintextData", "(", "src", ")", ";", "if", "(", "result", ">", "0", ")", "{", "bytesConsumed", "+=", "result", ";", "pendingNetResult", "=", "readPendingBytesFromBIO", "(", "dst", ",", "bytesConsumed", ",", "bytesProduced", ",", "status", ")", ";", "if", "(", "pendingNetResult", "!=", "null", ")", "{", "return", "pendingNetResult", ";", "}", "}", "else", "{", "int", "sslError", "=", "SSL", ".", "getError", "(", "ssl", ",", "result", ")", ";", "switch", "(", "sslError", ")", "{", "case", "SSL", ".", "SSL_ERROR_ZERO_RETURN", ":", "if", "(", "!", "receivedShutdown", ")", "{", "closeAll", "(", ")", ";", "}", "pendingNetResult", "=", "readPendingBytesFromBIO", "(", "dst", ",", "bytesConsumed", ",", "bytesProduced", ",", "status", ")", ";", "return", "pendingNetResult", "!=", "null", "?", "pendingNetResult", ":", "CLOSED_NOT_HANDSHAKING", ";", "case", "SSL", ".", "SSL_ERROR_WANT_READ", ":", "pendingNetResult", "=", "readPendingBytesFromBIO", "(", "dst", ",", "bytesConsumed", ",", "bytesProduced", ",", "status", ")", ";", "return", "pendingNetResult", "!=", "null", "?", "pendingNetResult", ":", "new", "SSLEngineResult", "(", "getEngineStatus", "(", ")", ",", "NEED_UNWRAP", ",", "bytesConsumed", ",", "bytesProduced", ")", ";", "case", "SSL", ".", "SSL_ERROR_WANT_WRITE", ":", "pendingNetResult", "=", "readPendingBytesFromBIO", "(", "dst", ",", "bytesConsumed", ",", "bytesProduced", ",", "status", ")", ";", "return", "pendingNetResult", "!=", "null", "?", "pendingNetResult", ":", "NEED_WRAP_CLOSED", ";", "default", ":", "throw", "shutdownWithError", "(", "\"", "SSL_write", "\"", ")", ";", "}", "}", "}", "}", "if", "(", "bytesConsumed", "==", "0", ")", "{", "SSLEngineResult", "pendingNetResult", "=", "readPendingBytesFromBIO", "(", "dst", ",", "0", ",", "bytesProduced", ",", "status", ")", ";", "if", "(", "pendingNetResult", "!=", "null", ")", "{", "return", "pendingNetResult", ";", "}", "}", "return", "newResult", "(", "bytesConsumed", ",", "bytesProduced", ",", "status", ")", ";", "}"], "idx": 82273, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "524156f164a910b8b0978d27a2c700a19cd8048", "function_name": "wrap", "body_hash": "e90a0ef53cfbcff28b9ded56db3b630ee2692d93"}
{"code": "private void verifySavedState(HttpServletRequest request) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            String savedContext = (String)session.getAttribute(FederationAuthenticationEntryPoint.SAVED_CONTEXT);\n            String state = getState(request);\n            if (savedContext != null && !savedContext.equals(state)) {\n                logger.warn(\"The received state does not match the state saved in the context\");\n                throw new BadCredentialsException(\"The received state does not match the state saved in the context\");\n            }\n        }\n    }", "code_tokens": ["private", "void", "verifySavedState", "(", "HttpServletRequest", "request", ")", "{", "HttpSession", "session", "=", "request", ".", "getSession", "(", "false", ")", ";", "if", "(", "session", "!=", "null", ")", "{", "String", "savedContext", "=", "(", "String", ")", "session", ".", "getAttribute", "(", "FederationAuthenticationEntryPoint", ".", "SAVED_CONTEXT", ")", ";", "String", "state", "=", "getState", "(", "request", ")", ";", "if", "(", "savedContext", "!=", "null", "&&", "!", "savedContext", ".", "equals", "(", "state", ")", ")", "{", "logger", ".", "warn", "(", "\"", "The received state does not match the state saved in the context", "\"", ")", ";", "throw", "new", "BadCredentialsException", "(", "\"", "The received state does not match the state saved in the context", "\"", ")", ";", "}", "}", "}"], "idx": 45089, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "48dd9b68d67c6b729376c1ce8886f52a57df6c4", "function_name": "verifySavedState", "body_hash": "16a2edeb74ab8d963835708bf2865cbe4ec6aab1"}
{"code": "private Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tIterator<Element> nodes = fragment.children().iterator();\n\t\twhile ( nodes.hasNext() ) {\n\t\t\tdocument.body().appendChild( nodes.next() );\n\t\t}\n\n\t\treturn document;\n\t}", "code_tokens": ["private", "Document", "getFragmentAsDocument", "(", "CharSequence", "value", ")", "{", "Document", "fragment", "=", "Jsoup", ".", "parse", "(", "value", ".", "toString", "(", ")", ",", "baseURI", ",", "Parser", ".", "xmlParser", "(", ")", ")", ";", "Document", "document", "=", "Document", ".", "createShell", "(", "baseURI", ")", ";", "Iterator", "<", "Element", ">", "nodes", "=", "fragment", ".", "children", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "nodes", ".", "hasNext", "(", ")", ")", "{", "document", ".", "body", "(", ")", ".", "appendChild", "(", "nodes", ".", "next", "(", ")", ")", ";", "}", "return", "document", ";", "}"], "idx": 79125, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "124b7dd6d9a4ad24d4d49f74701f05a13e56ceee", "function_name": "getFragmentAsDocument", "body_hash": "a4403d17c5020737febe29715620470266d7dbba"}
{"code": "@Override\n  public void Authenticate(String user, String password) throws AuthenticationException {\n\n    Hashtable<String, Object> env = new Hashtable<String, Object>();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n    env.put(Context.PROVIDER_URL, ldapURL);\n\n    // If the domain is available in the config, then append it unless domain is\n    // already part of the username. LDAP providers like Active Directory use a\n    // fully qualified user name like foo@bar.com.\n    if (!hasDomain(user) && ldapDomain != null) {\n      user  = user + \"@\" + ldapDomain;\n    }\n\n    if (password == null || password.isEmpty()) {\n      throw new AuthenticationException(\"Error validating LDAP user:\" +\n          \" a null or blank password has been provided\");\n    }\n\n    // setup the security principal\n    String bindDN;\n    if (baseDN == null) {\n      bindDN = user;\n    } else {\n      bindDN = \"uid=\" + user + \",\" + baseDN;\n    }\n    env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n    env.put(Context.SECURITY_PRINCIPAL, bindDN);\n    env.put(Context.SECURITY_CREDENTIALS, password);\n\n    try {\n      // Create initial context\n      Context ctx = new InitialDirContext(env);\n      ctx.close();\n    } catch (NamingException e) {\n      throw new AuthenticationException(\"Error validating LDAP user\", e);\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "Authenticate", "(", "String", "user", ",", "String", "password", ")", "throws", "AuthenticationException", "{", "Hashtable", "<", "String", ",", "Object", ">", "env", "=", "new", "Hashtable", "<", "String", ",", "Object", ">", "(", ")", ";", "env", ".", "put", "(", "Context", ".", "INITIAL_CONTEXT_FACTORY", ",", "\"", "com.sun.jndi.ldap.LdapCtxFactory", "\"", ")", ";", "env", ".", "put", "(", "Context", ".", "PROVIDER_URL", ",", "ldapURL", ")", ";", "if", "(", "!", "hasDomain", "(", "user", ")", "&&", "ldapDomain", "!=", "null", ")", "{", "user", "=", "user", "+", "\"", "@", "\"", "+", "ldapDomain", ";", "}", "if", "(", "password", "==", "null", "||", "password", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Error validating LDAP user:", "\"", "+", "\"", " a null or blank password has been provided", "\"", ")", ";", "}", "String", "bindDN", ";", "if", "(", "baseDN", "==", "null", ")", "{", "bindDN", "=", "user", ";", "}", "else", "{", "bindDN", "=", "\"", "uid=", "\"", "+", "user", "+", "\"", ",", "\"", "+", "baseDN", ";", "}", "env", ".", "put", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "\"", "simple", "\"", ")", ";", "env", ".", "put", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "bindDN", ")", ";", "env", ".", "put", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "password", ")", ";", "try", "{", "Context", "ctx", "=", "new", "InitialDirContext", "(", "env", ")", ";", "ctx", ".", "close", "(", ")", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Error validating LDAP user", "\"", ",", "e", ")", ";", "}", "}"], "idx": 39189, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "6929846a8120eaf094b914b4ca8af80b65f891c8", "function_name": "Authenticate", "body_hash": "90d11b378471ce09f9aaa5b1bd86f92654fdbeff"}
{"code": "protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n\t\tString targetUrl = null;\n\t\tHttpSession session = request.getSession(false);\n\t\tif (session != null && targetUrlSessionAttribute != null) {\n\t\t\ttargetUrl = (String) session.getAttribute(targetUrlSessionAttribute);\n\t\t\tsession.removeAttribute(targetUrlSessionAttribute);\n\t\t}\n\n\t\tif (isAlwaysUseDefaultTargetUrl() || !StringUtils.hasText(targetUrl) || (getTargetUrlParameter() != null && StringUtils.hasText(request.getParameter(getTargetUrlParameter())))) {\n\t\t\ttargetUrl = super.determineTargetUrl(request, response);\n\t\t} else {\n\t\t\tlogger.debug(\"Found targetUrlSessionAttribute in request: \" + targetUrl);\n\t\t}\n\n\t\t// URL returned from determineTargetUrl() is resolved against the context path,\n\t\t// whereas the \"from\" URL is resolved against the top of the website, so adjust this.\n\t\tif (targetUrl.startsWith(request.getContextPath())) {\n\t\t\ttargetUrl = targetUrl.substring(request.getContextPath().length());\n\t\t}\n\n\t\tif (!Util.isSafeToRedirectTo(targetUrl)) {\n\t\t\tlogger.debug(\"Target URL is not safe to redirect to and will be ignored: \" + targetUrl);\n\t\t\ttargetUrl = getDefaultTargetUrl();\n\t\t}\n\n\t\treturn targetUrl;\n\t}", "code_tokens": ["protected", "String", "determineTargetUrl", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "{", "String", "targetUrl", "=", "null", ";", "HttpSession", "session", "=", "request", ".", "getSession", "(", "false", ")", ";", "if", "(", "session", "!=", "null", "&&", "targetUrlSessionAttribute", "!=", "null", ")", "{", "targetUrl", "=", "(", "String", ")", "session", ".", "getAttribute", "(", "targetUrlSessionAttribute", ")", ";", "session", ".", "removeAttribute", "(", "targetUrlSessionAttribute", ")", ";", "}", "if", "(", "isAlwaysUseDefaultTargetUrl", "(", ")", "||", "!", "StringUtils", ".", "hasText", "(", "targetUrl", ")", "||", "(", "getTargetUrlParameter", "(", ")", "!=", "null", "&&", "StringUtils", ".", "hasText", "(", "request", ".", "getParameter", "(", "getTargetUrlParameter", "(", ")", ")", ")", ")", ")", "{", "targetUrl", "=", "super", ".", "determineTargetUrl", "(", "request", ",", "response", ")", ";", "}", "else", "{", "logger", ".", "debug", "(", "\"", "Found targetUrlSessionAttribute in request: ", "\"", "+", "targetUrl", ")", ";", "}", "if", "(", "targetUrl", ".", "startsWith", "(", "request", ".", "getContextPath", "(", ")", ")", ")", "{", "targetUrl", "=", "targetUrl", ".", "substring", "(", "request", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "}", "if", "(", "!", "Util", ".", "isSafeToRedirectTo", "(", "targetUrl", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Target URL is not safe to redirect to and will be ignored: ", "\"", "+", "targetUrl", ")", ";", "targetUrl", "=", "getDefaultTargetUrl", "(", ")", ";", "}", "return", "targetUrl", ";", "}"], "idx": 65800, "cwe": "CWE-601", "target": 0, "status": "FIXED", "commit": "8ac536a", "function_name": "determineTargetUrl", "body_hash": "68b4bcbb3a8db10cfb44ec059606ae75168f018a"}
