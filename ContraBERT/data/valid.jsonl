{"code":"void PrintPreviewDataService::RemoveEntry(\n    const std::string& preview_ui_addr_str) {\n  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);\n  if (it != data_store_map_.end())\n    data_store_map_.erase(it);\n }\n","idx":184397,"target":1}
{"code":"OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n    ALOGV(\"SoftFlacEncoder::internalGetParameter(index=0x%x)\", index);\n\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n\n         case OMX_IndexParamAudioFlac:\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             flacParams->nCompressionLevel = mCompressionLevel;\n             flacParams->nChannels = mNumChannels;\n             flacParams->nSampleRate = mSampleRate;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","idx":188225,"target":1}
{"code":"PP_Flash_Menu* ReadMenu(int depth,\n                        const IPC::Message* m,\n                        PickleIterator* iter) {\n  if (depth > kMaxMenuDepth)\n    return NULL;\n  ++depth;\n\n  PP_Flash_Menu* menu = new PP_Flash_Menu;\n  menu->items = NULL;\n\n  if (!m->ReadUInt32(iter, &menu->count)) {\n    FreeMenu(menu);\n    return NULL;\n  }\n\n   if (menu->count == 0)\n     return menu;\n \n   menu->items = new PP_Flash_MenuItem[menu->count];\n   memset(menu->items, 0, sizeof(PP_Flash_MenuItem) * menu->count);\n   for (uint32_t i = 0; i < menu->count; ++i) {\n    if (!ReadMenuItem(depth, m, iter, menu->items + i)) {\n      FreeMenu(menu);\n      return NULL;\n    }\n  }\n  return menu;\n}\n","idx":185099,"target":1}
{"code":"BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)\n\t{\n\t\/* k = SHA1(PAD(A) || PAD(B) ) -- tls-srp draft 8 *\/\n\n\tBIGNUM *u;\t\n\tunsigned char cu[SHA_DIGEST_LENGTH];\n\tunsigned char *cAB;\n\tEVP_MD_CTX ctxt;\n\tint longN;  \n\tif ((A == NULL) ||(B == NULL) || (N == NULL))\n\t\treturn NULL;\n\n        if ((A == NULL) ||(B == NULL) || (N == NULL))\n                return NULL;\n \n        longN= BN_num_bytes(N);\n \n        if ((cAB = OPENSSL_malloc(2*longN)) == NULL) \n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);\n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);\n\tOPENSSL_free(cAB);\n\tEVP_DigestFinal_ex(&ctxt, cu, NULL);\n\tEVP_MD_CTX_cleanup(&ctxt);\n\n\tif (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))\n\t\treturn NULL;\n\tif (!BN_is_zero(u))\n\t\treturn u;\n\tBN_free(u);\n\treturn NULL;\n}\n","idx":178344,"target":1}
{"code":"int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t\/*\n\t * This also sets hw\/phys segments, boundary and size\n\t *\/\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n \treturn -ENOMEM;\n }\n","idx":182934,"target":1}
{"code":"  void CallbackAndDie(bool succeeded) {\n    v8::Isolate* isolate = context_->isolate();\n    v8::HandleScope handle_scope(isolate);\n    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};\n    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),\n                           arraysize(args), args);\n     delete this;\n   }\n","idx":186112,"target":1}
{"code":" pim_print(netdissect_options *ndo,\n           register const u_char *bp, register u_int len, const u_char *bp2)\n {\n\tregister const u_char *ep;\n \tregister const struct pim *pim = (const struct pim *)bp;\n \n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n #ifdef notyet\t\t\t\/* currently we see only version and type *\/\n \tND_TCHECK(pim->pim_rsv);\n #endif\n \n \tswitch (PIM_VER(pim->pim_typever)) {\n \tcase 2:\n \t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n \t\tbreak;\n \t}\n \treturn;\n }\n","idx":181026,"target":1}
{"code":"void ExtensionServiceBackend::OnExtensionInstalled(\n     const scoped_refptr<const Extension>& extension) {\n   CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n   if (frontend_.get())\n    frontend_->OnExtensionInstalled(extension);\n }\n","idx":183865,"target":1}
{"code":"acl_get_file_mode(const char *path_p)\n{\n\tstruct stat st;\n\n\tif (stat(path_p, &st) != 0)\n\t\treturn NULL;\n\treturn acl_from_mode(st.st_mode);\n}\n","idx":24,"target":0}
{"code":"void acl_mask_perm_str(acl_t acl, char *str)\n{\n\tacl_entry_t entry;\n\n\tstr[0] = '\\0';\n\tif (acl_get_entry(acl, ACL_FIRST_ENTRY, &entry) != 1)\n\t\treturn;\n\tfor(;;) {\n\t\tacl_tag_t tag;\n\n\t\tacl_get_tag_type(entry, &tag);\n\t\tif (tag == ACL_MASK) {\n\t\t\tacl_perm_str(entry, str);\n\t\t\treturn;\n\t\t}\n\t\tif (acl_get_entry(acl, ACL_NEXT_ENTRY, &entry) != 1)\n\t\t\treturn;\n\t}\n}\n","idx":25,"target":0}
{"code":"void acl_perm_str(acl_entry_t entry, char *str)\n{\n\tacl_permset_t permset;\n\tint n;\n\n\tacl_get_permset(entry, &permset);\n\tfor (n = 0; n < (int) ACL_PERMS; n++) {\n\t\tstr[n] = (acl_get_perm(permset, acl_perm_defs[n].tag) ?\n\t\t          acl_perm_defs[n].c : '-');\n\t}\n\tstr[n] = '\\0';\n}\n","idx":26,"target":0}
{"code":"void apply_mask(char *perm, const char *mask)\n{\n\twhile (*perm) {\n\t\tif (*mask == '-' && *perm >= 'a' && *perm <= 'z')\n\t\t\t*perm = *perm - 'a' + 'A';\n\t\tperm++;\n\t\tif (*mask)\n\t\t\tmask++;\n\t}\n}\n","idx":27,"target":0}
{"code":"void free_list(struct name_list *names)\n{\n\tstruct name_list *next;\n\n\twhile (names) {\n\t\tnext = names->next;\n\t\tfree(names);\n\t\tnames = next;\n\t}\n}\n","idx":30,"target":0}
{"code":"struct name_list *get_list(const struct stat *st, acl_t acl)\n{\n\tstruct name_list *first = NULL, *last = NULL;\n\tacl_entry_t ent;\n\tint ret = 0;\n\n\tif (acl != NULL)\n\t\tret = acl_get_entry(acl, ACL_FIRST_ENTRY, &ent);\n\tif (ret != 1)\n\t\treturn NULL;\n\twhile (ret > 0) {\n\t\tacl_tag_t e_type;\n\t\tconst id_t *id_p;\n\t\tconst char *name = \"\";\n\t\tint len;\n\n\t\tacl_get_tag_type(ent, &e_type);\n\t\tswitch(e_type) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tname = user_name(st->st_uid, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tid_p = acl_get_qualifier(ent);\n\t\t\t\tif (id_p != NULL)\n\t\t\t\t\tname = user_name(*id_p, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tname = group_name(st->st_gid, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tid_p = acl_get_qualifier(ent);\n\t\t\t\tif (id_p != NULL)\n\t\t\t\t\tname = group_name(*id_p, opt_numeric);\n\t\t\t\tbreak;\n\t\t}\n\t\tname = xquote(name, \"\\t\\n\\r\");\n\t\tlen = strlen(name);\n\t\tif (last == NULL) {\n\t\t\tfirst = last = (struct name_list *)\n\t\t\t\tmalloc(sizeof(struct name_list) + len + 1);\n\t\t} else {\n\t\t\tlast->next = (struct name_list *)\n\t\t\t\tmalloc(sizeof(struct name_list) + len + 1);\n\t\t\tlast = last->next;\n\t\t}\n\t\tif (last == NULL) {\n\t\t\tfree_list(first);\n\t\t\treturn NULL;\n\t\t}\n\t\tlast->next = NULL;\n\t\tstrcpy(last->name, name);\n\n\t\tret = acl_get_entry(acl, ACL_NEXT_ENTRY, &ent);\n\t}\n\treturn first;\n}\n","idx":31,"target":0}
{"code":"void help(void)\n{\n\tprintf(_(\"%s %s -- get file access control lists\\n\"),\n\t       progname, VERSION);\n\tprintf(_(\"Usage: %s [-%s] file ...\\n\"),\n\t         progname, cmd_line_options);\n#if !POSIXLY_CORRECT\n\tif (posixly_correct) {\n#endif\n\t\tprintf(_(\n\"  -d, --default           display the default access control list\\n\"));\n#if !POSIXLY_CORRECT\n\t} else {\n\t\tprintf(_(\n\"  -a,  --access           display the file access control list only\\n\"\n\"  -d, --default           display the default access control list only\\n\"\n\"  -c, --omit-header       do not display the comment header\\n\"\n\"  -e, --all-effective     print all effective rights\\n\"\n\"  -E, --no-effective      print no effective rights\\n\"\n\"  -s, --skip-base         skip files that only have the base entries\\n\"\n\"  -R, --recursive         recurse into subdirectories\\n\"\n\"  -L, --logical           logical walk, follow symbolic links\\n\"\n\"  -P, --physical          physical walk, do not follow symbolic links\\n\"\n\"  -t, --tabular           use tabular output format\\n\"\n\"  -n, --numeric           print numeric user\/group identifiers\\n\"\n\"  -p, --absolute-names    don't strip leading '\/' in pathnames\\n\"));\n\t}\n#endif\n\tprintf(_(\n\"  -v, --version           print version and exit\\n\"\n\"  -h, --help              this help text\\n\"));\n}\n","idx":32,"target":0}
{"code":"int max_name_length(struct name_list *names)\n{\n\tint max_len = 0;\n\twhile (names != NULL) {\n\t\tstruct name_list *next = names->next;\n\t\tint len = strlen(names->name);\n\n\t\tif (len > max_len)\n\t\t\tmax_len = len;\n\t\tnames = next;\n\t}\n\treturn max_len;\n}\n","idx":34,"target":0}
{"code":"int show_line(FILE *stream, struct name_list **acl_names,  acl_t acl,\n              acl_entry_t *acl_ent, const char *acl_mask,\n              struct name_list **dacl_names, acl_t dacl,\n\t      acl_entry_t *dacl_ent, const char *dacl_mask)\n{\n\tacl_tag_t tag_type;\n\tconst char *tag, *name;\n\tchar acl_perm[ACL_PERMS+1], dacl_perm[ACL_PERMS+1];\n\n\tif (acl) {\n\t\tacl_get_tag_type(*acl_ent, &tag_type);\n\t\tname = (*acl_names)->name;\n\t} else {\n\t\tacl_get_tag_type(*dacl_ent, &tag_type);\n\t\tname = (*dacl_names)->name;\n\t}\n\n\tswitch(tag_type) {\n\t\tcase ACL_USER_OBJ:\n\t\t\ttag = \"USER\";\n\t\t\tbreak;\n\t\tcase ACL_USER:\n\t\t\ttag = \"user\";\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\ttag = \"GROUP\";\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\ttag = \"group\";\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\ttag = \"mask\";\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\ttag = \"other\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\n\tmemset(acl_perm, ' ', ACL_PERMS);\n\tacl_perm[ACL_PERMS] = '\\0';\n\tif (acl_ent) {\n\t\tacl_perm_str(*acl_ent, acl_perm);\n\t\tif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&\n\t\t    tag_type != ACL_MASK)\n\t\t\tapply_mask(acl_perm, acl_mask);\n\t}\n\tmemset(dacl_perm, ' ', ACL_PERMS);\n\tdacl_perm[ACL_PERMS] = '\\0';\n\tif (dacl_ent) {\n\t\tacl_perm_str(*dacl_ent, dacl_perm);\n\t\tif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&\n\t\t    tag_type != ACL_MASK)\n\t\t\tapply_mask(dacl_perm, dacl_mask);\n\t}\n\n\tfprintf(stream, \"%-5s  %*s  %*s  %*s\\n\",\n\t        tag, -names_width, name,\n\t        -(int)ACL_PERMS, acl_perm,\n\t\t-(int)ACL_PERMS, dacl_perm);\n\n\tif (acl_names) {\n\t\tacl_get_entry(acl, ACL_NEXT_ENTRY, acl_ent);\n\t\t(*acl_names) = (*acl_names)->next;\n\t}\n\tif (dacl_names) {\n\t\tacl_get_entry(dacl, ACL_NEXT_ENTRY, dacl_ent);\n\t\t(*dacl_names) = (*dacl_names)->next;\n\t}\n\treturn 0;\n}\n","idx":35,"target":0}
{"code":"static const char *xquote(const char *str, const char *quote_chars)\n{\n\tconst char *q = quote(str, quote_chars);\n\tif (q == NULL) {\n\t\tfprintf(stderr, \"%s: %s\\n\", progname, strerror(errno));\n\t\texit(1);\n\t}\n\treturn q;\n}\n","idx":36,"target":0}
{"code":"static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n \t\treturn;\n \t}\n \tif (status) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n \t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n \t\t\/* These are unsolicited reports from the firmware, hence no\n \t\t   waiting command to wakeup *\/\n \t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n \t\tmemcpy(command_info->result_buffer, &data[1],\n \t\t\t\t\t\turb->actual_length - 1);\n \t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t\/* Continue trying to always read *\/\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}\n","idx":179541,"target":1}
{"code":"void ASessionDescription::getFormatType(\n size_t index, unsigned long *PT,\n AString *desc, AString *params) const {\n AString format;\n    getFormat(index, &format);\n\n const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n char *end;\n unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n \n     *PT = x;\n \n    char key[20];\n    sprintf(key, \"a=rtpmap:%lu\", x);\n \n     CHECK(findAttribute(index, key, desc));\n \n    sprintf(key, \"a=fmtp:%lu\", x);\n     if (!findAttribute(index, key, params)) {\n         params->clear();\n     }\n}\n","idx":187433,"target":1}
{"code":"static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) \/* {{{ *\/\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\n \tif (intern->oth_handler && intern->oth_handler->dtor) {\n \t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n \t}\n \tzend_object_std_dtor(&intern->std TSRMLS_CC);\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n \t\t}\n \t\tif (intern->u.dir.sub_path) {\n \t\t\tefree(intern->u.dir.sub_path);\n\t\t}\t\t\n \t\tbreak;\n \tcase SPL_FS_FILE:\n \t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n\/*\t\t\t\tzend_list_delref(Z_RESVAL_P(intern->zcontext));*\/\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n } \/* }}} *\/\n","idx":180255,"target":1}
{"code":"RenderProcessImpl::RenderProcessImpl()\n     : ALLOW_THIS_IN_INITIALIZER_LIST(shared_mem_cache_cleaner_(\n           FROM_HERE, base::TimeDelta::FromSeconds(5),\n           this, &RenderProcessImpl::ClearTransportDIBCache)),\n      transport_dib_next_sequence_number_(0) {\n   in_process_plugins_ = InProcessPlugins();\n   for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i)\n     shared_mem_cache_[i] = NULL;\n\n#if defined(OS_WIN)\n  if (GetModuleHandle(L\"LPK.DLL\") == NULL) {\n    typedef BOOL (__stdcall *GdiInitializeLanguagePack)(int LoadedShapingDLLs);\n    GdiInitializeLanguagePack gdi_init_lpk =\n        reinterpret_cast<GdiInitializeLanguagePack>(GetProcAddress(\n            GetModuleHandle(L\"GDI32.DLL\"),\n            \"GdiInitializeLanguagePack\"));\n    DCHECK(gdi_init_lpk);\n    if (gdi_init_lpk) {\n      gdi_init_lpk(0);\n    }\n  }\n#endif\n\n  webkit_glue::SetJavaScriptFlags(\n      \"--debugger-auto-break\"\n      \" --prof --prof-lazy\");\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kJavaScriptFlags)) {\n    webkit_glue::SetJavaScriptFlags(\n        command_line.GetSwitchValueASCII(switches::kJavaScriptFlags));\n  }\n}\n","idx":184709,"target":1}
{"code":"modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n {\n     static generic_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n         if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n     }\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n","idx":180692,"target":1}
{"code":" beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n {\n \n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \/* A REQuest *\/\n \t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP END\"));\n \telse\n \t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}\n","idx":181056,"target":1}
{"code":"deinterlace_row(png_bytep buffer, png_const_bytep row,\n   unsigned int pixel_size, png_uint_32 w, int pass)\n{\n   \/* The inverse of the above, 'row' is part of row 'y' of the output image,\n    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute\n    * the pixels of row into buffer and return the number written (to allow\n    * this to be checked).\n    *\/\n   png_uint_32 xin, xout, xstep;\n   xout = PNG_PASS_START_COL(pass);\n   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);\n   for (xin=0; xout<w; xout+=xstep)\n   {\n      pixel_copy(buffer, xout, row, xin, pixel_size);\n      ++xin;\n   }\n}\n","idx":187629,"target":1}
{"code":"static void ptrace_hbptriggered(struct perf_event *bp, int unused,\n \t\t\t\t     struct perf_sample_data *data,\n \t\t\t\t     struct pt_regs *regs)\n {\n\tstruct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);\n\tlong num;\n\tint i;\n\tsiginfo_t info;\n\n\tfor (i = 0; i < ARM_MAX_HBP_SLOTS; ++i)\n\t\tif (current->thread.debug.hbp[i] == bp)\n\t\t\tbreak;\n\n\tnum = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i);\n\n\tinfo.si_signo\t= SIGTRAP;\n\tinfo.si_errno\t= (int)num;\n\tinfo.si_code\t= TRAP_HWBKPT;\n\tinfo.si_addr\t= (void __user *)(bkpt->trigger);\n\n\tforce_sig_info(SIGTRAP, &info, current);\n}\n","idx":178949,"target":1}
{"code":"static bool check_rodc_critical_attribute(struct ldb_message *msg)\n{\n\tuint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n\n\tschemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n\tsearchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n\trodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE\n\t\t\t      | SEARCH_FLAG_CONFIDENTIAL);\n\n\tif ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&\n\t\t((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n","idx":0,"target":0}
{"code":"static int samldb_add_entry(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tret = ldb_build_add_req(&req, ldb, ac,\n\t\t\t\tac->msg,\n\t\t\t\tac->req->controls,\n\t\t\t\tac, samldb_add_entry_callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, req);\n}\n","idx":1,"target":0}
{"code":"static int samldb_add_entry_callback(struct ldb_request *req,\n\t\t\t\t\tstruct ldb_reply *ares)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\tif (ares->type == LDB_REPLY_REFERRAL) {\n\t\treturn ldb_module_send_referral(ac->req, ares->referral);\n\t}\n\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\tif (ares->type != LDB_REPLY_DONE) {\n\t\tldb_asprintf_errstring(ldb, \"Invalid LDB reply type %d\", ares->type);\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\t\/* The caller may wish to get controls back from the add *\/\n\tac->ares = talloc_steal(ac, ares);\n\n\tret = samldb_next_step(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, ret);\n\t}\n\treturn ret;\n}\n","idx":2,"target":0}
{"code":"static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)\n{\n\tstruct samldb_step *step, *stepper;\n\n\tstep = talloc_zero(ac, struct samldb_step);\n\tif (step == NULL) {\n\t\treturn ldb_oom(ldb_module_get_ctx(ac->module));\n\t}\n\n\tstep->fn = fn;\n\n\tif (ac->steps == NULL) {\n\t\tac->steps = step;\n\t\tac->curstep = step;\n\t} else {\n\t\tif (ac->curstep == NULL)\n\t\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t\tfor (stepper = ac->curstep; stepper->next != NULL;\n\t\t\tstepper = stepper->next);\n\t\tstepper->next = step;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n","idx":4,"target":0}
{"code":"static int samldb_allocate_sid(struct samldb_ctx *ac)\n{\n\tuint32_t rid;\n\tstruct dom_sid *sid;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\tret = ridalloc_allocate_rid(ac->module, &rid, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tif ( ! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n","idx":5,"target":0}
{"code":"static int samldb_check_sAMAccountName(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char *name;\n\tint ret;\n\tstruct ldb_result *res;\n\tconst char * const noattrs[] = { NULL };\n\n\tif (ldb_msg_find_element(ac->msg, \"sAMAccountName\") == NULL) {\n\t\tret = samldb_generate_sAMAccountName(ldb, ac->msg);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tname = ldb_msg_find_attr_as_string(ac->msg, \"sAMAccountName\", NULL);\n\tif (name == NULL) {\n\t\t\/* The \"sAMAccountName\" cannot be nothing *\/\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: Empty account names aren't allowed!\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb), LDB_SCOPE_SUBTREE, noattrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(sAMAccountName=%s)\",\n\t\t\t\t ldb_binary_encode_string(ac, name));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb: Account name (sAMAccountName) '%s' already in use!\",\n\t\t\t\t       name);\n\t\ttalloc_free(res);\n\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t}\n\ttalloc_free(res);\n\n\treturn samldb_next_step(ac);\n}\n","idx":6,"target":0}
{"code":"static struct samldb_ctx *samldb_ctx_init(struct ldb_module *module,\n\t\t\t\t\t  struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\n\tldb = ldb_module_get_ctx(module);\n\n\tac = talloc_zero(req, struct samldb_ctx);\n\tif (ac == NULL) {\n\t\tldb_oom(ldb);\n\t\treturn NULL;\n\t}\n\n\tac->module = module;\n\tac->req = req;\n\n\treturn ac;\n}\n","idx":8,"target":0}
{"code":"static int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tconst struct ldb_val *rdn_value;\n\tstruct dom_sid *sid;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tsid = samdb_result_dom_sid(ac->msg, ac->msg, \"objectSid\");\n\tif (sid == NULL) {\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tsid = dom_sid_parse_talloc(ac->msg,\n\t\t\t\t\t   (const char *)rdn_value->data);\n\t\tif (sid == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: No valid SID found in ForeignSecurityPrincipal CN!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tif (! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t}\n\n\t\/* finally proceed with adding the entry *\/\n\tret = samldb_add_step(ac, samldb_add_entry);\n\tif (ret != LDB_SUCCESS) return ret;\n\n\treturn samldb_first_step(ac);\n}\n","idx":9,"target":0}
{"code":"static int samldb_find_for_defaultObjectCategory(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tac->res_dn = NULL;\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ac->dn, LDB_SCOPE_BASE, no_attrs,\n\t\t\t\t DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT\n\t\t\t\t | DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectClass=classSchema)\");\n\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\/* Don't be pricky when the DN doesn't exist if we have the *\/\n\t\t\/* RELAX control specified *\/\n\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb_find_defaultObjectCategory: \"\n\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\tif ((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)) {\n\t\treturn ret;\n\t}\n\n\tif (ret == LDB_SUCCESS) {\n\t\t\/* ensure the defaultObjectCategory has a full GUID *\/\n\t\tstruct ldb_message *m;\n\t\tm = ldb_msg_new(ac->msg);\n\t\tif (m == NULL) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->dn = ac->msg->dn;\n\t\tif (ldb_msg_add_string(m, \"defaultObjectCategory\",\n\t\t\t\t       ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1)) !=\n\t\t    LDB_SUCCESS) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->elements[0].flags = LDB_FLAG_MOD_REPLACE;\n\n\t\tret = dsdb_module_modify(ac->module, m,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\n\tac->res_dn = ac->dn;\n\n\treturn samldb_next_step(ac);\n}\n","idx":11,"target":0}
{"code":"static int samldb_first_step(struct samldb_ctx *ac)\n{\n\tif (ac->steps == NULL) {\n\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t}\n\n\tac->curstep = ac->steps;\n\treturn ac->curstep->fn(ac);\n}\n","idx":12,"target":0}
{"code":"static int samldb_generate_sAMAccountName(struct ldb_context *ldb,\n\t\t\t\t\t  struct ldb_message *msg)\n{\n\tchar *name;\n\n\t\/* Format: $000000-000000000000 *\/\n\n\tname = talloc_asprintf(msg, \"$%.6X-%.6X%.6X\",\n\t\t\t\t(unsigned int)generate_random(),\n\t\t\t\t(unsigned int)generate_random(),\n\t\t\t\t(unsigned int)generate_random());\n\tif (name == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\treturn ldb_msg_add_steal_string(msg, \"sAMAccountName\", name);\n}\n","idx":13,"target":0}
{"code":"static bool samldb_krbtgtnumber_available(struct samldb_ctx *ac,\n\t\t\t\t\t  uint32_t krbtgt_number)\n{\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tret = dsdb_module_search(ac->module, tmp_ctx, &res,\n\t\t\t\t ldb_get_default_basedn(ldb_module_get_ctx(ac->module)),\n\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(msDC-SecondaryKrbTgtNumber=%u)\",\n\t\t\t\t krbtgt_number);\n\tif (ret == LDB_SUCCESS && res->count == 0) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn true;\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn false;\n}\n","idx":14,"target":0}
{"code":"static bool samldb_msg_add_sid(struct ldb_message *msg,\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct dom_sid *sid)\n{\n\tstruct ldb_val v;\n\tenum ndr_err_code ndr_err;\n\n\tndr_err = ndr_push_struct_blob(&v, msg, sid,\n\t\t\t\t       (ndr_push_flags_fn_t)ndr_push_dom_sid);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\treturn false;\n\t}\n\treturn (ldb_msg_add_value(msg, name, &v, NULL) == 0);\n}\n","idx":15,"target":0}
{"code":"static int samldb_next_step(struct samldb_ctx *ac)\n{\n\tif (ac->curstep->next) {\n\t\tac->curstep = ac->curstep->next;\n\t\treturn ac->curstep->fn(ac);\n\t}\n\n\t\/* We exit the samldb module here. If someone set an \"ares\" to forward\n\t * controls and response back to the caller, use them. *\/\n\tif (ac->ares) {\n\t\treturn ldb_module_done(ac->req, ac->ares->controls,\n\t\t\t\t       ac->ares->response, LDB_SUCCESS);\n\t} else {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);\n\t}\n}\n","idx":16,"target":0}
{"code":"static int samldb_prim_group_set(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t rid;\n\n\trid = ldb_msg_find_attr_as_uint(ac->msg, \"primaryGroupID\", (uint32_t) -1);\n\tif (rid == (uint32_t) -1) {\n\t\t\/* we aren't affected of any primary group set *\/\n\t\treturn LDB_SUCCESS;\n\n\t} else if (!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"The primary group isn't settable on add operations!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\treturn samldb_prim_group_tester(ac, rid);\n}\n","idx":19,"target":0}
{"code":"static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct dom_sid *sid;\n\tstruct ldb_result *res;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\ttalloc_free(res);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"Failed to find primary group with RID %u!\",\n\t\t\t\t       rid);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n","idx":20,"target":0}
{"code":"static int samldb_prim_group_trigger(struct samldb_ctx *ac)\n{\n\tint ret;\n\n\tif (ac->req->operation == LDB_ADD) {\n\t\tret = samldb_prim_group_set(ac);\n\t} else {\n\t\tret = samldb_prim_group_change(ac);\n\t}\n\n\treturn ret;\n}\n","idx":21,"target":0}
{"code":"static int samldb_rodc_add(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t krbtgt_number, i_start, i;\n\tint ret;\n\tchar *newpass;\n\tstruct ldb_val newpass_utf16;\n\n\t\/* find a unused msDC-SecondaryKrbTgtNumber *\/\n\ti_start = generate_random() & 0xFFFF;\n\tif (i_start == 0) {\n\t\ti_start = 1;\n\t}\n\n\tfor (i=i_start; i<=0xFFFF; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\tfor (i=1; i<i_start; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tldb_asprintf_errstring(ldb,\n\t\t\t       \"%08X: Unable to find available msDS-SecondaryKrbTgtNumber\",\n\t\t\t       W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));\n\treturn LDB_ERR_OTHER;\n\nfound:\n\tret = ldb_msg_add_empty(ac->msg, \"msDS-SecondaryKrbTgtNumber\",\n\t\t\t\tLDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t \"msDS-SecondaryKrbTgtNumber\", krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = ldb_msg_add_fmt(ac->msg, \"sAMAccountName\", \"krbtgt_%u\",\n\t\t\t      krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tnewpass = generate_random_password(ac->msg, 128, 255);\n\tif (newpass == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tif (!convert_string_talloc(ac,\n\t\t\t\t   CH_UNIX, CH_UTF16,\n\t\t\t\t   newpass, strlen(newpass),\n\t\t\t\t   (void *)&newpass_utf16.data,\n\t\t\t\t   &newpass_utf16.length)) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb_rodc_add: \"\n\t\t\t\t       \"failed to generate UTF16 password from random password\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tret = ldb_msg_add_steal_value(ac->msg, \"clearTextPassword\", &newpass_utf16);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n","idx":22,"target":0}
{"code":"static int samldb_schema_info_update(struct samldb_ctx *ac)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct dsdb_schema *schema;\n\n\t\/* replicated update should always go through *\/\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* do not update schemaInfo during provisioning *\/\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_schema_info_update(ac->module, schema,\n\t\t\t\t\t     DSDB_FLAG_NEXT_MODULE|\n\t\t\t\t\t     DSDB_FLAG_AS_SYSTEM,\n\t\t\t\t\t     ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb_schema_info_update: dsdb_module_schema_info_update failed with %s\",\n\t\t\t\t       ldb_errstring(ldb));\n\t\treturn ret;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n","idx":23,"target":0}
{"code":"setup_server_realm(krb5_principal sprinc)\n{\n    krb5_error_code     kret;\n     kdc_realm_t         *newrealm;\n \n     kret = 0;\n     if (kdc_numrealms > 1) {\n         if (!(newrealm = find_realm_data(sprinc->realm.data,\n                                          (krb5_ui_4) sprinc->realm.length)))\n            kret = ENOENT;\n        else\n            kdc_active_realm = newrealm;\n    }\n    else\n        kdc_active_realm = kdc_realmlist[0];\n    return(kret);\n}\n","idx":179105,"target":1}
{"code":"static PHP_FUNCTION(preg_match)\n{\n\tphp_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n","idx":37,"target":0}
{"code":"static int xan_huffman_decode(unsigned char *dest, int dest_len,\n\n                              const unsigned char *src, int src_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    int ptr_len = src_len - 1 - byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    if (ptr_len < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    init_get_bits(&gb, ptr, ptr_len * 8);\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest >= dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":5130,"target":1}
{"code":" static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n {\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n }\n","idx":180738,"target":1}
{"code":"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n \tjas_image_cmpt_t *cmpt;\n \tsize_t size;\n \n \tcmpt = 0;\n \tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n \t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n \t  !jas_safe_intfast32_add(tly, height, 0)) {\n \t\tgoto error;\n \t}\n \n \tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n \t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) \/ 8;\n\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n \t\tgoto error;\n \t}\n \tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t\/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. *\/\n\t\/* Note: conversion of size - 1 to long can overflow *\/\n\tif (size > 0) {\n\t\tif (size - 1 > LONG_MAX) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}\n","idx":181865,"target":1}
{"code":"static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n {\n \tsize_t n;\n \tuint32_t types = up->types;\n\n\tp->types = types;\n \tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n \t\tuintptr_t a = up->vals[n * 2];\n \t\tsize_t b = up->vals[n * 2 + 1];\n \n \t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n \t\t\tp->u[n].mem.mobj = &mobj_virt;\n \t\t\tp->u[n].mem.offs = a;\n \t\t\tp->u[n].mem.size = b;\n \t\t\tbreak;\n \t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n \t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n \t\t\tbreak;\n \t\t}\n \t}\n }\n","idx":182643,"target":1}
{"code":" nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (config != NULL, FALSE);\n\n\t\/* Addresses *\/\n\tnm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);\n\n\t\/* Routes *\/\n\t{\n\t\tint count = nm_ip4_config_get_num_routes (config);\n\t\tGArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);\n\t\tconst NMPlatformIP4Route *route;\n\t\tgboolean success;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\troute = nm_ip4_config_get_route (config, i);\n\n\t\t\t\/* Don't add the route if it's more specific than one of the subnets\n\t\t\t * the device already has an IP address on.\n\t\t\t *\/\n\t\t\tif (   route->gateway == 0\n\t\t\t    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))\n\t\t\t\tcontinue;\n\n\t\t\tg_array_append_vals (routes, route, 1);\n\t\t}\n\n\t\tsuccess = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);\n\t\tg_array_unref (routes);\n \t\t\treturn FALSE;\n \t}\n \n\t\/* MTU *\/\n\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n\t\tnm_platform_link_set_mtu (ifindex, mtu);\n \treturn TRUE;\n }\n","idx":177987,"target":1}
{"code":"devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,\n    int *eofp, caller_context_t *ct_unused, int flags_unused)\n{\n\tstruct sdev_node *sdvp = VTOSDEV(dvp);\n\tchar *ptr;\n\n\tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,\n\t    sdvp->sdev_name));\n\n\tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {\n\t\tstruct vnode *vp;\n\n\t\trw_exit(&sdvp->sdev_contents);\n\t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tif (uiop->uio_offset == 0)\n\t\tdevzvol_prunedir(sdvp);\n\tptr = sdvp->sdev_path + strlen(ZVOL_DIR);\n\tif ((strcmp(ptr, \"\/dsk\") == 0) || (strcmp(ptr, \"\/rdsk\") == 0)) {\n\t\trw_exit(&sdvp->sdev_contents);\n\t\tdevzvol_create_pool_dirs(dvp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n \t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n \t}\n \n\tptr = strchr(ptr + 1, '\/') + 1;\n \trw_exit(&sdvp->sdev_contents);\n \tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);\n \trw_enter(&sdvp->sdev_contents, RW_READER);\n\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n}\n","idx":179957,"target":1}
{"code":" static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n {\n        xml_parser *parser = (xml_parser *)rsrc->ptr;\n        if (parser->parser) {\n                XML_ParserFree(parser->parser);\n        }\n\tif (parser->ltags) {\n\t\tint inx;\n\t\tfor (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)\n\t\t\tefree(parser->ltags[ inx ]);\n\t\tefree(parser->ltags);\n\t}\n\tif (parser->startElementHandler) {\n\t\tzval_ptr_dtor(&parser->startElementHandler);\n\t}\n\tif (parser->endElementHandler) {\n\t\tzval_ptr_dtor(&parser->endElementHandler);\n\t}\n\tif (parser->characterDataHandler) {\n\t\tzval_ptr_dtor(&parser->characterDataHandler);\n\t}\n\tif (parser->processingInstructionHandler) {\n\t\tzval_ptr_dtor(&parser->processingInstructionHandler);\n\t}\n\tif (parser->defaultHandler) {\n\t\tzval_ptr_dtor(&parser->defaultHandler);\n\t}\n\tif (parser->unparsedEntityDeclHandler) {\n\t\tzval_ptr_dtor(&parser->unparsedEntityDeclHandler);\n\t}\n\tif (parser->notationDeclHandler) {\n\t\tzval_ptr_dtor(&parser->notationDeclHandler);\n\t}\n\tif (parser->externalEntityRefHandler) {\n\t\tzval_ptr_dtor(&parser->externalEntityRefHandler);\n\t}\n\tif (parser->unknownEncodingHandler) {\n\t\tzval_ptr_dtor(&parser->unknownEncodingHandler);\n\t}\n\tif (parser->startNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->startNamespaceDeclHandler);\n\t}\n\tif (parser->endNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->endNamespaceDeclHandler);\n\t}\n\tif (parser->baseURI) {\n\t\tefree(parser->baseURI);\n\t}\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n\n\tefree(parser);\n}\n","idx":178219,"target":1}
{"code":"static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n \t\t\t       const struct in6_addr *dst,\n \t\t\t       const struct in6_addr *src)\n {\n \tu32 hash, id;\n \n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n \n \t\/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n \t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t *\/\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}\n","idx":182889,"target":1}
{"code":"void Document::finishedParsing()\n{\n    ASSERT(!scriptableDocumentParser() || !m_parser->isParsing());\n    ASSERT(!scriptableDocumentParser() || m_readyState != Loading);\n    setParsingState(InDOMContentLoaded);\n\n    if (!m_documentTiming.domContentLoadedEventStart())\n        m_documentTiming.setDomContentLoadedEventStart(monotonicallyIncreasingTime());\n    dispatchEvent(Event::createBubble(EventTypeNames::DOMContentLoaded));\n    if (!m_documentTiming.domContentLoadedEventEnd())\n        m_documentTiming.setDomContentLoadedEventEnd(monotonicallyIncreasingTime());\n    setParsingState(FinishedParsing);\n\n    RefPtrWillBeRawPtr<Document> protect(this);\n\n    Microtask::performCheckpoint();\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n        const bool mainResourceWasAlreadyRequested = frame->loader().stateMachine()->committedFirstRealDocumentLoad();\n\n        if (mainResourceWasAlreadyRequested)\n            updateLayoutTreeIfNeeded();\n\n        frame->loader().finishedParsing();\n\n        TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"MarkDOMContent\", TRACE_EVENT_SCOPE_THREAD, \"data\", InspectorMarkLoadEvent::data(frame.get()));\n        InspectorInstrumentation::domContentLoadedEventFired(frame.get());\n    }\n\n    m_elementDataCacheClearTimer.startOneShot(10, FROM_HERE);\n\n    m_fetcher->clearPreloads();\n}\n","idx":185822,"target":1}
{"code":"static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\n\tspin_lock_irqsave(&m->lock, flags);\n\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n \n \tspin_unlock_irqrestore(&m->lock, flags);\n \n \treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n }\n","idx":178896,"target":1}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    AVFilterContext *ctx = inlink->dst;\n    FrameRateContext *s = ctx->priv;\n    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);\n    int plane;\n\n    for (plane = 0; plane < 4; plane++) {\n        s->line_size[plane] = av_image_get_linesize(inlink->format, inlink->w,\n                                                    plane);\n    }\n\n    s->bitdepth = pix_desc->comp[0].depth;\n    s->vsub = pix_desc->log2_chroma_h;\n    s->interp_start = s->interp_start_param << (s->bitdepth - 8);\n    s->interp_end = s->interp_end_param << (s->bitdepth - 8);\n\n    s->sad = av_pixelutils_get_sad_fn(3, 3, 2, s); \/\/ 8x8 both sources aligned\n    if (!s->sad)\n        return AVERROR(EINVAL);\n\n    s->srce_time_base = inlink->time_base;\n\n    s->max = 1 << (s->bitdepth);\n    if (s->bitdepth == 8)\n        s->blend = blend_frames_c;\n    else\n        s->blend = blend_frames16_c;\n\n    return 0;\n}","idx":1291695,"target":1}
{"code":"static void blend_frame(AVFilterContext *ctx,\n                        AVFrame *top_buf,\n                        AVFrame *bottom_buf,\n                        AVFrame *dst_buf)\n{\n    BlendContext *b = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    FilterParams *param;\n    int plane;\n\n    for (plane = 0; dst_buf->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? b->hsub : 0;\n        int vsub = plane == 1 || plane == 2 ? b->vsub : 0;\n        int outw = dst_buf->width  >> hsub;\n        int outh = dst_buf->height >> vsub;\n        uint8_t *dst    = dst_buf->data[plane];\n        uint8_t *top    = top_buf->data[plane];\n        uint8_t *bottom = bottom_buf->data[plane];\n\n        param = &b->params[plane];\n        param->values[VAR_N]  = inlink->frame_count;\n        param->values[VAR_T]  = dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts * av_q2d(inlink->time_base);\n        param->values[VAR_W]  = outw;\n        param->values[VAR_H]  = outh;\n        param->values[VAR_SW] = outw \/ dst_buf->width;\n        param->values[VAR_SH] = outh \/ dst_buf->height;\n        param->blend(top, top_buf->linesize[plane],\n                     bottom, bottom_buf->linesize[plane],\n                     dst, dst_buf->linesize[plane], outw, outh, param);\n    }\n}","idx":1292326,"target":1}
{"code":"static int init_tile(Jpeg2000DecoderContext *s, int tileno)\n{\n    int compno;\n    int tilex = tileno % s->numXtiles;\n    int tiley = tileno \/ s->numXtiles;\n    Jpeg2000Tile *tile = s->tile + tileno;\n\n    if (!tile->comp)\n        return AVERROR(ENOMEM);\n\n    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;\n        int ret; \/\/ global bandno\n\n        comp->coord_o[0][0] = tile->coord[0][0];\n        comp->coord_o[0][1] = tile->coord[0][1];\n        comp->coord_o[1][0] = tile->coord[1][0];\n        comp->coord_o[1][1] = tile->coord[1][1];\n        if (compno) {\n            comp->coord_o[0][0] \/= s->cdx[compno];\n            comp->coord_o[0][1] \/= s->cdx[compno];\n            comp->coord_o[1][0] \/= s->cdy[compno];\n            comp->coord_o[1][1] \/= s->cdy[compno];\n        }\n\n        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);\n        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);\n        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);\n        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);\n\n        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,\n                                             s->cbps[compno], s->cdx[compno],\n                                             s->cdy[compno], s->avctx))\n            return ret;\n    }\n    return 0;\n}","idx":1295382,"target":1}
{"code":"int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type,\n                            uint8_t *data, size_t size)\n{\n    AVPacketSideData *sd, *tmp;\n    int i;\n\n    for (i = 0; i < st->nb_side_data; i++) {\n        sd = &st->side_data[i];\n\n        if (sd->type == type) {\n            av_freep(&sd->data);\n            sd->data = data;\n            sd->size = size;\n            return 0;\n        }\n    }\n\n    tmp = av_realloc_array(st->side_data, st->nb_side_data + 1, sizeof(*tmp));\n    if (!tmp) {\n        return AVERROR(ENOMEM);\n    }\n\n    st->side_data = tmp;\n    st->nb_side_data++;\n\n    sd = &st->side_data[st->nb_side_data - 1];\n    sd->type = type;\n    sd->data = data;\n    sd->size = size;\n\n    return 0;\n}","idx":1291528,"target":1}
{"code":"static inline void refill_32(BitstreamContext *bc)\n{\n    if (bc->ptr >= bc->buffer_end)\n        return;\n\n#ifdef BITSTREAM_READER_LE\n    bc->bits       = (uint64_t)AV_RL32(bc->ptr) << bc->bits_left | bc->bits;\n#else\n    bc->bits       = bc->bits | (uint64_t)AV_RB32(bc->ptr) << (32 - bc->bits_left);\n#endif\n    bc->ptr       += 4;\n    bc->bits_left += 32;\n}","idx":1295451,"target":1}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}","idx":1291672,"target":1}
{"code":"static void brigade_move(apr_bucket_brigade *b, apr_bucket_brigade *a,\n                         apr_bucket *e)\n{\n    apr_bucket *f;\n\n    if (e != APR_BRIGADE_SENTINEL(b)) {\n        f = APR_RING_LAST(&b->list);\n        APR_RING_UNSPLICE(e, f, link);\n        APR_RING_SPLICE_HEAD(&a->list, e, f, apr_bucket, link);\n    }\n\n    APR_BRIGADE_CHECK_CONSISTENCY(a);\n    APR_BRIGADE_CHECK_CONSISTENCY(b);\n}","idx":15,"target":0}
{"code":"static long get_chunk_size(char *b)\n{\n    long chunksize = 0;\n    size_t chunkbits = sizeof(long) * 8;\n\n    ap_xlate_proto_from_ascii(b, strlen(b));\n\n    \/* Skip leading zeros *\/\n    while (*b == '0') {\n        ++b;\n    }\n\n    while (apr_isxdigit(*b) && (chunkbits > 0)) {\n        int xvalue = 0;\n\n        if (*b >= '0' && *b <= '9') {\n            xvalue = *b - '0';\n        }\n        else if (*b >= 'A' && *b <= 'F') {\n            xvalue = *b - 'A' + 0xa;\n        }\n        else if (*b >= 'a' && *b <= 'f') {\n            xvalue = *b - 'a' + 0xa;\n        }\n\n        chunksize = (chunksize << 4) | xvalue;\n        chunkbits -= 4;\n        ++b;\n    }\n    if (apr_isxdigit(*b) && (chunkbits <= 0)) {\n        \/* overflow *\/\n        return -1;\n    }\n\n    return chunksize;\n}","idx":12,"target":0}
{"code":"AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int length)\n{\n    const char *hex = \"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;\n    unsigned char hash[APR_MD5_DIGESTSIZE];\n    char *r, result[33]; \/* (MD5_DIGESTSIZE * 2) + 1 *\/\n    int i;\n\n    \/*\n     * Take the MD5 hash of the string argument.\n     *\/\n\n    apr_md5_init(&my_md5);\n#if APR_CHARSET_EBCDIC\n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);\n#endif\n    apr_md5_update(&my_md5, buf, (unsigned int)length);\n    apr_md5_final(hash, &my_md5);\n\n    for (i = 0, r = result; i < APR_MD5_DIGESTSIZE; i++) {\n        *r++ = hex[hash[i] >> 4];\n        *r++ = hex[hash[i] & 0xF];\n    }\n    *r = '\\0';\n\n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);\n}","idx":3,"target":0}
{"code":"static int set_group_privs(void)\n{\n    if (!geteuid()) {\n        const char *name;\n\n        \/* Get username if passed as a uid *\/\n\n        if (unixd_config.user_name[0] == '#') {\n            struct passwd *ent;\n            uid_t uid = atoi(&unixd_config.user_name[1]);\n\n            if ((ent = getpwuid(uid)) == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"getpwuid: couldn't determine user name from uid %u, \"\n                         \"you probably need to modify the User directive\",\n                         (unsigned)uid);\n                return -1;\n            }\n\n            name = ent->pw_name;\n        }\n        else\n            name = unixd_config.user_name;\n\n#if !defined(OS2) && !defined(TPF)\n        \/* OS\/2 and TPF don't support groups. *\/\n\n        \/*\n         * Set the GID before initgroups(), since on some platforms\n         * setgid() is known to zap the group list.\n         *\/\n        if (setgid(unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"setgid: unable to set group id to Group %u\",\n                        (unsigned)unixd_config.group_id);\n            return -1;\n        }\n\n        \/* Reset `groups' attributes. *\/\n\n        if (initgroups(name, unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"initgroups: unable to set groups for User %s \"\n                        \"and Group %u\", name, (unsigned)unixd_config.group_id);\n            return -1;\n        }\n#endif \/* !defined(OS2) && !defined(TPF) *\/\n    }\n    return 0;\n}","idx":6,"target":0}
{"code":"AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int length)\n{\n    const char *hex = \"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;\n    unsigned char hash[APR_MD5_DIGESTSIZE];\n    char *r, result[33]; \/* (MD5_DIGESTSIZE * 2) + 1 *\/\n    int i;\n\n    \/*\n     * Take the MD5 hash of the string argument.\n     *\/\n\n    apr_md5_init(&my_md5);\n#if APR_CHARSET_EBCDIC\n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);\n#endif\n    apr_md5_update(&my_md5, buf, (unsigned int)length);\n    apr_md5_final(hash, &my_md5);\n\n    for (i = 0, r = result; i < APR_MD5_DIGESTSIZE; i++) {\n        *r++ = hex[hash[i] >> 4];\n        *r++ = hex[hash[i] & 0xF];\n    }\n    *r = '\\0';\n\n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);\n}","idx":4,"target":0}
{"code":"void ap_init_scoreboard(void *shared_score)\n{\n    char *more_storage;\n    int i;\n\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image =\n        calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *) +\n               server_limit * lb_limit * sizeof(lb_score *));\n    more_storage = shared_score;\n    ap_scoreboard_image->global = (global_score *)more_storage;\n    more_storage += sizeof(global_score);\n    ap_scoreboard_image->parent = (process_score *)more_storage;\n    more_storage += sizeof(process_score) * server_limit;\n    ap_scoreboard_image->servers =\n        (worker_score **)((char*)ap_scoreboard_image + sizeof(scoreboard));\n    for (i = 0; i < server_limit; i++) {\n        ap_scoreboard_image->servers[i] = (worker_score *)more_storage;\n        more_storage += thread_limit * sizeof(worker_score);\n    }\n    if (lb_limit) {\n        ap_scoreboard_image->balancers = (lb_score *)more_storage;\n        more_storage += lb_limit * sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score + scoreboard_size);\n    ap_scoreboard_image->global->server_limit = server_limit;\n    ap_scoreboard_image->global->thread_limit = thread_limit;\n    ap_scoreboard_image->global->lb_limit     = lb_limit;\n}","idx":19,"target":0}
{"code":"AP_DECLARE(char *) ap_field_noparam(apr_pool_t *p, const char *intype)\n{\n    const char *semi;\n\n    if (intype == NULL) return NULL;\n\n    semi = ap_strchr_c(intype, ';');\n    if (semi == NULL) {\n        return apr_pstrdup(p, intype);\n    }\n    else {\n        while ((semi > intype) && apr_isspace(semi[-1])) {\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi - intype);\n    }\n}","idx":17,"target":0}
{"code":"AP_DECLARE(char *) ap_field_noparam(apr_pool_t *p, const char *intype)\n{\n    const char *semi;\n\n    if (intype == NULL) return NULL;\n\n    semi = ap_strchr_c(intype, ';');\n    if (semi == NULL) {\n        return apr_pstrdup(p, intype);\n    }\n    else {\n        while ((semi > intype) && apr_isspace(semi[-1])) {\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi - intype);\n    }\n}","idx":16,"target":0}
{"code":"AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n\n    \/* http:\/\/issues.apache.org\/bugzilla\/show_bug.cgi?id=31875\n     * http:\/\/issues.apache.org\/bugzilla\/show_bug.cgi?id=28450\n     *\n     * This is not in fact a URI, it's a path.  That matters in the\n     * case of a leading double-slash.  We need to resolve the issue\n     * by normalising that out before treating it as a URI.\n     *\/\n    while ((uri[0] == '\/') && (uri[1] == '\/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        \/* Simple syntax Errors in URLs are trapped by\n         * parse_uri_components().\n         *\/\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n\n    if (status == APR_SUCCESS) {\n        \/* if it has a scheme we may need to do absoluteURI vhost stuff *\/\n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"\/\");\n\n#if defined(OS2) || defined(WIN32)\n        \/* Handle path translations for OS\/2 and plug security hole.\n         * This will prevent \"http:\/\/www.wherever.com\/..\\..\\\/\" from\n         * returning a directory for the root drive.\n         *\/\n        {\n            char *x;\n\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '\/';\n        }\n#endif \/* OS2 || WIN32 *\/\n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \/* set error status *\/\n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}","idx":0,"target":0}
{"code":"static void *merge_action_dir_configs(apr_pool_t *p, void *basev, void *addv)\n{\n    action_dir_config *base = (action_dir_config *) basev;\n    action_dir_config *add = (action_dir_config *) addv;\n    action_dir_config *new = (action_dir_config *) apr_palloc(p,\n                                  sizeof(action_dir_config));\n    int i;\n\n    new->action_types = apr_table_overlay(p, add->action_types,\n                                       base->action_types);\n\n    for (i = 0; i < METHODS; ++i) {\n        new->scripted[i] = add->scripted[i] ? add->scripted[i]\n                                            : base->scripted[i];\n    }\n\n    new->configured = (base->configured || add->configured);\n    return new;\n}","idx":10,"target":0}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (INT_MAX - 16))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    return (char *)realloc((char *)ptr - diff, size + diff) + diff;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size, 32);\n#else\n    return realloc(ptr, size);\n#endif\n}","idx":635446,"target":1}
{"code":"static int biquad_init_coeffs(void *avc, struct FFIIRFilterCoeffs *c,\n                              enum IIRFilterMode filt_mode, int order,\n                              float cutoff_ratio, float stopband)\n{\n    double cos_w0, sin_w0;\n    double a0, x0, x1;\n\n    if (filt_mode != FF_FILTER_MODE_HIGHPASS &&\n        filt_mode != FF_FILTER_MODE_LOWPASS) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter currently only supports \"\n               \"high-pass and low-pass filter modes\\n\");\n        return -1;\n    }\n    if (order != 2) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter must have order of 2\\n\");\n        return -1;\n    }\n\n    cos_w0 = cos(M_PI * cutoff_ratio);\n    sin_w0 = sin(M_PI * cutoff_ratio);\n\n    a0 = 1.0 + (sin_w0 \/ 2.0);\n\n    if (filt_mode == FF_FILTER_MODE_HIGHPASS) {\n        c->gain  =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x1       = (-(1.0 + cos_w0))        \/ a0;\n    } else { \/\/ FF_FILTER_MODE_LOWPASS\n        c->gain  =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x1       =   (1.0 - cos_w0)         \/ a0;\n    }\n    c->cy[0] = (-1.0 + (sin_w0 \/ 2.0)) \/ a0;\n    c->cy[1] =  (2.0 *  cos_w0)        \/ a0;\n\n    \/\/ divide by gain to make the x coeffs integers.\n    \/\/ during filtering, the delay state will include the gain multiplication\n    c->cx[0] = lrintf(x0 \/ c->gain);\n    c->cx[1] = lrintf(x1 \/ c->gain);\n\n    return 0;\n}","idx":634857,"target":1}
{"code":"static inline void init_get_bits(GetBitContext *s, const uint8_t *buffer,\n                                 int bit_size)\n{\n    int buffer_size = (bit_size+7)>>3;\n    if (buffer_size < 0 || bit_size < 0) {\n        buffer_size = bit_size = 0;\n        buffer = NULL;\n    }\n\n    s->buffer       = buffer;\n    s->size_in_bits = bit_size;\n#if !UNCHECKED_BITSTREAM_READER\n    s->size_in_bits_plus8 = bit_size + 8;\n#endif\n    s->buffer_end   = buffer + buffer_size;\n    s->index        = 0;\n}","idx":633355,"target":1}
{"code":"static\nECDSA_SIG *SM2_sig_gen(const EC_KEY *key, const BIGNUM *e)\n{\n    const BIGNUM *dA = EC_KEY_get0_private_key(key);\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n\n    ECDSA_SIG *sig = NULL;\n    EC_POINT *kG = NULL;\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *rk = NULL;\n    BIGNUM *r = NULL;\n    BIGNUM *s = NULL;\n    BIGNUM *x1 = NULL;\n    BIGNUM *tmp = NULL;\n\n    kG = EC_POINT_new(group);\n    if (kG == NULL)\n        goto done;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto done;\n\n    BN_CTX_start(ctx);\n\n    k = BN_CTX_get(ctx);\n    rk = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n\n    if (tmp == NULL)\n        goto done;\n\n    \/* These values are returned and so should not be allocated out of the context *\/\n    r = BN_new();\n    s = BN_new();\n\n    if (r == NULL || s == NULL)\n        goto done;\n\n    for (;;) {\n        BN_priv_rand_range(k, order);\n\n        if (EC_POINT_mul(group, kG, k, NULL, NULL, ctx) == 0)\n            goto done;\n\n        if (EC_POINT_get_affine_coordinates_GFp(group, kG, x1, NULL, ctx) == 0)\n            goto done;\n\n        if (BN_mod_add(r, e, x1, order, ctx) == 0)\n            goto done;\n\n        \/* try again if r == 0 or r+k == n *\/\n        if (BN_is_zero(r))\n            continue;\n\n        BN_add(rk, r, k);\n\n        if (BN_cmp(rk, order) == 0)\n            continue;\n\n        BN_add(s, dA, BN_value_one());\n        BN_mod_inverse(s, s, order, ctx);\n\n        BN_mod_mul(tmp, dA, r, order, ctx);\n        BN_sub(tmp, k, tmp);\n\n        BN_mod_mul(s, s, tmp, order, ctx);\n\n        sig = ECDSA_SIG_new();\n\n        if (sig == NULL)\n            goto done;\n\n         \/* takes ownership of r and s *\/\n        ECDSA_SIG_set0(sig, r, s);\n        break;\n    }\n\n done:\n\n    if (sig == NULL) {\n        BN_free(r);\n        BN_free(s);\n    }\n\n    BN_CTX_free(ctx);\n    EC_POINT_free(kG);\n    return sig;\n\n}","idx":394008,"target":1}
{"code":"void CRYPTO_destroy_dynlockid(int i)\n\t{\n\tCRYPTO_dynlock *pointer = NULL;\n\tif (i)\n\t\ti = -i-1;\n\tif (dynlock_destroy_callback == NULL)\n\t\treturn;\n\n\tCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))\n\t\treturn;\n\tpointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\n\tif (pointer != NULL)\n\t\t{\n\t\t--pointer->references;\n#ifdef REF_CHECK\n\t\tif (pointer->references < 0)\n\t\t\t{\n\t\t\tfprintf(stderr,\"CRYPTO_destroy_dynlockid, bad reference count\\n\");\n\t\t\tabort();\n\t\t\t}\n\t\telse\n#endif\n\t\t\tif (pointer->references <= 0)\n\t\t\t\t{\n\t\t\t\tsk_CRYPTO_dynlock_set(dyn_locks, i, NULL);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tpointer = NULL;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (pointer)\n\t\t{\n\t\tdynlock_destroy_callback(pointer->data,__FILE__,__LINE__);\n\t\tOPENSSL_free(pointer);\n\t\t}\n\t}","idx":391838,"target":1}
{"code":"void PEM_dek_info(char *buf, const char *type, int len, char *str)\n\t{\n\tstatic const unsigned char map[17]=\"0123456789ABCDEF\";\n\tlong i;\n\tint j;\n\n\tstrcat(buf,\"DEK-Info: \");\n\tstrcat(buf,type);\n\tstrcat(buf,\",\");\n\tj=strlen(buf);\n\tfor (i=0; i<len; i++)\n\t\t{\n\t\tbuf[j+i*2]  =map[(str[i]>>4)&0x0f];\n\t\tbuf[j+i*2+1]=map[(str[i]   )&0x0f];\n\t\t}\n\tbuf[j+i*2]='\\n';\n\tbuf[j+i*2+1]='\\0';\n\t}","idx":387288,"target":1}
{"code":"BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n        {\n\tBN_ULONG t1,t2;\n\tint c=0;\n\n\tassert(n >= 0);\n\tif (n <= 0) return((BN_ULONG)0);\n\n\tfor (;;)\n\t\t{\n\t\tt1=a[0]; t2=b[0];\n\t\tr[0]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[1]; t2=b[1];\n\t\tr[1]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[2]; t2=b[2];\n\t\tr[2]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[3]; t2=b[3];\n\t\tr[3]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\ta+=4;\n\t\tb+=4;\n\t\tr+=4;\n\t\t}\n\treturn(c);\n\t}","idx":392600,"target":1}
{"code":"static int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           int max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned int i;\n\n    if (max-- < 1)\n        return (0);\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (max < (int)i)\n                return 0;\n            \/* Skip leading zeroes *\/\n            while (i && *p == 0) {\n                p++;\n                i--;\n            }\n            if (i > sizeof(long))\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return (1);\n}","idx":392777,"target":1}
