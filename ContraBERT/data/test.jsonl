{"idx":"cve-2012-2375-BUFFER","target":1,"code":"static ssize_t __nfs4_get_acl_uncached(struct inode*inode, void*buf, size_t buflen){struct page*pages[NFS4ACL_MAXPAGES];struct nfs_getaclargs args={.fh=NFS_FH(inode), .acl_pages=pages, .acl_len=buflen, };struct nfs_getaclres res={.acl_len=buflen, };void*resp_buf;struct rpc_message msg={.rpc_proc=&nfs4_procedures[NFSPROC4_CLNT_GETACL], .rpc_argp=&args, .rpc_resp=&res, };struct page*localpage=NULL;int ret;if(buflen<PAGE_SIZE){localpage=alloc_page(GFP_KERNEL);resp_buf=page_address(localpage);if(localpage == NULL)return-ENOMEM;args.acl_pages[0]=localpage;args.acl_pgbase=0;args.acl_len=PAGE_SIZE;}else{resp_buf=buf;buf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);}ret=nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);if(ret)goto out_free;if(res.acl_len>args.acl_len)nfs4_write_cached_acl(inode, NULL, res.acl_len);else\n\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);if(buf){ret=-ERANGE;if(res.acl_len>buflen)goto out_free;if(localpage)memcpy(buf, resp_buf, res.acl_len);}ret=res.acl_len;out_free:\n\tif(localpage)__free_page(localpage);return ret;}"}
{"idx":"cve-2012-2375-CLEAN","target":0,"code":"static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen) {\n    struct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n    struct nfs_getaclargs args = {.fh = NFS_FH(inode), .acl_pages = pages, .acl_len = buflen, };\n    struct nfs_getaclres res = {.acl_len = buflen, };\n    struct rpc_message msg = {.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL], .rpc_argp = &args, .rpc_resp = &res, };\n    unsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n    int ret = -ENOMEM, i;\n    if (npages == 0)\n        npages = 1;\n    if (npages > ARRAY_SIZE(pages))\n        return -ERANGE;\n    for (i = 0; i < npages; i++) {\n        pages[i] = alloc_page(GFP_KERNEL);\n        if (!pages[i])\n            goto out_free;\n    }\n    res.acl_scratch = alloc_page(GFP_KERNEL);\n    if (!res.acl_scratch)\n        goto out_free;\n    args.acl_len = npages * PAGE_SIZE;\n    args.acl_pgbase = 0;\n    dprintk(\"%s  buf%p buflen%zu npages%d args.acl_len%zu\\n\", __func__, buf, buflen, npages, args.acl_len);\n    ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n    if (ret)\n        goto out_free;\n    if (res.acl_flags & NFS4_ACL_TRUNC) {\n        if (buf == NULL)\n            goto out_ok;\n        ret = -ERANGE;\n        goto out_free;\n    }\n    nfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n    if (buf) {\n        if (res.acl_len > buflen) {\n            ret = -ERANGE;\n            goto out_free;\n        }\n        _copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n    }\nout_ok:\n    ret = res.acl_len;\nout_free:\n    for (i = 0; i < npages; i++)\n        if (pages[i])\n            __free_page(pages[i]);\n    if (res.acl_scratch)\n        __free_page(res.acl_scratch);\n    return ret;\n}"}
{"idx":"cve-2012-4565-CLEAN","target":0,"code":"static void tcp_illinois_info(struct sock *sk, u32 ext, struct sk_buff *skb) {\n    const struct illinois *ca = inet_csk_ca(sk);\n    if (!ca) return;\n    if (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n        struct tcpvegas_info info = {\n            .tcpv_enabled = 1,\n            .tcpv_rttcnt = ca->cnt_rtt,\n            .tcpv_minrtt = ca->base_rtt,\n        };\n        if (info.tcpv_rttcnt > 0) {\n            u64 t = ca->sum_rtt;\n            do_div(t, info.tcpv_rttcnt);\n            info.tcpv_rtt = t;\n        }\n        nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n    }\n}"}
{"idx":"cve-2012-4565-NUMERICAL","target":1,"code":"static void tcp_illinois_info(struct sock*sk, u32 ext, struct sk_buff*skb){const struct illinois*ca=inet_csk_ca(sk);if(ext&(1<<(INET_DIAG_VEGASINFO-1))){struct tcpvegas_info info={.tcpv_enabled=1, .tcpv_rttcnt=ca->cnt_rtt, .tcpv_minrtt=ca->base_rtt, };u64 t=ca->sum_rtt;do_div(t, ca->cnt_rtt);info.tcpv_rtt=t;nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);}}"}
{"idx":"cve-2013-1774-BUFFER","target":1,"code":"static void chase_port(struct edgeport_port*port, unsigned long timeout, int flush){int baud_rate;struct tty_struct*tty=tty_port_tty_get(&port->port->port);wait_queue_t wait;unsigned long flags;if(!timeout)timeout=(HZ*EDGE_CLOSING_WAIT)\/100;spin_lock_irqsave(&port->ep_lock, flags);init_waitqueue_entry(&wait, current);add_wait_queue(&tty->write_wait, &wait);for(;;){set_current_state(TASK_INTERRUPTIBLE);if(kfifo_len(&port->write_fifo) == 0 || timeout == 0 || signal_pending(current) || !usb_get_intfdata(port->port->serial->interface))break;spin_unlock_irqrestore(&port->ep_lock, flags);timeout=schedule_timeout(timeout);spin_lock_irqsave(&port->ep_lock, flags);}set_current_state(TASK_RUNNING);remove_wait_queue(&tty->write_wait, &wait);if(flush)kfifo_reset_out(&port->write_fifo);spin_unlock_irqrestore(&port->ep_lock, flags);tty_kref_put(tty);timeout+=jiffies;while((long)(jiffies-timeout)<0 && !signal_pending(current) && usb_get_intfdata(port->port->serial->interface)){if(!tx_active(port))break;msleep(10);}if(!usb_get_intfdata(port->port->serial->interface))return;baud_rate=port->baud_rate;if(baud_rate == 0)baud_rate=50;msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));}"}
{"idx":"cve-2013-1774-CLEAN","target":0,"code":"static void chase_port(struct edgeport_port *port, unsigned long timeout, int flush)\n{\n    int baud_rate;\n    struct tty_struct *tty;\n    struct usb_serial *serial;\n    wait_queue_t wait;\n    unsigned long flags;\n    if (!port || !(port->port) || !(port->port->serial))\n        return;\n    tty = tty_port_tty_get(&port->port->port);\n    serial = port->port->serial;\n    if (!tty)\n        return;\n    if (!timeout)\n        timeout = (HZ * EDGE_CLOSING_WAIT) \/ 100;\n    spin_lock_irqsave(&port->ep_lock, flags);\n    init_waitqueue_entry(&wait, current);\n    add_wait_queue(&tty->write_wait, &wait);\n    for (;;) {\n        set_current_state(TASK_INTERRUPTIBLE);\n        if (kfifo_len(&port->write_fifo) == 0 || timeout == 0 || signal_pending(current) || serial->disconnected)\n            break;\n        spin_unlock_irqrestore(&port->ep_lock, flags);\n        timeout = schedule_timeout(timeout);\n        spin_lock_irqsave(&port->ep_lock, flags);\n    }\n    set_current_state(TASK_RUNNING);\n    remove_wait_queue(&tty->write_wait, &wait);\n    if (flush)\n        kfifo_reset_out(&port->write_fifo);\n    spin_unlock_irqrestore(&port->ep_lock, flags);\n    tty_kref_put(tty);\n    if (serial->disconnected)\n        return;\n    baud_rate = port->baud_rate;\n    if (baud_rate == 0)\n        baud_rate = 50;\n    msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}"}
{"idx":"cve-2013-1860-BUFFER","target":1,"code":"static void wdm_in_callback(struct urb*urb){struct wdm_device*desc=urb->context;int status=urb->status;int length=urb->actual_length;spin_lock(&desc->iuspin);clear_bit(WDM_RESPONDING, &desc->flags);if(status){switch(status){case-ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev, \"nonzero urb status received:-ENOENT\");goto skip_error;case-ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev, \"nonzero urb status received:-ECONNRESET\");goto skip_error;case-ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev, \"nonzero urb status received:-ESHUTDOWN\");goto skip_error;case-EPIPE:\n\t\t\tdev_err(&desc->intf->dev, \"nonzero urb status received:-EPIPE\\n\");break;default:\n\t\t\tdev_err(&desc->intf->dev, \"Unexpected error%d\\n\", status);break;}}desc->rerr=status;if(length+desc->length>desc->wMaxCommand){set_bit(WDM_OVERFLOW, &desc->flags);}else{if(!test_bit(WDM_OVERFLOW, &desc->flags)){memmove(desc->ubuf+desc->length, desc->inbuf, length);desc->length+=length;desc->reslength=length;}}skip_error:\n\twake_up(&desc->wait);set_bit(WDM_READ, &desc->flags);spin_unlock(&desc->iuspin);}"}
{"idx":"cve-2013-1860-CLEAN","target":0,"code":"static void wdm_in_callback(struct urb*urb){struct wdm_device*desc=urb->context;int status=urb->status;spin_lock(&desc->iuspin);clear_bit(WDM_RESPONDING, &desc->flags);if(status){switch(status){case-ENOENT:\n            dev_dbg(&desc->intf->dev, \"nonzero urb status received:-ENOENT\");goto skip_error;case-ECONNRESET:\n            dev_dbg(&desc->intf->dev, \"nonzero urb status received:-ECONNRESET\");goto skip_error;case-ESHUTDOWN:\n            dev_dbg(&desc->intf->dev, \"nonzero urb status received:-ESHUTDOWN\");goto skip_error;case-EPIPE:\n            dev_err(&desc->intf->dev, \"nonzero urb status received:-EPIPE\\n\");break;default:\n            dev_err(&desc->intf->dev, \"Unexpected error%d\\n\", status);break;}}desc->rerr=status;desc->reslength=urb->actual_length;if (desc->reslength <= (desc->bufsize - desc->length)) {memmove(desc->ubuf+desc->length, desc->inbuf, desc->reslength);desc->length+=desc->reslength;}skip_error:\n    wake_up(&desc->wait);set_bit(WDM_READ, &desc->flags);spin_unlock(&desc->iuspin);}"}
{"idx":"cve-2013-2850-BUFFER","target":1,"code":"static int iscsi_add_notunderstood_response(char*key, char*value, struct iscsi_param_list*param_list){struct iscsi_extra_response*extra_response;if(strlen(value)>VALUE_MAXLEN){pr_err(\"Value for notunderstood key \\\"%s\\\" exceeds%d, \"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);return-1;}extra_response=kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);if(!extra_response){pr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");return-1;}INIT_LIST_HEAD(&extra_response->er_list);strncpy(extra_response->key, key, strlen(key)+1);strncpy(extra_response->value, NOTUNDERSTOOD, strlen(NOTUNDERSTOOD)+1);list_add_tail(&extra_response->er_list, &param_list->extra_response_list);return 0;}"}
{"idx":"cve-2013-2850-CLEAN","target":0,"code":"static int iscsi_add_notunderstood_response(char*key, char*value, struct iscsi_param_list*param_list){if(!key || !value || !param_list){pr_err(\"NULL parameter provided.\");return -EINVAL;}struct iscsi_extra_response*extra_response;if(strlen(value)>VALUE_MAXLEN){pr_err(\"Value for notunderstood key \\\"%s\\\" exceeds%d, \"\n\" protocol error.\n\", key, VALUE_MAXLEN);return-1;}extra_response=kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);if(!extra_response){pr_err(\"Unable to allocate memory for\" \" struct iscsi_extra_response.\n\");return-ENOMEM;}INIT_LIST_HEAD(&extra_response->er_list);strlcpy(extra_response->key, key, sizeof(extra_response->key));strlcpy(extra_response->value, NOTUNDERSTOOD, sizeof(extra_response->value));list_add_tail(&extra_response->er_list, &param_list->extra_response_list);return 0;}"}
{"idx":"cve-2013-6367-CLEAN","target":0,"code":"static u32 apic_get_tmcct(struct kvm_lapic *apic) {\n    ktime_t remaining;\n    s64 ns;\n    u32 tmcct;\n    if (apic == NULL) return 0;\n    if (kvm_apic_get_reg(apic, APIC_TMICT) == 0 || apic->lapic_timer.period == 0) return 0;\n    remaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n    if (ktime_to_ns(remaining) < 0) remaining = ktime_set(0, 0);\n    ns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n    tmcct = div64_u64(ns, (APIC_BUS_CYCLE_NS * apic->divide_count));\n    return tmcct;\n}"}
{"idx":"cve-2013-6367-NUMERICAL","target":1,"code":"static u32 apic_get_tmcct(struct kvm_lapic*apic){ktime_t remaining;s64 ns;u32 tmcct;ASSERT(apic != NULL);if(apic_get_reg(apic, APIC_TMICT) == 0)return 0;remaining=hrtimer_get_remaining(&apic->lapic_timer.timer);if(ktime_to_ns(remaining)<0)remaining=ktime_set(0, 0);ns=mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);tmcct=div64_u64(ns, (APIC_BUS_CYCLE_NS*apic->divide_count));return tmcct;}"}
{"idx":"cve-2013-6432-CLEAN","target":0,"code":"int ping_recvmsg(struct kiocb*iocb, struct sock*sk, struct msghdr*msg, size_t len, int noblock, int flags, int*addr_len){\n    struct inet_sock*isk=inet_sk(sk);\n    int family=sk->sk_family;\n    struct sk_buff*skb;\n    int copied, err;\n    pr_debug(\"ping_recvmsg(sk=%p, sk->num=%u)\\n\", isk, isk->inet_num);\n    err=-EOPNOTSUPP;\n    if(flags&MSG_OOB)goto out;\n    if(flags&MSG_ERRQUEUE){\n        if(family == AF_INET){\n            return ip_recv_error(sk, msg, len, addr_len);\n        }else if(family == AF_INET6){\n            return pingv6_ops.ipv6_recv_error(sk, msg, len, addr_len);\n        }\n    }\n    flags &= ~MSG_OOB; \/\/ Clear MSG_OOB to prevent misuse in skb_recv_datagram.\n    skb=skb_recv_datagram(sk, flags, noblock, &err);\n    if(!skb)goto out;\n    copied=skb->len;\n    if(copied>len){\n        msg->msg_flags|=MSG_TRUNC;\n        copied=len;\n    }\n    err=skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n    if(err)goto done;\n    sock_recv_timestamp(msg, sk, skb);\n    if(family == AF_INET){\n        DECLARE_SOCKADDR(struct sockaddr_in*, sin, msg->msg_name);\n        if(sin){\n            sin->sin_family=AF_INET;\n            sin->sin_port=0;\n            sin->sin_addr.s_addr=ip_hdr(skb)->saddr;\n            memset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n            *addr_len=sizeof(*sin);\n        } else {\n            *addr_len=0;\n        }\n        if(isk->cmsg_flags)ip_cmsg_recv(msg, skb);\n    }else if(family == AF_INET6){\n        struct ipv6_pinfo*np=inet6_sk(sk);\n        struct ipv6hdr*ip6=ipv6_hdr(skb);\n        DECLARE_SOCKADDR(struct sockaddr_in6*, sin6, msg->msg_name);\n        if(sin6){\n            sin6->sin6_family=AF_INET6;\n            sin6->sin6_port=0;\n            sin6->sin6_addr=ip6->saddr;\n            sin6->sin6_flowinfo=0;\n            if(np->sndflow)sin6->sin6_flowinfo=ip6_flowinfo(ip6);\n            sin6->sin6_scope_id=ipv6_iface_scope_id(&sin6->sin6_addr, IP6CB(skb)->iif);\n            *addr_len=sizeof(*sin6);\n        } else {\n            *addr_len=0;\n        }\n        if(inet6_sk(sk)->rxopt.all)pingv6_ops.ip6_datagram_recv_common_ctl(sk, msg, skb);\n        if(skb->protocol == htons(ETH_P_IPV6) && inet6_sk(sk)->rxopt.all)pingv6_ops.ip6_datagram_recv_specific_ctl(sk, msg, skb);\n        else if(skb->protocol == htons(ETH_P_IP) && isk->cmsg_flags)ip_cmsg_recv(msg, skb);\n    }else{\n        BUG();\n    }\n    err=copied;\n    done:\n    skb_free_datagram(sk, skb);\n    out:\n    pr_debug(\"ping_recvmsg->%d\\n\", err);\n    return err;\n}"}
{"idx":"cve-2013-6432-MEMORY","target":1,"code":"int ping_recvmsg(struct kiocb*iocb, struct sock*sk, struct msghdr*msg, size_t len, int noblock, int flags, int*addr_len){struct inet_sock*isk=inet_sk(sk);int family=sk->sk_family;struct sockaddr_in*sin;struct sockaddr_in6*sin6;struct sk_buff*skb;int copied, err;pr_debug(\"ping_recvmsg(sk=%p, sk->num=%u)\\n\", isk, isk->inet_num);err=-EOPNOTSUPP;if(flags&MSG_OOB)goto out;if(addr_len){if(family == AF_INET)*addr_len=sizeof(*sin);else if(family == AF_INET6 && addr_len)*addr_len=sizeof(*sin6);}if(flags&MSG_ERRQUEUE){if(family == AF_INET){return ip_recv_error(sk, msg, len);}else if(family == AF_INET6){return pingv6_ops.ipv6_recv_error(sk, msg, len);}}skb=skb_recv_datagram(sk, flags, noblock, &err);if(!skb)goto out;copied=skb->len;if(copied>len){msg->msg_flags|=MSG_TRUNC;copied=len;}err=skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);if(err)goto done;sock_recv_timestamp(msg, sk, skb);if(family == AF_INET){sin=(struct sockaddr_in*)msg->msg_name;sin->sin_family=AF_INET;sin->sin_port=0;sin->sin_addr.s_addr=ip_hdr(skb)->saddr;memset(sin->sin_zero, 0, sizeof(sin->sin_zero));if(isk->cmsg_flags)ip_cmsg_recv(msg, skb);}else if(family == AF_INET6){struct ipv6_pinfo*np=inet6_sk(sk);struct ipv6hdr*ip6=ipv6_hdr(skb);sin6=(struct sockaddr_in6*)msg->msg_name;sin6->sin6_family=AF_INET6;sin6->sin6_port=0;sin6->sin6_addr=ip6->saddr;sin6->sin6_flowinfo=0;if(np->sndflow)sin6->sin6_flowinfo=ip6_flowinfo(ip6);sin6->sin6_scope_id=ipv6_iface_scope_id(&sin6->sin6_addr, IP6CB(skb)->iif);if(inet6_sk(sk)->rxopt.all)pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);}else{BUG();}err=copied;done:\n\tskb_free_datagram(sk, skb);out:\n\tpr_debug(\"ping_recvmsg->%d\\n\", err);return err;}"}
{"idx":"cve-2013-7348-CLEAN","target":0,"code":"static struct kioctx* ioctx_alloc(unsigned nr_events) {\n    struct mm_struct* mm = current->mm;\n    struct kioctx* ctx;\n    int err = -ENOMEM;\n    nr_events = max(nr_events, num_possible_cpus() * 4);\n    if (__builtin_mul_overflow(nr_events, 2, &nr_events)) {\n        return ERR_PTR(-EOVERFLOW);\n    }\n    if ((nr_events > (0x10000000U \/ sizeof(struct io_event))) || (nr_events > (0x10000000U \/ sizeof(struct kiocb)))) {\n        pr_debug(\"ENOMEM: nr_events too high\\n\");\n        return ERR_PTR(-EINVAL);\n    }\n    if (!nr_events || (unsigned long)nr_events > (aio_max_nr * 2UL))\n        return ERR_PTR(-EAGAIN);\n    ctx = kmem_cache_zalloc(kioctx_cachep, GFP_KERNEL);\n    if (!ctx)\n        return ERR_PTR(-ENOMEM);\n    ctx->max_reqs = nr_events;\n    spin_lock_init(&ctx->ctx_lock);\n    spin_lock_init(&ctx->completion_lock);\n    mutex_init(&ctx->ring_lock);\n    mutex_lock(&ctx->ring_lock);\n    init_waitqueue_head(&ctx->wait);\n    INIT_LIST_HEAD(&ctx->active_reqs);\n    if (percpu_ref_init(&ctx->users, free_ioctx_users))\n        goto err;\n    if (percpu_ref_init(&ctx->reqs, free_ioctx_reqs))\n        goto err;\n    ctx->cpu = alloc_percpu(struct kioctx_cpu);\n    if (!ctx->cpu)\n        goto err;\n    err = aio_setup_ring(ctx);\n    if (err < 0)\n        goto err;\n    atomic_set(&ctx->reqs_available, ctx->nr_events - 1);\n    ctx->req_batch = (ctx->nr_events - 1) \/ (num_possible_cpus() * 4);\n    if (ctx->req_batch < 1)\n        ctx->req_batch = 1;\n    spin_lock(&aio_nr_lock);\n    if (__builtin_add_overflow(aio_nr, nr_events, &aio_nr) || aio_nr > (aio_max_nr * 2UL)) {\n        spin_unlock(&aio_nr_lock);\n        err = -EAGAIN;\n        goto err_ctx;\n    }\n    aio_nr += ctx->max_reqs;\n    spin_unlock(&aio_nr_lock);\n    percpu_ref_get(&ctx->users);\n    percpu_ref_get(&ctx->reqs);\n    err = ioctx_add_table(ctx, mm);\n    if (err)\n        goto err_cleanup;\n    mutex_unlock(&ctx->ring_lock);\n    pr_debug(\"allocated ioctx%p[%ld]: mm=%p mask=0x%x\\n\", ctx, ctx->user_id, mm, ctx->nr_events);\n    return ctx;\n    err_cleanup:\n    aio_nr_sub(ctx->max_reqs);\n    err_ctx:\n    aio_free_ring(ctx);\n    err:\n    mutex_unlock(&ctx->ring_lock);\n    free_percpu(ctx->cpu);\n    free_percpu(ctx->reqs.pcpu_count);\n    free_percpu(ctx->users.pcpu_count);\n    kmem_cache_free(kioctx_cachep, ctx);\n    pr_debug(\"error allocating ioctx%d\\n\", err);\n    return ERR_PTR(err);\n}"}
{"idx":"cve-2013-7348-MEMORY","target":1,"code":"static struct kioctx*ioctx_alloc(unsigned nr_events){struct mm_struct*mm=current->mm;struct kioctx*ctx;int err=-ENOMEM;nr_events=max(nr_events, num_possible_cpus()*4);nr_events*=2;if((nr_events>(0x10000000U\/sizeof(struct io_event))) || (nr_events>(0x10000000U\/sizeof(struct kiocb)))){pr_debug(\"ENOMEM: nr_events too high\\n\");return ERR_PTR(-EINVAL);}if(!nr_events || (unsigned long)nr_events>(aio_max_nr*2UL))return ERR_PTR(-EAGAIN);ctx=kmem_cache_zalloc(kioctx_cachep, GFP_KERNEL);if(!ctx)return ERR_PTR(-ENOMEM);ctx->max_reqs=nr_events;if(percpu_ref_init(&ctx->users, free_ioctx_users))goto err;if(percpu_ref_init(&ctx->reqs, free_ioctx_reqs))goto err;spin_lock_init(&ctx->ctx_lock);spin_lock_init(&ctx->completion_lock);mutex_init(&ctx->ring_lock);init_waitqueue_head(&ctx->wait);INIT_LIST_HEAD(&ctx->active_reqs);ctx->cpu=alloc_percpu(struct kioctx_cpu);if(!ctx->cpu)goto err;if(aio_setup_ring(ctx)<0)goto err;atomic_set(&ctx->reqs_available, ctx->nr_events-1);ctx->req_batch=(ctx->nr_events-1)\/(num_possible_cpus()*4);if(ctx->req_batch<1)ctx->req_batch=1;spin_lock(&aio_nr_lock);if(aio_nr+nr_events>(aio_max_nr*2UL) || aio_nr+nr_events<aio_nr){spin_unlock(&aio_nr_lock);err=-EAGAIN;goto err;}aio_nr+=ctx->max_reqs;spin_unlock(&aio_nr_lock);percpu_ref_get(&ctx->users);err=ioctx_add_table(ctx, mm);if(err)goto err_cleanup;pr_debug(\"allocated ioctx%p[%ld]: mm=%p mask=0x%x\\n\", ctx, ctx->user_id, mm, ctx->nr_events);return ctx;err_cleanup:\n\taio_nr_sub(ctx->max_reqs);err:\n\tfree_percpu(ctx->cpu);free_percpu(ctx->reqs.pcpu_count);free_percpu(ctx->users.pcpu_count);kmem_cache_free(kioctx_cachep, ctx);pr_debug(\"error allocating ioctx%d\\n\", err);return ERR_PTR(err);}"}
{"idx":"cve-2014-8884-BUFFER","target":1,"code":"static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend*fe, struct dvb_diseqc_master_cmd*cmd){struct ttusbdecfe_state*state=(struct ttusbdecfe_state*)fe->demodulator_priv;u8 b[]={0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};memcpy(&b[4], cmd->msg, cmd->msg_len);state->config->send_command(fe, 0x72, sizeof(b)-(6-cmd->msg_len), b, NULL, NULL);return 0;}"}
{"idx":"cve-2014-8884-CLEAN","target":0,"code":"static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend*fe, struct dvb_diseqc_master_cmd*cmd){\n    struct ttusbdecfe_state*state=(struct ttusbdecfe_state*)fe->demodulator_priv;\n    u8 b[]={0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    if(cmd->msg_len>sizeof(b)-4)return-EINVAL;\n    memcpy(&b[4], cmd->msg, cmd->msg_len);\n    state->config->send_command(fe, 0x72, sizeof(b)-(6-cmd->msg_len), b, NULL, NULL);\n    return 0;\n}"}
{"idx":"cve-2014-9904-CLEAN","target":0,"code":"static int snd_compress_check_input(struct snd_compr_params*params){if(params->buffer.fragment_size <= 0 || params->buffer.fragments>INT_MAX\/params->buffer.fragment_size)return-EINVAL;if(params->codec.id == 0 || params->codec.id>SND_AUDIOCODEC_MAX)return-EINVAL;if(params->codec.ch_in == 0 || params->codec.ch_out == 0)return-EINVAL;return 0;}"}
{"idx":"cve-2014-9904-NUMERICAL","target":1,"code":"static int snd_compress_check_input(struct snd_compr_params*params){if(params->buffer.fragment_size == 0 || params->buffer.fragments>SIZE_MAX\/params->buffer.fragment_size)return-EINVAL;if(params->codec.id == 0 || params->codec.id>SND_AUDIOCODEC_MAX)return-EINVAL;if(params->codec.ch_in == 0 || params->codec.ch_out == 0)return-EINVAL;if(!(params->codec.sample_rate&SNDRV_PCM_RATE_8000_192000))return-EINVAL;return 0;}"}
{"idx":"cve-2015-2666-BUFFER","target":1,"code":"static enum ucode_state __init\nget_matching_model_microcode(int cpu, unsigned long start, void*data, size_t size, struct mc_saved_data*mc_saved_data, unsigned long*mc_saved_in_initrd, struct ucode_cpu_info*uci){u8*ucode_ptr=data;unsigned int leftover=size;enum ucode_state state=UCODE_OK;unsigned int mc_size;struct microcode_header_intel*mc_header;struct microcode_intel*mc_saved_tmp[MAX_UCODE_COUNT];unsigned int mc_saved_count=mc_saved_data->mc_saved_count;int i;while(leftover){mc_header=(struct microcode_header_intel*)ucode_ptr;mc_size=get_totalsize(mc_header);if(!mc_size || mc_size>leftover || microcode_sanity_check(ucode_ptr, 0)<0)break;leftover-=mc_size;if(matching_model_microcode(mc_header, uci->cpu_sig.sig) != UCODE_OK){ucode_ptr+=mc_size;continue;}_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);ucode_ptr+=mc_size;}if(leftover){state=UCODE_ERROR;goto out;}if(mc_saved_count == 0){state=UCODE_NFOUND;goto out;}for(i=0;i<mc_saved_count;i++)mc_saved_in_initrd[i]=(unsigned long)mc_saved_tmp[i]-start;mc_saved_data->mc_saved_count=mc_saved_count;out:\n\treturn state;}"}
{"idx":"cve-2015-2666-CLEAN","target":0,"code":"static enum ucode_state __init get_matching_model_microcode(int cpu, unsigned long start, void*data, size_t size, struct mc_saved_data*mc_saved_data, unsigned long*mc_saved_in_initrd, struct ucode_cpu_info*uci){u8*ucode_ptr=data;unsigned int leftover=size;enum ucode_state state=UCODE_OK;unsigned int mc_size;struct microcode_header_intel*mc_header;struct microcode_intel*mc_saved_tmp[MAX_UCODE_COUNT];unsigned int mc_saved_count=mc_saved_data->mc_saved_count;int i;while(leftover && mc_saved_count<ARRAY_SIZE(mc_saved_tmp)){if(leftover<sizeof(struct microcode_header_intel))break;mc_header=(struct microcode_header_intel*)ucode_ptr;mc_size=get_totalsize(mc_header);if(!mc_size || mc_size>leftover || microcode_sanity_check(ucode_ptr, 0)<0)break;leftover-=mc_size;if(matching_model_microcode(mc_header, uci->cpu_sig.sig) != UCODE_OK){ucode_ptr+=mc_size;continue;}mc_saved_count=_save_mc(mc_saved_tmp, ucode_ptr, mc_saved_count);ucode_ptr+=mc_size;}if(leftover){state=UCODE_ERROR;goto out;}if(mc_saved_count == 0){state=UCODE_NFOUND;goto out;}for(i=0;i<mc_saved_count;i++)mc_saved_in_initrd[i]=(unsigned long)mc_saved_tmp[i]-start;mc_saved_data->mc_saved_count=mc_saved_count;out: return state;}"}
{"idx":"cve-2015-4003-CLEAN","target":0,"code":"static void oz_usb_handle_ep_data(struct oz_usb_ctx*usb_ctx, struct oz_usb_hdr*usb_hdr, int len){\n    struct oz_data*data_hdr=(struct oz_data*)usb_hdr;\n    switch(data_hdr->format){\n    case OZ_DATA_F_MULTIPLE_FIXED:{\n        struct oz_multiple_fixed*body=(struct oz_multiple_fixed*)data_hdr;\n        u8*data=body->data;\n        unsigned int n;\n        if(!body->unit_size || len<sizeof(struct oz_multiple_fixed))break;\n        n=(len-sizeof(struct oz_multiple_fixed))\/body->unit_size;\n        while(n--){\n            if (data + body->unit_size > ((u8*)usb_hdr + len)) break;\n            oz_hcd_data_ind(usb_ctx->hport, body->endpoint, data, body->unit_size);\n            data+=body->unit_size;\n        }\n        break;\n    }\n    case OZ_DATA_F_ISOC_FIXED:{\n        struct oz_isoc_fixed*body=(struct oz_isoc_fixed*)data_hdr;\n        int data_len;\n        int unit_size=body->unit_size;\n        u8*data=body->data;\n        int count;\n        int i;\n        if(len<sizeof(struct oz_isoc_fixed))break;\n        data_len=len-sizeof(struct oz_isoc_fixed);\n        if(!unit_size)break;\n        count=data_len\/unit_size;\n        for(i=0;i<count;i++){\n            if (data + unit_size > ((u8*)usb_hdr + len)) break;\n            oz_hcd_data_ind(usb_ctx->hport, body->endpoint, data, unit_size);\n            data+=unit_size;\n        }\n        break;\n    }\n    }\n}"}
{"idx":"cve-2015-4003-NUMERICAL","target":1,"code":"static void oz_usb_handle_ep_data(struct oz_usb_ctx*usb_ctx, struct oz_usb_hdr*usb_hdr, int len){struct oz_data*data_hdr=(struct oz_data*)usb_hdr;switch(data_hdr->format){case OZ_DATA_F_MULTIPLE_FIXED:{struct oz_multiple_fixed*body=(struct oz_multiple_fixed*)data_hdr;u8*data=body->data;int n=(len-sizeof(struct oz_multiple_fixed)+1)\/body->unit_size;while(n--){oz_hcd_data_ind(usb_ctx->hport, body->endpoint, data, body->unit_size);data+=body->unit_size;}}break;case OZ_DATA_F_ISOC_FIXED:{struct oz_isoc_fixed*body=(struct oz_isoc_fixed*)data_hdr;int data_len=len-sizeof(struct oz_isoc_fixed)+1;int unit_size=body->unit_size;u8*data=body->data;int count;int i;if(!unit_size)break;count=data_len\/unit_size;for(i=0;i<count;i++){oz_hcd_data_ind(usb_ctx->hport, body->endpoint, data, unit_size);data+=unit_size;}}break;}}"}
{"idx":"cve-2015-8962-CLEAN","target":0,"code":"static int sg_common_write(Sg_fd *sfp, Sg_request *srp, unsigned char *cmnd, int timeout, int blocking) {\n    int k, at_head;\n    Sg_device *sdp = sfp->parentdp;\n    sg_io_hdr_t *hp = &srp->header;\n    if (!cmnd) return -EINVAL;\n    srp->data.cmd_opcode = cmnd[0];\n    hp->status = 0;\n    hp->masked_status = 0;\n    hp->msg_status = 0;\n    hp->info = 0;\n    hp->host_status = 0;\n    hp->driver_status = 0;\n    hp->resid = 0;\n    SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp, \"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\", (int)cmnd[0], (int)hp->cmd_len));\n    k = sg_start_req(srp, cmnd);\n    if (k) {\n        SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp, \"sg_common_write: start_req err=%d\\n\", k));\n        sg_finish_rem_req(srp);\n        return k;\n    }\n    if (atomic_read(&sdp->detaching)) {\n        if (srp->bio) {\n            if (srp->rq && srp->rq->cmd != srp->rq->__cmd) kfree(srp->rq->cmd);\n            if (srp->rq) blk_end_request_all(srp->rq, -EIO);\n            srp->rq = NULL;\n        }\n        sg_finish_rem_req(srp);\n        return -ENODEV;\n    }\n    hp->duration = jiffies_to_msecs(jiffies);\n    if (hp->interface_id != '\\0' && (SG_FLAG_Q_AT_TAIL & hp->flags)) at_head = 0;\n    else at_head = 1;\n    if (!sdp->device) return -ENODEV;\n    srp->rq->timeout = timeout;\n    kref_get(&sfp->f_ref);\n    blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk, srp->rq, at_head, sg_rq_end_io);\n    return 0;\n}"}
{"idx":"cve-2015-8962-MEMORY","target":1,"code":"static int\nsg_common_write(Sg_fd*sfp, Sg_request*srp, unsigned char*cmnd, int timeout, int blocking){int k, data_dir;Sg_device*sdp=sfp->parentdp;sg_io_hdr_t*hp=&srp->header;srp->data.cmd_opcode=cmnd[0];hp->status=0;hp->masked_status=0;hp->msg_status=0;hp->info=0;hp->host_status=0;hp->driver_status=0;hp->resid=0;SCSI_LOG_TIMEOUT(4, printk(\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\", (int)cmnd[0], (int)hp->cmd_len));k=sg_start_req(srp, cmnd);if(k){SCSI_LOG_TIMEOUT(1, printk(\"sg_common_write: start_req err=%d\\n\", k));sg_finish_rem_req(srp);return k;}if(sdp->detached){if(srp->bio)blk_end_request_all(srp->rq, -EIO);sg_finish_rem_req(srp);return-ENODEV;}switch(hp->dxfer_direction){case SG_DXFER_TO_FROM_DEV:\n\tcase SG_DXFER_FROM_DEV:\n\t\tdata_dir=DMA_FROM_DEVICE;break;case SG_DXFER_TO_DEV:\n\t\tdata_dir=DMA_TO_DEVICE;break;case SG_DXFER_UNKNOWN:\n\t\tdata_dir=DMA_BIDIRECTIONAL;break;default:\n\t\tdata_dir=DMA_NONE;break;}hp->duration=jiffies_to_msecs(jiffies);srp->rq->timeout=timeout;kref_get(&sfp->f_ref);blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk, srp->rq, 1, sg_rq_end_io);return 0;}"}
{"idx":"cve-2016-3135-CLEAN","target":0,"code":"struct xt_table_info* xt_alloc_table_info(unsigned int size) {\n    struct xt_table_info* info = NULL;\n    if (size > UINT_MAX - sizeof(*info)) return NULL;\n    size_t sz = sizeof(*info) + size;\n    if (sz < sizeof(*info)) return NULL;\n    if ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages) return NULL;\n    if (sz == 0) return NULL;\n    if (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n        info = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n    if (!info) {\n        info = __vmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY | __GFP_HIGHMEM, PAGE_KERNEL);\n        if (!info) return NULL;\n    }\n    memset(info, 0, sizeof(*info));\n    info->size = size;\n    return info;\n}"}
{"idx":"cve-2016-3135-NUMERICAL","target":1,"code":"struct xt_table_info*xt_alloc_table_info(unsigned int size){struct xt_table_info*info=NULL;size_t sz=sizeof(*info)+size;if((SMP_ALIGN(size)>>PAGE_SHIFT)+2>totalram_pages)return NULL;if(sz <= (PAGE_SIZE<<PAGE_ALLOC_COSTLY_ORDER))info=kmalloc(sz, GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY);if(!info){info=vmalloc(sz);if(!info)return NULL;}memset(info, 0, sizeof(*info));info->size=size;return info;}"}
{"idx":"cve-2016-8636-CLEAN","target":0,"code":"int mem_check_range(struct rxe_mem* mem, u64 iova, size_t length) {\n    switch (mem->type) {\n        case RXE_MEM_TYPE_DMA:\n            return 0;\n        case RXE_MEM_TYPE_MR:\n        case RXE_MEM_TYPE_FMR:\n            if (iova < mem->iova || length > mem->length || iova > mem->iova + mem->length - length)\n                return -EFAULT;\n            return 0;\n        default:\n            return -EFAULT;\n    }\n}"}
{"idx":"cve-2016-8636-NUMERICAL","target":1,"code":"int mem_check_range(struct rxe_mem*mem, u64 iova, size_t length){switch(mem->type){case RXE_MEM_TYPE_DMA:\n\t\treturn 0;case RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn((iova<mem->iova) || ((iova+length)>(mem->iova+mem->length)))?-EFAULT : 0;default:\n\t\treturn-EFAULT;}}"}
{"idx":"cve-2016-9806-CLEAN","target":0,"code":"static int netlink_dump(struct sock*sk){struct netlink_sock*nlk=nlk_sk(sk);struct netlink_callback*cb;struct sk_buff*skb=NULL;struct nlmsghdr*nlh;struct module*module;int len, err=-ENOBUFS;int alloc_min_size;int alloc_size;mutex_lock(nlk->cb_mutex);if(!nlk->cb_running){err=-EINVAL;goto errout_skb;}if(atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)goto errout_skb;cb=&nlk->cb;alloc_min_size=max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);if(alloc_min_size<nlk->max_recvmsg_len){alloc_size=nlk->max_recvmsg_len;skb=alloc_skb(alloc_size, (GFP_KERNEL&~__GFP_DIRECT_RECLAIM)|__GFP_NOWARN|__GFP_NORETRY);}if(!skb){alloc_size=alloc_min_size;skb=alloc_skb(alloc_size, GFP_KERNEL);}if(!skb)goto errout_skb;skb_reserve(skb, max(0, skb_tailroom(skb)-alloc_size));netlink_skb_set_owner_r(skb, sk);len=cb->dump(skb, cb);if(len>0){mutex_unlock(nlk->cb_mutex);if(sk_filter(sk, skb))kfree_skb(skb);else __netlink_sendskb(sk, skb);return 0;}nlh=nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);if(!nlh){kfree_skb(skb);goto errout_skb;}nl_dump_check_consistent(cb, nlh);memcpy(nlmsg_data(nlh), &len, sizeof(len));if(sk_filter(sk, skb))kfree_skb(skb);else __netlink_sendskb(sk, skb);if(cb->done)cb->done(cb);nlk->cb_running=false;module=cb->module;skb=cb->skb;mutex_unlock(nlk->cb_mutex);module_put(module);consume_skb(skb);return 0;errout_skb: mutex_unlock(nlk->cb_mutex);kfree_skb(skb);return err;}"}
{"idx":"cve-2016-9806-MEMORY","target":1,"code":"static int netlink_dump(struct sock*sk){struct netlink_sock*nlk=nlk_sk(sk);struct netlink_callback*cb;struct sk_buff*skb=NULL;struct nlmsghdr*nlh;int len, err=-ENOBUFS;int alloc_size;mutex_lock(nlk->cb_mutex);if(!nlk->cb_running){err=-EINVAL;goto errout_skb;}cb=&nlk->cb;alloc_size=max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);if(!netlink_rx_is_mmaped(sk) && atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)goto errout_skb;skb=netlink_alloc_skb(sk, alloc_size, nlk->portid, GFP_KERNEL);if(!skb)goto errout_skb;netlink_skb_set_owner_r(skb, sk);len=cb->dump(skb, cb);if(len>0){mutex_unlock(nlk->cb_mutex);if(sk_filter(sk, skb))kfree_skb(skb);else\n\t\t\t__netlink_sendskb(sk, skb);return 0;}nlh=nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);if(!nlh)goto errout_skb;nl_dump_check_consistent(cb, nlh);memcpy(nlmsg_data(nlh), &len, sizeof(len));if(sk_filter(sk, skb))kfree_skb(skb);else\n\t\t__netlink_sendskb(sk, skb);if(cb->done)cb->done(cb);nlk->cb_running=false;mutex_unlock(nlk->cb_mutex);module_put(cb->module);consume_skb(cb->skb);return 0;errout_skb:\n\tmutex_unlock(nlk->cb_mutex);kfree_skb(skb);return err;}"}
{"idx":"cve-2017-1000363-BUFFER","target":1,"code":"static int __init lp_setup(char*str){static int parport_ptr;int x;if(get_option(&str, &x)){if(x == 0){parport_nr[0]=LP_PARPORT_OFF;}else{printk(KERN_WARNING \"warning: 'lp=0x%x' is deprecated, ignored\\n\", x);return 0;}}else if(!strncmp(str, \"parport\", 7)){int n=simple_strtoul(str+7, NULL, 10);if(parport_ptr<LP_NO)parport_nr[parport_ptr++]=n;else\n\t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\", str);}else if(!strcmp(str, \"auto\")){parport_nr[0]=LP_PARPORT_AUTO;}else if(!strcmp(str, \"none\")){parport_nr[parport_ptr++]=LP_PARPORT_NONE;}else if(!strcmp(str, \"reset\")){reset=1;}return 1;}"}
{"idx":"cve-2017-1000363-CLEAN","target":0,"code":"static int __init lp_setup(char *str) {\n    static int parport_ptr;\n    int x;\n    if (get_option(&str, &x)) {\n        if (x == 0) {\n            parport_nr[0] = LP_PARPORT_OFF;\n        } else {\n            printk(KERN_WARNING \"warning: 'lp=0x%x' is deprecated, ignored\\n\", x);\n            return 0;\n        }\n    } else if (!strncmp(str, \"parport\", 7) && str[7] == '\\0') {\n        int n = simple_strtoul(str + 7, NULL, 10);\n        if (parport_ptr < LP_NO)\n            parport_nr[parport_ptr++] = n;\n        else \n            printk(KERN_INFO \"lp: too many ports, %s ignored.\\n\", str);\n    } else if (!strcmp(str, \"auto\")) {\n        parport_nr[0] = LP_PARPORT_AUTO;\n    } else if (!strcmp(str, \"none\")) {\n        if (parport_ptr < LP_NO)\n            parport_nr[parport_ptr++] = LP_PARPORT_NONE;\n        else \n            printk(KERN_INFO \"lp: too many ports, %s ignored.\\n\", str);\n    } else if (!strcmp(str, \"reset\")) {\n        reset = true;\n    }\n    return 1;\n}"}
{"idx":"cve-2017-10662-BUFFER","target":1,"code":"static int sanity_check_raw_super(struct super_block*sb, struct f2fs_super_block*raw_super){unsigned int blocksize;if(F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)){f2fs_msg(sb, KERN_INFO, \"Magic Mismatch, valid(0x%x)-read(0x%x)\", F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));return 1;}if(F2FS_BLKSIZE != PAGE_CACHE_SIZE){f2fs_msg(sb, KERN_INFO, \"Invalid page_cache_size(%lu), supports only 4KB\\n\", PAGE_CACHE_SIZE);return 1;}blocksize=1<<le32_to_cpu(raw_super->log_blocksize);if(blocksize != F2FS_BLKSIZE){f2fs_msg(sb, KERN_INFO, \"Invalid blocksize(%u), supports only 4KB\\n\", blocksize);return 1;}if(le32_to_cpu(raw_super->log_sectorsize)>F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu(raw_super->log_sectorsize)<F2FS_MIN_LOG_SECTOR_SIZE){f2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize(%u)\", le32_to_cpu(raw_super->log_sectorsize));return 1;}if(le32_to_cpu(raw_super->log_sectors_per_block)+le32_to_cpu(raw_super->log_sectorsize) != F2FS_MAX_LOG_SECTOR_SIZE){f2fs_msg(sb, KERN_INFO, \"Invalid log sectors per block(%u)log sectorsize(%u)\", le32_to_cpu(raw_super->log_sectors_per_block), le32_to_cpu(raw_super->log_sectorsize));return 1;}return 0;}"}
{"idx":"cve-2017-10662-CLEAN","target":0,"code":"static int sanity_check_raw_super(struct f2fs_sb_info *sbi, struct buffer_head *bh) {\n    if (!sbi || !bh || !bh->b_data) return 1;\n    struct f2fs_super_block *raw_super = (struct f2fs_super_block *)(bh->b_data + F2FS_SUPER_OFFSET);\n    struct super_block *sb = sbi->sb;\n    unsigned int blocksize;\n    if (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n        f2fs_msg(sb, KERN_INFO, \"Magic Mismatch, valid(0x%x)-read(0x%x)\", F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n        return 1;\n    }\n    if (F2FS_BLKSIZE != PAGE_SIZE) {\n        f2fs_msg(sb, KERN_INFO, \"Invalid page_cache_size(%lu), supports only 4KB\\n\", PAGE_SIZE);\n        return 1;\n    }\n    blocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n    if (blocksize != F2FS_BLKSIZE) {\n        f2fs_msg(sb, KERN_INFO, \"Invalid blocksize(%u), supports only 4KB\\n\", blocksize);\n        return 1;\n    }\n    if (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n        f2fs_msg(sb, KERN_INFO, \"Invalid log blocks per segment(%u)\\n\", le32_to_cpu(raw_super->log_blocks_per_seg));\n        return 1;\n    }\n    if (le32_to_cpu(raw_super->log_sectorsize) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu(raw_super->log_sectorsize) < F2FS_MIN_LOG_SECTOR_SIZE) {\n        f2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize(%u)\", le32_to_cpu(raw_super->log_sectorsize));\n        return 1;\n    }\n    if (le32_to_cpu(raw_super->log_sectors_per_block) + le32_to_cpu(raw_super->log_sectorsize) != F2FS_MAX_LOG_SECTOR_SIZE) {\n        f2fs_msg(sb, KERN_INFO, \"Invalid log sectors per block(%u)log sectorsize(%u)\", le32_to_cpu(raw_super->log_sectors_per_block), le32_to_cpu(raw_super->log_sectorsize));\n        return 1;\n    }\n    if (le32_to_cpu(raw_super->node_ino) != 1 || le32_to_cpu(raw_super->meta_ino) != 2 || le32_to_cpu(raw_super->root_ino) != 3) {\n        f2fs_msg(sb, KERN_INFO, \"Invalid Fs Meta Ino: node(%u)meta(%u)root(%u)\", le32_to_cpu(raw_super->node_ino), le32_to_cpu(raw_super->meta_ino), le32_to_cpu(raw_super->root_ino));\n        return 1;\n    }\n    if (le32_to_cpu(raw_super->segment_count) > F2FS_MAX_SEGMENT) {\n        f2fs_msg(sb, KERN_INFO, \"Invalid segment count(%u)\", le32_to_cpu(raw_super->segment_count));\n        return 1;\n    }\n    if (sanity_check_area_boundary(sbi, bh))\n        return 1;\n    return 0;\n}"}
{"idx":"cve-2017-16650-CLEAN","target":0,"code":"static int qmi_wwan_bind(struct usbnet*dev, struct usb_interface*intf){\n    int status=-1;\n    u8*buf=intf->cur_altsetting->extra;\n    int len=intf->cur_altsetting->extralen;\n    struct usb_interface_descriptor*desc=&intf->cur_altsetting->desc;\n    struct usb_cdc_union_desc*cdc_union;\n    struct usb_cdc_ether_desc*cdc_ether;\n    struct usb_driver*driver=driver_of(intf);\n    struct qmi_wwan_state*info=(void*)&dev->data;\n    struct usb_cdc_parsed_header hdr;\n    BUILD_BUG_ON((sizeof(((struct usbnet*)0)->data)<sizeof(struct qmi_wwan_state)));\n    info->control=intf;\n    info->data=intf;\n    if (len > 0) {\n        cdc_parse_cdc_header(&hdr, intf, buf, len);\n        cdc_union=hdr.usb_cdc_union_desc;\n        cdc_ether=hdr.usb_cdc_ether_desc;\n    }\n    if(cdc_union){\n        info->data=usb_ifnum_to_if(dev->udev, cdc_union->bSlaveInterface0);\n        if (!info->data || desc->bInterfaceNumber != cdc_union->bMasterInterface0){\n            dev_err(&intf->dev, \"bogus CDC Union: master=%u, slave=%u\\n\", cdc_union->bMasterInterface0, cdc_union->bSlaveInterface0);\n            cdc_union=NULL;\n            info->data=intf;\n        }\n    }\n    if(cdc_ether && cdc_ether->wMaxSegmentSize){\n        dev->hard_mtu=le16_to_cpu(cdc_ether->wMaxSegmentSize);\n        usbnet_get_ethernet_addr(dev, cdc_ether->iMACAddress);\n    }\n    if(info->control != info->data){\n        status=usb_driver_claim_interface(driver, info->data, dev);\n        if(status<0)goto err;\n    }\n    status=qmi_wwan_register_subdriver(dev);\n    if(status<0 && info->control != info->data){\n        usb_set_intfdata(info->data, NULL);\n        usb_driver_release_interface(driver, info->data);\n    }\n    if(dev->driver_info->data&QMI_WWAN_QUIRK_DTR || le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201){\n        qmi_wwan_manage_power(dev, 1);\n        qmi_wwan_change_dtr(dev, true);\n    }\n    if(ether_addr_equal(dev->net->dev_addr, default_modem_addr) || ether_addr_equal(dev->net->dev_addr, buggy_fw_addr))\n        eth_hw_addr_random(dev->net);\n    if(possibly_iphdr(dev->net->dev_addr)){\n        dev->net->dev_addr[0]|=0x02;\n        dev->net->dev_addr[0]&=0xbf;\n    }\n    dev->net->netdev_ops=&qmi_wwan_netdev_ops;\n    dev->net->sysfs_groups[0]=&qmi_wwan_sysfs_attr_group;\n    err:\n    return status;\n}"}
{"idx":"cve-2017-17975-CLEAN","target":0,"code":"static int usbtv_probe(struct usb_interface *intf, const struct usb_device_id *id) {\n    int ret;\n    int size;\n    struct device *dev = &intf->dev;\n    struct usbtv *usbtv;\n    struct usb_host_endpoint *ep;\n    if (intf->num_altsetting != 2)\n        return -ENODEV;\n    if (intf->altsetting[1].desc.bNumEndpoints != 4)\n        return -ENODEV;\n    ep = &intf->altsetting[1].endpoint[0];\n    size = usb_endpoint_maxp(&ep->desc);\n    size = size * usb_endpoint_maxp_mult(&ep->desc);\n    usbtv = kzalloc(sizeof(struct usbtv), GFP_KERNEL);\n    if (usbtv == NULL)\n        return -ENOMEM;\n    usbtv->dev = dev;\n    usbtv->udev = usb_get_dev(interface_to_usbdev(intf));\n    usbtv->iso_size = size;\n    usb_set_intfdata(intf, usbtv);\n    ret = usbtv_video_init(usbtv);\n    if (ret < 0)\n        goto usbtv_video_fail;\n    ret = usbtv_audio_init(usbtv);\n    if (ret < 0)\n        goto usbtv_audio_fail;\n    v4l2_device_get(&usbtv->v4l2_dev);\n    dev_info(dev, \"Fushicai USBTV007 Audio-Video Grabber\\n\");\n    return 0;\nusbtv_audio_fail:\n    usb_put_dev(usbtv->udev);\n    usbtv_video_free(usbtv);\nusbtv_video_fail:\n    usb_set_intfdata(intf, NULL);\n    usb_put_dev(usbtv->udev);\n    kfree(usbtv);\n    return ret;\n}"}
{"idx":"cve-2017-17975-MEMORY","target":1,"code":"static int usbtv_probe(struct usb_interface*intf, const struct usb_device_id*id){int ret;int size;struct device*dev=&intf->dev;struct usbtv*usbtv;if(intf->num_altsetting != 2)return-ENODEV;if(intf->altsetting[1].desc.bNumEndpoints != 4)return-ENODEV;size=usb_endpoint_maxp(&intf->altsetting[1].endpoint[0].desc);size=(size&0x07ff)*(((size&0x1800)>>11)+1);usbtv=kzalloc(sizeof(struct usbtv), GFP_KERNEL);if(usbtv == NULL)return-ENOMEM;usbtv->dev=dev;usbtv->udev=usb_get_dev(interface_to_usbdev(intf));usbtv->iso_size=size;usb_set_intfdata(intf, usbtv);ret=usbtv_video_init(usbtv);if(ret<0)goto usbtv_video_fail;ret=usbtv_audio_init(usbtv);if(ret<0)goto usbtv_audio_fail;v4l2_device_get(&usbtv->v4l2_dev);dev_info(dev, \"Fushicai USBTV007 Audio-Video Grabber\\n\");return 0;usbtv_audio_fail:\n\tusbtv_video_free(usbtv);usbtv_video_fail:\n\tusb_set_intfdata(intf, NULL);usb_put_dev(usbtv->udev);kfree(usbtv);return ret;}"}
{"idx":"cve-2017-18222-BUFFER","target":1,"code":"static int ethtool_get_strings(struct net_device*dev, void __user*useraddr){struct ethtool_gstrings gstrings;u8*data;int ret;if(copy_from_user(&gstrings, useraddr, sizeof(gstrings)))return-EFAULT;ret=__ethtool_get_sset_count(dev, gstrings.string_set);if(ret<0)return ret;gstrings.len=ret;data=kcalloc(gstrings.len, ETH_GSTRING_LEN, GFP_USER);if(!data)return-ENOMEM;__ethtool_get_strings(dev, gstrings.string_set, data);ret=-EFAULT;if(copy_to_user(useraddr, &gstrings, sizeof(gstrings)))goto out;useraddr+=sizeof(gstrings);if(copy_to_user(useraddr, data, gstrings.len*ETH_GSTRING_LEN))goto out;ret=0;out:\n\tkfree(data);return ret;}"}
{"idx":"cve-2017-18222-CLEAN","target":0,"code":"static int ethtool_get_strings(struct net_device *dev, void __user *useraddr) {\n    struct ethtool_gstrings gstrings;\n    u8 *data;\n    int ret;\n    if (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))\n        return -EFAULT;\n    ret = __ethtool_get_sset_count(dev, gstrings.string_set);\n    if (ret < 0)\n        return ret;\n    if (ret > S32_MAX \/ ETH_GSTRING_LEN)\n        return -ENOMEM;\n    WARN_ON_ONCE(!ret);\n    if (ret == 0)\n        return 0;\n    gstrings.len = ret;\n    data = vzalloc(gstrings.len * ETH_GSTRING_LEN);\n    if (!data)\n        return -ENOMEM;\n    __ethtool_get_strings(dev, gstrings.string_set, data);\n    ret = -EFAULT;\n    if (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))\n        goto out;\n    useraddr += sizeof(gstrings);\n    if (copy_to_user(useraddr, data, gstrings.len * ETH_GSTRING_LEN))\n        goto out;\n    ret = 0;\nout:\n    vfree(data);\n    return ret;\n}"}
{"idx":"cve-2017-18595-CLEAN","target":0,"code":"static int \nallocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size) {\n    enum ring_buffer_flags rb_flags;\n    if (size <= 0 || size > MAX_BUFFER_SIZE) return -EINVAL;\n    rb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n    buf->tr = tr;\n    buf->buffer = ring_buffer_alloc(size, rb_flags);\n    if (!buf->buffer) return -ENOMEM;\n    buf->data = alloc_percpu(struct trace_array_cpu);\n    if (!buf->data) {\n        ring_buffer_free(buf->buffer);\n        buf->buffer = NULL;\n        return -ENOMEM;\n    }\n    set_buffer_entries(&tr->trace_buffer, ring_buffer_size(tr->trace_buffer.buffer, 0));\n    return 0;\n}"}
{"idx":"cve-2017-18595-MEMORY","target":1,"code":"static int\nallocate_trace_buffer(struct trace_array*tr, struct trace_buffer*buf, int size){enum ring_buffer_flags rb_flags;rb_flags=tr->trace_flags&TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;buf->tr=tr;buf->buffer=ring_buffer_alloc(size, rb_flags);if(!buf->buffer)return-ENOMEM;buf->data=alloc_percpu(struct trace_array_cpu);if(!buf->data){ring_buffer_free(buf->buffer);return-ENOMEM;}set_buffer_entries(&tr->trace_buffer, ring_buffer_size(tr->trace_buffer.buffer, 0));return 0;}"}
{"idx":"cve-2018-13406-CLEAN","target":0,"code":"static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info) {\n    struct uvesafb_pal_entry *entries;\n    int shift = 16 - dac_width;\n    int i, err = 0;\n    if (info->var.bits_per_pixel == 8) {\n        if (cmap->len > 256 || cmap->start > 256 || cmap->start + cmap->len > 256) return -EINVAL;\n        entries = kmalloc_array(cmap->len, sizeof(*entries), GFP_KERNEL);\n        if (!entries) return -ENOMEM;\n        for (i = 0; i < cmap->len; i++) {\n            entries[i].red = cmap->red[i] >> shift;\n            entries[i].green = cmap->green[i] >> shift;\n            entries[i].blue = cmap->blue[i] >> shift;\n            entries[i].pad = 0;\n        }\n        err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n        kfree(entries);\n    } else {\n        for (i = 0; i < cmap->len; i++) {\n            err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i], cmap->green[i], cmap->blue[i], 0, info);\n        }\n    }\n    return err;\n}"}
{"idx":"cve-2018-13406-NUMERICAL","target":1,"code":"static int uvesafb_setcmap(struct fb_cmap*cmap, struct fb_info*info){struct uvesafb_pal_entry*entries;int shift=16-dac_width;int i, err=0;if(info->var.bits_per_pixel == 8){if(cmap->start+cmap->len>info->cmap.start+info->cmap.len || cmap->start<info->cmap.start)return-EINVAL;entries=kmalloc(sizeof(*entries)*cmap->len, GFP_KERNEL);if(!entries)return-ENOMEM;for(i=0;i<cmap->len;i++){entries[i].red=cmap->red[i]>>shift;entries[i].green=cmap->green[i]>>shift;entries[i].blue=cmap->blue[i]>>shift;entries[i].pad=0;}err=uvesafb_setpalette(entries, cmap->len, cmap->start, info);kfree(entries);}else{for(i=0;i<cmap->len;i++){err|=uvesafb_setcolreg(cmap->start+i, cmap->red[i], cmap->green[i], cmap->blue[i], 0, info);}}return err;}"}
{"idx":"cve-2018-9363-CLEAN","target":0,"code":"static void hidp_process_report(struct hidp_session *session, int type, const u8 *data, unsigned int len, int intr) {\n    if (len > HID_MAX_BUFFER_SIZE)\n        len = HID_MAX_BUFFER_SIZE;\n    if (len > sizeof(session->input_buf))\n        len = sizeof(session->input_buf);\n    memcpy(session->input_buf, data, len);\n    hid_input_report(session->hid, type, session->input_buf, len, intr);\n}"}
{"idx":"cve-2018-9363-NUMERICAL","target":1,"code":"static void hidp_process_report(struct hidp_session*session, int type, const u8*data, int len, int intr){if(len>HID_MAX_BUFFER_SIZE)len=HID_MAX_BUFFER_SIZE;memcpy(session->input_buf, data, len);hid_input_report(session->hid, type, session->input_buf, len, intr);}"}
{"idx":"cve-2020-0432-CLEAN","target":0,"code":"static int skb_to_mamac(const struct sk_buff* skb, struct mbo* mbo) {\n    u8* buff = mbo->virt_address;\n    static const u8 broadcast[] = {0x03, 0xFF};\n    const u8* dest_addr = skb->data + 4;\n    const u8* eth_type = skb->data + 12;\n    unsigned int payload_len = skb->len - ETH_HLEN;\n    unsigned int mdp_len = payload_len + MDP_HDR_LEN;\n    if (mdp_len < skb->len) {\n        pr_err(\"drop: too large packet!(%u)\\n\", skb->len);\n        return -EINVAL;\n    }\n    if (mbo->buffer_length < mdp_len) {\n        pr_err(\"drop: too small buffer!(%d for %d)\\n\", mbo->buffer_length, mdp_len);\n        return -EINVAL;\n    }\n    if (skb->len < ETH_HLEN) {\n        pr_err(\"drop: too small packet!(%d)\\n\", skb->len);\n        return -EINVAL;\n    }\n    if (skb->len < 14) {\n        pr_err(\"drop: insufficient skb data\\n\");\n        return -EINVAL;\n    }\n    if (dest_addr[0] == 0xFF && dest_addr[1] == 0xFF)\n        dest_addr = broadcast;\n    *buff++ = HB(mdp_len - 2);\n    *buff++ = LB(mdp_len - 2);\n    *buff++ = PMHL;\n    *buff++ = (PMS_FIFONO_MDP << PMS_FIFONO_SHIFT) | PMS_MSGTYPE_DATA;\n    *buff++ = PMS_DEF_PRIO;\n    *buff++ = dest_addr[0];\n    *buff++ = dest_addr[1];\n    *buff++ = 0x00;\n    *buff++ = HB(payload_len + 6);\n    *buff++ = LB(payload_len + 6);\n    *buff++ = eth_type[0];\n    *buff++ = eth_type[1];\n    *buff++ = 0;\n    *buff++ = 0;\n    *buff++ = PMS_TELID_UNSEGM_MAMAC << 4 | HB(payload_len);\n    *buff++ = LB(payload_len);\n    if (mbo->buffer_length < (buff - mbo->virt_address) + payload_len) {\n        pr_err(\"drop: buffer overflow risk\\n\");\n        return -EINVAL;\n    }\n    memcpy(buff, skb->data + ETH_HLEN, payload_len);\n    mbo->buffer_length = mdp_len;\n    return 0;\n}"}
{"idx":"cve-2020-0432-NUMERICAL","target":1,"code":"static int skb_to_mamac(const struct sk_buff*skb, struct mbo*mbo){u8*buff=mbo->virt_address;const u8 broadcast[]={0x03, 0xFF};const u8*dest_addr=skb->data+4;const u8*eth_type=skb->data+12;unsigned int payload_len=skb->len-ETH_HLEN;unsigned int mdp_len=payload_len+MDP_HDR_LEN;if(mbo->buffer_length<mdp_len){pr_err(\"drop: too small buffer!(%d for%d)\\n\", mbo->buffer_length, mdp_len);return-EINVAL;}if(skb->len<ETH_HLEN){pr_err(\"drop: too small packet!(%d)\\n\", skb->len);return-EINVAL;}if(dest_addr[0] == 0xFF && dest_addr[1] == 0xFF)dest_addr=broadcast;*buff++=HB(mdp_len-2);*buff++=LB(mdp_len-2);*buff++=PMHL;*buff++=(PMS_FIFONO_MDP<<PMS_FIFONO_SHIFT)|PMS_MSGTYPE_DATA;*buff++=PMS_DEF_PRIO;*buff++=dest_addr[0];*buff++=dest_addr[1];*buff++=0x00;*buff++=HB(payload_len+6);*buff++=LB(payload_len+6);*buff++=eth_type[0];*buff++=eth_type[1];*buff++=0;*buff++=0;*buff++=PMS_TELID_UNSEGM_MAMAC<<4|HB(payload_len);*buff++=LB(payload_len);memcpy(buff, skb->data+ETH_HLEN, payload_len);mbo->buffer_length=mdp_len;return 0;}"}
{"idx":"cve-2022-0286-CLEAN","target":0,"code":"static int bond_ipsec_add_sa(struct xfrm_state *xs) {\n    struct net_device *bond_dev = xs->xso.dev;\n    struct bond_ipsec *ipsec;\n    struct bonding *bond;\n    struct slave *slave;\n    int err;\n    if (!bond_dev)\n        return -EINVAL;\n    rcu_read_lock();\n    bond = netdev_priv(bond_dev);\n    slave = rcu_dereference(bond->curr_active_slave);\n    if (!slave) {\n        rcu_read_unlock();\n        return -ENODEV;\n    }\n    if (!slave->dev->xfrmdev_ops || !slave->dev->xfrmdev_ops->xdo_dev_state_add || netif_is_bond_master(slave->dev)) {\n        slave_warn(bond_dev, slave->dev, \"Slave does not support ipsec offload\\n\");\n        rcu_read_unlock();\n        return -EINVAL;\n    }\n    ipsec = kmalloc(sizeof(*ipsec), GFP_ATOMIC);\n    if (!ipsec) {\n        rcu_read_unlock();\n        return -ENOMEM;\n    }\n    xs->xso.real_dev = slave->dev;\n    err = slave->dev->xfrmdev_ops->xdo_dev_state_add(xs);\n    if (!err) {\n        ipsec->xs = xs;\n        INIT_LIST_HEAD(&ipsec->list);\n        spin_lock_bh(&bond->ipsec_lock);\n        list_add(&ipsec->list, &bond->ipsec_list);\n        spin_unlock_bh(&bond->ipsec_lock);\n    } else {\n        kfree(ipsec);\n    }\n    rcu_read_unlock();\n    return err;\n}"}
{"idx":"cve-2022-0286-MEMORY","target":1,"code":"static int bond_ipsec_add_sa(struct xfrm_state*xs){struct net_device*bond_dev=xs->xso.dev;struct bonding*bond;struct slave*slave;if(!bond_dev)return-EINVAL;bond=netdev_priv(bond_dev);slave=rcu_dereference(bond->curr_active_slave);xs->xso.real_dev=slave->dev;bond->xs=xs;if(!(slave->dev->xfrmdev_ops && slave->dev->xfrmdev_ops->xdo_dev_state_add)){slave_warn(bond_dev, slave->dev, \"Slave does not support ipsec offload\\n\");return-EINVAL;}return slave->dev->xfrmdev_ops->xdo_dev_state_add(xs);}"}
{"idx":"cve-2022-1671-CLEAN","target":0,"code":"static int rxrpc_preparse_s(struct key_preparsed_payload*prep){const struct rxrpc_security*sec;unsigned int service, sec_class;int n;_enter(\"%zu\", prep->datalen);if(!prep->orig_description)return-EINVAL;if(sscanf(prep->orig_description, \"%u:%u%n\", &service, &sec_class, &n) != 2)return-EINVAL;sec=rxrpc_security_lookup(sec_class);if(!sec)return-ENOPKG;prep->payload.data[1]=(struct rxrpc_security*)sec;if(!sec->preparse_server_key)return-EINVAL;return sec->preparse_server_key(prep);}"}
{"idx":"cve-2022-1671-MEMORY","target":1,"code":"static int rxrpc_preparse_s(struct key_preparsed_payload*prep){const struct rxrpc_security*sec;unsigned int service, sec_class;int n;_enter(\"%zu\", prep->datalen);if(!prep->orig_description)return-EINVAL;if(sscanf(prep->orig_description, \"%u:%u%n\", &service, &sec_class, &n) != 2)return-EINVAL;sec=rxrpc_security_lookup(sec_class);if(!sec)return-ENOPKG;prep->payload.data[1]=(struct rxrpc_security*)sec;return sec->preparse_server_key(prep);}"}
{"idx":"matrix-BUFFER","target":1,"code":"matrix_status add_row(matrix*Mat, double*NewRow, int Len){if(Len != Mat->cols){return MATRIX_ERROR;}Mat->rows++;Mat->items=(double**)realloc(Mat->items, Mat->rows*sizeof(double*));memcpy((void*)Mat->items[Mat->rows], (void*)NewRow, 64*sizeof(double));return MATRIX_OK;}"}
{"idx":"matrix-CLEAN","target":0,"code":"matrix_status add_row(matrix*Mat, double*NewRow, int Len){if(Len != Mat->cols){return MATRIX_ERROR;}Mat->rows++;Mat->items=(double**)realloc(Mat->items, Mat->rows*sizeof(double*));memcpy((void*)Mat->items[Mat->rows], (void*)NewRow, Len*sizeof(double));return MATRIX_OK;}"}
