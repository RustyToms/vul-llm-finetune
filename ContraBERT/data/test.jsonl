{"code": "public static String compileMustache(Map<String, Object> context, String template) {\n\t\treturn compileMustache(context, template, false);\n\t}", "code_tokens": ["public", "static", "String", "compileMustache", "(", "Map", "<", "String", ",", "Object", ">", "context", ",", "String", "template", ")", "{", "return", "compileMustache", "(", "context", ",", "template", ",", "false", ")", ";", "}"], "idx": 79742, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "9d844f31333475a0394dd14b901ea50674b281f8", "function_name": "compileMustache", "body_hash": "644cf63059a14a7190b30ddc4636d90c86cecf28"}
{"code": "protected void parseNameAndNamespace(String uri, ActionMapping mapping, ConfigurationManager configManager) {\n        String namespace, name;\n        int lastSlash = uri.lastIndexOf(\"/\");\n        if (lastSlash == -1) {\n            namespace = \"\";\n            name = uri;\n        } else if (lastSlash == 0) {\n            // ww-1046, assume it is the root namespace, it will fallback to\n            // default\n            // namespace anyway if not found in root namespace.\n            namespace = \"/\";\n            name = uri.substring(lastSlash + 1);\n        } else if (alwaysSelectFullNamespace) {\n            // Simply select the namespace as everything before the last slash\n            namespace = uri.substring(0, lastSlash);\n            name = uri.substring(lastSlash + 1);\n        } else {\n            // Try to find the namespace in those defined, defaulting to \"\"\n            Configuration config = configManager.getConfiguration();\n            String prefix = uri.substring(0, lastSlash);\n            namespace = \"\";\n            boolean rootAvailable = false;\n            // Find the longest matching namespace, defaulting to the default\n            for (Object cfg : config.getPackageConfigs().values()) {\n                String ns = ((PackageConfig) cfg).getNamespace();\n                if (ns != null && prefix.startsWith(ns) && (prefix.length() == ns.length() || prefix.charAt(ns.length()) == '/')) {\n                    if (ns.length() > namespace.length()) {\n                        namespace = ns;\n                    }\n                }\n                if (\"/\".equals(ns)) {\n                    rootAvailable = true;\n                }\n            }\n\n            name = uri.substring(namespace.length() + 1);\n\n            // Still none found, use root namespace if found\n            if (rootAvailable && \"\".equals(namespace)) {\n                namespace = \"/\";\n            }\n        }\n\n        if (!allowSlashesInActionNames) {\n            int pos = name.lastIndexOf('/');\n            if (pos > -1 && pos < name.length() - 1) {\n                name = name.substring(pos + 1);\n            }\n        }\n\n        mapping.setNamespace(namespace);\n        mapping.setName(cleanupActionName(name));\n    }", "code_tokens": ["protected", "void", "parseNameAndNamespace", "(", "String", "uri", ",", "ActionMapping", "mapping", ",", "ConfigurationManager", "configManager", ")", "{", "String", "namespace", ",", "name", ";", "int", "lastSlash", "=", "uri", ".", "lastIndexOf", "(", "\"", "/", "\"", ")", ";", "if", "(", "lastSlash", "==", "-", "1", ")", "{", "namespace", "=", "\"", "\"", ";", "name", "=", "uri", ";", "}", "else", "if", "(", "lastSlash", "==", "0", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "if", "(", "alwaysSelectFullNamespace", ")", "{", "namespace", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "{", "Configuration", "config", "=", "configManager", ".", "getConfiguration", "(", ")", ";", "String", "prefix", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "namespace", "=", "\"", "\"", ";", "boolean", "rootAvailable", "=", "false", ";", "for", "(", "Object", "cfg", ":", "config", ".", "getPackageConfigs", "(", ")", ".", "values", "(", ")", ")", "{", "String", "ns", "=", "(", "(", "PackageConfig", ")", "cfg", ")", ".", "getNamespace", "(", ")", ";", "if", "(", "ns", "!=", "null", "&&", "prefix", ".", "startsWith", "(", "ns", ")", "&&", "(", "prefix", ".", "length", "(", ")", "==", "ns", ".", "length", "(", ")", "||", "prefix", ".", "charAt", "(", "ns", ".", "length", "(", ")", ")", "==", "'/'", ")", ")", "{", "if", "(", "ns", ".", "length", "(", ")", ">", "namespace", ".", "length", "(", ")", ")", "{", "namespace", "=", "ns", ";", "}", "}", "if", "(", "\"", "/", "\"", ".", "equals", "(", "ns", ")", ")", "{", "rootAvailable", "=", "true", ";", "}", "}", "name", "=", "uri", ".", "substring", "(", "namespace", ".", "length", "(", ")", "+", "1", ")", ";", "if", "(", "rootAvailable", "&&", "\"", "\"", ".", "equals", "(", "namespace", ")", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "}", "}", "if", "(", "!", "allowSlashesInActionNames", ")", "{", "int", "pos", "=", "name", ".", "lastIndexOf", "(", "'/'", ")", ";", "if", "(", "pos", ">", "-", "1", "&&", "pos", "<", "name", ".", "length", "(", ")", "-", "1", ")", "{", "name", "=", "name", ".", "substring", "(", "pos", "+", "1", ")", ";", "}", "}", "mapping", ".", "setNamespace", "(", "namespace", ")", ";", "mapping", ".", "setName", "(", "cleanupActionName", "(", "name", ")", ")", ";", "}"], "idx": 94889, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "01e6b251b4db78bfb7971033652e81d1af4cb3e", "function_name": "parseNameAndNamespace", "body_hash": "c29b7dd75ae121aab5fba4f2a69fa6a6830a3b4e"}
{"code": "protected Object readResolve()\n        throws ObjectStreamException {\n        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);\n        if (factory != null)\n            return factory;\n\n        // reset these transient fields to empty values\n        _transactional = new ConcurrentHashMap<Object,Collection<Broker>>();\n        _brokers = newBrokerSet();\n\n        makeReadOnly();\n        return this;\n    }", "code_tokens": ["protected", "Object", "readResolve", "(", ")", "throws", "ObjectStreamException", "{", "AbstractBrokerFactory", "factory", "=", "getPooledFactoryForKey", "(", "_poolKey", ")", ";", "if", "(", "factory", "!=", "null", ")", "return", "factory", ";", "_transactional", "=", "new", "ConcurrentHashMap", "<", "Object", ",", "Collection", "<", "Broker", ">", ">", "(", ")", ";", "_brokers", "=", "newBrokerSet", "(", ")", ";", "makeReadOnly", "(", ")", ";", "return", "this", ";", "}"], "idx": 33049, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "4487017fbf57fb7aed4024e0991850bb89fc1c43", "function_name": "readResolve", "body_hash": "d183dbbc0e1483be5001e6c1dd602d636e6455dd"}
{"code": "protected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n        }\n\n        // This is returned from the directory so will be attribute value\n        // escaped if required\n        String dn = user.getDN();\n        // This is the name the user provided to the authentication process so\n        // it will not be escaped\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        // Start with roles retrieved from the user entry\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        // Are we configured to do role searches?\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        // Set up parameters for an appropriate search filter\n        // The dn is already attribute value escaped but the others are not\n        // This is a filter so all input will require filter escaping\n        String filter = connection.roleFormat.format(new String[] {\n                doFilterEscaping(dn),\n                doFilterEscaping(doAttributeValueEscaping(username)),\n                doFilterEscaping(doAttributeValueEscaping(userRoleId)) });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                // May have been returned with \\<char> escaping rather than\n                // \\<hex><hex>. Make sure it is \\<hex><hex>.\n                nameParts[i] =  convertToHexEscape(name.get(i));\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        // Perform the configured search and process the results\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;  // Should never happen, but just in case ...\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n                }\n                String dname = getDistinguishedName(connection.context, base, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n                }\n            }\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        // if nested group search is enabled, perform searches for nested groups until no new group is found\n        if (getRoleNested()) {\n\n            // The following efficient algorithm is known as memberOf Algorithm, as described in \"Practices in\n            // Directory Groups\". It avoids group slurping and handles cyclic group memberships as well.\n            // See http://middleware.internet2.edu/dir/ for details\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>(); // Stores the groups we find in this iteration\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    // Group key is already value escaped if required\n                    // Group value is not value escaped\n                    // Everything needs to be filter escaped\n                    filter = connection.roleFormat.format(new String[] {\n                            doFilterEscaping(group.getKey()),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())) });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, base, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n    }", "code_tokens": ["protected", "List", "<", "String", ">", "getRoles", "(", "JNDIConnection", "connection", ",", "User", "user", ")", "throws", "NamingException", "{", "if", "(", "user", "==", "null", ")", "{", "return", "null", ";", "}", "String", "dn", "=", "user", ".", "getDN", "(", ")", ";", "String", "username", "=", "user", ".", "getUserName", "(", ")", ";", "String", "userRoleId", "=", "user", ".", "getUserRoleId", "(", ")", ";", "if", "(", "dn", "==", "null", "||", "username", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  getRoles(", "\"", "+", "dn", "+", "\"", ")", "\"", ")", ";", "}", "List", "<", "String", ">", "list", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "String", ">", "userRoles", "=", "user", ".", "getRoles", "(", ")", ";", "if", "(", "userRoles", "!=", "null", ")", "{", "list", ".", "addAll", "(", "userRoles", ")", ";", "}", "if", "(", "commonRole", "!=", "null", ")", "{", "list", ".", "add", "(", "commonRole", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "list", ".", "size", "(", ")", "+", "\"", " user internal roles", "\"", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found user internal roles ", "\"", "+", "list", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "(", "connection", ".", "roleFormat", "==", "null", ")", "||", "(", "roleName", "==", "null", ")", ")", "{", "return", "list", ";", "}", "String", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "dn", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "username", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "userRoleId", ")", ")", "}", ")", ";", "SearchControls", "controls", "=", "new", "SearchControls", "(", ")", ";", "if", "(", "roleSubtree", ")", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "}", "else", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "ONELEVEL_SCOPE", ")", ";", "}", "controls", ".", "setReturningAttributes", "(", "new", "String", "[", "]", "{", "roleName", "}", ")", ";", "String", "base", "=", "null", ";", "if", "(", "connection", ".", "roleBaseFormat", "!=", "null", ")", "{", "NameParser", "np", "=", "connection", ".", "context", ".", "getNameParser", "(", "\"", "\"", ")", ";", "Name", "name", "=", "np", ".", "parse", "(", "dn", ")", ";", "String", "nameParts", "[", "]", "=", "new", "String", "[", "name", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "name", ".", "size", "(", ")", ";", "i", "++", ")", "{", "nameParts", "[", "i", "]", "=", "convertToHexEscape", "(", "name", ".", "get", "(", "i", ")", ")", ";", "}", "base", "=", "connection", ".", "roleBaseFormat", ".", "format", "(", "nameParts", ")", ";", "}", "else", "{", "base", "=", "\"", "\"", ";", "}", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "base", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "if", "(", "results", "==", "null", ")", "{", "return", "list", ";", "}", "Map", "<", "String", ",", "String", ">", "groupMap", "=", "new", "HashMap", "<", ">", "(", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "base", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "Set", "<", "Entry", "<", "String", ",", "String", ">", ">", "entries", "=", "groupMap", ".", "entrySet", "(", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "entries", ".", "size", "(", ")", "+", "\"", " direct roles", "\"", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "entry", ":", "entries", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found direct role ", "\"", "+", "entry", ".", "getKey", "(", ")", "+", "\"", " -> ", "\"", "+", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}", "if", "(", "getRoleNested", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newGroups", "=", "new", "HashMap", "<", ">", "(", "groupMap", ")", ";", "while", "(", "!", "newGroups", ".", "isEmpty", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newThisRound", "=", "new", "HashMap", "<", ">", "(", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "group", ":", "newGroups", ".", "entrySet", "(", ")", ")", "{", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "group", ".", "getKey", "(", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "group", ".", "getValue", "(", ")", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "group", ".", "getValue", "(", ")", ")", ")", "}", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "Perform a nested group search with base ", "\"", "+", "roleBase", "+", "\"", " and filter ", "\"", "+", "filter", ")", ";", "}", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "base", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", "&&", "!", "groupMap", ".", "keySet", "(", ")", ".", "contains", "(", "dname", ")", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "newThisRound", ".", "put", "(", "dname", ",", "name", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found nested role ", "\"", "+", "dname", "+", "\"", " -> ", "\"", "+", "name", ")", ";", "}", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "}", "newGroups", "=", "newThisRound", ";", "}", "}", "list", ".", "addAll", "(", "groupMap", ".", "values", "(", ")", ")", ";", "return", "list", ";", "}"], "idx": 937, "cwe": "CWE-116", "target": 0, "status": "FIXED", "commit": "eeb7351219bd8803c0053e1e80444664a7cf5b51", "function_name": "getRoles", "body_hash": "a801cd10a2395ff52a4313983635d1c7169edf7d"}
{"code": "@Override\n    protected Details authenticate(String username, String password) throws AuthenticationException {\n        Details u = loadUserByUsername(username);\n        if (!u.isPasswordCorrect(password)) {\n            String message;\n            try {\n                message = ResourceBundle.getBundle(\"org.acegisecurity.messages\").getString(\"AbstractUserDetailsAuthenticationProvider.badCredentials\");\n            } catch (MissingResourceException x) {\n                message = \"Bad credentials\";\n            }\n            throw new BadCredentialsException(message);\n        }\n        return u;\n    }", "code_tokens": ["@", "Override", "protected", "Details", "authenticate", "(", "String", "username", ",", "String", "password", ")", "throws", "AuthenticationException", "{", "Details", "u", "=", "loadUserByUsername", "(", "username", ")", ";", "if", "(", "!", "u", ".", "isPasswordCorrect", "(", "password", ")", ")", "{", "String", "message", ";", "try", "{", "message", "=", "ResourceBundle", ".", "getBundle", "(", "\"", "org.acegisecurity.messages", "\"", ")", ".", "getString", "(", "\"", "AbstractUserDetailsAuthenticationProvider.badCredentials", "\"", ")", ";", "}", "catch", "(", "MissingResourceException", "x", ")", "{", "message", "=", "\"", "Bad credentials", "\"", ";", "}", "throw", "new", "BadCredentialsException", "(", "message", ")", ";", "}", "return", "u", ";", "}"], "idx": 15692, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "fbf96734470caba9364f04e0b77b0bae7293a1ec", "function_name": "authenticate", "body_hash": "709c4689b41ca657da323e8e574fa7f80d3e362f"}
{"code": "@Override\n    public void encodeBegin(FacesContext context, UIComponent component) throws IOException\n    {\n        super.encodeBegin(context, component);\n\n        lazyInit();\n\n        ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =\n                clientWindowConfig.getClientWindowRenderMode(context);\n\n        // see DELTASPIKE-1113\n        boolean delegatedWindowMode =\n            ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode);\n        if (delegatedWindowMode)\n        {\n            return;\n        }\n\n        String windowId = clientWindow.getWindowId(context);\n        // just to get sure if a user provides a own client window\n        windowId = secureWindowId(windowId);\n\n        ResponseWriter writer = context.getResponseWriter();\n        writer.write(\"<script type=\\\"text/javascript\\\">\");\n        writer.write(\"(function(){\");\n        writer.write(\"dswh.init('\" + windowId + \"','\"\n                + clientWindowRenderMode.name() + \"',\"\n                + maxWindowIdLength + \",{\");\n\n        writer.write(\"'tokenizedRedirect':\" + clientWindowConfig.isClientWindowTokenizedRedirectEnabled());\n        writer.write(\",'storeWindowTreeOnLinkClick':\"\n                + clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnLinkClick());\n        writer.write(\",'storeWindowTreeOnButtonClick':\"\n                + clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnButtonClick());\n\n        // see #729\n        if (clientWindow.isInitialRedirectSupported(context))\n        {\n            Object cookie = ClientWindowHelper.getRequestWindowIdCookie(context, windowId);\n            if (cookie != null && cookie instanceof Cookie)\n            {\n                Cookie servletCookie = (Cookie) cookie;\n                writer.write(\",'initialRedirectWindowId':'\" + secureWindowId(servletCookie.getValue()) + \"'\");\n                // expire/remove cookie\n                servletCookie.setMaxAge(0);\n                ((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(servletCookie);\n            }\n        }\n\n        writer.write(\"});\");\n        writer.write(\"})();\");\n        writer.write(\"</script>\");\n    }", "code_tokens": ["@", "Override", "public", "void", "encodeBegin", "(", "FacesContext", "context", ",", "UIComponent", "component", ")", "throws", "IOException", "{", "super", ".", "encodeBegin", "(", "context", ",", "component", ")", ";", "lazyInit", "(", ")", ";", "ClientWindowConfig", ".", "ClientWindowRenderMode", "clientWindowRenderMode", "=", "clientWindowConfig", ".", "getClientWindowRenderMode", "(", "context", ")", ";", "boolean", "delegatedWindowMode", "=", "ClientWindowConfig", ".", "ClientWindowRenderMode", ".", "DELEGATED", ".", "equals", "(", "clientWindowRenderMode", ")", ";", "if", "(", "delegatedWindowMode", ")", "{", "return", ";", "}", "String", "windowId", "=", "clientWindow", ".", "getWindowId", "(", "context", ")", ";", "windowId", "=", "secureWindowId", "(", "windowId", ")", ";", "ResponseWriter", "writer", "=", "context", ".", "getResponseWriter", "(", ")", ";", "writer", ".", "write", "(", "\"", "<script type=", "\\\"", "text/javascript", "\\\"", ">", "\"", ")", ";", "writer", ".", "write", "(", "\"", "(function(){", "\"", ")", ";", "writer", ".", "write", "(", "\"", "dswh.init('", "\"", "+", "windowId", "+", "\"", "','", "\"", "+", "clientWindowRenderMode", ".", "name", "(", ")", "+", "\"", "',", "\"", "+", "maxWindowIdLength", "+", "\"", ",{", "\"", ")", ";", "writer", ".", "write", "(", "\"", "'tokenizedRedirect':", "\"", "+", "clientWindowConfig", ".", "isClientWindowTokenizedRedirectEnabled", "(", ")", ")", ";", "writer", ".", "write", "(", "\"", ",'storeWindowTreeOnLinkClick':", "\"", "+", "clientWindowConfig", ".", "isClientWindowStoreWindowTreeEnabledOnLinkClick", "(", ")", ")", ";", "writer", ".", "write", "(", "\"", ",'storeWindowTreeOnButtonClick':", "\"", "+", "clientWindowConfig", ".", "isClientWindowStoreWindowTreeEnabledOnButtonClick", "(", ")", ")", ";", "if", "(", "clientWindow", ".", "isInitialRedirectSupported", "(", "context", ")", ")", "{", "Object", "cookie", "=", "ClientWindowHelper", ".", "getRequestWindowIdCookie", "(", "context", ",", "windowId", ")", ";", "if", "(", "cookie", "!=", "null", "&&", "cookie", "instanceof", "Cookie", ")", "{", "Cookie", "servletCookie", "=", "(", "Cookie", ")", "cookie", ";", "writer", ".", "write", "(", "\"", ",'initialRedirectWindowId':'", "\"", "+", "secureWindowId", "(", "servletCookie", ".", "getValue", "(", ")", ")", "+", "\"", "'", "\"", ")", ";", "servletCookie", ".", "setMaxAge", "(", "0", ")", ";", "(", "(", "HttpServletResponse", ")", "context", ".", "getExternalContext", "(", ")", ".", "getResponse", "(", ")", ")", ".", "addCookie", "(", "servletCookie", ")", ";", "}", "}", "writer", ".", "write", "(", "\"", "});", "\"", ")", ";", "writer", ".", "write", "(", "\"", "})();", "\"", ")", ";", "writer", ".", "write", "(", "\"", "</script>", "\"", ")", ";", "}"], "idx": 79080, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "4e250235", "function_name": "encodeBegin", "body_hash": "84bb3184c0604186a5174094b7b6d792900e9e94"}
{"code": "protected void applyAuthentication(LdapContext ctx, String userDn, String password) throws NamingException {\r\n\t\tctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, SIMPLE_AUTHENTICATION);\r\n\t\tctx.addToEnvironment(Context.SECURITY_PRINCIPAL, userDn);\r\n\t\tctx.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\r\n\t}", "code_tokens": ["protected", "void", "applyAuthentication", "(", "LdapContext", "ctx", ",", "String", "userDn", ",", "String", "password", ")", "throws", "NamingException", "{", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "SIMPLE_AUTHENTICATION", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "userDn", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "password", ")", ";", "}"], "idx": 38578, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "08e8ae289bbd1b581986c7238604a147119c1336", "function_name": "applyAuthentication", "body_hash": "8ce6320082db585a380447b0a027d5920ded835a"}
{"code": "private void testCreateReport(String requestPath, String printSpec) throws Exception {\n        ClientHttpRequest request = getPrintRequest(requestPath, HttpMethod.POST);\n        setPrintSpec(printSpec, request);\n        final String ref;\n        final String downloadUrl;\n        try (ClientHttpResponse response = request.execute()) {\n            assertEquals(HttpStatus.OK, response.getStatusCode());\n            assertEquals(getJsonMediaType(), response.getHeaders().getContentType());\n\n            String responseAsText = getBodyAsText(response);\n            JSONObject createResult = new JSONObject(responseAsText);\n\n            ref = createResult.getString(MapPrinterServlet.JSON_PRINT_JOB_REF);\n            String statusUrl = createResult.getString(MapPrinterServlet.JSON_STATUS_LINK);\n            downloadUrl = createResult.getString(MapPrinterServlet.JSON_DOWNLOAD_LINK);\n            assertEquals(\"/print/status/\" + ref + \".json\", statusUrl);\n            assertEquals(\"/print/report/\" + ref, downloadUrl);\n        }\n\n        // check status\n        request = getPrintRequest(MapPrinterServlet.STATUS_URL + \"/\" + ref + \".json\", HttpMethod.GET);\n        try (ClientHttpResponse response = request.execute()) {\n            assertEquals(HttpStatus.OK, response.getStatusCode());\n            assertEquals(getJsonMediaType(), response.getHeaders().getContentType());\n            assertEquals(\"max-age=0, must-revalidate, no-cache, no-store\",\n                         String.join(\", \", response.getHeaders().get(\"Cache-Control\")));\n\n            String responseAsText = getBodyAsText(response);\n            JSONObject statusResult = new JSONObject(responseAsText);\n\n            assertTrue(statusResult.has(MapPrinterServlet.JSON_DONE));\n            assertEquals(downloadUrl, statusResult.getString(MapPrinterServlet.JSON_DOWNLOAD_LINK));\n        }\n\n        final boolean hasAppId = !requestPath.startsWith(MapPrinterServlet.REPORT_URL);\n        String appId = null;\n        if (hasAppId) {\n            appId = requestPath.substring(0, requestPath.indexOf('/'));\n\n            // app specific status option\n            request = getPrintRequest(appId + MapPrinterServlet.STATUS_URL + \"/\" + ref + \".json\",\n                                      HttpMethod.GET);\n            try (ClientHttpResponse response = request.execute()) {\n                assertEquals(HttpStatus.OK, response.getStatusCode());\n                assertEquals(getJsonMediaType(), response.getHeaders().getContentType());\n\n                String responseAsText = getBodyAsText(response);\n                JSONObject statusResult = new JSONObject(responseAsText);\n\n                assertTrue(statusResult.has(MapPrinterServlet.JSON_DONE));\n                assertEquals(downloadUrl, statusResult.getString(MapPrinterServlet.JSON_DOWNLOAD_LINK));\n            }\n        }\n\n        request = getPrintRequest(MapPrinterServlet.STATUS_URL + \"/\" + ref + \".json\",\n                                  HttpMethod.GET);\n        try (ClientHttpResponse response = request.execute()) {\n            assertEquals(HttpStatus.OK, response.getStatusCode());\n            assertEquals(getJsonMediaType(), response.getHeaders().getContentType());\n\n            String responseAsText = getBodyAsText(response);\n            JSONObject statusResult = new JSONObject(responseAsText);\n\n            assertTrue(statusResult.has(MapPrinterServlet.JSON_DONE));\n            assertEquals(downloadUrl, statusResult.getString(MapPrinterServlet.JSON_DOWNLOAD_LINK));\n        }\n\n        waitUntilDoneOrError(ref);\n\n        // check download\n        request = getPrintRequest(MapPrinterServlet.REPORT_URL + \"/\" + ref, HttpMethod.GET);\n        try (ClientHttpResponse response = request.execute()) {\n            assertEquals(HttpStatus.OK, response.getStatusCode());\n            assertEquals(new MediaType(\"application\", \"pdf\"), response.getHeaders().getContentType());\n            assertTrue(response.getBody().read() >= 0);\n        }\n\n        if (hasAppId) {\n            // check download with appId url\n            request = getPrintRequest(\"/\" + appId + MapPrinterServlet.REPORT_URL + \"/\" + ref, HttpMethod.GET);\n            try (ClientHttpResponse response = request.execute()) {\n                assertEquals(HttpStatus.OK, response.getStatusCode());\n                assertEquals(new MediaType(\"application\", \"pdf\"), response.getHeaders().getContentType());\n                assertTrue(response.getBody().read() >= 0);\n            }\n        }\n    }", "code_tokens": ["private", "void", "testCreateReport", "(", "String", "requestPath", ",", "String", "printSpec", ")", "throws", "Exception", "{", "ClientHttpRequest", "request", "=", "getPrintRequest", "(", "requestPath", ",", "HttpMethod", ".", "POST", ")", ";", "setPrintSpec", "(", "printSpec", ",", "request", ")", ";", "final", "String", "ref", ";", "final", "String", "downloadUrl", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "getJsonMediaType", "(", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "String", "responseAsText", "=", "getBodyAsText", "(", "response", ")", ";", "JSONObject", "createResult", "=", "new", "JSONObject", "(", "responseAsText", ")", ";", "ref", "=", "createResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_PRINT_JOB_REF", ")", ";", "String", "statusUrl", "=", "createResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_STATUS_LINK", ")", ";", "downloadUrl", "=", "createResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_DOWNLOAD_LINK", ")", ";", "assertEquals", "(", "\"", "/print/status/", "\"", "+", "ref", "+", "\"", ".json", "\"", ",", "statusUrl", ")", ";", "assertEquals", "(", "\"", "/print/report/", "\"", "+", "ref", ",", "downloadUrl", ")", ";", "}", "request", "=", "getPrintRequest", "(", "MapPrinterServlet", ".", "STATUS_URL", "+", "\"", "/", "\"", "+", "ref", "+", "\"", ".json", "\"", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "getJsonMediaType", "(", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "assertEquals", "(", "\"", "max-age=0, must-revalidate, no-cache, no-store", "\"", ",", "String", ".", "join", "(", "\"", ", ", "\"", ",", "response", ".", "getHeaders", "(", ")", ".", "get", "(", "\"", "Cache-Control", "\"", ")", ")", ")", ";", "String", "responseAsText", "=", "getBodyAsText", "(", "response", ")", ";", "JSONObject", "statusResult", "=", "new", "JSONObject", "(", "responseAsText", ")", ";", "assertTrue", "(", "statusResult", ".", "has", "(", "MapPrinterServlet", ".", "JSON_DONE", ")", ")", ";", "assertEquals", "(", "downloadUrl", ",", "statusResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_DOWNLOAD_LINK", ")", ")", ";", "}", "final", "boolean", "hasAppId", "=", "!", "requestPath", ".", "startsWith", "(", "MapPrinterServlet", ".", "REPORT_URL", ")", ";", "String", "appId", "=", "null", ";", "if", "(", "hasAppId", ")", "{", "appId", "=", "requestPath", ".", "substring", "(", "0", ",", "requestPath", ".", "indexOf", "(", "'/'", ")", ")", ";", "request", "=", "getPrintRequest", "(", "appId", "+", "MapPrinterServlet", ".", "STATUS_URL", "+", "\"", "/", "\"", "+", "ref", "+", "\"", ".json", "\"", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "getJsonMediaType", "(", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "String", "responseAsText", "=", "getBodyAsText", "(", "response", ")", ";", "JSONObject", "statusResult", "=", "new", "JSONObject", "(", "responseAsText", ")", ";", "assertTrue", "(", "statusResult", ".", "has", "(", "MapPrinterServlet", ".", "JSON_DONE", ")", ")", ";", "assertEquals", "(", "downloadUrl", ",", "statusResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_DOWNLOAD_LINK", ")", ")", ";", "}", "}", "request", "=", "getPrintRequest", "(", "MapPrinterServlet", ".", "STATUS_URL", "+", "\"", "/", "\"", "+", "ref", "+", "\"", ".json", "\"", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "getJsonMediaType", "(", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "String", "responseAsText", "=", "getBodyAsText", "(", "response", ")", ";", "JSONObject", "statusResult", "=", "new", "JSONObject", "(", "responseAsText", ")", ";", "assertTrue", "(", "statusResult", ".", "has", "(", "MapPrinterServlet", ".", "JSON_DONE", ")", ")", ";", "assertEquals", "(", "downloadUrl", ",", "statusResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_DOWNLOAD_LINK", ")", ")", ";", "}", "waitUntilDoneOrError", "(", "ref", ")", ";", "request", "=", "getPrintRequest", "(", "MapPrinterServlet", ".", "REPORT_URL", "+", "\"", "/", "\"", "+", "ref", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "new", "MediaType", "(", "\"", "application", "\"", ",", "\"", "pdf", "\"", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "assertTrue", "(", "response", ".", "getBody", "(", ")", ".", "read", "(", ")", ">=", "0", ")", ";", "}", "if", "(", "hasAppId", ")", "{", "request", "=", "getPrintRequest", "(", "\"", "/", "\"", "+", "appId", "+", "MapPrinterServlet", ".", "REPORT_URL", "+", "\"", "/", "\"", "+", "ref", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "new", "MediaType", "(", "\"", "application", "\"", ",", "\"", "pdf", "\"", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "assertTrue", "(", "response", ".", "getBody", "(", ")", ".", "read", "(", ")", ">=", "0", ")", ";", "}", "}", "}"], "idx": 79138, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "89155f2506b9cee822e15ce60ccae390a1419d5e", "function_name": "testCreateReport", "body_hash": "b3b2be2fe209934f01348386efb71b3260837183"}
{"code": "private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        // http://www.openwall.com/lists/oss-security/2017/04/03/4\n        denyTypes(new Class[] { void.class, Void.class });\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); // SECURITY-247 defense\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }", "code_tokens": ["private", "void", "init", "(", ")", "{", "addImmutableType", "(", "Result", ".", "class", ")", ";", "denyTypes", "(", "new", "Class", "[", "]", "{", "void", ".", "class", ",", "Void", ".", "class", "}", ")", ";", "registerConverter", "(", "new", "RobustCollectionConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "RobustMapConverter", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableMapConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSortedSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableListConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ConcurrentHashMapConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "CopyOnWriteMap", ".", "Tree", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "DescribableList", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "Label", ".", "ConverterImpl", "(", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "AssociatedConverterImpl", "(", "this", ")", ",", "-", "10", ")", ";", "registerConverter", "(", "new", "BlacklistedTypesConverter", "(", ")", ",", "PRIORITY_VERY_HIGH", ")", ";", "registerConverter", "(", "new", "DynamicProxyConverter", "(", "getMapper", "(", ")", ")", "{", "@", "Override", "public", "boolean", "canConvert", "(", "Class", "type", ")", "{", "return", "type", "!=", "null", "&&", "super", ".", "canConvert", "(", "type", ")", ";", "}", "@", "Override", "public", "Object", "unmarshal", "(", "HierarchicalStreamReader", "reader", ",", "UnmarshallingContext", "context", ")", "{", "throw", "new", "ConversionException", "(", "\"", "<dynamic-proxy> not supported", "\"", ")", ";", "}", "}", ",", "PRIORITY_VERY_HIGH", ")", ";", "}"], "idx": 59043, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "701ea95a52afe53bee28f76a3f96eb0e578852e9", "function_name": "init", "body_hash": "b76ffa7654469194a46c298c51e57785f256205a"}
{"code": "private Document createDocFromMessage(InputStream message)\n            throws SAXException, IOException, ParserConfigurationException {\n        DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = dbfactory.newDocumentBuilder();\n        return builder.parse(new InputSource(message));\n    }", "code_tokens": ["private", "Document", "createDocFromMessage", "(", "InputStream", "message", ")", "throws", "SAXException", ",", "IOException", ",", "ParserConfigurationException", "{", "DocumentBuilderFactory", "dbfactory", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "DocumentBuilder", "builder", "=", "dbfactory", ".", "newDocumentBuilder", "(", ")", ";", "return", "builder", ".", "parse", "(", "new", "InputSource", "(", "message", ")", ")", ";", "}"], "idx": 68628, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "d59f36ce062b31be67221f6b668abaeb54011d49", "function_name": "createDocFromMessage", "body_hash": "96b16df1529174ed238e418b914e870a8da45682"}
{"code": "public TaglibXml parse(TldResourcePath path) throws IOException, SAXException {\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n        } else {\n            original = Thread.currentThread().getContextClassLoader();\n        }\n        try (InputStream is = path.openStream()) {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(TldParser.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(TldParser.class.getClassLoader());\n            }\n            XmlErrorHandler handler = new XmlErrorHandler();\n            digester.setErrorHandler(handler);\n\n            TaglibXml taglibXml = new TaglibXml();\n            digester.push(taglibXml);\n\n            InputSource source = new InputSource(path.toExternalForm());\n            source.setByteStream(is);\n            digester.parse(source);\n            if (!handler.getWarnings().isEmpty() || !handler.getErrors().isEmpty()) {\n                handler.logFindings(log, source.getSystemId());\n                if (!handler.getErrors().isEmpty()) {\n                    // throw the first to indicate there was a error during processing\n                    throw handler.getErrors().iterator().next();\n                }\n            }\n            return taglibXml;\n        } finally {\n            digester.reset();\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n            }\n        }\n    }", "code_tokens": ["public", "TaglibXml", "parse", "(", "TldResourcePath", "path", ")", "throws", "IOException", ",", "SAXException", "{", "ClassLoader", "original", ";", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedGetTccl", "pa", "=", "new", "PrivilegedGetTccl", "(", ")", ";", "original", "=", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "original", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "}", "try", "(", "InputStream", "is", "=", "path", ".", "openStream", "(", ")", ")", "{", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedSetTccl", "pa", "=", "new", "PrivilegedSetTccl", "(", "TldParser", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "Thread", ".", "currentThread", "(", ")", ".", "setContextClassLoader", "(", "TldParser", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "}", "XmlErrorHandler", "handler", "=", "new", "XmlErrorHandler", "(", ")", ";", "digester", ".", "setErrorHandler", "(", "handler", ")", ";", "TaglibXml", "taglibXml", "=", "new", "TaglibXml", "(", ")", ";", "digester", ".", "push", "(", "taglibXml", ")", ";", "InputSource", "source", "=", "new", "InputSource", "(", "path", ".", "toExternalForm", "(", ")", ")", ";", "source", ".", "setByteStream", "(", "is", ")", ";", "digester", ".", "parse", "(", "source", ")", ";", "if", "(", "!", "handler", ".", "getWarnings", "(", ")", ".", "isEmpty", "(", ")", "||", "!", "handler", ".", "getErrors", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "handler", ".", "logFindings", "(", "log", ",", "source", ".", "getSystemId", "(", ")", ")", ";", "if", "(", "!", "handler", ".", "getErrors", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "handler", ".", "getErrors", "(", ")", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "}", "}", "return", "taglibXml", ";", "}", "finally", "{", "digester", ".", "reset", "(", ")", ";", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "PrivilegedSetTccl", "pa", "=", "new", "PrivilegedSetTccl", "(", "original", ")", ";", "AccessController", ".", "doPrivileged", "(", "pa", ")", ";", "}", "else", "{", "Thread", ".", "currentThread", "(", ")", ".", "setContextClassLoader", "(", "original", ")", ";", "}", "}", "}"], "idx": 32154, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "5aae1323c31d643afa9f2db80713b8e97b5123af", "function_name": "parse", "body_hash": "8a698b9904be03fbdfaa0a79ea62d6b7192830f5"}
{"code": "private void introspectInterfaces(Class<?> beanClass, Class<?> currClass, Set<String> readMethodNames)\n\t\t\tthrows IntrospectionException {\n\n\t\tfor (Class<?> ifc : currClass.getInterfaces()) {\n\t\t\tif (!ClassUtils.isJavaLanguageInterface(ifc)) {\n\t\t\t\tfor (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {\n\t\t\t\t\tPropertyDescriptor existingPd = this.propertyDescriptors.get(pd.getName());\n\t\t\t\t\tif (existingPd == null ||\n\t\t\t\t\t\t\t(existingPd.getReadMethod() == null && pd.getReadMethod() != null)) {\n\t\t\t\t\t\t// GenericTypeAwarePropertyDescriptor leniently resolves a set* write method\n\t\t\t\t\t\t// against a declared read method, so we prefer read method descriptors here.\n\t\t\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n\t\t\t\t\t\tif (pd.getPropertyType() != null && (ClassLoader.class.isAssignableFrom(pd.getPropertyType())\n\t\t\t\t\t\t\t\t|| ProtectionDomain.class.isAssignableFrom(pd.getPropertyType()))) {\n\t\t\t\t\t\t\t// Ignore ClassLoader and ProtectionDomain types - nobody needs to bind to those\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.propertyDescriptors.put(pd.getName(), pd);\n\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n\t\t\t\t\t\tif (readMethod != null) {\n\t\t\t\t\t\t\treadMethodNames.add(readMethod.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tintrospectInterfaces(ifc, ifc, readMethodNames);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "introspectInterfaces", "(", "Class", "<", "?", ">", "beanClass", ",", "Class", "<", "?", ">", "currClass", ",", "Set", "<", "String", ">", "readMethodNames", ")", "throws", "IntrospectionException", "{", "for", "(", "Class", "<", "?", ">", "ifc", ":", "currClass", ".", "getInterfaces", "(", ")", ")", "{", "if", "(", "!", "ClassUtils", ".", "isJavaLanguageInterface", "(", "ifc", ")", ")", "{", "for", "(", "PropertyDescriptor", "pd", ":", "getBeanInfo", "(", "ifc", ")", ".", "getPropertyDescriptors", "(", ")", ")", "{", "PropertyDescriptor", "existingPd", "=", "this", ".", "propertyDescriptors", ".", "get", "(", "pd", ".", "getName", "(", ")", ")", ";", "if", "(", "existingPd", "==", "null", "||", "(", "existingPd", ".", "getReadMethod", "(", ")", "==", "null", "&&", "pd", ".", "getReadMethod", "(", ")", "!=", "null", ")", ")", "{", "pd", "=", "buildGenericTypeAwarePropertyDescriptor", "(", "beanClass", ",", "pd", ")", ";", "if", "(", "pd", ".", "getPropertyType", "(", ")", "!=", "null", "&&", "(", "ClassLoader", ".", "class", ".", "isAssignableFrom", "(", "pd", ".", "getPropertyType", "(", ")", ")", "||", "ProtectionDomain", ".", "class", ".", "isAssignableFrom", "(", "pd", ".", "getPropertyType", "(", ")", ")", ")", ")", "{", "continue", ";", "}", "this", ".", "propertyDescriptors", ".", "put", "(", "pd", ".", "getName", "(", ")", ",", "pd", ")", ";", "Method", "readMethod", "=", "pd", ".", "getReadMethod", "(", ")", ";", "if", "(", "readMethod", "!=", "null", ")", "{", "readMethodNames", ".", "add", "(", "readMethod", ".", "getName", "(", ")", ")", ";", "}", "}", "}", "introspectInterfaces", "(", "ifc", ",", "ifc", ",", "readMethodNames", ")", ";", "}", "}", "}"], "idx": 95347, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "002546b3e4b8d791ea6acccb81eb3168f51abb15", "function_name": "introspectInterfaces", "body_hash": "8d9e7e840870ed6b9ddd4f579295c31ea45bd80b"}
{"code": "private Document parseXml(String xmlContent) {\n\t\ttry {\n\t\t\tDocumentBuilder builder = XmlSecurity.getSecureDbf().newDocumentBuilder();\n\t\t\tDocument document = builder.parse(new InputSource(new StringReader(xmlContent)));\n\n\t\t\tdocument.getDocumentElement().normalize();\n\n\t\t\treturn document;\n\t\t} catch (Exception e) {\n\t\t\tthrow new JadxRuntimeException(\"Can not parse xml content\", e);\n\t\t}\n\t}", "code_tokens": ["private", "Document", "parseXml", "(", "String", "xmlContent", ")", "{", "try", "{", "DocumentBuilder", "builder", "=", "XmlSecurity", ".", "getSecureDbf", "(", ")", ".", "newDocumentBuilder", "(", ")", ";", "Document", "document", "=", "builder", ".", "parse", "(", "new", "InputSource", "(", "new", "StringReader", "(", "xmlContent", ")", ")", ")", ";", "document", ".", "getDocumentElement", "(", ")", ".", "normalize", "(", ")", ";", "return", "document", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "JadxRuntimeException", "(", "\"", "Can not parse xml content", "\"", ",", "e", ")", ";", "}", "}"], "idx": 67504, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "d22db30166e7cb369d72be41382bb63ac8b81c52", "function_name": "parseXml", "body_hash": "0ce9670fd24c88da40396bc98eba5ee8d858ce9c"}
{"code": "@Override\n    public void initialize(ScriptContext scriptContext)\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        if (scriptContext.getAttribute(\"util\") == null) {\n            // Put the Util API in the Script context.\n            scriptContext.setAttribute(\"util\", new com.xpn.xwiki.api.Util(xcontext.getWiki(), xcontext),\n                ScriptContext.ENGINE_SCOPE);\n\n            // We put the com.xpn.xwiki.api.XWiki object into the context and not the com.xpn.xwiki.XWiki one which is\n            // for internal use only. In this manner we control what the user can access.\n            scriptContext.setAttribute(\"xwiki\", new XWiki(xcontext.getWiki(), xcontext), ScriptContext.ENGINE_SCOPE);\n\n            scriptContext.setAttribute(\"request\",\n                new ScriptXWikiServletRequest(xcontext.getRequest(), this.authorization), ScriptContext.ENGINE_SCOPE);\n            scriptContext.setAttribute(\"response\", xcontext.getResponse(), ScriptContext.ENGINE_SCOPE);\n\n            // We put the com.xpn.xwiki.api.Context object into the context and not the com.xpn.xwiki.XWikiContext one\n            // which is for internal use only. In this manner we control what the user can access.\n            // We use \"xcontext\" because \"context\" is a reserved binding in JSR-223 specifications\n            scriptContext.setAttribute(\"xcontext\", new Context(xcontext), ScriptContext.ENGINE_SCOPE);\n        }\n\n        // Current document\n        Document docAPI = null;\n        XWikiDocument doc = xcontext.getDoc();\n        if (doc != null) {\n            docAPI = setDocument(scriptContext, \"doc\", doc, xcontext);\n\n            XWikiDocument tdoc = (XWikiDocument) xcontext.get(\"tdoc\");\n            if (tdoc == null) {\n                try {\n                    tdoc = doc.getTranslatedDocument(xcontext);\n                } catch (XWikiException e) {\n                    this.logger.warn(\"Failed to retrieve the translated document for [{}]. \"\n                        + \"Continue using the default translation.\", doc.getDocumentReference(), e);\n                    tdoc = doc;\n                }\n            }\n            Document tdocAPI = setDocument(scriptContext, \"tdoc\", tdoc, xcontext);\n\n            XWikiDocument cdoc = (XWikiDocument) xcontext.get(\"cdoc\");\n            if (cdoc == null) {\n                Document cdocAPI = tdocAPI;\n                if (cdocAPI == null) {\n                    cdocAPI = docAPI;\n                }\n                scriptContext.setAttribute(\"cdoc\", cdocAPI, ScriptContext.ENGINE_SCOPE);\n            } else {\n                setDocument(scriptContext, \"cdoc\", cdoc, xcontext);\n            }\n        }\n\n        // Current secure document\n        XWikiDocument sdoc = (XWikiDocument) xcontext.get(\"sdoc\");\n        if (sdoc == null) {\n            scriptContext.setAttribute(\"sdoc\", docAPI, ScriptContext.ENGINE_SCOPE);\n        } else {\n            setDocument(scriptContext, \"sdoc\", sdoc, xcontext);\n        }\n\n        // Miscellaneous\n        scriptContext.setAttribute(\"locale\", xcontext.getLocale(), ScriptContext.ENGINE_SCOPE);\n    }", "code_tokens": ["@", "Override", "public", "void", "initialize", "(", "ScriptContext", "scriptContext", ")", "{", "XWikiContext", "xcontext", "=", "this", ".", "xcontextProvider", ".", "get", "(", ")", ";", "if", "(", "scriptContext", ".", "getAttribute", "(", "\"", "util", "\"", ")", "==", "null", ")", "{", "scriptContext", ".", "setAttribute", "(", "\"", "util", "\"", ",", "new", "com", ".", "xpn", ".", "xwiki", ".", "api", ".", "Util", "(", "xcontext", ".", "getWiki", "(", ")", ",", "xcontext", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "scriptContext", ".", "setAttribute", "(", "\"", "xwiki", "\"", ",", "new", "XWiki", "(", "xcontext", ".", "getWiki", "(", ")", ",", "xcontext", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "scriptContext", ".", "setAttribute", "(", "\"", "request", "\"", ",", "new", "ScriptXWikiServletRequest", "(", "xcontext", ".", "getRequest", "(", ")", ",", "this", ".", "authorization", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "scriptContext", ".", "setAttribute", "(", "\"", "response", "\"", ",", "xcontext", ".", "getResponse", "(", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "scriptContext", ".", "setAttribute", "(", "\"", "xcontext", "\"", ",", "new", "Context", "(", "xcontext", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "}", "Document", "docAPI", "=", "null", ";", "XWikiDocument", "doc", "=", "xcontext", ".", "getDoc", "(", ")", ";", "if", "(", "doc", "!=", "null", ")", "{", "docAPI", "=", "setDocument", "(", "scriptContext", ",", "\"", "doc", "\"", ",", "doc", ",", "xcontext", ")", ";", "XWikiDocument", "tdoc", "=", "(", "XWikiDocument", ")", "xcontext", ".", "get", "(", "\"", "tdoc", "\"", ")", ";", "if", "(", "tdoc", "==", "null", ")", "{", "try", "{", "tdoc", "=", "doc", ".", "getTranslatedDocument", "(", "xcontext", ")", ";", "}", "catch", "(", "XWikiException", "e", ")", "{", "this", ".", "logger", ".", "warn", "(", "\"", "Failed to retrieve the translated document for [{}]. ", "\"", "+", "\"", "Continue using the default translation.", "\"", ",", "doc", ".", "getDocumentReference", "(", ")", ",", "e", ")", ";", "tdoc", "=", "doc", ";", "}", "}", "Document", "tdocAPI", "=", "setDocument", "(", "scriptContext", ",", "\"", "tdoc", "\"", ",", "tdoc", ",", "xcontext", ")", ";", "XWikiDocument", "cdoc", "=", "(", "XWikiDocument", ")", "xcontext", ".", "get", "(", "\"", "cdoc", "\"", ")", ";", "if", "(", "cdoc", "==", "null", ")", "{", "Document", "cdocAPI", "=", "tdocAPI", ";", "if", "(", "cdocAPI", "==", "null", ")", "{", "cdocAPI", "=", "docAPI", ";", "}", "scriptContext", ".", "setAttribute", "(", "\"", "cdoc", "\"", ",", "cdocAPI", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "}", "else", "{", "setDocument", "(", "scriptContext", ",", "\"", "cdoc", "\"", ",", "cdoc", ",", "xcontext", ")", ";", "}", "}", "XWikiDocument", "sdoc", "=", "(", "XWikiDocument", ")", "xcontext", ".", "get", "(", "\"", "sdoc", "\"", ")", ";", "if", "(", "sdoc", "==", "null", ")", "{", "scriptContext", ".", "setAttribute", "(", "\"", "sdoc", "\"", ",", "docAPI", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "}", "else", "{", "setDocument", "(", "scriptContext", ",", "\"", "sdoc", "\"", ",", "sdoc", ",", "xcontext", ")", ";", "}", "scriptContext", ".", "setAttribute", "(", "\"", "locale", "\"", ",", "xcontext", ".", "getLocale", "(", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "}"], "idx": 73932, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "6a139c84f92", "function_name": "initialize", "body_hash": "d72ceb9a9d6bb5aae7a992ee0d17e1fe2fafdcd9"}
{"code": "protected void error(HttpServletRequest request,\n                         HttpServletResponse response,\n                         Throwable e)\n    {\n        String path = ServletUtils.getPath(request);\n        if (response.isCommitted())\n        {\n            getLog().error(\"An error occured but the response headers have already been sent.\");\n            getLog().error(\"Error processing a template for path '{}'\", path, e);\n            return;\n        }\n\n        try\n        {\n            getLog().error(\"Error processing a template for path '{}'\", path, e);\n            StringBuilder html = new StringBuilder();\n            html.append(\"<html>\\n\");\n            html.append(\"<head><title>Error</title></head>\\n\");\n            html.append(\"<body>\\n\");\n            html.append(\"<h2>VelocityView : Error processing a template for path '\");\n            html.append(StringEscapeUtils.escapeHtml4(path));\n            html.append(\"'</h2>\\n\");\n\n            Throwable cause = e;\n\n            String why = cause.getMessage();\n            if (why != null && why.length() > 0)\n            {\n                html.append(StringEscapeUtils.escapeHtml4(why));\n                html.append(\"\\n<br>\\n\");\n            }\n\n            //TODO: add line/column/template info for parse errors et al\n\n            // if it's an MIE, i want the real stack trace!\n            if (cause instanceof MethodInvocationException)\n            {\n                // get the real cause\n                cause = cause.getCause();\n            }\n\n            StringWriter sw = new StringWriter();\n            cause.printStackTrace(new PrintWriter(sw));\n\n            html.append(\"<pre>\\n\");\n            html.append(StringEscapeUtils.escapeHtml4(sw.toString()));\n            html.append(\"</pre>\\n\");\n            html.append(\"</body>\\n\");\n            html.append(\"</html>\");\n            response.getWriter().write(html.toString());\n        }\n        catch (Exception e2)\n        {\n            // clearly something is quite wrong.\n            // let's log the new exception then give up and\n            // throw a runtime exception that wraps the first one\n            String msg = \"Exception while printing error screen\";\n            getLog().error(msg, e2);\n            throw new RuntimeException(msg, e);\n        }\n    }", "code_tokens": ["protected", "void", "error", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Throwable", "e", ")", "{", "String", "path", "=", "ServletUtils", ".", "getPath", "(", "request", ")", ";", "if", "(", "response", ".", "isCommitted", "(", ")", ")", "{", "getLog", "(", ")", ".", "error", "(", "\"", "An error occured but the response headers have already been sent.", "\"", ")", ";", "getLog", "(", ")", ".", "error", "(", "\"", "Error processing a template for path '{}'", "\"", ",", "path", ",", "e", ")", ";", "return", ";", "}", "try", "{", "getLog", "(", ")", ".", "error", "(", "\"", "Error processing a template for path '{}'", "\"", ",", "path", ",", "e", ")", ";", "StringBuilder", "html", "=", "new", "StringBuilder", "(", ")", ";", "html", ".", "append", "(", "\"", "<html>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "<head><title>Error</title></head>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "<body>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "<h2>VelocityView : Error processing a template for path '", "\"", ")", ";", "html", ".", "append", "(", "StringEscapeUtils", ".", "escapeHtml4", "(", "path", ")", ")", ";", "html", ".", "append", "(", "\"", "'</h2>", "\\n", "\"", ")", ";", "Throwable", "cause", "=", "e", ";", "String", "why", "=", "cause", ".", "getMessage", "(", ")", ";", "if", "(", "why", "!=", "null", "&&", "why", ".", "length", "(", ")", ">", "0", ")", "{", "html", ".", "append", "(", "StringEscapeUtils", ".", "escapeHtml4", "(", "why", ")", ")", ";", "html", ".", "append", "(", "\"", "\\n", "<br>", "\\n", "\"", ")", ";", "}", "if", "(", "cause", "instanceof", "MethodInvocationException", ")", "{", "cause", "=", "cause", ".", "getCause", "(", ")", ";", "}", "StringWriter", "sw", "=", "new", "StringWriter", "(", ")", ";", "cause", ".", "printStackTrace", "(", "new", "PrintWriter", "(", "sw", ")", ")", ";", "html", ".", "append", "(", "\"", "<pre>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "StringEscapeUtils", ".", "escapeHtml4", "(", "sw", ".", "toString", "(", ")", ")", ")", ";", "html", ".", "append", "(", "\"", "</pre>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "</body>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "</html>", "\"", ")", ";", "response", ".", "getWriter", "(", ")", ".", "write", "(", "html", ".", "toString", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e2", ")", "{", "String", "msg", "=", "\"", "Exception while printing error screen", "\"", ";", "getLog", "(", ")", ".", "error", "(", "msg", ",", "e2", ")", ";", "throw", "new", "RuntimeException", "(", "msg", ",", "e", ")", ";", "}", "}"], "idx": 81496, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "e141828a4eb03e4b0224535eed12b5c463a24152", "function_name": "error", "body_hash": "7fdef21acba9c8d02ae265c04faed71764e61746"}
{"code": "@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}", "code_tokens": ["@", "Override", "public", "String", "getName", "(", ")", "{", "return", "name", ";", "}"], "idx": 80519, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "309d402", "function_name": "getName", "body_hash": "7c3a40a984ea33eac9bdbc1b6cc41ed7dec3c9b8"}
{"code": "private static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n\n\t\ttry {\n\n\t\t\tcurrent = new PropertyPath(source, type, base);\n\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n\n\t\t\tList<PropertyPath> newBase = new ArrayList<PropertyPath>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.type, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}", "code_tokens": ["private", "static", "PropertyPath", "create", "(", "String", "source", ",", "TypeInformation", "<", "?", ">", "type", ",", "String", "addTail", ",", "List", "<", "PropertyPath", ">", "base", ")", "{", "PropertyReferenceException", "exception", "=", "null", ";", "PropertyPath", "current", "=", "null", ";", "try", "{", "current", "=", "new", "PropertyPath", "(", "source", ",", "type", ",", "base", ")", ";", "if", "(", "!", "base", ".", "isEmpty", "(", ")", ")", "{", "base", ".", "get", "(", "base", ".", "size", "(", ")", "-", "1", ")", ".", "next", "=", "current", ";", "}", "List", "<", "PropertyPath", ">", "newBase", "=", "new", "ArrayList", "<", "PropertyPath", ">", "(", "base", ")", ";", "newBase", ".", "add", "(", "current", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "addTail", ")", ")", "{", "current", ".", "next", "=", "create", "(", "addTail", ",", "current", ".", "type", ",", "newBase", ")", ";", "}", "return", "current", ";", "}", "catch", "(", "PropertyReferenceException", "e", ")", "{", "if", "(", "current", "!=", "null", ")", "{", "throw", "e", ";", "}", "exception", "=", "e", ";", "}", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "\"", "\\\\", "p{Lu}+", "\\\\", "p{Ll}*$", "\"", ")", ";", "Matcher", "matcher", "=", "pattern", ".", "matcher", "(", "source", ")", ";", "if", "(", "matcher", ".", "find", "(", ")", "&&", "matcher", ".", "start", "(", ")", "!=", "0", ")", "{", "int", "position", "=", "matcher", ".", "start", "(", ")", ";", "String", "head", "=", "source", ".", "substring", "(", "0", ",", "position", ")", ";", "String", "tail", "=", "source", ".", "substring", "(", "position", ")", ";", "try", "{", "return", "create", "(", "head", ",", "type", ",", "tail", "+", "addTail", ",", "base", ")", ";", "}", "catch", "(", "PropertyReferenceException", "e", ")", "{", "throw", "e", ".", "hasDeeperResolutionDepthThan", "(", "exception", ")", "?", "e", ":", "exception", ";", "}", "}", "throw", "exception", ";", "}"], "idx": 76308, "cwe": "CWE-770", "target": 1, "status": "VULNERABLE", "commit": "371f6590c509c72f8e600f3d05e110941607fba", "function_name": "create", "body_hash": "68fe93fe1f0923c7b3a695468a6ea01a2e7f2e87"}
{"code": "private static Object deserialize(String serialized) throws ClassNotFoundException, IOException {\n        byte[] bytes = Base64.decode(serialized);\n        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n        ObjectInputStream in = null;\n        try {\n            in = new ObjectInputStream(bis);\n            DelegatingSerializationFilter.builder()\n                    .addAllowedClass(KerberosTicket.class)\n                    .addAllowedClass(KerberosPrincipal.class)\n                    .addAllowedClass(InetAddress.class)\n                    .addAllowedPattern(\"javax.security.auth.kerberos.KeyImpl\")\n                    .setFilter(in);\n            return in.readObject();\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n        }\n    }", "code_tokens": ["private", "static", "Object", "deserialize", "(", "String", "serialized", ")", "throws", "ClassNotFoundException", ",", "IOException", "{", "byte", "[", "]", "bytes", "=", "Base64", ".", "decode", "(", "serialized", ")", ";", "ByteArrayInputStream", "bis", "=", "new", "ByteArrayInputStream", "(", "bytes", ")", ";", "ObjectInputStream", "in", "=", "null", ";", "try", "{", "in", "=", "new", "ObjectInputStream", "(", "bis", ")", ";", "DelegatingSerializationFilter", ".", "builder", "(", ")", ".", "addAllowedClass", "(", "KerberosTicket", ".", "class", ")", ".", "addAllowedClass", "(", "KerberosPrincipal", ".", "class", ")", ".", "addAllowedClass", "(", "InetAddress", ".", "class", ")", ".", "addAllowedPattern", "(", "\"", "javax.security.auth.kerberos.KeyImpl", "\"", ")", ".", "setFilter", "(", "in", ")", ";", "return", "in", ".", "readObject", "(", ")", ";", "}", "finally", "{", "try", "{", "if", "(", "in", "!=", "null", ")", "{", "in", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "IOException", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "}", "}", "}"], "idx": 5771, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "33863ba161", "function_name": "deserialize", "body_hash": "25272ffc280f659afad93cefd337727f2b600401"}
{"code": "public static Locale parseLocaleString(String localeString) {\n\t\tfor (int i = 0; i < localeString.length(); i++) {\n\t\t\tchar ch = localeString.charAt(i);\n\t\t\tif (ch != '_' && !Character.isLetterOrDigit(ch)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Locale value \\\"\" + localeString + \"\\\" contains invalid characters\");\n\t\t\t}\n\t\t}\n\t\tString[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n\t\tString language = (parts.length > 0 ? parts[0] : \"\");\n\t\tString country = (parts.length > 1 ? parts[1] : \"\");\n\t\tString variant = \"\";\n\t\tif (parts.length >= 2) {\n\t\t\t// There is definitely a variant, and it is everything after the country\n\t\t\t// code sans the separator between the country code and the variant.\n\t\t\tint endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n\t\t\t// Strip off any leading '_' and whitespace, what's left is the variant.\n\t\t\tvariant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n\t\t\tif (variant.startsWith(\"_\")) {\n\t\t\t\tvariant = trimLeadingCharacter(variant, '_');\n\t\t\t}\n\t\t}\n\t\treturn (language.length() > 0 ? new Locale(language, country, variant) : null);\n\t}", "code_tokens": ["public", "static", "Locale", "parseLocaleString", "(", "String", "localeString", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "localeString", ".", "length", "(", ")", ";", "i", "++", ")", "{", "char", "ch", "=", "localeString", ".", "charAt", "(", "i", ")", ";", "if", "(", "ch", "!=", "'_'", "&&", "!", "Character", ".", "isLetterOrDigit", "(", "ch", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Locale value ", "\\\"", "\"", "+", "localeString", "+", "\"", "\\\"", " contains invalid characters", "\"", ")", ";", "}", "}", "String", "[", "]", "parts", "=", "tokenizeToStringArray", "(", "localeString", ",", "\"", "_ ", "\"", ",", "false", ",", "false", ")", ";", "String", "language", "=", "(", "parts", ".", "length", ">", "0", "?", "parts", "[", "0", "]", ":", "\"", "\"", ")", ";", "String", "country", "=", "(", "parts", ".", "length", ">", "1", "?", "parts", "[", "1", "]", ":", "\"", "\"", ")", ";", "String", "variant", "=", "\"", "\"", ";", "if", "(", "parts", ".", "length", ">=", "2", ")", "{", "int", "endIndexOfCountryCode", "=", "localeString", ".", "indexOf", "(", "country", ")", "+", "country", ".", "length", "(", ")", ";", "variant", "=", "trimLeadingWhitespace", "(", "localeString", ".", "substring", "(", "endIndexOfCountryCode", ")", ")", ";", "if", "(", "variant", ".", "startsWith", "(", "\"", "_", "\"", ")", ")", "{", "variant", "=", "trimLeadingCharacter", "(", "variant", ",", "'_'", ")", ";", "}", "}", "return", "(", "language", ".", "length", "(", ")", ">", "0", "?", "new", "Locale", "(", "language", ",", "country", ",", "variant", ")", ":", "null", ")", ";", "}"], "idx": 10473, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "f4a2282d9d9f6e58029022c58311a1db07f7defc", "function_name": "parseLocaleString", "body_hash": "dd32c67105ebc42c5b59f4f10acb5ac46533a041"}
{"code": "protected Key engineDoPhase(\n        Key     key,\n        boolean lastPhase) \n        throws InvalidKeyException, IllegalStateException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        if (!(key instanceof DHPublicKey))\n        {\n            throw new InvalidKeyException(\"DHKeyAgreement doPhase requires DHPublicKey\");\n        }\n        DHPublicKey pubKey = (DHPublicKey)key;\n\n        if (!pubKey.getParams().getG().equals(g) || !pubKey.getParams().getP().equals(p))\n        {\n            throw new InvalidKeyException(\"DHPublicKey not for this KeyAgreement!\");\n        }\n\n        if (lastPhase)\n        {\n            result = ((DHPublicKey)key).getY().modPow(x, p);\n            return null;\n        }\n        else\n        {\n            result = ((DHPublicKey)key).getY().modPow(x, p);\n        }\n\n        return new BCDHPublicKey(result, pubKey.getParams());\n    }", "code_tokens": ["protected", "Key", "engineDoPhase", "(", "Key", "key", ",", "boolean", "lastPhase", ")", "throws", "InvalidKeyException", ",", "IllegalStateException", "{", "if", "(", "x", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "Diffie-Hellman not initialised.", "\"", ")", ";", "}", "if", "(", "!", "(", "key", "instanceof", "DHPublicKey", ")", ")", "{", "throw", "new", "InvalidKeyException", "(", "\"", "DHKeyAgreement doPhase requires DHPublicKey", "\"", ")", ";", "}", "DHPublicKey", "pubKey", "=", "(", "DHPublicKey", ")", "key", ";", "if", "(", "!", "pubKey", ".", "getParams", "(", ")", ".", "getG", "(", ")", ".", "equals", "(", "g", ")", "||", "!", "pubKey", ".", "getParams", "(", ")", ".", "getP", "(", ")", ".", "equals", "(", "p", ")", ")", "{", "throw", "new", "InvalidKeyException", "(", "\"", "DHPublicKey not for this KeyAgreement!", "\"", ")", ";", "}", "if", "(", "lastPhase", ")", "{", "result", "=", "(", "(", "DHPublicKey", ")", "key", ")", ".", "getY", "(", ")", ".", "modPow", "(", "x", ",", "p", ")", ";", "return", "null", ";", "}", "else", "{", "result", "=", "(", "(", "DHPublicKey", ")", "key", ")", ".", "getY", "(", ")", ".", "modPow", "(", "x", ",", "p", ")", ";", "}", "return", "new", "BCDHPublicKey", "(", "result", ",", "pubKey", ".", "getParams", "(", ")", ")", ";", "}"], "idx": 42120, "cwe": "CWE-320", "target": 1, "status": "VULNERABLE", "commit": "1127131c89021612c6eefa26dbe5714c194e7495", "function_name": "engineDoPhase", "body_hash": "d651b9d4cef015ae9d20b2ec01e6c75bc5adcb8c"}
{"code": "protected final String getWindowOpenJavaScript()\n\t{\n\t\tAppendingStringBuffer buffer = new AppendingStringBuffer(500);\n\n\t\tif (isCustomComponent() == true)\n\t\t{\n\t\t\tbuffer.append(\"var element = document.getElementById(\\\"\");\n\t\t\tbuffer.append(getContentMarkupId());\n\t\t\tbuffer.append(\"\\\");\\n\");\n\t\t}\n\n\t\tbuffer.append(\"var settings = new Object();\\n\");\n\n\t\tappendAssignment(buffer, \"settings.minWidth\", getMinimalWidth());\n\t\tappendAssignment(buffer, \"settings.minHeight\", getMinimalHeight());\n\t\tappendAssignment(buffer, \"settings.className\", getCssClassName());\n\t\tappendAssignment(buffer, \"settings.width\", getInitialWidth());\n\n\t\tif ((isUseInitialHeight() == true) || (isCustomComponent() == false))\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.height\", getInitialHeight());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.append(\"settings.height=null;\\n\");\n\t\t}\n\n\t\tappendAssignment(buffer, \"settings.resizable\", isResizable());\n\n\t\tif (isResizable() == false)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.widthUnit\", getWidthUnit());\n\t\t\tappendAssignment(buffer, \"settings.heightUnit\", getHeightUnit());\n\t\t}\n\n\t\tif (isCustomComponent() == false)\n\t\t{\n\t\t\tPage page = createPage();\n\t\t\tif (page == null)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\"Error creating page for modal dialog.\");\n\t\t\t}\n\t\t\tCharSequence pageUrl;\n\t\t\tRequestCycle requestCycle = RequestCycle.get();\n\n\t\t\tpage.getSession().getPageManager().touchPage(page);\n\t\t\tif (page.isPageStateless())\n\t\t\t{\n\t\t\t\tpageUrl = requestCycle.urlFor(page.getClass(), page.getPageParameters());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\n\t\t\t\tpageUrl = requestCycle.urlFor(handler);\n\t\t\t}\n\n\t\t\tappendAssignment(buffer, \"settings.src\", pageUrl);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.append(\"settings.element=element;\\n\");\n\t\t}\n\n\t\tif (getCookieName() != null)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.cookieId\", getCookieName());\n\t\t}\n\n\t\tObject title = getTitle() != null ? getTitle().getObject() : null;\n\t\tif (title != null)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.title\", escapeQuotes(title.toString()));\n\t\t}\n\n\t\tif (getMaskType() == MaskType.TRANSPARENT)\n\t\t{\n\t\t\tbuffer.append(\"settings.mask=\\\"transparent\\\";\\n\");\n\t\t}\n\t\telse if (getMaskType() == MaskType.SEMI_TRANSPARENT)\n\t\t{\n\t\t\tbuffer.append(\"settings.mask=\\\"semi-transparent\\\";\\n\");\n\t\t}\n\n\t\tappendAssignment(buffer, \"settings.autoSize\", autoSize);\n\n\t\tappendAssignment(buffer, \"settings.unloadConfirmation\", showUnloadConfirmation());\n\n\t\t// set true if we set a windowclosedcallback\n\t\tboolean haveCloseCallback = false;\n\n\t\t// in case user is interested in window close callback or we have a pagemap to clean attach\n\t\t// notification request\n\t\tif (windowClosedCallback != null)\n\t\t{\n\t\t\tWindowClosedBehavior behavior = getBehaviors(WindowClosedBehavior.class).get(0);\n\t\t\tbuffer.append(\"settings.onClose = function() { \");\n\t\t\tbuffer.append(behavior.getCallbackScript());\n\t\t\tbuffer.append(\" };\\n\");\n\n\t\t\thaveCloseCallback = true;\n\t\t}\n\n\t\t// in case we didn't set windowclosecallback, we need at least callback on close button, to\n\t\t// close window property (thus cleaning the shown flag)\n\t\tif ((closeButtonCallback != null) || (haveCloseCallback == false))\n\t\t{\n\t\t\tCloseButtonBehavior behavior = getBehaviors(CloseButtonBehavior.class).get(0);\n\t\t\tbuffer.append(\"settings.onCloseButton = function() { \");\n\t\t\tbuffer.append(behavior.getCallbackScript());\n\t\t\tbuffer.append(\";return false;};\\n\");\n\t\t}\n\n\t\tpostProcessSettings(buffer);\n\n\t\tbuffer.append(getShowJavaScript());\n\t\treturn buffer.toString();\n\t}", "code_tokens": ["protected", "final", "String", "getWindowOpenJavaScript", "(", ")", "{", "AppendingStringBuffer", "buffer", "=", "new", "AppendingStringBuffer", "(", "500", ")", ";", "if", "(", "isCustomComponent", "(", ")", "==", "true", ")", "{", "buffer", ".", "append", "(", "\"", "var element = document.getElementById(", "\\\"", "\"", ")", ";", "buffer", ".", "append", "(", "getContentMarkupId", "(", ")", ")", ";", "buffer", ".", "append", "(", "\"", "\\\"", ");", "\\n", "\"", ")", ";", "}", "buffer", ".", "append", "(", "\"", "var settings = new Object();", "\\n", "\"", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.minWidth", "\"", ",", "getMinimalWidth", "(", ")", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.minHeight", "\"", ",", "getMinimalHeight", "(", ")", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.className", "\"", ",", "getCssClassName", "(", ")", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.width", "\"", ",", "getInitialWidth", "(", ")", ")", ";", "if", "(", "(", "isUseInitialHeight", "(", ")", "==", "true", ")", "||", "(", "isCustomComponent", "(", ")", "==", "false", ")", ")", "{", "appendAssignment", "(", "buffer", ",", "\"", "settings.height", "\"", ",", "getInitialHeight", "(", ")", ")", ";", "}", "else", "{", "buffer", ".", "append", "(", "\"", "settings.height=null;", "\\n", "\"", ")", ";", "}", "appendAssignment", "(", "buffer", ",", "\"", "settings.resizable", "\"", ",", "isResizable", "(", ")", ")", ";", "if", "(", "isResizable", "(", ")", "==", "false", ")", "{", "appendAssignment", "(", "buffer", ",", "\"", "settings.widthUnit", "\"", ",", "getWidthUnit", "(", ")", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.heightUnit", "\"", ",", "getHeightUnit", "(", ")", ")", ";", "}", "if", "(", "isCustomComponent", "(", ")", "==", "false", ")", "{", "Page", "page", "=", "createPage", "(", ")", ";", "if", "(", "page", "==", "null", ")", "{", "throw", "new", "WicketRuntimeException", "(", "\"", "Error creating page for modal dialog.", "\"", ")", ";", "}", "CharSequence", "pageUrl", ";", "RequestCycle", "requestCycle", "=", "RequestCycle", ".", "get", "(", ")", ";", "page", ".", "getSession", "(", ")", ".", "getPageManager", "(", ")", ".", "touchPage", "(", "page", ")", ";", "if", "(", "page", ".", "isPageStateless", "(", ")", ")", "{", "pageUrl", "=", "requestCycle", ".", "urlFor", "(", "page", ".", "getClass", "(", ")", ",", "page", ".", "getPageParameters", "(", ")", ")", ";", "}", "else", "{", "IRequestHandler", "handler", "=", "new", "RenderPageRequestHandler", "(", "new", "PageProvider", "(", "page", ")", ")", ";", "pageUrl", "=", "requestCycle", ".", "urlFor", "(", "handler", ")", ";", "}", "appendAssignment", "(", "buffer", ",", "\"", "settings.src", "\"", ",", "pageUrl", ")", ";", "}", "else", "{", "buffer", ".", "append", "(", "\"", "settings.element=element;", "\\n", "\"", ")", ";", "}", "if", "(", "getCookieName", "(", ")", "!=", "null", ")", "{", "appendAssignment", "(", "buffer", ",", "\"", "settings.cookieId", "\"", ",", "getCookieName", "(", ")", ")", ";", "}", "Object", "title", "=", "getTitle", "(", ")", "!=", "null", "?", "getTitle", "(", ")", ".", "getObject", "(", ")", ":", "null", ";", "if", "(", "title", "!=", "null", ")", "{", "appendAssignment", "(", "buffer", ",", "\"", "settings.title", "\"", ",", "escapeQuotes", "(", "title", ".", "toString", "(", ")", ")", ")", ";", "}", "if", "(", "getMaskType", "(", ")", "==", "MaskType", ".", "TRANSPARENT", ")", "{", "buffer", ".", "append", "(", "\"", "settings.mask=", "\\\"", "transparent", "\\\"", ";", "\\n", "\"", ")", ";", "}", "else", "if", "(", "getMaskType", "(", ")", "==", "MaskType", ".", "SEMI_TRANSPARENT", ")", "{", "buffer", ".", "append", "(", "\"", "settings.mask=", "\\\"", "semi-transparent", "\\\"", ";", "\\n", "\"", ")", ";", "}", "appendAssignment", "(", "buffer", ",", "\"", "settings.autoSize", "\"", ",", "autoSize", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.unloadConfirmation", "\"", ",", "showUnloadConfirmation", "(", ")", ")", ";", "boolean", "haveCloseCallback", "=", "false", ";", "if", "(", "windowClosedCallback", "!=", "null", ")", "{", "WindowClosedBehavior", "behavior", "=", "getBehaviors", "(", "WindowClosedBehavior", ".", "class", ")", ".", "get", "(", "0", ")", ";", "buffer", ".", "append", "(", "\"", "settings.onClose = function() { ", "\"", ")", ";", "buffer", ".", "append", "(", "behavior", ".", "getCallbackScript", "(", ")", ")", ";", "buffer", ".", "append", "(", "\"", " };", "\\n", "\"", ")", ";", "haveCloseCallback", "=", "true", ";", "}", "if", "(", "(", "closeButtonCallback", "!=", "null", ")", "||", "(", "haveCloseCallback", "==", "false", ")", ")", "{", "CloseButtonBehavior", "behavior", "=", "getBehaviors", "(", "CloseButtonBehavior", ".", "class", ")", ".", "get", "(", "0", ")", ";", "buffer", ".", "append", "(", "\"", "settings.onCloseButton = function() { ", "\"", ")", ";", "buffer", ".", "append", "(", "behavior", ".", "getCallbackScript", "(", ")", ")", ";", "buffer", ".", "append", "(", "\"", ";return false;};", "\\n", "\"", ")", ";", "}", "postProcessSettings", "(", "buffer", ")", ";", "buffer", ".", "append", "(", "getShowJavaScript", "(", ")", ")", ";", "return", "buffer", ".", "toString", "(", ")", ";", "}"], "idx": 81549, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "dffba2ce410ec7e917ad350d3528af4df67bc348", "function_name": "getWindowOpenJavaScript", "body_hash": "178037444f7b987c4233acb0268e7b7c6901f107"}
{"code": "private void checkRestrictedClass(Object o, Object method) {\n    if (o instanceof Class || o instanceof ClassLoader || o instanceof Thread) {\n      throw new MethodNotFoundException(\n        \"Cannot find method '\" + method + \"' in \" + o.getClass()\n      );\n    }\n  }", "code_tokens": ["private", "void", "checkRestrictedClass", "(", "Object", "o", ",", "Object", "method", ")", "{", "if", "(", "o", "instanceof", "Class", "||", "o", "instanceof", "ClassLoader", "||", "o", "instanceof", "Thread", ")", "{", "throw", "new", "MethodNotFoundException", "(", "\"", "Cannot find method '", "\"", "+", "method", "+", "\"", "' in ", "\"", "+", "o", ".", "getClass", "(", ")", ")", ";", "}", "}"], "idx": 89791, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "5dfa5b87318744a4d020b66d5f7747acc36b213b", "function_name": "checkRestrictedClass", "body_hash": "398e7f986c4c41de1026b1af2ed3445493219e4e"}
{"code": "@Override\n    public AcceptedInvitation acceptInvitation(String code, String password) {\n        ExpiringCode data = expiringCodeStore.retrieveCode(code);\n\n        Map<String,String> userData = JsonUtils.readValue(data.getData(), new TypeReference<Map<String, String>>() {});\n        String userId = userData.get(USER_ID);\n        String clientId = userData.get(CLIENT_ID);\n        String redirectUri = userData.get(REDIRECT_URI);\n\n        ScimUser user = scimUserProvisioning.retrieve(userId);\n\n        user = scimUserProvisioning.verifyUser(userId, user.getVersion());\n\n\n        if (OriginKeys.UAA.equals(user.getOrigin()) && StringUtils.hasText(password)) {\n            PasswordChangeRequest request = new PasswordChangeRequest();\n            request.setPassword(password);\n            scimUserProvisioning.changePassword(userId, null, password);\n        }\n\n        String redirectLocation = \"/home\";\n        try {\n            ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n            Set<String> redirectUris = clientDetails.getRegisteredRedirectUri();\n            redirectLocation = UaaUrlUtils.findMatchingRedirectUri(redirectUris, redirectUri, redirectLocation);\n        } catch (NoSuchClientException x) {\n            logger.debug(\"Unable to find client_id for invitation:\"+clientId);\n        } catch (Exception x) {\n            logger.error(\"Unable to resolve redirect for clientID:\"+clientId, x);\n        }\n        return new AcceptedInvitation(redirectLocation, user);\n    }", "code_tokens": ["@", "Override", "public", "AcceptedInvitation", "acceptInvitation", "(", "String", "code", ",", "String", "password", ")", "{", "ExpiringCode", "data", "=", "expiringCodeStore", ".", "retrieveCode", "(", "code", ")", ";", "Map", "<", "String", ",", "String", ">", "userData", "=", "JsonUtils", ".", "readValue", "(", "data", ".", "getData", "(", ")", ",", "new", "TypeReference", "<", "Map", "<", "String", ",", "String", ">", ">", "(", ")", "{", "}", ")", ";", "String", "userId", "=", "userData", ".", "get", "(", "USER_ID", ")", ";", "String", "clientId", "=", "userData", ".", "get", "(", "CLIENT_ID", ")", ";", "String", "redirectUri", "=", "userData", ".", "get", "(", "REDIRECT_URI", ")", ";", "ScimUser", "user", "=", "scimUserProvisioning", ".", "retrieve", "(", "userId", ")", ";", "user", "=", "scimUserProvisioning", ".", "verifyUser", "(", "userId", ",", "user", ".", "getVersion", "(", ")", ")", ";", "if", "(", "OriginKeys", ".", "UAA", ".", "equals", "(", "user", ".", "getOrigin", "(", ")", ")", "&&", "StringUtils", ".", "hasText", "(", "password", ")", ")", "{", "PasswordChangeRequest", "request", "=", "new", "PasswordChangeRequest", "(", ")", ";", "request", ".", "setPassword", "(", "password", ")", ";", "scimUserProvisioning", ".", "changePassword", "(", "userId", ",", "null", ",", "password", ")", ";", "}", "String", "redirectLocation", "=", "\"", "/home", "\"", ";", "try", "{", "ClientDetails", "clientDetails", "=", "clientDetailsService", ".", "loadClientByClientId", "(", "clientId", ")", ";", "Set", "<", "String", ">", "redirectUris", "=", "clientDetails", ".", "getRegisteredRedirectUri", "(", ")", ";", "redirectLocation", "=", "UaaUrlUtils", ".", "findMatchingRedirectUri", "(", "redirectUris", ",", "redirectUri", ",", "redirectLocation", ")", ";", "}", "catch", "(", "NoSuchClientException", "x", ")", "{", "logger", ".", "debug", "(", "\"", "Unable to find client_id for invitation:", "\"", "+", "clientId", ")", ";", "}", "catch", "(", "Exception", "x", ")", "{", "logger", ".", "error", "(", "\"", "Unable to resolve redirect for clientID:", "\"", "+", "clientId", ",", "x", ")", ";", "}", "return", "new", "AcceptedInvitation", "(", "redirectLocation", ",", "user", ")", ";", "}"], "idx": 34046, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "b3834364ab573e9655348193780a56a602fe87b7", "function_name": "acceptInvitation", "body_hash": "59991427d2c74b668fefa3b0c9b9d56e0aede519"}
{"code": "public static OMElement buildOMElement(String payload) throws RegistryException {\n        OMElement element;\n        try {\n            element = AXIOMUtil.stringToOM(payload);\n            element.build();\n        } catch (Exception e) {\n            String message = \"Unable to parse the XML configuration. Please validate the XML configuration\";\n            log.error(message,e);\n            throw new RegistryException(message,e);\n        }\n        return element;\n    }", "code_tokens": ["public", "static", "OMElement", "buildOMElement", "(", "String", "payload", ")", "throws", "RegistryException", "{", "OMElement", "element", ";", "try", "{", "element", "=", "AXIOMUtil", ".", "stringToOM", "(", "payload", ")", ";", "element", ".", "build", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "String", "message", "=", "\"", "Unable to parse the XML configuration. Please validate the XML configuration", "\"", ";", "log", ".", "error", "(", "message", ",", "e", ")", ";", "throw", "new", "RegistryException", "(", "message", ",", "e", ")", ";", "}", "return", "element", ";", "}"], "idx": 67256, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "80362069", "function_name": "buildOMElement", "body_hash": "f8aa4041c1163d081ea19638858dad72c17cbfbf"}
{"code": "@Override\n    public Object handleEvent(Map<String, String> headers, Object body, int instance) throws AppException, IOException {\n        String id = headers.get(\"id\");\n        if (id == null) {\n            throw new IllegalArgumentException(\"Missing parameter 'id'\");\n        }\n        if (id.equals(\"1\")) {\n            // to set status, key-values or parametric types, we can use EventEnvelope as a result wrapper\n            EventEnvelope result = new EventEnvelope();\n            ObjectWithGenericType<SamplePoJo> genericObject = new ObjectWithGenericType<>();\n            // return some place-holder values to demonstrate the PoJo can be transported over the network\n            SamplePoJo mock = new SamplePoJo(1, \"Generic class with parametric type SamplePoJo\",\n                                    \"200 World Blvd, Planet Earth\");\n            // set current timestamp to indicate that the object is a new one\n            mock.setDate(new Date());\n            // set instance count and service origin ID to show that the object comes from a different instance\n            mock.setInstance(instance);\n            mock.setOrigin(Platform.getInstance().getOrigin());\n\n            genericObject.setId(101);\n            genericObject.setContent(mock);\n\n            result.setBody(genericObject);\n            result.setParametricType(SamplePoJo.class);\n\n            return result;\n        } else {\n            throw new AppException(404, \"Not found. Try id = 1\");\n        }\n    }", "code_tokens": ["@", "Override", "public", "Object", "handleEvent", "(", "Map", "<", "String", ",", "String", ">", "headers", ",", "Object", "body", ",", "int", "instance", ")", "throws", "AppException", ",", "IOException", "{", "String", "id", "=", "headers", ".", "get", "(", "\"", "id", "\"", ")", ";", "if", "(", "id", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Missing parameter 'id'", "\"", ")", ";", "}", "if", "(", "id", ".", "equals", "(", "\"", "1", "\"", ")", ")", "{", "EventEnvelope", "result", "=", "new", "EventEnvelope", "(", ")", ";", "ObjectWithGenericType", "<", "SamplePoJo", ">", "genericObject", "=", "new", "ObjectWithGenericType", "<", ">", "(", ")", ";", "SamplePoJo", "mock", "=", "new", "SamplePoJo", "(", "1", ",", "\"", "Generic class with parametric type SamplePoJo", "\"", ",", "\"", "200 World Blvd, Planet Earth", "\"", ")", ";", "mock", ".", "setDate", "(", "new", "Date", "(", ")", ")", ";", "mock", ".", "setInstance", "(", "instance", ")", ";", "mock", ".", "setOrigin", "(", "Platform", ".", "getInstance", "(", ")", ".", "getOrigin", "(", ")", ")", ";", "genericObject", ".", "setId", "(", "101", ")", ";", "genericObject", ".", "setContent", "(", "mock", ")", ";", "result", ".", "setBody", "(", "genericObject", ")", ";", "result", ".", "setParametricType", "(", "SamplePoJo", ".", "class", ")", ";", "return", "result", ";", "}", "else", "{", "throw", "new", "AppException", "(", "404", ",", "\"", "Not found. Try id = 1", "\"", ")", ";", "}", "}"], "idx": 67358, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "f647a01347485d2afe3a0b735eab3d0121d61f46", "function_name": "handleEvent", "body_hash": "15564a4e01fcc64ec7063eda21d02db4aa88fa35"}
{"code": "public List<Map<String, Object>> read(int headerRowIndex, int startRowIndex, int endRowIndex) {\r\n\t\tcheckNotClosed();\r\n\t\t// \u8fb9\u754c\u5224\u65ad\r\n\t\tfinal int firstRowNum = sheet.getFirstRowNum();\r\n\t\tfinal int lastRowNum = sheet.getLastRowNum();\r\n\t\tif (headerRowIndex < firstRowNum) {\r\n\t\t\tthrow new IndexOutOfBoundsException(StrUtil.format(\"Header row index {} is lower than first row index {}.\", headerRowIndex, firstRowNum));\r\n\t\t} else if (headerRowIndex > lastRowNum) {\r\n\t\t\tthrow new IndexOutOfBoundsException(StrUtil.format(\"Header row index {} is greater than last row index {}.\", headerRowIndex, firstRowNum));\r\n\t\t}\r\n\t\tstartRowIndex = Math.max(startRowIndex, firstRowNum);// \u8bfb\u53d6\u8d77\u59cb\u884c\uff08\u5305\u542b\uff09\r\n\t\tendRowIndex = Math.min(endRowIndex, lastRowNum);// \u8bfb\u53d6\u7ed3\u675f\u884c\uff08\u5305\u542b\uff09\r\n\r\n\t\t// \u8bfb\u53d6header\r\n\t\tList<Object> headerList = readRow(sheet.getRow(headerRowIndex));\r\n\r\n\t\tfinal List<Map<String, Object>> result = new ArrayList<>(endRowIndex - startRowIndex + 1);\r\n\t\tList<Object> rowList;\r\n\t\tfor (int i = startRowIndex; i <= endRowIndex; i++) {\r\n\t\t\tif (i != headerRowIndex) {\r\n\t\t\t\t// \u8df3\u8fc7\u6807\u9898\u884c\r\n\t\t\t\trowList = readRow(sheet.getRow(i));\r\n\t\t\t\tif (CollUtil.isNotEmpty(rowList) || false == ignoreEmptyRow) {\r\n\t\t\t\t\tif (null == rowList) {\r\n\t\t\t\t\t\trowList = new ArrayList<>(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult.add(IterUtil.toMap(aliasHeader(headerList), rowList));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "code_tokens": ["public", "List", "<", "Map", "<", "String", ",", "Object", ">", ">", "read", "(", "int", "headerRowIndex", ",", "int", "startRowIndex", ",", "int", "endRowIndex", ")", "{", "checkNotClosed", "(", ")", ";", "final", "int", "firstRowNum", "=", "sheet", ".", "getFirstRowNum", "(", ")", ";", "final", "int", "lastRowNum", "=", "sheet", ".", "getLastRowNum", "(", ")", ";", "if", "(", "headerRowIndex", "<", "firstRowNum", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", "StrUtil", ".", "format", "(", "\"", "Header row index {} is lower than first row index {}.", "\"", ",", "headerRowIndex", ",", "firstRowNum", ")", ")", ";", "}", "else", "if", "(", "headerRowIndex", ">", "lastRowNum", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", "StrUtil", ".", "format", "(", "\"", "Header row index {} is greater than last row index {}.", "\"", ",", "headerRowIndex", ",", "firstRowNum", ")", ")", ";", "}", "startRowIndex", "=", "Math", ".", "max", "(", "startRowIndex", ",", "firstRowNum", ")", ";", "endRowIndex", "=", "Math", ".", "min", "(", "endRowIndex", ",", "lastRowNum", ")", ";", "List", "<", "Object", ">", "headerList", "=", "readRow", "(", "sheet", ".", "getRow", "(", "headerRowIndex", ")", ")", ";", "final", "List", "<", "Map", "<", "String", ",", "Object", ">", ">", "result", "=", "new", "ArrayList", "<", ">", "(", "endRowIndex", "-", "startRowIndex", "+", "1", ")", ";", "List", "<", "Object", ">", "rowList", ";", "for", "(", "int", "i", "=", "startRowIndex", ";", "i", "<=", "endRowIndex", ";", "i", "++", ")", "{", "if", "(", "i", "!=", "headerRowIndex", ")", "{", "rowList", "=", "readRow", "(", "sheet", ".", "getRow", "(", "i", ")", ")", ";", "if", "(", "CollUtil", ".", "isNotEmpty", "(", "rowList", ")", "||", "false", "==", "ignoreEmptyRow", ")", "{", "if", "(", "null", "==", "rowList", ")", "{", "rowList", "=", "new", "ArrayList", "<", ">", "(", "0", ")", ";", "}", "result", ".", "add", "(", "IterUtil", ".", "toMap", "(", "aliasHeader", "(", "headerList", ")", ",", "rowList", ")", ")", ";", "}", "}", "}", "return", "result", ";", "}"], "idx": 23399, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "9f8a801c7b98b75ee681c0988e1a58bcfdc21756", "function_name": "read", "body_hash": "2971a80e59052393c55b740f75c24160d31db46b"}
{"code": "private Document parseXml(String xmlContent) {\n\t\ttry {\n\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tDocument document = builder.parse(new InputSource(new StringReader(xmlContent)));\n\n\t\t\tdocument.getDocumentElement().normalize();\n\n\t\t\treturn document;\n\t\t} catch (Exception e) {\n\t\t\tthrow new JadxRuntimeException(\"Can not parse xml content\", e);\n\t\t}\n\t}", "code_tokens": ["private", "Document", "parseXml", "(", "String", "xmlContent", ")", "{", "try", "{", "DocumentBuilder", "builder", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ".", "newDocumentBuilder", "(", ")", ";", "Document", "document", "=", "builder", ".", "parse", "(", "new", "InputSource", "(", "new", "StringReader", "(", "xmlContent", ")", ")", ")", ";", "document", ".", "getDocumentElement", "(", ")", ".", "normalize", "(", ")", ";", "return", "document", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "JadxRuntimeException", "(", "\"", "Can not parse xml content", "\"", ",", "e", ")", ";", "}", "}"], "idx": 67503, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "d22db30166e7cb369d72be41382bb63ac8b81c52", "function_name": "parseXml", "body_hash": "df6967a335a5656ddd87e2924bd5b4fef3ec727c"}
{"code": "@Override\n\tprotected File getFile(HandlerRequest<EmptyRequestBody, FileMessageParameters> handlerRequest) {\n\t\tif (logDir == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString filename = handlerRequest.getPathParameter(LogFileNamePathParameter.class);\n\t\treturn new File(logDir, filename);\n\t}", "code_tokens": ["@", "Override", "protected", "File", "getFile", "(", "HandlerRequest", "<", "EmptyRequestBody", ",", "FileMessageParameters", ">", "handlerRequest", ")", "{", "if", "(", "logDir", "==", "null", ")", "{", "return", "null", ";", "}", "String", "filename", "=", "handlerRequest", ".", "getPathParameter", "(", "LogFileNamePathParameter", ".", "class", ")", ";", "return", "new", "File", "(", "logDir", ",", "filename", ")", ";", "}"], "idx": 64364, "cwe": "CWE-552", "target": 1, "status": "VULNERABLE", "commit": "b561010b0ee741543c3953306037f00d7a9f0801", "function_name": "getFile", "body_hash": "e11ddf58ceefbab734b79caa36c0e0cbaf763e22"}
{"code": "public static File createTempFile() throws IOException {\n        final File file = File.createTempFile(\"rep\", \"tmp\");\n        // Make sure the file is deleted when JVM is shutdown at last.\n        file.deleteOnExit();\n        return file;\n    }", "code_tokens": ["public", "static", "File", "createTempFile", "(", ")", "throws", "IOException", "{", "final", "File", "file", "=", "File", ".", "createTempFile", "(", "\"", "rep", "\"", ",", "\"", "tmp", "\"", ")", ";", "file", ".", "deleteOnExit", "(", ")", ";", "return", "file", ";", "}"], "idx": 71606, "cwe": "CWE-668", "target": 1, "status": "VULNERABLE", "commit": "f3cadb38dcc5b20e515706fae68dce533ad6c737", "function_name": "createTempFile", "body_hash": "bb3040b361b6dd33f45f5cb2897c029454ef5f05"}
{"code": "public FormValidation doCheckCommand(@QueryParameter String value) {\n            if(Util.fixEmptyAndTrim(value)==null)\n                return FormValidation.error(Messages.CommandLauncher_NoLaunchCommand());\n            else\n                return FormValidation.ok();\n        }", "code_tokens": ["public", "FormValidation", "doCheckCommand", "(", "@", "QueryParameter", "String", "value", ")", "{", "if", "(", "Util", ".", "fixEmptyAndTrim", "(", "value", ")", "==", "null", ")", "return", "FormValidation", ".", "error", "(", "Messages", ".", "CommandLauncher_NoLaunchCommand", "(", ")", ")", ";", "else", "return", "FormValidation", ".", "ok", "(", ")", ";", "}"], "idx": 76676, "cwe": "CWE-78", "target": 1, "status": "VULNERABLE", "commit": "d7ea3f40efedd50541a57b943d5f7bbed046d091", "function_name": "doCheckCommand", "body_hash": "095133c9687440e3f6086dbcc8d2f949615ea859"}
{"code": "protected String resolveAction() throws JspException {\n\t\tString action = getAction();\n\t\tString servletRelativeAction = getServletRelativeAction();\n\t\tif (StringUtils.hasText(action)) {\n\t\t\taction = getDisplayString(evaluate(ACTION_ATTRIBUTE, action));\n\t\t\treturn processAction(action);\n\t\t}\n\t\telse if (StringUtils.hasText(servletRelativeAction)) {\n\t\t\tString pathToServlet = getRequestContext().getPathToServlet();\n\t\t\tif (servletRelativeAction.startsWith(\"/\") && !servletRelativeAction.startsWith(getRequestContext().getContextPath())) {\n\t\t\t\tservletRelativeAction = pathToServlet + servletRelativeAction;\n\t\t\t}\n\t\t\tservletRelativeAction = getDisplayString(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));\n\t\t\treturn processAction(servletRelativeAction);\n\t\t}\n\t\telse {\n\t\t\tString requestUri = getRequestContext().getRequestUri();\n\t\t\tServletResponse response = this.pageContext.getResponse();\n\t\t\tif (response instanceof HttpServletResponse) {\n\t\t\t\trequestUri = ((HttpServletResponse) response).encodeURL(requestUri);\n\t\t\t\tString queryString = getRequestContext().getQueryString();\n\t\t\t\tif (StringUtils.hasText(queryString)) {\n\t\t\t\t\trequestUri += \"?\" + HtmlUtils.htmlEscape(queryString);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (StringUtils.hasText(requestUri)) {\n\t\t\t\treturn processAction(requestUri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Attribute 'action' is required. \" +\n\t\t\t\t\t\t\"Attempted to resolve against current request URI but request URI was null.\");\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["protected", "String", "resolveAction", "(", ")", "throws", "JspException", "{", "String", "action", "=", "getAction", "(", ")", ";", "String", "servletRelativeAction", "=", "getServletRelativeAction", "(", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "action", ")", ")", "{", "action", "=", "getDisplayString", "(", "evaluate", "(", "ACTION_ATTRIBUTE", ",", "action", ")", ")", ";", "return", "processAction", "(", "action", ")", ";", "}", "else", "if", "(", "StringUtils", ".", "hasText", "(", "servletRelativeAction", ")", ")", "{", "String", "pathToServlet", "=", "getRequestContext", "(", ")", ".", "getPathToServlet", "(", ")", ";", "if", "(", "servletRelativeAction", ".", "startsWith", "(", "\"", "/", "\"", ")", "&&", "!", "servletRelativeAction", ".", "startsWith", "(", "getRequestContext", "(", ")", ".", "getContextPath", "(", ")", ")", ")", "{", "servletRelativeAction", "=", "pathToServlet", "+", "servletRelativeAction", ";", "}", "servletRelativeAction", "=", "getDisplayString", "(", "evaluate", "(", "ACTION_ATTRIBUTE", ",", "servletRelativeAction", ")", ")", ";", "return", "processAction", "(", "servletRelativeAction", ")", ";", "}", "else", "{", "String", "requestUri", "=", "getRequestContext", "(", ")", ".", "getRequestUri", "(", ")", ";", "ServletResponse", "response", "=", "this", ".", "pageContext", ".", "getResponse", "(", ")", ";", "if", "(", "response", "instanceof", "HttpServletResponse", ")", "{", "requestUri", "=", "(", "(", "HttpServletResponse", ")", "response", ")", ".", "encodeURL", "(", "requestUri", ")", ";", "String", "queryString", "=", "getRequestContext", "(", ")", ".", "getQueryString", "(", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "queryString", ")", ")", "{", "requestUri", "+=", "\"", "?", "\"", "+", "HtmlUtils", ".", "htmlEscape", "(", "queryString", ")", ";", "}", "}", "if", "(", "StringUtils", ".", "hasText", "(", "requestUri", ")", ")", "{", "return", "processAction", "(", "requestUri", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Attribute 'action' is required. ", "\"", "+", "\"", "Attempted to resolve against current request URI but request URI was null.", "\"", ")", ";", "}", "}", "}"], "idx": 80446, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "741b4b229ae032bd17175b46f98673ce0bd2d485", "function_name": "resolveAction", "body_hash": "55bc76b1d0f595bc76d84bee28d8fd958777827a"}
{"code": "@Exported(name=\"property\",inline=true)\n    public List<UserProperty> getAllProperties() {\n        if (hasPermission(Jenkins.ADMINISTER)) {\n            return Collections.unmodifiableList(properties);\n        }\n\n        return Collections.emptyList();\n    }", "code_tokens": ["@", "Exported", "(", "name", "=", "\"", "property", "\"", ",", "inline", "=", "true", ")", "public", "List", "<", "UserProperty", ">", "getAllProperties", "(", ")", "{", "if", "(", "hasPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ")", "{", "return", "Collections", ".", "unmodifiableList", "(", "properties", ")", ";", "}", "return", "Collections", ".", "emptyList", "(", ")", ";", "}"], "idx": 14851, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "7b1f8e96a8d97dd09e5e093fcdb010b3295acc77", "function_name": "getAllProperties", "body_hash": "4393f66a8839b6e04b7dc0c0c43902971d65694c"}
{"code": "protected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n        }\n\n        // This is returned from the directory so will be attribute value\n        // escaped if required\n        String dn = user.getDN();\n        // This is the name the user provided to the authentication process so\n        // it will not be escaped\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        // Start with roles retrieved from the user entry\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        // Are we configured to do role searches?\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        // Set up parameters for an appropriate search\n        String filter = connection.roleFormat.format(new String[] {\n                doFilterEscaping(dn),\n                doFilterEscaping(doAttributeValueEscaping(username)),\n                userRoleId });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                nameParts[i] = name.get(i);\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        // Perform the configured search and process the results\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;  // Should never happen, but just in case ...\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n                }\n                String dname = getDistinguishedName(connection.context, roleBase, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n                }\n            }\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        // if nested group search is enabled, perform searches for nested groups until no new group is found\n        if (getRoleNested()) {\n\n            // The following efficient algorithm is known as memberOf Algorithm, as described in \"Practices in\n            // Directory Groups\". It avoids group slurping and handles cyclic group memberships as well.\n            // See http://middleware.internet2.edu/dir/ for details\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>(); // Stores the groups we find in this iteration\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    filter = connection.roleFormat.format(new String[] { doFilterEscaping(group.getKey()),\n                            group.getValue(), group.getValue() });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, roleBase, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n    }", "code_tokens": ["protected", "List", "<", "String", ">", "getRoles", "(", "JNDIConnection", "connection", ",", "User", "user", ")", "throws", "NamingException", "{", "if", "(", "user", "==", "null", ")", "{", "return", "null", ";", "}", "String", "dn", "=", "user", ".", "getDN", "(", ")", ";", "String", "username", "=", "user", ".", "getUserName", "(", ")", ";", "String", "userRoleId", "=", "user", ".", "getUserRoleId", "(", ")", ";", "if", "(", "dn", "==", "null", "||", "username", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  getRoles(", "\"", "+", "dn", "+", "\"", ")", "\"", ")", ";", "}", "List", "<", "String", ">", "list", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "String", ">", "userRoles", "=", "user", ".", "getRoles", "(", ")", ";", "if", "(", "userRoles", "!=", "null", ")", "{", "list", ".", "addAll", "(", "userRoles", ")", ";", "}", "if", "(", "commonRole", "!=", "null", ")", "{", "list", ".", "add", "(", "commonRole", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "list", ".", "size", "(", ")", "+", "\"", " user internal roles", "\"", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found user internal roles ", "\"", "+", "list", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "(", "connection", ".", "roleFormat", "==", "null", ")", "||", "(", "roleName", "==", "null", ")", ")", "{", "return", "list", ";", "}", "String", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "dn", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "username", ")", ")", ",", "userRoleId", "}", ")", ";", "SearchControls", "controls", "=", "new", "SearchControls", "(", ")", ";", "if", "(", "roleSubtree", ")", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "}", "else", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "ONELEVEL_SCOPE", ")", ";", "}", "controls", ".", "setReturningAttributes", "(", "new", "String", "[", "]", "{", "roleName", "}", ")", ";", "String", "base", "=", "null", ";", "if", "(", "connection", ".", "roleBaseFormat", "!=", "null", ")", "{", "NameParser", "np", "=", "connection", ".", "context", ".", "getNameParser", "(", "\"", "\"", ")", ";", "Name", "name", "=", "np", ".", "parse", "(", "dn", ")", ";", "String", "nameParts", "[", "]", "=", "new", "String", "[", "name", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "name", ".", "size", "(", ")", ";", "i", "++", ")", "{", "nameParts", "[", "i", "]", "=", "name", ".", "get", "(", "i", ")", ";", "}", "base", "=", "connection", ".", "roleBaseFormat", ".", "format", "(", "nameParts", ")", ";", "}", "else", "{", "base", "=", "\"", "\"", ";", "}", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "base", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "if", "(", "results", "==", "null", ")", "{", "return", "list", ";", "}", "Map", "<", "String", ",", "String", ">", "groupMap", "=", "new", "HashMap", "<", ">", "(", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "Set", "<", "Entry", "<", "String", ",", "String", ">", ">", "entries", "=", "groupMap", ".", "entrySet", "(", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "entries", ".", "size", "(", ")", "+", "\"", " direct roles", "\"", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "entry", ":", "entries", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found direct role ", "\"", "+", "entry", ".", "getKey", "(", ")", "+", "\"", " -> ", "\"", "+", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}", "if", "(", "getRoleNested", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newGroups", "=", "new", "HashMap", "<", ">", "(", "groupMap", ")", ";", "while", "(", "!", "newGroups", ".", "isEmpty", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newThisRound", "=", "new", "HashMap", "<", ">", "(", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "group", ":", "newGroups", ".", "entrySet", "(", ")", ")", "{", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "group", ".", "getKey", "(", ")", ")", ",", "group", ".", "getValue", "(", ")", ",", "group", ".", "getValue", "(", ")", "}", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "Perform a nested group search with base ", "\"", "+", "roleBase", "+", "\"", " and filter ", "\"", "+", "filter", ")", ";", "}", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "roleBase", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", "&&", "!", "groupMap", ".", "keySet", "(", ")", ".", "contains", "(", "dname", ")", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "newThisRound", ".", "put", "(", "dname", ",", "name", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found nested role ", "\"", "+", "dname", "+", "\"", " -> ", "\"", "+", "name", ")", ";", "}", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "}", "newGroups", "=", "newThisRound", ";", "}", "}", "list", ".", "addAll", "(", "groupMap", ".", "values", "(", ")", ")", ";", "return", "list", ";", "}"], "idx": 161, "cwe": "CWE-116", "target": 1, "status": "VULNERABLE", "commit": "17208c645d68d2af1444ee8c64f36a9b8f0ba76f", "function_name": "getRoles", "body_hash": "2719823e7972ada218bd4ecc873fba0905d667c6"}
{"code": "public void handleMessage(Message message) {\n        if (isGET(message) && message.getContent(List.class) != null) {\n            LOG.fine(\"DocLiteralInInterceptor skipped in HTTP GET method\");\n            return;\n        }\n\n        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n        DataReader<XMLStreamReader> dr = getDataReader(message);\n        MessageContentsList parameters = new MessageContentsList();\n\n        Exchange exchange = message.getExchange();\n        BindingOperationInfo bop = exchange.getBindingOperationInfo();\n\n        boolean client = isRequestor(message);\n\n        //if body is empty and we have BindingOperationInfo, we do not need to match \n        //operation anymore, just return\n        if (bop != null && !StaxUtils.toNextElement(xmlReader)) {\n            // body may be empty for partial response to decoupled request\n            return;\n        }\n\n        //bop might be a unwrapped, wrap it back so that we can get correct info \n        if (bop != null && bop.isUnwrapped()) {\n            bop = bop.getWrappedOperation();\n        }\n\n        if (bop == null) {\n            QName startQName = xmlReader == null \n                ? new QName(\"http://cxf.apache.org/jaxws/provider\", \"invoke\")\n                : xmlReader.getName();\n            bop = getBindingOperationInfo(exchange, startQName, client);\n        }\n\n        try {\n            if (bop != null && bop.isUnwrappedCapable()) {\n                ServiceInfo si = bop.getBinding().getService();\n                // Wrapped case\n                MessageInfo msgInfo = setMessage(message, bop, client, si);\n    \n                // Determine if we should keep the parameters wrapper\n                if (shouldWrapParameters(msgInfo, message)) {\n                    QName startQName = xmlReader.getName();\n                    if (!msgInfo.getMessageParts().get(0).getConcreteName().equals(startQName)) {\n                        throw new Fault(\"UNEXPECTED_WRAPPER_ELEMENT\", LOG, null, startQName,\n                                        msgInfo.getMessageParts().get(0).getConcreteName());\n                    }\n                    Object wrappedObject = dr.read(msgInfo.getMessageParts().get(0), xmlReader);\n                    parameters.put(msgInfo.getMessageParts().get(0), wrappedObject);\n                } else {\n                    // Unwrap each part individually if we don't have a wrapper\n    \n                    bop = bop.getUnwrappedOperation();\n    \n                    msgInfo = setMessage(message, bop, client, si);\n                    List<MessagePartInfo> messageParts = msgInfo.getMessageParts();\n                    Iterator<MessagePartInfo> itr = messageParts.iterator();\n    \n                    // advance just past the wrapped element so we don't get\n                    // stuck\n                    if (xmlReader.getEventType() == XMLStreamConstants.START_ELEMENT) {\n                        StaxUtils.nextEvent(xmlReader);\n                    }\n    \n                    // loop through each child element\n                    getPara(xmlReader, dr, parameters, itr, message);\n                }\n    \n            } else {\n                //Bare style\n                BindingMessageInfo msgInfo = null;\n\n    \n                Endpoint ep = exchange.get(Endpoint.class);\n                ServiceInfo si = ep.getEndpointInfo().getService();\n                if (bop != null) { //for xml binding or client side\n                    if (client) {\n                        msgInfo = bop.getOutput();\n                    } else {\n                        msgInfo = bop.getInput();\n                        if (bop.getOutput() == null) {\n                            exchange.setOneWay(true);\n                        }\n                    }\n                    if (msgInfo == null) {\n                        return;\n                    }\n                    setMessage(message, bop, client, si, msgInfo.getMessageInfo());\n                }\n    \n                Collection<OperationInfo> operations = null;\n                operations = new ArrayList<OperationInfo>();\n                operations.addAll(si.getInterface().getOperations());\n    \n                if (xmlReader == null || !StaxUtils.toNextElement(xmlReader)) {\n                    // empty input\n    \n                    // TO DO : check duplicate operation with no input\n                    for (OperationInfo op : operations) {\n                        MessageInfo bmsg = op.getInput();\n                        if (bmsg.getMessageParts().size() == 0) {\n                            BindingOperationInfo boi = ep.getEndpointInfo().getBinding().getOperation(op);\n                            exchange.put(BindingOperationInfo.class, boi);\n                            exchange.put(OperationInfo.class, op);\n                            exchange.setOneWay(op.isOneWay());\n                        }\n                    }\n                    return;\n                }\n    \n                int paramNum = 0;\n    \n                do {\n                    QName elName = xmlReader.getName();\n                    Object o = null;\n    \n                    MessagePartInfo p;\n                    if (!client && msgInfo != null && msgInfo.getMessageParts() != null \n                        && msgInfo.getMessageParts().size() == 0) {\n                        //no input messagePartInfo\n                        return;\n                    }\n                    \n                    if (msgInfo != null && msgInfo.getMessageParts() != null \n                        && msgInfo.getMessageParts().size() > 0) {\n                        if (msgInfo.getMessageParts().size() > paramNum) {\n                            p = msgInfo.getMessageParts().get(paramNum);\n                        } else {\n                            p = null;\n                        }\n                    } else {\n                        p = findMessagePart(exchange, operations, elName, client, paramNum, message);\n                    }\n    \n                    if (p == null) {\n                        throw new Fault(new org.apache.cxf.common.i18n.Message(\"NO_PART_FOUND\", LOG, elName),\n                                        Fault.FAULT_CODE_CLIENT);\n                    }\n    \n                    o = dr.read(p, xmlReader);\n                    if (Boolean.TRUE.equals(si.getProperty(\"soap.force.doclit.bare\")) \n                        && parameters.isEmpty()) {\n                        // webservice provider does not need to ensure size\n                        parameters.add(o);\n                    } else {\n                        parameters.put(p, o);\n                    }\n                    \n                    paramNum++;\n                    if (message.getContent(XMLStreamReader.class) == null || o == xmlReader) {\n                        xmlReader = null;\n                    }\n                } while (xmlReader != null && StaxUtils.toNextElement(xmlReader));\n    \n            }\n    \n            message.setContent(List.class, parameters);\n        } catch (Fault f) {\n            if (!isRequestor(message)) {\n                f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n            }\n            throw f;\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "{", "if", "(", "isGET", "(", "message", ")", "&&", "message", ".", "getContent", "(", "List", ".", "class", ")", "!=", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "DocLiteralInInterceptor skipped in HTTP GET method", "\"", ")", ";", "return", ";", "}", "DepthXMLStreamReader", "xmlReader", "=", "getXMLStreamReader", "(", "message", ")", ";", "DataReader", "<", "XMLStreamReader", ">", "dr", "=", "getDataReader", "(", "message", ")", ";", "MessageContentsList", "parameters", "=", "new", "MessageContentsList", "(", ")", ";", "Exchange", "exchange", "=", "message", ".", "getExchange", "(", ")", ";", "BindingOperationInfo", "bop", "=", "exchange", ".", "getBindingOperationInfo", "(", ")", ";", "boolean", "client", "=", "isRequestor", "(", "message", ")", ";", "if", "(", "bop", "!=", "null", "&&", "!", "StaxUtils", ".", "toNextElement", "(", "xmlReader", ")", ")", "{", "return", ";", "}", "if", "(", "bop", "!=", "null", "&&", "bop", ".", "isUnwrapped", "(", ")", ")", "{", "bop", "=", "bop", ".", "getWrappedOperation", "(", ")", ";", "}", "if", "(", "bop", "==", "null", ")", "{", "QName", "startQName", "=", "xmlReader", "==", "null", "?", "new", "QName", "(", "\"", "http://cxf.apache.org/jaxws/provider", "\"", ",", "\"", "invoke", "\"", ")", ":", "xmlReader", ".", "getName", "(", ")", ";", "bop", "=", "getBindingOperationInfo", "(", "exchange", ",", "startQName", ",", "client", ")", ";", "}", "try", "{", "if", "(", "bop", "!=", "null", "&&", "bop", ".", "isUnwrappedCapable", "(", ")", ")", "{", "ServiceInfo", "si", "=", "bop", ".", "getBinding", "(", ")", ".", "getService", "(", ")", ";", "MessageInfo", "msgInfo", "=", "setMessage", "(", "message", ",", "bop", ",", "client", ",", "si", ")", ";", "if", "(", "shouldWrapParameters", "(", "msgInfo", ",", "message", ")", ")", "{", "QName", "startQName", "=", "xmlReader", ".", "getName", "(", ")", ";", "if", "(", "!", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "0", ")", ".", "getConcreteName", "(", ")", ".", "equals", "(", "startQName", ")", ")", "{", "throw", "new", "Fault", "(", "\"", "UNEXPECTED_WRAPPER_ELEMENT", "\"", ",", "LOG", ",", "null", ",", "startQName", ",", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "0", ")", ".", "getConcreteName", "(", ")", ")", ";", "}", "Object", "wrappedObject", "=", "dr", ".", "read", "(", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "0", ")", ",", "xmlReader", ")", ";", "parameters", ".", "put", "(", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "0", ")", ",", "wrappedObject", ")", ";", "}", "else", "{", "bop", "=", "bop", ".", "getUnwrappedOperation", "(", ")", ";", "msgInfo", "=", "setMessage", "(", "message", ",", "bop", ",", "client", ",", "si", ")", ";", "List", "<", "MessagePartInfo", ">", "messageParts", "=", "msgInfo", ".", "getMessageParts", "(", ")", ";", "Iterator", "<", "MessagePartInfo", ">", "itr", "=", "messageParts", ".", "iterator", "(", ")", ";", "if", "(", "xmlReader", ".", "getEventType", "(", ")", "==", "XMLStreamConstants", ".", "START_ELEMENT", ")", "{", "StaxUtils", ".", "nextEvent", "(", "xmlReader", ")", ";", "}", "getPara", "(", "xmlReader", ",", "dr", ",", "parameters", ",", "itr", ",", "message", ")", ";", "}", "}", "else", "{", "BindingMessageInfo", "msgInfo", "=", "null", ";", "Endpoint", "ep", "=", "exchange", ".", "get", "(", "Endpoint", ".", "class", ")", ";", "ServiceInfo", "si", "=", "ep", ".", "getEndpointInfo", "(", ")", ".", "getService", "(", ")", ";", "if", "(", "bop", "!=", "null", ")", "{", "if", "(", "client", ")", "{", "msgInfo", "=", "bop", ".", "getOutput", "(", ")", ";", "}", "else", "{", "msgInfo", "=", "bop", ".", "getInput", "(", ")", ";", "if", "(", "bop", ".", "getOutput", "(", ")", "==", "null", ")", "{", "exchange", ".", "setOneWay", "(", "true", ")", ";", "}", "}", "if", "(", "msgInfo", "==", "null", ")", "{", "return", ";", "}", "setMessage", "(", "message", ",", "bop", ",", "client", ",", "si", ",", "msgInfo", ".", "getMessageInfo", "(", ")", ")", ";", "}", "Collection", "<", "OperationInfo", ">", "operations", "=", "null", ";", "operations", "=", "new", "ArrayList", "<", "OperationInfo", ">", "(", ")", ";", "operations", ".", "addAll", "(", "si", ".", "getInterface", "(", ")", ".", "getOperations", "(", ")", ")", ";", "if", "(", "xmlReader", "==", "null", "||", "!", "StaxUtils", ".", "toNextElement", "(", "xmlReader", ")", ")", "{", "for", "(", "OperationInfo", "op", ":", "operations", ")", "{", "MessageInfo", "bmsg", "=", "op", ".", "getInput", "(", ")", ";", "if", "(", "bmsg", ".", "getMessageParts", "(", ")", ".", "size", "(", ")", "==", "0", ")", "{", "BindingOperationInfo", "boi", "=", "ep", ".", "getEndpointInfo", "(", ")", ".", "getBinding", "(", ")", ".", "getOperation", "(", "op", ")", ";", "exchange", ".", "put", "(", "BindingOperationInfo", ".", "class", ",", "boi", ")", ";", "exchange", ".", "put", "(", "OperationInfo", ".", "class", ",", "op", ")", ";", "exchange", ".", "setOneWay", "(", "op", ".", "isOneWay", "(", ")", ")", ";", "}", "}", "return", ";", "}", "int", "paramNum", "=", "0", ";", "do", "{", "QName", "elName", "=", "xmlReader", ".", "getName", "(", ")", ";", "Object", "o", "=", "null", ";", "MessagePartInfo", "p", ";", "if", "(", "!", "client", "&&", "msgInfo", "!=", "null", "&&", "msgInfo", ".", "getMessageParts", "(", ")", "!=", "null", "&&", "msgInfo", ".", "getMessageParts", "(", ")", ".", "size", "(", ")", "==", "0", ")", "{", "return", ";", "}", "if", "(", "msgInfo", "!=", "null", "&&", "msgInfo", ".", "getMessageParts", "(", ")", "!=", "null", "&&", "msgInfo", ".", "getMessageParts", "(", ")", ".", "size", "(", ")", ">", "0", ")", "{", "if", "(", "msgInfo", ".", "getMessageParts", "(", ")", ".", "size", "(", ")", ">", "paramNum", ")", "{", "p", "=", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "paramNum", ")", ";", "}", "else", "{", "p", "=", "null", ";", "}", "}", "else", "{", "p", "=", "findMessagePart", "(", "exchange", ",", "operations", ",", "elName", ",", "client", ",", "paramNum", ",", "message", ")", ";", "}", "if", "(", "p", "==", "null", ")", "{", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "NO_PART_FOUND", "\"", ",", "LOG", ",", "elName", ")", ",", "Fault", ".", "FAULT_CODE_CLIENT", ")", ";", "}", "o", "=", "dr", ".", "read", "(", "p", ",", "xmlReader", ")", ";", "if", "(", "Boolean", ".", "TRUE", ".", "equals", "(", "si", ".", "getProperty", "(", "\"", "soap.force.doclit.bare", "\"", ")", ")", "&&", "parameters", ".", "isEmpty", "(", ")", ")", "{", "parameters", ".", "add", "(", "o", ")", ";", "}", "else", "{", "parameters", ".", "put", "(", "p", ",", "o", ")", ";", "}", "paramNum", "++", ";", "if", "(", "message", ".", "getContent", "(", "XMLStreamReader", ".", "class", ")", "==", "null", "||", "o", "==", "xmlReader", ")", "{", "xmlReader", "=", "null", ";", "}", "}", "while", "(", "xmlReader", "!=", "null", "&&", "StaxUtils", ".", "toNextElement", "(", "xmlReader", ")", ")", ";", "}", "message", ".", "setContent", "(", "List", ".", "class", ",", "parameters", ")", ";", "}", "catch", "(", "Fault", "f", ")", "{", "if", "(", "!", "isRequestor", "(", "message", ")", ")", "{", "f", ".", "setFaultCode", "(", "Fault", ".", "FAULT_CODE_CLIENT", ")", ";", "}", "throw", "f", ";", "}", "}"], "idx": 5546, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "9c70abe28fbf2b4c4df0b93ed12295ea5a012554", "function_name": "handleMessage", "body_hash": "d7cd891b844726caf98677a228715c2081072af3"}
{"code": "protected boolean acceptableName(String name) {\n        return isAccepted(name) && !isExcluded(name);\n    }", "code_tokens": ["protected", "boolean", "acceptableName", "(", "String", "name", ")", "{", "return", "isAccepted", "(", "name", ")", "&&", "!", "isExcluded", "(", "name", ")", ";", "}"], "idx": 35289, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "87935af56a27235e9399308ee1fcfb74f8edcefa", "function_name": "acceptableName", "body_hash": "4097179b5306bf011c5b9bdea98b86edbe93a1d9"}
{"code": "@Override\n\t@Exported(visibility = 2)\n\tpublic String getName() {\n\t\treturn hudson.Util.escape(pageCounts.page);\n\t}", "code_tokens": ["@", "Override", "@", "Exported", "(", "visibility", "=", "2", ")", "public", "String", "getName", "(", ")", "{", "return", "hudson", ".", "Util", ".", "escape", "(", "pageCounts", ".", "page", ")", ";", "}"], "idx": 80919, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "db72cc4", "function_name": "getName", "body_hash": "fa7b167086218f6fd143d7f81d56bf08312ea5c2"}
{"code": "@Override\n    public InputStream getResourceAsStream(String path) throws IOException {\n        final URL rootResourceURL = classLoader.getResource(THEME_RESOURCES_RESOURCES);\n        if (rootResourceURL == null) {\n            return null;\n        }\n        final String rootPath = rootResourceURL.getPath();\n        final URL resourceURL = classLoader.getResource(THEME_RESOURCES_RESOURCES + path);\n        if(resourceURL == null || !resourceURL.getPath().startsWith(rootPath)) {\n            return null;\n        }\n        else {\n            return resourceURL.openConnection().getInputStream();\n        }\n    }", "code_tokens": ["@", "Override", "public", "InputStream", "getResourceAsStream", "(", "String", "path", ")", "throws", "IOException", "{", "final", "URL", "rootResourceURL", "=", "classLoader", ".", "getResource", "(", "THEME_RESOURCES_RESOURCES", ")", ";", "if", "(", "rootResourceURL", "==", "null", ")", "{", "return", "null", ";", "}", "final", "String", "rootPath", "=", "rootResourceURL", ".", "getPath", "(", ")", ";", "final", "URL", "resourceURL", "=", "classLoader", ".", "getResource", "(", "THEME_RESOURCES_RESOURCES", "+", "path", ")", ";", "if", "(", "resourceURL", "==", "null", "||", "!", "resourceURL", ".", "getPath", "(", ")", ".", "startsWith", "(", "rootPath", ")", ")", "{", "return", "null", ";", "}", "else", "{", "return", "resourceURL", ".", "openConnection", "(", ")", ".", "getInputStream", "(", ")", ";", "}", "}"], "idx": 64460, "cwe": "CWE-552", "target": 0, "status": "FIXED", "commit": "73f0474008e1bebd0733e62a22aceda9e5de6743", "function_name": "getResourceAsStream", "body_hash": "a79e640fd2761bb7e1de658d707670999d4c43b8"}
{"code": "@Override\n    public long skip(long ln) throws IOException {\n        long n = IOUtils.skip(super.in, ln);\n        if (n != ln) {\n            throw new IOException(\"tried to skip \"+ln + \" but actually skipped: \"+n);\n        }\n        position += n;\n        return n;\n    }", "code_tokens": ["@", "Override", "public", "long", "skip", "(", "long", "ln", ")", "throws", "IOException", "{", "long", "n", "=", "IOUtils", ".", "skip", "(", "super", ".", "in", ",", "ln", ")", ";", "if", "(", "n", "!=", "ln", ")", "{", "throw", "new", "IOException", "(", "\"", "tried to skip ", "\"", "+", "ln", "+", "\"", " but actually skipped: ", "\"", "+", "n", ")", ";", "}", "position", "+=", "n", ";", "return", "n", ";", "}"], "idx": 82932, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "e9b2c38", "function_name": "skip", "body_hash": "24b05a635926c9eb3c728c221f3a9fc2b49219c6"}
{"code": "@Override\n    public Object handleEvent(Map<String, String> headers, Object body, int instance) throws AppException, IOException {\n\n        String id = headers.get(\"id\");\n        if (id == null) {\n            throw new IllegalArgumentException(\"Missing parameter 'id'\");\n        }\n\n        if (id.equals(\"1\")) {\n            // to set status, key-values or parametric types, we can use EventEnvelope as a result wrapper\n            EventEnvelope result = new EventEnvelope();\n\n            ObjectWithGenericType<SamplePoJo> genericObject = new ObjectWithGenericType<>();\n            // return some place-holder values to demonstrate the PoJo can be transported over the network\n            SamplePoJo mock = new SamplePoJo(1, \"Class with generic type resolved at run-time to be SamplePoJo\", \"200 World Blvd, Planet Earth\");\n            // set current timestamp to indicate that the object is a new one\n            mock.setDate(new Date());\n            // set instance count and service origin ID to show that the object comes from a different instance\n            mock.setInstance(instance);\n            mock.setOrigin(Platform.getInstance().getOrigin());\n\n            genericObject.setId(101);\n            genericObject.setContent(mock);\n\n            result.setBody(genericObject);\n            result.setParametricType(SamplePoJo.class);\n\n            return result;\n        } else {\n            throw new AppException(404, \"Not found. Try id = 1\");\n        }\n\n    }", "code_tokens": ["@", "Override", "public", "Object", "handleEvent", "(", "Map", "<", "String", ",", "String", ">", "headers", ",", "Object", "body", ",", "int", "instance", ")", "throws", "AppException", ",", "IOException", "{", "String", "id", "=", "headers", ".", "get", "(", "\"", "id", "\"", ")", ";", "if", "(", "id", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Missing parameter 'id'", "\"", ")", ";", "}", "if", "(", "id", ".", "equals", "(", "\"", "1", "\"", ")", ")", "{", "EventEnvelope", "result", "=", "new", "EventEnvelope", "(", ")", ";", "ObjectWithGenericType", "<", "SamplePoJo", ">", "genericObject", "=", "new", "ObjectWithGenericType", "<", ">", "(", ")", ";", "SamplePoJo", "mock", "=", "new", "SamplePoJo", "(", "1", ",", "\"", "Class with generic type resolved at run-time to be SamplePoJo", "\"", ",", "\"", "200 World Blvd, Planet Earth", "\"", ")", ";", "mock", ".", "setDate", "(", "new", "Date", "(", ")", ")", ";", "mock", ".", "setInstance", "(", "instance", ")", ";", "mock", ".", "setOrigin", "(", "Platform", ".", "getInstance", "(", ")", ".", "getOrigin", "(", ")", ")", ";", "genericObject", ".", "setId", "(", "101", ")", ";", "genericObject", ".", "setContent", "(", "mock", ")", ";", "result", ".", "setBody", "(", "genericObject", ")", ";", "result", ".", "setParametricType", "(", "SamplePoJo", ".", "class", ")", ";", "return", "result", ";", "}", "else", "{", "throw", "new", "AppException", "(", "404", ",", "\"", "Not found. Try id = 1", "\"", ")", ";", "}", "}"], "idx": 67357, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "f647a01347485d2afe3a0b735eab3d0121d61f46", "function_name": "handleEvent", "body_hash": "edf35c7977a9d547ae6839addf1871a085041eb3"}
{"code": "@BeforeClass\n  public static void setupClass() {\n    FunctionService.registerFunction(alterConnectionFunction);\n    FunctionService.registerFunction(alterMappingFunction);\n    FunctionService.registerFunction(createConnectionFunction);\n    FunctionService.registerFunction(createMappingFunction);\n    FunctionService.registerFunction(describeConnectionFunction);\n    FunctionService.registerFunction(describeMappingFunction);\n    FunctionService.registerFunction(destroyConnectionFunction);\n    FunctionService.registerFunction(destroyMappingFunction);\n    FunctionService.registerFunction(listConnectionFunction);\n    FunctionService.registerFunction(listMappingFunction);\n    FunctionService.registerFunction(inheritsDefaultPermissionsFunction);\n  }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "setupClass", "(", ")", "{", "FunctionService", ".", "registerFunction", "(", "alterConnectionFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "alterMappingFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "createConnectionFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "createMappingFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "describeConnectionFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "describeMappingFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "destroyConnectionFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "destroyMappingFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "listConnectionFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "listMappingFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "inheritsDefaultPermissionsFunction", ")", ";", "}"], "idx": 87262, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "00be4f9774e1adf8e7ccc2664da8005fc30bb11d", "function_name": "setupClass", "body_hash": "833264443e4570569f6307425c217cb2be5fa814"}
{"code": "public static String fillAuthentication(String mavenSettingsContent, final Boolean isReplaceAllServerDefinitions,\n                                            Map<String, StandardUsernameCredentials> mavenServerId2jenkinsCredential,\n                                            FilePath workDir, List<String> tempFiles) throws Exception {\n        String content = mavenSettingsContent;\n\n        if (mavenServerId2jenkinsCredential.isEmpty()) {\n            return mavenSettingsContent;\n        }\n\n        // TODO: switch to XMLUtils.parse(Reader) when the baseline > 2.179 or  XMLUtils.parse(InputSteam) > 2.265\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        //documentBuilderFactory.isValidating() is false by default, so these attributes won't avoid to parse an usual maven settings.\n        documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n        documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new StringReader(content)));\n\n        Map<String, Node> removedMavenServers = Collections.emptyMap();\n\n        // locate the server node(s)\n        XPath xpath = XPathFactory.newInstance().newXPath();\n        Node serversNode = (Node) xpath.evaluate(\"/settings/servers\", doc, XPathConstants.NODE);\n        if (serversNode == null) {\n            // need to create a 'servers' node\n            Node settingsNode = (Node) xpath.evaluate(\"/settings\", doc, XPathConstants.NODE);\n            serversNode = doc.createElement(\"servers\");\n            settingsNode.appendChild(serversNode);\n        } else {\n            // remove the server nodes\n        \tremovedMavenServers = removeMavenServerDefinitions(serversNode, mavenServerId2jenkinsCredential.keySet(), Boolean.TRUE.equals(isReplaceAllServerDefinitions));\n        }\n\n        for (Entry<String, StandardUsernameCredentials> mavenServerId2JenkinsCredential : mavenServerId2jenkinsCredential.entrySet()) {\n\n            final StandardUsernameCredentials credential = mavenServerId2JenkinsCredential.getValue();\n            String mavenServerId = mavenServerId2JenkinsCredential.getKey();\n\n            Node currentDefinition = removedMavenServers.get(mavenServerId);\n            if (credential instanceof StandardUsernamePasswordCredentials) {\n\n                StandardUsernamePasswordCredentials usernamePasswordCredentials = (StandardUsernamePasswordCredentials) credential;\n                LOGGER.log(Level.FINE, \"Maven Server ID {0}: use {1} / {2}\", new Object[]{mavenServerId, usernamePasswordCredentials.getId(), usernamePasswordCredentials.getDescription()});\n\n                final Element server = doc.createElement(\"server\");\n\n                // create and add the relevant xml elements\n                final Element id = doc.createElement(\"id\");\n                id.setTextContent(mavenServerId);\n                final Element password = doc.createElement(\"password\");\n                password.setTextContent(Secret.toString(usernamePasswordCredentials.getPassword()));\n                final Element username = doc.createElement(\"username\");\n                username.setTextContent(usernamePasswordCredentials.getUsername());\n\n                server.appendChild(id);\n                server.appendChild(username);\n                server.appendChild(password);\n                copyServerAttributes(currentDefinition,\tserver);\n\n                serversNode.appendChild(server);\n            } else if (credential instanceof SSHUserPrivateKey) {\n                SSHUserPrivateKey sshUserPrivateKey = (SSHUserPrivateKey) credential;\n                List<String> privateKeys = sshUserPrivateKey.getPrivateKeys();\n                String privateKeyContent;\n\n                if (privateKeys.isEmpty()) {\n                    LOGGER.log(Level.WARNING, \"Maven Server ID {0}: not private key defined in {1}, skip\", new Object[]{mavenServerId, sshUserPrivateKey.getId()});\n                    continue;\n                } else if (privateKeys.size() == 1) {\n                    LOGGER.log(Level.FINE, \"Maven Server ID {0}: use {1}\", new Object[]{mavenServerId, sshUserPrivateKey.getId()});\n                    privateKeyContent = privateKeys.get(0);\n                } else {\n                    LOGGER.log(Level.WARNING, \"Maven Server ID {0}: more than one ({1}) private key defined in {1}, use first private key\", new Object[]{mavenServerId, privateKeys.size(), sshUserPrivateKey.getId()});\n                    privateKeyContent = privateKeys.get(0);\n                }\n\n                final Element server = doc.createElement(\"server\");\n\n                // create and add the relevant xml elements\n                final Element id = doc.createElement(\"id\");\n                id.setTextContent(mavenServerId);\n\n                final Element username = doc.createElement(\"username\");\n                username.setTextContent(sshUserPrivateKey.getUsername());\n\n                workDir.mkdirs();\n                FilePath privateKeyFile = workDir.createTextTempFile(\"private-key-\", \".pem\", privateKeyContent, true);\n                privateKeyFile.chmod(0600);\n                tempFiles.add(privateKeyFile.getRemote());\n                LOGGER.log(Level.FINE, \"Create {0}\", new Object[]{privateKeyFile.getRemote()});\n\n                final Element privateKey = doc.createElement(\"privateKey\");\n                privateKey.setTextContent(privateKeyFile.getRemote());\n\n                final Element passphrase = doc.createElement(\"passphrase\");\n                passphrase.setTextContent(Secret.toString(sshUserPrivateKey.getPassphrase()));\n\n                server.appendChild(id);\n                server.appendChild(username);\n                server.appendChild(privateKey);\n                server.appendChild(passphrase);\n                copyServerAttributes(currentDefinition,\tserver);\n\n                serversNode.appendChild(server);\n            } else {\n                LOGGER.log(Level.WARNING, \"Maven Server ID {0}: credentials type of {1} not supported: {2}\",\n                        new Object[]{mavenServerId, credential == null ? null : credential.getId(), credential == null ? null : credential.getClass()});\n            }\n\n        }\n\n        // save the result\n        StringWriter writer = new StringWriter();\n        Transformer xformer = TransformerFactory.newInstance().newTransformer();\n        xformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        xformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n        xformer.transform(new DOMSource(doc), new StreamResult(writer));\n        content = writer.toString();\n\n        return content;\n    }", "code_tokens": ["public", "static", "String", "fillAuthentication", "(", "String", "mavenSettingsContent", ",", "final", "Boolean", "isReplaceAllServerDefinitions", ",", "Map", "<", "String", ",", "StandardUsernameCredentials", ">", "mavenServerId2jenkinsCredential", ",", "FilePath", "workDir", ",", "List", "<", "String", ">", "tempFiles", ")", "throws", "Exception", "{", "String", "content", "=", "mavenSettingsContent", ";", "if", "(", "mavenServerId2jenkinsCredential", ".", "isEmpty", "(", ")", ")", "{", "return", "mavenSettingsContent", ";", "}", "DocumentBuilderFactory", "documentBuilderFactory", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "documentBuilderFactory", ".", "setAttribute", "(", "XMLConstants", ".", "ACCESS_EXTERNAL_DTD", ",", "\"", "\"", ")", ";", "documentBuilderFactory", ".", "setAttribute", "(", "XMLConstants", ".", "ACCESS_EXTERNAL_SCHEMA", ",", "\"", "\"", ")", ";", "Document", "doc", "=", "documentBuilderFactory", ".", "newDocumentBuilder", "(", ")", ".", "parse", "(", "new", "InputSource", "(", "new", "StringReader", "(", "content", ")", ")", ")", ";", "Map", "<", "String", ",", "Node", ">", "removedMavenServers", "=", "Collections", ".", "emptyMap", "(", ")", ";", "XPath", "xpath", "=", "XPathFactory", ".", "newInstance", "(", ")", ".", "newXPath", "(", ")", ";", "Node", "serversNode", "=", "(", "Node", ")", "xpath", ".", "evaluate", "(", "\"", "/settings/servers", "\"", ",", "doc", ",", "XPathConstants", ".", "NODE", ")", ";", "if", "(", "serversNode", "==", "null", ")", "{", "Node", "settingsNode", "=", "(", "Node", ")", "xpath", ".", "evaluate", "(", "\"", "/settings", "\"", ",", "doc", ",", "XPathConstants", ".", "NODE", ")", ";", "serversNode", "=", "doc", ".", "createElement", "(", "\"", "servers", "\"", ")", ";", "settingsNode", ".", "appendChild", "(", "serversNode", ")", ";", "}", "else", "{", "removedMavenServers", "=", "removeMavenServerDefinitions", "(", "serversNode", ",", "mavenServerId2jenkinsCredential", ".", "keySet", "(", ")", ",", "Boolean", ".", "TRUE", ".", "equals", "(", "isReplaceAllServerDefinitions", ")", ")", ";", "}", "for", "(", "Entry", "<", "String", ",", "StandardUsernameCredentials", ">", "mavenServerId2JenkinsCredential", ":", "mavenServerId2jenkinsCredential", ".", "entrySet", "(", ")", ")", "{", "final", "StandardUsernameCredentials", "credential", "=", "mavenServerId2JenkinsCredential", ".", "getValue", "(", ")", ";", "String", "mavenServerId", "=", "mavenServerId2JenkinsCredential", ".", "getKey", "(", ")", ";", "Node", "currentDefinition", "=", "removedMavenServers", ".", "get", "(", "mavenServerId", ")", ";", "if", "(", "credential", "instanceof", "StandardUsernamePasswordCredentials", ")", "{", "StandardUsernamePasswordCredentials", "usernamePasswordCredentials", "=", "(", "StandardUsernamePasswordCredentials", ")", "credential", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Maven Server ID {0}: use {1} / {2}", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "usernamePasswordCredentials", ".", "getId", "(", ")", ",", "usernamePasswordCredentials", ".", "getDescription", "(", ")", "}", ")", ";", "final", "Element", "server", "=", "doc", ".", "createElement", "(", "\"", "server", "\"", ")", ";", "final", "Element", "id", "=", "doc", ".", "createElement", "(", "\"", "id", "\"", ")", ";", "id", ".", "setTextContent", "(", "mavenServerId", ")", ";", "final", "Element", "password", "=", "doc", ".", "createElement", "(", "\"", "password", "\"", ")", ";", "password", ".", "setTextContent", "(", "Secret", ".", "toString", "(", "usernamePasswordCredentials", ".", "getPassword", "(", ")", ")", ")", ";", "final", "Element", "username", "=", "doc", ".", "createElement", "(", "\"", "username", "\"", ")", ";", "username", ".", "setTextContent", "(", "usernamePasswordCredentials", ".", "getUsername", "(", ")", ")", ";", "server", ".", "appendChild", "(", "id", ")", ";", "server", ".", "appendChild", "(", "username", ")", ";", "server", ".", "appendChild", "(", "password", ")", ";", "copyServerAttributes", "(", "currentDefinition", ",", "server", ")", ";", "serversNode", ".", "appendChild", "(", "server", ")", ";", "}", "else", "if", "(", "credential", "instanceof", "SSHUserPrivateKey", ")", "{", "SSHUserPrivateKey", "sshUserPrivateKey", "=", "(", "SSHUserPrivateKey", ")", "credential", ";", "List", "<", "String", ">", "privateKeys", "=", "sshUserPrivateKey", ".", "getPrivateKeys", "(", ")", ";", "String", "privateKeyContent", ";", "if", "(", "privateKeys", ".", "isEmpty", "(", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Maven Server ID {0}: not private key defined in {1}, skip", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "sshUserPrivateKey", ".", "getId", "(", ")", "}", ")", ";", "continue", ";", "}", "else", "if", "(", "privateKeys", ".", "size", "(", ")", "==", "1", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Maven Server ID {0}: use {1}", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "sshUserPrivateKey", ".", "getId", "(", ")", "}", ")", ";", "privateKeyContent", "=", "privateKeys", ".", "get", "(", "0", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Maven Server ID {0}: more than one ({1}) private key defined in {1}, use first private key", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "privateKeys", ".", "size", "(", ")", ",", "sshUserPrivateKey", ".", "getId", "(", ")", "}", ")", ";", "privateKeyContent", "=", "privateKeys", ".", "get", "(", "0", ")", ";", "}", "final", "Element", "server", "=", "doc", ".", "createElement", "(", "\"", "server", "\"", ")", ";", "final", "Element", "id", "=", "doc", ".", "createElement", "(", "\"", "id", "\"", ")", ";", "id", ".", "setTextContent", "(", "mavenServerId", ")", ";", "final", "Element", "username", "=", "doc", ".", "createElement", "(", "\"", "username", "\"", ")", ";", "username", ".", "setTextContent", "(", "sshUserPrivateKey", ".", "getUsername", "(", ")", ")", ";", "workDir", ".", "mkdirs", "(", ")", ";", "FilePath", "privateKeyFile", "=", "workDir", ".", "createTextTempFile", "(", "\"", "private-key-", "\"", ",", "\"", ".pem", "\"", ",", "privateKeyContent", ",", "true", ")", ";", "privateKeyFile", ".", "chmod", "(", "0600", ")", ";", "tempFiles", ".", "add", "(", "privateKeyFile", ".", "getRemote", "(", ")", ")", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Create {0}", "\"", ",", "new", "Object", "[", "]", "{", "privateKeyFile", ".", "getRemote", "(", ")", "}", ")", ";", "final", "Element", "privateKey", "=", "doc", ".", "createElement", "(", "\"", "privateKey", "\"", ")", ";", "privateKey", ".", "setTextContent", "(", "privateKeyFile", ".", "getRemote", "(", ")", ")", ";", "final", "Element", "passphrase", "=", "doc", ".", "createElement", "(", "\"", "passphrase", "\"", ")", ";", "passphrase", ".", "setTextContent", "(", "Secret", ".", "toString", "(", "sshUserPrivateKey", ".", "getPassphrase", "(", ")", ")", ")", ";", "server", ".", "appendChild", "(", "id", ")", ";", "server", ".", "appendChild", "(", "username", ")", ";", "server", ".", "appendChild", "(", "privateKey", ")", ";", "server", ".", "appendChild", "(", "passphrase", ")", ";", "copyServerAttributes", "(", "currentDefinition", ",", "server", ")", ";", "serversNode", ".", "appendChild", "(", "server", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Maven Server ID {0}: credentials type of {1} not supported: {2}", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "credential", "==", "null", "?", "null", ":", "credential", ".", "getId", "(", ")", ",", "credential", "==", "null", "?", "null", ":", "credential", ".", "getClass", "(", ")", "}", ")", ";", "}", "}", "StringWriter", "writer", "=", "new", "StringWriter", "(", ")", ";", "Transformer", "xformer", "=", "TransformerFactory", ".", "newInstance", "(", ")", ".", "newTransformer", "(", ")", ";", "xformer", ".", "setOutputProperty", "(", "OutputKeys", ".", "INDENT", ",", "\"", "yes", "\"", ")", ";", "xformer", ".", "setOutputProperty", "(", "\"", "{http://xml.apache.org/xslt}indent-amount", "\"", ",", "\"", "2", "\"", ")", ";", "xformer", ".", "transform", "(", "new", "DOMSource", "(", "doc", ")", ",", "new", "StreamResult", "(", "writer", ")", ")", ";", "content", "=", "writer", ".", "toString", "(", ")", ";", "return", "content", ";", "}"], "idx": 69655, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "5f845bc", "function_name": "fillAuthentication", "body_hash": "188b6fd30e532cdaf82346529c3d1bd28b12a3c7"}
{"code": "public void register(ContainerBuilder builder, LocatableProperties props) {\n        alias(ObjectFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY, builder, props);\n        alias(FileManagerFactory.class, StrutsConstants.STRUTS_FILE_MANAGER_FACTORY, builder, props, Scope.SINGLETON);\n\n        alias(XWorkConverter.class, StrutsConstants.STRUTS_XWORKCONVERTER, builder, props);\n        alias(CollectionConverter.class, StrutsConstants.STRUTS_CONVERTER_COLLECTION, builder, props);\n        alias(ArrayConverter.class, StrutsConstants.STRUTS_CONVERTER_ARRAY, builder, props);\n        alias(DateConverter.class, StrutsConstants.STRUTS_CONVERTER_DATE, builder, props);\n        alias(NumberConverter.class, StrutsConstants.STRUTS_CONVERTER_NUMBER, builder, props);\n        alias(StringConverter.class, StrutsConstants.STRUTS_CONVERTER_STRING, builder, props);\n\n        alias(ConversionPropertiesProcessor.class, StrutsConstants.STRUTS_CONVERTER_PROPERTIES_PROCESSOR, builder, props);\n        alias(ConversionFileProcessor.class, StrutsConstants.STRUTS_CONVERTER_FILE_PROCESSOR, builder, props);\n        alias(ConversionAnnotationProcessor.class, StrutsConstants.STRUTS_CONVERTER_ANNOTATION_PROCESSOR, builder, props);\n        alias(TypeConverterCreator.class, StrutsConstants.STRUTS_CONVERTER_CREATOR, builder, props);\n        alias(TypeConverterHolder.class, StrutsConstants.STRUTS_CONVERTER_HOLDER, builder, props);\n\n        alias(TextProvider.class, StrutsConstants.STRUTS_XWORKTEXTPROVIDER, builder, props, Scope.DEFAULT);\n\n        alias(LocaleProvider.class, StrutsConstants.STRUTS_LOCALE_PROVIDER, builder, props);\n        alias(ActionProxyFactory.class, StrutsConstants.STRUTS_ACTIONPROXYFACTORY, builder, props);\n        alias(ObjectTypeDeterminer.class, StrutsConstants.STRUTS_OBJECTTYPEDETERMINER, builder, props);\n        alias(ActionMapper.class, StrutsConstants.STRUTS_MAPPER_CLASS, builder, props);\n        alias(MultiPartRequest.class, StrutsConstants.STRUTS_MULTIPART_PARSER, builder, props, Scope.DEFAULT);\n        alias(FreemarkerManager.class, StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME, builder, props);\n        alias(VelocityManager.class, StrutsConstants.STRUTS_VELOCITY_MANAGER_CLASSNAME, builder, props);\n        alias(UrlRenderer.class, StrutsConstants.STRUTS_URL_RENDERER, builder, props);\n        alias(ActionValidatorManager.class, StrutsConstants.STRUTS_ACTIONVALIDATORMANAGER, builder, props);\n        alias(ValueStackFactory.class, StrutsConstants.STRUTS_VALUESTACKFACTORY, builder, props);\n        alias(ReflectionProvider.class, StrutsConstants.STRUTS_REFLECTIONPROVIDER, builder, props);\n        alias(ReflectionContextFactory.class, StrutsConstants.STRUTS_REFLECTIONCONTEXTFACTORY, builder, props);\n        alias(PatternMatcher.class, StrutsConstants.STRUTS_PATTERNMATCHER, builder, props);\n        alias(StaticContentLoader.class, StrutsConstants.STRUTS_STATIC_CONTENT_LOADER, builder, props);\n        alias(UnknownHandlerManager.class, StrutsConstants.STRUTS_UNKNOWN_HANDLER_MANAGER, builder, props);\n        alias(UrlHelper.class, StrutsConstants.STRUTS_URL_HELPER, builder, props);\n\n        alias(TextParser.class, StrutsConstants.STRUTS_EXPRESSION_PARSER, builder, props);\n\n        if (\"true\".equalsIgnoreCase(props.getProperty(StrutsConstants.STRUTS_DEVMODE))) {\n            props.setProperty(StrutsConstants.STRUTS_I18N_RELOAD, \"true\");\n            props.setProperty(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, \"true\");\n            props.setProperty(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE, \"false\");\n            props.setProperty(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE_UPDATE_DELAY, \"0\");\n            // Convert struts properties into ones that xwork expects\n            props.setProperty(XWorkConstants.DEV_MODE, \"true\");\n        } else {\n            props.setProperty(XWorkConstants.DEV_MODE, \"false\");\n        }\n\n        // Convert Struts properties into XWork properties\n        convertIfExist(props, StrutsConstants.STRUTS_LOG_MISSING_PROPERTIES, XWorkConstants.LOG_MISSING_PROPERTIES);\n        convertIfExist(props, StrutsConstants.STRUTS_ENABLE_OGNL_EXPRESSION_CACHE, XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE);\n        convertIfExist(props, StrutsConstants.STRUTS_ENABLE_OGNL_EVAL_EXPRESSION, XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION);\n        convertIfExist(props, StrutsConstants.STRUTS_ALLOW_STATIC_METHOD_ACCESS, XWorkConstants.ALLOW_STATIC_METHOD_ACCESS);\n        convertIfExist(props, StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, XWorkConstants.RELOAD_XML_CONFIGURATION);\n\n        LocalizedTextUtil.addDefaultResourceBundle(\"org/apache/struts2/struts-messages\");\n        loadCustomResourceBundles(props);\n    }", "code_tokens": ["public", "void", "register", "(", "ContainerBuilder", "builder", ",", "LocatableProperties", "props", ")", "{", "alias", "(", "ObjectFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_OBJECTFACTORY", ",", "builder", ",", "props", ")", ";", "alias", "(", "FileManagerFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_FILE_MANAGER_FACTORY", ",", "builder", ",", "props", ",", "Scope", ".", "SINGLETON", ")", ";", "alias", "(", "XWorkConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_XWORKCONVERTER", ",", "builder", ",", "props", ")", ";", "alias", "(", "CollectionConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_COLLECTION", ",", "builder", ",", "props", ")", ";", "alias", "(", "ArrayConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_ARRAY", ",", "builder", ",", "props", ")", ";", "alias", "(", "DateConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_DATE", ",", "builder", ",", "props", ")", ";", "alias", "(", "NumberConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_NUMBER", ",", "builder", ",", "props", ")", ";", "alias", "(", "StringConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_STRING", ",", "builder", ",", "props", ")", ";", "alias", "(", "ConversionPropertiesProcessor", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_PROPERTIES_PROCESSOR", ",", "builder", ",", "props", ")", ";", "alias", "(", "ConversionFileProcessor", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_FILE_PROCESSOR", ",", "builder", ",", "props", ")", ";", "alias", "(", "ConversionAnnotationProcessor", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_ANNOTATION_PROCESSOR", ",", "builder", ",", "props", ")", ";", "alias", "(", "TypeConverterCreator", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_CREATOR", ",", "builder", ",", "props", ")", ";", "alias", "(", "TypeConverterHolder", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_HOLDER", ",", "builder", ",", "props", ")", ";", "alias", "(", "TextProvider", ".", "class", ",", "StrutsConstants", ".", "STRUTS_XWORKTEXTPROVIDER", ",", "builder", ",", "props", ",", "Scope", ".", "DEFAULT", ")", ";", "alias", "(", "LocaleProvider", ".", "class", ",", "StrutsConstants", ".", "STRUTS_LOCALE_PROVIDER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ActionProxyFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_ACTIONPROXYFACTORY", ",", "builder", ",", "props", ")", ";", "alias", "(", "ObjectTypeDeterminer", ".", "class", ",", "StrutsConstants", ".", "STRUTS_OBJECTTYPEDETERMINER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ActionMapper", ".", "class", ",", "StrutsConstants", ".", "STRUTS_MAPPER_CLASS", ",", "builder", ",", "props", ")", ";", "alias", "(", "MultiPartRequest", ".", "class", ",", "StrutsConstants", ".", "STRUTS_MULTIPART_PARSER", ",", "builder", ",", "props", ",", "Scope", ".", "DEFAULT", ")", ";", "alias", "(", "FreemarkerManager", ".", "class", ",", "StrutsConstants", ".", "STRUTS_FREEMARKER_MANAGER_CLASSNAME", ",", "builder", ",", "props", ")", ";", "alias", "(", "VelocityManager", ".", "class", ",", "StrutsConstants", ".", "STRUTS_VELOCITY_MANAGER_CLASSNAME", ",", "builder", ",", "props", ")", ";", "alias", "(", "UrlRenderer", ".", "class", ",", "StrutsConstants", ".", "STRUTS_URL_RENDERER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ActionValidatorManager", ".", "class", ",", "StrutsConstants", ".", "STRUTS_ACTIONVALIDATORMANAGER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ValueStackFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_VALUESTACKFACTORY", ",", "builder", ",", "props", ")", ";", "alias", "(", "ReflectionProvider", ".", "class", ",", "StrutsConstants", ".", "STRUTS_REFLECTIONPROVIDER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ReflectionContextFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_REFLECTIONCONTEXTFACTORY", ",", "builder", ",", "props", ")", ";", "alias", "(", "PatternMatcher", ".", "class", ",", "StrutsConstants", ".", "STRUTS_PATTERNMATCHER", ",", "builder", ",", "props", ")", ";", "alias", "(", "StaticContentLoader", ".", "class", ",", "StrutsConstants", ".", "STRUTS_STATIC_CONTENT_LOADER", ",", "builder", ",", "props", ")", ";", "alias", "(", "UnknownHandlerManager", ".", "class", ",", "StrutsConstants", ".", "STRUTS_UNKNOWN_HANDLER_MANAGER", ",", "builder", ",", "props", ")", ";", "alias", "(", "UrlHelper", ".", "class", ",", "StrutsConstants", ".", "STRUTS_URL_HELPER", ",", "builder", ",", "props", ")", ";", "alias", "(", "TextParser", ".", "class", ",", "StrutsConstants", ".", "STRUTS_EXPRESSION_PARSER", ",", "builder", ",", "props", ")", ";", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "props", ".", "getProperty", "(", "StrutsConstants", ".", "STRUTS_DEVMODE", ")", ")", ")", "{", "props", ".", "setProperty", "(", "StrutsConstants", ".", "STRUTS_I18N_RELOAD", ",", "\"", "true", "\"", ")", ";", "props", ".", "setProperty", "(", "StrutsConstants", ".", "STRUTS_CONFIGURATION_XML_RELOAD", ",", "\"", "true", "\"", ")", ";", "props", ".", "setProperty", "(", "StrutsConstants", ".", "STRUTS_FREEMARKER_TEMPLATES_CACHE", ",", "\"", "false", "\"", ")", ";", "props", ".", "setProperty", "(", "StrutsConstants", ".", "STRUTS_FREEMARKER_TEMPLATES_CACHE_UPDATE_DELAY", ",", "\"", "0", "\"", ")", ";", "props", ".", "setProperty", "(", "XWorkConstants", ".", "DEV_MODE", ",", "\"", "true", "\"", ")", ";", "}", "else", "{", "props", ".", "setProperty", "(", "XWorkConstants", ".", "DEV_MODE", ",", "\"", "false", "\"", ")", ";", "}", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_LOG_MISSING_PROPERTIES", ",", "XWorkConstants", ".", "LOG_MISSING_PROPERTIES", ")", ";", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_ENABLE_OGNL_EXPRESSION_CACHE", ",", "XWorkConstants", ".", "ENABLE_OGNL_EXPRESSION_CACHE", ")", ";", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_ENABLE_OGNL_EVAL_EXPRESSION", ",", "XWorkConstants", ".", "ENABLE_OGNL_EVAL_EXPRESSION", ")", ";", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_ALLOW_STATIC_METHOD_ACCESS", ",", "XWorkConstants", ".", "ALLOW_STATIC_METHOD_ACCESS", ")", ";", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_CONFIGURATION_XML_RELOAD", ",", "XWorkConstants", ".", "RELOAD_XML_CONFIGURATION", ")", ";", "LocalizedTextUtil", ".", "addDefaultResourceBundle", "(", "\"", "org/apache/struts2/struts-messages", "\"", ")", ";", "loadCustomResourceBundles", "(", "props", ")", ";", "}"], "idx": 95030, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "7e6f641ebb142663cbd1653dc49bed725edf7f56", "function_name": "register", "body_hash": "d21ca0e3947da120458ffe567a1ec81ee4fdcf3f"}
{"code": "public static String getPropertyDef(InputSpec inputSpec, Map<String, Integer> indexes, \n\t\t\tString pattern, DefaultValueProvider defaultValueProvider) {\n\t\tint index = indexes.get(inputSpec.getName());\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tinputSpec.appendField(buffer, index, \"String\");\n\t\tinputSpec.appendCommonAnnotations(buffer, index);\n\t\tif (!inputSpec.isAllowEmpty())\n\t\t\tbuffer.append(\"    @NotEmpty\\n\");\n\t\tif (pattern != null)\n\t\t\tbuffer.append(\"    @Pattern(regexp=\\\"\" + pattern + \"\\\", message=\\\"Should match regular expression: \" + pattern + \"\\\")\\n\");\n\t\tinputSpec.appendMethods(buffer, index, \"String\", null, defaultValueProvider);\n\t\t\n\t\treturn buffer.toString();\n\t}", "code_tokens": ["public", "static", "String", "getPropertyDef", "(", "InputSpec", "inputSpec", ",", "Map", "<", "String", ",", "Integer", ">", "indexes", ",", "String", "pattern", ",", "DefaultValueProvider", "defaultValueProvider", ")", "{", "int", "index", "=", "indexes", ".", "get", "(", "inputSpec", ".", "getName", "(", ")", ")", ";", "StringBuffer", "buffer", "=", "new", "StringBuffer", "(", ")", ";", "inputSpec", ".", "appendField", "(", "buffer", ",", "index", ",", "\"", "String", "\"", ")", ";", "inputSpec", ".", "appendCommonAnnotations", "(", "buffer", ",", "index", ")", ";", "if", "(", "!", "inputSpec", ".", "isAllowEmpty", "(", ")", ")", "buffer", ".", "append", "(", "\"", "    @NotEmpty", "\\n", "\"", ")", ";", "if", "(", "pattern", "!=", "null", ")", "buffer", ".", "append", "(", "\"", "    @Pattern(regexp=", "\\\"", "\"", "+", "pattern", "+", "\"", "\\\"", ", message=", "\\\"", "Should match regular expression: ", "\"", "+", "pattern", "+", "\"", "\\\"", ")", "\\n", "\"", ")", ";", "inputSpec", ".", "appendMethods", "(", "buffer", ",", "index", ",", "\"", "String", "\"", ",", "null", ",", "defaultValueProvider", ")", ";", "return", "buffer", ".", "toString", "(", ")", ";", "}"], "idx": 73799, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "39d95ab8122c5d9ed18e69dc024870cae08d2d60", "function_name": "getPropertyDef", "body_hash": "bd10028350456227a2932852a38ed1f212b1986b"}
{"code": "@Override\n\tpublic synchronized Resource findOne(String application, String profile, String label,\n\t\t\tString path) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\tString[] locations = this.service.getLocations(application, profile, label)\n\t\t\t\t\t.getLocations();\n\t\t\tArrayList<Resource> locationResources = new ArrayList<>();\n\t\t\tfor (int i = locations.length; i-- > 0;) {\n\t\t\t\tString location = locations[i];\n\t\t\t\tif (!PathUtils.isInvalidEncodedLocation(location)) {\n\t\t\t\t\tlocationResources.add(this.resourceLoader.getResource(location));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfor (Resource location : locationResources) {\n\t\t\t\t\tfor (String local : getProfilePaths(profile, path)) {\n\t\t\t\t\t\tif (!PathUtils.isInvalidPath(local)\n\t\t\t\t\t\t\t\t&& !PathUtils.isInvalidEncodedPath(local)) {\n\t\t\t\t\t\t\tResource file = location.createRelative(local);\n\t\t\t\t\t\t\tif (file.exists() && file.isReadable() && PathUtils\n\t\t\t\t\t\t\t\t\t.checkResource(file, location, locationResources)) {\n\t\t\t\t\t\t\t\treturn file;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new NoSuchResourceException(\n\t\t\t\t\t\t\"Error : \" + path + \". (\" + e.getMessage() + \")\");\n\t\t\t}\n\t\t}\n\t\tthrow new NoSuchResourceException(\"Not found: \" + path);\n\t}", "code_tokens": ["@", "Override", "public", "synchronized", "Resource", "findOne", "(", "String", "application", ",", "String", "profile", ",", "String", "label", ",", "String", "path", ")", "{", "if", "(", "StringUtils", ".", "hasText", "(", "path", ")", ")", "{", "String", "[", "]", "locations", "=", "this", ".", "service", ".", "getLocations", "(", "application", ",", "profile", ",", "label", ")", ".", "getLocations", "(", ")", ";", "ArrayList", "<", "Resource", ">", "locationResources", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "for", "(", "int", "i", "=", "locations", ".", "length", ";", "i", "--", ">", "0", ";", ")", "{", "String", "location", "=", "locations", "[", "i", "]", ";", "if", "(", "!", "PathUtils", ".", "isInvalidEncodedLocation", "(", "location", ")", ")", "{", "locationResources", ".", "add", "(", "this", ".", "resourceLoader", ".", "getResource", "(", "location", ")", ")", ";", "}", "}", "try", "{", "for", "(", "Resource", "location", ":", "locationResources", ")", "{", "for", "(", "String", "local", ":", "getProfilePaths", "(", "profile", ",", "path", ")", ")", "{", "if", "(", "!", "PathUtils", ".", "isInvalidPath", "(", "local", ")", "&&", "!", "PathUtils", ".", "isInvalidEncodedPath", "(", "local", ")", ")", "{", "Resource", "file", "=", "location", ".", "createRelative", "(", "local", ")", ";", "if", "(", "file", ".", "exists", "(", ")", "&&", "file", ".", "isReadable", "(", ")", "&&", "PathUtils", ".", "checkResource", "(", "file", ",", "location", ",", "locationResources", ")", ")", "{", "return", "file", ";", "}", "}", "}", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "NoSuchResourceException", "(", "\"", "Error : ", "\"", "+", "path", "+", "\"", ". (", "\"", "+", "e", ".", "getMessage", "(", ")", "+", "\"", ")", "\"", ")", ";", "}", "}", "throw", "new", "NoSuchResourceException", "(", "\"", "Not found: ", "\"", "+", "path", ")", ";", "}"], "idx": 26352, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "03eaadc25323d8c8c89f528e8585033ed90c50f6", "function_name": "findOne", "body_hash": "83f0c4f0417167314417a0be636dfa42c415fee4"}
{"code": "@Override\n\tpublic synchronized Resource findOne(String application, String profile, String label,\n\t\t\tString path) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\tString[] locations = this.service.getLocations(application, profile, label)\n\t\t\t\t\t.getLocations();\n\t\t\ttry {\n\t\t\t\tfor (int i = locations.length; i-- > 0;) {\n\t\t\t\t\tString location = locations[i];\n\t\t\t\t\tif (PathUtils.isInvalidEncodedLocation(location)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (String local : getProfilePaths(profile, path)) {\n\t\t\t\t\t\tif (!PathUtils.isInvalidPath(local)\n\t\t\t\t\t\t\t\t&& !PathUtils.isInvalidEncodedPath(local)) {\n\t\t\t\t\t\t\tResource file = this.resourceLoader.getResource(location)\n\t\t\t\t\t\t\t\t\t.createRelative(local);\n\t\t\t\t\t\t\tif (file.exists() && file.isReadable()) {\n\t\t\t\t\t\t\t\treturn file;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new NoSuchResourceException(\n\t\t\t\t\t\t\"Error : \" + path + \". (\" + e.getMessage() + \")\");\n\t\t\t}\n\t\t}\n\t\tthrow new NoSuchResourceException(\"Not found: \" + path);\n\t}", "code_tokens": ["@", "Override", "public", "synchronized", "Resource", "findOne", "(", "String", "application", ",", "String", "profile", ",", "String", "label", ",", "String", "path", ")", "{", "if", "(", "StringUtils", ".", "hasText", "(", "path", ")", ")", "{", "String", "[", "]", "locations", "=", "this", ".", "service", ".", "getLocations", "(", "application", ",", "profile", ",", "label", ")", ".", "getLocations", "(", ")", ";", "try", "{", "for", "(", "int", "i", "=", "locations", ".", "length", ";", "i", "--", ">", "0", ";", ")", "{", "String", "location", "=", "locations", "[", "i", "]", ";", "if", "(", "PathUtils", ".", "isInvalidEncodedLocation", "(", "location", ")", ")", "{", "continue", ";", "}", "for", "(", "String", "local", ":", "getProfilePaths", "(", "profile", ",", "path", ")", ")", "{", "if", "(", "!", "PathUtils", ".", "isInvalidPath", "(", "local", ")", "&&", "!", "PathUtils", ".", "isInvalidEncodedPath", "(", "local", ")", ")", "{", "Resource", "file", "=", "this", ".", "resourceLoader", ".", "getResource", "(", "location", ")", ".", "createRelative", "(", "local", ")", ";", "if", "(", "file", ".", "exists", "(", ")", "&&", "file", ".", "isReadable", "(", ")", ")", "{", "return", "file", ";", "}", "}", "}", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "NoSuchResourceException", "(", "\"", "Error : ", "\"", "+", "path", "+", "\"", ". (", "\"", "+", "e", ".", "getMessage", "(", ")", "+", "\"", ")", "\"", ")", ";", "}", "}", "throw", "new", "NoSuchResourceException", "(", "\"", "Not found: ", "\"", "+", "path", ")", ";", "}"], "idx": 26351, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "03eaadc25323d8c8c89f528e8585033ed90c50f6", "function_name": "findOne", "body_hash": "c4741a0a8fb27b232c7e7e6b9ee7b522b96507a8"}
{"code": "protected void handleSimpleCORS(final HttpServletRequest request,\n            final HttpServletResponse response, final FilterChain filterChain)\n            throws IOException, ServletException {\n\n        CorsFilter.CORSRequestType requestType = checkRequestType(request);\n        if (!(requestType == CorsFilter.CORSRequestType.SIMPLE ||\n                requestType == CorsFilter.CORSRequestType.ACTUAL)) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"corsFilter.wrongType2\",\n                            CorsFilter.CORSRequestType.SIMPLE,\n                            CorsFilter.CORSRequestType.ACTUAL));\n        }\n\n        final String origin = request\n                .getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);\n        final String method = request.getMethod();\n\n        // Section 6.1.2\n        if (!isOriginAllowed(origin)) {\n            handleInvalidCORS(request, response, filterChain);\n            return;\n        }\n\n        if (!allowedHttpMethods.contains(method)) {\n            handleInvalidCORS(request, response, filterChain);\n            return;\n        }\n\n        // Section 6.1.3\n        // Add a single Access-Control-Allow-Origin header.\n        if (anyOriginAllowed && !supportsCredentials) {\n            // If resource doesn't support credentials and if any origin is\n            // allowed\n            // to make CORS request, return header with '*'.\n            response.addHeader(\n                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,\n                    \"*\");\n        } else {\n            // If the resource supports credentials add a single\n            // Access-Control-Allow-Origin header, with the value of the Origin\n            // header as value.\n            response.addHeader(\n                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,\n                    origin);\n        }\n\n        // Section 6.1.3\n        // If the resource supports credentials, add a single\n        // Access-Control-Allow-Credentials header with the case-sensitive\n        // string \"true\" as value.\n        if (supportsCredentials) {\n            response.addHeader(\n                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,\n                    \"true\");\n        }\n\n        // Section 6.1.4\n        // If the list of exposed headers is not empty add one or more\n        // Access-Control-Expose-Headers headers, with as values the header\n        // field names given in the list of exposed headers.\n        if ((exposedHeaders != null) && (exposedHeaders.size() > 0)) {\n            String exposedHeadersString = join(exposedHeaders, \",\");\n            response.addHeader(\n                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS,\n                    exposedHeadersString);\n        }\n\n        // Indicate the response depends on the origin\n        response.addHeader(CorsFilter.REQUEST_HEADER_VARY,\n                CorsFilter.REQUEST_HEADER_ORIGIN);\n\n        // Forward the request down the filter chain.\n        filterChain.doFilter(request, response);\n    }", "code_tokens": ["protected", "void", "handleSimpleCORS", "(", "final", "HttpServletRequest", "request", ",", "final", "HttpServletResponse", "response", ",", "final", "FilterChain", "filterChain", ")", "throws", "IOException", ",", "ServletException", "{", "CorsFilter", ".", "CORSRequestType", "requestType", "=", "checkRequestType", "(", "request", ")", ";", "if", "(", "!", "(", "requestType", "==", "CorsFilter", ".", "CORSRequestType", ".", "SIMPLE", "||", "requestType", "==", "CorsFilter", ".", "CORSRequestType", ".", "ACTUAL", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "sm", ".", "getString", "(", "\"", "corsFilter.wrongType2", "\"", ",", "CorsFilter", ".", "CORSRequestType", ".", "SIMPLE", ",", "CorsFilter", ".", "CORSRequestType", ".", "ACTUAL", ")", ")", ";", "}", "final", "String", "origin", "=", "request", ".", "getHeader", "(", "CorsFilter", ".", "REQUEST_HEADER_ORIGIN", ")", ";", "final", "String", "method", "=", "request", ".", "getMethod", "(", ")", ";", "if", "(", "!", "isOriginAllowed", "(", "origin", ")", ")", "{", "handleInvalidCORS", "(", "request", ",", "response", ",", "filterChain", ")", ";", "return", ";", "}", "if", "(", "!", "allowedHttpMethods", ".", "contains", "(", "method", ")", ")", "{", "handleInvalidCORS", "(", "request", ",", "response", ",", "filterChain", ")", ";", "return", ";", "}", "if", "(", "anyOriginAllowed", "&&", "!", "supportsCredentials", ")", "{", "response", ".", "addHeader", "(", "CorsFilter", ".", "RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN", ",", "\"", "*", "\"", ")", ";", "}", "else", "{", "response", ".", "addHeader", "(", "CorsFilter", ".", "RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN", ",", "origin", ")", ";", "}", "if", "(", "supportsCredentials", ")", "{", "response", ".", "addHeader", "(", "CorsFilter", ".", "RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS", ",", "\"", "true", "\"", ")", ";", "}", "if", "(", "(", "exposedHeaders", "!=", "null", ")", "&&", "(", "exposedHeaders", ".", "size", "(", ")", ">", "0", ")", ")", "{", "String", "exposedHeadersString", "=", "join", "(", "exposedHeaders", ",", "\"", ",", "\"", ")", ";", "response", ".", "addHeader", "(", "CorsFilter", ".", "RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS", ",", "exposedHeadersString", ")", ";", "}", "response", ".", "addHeader", "(", "CorsFilter", ".", "REQUEST_HEADER_VARY", ",", "CorsFilter", ".", "REQUEST_HEADER_ORIGIN", ")", ";", "filterChain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}"], "idx": 42895, "cwe": "CWE-345", "target": 0, "status": "FIXED", "commit": "b94478d45b7e1fc06134a785571f78772fa30fed", "function_name": "handleSimpleCORS", "body_hash": "56b97cde89f7950b818a7adfb1d2bd0ee7a9bceb"}
{"code": "public static OMElement buildOMElement(String payload) throws RegistryException {\n\n        OMElement element = getOMElementFromString(payload);\n        element.build();\n        return element;\n    }", "code_tokens": ["public", "static", "OMElement", "buildOMElement", "(", "String", "payload", ")", "throws", "RegistryException", "{", "OMElement", "element", "=", "getOMElementFromString", "(", "payload", ")", ";", "element", ".", "build", "(", ")", ";", "return", "element", ";", "}"], "idx": 67257, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "80362069", "function_name": "buildOMElement", "body_hash": "055c286d7266e3d6b1c3b908d65d80a1211baf75"}
{"code": "protected void addDefaultMapping(DefaultMapper mapper, String parameter, Object model) {\n\t\tExpression source = new RequestParameterExpression(parameter);\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tvalidateDataBindingExpression(parameter, model);\n\t\tExpression target = expressionParser.parseExpression(parameter, parserContext);\n\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding default mapping for parameter '\" + parameter + \"'\");\n\t\t}\n\t\tmapper.addMapping(mapping);\n\t}", "code_tokens": ["protected", "void", "addDefaultMapping", "(", "DefaultMapper", "mapper", ",", "String", "parameter", ",", "Object", "model", ")", "{", "Expression", "source", "=", "new", "RequestParameterExpression", "(", "parameter", ")", ";", "ParserContext", "parserContext", "=", "new", "FluentParserContext", "(", ")", ".", "evaluate", "(", "model", ".", "getClass", "(", ")", ")", ";", "validateDataBindingExpression", "(", "parameter", ",", "model", ")", ";", "Expression", "target", "=", "expressionParser", ".", "parseExpression", "(", "parameter", ",", "parserContext", ")", ";", "DefaultMapping", "mapping", "=", "new", "DefaultMapping", "(", "source", ",", "target", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Adding default mapping for parameter '", "\"", "+", "parameter", "+", "\"", "'", "\"", ")", ";", "}", "mapper", ".", "addMapping", "(", "mapping", ")", ";", "}"], "idx": 1380, "cwe": "CWE-1188", "target": 0, "status": "FIXED", "commit": "df0ea", "function_name": "addDefaultMapping", "body_hash": "da529ea024006c06ed1af4770282d6e130d05ae4"}
{"code": "public static HttpHost extractHost(final URI uri) {\n        if (uri == null) {\n            return null;\n        }\n        HttpHost target = null;\n        if (uri.isAbsolute()) {\n            int port = uri.getPort(); // may be overridden later\n            String host = uri.getHost();\n            if (host == null) { // normal parse failed; let's do it ourselves\n                // authority does not seem to care about the valid character-set for host names\n                host = uri.getAuthority();\n                if (host != null) {\n                    // Strip off any leading user credentials\n                    final int at = host.indexOf('@');\n                    if (at >= 0) {\n                        if (host.length() > at+1 ) {\n                            host = host.substring(at+1);\n                        } else {\n                            host = null; // @ on its own\n                        }\n                    }\n                    // Extract the port suffix, if present\n                    if (host != null) {\n                        final int colon = host.indexOf(':');\n                        if (colon >= 0) {\n                            final int pos = colon + 1;\n                            int len = 0;\n                            for (int i = pos; i < host.length(); i++) {\n                                if (Character.isDigit(host.charAt(i))) {\n                                    len++;\n                                } else {\n                                    break;\n                                }\n                            }\n                            if (len > 0) {\n                                try {\n                                    port = Integer.parseInt(host.substring(pos, pos + len));\n                                } catch (final NumberFormatException ex) {\n                                }\n                            }\n                            host = host.substring(0, colon);\n                        }\n                    }\n                }\n            }\n            final String scheme = uri.getScheme();\n            if (!TextUtils.isBlank(host)) {\n                try {\n                    target = new HttpHost(host, port, scheme);\n                } catch (final IllegalArgumentException ignore) {\n                }\n            }\n        }\n        return target;\n    }", "code_tokens": ["public", "static", "HttpHost", "extractHost", "(", "final", "URI", "uri", ")", "{", "if", "(", "uri", "==", "null", ")", "{", "return", "null", ";", "}", "HttpHost", "target", "=", "null", ";", "if", "(", "uri", ".", "isAbsolute", "(", ")", ")", "{", "int", "port", "=", "uri", ".", "getPort", "(", ")", ";", "String", "host", "=", "uri", ".", "getHost", "(", ")", ";", "if", "(", "host", "==", "null", ")", "{", "host", "=", "uri", ".", "getAuthority", "(", ")", ";", "if", "(", "host", "!=", "null", ")", "{", "final", "int", "at", "=", "host", ".", "indexOf", "(", "'@'", ")", ";", "if", "(", "at", ">=", "0", ")", "{", "if", "(", "host", ".", "length", "(", ")", ">", "at", "+", "1", ")", "{", "host", "=", "host", ".", "substring", "(", "at", "+", "1", ")", ";", "}", "else", "{", "host", "=", "null", ";", "}", "}", "if", "(", "host", "!=", "null", ")", "{", "final", "int", "colon", "=", "host", ".", "indexOf", "(", "':'", ")", ";", "if", "(", "colon", ">=", "0", ")", "{", "final", "int", "pos", "=", "colon", "+", "1", ";", "int", "len", "=", "0", ";", "for", "(", "int", "i", "=", "pos", ";", "i", "<", "host", ".", "length", "(", ")", ";", "i", "++", ")", "{", "if", "(", "Character", ".", "isDigit", "(", "host", ".", "charAt", "(", "i", ")", ")", ")", "{", "len", "++", ";", "}", "else", "{", "break", ";", "}", "}", "if", "(", "len", ">", "0", ")", "{", "try", "{", "port", "=", "Integer", ".", "parseInt", "(", "host", ".", "substring", "(", "pos", ",", "pos", "+", "len", ")", ")", ";", "}", "catch", "(", "final", "NumberFormatException", "ex", ")", "{", "}", "}", "host", "=", "host", ".", "substring", "(", "0", ",", "colon", ")", ";", "}", "}", "}", "}", "final", "String", "scheme", "=", "uri", ".", "getScheme", "(", ")", ";", "if", "(", "!", "TextUtils", ".", "isBlank", "(", "host", ")", ")", "{", "try", "{", "target", "=", "new", "HttpHost", "(", "host", ",", "port", ",", "scheme", ")", ";", "}", "catch", "(", "final", "IllegalArgumentException", "ignore", ")", "{", "}", "}", "}", "return", "target", ";", "}"], "idx": 99558, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "e628b4c5c464c2fa346385596cc78e035a91a62e", "function_name": "extractHost", "body_hash": "f3a3a2e247bca397ffa718fe42dd579e48404dd5"}
{"code": "@Override\n        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.process\",\n                        wrapper.getSocket(), status));\n            }\n            if (wrapper == null) {\n                // Nothing to do. Socket has been closed.\n                return SocketState.CLOSED;\n            }\n\n            S socket = wrapper.getSocket();\n\n            Processor processor = (Processor) wrapper.getCurrentProcessor();\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.connectionsGet\",\n                        processor, socket));\n            }\n\n            // Timeouts are calculated on a dedicated thread and then\n            // dispatched. Because of delays in the dispatch process, the\n            // timeout may no longer be required. Check here and avoid\n            // unnecessary processing.\n            if (SocketEvent.TIMEOUT == status &&\n                    (processor == null ||\n                    !processor.isAsync() && !processor.isUpgrade() ||\n                    processor.isAsync() && !processor.checkAsyncTimeoutGeneration())) {\n                // This is effectively a NO-OP\n                return SocketState.OPEN;\n            }\n\n            if (processor != null) {\n                // Make sure an async timeout doesn't fire\n                getProtocol().removeWaitingProcessor(processor);\n            } else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) {\n                // Nothing to do. Endpoint requested a close and there is no\n                // longer a processor associated with this socket.\n                return SocketState.CLOSED;\n            }\n\n            ContainerThreadMarker.set();\n\n            try {\n                if (processor == null) {\n                    String negotiatedProtocol = wrapper.getNegotiatedProtocol();\n                    // OpenSSL typically returns null whereas JSSE typically\n                    // returns \"\" when no protocol is negotiated\n                    if (negotiatedProtocol != null && negotiatedProtocol.length() > 0) {\n                        UpgradeProtocol upgradeProtocol = getProtocol().getNegotiatedProtocol(negotiatedProtocol);\n                        if (upgradeProtocol != null) {\n                            processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                            }\n                        } else if (negotiatedProtocol.equals(\"http/1.1\")) {\n                            // Explicitly negotiated the default protocol.\n                            // Obtain a processor below.\n                        } else {\n                            // TODO:\n                            // OpenSSL 1.0.2's ALPN callback doesn't support\n                            // failing the handshake with an error if no\n                            // protocol can be negotiated. Therefore, we need to\n                            // fail the connection here. Once this is fixed,\n                            // replace the code below with the commented out\n                            // block.\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        negotiatedProtocol));\n                            }\n                            return SocketState.CLOSED;\n                            /*\n                             * To replace the code above once OpenSSL 1.1.0 is\n                             * used.\n                            // Failed to create processor. This is a bug.\n                            throw new IllegalStateException(sm.getString(\n                                    \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                    negotiatedProtocol));\n                            */\n                        }\n                    }\n                }\n                if (processor == null) {\n                    processor = recycledProcessors.pop();\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorPop\", processor));\n                    }\n                }\n                if (processor == null) {\n                    processor = getProtocol().createProcessor();\n                    register(processor);\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                    }\n                }\n\n                processor.setSslSupport(\n                        wrapper.getSslSupport(getProtocol().getClientCertProvider()));\n\n                // Associate the processor with the connection\n                wrapper.setCurrentProcessor(processor);\n\n                SocketState state = SocketState.CLOSED;\n                do {\n                    state = processor.process(wrapper, status);\n\n                    if (state == SocketState.UPGRADING) {\n                        // Get the HTTP upgrade handler\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        // Restore leftover input to the wrapper so the upgrade\n                        // processor can process it.\n                        ByteBuffer leftOverInput = processor.getLeftoverInput();\n                        wrapper.unRead(leftOverInput);\n                        if (upgradeToken == null) {\n                            // Assume direct HTTP/2 connection\n                            UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(\"h2c\");\n                            if (upgradeProtocol != null) {\n                                // Release the Http11 processor to be re-used\n                                release(processor);\n                                // Create the upgrade processor\n                                processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                                // Associate with the processor with the connection\n                                wrapper.setCurrentProcessor(processor);\n                            } else {\n                                if (getLog().isDebugEnabled()) {\n                                    getLog().debug(sm.getString(\n                                        \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        \"h2c\"));\n                                }\n                                // Exit loop and trigger appropriate clean-up\n                                state = SocketState.CLOSED;\n                            }\n                        } else {\n                            HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                            // Release the Http11 processor to be re-used\n                            release(processor);\n                            // Create the upgrade processor\n                            processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.upgradeCreate\",\n                                        processor, wrapper));\n                            }\n                            // Associate with the processor with the connection\n                            wrapper.setCurrentProcessor(processor);\n                            // Initialise the upgrade handler (which may trigger\n                            // some IO using the new protocol which is why the lines\n                            // above are necessary)\n                            // This cast should be safe. If it fails the error\n                            // handling for the surrounding try/catch will deal with\n                            // it.\n                            if (upgradeToken.getInstanceManager() == null) {\n                                httpUpgradeHandler.init((WebConnection) processor);\n                            } else {\n                                ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                                try {\n                                    httpUpgradeHandler.init((WebConnection) processor);\n                                } finally {\n                                    upgradeToken.getContextBind().unbind(false, oldCL);\n                                }\n                            }\n                            if (httpUpgradeHandler instanceof InternalHttpUpgradeHandler) {\n                                if (((InternalHttpUpgradeHandler) httpUpgradeHandler).hasAsyncIO()) {\n                                    // The handler will initiate all further I/O\n                                    state = SocketState.UPGRADED;\n                                }\n                            }\n                        }\n                    }\n                } while ( state == SocketState.UPGRADING);\n\n                if (state == SocketState.LONG) {\n                    // In the middle of processing a request/response. Keep the\n                    // socket associated with the processor. Exact requirements\n                    // depend on type of long poll\n                    longPoll(wrapper, processor);\n                    if (processor.isAsync()) {\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.OPEN) {\n                    // In keep-alive but between requests. OK to recycle\n                    // processor. Continue to poll for the next request.\n                    wrapper.setCurrentProcessor(null);\n                    release(processor);\n                    wrapper.registerReadInterest();\n                } else if (state == SocketState.SENDFILE) {\n                    // Sendfile in progress. If it fails, the socket will be\n                    // closed. If it works, the socket either be added to the\n                    // poller (or equivalent) to await more data or processed\n                    // if there are any pipe-lined requests remaining.\n                } else if (state == SocketState.UPGRADED) {\n                    // Don't add sockets back to the poller if this was a\n                    // non-blocking write otherwise the poller may trigger\n                    // multiple read events which may lead to thread starvation\n                    // in the connector. The write() method will add this socket\n                    // to the poller if necessary.\n                    if (status != SocketEvent.OPEN_WRITE) {\n                        longPoll(wrapper, processor);\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.SUSPENDED) {\n                    // Don't add sockets back to the poller.\n                    // The resumeProcessing() method will add this socket\n                    // to the poller.\n                } else {\n                    // Connection closed. OK to recycle the processor.\n                    // Processors handling upgrades require additional clean-up\n                    // before release.\n                    wrapper.setCurrentProcessor(null);\n                    if (processor.isUpgrade()) {\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                        InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                        if (instanceManager == null) {\n                            httpUpgradeHandler.destroy();\n                        } else {\n                            ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                            try {\n                                httpUpgradeHandler.destroy();\n                            } finally {\n                                try {\n                                    instanceManager.destroyInstance(httpUpgradeHandler);\n                                } catch (Throwable e) {\n                                    ExceptionUtils.handleThrowable(e);\n                                    getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n                                }\n                                upgradeToken.getContextBind().unbind(false, oldCL);\n                            }\n                        }\n                    }\n                    release(processor);\n                }\n                return state;\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.ioexception.debug\"), e);\n            } catch (ProtocolException e) {\n                // Protocol exceptions normally mean the client sent invalid or\n                // incomplete data.\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.protocolexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (OutOfMemoryError oome) {\n                // Try and handle this here to give Tomcat a chance to close the\n                // connection and prevent clients waiting until they time out.\n                // Worst case, it isn't recoverable and the attempt at logging\n                // will trigger another OOME.\n                getLog().error(sm.getString(\"abstractConnectionHandler.oome\"), oome);\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n            } finally {\n                ContainerThreadMarker.clear();\n            }\n\n            // Make sure socket/processor is removed from the list of current\n            // connections\n            wrapper.setCurrentProcessor(null);\n            release(processor);\n            return SocketState.CLOSED;\n        }", "code_tokens": ["@", "Override", "public", "SocketState", "process", "(", "SocketWrapperBase", "<", "S", ">", "wrapper", ",", "SocketEvent", "status", ")", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.process", "\"", ",", "wrapper", ".", "getSocket", "(", ")", ",", "status", ")", ")", ";", "}", "if", "(", "wrapper", "==", "null", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "S", "socket", "=", "wrapper", ".", "getSocket", "(", ")", ";", "Processor", "processor", "=", "(", "Processor", ")", "wrapper", ".", "getCurrentProcessor", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.connectionsGet", "\"", ",", "processor", ",", "socket", ")", ")", ";", "}", "if", "(", "SocketEvent", ".", "TIMEOUT", "==", "status", "&&", "(", "processor", "==", "null", "||", "!", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "isUpgrade", "(", ")", "||", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "checkAsyncTimeoutGeneration", "(", ")", ")", ")", "{", "return", "SocketState", ".", "OPEN", ";", "}", "if", "(", "processor", "!=", "null", ")", "{", "getProtocol", "(", ")", ".", "removeWaitingProcessor", "(", "processor", ")", ";", "}", "else", "if", "(", "status", "==", "SocketEvent", ".", "DISCONNECT", "||", "status", "==", "SocketEvent", ".", "ERROR", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "ContainerThreadMarker", ".", "set", "(", ")", ";", "try", "{", "if", "(", "processor", "==", "null", ")", "{", "String", "negotiatedProtocol", "=", "wrapper", ".", "getNegotiatedProtocol", "(", ")", ";", "if", "(", "negotiatedProtocol", "!=", "null", "&&", "negotiatedProtocol", ".", "length", "(", ")", ">", "0", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getNegotiatedProtocol", "(", "negotiatedProtocol", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "else", "if", "(", "negotiatedProtocol", ".", "equals", "(", "\"", "http/1.1", "\"", ")", ")", "{", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "negotiatedProtocol", ")", ")", ";", "}", "return", "SocketState", ".", "CLOSED", ";", "}", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "recycledProcessors", ".", "pop", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorPop", "\"", ",", "processor", ")", ")", ";", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "getProtocol", "(", ")", ".", "createProcessor", "(", ")", ";", "register", "(", "processor", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "processor", ".", "setSslSupport", "(", "wrapper", ".", "getSslSupport", "(", "getProtocol", "(", ")", ".", "getClientCertProvider", "(", ")", ")", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "SocketState", "state", "=", "SocketState", ".", "CLOSED", ";", "do", "{", "state", "=", "processor", ".", "process", "(", "wrapper", ",", "status", ")", ";", "if", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "ByteBuffer", "leftOverInput", "=", "processor", ".", "getLeftoverInput", "(", ")", ";", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "if", "(", "upgradeToken", "==", "null", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getUpgradeProtocol", "(", "\"", "h2c", "\"", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "release", "(", "processor", ")", ";", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "\"", "h2c", "\"", ")", ")", ";", "}", "state", "=", "SocketState", ".", "CLOSED", ";", "}", "}", "else", "{", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "release", "(", "processor", ")", ";", "processor", "=", "getProtocol", "(", ")", ".", "createUpgradeProcessor", "(", "wrapper", ",", "upgradeToken", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.upgradeCreate", "\"", ",", "processor", ",", "wrapper", ")", ")", ";", "}", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "if", "(", "upgradeToken", ".", "getInstanceManager", "(", ")", "==", "null", ")", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "finally", "{", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "if", "(", "httpUpgradeHandler", "instanceof", "InternalHttpUpgradeHandler", ")", "{", "if", "(", "(", "(", "InternalHttpUpgradeHandler", ")", "httpUpgradeHandler", ")", ".", "hasAsyncIO", "(", ")", ")", "{", "state", "=", "SocketState", ".", "UPGRADED", ";", "}", "}", "}", "}", "}", "while", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", ";", "if", "(", "state", "==", "SocketState", ".", "LONG", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "if", "(", "processor", ".", "isAsync", "(", ")", ")", "{", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "OPEN", ")", "{", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "release", "(", "processor", ")", ";", "wrapper", ".", "registerReadInterest", "(", ")", ";", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SENDFILE", ")", "{", "}", "else", "if", "(", "state", "==", "SocketState", ".", "UPGRADED", ")", "{", "if", "(", "status", "!=", "SocketEvent", ".", "OPEN_WRITE", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SUSPENDED", ")", "{", "}", "else", "{", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "if", "(", "processor", ".", "isUpgrade", "(", ")", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "InstanceManager", "instanceManager", "=", "upgradeToken", ".", "getInstanceManager", "(", ")", ";", "if", "(", "instanceManager", "==", "null", ")", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "finally", "{", "try", "{", "instanceManager", ".", "destroyInstance", "(", "httpUpgradeHandler", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "}", "release", "(", "processor", ")", ";", "}", "return", "state", ";", "}", "catch", "(", "java", ".", "net", ".", "SocketException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.socketexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "java", ".", "io", ".", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.ioexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "ProtocolException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.protocolexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "OutOfMemoryError", "oome", ")", "{", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.oome", "\"", ")", ",", "oome", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "finally", "{", "ContainerThreadMarker", ".", "clear", "(", ")", ";", "}", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "release", "(", "processor", ")", ";", "return", "SocketState", ".", "CLOSED", ";", "}"], "idx": 17642, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "dd757c0a893e2e35f8bc1385d6967221ae8b9b9b", "function_name": "process", "body_hash": "05326d813163155f08abe423a74ba1842e17b8df"}
{"code": "protected XMLInputFactory createXmlInputFactory() {\n\t\tXMLInputFactory inputFactory = XMLInputFactory.newInstance();\n\t\tinputFactory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);\n\t\treturn inputFactory;\n\t}", "code_tokens": ["protected", "XMLInputFactory", "createXmlInputFactory", "(", ")", "{", "XMLInputFactory", "inputFactory", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "inputFactory", ".", "setProperty", "(", "XMLInputFactory", ".", "IS_REPLACING_ENTITY_REFERENCES", ",", "false", ")", ";", "return", "inputFactory", ";", "}"], "idx": 34111, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "7576274874deeccb6da6b09a8d5bd62e8b5538b7", "function_name": "createXmlInputFactory", "body_hash": "5a8339639fbfe051f3e7e79f47aefb7426b162d1"}
{"code": "protected void parseNameAndNamespace(String uri, ActionMapping mapping, ConfigurationManager configManager) {\n        String namespace, name;\n        int lastSlash = uri.lastIndexOf(\"/\");\n        if (lastSlash == -1) {\n            namespace = \"\";\n            name = uri;\n        } else if (lastSlash == 0) {\n            // ww-1046, assume it is the root namespace, it will fallback to\n            // default\n            // namespace anyway if not found in root namespace.\n            namespace = \"/\";\n            name = uri.substring(lastSlash + 1);\n        } else {\n            // Try to find the namespace in those defined, defaulting to \"\"\n            Configuration config = configManager.getConfiguration();\n            String prefix = uri.substring(0, lastSlash);\n            namespace = \"\";\n            // Find the longest matching namespace, defaulting to the default\n            for (Object o : config.getPackageConfigs().values()) {\n                String ns = ((PackageConfig) o).getNamespace();\n                if (ns != null && prefix.startsWith(ns) && (prefix.length() == ns.length() || prefix.charAt(ns.length()) == '/')) {\n                    if (ns.length() > namespace.length()) {\n                        namespace = ns;\n                    }\n                }\n            }\n\n            name = uri.substring(namespace.length() + 1);\n        }\n\n        mapping.setNamespace(namespace);\n        mapping.setName(name);\n    }", "code_tokens": ["protected", "void", "parseNameAndNamespace", "(", "String", "uri", ",", "ActionMapping", "mapping", ",", "ConfigurationManager", "configManager", ")", "{", "String", "namespace", ",", "name", ";", "int", "lastSlash", "=", "uri", ".", "lastIndexOf", "(", "\"", "/", "\"", ")", ";", "if", "(", "lastSlash", "==", "-", "1", ")", "{", "namespace", "=", "\"", "\"", ";", "name", "=", "uri", ";", "}", "else", "if", "(", "lastSlash", "==", "0", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "{", "Configuration", "config", "=", "configManager", ".", "getConfiguration", "(", ")", ";", "String", "prefix", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "namespace", "=", "\"", "\"", ";", "for", "(", "Object", "o", ":", "config", ".", "getPackageConfigs", "(", ")", ".", "values", "(", ")", ")", "{", "String", "ns", "=", "(", "(", "PackageConfig", ")", "o", ")", ".", "getNamespace", "(", ")", ";", "if", "(", "ns", "!=", "null", "&&", "prefix", ".", "startsWith", "(", "ns", ")", "&&", "(", "prefix", ".", "length", "(", ")", "==", "ns", ".", "length", "(", ")", "||", "prefix", ".", "charAt", "(", "ns", ".", "length", "(", ")", ")", "==", "'/'", ")", ")", "{", "if", "(", "ns", ".", "length", "(", ")", ">", "namespace", ".", "length", "(", ")", ")", "{", "namespace", "=", "ns", ";", "}", "}", "}", "name", "=", "uri", ".", "substring", "(", "namespace", ".", "length", "(", ")", "+", "1", ")", ";", "}", "mapping", ".", "setNamespace", "(", "namespace", ")", ";", "mapping", ".", "setName", "(", "name", ")", ";", "}"], "idx": 10579, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "6e87474f9ad0549f07dd2c37d50a9ccd0977c6e", "function_name": "parseNameAndNamespace", "body_hash": "3443edf059adeb1bea4bafd52a8783f0742800e0"}
{"code": "public Column<T, V> setCaption(String caption) {\n            Objects.requireNonNull(caption, \"Header caption can't be null\");\n            caption = Jsoup.parse(caption).text();\n            if (caption.equals(getState(false).caption)) {\n                return this;\n            }\n            getState().caption = caption;\n\n            HeaderRow row = getGrid().getDefaultHeaderRow();\n            if (row != null) {\n                row.getCell(this).setText(caption);\n            }\n\n            return this;\n        }", "code_tokens": ["public", "Column", "<", "T", ",", "V", ">", "setCaption", "(", "String", "caption", ")", "{", "Objects", ".", "requireNonNull", "(", "caption", ",", "\"", "Header caption can't be null", "\"", ")", ";", "caption", "=", "Jsoup", ".", "parse", "(", "caption", ")", ".", "text", "(", ")", ";", "if", "(", "caption", ".", "equals", "(", "getState", "(", "false", ")", ".", "caption", ")", ")", "{", "return", "this", ";", "}", "getState", "(", ")", ".", "caption", "=", "caption", ";", "HeaderRow", "row", "=", "getGrid", "(", ")", ".", "getDefaultHeaderRow", "(", ")", ";", "if", "(", "row", "!=", "null", ")", "{", "row", ".", "getCell", "(", "this", ")", ".", "setText", "(", "caption", ")", ";", "}", "return", "this", ";", "}"], "idx": 80329, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "2584e9ad44fa9135daa405df8cbc9ae7d4a3ee33", "function_name": "setCaption", "body_hash": "67f3345b903a1398ccfb9ab04ee9ce4c9c2f33f4"}
{"code": "public static Document parse(LSInput source)\n    {\n        try {\n            LSParser p = LS_IMPL.createLSParser(DOMImplementationLS.MODE_SYNCHRONOUS, null);\n            // Disable validation, since this takes a lot of time and causes unneeded network traffic\n            p.getDomConfig().setParameter(\"validate\", false);\n            if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n            }\n\n            // Avoid XML eXternal Entity injection (XXE)\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false);\n            }\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false);\n            }\n            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false)) {\n                p.getDomConfig().setParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false);\n            }\n            return p.parse(source);\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot parse XML document: [{}]\", ex.getMessage());\n            return null;\n        }\n    }", "code_tokens": ["public", "static", "Document", "parse", "(", "LSInput", "source", ")", "{", "try", "{", "LSParser", "p", "=", "LS_IMPL", ".", "createLSParser", "(", "DOMImplementationLS", ".", "MODE_SYNCHRONOUS", ",", "null", ")", ";", "p", ".", "getDomConfig", "(", ")", ".", "setParameter", "(", "\"", "validate", "\"", ",", "false", ")", ";", "if", "(", "p", ".", "getDomConfig", "(", ")", ".", "canSetParameter", "(", "DISABLE_DTD_PARAM", ",", "false", ")", ")", "{", "p", ".", "getDomConfig", "(", ")", ".", "setParameter", "(", "DISABLE_DTD_PARAM", ",", "false", ")", ";", "}", "if", "(", "p", ".", "getDomConfig", "(", ")", ".", "canSetParameter", "(", "DISABLE_EXTERNAL_DOCTYPE_DECLARATION", ",", "false", ")", ")", "{", "p", ".", "getDomConfig", "(", ")", ".", "setParameter", "(", "DISABLE_EXTERNAL_DOCTYPE_DECLARATION", ",", "false", ")", ";", "}", "if", "(", "p", ".", "getDomConfig", "(", ")", ".", "canSetParameter", "(", "DISABLE_EXTERNAL_PARAMETER_ENTITIES", ",", "false", ")", ")", "{", "p", ".", "getDomConfig", "(", ")", ".", "setParameter", "(", "DISABLE_EXTERNAL_PARAMETER_ENTITIES", ",", "false", ")", ";", "}", "if", "(", "p", ".", "getDomConfig", "(", ")", ".", "canSetParameter", "(", "DISABLE_EXTERNAL_GENERAL_ENTITIES", ",", "false", ")", ")", "{", "p", ".", "getDomConfig", "(", ")", ".", "setParameter", "(", "DISABLE_EXTERNAL_GENERAL_ENTITIES", ",", "false", ")", ";", "}", "return", "p", ".", "parse", "(", "source", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "LOGGER", ".", "warn", "(", "\"", "Cannot parse XML document: [{}]", "\"", ",", "ex", ".", "getMessage", "(", ")", ")", ";", "return", "null", ";", "}", "}"], "idx": 70855, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "947e8921ebd95462d5a7928f397dd1b64f77c7d5", "function_name": "parse", "body_hash": "a1abb221b17cb63602719db1b97cdc94655d0c87"}
{"code": "private static void languages( Connection c, Statement s)\n\tthrows SQLException\n\t{\n\t\tSavepoint p = null;\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE TRUSTED LANGUAGE java HANDLER sqlj.java_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE java IS '\" +\n\t\t\t\t\"Trusted/sandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE LANGUAGE javaU HANDLER sqlj.javau_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE javau IS '\" +\n\t\t\t\t\"Untrusted/unsandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\t}", "code_tokens": ["private", "static", "void", "languages", "(", "Connection", "c", ",", "Statement", "s", ")", "throws", "SQLException", "{", "Savepoint", "p", "=", "null", ";", "try", "{", "p", "=", "c", ".", "setSavepoint", "(", ")", ";", "s", ".", "execute", "(", "\"", "CREATE TRUSTED LANGUAGE java HANDLER sqlj.java_call_handler", "\"", ")", ";", "s", ".", "execute", "(", "\"", "COMMENT ON LANGUAGE java IS '", "\"", "+", "\"", "Trusted/sandboxed language for routines and types in ", "\"", "+", "\"", "Java; http://tada.github.io/pljava/'", "\"", ")", ";", "c", ".", "releaseSavepoint", "(", "p", ")", ";", "}", "catch", "(", "SQLException", "sqle", ")", "{", "c", ".", "rollback", "(", "p", ")", ";", "if", "(", "!", "\"", "42710", "\"", ".", "equals", "(", "sqle", ".", "getSQLState", "(", ")", ")", ")", "throw", "sqle", ";", "}", "try", "{", "p", "=", "c", ".", "setSavepoint", "(", ")", ";", "s", ".", "execute", "(", "\"", "CREATE LANGUAGE javaU HANDLER sqlj.javau_call_handler", "\"", ")", ";", "s", ".", "execute", "(", "\"", "COMMENT ON LANGUAGE javau IS '", "\"", "+", "\"", "Untrusted/unsandboxed language for routines and types in ", "\"", "+", "\"", "Java; http://tada.github.io/pljava/'", "\"", ")", ";", "c", ".", "releaseSavepoint", "(", "p", ")", ";", "}", "catch", "(", "SQLException", "sqle", ")", "{", "c", ".", "rollback", "(", "p", ")", ";", "if", "(", "!", "\"", "42710", "\"", ".", "equals", "(", "sqle", ".", "getSQLState", "(", ")", ")", ")", "throw", "sqle", ";", "}", "}"], "idx": 37894, "cwe": "CWE-284", "target": 1, "status": "VULNERABLE", "commit": "675254b0f17b76f05e72cba2e3b8d3e548ae7a43", "function_name": "languages", "body_hash": "1b60843e110c611e43a504f371869a2ae4b0c59c"}
{"code": "protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {\n\n        if (!WebUtils.isHttp(subjectContext)) {\n            if (log.isDebugEnabled()) {\n                String msg = \"SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a \" +\n                        \"servlet request and response in order to retrieve the rememberMe cookie. Returning \" +\n                        \"immediately and ignoring rememberMe operation.\";\n                log.debug(msg);\n            }\n            return null;\n        }\n\n        WebSubjectContext wsc = (WebSubjectContext) subjectContext;\n        if (isIdentityRemoved(wsc)) {\n            return null;\n        }\n\n        HttpServletRequest request = WebUtils.getHttpRequest(wsc);\n        HttpServletResponse response = WebUtils.getHttpResponse(wsc);\n\n        String base64 = getCookie().readValue(request, response);\n        // Browsers do not always remove cookies immediately (SHIRO-183)\n        // ignore cookies that are scheduled for removal\n        if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null;\n\n        if (base64 != null) {\n            base64 = ensurePadding(base64);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Acquired Base64 encoded identity [\" + base64 + \"]\");\n            }\n            byte[] decoded = Base64.decode(base64);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Base64 decoded byte array length: \" + (decoded != null ? decoded.length : 0) + \" bytes.\");\n            }\n            return decoded;\n        } else {\n            //no cookie set - new site visitor?\n            return null;\n        }\n    }", "code_tokens": ["protected", "byte", "[", "]", "getRememberedSerializedIdentity", "(", "SubjectContext", "subjectContext", ")", "{", "if", "(", "!", "WebUtils", ".", "isHttp", "(", "subjectContext", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "String", "msg", "=", "\"", "SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a ", "\"", "+", "\"", "servlet request and response in order to retrieve the rememberMe cookie. Returning ", "\"", "+", "\"", "immediately and ignoring rememberMe operation.", "\"", ";", "log", ".", "debug", "(", "msg", ")", ";", "}", "return", "null", ";", "}", "WebSubjectContext", "wsc", "=", "(", "WebSubjectContext", ")", "subjectContext", ";", "if", "(", "isIdentityRemoved", "(", "wsc", ")", ")", "{", "return", "null", ";", "}", "HttpServletRequest", "request", "=", "WebUtils", ".", "getHttpRequest", "(", "wsc", ")", ";", "HttpServletResponse", "response", "=", "WebUtils", ".", "getHttpResponse", "(", "wsc", ")", ";", "String", "base64", "=", "getCookie", "(", ")", ".", "readValue", "(", "request", ",", "response", ")", ";", "if", "(", "Cookie", ".", "DELETED_COOKIE_VALUE", ".", "equals", "(", "base64", ")", ")", "return", "null", ";", "if", "(", "base64", "!=", "null", ")", "{", "base64", "=", "ensurePadding", "(", "base64", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Acquired Base64 encoded identity [", "\"", "+", "base64", "+", "\"", "]", "\"", ")", ";", "}", "byte", "[", "]", "decoded", "=", "Base64", ".", "decode", "(", "base64", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Base64 decoded byte array length: ", "\"", "+", "(", "decoded", "!=", "null", "?", "decoded", ".", "length", ":", "0", ")", "+", "\"", " bytes.", "\"", ")", ";", "}", "return", "decoded", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "idx": 109396, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "83d8dacd273c8f6d70e6b1aa4f240d4f7a408c27", "function_name": "getRememberedSerializedIdentity", "body_hash": "992fc9892f68117c2e0d5a1e7309cc42d63f3826"}
{"code": "public TaglibXml parse(TldResourcePath path) throws IOException, SAXException {\n        try (InputStream is = path.openStream()) {\n            XmlErrorHandler handler = new XmlErrorHandler();\n            digester.setErrorHandler(handler);\n\n            TaglibXml taglibXml = new TaglibXml();\n            digester.push(taglibXml);\n\n            InputSource source = new InputSource(path.toExternalForm());\n            source.setByteStream(is);\n            digester.parse(source);\n            if (!handler.getWarnings().isEmpty() || !handler.getErrors().isEmpty()) {\n                handler.logFindings(log, source.getSystemId());\n                if (!handler.getErrors().isEmpty()) {\n                    // throw the first to indicate there was a error during processing\n                    throw handler.getErrors().iterator().next();\n                }\n            }\n            return taglibXml;\n        } finally {\n            digester.reset();\n        }\n    }", "code_tokens": ["public", "TaglibXml", "parse", "(", "TldResourcePath", "path", ")", "throws", "IOException", ",", "SAXException", "{", "try", "(", "InputStream", "is", "=", "path", ".", "openStream", "(", ")", ")", "{", "XmlErrorHandler", "handler", "=", "new", "XmlErrorHandler", "(", ")", ";", "digester", ".", "setErrorHandler", "(", "handler", ")", ";", "TaglibXml", "taglibXml", "=", "new", "TaglibXml", "(", ")", ";", "digester", ".", "push", "(", "taglibXml", ")", ";", "InputSource", "source", "=", "new", "InputSource", "(", "path", ".", "toExternalForm", "(", ")", ")", ";", "source", ".", "setByteStream", "(", "is", ")", ";", "digester", ".", "parse", "(", "source", ")", ";", "if", "(", "!", "handler", ".", "getWarnings", "(", ")", ".", "isEmpty", "(", ")", "||", "!", "handler", ".", "getErrors", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "handler", ".", "logFindings", "(", "log", ",", "source", ".", "getSystemId", "(", ")", ")", ";", "if", "(", "!", "handler", ".", "getErrors", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "throw", "handler", ".", "getErrors", "(", ")", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "}", "}", "return", "taglibXml", ";", "}", "finally", "{", "digester", ".", "reset", "(", ")", ";", "}", "}"], "idx": 32153, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "5aae1323c31d643afa9f2db80713b8e97b5123af", "function_name": "parse", "body_hash": "be8a8ea5c6fc96cb48dd45506873dc9d0be4c9b3"}
{"code": "@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        String url = this.url;\n        if (url.startsWith(\"/\")) {\n            StaplerRequest req = Stapler.getCurrentRequest();\n            if (req!=null) {\n                // if we are serving HTTP request, we want to use app relative URL\n                url = req.getContextPath()+url;\n            } else {\n                // otherwise presumably this is rendered for e-mails and other non-HTTP stuff\n                url = Jenkins.get().getRootUrl()+url.substring(1);\n            }\n        }\n        text.addMarkup(charPos, charPos + length, \"<a href='\" + url + \"'\"+extraAttributes()+\">\", \"</a>\");\n        return null;\n    }", "code_tokens": ["@", "Override", "public", "ConsoleAnnotator", "annotate", "(", "Object", "context", ",", "MarkupText", "text", ",", "int", "charPos", ")", "{", "String", "url", "=", "this", ".", "url", ";", "if", "(", "url", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "{", "StaplerRequest", "req", "=", "Stapler", ".", "getCurrentRequest", "(", ")", ";", "if", "(", "req", "!=", "null", ")", "{", "url", "=", "req", ".", "getContextPath", "(", ")", "+", "url", ";", "}", "else", "{", "url", "=", "Jenkins", ".", "get", "(", ")", ".", "getRootUrl", "(", ")", "+", "url", ".", "substring", "(", "1", ")", ";", "}", "}", "text", ".", "addMarkup", "(", "charPos", ",", "charPos", "+", "length", ",", "\"", "<a href='", "\"", "+", "url", "+", "\"", "'", "\"", "+", "extraAttributes", "(", ")", "+", "\"", ">", "\"", ",", "\"", "</a>", "\"", ")", ";", "return", "null", ";", "}"], "idx": 77677, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "11f4a351224ef04cfeb9c7636fb1590b67543f3c", "function_name": "annotate", "body_hash": "2d714d1cee58f50f86f1af8b1c3f364d482aa965"}
{"code": "public static File newTmpFile( final String content, final Charset encoding ) throws IOException {\n        final File f = File.createTempFile( \"jspwiki\", null );\n        try( final Reader in = new StringReader( content );\n             final Writer out = new OutputStreamWriter( new FileOutputStream( f ), encoding ) ) {\n            copyContents( in, out );\n        }\n\n        return f;\n    }", "code_tokens": ["public", "static", "File", "newTmpFile", "(", "final", "String", "content", ",", "final", "Charset", "encoding", ")", "throws", "IOException", "{", "final", "File", "f", "=", "File", ".", "createTempFile", "(", "\"", "jspwiki", "\"", ",", "null", ")", ";", "try", "(", "final", "Reader", "in", "=", "new", "StringReader", "(", "content", ")", ";", "final", "Writer", "out", "=", "new", "OutputStreamWriter", "(", "new", "FileOutputStream", "(", "f", ")", ",", "encoding", ")", ")", "{", "copyContents", "(", "in", ",", "out", ")", ";", "}", "return", "f", ";", "}"], "idx": 36719, "cwe": "CWE-276", "target": 1, "status": "VULNERABLE", "commit": "800196dc239553ee2ea8f71754f8ee3f85bcf70f", "function_name": "newTmpFile", "body_hash": "28dc29a1fc5d68623774063753a1d46f94c0f31c"}
{"code": "private static boolean contains(final String[] list, final String name) {\n        if (list != null) {\n            for (final String white : list) {\n                if (\"*\".equals(white) || name.startsWith(white)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "code_tokens": ["private", "static", "boolean", "contains", "(", "final", "String", "[", "]", "list", ",", "final", "String", "name", ")", "{", "if", "(", "list", "!=", "null", ")", "{", "for", "(", "final", "String", "white", ":", "list", ")", "{", "if", "(", "\"", "*", "\"", ".", "equals", "(", "white", ")", "||", "name", ".", "startsWith", "(", "white", ")", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "idx": 58393, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "58cdbbef9c77ab2b44870f9d606593b49cde76d9", "function_name": "contains", "body_hash": "502fd4e0e6bbe30061351adabe42b1dfc149a569"}
{"code": "private static Node newNode() {\n        Node build = NodeBuilder.nodeBuilder().local(true).data(true).settings(ImmutableSettings.builder()\n                .put(ClusterName.SETTING, nodeName())\n                .put(\"node.name\", nodeName())\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n                .put(EsExecutors.PROCESSORS, 1) // limit the number of threads created\n                .put(\"http.enabled\", false)\n                .put(\"index.store.type\", \"ram\")\n                .put(\"config.ignore_system_properties\", true) // make sure we get what we set :)\n                .put(\"gateway.type\", \"none\")).build();\n        build.start();\n        assertThat(DiscoveryNode.localNode(build.settings()), is(true));\n        return build;\n    }", "code_tokens": ["private", "static", "Node", "newNode", "(", ")", "{", "Node", "build", "=", "NodeBuilder", ".", "nodeBuilder", "(", ")", ".", "local", "(", "true", ")", ".", "data", "(", "true", ")", ".", "settings", "(", "ImmutableSettings", ".", "builder", "(", ")", ".", "put", "(", "ClusterName", ".", "SETTING", ",", "nodeName", "(", ")", ")", ".", "put", "(", "\"", "node.name", "\"", ",", "nodeName", "(", ")", ")", ".", "put", "(", "IndexMetaData", ".", "SETTING_NUMBER_OF_SHARDS", ",", "1", ")", ".", "put", "(", "IndexMetaData", ".", "SETTING_NUMBER_OF_REPLICAS", ",", "0", ")", ".", "put", "(", "EsExecutors", ".", "PROCESSORS", ",", "1", ")", ".", "put", "(", "\"", "http.enabled", "\"", ",", "false", ")", ".", "put", "(", "\"", "index.store.type", "\"", ",", "\"", "ram", "\"", ")", ".", "put", "(", "\"", "config.ignore_system_properties", "\"", ",", "true", ")", ".", "put", "(", "\"", "gateway.type", "\"", ",", "\"", "none", "\"", ")", ")", ".", "build", "(", ")", ";", "build", ".", "start", "(", ")", ";", "assertThat", "(", "DiscoveryNode", ".", "localNode", "(", "build", ".", "settings", "(", ")", ")", ",", "is", "(", "true", ")", ")", ";", "return", "build", ";", "}"], "idx": 38061, "cwe": "CWE-284", "target": 1, "status": "VULNERABLE", "commit": "4e952b2d75de6ca4caf4b6743462714f3b60d07f", "function_name": "newNode", "body_hash": "440d15c1c2281cb7fdb05c32e5f94cc34ea1f21c"}
{"code": "public XWikiRequest getRequest()\n    {\n        return getXWikiContext().getRequest();\n    }", "code_tokens": ["public", "XWikiRequest", "getRequest", "(", ")", "{", "return", "getXWikiContext", "(", ")", ".", "getRequest", "(", ")", ";", "}"], "idx": 73948, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "766e5e8480f", "function_name": "getRequest", "body_hash": "567ac28d381449920df7c22ccf15eef4883810df"}
{"code": "@RequirePOST\n    public synchronized void doConfigure(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, Descriptor.FormException {\n        // for compatibility reasons, the actual value is stored in Jenkins\n        BulkChange bc = new BulkChange(Jenkins.get());\n        try{\n            boolean result = configure(req, req.getSubmittedForm());\n            LOGGER.log(Level.FINE, \"security saved: \"+result);\n            Jenkins.get().save();\n            FormApply.success(req.getContextPath()+\"/manage\").generateResponse(req, rsp, null);\n        } finally {\n            bc.commit();\n        }\n    }", "code_tokens": ["@", "RequirePOST", "public", "synchronized", "void", "doConfigure", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", ",", "Descriptor", ".", "FormException", "{", "BulkChange", "bc", "=", "new", "BulkChange", "(", "Jenkins", ".", "get", "(", ")", ")", ";", "try", "{", "boolean", "result", "=", "configure", "(", "req", ",", "req", ".", "getSubmittedForm", "(", ")", ")", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "security saved: ", "\"", "+", "result", ")", ";", "Jenkins", ".", "get", "(", ")", ".", "save", "(", ")", ";", "FormApply", ".", "success", "(", "req", ".", "getContextPath", "(", ")", "+", "\"", "/manage", "\"", ")", ".", "generateResponse", "(", "req", ",", "rsp", ",", "null", ")", ";", "}", "finally", "{", "bc", ".", "commit", "(", ")", ";", "}", "}"], "idx": 85235, "cwe": "CWE-862", "target": 1, "status": "VULNERABLE", "commit": "783618f", "function_name": "doConfigure", "body_hash": "283cf408c75fa64528b03f7ceab1325cb4b3f77e"}
{"code": "private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {\n        // Create the NamingService, needed by JSR 160\n        try {\n            if (registry == null) {\n                LOG.debug(\"Creating RMIRegistry on port {}\", connectorPort);\n                registry = new JmxRegistry(connectorPort);\n            }\n\n            namingServiceObjectName = ObjectName.getInstance(\"naming:type=rmiregistry\");\n\n            // Do not use the createMBean as the mx4j jar may not be in the\n            // same class loader than the server\n            Class<?> cl = Class.forName(\"mx4j.tools.naming.NamingService\");\n            mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);\n\n            // set the naming port\n            Attribute attr = new Attribute(\"Port\", Integer.valueOf(connectorPort));\n            mbeanServer.setAttribute(namingServiceObjectName, attr);\n        } catch(ClassNotFoundException e) {\n            LOG.debug(\"Probably not using JRE 1.4: {}\", e.getLocalizedMessage());\n        } catch (Throwable e) {\n            LOG.debug(\"Failed to create local registry. This exception will be ignored.\", e);\n        }\n\n        // Create the JMXConnectorServer\n        String rmiServer = \"\";\n        if (rmiServerPort != 0) {\n            // This is handy to use if you have a firewall and need to force JMX to use fixed ports.\n            rmiServer = \"\"+getConnectorHost()+\":\" + rmiServerPort;\n        }\n\n        server = new RMIJRMPServerImpl(connectorPort, null, null, environment);\n\n        final String serviceURL = \"service:jmx:rmi://\" + rmiServer + \"/jndi/rmi://\" +getConnectorHost()+\":\" + connectorPort + connectorPath;\n        final JMXServiceURL url = new JMXServiceURL(serviceURL);\n\n        connectorServer = new RMIConnectorServer(url, environment, server, ManagementFactory.getPlatformMBeanServer());\n        LOG.debug(\"Created JMXConnectorServer {}\", connectorServer);\n    }", "code_tokens": ["private", "void", "createConnector", "(", "MBeanServer", "mbeanServer", ")", "throws", "MalformedObjectNameException", ",", "IOException", "{", "try", "{", "if", "(", "registry", "==", "null", ")", "{", "LOG", ".", "debug", "(", "\"", "Creating RMIRegistry on port {}", "\"", ",", "connectorPort", ")", ";", "registry", "=", "new", "JmxRegistry", "(", "connectorPort", ")", ";", "}", "namingServiceObjectName", "=", "ObjectName", ".", "getInstance", "(", "\"", "naming:type=rmiregistry", "\"", ")", ";", "Class", "<", "?", ">", "cl", "=", "Class", ".", "forName", "(", "\"", "mx4j.tools.naming.NamingService", "\"", ")", ";", "mbeanServer", ".", "registerMBean", "(", "cl", ".", "newInstance", "(", ")", ",", "namingServiceObjectName", ")", ";", "Attribute", "attr", "=", "new", "Attribute", "(", "\"", "Port", "\"", ",", "Integer", ".", "valueOf", "(", "connectorPort", ")", ")", ";", "mbeanServer", ".", "setAttribute", "(", "namingServiceObjectName", ",", "attr", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "LOG", ".", "debug", "(", "\"", "Probably not using JRE 1.4: {}", "\"", ",", "e", ".", "getLocalizedMessage", "(", ")", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "LOG", ".", "debug", "(", "\"", "Failed to create local registry. This exception will be ignored.", "\"", ",", "e", ")", ";", "}", "String", "rmiServer", "=", "\"", "\"", ";", "if", "(", "rmiServerPort", "!=", "0", ")", "{", "rmiServer", "=", "\"", "\"", "+", "getConnectorHost", "(", ")", "+", "\"", ":", "\"", "+", "rmiServerPort", ";", "}", "server", "=", "new", "RMIJRMPServerImpl", "(", "connectorPort", ",", "null", ",", "null", ",", "environment", ")", ";", "final", "String", "serviceURL", "=", "\"", "service:jmx:rmi://", "\"", "+", "rmiServer", "+", "\"", "/jndi/rmi://", "\"", "+", "getConnectorHost", "(", ")", "+", "\"", ":", "\"", "+", "connectorPort", "+", "connectorPath", ";", "final", "JMXServiceURL", "url", "=", "new", "JMXServiceURL", "(", "serviceURL", ")", ";", "connectorServer", "=", "new", "RMIConnectorServer", "(", "url", ",", "environment", ",", "server", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "LOG", ".", "debug", "(", "\"", "Created JMXConnectorServer {}", "\"", ",", "connectorServer", ")", ";", "}"], "idx": 96198, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "aa8900ca70e6f9422490c1a03627400375d3ff83", "function_name": "createConnector", "body_hash": "76209becc879bca50cc5c686fb3ea182044d9de5"}
{"code": "public Socket connectSocket(\n            final int connectTimeout,\n            final Socket socket,\n            final HttpHost host,\n            final InetSocketAddress remoteAddress,\n            final InetSocketAddress localAddress,\n            final HttpContext context) throws IOException {\n        Args.notNull(host, \"HTTP host\");\n        Args.notNull(remoteAddress, \"Remote address\");\n        final Socket sock = socket != null ? socket : createSocket(context);\n        if (localAddress != null) {\n            sock.bind(localAddress);\n        }\n        try {\n            if (connectTimeout > 0 && sock.getSoTimeout() == 0) {\n                sock.setSoTimeout(connectTimeout);\n            }\n            sock.connect(remoteAddress, connectTimeout);\n        } catch (final IOException ex) {\n            try {\n                sock.close();\n            } catch (final IOException ignore) {\n            }\n            throw ex;\n        }\n        // Setup SSL layering if necessary\n        if (sock instanceof SSLSocket) {\n            final SSLSocket sslsock = (SSLSocket) sock;\n            sslsock.startHandshake();\n            verifyHostname(sslsock, host.getHostName());\n            return sock;\n        } else {\n            return createLayeredSocket(sock, host.getHostName(), remoteAddress.getPort(), context);\n        }\n    }", "code_tokens": ["public", "Socket", "connectSocket", "(", "final", "int", "connectTimeout", ",", "final", "Socket", "socket", ",", "final", "HttpHost", "host", ",", "final", "InetSocketAddress", "remoteAddress", ",", "final", "InetSocketAddress", "localAddress", ",", "final", "HttpContext", "context", ")", "throws", "IOException", "{", "Args", ".", "notNull", "(", "host", ",", "\"", "HTTP host", "\"", ")", ";", "Args", ".", "notNull", "(", "remoteAddress", ",", "\"", "Remote address", "\"", ")", ";", "final", "Socket", "sock", "=", "socket", "!=", "null", "?", "socket", ":", "createSocket", "(", "context", ")", ";", "if", "(", "localAddress", "!=", "null", ")", "{", "sock", ".", "bind", "(", "localAddress", ")", ";", "}", "try", "{", "if", "(", "connectTimeout", ">", "0", "&&", "sock", ".", "getSoTimeout", "(", ")", "==", "0", ")", "{", "sock", ".", "setSoTimeout", "(", "connectTimeout", ")", ";", "}", "sock", ".", "connect", "(", "remoteAddress", ",", "connectTimeout", ")", ";", "}", "catch", "(", "final", "IOException", "ex", ")", "{", "try", "{", "sock", ".", "close", "(", ")", ";", "}", "catch", "(", "final", "IOException", "ignore", ")", "{", "}", "throw", "ex", ";", "}", "if", "(", "sock", "instanceof", "SSLSocket", ")", "{", "final", "SSLSocket", "sslsock", "=", "(", "SSLSocket", ")", "sock", ";", "sslsock", ".", "startHandshake", "(", ")", ";", "verifyHostname", "(", "sslsock", ",", "host", ".", "getHostName", "(", ")", ")", ";", "return", "sock", ";", "}", "else", "{", "return", "createLayeredSocket", "(", "sock", ",", "host", ".", "getHostName", "(", ")", ",", "remoteAddress", ".", "getPort", "(", ")", ",", "context", ")", ";", "}", "}"], "idx": 51215, "cwe": "CWE-399", "target": 0, "status": "FIXED", "commit": "d954cd287dfcdad8f153e61181e20d253175ca8c", "function_name": "connectSocket", "body_hash": "0eb6527aee859694069ebe6d5a4bb881ee50a976"}
{"code": "protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        PrintWriter out = response.getWriter();\n        String[] stocks = request.getParameterValues(\"stocks\");\n        if (stocks == null || stocks.length == 0) {\n            out.println(\"<html><body>No <b>stocks</b> query parameter specified. Cannot publish market data</body></html>\");\n        } else {\n            Integer total = (Integer)request.getSession(true).getAttribute(\"total\");\n            if (total == null) {\n                total = Integer.valueOf(0);\n            }\n\n            int count = getNumberOfMessages(request);\n            total = Integer.valueOf(total.intValue() + count);\n            request.getSession().setAttribute(\"total\", total);\n\n            try {\n                WebClient client = WebClient.getWebClient(request);\n                for (int i = 0; i < count; i++) {\n                    sendMessage(client, stocks);\n                }\n                out.print(\"<html><head><meta http-equiv='refresh' content='\");\n                String refreshRate = request.getParameter(\"refresh\");\n                if (refreshRate == null || refreshRate.length() == 0) {\n                    refreshRate = \"1\";\n                }\n                out.print(refreshRate);\n                out.println(\"'/></head>\");\n                out.println(\"<body>Published <b>\" + count + \"</b> of \" + total + \" price messages.  Refresh = \" + refreshRate + \"s\");\n                out.println(\"</body></html>\");\n\n            } catch (JMSException e) {\n                out.println(\"<html><body>Failed sending price messages due to <b>\" + e + \"</b></body></html>\");\n                log(\"Failed to send message: \" + e, e);\n            }\n        }\n    }", "code_tokens": ["protected", "void", "doGet", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "PrintWriter", "out", "=", "response", ".", "getWriter", "(", ")", ";", "String", "[", "]", "stocks", "=", "request", ".", "getParameterValues", "(", "\"", "stocks", "\"", ")", ";", "if", "(", "stocks", "==", "null", "||", "stocks", ".", "length", "==", "0", ")", "{", "out", ".", "println", "(", "\"", "<html><body>No <b>stocks</b> query parameter specified. Cannot publish market data</body></html>", "\"", ")", ";", "}", "else", "{", "Integer", "total", "=", "(", "Integer", ")", "request", ".", "getSession", "(", "true", ")", ".", "getAttribute", "(", "\"", "total", "\"", ")", ";", "if", "(", "total", "==", "null", ")", "{", "total", "=", "Integer", ".", "valueOf", "(", "0", ")", ";", "}", "int", "count", "=", "getNumberOfMessages", "(", "request", ")", ";", "total", "=", "Integer", ".", "valueOf", "(", "total", ".", "intValue", "(", ")", "+", "count", ")", ";", "request", ".", "getSession", "(", ")", ".", "setAttribute", "(", "\"", "total", "\"", ",", "total", ")", ";", "try", "{", "WebClient", "client", "=", "WebClient", ".", "getWebClient", "(", "request", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "{", "sendMessage", "(", "client", ",", "stocks", ")", ";", "}", "out", ".", "print", "(", "\"", "<html><head><meta http-equiv='refresh' content='", "\"", ")", ";", "String", "refreshRate", "=", "request", ".", "getParameter", "(", "\"", "refresh", "\"", ")", ";", "if", "(", "refreshRate", "==", "null", "||", "refreshRate", ".", "length", "(", ")", "==", "0", ")", "{", "refreshRate", "=", "\"", "1", "\"", ";", "}", "out", ".", "print", "(", "refreshRate", ")", ";", "out", ".", "println", "(", "\"", "'/></head>", "\"", ")", ";", "out", ".", "println", "(", "\"", "<body>Published <b>", "\"", "+", "count", "+", "\"", "</b> of ", "\"", "+", "total", "+", "\"", " price messages.  Refresh = ", "\"", "+", "refreshRate", "+", "\"", "s", "\"", ")", ";", "out", ".", "println", "(", "\"", "</body></html>", "\"", ")", ";", "}", "catch", "(", "JMSException", "e", ")", "{", "out", ".", "println", "(", "\"", "<html><body>Failed sending price messages due to <b>", "\"", "+", "e", "+", "\"", "</b></body></html>", "\"", ")", ";", "log", "(", "\"", "Failed to send message: ", "\"", "+", "e", ",", "e", ")", ";", "}", "}", "}"], "idx": 77484, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "51eb87a84be88d28383ea48f6e341ffe1203c5ba", "function_name": "doGet", "body_hash": "f50a37c174c4b95a7af28ec2d888462e6c02e440"}
{"code": "@Override\n  public void init(NamedList args) {\n    super.init(args);\n\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input factory: \" + inputFactory);\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "init", "(", "NamedList", "args", ")", "{", "super", ".", "init", "(", "args", ")", ";", "inputFactory", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "EmptyEntityResolver", ".", "configureXMLInputFactory", "(", "inputFactory", ")", ";", "inputFactory", ".", "setXMLReporter", "(", "xmllog", ")", ";", "try", "{", "inputFactory", ".", "setProperty", "(", "\"", "reuse-instance", "\"", ",", "Boolean", ".", "FALSE", ")", ";", "}", "catch", "(", "IllegalArgumentException", "ex", ")", "{", "log", ".", "debug", "(", "\"", "Unable to set the 'reuse-instance' property for the input factory: ", "\"", "+", "inputFactory", ")", ";", "}", "}"], "idx": 102902, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "7239a57a51ea0f4d05dd330ce5e15e4f72f72747", "function_name": "init", "body_hash": "cbf55dc2e1389266dc0ee9b277bef0d99ba6f7aa"}
{"code": "public static void unJar(File jarFile, File toDir, Pattern unpackRegex)\n    throws IOException {\n    JarFile jar = new JarFile(jarFile);\n    try {\n      String targetDirPath = toDir.getCanonicalPath() + File.separator;\n      Enumeration<JarEntry> entries = jar.entries();\n      while (entries.hasMoreElements()) {\n        final JarEntry entry = entries.nextElement();\n        if (!entry.isDirectory() &&\n            unpackRegex.matcher(entry.getName()).matches()) {\n          InputStream in = jar.getInputStream(entry);\n          try {\n            File file = new File(toDir, entry.getName());\n            ensureDirectory(file.getParentFile());\n            if (!file.getCanonicalPath().startsWith(targetDirPath)) {\n              throw new IOException(\"expanding \" + entry.getName()\n                  + \" would create file outside of \" + toDir);\n            }\n            OutputStream out = new FileOutputStream(file);\n            try {\n              IOUtils.copyBytes(in, out, 8192);\n            } finally {\n              out.close();\n            }\n          } finally {\n            in.close();\n          }\n        }\n      }\n    } finally {\n      jar.close();\n    }\n  }", "code_tokens": ["public", "static", "void", "unJar", "(", "File", "jarFile", ",", "File", "toDir", ",", "Pattern", "unpackRegex", ")", "throws", "IOException", "{", "JarFile", "jar", "=", "new", "JarFile", "(", "jarFile", ")", ";", "try", "{", "String", "targetDirPath", "=", "toDir", ".", "getCanonicalPath", "(", ")", "+", "File", ".", "separator", ";", "Enumeration", "<", "JarEntry", ">", "entries", "=", "jar", ".", "entries", "(", ")", ";", "while", "(", "entries", ".", "hasMoreElements", "(", ")", ")", "{", "final", "JarEntry", "entry", "=", "entries", ".", "nextElement", "(", ")", ";", "if", "(", "!", "entry", ".", "isDirectory", "(", ")", "&&", "unpackRegex", ".", "matcher", "(", "entry", ".", "getName", "(", ")", ")", ".", "matches", "(", ")", ")", "{", "InputStream", "in", "=", "jar", ".", "getInputStream", "(", "entry", ")", ";", "try", "{", "File", "file", "=", "new", "File", "(", "toDir", ",", "entry", ".", "getName", "(", ")", ")", ";", "ensureDirectory", "(", "file", ".", "getParentFile", "(", ")", ")", ";", "if", "(", "!", "file", ".", "getCanonicalPath", "(", ")", ".", "startsWith", "(", "targetDirPath", ")", ")", "{", "throw", "new", "IOException", "(", "\"", "expanding ", "\"", "+", "entry", ".", "getName", "(", ")", "+", "\"", " would create file outside of ", "\"", "+", "toDir", ")", ";", "}", "OutputStream", "out", "=", "new", "FileOutputStream", "(", "file", ")", ";", "try", "{", "IOUtils", ".", "copyBytes", "(", "in", ",", "out", ",", "8192", ")", ";", "}", "finally", "{", "out", ".", "close", "(", ")", ";", "}", "}", "finally", "{", "in", ".", "close", "(", ")", ";", "}", "}", "}", "}", "finally", "{", "jar", ".", "close", "(", ")", ";", "}", "}"], "idx": 22515, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "eaa2b8035b584dfcf7c79a33484eb2dffd3fdb1", "function_name": "unJar", "body_hash": "964d450900f49721b379d9a613d82fe25b143f04"}
{"code": "@Override\n    public AcceptedInvitation acceptInvitation(String code, String password) {\n        ExpiringCode data = expiringCodeStore.retrieveCode(code);\n\n        Map<String,String> userData = JsonUtils.readValue(data.getData(), new TypeReference<Map<String, String>>() {});\n        String userId = userData.get(USER_ID);\n        String clientId = userData.get(CLIENT_ID);\n        String redirectUri = userData.get(REDIRECT_URI);\n\n        ScimUser user = scimUserProvisioning.retrieve(userId);\n\n        user = scimUserProvisioning.verifyUser(userId, user.getVersion());\n\n\n        if (OriginKeys.UAA.equals(user.getOrigin())) {\n            PasswordChangeRequest request = new PasswordChangeRequest();\n            request.setPassword(password);\n            scimUserProvisioning.changePassword(userId, null, password);\n        }\n\n        String redirectLocation = \"/home\";\n        try {\n            ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n            Set<String> redirectUris = clientDetails.getRegisteredRedirectUri();\n            redirectLocation = UaaUrlUtils.findMatchingRedirectUri(redirectUris, redirectUri, redirectLocation);\n        } catch (NoSuchClientException x) {\n            logger.debug(\"Unable to find client_id for invitation:\"+clientId);\n        } catch (Exception x) {\n            logger.error(\"Unable to resolve redirect for clientID:\"+clientId, x);\n        }\n        return new AcceptedInvitation(redirectLocation, user);\n    }", "code_tokens": ["@", "Override", "public", "AcceptedInvitation", "acceptInvitation", "(", "String", "code", ",", "String", "password", ")", "{", "ExpiringCode", "data", "=", "expiringCodeStore", ".", "retrieveCode", "(", "code", ")", ";", "Map", "<", "String", ",", "String", ">", "userData", "=", "JsonUtils", ".", "readValue", "(", "data", ".", "getData", "(", ")", ",", "new", "TypeReference", "<", "Map", "<", "String", ",", "String", ">", ">", "(", ")", "{", "}", ")", ";", "String", "userId", "=", "userData", ".", "get", "(", "USER_ID", ")", ";", "String", "clientId", "=", "userData", ".", "get", "(", "CLIENT_ID", ")", ";", "String", "redirectUri", "=", "userData", ".", "get", "(", "REDIRECT_URI", ")", ";", "ScimUser", "user", "=", "scimUserProvisioning", ".", "retrieve", "(", "userId", ")", ";", "user", "=", "scimUserProvisioning", ".", "verifyUser", "(", "userId", ",", "user", ".", "getVersion", "(", ")", ")", ";", "if", "(", "OriginKeys", ".", "UAA", ".", "equals", "(", "user", ".", "getOrigin", "(", ")", ")", ")", "{", "PasswordChangeRequest", "request", "=", "new", "PasswordChangeRequest", "(", ")", ";", "request", ".", "setPassword", "(", "password", ")", ";", "scimUserProvisioning", ".", "changePassword", "(", "userId", ",", "null", ",", "password", ")", ";", "}", "String", "redirectLocation", "=", "\"", "/home", "\"", ";", "try", "{", "ClientDetails", "clientDetails", "=", "clientDetailsService", ".", "loadClientByClientId", "(", "clientId", ")", ";", "Set", "<", "String", ">", "redirectUris", "=", "clientDetails", ".", "getRegisteredRedirectUri", "(", ")", ";", "redirectLocation", "=", "UaaUrlUtils", ".", "findMatchingRedirectUri", "(", "redirectUris", ",", "redirectUri", ",", "redirectLocation", ")", ";", "}", "catch", "(", "NoSuchClientException", "x", ")", "{", "logger", ".", "debug", "(", "\"", "Unable to find client_id for invitation:", "\"", "+", "clientId", ")", ";", "}", "catch", "(", "Exception", "x", ")", "{", "logger", ".", "error", "(", "\"", "Unable to resolve redirect for clientID:", "\"", "+", "clientId", ",", "x", ")", ";", "}", "return", "new", "AcceptedInvitation", "(", "redirectLocation", ",", "user", ")", ";", "}"], "idx": 34045, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "b3834364ab573e9655348193780a56a602fe87b7", "function_name": "acceptInvitation", "body_hash": "27cd9dae1ff0d43196dd9c5c7c90c134f42795e1"}
{"code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,\n            ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpReq = (HttpServletRequest) request;\n            HttpServletResponse httpResp = (HttpServletResponse) response;\n\n            if (\"GET\".equals(httpReq.getMethod())) {\n                String pushSessionId = httpReq.getParameter(PUSH_SESSION_ID_PARAM);\n\n                Session session = null;\n\n                if (pushSessionId != null) {\n                    ensureServletContextAvailable(request);\n                    PushContext pushContext = (PushContext) servletContext.getAttribute(PushContext.INSTANCE_KEY_NAME);\n                    session = pushContext.getSessionManager().getPushSession(pushSessionId);\n                }\n\n                if (session == null) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(MessageFormat.format(\"Session {0} was not found\", pushSessionId));\n                    }\n                    httpResp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n\n                httpResp.setContentType(\"text/plain\");\n\n                Meteor meteor = Meteor.build(httpReq, SCOPE.REQUEST, Collections.<BroadcastFilter>emptyList(), null);\n\n                try {\n                    Request pushRequest = new RequestImpl(meteor, session);\n\n                    httpReq.setAttribute(SESSION_ATTRIBUTE_NAME, session);\n                    httpReq.setAttribute(REQUEST_ATTRIBUTE_NAME, pushRequest);\n\n                    pushRequest.suspend();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n\n                return;\n            }\n        }\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "request", "instanceof", "HttpServletRequest", "&&", "response", "instanceof", "HttpServletResponse", ")", "{", "HttpServletRequest", "httpReq", "=", "(", "HttpServletRequest", ")", "request", ";", "HttpServletResponse", "httpResp", "=", "(", "HttpServletResponse", ")", "response", ";", "if", "(", "\"", "GET", "\"", ".", "equals", "(", "httpReq", ".", "getMethod", "(", ")", ")", ")", "{", "String", "pushSessionId", "=", "httpReq", ".", "getParameter", "(", "PUSH_SESSION_ID_PARAM", ")", ";", "Session", "session", "=", "null", ";", "if", "(", "pushSessionId", "!=", "null", ")", "{", "ensureServletContextAvailable", "(", "request", ")", ";", "PushContext", "pushContext", "=", "(", "PushContext", ")", "servletContext", ".", "getAttribute", "(", "PushContext", ".", "INSTANCE_KEY_NAME", ")", ";", "session", "=", "pushContext", ".", "getSessionManager", "(", ")", ".", "getPushSession", "(", "pushSessionId", ")", ";", "}", "if", "(", "session", "==", "null", ")", "{", "if", "(", "LOGGER", ".", "isDebugEnabled", "(", ")", ")", "{", "LOGGER", ".", "debug", "(", "MessageFormat", ".", "format", "(", "\"", "Session {0} was not found", "\"", ",", "pushSessionId", ")", ")", ";", "}", "httpResp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "httpResp", ".", "setContentType", "(", "\"", "text/plain", "\"", ")", ";", "Meteor", "meteor", "=", "Meteor", ".", "build", "(", "httpReq", ",", "SCOPE", ".", "REQUEST", ",", "Collections", ".", "<", "BroadcastFilter", ">", "emptyList", "(", ")", ",", "null", ")", ";", "try", "{", "Request", "pushRequest", "=", "new", "RequestImpl", "(", "meteor", ",", "session", ")", ";", "httpReq", ".", "setAttribute", "(", "SESSION_ATTRIBUTE_NAME", ",", "session", ")", ";", "httpReq", ".", "setAttribute", "(", "REQUEST_ATTRIBUTE_NAME", ",", "pushRequest", ")", ";", "pushRequest", ".", "suspend", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOGGER", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "return", ";", "}", "}", "}"], "idx": 7826, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "8131f15003f5bec73d475d2b724472e4b87d0757", "function_name": "doFilter", "body_hash": "216c6ca323e8f1a85b4aec92bc21b9c2dd9db481"}
{"code": "private static boolean contains(final String[] list, String name) {\n            if (list != null) {\n                for (final String white : list) {\n                    if (name.startsWith(white)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "code_tokens": ["private", "static", "boolean", "contains", "(", "final", "String", "[", "]", "list", ",", "String", "name", ")", "{", "if", "(", "list", "!=", "null", ")", "{", "for", "(", "final", "String", "white", ":", "list", ")", "{", "if", "(", "name", ".", "startsWith", "(", "white", ")", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "idx": 61610, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "58cdbbef9c77ab2b44870f9d606593b49cde76d9", "function_name": "contains", "body_hash": "03e719e52002564a76586c9562e4072b3c3f93cc"}
{"code": "private void introspectInterfaces(Class<?> beanClass, Class<?> currClass, Set<String> readMethodNames)\n\t\t\tthrows IntrospectionException {\n\n\t\tfor (Class<?> ifc : currClass.getInterfaces()) {\n\t\t\tif (!ClassUtils.isJavaLanguageInterface(ifc)) {\n\t\t\t\tfor (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {\n\t\t\t\t\tPropertyDescriptor existingPd = this.propertyDescriptors.get(pd.getName());\n\t\t\t\t\tif (existingPd == null ||\n\t\t\t\t\t\t\t(existingPd.getReadMethod() == null && pd.getReadMethod() != null)) {\n\t\t\t\t\t\t// GenericTypeAwarePropertyDescriptor leniently resolves a set* write method\n\t\t\t\t\t\t// against a declared read method, so we prefer read method descriptors here.\n\t\t\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n\t\t\t\t\t\tthis.propertyDescriptors.put(pd.getName(), pd);\n\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n\t\t\t\t\t\tif (readMethod != null) {\n\t\t\t\t\t\t\treadMethodNames.add(readMethod.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tintrospectInterfaces(ifc, ifc, readMethodNames);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["private", "void", "introspectInterfaces", "(", "Class", "<", "?", ">", "beanClass", ",", "Class", "<", "?", ">", "currClass", ",", "Set", "<", "String", ">", "readMethodNames", ")", "throws", "IntrospectionException", "{", "for", "(", "Class", "<", "?", ">", "ifc", ":", "currClass", ".", "getInterfaces", "(", ")", ")", "{", "if", "(", "!", "ClassUtils", ".", "isJavaLanguageInterface", "(", "ifc", ")", ")", "{", "for", "(", "PropertyDescriptor", "pd", ":", "getBeanInfo", "(", "ifc", ")", ".", "getPropertyDescriptors", "(", ")", ")", "{", "PropertyDescriptor", "existingPd", "=", "this", ".", "propertyDescriptors", ".", "get", "(", "pd", ".", "getName", "(", ")", ")", ";", "if", "(", "existingPd", "==", "null", "||", "(", "existingPd", ".", "getReadMethod", "(", ")", "==", "null", "&&", "pd", ".", "getReadMethod", "(", ")", "!=", "null", ")", ")", "{", "pd", "=", "buildGenericTypeAwarePropertyDescriptor", "(", "beanClass", ",", "pd", ")", ";", "this", ".", "propertyDescriptors", ".", "put", "(", "pd", ".", "getName", "(", ")", ",", "pd", ")", ";", "Method", "readMethod", "=", "pd", ".", "getReadMethod", "(", ")", ";", "if", "(", "readMethod", "!=", "null", ")", "{", "readMethodNames", ".", "add", "(", "readMethod", ".", "getName", "(", ")", ")", ";", "}", "}", "}", "introspectInterfaces", "(", "ifc", ",", "ifc", ",", "readMethodNames", ")", ";", "}", "}", "}"], "idx": 95346, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "002546b3e4b8d791ea6acccb81eb3168f51abb15", "function_name": "introspectInterfaces", "body_hash": "07a730517671a514b79bd0d2d62e641bab289349"}
{"code": "@Activate\n    @SuppressWarnings(\"unused\")\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n    }", "code_tokens": ["@", "Activate", "@", "SuppressWarnings", "(", "\"", "unused", "\"", ")", "protected", "void", "activate", "(", ")", "{", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setValidating", "(", "false", ")", ";", "factory", ".", "setNamespaceAware", "(", "true", ")", ";", "}"], "idx": 66820, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "fb2719e8299fadddae62245482de112052a0e08c", "function_name": "activate", "body_hash": "ed9f3025ad1e83674522f691917a1e8a5d49ef38"}
{"code": "@BeforeClass\n  public static void setupClass() {\n    FunctionService.registerFunction(luceneCreateIndexFunction);\n    FunctionService.registerFunction(luceneDescribeIndexFunction);\n    FunctionService.registerFunction(luceneDestroyIndexFunction);\n    FunctionService.registerFunction(luceneListIndexFunction);\n    FunctionService.registerFunction(luceneSearchIndexFunction);\n    FunctionService.registerFunction(dumpDirectoryFiles);\n    FunctionService.registerFunction(luceneQueryFunction);\n    FunctionService.registerFunction(waitUntilFlushedFunction);\n    FunctionService.registerFunction(luceneGetPageFunction);\n  }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "setupClass", "(", ")", "{", "FunctionService", ".", "registerFunction", "(", "luceneCreateIndexFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "luceneDescribeIndexFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "luceneDestroyIndexFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "luceneListIndexFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "luceneSearchIndexFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "dumpDirectoryFiles", ")", ";", "FunctionService", ".", "registerFunction", "(", "luceneQueryFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "waitUntilFlushedFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "luceneGetPageFunction", ")", ";", "}"], "idx": 88191, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "00be4f9774e1adf8e7ccc2664da8005fc30bb11d", "function_name": "setupClass", "body_hash": "bc57a58ff60d33b29eaf20e4edee2c0fdabd2f86"}
{"code": "@PresetData(DataSet.NO_ANONYMOUS_READACCESS)\n    @Email(\"http://www.nabble.com/Launching-slave-by-JNLP-with-Active-Directory-plugin-and-matrix-security-problem-td18980323.html\")\n    public void test() throws Exception {\n        jenkins.setNodes(Collections.singletonList(createNewJnlpSlave(\"test\")));\n        HudsonTestCase.WebClient wc = new WebClient();\n        HtmlPage p = wc.login(\"alice\").goTo(\"computer/test/\");\n\n        // this fresh WebClient doesn't have a login cookie and represent JNLP launcher\n        HudsonTestCase.WebClient jnlpAgent = new WebClient();\n\n        // parse the JNLP page into DOM to list up the jars.\n        XmlPage jnlp = (XmlPage) wc.goTo(\"computer/test/slave-agent.jnlp\",\"application/x-java-jnlp-file\");\n        URL baseUrl = jnlp.getWebResponse().getUrl();\n        Document dom = new DOMReader().read(jnlp.getXmlDocument());\n        for( Element jar : (List<Element>)dom.selectNodes(\"//jar\") ) {\n            URL url = new URL(baseUrl,jar.attributeValue(\"href\"));\n            System.out.println(url);\n            \n            // now make sure that these URLs are unprotected\n            Page jarResource = jnlpAgent.getPage(url);\n            assertTrue(jarResource.getWebResponse().getContentType().toLowerCase(Locale.ENGLISH).startsWith(\"application/\"));\n        }\n    }", "code_tokens": ["@", "PresetData", "(", "DataSet", ".", "NO_ANONYMOUS_READACCESS", ")", "@", "Email", "(", "\"", "http://www.nabble.com/Launching-slave-by-JNLP-with-Active-Directory-plugin-and-matrix-security-problem-td18980323.html", "\"", ")", "public", "void", "test", "(", ")", "throws", "Exception", "{", "jenkins", ".", "setNodes", "(", "Collections", ".", "singletonList", "(", "createNewJnlpSlave", "(", "\"", "test", "\"", ")", ")", ")", ";", "HudsonTestCase", ".", "WebClient", "wc", "=", "new", "WebClient", "(", ")", ";", "HtmlPage", "p", "=", "wc", ".", "login", "(", "\"", "alice", "\"", ")", ".", "goTo", "(", "\"", "computer/test/", "\"", ")", ";", "HudsonTestCase", ".", "WebClient", "jnlpAgent", "=", "new", "WebClient", "(", ")", ";", "XmlPage", "jnlp", "=", "(", "XmlPage", ")", "wc", ".", "goTo", "(", "\"", "computer/test/slave-agent.jnlp", "\"", ",", "\"", "application/x-java-jnlp-file", "\"", ")", ";", "URL", "baseUrl", "=", "jnlp", ".", "getWebResponse", "(", ")", ".", "getUrl", "(", ")", ";", "Document", "dom", "=", "new", "DOMReader", "(", ")", ".", "read", "(", "jnlp", ".", "getXmlDocument", "(", ")", ")", ";", "for", "(", "Element", "jar", ":", "(", "List", "<", "Element", ">", ")", "dom", ".", "selectNodes", "(", "\"", "//jar", "\"", ")", ")", "{", "URL", "url", "=", "new", "URL", "(", "baseUrl", ",", "jar", ".", "attributeValue", "(", "\"", "href", "\"", ")", ")", ";", "System", ".", "out", ".", "println", "(", "url", ")", ";", "Page", "jarResource", "=", "jnlpAgent", ".", "getPage", "(", "url", ")", ";", "assertTrue", "(", "jarResource", ".", "getWebResponse", "(", ")", ".", "getContentType", "(", ")", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ".", "startsWith", "(", "\"", "application/", "\"", ")", ")", ";", "}", "}"], "idx": 108129, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "a9aff088f327278a8873aef47fa8f80d3c5932fd", "function_name": "test", "body_hash": "bc43c4260865804e5e42c1d9ec2065fc4d524956"}
{"code": "@Override\n\tprotected void convertInput()\n\t{\n\t\tfinal PolicyFactory policy = this.newPolicyFactory();\n\t\tfinal String html = this.textarea.getConvertedInput();\n\n\t\tthis.setConvertedInput(policy.sanitize(html));\n\t}", "code_tokens": ["@", "Override", "protected", "void", "convertInput", "(", ")", "{", "final", "PolicyFactory", "policy", "=", "this", ".", "newPolicyFactory", "(", ")", ";", "final", "String", "html", "=", "this", ".", "textarea", ".", "getConvertedInput", "(", ")", ";", "this", ".", "setConvertedInput", "(", "policy", ".", "sanitize", "(", "html", ")", ")", ";", "}"], "idx": 81645, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "3e8cfdcb0f8e6e0cf0da01e74501afb5c9bff0f", "function_name": "convertInput", "body_hash": "43a6a642993cc832b2e41d97e233b3c6ce5b322c"}
{"code": "protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\"java.beans.EventHandler\", \"java.lang.ProcessBuilder\", \"javax.imageio.ImageIO$ContainsFilter\"});\n        denyTypesByRegExp(new Pattern[]{LAZY_ITERATORS, JAVAX_CRYPTO});\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }", "code_tokens": ["protected", "void", "setupSecurity", "(", ")", "{", "if", "(", "securityMapper", "==", "null", ")", "{", "return", ";", "}", "addPermission", "(", "AnyTypePermission", ".", "ANY", ")", ";", "denyTypes", "(", "new", "String", "[", "]", "{", "\"", "java.beans.EventHandler", "\"", ",", "\"", "java.lang.ProcessBuilder", "\"", ",", "\"", "javax.imageio.ImageIO$ContainsFilter", "\"", "}", ")", ";", "denyTypesByRegExp", "(", "new", "Pattern", "[", "]", "{", "LAZY_ITERATORS", ",", "JAVAX_CRYPTO", "}", ")", ";", "allowTypeHierarchy", "(", "Exception", ".", "class", ")", ";", "securityInitialized", "=", "false", ";", "}"], "idx": 77348, "cwe": "CWE-78", "target": 0, "status": "FIXED", "commit": "f8abc1ac909d26c69c752ba4a987b7f21c4dccd0", "function_name": "setupSecurity", "body_hash": "373417bd2ed30f80d10b88244b42aa172dcd96d8"}
{"code": "public XWikiRequest getRequest()\n    {\n        return new ScriptXWikiServletRequest(getXWikiContext().getRequest(), getContextualAuthorizationManager());\n    }", "code_tokens": ["public", "XWikiRequest", "getRequest", "(", ")", "{", "return", "new", "ScriptXWikiServletRequest", "(", "getXWikiContext", "(", ")", ".", "getRequest", "(", ")", ",", "getContextualAuthorizationManager", "(", ")", ")", ";", "}"], "idx": 73949, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "766e5e8480f", "function_name": "getRequest", "body_hash": "12ad8b871b25daca2421fa99a0c35cc871d4bb88"}
{"code": "public static void introspecthelper(Object bean, String prop,\n                                        String value, ServletRequest request,\n                                        String param, boolean ignoreMethodNF)\n                                        throws JasperException\n    {\n        if( Constants.IS_SECURITY_ENABLED ) {\n            try {\n                PrivilegedIntrospectHelper dp =\n                    new PrivilegedIntrospectHelper(\n                        bean,prop,value,request,param,ignoreMethodNF);\n                AccessController.doPrivileged(dp);\n            } catch( PrivilegedActionException pe) {\n                Exception e = pe.getException();\n                throw (JasperException)e;\n            }\n        } else {\n            internalIntrospecthelper(\n                bean,prop,value,request,param,ignoreMethodNF);\n        }\n    }", "code_tokens": ["public", "static", "void", "introspecthelper", "(", "Object", "bean", ",", "String", "prop", ",", "String", "value", ",", "ServletRequest", "request", ",", "String", "param", ",", "boolean", "ignoreMethodNF", ")", "throws", "JasperException", "{", "if", "(", "Constants", ".", "IS_SECURITY_ENABLED", ")", "{", "try", "{", "PrivilegedIntrospectHelper", "dp", "=", "new", "PrivilegedIntrospectHelper", "(", "bean", ",", "prop", ",", "value", ",", "request", ",", "param", ",", "ignoreMethodNF", ")", ";", "AccessController", ".", "doPrivileged", "(", "dp", ")", ";", "}", "catch", "(", "PrivilegedActionException", "pe", ")", "{", "Exception", "e", "=", "pe", ".", "getException", "(", ")", ";", "throw", "(", "JasperException", ")", "e", ";", "}", "}", "else", "{", "internalIntrospecthelper", "(", "bean", ",", "prop", ",", "value", ",", "request", ",", "param", ",", "ignoreMethodNF", ")", ";", "}", "}"], "idx": 99583, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "11950154730c3b2473580621df83356e09142e73", "function_name": "introspecthelper", "body_hash": "4e339d7a73558999f445703c55d2aefdd8f7ee98"}
{"code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }  \n        if (camelContext == null || !Boolean.parseBoolean(camelContext.getProperty(ACCESS_EXTERNAL_DTD))) {\n            try {\n                factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            } catch (SAXException e) {\n                LOG.error(e.getMessage(), e);\n                throw new IllegalStateException(e);\n            } \n        }\n        return factory;\n    }", "code_tokens": ["protected", "SchemaFactory", "createSchemaFactory", "(", ")", "{", "SchemaFactory", "factory", "=", "SchemaFactory", ".", "newInstance", "(", "schemaLanguage", ")", ";", "if", "(", "getResourceResolver", "(", ")", "!=", "null", ")", "{", "factory", ".", "setResourceResolver", "(", "getResourceResolver", "(", ")", ")", ";", "}", "if", "(", "camelContext", "==", "null", "||", "!", "Boolean", ".", "parseBoolean", "(", "camelContext", ".", "getProperty", "(", "ACCESS_EXTERNAL_DTD", ")", ")", ")", "{", "try", "{", "factory", ".", "setProperty", "(", "XMLConstants", ".", "ACCESS_EXTERNAL_DTD", ",", "\"", "\"", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "LOG", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}", "return", "factory", ";", "}"], "idx": 67119, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "99cbcd78b7e64083fae1d9552ead7425a90994b", "function_name": "createSchemaFactory", "body_hash": "ee862f70084f24436c95feb9cbc09e540eef9449"}
{"code": "@SuppressWarnings(\"unchecked\")\n    private Jwt<?, Claims> authenticateToken(final String token) throws AuthenticationException {\n        try {\n            Jwt<?, Claims> jwt = Jwts.parserBuilder().setSigningKey(validationKey).build().parseClaimsJws(token);\n\n            if (audienceClaim != null) {\n                Object object = jwt.getBody().get(audienceClaim);\n                if (object == null) {\n                    throw new JwtException(\"Found null Audience in token, for claimed field: \" + audienceClaim);\n                }\n\n                if (object instanceof List) {\n                    List<String> audiences = (List<String>) object;\n                    // audience not contains this broker, throw exception.\n                    if (!audiences.stream().anyMatch(audienceInToken -> audienceInToken.equals(audience))) {\n                        throw new AuthenticationException(\"Audiences in token: [\" + String.join(\", \", audiences)\n                                                          + \"] not contains this broker: \" + audience);\n                    }\n                } else if (object instanceof String) {\n                    if (!object.equals(audience)) {\n                        throw new AuthenticationException(\"Audiences in token: [\" + object\n                                                          + \"] not contains this broker: \" + audience);\n                    }\n                } else {\n                    // should not reach here.\n                    throw new AuthenticationException(\"Audiences in token is not in expected format: \" + object);\n                }\n            }\n\n            return jwt;\n        } catch (JwtException e) {\n            throw new AuthenticationException(\"Failed to authentication token: \" + e.getMessage());\n        }\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "private", "Jwt", "<", "?", ",", "Claims", ">", "authenticateToken", "(", "final", "String", "token", ")", "throws", "AuthenticationException", "{", "try", "{", "Jwt", "<", "?", ",", "Claims", ">", "jwt", "=", "Jwts", ".", "parserBuilder", "(", ")", ".", "setSigningKey", "(", "validationKey", ")", ".", "build", "(", ")", ".", "parseClaimsJws", "(", "token", ")", ";", "if", "(", "audienceClaim", "!=", "null", ")", "{", "Object", "object", "=", "jwt", ".", "getBody", "(", ")", ".", "get", "(", "audienceClaim", ")", ";", "if", "(", "object", "==", "null", ")", "{", "throw", "new", "JwtException", "(", "\"", "Found null Audience in token, for claimed field: ", "\"", "+", "audienceClaim", ")", ";", "}", "if", "(", "object", "instanceof", "List", ")", "{", "List", "<", "String", ">", "audiences", "=", "(", "List", "<", "String", ">", ")", "object", ";", "if", "(", "!", "audiences", ".", "stream", "(", ")", ".", "anyMatch", "(", "audienceInToken", "->", "audienceInToken", ".", "equals", "(", "audience", ")", ")", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Audiences in token: [", "\"", "+", "String", ".", "join", "(", "\"", ", ", "\"", ",", "audiences", ")", "+", "\"", "] not contains this broker: ", "\"", "+", "audience", ")", ";", "}", "}", "else", "if", "(", "object", "instanceof", "String", ")", "{", "if", "(", "!", "object", ".", "equals", "(", "audience", ")", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Audiences in token: [", "\"", "+", "object", "+", "\"", "] not contains this broker: ", "\"", "+", "audience", ")", ";", "}", "}", "else", "{", "throw", "new", "AuthenticationException", "(", "\"", "Audiences in token is not in expected format: ", "\"", "+", "object", ")", ";", "}", "}", "return", "jwt", ";", "}", "catch", "(", "JwtException", "e", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Failed to authentication token: ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}"], "idx": 43689, "cwe": "CWE-347", "target": 0, "status": "FIXED", "commit": "67e7e0cd231", "function_name": "authenticateToken", "body_hash": "81e356497e8ca684599be99ec30efe7ae47c25b6"}
{"code": "protected final String getWindowOpenJavaScript()\n\t{\n\t\tAppendingStringBuffer buffer = new AppendingStringBuffer(500);\n\n\t\tif (isCustomComponent() == true)\n\t\t{\n\t\t\tbuffer.append(\"var element = document.getElementById(\\\"\");\n\t\t\tbuffer.append(getContentMarkupId());\n\t\t\tbuffer.append(\"\\\");\\n\");\n\t\t}\n\n\t\tbuffer.append(\"var settings = new Object();\\n\");\n\n\t\tappendAssignment(buffer, \"settings.minWidth\", getMinimalWidth());\n\t\tappendAssignment(buffer, \"settings.minHeight\", getMinimalHeight());\n\t\tappendAssignment(buffer, \"settings.className\", getCssClassName());\n\t\tappendAssignment(buffer, \"settings.width\", getInitialWidth());\n\n\t\tif ((isUseInitialHeight() == true) || (isCustomComponent() == false))\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.height\", getInitialHeight());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.append(\"settings.height=null;\\n\");\n\t\t}\n\n\t\tappendAssignment(buffer, \"settings.resizable\", isResizable());\n\n\t\tif (isResizable() == false)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.widthUnit\", getWidthUnit());\n\t\t\tappendAssignment(buffer, \"settings.heightUnit\", getHeightUnit());\n\t\t}\n\n\t\tif (isCustomComponent() == false)\n\t\t{\n\t\t\tPage page = createPage();\n\t\t\tif (page == null)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\"Error creating page for modal dialog.\");\n\t\t\t}\n\t\t\tCharSequence pageUrl;\n\t\t\tRequestCycle requestCycle = RequestCycle.get();\n\n\t\t\tpage.getSession().getPageManager().touchPage(page);\n\t\t\tif (page.isPageStateless())\n\t\t\t{\n\t\t\t\tpageUrl = requestCycle.urlFor(page.getClass(), page.getPageParameters());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\n\t\t\t\tpageUrl = requestCycle.urlFor(handler);\n\t\t\t}\n\n\t\t\tappendAssignment(buffer, \"settings.src\", pageUrl);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.append(\"settings.element=element;\\n\");\n\t\t}\n\n\t\tif (getCookieName() != null)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.cookieId\", getCookieName());\n\t\t}\n\n\t\tString title = getTitle() != null ? getTitle().getObject() : null;\n\t\tif (title != null)\n\t\t{\n\t\t\tString escaped = getDefaultModelObjectAsString(title);\n\t\t\tappendAssignment(buffer, \"settings.title\", escaped);\n\t\t}\n\n\t\tif (getMaskType() == MaskType.TRANSPARENT)\n\t\t{\n\t\t\tbuffer.append(\"settings.mask=\\\"transparent\\\";\\n\");\n\t\t}\n\t\telse if (getMaskType() == MaskType.SEMI_TRANSPARENT)\n\t\t{\n\t\t\tbuffer.append(\"settings.mask=\\\"semi-transparent\\\";\\n\");\n\t\t}\n\n\t\tappendAssignment(buffer, \"settings.autoSize\", autoSize);\n\n\t\tappendAssignment(buffer, \"settings.unloadConfirmation\", showUnloadConfirmation());\n\n\t\t// set true if we set a windowclosedcallback\n\t\tboolean haveCloseCallback = false;\n\n\t\t// in case user is interested in window close callback or we have a pagemap to clean attach\n\t\t// notification request\n\t\tif (windowClosedCallback != null)\n\t\t{\n\t\t\tWindowClosedBehavior behavior = getBehaviors(WindowClosedBehavior.class).get(0);\n\t\t\tbuffer.append(\"settings.onClose = function() { \");\n\t\t\tbuffer.append(behavior.getCallbackScript());\n\t\t\tbuffer.append(\" };\\n\");\n\n\t\t\thaveCloseCallback = true;\n\t\t}\n\n\t\t// in case we didn't set windowclosecallback, we need at least callback on close button, to\n\t\t// close window property (thus cleaning the shown flag)\n\t\tif ((closeButtonCallback != null) || (haveCloseCallback == false))\n\t\t{\n\t\t\tCloseButtonBehavior behavior = getBehaviors(CloseButtonBehavior.class).get(0);\n\t\t\tbuffer.append(\"settings.onCloseButton = function() { \");\n\t\t\tbuffer.append(behavior.getCallbackScript());\n\t\t\tbuffer.append(\";return false;};\\n\");\n\t\t}\n\n\t\tpostProcessSettings(buffer);\n\n\t\tbuffer.append(getShowJavaScript());\n\t\treturn buffer.toString();\n\t}", "code_tokens": ["protected", "final", "String", "getWindowOpenJavaScript", "(", ")", "{", "AppendingStringBuffer", "buffer", "=", "new", "AppendingStringBuffer", "(", "500", ")", ";", "if", "(", "isCustomComponent", "(", ")", "==", "true", ")", "{", "buffer", ".", "append", "(", "\"", "var element = document.getElementById(", "\\\"", "\"", ")", ";", "buffer", ".", "append", "(", "getContentMarkupId", "(", ")", ")", ";", "buffer", ".", "append", "(", "\"", "\\\"", ");", "\\n", "\"", ")", ";", "}", "buffer", ".", "append", "(", "\"", "var settings = new Object();", "\\n", "\"", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.minWidth", "\"", ",", "getMinimalWidth", "(", ")", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.minHeight", "\"", ",", "getMinimalHeight", "(", ")", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.className", "\"", ",", "getCssClassName", "(", ")", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.width", "\"", ",", "getInitialWidth", "(", ")", ")", ";", "if", "(", "(", "isUseInitialHeight", "(", ")", "==", "true", ")", "||", "(", "isCustomComponent", "(", ")", "==", "false", ")", ")", "{", "appendAssignment", "(", "buffer", ",", "\"", "settings.height", "\"", ",", "getInitialHeight", "(", ")", ")", ";", "}", "else", "{", "buffer", ".", "append", "(", "\"", "settings.height=null;", "\\n", "\"", ")", ";", "}", "appendAssignment", "(", "buffer", ",", "\"", "settings.resizable", "\"", ",", "isResizable", "(", ")", ")", ";", "if", "(", "isResizable", "(", ")", "==", "false", ")", "{", "appendAssignment", "(", "buffer", ",", "\"", "settings.widthUnit", "\"", ",", "getWidthUnit", "(", ")", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.heightUnit", "\"", ",", "getHeightUnit", "(", ")", ")", ";", "}", "if", "(", "isCustomComponent", "(", ")", "==", "false", ")", "{", "Page", "page", "=", "createPage", "(", ")", ";", "if", "(", "page", "==", "null", ")", "{", "throw", "new", "WicketRuntimeException", "(", "\"", "Error creating page for modal dialog.", "\"", ")", ";", "}", "CharSequence", "pageUrl", ";", "RequestCycle", "requestCycle", "=", "RequestCycle", ".", "get", "(", ")", ";", "page", ".", "getSession", "(", ")", ".", "getPageManager", "(", ")", ".", "touchPage", "(", "page", ")", ";", "if", "(", "page", ".", "isPageStateless", "(", ")", ")", "{", "pageUrl", "=", "requestCycle", ".", "urlFor", "(", "page", ".", "getClass", "(", ")", ",", "page", ".", "getPageParameters", "(", ")", ")", ";", "}", "else", "{", "IRequestHandler", "handler", "=", "new", "RenderPageRequestHandler", "(", "new", "PageProvider", "(", "page", ")", ")", ";", "pageUrl", "=", "requestCycle", ".", "urlFor", "(", "handler", ")", ";", "}", "appendAssignment", "(", "buffer", ",", "\"", "settings.src", "\"", ",", "pageUrl", ")", ";", "}", "else", "{", "buffer", ".", "append", "(", "\"", "settings.element=element;", "\\n", "\"", ")", ";", "}", "if", "(", "getCookieName", "(", ")", "!=", "null", ")", "{", "appendAssignment", "(", "buffer", ",", "\"", "settings.cookieId", "\"", ",", "getCookieName", "(", ")", ")", ";", "}", "String", "title", "=", "getTitle", "(", ")", "!=", "null", "?", "getTitle", "(", ")", ".", "getObject", "(", ")", ":", "null", ";", "if", "(", "title", "!=", "null", ")", "{", "String", "escaped", "=", "getDefaultModelObjectAsString", "(", "title", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.title", "\"", ",", "escaped", ")", ";", "}", "if", "(", "getMaskType", "(", ")", "==", "MaskType", ".", "TRANSPARENT", ")", "{", "buffer", ".", "append", "(", "\"", "settings.mask=", "\\\"", "transparent", "\\\"", ";", "\\n", "\"", ")", ";", "}", "else", "if", "(", "getMaskType", "(", ")", "==", "MaskType", ".", "SEMI_TRANSPARENT", ")", "{", "buffer", ".", "append", "(", "\"", "settings.mask=", "\\\"", "semi-transparent", "\\\"", ";", "\\n", "\"", ")", ";", "}", "appendAssignment", "(", "buffer", ",", "\"", "settings.autoSize", "\"", ",", "autoSize", ")", ";", "appendAssignment", "(", "buffer", ",", "\"", "settings.unloadConfirmation", "\"", ",", "showUnloadConfirmation", "(", ")", ")", ";", "boolean", "haveCloseCallback", "=", "false", ";", "if", "(", "windowClosedCallback", "!=", "null", ")", "{", "WindowClosedBehavior", "behavior", "=", "getBehaviors", "(", "WindowClosedBehavior", ".", "class", ")", ".", "get", "(", "0", ")", ";", "buffer", ".", "append", "(", "\"", "settings.onClose = function() { ", "\"", ")", ";", "buffer", ".", "append", "(", "behavior", ".", "getCallbackScript", "(", ")", ")", ";", "buffer", ".", "append", "(", "\"", " };", "\\n", "\"", ")", ";", "haveCloseCallback", "=", "true", ";", "}", "if", "(", "(", "closeButtonCallback", "!=", "null", ")", "||", "(", "haveCloseCallback", "==", "false", ")", ")", "{", "CloseButtonBehavior", "behavior", "=", "getBehaviors", "(", "CloseButtonBehavior", ".", "class", ")", ".", "get", "(", "0", ")", ";", "buffer", ".", "append", "(", "\"", "settings.onCloseButton = function() { ", "\"", ")", ";", "buffer", ".", "append", "(", "behavior", ".", "getCallbackScript", "(", ")", ")", ";", "buffer", ".", "append", "(", "\"", ";return false;};", "\\n", "\"", ")", ";", "}", "postProcessSettings", "(", "buffer", ")", ";", "buffer", ".", "append", "(", "getShowJavaScript", "(", ")", ")", ";", "return", "buffer", ".", "toString", "(", ")", ";", "}"], "idx": 81550, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "dffba2ce410ec7e917ad350d3528af4df67bc348", "function_name": "getWindowOpenJavaScript", "body_hash": "51e2f4f3613b5e87e7be8155ff754fa76496d087"}
{"code": "private static Object deserialize(String serialized) throws ClassNotFoundException, IOException {\n        byte[] bytes = Base64.decode(serialized);\n        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n        ObjectInput in = null;\n        try {\n            in = new ObjectInputStream(bis);\n            return in.readObject();\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n        }\n    }", "code_tokens": ["private", "static", "Object", "deserialize", "(", "String", "serialized", ")", "throws", "ClassNotFoundException", ",", "IOException", "{", "byte", "[", "]", "bytes", "=", "Base64", ".", "decode", "(", "serialized", ")", ";", "ByteArrayInputStream", "bis", "=", "new", "ByteArrayInputStream", "(", "bytes", ")", ";", "ObjectInput", "in", "=", "null", ";", "try", "{", "in", "=", "new", "ObjectInputStream", "(", "bis", ")", ";", "return", "in", ".", "readObject", "(", ")", ";", "}", "finally", "{", "try", "{", "if", "(", "in", "!=", "null", ")", "{", "in", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "IOException", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "}", "}", "}"], "idx": 5770, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "33863ba161", "function_name": "deserialize", "body_hash": "0d609cfb8c6f72774f8ac3ad46fa6d43a5a01fcb"}
{"code": "protected void serveResource(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 boolean content,\n                                 String encoding)\n        throws IOException, ServletException {\n\n        boolean serveContent = content;\n\n        // Identify the requested resource path\n        String path = getRelativePath(request, true);\n\n        if (debug > 0) {\n            if (serveContent)\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers and data\");\n            else\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers only\");\n        }\n\n        if (path.length() == 0) {\n            // Context root redirect\n            doDirectoryRedirect(request, response);\n            return;\n        }\n\n        WebResource resource = resources.getResource(path);\n\n        if (!resource.exists()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // SRV.9.3 says we must throw a FNFE\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        if (!resource.canRead()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // Spec doesn't say what to do in this case but a FNFE seems\n                // reasonable\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestUri);\n            return;\n        }\n\n        // If the resource is not a collection, and the resource path\n        // ends with \"/\" or \"\\\", return NOT FOUND\n        if (resource.isFile() && (path.endsWith(\"/\") || path.endsWith(\"\\\\\"))) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            }\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        boolean isError = response.getStatus() >= HttpServletResponse.SC_BAD_REQUEST;\n\n        boolean included = false;\n        // Check if the conditions specified in the optional If headers are\n        // satisfied.\n        if (resource.isFile()) {\n            // Checking If headers\n            included = (request.getAttribute(\n                    RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\n            if (!included && !isError && !checkIfHeaders(request, response, resource)) {\n                return;\n            }\n        }\n\n        // Find content type.\n        String contentType = resource.getMimeType();\n        if (contentType == null) {\n            contentType = getServletContext().getMimeType(resource.getName());\n            resource.setMimeType(contentType);\n        }\n\n        // These need to reflect the original resource, not the potentially\n        // gzip'd version of the resource so get them now if they are going to\n        // be needed later\n        String eTag = null;\n        String lastModifiedHttp = null;\n        if (resource.isFile() && !isError) {\n            eTag = resource.getETag();\n            lastModifiedHttp = resource.getLastModifiedHttp();\n        }\n\n\n        // Serve a gzipped version of the file if present\n        boolean usingGzippedVersion = false;\n        if (gzip && !included && resource.isFile() && !path.endsWith(\".gz\")) {\n            WebResource gzipResource = resources.getResource(path + \".gz\");\n            if (gzipResource.exists() && gzipResource.isFile()) {\n                Collection<String> varyHeaders = response.getHeaders(\"Vary\");\n                boolean addRequired = true;\n                for (String varyHeader : varyHeaders) {\n                    if (\"*\".equals(varyHeader) ||\n                            \"accept-encoding\".equalsIgnoreCase(varyHeader)) {\n                        addRequired = false;\n                        break;\n                    }\n                }\n                if (addRequired) {\n                    response.addHeader(\"Vary\", \"accept-encoding\");\n                }\n                if (checkIfGzip(request)) {\n                    response.addHeader(\"Content-Encoding\", \"gzip\");\n                    resource = gzipResource;\n                    usingGzippedVersion = true;\n                }\n            }\n        }\n\n        ArrayList<Range> ranges = null;\n        long contentLength = -1L;\n\n        if (resource.isDirectory()) {\n            if (!path.endsWith(\"/\")) {\n                doDirectoryRedirect(request, response);\n                return;\n            }\n\n            // Skip directory listings if we have been configured to\n            // suppress them\n            if (!listings) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                   request.getRequestURI());\n                return;\n            }\n            contentType = \"text/html;charset=UTF-8\";\n        } else {\n            if (!isError) {\n                if (useAcceptRanges) {\n                    // Accept ranges header\n                    response.setHeader(\"Accept-Ranges\", \"bytes\");\n                }\n\n                // Parse range specifier\n                ranges = parseRange(request, response, resource);\n\n                // ETag header\n                response.setHeader(\"ETag\", eTag);\n\n                // Last-Modified header\n                response.setHeader(\"Last-Modified\", lastModifiedHttp);\n            }\n\n            // Get content length\n            contentLength = resource.getContentLength();\n            // Special case for zero length files, which would cause a\n            // (silent) ISE when setting the output buffer size\n            if (contentLength == 0L) {\n                serveContent = false;\n            }\n        }\n\n        ServletOutputStream ostream = null;\n        PrintWriter writer = null;\n\n        if (serveContent) {\n            // Trying to retrieve the servlet output stream\n            try {\n                ostream = response.getOutputStream();\n            } catch (IllegalStateException e) {\n                // If it fails, we try to get a Writer instead if we're\n                // trying to serve a text file\n                if (!usingGzippedVersion &&\n                        ((contentType == null) ||\n                                (contentType.startsWith(\"text\")) ||\n                                (contentType.endsWith(\"xml\")) ||\n                                (contentType.contains(\"/javascript\")))\n                        ) {\n                    writer = response.getWriter();\n                    // Cannot reliably serve partial content with a Writer\n                    ranges = FULL;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // Check to see if a Filter, Valve of wrapper has written some content.\n        // If it has, disable range requests and setting of a content length\n        // since neither can be done reliably.\n        ServletResponse r = response;\n        long contentWritten = 0;\n        while (r instanceof ServletResponseWrapper) {\n            r = ((ServletResponseWrapper) r).getResponse();\n        }\n        if (r instanceof ResponseFacade) {\n            contentWritten = ((ResponseFacade) r).getContentWritten();\n        }\n        if (contentWritten > 0) {\n            ranges = FULL;\n        }\n\n        if (resource.isDirectory() ||\n                isError ||\n                ( (ranges == null || ranges.isEmpty())\n                        && request.getHeader(\"Range\") == null ) ||\n                ranges == FULL ) {\n\n            // Set the appropriate output headers\n            if (contentType != null) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentType='\" +\n                        contentType + \"'\");\n                response.setContentType(contentType);\n            }\n            if (resource.isFile() && contentLength >= 0 &&\n                    (!serveContent || ostream != null)) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentLength=\" +\n                        contentLength);\n                // Don't set a content length if something else has already\n                // written to the response.\n                if (contentWritten == 0) {\n                    response.setContentLengthLong(contentLength);\n                }\n            }\n\n            if (serveContent) {\n                try {\n                    response.setBufferSize(output);\n                } catch (IllegalStateException e) {\n                    // Silent catch\n                }\n                InputStream renderResult = null;\n                if (ostream == null) {\n                    // Output via a writer so can't use sendfile or write\n                    // content directly.\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        renderResult = resource.getInputStream();\n                    }\n                    copy(resource, renderResult, writer, encoding);\n                } else {\n                    // Output is via an InputStream\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        // Output is content of resource\n                        if (!checkSendfile(request, response, resource,\n                                contentLength, null)) {\n                            // sendfile not possible so check if resource\n                            // content is available directly\n                            byte[] resourceBody = resource.getContent();\n                            if (resourceBody == null) {\n                                // Resource content not available, use\n                                // inputstream\n                                renderResult = resource.getInputStream();\n                            } else {\n                                // Use the resource content directly\n                                ostream.write(resourceBody);\n                            }\n                        }\n                    }\n                    // If a stream was configured, it needs to be copied to\n                    // the output (this method closes the stream)\n                    if (renderResult != null) {\n                        copy(resource, renderResult, ostream);\n                    }\n                }\n            }\n\n        } else {\n\n            if ((ranges == null) || (ranges.isEmpty()))\n                return;\n\n            // Partial content response.\n\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n            if (ranges.size() == 1) {\n\n                Range range = ranges.get(0);\n                response.addHeader(\"Content-Range\", \"bytes \"\n                                   + range.start\n                                   + \"-\" + range.end + \"/\"\n                                   + range.length);\n                long length = range.end - range.start + 1;\n                response.setContentLengthLong(length);\n\n                if (contentType != null) {\n                    if (debug > 0)\n                        log(\"DefaultServlet.serveFile:  contentType='\" +\n                            contentType + \"'\");\n                    response.setContentType(contentType);\n                }\n\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        if (!checkSendfile(request, response, resource,\n                                range.end - range.start + 1, range))\n                            copy(resource, ostream, range);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            } else {\n                response.setContentType(\"multipart/byteranges; boundary=\"\n                                        + mimeSeparation);\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        copy(resource, ostream, ranges.iterator(), contentType);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "serveResource", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "boolean", "content", ",", "String", "encoding", ")", "throws", "IOException", ",", "ServletException", "{", "boolean", "serveContent", "=", "content", ";", "String", "path", "=", "getRelativePath", "(", "request", ",", "true", ")", ";", "if", "(", "debug", ">", "0", ")", "{", "if", "(", "serveContent", ")", "log", "(", "\"", "DefaultServlet.serveResource:  Serving resource '", "\"", "+", "path", "+", "\"", "' headers and data", "\"", ")", ";", "else", "log", "(", "\"", "DefaultServlet.serveResource:  Serving resource '", "\"", "+", "path", "+", "\"", "' headers only", "\"", ")", ";", "}", "if", "(", "path", ".", "length", "(", ")", "==", "0", ")", "{", "doDirectoryRedirect", "(", "request", ",", "response", ")", ";", "return", ";", "}", "WebResource", "resource", "=", "resources", ".", "getResource", "(", "path", ")", ";", "if", "(", "!", "resource", ".", "exists", "(", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "else", "{", "throw", "new", "FileNotFoundException", "(", "sm", ".", "getString", "(", "\"", "defaultServlet.missingResource", "\"", ",", "requestUri", ")", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "requestUri", ")", ";", "return", ";", "}", "if", "(", "!", "resource", ".", "canRead", "(", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "else", "{", "throw", "new", "FileNotFoundException", "(", "sm", ".", "getString", "(", "\"", "defaultServlet.missingResource", "\"", ",", "requestUri", ")", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ",", "requestUri", ")", ";", "return", ";", "}", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "(", "path", ".", "endsWith", "(", "\"", "/", "\"", ")", "||", "path", ".", "endsWith", "(", "\"", "\\\\", "\"", ")", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "requestUri", ")", ";", "return", ";", "}", "boolean", "isError", "=", "response", ".", "getStatus", "(", ")", ">=", "HttpServletResponse", ".", "SC_BAD_REQUEST", ";", "boolean", "included", "=", "false", ";", "if", "(", "resource", ".", "isFile", "(", ")", ")", "{", "included", "=", "(", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_CONTEXT_PATH", ")", "!=", "null", ")", ";", "if", "(", "!", "included", "&&", "!", "isError", "&&", "!", "checkIfHeaders", "(", "request", ",", "response", ",", "resource", ")", ")", "{", "return", ";", "}", "}", "String", "contentType", "=", "resource", ".", "getMimeType", "(", ")", ";", "if", "(", "contentType", "==", "null", ")", "{", "contentType", "=", "getServletContext", "(", ")", ".", "getMimeType", "(", "resource", ".", "getName", "(", ")", ")", ";", "resource", ".", "setMimeType", "(", "contentType", ")", ";", "}", "String", "eTag", "=", "null", ";", "String", "lastModifiedHttp", "=", "null", ";", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "!", "isError", ")", "{", "eTag", "=", "resource", ".", "getETag", "(", ")", ";", "lastModifiedHttp", "=", "resource", ".", "getLastModifiedHttp", "(", ")", ";", "}", "boolean", "usingGzippedVersion", "=", "false", ";", "if", "(", "gzip", "&&", "!", "included", "&&", "resource", ".", "isFile", "(", ")", "&&", "!", "path", ".", "endsWith", "(", "\"", ".gz", "\"", ")", ")", "{", "WebResource", "gzipResource", "=", "resources", ".", "getResource", "(", "path", "+", "\"", ".gz", "\"", ")", ";", "if", "(", "gzipResource", ".", "exists", "(", ")", "&&", "gzipResource", ".", "isFile", "(", ")", ")", "{", "Collection", "<", "String", ">", "varyHeaders", "=", "response", ".", "getHeaders", "(", "\"", "Vary", "\"", ")", ";", "boolean", "addRequired", "=", "true", ";", "for", "(", "String", "varyHeader", ":", "varyHeaders", ")", "{", "if", "(", "\"", "*", "\"", ".", "equals", "(", "varyHeader", ")", "||", "\"", "accept-encoding", "\"", ".", "equalsIgnoreCase", "(", "varyHeader", ")", ")", "{", "addRequired", "=", "false", ";", "break", ";", "}", "}", "if", "(", "addRequired", ")", "{", "response", ".", "addHeader", "(", "\"", "Vary", "\"", ",", "\"", "accept-encoding", "\"", ")", ";", "}", "if", "(", "checkIfGzip", "(", "request", ")", ")", "{", "response", ".", "addHeader", "(", "\"", "Content-Encoding", "\"", ",", "\"", "gzip", "\"", ")", ";", "resource", "=", "gzipResource", ";", "usingGzippedVersion", "=", "true", ";", "}", "}", "}", "ArrayList", "<", "Range", ">", "ranges", "=", "null", ";", "long", "contentLength", "=", "-", "1L", ";", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "path", ".", "endsWith", "(", "\"", "/", "\"", ")", ")", "{", "doDirectoryRedirect", "(", "request", ",", "response", ")", ";", "return", ";", "}", "if", "(", "!", "listings", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "request", ".", "getRequestURI", "(", ")", ")", ";", "return", ";", "}", "contentType", "=", "\"", "text/html;charset=UTF-8", "\"", ";", "}", "else", "{", "if", "(", "!", "isError", ")", "{", "if", "(", "useAcceptRanges", ")", "{", "response", ".", "setHeader", "(", "\"", "Accept-Ranges", "\"", ",", "\"", "bytes", "\"", ")", ";", "}", "ranges", "=", "parseRange", "(", "request", ",", "response", ",", "resource", ")", ";", "response", ".", "setHeader", "(", "\"", "ETag", "\"", ",", "eTag", ")", ";", "response", ".", "setHeader", "(", "\"", "Last-Modified", "\"", ",", "lastModifiedHttp", ")", ";", "}", "contentLength", "=", "resource", ".", "getContentLength", "(", ")", ";", "if", "(", "contentLength", "==", "0L", ")", "{", "serveContent", "=", "false", ";", "}", "}", "ServletOutputStream", "ostream", "=", "null", ";", "PrintWriter", "writer", "=", "null", ";", "if", "(", "serveContent", ")", "{", "try", "{", "ostream", "=", "response", ".", "getOutputStream", "(", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "if", "(", "!", "usingGzippedVersion", "&&", "(", "(", "contentType", "==", "null", ")", "||", "(", "contentType", ".", "startsWith", "(", "\"", "text", "\"", ")", ")", "||", "(", "contentType", ".", "endsWith", "(", "\"", "xml", "\"", ")", ")", "||", "(", "contentType", ".", "contains", "(", "\"", "/javascript", "\"", ")", ")", ")", ")", "{", "writer", "=", "response", ".", "getWriter", "(", ")", ";", "ranges", "=", "FULL", ";", "}", "else", "{", "throw", "e", ";", "}", "}", "}", "ServletResponse", "r", "=", "response", ";", "long", "contentWritten", "=", "0", ";", "while", "(", "r", "instanceof", "ServletResponseWrapper", ")", "{", "r", "=", "(", "(", "ServletResponseWrapper", ")", "r", ")", ".", "getResponse", "(", ")", ";", "}", "if", "(", "r", "instanceof", "ResponseFacade", ")", "{", "contentWritten", "=", "(", "(", "ResponseFacade", ")", "r", ")", ".", "getContentWritten", "(", ")", ";", "}", "if", "(", "contentWritten", ">", "0", ")", "{", "ranges", "=", "FULL", ";", "}", "if", "(", "resource", ".", "isDirectory", "(", ")", "||", "isError", "||", "(", "(", "ranges", "==", "null", "||", "ranges", ".", "isEmpty", "(", ")", ")", "&&", "request", ".", "getHeader", "(", "\"", "Range", "\"", ")", "==", "null", ")", "||", "ranges", "==", "FULL", ")", "{", "if", "(", "contentType", "!=", "null", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentType='", "\"", "+", "contentType", "+", "\"", "'", "\"", ")", ";", "response", ".", "setContentType", "(", "contentType", ")", ";", "}", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "contentLength", ">=", "0", "&&", "(", "!", "serveContent", "||", "ostream", "!=", "null", ")", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentLength=", "\"", "+", "contentLength", ")", ";", "if", "(", "contentWritten", "==", "0", ")", "{", "response", ".", "setContentLengthLong", "(", "contentLength", ")", ";", "}", "}", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "InputStream", "renderResult", "=", "null", ";", "if", "(", "ostream", "==", "null", ")", "{", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "renderResult", "=", "render", "(", "getPathPrefix", "(", "request", ")", ",", "resource", ",", "encoding", ")", ";", "}", "else", "{", "renderResult", "=", "resource", ".", "getInputStream", "(", ")", ";", "}", "copy", "(", "resource", ",", "renderResult", ",", "writer", ",", "encoding", ")", ";", "}", "else", "{", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "renderResult", "=", "render", "(", "getPathPrefix", "(", "request", ")", ",", "resource", ",", "encoding", ")", ";", "}", "else", "{", "if", "(", "!", "checkSendfile", "(", "request", ",", "response", ",", "resource", ",", "contentLength", ",", "null", ")", ")", "{", "byte", "[", "]", "resourceBody", "=", "resource", ".", "getContent", "(", ")", ";", "if", "(", "resourceBody", "==", "null", ")", "{", "renderResult", "=", "resource", ".", "getInputStream", "(", ")", ";", "}", "else", "{", "ostream", ".", "write", "(", "resourceBody", ")", ";", "}", "}", "}", "if", "(", "renderResult", "!=", "null", ")", "{", "copy", "(", "resource", ",", "renderResult", ",", "ostream", ")", ";", "}", "}", "}", "}", "else", "{", "if", "(", "(", "ranges", "==", "null", ")", "||", "(", "ranges", ".", "isEmpty", "(", ")", ")", ")", "return", ";", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_PARTIAL_CONTENT", ")", ";", "if", "(", "ranges", ".", "size", "(", ")", "==", "1", ")", "{", "Range", "range", "=", "ranges", ".", "get", "(", "0", ")", ";", "response", ".", "addHeader", "(", "\"", "Content-Range", "\"", ",", "\"", "bytes ", "\"", "+", "range", ".", "start", "+", "\"", "-", "\"", "+", "range", ".", "end", "+", "\"", "/", "\"", "+", "range", ".", "length", ")", ";", "long", "length", "=", "range", ".", "end", "-", "range", ".", "start", "+", "1", ";", "response", ".", "setContentLengthLong", "(", "length", ")", ";", "if", "(", "contentType", "!=", "null", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentType='", "\"", "+", "contentType", "+", "\"", "'", "\"", ")", ";", "response", ".", "setContentType", "(", "contentType", ")", ";", "}", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "if", "(", "ostream", "!=", "null", ")", "{", "if", "(", "!", "checkSendfile", "(", "request", ",", "response", ",", "resource", ",", "range", ".", "end", "-", "range", ".", "start", "+", "1", ",", "range", ")", ")", "copy", "(", "resource", ",", "ostream", ",", "range", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "}", "}", "else", "{", "response", ".", "setContentType", "(", "\"", "multipart/byteranges; boundary=", "\"", "+", "mimeSeparation", ")", ";", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "if", "(", "ostream", "!=", "null", ")", "{", "copy", "(", "resource", ",", "ostream", ",", "ranges", ".", "iterator", "(", ")", ",", "contentType", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "}", "}", "}", "}"], "idx": 74752, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "e070a31ec81b56377822e44883c64abb41f36a3b", "function_name": "serveResource", "body_hash": "5f22c3dd3458dded17e9fb84a685b3d51b369612"}
{"code": "private void checkCancelOperationUsingUrl(Function<Queue.Item, String> urlProvider, boolean legacyRedirect) throws Exception {\n        Queue q = r.jenkins.getQueue();\n\n        r.jenkins.setCrumbIssuer(null);\n        r.jenkins.setSecurityRealm(r.createDummySecurityRealm());\n        r.jenkins.setAuthorizationStrategy(new MockAuthorizationStrategy()\n                .grant(Jenkins.READ, Item.READ, Item.CANCEL).everywhere().to(\"admin\")\n                .grant(Jenkins.READ).everywhere().to(\"user\")\n        );\n\n        // prevent execution to push stuff into the queue\n        r.jenkins.setNumExecutors(0);\n        assertThat(q.getItems().length, equalTo(0));\n\n        FreeStyleProject testProject = r.createFreeStyleProject(\"test\");\n        testProject.scheduleBuild(new UserIdCause());\n\n        Queue.Item[] items = q.getItems();\n        assertThat(items.length, equalTo(1));\n        Queue.Item currentOne = items[0];\n        assertFalse(currentOne.getFuture().isCancelled());\n\n        WebRequest request = new WebRequest(new URL(r.getURL() + urlProvider.apply(currentOne)), HttpMethod.POST);\n\n        { // user without right cannot cancel\n            JenkinsRule.WebClient wc = r.createWebClient()\n                    .withRedirectEnabled(false)\n                    .withThrowExceptionOnFailingStatusCode(false);\n            wc.login(\"user\");\n            if(legacyRedirect) {\n                Page p = wc.getPage(request);\n                // the legacy endpoint returns a redirection to the previously visited page, none in our case\n                // (so force no redirect to avoid false positive error)\n                // see JENKINS-21311\n                assertThat(p.getWebResponse().getStatusCode(), lessThan(400));\n            }\n            assertFalse(currentOne.getFuture().isCancelled());\n        }\n        { // user with right can\n            JenkinsRule.WebClient wc = r.createWebClient()\n                    .withRedirectEnabled(false)\n                    .withThrowExceptionOnFailingStatusCode(false);\n            wc.login(\"admin\");\n            Page p = wc.getPage(request);\n            assertThat(p.getWebResponse().getStatusCode(), lessThan(400));\n\n            assertTrue(currentOne.getFuture().isCancelled());\n        }\n    }", "code_tokens": ["private", "void", "checkCancelOperationUsingUrl", "(", "Function", "<", "Queue", ".", "Item", ",", "String", ">", "urlProvider", ",", "boolean", "legacyRedirect", ")", "throws", "Exception", "{", "Queue", "q", "=", "r", ".", "jenkins", ".", "getQueue", "(", ")", ";", "r", ".", "jenkins", ".", "setCrumbIssuer", "(", "null", ")", ";", "r", ".", "jenkins", ".", "setSecurityRealm", "(", "r", ".", "createDummySecurityRealm", "(", ")", ")", ";", "r", ".", "jenkins", ".", "setAuthorizationStrategy", "(", "new", "MockAuthorizationStrategy", "(", ")", ".", "grant", "(", "Jenkins", ".", "READ", ",", "Item", ".", "READ", ",", "Item", ".", "CANCEL", ")", ".", "everywhere", "(", ")", ".", "to", "(", "\"", "admin", "\"", ")", ".", "grant", "(", "Jenkins", ".", "READ", ")", ".", "everywhere", "(", ")", ".", "to", "(", "\"", "user", "\"", ")", ")", ";", "r", ".", "jenkins", ".", "setNumExecutors", "(", "0", ")", ";", "assertThat", "(", "q", ".", "getItems", "(", ")", ".", "length", ",", "equalTo", "(", "0", ")", ")", ";", "FreeStyleProject", "testProject", "=", "r", ".", "createFreeStyleProject", "(", "\"", "test", "\"", ")", ";", "testProject", ".", "scheduleBuild", "(", "new", "UserIdCause", "(", ")", ")", ";", "Queue", ".", "Item", "[", "]", "items", "=", "q", ".", "getItems", "(", ")", ";", "assertThat", "(", "items", ".", "length", ",", "equalTo", "(", "1", ")", ")", ";", "Queue", ".", "Item", "currentOne", "=", "items", "[", "0", "]", ";", "assertFalse", "(", "currentOne", ".", "getFuture", "(", ")", ".", "isCancelled", "(", ")", ")", ";", "WebRequest", "request", "=", "new", "WebRequest", "(", "new", "URL", "(", "r", ".", "getURL", "(", ")", "+", "urlProvider", ".", "apply", "(", "currentOne", ")", ")", ",", "HttpMethod", ".", "POST", ")", ";", "{", "JenkinsRule", ".", "WebClient", "wc", "=", "r", ".", "createWebClient", "(", ")", ".", "withRedirectEnabled", "(", "false", ")", ".", "withThrowExceptionOnFailingStatusCode", "(", "false", ")", ";", "wc", ".", "login", "(", "\"", "user", "\"", ")", ";", "if", "(", "legacyRedirect", ")", "{", "Page", "p", "=", "wc", ".", "getPage", "(", "request", ")", ";", "assertThat", "(", "p", ".", "getWebResponse", "(", ")", ".", "getStatusCode", "(", ")", ",", "lessThan", "(", "400", ")", ")", ";", "}", "assertFalse", "(", "currentOne", ".", "getFuture", "(", ")", ".", "isCancelled", "(", ")", ")", ";", "}", "{", "JenkinsRule", ".", "WebClient", "wc", "=", "r", ".", "createWebClient", "(", ")", ".", "withRedirectEnabled", "(", "false", ")", ".", "withThrowExceptionOnFailingStatusCode", "(", "false", ")", ";", "wc", ".", "login", "(", "\"", "admin", "\"", ")", ";", "Page", "p", "=", "wc", ".", "getPage", "(", "request", ")", ";", "assertThat", "(", "p", ".", "getWebResponse", "(", ")", ".", "getStatusCode", "(", ")", ",", "lessThan", "(", "400", ")", ")", ";", "assertTrue", "(", "currentOne", ".", "getFuture", "(", ")", ".", "isCancelled", "(", ")", ")", ";", "}", "}"], "idx": 50607, "cwe": "CWE-384", "target": 0, "status": "FIXED", "commit": "86b7d7e789586575522650c60d591605facb1d70", "function_name": "checkCancelOperationUsingUrl", "body_hash": "b77dda685ae50bcf03550dc990ff8910f547349b"}
{"code": "public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        contextPath = normalize(decodeRequestString(request, contextPath));\n        if (\"/\".equals(contextPath)) {\n            // the normalize method will return a \"/\" and includes on Jetty, will also be a \"/\".\n            contextPath = \"\";\n        }\n        return contextPath;\n    }", "code_tokens": ["public", "static", "String", "getContextPath", "(", "HttpServletRequest", "request", ")", "{", "String", "contextPath", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "INCLUDE_CONTEXT_PATH_ATTRIBUTE", ")", ";", "if", "(", "contextPath", "==", "null", ")", "{", "contextPath", "=", "request", ".", "getContextPath", "(", ")", ";", "}", "contextPath", "=", "normalize", "(", "decodeRequestString", "(", "request", ",", "contextPath", ")", ")", ";", "if", "(", "\"", "/", "\"", ".", "equals", "(", "contextPath", ")", ")", "{", "contextPath", "=", "\"", "\"", ";", "}", "return", "contextPath", ";", "}"], "idx": 38197, "cwe": "CWE-284", "target": 0, "status": "FIXED", "commit": "b15ab927709ca18ea4a02538be01919a19ab65af", "function_name": "getContextPath", "body_hash": "43d238c53c2c2a09e5c7ca1e24dde142ab04582a"}
{"code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,\n            ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpReq = (HttpServletRequest) request;\n            HttpServletResponse httpResp = (HttpServletResponse) response;\n\n            if (\"GET\".equals(httpReq.getMethod())) {\n                Meteor meteor = Meteor.build(httpReq, SCOPE.REQUEST, Collections.<BroadcastFilter>emptyList(), null);\n\n                String pushSessionId = httpReq.getParameter(PUSH_SESSION_ID_PARAM);\n\n                Session session = null;\n\n                if (pushSessionId != null) {\n                    ensureServletContextAvailable(request);\n                    PushContext pushContext = (PushContext) servletContext.getAttribute(PushContext.INSTANCE_KEY_NAME);\n                    session = pushContext.getSessionManager().getPushSession(pushSessionId);\n                }\n\n                if (session == null) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(MessageFormat.format(\"Session {0} was not found\", pushSessionId));\n                    }\n                    httpResp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n\n                httpResp.setContentType(\"text/plain\");\n\n                try {\n                    Request pushRequest = new RequestImpl(meteor, session);\n\n                    httpReq.setAttribute(SESSION_ATTRIBUTE_NAME, session);\n                    httpReq.setAttribute(REQUEST_ATTRIBUTE_NAME, pushRequest);\n\n                    pushRequest.suspend();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n\n                return;\n            }\n        }\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "request", "instanceof", "HttpServletRequest", "&&", "response", "instanceof", "HttpServletResponse", ")", "{", "HttpServletRequest", "httpReq", "=", "(", "HttpServletRequest", ")", "request", ";", "HttpServletResponse", "httpResp", "=", "(", "HttpServletResponse", ")", "response", ";", "if", "(", "\"", "GET", "\"", ".", "equals", "(", "httpReq", ".", "getMethod", "(", ")", ")", ")", "{", "Meteor", "meteor", "=", "Meteor", ".", "build", "(", "httpReq", ",", "SCOPE", ".", "REQUEST", ",", "Collections", ".", "<", "BroadcastFilter", ">", "emptyList", "(", ")", ",", "null", ")", ";", "String", "pushSessionId", "=", "httpReq", ".", "getParameter", "(", "PUSH_SESSION_ID_PARAM", ")", ";", "Session", "session", "=", "null", ";", "if", "(", "pushSessionId", "!=", "null", ")", "{", "ensureServletContextAvailable", "(", "request", ")", ";", "PushContext", "pushContext", "=", "(", "PushContext", ")", "servletContext", ".", "getAttribute", "(", "PushContext", ".", "INSTANCE_KEY_NAME", ")", ";", "session", "=", "pushContext", ".", "getSessionManager", "(", ")", ".", "getPushSession", "(", "pushSessionId", ")", ";", "}", "if", "(", "session", "==", "null", ")", "{", "if", "(", "LOGGER", ".", "isDebugEnabled", "(", ")", ")", "{", "LOGGER", ".", "debug", "(", "MessageFormat", ".", "format", "(", "\"", "Session {0} was not found", "\"", ",", "pushSessionId", ")", ")", ";", "}", "httpResp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "httpResp", ".", "setContentType", "(", "\"", "text/plain", "\"", ")", ";", "try", "{", "Request", "pushRequest", "=", "new", "RequestImpl", "(", "meteor", ",", "session", ")", ";", "httpReq", ".", "setAttribute", "(", "SESSION_ATTRIBUTE_NAME", ",", "session", ")", ";", "httpReq", ".", "setAttribute", "(", "REQUEST_ATTRIBUTE_NAME", ",", "pushRequest", ")", ";", "pushRequest", ".", "suspend", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOGGER", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "return", ";", "}", "}", "}"], "idx": 7825, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "8131f15003f5bec73d475d2b724472e4b87d0757", "function_name": "doFilter", "body_hash": "7267226df60e1c241fe36647b1c71ac82fbfbf72"}
{"code": "private static void languages( Connection c, Statement s)\n\tthrows SQLException\n\t{\n\t\tSavepoint p = null;\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE TRUSTED LANGUAGE java HANDLER sqlj.java_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE java IS '\" +\n\t\t\t\t\"Trusted/sandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\ts.execute(\"REVOKE USAGE ON LANGUAGE java FROM PUBLIC\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE LANGUAGE javaU HANDLER sqlj.javau_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE javau IS '\" +\n\t\t\t\t\"Untrusted/unsandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\t}", "code_tokens": ["private", "static", "void", "languages", "(", "Connection", "c", ",", "Statement", "s", ")", "throws", "SQLException", "{", "Savepoint", "p", "=", "null", ";", "try", "{", "p", "=", "c", ".", "setSavepoint", "(", ")", ";", "s", ".", "execute", "(", "\"", "CREATE TRUSTED LANGUAGE java HANDLER sqlj.java_call_handler", "\"", ")", ";", "s", ".", "execute", "(", "\"", "COMMENT ON LANGUAGE java IS '", "\"", "+", "\"", "Trusted/sandboxed language for routines and types in ", "\"", "+", "\"", "Java; http://tada.github.io/pljava/'", "\"", ")", ";", "s", ".", "execute", "(", "\"", "REVOKE USAGE ON LANGUAGE java FROM PUBLIC", "\"", ")", ";", "c", ".", "releaseSavepoint", "(", "p", ")", ";", "}", "catch", "(", "SQLException", "sqle", ")", "{", "c", ".", "rollback", "(", "p", ")", ";", "if", "(", "!", "\"", "42710", "\"", ".", "equals", "(", "sqle", ".", "getSQLState", "(", ")", ")", ")", "throw", "sqle", ";", "}", "try", "{", "p", "=", "c", ".", "setSavepoint", "(", ")", ";", "s", ".", "execute", "(", "\"", "CREATE LANGUAGE javaU HANDLER sqlj.javau_call_handler", "\"", ")", ";", "s", ".", "execute", "(", "\"", "COMMENT ON LANGUAGE javau IS '", "\"", "+", "\"", "Untrusted/unsandboxed language for routines and types in ", "\"", "+", "\"", "Java; http://tada.github.io/pljava/'", "\"", ")", ";", "c", ".", "releaseSavepoint", "(", "p", ")", ";", "}", "catch", "(", "SQLException", "sqle", ")", "{", "c", ".", "rollback", "(", "p", ")", ";", "if", "(", "!", "\"", "42710", "\"", ".", "equals", "(", "sqle", ".", "getSQLState", "(", ")", ")", ")", "throw", "sqle", ";", "}", "}"], "idx": 37895, "cwe": "CWE-284", "target": 0, "status": "FIXED", "commit": "675254b0f17b76f05e72cba2e3b8d3e548ae7a43", "function_name": "languages", "body_hash": "f1a040b6b0f62491f08157b9b1cd306c89fd5e98"}
{"code": "public void testCookiesWithClassPollution() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        String pollution1 = \"model['class']['classLoader']['jarPath']\";\n        String pollution2 = \"model.class.classLoader.jarPath\";\n        String pollution3 = \"class.classLoader.jarPath\";\n        String pollution4 = \"class['classLoader']['jarPath']\";\n        String pollution5 = \"model[\\\"class\\\"]['classLoader']['jarPath']\";\n        String pollution6 = \"class[\\\"classLoader\\\"]['jarPath']\";\n\n        request.setCookies(\n                new Cookie(pollution1, \"pollution1\"),\n                new Cookie(\"pollution1\", pollution1),\n                new Cookie(pollution2, \"pollution2\"),\n                new Cookie(\"pollution2\", pollution2),\n                new Cookie(pollution3, \"pollution3\"),\n                new Cookie(\"pollution3\", pollution3),\n                new Cookie(pollution4, \"pollution4\"),\n                new Cookie(\"pollution4\", pollution4),\n                new Cookie(pollution5, \"pollution5\"),\n                new Cookie(\"pollution5\", pollution5),\n                new Cookie(pollution6, \"pollution6\"),\n                new Cookie(\"pollution6\", pollution6)\n            );\n        ServletActionContext.setRequest(request);\n\n        final Map<String, Boolean> excludedName = new HashMap<String, Boolean>();\n        final Map<String, Boolean> excludedValue = new HashMap<String, Boolean>();\n\n        CookieInterceptor interceptor = new CookieInterceptor() {\n            @Override\n            protected boolean isAcceptableName(String name) {\n                boolean accepted = super.isAcceptableName(name);\n                excludedName.put(name, accepted);\n                return accepted;\n            }\n\n            @Override\n            protected boolean isAcceptableValue(String value) {\n                boolean accepted = super.isAcceptableValue(value);\n                excludedValue.put(value, accepted);\n                return accepted;\n            }\n        };\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"*\");\n\n        MockActionInvocation invocation = new MockActionInvocation();\n        invocation.setAction(new MockActionWithCookieAware());\n\n        interceptor.intercept(invocation);\n\n        assertFalse(excludedName.get(pollution1));\n        assertFalse(excludedName.get(pollution2));\n        assertFalse(excludedName.get(pollution3));\n        assertFalse(excludedName.get(pollution4));\n        assertFalse(excludedName.get(pollution5));\n        assertFalse(excludedName.get(pollution6));\n\n        assertFalse(excludedValue.get(pollution1));\n        assertFalse(excludedValue.get(pollution2));\n        assertFalse(excludedValue.get(pollution3));\n        assertFalse(excludedValue.get(pollution4));\n        assertFalse(excludedValue.get(pollution5));\n        assertFalse(excludedValue.get(pollution6));\n    }", "code_tokens": ["public", "void", "testCookiesWithClassPollution", "(", ")", "throws", "Exception", "{", "MockHttpServletRequest", "request", "=", "new", "MockHttpServletRequest", "(", ")", ";", "String", "pollution1", "=", "\"", "model['class']['classLoader']['jarPath']", "\"", ";", "String", "pollution2", "=", "\"", "model.class.classLoader.jarPath", "\"", ";", "String", "pollution3", "=", "\"", "class.classLoader.jarPath", "\"", ";", "String", "pollution4", "=", "\"", "class['classLoader']['jarPath']", "\"", ";", "String", "pollution5", "=", "\"", "model[", "\\\"", "class", "\\\"", "]['classLoader']['jarPath']", "\"", ";", "String", "pollution6", "=", "\"", "class[", "\\\"", "classLoader", "\\\"", "]['jarPath']", "\"", ";", "request", ".", "setCookies", "(", "new", "Cookie", "(", "pollution1", ",", "\"", "pollution1", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution1", "\"", ",", "pollution1", ")", ",", "new", "Cookie", "(", "pollution2", ",", "\"", "pollution2", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution2", "\"", ",", "pollution2", ")", ",", "new", "Cookie", "(", "pollution3", ",", "\"", "pollution3", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution3", "\"", ",", "pollution3", ")", ",", "new", "Cookie", "(", "pollution4", ",", "\"", "pollution4", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution4", "\"", ",", "pollution4", ")", ",", "new", "Cookie", "(", "pollution5", ",", "\"", "pollution5", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution5", "\"", ",", "pollution5", ")", ",", "new", "Cookie", "(", "pollution6", ",", "\"", "pollution6", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution6", "\"", ",", "pollution6", ")", ")", ";", "ServletActionContext", ".", "setRequest", "(", "request", ")", ";", "final", "Map", "<", "String", ",", "Boolean", ">", "excludedName", "=", "new", "HashMap", "<", "String", ",", "Boolean", ">", "(", ")", ";", "final", "Map", "<", "String", ",", "Boolean", ">", "excludedValue", "=", "new", "HashMap", "<", "String", ",", "Boolean", ">", "(", ")", ";", "CookieInterceptor", "interceptor", "=", "new", "CookieInterceptor", "(", ")", "{", "@", "Override", "protected", "boolean", "isAcceptableName", "(", "String", "name", ")", "{", "boolean", "accepted", "=", "super", ".", "isAcceptableName", "(", "name", ")", ";", "excludedName", ".", "put", "(", "name", ",", "accepted", ")", ";", "return", "accepted", ";", "}", "@", "Override", "protected", "boolean", "isAcceptableValue", "(", "String", "value", ")", "{", "boolean", "accepted", "=", "super", ".", "isAcceptableValue", "(", "value", ")", ";", "excludedValue", ".", "put", "(", "value", ",", "accepted", ")", ";", "return", "accepted", ";", "}", "}", ";", "interceptor", ".", "setExcludedPatternsChecker", "(", "new", "DefaultExcludedPatternsChecker", "(", ")", ")", ";", "interceptor", ".", "setCookiesName", "(", "\"", "*", "\"", ")", ";", "MockActionInvocation", "invocation", "=", "new", "MockActionInvocation", "(", ")", ";", "invocation", ".", "setAction", "(", "new", "MockActionWithCookieAware", "(", ")", ")", ";", "interceptor", ".", "intercept", "(", "invocation", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution1", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution2", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution3", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution4", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution5", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution6", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution1", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution2", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution3", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution4", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution5", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution6", ")", ")", ";", "}"], "idx": 99433, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "d832747d647df343ed07a58b1b5e540a05a4d51b", "function_name": "testCookiesWithClassPollution", "body_hash": "e217c37cde03f04754c42ee3f4145a0d0aeaecb3"}
{"code": "private Document createDocFromMessage(InputStream message)\n            throws SAXException, IOException, ParserConfigurationException {\n        DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();\n        //Disabling DTDs in order to avoid XXE xml-based attacks.\n        disableFeature(dbfactory, DISALLOW_DTD_FEATURE);\n        disableFeature(dbfactory, DISALLOW_EXTERNAL_DTD);\n        dbfactory.setXIncludeAware(false);\n        dbfactory.setExpandEntityReferences(false);\n        DocumentBuilder builder = dbfactory.newDocumentBuilder();\n        return builder.parse(new InputSource(message));\n    }", "code_tokens": ["private", "Document", "createDocFromMessage", "(", "InputStream", "message", ")", "throws", "SAXException", ",", "IOException", ",", "ParserConfigurationException", "{", "DocumentBuilderFactory", "dbfactory", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "disableFeature", "(", "dbfactory", ",", "DISALLOW_DTD_FEATURE", ")", ";", "disableFeature", "(", "dbfactory", ",", "DISALLOW_EXTERNAL_DTD", ")", ";", "dbfactory", ".", "setXIncludeAware", "(", "false", ")", ";", "dbfactory", ".", "setExpandEntityReferences", "(", "false", ")", ";", "DocumentBuilder", "builder", "=", "dbfactory", ".", "newDocumentBuilder", "(", ")", ";", "return", "builder", ".", "parse", "(", "new", "InputSource", "(", "message", ")", ")", ";", "}"], "idx": 68629, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "d59f36ce062b31be67221f6b668abaeb54011d49", "function_name": "createDocFromMessage", "body_hash": "1491bf2d04968fffac5abbcb09e9ff9180f5581b"}
{"code": "@RequirePOST\n        public FormValidation doCheckRepoUrl(@QueryParameter(fixEmpty = true) String value, @AncestorInPath AbstractProject project) throws IOException,\n                ServletException {\n\n            // Connect to URL and check content only if we have admin permission\n            if (!Jenkins.get().hasPermission(Jenkins.ADMINISTER))\n                return FormValidation.ok();\n\n            if (value == null) // nothing entered yet\n                value = \"origin\";\n\n            if (!value.contains(\"/\") && project != null) {\n                GitSCM scm = (GitSCM) project.getScm();\n                RemoteConfig remote = scm.getRepositoryByName(value);\n                if (remote == null)\n                    return FormValidation.errorWithMarkup(\"There is no remote with the name <code>\" + value + \"</code>\");\n                \n                value = remote.getURIs().get(0).toString();\n            }\n            \n            if (!value.endsWith(\"/\"))\n                value += '/';\n            if (!URL_PATTERN.matcher(value).matches())\n                return FormValidation.errorWithMarkup(\"The URL should end like <code>.../_git/foobar/</code>\");\n\n            final String finalValue = value;\n            return new FormValidation.URLCheck() {\n                @Override\n                protected FormValidation check() throws IOException, ServletException {\n                    try {\n                        if (findText(open(new URL(finalValue)), REPOSITORY_BROWSER_LABEL)) {\n                            return FormValidation.ok();\n                        } else {\n                            return FormValidation.error(\"This is a valid URL but it doesn't look like Microsoft TFS 2013\");\n                        }\n                    } catch (IOException e) {\n                        return handleIOException(finalValue, e);\n                    }\n                }\n            }.check();\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doCheckRepoUrl", "(", "@", "QueryParameter", "(", "fixEmpty", "=", "true", ")", "String", "value", ",", "@", "AncestorInPath", "AbstractProject", "project", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "!", "Jenkins", ".", "get", "(", ")", ".", "hasPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ")", "return", "FormValidation", ".", "ok", "(", ")", ";", "if", "(", "value", "==", "null", ")", "value", "=", "\"", "origin", "\"", ";", "if", "(", "!", "value", ".", "contains", "(", "\"", "/", "\"", ")", "&&", "project", "!=", "null", ")", "{", "GitSCM", "scm", "=", "(", "GitSCM", ")", "project", ".", "getScm", "(", ")", ";", "RemoteConfig", "remote", "=", "scm", ".", "getRepositoryByName", "(", "value", ")", ";", "if", "(", "remote", "==", "null", ")", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "There is no remote with the name <code>", "\"", "+", "value", "+", "\"", "</code>", "\"", ")", ";", "value", "=", "remote", ".", "getURIs", "(", ")", ".", "get", "(", "0", ")", ".", "toString", "(", ")", ";", "}", "if", "(", "!", "value", ".", "endsWith", "(", "\"", "/", "\"", ")", ")", "value", "+=", "'/'", ";", "if", "(", "!", "URL_PATTERN", ".", "matcher", "(", "value", ")", ".", "matches", "(", ")", ")", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "The URL should end like <code>.../_git/foobar/</code>", "\"", ")", ";", "final", "String", "finalValue", "=", "value", ";", "return", "new", "FormValidation", ".", "URLCheck", "(", ")", "{", "@", "Override", "protected", "FormValidation", "check", "(", ")", "throws", "IOException", ",", "ServletException", "{", "try", "{", "if", "(", "findText", "(", "open", "(", "new", "URL", "(", "finalValue", ")", ")", ",", "REPOSITORY_BROWSER_LABEL", ")", ")", "{", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "else", "{", "return", "FormValidation", ".", "error", "(", "\"", "This is a valid URL but it doesn't look like Microsoft TFS 2013", "\"", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "return", "handleIOException", "(", "finalValue", ",", "e", ")", ";", "}", "}", "}", ".", "check", "(", ")", ";", "}"], "idx": 81303, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "f581998b", "function_name": "doCheckRepoUrl", "body_hash": "5f524021cf23c24630f66dacc85a8318e405e22f"}
{"code": "public void handleMessage(Message message) {\n        if (isGET(message) && message.getContent(List.class) != null) {\n            LOG.fine(\"DocLiteralInInterceptor skipped in HTTP GET method\");\n            return;\n        }\n\n        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n        DataReader<XMLStreamReader> dr = getDataReader(message);\n        MessageContentsList parameters = new MessageContentsList();\n\n        Exchange exchange = message.getExchange();\n        BindingOperationInfo bop = exchange.getBindingOperationInfo();\n\n        boolean client = isRequestor(message);\n\n        //if body is empty and we have BindingOperationInfo, we do not need to match \n        //operation anymore, just return\n        if (bop != null && !StaxUtils.toNextElement(xmlReader)) {\n            // body may be empty for partial response to decoupled request\n            return;\n        }\n\n        //bop might be a unwrapped, wrap it back so that we can get correct info \n        if (bop != null && bop.isUnwrapped()) {\n            bop = bop.getWrappedOperation();\n        }\n\n        if (bop == null) {\n            QName startQName = xmlReader == null \n                ? new QName(\"http://cxf.apache.org/jaxws/provider\", \"invoke\")\n                : xmlReader.getName();\n            bop = getBindingOperationInfo(exchange, startQName, client);\n        }\n\n        try {\n            if (bop != null && bop.isUnwrappedCapable()) {\n                ServiceInfo si = bop.getBinding().getService();\n                // Wrapped case\n                MessageInfo msgInfo = setMessage(message, bop, client, si);\n    \n                // Determine if we should keep the parameters wrapper\n                if (shouldWrapParameters(msgInfo, message)) {\n                    QName startQName = xmlReader.getName();\n                    if (!msgInfo.getMessageParts().get(0).getConcreteName().equals(startQName)) {\n                        throw new Fault(\"UNEXPECTED_WRAPPER_ELEMENT\", LOG, null, startQName,\n                                        msgInfo.getMessageParts().get(0).getConcreteName());\n                    }\n                    Object wrappedObject = dr.read(msgInfo.getMessageParts().get(0), xmlReader);\n                    parameters.put(msgInfo.getMessageParts().get(0), wrappedObject);\n                } else {\n                    // Unwrap each part individually if we don't have a wrapper\n    \n                    bop = bop.getUnwrappedOperation();\n    \n                    msgInfo = setMessage(message, bop, client, si);\n                    List<MessagePartInfo> messageParts = msgInfo.getMessageParts();\n                    Iterator<MessagePartInfo> itr = messageParts.iterator();\n    \n                    // advance just past the wrapped element so we don't get\n                    // stuck\n                    if (xmlReader.getEventType() == XMLStreamConstants.START_ELEMENT) {\n                        StaxUtils.nextEvent(xmlReader);\n                    }\n    \n                    // loop through each child element\n                    getPara(xmlReader, dr, parameters, itr, message);\n                }\n    \n            } else {\n                //Bare style\n                BindingMessageInfo msgInfo = null;\n\n    \n                Endpoint ep = exchange.get(Endpoint.class);\n                ServiceInfo si = ep.getEndpointInfo().getService();\n                if (bop != null) { //for xml binding or client side\n                    if (client) {\n                        msgInfo = bop.getOutput();\n                    } else {\n                        msgInfo = bop.getInput();\n                        if (bop.getOutput() == null) {\n                            exchange.setOneWay(true);\n                        }\n                    }\n                    if (msgInfo == null) {\n                        return;\n                    }\n                    setMessage(message, bop, client, si, msgInfo.getMessageInfo());\n                }\n    \n                Collection<OperationInfo> operations = null;\n                operations = new ArrayList<OperationInfo>();\n                operations.addAll(si.getInterface().getOperations());\n    \n                if (xmlReader == null || !StaxUtils.toNextElement(xmlReader)) {\n                    // empty input\n    \n                    // TO DO : check duplicate operation with no input\n                    for (OperationInfo op : operations) {\n                        MessageInfo bmsg = op.getInput();\n                        if (bmsg.getMessageParts().size() == 0) {\n                            BindingOperationInfo boi = ep.getEndpointInfo().getBinding().getOperation(op);\n                            exchange.put(BindingOperationInfo.class, boi);\n                            exchange.put(OperationInfo.class, op);\n                            exchange.setOneWay(op.isOneWay());\n                        }\n                    }\n                    return;\n                }\n    \n                int paramNum = 0;\n    \n                do {\n                    QName elName = xmlReader.getName();\n                    Object o = null;\n    \n                    MessagePartInfo p;\n                    if (!client && msgInfo != null && msgInfo.getMessageParts() != null \n                        && msgInfo.getMessageParts().size() == 0) {\n                        //no input messagePartInfo\n                        return;\n                    }\n                    \n                    if (msgInfo != null && msgInfo.getMessageParts() != null \n                        && msgInfo.getMessageParts().size() > 0) {\n                        if (msgInfo.getMessageParts().size() > paramNum) {\n                            p = msgInfo.getMessageParts().get(paramNum);\n                        } else {\n                            p = null;\n                        }\n                    } else {\n                        p = findMessagePart(exchange, operations, elName, client, paramNum, message);\n                    }\n                    \n                    //Make sure the elName found on the wire is actually OK for \n                    //the purpose we need it\n                    validatePart(p, elName, si);\n\n                    o = dr.read(p, xmlReader);\n                    if (Boolean.TRUE.equals(si.getProperty(\"soap.force.doclit.bare\")) \n                        && parameters.isEmpty()) {\n                        // webservice provider does not need to ensure size\n                        parameters.add(o);\n                    } else {\n                        parameters.put(p, o);\n                    }\n                    \n                    paramNum++;\n                    if (message.getContent(XMLStreamReader.class) == null || o == xmlReader) {\n                        xmlReader = null;\n                    }\n                } while (xmlReader != null && StaxUtils.toNextElement(xmlReader));\n    \n            }\n    \n            message.setContent(List.class, parameters);\n        } catch (Fault f) {\n            if (!isRequestor(message)) {\n                f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n            }\n            throw f;\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "{", "if", "(", "isGET", "(", "message", ")", "&&", "message", ".", "getContent", "(", "List", ".", "class", ")", "!=", "null", ")", "{", "LOG", ".", "fine", "(", "\"", "DocLiteralInInterceptor skipped in HTTP GET method", "\"", ")", ";", "return", ";", "}", "DepthXMLStreamReader", "xmlReader", "=", "getXMLStreamReader", "(", "message", ")", ";", "DataReader", "<", "XMLStreamReader", ">", "dr", "=", "getDataReader", "(", "message", ")", ";", "MessageContentsList", "parameters", "=", "new", "MessageContentsList", "(", ")", ";", "Exchange", "exchange", "=", "message", ".", "getExchange", "(", ")", ";", "BindingOperationInfo", "bop", "=", "exchange", ".", "getBindingOperationInfo", "(", ")", ";", "boolean", "client", "=", "isRequestor", "(", "message", ")", ";", "if", "(", "bop", "!=", "null", "&&", "!", "StaxUtils", ".", "toNextElement", "(", "xmlReader", ")", ")", "{", "return", ";", "}", "if", "(", "bop", "!=", "null", "&&", "bop", ".", "isUnwrapped", "(", ")", ")", "{", "bop", "=", "bop", ".", "getWrappedOperation", "(", ")", ";", "}", "if", "(", "bop", "==", "null", ")", "{", "QName", "startQName", "=", "xmlReader", "==", "null", "?", "new", "QName", "(", "\"", "http://cxf.apache.org/jaxws/provider", "\"", ",", "\"", "invoke", "\"", ")", ":", "xmlReader", ".", "getName", "(", ")", ";", "bop", "=", "getBindingOperationInfo", "(", "exchange", ",", "startQName", ",", "client", ")", ";", "}", "try", "{", "if", "(", "bop", "!=", "null", "&&", "bop", ".", "isUnwrappedCapable", "(", ")", ")", "{", "ServiceInfo", "si", "=", "bop", ".", "getBinding", "(", ")", ".", "getService", "(", ")", ";", "MessageInfo", "msgInfo", "=", "setMessage", "(", "message", ",", "bop", ",", "client", ",", "si", ")", ";", "if", "(", "shouldWrapParameters", "(", "msgInfo", ",", "message", ")", ")", "{", "QName", "startQName", "=", "xmlReader", ".", "getName", "(", ")", ";", "if", "(", "!", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "0", ")", ".", "getConcreteName", "(", ")", ".", "equals", "(", "startQName", ")", ")", "{", "throw", "new", "Fault", "(", "\"", "UNEXPECTED_WRAPPER_ELEMENT", "\"", ",", "LOG", ",", "null", ",", "startQName", ",", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "0", ")", ".", "getConcreteName", "(", ")", ")", ";", "}", "Object", "wrappedObject", "=", "dr", ".", "read", "(", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "0", ")", ",", "xmlReader", ")", ";", "parameters", ".", "put", "(", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "0", ")", ",", "wrappedObject", ")", ";", "}", "else", "{", "bop", "=", "bop", ".", "getUnwrappedOperation", "(", ")", ";", "msgInfo", "=", "setMessage", "(", "message", ",", "bop", ",", "client", ",", "si", ")", ";", "List", "<", "MessagePartInfo", ">", "messageParts", "=", "msgInfo", ".", "getMessageParts", "(", ")", ";", "Iterator", "<", "MessagePartInfo", ">", "itr", "=", "messageParts", ".", "iterator", "(", ")", ";", "if", "(", "xmlReader", ".", "getEventType", "(", ")", "==", "XMLStreamConstants", ".", "START_ELEMENT", ")", "{", "StaxUtils", ".", "nextEvent", "(", "xmlReader", ")", ";", "}", "getPara", "(", "xmlReader", ",", "dr", ",", "parameters", ",", "itr", ",", "message", ")", ";", "}", "}", "else", "{", "BindingMessageInfo", "msgInfo", "=", "null", ";", "Endpoint", "ep", "=", "exchange", ".", "get", "(", "Endpoint", ".", "class", ")", ";", "ServiceInfo", "si", "=", "ep", ".", "getEndpointInfo", "(", ")", ".", "getService", "(", ")", ";", "if", "(", "bop", "!=", "null", ")", "{", "if", "(", "client", ")", "{", "msgInfo", "=", "bop", ".", "getOutput", "(", ")", ";", "}", "else", "{", "msgInfo", "=", "bop", ".", "getInput", "(", ")", ";", "if", "(", "bop", ".", "getOutput", "(", ")", "==", "null", ")", "{", "exchange", ".", "setOneWay", "(", "true", ")", ";", "}", "}", "if", "(", "msgInfo", "==", "null", ")", "{", "return", ";", "}", "setMessage", "(", "message", ",", "bop", ",", "client", ",", "si", ",", "msgInfo", ".", "getMessageInfo", "(", ")", ")", ";", "}", "Collection", "<", "OperationInfo", ">", "operations", "=", "null", ";", "operations", "=", "new", "ArrayList", "<", "OperationInfo", ">", "(", ")", ";", "operations", ".", "addAll", "(", "si", ".", "getInterface", "(", ")", ".", "getOperations", "(", ")", ")", ";", "if", "(", "xmlReader", "==", "null", "||", "!", "StaxUtils", ".", "toNextElement", "(", "xmlReader", ")", ")", "{", "for", "(", "OperationInfo", "op", ":", "operations", ")", "{", "MessageInfo", "bmsg", "=", "op", ".", "getInput", "(", ")", ";", "if", "(", "bmsg", ".", "getMessageParts", "(", ")", ".", "size", "(", ")", "==", "0", ")", "{", "BindingOperationInfo", "boi", "=", "ep", ".", "getEndpointInfo", "(", ")", ".", "getBinding", "(", ")", ".", "getOperation", "(", "op", ")", ";", "exchange", ".", "put", "(", "BindingOperationInfo", ".", "class", ",", "boi", ")", ";", "exchange", ".", "put", "(", "OperationInfo", ".", "class", ",", "op", ")", ";", "exchange", ".", "setOneWay", "(", "op", ".", "isOneWay", "(", ")", ")", ";", "}", "}", "return", ";", "}", "int", "paramNum", "=", "0", ";", "do", "{", "QName", "elName", "=", "xmlReader", ".", "getName", "(", ")", ";", "Object", "o", "=", "null", ";", "MessagePartInfo", "p", ";", "if", "(", "!", "client", "&&", "msgInfo", "!=", "null", "&&", "msgInfo", ".", "getMessageParts", "(", ")", "!=", "null", "&&", "msgInfo", ".", "getMessageParts", "(", ")", ".", "size", "(", ")", "==", "0", ")", "{", "return", ";", "}", "if", "(", "msgInfo", "!=", "null", "&&", "msgInfo", ".", "getMessageParts", "(", ")", "!=", "null", "&&", "msgInfo", ".", "getMessageParts", "(", ")", ".", "size", "(", ")", ">", "0", ")", "{", "if", "(", "msgInfo", ".", "getMessageParts", "(", ")", ".", "size", "(", ")", ">", "paramNum", ")", "{", "p", "=", "msgInfo", ".", "getMessageParts", "(", ")", ".", "get", "(", "paramNum", ")", ";", "}", "else", "{", "p", "=", "null", ";", "}", "}", "else", "{", "p", "=", "findMessagePart", "(", "exchange", ",", "operations", ",", "elName", ",", "client", ",", "paramNum", ",", "message", ")", ";", "}", "validatePart", "(", "p", ",", "elName", ",", "si", ")", ";", "o", "=", "dr", ".", "read", "(", "p", ",", "xmlReader", ")", ";", "if", "(", "Boolean", ".", "TRUE", ".", "equals", "(", "si", ".", "getProperty", "(", "\"", "soap.force.doclit.bare", "\"", ")", ")", "&&", "parameters", ".", "isEmpty", "(", ")", ")", "{", "parameters", ".", "add", "(", "o", ")", ";", "}", "else", "{", "parameters", ".", "put", "(", "p", ",", "o", ")", ";", "}", "paramNum", "++", ";", "if", "(", "message", ".", "getContent", "(", "XMLStreamReader", ".", "class", ")", "==", "null", "||", "o", "==", "xmlReader", ")", "{", "xmlReader", "=", "null", ";", "}", "}", "while", "(", "xmlReader", "!=", "null", "&&", "StaxUtils", ".", "toNextElement", "(", "xmlReader", ")", ")", ";", "}", "message", ".", "setContent", "(", "List", ".", "class", ",", "parameters", ")", ";", "}", "catch", "(", "Fault", "f", ")", "{", "if", "(", "!", "isRequestor", "(", "message", ")", ")", "{", "f", ".", "setFaultCode", "(", "Fault", ".", "FAULT_CODE_CLIENT", ")", ";", "}", "throw", "f", ";", "}", "}"], "idx": 5547, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "9c70abe28fbf2b4c4df0b93ed12295ea5a012554", "function_name": "handleMessage", "body_hash": "e3c2111da35f4092136d94c1b98cd6783f6a96ce"}
{"code": "public static ReconciliationReport parse(final Date run, final InputStream in) throws XMLStreamException {\n        XMLStreamReader streamReader = XML_INPUT_FACTORY.createXMLStreamReader(in);\n        streamReader.nextTag(); // root\n        streamReader.nextTag(); // report\n        streamReader.nextTag(); // reportlet\n\n        ReconciliationReport report = new ReconciliationReport(run);\n\n        List<Missing> missing = new ArrayList<>();\n        List<Misaligned> misaligned = new ArrayList<>();\n        Set<String> onSyncope = null;\n        Set<String> onResource = null;\n\n        Any user = null;\n        Any group = null;\n        Any anyObject = null;\n        String lastAnyType = null;\n        while (streamReader.hasNext()) {\n            if (streamReader.isStartElement()) {\n                switch (streamReader.getLocalName()) {\n                    case \"users\":\n                        Anys users = new Anys();\n                        users.setTotal(Integer.parseInt(streamReader.getAttributeValue(\"\", \"total\")));\n                        report.setUsers(users);\n                        break;\n\n                    case \"user\":\n                        user = new Any();\n                        user.setType(AnyTypeKind.USER.name());\n                        user.setKey(streamReader.getAttributeValue(\"\", \"key\"));\n                        user.setName(streamReader.getAttributeValue(\"\", \"username\"));\n                        report.getUsers().getAnys().add(user);\n                        break;\n\n                    case \"groups\":\n                        Anys groups = new Anys();\n                        groups.setTotal(Integer.parseInt(streamReader.getAttributeValue(\"\", \"total\")));\n                        report.setGroups(groups);\n                        break;\n\n                    case \"group\":\n                        group = new Any();\n                        group.setType(AnyTypeKind.GROUP.name());\n                        group.setKey(streamReader.getAttributeValue(\"\", \"key\"));\n                        group.setName(streamReader.getAttributeValue(\"\", \"groupName\"));\n                        report.getGroups().getAnys().add(group);\n                        break;\n\n                    case \"anyObjects\":\n                        lastAnyType = streamReader.getAttributeValue(\"\", \"type\");\n                        Anys anyObjects = new Anys();\n                        anyObjects.setAnyType(lastAnyType);\n                        anyObjects.setTotal(Integer.parseInt(streamReader.getAttributeValue(\"\", \"total\")));\n                        report.getAnyObjects().add(anyObjects);\n                        break;\n\n                    case \"anyObject\":\n                        anyObject = new Any();\n                        anyObject.setType(lastAnyType);\n                        anyObject.setKey(streamReader.getAttributeValue(\"\", \"key\"));\n                        final String anyType = lastAnyType;\n                        Optional<Anys> anyReport = report.getAnyObjects().stream().\n                                filter(anys -> anyType.equals(anys.getAnyType())).\n                                findFirst();\n                        if (anyReport.isPresent()) {\n                            anyReport.get().getAnys().add(anyObject);\n                        }\n                        break;\n\n                    case \"missing\":\n                        missing.add(new Missing(\n                                streamReader.getAttributeValue(\"\", \"resource\"),\n                                streamReader.getAttributeValue(\"\", \"connObjectKeyValue\")));\n                        break;\n\n                    case \"misaligned\":\n                        misaligned.add(new Misaligned(\n                                streamReader.getAttributeValue(\"\", \"resource\"),\n                                streamReader.getAttributeValue(\"\", \"connObjectKeyValue\"),\n                                streamReader.getAttributeValue(\"\", \"name\")));\n                        break;\n\n                    case \"onSyncope\":\n                        onSyncope = new HashSet<>();\n                        break;\n\n                    case \"onResource\":\n                        onResource = new HashSet<>();\n                        break;\n\n                    case \"value\":\n                        Set<String> set = onSyncope == null ? onResource : onSyncope;\n                        set.add(streamReader.getElementText());\n                        break;\n\n                    default:\n                }\n            } else if (streamReader.isEndElement()) {\n                switch (streamReader.getLocalName()) {\n                    case \"user\":\n                        user.getMissing().addAll(missing);\n                        user.getMisaligned().addAll(misaligned);\n                        missing.clear();\n                        misaligned.clear();\n                        break;\n\n                    case \"group\":\n                        group.getMissing().addAll(missing);\n                        group.getMisaligned().addAll(misaligned);\n                        missing.clear();\n                        misaligned.clear();\n                        break;\n\n                    case \"anyObject\":\n                        anyObject.getMissing().addAll(missing);\n                        anyObject.getMisaligned().addAll(misaligned);\n                        missing.clear();\n                        misaligned.clear();\n                        break;\n\n                    case \"onSyncope\":\n                        misaligned.get(misaligned.size() - 1).getOnSyncope().addAll(onSyncope);\n                        onSyncope = null;\n                        break;\n\n                    case \"onResource\":\n                        misaligned.get(misaligned.size() - 1).getOnResource().addAll(onResource);\n                        onResource = null;\n                        break;\n\n                    default:\n                }\n\n            }\n\n            streamReader.next();\n        }\n\n        return report;\n    }", "code_tokens": ["public", "static", "ReconciliationReport", "parse", "(", "final", "Date", "run", ",", "final", "InputStream", "in", ")", "throws", "XMLStreamException", "{", "XMLStreamReader", "streamReader", "=", "XML_INPUT_FACTORY", ".", "createXMLStreamReader", "(", "in", ")", ";", "streamReader", ".", "nextTag", "(", ")", ";", "streamReader", ".", "nextTag", "(", ")", ";", "streamReader", ".", "nextTag", "(", ")", ";", "ReconciliationReport", "report", "=", "new", "ReconciliationReport", "(", "run", ")", ";", "List", "<", "Missing", ">", "missing", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "Misaligned", ">", "misaligned", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Set", "<", "String", ">", "onSyncope", "=", "null", ";", "Set", "<", "String", ">", "onResource", "=", "null", ";", "Any", "user", "=", "null", ";", "Any", "group", "=", "null", ";", "Any", "anyObject", "=", "null", ";", "String", "lastAnyType", "=", "null", ";", "while", "(", "streamReader", ".", "hasNext", "(", ")", ")", "{", "if", "(", "streamReader", ".", "isStartElement", "(", ")", ")", "{", "switch", "(", "streamReader", ".", "getLocalName", "(", ")", ")", "{", "case", "\"", "users", "\"", ":", "Anys", "users", "=", "new", "Anys", "(", ")", ";", "users", ".", "setTotal", "(", "Integer", ".", "parseInt", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "total", "\"", ")", ")", ")", ";", "report", ".", "setUsers", "(", "users", ")", ";", "break", ";", "case", "\"", "user", "\"", ":", "user", "=", "new", "Any", "(", ")", ";", "user", ".", "setType", "(", "AnyTypeKind", ".", "USER", ".", "name", "(", ")", ")", ";", "user", ".", "setKey", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "key", "\"", ")", ")", ";", "user", ".", "setName", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "username", "\"", ")", ")", ";", "report", ".", "getUsers", "(", ")", ".", "getAnys", "(", ")", ".", "add", "(", "user", ")", ";", "break", ";", "case", "\"", "groups", "\"", ":", "Anys", "groups", "=", "new", "Anys", "(", ")", ";", "groups", ".", "setTotal", "(", "Integer", ".", "parseInt", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "total", "\"", ")", ")", ")", ";", "report", ".", "setGroups", "(", "groups", ")", ";", "break", ";", "case", "\"", "group", "\"", ":", "group", "=", "new", "Any", "(", ")", ";", "group", ".", "setType", "(", "AnyTypeKind", ".", "GROUP", ".", "name", "(", ")", ")", ";", "group", ".", "setKey", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "key", "\"", ")", ")", ";", "group", ".", "setName", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "groupName", "\"", ")", ")", ";", "report", ".", "getGroups", "(", ")", ".", "getAnys", "(", ")", ".", "add", "(", "group", ")", ";", "break", ";", "case", "\"", "anyObjects", "\"", ":", "lastAnyType", "=", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "type", "\"", ")", ";", "Anys", "anyObjects", "=", "new", "Anys", "(", ")", ";", "anyObjects", ".", "setAnyType", "(", "lastAnyType", ")", ";", "anyObjects", ".", "setTotal", "(", "Integer", ".", "parseInt", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "total", "\"", ")", ")", ")", ";", "report", ".", "getAnyObjects", "(", ")", ".", "add", "(", "anyObjects", ")", ";", "break", ";", "case", "\"", "anyObject", "\"", ":", "anyObject", "=", "new", "Any", "(", ")", ";", "anyObject", ".", "setType", "(", "lastAnyType", ")", ";", "anyObject", ".", "setKey", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "key", "\"", ")", ")", ";", "final", "String", "anyType", "=", "lastAnyType", ";", "Optional", "<", "Anys", ">", "anyReport", "=", "report", ".", "getAnyObjects", "(", ")", ".", "stream", "(", ")", ".", "filter", "(", "anys", "->", "anyType", ".", "equals", "(", "anys", ".", "getAnyType", "(", ")", ")", ")", ".", "findFirst", "(", ")", ";", "if", "(", "anyReport", ".", "isPresent", "(", ")", ")", "{", "anyReport", ".", "get", "(", ")", ".", "getAnys", "(", ")", ".", "add", "(", "anyObject", ")", ";", "}", "break", ";", "case", "\"", "missing", "\"", ":", "missing", ".", "add", "(", "new", "Missing", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "resource", "\"", ")", ",", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "connObjectKeyValue", "\"", ")", ")", ")", ";", "break", ";", "case", "\"", "misaligned", "\"", ":", "misaligned", ".", "add", "(", "new", "Misaligned", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "resource", "\"", ")", ",", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "connObjectKeyValue", "\"", ")", ",", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "name", "\"", ")", ")", ")", ";", "break", ";", "case", "\"", "onSyncope", "\"", ":", "onSyncope", "=", "new", "HashSet", "<", ">", "(", ")", ";", "break", ";", "case", "\"", "onResource", "\"", ":", "onResource", "=", "new", "HashSet", "<", ">", "(", ")", ";", "break", ";", "case", "\"", "value", "\"", ":", "Set", "<", "String", ">", "set", "=", "onSyncope", "==", "null", "?", "onResource", ":", "onSyncope", ";", "set", ".", "add", "(", "streamReader", ".", "getElementText", "(", ")", ")", ";", "break", ";", "default", ":", "}", "}", "else", "if", "(", "streamReader", ".", "isEndElement", "(", ")", ")", "{", "switch", "(", "streamReader", ".", "getLocalName", "(", ")", ")", "{", "case", "\"", "user", "\"", ":", "user", ".", "getMissing", "(", ")", ".", "addAll", "(", "missing", ")", ";", "user", ".", "getMisaligned", "(", ")", ".", "addAll", "(", "misaligned", ")", ";", "missing", ".", "clear", "(", ")", ";", "misaligned", ".", "clear", "(", ")", ";", "break", ";", "case", "\"", "group", "\"", ":", "group", ".", "getMissing", "(", ")", ".", "addAll", "(", "missing", ")", ";", "group", ".", "getMisaligned", "(", ")", ".", "addAll", "(", "misaligned", ")", ";", "missing", ".", "clear", "(", ")", ";", "misaligned", ".", "clear", "(", ")", ";", "break", ";", "case", "\"", "anyObject", "\"", ":", "anyObject", ".", "getMissing", "(", ")", ".", "addAll", "(", "missing", ")", ";", "anyObject", ".", "getMisaligned", "(", ")", ".", "addAll", "(", "misaligned", ")", ";", "missing", ".", "clear", "(", ")", ";", "misaligned", ".", "clear", "(", ")", ";", "break", ";", "case", "\"", "onSyncope", "\"", ":", "misaligned", ".", "get", "(", "misaligned", ".", "size", "(", ")", "-", "1", ")", ".", "getOnSyncope", "(", ")", ".", "addAll", "(", "onSyncope", ")", ";", "onSyncope", "=", "null", ";", "break", ";", "case", "\"", "onResource", "\"", ":", "misaligned", ".", "get", "(", "misaligned", ".", "size", "(", ")", "-", "1", ")", ".", "getOnResource", "(", ")", ".", "addAll", "(", "onResource", ")", ";", "onResource", "=", "null", ";", "break", ";", "default", ":", "}", "}", "streamReader", ".", "next", "(", ")", ";", "}", "return", "report", ";", "}"], "idx": 67246, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "a0f35f45f8ca5c98853ae8477fb2db81a84709a", "function_name": "parse", "body_hash": "13449a368c3e83cd65ad37e320cfeecbad904a7e"}
{"code": "public static void unJar(File jarFile, File toDir, Pattern unpackRegex)\n    throws IOException {\n    JarFile jar = new JarFile(jarFile);\n    try {\n      Enumeration<JarEntry> entries = jar.entries();\n      while (entries.hasMoreElements()) {\n        final JarEntry entry = entries.nextElement();\n        if (!entry.isDirectory() &&\n            unpackRegex.matcher(entry.getName()).matches()) {\n          InputStream in = jar.getInputStream(entry);\n          try {\n            File file = new File(toDir, entry.getName());\n            ensureDirectory(file.getParentFile());\n            OutputStream out = new FileOutputStream(file);\n            try {\n              IOUtils.copyBytes(in, out, 8192);\n            } finally {\n              out.close();\n            }\n          } finally {\n            in.close();\n          }\n        }\n      }\n    } finally {\n      jar.close();\n    }\n  }", "code_tokens": ["public", "static", "void", "unJar", "(", "File", "jarFile", ",", "File", "toDir", ",", "Pattern", "unpackRegex", ")", "throws", "IOException", "{", "JarFile", "jar", "=", "new", "JarFile", "(", "jarFile", ")", ";", "try", "{", "Enumeration", "<", "JarEntry", ">", "entries", "=", "jar", ".", "entries", "(", ")", ";", "while", "(", "entries", ".", "hasMoreElements", "(", ")", ")", "{", "final", "JarEntry", "entry", "=", "entries", ".", "nextElement", "(", ")", ";", "if", "(", "!", "entry", ".", "isDirectory", "(", ")", "&&", "unpackRegex", ".", "matcher", "(", "entry", ".", "getName", "(", ")", ")", ".", "matches", "(", ")", ")", "{", "InputStream", "in", "=", "jar", ".", "getInputStream", "(", "entry", ")", ";", "try", "{", "File", "file", "=", "new", "File", "(", "toDir", ",", "entry", ".", "getName", "(", ")", ")", ";", "ensureDirectory", "(", "file", ".", "getParentFile", "(", ")", ")", ";", "OutputStream", "out", "=", "new", "FileOutputStream", "(", "file", ")", ";", "try", "{", "IOUtils", ".", "copyBytes", "(", "in", ",", "out", ",", "8192", ")", ";", "}", "finally", "{", "out", ".", "close", "(", ")", ";", "}", "}", "finally", "{", "in", ".", "close", "(", ")", ";", "}", "}", "}", "}", "finally", "{", "jar", ".", "close", "(", ")", ";", "}", "}"], "idx": 22514, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "eaa2b8035b584dfcf7c79a33484eb2dffd3fdb1", "function_name": "unJar", "body_hash": "260fce28ca2992c555b0c9960787d07a3567bb77"}
{"code": "public String getDivUUID() {\n        StringBuilder randomSelectName = new StringBuilder();\n        randomSelectName.append(getName()).append(\"-\").append(uuid);\n        return randomSelectName.toString();\n    }", "code_tokens": ["public", "String", "getDivUUID", "(", ")", "{", "StringBuilder", "randomSelectName", "=", "new", "StringBuilder", "(", ")", ";", "randomSelectName", ".", "append", "(", "getName", "(", ")", ")", ".", "append", "(", "\"", "-", "\"", ")", ".", "append", "(", "uuid", ")", ";", "return", "randomSelectName", ".", "toString", "(", ")", ";", "}"], "idx": 80823, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "6fd933c", "function_name": "getDivUUID", "body_hash": "f30557d6667504e28d0e54361f04cdbd5bca53a2"}
{"code": "protected XMLInputFactory createXmlInputFactory() {\n\t\treturn XMLInputFactory.newInstance();\n\t}", "code_tokens": ["protected", "XMLInputFactory", "createXmlInputFactory", "(", ")", "{", "return", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "}"], "idx": 34110, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "7576274874deeccb6da6b09a8d5bd62e8b5538b7", "function_name": "createXmlInputFactory", "body_hash": "59b444a7eef176fb8616001a3f0a6de05dd96352"}
{"code": "private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); // SECURITY-247 defense\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }", "code_tokens": ["private", "void", "init", "(", ")", "{", "addImmutableType", "(", "Result", ".", "class", ")", ";", "registerConverter", "(", "new", "RobustCollectionConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "RobustMapConverter", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableMapConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSortedSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableListConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ConcurrentHashMapConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "CopyOnWriteMap", ".", "Tree", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "DescribableList", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "Label", ".", "ConverterImpl", "(", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "AssociatedConverterImpl", "(", "this", ")", ",", "-", "10", ")", ";", "registerConverter", "(", "new", "BlacklistedTypesConverter", "(", ")", ",", "PRIORITY_VERY_HIGH", ")", ";", "registerConverter", "(", "new", "DynamicProxyConverter", "(", "getMapper", "(", ")", ")", "{", "@", "Override", "public", "boolean", "canConvert", "(", "Class", "type", ")", "{", "return", "type", "!=", "null", "&&", "super", ".", "canConvert", "(", "type", ")", ";", "}", "@", "Override", "public", "Object", "unmarshal", "(", "HierarchicalStreamReader", "reader", ",", "UnmarshallingContext", "context", ")", "{", "throw", "new", "ConversionException", "(", "\"", "<dynamic-proxy> not supported", "\"", ")", ";", "}", "}", ",", "PRIORITY_VERY_HIGH", ")", ";", "}"], "idx": 6182, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "18cc8e0eb7d8c9910ce8ce2a9c8dab4c4df8b9c2", "function_name": "init", "body_hash": "dbafd6a2b45499df393cf5b5f6a58dfa73b43862"}
{"code": "@Override\n    protected Details authenticate(String username, String password) throws AuthenticationException {\n        Details u = loadUserByUsername(username);\n        if (!u.isPasswordCorrect(password))\n            throw new BadCredentialsException(\"Failed to login as \"+username);\n        return u;\n    }", "code_tokens": ["@", "Override", "protected", "Details", "authenticate", "(", "String", "username", ",", "String", "password", ")", "throws", "AuthenticationException", "{", "Details", "u", "=", "loadUserByUsername", "(", "username", ")", ";", "if", "(", "!", "u", ".", "isPasswordCorrect", "(", "password", ")", ")", "throw", "new", "BadCredentialsException", "(", "\"", "Failed to login as ", "\"", "+", "username", ")", ";", "return", "u", ";", "}"], "idx": 15691, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "fbf96734470caba9364f04e0b77b0bae7293a1ec", "function_name": "authenticate", "body_hash": "705728433c5e4fa21b74231d7dad1f9cf265a357"}
{"code": "public static void doAuthorization(BaseSemanticAnalyzer sem, String command)\n      throws HiveException, AuthorizationException {\n    SessionState ss = SessionState.get();\n    HiveOperation op = ss.getHiveOperation();\n    Hive db = sem.getDb();\n\n    Set<ReadEntity> additionalInputs = new HashSet<ReadEntity>();\n    for (Entity e : sem.getInputs()) {\n      if (e.getType() == Entity.Type.PARTITION) {\n        additionalInputs.add(new ReadEntity(e.getTable()));\n      }\n    }\n\n    Set<WriteEntity> additionalOutputs = new HashSet<WriteEntity>();\n    for (Entity e : sem.getOutputs()) {\n      if (e.getType() == Entity.Type.PARTITION) {\n        additionalOutputs.add(new WriteEntity(e.getTable(), WriteEntity.WriteType.DDL_NO_LOCK));\n      }\n    }\n\n    Set<ReadEntity> inputs = Sets.union(sem.getInputs(), additionalInputs);\n    Set<WriteEntity> outputs = Sets.union(sem.getOutputs(), additionalOutputs);\n\n    if (ss.isAuthorizationModeV2()) {\n      // get mapping of tables to columns used\n      ColumnAccessInfo colAccessInfo = sem.getColumnAccessInfo();\n      // colAccessInfo is set only in case of SemanticAnalyzer\n      Map<String, List<String>> selectTab2Cols = colAccessInfo != null ? colAccessInfo\n          .getTableToColumnAccessMap() : null;\n      Map<String, List<String>> updateTab2Cols = sem.getUpdateColumnAccessInfo() != null ?\n          sem.getUpdateColumnAccessInfo().getTableToColumnAccessMap() : null;\n      doAuthorizationV2(ss, op, inputs, outputs, command, selectTab2Cols, updateTab2Cols);\n     return;\n    }\n    if (op == null) {\n      throw new HiveException(\"Operation should not be null\");\n    }\n    HiveAuthorizationProvider authorizer = ss.getAuthorizer();\n    if (op.equals(HiveOperation.CREATEDATABASE)) {\n      authorizer.authorize(\n          op.getInputRequiredPrivileges(), op.getOutputRequiredPrivileges());\n    } else if (op.equals(HiveOperation.CREATETABLE_AS_SELECT)\n        || op.equals(HiveOperation.CREATETABLE)) {\n      authorizer.authorize(\n          db.getDatabase(SessionState.get().getCurrentDatabase()), null,\n          HiveOperation.CREATETABLE_AS_SELECT.getOutputRequiredPrivileges());\n    } else {\n      if (op.equals(HiveOperation.IMPORT)) {\n        ImportSemanticAnalyzer isa = (ImportSemanticAnalyzer) sem;\n        if (!isa.existsTable()) {\n          authorizer.authorize(\n              db.getDatabase(SessionState.get().getCurrentDatabase()), null,\n              HiveOperation.CREATETABLE_AS_SELECT.getOutputRequiredPrivileges());\n        }\n      }\n    }\n    if (outputs != null && outputs.size() > 0) {\n      for (WriteEntity write : outputs) {\n        if (write.isDummy() || write.isPathType()) {\n          continue;\n        }\n        if (write.getType() == Entity.Type.DATABASE) {\n          if (!op.equals(HiveOperation.IMPORT)){\n            // We skip DB check for import here because we already handle it above\n            // as a CTAS check.\n            authorizer.authorize(write.getDatabase(),\n                null, op.getOutputRequiredPrivileges());\n          }\n          continue;\n        }\n\n        if (write.getType() == WriteEntity.Type.PARTITION) {\n          Partition part = db.getPartition(write.getTable(), write\n              .getPartition().getSpec(), false);\n          if (part != null) {\n            authorizer.authorize(write.getPartition(), null,\n                    op.getOutputRequiredPrivileges());\n            continue;\n          }\n        }\n\n        if (write.getTable() != null) {\n          authorizer.authorize(write.getTable(), null,\n                  op.getOutputRequiredPrivileges());\n        }\n      }\n    }\n\n    if (inputs != null && inputs.size() > 0) {\n      Map<Table, List<String>> tab2Cols = new HashMap<Table, List<String>>();\n      Map<Partition, List<String>> part2Cols = new HashMap<Partition, List<String>>();\n\n      //determine if partition level privileges should be checked for input tables\n      Map<String, Boolean> tableUsePartLevelAuth = new HashMap<String, Boolean>();\n      for (ReadEntity read : inputs) {\n        if (read.isDummy() || read.isPathType() || read.getType() == Entity.Type.DATABASE) {\n          continue;\n        }\n        Table tbl = read.getTable();\n        if ((read.getPartition() != null) || (tbl != null && tbl.isPartitioned())) {\n          String tblName = tbl.getTableName();\n          if (tableUsePartLevelAuth.get(tblName) == null) {\n            boolean usePartLevelPriv = (tbl.getParameters().get(\n                \"PARTITION_LEVEL_PRIVILEGE\") != null && (\"TRUE\"\n                .equalsIgnoreCase(tbl.getParameters().get(\n                    \"PARTITION_LEVEL_PRIVILEGE\"))));\n            if (usePartLevelPriv) {\n              tableUsePartLevelAuth.put(tblName, Boolean.TRUE);\n            } else {\n              tableUsePartLevelAuth.put(tblName, Boolean.FALSE);\n            }\n          }\n        }\n      }\n\n      getTablePartitionUsedColumns(op, sem, tab2Cols, part2Cols, tableUsePartLevelAuth);\n\n\n\n      // cache the results for table authorization\n      Set<String> tableAuthChecked = new HashSet<String>();\n      for (ReadEntity read : inputs) {\n        if (read.isDummy() || read.isPathType()) {\n          continue;\n        }\n        if (read.getType() == Entity.Type.DATABASE) {\n          authorizer.authorize(read.getDatabase(), op.getInputRequiredPrivileges(), null);\n          continue;\n        }\n        Table tbl = read.getTable();\n        if (read.getPartition() != null) {\n          Partition partition = read.getPartition();\n          tbl = partition.getTable();\n          // use partition level authorization\n          if (Boolean.TRUE.equals(tableUsePartLevelAuth.get(tbl.getTableName()))) {\n            List<String> cols = part2Cols.get(partition);\n            if (cols != null && cols.size() > 0) {\n              authorizer.authorize(partition.getTable(),\n                  partition, cols, op.getInputRequiredPrivileges(),\n                  null);\n            } else {\n              authorizer.authorize(partition,\n                  op.getInputRequiredPrivileges(), null);\n            }\n            continue;\n          }\n        }\n\n        // if we reach here, it means it needs to do a table authorization\n        // check, and the table authorization may already happened because of other\n        // partitions\n        if (tbl != null && !tableAuthChecked.contains(tbl.getTableName()) &&\n            !(Boolean.TRUE.equals(tableUsePartLevelAuth.get(tbl.getTableName())))) {\n          List<String> cols = tab2Cols.get(tbl);\n          if (cols != null && cols.size() > 0) {\n            authorizer.authorize(tbl, null, cols,\n                op.getInputRequiredPrivileges(), null);\n          } else {\n            authorizer.authorize(tbl, op.getInputRequiredPrivileges(),\n                null);\n          }\n          tableAuthChecked.add(tbl.getTableName());\n        }\n      }\n\n    }\n  }", "code_tokens": ["public", "static", "void", "doAuthorization", "(", "BaseSemanticAnalyzer", "sem", ",", "String", "command", ")", "throws", "HiveException", ",", "AuthorizationException", "{", "SessionState", "ss", "=", "SessionState", ".", "get", "(", ")", ";", "HiveOperation", "op", "=", "ss", ".", "getHiveOperation", "(", ")", ";", "Hive", "db", "=", "sem", ".", "getDb", "(", ")", ";", "Set", "<", "ReadEntity", ">", "additionalInputs", "=", "new", "HashSet", "<", "ReadEntity", ">", "(", ")", ";", "for", "(", "Entity", "e", ":", "sem", ".", "getInputs", "(", ")", ")", "{", "if", "(", "e", ".", "getType", "(", ")", "==", "Entity", ".", "Type", ".", "PARTITION", ")", "{", "additionalInputs", ".", "add", "(", "new", "ReadEntity", "(", "e", ".", "getTable", "(", ")", ")", ")", ";", "}", "}", "Set", "<", "WriteEntity", ">", "additionalOutputs", "=", "new", "HashSet", "<", "WriteEntity", ">", "(", ")", ";", "for", "(", "Entity", "e", ":", "sem", ".", "getOutputs", "(", ")", ")", "{", "if", "(", "e", ".", "getType", "(", ")", "==", "Entity", ".", "Type", ".", "PARTITION", ")", "{", "additionalOutputs", ".", "add", "(", "new", "WriteEntity", "(", "e", ".", "getTable", "(", ")", ",", "WriteEntity", ".", "WriteType", ".", "DDL_NO_LOCK", ")", ")", ";", "}", "}", "Set", "<", "ReadEntity", ">", "inputs", "=", "Sets", ".", "union", "(", "sem", ".", "getInputs", "(", ")", ",", "additionalInputs", ")", ";", "Set", "<", "WriteEntity", ">", "outputs", "=", "Sets", ".", "union", "(", "sem", ".", "getOutputs", "(", ")", ",", "additionalOutputs", ")", ";", "if", "(", "ss", ".", "isAuthorizationModeV2", "(", ")", ")", "{", "ColumnAccessInfo", "colAccessInfo", "=", "sem", ".", "getColumnAccessInfo", "(", ")", ";", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "selectTab2Cols", "=", "colAccessInfo", "!=", "null", "?", "colAccessInfo", ".", "getTableToColumnAccessMap", "(", ")", ":", "null", ";", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "updateTab2Cols", "=", "sem", ".", "getUpdateColumnAccessInfo", "(", ")", "!=", "null", "?", "sem", ".", "getUpdateColumnAccessInfo", "(", ")", ".", "getTableToColumnAccessMap", "(", ")", ":", "null", ";", "doAuthorizationV2", "(", "ss", ",", "op", ",", "inputs", ",", "outputs", ",", "command", ",", "selectTab2Cols", ",", "updateTab2Cols", ")", ";", "return", ";", "}", "if", "(", "op", "==", "null", ")", "{", "throw", "new", "HiveException", "(", "\"", "Operation should not be null", "\"", ")", ";", "}", "HiveAuthorizationProvider", "authorizer", "=", "ss", ".", "getAuthorizer", "(", ")", ";", "if", "(", "op", ".", "equals", "(", "HiveOperation", ".", "CREATEDATABASE", ")", ")", "{", "authorizer", ".", "authorize", "(", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "op", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "else", "if", "(", "op", ".", "equals", "(", "HiveOperation", ".", "CREATETABLE_AS_SELECT", ")", "||", "op", ".", "equals", "(", "HiveOperation", ".", "CREATETABLE", ")", ")", "{", "authorizer", ".", "authorize", "(", "db", ".", "getDatabase", "(", "SessionState", ".", "get", "(", ")", ".", "getCurrentDatabase", "(", ")", ")", ",", "null", ",", "HiveOperation", ".", "CREATETABLE_AS_SELECT", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "else", "{", "if", "(", "op", ".", "equals", "(", "HiveOperation", ".", "IMPORT", ")", ")", "{", "ImportSemanticAnalyzer", "isa", "=", "(", "ImportSemanticAnalyzer", ")", "sem", ";", "if", "(", "!", "isa", ".", "existsTable", "(", ")", ")", "{", "authorizer", ".", "authorize", "(", "db", ".", "getDatabase", "(", "SessionState", ".", "get", "(", ")", ".", "getCurrentDatabase", "(", ")", ")", ",", "null", ",", "HiveOperation", ".", "CREATETABLE_AS_SELECT", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "}", "}", "if", "(", "outputs", "!=", "null", "&&", "outputs", ".", "size", "(", ")", ">", "0", ")", "{", "for", "(", "WriteEntity", "write", ":", "outputs", ")", "{", "if", "(", "write", ".", "isDummy", "(", ")", "||", "write", ".", "isPathType", "(", ")", ")", "{", "continue", ";", "}", "if", "(", "write", ".", "getType", "(", ")", "==", "Entity", ".", "Type", ".", "DATABASE", ")", "{", "if", "(", "!", "op", ".", "equals", "(", "HiveOperation", ".", "IMPORT", ")", ")", "{", "authorizer", ".", "authorize", "(", "write", ".", "getDatabase", "(", ")", ",", "null", ",", "op", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "continue", ";", "}", "if", "(", "write", ".", "getType", "(", ")", "==", "WriteEntity", ".", "Type", ".", "PARTITION", ")", "{", "Partition", "part", "=", "db", ".", "getPartition", "(", "write", ".", "getTable", "(", ")", ",", "write", ".", "getPartition", "(", ")", ".", "getSpec", "(", ")", ",", "false", ")", ";", "if", "(", "part", "!=", "null", ")", "{", "authorizer", ".", "authorize", "(", "write", ".", "getPartition", "(", ")", ",", "null", ",", "op", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "continue", ";", "}", "}", "if", "(", "write", ".", "getTable", "(", ")", "!=", "null", ")", "{", "authorizer", ".", "authorize", "(", "write", ".", "getTable", "(", ")", ",", "null", ",", "op", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "}", "}", "if", "(", "inputs", "!=", "null", "&&", "inputs", ".", "size", "(", ")", ">", "0", ")", "{", "Map", "<", "Table", ",", "List", "<", "String", ">", ">", "tab2Cols", "=", "new", "HashMap", "<", "Table", ",", "List", "<", "String", ">", ">", "(", ")", ";", "Map", "<", "Partition", ",", "List", "<", "String", ">", ">", "part2Cols", "=", "new", "HashMap", "<", "Partition", ",", "List", "<", "String", ">", ">", "(", ")", ";", "Map", "<", "String", ",", "Boolean", ">", "tableUsePartLevelAuth", "=", "new", "HashMap", "<", "String", ",", "Boolean", ">", "(", ")", ";", "for", "(", "ReadEntity", "read", ":", "inputs", ")", "{", "if", "(", "read", ".", "isDummy", "(", ")", "||", "read", ".", "isPathType", "(", ")", "||", "read", ".", "getType", "(", ")", "==", "Entity", ".", "Type", ".", "DATABASE", ")", "{", "continue", ";", "}", "Table", "tbl", "=", "read", ".", "getTable", "(", ")", ";", "if", "(", "(", "read", ".", "getPartition", "(", ")", "!=", "null", ")", "||", "(", "tbl", "!=", "null", "&&", "tbl", ".", "isPartitioned", "(", ")", ")", ")", "{", "String", "tblName", "=", "tbl", ".", "getTableName", "(", ")", ";", "if", "(", "tableUsePartLevelAuth", ".", "get", "(", "tblName", ")", "==", "null", ")", "{", "boolean", "usePartLevelPriv", "=", "(", "tbl", ".", "getParameters", "(", ")", ".", "get", "(", "\"", "PARTITION_LEVEL_PRIVILEGE", "\"", ")", "!=", "null", "&&", "(", "\"", "TRUE", "\"", ".", "equalsIgnoreCase", "(", "tbl", ".", "getParameters", "(", ")", ".", "get", "(", "\"", "PARTITION_LEVEL_PRIVILEGE", "\"", ")", ")", ")", ")", ";", "if", "(", "usePartLevelPriv", ")", "{", "tableUsePartLevelAuth", ".", "put", "(", "tblName", ",", "Boolean", ".", "TRUE", ")", ";", "}", "else", "{", "tableUsePartLevelAuth", ".", "put", "(", "tblName", ",", "Boolean", ".", "FALSE", ")", ";", "}", "}", "}", "}", "getTablePartitionUsedColumns", "(", "op", ",", "sem", ",", "tab2Cols", ",", "part2Cols", ",", "tableUsePartLevelAuth", ")", ";", "Set", "<", "String", ">", "tableAuthChecked", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "for", "(", "ReadEntity", "read", ":", "inputs", ")", "{", "if", "(", "read", ".", "isDummy", "(", ")", "||", "read", ".", "isPathType", "(", ")", ")", "{", "continue", ";", "}", "if", "(", "read", ".", "getType", "(", ")", "==", "Entity", ".", "Type", ".", "DATABASE", ")", "{", "authorizer", ".", "authorize", "(", "read", ".", "getDatabase", "(", ")", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "continue", ";", "}", "Table", "tbl", "=", "read", ".", "getTable", "(", ")", ";", "if", "(", "read", ".", "getPartition", "(", ")", "!=", "null", ")", "{", "Partition", "partition", "=", "read", ".", "getPartition", "(", ")", ";", "tbl", "=", "partition", ".", "getTable", "(", ")", ";", "if", "(", "Boolean", ".", "TRUE", ".", "equals", "(", "tableUsePartLevelAuth", ".", "get", "(", "tbl", ".", "getTableName", "(", ")", ")", ")", ")", "{", "List", "<", "String", ">", "cols", "=", "part2Cols", ".", "get", "(", "partition", ")", ";", "if", "(", "cols", "!=", "null", "&&", "cols", ".", "size", "(", ")", ">", "0", ")", "{", "authorizer", ".", "authorize", "(", "partition", ".", "getTable", "(", ")", ",", "partition", ",", "cols", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "}", "else", "{", "authorizer", ".", "authorize", "(", "partition", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "}", "continue", ";", "}", "}", "if", "(", "tbl", "!=", "null", "&&", "!", "tableAuthChecked", ".", "contains", "(", "tbl", ".", "getTableName", "(", ")", ")", "&&", "!", "(", "Boolean", ".", "TRUE", ".", "equals", "(", "tableUsePartLevelAuth", ".", "get", "(", "tbl", ".", "getTableName", "(", ")", ")", ")", ")", ")", "{", "List", "<", "String", ">", "cols", "=", "tab2Cols", ".", "get", "(", "tbl", ")", ";", "if", "(", "cols", "!=", "null", "&&", "cols", ".", "size", "(", ")", ">", "0", ")", "{", "authorizer", ".", "authorize", "(", "tbl", ",", "null", ",", "cols", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "}", "else", "{", "authorizer", ".", "authorize", "(", "tbl", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "}", "tableAuthChecked", ".", "add", "(", "tbl", ".", "getTableName", "(", ")", ")", ";", "}", "}", "}", "}"], "idx": 39017, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "98f933f269e6b528ef84912b3d701ca3272ec04b", "function_name": "doAuthorization", "body_hash": "0228cd11a18da530e27f0ee3582512c88d0ebae9"}
{"code": "protected void handleSimpleCORS(final HttpServletRequest request,\n            final HttpServletResponse response, final FilterChain filterChain)\n            throws IOException, ServletException {\n\n        CorsFilter.CORSRequestType requestType = checkRequestType(request);\n        if (!(requestType == CorsFilter.CORSRequestType.SIMPLE ||\n                requestType == CorsFilter.CORSRequestType.ACTUAL)) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"corsFilter.wrongType2\",\n                            CorsFilter.CORSRequestType.SIMPLE,\n                            CorsFilter.CORSRequestType.ACTUAL));\n        }\n\n        final String origin = request\n                .getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);\n        final String method = request.getMethod();\n\n        // Section 6.1.2\n        if (!isOriginAllowed(origin)) {\n            handleInvalidCORS(request, response, filterChain);\n            return;\n        }\n\n        if (!allowedHttpMethods.contains(method)) {\n            handleInvalidCORS(request, response, filterChain);\n            return;\n        }\n\n        // Section 6.1.3\n        // Add a single Access-Control-Allow-Origin header.\n        if (anyOriginAllowed && !supportsCredentials) {\n            // If resource doesn't support credentials and if any origin is\n            // allowed\n            // to make CORS request, return header with '*'.\n            response.addHeader(\n                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,\n                    \"*\");\n        } else {\n            // If the resource supports credentials add a single\n            // Access-Control-Allow-Origin header, with the value of the Origin\n            // header as value.\n            response.addHeader(\n                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,\n                    origin);\n        }\n\n        // Section 6.1.3\n        // If the resource supports credentials, add a single\n        // Access-Control-Allow-Credentials header with the case-sensitive\n        // string \"true\" as value.\n        if (supportsCredentials) {\n            response.addHeader(\n                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,\n                    \"true\");\n        }\n\n        // Section 6.1.4\n        // If the list of exposed headers is not empty add one or more\n        // Access-Control-Expose-Headers headers, with as values the header\n        // field names given in the list of exposed headers.\n        if ((exposedHeaders != null) && (exposedHeaders.size() > 0)) {\n            String exposedHeadersString = join(exposedHeaders, \",\");\n            response.addHeader(\n                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS,\n                    exposedHeadersString);\n        }\n\n        // Forward the request down the filter chain.\n        filterChain.doFilter(request, response);\n    }", "code_tokens": ["protected", "void", "handleSimpleCORS", "(", "final", "HttpServletRequest", "request", ",", "final", "HttpServletResponse", "response", ",", "final", "FilterChain", "filterChain", ")", "throws", "IOException", ",", "ServletException", "{", "CorsFilter", ".", "CORSRequestType", "requestType", "=", "checkRequestType", "(", "request", ")", ";", "if", "(", "!", "(", "requestType", "==", "CorsFilter", ".", "CORSRequestType", ".", "SIMPLE", "||", "requestType", "==", "CorsFilter", ".", "CORSRequestType", ".", "ACTUAL", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "sm", ".", "getString", "(", "\"", "corsFilter.wrongType2", "\"", ",", "CorsFilter", ".", "CORSRequestType", ".", "SIMPLE", ",", "CorsFilter", ".", "CORSRequestType", ".", "ACTUAL", ")", ")", ";", "}", "final", "String", "origin", "=", "request", ".", "getHeader", "(", "CorsFilter", ".", "REQUEST_HEADER_ORIGIN", ")", ";", "final", "String", "method", "=", "request", ".", "getMethod", "(", ")", ";", "if", "(", "!", "isOriginAllowed", "(", "origin", ")", ")", "{", "handleInvalidCORS", "(", "request", ",", "response", ",", "filterChain", ")", ";", "return", ";", "}", "if", "(", "!", "allowedHttpMethods", ".", "contains", "(", "method", ")", ")", "{", "handleInvalidCORS", "(", "request", ",", "response", ",", "filterChain", ")", ";", "return", ";", "}", "if", "(", "anyOriginAllowed", "&&", "!", "supportsCredentials", ")", "{", "response", ".", "addHeader", "(", "CorsFilter", ".", "RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN", ",", "\"", "*", "\"", ")", ";", "}", "else", "{", "response", ".", "addHeader", "(", "CorsFilter", ".", "RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN", ",", "origin", ")", ";", "}", "if", "(", "supportsCredentials", ")", "{", "response", ".", "addHeader", "(", "CorsFilter", ".", "RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS", ",", "\"", "true", "\"", ")", ";", "}", "if", "(", "(", "exposedHeaders", "!=", "null", ")", "&&", "(", "exposedHeaders", ".", "size", "(", ")", ">", "0", ")", ")", "{", "String", "exposedHeadersString", "=", "join", "(", "exposedHeaders", ",", "\"", ",", "\"", ")", ";", "response", ".", "addHeader", "(", "CorsFilter", ".", "RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS", ",", "exposedHeadersString", ")", ";", "}", "filterChain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}"], "idx": 42894, "cwe": "CWE-345", "target": 1, "status": "VULNERABLE", "commit": "b94478d45b7e1fc06134a785571f78772fa30fed", "function_name": "handleSimpleCORS", "body_hash": "f4cf11d429bdffab1c5d956567f6e08c8c1266aa"}
{"code": "private Environment getRemoteEnvironment(RestTemplate restTemplate,\n\t\t\tConfigClientProperties properties, String label, String state) {\n\t\tString path = \"/{name}/{profile}\";\n\t\tString name = properties.getName();\n\t\tString profile = properties.getProfile();\n\t\tString token = properties.getToken();\n\t\tint noOfUrls = properties.getUri().length;\n\t\tif (noOfUrls > 1) {\n\t\t\tlogger.info(\"Multiple Config Server Urls found listed.\");\n\t\t}\n\n\t\tObject[] args = new String[] { name, profile };\n\t\tif (StringUtils.hasText(label)) {\n\t\t\tif (label.contains(\"/\")) {\n\t\t\t\tlabel = label.replace(\"/\", \"(_)\");\n\t\t\t}\n\t\t\targs = new String[] { name, profile, label };\n\t\t\tpath = path + \"/{label}\";\n\t\t}\n\t\tResponseEntity<Environment> response = null;\n\n\t\tfor (int i = 0; i < noOfUrls; i++) {\n\t\t\tCredentials credentials = properties.getCredentials(i);\n\t\t\tString uri = credentials.getUri();\n\t\t\tString username = credentials.getUsername();\n\t\t\tString password = credentials.getPassword();\n\n\t\t\tlogger.info(\"Fetching config from server at : \" + uri);\n\n\t\t\ttry {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\taddAuthorizationToken(properties, headers, username, password);\n\t\t\t\tif (StringUtils.hasText(token)) {\n\t\t\t\t\theaders.add(TOKEN_HEADER, token);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasText(state) && properties.isSendState()) {\n\t\t\t\t\theaders.add(STATE_HEADER, state);\n\t\t\t\t}\n\t\t\t\theaders.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));\n\n\t\t\t\tfinal HttpEntity<Void> entity = new HttpEntity<>((Void) null, headers);\n\t\t\t\tresponse = restTemplate.exchange(uri + path, HttpMethod.GET, entity,\n\t\t\t\t\t\tEnvironment.class, args);\n\t\t\t}\n\t\t\tcatch (HttpClientErrorException e) {\n\t\t\t\tif (e.getStatusCode() != HttpStatus.NOT_FOUND) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ResourceAccessException e) {\n\t\t\t\tlogger.info(\"Connect Timeout Exception on Url - \" + uri\n\t\t\t\t\t\t+ \". Will be trying the next url if available\");\n\t\t\t\tif (i == noOfUrls - 1) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (response == null || response.getStatusCode() != HttpStatus.OK) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tEnvironment result = response.getBody();\n\t\t\treturn result;\n\t\t}\n\n\t\treturn null;\n\t}", "code_tokens": ["private", "Environment", "getRemoteEnvironment", "(", "RestTemplate", "restTemplate", ",", "ConfigClientProperties", "properties", ",", "String", "label", ",", "String", "state", ")", "{", "String", "path", "=", "\"", "/{name}/{profile}", "\"", ";", "String", "name", "=", "properties", ".", "getName", "(", ")", ";", "String", "profile", "=", "properties", ".", "getProfile", "(", ")", ";", "String", "token", "=", "properties", ".", "getToken", "(", ")", ";", "int", "noOfUrls", "=", "properties", ".", "getUri", "(", ")", ".", "length", ";", "if", "(", "noOfUrls", ">", "1", ")", "{", "logger", ".", "info", "(", "\"", "Multiple Config Server Urls found listed.", "\"", ")", ";", "}", "Object", "[", "]", "args", "=", "new", "String", "[", "]", "{", "name", ",", "profile", "}", ";", "if", "(", "StringUtils", ".", "hasText", "(", "label", ")", ")", "{", "if", "(", "label", ".", "contains", "(", "\"", "/", "\"", ")", ")", "{", "label", "=", "label", ".", "replace", "(", "\"", "/", "\"", ",", "\"", "(_)", "\"", ")", ";", "}", "args", "=", "new", "String", "[", "]", "{", "name", ",", "profile", ",", "label", "}", ";", "path", "=", "path", "+", "\"", "/{label}", "\"", ";", "}", "ResponseEntity", "<", "Environment", ">", "response", "=", "null", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "noOfUrls", ";", "i", "++", ")", "{", "Credentials", "credentials", "=", "properties", ".", "getCredentials", "(", "i", ")", ";", "String", "uri", "=", "credentials", ".", "getUri", "(", ")", ";", "String", "username", "=", "credentials", ".", "getUsername", "(", ")", ";", "String", "password", "=", "credentials", ".", "getPassword", "(", ")", ";", "logger", ".", "info", "(", "\"", "Fetching config from server at : ", "\"", "+", "uri", ")", ";", "try", "{", "HttpHeaders", "headers", "=", "new", "HttpHeaders", "(", ")", ";", "addAuthorizationToken", "(", "properties", ",", "headers", ",", "username", ",", "password", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "token", ")", ")", "{", "headers", ".", "add", "(", "TOKEN_HEADER", ",", "token", ")", ";", "}", "if", "(", "StringUtils", ".", "hasText", "(", "state", ")", "&&", "properties", ".", "isSendState", "(", ")", ")", "{", "headers", ".", "add", "(", "STATE_HEADER", ",", "state", ")", ";", "}", "headers", ".", "setAccept", "(", "Collections", ".", "singletonList", "(", "MediaType", ".", "APPLICATION_JSON", ")", ")", ";", "final", "HttpEntity", "<", "Void", ">", "entity", "=", "new", "HttpEntity", "<", ">", "(", "(", "Void", ")", "null", ",", "headers", ")", ";", "response", "=", "restTemplate", ".", "exchange", "(", "uri", "+", "path", ",", "HttpMethod", ".", "GET", ",", "entity", ",", "Environment", ".", "class", ",", "args", ")", ";", "}", "catch", "(", "HttpClientErrorException", "e", ")", "{", "if", "(", "e", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "NOT_FOUND", ")", "{", "throw", "e", ";", "}", "}", "catch", "(", "ResourceAccessException", "e", ")", "{", "logger", ".", "info", "(", "\"", "Connect Timeout Exception on Url - ", "\"", "+", "uri", "+", "\"", ". Will be trying the next url if available", "\"", ")", ";", "if", "(", "i", "==", "noOfUrls", "-", "1", ")", "{", "throw", "e", ";", "}", "else", "{", "continue", ";", "}", "}", "if", "(", "response", "==", "null", "||", "response", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "OK", ")", "{", "return", "null", ";", "}", "Environment", "result", "=", "response", ".", "getBody", "(", ")", ";", "return", "result", ";", "}", "return", "null", ";", "}"], "idx": 26328, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "b991dc17c2772e5da33639d3c4bc98b13bc04734", "function_name": "getRemoteEnvironment", "body_hash": "20c158d7ac70370de653d5a47245e7641a75a534"}
{"code": "@Override\n    public void initialize(ScriptContext scriptContext)\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        if (scriptContext.getAttribute(\"util\") == null) {\n            // Put the Util API in the Script context.\n            scriptContext.setAttribute(\"util\", new com.xpn.xwiki.api.Util(xcontext.getWiki(), xcontext),\n                ScriptContext.ENGINE_SCOPE);\n\n            // We put the com.xpn.xwiki.api.XWiki object into the context and not the com.xpn.xwiki.XWiki one which is\n            // for internal use only. In this manner we control what the user can access.\n            scriptContext.setAttribute(\"xwiki\", new XWiki(xcontext.getWiki(), xcontext), ScriptContext.ENGINE_SCOPE);\n\n            scriptContext.setAttribute(\"request\", xcontext.getRequest(), ScriptContext.ENGINE_SCOPE);\n            scriptContext.setAttribute(\"response\", xcontext.getResponse(), ScriptContext.ENGINE_SCOPE);\n\n            // We put the com.xpn.xwiki.api.Context object into the context and not the com.xpn.xwiki.XWikiContext one\n            // which is for internal use only. In this manner we control what the user can access.\n            // We use \"xcontext\" because \"context\" is a reserved binding in JSR-223 specifications\n            scriptContext.setAttribute(\"xcontext\", new Context(xcontext), ScriptContext.ENGINE_SCOPE);\n        }\n\n        // Current document\n        Document docAPI = null;\n        XWikiDocument doc = xcontext.getDoc();\n        if (doc != null) {\n            docAPI = setDocument(scriptContext, \"doc\", doc, xcontext);\n\n            XWikiDocument tdoc = (XWikiDocument) xcontext.get(\"tdoc\");\n            if (tdoc == null) {\n                try {\n                    tdoc = doc.getTranslatedDocument(xcontext);\n                } catch (XWikiException e) {\n                    this.logger.warn(\"Failed to retrieve the translated document for [{}]. \"\n                        + \"Continue using the default translation.\", doc.getDocumentReference(), e);\n                    tdoc = doc;\n                }\n            }\n            Document tdocAPI = setDocument(scriptContext, \"tdoc\", tdoc, xcontext);\n\n            XWikiDocument cdoc = (XWikiDocument) xcontext.get(\"cdoc\");\n            if (cdoc == null) {\n                Document cdocAPI = tdocAPI;\n                if (cdocAPI == null) {\n                    cdocAPI = docAPI;\n                }\n                scriptContext.setAttribute(\"cdoc\", cdocAPI, ScriptContext.ENGINE_SCOPE);\n            } else {\n                setDocument(scriptContext, \"cdoc\", cdoc, xcontext);\n            }\n        }\n\n        // Current secure document\n        XWikiDocument sdoc = (XWikiDocument) xcontext.get(\"sdoc\");\n        if (sdoc == null) {\n            scriptContext.setAttribute(\"sdoc\", docAPI, ScriptContext.ENGINE_SCOPE);\n        } else {\n            setDocument(scriptContext, \"sdoc\", sdoc, xcontext);\n        }\n\n        // Miscellaneous\n        scriptContext.setAttribute(\"locale\", xcontext.getLocale(), ScriptContext.ENGINE_SCOPE);\n    }", "code_tokens": ["@", "Override", "public", "void", "initialize", "(", "ScriptContext", "scriptContext", ")", "{", "XWikiContext", "xcontext", "=", "this", ".", "xcontextProvider", ".", "get", "(", ")", ";", "if", "(", "scriptContext", ".", "getAttribute", "(", "\"", "util", "\"", ")", "==", "null", ")", "{", "scriptContext", ".", "setAttribute", "(", "\"", "util", "\"", ",", "new", "com", ".", "xpn", ".", "xwiki", ".", "api", ".", "Util", "(", "xcontext", ".", "getWiki", "(", ")", ",", "xcontext", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "scriptContext", ".", "setAttribute", "(", "\"", "xwiki", "\"", ",", "new", "XWiki", "(", "xcontext", ".", "getWiki", "(", ")", ",", "xcontext", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "scriptContext", ".", "setAttribute", "(", "\"", "request", "\"", ",", "xcontext", ".", "getRequest", "(", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "scriptContext", ".", "setAttribute", "(", "\"", "response", "\"", ",", "xcontext", ".", "getResponse", "(", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "scriptContext", ".", "setAttribute", "(", "\"", "xcontext", "\"", ",", "new", "Context", "(", "xcontext", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "}", "Document", "docAPI", "=", "null", ";", "XWikiDocument", "doc", "=", "xcontext", ".", "getDoc", "(", ")", ";", "if", "(", "doc", "!=", "null", ")", "{", "docAPI", "=", "setDocument", "(", "scriptContext", ",", "\"", "doc", "\"", ",", "doc", ",", "xcontext", ")", ";", "XWikiDocument", "tdoc", "=", "(", "XWikiDocument", ")", "xcontext", ".", "get", "(", "\"", "tdoc", "\"", ")", ";", "if", "(", "tdoc", "==", "null", ")", "{", "try", "{", "tdoc", "=", "doc", ".", "getTranslatedDocument", "(", "xcontext", ")", ";", "}", "catch", "(", "XWikiException", "e", ")", "{", "this", ".", "logger", ".", "warn", "(", "\"", "Failed to retrieve the translated document for [{}]. ", "\"", "+", "\"", "Continue using the default translation.", "\"", ",", "doc", ".", "getDocumentReference", "(", ")", ",", "e", ")", ";", "tdoc", "=", "doc", ";", "}", "}", "Document", "tdocAPI", "=", "setDocument", "(", "scriptContext", ",", "\"", "tdoc", "\"", ",", "tdoc", ",", "xcontext", ")", ";", "XWikiDocument", "cdoc", "=", "(", "XWikiDocument", ")", "xcontext", ".", "get", "(", "\"", "cdoc", "\"", ")", ";", "if", "(", "cdoc", "==", "null", ")", "{", "Document", "cdocAPI", "=", "tdocAPI", ";", "if", "(", "cdocAPI", "==", "null", ")", "{", "cdocAPI", "=", "docAPI", ";", "}", "scriptContext", ".", "setAttribute", "(", "\"", "cdoc", "\"", ",", "cdocAPI", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "}", "else", "{", "setDocument", "(", "scriptContext", ",", "\"", "cdoc", "\"", ",", "cdoc", ",", "xcontext", ")", ";", "}", "}", "XWikiDocument", "sdoc", "=", "(", "XWikiDocument", ")", "xcontext", ".", "get", "(", "\"", "sdoc", "\"", ")", ";", "if", "(", "sdoc", "==", "null", ")", "{", "scriptContext", ".", "setAttribute", "(", "\"", "sdoc", "\"", ",", "docAPI", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "}", "else", "{", "setDocument", "(", "scriptContext", ",", "\"", "sdoc", "\"", ",", "sdoc", ",", "xcontext", ")", ";", "}", "scriptContext", ".", "setAttribute", "(", "\"", "locale", "\"", ",", "xcontext", ".", "getLocale", "(", ")", ",", "ScriptContext", ".", "ENGINE_SCOPE", ")", ";", "}"], "idx": 73931, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "6a139c84f92", "function_name": "initialize", "body_hash": "8e645fd9fe6ca8cc2d02540164bb9f8a0b1e5b1f"}
{"code": "private void copyJarEntryTrimmingBasePath(JarFile jarFile,\n            ZipEntry jarEntry, String basePath, File outputDirectory) {\n        String fullPath = jarEntry.getName();\n        String relativePath = fullPath\n                .substring(fullPath.toLowerCase(Locale.ENGLISH)\n                        .indexOf(basePath.toLowerCase(Locale.ENGLISH))\n                        + basePath.length());\n        File target = new File(outputDirectory, relativePath);\n        try {\n            if (!target.exists()\n                    || !hasSameContent(jarFile.getInputStream(jarEntry),\n                            target)) {\n                FileUtils.copyInputStreamToFile(\n                        jarFile.getInputStream(jarEntry), target);\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(String.format(\n                    \"Failed to extract jar entry '%s' from jarFile\", jarEntry),\n                    e);\n        }\n    }", "code_tokens": ["private", "void", "copyJarEntryTrimmingBasePath", "(", "JarFile", "jarFile", ",", "ZipEntry", "jarEntry", ",", "String", "basePath", ",", "File", "outputDirectory", ")", "{", "String", "fullPath", "=", "jarEntry", ".", "getName", "(", ")", ";", "String", "relativePath", "=", "fullPath", ".", "substring", "(", "fullPath", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ".", "indexOf", "(", "basePath", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ")", "+", "basePath", ".", "length", "(", ")", ")", ";", "File", "target", "=", "new", "File", "(", "outputDirectory", ",", "relativePath", ")", ";", "try", "{", "if", "(", "!", "target", ".", "exists", "(", ")", "||", "!", "hasSameContent", "(", "jarFile", ".", "getInputStream", "(", "jarEntry", ")", ",", "target", ")", ")", "{", "FileUtils", ".", "copyInputStreamToFile", "(", "jarFile", ".", "getInputStream", "(", "jarEntry", ")", ",", "target", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "UncheckedIOException", "(", "String", ".", "format", "(", "\"", "Failed to extract jar entry '%s' from jarFile", "\"", ",", "jarEntry", ")", ",", "e", ")", ";", "}", "}"], "idx": 110819, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "dde115adfbcc9484e60a34d603251edf94fae529", "function_name": "copyJarEntryTrimmingBasePath", "body_hash": "d792841da49b92956841a8abaa5ad1e3faddb654"}
{"code": "protected Key engineDoPhase(\n        Key     key,\n        boolean lastPhase) \n        throws InvalidKeyException, IllegalStateException\n    {\n        if (x == null)\n        {\n            throw new IllegalStateException(\"Diffie-Hellman not initialised.\");\n        }\n\n        if (!(key instanceof DHPublicKey))\n        {\n            throw new InvalidKeyException(\"DHKeyAgreement doPhase requires DHPublicKey\");\n        }\n        DHPublicKey pubKey = (DHPublicKey)key;\n\n        if (!pubKey.getParams().getG().equals(g) || !pubKey.getParams().getP().equals(p))\n        {\n            throw new InvalidKeyException(\"DHPublicKey not for this KeyAgreement!\");\n        }\n\n        BigInteger peerY = ((DHPublicKey)key).getY();\n        if (peerY == null || peerY.compareTo(TWO) < 0\n            || peerY.compareTo(p.subtract(ONE)) >= 0)\n        {\n            throw new InvalidKeyException(\"Invalid DH PublicKey\");\n        }\n\n        result = peerY.modPow(x, p);\n        if (result.compareTo(ONE) == 0)\n        {\n            throw new InvalidKeyException(\"Shared key can't be 1\");\n        }\n\n        if (lastPhase)\n        {\n            return null;\n        }\n\n        return new BCDHPublicKey(result, pubKey.getParams());\n    }", "code_tokens": ["protected", "Key", "engineDoPhase", "(", "Key", "key", ",", "boolean", "lastPhase", ")", "throws", "InvalidKeyException", ",", "IllegalStateException", "{", "if", "(", "x", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "Diffie-Hellman not initialised.", "\"", ")", ";", "}", "if", "(", "!", "(", "key", "instanceof", "DHPublicKey", ")", ")", "{", "throw", "new", "InvalidKeyException", "(", "\"", "DHKeyAgreement doPhase requires DHPublicKey", "\"", ")", ";", "}", "DHPublicKey", "pubKey", "=", "(", "DHPublicKey", ")", "key", ";", "if", "(", "!", "pubKey", ".", "getParams", "(", ")", ".", "getG", "(", ")", ".", "equals", "(", "g", ")", "||", "!", "pubKey", ".", "getParams", "(", ")", ".", "getP", "(", ")", ".", "equals", "(", "p", ")", ")", "{", "throw", "new", "InvalidKeyException", "(", "\"", "DHPublicKey not for this KeyAgreement!", "\"", ")", ";", "}", "BigInteger", "peerY", "=", "(", "(", "DHPublicKey", ")", "key", ")", ".", "getY", "(", ")", ";", "if", "(", "peerY", "==", "null", "||", "peerY", ".", "compareTo", "(", "TWO", ")", "<", "0", "||", "peerY", ".", "compareTo", "(", "p", ".", "subtract", "(", "ONE", ")", ")", ">=", "0", ")", "{", "throw", "new", "InvalidKeyException", "(", "\"", "Invalid DH PublicKey", "\"", ")", ";", "}", "result", "=", "peerY", ".", "modPow", "(", "x", ",", "p", ")", ";", "if", "(", "result", ".", "compareTo", "(", "ONE", ")", "==", "0", ")", "{", "throw", "new", "InvalidKeyException", "(", "\"", "Shared key can't be 1", "\"", ")", ";", "}", "if", "(", "lastPhase", ")", "{", "return", "null", ";", "}", "return", "new", "BCDHPublicKey", "(", "result", ",", "pubKey", ".", "getParams", "(", ")", ")", ";", "}"], "idx": 42121, "cwe": "CWE-320", "target": 0, "status": "FIXED", "commit": "1127131c89021612c6eefa26dbe5714c194e7495", "function_name": "engineDoPhase", "body_hash": "d384eb778b41bbce8dc0a7e0437ac3b7d2068ead"}
{"code": "@Override\n\tpublic void convertInput()\n\t{\n\t\tfinal PolicyFactory policy = this.newPolicyFactory();\n\t\tfinal String input = this.textarea.getConvertedInput();\n\n\t\tthis.setConvertedInput(policy.sanitize(input));\n\t}", "code_tokens": ["@", "Override", "public", "void", "convertInput", "(", ")", "{", "final", "PolicyFactory", "policy", "=", "this", ".", "newPolicyFactory", "(", ")", ";", "final", "String", "input", "=", "this", ".", "textarea", ".", "getConvertedInput", "(", ")", ";", "this", ".", "setConvertedInput", "(", "policy", ".", "sanitize", "(", "input", ")", ")", ";", "}"], "idx": 81703, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "936c12a2db262cf471c781f0d3c0d0ad61c35c7", "function_name": "convertInput", "body_hash": "3609d4a4ae0adf206cb12e99191ff6a319796fee"}
{"code": "protected boolean evaluate(InputSource inputSource)\n   {\n      try\n      {\n         DocumentBuilder dbuilder = createDocumentBuilder();\n         Document doc = dbuilder.parse(inputSource);\n\n         //An XPath expression could return a true or false value instead of a node.\n         //eval() is a better way to determine the boolean value of the exp.\n         //For compliance with legacy behavior where selecting an empty node returns true,\n         //selectNodeIterator is attempted in case of a failure.\n\n         CachedXPathAPI cachedXPathAPI = new CachedXPathAPI();\n         XObject result = cachedXPathAPI.eval(doc, xpath);\n         if (result.bool())\n            return true;\n         else\n         {\n            NodeIterator iterator = cachedXPathAPI.selectNodeIterator(doc, xpath);\n            return (iterator.nextNode() != null);\n         }\n      }\n      catch (Throwable e)\n      {\n         return false;\n      }\n   }", "code_tokens": ["protected", "boolean", "evaluate", "(", "InputSource", "inputSource", ")", "{", "try", "{", "DocumentBuilder", "dbuilder", "=", "createDocumentBuilder", "(", ")", ";", "Document", "doc", "=", "dbuilder", ".", "parse", "(", "inputSource", ")", ";", "CachedXPathAPI", "cachedXPathAPI", "=", "new", "CachedXPathAPI", "(", ")", ";", "XObject", "result", "=", "cachedXPathAPI", ".", "eval", "(", "doc", ",", "xpath", ")", ";", "if", "(", "result", ".", "bool", "(", ")", ")", "return", "true", ";", "else", "{", "NodeIterator", "iterator", "=", "cachedXPathAPI", ".", "selectNodeIterator", "(", "doc", ",", "xpath", ")", ";", "return", "(", "iterator", ".", "nextNode", "(", ")", "!=", "null", ")", ";", "}", "}", "catch", "(", "Throwable", "e", ")", "{", "return", "false", ";", "}", "}"], "idx": 66020, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "48d9951d879e0c8cbb59d4b64ab59d53ef88310d", "function_name": "evaluate", "body_hash": "e521946d51712c0c58b7d2867d4b55225bad80ce"}
{"code": "@Override\n    public void setServerUrl(final String url) {\n        super.setServerUrl(url);\n    }", "code_tokens": ["@", "Override", "public", "void", "setServerUrl", "(", "final", "String", "url", ")", "{", "super", ".", "setServerUrl", "(", "url", ")", ";", "}"], "idx": 98073, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "a59ca1cc8839e7d7be48d3f2d7977747a59bd107", "function_name": "setServerUrl", "body_hash": "ec4fdafae9a365d335778a587faba61441aa4769"}
{"code": "public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        if(path.length()==0)\n            path = \"/\";\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        try {\n            rsp.serveLocalizedFile(req, wrapper.baseResourceURL.toURI().resolve(new URI(null, '.' + path, null)).toURL(), expires);\n        } catch (URISyntaxException x) {\n            throw new IOException(x);\n        }\n    }", "code_tokens": ["public", "void", "doDynamic", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "req", ".", "getRestOfPath", "(", ")", ";", "if", "(", "path", ".", "length", "(", ")", "==", "0", ")", "path", "=", "\"", "/", "\"", ";", "String", "requestPath", "=", "req", ".", "getRequestURI", "(", ")", ".", "substring", "(", "req", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "boolean", "staticLink", "=", "requestPath", ".", "startsWith", "(", "\"", "/static/", "\"", ")", ";", "long", "expires", "=", "staticLink", "?", "TimeUnit2", ".", "DAYS", ".", "toMillis", "(", "365", ")", ":", "-", "1", ";", "try", "{", "rsp", ".", "serveLocalizedFile", "(", "req", ",", "wrapper", ".", "baseResourceURL", ".", "toURI", "(", ")", ".", "resolve", "(", "new", "URI", "(", "null", ",", "'.'", "+", "path", ",", "null", ")", ")", ".", "toURL", "(", ")", ",", "expires", ")", ";", "}", "catch", "(", "URISyntaxException", "x", ")", "{", "throw", "new", "IOException", "(", "x", ")", ";", "}", "}"], "idx": 15669, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "f0a29b562e14d837912c6b35fa4e81478563813a", "function_name": "doDynamic", "body_hash": "0b1bb4d10801ffb0bc68a2e3fef2bc50e996a508"}
{"code": "protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\"java.beans.EventHandler\", \"javax.imageio.ImageIO$ContainsFilter\"});\n        denyTypesByRegExp(new Pattern[]{LAZY_ITERATORS, JAVAX_CRYPTO});\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }", "code_tokens": ["protected", "void", "setupSecurity", "(", ")", "{", "if", "(", "securityMapper", "==", "null", ")", "{", "return", ";", "}", "addPermission", "(", "AnyTypePermission", ".", "ANY", ")", ";", "denyTypes", "(", "new", "String", "[", "]", "{", "\"", "java.beans.EventHandler", "\"", ",", "\"", "javax.imageio.ImageIO$ContainsFilter", "\"", "}", ")", ";", "denyTypesByRegExp", "(", "new", "Pattern", "[", "]", "{", "LAZY_ITERATORS", ",", "JAVAX_CRYPTO", "}", ")", ";", "allowTypeHierarchy", "(", "Exception", ".", "class", ")", ";", "securityInitialized", "=", "false", ";", "}"], "idx": 77347, "cwe": "CWE-78", "target": 1, "status": "VULNERABLE", "commit": "f8abc1ac909d26c69c752ba4a987b7f21c4dccd0", "function_name": "setupSecurity", "body_hash": "75082f96705b5520a92a4d8365ac362e30fdaa07"}
{"code": "default URL findConfigFile( final String name ) {\n        LogManager.getLogger( Engine.class ).info( \"looking for \" + name + \" inside WEB-INF \" );\n        // Try creating an absolute path first\n        File defaultFile = null;\n        if( getRootPath() != null ) {\n            defaultFile = new File( getRootPath() + \"/WEB-INF/\" + name );\n        }\n        if ( defaultFile != null && defaultFile.exists() ) {\n            try {\n                return defaultFile.toURI().toURL();\n            } catch ( final MalformedURLException e ) {\n                // Shouldn't happen, but log it if it does\n                LogManager.getLogger( Engine.class ).warn( \"Malformed URL: \" + e.getMessage() );\n            }\n        }\n\n        // Ok, the absolute path didn't work; try other methods\n        URL path = null;\n\n        if( getServletContext() != null ) {\n            final File tmpFile;\n            try {\n                tmpFile = File.createTempFile( \"temp.\" + name, \"\" );\n            } catch( final IOException e ) {\n                LogManager.getLogger( Engine.class ).error( \"unable to create a temp file to load onto the policy\", e );\n                return null;\n            }\n            tmpFile.deleteOnExit();\n            LogManager.getLogger( Engine.class ).info( \"looking for /\" + name + \" on classpath\" );\n            //  create a tmp file of the policy loaded as an InputStream and return the URL to it\n            try( final InputStream is = Engine.class.getResourceAsStream( \"/\" + name );\n                final OutputStream os = Files.newOutputStream( tmpFile.toPath() ) ) {\n                if( is == null ) {\n                    throw new FileNotFoundException( name + \" not found\" );\n                }\n                final URL url = getServletContext().getResource( \"/WEB-INF/\" + name );\n                if( url != null ) {\n                    return url;\n                }\n\n                final byte[] buff = new byte[1024];\n                int bytes;\n                while( ( bytes = is.read( buff ) ) != -1 ) {\n                    os.write( buff, 0, bytes );\n                }\n\n                path = tmpFile.toURI().toURL();\n            } catch( final MalformedURLException e ) {\n                // This should never happen unless I screw up\n                LogManager.getLogger( Engine.class ).fatal( \"Your code is b0rked.  You are a bad person.\", e );\n            } catch( final IOException e ) {\n                LogManager.getLogger( Engine.class ).error( \"failed to load security policy from file \" + name + \",stacktrace follows\", e );\n            }\n        }\n        return path;\n    }", "code_tokens": ["default", "URL", "findConfigFile", "(", "final", "String", "name", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "info", "(", "\"", "looking for ", "\"", "+", "name", "+", "\"", " inside WEB-INF ", "\"", ")", ";", "File", "defaultFile", "=", "null", ";", "if", "(", "getRootPath", "(", ")", "!=", "null", ")", "{", "defaultFile", "=", "new", "File", "(", "getRootPath", "(", ")", "+", "\"", "/WEB-INF/", "\"", "+", "name", ")", ";", "}", "if", "(", "defaultFile", "!=", "null", "&&", "defaultFile", ".", "exists", "(", ")", ")", "{", "try", "{", "return", "defaultFile", ".", "toURI", "(", ")", ".", "toURL", "(", ")", ";", "}", "catch", "(", "final", "MalformedURLException", "e", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "warn", "(", "\"", "Malformed URL: ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "URL", "path", "=", "null", ";", "if", "(", "getServletContext", "(", ")", "!=", "null", ")", "{", "final", "File", "tmpFile", ";", "try", "{", "tmpFile", "=", "File", ".", "createTempFile", "(", "\"", "temp.", "\"", "+", "name", ",", "\"", "\"", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "error", "(", "\"", "unable to create a temp file to load onto the policy", "\"", ",", "e", ")", ";", "return", "null", ";", "}", "tmpFile", ".", "deleteOnExit", "(", ")", ";", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "info", "(", "\"", "looking for /", "\"", "+", "name", "+", "\"", " on classpath", "\"", ")", ";", "try", "(", "final", "InputStream", "is", "=", "Engine", ".", "class", ".", "getResourceAsStream", "(", "\"", "/", "\"", "+", "name", ")", ";", "final", "OutputStream", "os", "=", "Files", ".", "newOutputStream", "(", "tmpFile", ".", "toPath", "(", ")", ")", ")", "{", "if", "(", "is", "==", "null", ")", "{", "throw", "new", "FileNotFoundException", "(", "name", "+", "\"", " not found", "\"", ")", ";", "}", "final", "URL", "url", "=", "getServletContext", "(", ")", ".", "getResource", "(", "\"", "/WEB-INF/", "\"", "+", "name", ")", ";", "if", "(", "url", "!=", "null", ")", "{", "return", "url", ";", "}", "final", "byte", "[", "]", "buff", "=", "new", "byte", "[", "1024", "]", ";", "int", "bytes", ";", "while", "(", "(", "bytes", "=", "is", ".", "read", "(", "buff", ")", ")", "!=", "-", "1", ")", "{", "os", ".", "write", "(", "buff", ",", "0", ",", "bytes", ")", ";", "}", "path", "=", "tmpFile", ".", "toURI", "(", ")", ".", "toURL", "(", ")", ";", "}", "catch", "(", "final", "MalformedURLException", "e", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "fatal", "(", "\"", "Your code is b0rked.  You are a bad person.", "\"", ",", "e", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "error", "(", "\"", "failed to load security policy from file ", "\"", "+", "name", "+", "\"", ",stacktrace follows", "\"", ",", "e", ")", ";", "}", "}", "return", "path", ";", "}"], "idx": 36483, "cwe": "CWE-276", "target": 0, "status": "FIXED", "commit": "800196dc239553ee2ea8f71754f8ee3f85bcf70f", "function_name": "findConfigFile", "body_hash": "b4decef6f46ede404c45912ef7d5e6dd5eece2c8"}
{"code": "private T buildFromConnection(Http2Connection connection) {\n        Long maxHeaderListSize = initialSettings.maxHeaderListSize();\n        Http2FrameReader reader = new DefaultHttp2FrameReader(new DefaultHttp2HeadersDecoder(isValidateHeaders(),\n                maxHeaderListSize == null ? DEFAULT_HEADER_LIST_SIZE : maxHeaderListSize,\n                /* initialHuffmanDecodeCapacity= */ -1));\n        Http2FrameWriter writer = encoderIgnoreMaxHeaderListSize == null ?\n                new DefaultHttp2FrameWriter(headerSensitivityDetector()) :\n                new DefaultHttp2FrameWriter(headerSensitivityDetector(), encoderIgnoreMaxHeaderListSize);\n\n        if (frameLogger != null) {\n            reader = new Http2InboundFrameLogger(reader, frameLogger);\n            writer = new Http2OutboundFrameLogger(writer, frameLogger);\n        }\n\n        Http2ConnectionEncoder encoder = new DefaultHttp2ConnectionEncoder(connection, writer);\n        boolean encoderEnforceMaxConcurrentStreams = encoderEnforceMaxConcurrentStreams();\n\n        if (maxQueuedControlFrames != 0) {\n            encoder = new Http2ControlFrameLimitEncoder(encoder, maxQueuedControlFrames);\n        }\n        if (encoderEnforceMaxConcurrentStreams) {\n            if (connection.isServer()) {\n                encoder.close();\n                reader.close();\n                throw new IllegalArgumentException(\n                        \"encoderEnforceMaxConcurrentStreams: \" + encoderEnforceMaxConcurrentStreams +\n                        \" not supported for server\");\n            }\n            encoder = new StreamBufferingEncoder(encoder);\n        }\n\n        DefaultHttp2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, reader,\n                promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame());\n        return buildFromCodec(decoder, encoder);\n    }", "code_tokens": ["private", "T", "buildFromConnection", "(", "Http2Connection", "connection", ")", "{", "Long", "maxHeaderListSize", "=", "initialSettings", ".", "maxHeaderListSize", "(", ")", ";", "Http2FrameReader", "reader", "=", "new", "DefaultHttp2FrameReader", "(", "new", "DefaultHttp2HeadersDecoder", "(", "isValidateHeaders", "(", ")", ",", "maxHeaderListSize", "==", "null", "?", "DEFAULT_HEADER_LIST_SIZE", ":", "maxHeaderListSize", ",", "-", "1", ")", ")", ";", "Http2FrameWriter", "writer", "=", "encoderIgnoreMaxHeaderListSize", "==", "null", "?", "new", "DefaultHttp2FrameWriter", "(", "headerSensitivityDetector", "(", ")", ")", ":", "new", "DefaultHttp2FrameWriter", "(", "headerSensitivityDetector", "(", ")", ",", "encoderIgnoreMaxHeaderListSize", ")", ";", "if", "(", "frameLogger", "!=", "null", ")", "{", "reader", "=", "new", "Http2InboundFrameLogger", "(", "reader", ",", "frameLogger", ")", ";", "writer", "=", "new", "Http2OutboundFrameLogger", "(", "writer", ",", "frameLogger", ")", ";", "}", "Http2ConnectionEncoder", "encoder", "=", "new", "DefaultHttp2ConnectionEncoder", "(", "connection", ",", "writer", ")", ";", "boolean", "encoderEnforceMaxConcurrentStreams", "=", "encoderEnforceMaxConcurrentStreams", "(", ")", ";", "if", "(", "maxQueuedControlFrames", "!=", "0", ")", "{", "encoder", "=", "new", "Http2ControlFrameLimitEncoder", "(", "encoder", ",", "maxQueuedControlFrames", ")", ";", "}", "if", "(", "encoderEnforceMaxConcurrentStreams", ")", "{", "if", "(", "connection", ".", "isServer", "(", ")", ")", "{", "encoder", ".", "close", "(", ")", ";", "reader", ".", "close", "(", ")", ";", "throw", "new", "IllegalArgumentException", "(", "\"", "encoderEnforceMaxConcurrentStreams: ", "\"", "+", "encoderEnforceMaxConcurrentStreams", "+", "\"", " not supported for server", "\"", ")", ";", "}", "encoder", "=", "new", "StreamBufferingEncoder", "(", "encoder", ")", ";", "}", "DefaultHttp2ConnectionDecoder", "decoder", "=", "new", "DefaultHttp2ConnectionDecoder", "(", "connection", ",", "encoder", ",", "reader", ",", "promisedRequestVerifier", "(", ")", ",", "isAutoAckSettingsFrame", "(", ")", ",", "isAutoAckPingFrame", "(", ")", ")", ";", "return", "buildFromCodec", "(", "decoder", ",", "encoder", ")", ";", "}"], "idx": 75743, "cwe": "CWE-770", "target": 0, "status": "FIXED", "commit": "cecb46a3dd", "function_name": "buildFromConnection", "body_hash": "cce36dbeaae30d9d32c865bc766175adca005dd4"}
{"code": "@Override\n\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t\tif (this.jsonPrefix != null) {\n\t\t\tgenerator.writeRaw(this.jsonPrefix);\n\t\t}\n\t}", "code_tokens": ["@", "Override", "protected", "void", "writePrefix", "(", "JsonGenerator", "generator", ",", "Object", "object", ")", "throws", "IOException", "{", "if", "(", "this", ".", "jsonPrefix", "!=", "null", ")", "{", "generator", ".", "writeRaw", "(", "this", ".", "jsonPrefix", ")", ";", "}", "}"], "idx": 81893, "cwe": "CWE-829", "target": 0, "status": "FIXED", "commit": "ac37b678a3ac9ee541a10e8ad74d612bb9ec5b88", "function_name": "writePrefix", "body_hash": "69fa2eda3d92ddc21cc29591cc3ac19bf4bd892c"}
{"code": "protected SCIMFilter scimFilter(String filter) throws SCIMException {\n        SCIMFilter scimFilter;\n        try {\n            scimFilter = SCIMFilter.parse(filter);\n        } catch (SCIMException e) {\n            logger.debug(\"Attempting legacy scim filter conversion for [\" + filter + \"]\", e);\n            filter = filter.replaceAll(\"'\",\"\\\"\");\n            scimFilter = SCIMFilter.parse(filter);\n        }\n        validateFilterAttributes(scimFilter);\n        return scimFilter;\n    }", "code_tokens": ["protected", "SCIMFilter", "scimFilter", "(", "String", "filter", ")", "throws", "SCIMException", "{", "SCIMFilter", "scimFilter", ";", "try", "{", "scimFilter", "=", "SCIMFilter", ".", "parse", "(", "filter", ")", ";", "}", "catch", "(", "SCIMException", "e", ")", "{", "logger", ".", "debug", "(", "\"", "Attempting legacy scim filter conversion for [", "\"", "+", "filter", "+", "\"", "]", "\"", ",", "e", ")", ";", "filter", "=", "filter", ".", "replaceAll", "(", "\"", "'", "\"", ",", "\"", "\\\"", "\"", ")", ";", "scimFilter", "=", "SCIMFilter", ".", "parse", "(", "filter", ")", ";", "}", "validateFilterAttributes", "(", "scimFilter", ")", ";", "return", "scimFilter", ";", "}"], "idx": 90827, "cwe": "CWE-89", "target": 0, "status": "FIXED", "commit": "01edea6337c8ddb2ab80906aa1254d3c1dc02fb", "function_name": "scimFilter", "body_hash": "a7ec1006b1462baabdaa3b7d9f6ce133b6b7b74e"}
{"code": "public CloseableHttpClient build() {\n        // Create main request executor\n        HttpRequestExecutor requestExec = this.requestExec;\n        if (requestExec == null) {\n            requestExec = new HttpRequestExecutor();\n        }\n        HttpClientConnectionManager connManager = this.connManager;\n        if (connManager == null) {\n            LayeredConnectionSocketFactory sslSocketFactory = this.sslSocketFactory;\n            if (sslSocketFactory == null) {\n                X509HostnameVerifier hostnameVerifier = this.hostnameVerifier;\n                if (hostnameVerifier == null) {\n                    hostnameVerifier = SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER;\n                }\n                if (sslcontext != null) {\n                    sslSocketFactory = new SSLConnectionSocketFactory(sslcontext, hostnameVerifier);\n                } else {\n                    if (systemProperties) {\n                        sslSocketFactory = new SSLConnectionSocketFactory(\n                                (javax.net.ssl.SSLSocketFactory) javax.net.ssl.SSLSocketFactory.getDefault(),\n                                split(System.getProperty(\"https.protocols\")),\n                                split(System.getProperty(\"https.cipherSuites\")),\n                                hostnameVerifier);\n                    } else {\n                        sslSocketFactory = new SSLConnectionSocketFactory(\n                                SSLContexts.createDefault(),\n                                hostnameVerifier);\n                    }\n                }\n            }\n            @SuppressWarnings(\"resource\")\n            final PoolingHttpClientConnectionManager poolingmgr = new PoolingHttpClientConnectionManager(\n                    RegistryBuilder.<ConnectionSocketFactory>create()\n                        .register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n                        .register(\"https\", sslSocketFactory)\n                        .build());\n            if (defaultSocketConfig != null) {\n                poolingmgr.setDefaultSocketConfig(defaultSocketConfig);\n            }\n            if (defaultConnectionConfig != null) {\n                poolingmgr.setDefaultConnectionConfig(defaultConnectionConfig);\n            }\n            if (systemProperties) {\n                String s = System.getProperty(\"http.keepAlive\", \"true\");\n                if (\"true\".equalsIgnoreCase(s)) {\n                    s = System.getProperty(\"http.maxConnections\", \"5\");\n                    final int max = Integer.parseInt(s);\n                    poolingmgr.setDefaultMaxPerRoute(max);\n                    poolingmgr.setMaxTotal(2 * max);\n                }\n            }\n            if (maxConnTotal > 0) {\n                poolingmgr.setMaxTotal(maxConnTotal);\n            }\n            if (maxConnPerRoute > 0) {\n                poolingmgr.setDefaultMaxPerRoute(maxConnPerRoute);\n            }\n            connManager = poolingmgr;\n        }\n        ConnectionReuseStrategy reuseStrategy = this.reuseStrategy;\n        if (reuseStrategy == null) {\n            if (systemProperties) {\n                final String s = System.getProperty(\"http.keepAlive\", \"true\");\n                if (\"true\".equalsIgnoreCase(s)) {\n                    reuseStrategy = DefaultConnectionReuseStrategy.INSTANCE;\n                } else {\n                    reuseStrategy = NoConnectionReuseStrategy.INSTANCE;\n                }\n            } else {\n                reuseStrategy = DefaultConnectionReuseStrategy.INSTANCE;\n            }\n        }\n        ConnectionKeepAliveStrategy keepAliveStrategy = this.keepAliveStrategy;\n        if (keepAliveStrategy == null) {\n            keepAliveStrategy = DefaultConnectionKeepAliveStrategy.INSTANCE;\n        }\n        AuthenticationStrategy targetAuthStrategy = this.targetAuthStrategy;\n        if (targetAuthStrategy == null) {\n            targetAuthStrategy = TargetAuthenticationStrategy.INSTANCE;\n        }\n        AuthenticationStrategy proxyAuthStrategy = this.proxyAuthStrategy;\n        if (proxyAuthStrategy == null) {\n            proxyAuthStrategy = ProxyAuthenticationStrategy.INSTANCE;\n        }\n        UserTokenHandler userTokenHandler = this.userTokenHandler;\n        if (userTokenHandler == null) {\n            if (!connectionStateDisabled) {\n                userTokenHandler = DefaultUserTokenHandler.INSTANCE;\n            } else {\n                userTokenHandler = NoopUserTokenHandler.INSTANCE;\n            }\n        }\n        ClientExecChain execChain = new MainClientExec(\n                requestExec,\n                connManager,\n                reuseStrategy,\n                keepAliveStrategy,\n                targetAuthStrategy,\n                proxyAuthStrategy,\n                userTokenHandler);\n\n        execChain = decorateMainExec(execChain);\n\n        HttpProcessor httpprocessor = this.httpprocessor;\n        if (httpprocessor == null) {\n\n            String userAgent = this.userAgent;\n            if (userAgent == null) {\n                if (systemProperties) {\n                    userAgent = System.getProperty(\"http.agent\");\n                }\n                if (userAgent == null) {\n                    userAgent = DEFAULT_USER_AGENT;\n                }\n            }\n\n            final HttpProcessorBuilder b = HttpProcessorBuilder.create();\n            if (requestFirst != null) {\n                for (final HttpRequestInterceptor i: requestFirst) {\n                    b.addFirst(i);\n                }\n            }\n            if (responseFirst != null) {\n                for (final HttpResponseInterceptor i: responseFirst) {\n                    b.addFirst(i);\n                }\n            }\n            b.addAll(\n                    new RequestDefaultHeaders(defaultHeaders),\n                    new RequestContent(),\n                    new RequestTargetHost(),\n                    new RequestClientConnControl(),\n                    new RequestUserAgent(userAgent),\n                    new RequestExpectContinue());\n            if (!cookieManagementDisabled) {\n                b.add(new RequestAddCookies());\n            }\n            if (!contentCompressionDisabled) {\n                b.add(new RequestAcceptEncoding());\n            }\n            if (!authCachingDisabled) {\n                b.add(new RequestAuthCache());\n            }\n            if (!cookieManagementDisabled) {\n                b.add(new ResponseProcessCookies());\n            }\n            if (!contentCompressionDisabled) {\n                b.add(new ResponseContentEncoding());\n            }\n            if (requestLast != null) {\n                for (final HttpRequestInterceptor i: requestLast) {\n                    b.addLast(i);\n                }\n            }\n            if (responseLast != null) {\n                for (final HttpResponseInterceptor i: responseLast) {\n                    b.addLast(i);\n                }\n            }\n            httpprocessor = b.build();\n        }\n        execChain = new ProtocolExec(execChain, httpprocessor);\n\n        execChain = decorateProtocolExec(execChain);\n\n        // Add request retry executor, if not disabled\n        if (!automaticRetriesDisabled) {\n            HttpRequestRetryHandler retryHandler = this.retryHandler;\n            if (retryHandler == null) {\n                retryHandler = DefaultHttpRequestRetryHandler.INSTANCE;\n            }\n            execChain = new RetryExec(execChain, retryHandler);\n        }\n\n        HttpRoutePlanner routePlanner = this.routePlanner;\n        if (routePlanner == null) {\n            SchemePortResolver schemePortResolver = this.schemePortResolver;\n            if (schemePortResolver == null) {\n                schemePortResolver = DefaultSchemePortResolver.INSTANCE;\n            }\n            if (proxy != null) {\n                routePlanner = new DefaultProxyRoutePlanner(proxy, schemePortResolver);\n            } else if (systemProperties) {\n                routePlanner = new SystemDefaultRoutePlanner(\n                        schemePortResolver, ProxySelector.getDefault());\n            } else {\n                routePlanner = new DefaultRoutePlanner(schemePortResolver);\n            }\n        }\n        // Add redirect executor, if not disabled\n        if (!redirectHandlingDisabled) {\n            RedirectStrategy redirectStrategy = this.redirectStrategy;\n            if (redirectStrategy == null) {\n                redirectStrategy = DefaultRedirectStrategy.INSTANCE;\n            }\n            execChain = new RedirectExec(execChain, routePlanner, redirectStrategy);\n        }\n\n        // Optionally, add service unavailable retry executor\n        final ServiceUnavailableRetryStrategy serviceUnavailStrategy = this.serviceUnavailStrategy;\n        if (serviceUnavailStrategy != null) {\n            execChain = new ServiceUnavailableRetryExec(execChain, serviceUnavailStrategy);\n        }\n        // Optionally, add connection back-off executor\n        final BackoffManager backoffManager = this.backoffManager;\n        final ConnectionBackoffStrategy connectionBackoffStrategy = this.connectionBackoffStrategy;\n        if (backoffManager != null && connectionBackoffStrategy != null) {\n            execChain = new BackoffStrategyExec(execChain, connectionBackoffStrategy, backoffManager);\n        }\n\n        Lookup<AuthSchemeProvider> authSchemeRegistry = this.authSchemeRegistry;\n        if (authSchemeRegistry == null) {\n            authSchemeRegistry = RegistryBuilder.<AuthSchemeProvider>create()\n                .register(AuthSchemes.BASIC, new BasicSchemeFactory())\n                .register(AuthSchemes.DIGEST, new DigestSchemeFactory())\n                .register(AuthSchemes.NTLM, new NTLMSchemeFactory())\n                .register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory())\n                .register(AuthSchemes.KERBEROS, new KerberosSchemeFactory())\n                .build();\n        }\n        Lookup<CookieSpecProvider> cookieSpecRegistry = this.cookieSpecRegistry;\n        if (cookieSpecRegistry == null) {\n            cookieSpecRegistry = RegistryBuilder.<CookieSpecProvider>create()\n                .register(CookieSpecs.BEST_MATCH, new BestMatchSpecFactory())\n                .register(CookieSpecs.STANDARD, new RFC2965SpecFactory())\n                .register(CookieSpecs.BROWSER_COMPATIBILITY, new BrowserCompatSpecFactory())\n                .register(CookieSpecs.NETSCAPE, new NetscapeDraftSpecFactory())\n                .register(CookieSpecs.IGNORE_COOKIES, new IgnoreSpecFactory())\n                .register(\"rfc2109\", new RFC2109SpecFactory())\n                .register(\"rfc2965\", new RFC2965SpecFactory())\n                .build();\n        }\n\n        CookieStore defaultCookieStore = this.cookieStore;\n        if (defaultCookieStore == null) {\n            defaultCookieStore = new BasicCookieStore();\n        }\n\n        CredentialsProvider defaultCredentialsProvider = this.credentialsProvider;\n        if (defaultCredentialsProvider == null) {\n            if (systemProperties) {\n                defaultCredentialsProvider = new SystemDefaultCredentialsProvider();\n            } else {\n                defaultCredentialsProvider = new BasicCredentialsProvider();\n            }\n        }\n\n        return new InternalHttpClient(\n                execChain,\n                connManager,\n                routePlanner,\n                cookieSpecRegistry,\n                authSchemeRegistry,\n                defaultCookieStore,\n                defaultCredentialsProvider,\n                defaultRequestConfig != null ? defaultRequestConfig : RequestConfig.DEFAULT,\n                closeables != null ? new ArrayList<Closeable>(closeables) : null);\n    }", "code_tokens": ["public", "CloseableHttpClient", "build", "(", ")", "{", "HttpRequestExecutor", "requestExec", "=", "this", ".", "requestExec", ";", "if", "(", "requestExec", "==", "null", ")", "{", "requestExec", "=", "new", "HttpRequestExecutor", "(", ")", ";", "}", "HttpClientConnectionManager", "connManager", "=", "this", ".", "connManager", ";", "if", "(", "connManager", "==", "null", ")", "{", "LayeredConnectionSocketFactory", "sslSocketFactory", "=", "this", ".", "sslSocketFactory", ";", "if", "(", "sslSocketFactory", "==", "null", ")", "{", "X509HostnameVerifier", "hostnameVerifier", "=", "this", ".", "hostnameVerifier", ";", "if", "(", "hostnameVerifier", "==", "null", ")", "{", "hostnameVerifier", "=", "SSLConnectionSocketFactory", ".", "BROWSER_COMPATIBLE_HOSTNAME_VERIFIER", ";", "}", "if", "(", "sslcontext", "!=", "null", ")", "{", "sslSocketFactory", "=", "new", "SSLConnectionSocketFactory", "(", "sslcontext", ",", "hostnameVerifier", ")", ";", "}", "else", "{", "if", "(", "systemProperties", ")", "{", "sslSocketFactory", "=", "new", "SSLConnectionSocketFactory", "(", "(", "javax", ".", "net", ".", "ssl", ".", "SSLSocketFactory", ")", "javax", ".", "net", ".", "ssl", ".", "SSLSocketFactory", ".", "getDefault", "(", ")", ",", "split", "(", "System", ".", "getProperty", "(", "\"", "https.protocols", "\"", ")", ")", ",", "split", "(", "System", ".", "getProperty", "(", "\"", "https.cipherSuites", "\"", ")", ")", ",", "hostnameVerifier", ")", ";", "}", "else", "{", "sslSocketFactory", "=", "new", "SSLConnectionSocketFactory", "(", "SSLContexts", ".", "createDefault", "(", ")", ",", "hostnameVerifier", ")", ";", "}", "}", "}", "@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "final", "PoolingHttpClientConnectionManager", "poolingmgr", "=", "new", "PoolingHttpClientConnectionManager", "(", "RegistryBuilder", ".", "<", "ConnectionSocketFactory", ">", "create", "(", ")", ".", "register", "(", "\"", "http", "\"", ",", "PlainConnectionSocketFactory", ".", "getSocketFactory", "(", ")", ")", ".", "register", "(", "\"", "https", "\"", ",", "sslSocketFactory", ")", ".", "build", "(", ")", ")", ";", "if", "(", "defaultSocketConfig", "!=", "null", ")", "{", "poolingmgr", ".", "setDefaultSocketConfig", "(", "defaultSocketConfig", ")", ";", "}", "if", "(", "defaultConnectionConfig", "!=", "null", ")", "{", "poolingmgr", ".", "setDefaultConnectionConfig", "(", "defaultConnectionConfig", ")", ";", "}", "if", "(", "systemProperties", ")", "{", "String", "s", "=", "System", ".", "getProperty", "(", "\"", "http.keepAlive", "\"", ",", "\"", "true", "\"", ")", ";", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "s", ")", ")", "{", "s", "=", "System", ".", "getProperty", "(", "\"", "http.maxConnections", "\"", ",", "\"", "5", "\"", ")", ";", "final", "int", "max", "=", "Integer", ".", "parseInt", "(", "s", ")", ";", "poolingmgr", ".", "setDefaultMaxPerRoute", "(", "max", ")", ";", "poolingmgr", ".", "setMaxTotal", "(", "2", "*", "max", ")", ";", "}", "}", "if", "(", "maxConnTotal", ">", "0", ")", "{", "poolingmgr", ".", "setMaxTotal", "(", "maxConnTotal", ")", ";", "}", "if", "(", "maxConnPerRoute", ">", "0", ")", "{", "poolingmgr", ".", "setDefaultMaxPerRoute", "(", "maxConnPerRoute", ")", ";", "}", "connManager", "=", "poolingmgr", ";", "}", "ConnectionReuseStrategy", "reuseStrategy", "=", "this", ".", "reuseStrategy", ";", "if", "(", "reuseStrategy", "==", "null", ")", "{", "if", "(", "systemProperties", ")", "{", "final", "String", "s", "=", "System", ".", "getProperty", "(", "\"", "http.keepAlive", "\"", ",", "\"", "true", "\"", ")", ";", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "s", ")", ")", "{", "reuseStrategy", "=", "DefaultConnectionReuseStrategy", ".", "INSTANCE", ";", "}", "else", "{", "reuseStrategy", "=", "NoConnectionReuseStrategy", ".", "INSTANCE", ";", "}", "}", "else", "{", "reuseStrategy", "=", "DefaultConnectionReuseStrategy", ".", "INSTANCE", ";", "}", "}", "ConnectionKeepAliveStrategy", "keepAliveStrategy", "=", "this", ".", "keepAliveStrategy", ";", "if", "(", "keepAliveStrategy", "==", "null", ")", "{", "keepAliveStrategy", "=", "DefaultConnectionKeepAliveStrategy", ".", "INSTANCE", ";", "}", "AuthenticationStrategy", "targetAuthStrategy", "=", "this", ".", "targetAuthStrategy", ";", "if", "(", "targetAuthStrategy", "==", "null", ")", "{", "targetAuthStrategy", "=", "TargetAuthenticationStrategy", ".", "INSTANCE", ";", "}", "AuthenticationStrategy", "proxyAuthStrategy", "=", "this", ".", "proxyAuthStrategy", ";", "if", "(", "proxyAuthStrategy", "==", "null", ")", "{", "proxyAuthStrategy", "=", "ProxyAuthenticationStrategy", ".", "INSTANCE", ";", "}", "UserTokenHandler", "userTokenHandler", "=", "this", ".", "userTokenHandler", ";", "if", "(", "userTokenHandler", "==", "null", ")", "{", "if", "(", "!", "connectionStateDisabled", ")", "{", "userTokenHandler", "=", "DefaultUserTokenHandler", ".", "INSTANCE", ";", "}", "else", "{", "userTokenHandler", "=", "NoopUserTokenHandler", ".", "INSTANCE", ";", "}", "}", "ClientExecChain", "execChain", "=", "new", "MainClientExec", "(", "requestExec", ",", "connManager", ",", "reuseStrategy", ",", "keepAliveStrategy", ",", "targetAuthStrategy", ",", "proxyAuthStrategy", ",", "userTokenHandler", ")", ";", "execChain", "=", "decorateMainExec", "(", "execChain", ")", ";", "HttpProcessor", "httpprocessor", "=", "this", ".", "httpprocessor", ";", "if", "(", "httpprocessor", "==", "null", ")", "{", "String", "userAgent", "=", "this", ".", "userAgent", ";", "if", "(", "userAgent", "==", "null", ")", "{", "if", "(", "systemProperties", ")", "{", "userAgent", "=", "System", ".", "getProperty", "(", "\"", "http.agent", "\"", ")", ";", "}", "if", "(", "userAgent", "==", "null", ")", "{", "userAgent", "=", "DEFAULT_USER_AGENT", ";", "}", "}", "final", "HttpProcessorBuilder", "b", "=", "HttpProcessorBuilder", ".", "create", "(", ")", ";", "if", "(", "requestFirst", "!=", "null", ")", "{", "for", "(", "final", "HttpRequestInterceptor", "i", ":", "requestFirst", ")", "{", "b", ".", "addFirst", "(", "i", ")", ";", "}", "}", "if", "(", "responseFirst", "!=", "null", ")", "{", "for", "(", "final", "HttpResponseInterceptor", "i", ":", "responseFirst", ")", "{", "b", ".", "addFirst", "(", "i", ")", ";", "}", "}", "b", ".", "addAll", "(", "new", "RequestDefaultHeaders", "(", "defaultHeaders", ")", ",", "new", "RequestContent", "(", ")", ",", "new", "RequestTargetHost", "(", ")", ",", "new", "RequestClientConnControl", "(", ")", ",", "new", "RequestUserAgent", "(", "userAgent", ")", ",", "new", "RequestExpectContinue", "(", ")", ")", ";", "if", "(", "!", "cookieManagementDisabled", ")", "{", "b", ".", "add", "(", "new", "RequestAddCookies", "(", ")", ")", ";", "}", "if", "(", "!", "contentCompressionDisabled", ")", "{", "b", ".", "add", "(", "new", "RequestAcceptEncoding", "(", ")", ")", ";", "}", "if", "(", "!", "authCachingDisabled", ")", "{", "b", ".", "add", "(", "new", "RequestAuthCache", "(", ")", ")", ";", "}", "if", "(", "!", "cookieManagementDisabled", ")", "{", "b", ".", "add", "(", "new", "ResponseProcessCookies", "(", ")", ")", ";", "}", "if", "(", "!", "contentCompressionDisabled", ")", "{", "b", ".", "add", "(", "new", "ResponseContentEncoding", "(", ")", ")", ";", "}", "if", "(", "requestLast", "!=", "null", ")", "{", "for", "(", "final", "HttpRequestInterceptor", "i", ":", "requestLast", ")", "{", "b", ".", "addLast", "(", "i", ")", ";", "}", "}", "if", "(", "responseLast", "!=", "null", ")", "{", "for", "(", "final", "HttpResponseInterceptor", "i", ":", "responseLast", ")", "{", "b", ".", "addLast", "(", "i", ")", ";", "}", "}", "httpprocessor", "=", "b", ".", "build", "(", ")", ";", "}", "execChain", "=", "new", "ProtocolExec", "(", "execChain", ",", "httpprocessor", ")", ";", "execChain", "=", "decorateProtocolExec", "(", "execChain", ")", ";", "if", "(", "!", "automaticRetriesDisabled", ")", "{", "HttpRequestRetryHandler", "retryHandler", "=", "this", ".", "retryHandler", ";", "if", "(", "retryHandler", "==", "null", ")", "{", "retryHandler", "=", "DefaultHttpRequestRetryHandler", ".", "INSTANCE", ";", "}", "execChain", "=", "new", "RetryExec", "(", "execChain", ",", "retryHandler", ")", ";", "}", "HttpRoutePlanner", "routePlanner", "=", "this", ".", "routePlanner", ";", "if", "(", "routePlanner", "==", "null", ")", "{", "SchemePortResolver", "schemePortResolver", "=", "this", ".", "schemePortResolver", ";", "if", "(", "schemePortResolver", "==", "null", ")", "{", "schemePortResolver", "=", "DefaultSchemePortResolver", ".", "INSTANCE", ";", "}", "if", "(", "proxy", "!=", "null", ")", "{", "routePlanner", "=", "new", "DefaultProxyRoutePlanner", "(", "proxy", ",", "schemePortResolver", ")", ";", "}", "else", "if", "(", "systemProperties", ")", "{", "routePlanner", "=", "new", "SystemDefaultRoutePlanner", "(", "schemePortResolver", ",", "ProxySelector", ".", "getDefault", "(", ")", ")", ";", "}", "else", "{", "routePlanner", "=", "new", "DefaultRoutePlanner", "(", "schemePortResolver", ")", ";", "}", "}", "if", "(", "!", "redirectHandlingDisabled", ")", "{", "RedirectStrategy", "redirectStrategy", "=", "this", ".", "redirectStrategy", ";", "if", "(", "redirectStrategy", "==", "null", ")", "{", "redirectStrategy", "=", "DefaultRedirectStrategy", ".", "INSTANCE", ";", "}", "execChain", "=", "new", "RedirectExec", "(", "execChain", ",", "routePlanner", ",", "redirectStrategy", ")", ";", "}", "final", "ServiceUnavailableRetryStrategy", "serviceUnavailStrategy", "=", "this", ".", "serviceUnavailStrategy", ";", "if", "(", "serviceUnavailStrategy", "!=", "null", ")", "{", "execChain", "=", "new", "ServiceUnavailableRetryExec", "(", "execChain", ",", "serviceUnavailStrategy", ")", ";", "}", "final", "BackoffManager", "backoffManager", "=", "this", ".", "backoffManager", ";", "final", "ConnectionBackoffStrategy", "connectionBackoffStrategy", "=", "this", ".", "connectionBackoffStrategy", ";", "if", "(", "backoffManager", "!=", "null", "&&", "connectionBackoffStrategy", "!=", "null", ")", "{", "execChain", "=", "new", "BackoffStrategyExec", "(", "execChain", ",", "connectionBackoffStrategy", ",", "backoffManager", ")", ";", "}", "Lookup", "<", "AuthSchemeProvider", ">", "authSchemeRegistry", "=", "this", ".", "authSchemeRegistry", ";", "if", "(", "authSchemeRegistry", "==", "null", ")", "{", "authSchemeRegistry", "=", "RegistryBuilder", ".", "<", "AuthSchemeProvider", ">", "create", "(", ")", ".", "register", "(", "AuthSchemes", ".", "BASIC", ",", "new", "BasicSchemeFactory", "(", ")", ")", ".", "register", "(", "AuthSchemes", ".", "DIGEST", ",", "new", "DigestSchemeFactory", "(", ")", ")", ".", "register", "(", "AuthSchemes", ".", "NTLM", ",", "new", "NTLMSchemeFactory", "(", ")", ")", ".", "register", "(", "AuthSchemes", ".", "SPNEGO", ",", "new", "SPNegoSchemeFactory", "(", ")", ")", ".", "register", "(", "AuthSchemes", ".", "KERBEROS", ",", "new", "KerberosSchemeFactory", "(", ")", ")", ".", "build", "(", ")", ";", "}", "Lookup", "<", "CookieSpecProvider", ">", "cookieSpecRegistry", "=", "this", ".", "cookieSpecRegistry", ";", "if", "(", "cookieSpecRegistry", "==", "null", ")", "{", "cookieSpecRegistry", "=", "RegistryBuilder", ".", "<", "CookieSpecProvider", ">", "create", "(", ")", ".", "register", "(", "CookieSpecs", ".", "BEST_MATCH", ",", "new", "BestMatchSpecFactory", "(", ")", ")", ".", "register", "(", "CookieSpecs", ".", "STANDARD", ",", "new", "RFC2965SpecFactory", "(", ")", ")", ".", "register", "(", "CookieSpecs", ".", "BROWSER_COMPATIBILITY", ",", "new", "BrowserCompatSpecFactory", "(", ")", ")", ".", "register", "(", "CookieSpecs", ".", "NETSCAPE", ",", "new", "NetscapeDraftSpecFactory", "(", ")", ")", ".", "register", "(", "CookieSpecs", ".", "IGNORE_COOKIES", ",", "new", "IgnoreSpecFactory", "(", ")", ")", ".", "register", "(", "\"", "rfc2109", "\"", ",", "new", "RFC2109SpecFactory", "(", ")", ")", ".", "register", "(", "\"", "rfc2965", "\"", ",", "new", "RFC2965SpecFactory", "(", ")", ")", ".", "build", "(", ")", ";", "}", "CookieStore", "defaultCookieStore", "=", "this", ".", "cookieStore", ";", "if", "(", "defaultCookieStore", "==", "null", ")", "{", "defaultCookieStore", "=", "new", "BasicCookieStore", "(", ")", ";", "}", "CredentialsProvider", "defaultCredentialsProvider", "=", "this", ".", "credentialsProvider", ";", "if", "(", "defaultCredentialsProvider", "==", "null", ")", "{", "if", "(", "systemProperties", ")", "{", "defaultCredentialsProvider", "=", "new", "SystemDefaultCredentialsProvider", "(", ")", ";", "}", "else", "{", "defaultCredentialsProvider", "=", "new", "BasicCredentialsProvider", "(", ")", ";", "}", "}", "return", "new", "InternalHttpClient", "(", "execChain", ",", "connManager", ",", "routePlanner", ",", "cookieSpecRegistry", ",", "authSchemeRegistry", ",", "defaultCookieStore", ",", "defaultCredentialsProvider", ",", "defaultRequestConfig", "!=", "null", "?", "defaultRequestConfig", ":", "RequestConfig", ".", "DEFAULT", ",", "closeables", "!=", "null", "?", "new", "ArrayList", "<", "Closeable", ">", "(", "closeables", ")", ":", "null", ")", ";", "}"], "idx": 7808, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "08140864e3e4c0994e094c4cf0507932baf6a66", "function_name": "build", "body_hash": "1238f037162241e88a8dd225b3b44f9070ff3fe4"}
{"code": "@Override public MercurialChangeSetList parse(Run build, RepositoryBrowser<?> browser, File changelogFile)\n            throws IOException, SAXException {\n        ArrayList<MercurialChangeSet> r = new ArrayList<>();\n\n        Element changesetsE;\n        try {\n            changesetsE = XMLUtils.parse(changelogFile, \"UTF-8\").getDocumentElement();\n        } catch (IOException e) {\n            throw new IOException(\"Failed to parse \" + changelogFile, e);\n        } catch (SAXException e) {\n            throw new IOException(\"Failed to parse \" + changelogFile + \": '\" + Util.loadFile(changelogFile) + \"'\", e);\n        }\n        NodeList changesetsNL = changesetsE.getChildNodes();\n        for (int i = 0; i < changesetsNL.getLength(); i++) {\n            if (changesetsNL.item(i).getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element changesetE = (Element) changesetsNL.item(i);\n            MercurialChangeSet cs = new MercurialChangeSet();\n            // See CHANGELOG_TEMPLATE:\n            cs.setNode(changesetE.getAttribute(\"node\"));\n            if (changesetE.hasAttribute(\"user\")) {\n                cs.setAuthor(changesetE.getAttribute(\"user\"));\n            } else {\n                cs.setAuthor(changesetE.getAttribute(\"author\"));\n            }\n            if (changesetE.hasAttribute(\"rev\")) { // unit tests omit it\n                cs.setRev(Long.parseLong(changesetE.getAttribute(\"rev\")));\n            }\n            cs.setDate(changesetE.getAttribute(\"date\"));\n            NodeList changesetNL = changesetE.getChildNodes();\n            for (int j = 0; j < changesetNL.getLength(); j++) {\n                if (changesetNL.item(j).getNodeType() != Node.ELEMENT_NODE) {\n                    continue;\n                }\n                Element otherE = (Element) changesetNL.item(j);\n                String text = otherE.getTextContent();\n                switch (otherE.getTagName()) {\n                case \"msg\":\n                    cs.setMsg(text);\n                    break;\n                // Before JENKINS-55319:\n                case \"added\":\n                    cs.setAdded(text);\n                    break;\n                case \"deleted\":\n                    cs.setDeleted(text);\n                    break;\n                case \"files\":\n                    cs.setFiles(text);\n                    break;\n                // After JENKINS-55319:\n                case \"file\":\n                    cs.addFile(text);\n                    break;\n                case \"addedFile\":\n                    cs.addAddedFile(text);\n                    break;\n                case \"deletedFile\":\n                    cs.addDeletedFile(text);\n                    break;\n                case \"parents\":\n                    cs.setParents(text);\n                    break;\n                default:\n                    throw new IOException(otherE.getTagName());\n                }\n            }\n            r.add(cs);\n        }\n\n        if (modules != null) {\n            Iterator<MercurialChangeSet> it = r.iterator();\n            while (it.hasNext()) {\n                boolean include = false;\n                INCLUDE: for (String path : it.next().getAffectedPaths()) {\n                    for (String module : modules) {\n                        if (path.startsWith(module)) {\n                            include = true;\n                            break INCLUDE;\n                        }\n                    }\n                }\n                if (!include) {\n                    it.remove();\n                }\n            }\n        }\n\n        // sort the changes from oldest to newest, this gives the best result in\n        // the Jenkins changes view,\n        // and is like the old situation where 'hg incoming' was used to\n        // determine the changelog\n        r.sort(Comparator.comparingLong(MercurialChangeSet::getRev));\n\n        return new MercurialChangeSetList(build, browser, r);\n    }", "code_tokens": ["@", "Override", "public", "MercurialChangeSetList", "parse", "(", "Run", "build", ",", "RepositoryBrowser", "<", "?", ">", "browser", ",", "File", "changelogFile", ")", "throws", "IOException", ",", "SAXException", "{", "ArrayList", "<", "MercurialChangeSet", ">", "r", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Element", "changesetsE", ";", "try", "{", "changesetsE", "=", "XMLUtils", ".", "parse", "(", "changelogFile", ",", "\"", "UTF-8", "\"", ")", ".", "getDocumentElement", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "IOException", "(", "\"", "Failed to parse ", "\"", "+", "changelogFile", ",", "e", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "throw", "new", "IOException", "(", "\"", "Failed to parse ", "\"", "+", "changelogFile", "+", "\"", ": '", "\"", "+", "Util", ".", "loadFile", "(", "changelogFile", ")", "+", "\"", "'", "\"", ",", "e", ")", ";", "}", "NodeList", "changesetsNL", "=", "changesetsE", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "changesetsNL", ".", "getLength", "(", ")", ";", "i", "++", ")", "{", "if", "(", "changesetsNL", ".", "item", "(", "i", ")", ".", "getNodeType", "(", ")", "!=", "Node", ".", "ELEMENT_NODE", ")", "{", "continue", ";", "}", "Element", "changesetE", "=", "(", "Element", ")", "changesetsNL", ".", "item", "(", "i", ")", ";", "MercurialChangeSet", "cs", "=", "new", "MercurialChangeSet", "(", ")", ";", "cs", ".", "setNode", "(", "changesetE", ".", "getAttribute", "(", "\"", "node", "\"", ")", ")", ";", "if", "(", "changesetE", ".", "hasAttribute", "(", "\"", "user", "\"", ")", ")", "{", "cs", ".", "setAuthor", "(", "changesetE", ".", "getAttribute", "(", "\"", "user", "\"", ")", ")", ";", "}", "else", "{", "cs", ".", "setAuthor", "(", "changesetE", ".", "getAttribute", "(", "\"", "author", "\"", ")", ")", ";", "}", "if", "(", "changesetE", ".", "hasAttribute", "(", "\"", "rev", "\"", ")", ")", "{", "cs", ".", "setRev", "(", "Long", ".", "parseLong", "(", "changesetE", ".", "getAttribute", "(", "\"", "rev", "\"", ")", ")", ")", ";", "}", "cs", ".", "setDate", "(", "changesetE", ".", "getAttribute", "(", "\"", "date", "\"", ")", ")", ";", "NodeList", "changesetNL", "=", "changesetE", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "changesetNL", ".", "getLength", "(", ")", ";", "j", "++", ")", "{", "if", "(", "changesetNL", ".", "item", "(", "j", ")", ".", "getNodeType", "(", ")", "!=", "Node", ".", "ELEMENT_NODE", ")", "{", "continue", ";", "}", "Element", "otherE", "=", "(", "Element", ")", "changesetNL", ".", "item", "(", "j", ")", ";", "String", "text", "=", "otherE", ".", "getTextContent", "(", ")", ";", "switch", "(", "otherE", ".", "getTagName", "(", ")", ")", "{", "case", "\"", "msg", "\"", ":", "cs", ".", "setMsg", "(", "text", ")", ";", "break", ";", "case", "\"", "added", "\"", ":", "cs", ".", "setAdded", "(", "text", ")", ";", "break", ";", "case", "\"", "deleted", "\"", ":", "cs", ".", "setDeleted", "(", "text", ")", ";", "break", ";", "case", "\"", "files", "\"", ":", "cs", ".", "setFiles", "(", "text", ")", ";", "break", ";", "case", "\"", "file", "\"", ":", "cs", ".", "addFile", "(", "text", ")", ";", "break", ";", "case", "\"", "addedFile", "\"", ":", "cs", ".", "addAddedFile", "(", "text", ")", ";", "break", ";", "case", "\"", "deletedFile", "\"", ":", "cs", ".", "addDeletedFile", "(", "text", ")", ";", "break", ";", "case", "\"", "parents", "\"", ":", "cs", ".", "setParents", "(", "text", ")", ";", "break", ";", "default", ":", "throw", "new", "IOException", "(", "otherE", ".", "getTagName", "(", ")", ")", ";", "}", "}", "r", ".", "add", "(", "cs", ")", ";", "}", "if", "(", "modules", "!=", "null", ")", "{", "Iterator", "<", "MercurialChangeSet", ">", "it", "=", "r", ".", "iterator", "(", ")", ";", "while", "(", "it", ".", "hasNext", "(", ")", ")", "{", "boolean", "include", "=", "false", ";", "INCLUDE", ":", "for", "(", "String", "path", ":", "it", ".", "next", "(", ")", ".", "getAffectedPaths", "(", ")", ")", "{", "for", "(", "String", "module", ":", "modules", ")", "{", "if", "(", "path", ".", "startsWith", "(", "module", ")", ")", "{", "include", "=", "true", ";", "break", "INCLUDE", ";", "}", "}", "}", "if", "(", "!", "include", ")", "{", "it", ".", "remove", "(", ")", ";", "}", "}", "}", "r", ".", "sort", "(", "Comparator", ".", "comparingLong", "(", "MercurialChangeSet", "::", "getRev", ")", ")", ";", "return", "new", "MercurialChangeSetList", "(", "build", ",", "browser", ",", "r", ")", ";", "}"], "idx": 69720, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "84af58b08f80bb92792f7bc04a31487f3eeee95a", "function_name": "parse", "body_hash": "9625b62443eefd06dac8296f32adfe68ab21a704"}
{"code": "private void renderState(FacesContext context) throws IOException {\n        // Get the view state and write it to the response..\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        String viewStateId = Util.getViewStateId(context);\n\n        writer.startUpdate(viewStateId);\n        String state = context.getApplication().getStateManager().getViewState(context);\n        writer.write(state);\n        writer.endUpdate();\n\n        ClientWindow window = context.getExternalContext().getClientWindow();\n        if (null != window) {\n            String clientWindowId = Util.getClientWindowId(context);\n            writer.startUpdate(clientWindowId);\n            writer.writeText(window.getId(), null);\n            writer.endUpdate();\n        }\n    }", "code_tokens": ["private", "void", "renderState", "(", "FacesContext", "context", ")", "throws", "IOException", "{", "PartialViewContext", "pvc", "=", "context", ".", "getPartialViewContext", "(", ")", ";", "PartialResponseWriter", "writer", "=", "pvc", ".", "getPartialResponseWriter", "(", ")", ";", "String", "viewStateId", "=", "Util", ".", "getViewStateId", "(", "context", ")", ";", "writer", ".", "startUpdate", "(", "viewStateId", ")", ";", "String", "state", "=", "context", ".", "getApplication", "(", ")", ".", "getStateManager", "(", ")", ".", "getViewState", "(", "context", ")", ";", "writer", ".", "write", "(", "state", ")", ";", "writer", ".", "endUpdate", "(", ")", ";", "ClientWindow", "window", "=", "context", ".", "getExternalContext", "(", ")", ".", "getClientWindow", "(", ")", ";", "if", "(", "null", "!=", "window", ")", "{", "String", "clientWindowId", "=", "Util", ".", "getClientWindowId", "(", "context", ")", ";", "writer", ".", "startUpdate", "(", "clientWindowId", ")", ";", "writer", ".", "writeText", "(", "window", ".", "getId", "(", ")", ",", "null", ")", ";", "writer", ".", "endUpdate", "(", ")", ";", "}", "}"], "idx": 79223, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "a3fa9573789ed5e867c43ea38374f4dbd5a8f81f", "function_name": "renderState", "body_hash": "027a0b2ae953a7c105a2b467937a1ca24329c880"}
{"code": "private T buildFromConnection(Http2Connection connection) {\n        Long maxHeaderListSize = initialSettings.maxHeaderListSize();\n        Http2FrameReader reader = new DefaultHttp2FrameReader(new DefaultHttp2HeadersDecoder(isValidateHeaders(),\n                maxHeaderListSize == null ? DEFAULT_HEADER_LIST_SIZE : maxHeaderListSize,\n                /* initialHuffmanDecodeCapacity= */ -1));\n        Http2FrameWriter writer = encoderIgnoreMaxHeaderListSize == null ?\n                new DefaultHttp2FrameWriter(headerSensitivityDetector()) :\n                new DefaultHttp2FrameWriter(headerSensitivityDetector(), encoderIgnoreMaxHeaderListSize);\n\n        if (frameLogger != null) {\n            reader = new Http2InboundFrameLogger(reader, frameLogger);\n            writer = new Http2OutboundFrameLogger(writer, frameLogger);\n        }\n\n        Http2ConnectionEncoder encoder = new DefaultHttp2ConnectionEncoder(connection, writer);\n        boolean encoderEnforceMaxConcurrentStreams = encoderEnforceMaxConcurrentStreams();\n\n        if (encoderEnforceMaxConcurrentStreams) {\n            if (connection.isServer()) {\n                encoder.close();\n                reader.close();\n                throw new IllegalArgumentException(\n                        \"encoderEnforceMaxConcurrentStreams: \" + encoderEnforceMaxConcurrentStreams +\n                        \" not supported for server\");\n            }\n            encoder = new StreamBufferingEncoder(encoder);\n        }\n\n        DefaultHttp2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, reader,\n                promisedRequestVerifier(), isAutoAckSettingsFrame(), isAutoAckPingFrame());\n        return buildFromCodec(decoder, encoder);\n    }", "code_tokens": ["private", "T", "buildFromConnection", "(", "Http2Connection", "connection", ")", "{", "Long", "maxHeaderListSize", "=", "initialSettings", ".", "maxHeaderListSize", "(", ")", ";", "Http2FrameReader", "reader", "=", "new", "DefaultHttp2FrameReader", "(", "new", "DefaultHttp2HeadersDecoder", "(", "isValidateHeaders", "(", ")", ",", "maxHeaderListSize", "==", "null", "?", "DEFAULT_HEADER_LIST_SIZE", ":", "maxHeaderListSize", ",", "-", "1", ")", ")", ";", "Http2FrameWriter", "writer", "=", "encoderIgnoreMaxHeaderListSize", "==", "null", "?", "new", "DefaultHttp2FrameWriter", "(", "headerSensitivityDetector", "(", ")", ")", ":", "new", "DefaultHttp2FrameWriter", "(", "headerSensitivityDetector", "(", ")", ",", "encoderIgnoreMaxHeaderListSize", ")", ";", "if", "(", "frameLogger", "!=", "null", ")", "{", "reader", "=", "new", "Http2InboundFrameLogger", "(", "reader", ",", "frameLogger", ")", ";", "writer", "=", "new", "Http2OutboundFrameLogger", "(", "writer", ",", "frameLogger", ")", ";", "}", "Http2ConnectionEncoder", "encoder", "=", "new", "DefaultHttp2ConnectionEncoder", "(", "connection", ",", "writer", ")", ";", "boolean", "encoderEnforceMaxConcurrentStreams", "=", "encoderEnforceMaxConcurrentStreams", "(", ")", ";", "if", "(", "encoderEnforceMaxConcurrentStreams", ")", "{", "if", "(", "connection", ".", "isServer", "(", ")", ")", "{", "encoder", ".", "close", "(", ")", ";", "reader", ".", "close", "(", ")", ";", "throw", "new", "IllegalArgumentException", "(", "\"", "encoderEnforceMaxConcurrentStreams: ", "\"", "+", "encoderEnforceMaxConcurrentStreams", "+", "\"", " not supported for server", "\"", ")", ";", "}", "encoder", "=", "new", "StreamBufferingEncoder", "(", "encoder", ")", ";", "}", "DefaultHttp2ConnectionDecoder", "decoder", "=", "new", "DefaultHttp2ConnectionDecoder", "(", "connection", ",", "encoder", ",", "reader", ",", "promisedRequestVerifier", "(", ")", ",", "isAutoAckSettingsFrame", "(", ")", ",", "isAutoAckPingFrame", "(", ")", ")", ";", "return", "buildFromCodec", "(", "decoder", ",", "encoder", ")", ";", "}"], "idx": 75742, "cwe": "CWE-770", "target": 1, "status": "VULNERABLE", "commit": "cecb46a3dd", "function_name": "buildFromConnection", "body_hash": "7a0c73d1c758140c9fd4c3cc22d8a6e6f26c5539"}
{"code": "@Override\n\t@Exported(visibility = 2)\n\tpublic String getName() {\n\t\treturn pageCounts.page;\n\t}", "code_tokens": ["@", "Override", "@", "Exported", "(", "visibility", "=", "2", ")", "public", "String", "getName", "(", ")", "{", "return", "pageCounts", ".", "page", ";", "}"], "idx": 80918, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "db72cc4", "function_name": "getName", "body_hash": "c1e97ded6fb911a6d63bad1ee7e0605cec94ba76"}
{"code": "public void installConfigFiles(final boolean builtIn) {\n        final File openejbCoreJar = paths.getOpenEJBCoreJar();\n        final File confDir = paths.getCatalinaConfDir();\n        final Alerts alerts = this.alerts;\n\n        if (openejbCoreJar == null) {\n            // the core jar contains the config files\n            return;\n        }\n        final JarFile coreJar;\n        try {\n            coreJar = new JarFile(openejbCoreJar);\n        } catch (final IOException e) {\n            return;\n        }\n\n        //\n        // conf/tomee.xml\n        //\n        final File openEjbXmlFile = new File(confDir, \"tomee.xml\");\n        if (!openEjbXmlFile.exists()) {\n            // read in the openejb.xml file from the openejb core jar\n            final String openEjbXml = Installers.readEntry(coreJar, \"default.openejb.conf\", alerts);\n            if (openEjbXml != null) {\n                if (Installers.writeAll(openEjbXmlFile, openEjbXml.replace(\"<openejb>\", \"<tomee>\").replace(\"</openejb>\", \"</tomee>\"), alerts)) {\n                    alerts.addInfo(\"Copy tomee.xml to conf\");\n                }\n            }\n        }\n\n\n        //\n        // conf/logging.properties\n        // now we are using tomcat one of jdk one by default\n        //\n        final String openejbLoggingProps = \"################################\\r\\n\" +\n                \"# OpenEJB/TomEE specific loggers\\r\\n\" +\n                \"################################\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# ACTIVATE LEVEL/HANDLERS YOU WANT\\r\\n\" +\n                \"# IF YOU ACTIVATE 5tomee.org.apache.juli.FileHandler\\r\\n\" +\n                \"# ADD IT TO handlers LINE LIKE:\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# LEVELS:\\r\\n\" +\n                \"# =======\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.options.level     = INFO\\r\\n\" +\n                \"# OpenEJB.server.level      = INFO\\r\\n\" +\n                \"# OpenEJB.startup.level     = INFO\\r\\n\" +\n                \"# OpenEJB.startup.service.level = WARNING\\r\\n\" +\n                \"# OpenEJB.startup.config.level = INFO\\r\\n\" +\n                \"# OpenEJB.hsql.level        = INFO\\r\\n\" +\n                \"# CORBA-Adapter.level       = WARNING\\r\\n\" +\n                \"# Transaction.level         = WARNING\\r\\n\" +\n                \"# org.apache.activemq.level = SEVERE\\r\\n\" +\n                \"# org.apache.geronimo.level = SEVERE\\r\\n\" +\n                \"# openjpa.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.cdi.level         = INFO\\r\\n\" +\n                \"# org.apache.webbeans.level = INFO\\r\\n\" +\n                \"# org.apache.openejb.level = FINE\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# HANDLERS:\\r\\n\" +\n                \"# =========\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.options.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.server.handlers      = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.service.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.config.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.hsql.handlers        = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# CORBA-Adapter.handlers       = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# Transaction.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.activemq.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.geronimo.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# openjpa.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.cdi.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.webbeans.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.openejb.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# TOMEE HANDLER SAMPLE:\\r\\n\" +\n                \"# =====================\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.level = FINEST\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.prefix = tomee.\\r\\n\";\n        final File loggingPropsFile = new File(confDir, \"logging.properties\");\n        String newLoggingProps = null;\n        if (!loggingPropsFile.exists()) {\n            newLoggingProps = openejbLoggingProps;\n        } else {\n            final String loggingPropsOriginal = Installers.readAll(loggingPropsFile, alerts);\n            if (!loggingPropsOriginal.toLowerCase().contains(\"openejb\")) {\n                // append our properties\n                newLoggingProps = loggingPropsOriginal +\n                        \"\\r\\n\\r\\n\" +\n                        openejbLoggingProps + \"\\r\\n\";\n            }\n        }\n        if (builtIn) {\n            installTomEEJuli(alerts, loggingPropsFile, newLoggingProps);\n        }\n\n        final File openejbSystemProperties = new File(confDir, \"system.properties\");\n        if (!openejbSystemProperties.exists()) {\n            FileWriter systemPropertiesWriter = null;\n            try {\n                systemPropertiesWriter = new FileWriter(openejbSystemProperties);\n\n                systemPropertiesWriter.write(\"# all this properties are added at JVM system properties at startup\\n\");\n                systemPropertiesWriter.write(\"# here some default Apache TomEE system properties\\n\");\n                systemPropertiesWriter.write(\"# for more information please see http://tomee.apache.org/properties-listing.html\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\n                    \"# allowed packages to be deserialized, by security we denied all by default, \" +\n                    \"tune tomee.serialization.class.whitelist packages to change it\\n\");\n                systemPropertiesWriter.write(\"# tomee.remote.support = true\\n\");\n                systemPropertiesWriter.write(\"tomee.serialization.class.blacklist = *\\n\");\n                systemPropertiesWriter.write(\"# tomee.serialization.class.whitelist = my.package\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader.verbose = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.subcontext = webservices\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.oldsubcontext = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# if you want to propagate a deployment on a cluster when a tomcat cluster is defined\\n\");\n                systemPropertiesWriter.write(\"# tomee.cluster.deployment = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.system.apps = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.servicemanager.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.descriptors.output = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.strict.interface.declaration = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.conf.file = conf/tomee.xml\\n\");\n                systemPropertiesWriter.write(\"# openejb.debuggable-vm-hackery = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.skip = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.webservices.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.output.level = MEDIUM\\n\");\n                systemPropertiesWriter.write(\"# openejb.user.mbeans.list = *\\n\");\n                systemPropertiesWriter.write(\"# openejb.deploymentId.format = {appId}/{ejbJarId}/{ejbName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.format = {deploymentId}{interfaceType.annotationName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.include = .*\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.exclude = \\n\");\n                systemPropertiesWriter.write(\"# openejb.autocreate.jta-datasource-from-non-jta-one = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.altdd.prefix = \\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.default.system.interceptors = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.failoncollision = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.wsAddress.format = /{ejbDeploymentId}\\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.server.webservices.saaj.provider = \\n\");\n                systemPropertiesWriter.write(\"# openejb.nobanner = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.offline = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.exclude-include.order = include-exclude\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.exclude =\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.include =\\n\");\n                systemPropertiesWriter.write(\"# openejb.crosscontext = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jsessionid-support = \\n\");\n                systemPropertiesWriter.write(\"# openejb.myfaces.disable-default-values = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.web.xml.major = \\n\");\n                systemPropertiesWriter.write(\"# openjpa.Log = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jdbc.log = false\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.provider = org.apache.openjpa.persistence.PersistenceProviderImpl\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.transactionType = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.jtaDataSource = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.nonJtaDataSource = \\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# Properties for JAS RS\\n\");\n                systemPropertiesWriter.write(\"# openejb.jaxrs.application = \\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreRequests = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreMessageWriters = true\\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# These properties are only for cxf service (SOAP webservices) and TomEE+\\n\");\n                systemPropertiesWriter.write(\"# If you don't use special tricks and sun default implementation, uncommenting these 4 lines forces TomEE to use it without overhead at all = \\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MessageFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPConnectionFactory = com.sun.xml.messaging.saaj.client.p2p.HttpSOAPConnectionFactory\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MetaFactory = com.sun.xml.messaging.saaj.soap.SAAJMetaFactoryImpl\\n\");\n            } catch (final IOException e) {\n                // ignored, this file is far to be mandatory\n            } finally {\n                if (systemPropertiesWriter != null) {\n                    try {\n                        systemPropertiesWriter.close();\n                    } catch (final IOException e) {\n                        // no-op\n                    }\n                }\n            }\n        }\n\n        //\n        // conf/web.xml\n        //\n        final JarFile openejbTomcatCommonJar;\n        try {\n            openejbTomcatCommonJar = new JarFile(paths.geOpenEJBTomcatCommonJar());\n        } catch (final IOException e) {\n            return;\n        }\n        final File webXmlFile = new File(confDir, \"web.xml\");\n        final String webXml = Installers.readEntry(openejbTomcatCommonJar, \"conf/web.xml\", alerts);\n        if (Installers.writeAll(webXmlFile, webXml, alerts)) {\n            alerts.addInfo(\"Set jasper in production mode in TomEE web.xml\");\n        }\n    }", "code_tokens": ["public", "void", "installConfigFiles", "(", "final", "boolean", "builtIn", ")", "{", "final", "File", "openejbCoreJar", "=", "paths", ".", "getOpenEJBCoreJar", "(", ")", ";", "final", "File", "confDir", "=", "paths", ".", "getCatalinaConfDir", "(", ")", ";", "final", "Alerts", "alerts", "=", "this", ".", "alerts", ";", "if", "(", "openejbCoreJar", "==", "null", ")", "{", "return", ";", "}", "final", "JarFile", "coreJar", ";", "try", "{", "coreJar", "=", "new", "JarFile", "(", "openejbCoreJar", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "return", ";", "}", "final", "File", "openEjbXmlFile", "=", "new", "File", "(", "confDir", ",", "\"", "tomee.xml", "\"", ")", ";", "if", "(", "!", "openEjbXmlFile", ".", "exists", "(", ")", ")", "{", "final", "String", "openEjbXml", "=", "Installers", ".", "readEntry", "(", "coreJar", ",", "\"", "default.openejb.conf", "\"", ",", "alerts", ")", ";", "if", "(", "openEjbXml", "!=", "null", ")", "{", "if", "(", "Installers", ".", "writeAll", "(", "openEjbXmlFile", ",", "openEjbXml", ".", "replace", "(", "\"", "<openejb>", "\"", ",", "\"", "<tomee>", "\"", ")", ".", "replace", "(", "\"", "</openejb>", "\"", ",", "\"", "</tomee>", "\"", ")", ",", "alerts", ")", ")", "{", "alerts", ".", "addInfo", "(", "\"", "Copy tomee.xml to conf", "\"", ")", ";", "}", "}", "}", "final", "String", "openejbLoggingProps", "=", "\"", "################################", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB/TomEE specific loggers", "\\r", "\\n", "\"", "+", "\"", "################################", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# ACTIVATE LEVEL/HANDLERS YOU WANT", "\\r", "\\n", "\"", "+", "\"", "# IF YOU ACTIVATE 5tomee.org.apache.juli.FileHandler", "\\r", "\\n", "\"", "+", "\"", "# ADD IT TO handlers LINE LIKE:", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# LEVELS:", "\\r", "\\n", "\"", "+", "\"", "# =======", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.level             = WARNING", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.options.level     = INFO", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.server.level      = INFO", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.level     = INFO", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.service.level = WARNING", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.config.level = INFO", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.hsql.level        = INFO", "\\r", "\\n", "\"", "+", "\"", "# CORBA-Adapter.level       = WARNING", "\\r", "\\n", "\"", "+", "\"", "# Transaction.level         = WARNING", "\\r", "\\n", "\"", "+", "\"", "# org.apache.activemq.level = SEVERE", "\\r", "\\n", "\"", "+", "\"", "# org.apache.geronimo.level = SEVERE", "\\r", "\\n", "\"", "+", "\"", "# openjpa.level             = WARNING", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.cdi.level         = INFO", "\\r", "\\n", "\"", "+", "\"", "# org.apache.webbeans.level = INFO", "\\r", "\\n", "\"", "+", "\"", "# org.apache.openejb.level = FINE", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# HANDLERS:", "\\r", "\\n", "\"", "+", "\"", "# =========", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.options.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.server.handlers      = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.service.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.config.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.hsql.handlers        = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# CORBA-Adapter.handlers       = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# Transaction.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# org.apache.activemq.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# org.apache.geronimo.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# openjpa.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.cdi.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# org.apache.webbeans.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# org.apache.openejb.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# TOMEE HANDLER SAMPLE:", "\\r", "\\n", "\"", "+", "\"", "# =====================", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# 5tomee.org.apache.juli.FileHandler.level = FINEST", "\\r", "\\n", "\"", "+", "\"", "# 5tomee.org.apache.juli.FileHandler.directory = ${catalina.base}/logs", "\\r", "\\n", "\"", "+", "\"", "# 5tomee.org.apache.juli.FileHandler.prefix = tomee.", "\\r", "\\n", "\"", ";", "final", "File", "loggingPropsFile", "=", "new", "File", "(", "confDir", ",", "\"", "logging.properties", "\"", ")", ";", "String", "newLoggingProps", "=", "null", ";", "if", "(", "!", "loggingPropsFile", ".", "exists", "(", ")", ")", "{", "newLoggingProps", "=", "openejbLoggingProps", ";", "}", "else", "{", "final", "String", "loggingPropsOriginal", "=", "Installers", ".", "readAll", "(", "loggingPropsFile", ",", "alerts", ")", ";", "if", "(", "!", "loggingPropsOriginal", ".", "toLowerCase", "(", ")", ".", "contains", "(", "\"", "openejb", "\"", ")", ")", "{", "newLoggingProps", "=", "loggingPropsOriginal", "+", "\"", "\\r", "\\n", "\\r", "\\n", "\"", "+", "openejbLoggingProps", "+", "\"", "\\r", "\\n", "\"", ";", "}", "}", "if", "(", "builtIn", ")", "{", "installTomEEJuli", "(", "alerts", ",", "loggingPropsFile", ",", "newLoggingProps", ")", ";", "}", "final", "File", "openejbSystemProperties", "=", "new", "File", "(", "confDir", ",", "\"", "system.properties", "\"", ")", ";", "if", "(", "!", "openejbSystemProperties", ".", "exists", "(", ")", ")", "{", "FileWriter", "systemPropertiesWriter", "=", "null", ";", "try", "{", "systemPropertiesWriter", "=", "new", "FileWriter", "(", "openejbSystemProperties", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# all this properties are added at JVM system properties at startup", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# here some default Apache TomEE system properties", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# for more information please see http://tomee.apache.org/properties-listing.html", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# allowed packages to be deserialized, by security we denied all by default, ", "\"", "+", "\"", "tune tomee.serialization.class.whitelist packages to change it", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# tomee.remote.support = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "tomee.serialization.class.blacklist = *", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# tomee.serialization.class.whitelist = my.package", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.check.classloader = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.check.classloader.verbose = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# tomee.jaxws.subcontext = webservices", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# tomee.jaxws.oldsubcontext = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# if you want to propagate a deployment on a cluster when a tomcat cluster is defined", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# tomee.cluster.deployment = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.system.apps = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.servicemanager.enabled = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jmx.active = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.descriptors.output = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.strict.interface.declaration = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.conf.file = conf/tomee.xml", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.debuggable-vm-hackery = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.validation.skip = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.webservices.enabled = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.validation.output.level = MEDIUM", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.user.mbeans.list = *", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.deploymentId.format = {appId}/{ejbJarId}/{ejbName}", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jndiname.format = {deploymentId}{interfaceType.annotationName}", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.deployments.package.include = .*", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.deployments.package.exclude = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.autocreate.jta-datasource-from-non-jta-one = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.altdd.prefix = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# org.apache.openejb.default.system.interceptors = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jndiname.failoncollision = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.wsAddress.format = /{ejbDeploymentId}", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# org.apache.openejb.server.webservices.saaj.provider = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.nobanner = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.offline = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jmx.active = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.exclude-include.order = include-exclude", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.additional.exclude =", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.additional.include =", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.crosscontext = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jsessionid-support = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.myfaces.disable-default-values = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.web.xml.major = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openjpa.Log = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jdbc.log = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.persistence.provider = org.apache.openjpa.persistence.PersistenceProviderImpl", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.persistence.transactionType = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.persistence.jtaDataSource = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.persistence.nonJtaDataSource = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "#", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# Properties for JAS RS", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jaxrs.application = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.cxf-rs.wadl-generator.ignoreRequests = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.cxf-rs.wadl-generator.ignoreMessageWriters = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "#", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# These properties are only for cxf service (SOAP webservices) and TomEE+", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# If you don't use special tricks and sun default implementation, uncommenting these 4 lines forces TomEE to use it without overhead at all = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.xml.soap.MessageFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.xml.soap.SOAPFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPFactory1_1Impl", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.xml.soap.SOAPConnectionFactory = com.sun.xml.messaging.saaj.client.p2p.HttpSOAPConnectionFactory", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.xml.soap.MetaFactory = com.sun.xml.messaging.saaj.soap.SAAJMetaFactoryImpl", "\\n", "\"", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "}", "finally", "{", "if", "(", "systemPropertiesWriter", "!=", "null", ")", "{", "try", "{", "systemPropertiesWriter", ".", "close", "(", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "}", "}", "}", "}", "final", "JarFile", "openejbTomcatCommonJar", ";", "try", "{", "openejbTomcatCommonJar", "=", "new", "JarFile", "(", "paths", ".", "geOpenEJBTomcatCommonJar", "(", ")", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "return", ";", "}", "final", "File", "webXmlFile", "=", "new", "File", "(", "confDir", ",", "\"", "web.xml", "\"", ")", ";", "final", "String", "webXml", "=", "Installers", ".", "readEntry", "(", "openejbTomcatCommonJar", ",", "\"", "conf/web.xml", "\"", ",", "alerts", ")", ";", "if", "(", "Installers", ".", "writeAll", "(", "webXmlFile", ",", "webXml", ",", "alerts", ")", ")", "{", "alerts", ".", "addInfo", "(", "\"", "Set jasper in production mode in TomEE web.xml", "\"", ")", ";", "}", "}"], "idx": 62848, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "58cdbbef9c77ab2b44870f9d606593b49cde76d9", "function_name": "installConfigFiles", "body_hash": "6589d3ff00ffdf08fa964679c9f588d917307159"}
{"code": "protected void serveResource(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 boolean content,\n                                 String encoding)\n        throws IOException, ServletException {\n\n        boolean serveContent = content;\n\n        // Identify the requested resource path\n        String path = getRelativePath(request, true);\n\n        if (debug > 0) {\n            if (serveContent)\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers and data\");\n            else\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers only\");\n        }\n\n        if (path.length() == 0) {\n            // Context root redirect\n            doDirectoryRedirect(request, response);\n            return;\n        }\n\n        WebResource resource = resources.getResource(path);\n\n        if (!resource.exists()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // SRV.9.3 says we must throw a FNFE\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        if (!resource.canRead()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // Spec doesn't say what to do in this case but a FNFE seems\n                // reasonable\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestUri);\n            return;\n        }\n\n        // If the resource is not a collection, and the resource path\n        // ends with \"/\" or \"\\\", return NOT FOUND\n        if (resource.isFile() && (path.endsWith(\"/\") || path.endsWith(\"\\\\\"))) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            }\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        boolean isError = DispatcherType.ERROR == request.getDispatcherType();\n\n        boolean included = false;\n        // Check if the conditions specified in the optional If headers are\n        // satisfied.\n        if (resource.isFile()) {\n            // Checking If headers\n            included = (request.getAttribute(\n                    RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\n            if (!included && !isError && !checkIfHeaders(request, response, resource)) {\n                return;\n            }\n        }\n\n        // Find content type.\n        String contentType = resource.getMimeType();\n        if (contentType == null) {\n            contentType = getServletContext().getMimeType(resource.getName());\n            resource.setMimeType(contentType);\n        }\n\n        // These need to reflect the original resource, not the potentially\n        // gzip'd version of the resource so get them now if they are going to\n        // be needed later\n        String eTag = null;\n        String lastModifiedHttp = null;\n        if (resource.isFile() && !isError) {\n            eTag = resource.getETag();\n            lastModifiedHttp = resource.getLastModifiedHttp();\n        }\n\n\n        // Serve a gzipped version of the file if present\n        boolean usingGzippedVersion = false;\n        if (gzip && !included && resource.isFile() && !path.endsWith(\".gz\")) {\n            WebResource gzipResource = resources.getResource(path + \".gz\");\n            if (gzipResource.exists() && gzipResource.isFile()) {\n                Collection<String> varyHeaders = response.getHeaders(\"Vary\");\n                boolean addRequired = true;\n                for (String varyHeader : varyHeaders) {\n                    if (\"*\".equals(varyHeader) ||\n                            \"accept-encoding\".equalsIgnoreCase(varyHeader)) {\n                        addRequired = false;\n                        break;\n                    }\n                }\n                if (addRequired) {\n                    response.addHeader(\"Vary\", \"accept-encoding\");\n                }\n                if (checkIfGzip(request)) {\n                    response.addHeader(\"Content-Encoding\", \"gzip\");\n                    resource = gzipResource;\n                    usingGzippedVersion = true;\n                }\n            }\n        }\n\n        ArrayList<Range> ranges = null;\n        long contentLength = -1L;\n\n        if (resource.isDirectory()) {\n            if (!path.endsWith(\"/\")) {\n                doDirectoryRedirect(request, response);\n                return;\n            }\n\n            // Skip directory listings if we have been configured to\n            // suppress them\n            if (!listings) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                   request.getRequestURI());\n                return;\n            }\n            contentType = \"text/html;charset=UTF-8\";\n        } else {\n            if (!isError) {\n                if (useAcceptRanges) {\n                    // Accept ranges header\n                    response.setHeader(\"Accept-Ranges\", \"bytes\");\n                }\n\n                // Parse range specifier\n                ranges = parseRange(request, response, resource);\n\n                // ETag header\n                response.setHeader(\"ETag\", eTag);\n\n                // Last-Modified header\n                response.setHeader(\"Last-Modified\", lastModifiedHttp);\n            }\n\n            // Get content length\n            contentLength = resource.getContentLength();\n            // Special case for zero length files, which would cause a\n            // (silent) ISE when setting the output buffer size\n            if (contentLength == 0L) {\n                serveContent = false;\n            }\n        }\n\n        ServletOutputStream ostream = null;\n        PrintWriter writer = null;\n\n        if (serveContent) {\n            // Trying to retrieve the servlet output stream\n            try {\n                ostream = response.getOutputStream();\n            } catch (IllegalStateException e) {\n                // If it fails, we try to get a Writer instead if we're\n                // trying to serve a text file\n                if (!usingGzippedVersion &&\n                        ((contentType == null) ||\n                                (contentType.startsWith(\"text\")) ||\n                                (contentType.endsWith(\"xml\")) ||\n                                (contentType.contains(\"/javascript\")))\n                        ) {\n                    writer = response.getWriter();\n                    // Cannot reliably serve partial content with a Writer\n                    ranges = FULL;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // Check to see if a Filter, Valve of wrapper has written some content.\n        // If it has, disable range requests and setting of a content length\n        // since neither can be done reliably.\n        ServletResponse r = response;\n        long contentWritten = 0;\n        while (r instanceof ServletResponseWrapper) {\n            r = ((ServletResponseWrapper) r).getResponse();\n        }\n        if (r instanceof ResponseFacade) {\n            contentWritten = ((ResponseFacade) r).getContentWritten();\n        }\n        if (contentWritten > 0) {\n            ranges = FULL;\n        }\n\n        if (resource.isDirectory() ||\n                isError ||\n                ( (ranges == null || ranges.isEmpty())\n                        && request.getHeader(\"Range\") == null ) ||\n                ranges == FULL ) {\n\n            // Set the appropriate output headers\n            if (contentType != null) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentType='\" +\n                        contentType + \"'\");\n                response.setContentType(contentType);\n            }\n            if (resource.isFile() && contentLength >= 0 &&\n                    (!serveContent || ostream != null)) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentLength=\" +\n                        contentLength);\n                // Don't set a content length if something else has already\n                // written to the response.\n                if (contentWritten == 0) {\n                    response.setContentLengthLong(contentLength);\n                }\n            }\n\n            if (serveContent) {\n                try {\n                    response.setBufferSize(output);\n                } catch (IllegalStateException e) {\n                    // Silent catch\n                }\n                InputStream renderResult = null;\n                if (ostream == null) {\n                    // Output via a writer so can't use sendfile or write\n                    // content directly.\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        renderResult = resource.getInputStream();\n                    }\n                    copy(resource, renderResult, writer, encoding);\n                } else {\n                    // Output is via an InputStream\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        // Output is content of resource\n                        if (!checkSendfile(request, response, resource,\n                                contentLength, null)) {\n                            // sendfile not possible so check if resource\n                            // content is available directly\n                            byte[] resourceBody = resource.getContent();\n                            if (resourceBody == null) {\n                                // Resource content not available, use\n                                // inputstream\n                                renderResult = resource.getInputStream();\n                            } else {\n                                // Use the resource content directly\n                                ostream.write(resourceBody);\n                            }\n                        }\n                    }\n                    // If a stream was configured, it needs to be copied to\n                    // the output (this method closes the stream)\n                    if (renderResult != null) {\n                        copy(resource, renderResult, ostream);\n                    }\n                }\n            }\n\n        } else {\n\n            if ((ranges == null) || (ranges.isEmpty()))\n                return;\n\n            // Partial content response.\n\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n            if (ranges.size() == 1) {\n\n                Range range = ranges.get(0);\n                response.addHeader(\"Content-Range\", \"bytes \"\n                                   + range.start\n                                   + \"-\" + range.end + \"/\"\n                                   + range.length);\n                long length = range.end - range.start + 1;\n                response.setContentLengthLong(length);\n\n                if (contentType != null) {\n                    if (debug > 0)\n                        log(\"DefaultServlet.serveFile:  contentType='\" +\n                            contentType + \"'\");\n                    response.setContentType(contentType);\n                }\n\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        if (!checkSendfile(request, response, resource,\n                                range.end - range.start + 1, range))\n                            copy(resource, ostream, range);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            } else {\n                response.setContentType(\"multipart/byteranges; boundary=\"\n                                        + mimeSeparation);\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        copy(resource, ostream, ranges.iterator(), contentType);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "serveResource", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "boolean", "content", ",", "String", "encoding", ")", "throws", "IOException", ",", "ServletException", "{", "boolean", "serveContent", "=", "content", ";", "String", "path", "=", "getRelativePath", "(", "request", ",", "true", ")", ";", "if", "(", "debug", ">", "0", ")", "{", "if", "(", "serveContent", ")", "log", "(", "\"", "DefaultServlet.serveResource:  Serving resource '", "\"", "+", "path", "+", "\"", "' headers and data", "\"", ")", ";", "else", "log", "(", "\"", "DefaultServlet.serveResource:  Serving resource '", "\"", "+", "path", "+", "\"", "' headers only", "\"", ")", ";", "}", "if", "(", "path", ".", "length", "(", ")", "==", "0", ")", "{", "doDirectoryRedirect", "(", "request", ",", "response", ")", ";", "return", ";", "}", "WebResource", "resource", "=", "resources", ".", "getResource", "(", "path", ")", ";", "if", "(", "!", "resource", ".", "exists", "(", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "else", "{", "throw", "new", "FileNotFoundException", "(", "sm", ".", "getString", "(", "\"", "defaultServlet.missingResource", "\"", ",", "requestUri", ")", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "requestUri", ")", ";", "return", ";", "}", "if", "(", "!", "resource", ".", "canRead", "(", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "else", "{", "throw", "new", "FileNotFoundException", "(", "sm", ".", "getString", "(", "\"", "defaultServlet.missingResource", "\"", ",", "requestUri", ")", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ",", "requestUri", ")", ";", "return", ";", "}", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "(", "path", ".", "endsWith", "(", "\"", "/", "\"", ")", "||", "path", ".", "endsWith", "(", "\"", "\\\\", "\"", ")", ")", ")", "{", "String", "requestUri", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_REQUEST_URI", ")", ";", "if", "(", "requestUri", "==", "null", ")", "{", "requestUri", "=", "request", ".", "getRequestURI", "(", ")", ";", "}", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "requestUri", ")", ";", "return", ";", "}", "boolean", "isError", "=", "DispatcherType", ".", "ERROR", "==", "request", ".", "getDispatcherType", "(", ")", ";", "boolean", "included", "=", "false", ";", "if", "(", "resource", ".", "isFile", "(", ")", ")", "{", "included", "=", "(", "request", ".", "getAttribute", "(", "RequestDispatcher", ".", "INCLUDE_CONTEXT_PATH", ")", "!=", "null", ")", ";", "if", "(", "!", "included", "&&", "!", "isError", "&&", "!", "checkIfHeaders", "(", "request", ",", "response", ",", "resource", ")", ")", "{", "return", ";", "}", "}", "String", "contentType", "=", "resource", ".", "getMimeType", "(", ")", ";", "if", "(", "contentType", "==", "null", ")", "{", "contentType", "=", "getServletContext", "(", ")", ".", "getMimeType", "(", "resource", ".", "getName", "(", ")", ")", ";", "resource", ".", "setMimeType", "(", "contentType", ")", ";", "}", "String", "eTag", "=", "null", ";", "String", "lastModifiedHttp", "=", "null", ";", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "!", "isError", ")", "{", "eTag", "=", "resource", ".", "getETag", "(", ")", ";", "lastModifiedHttp", "=", "resource", ".", "getLastModifiedHttp", "(", ")", ";", "}", "boolean", "usingGzippedVersion", "=", "false", ";", "if", "(", "gzip", "&&", "!", "included", "&&", "resource", ".", "isFile", "(", ")", "&&", "!", "path", ".", "endsWith", "(", "\"", ".gz", "\"", ")", ")", "{", "WebResource", "gzipResource", "=", "resources", ".", "getResource", "(", "path", "+", "\"", ".gz", "\"", ")", ";", "if", "(", "gzipResource", ".", "exists", "(", ")", "&&", "gzipResource", ".", "isFile", "(", ")", ")", "{", "Collection", "<", "String", ">", "varyHeaders", "=", "response", ".", "getHeaders", "(", "\"", "Vary", "\"", ")", ";", "boolean", "addRequired", "=", "true", ";", "for", "(", "String", "varyHeader", ":", "varyHeaders", ")", "{", "if", "(", "\"", "*", "\"", ".", "equals", "(", "varyHeader", ")", "||", "\"", "accept-encoding", "\"", ".", "equalsIgnoreCase", "(", "varyHeader", ")", ")", "{", "addRequired", "=", "false", ";", "break", ";", "}", "}", "if", "(", "addRequired", ")", "{", "response", ".", "addHeader", "(", "\"", "Vary", "\"", ",", "\"", "accept-encoding", "\"", ")", ";", "}", "if", "(", "checkIfGzip", "(", "request", ")", ")", "{", "response", ".", "addHeader", "(", "\"", "Content-Encoding", "\"", ",", "\"", "gzip", "\"", ")", ";", "resource", "=", "gzipResource", ";", "usingGzippedVersion", "=", "true", ";", "}", "}", "}", "ArrayList", "<", "Range", ">", "ranges", "=", "null", ";", "long", "contentLength", "=", "-", "1L", ";", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "!", "path", ".", "endsWith", "(", "\"", "/", "\"", ")", ")", "{", "doDirectoryRedirect", "(", "request", ",", "response", ")", ";", "return", ";", "}", "if", "(", "!", "listings", ")", "{", "response", ".", "sendError", "(", "HttpServletResponse", ".", "SC_NOT_FOUND", ",", "request", ".", "getRequestURI", "(", ")", ")", ";", "return", ";", "}", "contentType", "=", "\"", "text/html;charset=UTF-8", "\"", ";", "}", "else", "{", "if", "(", "!", "isError", ")", "{", "if", "(", "useAcceptRanges", ")", "{", "response", ".", "setHeader", "(", "\"", "Accept-Ranges", "\"", ",", "\"", "bytes", "\"", ")", ";", "}", "ranges", "=", "parseRange", "(", "request", ",", "response", ",", "resource", ")", ";", "response", ".", "setHeader", "(", "\"", "ETag", "\"", ",", "eTag", ")", ";", "response", ".", "setHeader", "(", "\"", "Last-Modified", "\"", ",", "lastModifiedHttp", ")", ";", "}", "contentLength", "=", "resource", ".", "getContentLength", "(", ")", ";", "if", "(", "contentLength", "==", "0L", ")", "{", "serveContent", "=", "false", ";", "}", "}", "ServletOutputStream", "ostream", "=", "null", ";", "PrintWriter", "writer", "=", "null", ";", "if", "(", "serveContent", ")", "{", "try", "{", "ostream", "=", "response", ".", "getOutputStream", "(", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "if", "(", "!", "usingGzippedVersion", "&&", "(", "(", "contentType", "==", "null", ")", "||", "(", "contentType", ".", "startsWith", "(", "\"", "text", "\"", ")", ")", "||", "(", "contentType", ".", "endsWith", "(", "\"", "xml", "\"", ")", ")", "||", "(", "contentType", ".", "contains", "(", "\"", "/javascript", "\"", ")", ")", ")", ")", "{", "writer", "=", "response", ".", "getWriter", "(", ")", ";", "ranges", "=", "FULL", ";", "}", "else", "{", "throw", "e", ";", "}", "}", "}", "ServletResponse", "r", "=", "response", ";", "long", "contentWritten", "=", "0", ";", "while", "(", "r", "instanceof", "ServletResponseWrapper", ")", "{", "r", "=", "(", "(", "ServletResponseWrapper", ")", "r", ")", ".", "getResponse", "(", ")", ";", "}", "if", "(", "r", "instanceof", "ResponseFacade", ")", "{", "contentWritten", "=", "(", "(", "ResponseFacade", ")", "r", ")", ".", "getContentWritten", "(", ")", ";", "}", "if", "(", "contentWritten", ">", "0", ")", "{", "ranges", "=", "FULL", ";", "}", "if", "(", "resource", ".", "isDirectory", "(", ")", "||", "isError", "||", "(", "(", "ranges", "==", "null", "||", "ranges", ".", "isEmpty", "(", ")", ")", "&&", "request", ".", "getHeader", "(", "\"", "Range", "\"", ")", "==", "null", ")", "||", "ranges", "==", "FULL", ")", "{", "if", "(", "contentType", "!=", "null", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentType='", "\"", "+", "contentType", "+", "\"", "'", "\"", ")", ";", "response", ".", "setContentType", "(", "contentType", ")", ";", "}", "if", "(", "resource", ".", "isFile", "(", ")", "&&", "contentLength", ">=", "0", "&&", "(", "!", "serveContent", "||", "ostream", "!=", "null", ")", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentLength=", "\"", "+", "contentLength", ")", ";", "if", "(", "contentWritten", "==", "0", ")", "{", "response", ".", "setContentLengthLong", "(", "contentLength", ")", ";", "}", "}", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "InputStream", "renderResult", "=", "null", ";", "if", "(", "ostream", "==", "null", ")", "{", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "renderResult", "=", "render", "(", "getPathPrefix", "(", "request", ")", ",", "resource", ",", "encoding", ")", ";", "}", "else", "{", "renderResult", "=", "resource", ".", "getInputStream", "(", ")", ";", "}", "copy", "(", "resource", ",", "renderResult", ",", "writer", ",", "encoding", ")", ";", "}", "else", "{", "if", "(", "resource", ".", "isDirectory", "(", ")", ")", "{", "renderResult", "=", "render", "(", "getPathPrefix", "(", "request", ")", ",", "resource", ",", "encoding", ")", ";", "}", "else", "{", "if", "(", "!", "checkSendfile", "(", "request", ",", "response", ",", "resource", ",", "contentLength", ",", "null", ")", ")", "{", "byte", "[", "]", "resourceBody", "=", "resource", ".", "getContent", "(", ")", ";", "if", "(", "resourceBody", "==", "null", ")", "{", "renderResult", "=", "resource", ".", "getInputStream", "(", ")", ";", "}", "else", "{", "ostream", ".", "write", "(", "resourceBody", ")", ";", "}", "}", "}", "if", "(", "renderResult", "!=", "null", ")", "{", "copy", "(", "resource", ",", "renderResult", ",", "ostream", ")", ";", "}", "}", "}", "}", "else", "{", "if", "(", "(", "ranges", "==", "null", ")", "||", "(", "ranges", ".", "isEmpty", "(", ")", ")", ")", "return", ";", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_PARTIAL_CONTENT", ")", ";", "if", "(", "ranges", ".", "size", "(", ")", "==", "1", ")", "{", "Range", "range", "=", "ranges", ".", "get", "(", "0", ")", ";", "response", ".", "addHeader", "(", "\"", "Content-Range", "\"", ",", "\"", "bytes ", "\"", "+", "range", ".", "start", "+", "\"", "-", "\"", "+", "range", ".", "end", "+", "\"", "/", "\"", "+", "range", ".", "length", ")", ";", "long", "length", "=", "range", ".", "end", "-", "range", ".", "start", "+", "1", ";", "response", ".", "setContentLengthLong", "(", "length", ")", ";", "if", "(", "contentType", "!=", "null", ")", "{", "if", "(", "debug", ">", "0", ")", "log", "(", "\"", "DefaultServlet.serveFile:  contentType='", "\"", "+", "contentType", "+", "\"", "'", "\"", ")", ";", "response", ".", "setContentType", "(", "contentType", ")", ";", "}", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "if", "(", "ostream", "!=", "null", ")", "{", "if", "(", "!", "checkSendfile", "(", "request", ",", "response", ",", "resource", ",", "range", ".", "end", "-", "range", ".", "start", "+", "1", ",", "range", ")", ")", "copy", "(", "resource", ",", "ostream", ",", "range", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "}", "}", "else", "{", "response", ".", "setContentType", "(", "\"", "multipart/byteranges; boundary=", "\"", "+", "mimeSeparation", ")", ";", "if", "(", "serveContent", ")", "{", "try", "{", "response", ".", "setBufferSize", "(", "output", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "if", "(", "ostream", "!=", "null", ")", "{", "copy", "(", "resource", ",", "ostream", ",", "ranges", ".", "iterator", "(", ")", ",", "contentType", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "}", "}", "}", "}"], "idx": 74753, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "e070a31ec81b56377822e44883c64abb41f36a3b", "function_name": "serveResource", "body_hash": "0a96e6cc76ba77a20b40c8c0156df87b6b7fd180"}
{"code": "public void setPreservedState(String stateKey, Object preservedState) {\n\t\tstate.put(stateKey, preservedState);\n\t}", "code_tokens": ["public", "void", "setPreservedState", "(", "String", "stateKey", ",", "Object", "preservedState", ")", "{", "state", ".", "put", "(", "stateKey", ",", "preservedState", ")", ";", "}"], "idx": 52670, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "3379a36e64c13e4118c7e179f3a874a64de5f5a2", "function_name": "setPreservedState", "body_hash": "1b2fd2396a1419431ba3c79629436da2846190f0"}
{"code": "protected boolean evaluate(InputSource inputSource)\n   {\n      try\n      {\n         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n         factory.setNamespaceAware(true);\n         DocumentBuilder dbuilder = factory.newDocumentBuilder();\n         Document doc = dbuilder.parse(inputSource);\n\n         //An XPath expression could return a true or false value instead of a node.\n         //eval() is a better way to determine the boolean value of the exp.\n         //For compliance with legacy behavior where selecting an empty node returns true,\n         //selectNodeIterator is attempted in case of a failure.\n\n         CachedXPathAPI cachedXPathAPI = new CachedXPathAPI();\n         XObject result = cachedXPathAPI.eval(doc, xpath);\n         if (result.bool())\n            return true;\n         else\n         {\n            NodeIterator iterator = cachedXPathAPI.selectNodeIterator(doc, xpath);\n            return (iterator.nextNode() != null);\n         }\n\n      }\n      catch (Throwable e)\n      {\n         return false;\n      }\n   }", "code_tokens": ["protected", "boolean", "evaluate", "(", "InputSource", "inputSource", ")", "{", "try", "{", "DocumentBuilderFactory", "factory", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setNamespaceAware", "(", "true", ")", ";", "DocumentBuilder", "dbuilder", "=", "factory", ".", "newDocumentBuilder", "(", ")", ";", "Document", "doc", "=", "dbuilder", ".", "parse", "(", "inputSource", ")", ";", "CachedXPathAPI", "cachedXPathAPI", "=", "new", "CachedXPathAPI", "(", ")", ";", "XObject", "result", "=", "cachedXPathAPI", ".", "eval", "(", "doc", ",", "xpath", ")", ";", "if", "(", "result", ".", "bool", "(", ")", ")", "return", "true", ";", "else", "{", "NodeIterator", "iterator", "=", "cachedXPathAPI", ".", "selectNodeIterator", "(", "doc", ",", "xpath", ")", ";", "return", "(", "iterator", ".", "nextNode", "(", ")", "!=", "null", ")", ";", "}", "}", "catch", "(", "Throwable", "e", ")", "{", "return", "false", ";", "}", "}"], "idx": 66019, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "48d9951d879e0c8cbb59d4b64ab59d53ef88310d", "function_name": "evaluate", "body_hash": "092019f8fb8afb2916eea41424777528d6bea06a"}
{"code": "@Exported(name=\"property\",inline=true)\n    public List<UserProperty> getAllProperties() {\n        return Collections.unmodifiableList(properties);\n    }", "code_tokens": ["@", "Exported", "(", "name", "=", "\"", "property", "\"", ",", "inline", "=", "true", ")", "public", "List", "<", "UserProperty", ">", "getAllProperties", "(", ")", "{", "return", "Collections", ".", "unmodifiableList", "(", "properties", ")", ";", "}"], "idx": 14850, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "7b1f8e96a8d97dd09e5e093fcdb010b3295acc77", "function_name": "getAllProperties", "body_hash": "32c895e7d8917e57cbd74e23ad01d632e2b46933"}
{"code": "@Override public MercurialChangeSetList parse(Run build, RepositoryBrowser<?> browser, File changelogFile)\n            throws IOException, SAXException {\n        Digester digester = new Digester2();\n        ArrayList<MercurialChangeSet> r = new ArrayList<MercurialChangeSet>();\n        digester.push(r);\n\n        digester.addObjectCreate(\"*/changeset\", MercurialChangeSet.class);\n        digester.addSetProperties(\"*/changeset\");\n        digester.addSetProperties(\"*/changeset\", \"author\", \"user\");\n        digester.addBeanPropertySetter(\"*/changeset/msg\");\n        // Before JENKINS-55319:\n        digester.addBeanPropertySetter(\"*/changeset/added\");\n        digester.addBeanPropertySetter(\"*/changeset/deleted\");\n        digester.addBeanPropertySetter(\"*/changeset/files\");\n        // After JENKINS-55319:\n        digester.addCallMethod(\"*/changeset/file\", \"addFile\", 1);\n        digester.addCallParam(\"*/changeset/file\", 0);\n        digester.addCallMethod(\"*/changeset/addedFile\", \"addAddedFile\", 1);\n        digester.addCallParam(\"*/changeset/addedFile\", 0);\n        digester.addCallMethod(\"*/changeset/deletedFile\", \"addDeletedFile\", 1);\n        digester.addCallParam(\"*/changeset/deletedFile\", 0);\n        digester.addBeanPropertySetter(\"*/changeset/parents\");\n        digester.addSetNext(\"*/changeset\", \"add\");\n\n        try {\n            digester.parse(changelogFile);\n        } catch (IOException e) {\n            throw new IOException(\"Failed to parse \" + changelogFile, e);\n        } catch (SAXException e) {\n            throw new IOException(\"Failed to parse \" + changelogFile + \": '\" + Util.loadFile(changelogFile) + \"'\", e);\n        }\n\n        if (modules != null) {\n            Iterator<MercurialChangeSet> it = r.iterator();\n            while (it.hasNext()) {\n                boolean include = false;\n                INCLUDE: for (String path : it.next().getAffectedPaths()) {\n                    for (String module : modules) {\n                        if (path.startsWith(module)) {\n                            include = true;\n                            break INCLUDE;\n                        }\n                    }\n                }\n                if (!include) {\n                    it.remove();\n                }\n            }\n        }\n\n        // sort the changes from oldest to newest, this gives the best result in\n        // the Jenkins changes view,\n        // and is like the old situation where 'hg incoming' was used to\n        // determine the changelog\n        r.sort(Comparator.comparingLong(MercurialChangeSet::getRev));\n\n        return new MercurialChangeSetList(build, browser, r);\n    }", "code_tokens": ["@", "Override", "public", "MercurialChangeSetList", "parse", "(", "Run", "build", ",", "RepositoryBrowser", "<", "?", ">", "browser", ",", "File", "changelogFile", ")", "throws", "IOException", ",", "SAXException", "{", "Digester", "digester", "=", "new", "Digester2", "(", ")", ";", "ArrayList", "<", "MercurialChangeSet", ">", "r", "=", "new", "ArrayList", "<", "MercurialChangeSet", ">", "(", ")", ";", "digester", ".", "push", "(", "r", ")", ";", "digester", ".", "addObjectCreate", "(", "\"", "*/changeset", "\"", ",", "MercurialChangeSet", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "\"", "*/changeset", "\"", ")", ";", "digester", ".", "addSetProperties", "(", "\"", "*/changeset", "\"", ",", "\"", "author", "\"", ",", "\"", "user", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/changeset/msg", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/changeset/added", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/changeset/deleted", "\"", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/changeset/files", "\"", ")", ";", "digester", ".", "addCallMethod", "(", "\"", "*/changeset/file", "\"", ",", "\"", "addFile", "\"", ",", "1", ")", ";", "digester", ".", "addCallParam", "(", "\"", "*/changeset/file", "\"", ",", "0", ")", ";", "digester", ".", "addCallMethod", "(", "\"", "*/changeset/addedFile", "\"", ",", "\"", "addAddedFile", "\"", ",", "1", ")", ";", "digester", ".", "addCallParam", "(", "\"", "*/changeset/addedFile", "\"", ",", "0", ")", ";", "digester", ".", "addCallMethod", "(", "\"", "*/changeset/deletedFile", "\"", ",", "\"", "addDeletedFile", "\"", ",", "1", ")", ";", "digester", ".", "addCallParam", "(", "\"", "*/changeset/deletedFile", "\"", ",", "0", ")", ";", "digester", ".", "addBeanPropertySetter", "(", "\"", "*/changeset/parents", "\"", ")", ";", "digester", ".", "addSetNext", "(", "\"", "*/changeset", "\"", ",", "\"", "add", "\"", ")", ";", "try", "{", "digester", ".", "parse", "(", "changelogFile", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "IOException", "(", "\"", "Failed to parse ", "\"", "+", "changelogFile", ",", "e", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "throw", "new", "IOException", "(", "\"", "Failed to parse ", "\"", "+", "changelogFile", "+", "\"", ": '", "\"", "+", "Util", ".", "loadFile", "(", "changelogFile", ")", "+", "\"", "'", "\"", ",", "e", ")", ";", "}", "if", "(", "modules", "!=", "null", ")", "{", "Iterator", "<", "MercurialChangeSet", ">", "it", "=", "r", ".", "iterator", "(", ")", ";", "while", "(", "it", ".", "hasNext", "(", ")", ")", "{", "boolean", "include", "=", "false", ";", "INCLUDE", ":", "for", "(", "String", "path", ":", "it", ".", "next", "(", ")", ".", "getAffectedPaths", "(", ")", ")", "{", "for", "(", "String", "module", ":", "modules", ")", "{", "if", "(", "path", ".", "startsWith", "(", "module", ")", ")", "{", "include", "=", "true", ";", "break", "INCLUDE", ";", "}", "}", "}", "if", "(", "!", "include", ")", "{", "it", ".", "remove", "(", ")", ";", "}", "}", "}", "r", ".", "sort", "(", "Comparator", ".", "comparingLong", "(", "MercurialChangeSet", "::", "getRev", ")", ")", ";", "return", "new", "MercurialChangeSetList", "(", "build", ",", "browser", ",", "r", ")", ";", "}"], "idx": 69719, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "84af58b08f80bb92792f7bc04a31487f3eeee95a", "function_name": "parse", "body_hash": "eee6b52de6ec4a34a595af8b035797274e7debd8"}
{"code": "protected boolean acceptableName(String name) {\n        return isWithinLengthLimit(name) && isAccepted(name)\n                && !isExcluded(name);\n    }", "code_tokens": ["protected", "boolean", "acceptableName", "(", "String", "name", ")", "{", "return", "isWithinLengthLimit", "(", "name", ")", "&&", "isAccepted", "(", "name", ")", "&&", "!", "isExcluded", "(", "name", ")", ";", "}"], "idx": 35290, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "87935af56a27235e9399308ee1fcfb74f8edcefa", "function_name": "acceptableName", "body_hash": "64e215bb57ae8bc68477dc30b78d99236fa47f56"}
{"code": "void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    String replacement = canonicalizeForPath(value, encoded);\n    String newRelativeUrl = relativeUrl.replace(\"{\" + name + \"}\", replacement);\n    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {\n      throw new IllegalArgumentException(\n          \"@Path parameters shouldn't perform path traversal ('.' or '..'): \" + value);\n    }\n    relativeUrl = newRelativeUrl;\n  }", "code_tokens": ["void", "addPathParam", "(", "String", "name", ",", "String", "value", ",", "boolean", "encoded", ")", "{", "if", "(", "relativeUrl", "==", "null", ")", "{", "throw", "new", "AssertionError", "(", ")", ";", "}", "String", "replacement", "=", "canonicalizeForPath", "(", "value", ",", "encoded", ")", ";", "String", "newRelativeUrl", "=", "relativeUrl", ".", "replace", "(", "\"", "{", "\"", "+", "name", "+", "\"", "}", "\"", ",", "replacement", ")", ";", "if", "(", "PATH_TRAVERSAL", ".", "matcher", "(", "newRelativeUrl", ")", ".", "matches", "(", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "@Path parameters shouldn't perform path traversal ('.' or '..'): ", "\"", "+", "value", ")", ";", "}", "relativeUrl", "=", "newRelativeUrl", ";", "}"], "idx": 25845, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "b9a7f6ad72073ddd40254c0058710e87a073047d", "function_name": "addPathParam", "body_hash": "b288dad0c119e322caca664cf3b03f01ad2057ae"}
{"code": "private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }", "code_tokens": ["private", "void", "init", "(", ")", "{", "addImmutableType", "(", "Result", ".", "class", ")", ";", "registerConverter", "(", "new", "RobustCollectionConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "RobustMapConverter", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableMapConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSortedSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableSetConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ImmutableListConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "ConcurrentHashMapConverter", "(", "getMapper", "(", ")", ",", "getReflectionProvider", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "CopyOnWriteMap", ".", "Tree", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "DescribableList", ".", "ConverterImpl", "(", "getMapper", "(", ")", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "Label", ".", "ConverterImpl", "(", ")", ",", "10", ")", ";", "registerConverter", "(", "new", "AssociatedConverterImpl", "(", "this", ")", ",", "-", "10", ")", ";", "registerConverter", "(", "new", "DynamicProxyConverter", "(", "getMapper", "(", ")", ")", "{", "@", "Override", "public", "boolean", "canConvert", "(", "Class", "type", ")", "{", "return", "type", "!=", "null", "&&", "super", ".", "canConvert", "(", "type", ")", ";", "}", "@", "Override", "public", "Object", "unmarshal", "(", "HierarchicalStreamReader", "reader", ",", "UnmarshallingContext", "context", ")", "{", "throw", "new", "ConversionException", "(", "\"", "<dynamic-proxy> not supported", "\"", ")", ";", "}", "}", ",", "PRIORITY_VERY_HIGH", ")", ";", "}"], "idx": 6181, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "18cc8e0eb7d8c9910ce8ce2a9c8dab4c4df8b9c2", "function_name": "init", "body_hash": "6da137398f93813f8695b98a1718453240817990"}
{"code": "@Override\n    protected void doExecute(CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n        final Authentication authentication = securityContext.getAuthentication();\n        if (authentication == null) {\n            listener.onFailure(new IllegalStateException(\"authentication is required\"));\n        } else {\n            if (Authentication.AuthenticationType.API_KEY == authentication.getAuthenticationType() && grantsAnyPrivileges(request)) {\n                listener.onFailure(new IllegalArgumentException(\n                    \"creating derived api keys requires an explicit role descriptor that is empty (has no privileges)\"));\n                return;\n            }\n            rolesStore.getRoleDescriptors(new HashSet<>(Arrays.asList(authentication.getUser().roles())),\n                ActionListener.wrap(roleDescriptors -> apiKeyService.createApiKey(authentication, request, roleDescriptors, listener),\n                    listener::onFailure));\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "doExecute", "(", "CreateApiKeyRequest", "request", ",", "ActionListener", "<", "CreateApiKeyResponse", ">", "listener", ")", "{", "final", "Authentication", "authentication", "=", "securityContext", ".", "getAuthentication", "(", ")", ";", "if", "(", "authentication", "==", "null", ")", "{", "listener", ".", "onFailure", "(", "new", "IllegalStateException", "(", "\"", "authentication is required", "\"", ")", ")", ";", "}", "else", "{", "if", "(", "Authentication", ".", "AuthenticationType", ".", "API_KEY", "==", "authentication", ".", "getAuthenticationType", "(", ")", "&&", "grantsAnyPrivileges", "(", "request", ")", ")", "{", "listener", ".", "onFailure", "(", "new", "IllegalArgumentException", "(", "\"", "creating derived api keys requires an explicit role descriptor that is empty (has no privileges)", "\"", ")", ")", ";", "return", ";", "}", "rolesStore", ".", "getRoleDescriptors", "(", "new", "HashSet", "<", ">", "(", "Arrays", ".", "asList", "(", "authentication", ".", "getUser", "(", ")", ".", "roles", "(", ")", ")", ")", ",", "ActionListener", ".", "wrap", "(", "roleDescriptors", "->", "apiKeyService", ".", "createApiKey", "(", "authentication", ",", "request", ",", "roleDescriptors", ",", "listener", ")", ",", "listener", "::", "onFailure", ")", ")", ";", "}", "}"], "idx": 36388, "cwe": "CWE-269", "target": 0, "status": "FIXED", "commit": "1c5f53076b625c44111c1e9430dc36327a088583", "function_name": "doExecute", "body_hash": "b835149a7122fc51df76a9380a1d6e8022d50674"}
{"code": "private static void processHeaderConfig(MultivaluedMap<String, String> httpHeaders, Object object, String key, String prefix) {\n        try {\n            String property = StringUtils.removeStart(key, prefix);\n            Field field = object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n\n            field.setAccessible(true);\n            if (field.getType() == String.class) {\n                field.set(object, httpHeaders.getFirst(key));\n            } else if (field.getType() == int.class) {\n                field.setInt(object, Integer.parseInt(httpHeaders.getFirst(key)));\n            } else if (field.getType() == double.class) {\n                field.setDouble(object, Double.parseDouble(httpHeaders.getFirst(key)));\n            } else if (field.getType() == boolean.class) {\n                field.setBoolean(object, Boolean.parseBoolean(httpHeaders.getFirst(key)));\n            } else {\n                //couldn't find a directly accessible field\n                //try for setX(String s)\n                String setter = StringUtils.uncapitalize(property);\n                setter = \"set\"+setter.substring(0,1).toUpperCase(Locale.US)+setter.substring(1);\n                Method m = null;\n                try {\n                    m = object.getClass().getMethod(setter, String.class);\n                } catch (NoSuchMethodException e) {\n                    //swallow\n                }\n                if (m != null) {\n                    m.invoke(object, httpHeaders.getFirst(key));\n                }\n            }\n        } catch (Throwable ex) {\n            throw new WebApplicationException(String.format(Locale.ROOT,\n                    \"%s is an invalid %s header\", key, X_TIKA_OCR_HEADER_PREFIX));\n        }\n    }", "code_tokens": ["private", "static", "void", "processHeaderConfig", "(", "MultivaluedMap", "<", "String", ",", "String", ">", "httpHeaders", ",", "Object", "object", ",", "String", "key", ",", "String", "prefix", ")", "{", "try", "{", "String", "property", "=", "StringUtils", ".", "removeStart", "(", "key", ",", "prefix", ")", ";", "Field", "field", "=", "object", ".", "getClass", "(", ")", ".", "getDeclaredField", "(", "StringUtils", ".", "uncapitalize", "(", "property", ")", ")", ";", "field", ".", "setAccessible", "(", "true", ")", ";", "if", "(", "field", ".", "getType", "(", ")", "==", "String", ".", "class", ")", "{", "field", ".", "set", "(", "object", ",", "httpHeaders", ".", "getFirst", "(", "key", ")", ")", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "int", ".", "class", ")", "{", "field", ".", "setInt", "(", "object", ",", "Integer", ".", "parseInt", "(", "httpHeaders", ".", "getFirst", "(", "key", ")", ")", ")", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "double", ".", "class", ")", "{", "field", ".", "setDouble", "(", "object", ",", "Double", ".", "parseDouble", "(", "httpHeaders", ".", "getFirst", "(", "key", ")", ")", ")", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "boolean", ".", "class", ")", "{", "field", ".", "setBoolean", "(", "object", ",", "Boolean", ".", "parseBoolean", "(", "httpHeaders", ".", "getFirst", "(", "key", ")", ")", ")", ";", "}", "else", "{", "String", "setter", "=", "StringUtils", ".", "uncapitalize", "(", "property", ")", ";", "setter", "=", "\"", "set", "\"", "+", "setter", ".", "substring", "(", "0", ",", "1", ")", ".", "toUpperCase", "(", "Locale", ".", "US", ")", "+", "setter", ".", "substring", "(", "1", ")", ";", "Method", "m", "=", "null", ";", "try", "{", "m", "=", "object", ".", "getClass", "(", ")", ".", "getMethod", "(", "setter", ",", "String", ".", "class", ")", ";", "}", "catch", "(", "NoSuchMethodException", "e", ")", "{", "}", "if", "(", "m", "!=", "null", ")", "{", "m", ".", "invoke", "(", "object", ",", "httpHeaders", ".", "getFirst", "(", "key", ")", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "ex", ")", "{", "throw", "new", "WebApplicationException", "(", "String", ".", "format", "(", "Locale", ".", "ROOT", ",", "\"", "%s is an invalid %s header", "\"", ",", "key", ",", "X_TIKA_OCR_HEADER_PREFIX", ")", ")", ";", "}", "}"], "idx": 109154, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "e82c2efd2b1ac731b6954634741b70ecf0ed6f01", "function_name": "processHeaderConfig", "body_hash": "cfa5e1bf153834944760066a792ee45b2714ce96"}
{"code": "default URL findConfigFile( final String name ) {\n        LogManager.getLogger( Engine.class ).info( \"looking for \" + name + \" inside WEB-INF \" );\n        // Try creating an absolute path first\n        File defaultFile = null;\n        if( getRootPath() != null ) {\n            defaultFile = new File( getRootPath() + \"/WEB-INF/\" + name );\n        }\n        if ( defaultFile != null && defaultFile.exists() ) {\n            try {\n                return defaultFile.toURI().toURL();\n            } catch ( final MalformedURLException e ) {\n                // Shouldn't happen, but log it if it does\n                LogManager.getLogger( Engine.class ).warn( \"Malformed URL: \" + e.getMessage() );\n            }\n        }\n\n        // Ok, the absolute path didn't work; try other methods\n        URL path = null;\n\n        if( getServletContext() != null ) {\n            final File tmpFile;\n            try {\n                tmpFile = File.createTempFile( \"temp.\" + name, \"\" );\n            } catch( final IOException e ) {\n                LogManager.getLogger( Engine.class ).error( \"unable to create a temp file to load onto the policy\", e );\n                return null;\n            }\n            tmpFile.deleteOnExit();\n            LogManager.getLogger( Engine.class ).info( \"looking for /\" + name + \" on classpath\" );\n            //  create a tmp file of the policy loaded as an InputStream and return the URL to it\n            try( final InputStream is = Engine.class.getResourceAsStream( \"/\" + name );\n                    final OutputStream os = new FileOutputStream( tmpFile ) ) {\n                if( is == null ) {\n                    throw new FileNotFoundException( name + \" not found\" );\n                }\n                final URL url = getServletContext().getResource( \"/WEB-INF/\" + name );\n                if( url != null ) {\n                    return url;\n                }\n\n                final byte[] buff = new byte[1024];\n                int bytes;\n                while( ( bytes = is.read( buff ) ) != -1 ) {\n                    os.write( buff, 0, bytes );\n                }\n\n                path = tmpFile.toURI().toURL();\n            } catch( final MalformedURLException e ) {\n                // This should never happen unless I screw up\n                LogManager.getLogger( Engine.class ).fatal( \"Your code is b0rked.  You are a bad person.\", e );\n            } catch( final IOException e ) {\n                LogManager.getLogger( Engine.class ).error( \"failed to load security policy from file \" + name + \",stacktrace follows\", e );\n            }\n        }\n        return path;\n    }", "code_tokens": ["default", "URL", "findConfigFile", "(", "final", "String", "name", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "info", "(", "\"", "looking for ", "\"", "+", "name", "+", "\"", " inside WEB-INF ", "\"", ")", ";", "File", "defaultFile", "=", "null", ";", "if", "(", "getRootPath", "(", ")", "!=", "null", ")", "{", "defaultFile", "=", "new", "File", "(", "getRootPath", "(", ")", "+", "\"", "/WEB-INF/", "\"", "+", "name", ")", ";", "}", "if", "(", "defaultFile", "!=", "null", "&&", "defaultFile", ".", "exists", "(", ")", ")", "{", "try", "{", "return", "defaultFile", ".", "toURI", "(", ")", ".", "toURL", "(", ")", ";", "}", "catch", "(", "final", "MalformedURLException", "e", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "warn", "(", "\"", "Malformed URL: ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "URL", "path", "=", "null", ";", "if", "(", "getServletContext", "(", ")", "!=", "null", ")", "{", "final", "File", "tmpFile", ";", "try", "{", "tmpFile", "=", "File", ".", "createTempFile", "(", "\"", "temp.", "\"", "+", "name", ",", "\"", "\"", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "error", "(", "\"", "unable to create a temp file to load onto the policy", "\"", ",", "e", ")", ";", "return", "null", ";", "}", "tmpFile", ".", "deleteOnExit", "(", ")", ";", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "info", "(", "\"", "looking for /", "\"", "+", "name", "+", "\"", " on classpath", "\"", ")", ";", "try", "(", "final", "InputStream", "is", "=", "Engine", ".", "class", ".", "getResourceAsStream", "(", "\"", "/", "\"", "+", "name", ")", ";", "final", "OutputStream", "os", "=", "new", "FileOutputStream", "(", "tmpFile", ")", ")", "{", "if", "(", "is", "==", "null", ")", "{", "throw", "new", "FileNotFoundException", "(", "name", "+", "\"", " not found", "\"", ")", ";", "}", "final", "URL", "url", "=", "getServletContext", "(", ")", ".", "getResource", "(", "\"", "/WEB-INF/", "\"", "+", "name", ")", ";", "if", "(", "url", "!=", "null", ")", "{", "return", "url", ";", "}", "final", "byte", "[", "]", "buff", "=", "new", "byte", "[", "1024", "]", ";", "int", "bytes", ";", "while", "(", "(", "bytes", "=", "is", ".", "read", "(", "buff", ")", ")", "!=", "-", "1", ")", "{", "os", ".", "write", "(", "buff", ",", "0", ",", "bytes", ")", ";", "}", "path", "=", "tmpFile", ".", "toURI", "(", ")", ".", "toURL", "(", ")", ";", "}", "catch", "(", "final", "MalformedURLException", "e", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "fatal", "(", "\"", "Your code is b0rked.  You are a bad person.", "\"", ",", "e", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "LogManager", ".", "getLogger", "(", "Engine", ".", "class", ")", ".", "error", "(", "\"", "failed to load security policy from file ", "\"", "+", "name", "+", "\"", ",stacktrace follows", "\"", ",", "e", ")", ";", "}", "}", "return", "path", ";", "}"], "idx": 36482, "cwe": "CWE-276", "target": 1, "status": "VULNERABLE", "commit": "800196dc239553ee2ea8f71754f8ee3f85bcf70f", "function_name": "findConfigFile", "body_hash": "739514f6572eadd722beda23faa22dd388701bd3"}
{"code": "public List<Map<String, Object>> read(int headerRowIndex, int startRowIndex, int endRowIndex) {\r\n\t\tcheckNotClosed();\r\n\t\t// \u8fb9\u754c\u5224\u65ad\r\n\t\tfinal int firstRowNum = sheet.getFirstRowNum();\r\n\t\tfinal int lastRowNum = sheet.getLastRowNum();\r\n\t\tif (headerRowIndex < firstRowNum) {\r\n\t\t\tthrow new IndexOutOfBoundsException(StrUtil.format(\"Header row index {} is lower than first row index {}.\", headerRowIndex, firstRowNum));\r\n\t\t} else if (headerRowIndex > lastRowNum) {\r\n\t\t\tthrow new IndexOutOfBoundsException(StrUtil.format(\"Header row index {} is greater than last row index {}.\", headerRowIndex, firstRowNum));\r\n\t\t}\r\n\t\tstartRowIndex = Math.max(startRowIndex, firstRowNum);// \u8bfb\u53d6\u8d77\u59cb\u884c\uff08\u5305\u542b\uff09\r\n\t\tendRowIndex = Math.min(endRowIndex, lastRowNum);// \u8bfb\u53d6\u7ed3\u675f\u884c\uff08\u5305\u542b\uff09\r\n\r\n\t\t// \u8bfb\u53d6header\r\n\t\tList<Object> headerList = readRow(sheet.getRow(headerRowIndex));\r\n\r\n\t\tfinal List<Map<String, Object>> result = new ArrayList<>(endRowIndex - startRowIndex + 1);\r\n\t\tList<Object> rowList;\r\n\t\tfor (int i = startRowIndex; i <= endRowIndex; i++) {\r\n\t\t\tif (i != headerRowIndex) {\r\n\t\t\t\t// \u8df3\u8fc7\u6807\u9898\u884c\r\n\t\t\t\trowList = readRow(sheet.getRow(i));\r\n\t\t\t\tif (CollUtil.isNotEmpty(rowList) || false == ignoreEmptyRow) {\r\n\t\t\t\t\tif (null == rowList) {\r\n\t\t\t\t\t\trowList = new ArrayList<>(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult.add(IterUtil.toMap(aliasHeader(headerList), rowList, true));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "code_tokens": ["public", "List", "<", "Map", "<", "String", ",", "Object", ">", ">", "read", "(", "int", "headerRowIndex", ",", "int", "startRowIndex", ",", "int", "endRowIndex", ")", "{", "checkNotClosed", "(", ")", ";", "final", "int", "firstRowNum", "=", "sheet", ".", "getFirstRowNum", "(", ")", ";", "final", "int", "lastRowNum", "=", "sheet", ".", "getLastRowNum", "(", ")", ";", "if", "(", "headerRowIndex", "<", "firstRowNum", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", "StrUtil", ".", "format", "(", "\"", "Header row index {} is lower than first row index {}.", "\"", ",", "headerRowIndex", ",", "firstRowNum", ")", ")", ";", "}", "else", "if", "(", "headerRowIndex", ">", "lastRowNum", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", "StrUtil", ".", "format", "(", "\"", "Header row index {} is greater than last row index {}.", "\"", ",", "headerRowIndex", ",", "firstRowNum", ")", ")", ";", "}", "startRowIndex", "=", "Math", ".", "max", "(", "startRowIndex", ",", "firstRowNum", ")", ";", "endRowIndex", "=", "Math", ".", "min", "(", "endRowIndex", ",", "lastRowNum", ")", ";", "List", "<", "Object", ">", "headerList", "=", "readRow", "(", "sheet", ".", "getRow", "(", "headerRowIndex", ")", ")", ";", "final", "List", "<", "Map", "<", "String", ",", "Object", ">", ">", "result", "=", "new", "ArrayList", "<", ">", "(", "endRowIndex", "-", "startRowIndex", "+", "1", ")", ";", "List", "<", "Object", ">", "rowList", ";", "for", "(", "int", "i", "=", "startRowIndex", ";", "i", "<=", "endRowIndex", ";", "i", "++", ")", "{", "if", "(", "i", "!=", "headerRowIndex", ")", "{", "rowList", "=", "readRow", "(", "sheet", ".", "getRow", "(", "i", ")", ")", ";", "if", "(", "CollUtil", ".", "isNotEmpty", "(", "rowList", ")", "||", "false", "==", "ignoreEmptyRow", ")", "{", "if", "(", "null", "==", "rowList", ")", "{", "rowList", "=", "new", "ArrayList", "<", ">", "(", "0", ")", ";", "}", "result", ".", "add", "(", "IterUtil", ".", "toMap", "(", "aliasHeader", "(", "headerList", ")", ",", "rowList", ",", "true", ")", ")", ";", "}", "}", "}", "return", "result", ";", "}"], "idx": 23400, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "9f8a801c7b98b75ee681c0988e1a58bcfdc21756", "function_name": "read", "body_hash": "1687c023964e50a6cb09e0b19cedf7feb8419896"}
{"code": "public static String getPropertyDef(InputSpec inputSpec, Map<String, Integer> indexes, \n\t\t\tString pattern, DefaultValueProvider defaultValueProvider) {\n\t\tpattern = InputSpec.escape(pattern);\n\t\tint index = indexes.get(inputSpec.getName());\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tinputSpec.appendField(buffer, index, \"String\");\n\t\tinputSpec.appendCommonAnnotations(buffer, index);\n\t\tif (!inputSpec.isAllowEmpty())\n\t\t\tbuffer.append(\"    @NotEmpty\\n\");\n\t\tif (pattern != null)\n\t\t\tbuffer.append(\"    @Pattern(regexp=\\\"\" + pattern + \"\\\", message=\\\"Should match regular expression: \" + pattern + \"\\\")\\n\");\n\t\tinputSpec.appendMethods(buffer, index, \"String\", null, defaultValueProvider);\n\n\t\treturn buffer.toString();\n\t}", "code_tokens": ["public", "static", "String", "getPropertyDef", "(", "InputSpec", "inputSpec", ",", "Map", "<", "String", ",", "Integer", ">", "indexes", ",", "String", "pattern", ",", "DefaultValueProvider", "defaultValueProvider", ")", "{", "pattern", "=", "InputSpec", ".", "escape", "(", "pattern", ")", ";", "int", "index", "=", "indexes", ".", "get", "(", "inputSpec", ".", "getName", "(", ")", ")", ";", "StringBuffer", "buffer", "=", "new", "StringBuffer", "(", ")", ";", "inputSpec", ".", "appendField", "(", "buffer", ",", "index", ",", "\"", "String", "\"", ")", ";", "inputSpec", ".", "appendCommonAnnotations", "(", "buffer", ",", "index", ")", ";", "if", "(", "!", "inputSpec", ".", "isAllowEmpty", "(", ")", ")", "buffer", ".", "append", "(", "\"", "    @NotEmpty", "\\n", "\"", ")", ";", "if", "(", "pattern", "!=", "null", ")", "buffer", ".", "append", "(", "\"", "    @Pattern(regexp=", "\\\"", "\"", "+", "pattern", "+", "\"", "\\\"", ", message=", "\\\"", "Should match regular expression: ", "\"", "+", "pattern", "+", "\"", "\\\"", ")", "\\n", "\"", ")", ";", "inputSpec", ".", "appendMethods", "(", "buffer", ",", "index", ",", "\"", "String", "\"", ",", "null", ",", "defaultValueProvider", ")", ";", "return", "buffer", ".", "toString", "(", ")", ";", "}"], "idx": 73800, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "39d95ab8122c5d9ed18e69dc024870cae08d2d60", "function_name": "getPropertyDef", "body_hash": "762d59e9ba281d5f7f4b8c7c1561d1bc61221a0e"}
{"code": "private void updateStatus() {\n        if (config.getHIDMode() == 0) {\n            config.setNetworkStatus(false);\n            EditorActivity.stopNetworkSocketService(this);\n            ipButton.setVisibility(View.INVISIBLE);\n            ipStatusDivider.setVisibility(View.INVISIBLE);\n            if (config.getUSBStatus()) {\n                statusText.setText(R.string.config_status_usb_on);\n                statusImage.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_usb));\n            } else {\n                statusText.setText(R.string.config_status_usb_off);\n                statusImage.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_usb_off));\n            }\n        } else if (config.getHIDMode() == 1) {\n            EditorActivity.startNetworkSocketService(this);\n            ipButton.setVisibility(View.VISIBLE);\n            ipStatusDivider.setVisibility(View.VISIBLE);\n            if (config.getNetworkStatus()) {\n                statusText.setText(R.string.config_status_net_on);\n                statusImage.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_net));\n            } else {\n                statusText.setText(R.string.config_status_net_off);\n                statusImage.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_net_off));\n            }\n            EditorActivity.updateNotification(this);\n        }\n    }", "code_tokens": ["private", "void", "updateStatus", "(", ")", "{", "if", "(", "config", ".", "getHIDMode", "(", ")", "==", "0", ")", "{", "config", ".", "setNetworkStatus", "(", "false", ")", ";", "EditorActivity", ".", "stopNetworkSocketService", "(", "this", ")", ";", "ipButton", ".", "setVisibility", "(", "View", ".", "INVISIBLE", ")", ";", "ipStatusDivider", ".", "setVisibility", "(", "View", ".", "INVISIBLE", ")", ";", "if", "(", "config", ".", "getUSBStatus", "(", ")", ")", "{", "statusText", ".", "setText", "(", "R", ".", "string", ".", "config_status_usb_on", ")", ";", "statusImage", ".", "setImageDrawable", "(", "ContextCompat", ".", "getDrawable", "(", "this", ",", "R", ".", "drawable", ".", "ic_usb", ")", ")", ";", "}", "else", "{", "statusText", ".", "setText", "(", "R", ".", "string", ".", "config_status_usb_off", ")", ";", "statusImage", ".", "setImageDrawable", "(", "ContextCompat", ".", "getDrawable", "(", "this", ",", "R", ".", "drawable", ".", "ic_usb_off", ")", ")", ";", "}", "}", "else", "if", "(", "config", ".", "getHIDMode", "(", ")", "==", "1", ")", "{", "EditorActivity", ".", "startNetworkSocketService", "(", "this", ")", ";", "ipButton", ".", "setVisibility", "(", "View", ".", "VISIBLE", ")", ";", "ipStatusDivider", ".", "setVisibility", "(", "View", ".", "VISIBLE", ")", ";", "if", "(", "config", ".", "getNetworkStatus", "(", ")", ")", "{", "statusText", ".", "setText", "(", "R", ".", "string", ".", "config_status_net_on", ")", ";", "statusImage", ".", "setImageDrawable", "(", "ContextCompat", ".", "getDrawable", "(", "this", ",", "R", ".", "drawable", ".", "ic_net", ")", ")", ";", "}", "else", "{", "statusText", ".", "setText", "(", "R", ".", "string", ".", "config_status_net_off", ")", ";", "statusImage", ".", "setImageDrawable", "(", "ContextCompat", ".", "getDrawable", "(", "this", ",", "R", ".", "drawable", ".", "ic_net_off", ")", ")", ";", "}", "EditorActivity", ".", "updateNotification", "(", "this", ")", ";", "}", "}"], "idx": 42139, "cwe": "CWE-327", "target": 0, "status": "FIXED", "commit": "5e3a477365009f488a73efd26a91168502de1b93", "function_name": "updateStatus", "body_hash": "ed1f1b07c9c19797a4de6b98248ba9fe099f47ac"}
{"code": "@Override\n    public final void emitHeader(String name, String value) throws HpackException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"stream.header.debug\", getConnectionId(), getIdentifier(),\n                    name, value));\n        }\n\n        // Header names must be lower case\n        if (!name.toLowerCase(Locale.US).equals(name)) {\n            throw new HpackException(sm.getString(\"stream.header.case\",\n                    getConnectionId(), getIdentifier(), name));\n        }\n\n        if (\"connection\".equals(name)) {\n            throw new HpackException(sm.getString(\"stream.header.connection\",\n                    getConnectionId(), getIdentifier()));\n        }\n\n        if (\"te\".equals(name)) {\n            if (!\"trailers\".equals(value)) {\n                throw new HpackException(sm.getString(\"stream.header.te\",\n                        getConnectionId(), getIdentifier(), value));\n            }\n        }\n\n        if (headerStateErrorMsg != null) {\n            // Don't bother processing the header since the stream is going to\n            // be reset anyway\n            return;\n        }\n\n        boolean pseudoHeader = name.charAt(0) == ':';\n\n        if (pseudoHeader && headerState != HEADER_STATE_PSEUDO) {\n            headerStateErrorMsg = sm.getString(\"stream.header.unexpectedPseudoHeader\",\n                    getConnectionId(), getIdentifier(), name);\n            // No need for further processing. The stream will be reset.\n            return;\n        }\n\n        if (headerState == HEADER_STATE_PSEUDO && !pseudoHeader) {\n            headerState = HEADER_STATE_REGULAR;\n        }\n\n        switch(name) {\n        case \":method\": {\n            if (coyoteRequest.method().isNull()) {\n                coyoteRequest.method().setString(value);\n            } else {\n                throw new HpackException(sm.getString(\"stream.header.duplicate\",\n                        getConnectionId(), getIdentifier(), \":method\" ));\n            }\n            break;\n        }\n        case \":scheme\": {\n            if (coyoteRequest.scheme().isNull()) {\n                coyoteRequest.scheme().setString(value);\n            } else {\n                throw new HpackException(sm.getString(\"stream.header.duplicate\",\n                        getConnectionId(), getIdentifier(), \":scheme\" ));\n            }\n            break;\n        }\n        case \":path\": {\n            if (!coyoteRequest.requestURI().isNull()) {\n                throw new HpackException(sm.getString(\"stream.header.duplicate\",\n                        getConnectionId(), getIdentifier(), \":path\" ));\n            }\n            if (value.length() == 0) {\n                throw new HpackException(sm.getString(\"stream.header.noPath\",\n                        getConnectionId(), getIdentifier()));\n            }\n            int queryStart = value.indexOf('?');\n            String uri;\n            if (queryStart == -1) {\n                uri = value;\n            } else {\n                uri = value.substring(0, queryStart);\n                String query = value.substring(queryStart + 1);\n                coyoteRequest.queryString().setString(query);\n            }\n            // Bug 61120. Set the URI as bytes rather than String so any path\n            // parameters are correctly processed\n            byte[] uriBytes = uri.getBytes(StandardCharsets.ISO_8859_1);\n            coyoteRequest.requestURI().setBytes(uriBytes, 0, uriBytes.length);\n            break;\n        }\n        case \":authority\": {\n            if (coyoteRequest.serverName().isNull()) {\n                int i = value.lastIndexOf(':');\n                if (i > -1) {\n                    coyoteRequest.serverName().setString(value.substring(0, i));\n                    coyoteRequest.setServerPort(Integer.parseInt(value.substring(i + 1)));\n                } else {\n                    coyoteRequest.serverName().setString(value);\n                }\n            } else {\n                throw new HpackException(sm.getString(\"stream.header.duplicate\",\n                        getConnectionId(), getIdentifier(), \":authority\" ));\n            }\n            break;\n        }\n        case \"cookie\": {\n            // Cookie headers need to be concatenated into a single header\n            // See RFC 7540 8.1.2.5\n            if (cookieHeader == null) {\n                cookieHeader = new StringBuilder();\n            } else {\n                cookieHeader.append(\"; \");\n            }\n            cookieHeader.append(value);\n            break;\n        }\n        default: {\n            if (headerState == HEADER_STATE_TRAILER && !handler.isTrailerHeaderAllowed(name)) {\n                break;\n            }\n            if (\"expect\".equals(name) && \"100-continue\".equals(value)) {\n                coyoteRequest.setExpectation(true);\n            }\n            if (pseudoHeader) {\n                headerStateErrorMsg = sm.getString(\"stream.header.unknownPseudoHeader\",\n                        getConnectionId(), getIdentifier(), name);\n            }\n\n            if (headerState == HEADER_STATE_TRAILER) {\n                // HTTP/2 headers are already always lower case\n                coyoteRequest.getTrailerFields().put(name, value);\n            } else {\n                coyoteRequest.getMimeHeaders().addValue(name).setString(value);\n            }\n        }\n        }\n    }", "code_tokens": ["@", "Override", "public", "final", "void", "emitHeader", "(", "String", "name", ",", "String", "value", ")", "throws", "HpackException", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "stream.header.debug", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "name", ",", "value", ")", ")", ";", "}", "if", "(", "!", "name", ".", "toLowerCase", "(", "Locale", ".", "US", ")", ".", "equals", "(", "name", ")", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.case", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "name", ")", ")", ";", "}", "if", "(", "\"", "connection", "\"", ".", "equals", "(", "name", ")", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.connection", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ")", ")", ";", "}", "if", "(", "\"", "te", "\"", ".", "equals", "(", "name", ")", ")", "{", "if", "(", "!", "\"", "trailers", "\"", ".", "equals", "(", "value", ")", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.te", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "value", ")", ")", ";", "}", "}", "if", "(", "headerStateErrorMsg", "!=", "null", ")", "{", "return", ";", "}", "boolean", "pseudoHeader", "=", "name", ".", "charAt", "(", "0", ")", "==", "':'", ";", "if", "(", "pseudoHeader", "&&", "headerState", "!=", "HEADER_STATE_PSEUDO", ")", "{", "headerStateErrorMsg", "=", "sm", ".", "getString", "(", "\"", "stream.header.unexpectedPseudoHeader", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "name", ")", ";", "return", ";", "}", "if", "(", "headerState", "==", "HEADER_STATE_PSEUDO", "&&", "!", "pseudoHeader", ")", "{", "headerState", "=", "HEADER_STATE_REGULAR", ";", "}", "switch", "(", "name", ")", "{", "case", "\"", ":method", "\"", ":", "{", "if", "(", "coyoteRequest", ".", "method", "(", ")", ".", "isNull", "(", ")", ")", "{", "coyoteRequest", ".", "method", "(", ")", ".", "setString", "(", "value", ")", ";", "}", "else", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.duplicate", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "\"", ":method", "\"", ")", ")", ";", "}", "break", ";", "}", "case", "\"", ":scheme", "\"", ":", "{", "if", "(", "coyoteRequest", ".", "scheme", "(", ")", ".", "isNull", "(", ")", ")", "{", "coyoteRequest", ".", "scheme", "(", ")", ".", "setString", "(", "value", ")", ";", "}", "else", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.duplicate", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "\"", ":scheme", "\"", ")", ")", ";", "}", "break", ";", "}", "case", "\"", ":path", "\"", ":", "{", "if", "(", "!", "coyoteRequest", ".", "requestURI", "(", ")", ".", "isNull", "(", ")", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.duplicate", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "\"", ":path", "\"", ")", ")", ";", "}", "if", "(", "value", ".", "length", "(", ")", "==", "0", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.noPath", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ")", ")", ";", "}", "int", "queryStart", "=", "value", ".", "indexOf", "(", "'?'", ")", ";", "String", "uri", ";", "if", "(", "queryStart", "==", "-", "1", ")", "{", "uri", "=", "value", ";", "}", "else", "{", "uri", "=", "value", ".", "substring", "(", "0", ",", "queryStart", ")", ";", "String", "query", "=", "value", ".", "substring", "(", "queryStart", "+", "1", ")", ";", "coyoteRequest", ".", "queryString", "(", ")", ".", "setString", "(", "query", ")", ";", "}", "byte", "[", "]", "uriBytes", "=", "uri", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ";", "coyoteRequest", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriBytes", ",", "0", ",", "uriBytes", ".", "length", ")", ";", "break", ";", "}", "case", "\"", ":authority", "\"", ":", "{", "if", "(", "coyoteRequest", ".", "serverName", "(", ")", ".", "isNull", "(", ")", ")", "{", "int", "i", "=", "value", ".", "lastIndexOf", "(", "':'", ")", ";", "if", "(", "i", ">", "-", "1", ")", "{", "coyoteRequest", ".", "serverName", "(", ")", ".", "setString", "(", "value", ".", "substring", "(", "0", ",", "i", ")", ")", ";", "coyoteRequest", ".", "setServerPort", "(", "Integer", ".", "parseInt", "(", "value", ".", "substring", "(", "i", "+", "1", ")", ")", ")", ";", "}", "else", "{", "coyoteRequest", ".", "serverName", "(", ")", ".", "setString", "(", "value", ")", ";", "}", "}", "else", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.duplicate", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "\"", ":authority", "\"", ")", ")", ";", "}", "break", ";", "}", "case", "\"", "cookie", "\"", ":", "{", "if", "(", "cookieHeader", "==", "null", ")", "{", "cookieHeader", "=", "new", "StringBuilder", "(", ")", ";", "}", "else", "{", "cookieHeader", ".", "append", "(", "\"", "; ", "\"", ")", ";", "}", "cookieHeader", ".", "append", "(", "value", ")", ";", "break", ";", "}", "default", ":", "{", "if", "(", "headerState", "==", "HEADER_STATE_TRAILER", "&&", "!", "handler", ".", "isTrailerHeaderAllowed", "(", "name", ")", ")", "{", "break", ";", "}", "if", "(", "\"", "expect", "\"", ".", "equals", "(", "name", ")", "&&", "\"", "100-continue", "\"", ".", "equals", "(", "value", ")", ")", "{", "coyoteRequest", ".", "setExpectation", "(", "true", ")", ";", "}", "if", "(", "pseudoHeader", ")", "{", "headerStateErrorMsg", "=", "sm", ".", "getString", "(", "\"", "stream.header.unknownPseudoHeader", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "name", ")", ";", "}", "if", "(", "headerState", "==", "HEADER_STATE_TRAILER", ")", "{", "coyoteRequest", ".", "getTrailerFields", "(", ")", ".", "put", "(", "name", ",", "value", ")", ";", "}", "else", "{", "coyoteRequest", ".", "getMimeHeaders", "(", ")", ".", "addValue", "(", "name", ")", ".", "setString", "(", "value", ")", ";", "}", "}", "}", "}"], "idx": 25677, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "cf181edc9a8c239cde704cffc3c503425bdcae2b", "function_name": "emitHeader", "body_hash": "bb37760a56feadf64afdedef152a11a2311bfc5b"}
{"code": "public void onTaskSelectionEvent(@Observes TaskSelectionEvent event){\n        selectedTaskId = event.getTaskId();\n        selectedTaskName = event.getTaskName();\n        \n        view.getTaskIdAndName().setText(SafeHtmlUtils.htmlEscape(String.valueOf(selectedTaskId) + \" - \"+selectedTaskName));\n        \n        view.getContent().clear();\n        \n        String placeToGo;\n        if(event.getPlace() != null && !event.getPlace().equals(\"\")){\n            placeToGo = event.getPlace();\n        }else{\n            placeToGo = \"Task Details\";\n        }\n        \n        \n\n        DefaultPlaceRequest defaultPlaceRequest = new DefaultPlaceRequest(placeToGo);\n        //Set Parameters here: \n        defaultPlaceRequest.addParameter(\"taskId\", String.valueOf(selectedTaskId));\n        defaultPlaceRequest.addParameter(\"taskName\", selectedTaskName);\n\n        Set<Activity> activities = activityManager.getActivities(defaultPlaceRequest);\n        AbstractWorkbenchScreenActivity activity = ((AbstractWorkbenchScreenActivity) activities.iterator().next());\n        \n        activitiesMap.put(placeToGo, activity);\n        \n        IsWidget widget = activity.getWidget();\n        activity.launch(place, null);\n        activity.onStartup(defaultPlaceRequest);\n        view.getContent().add(widget);\n        activity.onOpen();\n    }", "code_tokens": ["public", "void", "onTaskSelectionEvent", "(", "@", "Observes", "TaskSelectionEvent", "event", ")", "{", "selectedTaskId", "=", "event", ".", "getTaskId", "(", ")", ";", "selectedTaskName", "=", "event", ".", "getTaskName", "(", ")", ";", "view", ".", "getTaskIdAndName", "(", ")", ".", "setText", "(", "SafeHtmlUtils", ".", "htmlEscape", "(", "String", ".", "valueOf", "(", "selectedTaskId", ")", "+", "\"", " - ", "\"", "+", "selectedTaskName", ")", ")", ";", "view", ".", "getContent", "(", ")", ".", "clear", "(", ")", ";", "String", "placeToGo", ";", "if", "(", "event", ".", "getPlace", "(", ")", "!=", "null", "&&", "!", "event", ".", "getPlace", "(", ")", ".", "equals", "(", "\"", "\"", ")", ")", "{", "placeToGo", "=", "event", ".", "getPlace", "(", ")", ";", "}", "else", "{", "placeToGo", "=", "\"", "Task Details", "\"", ";", "}", "DefaultPlaceRequest", "defaultPlaceRequest", "=", "new", "DefaultPlaceRequest", "(", "placeToGo", ")", ";", "defaultPlaceRequest", ".", "addParameter", "(", "\"", "taskId", "\"", ",", "String", ".", "valueOf", "(", "selectedTaskId", ")", ")", ";", "defaultPlaceRequest", ".", "addParameter", "(", "\"", "taskName", "\"", ",", "selectedTaskName", ")", ";", "Set", "<", "Activity", ">", "activities", "=", "activityManager", ".", "getActivities", "(", "defaultPlaceRequest", ")", ";", "AbstractWorkbenchScreenActivity", "activity", "=", "(", "(", "AbstractWorkbenchScreenActivity", ")", "activities", ".", "iterator", "(", ")", ".", "next", "(", ")", ")", ";", "activitiesMap", ".", "put", "(", "placeToGo", ",", "activity", ")", ";", "IsWidget", "widget", "=", "activity", ".", "getWidget", "(", ")", ";", "activity", ".", "launch", "(", "place", ",", "null", ")", ";", "activity", ".", "onStartup", "(", "defaultPlaceRequest", ")", ";", "view", ".", "getContent", "(", ")", ".", "add", "(", "widget", ")", ";", "activity", ".", "onOpen", "(", ")", ";", "}"], "idx": 79353, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "4818204506e8e94645b52adb9426bedfa9ffdd04", "function_name": "onTaskSelectionEvent", "body_hash": "8683a8d0538e5a87d0eab8b02b55fae22fce36bd"}
{"code": "@BeforeClass\n  public static void setupClass() {\n    functionStringMap.put(new LuceneCreateIndexFunction(), \"CLUSTER:MANAGE:LUCENE\");\n    functionStringMap.put(new LuceneDescribeIndexFunction(), \"CLUSTER:READ:LUCENE\");\n    functionStringMap.put(new LuceneDestroyIndexFunction(), \"CLUSTER:MANAGE:LUCENE\");\n    functionStringMap.put(new LuceneListIndexFunction(), \"CLUSTER:READ:LUCENE\");\n    functionStringMap.put(new LuceneSearchIndexFunction(), \"DATA:READ:testRegion\");\n    functionStringMap.put(new LuceneQueryFunction(), \"DATA:READ:testRegion\");\n    functionStringMap.put(new WaitUntilFlushedFunction(), \"DATA:READ:testRegion\");\n    functionStringMap.put(new LuceneGetPageFunction(), \"DATA:READ:testRegion\");\n\n    functionStringMap.keySet().forEach(FunctionService::registerFunction);\n    FunctionService.registerFunction(new DumpDirectoryFiles());\n  }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "setupClass", "(", ")", "{", "functionStringMap", ".", "put", "(", "new", "LuceneCreateIndexFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:LUCENE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "LuceneDescribeIndexFunction", "(", ")", ",", "\"", "CLUSTER:READ:LUCENE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "LuceneDestroyIndexFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE:LUCENE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "LuceneListIndexFunction", "(", ")", ",", "\"", "CLUSTER:READ:LUCENE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "LuceneSearchIndexFunction", "(", ")", ",", "\"", "DATA:READ:testRegion", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "LuceneQueryFunction", "(", ")", ",", "\"", "DATA:READ:testRegion", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "WaitUntilFlushedFunction", "(", ")", ",", "\"", "DATA:READ:testRegion", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "LuceneGetPageFunction", "(", ")", ",", "\"", "DATA:READ:testRegion", "\"", ")", ";", "functionStringMap", ".", "keySet", "(", ")", ".", "forEach", "(", "FunctionService", "::", "registerFunction", ")", ";", "FunctionService", ".", "registerFunction", "(", "new", "DumpDirectoryFiles", "(", ")", ")", ";", "}"], "idx": 88192, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "00be4f9774e1adf8e7ccc2664da8005fc30bb11d", "function_name": "setupClass", "body_hash": "60cb39fc21cc120eef9966c1dcb9683480ebac71"}
{"code": "protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\n            \"java.beans.EventHandler\", //\n            \"java.lang.ProcessBuilder\", //\n            \"javax.imageio.ImageIO$ContainsFilter\", //\n            \"jdk.nashorn.internal.objects.NativeString\" });\n        denyTypesByRegExp(new Pattern[]{LAZY_ITERATORS, JAVAX_CRYPTO, JAXWS_FILE_STREAM});\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }", "code_tokens": ["protected", "void", "setupSecurity", "(", ")", "{", "if", "(", "securityMapper", "==", "null", ")", "{", "return", ";", "}", "addPermission", "(", "AnyTypePermission", ".", "ANY", ")", ";", "denyTypes", "(", "new", "String", "[", "]", "{", "\"", "java.beans.EventHandler", "\"", ",", "\"", "java.lang.ProcessBuilder", "\"", ",", "\"", "javax.imageio.ImageIO$ContainsFilter", "\"", ",", "\"", "jdk.nashorn.internal.objects.NativeString", "\"", "}", ")", ";", "denyTypesByRegExp", "(", "new", "Pattern", "[", "]", "{", "LAZY_ITERATORS", ",", "JAVAX_CRYPTO", ",", "JAXWS_FILE_STREAM", "}", ")", ";", "allowTypeHierarchy", "(", "Exception", ".", "class", ")", ";", "securityInitialized", "=", "false", ";", "}"], "idx": 77031, "cwe": "CWE-78", "target": 0, "status": "FIXED", "commit": "0bcbf50126a62dfcd65f93a0da0c6d1ae92aa738", "function_name": "setupSecurity", "body_hash": "b36adbbafc5c64a1bf24a63872323191b9ea2862"}
{"code": "@Override\n  public void init(NamedList args) {\n    super.init(args);\n\n    inputFactory = XMLInputFactory.newInstance();\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input factory: \" + inputFactory);\n    }\n    inputFactory.setXMLReporter(xmllog);\n  }", "code_tokens": ["@", "Override", "public", "void", "init", "(", "NamedList", "args", ")", "{", "super", ".", "init", "(", "args", ")", ";", "inputFactory", "=", "XMLInputFactory", ".", "newInstance", "(", ")", ";", "try", "{", "inputFactory", ".", "setProperty", "(", "\"", "reuse-instance", "\"", ",", "Boolean", ".", "FALSE", ")", ";", "}", "catch", "(", "IllegalArgumentException", "ex", ")", "{", "log", ".", "debug", "(", "\"", "Unable to set the 'reuse-instance' property for the input factory: ", "\"", "+", "inputFactory", ")", ";", "}", "inputFactory", ".", "setXMLReporter", "(", "xmllog", ")", ";", "}"], "idx": 102901, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "7239a57a51ea0f4d05dd330ce5e15e4f72f72747", "function_name": "init", "body_hash": "1ea80da57705eef9af3dcd73893050446967b8f5"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (unmarshalType != null) {\n            setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n        }\n        if (prettyPrint != null) {\n            setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n        }\n        if (jsonView != null) {\n            setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n        }\n        if (include != null) {\n            setProperty(camelContext, dataFormat, \"include\", include);\n        }\n        if (allowJmsType != null) {\n            setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n        }\n        if (collectionType != null) {\n            setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n        }\n        if (useList != null) {\n            setProperty(camelContext, dataFormat, \"useList\", useList);\n        }\n        if (enableJaxbAnnotationModule != null) {\n            setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n        }\n        if (moduleClassNames != null) {\n            setProperty(camelContext, dataFormat, \"modulesClassNames\", moduleClassNames);\n        }\n        if (moduleRefs != null) {\n            setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n        }\n        if (enableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n        }\n        if (disableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n        }\n        if (allowUnmarshallType != null) {\n            setProperty(camelContext, dataFormat, \"allowUnmarshallType\", allowUnmarshallType);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "unmarshalType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "unmarshalType", "\"", ",", "unmarshalType", ")", ";", "}", "if", "(", "prettyPrint", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "prettyPrint", "\"", ",", "prettyPrint", ")", ";", "}", "if", "(", "jsonView", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "jsonView", "\"", ",", "jsonView", ")", ";", "}", "if", "(", "include", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "include", "\"", ",", "include", ")", ";", "}", "if", "(", "allowJmsType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowJmsType", "\"", ",", "allowJmsType", ")", ";", "}", "if", "(", "collectionType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "collectionType", "\"", ",", "collectionType", ")", ";", "}", "if", "(", "useList", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "useList", "\"", ",", "useList", ")", ";", "}", "if", "(", "enableJaxbAnnotationModule", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableJaxbAnnotationModule", "\"", ",", "enableJaxbAnnotationModule", ")", ";", "}", "if", "(", "moduleClassNames", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "modulesClassNames", "\"", ",", "moduleClassNames", ")", ";", "}", "if", "(", "moduleRefs", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "moduleRefs", "\"", ",", "moduleRefs", ")", ";", "}", "if", "(", "enableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableFeatures", "\"", ",", "enableFeatures", ")", ";", "}", "if", "(", "disableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "disableFeatures", "\"", ",", "disableFeatures", ")", ";", "}", "if", "(", "allowUnmarshallType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowUnmarshallType", "\"", ",", "allowUnmarshallType", ")", ";", "}", "}"], "idx": 57502, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "ccf149c76bf37adc5977dc626e141a14e60b5ae", "function_name": "configureDataFormat", "body_hash": "c5a93b02504fb1f80c942eb04be92aaee7a94e70"}
{"code": "public static File newTmpFile( final String content, final Charset encoding ) throws IOException {\n        final File f = File.createTempFile( \"jspwiki\", null );\n        try( final Reader in = new StringReader( content );\n            final Writer out = new OutputStreamWriter( Files.newOutputStream( f.toPath() ), encoding ) ) {\n            copyContents( in, out );\n        }\n\n        return f;\n    }", "code_tokens": ["public", "static", "File", "newTmpFile", "(", "final", "String", "content", ",", "final", "Charset", "encoding", ")", "throws", "IOException", "{", "final", "File", "f", "=", "File", ".", "createTempFile", "(", "\"", "jspwiki", "\"", ",", "null", ")", ";", "try", "(", "final", "Reader", "in", "=", "new", "StringReader", "(", "content", ")", ";", "final", "Writer", "out", "=", "new", "OutputStreamWriter", "(", "Files", ".", "newOutputStream", "(", "f", ".", "toPath", "(", ")", ")", ",", "encoding", ")", ")", "{", "copyContents", "(", "in", ",", "out", ")", ";", "}", "return", "f", ";", "}"], "idx": 36720, "cwe": "CWE-276", "target": 0, "status": "FIXED", "commit": "800196dc239553ee2ea8f71754f8ee3f85bcf70f", "function_name": "newTmpFile", "body_hash": "ac2cb3bf14c3e0c99bfabf12ea8011801ad6b9df"}
{"code": "public void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n\n        // The MP4Parser library accepts either a File, or a byte array\n        // As MP4 video files are typically large, always use a file to\n        //  avoid OOMs that may occur with in-memory buffering\n        TemporaryResources tmp = new TemporaryResources();\n        TikaInputStream tstream = TikaInputStream.get(stream, tmp);\n\n        try (IsoFile isoFile = new IsoFile(tstream.getFile())) {\n            tmp.addResource(isoFile);\n\n            // Grab the file type box\n            FileTypeBox fileType = getOrNull(isoFile, FileTypeBox.class);\n            if (fileType != null) {\n                // Identify the type\n                MediaType type = MediaType.application(\"mp4\");\n                for (Map.Entry<MediaType, List<String>> e : typesMap.entrySet()) {\n                    if (e.getValue().contains(fileType.getMajorBrand())) {\n                        type = e.getKey();\n                        break;\n                    }\n                }\n                metadata.set(Metadata.CONTENT_TYPE, type.toString());\n\n                if (type.getType().equals(\"audio\")) {\n                    metadata.set(XMPDM.AUDIO_COMPRESSOR, fileType.getMajorBrand().trim());\n                }\n            } else {\n                // Some older QuickTime files lack the FileType\n                metadata.set(Metadata.CONTENT_TYPE, \"video/quicktime\");\n            }\n\n\n            // Get the main MOOV box\n            MovieBox moov = getOrNull(isoFile, MovieBox.class);\n            if (moov == null) {\n                // Bail out\n                return;\n            }\n\n\n            XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n            xhtml.startDocument();\n\n            handleMovieHeaderBox(moov, metadata, xhtml);\n            handleTrackBoxes(moov, metadata, xhtml);\n\n            // Get metadata from the User Data Box\n            UserDataBox userData = getOrNull(moov, UserDataBox.class);\n            if (userData != null) {\n                extractGPS(userData, metadata);\n                MetaBox metaBox = getOrNull(userData, MetaBox.class);\n\n                // Check for iTunes Metadata\n                // See http://atomicparsley.sourceforge.net/mpeg-4files.html and\n                //  http://code.google.com/p/mp4v2/wiki/iTunesMetadata for more on these\n                handleApple(metaBox, metadata, xhtml);\n                // TODO Check for other kinds too\n            }\n\n            // All done\n            xhtml.endDocument();\n\n        } finally {\n            tmp.dispose();\n        }\n\n    }", "code_tokens": ["public", "void", "parse", "(", "InputStream", "stream", ",", "ContentHandler", "handler", ",", "Metadata", "metadata", ",", "ParseContext", "context", ")", "throws", "IOException", ",", "SAXException", ",", "TikaException", "{", "TemporaryResources", "tmp", "=", "new", "TemporaryResources", "(", ")", ";", "TikaInputStream", "tstream", "=", "TikaInputStream", ".", "get", "(", "stream", ",", "tmp", ")", ";", "try", "(", "IsoFile", "isoFile", "=", "new", "IsoFile", "(", "tstream", ".", "getFile", "(", ")", ")", ")", "{", "tmp", ".", "addResource", "(", "isoFile", ")", ";", "FileTypeBox", "fileType", "=", "getOrNull", "(", "isoFile", ",", "FileTypeBox", ".", "class", ")", ";", "if", "(", "fileType", "!=", "null", ")", "{", "MediaType", "type", "=", "MediaType", ".", "application", "(", "\"", "mp4", "\"", ")", ";", "for", "(", "Map", ".", "Entry", "<", "MediaType", ",", "List", "<", "String", ">", ">", "e", ":", "typesMap", ".", "entrySet", "(", ")", ")", "{", "if", "(", "e", ".", "getValue", "(", ")", ".", "contains", "(", "fileType", ".", "getMajorBrand", "(", ")", ")", ")", "{", "type", "=", "e", ".", "getKey", "(", ")", ";", "break", ";", "}", "}", "metadata", ".", "set", "(", "Metadata", ".", "CONTENT_TYPE", ",", "type", ".", "toString", "(", ")", ")", ";", "if", "(", "type", ".", "getType", "(", ")", ".", "equals", "(", "\"", "audio", "\"", ")", ")", "{", "metadata", ".", "set", "(", "XMPDM", ".", "AUDIO_COMPRESSOR", ",", "fileType", ".", "getMajorBrand", "(", ")", ".", "trim", "(", ")", ")", ";", "}", "}", "else", "{", "metadata", ".", "set", "(", "Metadata", ".", "CONTENT_TYPE", ",", "\"", "video/quicktime", "\"", ")", ";", "}", "MovieBox", "moov", "=", "getOrNull", "(", "isoFile", ",", "MovieBox", ".", "class", ")", ";", "if", "(", "moov", "==", "null", ")", "{", "return", ";", "}", "XHTMLContentHandler", "xhtml", "=", "new", "XHTMLContentHandler", "(", "handler", ",", "metadata", ")", ";", "xhtml", ".", "startDocument", "(", ")", ";", "handleMovieHeaderBox", "(", "moov", ",", "metadata", ",", "xhtml", ")", ";", "handleTrackBoxes", "(", "moov", ",", "metadata", ",", "xhtml", ")", ";", "UserDataBox", "userData", "=", "getOrNull", "(", "moov", ",", "UserDataBox", ".", "class", ")", ";", "if", "(", "userData", "!=", "null", ")", "{", "extractGPS", "(", "userData", ",", "metadata", ")", ";", "MetaBox", "metaBox", "=", "getOrNull", "(", "userData", ",", "MetaBox", ".", "class", ")", ";", "handleApple", "(", "metaBox", ",", "metadata", ",", "xhtml", ")", ";", "}", "xhtml", ".", "endDocument", "(", ")", ";", "}", "finally", "{", "tmp", ".", "dispose", "(", ")", ";", "}", "}"], "idx": 83079, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "8e2eb05", "function_name": "parse", "body_hash": "04decc3dc8894bacb37590af7c416719914f4f0b"}
{"code": "private synchronized TaskBuilder loadTasks() throws IOException {\n        File projectsDir = new File(root,\"jobs\");\n        if(!projectsDir.getCanonicalFile().isDirectory() && !projectsDir.mkdirs()) {\n            if(projectsDir.exists())\n                throw new IOException(projectsDir+\" is not a directory\");\n            throw new IOException(\"Unable to create \"+projectsDir+\"\\nPermission issue? Please create this directory manually.\");\n        }\n        File[] subdirs = projectsDir.listFiles();\n\n        final Set<String> loadedNames = Collections.synchronizedSet(new HashSet<String>());\n\n        TaskGraphBuilder g = new TaskGraphBuilder();\n        Handle loadJenkins = g.requires(EXTENSIONS_AUGMENTED).attains(JOB_LOADED).add(\"Loading global config\", new Executable() {\n            public void run(Reactor session) throws Exception {\n                loadConfig();\n                // if we are loading old data that doesn't have this field\n                if (slaves != null && !slaves.isEmpty() && nodes.isLegacy()) {\n                    nodes.setNodes(slaves);\n                    slaves = null;\n                } else {\n                    nodes.load();\n                }\n\n                clouds.setOwner(Jenkins.this);\n            }\n        });\n\n        for (final File subdir : subdirs) {\n            g.requires(loadJenkins).attains(JOB_LOADED).notFatal().add(\"Loading item \" + subdir.getName(), new Executable() {\n                public void run(Reactor session) throws Exception {\n                    if(!Items.getConfigFile(subdir).exists()) {\n                        //Does not have job config file, so it is not a jenkins job hence skip it\n                        return;\n                    }\n                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);\n                    items.put(item.getName(), item);\n                    loadedNames.add(item.getName());\n                }\n            });\n        }\n\n        g.requires(JOB_LOADED).attains(COMPLETED).add(\"Cleaning up obsolete items deleted from the disk\", new Executable() {\n            public void run(Reactor reactor) throws Exception {\n                // anything we didn't load from disk, throw them away.\n                // doing this after loading from disk allows newly loaded items\n                // to inspect what already existed in memory (in case of reloading)\n\n                // retainAll doesn't work well because of CopyOnWriteMap implementation, so remove one by one\n                // hopefully there shouldn't be too many of them.\n                for (String name : items.keySet()) {\n                    if (!loadedNames.contains(name))\n                        items.remove(name);\n                }\n            }\n        });\n\n        g.requires(JOB_LOADED).attains(COMPLETED).add(\"Finalizing set up\",new Executable() {\n            public void run(Reactor session) throws Exception {\n                rebuildDependencyGraph();\n\n                {// recompute label objects - populates the labels mapping.\n                    for (Node slave : nodes.getNodes())\n                        // Note that not all labels are visible until the agents have connected.\n                        slave.getAssignedLabels();\n                    getAssignedLabels();\n                }\n\n                // initialize views by inserting the default view if necessary\n                // this is both for clean Jenkins and for backward compatibility.\n                if(views.size()==0 || primaryView==null) {\n                    View v = new AllView(AllView.DEFAULT_VIEW_NAME);\n                    setViewOwner(v);\n                    views.add(0,v);\n                    primaryView = v.getViewName();\n                }\n                primaryView = AllView.migrateLegacyPrimaryAllViewLocalizedName(views, primaryView);\n\n                if (useSecurity!=null && !useSecurity) {\n                    // forced reset to the unsecure mode.\n                    // this works as an escape hatch for people who locked themselves out.\n                    authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                } else {\n                    // read in old data that doesn't have the security field set\n                    if(authorizationStrategy==null) {\n                        if(useSecurity==null)\n                            authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                        else\n                            authorizationStrategy = new LegacyAuthorizationStrategy();\n                    }\n                    if(securityRealm==null) {\n                        if(useSecurity==null)\n                            setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                        else\n                            setSecurityRealm(new LegacySecurityRealm());\n                    } else {\n                        // force the set to proxy\n                        setSecurityRealm(securityRealm);\n                    }\n                }\n\n\n                // Initialize the filter with the crumb issuer\n                setCrumbIssuer(crumbIssuer);\n\n                // auto register root actions\n                for (Action a : getExtensionList(RootAction.class))\n                    if (!actions.contains(a)) actions.add(a);\n            }\n        });\n\n        return g;\n    }", "code_tokens": ["private", "synchronized", "TaskBuilder", "loadTasks", "(", ")", "throws", "IOException", "{", "File", "projectsDir", "=", "new", "File", "(", "root", ",", "\"", "jobs", "\"", ")", ";", "if", "(", "!", "projectsDir", ".", "getCanonicalFile", "(", ")", ".", "isDirectory", "(", ")", "&&", "!", "projectsDir", ".", "mkdirs", "(", ")", ")", "{", "if", "(", "projectsDir", ".", "exists", "(", ")", ")", "throw", "new", "IOException", "(", "projectsDir", "+", "\"", " is not a directory", "\"", ")", ";", "throw", "new", "IOException", "(", "\"", "Unable to create ", "\"", "+", "projectsDir", "+", "\"", "\\n", "Permission issue? Please create this directory manually.", "\"", ")", ";", "}", "File", "[", "]", "subdirs", "=", "projectsDir", ".", "listFiles", "(", ")", ";", "final", "Set", "<", "String", ">", "loadedNames", "=", "Collections", ".", "synchronizedSet", "(", "new", "HashSet", "<", "String", ">", "(", ")", ")", ";", "TaskGraphBuilder", "g", "=", "new", "TaskGraphBuilder", "(", ")", ";", "Handle", "loadJenkins", "=", "g", ".", "requires", "(", "EXTENSIONS_AUGMENTED", ")", ".", "attains", "(", "JOB_LOADED", ")", ".", "add", "(", "\"", "Loading global config", "\"", ",", "new", "Executable", "(", ")", "{", "public", "void", "run", "(", "Reactor", "session", ")", "throws", "Exception", "{", "loadConfig", "(", ")", ";", "if", "(", "slaves", "!=", "null", "&&", "!", "slaves", ".", "isEmpty", "(", ")", "&&", "nodes", ".", "isLegacy", "(", ")", ")", "{", "nodes", ".", "setNodes", "(", "slaves", ")", ";", "slaves", "=", "null", ";", "}", "else", "{", "nodes", ".", "load", "(", ")", ";", "}", "clouds", ".", "setOwner", "(", "Jenkins", ".", "this", ")", ";", "}", "}", ")", ";", "for", "(", "final", "File", "subdir", ":", "subdirs", ")", "{", "g", ".", "requires", "(", "loadJenkins", ")", ".", "attains", "(", "JOB_LOADED", ")", ".", "notFatal", "(", ")", ".", "add", "(", "\"", "Loading item ", "\"", "+", "subdir", ".", "getName", "(", ")", ",", "new", "Executable", "(", ")", "{", "public", "void", "run", "(", "Reactor", "session", ")", "throws", "Exception", "{", "if", "(", "!", "Items", ".", "getConfigFile", "(", "subdir", ")", ".", "exists", "(", ")", ")", "{", "return", ";", "}", "TopLevelItem", "item", "=", "(", "TopLevelItem", ")", "Items", ".", "load", "(", "Jenkins", ".", "this", ",", "subdir", ")", ";", "items", ".", "put", "(", "item", ".", "getName", "(", ")", ",", "item", ")", ";", "loadedNames", ".", "add", "(", "item", ".", "getName", "(", ")", ")", ";", "}", "}", ")", ";", "}", "g", ".", "requires", "(", "JOB_LOADED", ")", ".", "attains", "(", "COMPLETED", ")", ".", "add", "(", "\"", "Cleaning up obsolete items deleted from the disk", "\"", ",", "new", "Executable", "(", ")", "{", "public", "void", "run", "(", "Reactor", "reactor", ")", "throws", "Exception", "{", "for", "(", "String", "name", ":", "items", ".", "keySet", "(", ")", ")", "{", "if", "(", "!", "loadedNames", ".", "contains", "(", "name", ")", ")", "items", ".", "remove", "(", "name", ")", ";", "}", "}", "}", ")", ";", "g", ".", "requires", "(", "JOB_LOADED", ")", ".", "attains", "(", "COMPLETED", ")", ".", "add", "(", "\"", "Finalizing set up", "\"", ",", "new", "Executable", "(", ")", "{", "public", "void", "run", "(", "Reactor", "session", ")", "throws", "Exception", "{", "rebuildDependencyGraph", "(", ")", ";", "{", "for", "(", "Node", "slave", ":", "nodes", ".", "getNodes", "(", ")", ")", "slave", ".", "getAssignedLabels", "(", ")", ";", "getAssignedLabels", "(", ")", ";", "}", "if", "(", "views", ".", "size", "(", ")", "==", "0", "||", "primaryView", "==", "null", ")", "{", "View", "v", "=", "new", "AllView", "(", "AllView", ".", "DEFAULT_VIEW_NAME", ")", ";", "setViewOwner", "(", "v", ")", ";", "views", ".", "add", "(", "0", ",", "v", ")", ";", "primaryView", "=", "v", ".", "getViewName", "(", ")", ";", "}", "primaryView", "=", "AllView", ".", "migrateLegacyPrimaryAllViewLocalizedName", "(", "views", ",", "primaryView", ")", ";", "if", "(", "useSecurity", "!=", "null", "&&", "!", "useSecurity", ")", "{", "authorizationStrategy", "=", "AuthorizationStrategy", ".", "UNSECURED", ";", "setSecurityRealm", "(", "SecurityRealm", ".", "NO_AUTHENTICATION", ")", ";", "}", "else", "{", "if", "(", "authorizationStrategy", "==", "null", ")", "{", "if", "(", "useSecurity", "==", "null", ")", "authorizationStrategy", "=", "AuthorizationStrategy", ".", "UNSECURED", ";", "else", "authorizationStrategy", "=", "new", "LegacyAuthorizationStrategy", "(", ")", ";", "}", "if", "(", "securityRealm", "==", "null", ")", "{", "if", "(", "useSecurity", "==", "null", ")", "setSecurityRealm", "(", "SecurityRealm", ".", "NO_AUTHENTICATION", ")", ";", "else", "setSecurityRealm", "(", "new", "LegacySecurityRealm", "(", ")", ")", ";", "}", "else", "{", "setSecurityRealm", "(", "securityRealm", ")", ";", "}", "}", "setCrumbIssuer", "(", "crumbIssuer", ")", ";", "for", "(", "Action", "a", ":", "getExtensionList", "(", "RootAction", ".", "class", ")", ")", "if", "(", "!", "actions", ".", "contains", "(", "a", ")", ")", "actions", ".", "add", "(", "a", ")", ";", "}", "}", ")", ";", "return", "g", ";", "}"], "idx": 48617, "cwe": "CWE-362", "target": 0, "status": "FIXED", "commit": "ccc374a7176d7704941fb494589790b7673efe2e", "function_name": "loadTasks", "body_hash": "91a81409d1408b40a5bd72d7fa8c2d6700a03587"}
{"code": "private static Node newNode() {\n        Node build = NodeBuilder.nodeBuilder().local(true).data(true).settings(ImmutableSettings.builder()\n                .put(ClusterName.SETTING, nodeName())\n                .put(\"node.name\", nodeName())\n                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n                .put(\"script.disable_dynamic\", false)\n                .put(EsExecutors.PROCESSORS, 1) // limit the number of threads created\n                .put(\"http.enabled\", false)\n                .put(\"index.store.type\", \"ram\")\n                .put(\"config.ignore_system_properties\", true) // make sure we get what we set :)\n                .put(\"gateway.type\", \"none\")).build();\n        build.start();\n        assertThat(DiscoveryNode.localNode(build.settings()), is(true));\n        return build;\n    }", "code_tokens": ["private", "static", "Node", "newNode", "(", ")", "{", "Node", "build", "=", "NodeBuilder", ".", "nodeBuilder", "(", ")", ".", "local", "(", "true", ")", ".", "data", "(", "true", ")", ".", "settings", "(", "ImmutableSettings", ".", "builder", "(", ")", ".", "put", "(", "ClusterName", ".", "SETTING", ",", "nodeName", "(", ")", ")", ".", "put", "(", "\"", "node.name", "\"", ",", "nodeName", "(", ")", ")", ".", "put", "(", "IndexMetaData", ".", "SETTING_NUMBER_OF_SHARDS", ",", "1", ")", ".", "put", "(", "IndexMetaData", ".", "SETTING_NUMBER_OF_REPLICAS", ",", "0", ")", ".", "put", "(", "\"", "script.disable_dynamic", "\"", ",", "false", ")", ".", "put", "(", "EsExecutors", ".", "PROCESSORS", ",", "1", ")", ".", "put", "(", "\"", "http.enabled", "\"", ",", "false", ")", ".", "put", "(", "\"", "index.store.type", "\"", ",", "\"", "ram", "\"", ")", ".", "put", "(", "\"", "config.ignore_system_properties", "\"", ",", "true", ")", ".", "put", "(", "\"", "gateway.type", "\"", ",", "\"", "none", "\"", ")", ")", ".", "build", "(", ")", ";", "build", ".", "start", "(", ")", ";", "assertThat", "(", "DiscoveryNode", ".", "localNode", "(", "build", ".", "settings", "(", ")", ")", ",", "is", "(", "true", ")", ")", ";", "return", "build", ";", "}"], "idx": 38062, "cwe": "CWE-284", "target": 0, "status": "FIXED", "commit": "4e952b2d75de6ca4caf4b6743462714f3b60d07f", "function_name": "newNode", "body_hash": "92f8e1871ef1af60a24677a806b0d486d6449e62"}
{"code": "public static ReconciliationReport parse(final Date run, final InputStream in) throws XMLStreamException {\n        XMLStreamReader streamReader = INPUT_FACTORY.createXMLStreamReader(in);\n        streamReader.nextTag(); // root\n        streamReader.nextTag(); // report\n        streamReader.nextTag(); // reportlet\n\n        ReconciliationReport report = new ReconciliationReport(run);\n\n        List<Missing> missing = new ArrayList<>();\n        List<Misaligned> misaligned = new ArrayList<>();\n        Set<String> onSyncope = null;\n        Set<String> onResource = null;\n\n        Any user = null;\n        Any group = null;\n        Any anyObject = null;\n        String lastAnyType = null;\n        while (streamReader.hasNext()) {\n            if (streamReader.isStartElement()) {\n                switch (streamReader.getLocalName()) {\n                    case \"users\":\n                        Anys users = new Anys();\n                        users.setTotal(Integer.parseInt(streamReader.getAttributeValue(\"\", \"total\")));\n                        report.setUsers(users);\n                        break;\n\n                    case \"user\":\n                        user = new Any();\n                        user.setType(AnyTypeKind.USER.name());\n                        user.setKey(streamReader.getAttributeValue(\"\", \"key\"));\n                        user.setName(streamReader.getAttributeValue(\"\", \"username\"));\n                        report.getUsers().getAnys().add(user);\n                        break;\n\n                    case \"groups\":\n                        Anys groups = new Anys();\n                        groups.setTotal(Integer.parseInt(streamReader.getAttributeValue(\"\", \"total\")));\n                        report.setGroups(groups);\n                        break;\n\n                    case \"group\":\n                        group = new Any();\n                        group.setType(AnyTypeKind.GROUP.name());\n                        group.setKey(streamReader.getAttributeValue(\"\", \"key\"));\n                        group.setName(streamReader.getAttributeValue(\"\", \"groupName\"));\n                        report.getGroups().getAnys().add(group);\n                        break;\n\n                    case \"anyObjects\":\n                        lastAnyType = streamReader.getAttributeValue(\"\", \"type\");\n                        Anys anyObjects = new Anys();\n                        anyObjects.setAnyType(lastAnyType);\n                        anyObjects.setTotal(Integer.parseInt(streamReader.getAttributeValue(\"\", \"total\")));\n                        report.getAnyObjects().add(anyObjects);\n                        break;\n\n                    case \"anyObject\":\n                        anyObject = new Any();\n                        anyObject.setType(lastAnyType);\n                        anyObject.setKey(streamReader.getAttributeValue(\"\", \"key\"));\n                        final String anyType = lastAnyType;\n                        Optional<Anys> anyReport = report.getAnyObjects().stream().\n                                filter(anys -> anyType.equals(anys.getAnyType())).\n                                findFirst();\n                        if (anyReport.isPresent()) {\n                            anyReport.get().getAnys().add(anyObject);\n                        }\n                        break;\n\n                    case \"missing\":\n                        missing.add(new Missing(\n                                streamReader.getAttributeValue(\"\", \"resource\"),\n                                streamReader.getAttributeValue(\"\", \"connObjectKeyValue\")));\n                        break;\n\n                    case \"misaligned\":\n                        misaligned.add(new Misaligned(\n                                streamReader.getAttributeValue(\"\", \"resource\"),\n                                streamReader.getAttributeValue(\"\", \"connObjectKeyValue\"),\n                                streamReader.getAttributeValue(\"\", \"name\")));\n                        break;\n\n                    case \"onSyncope\":\n                        onSyncope = new HashSet<>();\n                        break;\n\n                    case \"onResource\":\n                        onResource = new HashSet<>();\n                        break;\n\n                    case \"value\":\n                        Set<String> set = onSyncope == null ? onResource : onSyncope;\n                        set.add(streamReader.getElementText());\n                        break;\n\n                    default:\n                }\n            } else if (streamReader.isEndElement()) {\n                switch (streamReader.getLocalName()) {\n                    case \"user\":\n                        user.getMissing().addAll(missing);\n                        user.getMisaligned().addAll(misaligned);\n                        missing.clear();\n                        misaligned.clear();\n                        break;\n\n                    case \"group\":\n                        group.getMissing().addAll(missing);\n                        group.getMisaligned().addAll(misaligned);\n                        missing.clear();\n                        misaligned.clear();\n                        break;\n\n                    case \"anyObject\":\n                        anyObject.getMissing().addAll(missing);\n                        anyObject.getMisaligned().addAll(misaligned);\n                        missing.clear();\n                        misaligned.clear();\n                        break;\n\n                    case \"onSyncope\":\n                        misaligned.get(misaligned.size() - 1).getOnSyncope().addAll(onSyncope);\n                        onSyncope = null;\n                        break;\n\n                    case \"onResource\":\n                        misaligned.get(misaligned.size() - 1).getOnResource().addAll(onResource);\n                        onResource = null;\n                        break;\n\n                    default:\n                }\n\n            }\n\n            streamReader.next();\n        }\n\n        return report;\n    }", "code_tokens": ["public", "static", "ReconciliationReport", "parse", "(", "final", "Date", "run", ",", "final", "InputStream", "in", ")", "throws", "XMLStreamException", "{", "XMLStreamReader", "streamReader", "=", "INPUT_FACTORY", ".", "createXMLStreamReader", "(", "in", ")", ";", "streamReader", ".", "nextTag", "(", ")", ";", "streamReader", ".", "nextTag", "(", ")", ";", "streamReader", ".", "nextTag", "(", ")", ";", "ReconciliationReport", "report", "=", "new", "ReconciliationReport", "(", "run", ")", ";", "List", "<", "Missing", ">", "missing", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "Misaligned", ">", "misaligned", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "Set", "<", "String", ">", "onSyncope", "=", "null", ";", "Set", "<", "String", ">", "onResource", "=", "null", ";", "Any", "user", "=", "null", ";", "Any", "group", "=", "null", ";", "Any", "anyObject", "=", "null", ";", "String", "lastAnyType", "=", "null", ";", "while", "(", "streamReader", ".", "hasNext", "(", ")", ")", "{", "if", "(", "streamReader", ".", "isStartElement", "(", ")", ")", "{", "switch", "(", "streamReader", ".", "getLocalName", "(", ")", ")", "{", "case", "\"", "users", "\"", ":", "Anys", "users", "=", "new", "Anys", "(", ")", ";", "users", ".", "setTotal", "(", "Integer", ".", "parseInt", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "total", "\"", ")", ")", ")", ";", "report", ".", "setUsers", "(", "users", ")", ";", "break", ";", "case", "\"", "user", "\"", ":", "user", "=", "new", "Any", "(", ")", ";", "user", ".", "setType", "(", "AnyTypeKind", ".", "USER", ".", "name", "(", ")", ")", ";", "user", ".", "setKey", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "key", "\"", ")", ")", ";", "user", ".", "setName", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "username", "\"", ")", ")", ";", "report", ".", "getUsers", "(", ")", ".", "getAnys", "(", ")", ".", "add", "(", "user", ")", ";", "break", ";", "case", "\"", "groups", "\"", ":", "Anys", "groups", "=", "new", "Anys", "(", ")", ";", "groups", ".", "setTotal", "(", "Integer", ".", "parseInt", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "total", "\"", ")", ")", ")", ";", "report", ".", "setGroups", "(", "groups", ")", ";", "break", ";", "case", "\"", "group", "\"", ":", "group", "=", "new", "Any", "(", ")", ";", "group", ".", "setType", "(", "AnyTypeKind", ".", "GROUP", ".", "name", "(", ")", ")", ";", "group", ".", "setKey", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "key", "\"", ")", ")", ";", "group", ".", "setName", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "groupName", "\"", ")", ")", ";", "report", ".", "getGroups", "(", ")", ".", "getAnys", "(", ")", ".", "add", "(", "group", ")", ";", "break", ";", "case", "\"", "anyObjects", "\"", ":", "lastAnyType", "=", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "type", "\"", ")", ";", "Anys", "anyObjects", "=", "new", "Anys", "(", ")", ";", "anyObjects", ".", "setAnyType", "(", "lastAnyType", ")", ";", "anyObjects", ".", "setTotal", "(", "Integer", ".", "parseInt", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "total", "\"", ")", ")", ")", ";", "report", ".", "getAnyObjects", "(", ")", ".", "add", "(", "anyObjects", ")", ";", "break", ";", "case", "\"", "anyObject", "\"", ":", "anyObject", "=", "new", "Any", "(", ")", ";", "anyObject", ".", "setType", "(", "lastAnyType", ")", ";", "anyObject", ".", "setKey", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "key", "\"", ")", ")", ";", "final", "String", "anyType", "=", "lastAnyType", ";", "Optional", "<", "Anys", ">", "anyReport", "=", "report", ".", "getAnyObjects", "(", ")", ".", "stream", "(", ")", ".", "filter", "(", "anys", "->", "anyType", ".", "equals", "(", "anys", ".", "getAnyType", "(", ")", ")", ")", ".", "findFirst", "(", ")", ";", "if", "(", "anyReport", ".", "isPresent", "(", ")", ")", "{", "anyReport", ".", "get", "(", ")", ".", "getAnys", "(", ")", ".", "add", "(", "anyObject", ")", ";", "}", "break", ";", "case", "\"", "missing", "\"", ":", "missing", ".", "add", "(", "new", "Missing", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "resource", "\"", ")", ",", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "connObjectKeyValue", "\"", ")", ")", ")", ";", "break", ";", "case", "\"", "misaligned", "\"", ":", "misaligned", ".", "add", "(", "new", "Misaligned", "(", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "resource", "\"", ")", ",", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "connObjectKeyValue", "\"", ")", ",", "streamReader", ".", "getAttributeValue", "(", "\"", "\"", ",", "\"", "name", "\"", ")", ")", ")", ";", "break", ";", "case", "\"", "onSyncope", "\"", ":", "onSyncope", "=", "new", "HashSet", "<", ">", "(", ")", ";", "break", ";", "case", "\"", "onResource", "\"", ":", "onResource", "=", "new", "HashSet", "<", ">", "(", ")", ";", "break", ";", "case", "\"", "value", "\"", ":", "Set", "<", "String", ">", "set", "=", "onSyncope", "==", "null", "?", "onResource", ":", "onSyncope", ";", "set", ".", "add", "(", "streamReader", ".", "getElementText", "(", ")", ")", ";", "break", ";", "default", ":", "}", "}", "else", "if", "(", "streamReader", ".", "isEndElement", "(", ")", ")", "{", "switch", "(", "streamReader", ".", "getLocalName", "(", ")", ")", "{", "case", "\"", "user", "\"", ":", "user", ".", "getMissing", "(", ")", ".", "addAll", "(", "missing", ")", ";", "user", ".", "getMisaligned", "(", ")", ".", "addAll", "(", "misaligned", ")", ";", "missing", ".", "clear", "(", ")", ";", "misaligned", ".", "clear", "(", ")", ";", "break", ";", "case", "\"", "group", "\"", ":", "group", ".", "getMissing", "(", ")", ".", "addAll", "(", "missing", ")", ";", "group", ".", "getMisaligned", "(", ")", ".", "addAll", "(", "misaligned", ")", ";", "missing", ".", "clear", "(", ")", ";", "misaligned", ".", "clear", "(", ")", ";", "break", ";", "case", "\"", "anyObject", "\"", ":", "anyObject", ".", "getMissing", "(", ")", ".", "addAll", "(", "missing", ")", ";", "anyObject", ".", "getMisaligned", "(", ")", ".", "addAll", "(", "misaligned", ")", ";", "missing", ".", "clear", "(", ")", ";", "misaligned", ".", "clear", "(", ")", ";", "break", ";", "case", "\"", "onSyncope", "\"", ":", "misaligned", ".", "get", "(", "misaligned", ".", "size", "(", ")", "-", "1", ")", ".", "getOnSyncope", "(", ")", ".", "addAll", "(", "onSyncope", ")", ";", "onSyncope", "=", "null", ";", "break", ";", "case", "\"", "onResource", "\"", ":", "misaligned", ".", "get", "(", "misaligned", ".", "size", "(", ")", "-", "1", ")", ".", "getOnResource", "(", ")", ".", "addAll", "(", "onResource", ")", ";", "onResource", "=", "null", ";", "break", ";", "default", ":", "}", "}", "streamReader", ".", "next", "(", ")", ";", "}", "return", "report", ";", "}"], "idx": 67245, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "a0f35f45f8ca5c98853ae8477fb2db81a84709a", "function_name": "parse", "body_hash": "7a7793b2304cb75f0762bf8b7118525a3bf11feb"}
{"code": "@Override\n\tpublic void convertInput()\n\t{\n\t\tsuper.convertInput();\n\n\t\tfinal PolicyFactory policy = newPolicyFactory();\n\t\tfinal String input = this.getConvertedInput();\n\n\t\tthis.setConvertedInput(policy.sanitize(input));\n\t}", "code_tokens": ["@", "Override", "public", "void", "convertInput", "(", ")", "{", "super", ".", "convertInput", "(", ")", ";", "final", "PolicyFactory", "policy", "=", "newPolicyFactory", "(", ")", ";", "final", "String", "input", "=", "this", ".", "getConvertedInput", "(", ")", ";", "this", ".", "setConvertedInput", "(", "policy", ".", "sanitize", "(", "input", ")", ")", ";", "}"], "idx": 81752, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "936c12a2db262cf471c781f0d3c0d0ad61c35c7", "function_name": "convertInput", "body_hash": "14cd0118dfa4ba37d8cd3c87084809a7e55db4f4"}
{"code": "protected void applyAuthentication(LdapContext ctx, String userDn, String password) throws NamingException {\r\n\t\tctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, SIMPLE_AUTHENTICATION);\r\n\t\tctx.addToEnvironment(Context.SECURITY_PRINCIPAL, userDn);\r\n\t\tctx.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\r\n\t\t// Force reconnect with user credentials\r\n\t\tctx.reconnect(null);\r\n\t}", "code_tokens": ["protected", "void", "applyAuthentication", "(", "LdapContext", "ctx", ",", "String", "userDn", ",", "String", "password", ")", "throws", "NamingException", "{", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "SIMPLE_AUTHENTICATION", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "userDn", ")", ";", "ctx", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "password", ")", ";", "ctx", ".", "reconnect", "(", "null", ")", ";", "}"], "idx": 38579, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "08e8ae289bbd1b581986c7238604a147119c1336", "function_name": "applyAuthentication", "body_hash": "9c0dc11c88e8ce4d36334dab2f4d59e1a128e254"}
{"code": "protected void parseNameAndNamespace(String uri, ActionMapping mapping, ConfigurationManager configManager) {\n        String namespace, name;\n        int lastSlash = uri.lastIndexOf('/');\n        if (lastSlash == -1) {\n            namespace = \"\";\n            name = uri;\n        } else if (lastSlash == 0) {\n            // ww-1046, assume it is the root namespace, it will fallback to\n            // default\n            // namespace anyway if not found in root namespace.\n            namespace = \"/\";\n            name = uri.substring(lastSlash + 1);\n        } else if (alwaysSelectFullNamespace) {\n            // Simply select the namespace as everything before the last slash\n            namespace = uri.substring(0, lastSlash);\n            name = uri.substring(lastSlash + 1);\n        } else {\n            // Try to find the namespace in those defined, defaulting to \"\"\n            Configuration config = configManager.getConfiguration();\n            String prefix = uri.substring(0, lastSlash);\n            namespace = \"\";\n            boolean rootAvailable = false;\n            // Find the longest matching namespace, defaulting to the default\n            for (PackageConfig cfg : config.getPackageConfigs().values()) {\n                String ns = cfg.getNamespace();\n                if (ns != null && prefix.startsWith(ns) && (prefix.length() == ns.length() || prefix.charAt(ns.length()) == '/')) {\n                    if (ns.length() > namespace.length()) {\n                        namespace = ns;\n                    }\n                }\n                if (\"/\".equals(ns)) {\n                    rootAvailable = true;\n                }\n            }\n\n            name = uri.substring(namespace.length() + 1);\n\n            // Still none found, use root namespace if found\n            if (rootAvailable && \"\".equals(namespace)) {\n                namespace = \"/\";\n            }\n        }\n\n        if (!allowSlashesInActionNames) {\n            int pos = name.lastIndexOf('/');\n            if (pos > -1 && pos < name.length() - 1) {\n                name = name.substring(pos + 1);\n            }\n        }\n\n        mapping.setNamespace(namespace);\n        mapping.setName(cleanupActionName(name));\n    }", "code_tokens": ["protected", "void", "parseNameAndNamespace", "(", "String", "uri", ",", "ActionMapping", "mapping", ",", "ConfigurationManager", "configManager", ")", "{", "String", "namespace", ",", "name", ";", "int", "lastSlash", "=", "uri", ".", "lastIndexOf", "(", "'/'", ")", ";", "if", "(", "lastSlash", "==", "-", "1", ")", "{", "namespace", "=", "\"", "\"", ";", "name", "=", "uri", ";", "}", "else", "if", "(", "lastSlash", "==", "0", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "if", "(", "alwaysSelectFullNamespace", ")", "{", "namespace", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "{", "Configuration", "config", "=", "configManager", ".", "getConfiguration", "(", ")", ";", "String", "prefix", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "namespace", "=", "\"", "\"", ";", "boolean", "rootAvailable", "=", "false", ";", "for", "(", "PackageConfig", "cfg", ":", "config", ".", "getPackageConfigs", "(", ")", ".", "values", "(", ")", ")", "{", "String", "ns", "=", "cfg", ".", "getNamespace", "(", ")", ";", "if", "(", "ns", "!=", "null", "&&", "prefix", ".", "startsWith", "(", "ns", ")", "&&", "(", "prefix", ".", "length", "(", ")", "==", "ns", ".", "length", "(", ")", "||", "prefix", ".", "charAt", "(", "ns", ".", "length", "(", ")", ")", "==", "'/'", ")", ")", "{", "if", "(", "ns", ".", "length", "(", ")", ">", "namespace", ".", "length", "(", ")", ")", "{", "namespace", "=", "ns", ";", "}", "}", "if", "(", "\"", "/", "\"", ".", "equals", "(", "ns", ")", ")", "{", "rootAvailable", "=", "true", ";", "}", "}", "name", "=", "uri", ".", "substring", "(", "namespace", ".", "length", "(", ")", "+", "1", ")", ";", "if", "(", "rootAvailable", "&&", "\"", "\"", ".", "equals", "(", "namespace", ")", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "}", "}", "if", "(", "!", "allowSlashesInActionNames", ")", "{", "int", "pos", "=", "name", ".", "lastIndexOf", "(", "'/'", ")", ";", "if", "(", "pos", ">", "-", "1", "&&", "pos", "<", "name", ".", "length", "(", ")", "-", "1", ")", "{", "name", "=", "name", ".", "substring", "(", "pos", "+", "1", ")", ";", "}", "}", "mapping", ".", "setNamespace", "(", "namespace", ")", ";", "mapping", ".", "setName", "(", "cleanupActionName", "(", "name", ")", ")", ";", "}"], "idx": 6703, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "6e87474f9ad0549f07dd2c37d50a9ccd0977c6e", "function_name": "parseNameAndNamespace", "body_hash": "6adb73fe7120c15865c8d83ca5ded19ee6dea8d9"}
{"code": "@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tString newLocale = request.getParameter(this.paramName);\n\t\tif (newLocale != null) {\n\t\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);\n\t\t\tif (localeResolver == null) {\n\t\t\t\tthrow new IllegalStateException(\"No LocaleResolver found: not in a DispatcherServlet request?\");\n\t\t\t}\n\t\t\tLocaleEditor localeEditor = new LocaleEditor();\n\t\t\tlocaleEditor.setAsText(newLocale);\n\t\t\tlocaleResolver.setLocale(request, response, (Locale) localeEditor.getValue());\n\t\t}\n\t\t// Proceed in any case.\n\t\treturn true;\n\t}", "code_tokens": ["@", "Override", "public", "boolean", "preHandle", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Object", "handler", ")", "throws", "ServletException", "{", "String", "newLocale", "=", "request", ".", "getParameter", "(", "this", ".", "paramName", ")", ";", "if", "(", "newLocale", "!=", "null", ")", "{", "LocaleResolver", "localeResolver", "=", "RequestContextUtils", ".", "getLocaleResolver", "(", "request", ")", ";", "if", "(", "localeResolver", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "No LocaleResolver found: not in a DispatcherServlet request?", "\"", ")", ";", "}", "LocaleEditor", "localeEditor", "=", "new", "LocaleEditor", "(", ")", ";", "localeEditor", ".", "setAsText", "(", "newLocale", ")", ";", "localeResolver", ".", "setLocale", "(", "request", ",", "response", ",", "(", "Locale", ")", "localeEditor", ".", "getValue", "(", ")", ")", ";", "}", "return", "true", ";", "}"], "idx": 10553, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "f4a2282d9d9f6e58029022c58311a1db07f7defc", "function_name": "preHandle", "body_hash": "fbf0af152ab1eceab912a50fc3eea2a734e4c428"}
{"code": "private Environment getRemoteEnvironment(RestTemplate restTemplate,\n\t\t\tConfigClientProperties properties, String label, String state) {\n\t\tString path = \"/{name}/{profile}\";\n\t\tString name = properties.getName();\n\t\tString profile = properties.getProfile();\n\t\tString token = properties.getToken();\n\t\tint noOfUrls = properties.getUri().length;\n\t\tif (noOfUrls > 1) {\n\t\t\tlogger.info(\"Multiple Config Server Urls found listed.\");\n\t\t}\n\n\t\tObject[] args = new String[] { name, profile };\n\t\tif (StringUtils.hasText(label)) {\n\t\t\t// workaround for Spring MVC matching / in paths\n\t\t\tlabel = Environment.denormalize(label);\n\t\t\targs = new String[] { name, profile, label };\n\t\t\tpath = path + \"/{label}\";\n\t\t}\n\t\tResponseEntity<Environment> response = null;\n\n\t\tfor (int i = 0; i < noOfUrls; i++) {\n\t\t\tCredentials credentials = properties.getCredentials(i);\n\t\t\tString uri = credentials.getUri();\n\t\t\tString username = credentials.getUsername();\n\t\t\tString password = credentials.getPassword();\n\n\t\t\tlogger.info(\"Fetching config from server at : \" + uri);\n\n\t\t\ttry {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\taddAuthorizationToken(properties, headers, username, password);\n\t\t\t\tif (StringUtils.hasText(token)) {\n\t\t\t\t\theaders.add(TOKEN_HEADER, token);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasText(state) && properties.isSendState()) {\n\t\t\t\t\theaders.add(STATE_HEADER, state);\n\t\t\t\t}\n\t\t\t\theaders.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));\n\n\t\t\t\tfinal HttpEntity<Void> entity = new HttpEntity<>((Void) null, headers);\n\t\t\t\tresponse = restTemplate.exchange(uri + path, HttpMethod.GET, entity,\n\t\t\t\t\t\tEnvironment.class, args);\n\t\t\t}\n\t\t\tcatch (HttpClientErrorException e) {\n\t\t\t\tif (e.getStatusCode() != HttpStatus.NOT_FOUND) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ResourceAccessException e) {\n\t\t\t\tlogger.info(\"Connect Timeout Exception on Url - \" + uri\n\t\t\t\t\t\t+ \". Will be trying the next url if available\");\n\t\t\t\tif (i == noOfUrls - 1) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (response == null || response.getStatusCode() != HttpStatus.OK) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tEnvironment result = response.getBody();\n\t\t\treturn result;\n\t\t}\n\n\t\treturn null;\n\t}", "code_tokens": ["private", "Environment", "getRemoteEnvironment", "(", "RestTemplate", "restTemplate", ",", "ConfigClientProperties", "properties", ",", "String", "label", ",", "String", "state", ")", "{", "String", "path", "=", "\"", "/{name}/{profile}", "\"", ";", "String", "name", "=", "properties", ".", "getName", "(", ")", ";", "String", "profile", "=", "properties", ".", "getProfile", "(", ")", ";", "String", "token", "=", "properties", ".", "getToken", "(", ")", ";", "int", "noOfUrls", "=", "properties", ".", "getUri", "(", ")", ".", "length", ";", "if", "(", "noOfUrls", ">", "1", ")", "{", "logger", ".", "info", "(", "\"", "Multiple Config Server Urls found listed.", "\"", ")", ";", "}", "Object", "[", "]", "args", "=", "new", "String", "[", "]", "{", "name", ",", "profile", "}", ";", "if", "(", "StringUtils", ".", "hasText", "(", "label", ")", ")", "{", "label", "=", "Environment", ".", "denormalize", "(", "label", ")", ";", "args", "=", "new", "String", "[", "]", "{", "name", ",", "profile", ",", "label", "}", ";", "path", "=", "path", "+", "\"", "/{label}", "\"", ";", "}", "ResponseEntity", "<", "Environment", ">", "response", "=", "null", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "noOfUrls", ";", "i", "++", ")", "{", "Credentials", "credentials", "=", "properties", ".", "getCredentials", "(", "i", ")", ";", "String", "uri", "=", "credentials", ".", "getUri", "(", ")", ";", "String", "username", "=", "credentials", ".", "getUsername", "(", ")", ";", "String", "password", "=", "credentials", ".", "getPassword", "(", ")", ";", "logger", ".", "info", "(", "\"", "Fetching config from server at : ", "\"", "+", "uri", ")", ";", "try", "{", "HttpHeaders", "headers", "=", "new", "HttpHeaders", "(", ")", ";", "addAuthorizationToken", "(", "properties", ",", "headers", ",", "username", ",", "password", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "token", ")", ")", "{", "headers", ".", "add", "(", "TOKEN_HEADER", ",", "token", ")", ";", "}", "if", "(", "StringUtils", ".", "hasText", "(", "state", ")", "&&", "properties", ".", "isSendState", "(", ")", ")", "{", "headers", ".", "add", "(", "STATE_HEADER", ",", "state", ")", ";", "}", "headers", ".", "setAccept", "(", "Collections", ".", "singletonList", "(", "MediaType", ".", "APPLICATION_JSON", ")", ")", ";", "final", "HttpEntity", "<", "Void", ">", "entity", "=", "new", "HttpEntity", "<", ">", "(", "(", "Void", ")", "null", ",", "headers", ")", ";", "response", "=", "restTemplate", ".", "exchange", "(", "uri", "+", "path", ",", "HttpMethod", ".", "GET", ",", "entity", ",", "Environment", ".", "class", ",", "args", ")", ";", "}", "catch", "(", "HttpClientErrorException", "e", ")", "{", "if", "(", "e", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "NOT_FOUND", ")", "{", "throw", "e", ";", "}", "}", "catch", "(", "ResourceAccessException", "e", ")", "{", "logger", ".", "info", "(", "\"", "Connect Timeout Exception on Url - ", "\"", "+", "uri", "+", "\"", ". Will be trying the next url if available", "\"", ")", ";", "if", "(", "i", "==", "noOfUrls", "-", "1", ")", "{", "throw", "e", ";", "}", "else", "{", "continue", ";", "}", "}", "if", "(", "response", "==", "null", "||", "response", ".", "getStatusCode", "(", ")", "!=", "HttpStatus", ".", "OK", ")", "{", "return", "null", ";", "}", "Environment", "result", "=", "response", ".", "getBody", "(", ")", ";", "return", "result", ";", "}", "return", "null", ";", "}"], "idx": 26329, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "b991dc17c2772e5da33639d3c4bc98b13bc04734", "function_name": "getRemoteEnvironment", "body_hash": "84cbeff2db73cb68d8e0fd2e184b1fa84db6ef5d"}
{"code": "@Override\n\tpublic String getName() {\n\t\treturn hudson.Util.escape(name);\n\t}", "code_tokens": ["@", "Override", "public", "String", "getName", "(", ")", "{", "return", "hudson", ".", "Util", ".", "escape", "(", "name", ")", ";", "}"], "idx": 80520, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "309d402", "function_name": "getName", "body_hash": "bbb7402d9cc2b652c7eeaa86bda44301c1da9795"}
{"code": "private static boolean contains(final String[] list, final String name) {\n        if (list != null) {\n            for (final String white : list) {\n                if (name.startsWith(white)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "code_tokens": ["private", "static", "boolean", "contains", "(", "final", "String", "[", "]", "list", ",", "final", "String", "name", ")", "{", "if", "(", "list", "!=", "null", ")", "{", "for", "(", "final", "String", "white", ":", "list", ")", "{", "if", "(", "name", ".", "startsWith", "(", "white", ")", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "idx": 58392, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "58cdbbef9c77ab2b44870f9d606593b49cde76d9", "function_name": "contains", "body_hash": "39db7e8f8cf80bdc3b53277d3b2501f634c03b59"}
{"code": "@Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            RESTRequestParameterProcessingFilter restAuthenticationFilter = new RESTRequestParameterProcessingFilter();\n            restAuthenticationFilter.setAuthenticationManager(authenticationManagerBean());\n            restAuthenticationFilter.setSecurityService(securityService);\n            restAuthenticationFilter.setEventPublisher(eventPublisher);\n            http = http.addFilterBefore(restAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .csrf()\n                    .requireCsrfProtectionMatcher(csrfSecurityRequestMatcher)\n                    .and().headers()\n                    .frameOptions()\n                    .sameOrigin()\n                    .and().authorizeRequests()\n                    .antMatchers(\"/recover*\", \"/accessDenied*\",\n                            \"/style/**\", \"/icons/**\", \"/flash/**\", \"/script/**\",\n                            \"/sonos/**\", \"/crossdomain.xml\", \"/login\", \"/error\")\n                    .permitAll()\n                    .antMatchers(\"/personalSettings*\", \"/passwordSettings*\",\n                            \"/playerSettings*\", \"/shareSettings*\", \"/passwordSettings*\")\n                    .hasRole(\"SETTINGS\")\n                    .antMatchers(\"/generalSettings*\", \"/advancedSettings*\", \"/userSettings*\",\n                            \"/musicFolderSettings*\", \"/databaseSettings*\", \"/transcodeSettings*\", \"/rest/startScan*\")\n                    .hasRole(\"ADMIN\")\n                    .antMatchers(\"/deletePlaylist*\", \"/savePlaylist*\", \"/db*\")\n                    .hasRole(\"PLAYLIST\")\n                    .antMatchers(\"/download*\")\n                    .hasRole(\"DOWNLOAD\")\n                    .antMatchers(\"/upload*\")\n                    .hasRole(\"UPLOAD\")\n                    .antMatchers(\"/createShare*\")\n                    .hasRole(\"SHARE\")\n                    .antMatchers(\"/changeCoverArt*\", \"/editTags*\")\n                    .hasRole(\"COVERART\")\n                    .antMatchers(\"/setMusicFileInfo*\")\n                    .hasRole(\"COMMENT\")\n                    .antMatchers(\"/podcastReceiverAdmin*\")\n                    .hasRole(\"PODCAST\")\n                    .antMatchers(\"/**\")\n                    .hasRole(\"USER\")\n                    .anyRequest().authenticated()\n                    .and().formLogin()\n                    .loginPage(\"/login\")\n                    .permitAll()\n                    .defaultSuccessUrl(\"/index\", true)\n                    .failureUrl(FAILURE_URL)\n                    .usernameParameter(\"j_username\")\n                    .passwordParameter(\"j_password\")\n                    // see http://docs.spring.io/spring-security/site/docs/3.2.4.RELEASE/reference/htmlsingle/#csrf-logout\n                    .and().logout().logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\", \"GET\")).logoutSuccessUrl(\n                    \"/login?logout\")\n                    .and().rememberMe().key(\"airsonic\");\n        }", "code_tokens": ["@", "Override", "protected", "void", "configure", "(", "HttpSecurity", "http", ")", "throws", "Exception", "{", "RESTRequestParameterProcessingFilter", "restAuthenticationFilter", "=", "new", "RESTRequestParameterProcessingFilter", "(", ")", ";", "restAuthenticationFilter", ".", "setAuthenticationManager", "(", "authenticationManagerBean", "(", ")", ")", ";", "restAuthenticationFilter", ".", "setSecurityService", "(", "securityService", ")", ";", "restAuthenticationFilter", ".", "setEventPublisher", "(", "eventPublisher", ")", ";", "http", "=", "http", ".", "addFilterBefore", "(", "restAuthenticationFilter", ",", "UsernamePasswordAuthenticationFilter", ".", "class", ")", ";", "http", ".", "csrf", "(", ")", ".", "requireCsrfProtectionMatcher", "(", "csrfSecurityRequestMatcher", ")", ".", "and", "(", ")", ".", "headers", "(", ")", ".", "frameOptions", "(", ")", ".", "sameOrigin", "(", ")", ".", "and", "(", ")", ".", "authorizeRequests", "(", ")", ".", "antMatchers", "(", "\"", "/recover*", "\"", ",", "\"", "/accessDenied*", "\"", ",", "\"", "/style/**", "\"", ",", "\"", "/icons/**", "\"", ",", "\"", "/flash/**", "\"", ",", "\"", "/script/**", "\"", ",", "\"", "/sonos/**", "\"", ",", "\"", "/crossdomain.xml", "\"", ",", "\"", "/login", "\"", ",", "\"", "/error", "\"", ")", ".", "permitAll", "(", ")", ".", "antMatchers", "(", "\"", "/personalSettings*", "\"", ",", "\"", "/passwordSettings*", "\"", ",", "\"", "/playerSettings*", "\"", ",", "\"", "/shareSettings*", "\"", ",", "\"", "/passwordSettings*", "\"", ")", ".", "hasRole", "(", "\"", "SETTINGS", "\"", ")", ".", "antMatchers", "(", "\"", "/generalSettings*", "\"", ",", "\"", "/advancedSettings*", "\"", ",", "\"", "/userSettings*", "\"", ",", "\"", "/musicFolderSettings*", "\"", ",", "\"", "/databaseSettings*", "\"", ",", "\"", "/transcodeSettings*", "\"", ",", "\"", "/rest/startScan*", "\"", ")", ".", "hasRole", "(", "\"", "ADMIN", "\"", ")", ".", "antMatchers", "(", "\"", "/deletePlaylist*", "\"", ",", "\"", "/savePlaylist*", "\"", ",", "\"", "/db*", "\"", ")", ".", "hasRole", "(", "\"", "PLAYLIST", "\"", ")", ".", "antMatchers", "(", "\"", "/download*", "\"", ")", ".", "hasRole", "(", "\"", "DOWNLOAD", "\"", ")", ".", "antMatchers", "(", "\"", "/upload*", "\"", ")", ".", "hasRole", "(", "\"", "UPLOAD", "\"", ")", ".", "antMatchers", "(", "\"", "/createShare*", "\"", ")", ".", "hasRole", "(", "\"", "SHARE", "\"", ")", ".", "antMatchers", "(", "\"", "/changeCoverArt*", "\"", ",", "\"", "/editTags*", "\"", ")", ".", "hasRole", "(", "\"", "COVERART", "\"", ")", ".", "antMatchers", "(", "\"", "/setMusicFileInfo*", "\"", ")", ".", "hasRole", "(", "\"", "COMMENT", "\"", ")", ".", "antMatchers", "(", "\"", "/podcastReceiverAdmin*", "\"", ")", ".", "hasRole", "(", "\"", "PODCAST", "\"", ")", ".", "antMatchers", "(", "\"", "/**", "\"", ")", ".", "hasRole", "(", "\"", "USER", "\"", ")", ".", "anyRequest", "(", ")", ".", "authenticated", "(", ")", ".", "and", "(", ")", ".", "formLogin", "(", ")", ".", "loginPage", "(", "\"", "/login", "\"", ")", ".", "permitAll", "(", ")", ".", "defaultSuccessUrl", "(", "\"", "/index", "\"", ",", "true", ")", ".", "failureUrl", "(", "FAILURE_URL", ")", ".", "usernameParameter", "(", "\"", "j_username", "\"", ")", ".", "passwordParameter", "(", "\"", "j_password", "\"", ")", ".", "and", "(", ")", ".", "logout", "(", ")", ".", "logoutRequestMatcher", "(", "new", "AntPathRequestMatcher", "(", "\"", "/logout", "\"", ",", "\"", "GET", "\"", ")", ")", ".", "logoutSuccessUrl", "(", "\"", "/login?logout", "\"", ")", ".", "and", "(", ")", ".", "rememberMe", "(", ")", ".", "key", "(", "\"", "airsonic", "\"", ")", ";", "}"], "idx": 42131, "cwe": "CWE-326", "target": 1, "status": "VULNERABLE", "commit": "3e07ea52885f88d3fbec444dfd592f27bfb65647", "function_name": "configure", "body_hash": "3bafb937f42e4339af03ec188111081c2447f7b1"}
{"code": "@Override\n  public void refreshRow() throws SQLException {\n    checkUpdateable();\n    if (onInsertRow) {\n      throw new PSQLException(GT.tr(\"Can''t refresh the insert row.\"),\n          PSQLState.INVALID_CURSOR_STATE);\n    }\n\n    if (isBeforeFirst() || isAfterLast() || castNonNull(rows, \"rows\").isEmpty()) {\n      return;\n    }\n\n    StringBuilder selectSQL = new StringBuilder(\"select \");\n\n    ResultSetMetaData rsmd = getMetaData();\n    PGResultSetMetaData pgmd = (PGResultSetMetaData) rsmd;\n    for (int i = 1; i <= rsmd.getColumnCount(); i++) {\n      if (i > 1) {\n        selectSQL.append(\", \");\n      }\n      selectSQL.append(pgmd.getBaseColumnName(i));\n    }\n    selectSQL.append(\" from \").append(onlyTable).append(tableName).append(\" where \");\n\n    List<PrimaryKey> primaryKeys = castNonNull(this.primaryKeys, \"primaryKeys\");\n    int numKeys = primaryKeys.size();\n\n    for (int i = 0; i < numKeys; i++) {\n\n      PrimaryKey primaryKey = primaryKeys.get(i);\n      selectSQL.append(primaryKey.name).append(\" = ?\");\n\n      if (i < numKeys - 1) {\n        selectSQL.append(\" and \");\n      }\n    }\n    String sqlText = selectSQL.toString();\n    if (connection.getLogger().isLoggable(Level.FINE)) {\n      connection.getLogger().log(Level.FINE, \"selecting {0}\", sqlText);\n    }\n    // because updateable result sets do not yet support binary transfers we must request refresh\n    // with updateable result set to get field data in correct format\n    PreparedStatement selectStatement = null;\n    try {\n      selectStatement = connection.prepareStatement(sqlText,\n          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);\n\n      for (int i = 0; i < numKeys; i++) {\n        selectStatement.setObject(i + 1, primaryKeys.get(i).getValue());\n      }\n\n      PgResultSet rs = (PgResultSet) selectStatement.executeQuery();\n\n      if (rs.next()) {\n        // we know that the row is updatable as it was tested above.\n        if ( rs.thisRow == null ) {\n          rowBuffer = null;\n        } else {\n          rowBuffer = castNonNull(rs.thisRow).updateableCopy();\n        }\n      }\n\n      castNonNull(rows).set(currentRow, castNonNull(rowBuffer));\n      thisRow = rowBuffer;\n\n      connection.getLogger().log(Level.FINE, \"done updates\");\n\n      rs.close();\n    } finally {\n      JdbcBlackHole.close(selectStatement);\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "refreshRow", "(", ")", "throws", "SQLException", "{", "checkUpdateable", "(", ")", ";", "if", "(", "onInsertRow", ")", "{", "throw", "new", "PSQLException", "(", "GT", ".", "tr", "(", "\"", "Can''t refresh the insert row.", "\"", ")", ",", "PSQLState", ".", "INVALID_CURSOR_STATE", ")", ";", "}", "if", "(", "isBeforeFirst", "(", ")", "||", "isAfterLast", "(", ")", "||", "castNonNull", "(", "rows", ",", "\"", "rows", "\"", ")", ".", "isEmpty", "(", ")", ")", "{", "return", ";", "}", "StringBuilder", "selectSQL", "=", "new", "StringBuilder", "(", "\"", "select ", "\"", ")", ";", "ResultSetMetaData", "rsmd", "=", "getMetaData", "(", ")", ";", "PGResultSetMetaData", "pgmd", "=", "(", "PGResultSetMetaData", ")", "rsmd", ";", "for", "(", "int", "i", "=", "1", ";", "i", "<=", "rsmd", ".", "getColumnCount", "(", ")", ";", "i", "++", ")", "{", "if", "(", "i", ">", "1", ")", "{", "selectSQL", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "selectSQL", ".", "append", "(", "pgmd", ".", "getBaseColumnName", "(", "i", ")", ")", ";", "}", "selectSQL", ".", "append", "(", "\"", " from ", "\"", ")", ".", "append", "(", "onlyTable", ")", ".", "append", "(", "tableName", ")", ".", "append", "(", "\"", " where ", "\"", ")", ";", "List", "<", "PrimaryKey", ">", "primaryKeys", "=", "castNonNull", "(", "this", ".", "primaryKeys", ",", "\"", "primaryKeys", "\"", ")", ";", "int", "numKeys", "=", "primaryKeys", ".", "size", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "numKeys", ";", "i", "++", ")", "{", "PrimaryKey", "primaryKey", "=", "primaryKeys", ".", "get", "(", "i", ")", ";", "selectSQL", ".", "append", "(", "primaryKey", ".", "name", ")", ".", "append", "(", "\"", " = ?", "\"", ")", ";", "if", "(", "i", "<", "numKeys", "-", "1", ")", "{", "selectSQL", ".", "append", "(", "\"", " and ", "\"", ")", ";", "}", "}", "String", "sqlText", "=", "selectSQL", ".", "toString", "(", ")", ";", "if", "(", "connection", ".", "getLogger", "(", ")", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "connection", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "selecting {0}", "\"", ",", "sqlText", ")", ";", "}", "PreparedStatement", "selectStatement", "=", "null", ";", "try", "{", "selectStatement", "=", "connection", ".", "prepareStatement", "(", "sqlText", ",", "ResultSet", ".", "TYPE_SCROLL_INSENSITIVE", ",", "ResultSet", ".", "CONCUR_UPDATABLE", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "numKeys", ";", "i", "++", ")", "{", "selectStatement", ".", "setObject", "(", "i", "+", "1", ",", "primaryKeys", ".", "get", "(", "i", ")", ".", "getValue", "(", ")", ")", ";", "}", "PgResultSet", "rs", "=", "(", "PgResultSet", ")", "selectStatement", ".", "executeQuery", "(", ")", ";", "if", "(", "rs", ".", "next", "(", ")", ")", "{", "if", "(", "rs", ".", "thisRow", "==", "null", ")", "{", "rowBuffer", "=", "null", ";", "}", "else", "{", "rowBuffer", "=", "castNonNull", "(", "rs", ".", "thisRow", ")", ".", "updateableCopy", "(", ")", ";", "}", "}", "castNonNull", "(", "rows", ")", ".", "set", "(", "currentRow", ",", "castNonNull", "(", "rowBuffer", ")", ")", ";", "thisRow", "=", "rowBuffer", ";", "connection", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "done updates", "\"", ")", ";", "rs", ".", "close", "(", ")", ";", "}", "finally", "{", "JdbcBlackHole", ".", "close", "(", "selectStatement", ")", ";", "}", "}"], "idx": 91572, "cwe": "CWE-89", "target": 1, "status": "VULNERABLE", "commit": "739e599d52ad80f8dcd6efedc6157859b1a9d637", "function_name": "refreshRow", "body_hash": "45ca4fdf50e104686dc0219de4e46901a6232dab"}
{"code": "public void testCookiesWithClassPollution() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        String pollution1 = \"model['class']['classLoader']['jarPath']\";\n        String pollution2 = \"model.class.classLoader.jarPath\";\n        String pollution3 = \"class.classLoader.jarPath\";\n        String pollution4 = \"class['classLoader']['jarPath']\";\n        String pollution5 = \"model[\\\"class\\\"]['classLoader']['jarPath']\";\n        String pollution6 = \"class[\\\"classLoader\\\"]['jarPath']\";\n\n        request.setCookies(\n                new Cookie(pollution1, \"pollution1\"),\n                new Cookie(\"pollution1\", pollution1),\n                new Cookie(pollution2, \"pollution2\"),\n                new Cookie(\"pollution2\", pollution2),\n                new Cookie(pollution3, \"pollution3\"),\n                new Cookie(\"pollution3\", pollution3),\n                new Cookie(pollution4, \"pollution4\"),\n                new Cookie(\"pollution4\", pollution4),\n                new Cookie(pollution5, \"pollution5\"),\n                new Cookie(\"pollution5\", pollution5),\n                new Cookie(pollution6, \"pollution6\"),\n                new Cookie(\"pollution6\", pollution6)\n            );\n        ServletActionContext.setRequest(request);\n\n        final Map<String, Boolean> excludedName = new HashMap<String, Boolean>();\n        final Map<String, Boolean> excludedValue = new HashMap<String, Boolean>();\n\n        CookieInterceptor interceptor = new CookieInterceptor() {\n            @Override\n            protected boolean isAcceptableName(String name) {\n                boolean accepted = super.isAcceptableName(name);\n                excludedName.put(name, accepted);\n                return accepted;\n            }\n\n            @Override\n            protected boolean isAcceptableValue(String value) {\n                boolean accepted = super.isAcceptableValue(value);\n                excludedValue.put(value, accepted);\n                return accepted;\n            }\n        };\n        DefaultExcludedPatternsChecker excludedPatternsChecker = new DefaultExcludedPatternsChecker();\n        excludedPatternsChecker.setAdditionalExcludePatterns(\".*(^|\\\\.|\\\\[|'|\\\")class(\\\\.|\\\\[|'|\\\").*\");\n        interceptor.setExcludedPatternsChecker(excludedPatternsChecker);\n        interceptor.setCookiesName(\"*\");\n\n        MockActionInvocation invocation = new MockActionInvocation();\n        invocation.setAction(new MockActionWithCookieAware());\n\n        interceptor.intercept(invocation);\n\n        assertFalse(excludedName.get(pollution1));\n        assertFalse(excludedName.get(pollution2));\n        assertFalse(excludedName.get(pollution3));\n        assertFalse(excludedName.get(pollution4));\n        assertFalse(excludedName.get(pollution5));\n        assertFalse(excludedName.get(pollution6));\n\n        assertFalse(excludedValue.get(pollution1));\n        assertFalse(excludedValue.get(pollution2));\n        assertFalse(excludedValue.get(pollution3));\n        assertFalse(excludedValue.get(pollution4));\n        assertFalse(excludedValue.get(pollution5));\n        assertFalse(excludedValue.get(pollution6));\n    }", "code_tokens": ["public", "void", "testCookiesWithClassPollution", "(", ")", "throws", "Exception", "{", "MockHttpServletRequest", "request", "=", "new", "MockHttpServletRequest", "(", ")", ";", "String", "pollution1", "=", "\"", "model['class']['classLoader']['jarPath']", "\"", ";", "String", "pollution2", "=", "\"", "model.class.classLoader.jarPath", "\"", ";", "String", "pollution3", "=", "\"", "class.classLoader.jarPath", "\"", ";", "String", "pollution4", "=", "\"", "class['classLoader']['jarPath']", "\"", ";", "String", "pollution5", "=", "\"", "model[", "\\\"", "class", "\\\"", "]['classLoader']['jarPath']", "\"", ";", "String", "pollution6", "=", "\"", "class[", "\\\"", "classLoader", "\\\"", "]['jarPath']", "\"", ";", "request", ".", "setCookies", "(", "new", "Cookie", "(", "pollution1", ",", "\"", "pollution1", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution1", "\"", ",", "pollution1", ")", ",", "new", "Cookie", "(", "pollution2", ",", "\"", "pollution2", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution2", "\"", ",", "pollution2", ")", ",", "new", "Cookie", "(", "pollution3", ",", "\"", "pollution3", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution3", "\"", ",", "pollution3", ")", ",", "new", "Cookie", "(", "pollution4", ",", "\"", "pollution4", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution4", "\"", ",", "pollution4", ")", ",", "new", "Cookie", "(", "pollution5", ",", "\"", "pollution5", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution5", "\"", ",", "pollution5", ")", ",", "new", "Cookie", "(", "pollution6", ",", "\"", "pollution6", "\"", ")", ",", "new", "Cookie", "(", "\"", "pollution6", "\"", ",", "pollution6", ")", ")", ";", "ServletActionContext", ".", "setRequest", "(", "request", ")", ";", "final", "Map", "<", "String", ",", "Boolean", ">", "excludedName", "=", "new", "HashMap", "<", "String", ",", "Boolean", ">", "(", ")", ";", "final", "Map", "<", "String", ",", "Boolean", ">", "excludedValue", "=", "new", "HashMap", "<", "String", ",", "Boolean", ">", "(", ")", ";", "CookieInterceptor", "interceptor", "=", "new", "CookieInterceptor", "(", ")", "{", "@", "Override", "protected", "boolean", "isAcceptableName", "(", "String", "name", ")", "{", "boolean", "accepted", "=", "super", ".", "isAcceptableName", "(", "name", ")", ";", "excludedName", ".", "put", "(", "name", ",", "accepted", ")", ";", "return", "accepted", ";", "}", "@", "Override", "protected", "boolean", "isAcceptableValue", "(", "String", "value", ")", "{", "boolean", "accepted", "=", "super", ".", "isAcceptableValue", "(", "value", ")", ";", "excludedValue", ".", "put", "(", "value", ",", "accepted", ")", ";", "return", "accepted", ";", "}", "}", ";", "DefaultExcludedPatternsChecker", "excludedPatternsChecker", "=", "new", "DefaultExcludedPatternsChecker", "(", ")", ";", "excludedPatternsChecker", ".", "setAdditionalExcludePatterns", "(", "\"", ".*(^|", "\\\\", ".|", "\\\\", "[|'|", "\\\"", ")class(", "\\\\", ".|", "\\\\", "[|'|", "\\\"", ").*", "\"", ")", ";", "interceptor", ".", "setExcludedPatternsChecker", "(", "excludedPatternsChecker", ")", ";", "interceptor", ".", "setCookiesName", "(", "\"", "*", "\"", ")", ";", "MockActionInvocation", "invocation", "=", "new", "MockActionInvocation", "(", ")", ";", "invocation", ".", "setAction", "(", "new", "MockActionWithCookieAware", "(", ")", ")", ";", "interceptor", ".", "intercept", "(", "invocation", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution1", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution2", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution3", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution4", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution5", ")", ")", ";", "assertFalse", "(", "excludedName", ".", "get", "(", "pollution6", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution1", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution2", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution3", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution4", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution5", ")", ")", ";", "assertFalse", "(", "excludedValue", ".", "get", "(", "pollution6", ")", ")", ";", "}"], "idx": 99434, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "d832747d647df343ed07a58b1b5e540a05a4d51b", "function_name": "testCookiesWithClassPollution", "body_hash": "99b6f86e3797084ab49da0c4e2ebd1e9b52ca34a"}
{"code": "@Override\n\tprotected void convertInput()\n\t{\n\t\tthis.setConvertedInput(this.textarea.getConvertedInput());\n\t}", "code_tokens": ["@", "Override", "protected", "void", "convertInput", "(", ")", "{", "this", ".", "setConvertedInput", "(", "this", ".", "textarea", ".", "getConvertedInput", "(", ")", ")", ";", "}"], "idx": 81644, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "3e8cfdcb0f8e6e0cf0da01e74501afb5c9bff0f", "function_name": "convertInput", "body_hash": "59caec57a28e10dcbb9993287108e82f642e03a3"}
{"code": "@BeforeClass\n    public static void createServers() throws Exception {\n        bus = BusFactory.getDefaultBus();\n        JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new SoapActionGreeterImpl());\n        sf.setAddress(add11);\n        sf.setBus(bus);\n        sf.create();\n        \n        sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new SoapActionGreeterImpl());\n        sf.setAddress(add12);\n        sf.setBus(bus);\n        SoapBindingConfiguration config = new SoapBindingConfiguration();\n        config.setVersion(Soap12.getInstance());\n        sf.setBindingConfig(config);\n        sf.create();\n        \n        sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new WrappedSoapActionGreeterImpl());\n        sf.setAddress(add13);\n        sf.setBus(bus);\n        sf.create();\n        \n        sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new WrappedSoapActionGreeterImpl());\n        sf.setAddress(add14);\n        sf.setBus(bus);\n        config.setVersion(Soap12.getInstance());\n        sf.setBindingConfig(config);\n        sf.create();\n        \n        sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new RPCLitSoapActionGreeterImpl());\n        sf.setAddress(add15);\n        sf.setBus(bus);\n        sf.create();\n        \n        sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new RPCEncodedSoapActionGreeterImpl());\n        sf.setAddress(add16);\n        sf.setBus(bus);\n        sf.create();\n        \n        sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new WrappedEncodedSoapActionGreeterImpl());\n        sf.setAddress(add17);\n        sf.setBus(bus);\n        sf.create();\n    }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "createServers", "(", ")", "throws", "Exception", "{", "bus", "=", "BusFactory", ".", "getDefaultBus", "(", ")", ";", "JaxWsServerFactoryBean", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "SoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add11", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "sf", ".", "create", "(", ")", ";", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "SoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add12", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "SoapBindingConfiguration", "config", "=", "new", "SoapBindingConfiguration", "(", ")", ";", "config", ".", "setVersion", "(", "Soap12", ".", "getInstance", "(", ")", ")", ";", "sf", ".", "setBindingConfig", "(", "config", ")", ";", "sf", ".", "create", "(", ")", ";", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "WrappedSoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add13", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "sf", ".", "create", "(", ")", ";", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "WrappedSoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add14", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "config", ".", "setVersion", "(", "Soap12", ".", "getInstance", "(", ")", ")", ";", "sf", ".", "setBindingConfig", "(", "config", ")", ";", "sf", ".", "create", "(", ")", ";", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "RPCLitSoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add15", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "sf", ".", "create", "(", ")", ";", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "RPCEncodedSoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add16", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "sf", ".", "create", "(", ")", ";", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "WrappedEncodedSoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add17", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "sf", ".", "create", "(", ")", ";", "}"], "idx": 11875, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "9c70abe28fbf2b4c4df0b93ed12295ea5a012554", "function_name": "createServers", "body_hash": "07a8db66396d4c4cd0ad4d9a83f4a3e106ddc8c6"}
{"code": "@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tString newLocale = request.getParameter(this.paramName);\n\t\tif (newLocale != null) {\n\t\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);\n\t\t\tif (localeResolver == null) {\n\t\t\t\tthrow new IllegalStateException(\"No LocaleResolver found: not in a DispatcherServlet request?\");\n\t\t\t}\n\t\t\tlocaleResolver.setLocale(request, response, StringUtils.parseLocaleString(newLocale));\n\t\t}\n\t\t// Proceed in any case.\n\t\treturn true;\n\t}", "code_tokens": ["@", "Override", "public", "boolean", "preHandle", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Object", "handler", ")", "throws", "ServletException", "{", "String", "newLocale", "=", "request", ".", "getParameter", "(", "this", ".", "paramName", ")", ";", "if", "(", "newLocale", "!=", "null", ")", "{", "LocaleResolver", "localeResolver", "=", "RequestContextUtils", ".", "getLocaleResolver", "(", "request", ")", ";", "if", "(", "localeResolver", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "No LocaleResolver found: not in a DispatcherServlet request?", "\"", ")", ";", "}", "localeResolver", ".", "setLocale", "(", "request", ",", "response", ",", "StringUtils", ".", "parseLocaleString", "(", "newLocale", ")", ")", ";", "}", "return", "true", ";", "}"], "idx": 10554, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "f4a2282d9d9f6e58029022c58311a1db07f7defc", "function_name": "preHandle", "body_hash": "95944dda528bd205694e3b7b5eb5b43d209540fe"}
{"code": "@BeforeClass\n    public static void createServers() throws Exception {\n        bus = BusFactory.getDefaultBus();\n        JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new SoapActionGreeterImpl());\n        sf.setAddress(add11);\n        sf.setBus(bus);\n        sf.create();\n        \n        sf = new JaxWsServerFactoryBean();\n        sf.setServiceBean(new SoapActionGreeterImpl());\n        sf.setAddress(add12);\n        sf.setBus(bus);\n        SoapBindingConfiguration config = new SoapBindingConfiguration();\n        config.setVersion(Soap12.getInstance());\n        sf.setBindingConfig(config);\n        sf.create();\n    }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "createServers", "(", ")", "throws", "Exception", "{", "bus", "=", "BusFactory", ".", "getDefaultBus", "(", ")", ";", "JaxWsServerFactoryBean", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "SoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add11", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "sf", ".", "create", "(", ")", ";", "sf", "=", "new", "JaxWsServerFactoryBean", "(", ")", ";", "sf", ".", "setServiceBean", "(", "new", "SoapActionGreeterImpl", "(", ")", ")", ";", "sf", ".", "setAddress", "(", "add12", ")", ";", "sf", ".", "setBus", "(", "bus", ")", ";", "SoapBindingConfiguration", "config", "=", "new", "SoapBindingConfiguration", "(", ")", ";", "config", ".", "setVersion", "(", "Soap12", ".", "getInstance", "(", ")", ")", ";", "sf", ".", "setBindingConfig", "(", "config", ")", ";", "sf", ".", "create", "(", ")", ";", "}"], "idx": 11874, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "9c70abe28fbf2b4c4df0b93ed12295ea5a012554", "function_name": "createServers", "body_hash": "7399b53b6c247b632dd28e86e51f890945cad616"}
{"code": "@Override\n    public void onTrigger(final ProcessContext context, final ProcessSession session) {\n        final FlowFile original = session.get();\n        if (original == null) {\n            return;\n        }\n\n        final int depth = context.getProperty(SPLIT_DEPTH).asInteger();\n        final ComponentLog logger = getLogger();\n\n        final List<FlowFile> splits = new ArrayList<>();\n        final String fragmentIdentifier = UUID.randomUUID().toString();\n        final AtomicInteger numberOfRecords = new AtomicInteger(0);\n        final XmlSplitterSaxParser parser = new XmlSplitterSaxParser(xmlTree -> {\n            FlowFile split = session.create(original);\n            split = session.write(split, out -> out.write(xmlTree.getBytes(\"UTF-8\")));\n            split = session.putAttribute(split, FRAGMENT_ID.key(), fragmentIdentifier);\n            split = session.putAttribute(split, FRAGMENT_INDEX.key(), Integer.toString(numberOfRecords.getAndIncrement()));\n            split = session.putAttribute(split, SEGMENT_ORIGINAL_FILENAME.key(), split.getAttribute(CoreAttributes.FILENAME.key()));\n            splits.add(split);\n        }, depth);\n\n        final AtomicBoolean failed = new AtomicBoolean(false);\n        session.read(original, rawIn -> {\n            try (final InputStream in = new java.io.BufferedInputStream(rawIn)) {\n                try {\n                    final XMLReader reader = XmlUtils.createSafeSaxReader(saxParserFactory, parser);\n                    reader.parse(new InputSource(in));\n                } catch (final ParserConfigurationException | SAXException e) {\n                    logger.error(\"Unable to parse {} due to {}\", new Object[]{original, e});\n                    failed.set(true);\n                }\n            }\n        });\n\n        if (failed.get()) {\n            session.transfer(original, REL_FAILURE);\n            session.remove(splits);\n        } else {\n            splits.forEach((split) -> {\n                split = session.putAttribute(split, FRAGMENT_COUNT.key(), Integer.toString(numberOfRecords.get()));\n                session.transfer(split, REL_SPLIT);\n            });\n\n            final FlowFile originalToTransfer = copyAttributesToOriginal(session, original, fragmentIdentifier, numberOfRecords.get());\n            session.transfer(originalToTransfer, REL_ORIGINAL);\n            logger.info(\"Split {} into {} FlowFiles\", new Object[]{originalToTransfer, splits.size()});\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "onTrigger", "(", "final", "ProcessContext", "context", ",", "final", "ProcessSession", "session", ")", "{", "final", "FlowFile", "original", "=", "session", ".", "get", "(", ")", ";", "if", "(", "original", "==", "null", ")", "{", "return", ";", "}", "final", "int", "depth", "=", "context", ".", "getProperty", "(", "SPLIT_DEPTH", ")", ".", "asInteger", "(", ")", ";", "final", "ComponentLog", "logger", "=", "getLogger", "(", ")", ";", "final", "List", "<", "FlowFile", ">", "splits", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "final", "String", "fragmentIdentifier", "=", "UUID", ".", "randomUUID", "(", ")", ".", "toString", "(", ")", ";", "final", "AtomicInteger", "numberOfRecords", "=", "new", "AtomicInteger", "(", "0", ")", ";", "final", "XmlSplitterSaxParser", "parser", "=", "new", "XmlSplitterSaxParser", "(", "xmlTree", "->", "{", "FlowFile", "split", "=", "session", ".", "create", "(", "original", ")", ";", "split", "=", "session", ".", "write", "(", "split", ",", "out", "->", "out", ".", "write", "(", "xmlTree", ".", "getBytes", "(", "\"", "UTF-8", "\"", ")", ")", ")", ";", "split", "=", "session", ".", "putAttribute", "(", "split", ",", "FRAGMENT_ID", ".", "key", "(", ")", ",", "fragmentIdentifier", ")", ";", "split", "=", "session", ".", "putAttribute", "(", "split", ",", "FRAGMENT_INDEX", ".", "key", "(", ")", ",", "Integer", ".", "toString", "(", "numberOfRecords", ".", "getAndIncrement", "(", ")", ")", ")", ";", "split", "=", "session", ".", "putAttribute", "(", "split", ",", "SEGMENT_ORIGINAL_FILENAME", ".", "key", "(", ")", ",", "split", ".", "getAttribute", "(", "CoreAttributes", ".", "FILENAME", ".", "key", "(", ")", ")", ")", ";", "splits", ".", "add", "(", "split", ")", ";", "}", ",", "depth", ")", ";", "final", "AtomicBoolean", "failed", "=", "new", "AtomicBoolean", "(", "false", ")", ";", "session", ".", "read", "(", "original", ",", "rawIn", "->", "{", "try", "(", "final", "InputStream", "in", "=", "new", "java", ".", "io", ".", "BufferedInputStream", "(", "rawIn", ")", ")", "{", "try", "{", "final", "XMLReader", "reader", "=", "XmlUtils", ".", "createSafeSaxReader", "(", "saxParserFactory", ",", "parser", ")", ";", "reader", ".", "parse", "(", "new", "InputSource", "(", "in", ")", ")", ";", "}", "catch", "(", "final", "ParserConfigurationException", "|", "SAXException", "e", ")", "{", "logger", ".", "error", "(", "\"", "Unable to parse {} due to {}", "\"", ",", "new", "Object", "[", "]", "{", "original", ",", "e", "}", ")", ";", "failed", ".", "set", "(", "true", ")", ";", "}", "}", "}", ")", ";", "if", "(", "failed", ".", "get", "(", ")", ")", "{", "session", ".", "transfer", "(", "original", ",", "REL_FAILURE", ")", ";", "session", ".", "remove", "(", "splits", ")", ";", "}", "else", "{", "splits", ".", "forEach", "(", "(", "split", ")", "->", "{", "split", "=", "session", ".", "putAttribute", "(", "split", ",", "FRAGMENT_COUNT", ".", "key", "(", ")", ",", "Integer", ".", "toString", "(", "numberOfRecords", ".", "get", "(", ")", ")", ")", ";", "session", ".", "transfer", "(", "split", ",", "REL_SPLIT", ")", ";", "}", ")", ";", "final", "FlowFile", "originalToTransfer", "=", "copyAttributesToOriginal", "(", "session", ",", "original", ",", "fragmentIdentifier", ",", "numberOfRecords", ".", "get", "(", ")", ")", ";", "session", ".", "transfer", "(", "originalToTransfer", ",", "REL_ORIGINAL", ")", ";", "logger", ".", "info", "(", "\"", "Split {} into {} FlowFiles", "\"", ",", "new", "Object", "[", "]", "{", "originalToTransfer", ",", "splits", ".", "size", "(", ")", "}", ")", ";", "}", "}"], "idx": 68000, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "28067a29fd13cdf8e21b440fc65c6dd67872522f", "function_name": "onTrigger", "body_hash": "2069cb4ffbbf4fec9b15c1893e1753559fb5dd94"}
{"code": "protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {\n\n        if (!WebUtils.isHttp(subjectContext)) {\n            if (log.isDebugEnabled()) {\n                String msg = \"SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a \" +\n                        \"servlet request and response in order to retrieve the rememberMe cookie. Returning \" +\n                        \"immediately and ignoring rememberMe operation.\";\n                log.debug(msg);\n            }\n            return null;\n        }\n\n        WebSubjectContext wsc = (WebSubjectContext) subjectContext;\n        if (isIdentityRemoved(wsc)) {\n            return null;\n        }\n\n        HttpServletRequest request = WebUtils.getHttpRequest(wsc);\n        HttpServletResponse response = WebUtils.getHttpResponse(wsc);\n\n        String base64 = getCookie().readValue(request, response);\n        // Browsers do not always remove cookies immediately (SHIRO-183)\n        // ignore cookies that are scheduled for removal\n        if (Cookie.DELETED_COOKIE_VALUE.equals(base64)) return null;\n\n        if (base64 != null) {\n            base64 = ensurePadding(base64);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Acquired Base64 encoded identity [\" + base64 + \"]\");\n            }\n            byte[] decoded;\n            try {\n                decoded = Base64.decode(base64);\n            } catch (RuntimeException rtEx) {\n                /*\n                 * https://issues.apache.org/jira/browse/SHIRO-766:\n                 * If the base64 string cannot be decoded, just assume there is no valid cookie value.\n                 * */\n                getCookie().removeFrom(request, response);\n                log.warn(\"Unable to decode existing base64 encoded entity: [\" + base64 + \"].\", rtEx);\n                return null;\n            }\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"Base64 decoded byte array length: \" + decoded.length + \" bytes.\");\n            }\n            return decoded;\n        } else {\n            //no cookie set - new site visitor?\n            return null;\n        }\n    }", "code_tokens": ["protected", "byte", "[", "]", "getRememberedSerializedIdentity", "(", "SubjectContext", "subjectContext", ")", "{", "if", "(", "!", "WebUtils", ".", "isHttp", "(", "subjectContext", ")", ")", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "String", "msg", "=", "\"", "SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a ", "\"", "+", "\"", "servlet request and response in order to retrieve the rememberMe cookie. Returning ", "\"", "+", "\"", "immediately and ignoring rememberMe operation.", "\"", ";", "log", ".", "debug", "(", "msg", ")", ";", "}", "return", "null", ";", "}", "WebSubjectContext", "wsc", "=", "(", "WebSubjectContext", ")", "subjectContext", ";", "if", "(", "isIdentityRemoved", "(", "wsc", ")", ")", "{", "return", "null", ";", "}", "HttpServletRequest", "request", "=", "WebUtils", ".", "getHttpRequest", "(", "wsc", ")", ";", "HttpServletResponse", "response", "=", "WebUtils", ".", "getHttpResponse", "(", "wsc", ")", ";", "String", "base64", "=", "getCookie", "(", ")", ".", "readValue", "(", "request", ",", "response", ")", ";", "if", "(", "Cookie", ".", "DELETED_COOKIE_VALUE", ".", "equals", "(", "base64", ")", ")", "return", "null", ";", "if", "(", "base64", "!=", "null", ")", "{", "base64", "=", "ensurePadding", "(", "base64", ")", ";", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Acquired Base64 encoded identity [", "\"", "+", "base64", "+", "\"", "]", "\"", ")", ";", "}", "byte", "[", "]", "decoded", ";", "try", "{", "decoded", "=", "Base64", ".", "decode", "(", "base64", ")", ";", "}", "catch", "(", "RuntimeException", "rtEx", ")", "{", "getCookie", "(", ")", ".", "removeFrom", "(", "request", ",", "response", ")", ";", "log", ".", "warn", "(", "\"", "Unable to decode existing base64 encoded entity: [", "\"", "+", "base64", "+", "\"", "].", "\"", ",", "rtEx", ")", ";", "return", "null", ";", "}", "if", "(", "log", ".", "isTraceEnabled", "(", ")", ")", "{", "log", ".", "trace", "(", "\"", "Base64 decoded byte array length: ", "\"", "+", "decoded", ".", "length", "+", "\"", " bytes.", "\"", ")", ";", "}", "return", "decoded", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "idx": 109397, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "83d8dacd273c8f6d70e6b1aa4f240d4f7a408c27", "function_name": "getRememberedSerializedIdentity", "body_hash": "4ea088065bda8bfa56d007900d808f03a0c5617b"}
{"code": "private void checkCancelOperationUsingUrl(Function<Queue.Item, String> urlProvider, boolean legacyRedirect) throws Exception {\n        Queue q = r.jenkins.getQueue();\n\n        r.jenkins.setCrumbIssuer(null);\n        r.jenkins.setSecurityRealm(r.createDummySecurityRealm());\n        r.jenkins.setAuthorizationStrategy(new MockAuthorizationStrategy()\n                .grant(Jenkins.READ, Item.CANCEL).everywhere().to(\"admin\")\n                .grant(Jenkins.READ).everywhere().to(\"user\")\n        );\n\n        // prevent execution to push stuff into the queue\n        r.jenkins.setNumExecutors(0);\n        assertThat(q.getItems().length, equalTo(0));\n\n        FreeStyleProject testProject = r.createFreeStyleProject(\"test\");\n        testProject.scheduleBuild(new UserIdCause());\n\n        Queue.Item[] items = q.getItems();\n        assertThat(items.length, equalTo(1));\n        Queue.Item currentOne = items[0];\n        assertFalse(currentOne.getFuture().isCancelled());\n\n        WebRequest request = new WebRequest(new URL(r.getURL() + urlProvider.apply(currentOne)), HttpMethod.POST);\n\n        { // user without right cannot cancel\n            JenkinsRule.WebClient wc = r.createWebClient()\n                    .withRedirectEnabled(false)\n                    .withThrowExceptionOnFailingStatusCode(false);\n            wc.login(\"user\");\n            if(legacyRedirect) {\n                Page p = wc.getPage(request);\n                // the legacy endpoint returns a redirection to the previously visited page, none in our case\n                // (so force no redirect to avoid false positive error)\n                // see JENKINS-21311\n                assertThat(p.getWebResponse().getStatusCode(), lessThan(400));\n            }\n            assertFalse(currentOne.getFuture().isCancelled());\n        }\n        { // user with right can\n            JenkinsRule.WebClient wc = r.createWebClient()\n                    .withRedirectEnabled(false)\n                    .withThrowExceptionOnFailingStatusCode(false);\n            wc.login(\"admin\");\n            Page p = wc.getPage(request);\n            assertThat(p.getWebResponse().getStatusCode(), lessThan(400));\n\n            assertTrue(currentOne.getFuture().isCancelled());\n        }\n    }", "code_tokens": ["private", "void", "checkCancelOperationUsingUrl", "(", "Function", "<", "Queue", ".", "Item", ",", "String", ">", "urlProvider", ",", "boolean", "legacyRedirect", ")", "throws", "Exception", "{", "Queue", "q", "=", "r", ".", "jenkins", ".", "getQueue", "(", ")", ";", "r", ".", "jenkins", ".", "setCrumbIssuer", "(", "null", ")", ";", "r", ".", "jenkins", ".", "setSecurityRealm", "(", "r", ".", "createDummySecurityRealm", "(", ")", ")", ";", "r", ".", "jenkins", ".", "setAuthorizationStrategy", "(", "new", "MockAuthorizationStrategy", "(", ")", ".", "grant", "(", "Jenkins", ".", "READ", ",", "Item", ".", "CANCEL", ")", ".", "everywhere", "(", ")", ".", "to", "(", "\"", "admin", "\"", ")", ".", "grant", "(", "Jenkins", ".", "READ", ")", ".", "everywhere", "(", ")", ".", "to", "(", "\"", "user", "\"", ")", ")", ";", "r", ".", "jenkins", ".", "setNumExecutors", "(", "0", ")", ";", "assertThat", "(", "q", ".", "getItems", "(", ")", ".", "length", ",", "equalTo", "(", "0", ")", ")", ";", "FreeStyleProject", "testProject", "=", "r", ".", "createFreeStyleProject", "(", "\"", "test", "\"", ")", ";", "testProject", ".", "scheduleBuild", "(", "new", "UserIdCause", "(", ")", ")", ";", "Queue", ".", "Item", "[", "]", "items", "=", "q", ".", "getItems", "(", ")", ";", "assertThat", "(", "items", ".", "length", ",", "equalTo", "(", "1", ")", ")", ";", "Queue", ".", "Item", "currentOne", "=", "items", "[", "0", "]", ";", "assertFalse", "(", "currentOne", ".", "getFuture", "(", ")", ".", "isCancelled", "(", ")", ")", ";", "WebRequest", "request", "=", "new", "WebRequest", "(", "new", "URL", "(", "r", ".", "getURL", "(", ")", "+", "urlProvider", ".", "apply", "(", "currentOne", ")", ")", ",", "HttpMethod", ".", "POST", ")", ";", "{", "JenkinsRule", ".", "WebClient", "wc", "=", "r", ".", "createWebClient", "(", ")", ".", "withRedirectEnabled", "(", "false", ")", ".", "withThrowExceptionOnFailingStatusCode", "(", "false", ")", ";", "wc", ".", "login", "(", "\"", "user", "\"", ")", ";", "if", "(", "legacyRedirect", ")", "{", "Page", "p", "=", "wc", ".", "getPage", "(", "request", ")", ";", "assertThat", "(", "p", ".", "getWebResponse", "(", ")", ".", "getStatusCode", "(", ")", ",", "lessThan", "(", "400", ")", ")", ";", "}", "assertFalse", "(", "currentOne", ".", "getFuture", "(", ")", ".", "isCancelled", "(", ")", ")", ";", "}", "{", "JenkinsRule", ".", "WebClient", "wc", "=", "r", ".", "createWebClient", "(", ")", ".", "withRedirectEnabled", "(", "false", ")", ".", "withThrowExceptionOnFailingStatusCode", "(", "false", ")", ";", "wc", ".", "login", "(", "\"", "admin", "\"", ")", ";", "Page", "p", "=", "wc", ".", "getPage", "(", "request", ")", ";", "assertThat", "(", "p", ".", "getWebResponse", "(", ")", ".", "getStatusCode", "(", ")", ",", "lessThan", "(", "400", ")", ")", ";", "assertTrue", "(", "currentOne", ".", "getFuture", "(", ")", ".", "isCancelled", "(", ")", ")", ";", "}", "}"], "idx": 50606, "cwe": "CWE-384", "target": 1, "status": "VULNERABLE", "commit": "86b7d7e789586575522650c60d591605facb1d70", "function_name": "checkCancelOperationUsingUrl", "body_hash": "1cbdf4a2491d52beba19283e5625eecf416f1555"}
{"code": "protected void parseNameAndNamespace(String uri, ActionMapping mapping, ConfigurationManager configManager) {\n        String namespace, name;\n        int lastSlash = uri.lastIndexOf(\"/\");\n        if (lastSlash == -1) {\n            namespace = \"\";\n            name = uri;\n        } else if (lastSlash == 0) {\n            // ww-1046, assume it is the root namespace, it will fallback to\n            // default\n            // namespace anyway if not found in root namespace.\n            namespace = \"/\";\n            name = uri.substring(lastSlash + 1);\n        } else if (alwaysSelectFullNamespace) {\n            // Simply select the namespace as everything before the last slash\n            namespace = uri.substring(0, lastSlash);\n            name = uri.substring(lastSlash + 1);\n        } else {\n            // Try to find the namespace in those defined, defaulting to \"\"\n            Configuration config = configManager.getConfiguration();\n            String prefix = uri.substring(0, lastSlash);\n            namespace = \"\";\n            boolean rootAvailable = false;\n            // Find the longest matching namespace, defaulting to the default\n            for (Object cfg : config.getPackageConfigs().values()) {\n                String ns = ((PackageConfig) cfg).getNamespace();\n                if (ns != null && prefix.startsWith(ns) && (prefix.length() == ns.length() || prefix.charAt(ns.length()) == '/')) {\n                    if (ns.length() > namespace.length()) {\n                        namespace = ns;\n                    }\n                }\n                if (\"/\".equals(ns)) {\n                    rootAvailable = true;\n                }\n            }\n\n            name = uri.substring(namespace.length() + 1);\n\n            // Still none found, use root namespace if found\n            if (rootAvailable && \"\".equals(namespace)) {\n                namespace = \"/\";\n            }\n        }\n\n        if (!allowSlashesInActionNames) {\n            int pos = name.lastIndexOf('/');\n            if (pos > -1 && pos < name.length() - 1) {\n                name = name.substring(pos + 1);\n            }\n        }\n\n        mapping.setNamespace(namespace);\n        mapping.setName(name);\n    }", "code_tokens": ["protected", "void", "parseNameAndNamespace", "(", "String", "uri", ",", "ActionMapping", "mapping", ",", "ConfigurationManager", "configManager", ")", "{", "String", "namespace", ",", "name", ";", "int", "lastSlash", "=", "uri", ".", "lastIndexOf", "(", "\"", "/", "\"", ")", ";", "if", "(", "lastSlash", "==", "-", "1", ")", "{", "namespace", "=", "\"", "\"", ";", "name", "=", "uri", ";", "}", "else", "if", "(", "lastSlash", "==", "0", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "if", "(", "alwaysSelectFullNamespace", ")", "{", "namespace", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "{", "Configuration", "config", "=", "configManager", ".", "getConfiguration", "(", ")", ";", "String", "prefix", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "namespace", "=", "\"", "\"", ";", "boolean", "rootAvailable", "=", "false", ";", "for", "(", "Object", "cfg", ":", "config", ".", "getPackageConfigs", "(", ")", ".", "values", "(", ")", ")", "{", "String", "ns", "=", "(", "(", "PackageConfig", ")", "cfg", ")", ".", "getNamespace", "(", ")", ";", "if", "(", "ns", "!=", "null", "&&", "prefix", ".", "startsWith", "(", "ns", ")", "&&", "(", "prefix", ".", "length", "(", ")", "==", "ns", ".", "length", "(", ")", "||", "prefix", ".", "charAt", "(", "ns", ".", "length", "(", ")", ")", "==", "'/'", ")", ")", "{", "if", "(", "ns", ".", "length", "(", ")", ">", "namespace", ".", "length", "(", ")", ")", "{", "namespace", "=", "ns", ";", "}", "}", "if", "(", "\"", "/", "\"", ".", "equals", "(", "ns", ")", ")", "{", "rootAvailable", "=", "true", ";", "}", "}", "name", "=", "uri", ".", "substring", "(", "namespace", ".", "length", "(", ")", "+", "1", ")", ";", "if", "(", "rootAvailable", "&&", "\"", "\"", ".", "equals", "(", "namespace", ")", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "}", "}", "if", "(", "!", "allowSlashesInActionNames", ")", "{", "int", "pos", "=", "name", ".", "lastIndexOf", "(", "'/'", ")", ";", "if", "(", "pos", ">", "-", "1", "&&", "pos", "<", "name", ".", "length", "(", ")", "-", "1", ")", "{", "name", "=", "name", ".", "substring", "(", "pos", "+", "1", ")", ";", "}", "}", "mapping", ".", "setNamespace", "(", "namespace", ")", ";", "mapping", ".", "setName", "(", "name", ")", ";", "}"], "idx": 94888, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "01e6b251b4db78bfb7971033652e81d1af4cb3e", "function_name": "parseNameAndNamespace", "body_hash": "c39a6ec152937b1357b7f973b8d2a6036d52091c"}
{"code": "private void prepareRequest() {\n\n        // Translate the HTTP method code to a String.\n        byte methodCode = requestHeaderMessage.getByte();\n        if (methodCode != Constants.SC_M_JK_STORED) {\n            String methodName = Constants.getMethodForCode(methodCode - 1);\n            request.method().setString(methodName);\n        }\n\n        requestHeaderMessage.getBytes(request.protocol());\n        requestHeaderMessage.getBytes(request.requestURI());\n\n        requestHeaderMessage.getBytes(request.remoteAddr());\n        requestHeaderMessage.getBytes(request.remoteHost());\n        requestHeaderMessage.getBytes(request.localName());\n        request.setLocalPort(requestHeaderMessage.getInt());\n\n        boolean isSSL = requestHeaderMessage.getByte() != 0;\n        if (isSSL) {\n            request.scheme().setString(\"https\");\n        }\n\n        // Decode headers\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Set this every time in case limit has been changed via JMX\n        headers.setLimit(protocol.getMaxHeaderCount());\n\n        boolean contentLengthSet = false;\n        int hCount = requestHeaderMessage.getInt();\n        for(int i = 0 ; i < hCount ; i++) {\n            String hName = null;\n\n            // Header names are encoded as either an integer code starting\n            // with 0xA0, or as a normal string (in which case the first\n            // two bytes are the length).\n            int isc = requestHeaderMessage.peekInt();\n            int hId = isc & 0xFF;\n\n            MessageBytes vMB = null;\n            isc &= 0xFF00;\n            if(0xA000 == isc) {\n                requestHeaderMessage.getInt(); // To advance the read position\n                hName = Constants.getHeaderForCode(hId - 1);\n                vMB = headers.addValue(hName);\n            } else {\n                // reset hId -- if the header currently being read\n                // happens to be 7 or 8 bytes long, the code below\n                // will think it's the content-type header or the\n                // content-length header - SC_REQ_CONTENT_TYPE=7,\n                // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected\n                // behaviour.  see bug 5861 for more information.\n                hId = -1;\n                requestHeaderMessage.getBytes(tmpMB);\n                ByteChunk bc = tmpMB.getByteChunk();\n                vMB = headers.addValue(bc.getBuffer(),\n                        bc.getStart(), bc.getLength());\n            }\n\n            requestHeaderMessage.getBytes(vMB);\n\n            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Length\"))) {\n                long cl = vMB.getLong();\n                if (contentLengthSet) {\n                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                } else {\n                    contentLengthSet = true;\n                    // Set the content-length header for the request\n                    request.setContentLength(cl);\n                }\n            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Type\"))) {\n                // just read the content-type header, so set it\n                ByteChunk bchunk = vMB.getByteChunk();\n                request.contentType().setBytes(bchunk.getBytes(),\n                        bchunk.getOffset(),\n                        bchunk.getLength());\n            }\n        }\n\n        // Decode extra attributes\n        String secret = protocol.getSecret();\n        boolean secretPresentInRequest = false;\n        byte attributeCode;\n        while ((attributeCode = requestHeaderMessage.getByte())\n                != Constants.SC_A_ARE_DONE) {\n\n            switch (attributeCode) {\n\n            case Constants.SC_A_REQ_ATTRIBUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                String n = tmpMB.toString();\n                requestHeaderMessage.getBytes(tmpMB);\n                String v = tmpMB.toString();\n                /*\n                 * AJP13 misses to forward the local IP address and the\n                 * remote port. Allow the AJP connector to add this info via\n                 * private request attributes.\n                 * We will accept the forwarded data and remove it from the\n                 * public list of request attributes.\n                 */\n                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {\n                    request.localAddr().setString(v);\n                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {\n                    try {\n                        request.setRemotePort(Integer.parseInt(v));\n                    } catch (NumberFormatException nfe) {\n                        // Ignore invalid value\n                    }\n                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {\n                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);\n                } else if (n.equals(\"JK_LB_ACTIVATION\")) {\n                    request.setAttribute(n, v);\n                } else if (javaxAttributes.contains(n)) {\n                    request.setAttribute(n, v);\n                } else {\n                    // All 'known' attributes will be processed by the previous\n                    // blocks. Any remaining attribute is an 'arbitrary' one.\n                    Pattern pattern = protocol.getAllowedArbitraryRequestAttributesPattern();\n                    if (pattern == null) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    } else {\n                        Matcher m = pattern.matcher(n);\n                        if (m.matches()) {\n                            request.setAttribute(n, v);\n                        } else {\n                            response.setStatus(403);\n                            setErrorState(ErrorState.CLOSE_CLEAN, null);\n                        }\n                    }\n                }\n                break;\n\n            case Constants.SC_A_CONTEXT :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SERVLET_PATH :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_REMOTE_USER :\n                boolean tomcatAuthorization  = protocol.getTomcatAuthorization();\n                if (tomcatAuthorization || !protocol.getTomcatAuthentication()) {\n                    // Implies tomcatAuthentication == false\n                    requestHeaderMessage.getBytes(request.getRemoteUser());\n                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);\n                } else {\n                    // Ignore user information from reverse proxy\n                    requestHeaderMessage.getBytes(tmpMB);\n                }\n                break;\n\n            case Constants.SC_A_AUTH_TYPE :\n                if (protocol.getTomcatAuthentication()) {\n                    // ignore server\n                    requestHeaderMessage.getBytes(tmpMB);\n                } else {\n                    requestHeaderMessage.getBytes(request.getAuthType());\n                }\n                break;\n\n            case Constants.SC_A_QUERY_STRING :\n                requestHeaderMessage.getBytes(request.queryString());\n                break;\n\n            case Constants.SC_A_JVM_ROUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SSL_CERT :\n                // SSL certificate extraction is lazy, moved to JkCoyoteHandler\n                requestHeaderMessage.getBytes(certificates);\n                break;\n\n            case Constants.SC_A_SSL_CIPHER :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_SESSION :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.SESSION_ID_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_KEY_SIZE :\n                request.setAttribute(SSLSupport.KEY_SIZE_KEY,\n                        Integer.valueOf(requestHeaderMessage.getInt()));\n                break;\n\n            case Constants.SC_A_STORED_METHOD:\n                requestHeaderMessage.getBytes(request.method());\n                break;\n\n            case Constants.SC_A_SECRET:\n                requestHeaderMessage.getBytes(tmpMB);\n                if (secret != null) {\n                    secretPresentInRequest = true;\n                    if (!tmpMB.equals(secret)) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    }\n                }\n                break;\n\n            default:\n                // Ignore unknown attribute for backward compatibility\n                break;\n\n            }\n\n        }\n\n        // Check if secret was submitted if required\n        if ((secret != null) && !secretPresentInRequest) {\n            response.setStatus(403);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n        }\n\n        // Check for a full URI (including protocol://host:port/)\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\"\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + slashPos,\n                            uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                        slashPos - pos - 3);\n            }\n\n        }\n\n        MessageBytes valueMB = request.getMimeHeaders().getValue(\"host\");\n        parseHost(valueMB);\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "{", "byte", "methodCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ";", "if", "(", "methodCode", "!=", "Constants", ".", "SC_M_JK_STORED", ")", "{", "String", "methodName", "=", "Constants", ".", "getMethodForCode", "(", "methodCode", "-", "1", ")", ";", "request", ".", "method", "(", ")", ".", "setString", "(", "methodName", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "protocol", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "requestURI", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteAddr", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteHost", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "localName", "(", ")", ")", ";", "request", ".", "setLocalPort", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ";", "boolean", "isSSL", "=", "requestHeaderMessage", ".", "getByte", "(", ")", "!=", "0", ";", "if", "(", "isSSL", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "headers", ".", "setLimit", "(", "protocol", ".", "getMaxHeaderCount", "(", ")", ")", ";", "boolean", "contentLengthSet", "=", "false", ";", "int", "hCount", "=", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hCount", ";", "i", "++", ")", "{", "String", "hName", "=", "null", ";", "int", "isc", "=", "requestHeaderMessage", ".", "peekInt", "(", ")", ";", "int", "hId", "=", "isc", "&", "0xFF", ";", "MessageBytes", "vMB", "=", "null", ";", "isc", "&=", "0xFF00", ";", "if", "(", "0xA000", "==", "isc", ")", "{", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "hName", "=", "Constants", ".", "getHeaderForCode", "(", "hId", "-", "1", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "hName", ")", ";", "}", "else", "{", "hId", "=", "-", "1", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "ByteChunk", "bc", "=", "tmpMB", ".", "getByteChunk", "(", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "bc", ".", "getBuffer", "(", ")", ",", "bc", ".", "getStart", "(", ")", ",", "bc", ".", "getLength", "(", ")", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "vMB", ")", ";", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_LENGTH", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Length", "\"", ")", ")", ")", "{", "long", "cl", "=", "vMB", ".", "getLong", "(", ")", ";", "if", "(", "contentLengthSet", ")", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "else", "{", "contentLengthSet", "=", "true", ";", "request", ".", "setContentLength", "(", "cl", ")", ";", "}", "}", "else", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_TYPE", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Type", "\"", ")", ")", ")", "{", "ByteChunk", "bchunk", "=", "vMB", ".", "getByteChunk", "(", ")", ";", "request", ".", "contentType", "(", ")", ".", "setBytes", "(", "bchunk", ".", "getBytes", "(", ")", ",", "bchunk", ".", "getOffset", "(", ")", ",", "bchunk", ".", "getLength", "(", ")", ")", ";", "}", "}", "String", "secret", "=", "protocol", ".", "getSecret", "(", ")", ";", "boolean", "secretPresentInRequest", "=", "false", ";", "byte", "attributeCode", ";", "while", "(", "(", "attributeCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ")", "!=", "Constants", ".", "SC_A_ARE_DONE", ")", "{", "switch", "(", "attributeCode", ")", "{", "case", "Constants", ".", "SC_A_REQ_ATTRIBUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "n", "=", "tmpMB", ".", "toString", "(", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "v", "=", "tmpMB", ".", "toString", "(", ")", ";", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_LOCAL_ADDR", ")", ")", "{", "request", ".", "localAddr", "(", ")", ".", "setString", "(", "v", ")", ";", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_REMOTE_PORT", ")", ")", "{", "try", "{", "request", ".", "setRemotePort", "(", "Integer", ".", "parseInt", "(", "v", ")", ")", ";", "}", "catch", "(", "NumberFormatException", "nfe", ")", "{", "}", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_SSL_PROTOCOL", ")", ")", "{", "request", ".", "setAttribute", "(", "SSLSupport", ".", "PROTOCOL_VERSION_KEY", ",", "v", ")", ";", "}", "else", "if", "(", "n", ".", "equals", "(", "\"", "JK_LB_ACTIVATION", "\"", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "if", "(", "javaxAttributes", ".", "contains", "(", "n", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "{", "Pattern", "pattern", "=", "protocol", ".", "getAllowedArbitraryRequestAttributesPattern", "(", ")", ";", "if", "(", "pattern", "==", "null", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "else", "{", "Matcher", "m", "=", "pattern", ".", "matcher", "(", "n", ")", ";", "if", "(", "m", ".", "matches", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "break", ";", "case", "Constants", ".", "SC_A_CONTEXT", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SERVLET_PATH", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_REMOTE_USER", ":", "boolean", "tomcatAuthorization", "=", "protocol", ".", "getTomcatAuthorization", "(", ")", ";", "if", "(", "tomcatAuthorization", "||", "!", "protocol", ".", "getTomcatAuthentication", "(", ")", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getRemoteUser", "(", ")", ")", ";", "request", ".", "setRemoteUserNeedsAuthorization", "(", "tomcatAuthorization", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_AUTH_TYPE", ":", "if", "(", "protocol", ".", "getTomcatAuthentication", "(", ")", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getAuthType", "(", ")", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_QUERY_STRING", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "queryString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_JVM_ROUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CERT", ":", "requestHeaderMessage", ".", "getBytes", "(", "certificates", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CIPHER", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "CIPHER_SUITE_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_SESSION", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "SESSION_ID_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_KEY_SIZE", ":", "request", ".", "setAttribute", "(", "SSLSupport", ".", "KEY_SIZE_KEY", ",", "Integer", ".", "valueOf", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_STORED_METHOD", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "method", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SECRET", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "if", "(", "secret", "!=", "null", ")", "{", "secretPresentInRequest", "=", "true", ";", "if", "(", "!", "tmpMB", ".", "equals", "(", "secret", ")", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "break", ";", "default", ":", "break", ";", "}", "}", "if", "(", "(", "secret", "!=", "null", ")", "&&", "!", "secretPresentInRequest", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "uriBC", ".", "indexOf", "(", "\"", "://", "\"", ",", "0", ",", "3", ",", "4", ")", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "-", "1", ";", "if", "(", "pos", "!=", "-", "1", ")", "{", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", "+", "3", ")", ";", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "1", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "MessageBytes", "hostMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "3", ",", "slashPos", "-", "pos", "-", "3", ")", ";", "}", "}", "MessageBytes", "valueMB", "=", "request", ".", "getMimeHeaders", "(", ")", ".", "getValue", "(", "\"", "host", "\"", ")", ";", "parseHost", "(", "valueMB", ")", ";", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 112501, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "64fa5b99442589ef0bf2a7fcd71ad2bc68b35fad", "function_name": "prepareRequest", "body_hash": "d90a2d8034edc30ee7e74b60af946f30e088ba99"}
{"code": "public static void introspecthelper(Object bean, String prop,\n                                        String value, ServletRequest request,\n                                        String param, boolean ignoreMethodNF)\n                                        throws JasperException {\n        Method method = null;\n        Class<?> type = null;\n        Class<?> propertyEditorClass = null;\n        try {\n            java.beans.BeanInfo info\n                = java.beans.Introspector.getBeanInfo(bean.getClass());\n            if ( info != null ) {\n                java.beans.PropertyDescriptor pd[]\n                    = info.getPropertyDescriptors();\n                for (int i = 0 ; i < pd.length ; i++) {\n                    if ( pd[i].getName().equals(prop) ) {\n                        method = pd[i].getWriteMethod();\n                        type   = pd[i].getPropertyType();\n                        propertyEditorClass = pd[i].getPropertyEditorClass();\n                        break;\n                    }\n                }\n            }\n            if (method != null && type != null) {\n                if (type.isArray()) {\n                    if (request == null) {\n                        throw new JasperException(\n                            Localizer.getMessage(\"jsp.error.beans.setproperty.noindexset\"));\n                    }\n                    Class<?> t = type.getComponentType();\n                    String[] values = request.getParameterValues(param);\n                    //XXX Please check.\n                    if(values == null) return;\n                    if(t.equals(String.class)) {\n                        method.invoke(bean, new Object[] { values });\n                    } else {\n                        createTypedArray (prop, bean, method, values, t,\n                                          propertyEditorClass);\n                    }\n                } else {\n                    if(value == null || (param != null && value.equals(\"\"))) return;\n                    Object oval = convert(prop, value, type, propertyEditorClass);\n                    if ( oval != null )\n                        method.invoke(bean, new Object[] { oval });\n                }\n            }\n        } catch (Exception ex) {\n            Throwable thr = ExceptionUtils.unwrapInvocationTargetException(ex);\n            ExceptionUtils.handleThrowable(thr);\n            throw new JasperException(ex);\n        }\n        if (!ignoreMethodNF && (method == null)) {\n            if (type == null) {\n                throw new JasperException(\n                    Localizer.getMessage(\"jsp.error.beans.noproperty\",\n                                         prop,\n                                         bean.getClass().getName()));\n            } else {\n                throw new JasperException(\n                    Localizer.getMessage(\"jsp.error.beans.nomethod.setproperty\",\n                                         prop,\n                                         type.getName(),\n                                         bean.getClass().getName()));\n            }\n        }\n    }", "code_tokens": ["public", "static", "void", "introspecthelper", "(", "Object", "bean", ",", "String", "prop", ",", "String", "value", ",", "ServletRequest", "request", ",", "String", "param", ",", "boolean", "ignoreMethodNF", ")", "throws", "JasperException", "{", "Method", "method", "=", "null", ";", "Class", "<", "?", ">", "type", "=", "null", ";", "Class", "<", "?", ">", "propertyEditorClass", "=", "null", ";", "try", "{", "java", ".", "beans", ".", "BeanInfo", "info", "=", "java", ".", "beans", ".", "Introspector", ".", "getBeanInfo", "(", "bean", ".", "getClass", "(", ")", ")", ";", "if", "(", "info", "!=", "null", ")", "{", "java", ".", "beans", ".", "PropertyDescriptor", "pd", "[", "]", "=", "info", ".", "getPropertyDescriptors", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pd", ".", "length", ";", "i", "++", ")", "{", "if", "(", "pd", "[", "i", "]", ".", "getName", "(", ")", ".", "equals", "(", "prop", ")", ")", "{", "method", "=", "pd", "[", "i", "]", ".", "getWriteMethod", "(", ")", ";", "type", "=", "pd", "[", "i", "]", ".", "getPropertyType", "(", ")", ";", "propertyEditorClass", "=", "pd", "[", "i", "]", ".", "getPropertyEditorClass", "(", ")", ";", "break", ";", "}", "}", "}", "if", "(", "method", "!=", "null", "&&", "type", "!=", "null", ")", "{", "if", "(", "type", ".", "isArray", "(", ")", ")", "{", "if", "(", "request", "==", "null", ")", "{", "throw", "new", "JasperException", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.error.beans.setproperty.noindexset", "\"", ")", ")", ";", "}", "Class", "<", "?", ">", "t", "=", "type", ".", "getComponentType", "(", ")", ";", "String", "[", "]", "values", "=", "request", ".", "getParameterValues", "(", "param", ")", ";", "if", "(", "values", "==", "null", ")", "return", ";", "if", "(", "t", ".", "equals", "(", "String", ".", "class", ")", ")", "{", "method", ".", "invoke", "(", "bean", ",", "new", "Object", "[", "]", "{", "values", "}", ")", ";", "}", "else", "{", "createTypedArray", "(", "prop", ",", "bean", ",", "method", ",", "values", ",", "t", ",", "propertyEditorClass", ")", ";", "}", "}", "else", "{", "if", "(", "value", "==", "null", "||", "(", "param", "!=", "null", "&&", "value", ".", "equals", "(", "\"", "\"", ")", ")", ")", "return", ";", "Object", "oval", "=", "convert", "(", "prop", ",", "value", ",", "type", ",", "propertyEditorClass", ")", ";", "if", "(", "oval", "!=", "null", ")", "method", ".", "invoke", "(", "bean", ",", "new", "Object", "[", "]", "{", "oval", "}", ")", ";", "}", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "Throwable", "thr", "=", "ExceptionUtils", ".", "unwrapInvocationTargetException", "(", "ex", ")", ";", "ExceptionUtils", ".", "handleThrowable", "(", "thr", ")", ";", "throw", "new", "JasperException", "(", "ex", ")", ";", "}", "if", "(", "!", "ignoreMethodNF", "&&", "(", "method", "==", "null", ")", ")", "{", "if", "(", "type", "==", "null", ")", "{", "throw", "new", "JasperException", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.error.beans.noproperty", "\"", ",", "prop", ",", "bean", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ")", ";", "}", "else", "{", "throw", "new", "JasperException", "(", "Localizer", ".", "getMessage", "(", "\"", "jsp.error.beans.nomethod.setproperty", "\"", ",", "prop", ",", "type", ".", "getName", "(", ")", ",", "bean", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ")", ";", "}", "}", "}"], "idx": 99584, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "11950154730c3b2473580621df83356e09142e73", "function_name": "introspecthelper", "body_hash": "5d5643278a4d33c6a2498b1528f080a1a1069381"}
{"code": "@Override\n    public InputStream getResourceAsStream(String path) throws IOException {\n        return classLoader.getResourceAsStream(THEME_RESOURCES_RESOURCES + path);\n    }", "code_tokens": ["@", "Override", "public", "InputStream", "getResourceAsStream", "(", "String", "path", ")", "throws", "IOException", "{", "return", "classLoader", ".", "getResourceAsStream", "(", "THEME_RESOURCES_RESOURCES", "+", "path", ")", ";", "}"], "idx": 64459, "cwe": "CWE-552", "target": 1, "status": "VULNERABLE", "commit": "73f0474008e1bebd0733e62a22aceda9e5de6743", "function_name": "getResourceAsStream", "body_hash": "5aae0e158ee6d2f5c6a34c99cd33093e66bd0977"}
{"code": "private static File getTmpFolder() {\n        try {\n            File outputFolder = Files.createTempDirectory(\"codegen-tmp\").toFile();\n            outputFolder.deleteOnExit();\n            return outputFolder;\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Cannot access tmp folder\");\n        }\n    }", "code_tokens": ["private", "static", "File", "getTmpFolder", "(", ")", "{", "try", "{", "File", "outputFolder", "=", "Files", ".", "createTempDirectory", "(", "\"", "codegen-tmp", "\"", ")", ".", "toFile", "(", ")", ";", "outputFolder", ".", "deleteOnExit", "(", ")", ";", "return", "outputFolder", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "throw", "new", "RuntimeException", "(", "\"", "Cannot access tmp folder", "\"", ")", ";", "}", "}"], "idx": 35410, "cwe": "CWE-269", "target": 0, "status": "FIXED", "commit": "c31e6e79d02d9f59d3b727cfc766cd4e0c27f75a", "function_name": "getTmpFolder", "body_hash": "da0a955c2f68d43d13f594a91c7ab470fe6cab7e"}
{"code": "@Override\n\tpublic void convertInput()\n\t{\n\t\tfinal PolicyFactory policy = newPolicyFactory();\n\t\tfinal String input = this.textarea.getConvertedInput();\n\n\t\tthis.setConvertedInput(policy.sanitize(input));\n\t}", "code_tokens": ["@", "Override", "public", "void", "convertInput", "(", ")", "{", "final", "PolicyFactory", "policy", "=", "newPolicyFactory", "(", ")", ";", "final", "String", "input", "=", "this", ".", "textarea", ".", "getConvertedInput", "(", ")", ";", "this", ".", "setConvertedInput", "(", "policy", ".", "sanitize", "(", "input", ")", ")", ";", "}"], "idx": 81655, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "42294cc890536459b13cf16844cd65cccf66578", "function_name": "convertInput", "body_hash": "27ec3c0100e7ca2c9284d140b15a8ee7b0ddb228"}
{"code": "@Override\n\tprotected File getFile(HandlerRequest<EmptyRequestBody, FileMessageParameters> handlerRequest) {\n\t\tif (logDir == null) {\n\t\t\treturn null;\n\t\t}\n\t\t// wrapping around another File instantiation is a simple way to remove any path information - we're\n\t\t// solely interested in the filename\n\t\tString filename = new File(handlerRequest.getPathParameter(LogFileNamePathParameter.class)).getName();\n\t\treturn new File(logDir, filename);\n\t}", "code_tokens": ["@", "Override", "protected", "File", "getFile", "(", "HandlerRequest", "<", "EmptyRequestBody", ",", "FileMessageParameters", ">", "handlerRequest", ")", "{", "if", "(", "logDir", "==", "null", ")", "{", "return", "null", ";", "}", "String", "filename", "=", "new", "File", "(", "handlerRequest", ".", "getPathParameter", "(", "LogFileNamePathParameter", ".", "class", ")", ")", ".", "getName", "(", ")", ";", "return", "new", "File", "(", "logDir", ",", "filename", ")", ";", "}"], "idx": 64365, "cwe": "CWE-552", "target": 0, "status": "FIXED", "commit": "b561010b0ee741543c3953306037f00d7a9f0801", "function_name": "getFile", "body_hash": "b969dd037e87b066f3b95d8ace1354bb48163e65"}
{"code": "public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }", "code_tokens": ["public", "static", "String", "getContextPath", "(", "HttpServletRequest", "request", ")", "{", "String", "contextPath", "=", "(", "String", ")", "request", ".", "getAttribute", "(", "INCLUDE_CONTEXT_PATH_ATTRIBUTE", ")", ";", "if", "(", "contextPath", "==", "null", ")", "{", "contextPath", "=", "request", ".", "getContextPath", "(", ")", ";", "}", "if", "(", "\"", "/", "\"", ".", "equals", "(", "contextPath", ")", ")", "{", "contextPath", "=", "\"", "\"", ";", "}", "return", "decodeRequestString", "(", "request", ",", "contextPath", ")", ";", "}"], "idx": 38196, "cwe": "CWE-284", "target": 1, "status": "VULNERABLE", "commit": "b15ab927709ca18ea4a02538be01919a19ab65af", "function_name": "getContextPath", "body_hash": "a196ecf636e748eb0486a63aaeb032e17951d245"}
{"code": "public static File createTempFile() throws IOException {\n        final AtomicReference<IOException> exceptionReference = new AtomicReference<>();\n        final File file = AccessController.doPrivileged(new PrivilegedAction<File>() {\n            public File run() {\n                File tempFile = null;\n                try {\n                    tempFile = Files.createTempFile(\"rep\", \"tmp\").toFile();\n                    // Make sure the file is deleted when JVM is shutdown at last.\n                    tempFile.deleteOnExit();\n                } catch (IOException e) {\n                    exceptionReference.set(e);\n                }\n                return tempFile;\n            }\n        });\n        if (exceptionReference.get() != null) {\n            throw exceptionReference.get();\n        }\n        return file;\n    }", "code_tokens": ["public", "static", "File", "createTempFile", "(", ")", "throws", "IOException", "{", "final", "AtomicReference", "<", "IOException", ">", "exceptionReference", "=", "new", "AtomicReference", "<", ">", "(", ")", ";", "final", "File", "file", "=", "AccessController", ".", "doPrivileged", "(", "new", "PrivilegedAction", "<", "File", ">", "(", ")", "{", "public", "File", "run", "(", ")", "{", "File", "tempFile", "=", "null", ";", "try", "{", "tempFile", "=", "Files", ".", "createTempFile", "(", "\"", "rep", "\"", ",", "\"", "tmp", "\"", ")", ".", "toFile", "(", ")", ";", "tempFile", ".", "deleteOnExit", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "exceptionReference", ".", "set", "(", "e", ")", ";", "}", "return", "tempFile", ";", "}", "}", ")", ";", "if", "(", "exceptionReference", ".", "get", "(", ")", "!=", "null", ")", "{", "throw", "exceptionReference", ".", "get", "(", ")", ";", "}", "return", "file", ";", "}"], "idx": 71607, "cwe": "CWE-668", "target": 0, "status": "FIXED", "commit": "f3cadb38dcc5b20e515706fae68dce533ad6c737", "function_name": "createTempFile", "body_hash": "0ad9a0a807e1b81713c1010e3918022f7fd01b09"}
{"code": "protected void prepareRequest() throws IOException {\n\n        http11 = true;\n        http09 = false;\n        contentDelimitation = false;\n        expectation = false;\n\n        prepareRequestInternal();\n\n        if (endpoint.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n        MessageBytes protocolMB = request.protocol();\n        if (protocolMB.equals(Constants.HTTP_11)) {\n            http11 = true;\n            protocolMB.setString(Constants.HTTP_11);\n        } else if (protocolMB.equals(Constants.HTTP_10)) {\n            http11 = false;\n            keepAlive = false;\n            protocolMB.setString(Constants.HTTP_10);\n        } else if (protocolMB.equals(\"\")) {\n            // HTTP/0.9\n            http09 = true;\n            http11 = false;\n            keepAlive = false;\n        } else {\n            // Unsupported protocol\n            http11 = false;\n            // Send 505; Unsupported HTTP version\n            response.setStatus(505);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n            }\n        }\n\n        MessageBytes methodMB = request.method();\n        if (methodMB.equals(Constants.GET)) {\n            methodMB.setString(Constants.GET);\n        } else if (methodMB.equals(Constants.POST)) {\n            methodMB.setString(Constants.POST);\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<String>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEPALIVE)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    getInputBuffer().setSwallowInput(false);\n                    expectation = true;\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (allowHostHeaderMismatch) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = getInputBuffer().getFilters();\n\n        // Parse transfer-encoding header\n        MessageBytes transferEncodingValueMB = null;\n        if (http11) {\n            transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n        }\n        if (transferEncodingValueMB != null) {\n            List<String> encodingNames = new ArrayList<String>();\n            if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                for (String encodingName : encodingNames) {\n                    // \"identity\" codings are ignored\n                    addInputFilter(inputFilters, encodingName);\n                }\n            } else {\n                // Invalid transfer encoding\n                badRequest(\"http11processor.request.invalidTransferEncoding\");\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n            } else {\n                getInputBuffer().addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            getInputBuffer().addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        // Advertise sendfile support through a request attribute\n        if (endpoint.getUseSendfile()) {\n            request.setAttribute(\n                    org.apache.coyote.Constants.SENDFILE_SUPPORTED_ATTR,\n                    Boolean.TRUE);\n        }\n\n        // Advertise comet support through a request attribute\n        if (endpoint.getUseComet()) {\n            request.setAttribute(\n                    org.apache.coyote.Constants.COMET_SUPPORTED_ATTR,\n                    Boolean.TRUE);\n        }\n        // Advertise comet timeout support\n        if (endpoint.getUseCometTimeout()) {\n            request.setAttribute(\n                    org.apache.coyote.Constants.COMET_TIMEOUT_SUPPORTED_ATTR,\n                    Boolean.TRUE);\n        }\n        if (getErrorState().isError()) {\n            adapter.log(request, response, 0);\n        }\n    }", "code_tokens": ["protected", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "http11", "=", "true", ";", "http09", "=", "false", ";", "contentDelimitation", "=", "false", ";", "expectation", "=", "false", ";", "prepareRequestInternal", "(", ")", ";", "if", "(", "endpoint", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MessageBytes", "protocolMB", "=", "request", ".", "protocol", "(", ")", ";", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_11", ")", ")", "{", "http11", "=", "true", ";", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_11", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_10", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_10", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "\"", "\"", ")", ")", "{", "http09", "=", "true", ";", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "http11", "=", "false", ";", "response", ".", "setStatus", "(", "505", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Unsupported HTTP version ", "\\\"", "\"", "+", "protocolMB", "+", "\"", "\\\"", "\"", ")", ";", "}", "}", "MessageBytes", "methodMB", "=", "request", ".", "method", "(", ")", ";", "if", "(", "methodMB", ".", "equals", "(", "Constants", ".", "GET", ")", ")", "{", "methodMB", ".", "setString", "(", "Constants", ".", "GET", ")", ";", "}", "else", "if", "(", "methodMB", ".", "equals", "(", "Constants", ".", "POST", ")", ")", "{", "methodMB", ".", "setString", "(", "Constants", ".", "POST", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEPALIVE", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "getInputBuffer", "(", ")", ".", "setSwallowInput", "(", "false", ")", ";", "expectation", "=", "true", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "if", "(", "(", "restrictedUserAgents", "!=", "null", ")", "&&", "(", "(", "http11", ")", "||", "(", "keepAlive", ")", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "allowHostHeaderMismatch", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "getInputBuffer", "(", ")", ".", "getFilters", "(", ")", ";", "MessageBytes", "transferEncodingValueMB", "=", "null", ";", "if", "(", "http11", ")", "{", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "}", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "if", "(", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ")", "{", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidTransferEncoding", "\"", ")", ";", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "}", "else", "{", "getInputBuffer", "(", ")", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "getInputBuffer", "(", ")", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "endpoint", ".", "getUseSendfile", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "org", ".", "apache", ".", "coyote", ".", "Constants", ".", "SENDFILE_SUPPORTED_ATTR", ",", "Boolean", ".", "TRUE", ")", ";", "}", "if", "(", "endpoint", ".", "getUseComet", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "org", ".", "apache", ".", "coyote", ".", "Constants", ".", "COMET_SUPPORTED_ATTR", ",", "Boolean", ".", "TRUE", ")", ";", "}", "if", "(", "endpoint", ".", "getUseCometTimeout", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "org", ".", "apache", ".", "coyote", ".", "Constants", ".", "COMET_TIMEOUT_SUPPORTED_ATTR", ",", "Boolean", ".", "TRUE", ")", ";", "}", "if", "(", "getErrorState", "(", ")", ".", "isError", "(", ")", ")", "{", "adapter", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 55733, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "b191a0d", "function_name": "prepareRequest", "body_hash": "f55f438d6ee22898f4cc17be56319bc97a79d275"}
{"code": "public static Locale parseLocaleString(String localeString) {\n\t\tString[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n\t\tString language = (parts.length > 0 ? parts[0] : \"\");\n\t\tString country = (parts.length > 1 ? parts[1] : \"\");\n\t\tString variant = \"\";\n\t\tif (parts.length >= 2) {\n\t\t\t// There is definitely a variant, and it is everything after the country\n\t\t\t// code sans the separator between the country code and the variant.\n\t\t\tint endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n\t\t\t// Strip off any leading '_' and whitespace, what's left is the variant.\n\t\t\tvariant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n\t\t\tif (variant.startsWith(\"_\")) {\n\t\t\t\tvariant = trimLeadingCharacter(variant, '_');\n\t\t\t}\n\t\t}\n\t\treturn (language.length() > 0 ? new Locale(language, country, variant) : null);\n\t}", "code_tokens": ["public", "static", "Locale", "parseLocaleString", "(", "String", "localeString", ")", "{", "String", "[", "]", "parts", "=", "tokenizeToStringArray", "(", "localeString", ",", "\"", "_ ", "\"", ",", "false", ",", "false", ")", ";", "String", "language", "=", "(", "parts", ".", "length", ">", "0", "?", "parts", "[", "0", "]", ":", "\"", "\"", ")", ";", "String", "country", "=", "(", "parts", ".", "length", ">", "1", "?", "parts", "[", "1", "]", ":", "\"", "\"", ")", ";", "String", "variant", "=", "\"", "\"", ";", "if", "(", "parts", ".", "length", ">=", "2", ")", "{", "int", "endIndexOfCountryCode", "=", "localeString", ".", "indexOf", "(", "country", ")", "+", "country", ".", "length", "(", ")", ";", "variant", "=", "trimLeadingWhitespace", "(", "localeString", ".", "substring", "(", "endIndexOfCountryCode", ")", ")", ";", "if", "(", "variant", ".", "startsWith", "(", "\"", "_", "\"", ")", ")", "{", "variant", "=", "trimLeadingCharacter", "(", "variant", ",", "'_'", ")", ";", "}", "}", "return", "(", "language", ".", "length", "(", ")", ">", "0", "?", "new", "Locale", "(", "language", ",", "country", ",", "variant", ")", ":", "null", ")", ";", "}"], "idx": 10472, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "f4a2282d9d9f6e58029022c58311a1db07f7defc", "function_name": "parseLocaleString", "body_hash": "084869e5c2ea86172f5d3809e45a8276e950d261"}
{"code": "@Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            RESTRequestParameterProcessingFilter restAuthenticationFilter = new RESTRequestParameterProcessingFilter();\n            restAuthenticationFilter.setAuthenticationManager(authenticationManagerBean());\n            restAuthenticationFilter.setSecurityService(securityService);\n            restAuthenticationFilter.setEventPublisher(eventPublisher);\n            http = http.addFilterBefore(restAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .csrf()\n                    .requireCsrfProtectionMatcher(csrfSecurityRequestMatcher)\n                    .and().headers()\n                    .frameOptions()\n                    .sameOrigin()\n                    .and().authorizeRequests()\n                    .antMatchers(\"/recover*\", \"/accessDenied*\",\n                            \"/style/**\", \"/icons/**\", \"/flash/**\", \"/script/**\",\n                            \"/sonos/**\", \"/crossdomain.xml\", \"/login\", \"/error\")\n                    .permitAll()\n                    .antMatchers(\"/personalSettings*\", \"/passwordSettings*\",\n                            \"/playerSettings*\", \"/shareSettings*\", \"/passwordSettings*\")\n                    .hasRole(\"SETTINGS\")\n                    .antMatchers(\"/generalSettings*\", \"/advancedSettings*\", \"/userSettings*\",\n                            \"/musicFolderSettings*\", \"/databaseSettings*\", \"/transcodeSettings*\", \"/rest/startScan*\")\n                    .hasRole(\"ADMIN\")\n                    .antMatchers(\"/deletePlaylist*\", \"/savePlaylist*\", \"/db*\")\n                    .hasRole(\"PLAYLIST\")\n                    .antMatchers(\"/download*\")\n                    .hasRole(\"DOWNLOAD\")\n                    .antMatchers(\"/upload*\")\n                    .hasRole(\"UPLOAD\")\n                    .antMatchers(\"/createShare*\")\n                    .hasRole(\"SHARE\")\n                    .antMatchers(\"/changeCoverArt*\", \"/editTags*\")\n                    .hasRole(\"COVERART\")\n                    .antMatchers(\"/setMusicFileInfo*\")\n                    .hasRole(\"COMMENT\")\n                    .antMatchers(\"/podcastReceiverAdmin*\")\n                    .hasRole(\"PODCAST\")\n                    .antMatchers(\"/**\")\n                    .hasRole(\"USER\")\n                    .anyRequest().authenticated()\n                    .and().formLogin()\n                    .loginPage(\"/login\")\n                    .permitAll()\n                    .defaultSuccessUrl(\"/index\", true)\n                    .failureUrl(FAILURE_URL)\n                    .usernameParameter(\"j_username\")\n                    .passwordParameter(\"j_password\")\n                    // see http://docs.spring.io/spring-security/site/docs/3.2.4.RELEASE/reference/htmlsingle/#csrf-logout\n                    .and().logout().logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\", \"GET\")).logoutSuccessUrl(\n                    \"/login?logout\")\n                    .and().rememberMe().key(key);\n        }", "code_tokens": ["@", "Override", "protected", "void", "configure", "(", "HttpSecurity", "http", ")", "throws", "Exception", "{", "RESTRequestParameterProcessingFilter", "restAuthenticationFilter", "=", "new", "RESTRequestParameterProcessingFilter", "(", ")", ";", "restAuthenticationFilter", ".", "setAuthenticationManager", "(", "authenticationManagerBean", "(", ")", ")", ";", "restAuthenticationFilter", ".", "setSecurityService", "(", "securityService", ")", ";", "restAuthenticationFilter", ".", "setEventPublisher", "(", "eventPublisher", ")", ";", "http", "=", "http", ".", "addFilterBefore", "(", "restAuthenticationFilter", ",", "UsernamePasswordAuthenticationFilter", ".", "class", ")", ";", "http", ".", "csrf", "(", ")", ".", "requireCsrfProtectionMatcher", "(", "csrfSecurityRequestMatcher", ")", ".", "and", "(", ")", ".", "headers", "(", ")", ".", "frameOptions", "(", ")", ".", "sameOrigin", "(", ")", ".", "and", "(", ")", ".", "authorizeRequests", "(", ")", ".", "antMatchers", "(", "\"", "/recover*", "\"", ",", "\"", "/accessDenied*", "\"", ",", "\"", "/style/**", "\"", ",", "\"", "/icons/**", "\"", ",", "\"", "/flash/**", "\"", ",", "\"", "/script/**", "\"", ",", "\"", "/sonos/**", "\"", ",", "\"", "/crossdomain.xml", "\"", ",", "\"", "/login", "\"", ",", "\"", "/error", "\"", ")", ".", "permitAll", "(", ")", ".", "antMatchers", "(", "\"", "/personalSettings*", "\"", ",", "\"", "/passwordSettings*", "\"", ",", "\"", "/playerSettings*", "\"", ",", "\"", "/shareSettings*", "\"", ",", "\"", "/passwordSettings*", "\"", ")", ".", "hasRole", "(", "\"", "SETTINGS", "\"", ")", ".", "antMatchers", "(", "\"", "/generalSettings*", "\"", ",", "\"", "/advancedSettings*", "\"", ",", "\"", "/userSettings*", "\"", ",", "\"", "/musicFolderSettings*", "\"", ",", "\"", "/databaseSettings*", "\"", ",", "\"", "/transcodeSettings*", "\"", ",", "\"", "/rest/startScan*", "\"", ")", ".", "hasRole", "(", "\"", "ADMIN", "\"", ")", ".", "antMatchers", "(", "\"", "/deletePlaylist*", "\"", ",", "\"", "/savePlaylist*", "\"", ",", "\"", "/db*", "\"", ")", ".", "hasRole", "(", "\"", "PLAYLIST", "\"", ")", ".", "antMatchers", "(", "\"", "/download*", "\"", ")", ".", "hasRole", "(", "\"", "DOWNLOAD", "\"", ")", ".", "antMatchers", "(", "\"", "/upload*", "\"", ")", ".", "hasRole", "(", "\"", "UPLOAD", "\"", ")", ".", "antMatchers", "(", "\"", "/createShare*", "\"", ")", ".", "hasRole", "(", "\"", "SHARE", "\"", ")", ".", "antMatchers", "(", "\"", "/changeCoverArt*", "\"", ",", "\"", "/editTags*", "\"", ")", ".", "hasRole", "(", "\"", "COVERART", "\"", ")", ".", "antMatchers", "(", "\"", "/setMusicFileInfo*", "\"", ")", ".", "hasRole", "(", "\"", "COMMENT", "\"", ")", ".", "antMatchers", "(", "\"", "/podcastReceiverAdmin*", "\"", ")", ".", "hasRole", "(", "\"", "PODCAST", "\"", ")", ".", "antMatchers", "(", "\"", "/**", "\"", ")", ".", "hasRole", "(", "\"", "USER", "\"", ")", ".", "anyRequest", "(", ")", ".", "authenticated", "(", ")", ".", "and", "(", ")", ".", "formLogin", "(", ")", ".", "loginPage", "(", "\"", "/login", "\"", ")", ".", "permitAll", "(", ")", ".", "defaultSuccessUrl", "(", "\"", "/index", "\"", ",", "true", ")", ".", "failureUrl", "(", "FAILURE_URL", ")", ".", "usernameParameter", "(", "\"", "j_username", "\"", ")", ".", "passwordParameter", "(", "\"", "j_password", "\"", ")", ".", "and", "(", ")", ".", "logout", "(", ")", ".", "logoutRequestMatcher", "(", "new", "AntPathRequestMatcher", "(", "\"", "/logout", "\"", ",", "\"", "GET", "\"", ")", ")", ".", "logoutSuccessUrl", "(", "\"", "/login?logout", "\"", ")", ".", "and", "(", ")", ".", "rememberMe", "(", ")", ".", "key", "(", "key", ")", ";", "}"], "idx": 42132, "cwe": "CWE-326", "target": 0, "status": "FIXED", "commit": "3e07ea52885f88d3fbec444dfd592f27bfb65647", "function_name": "configure", "body_hash": "c4633e6cbbc66edb005513082ca2937d5e9ec725"}
{"code": "protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {\n        boolean isValid = false;\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Binding the user.\");\n        }\n        context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);\n        context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n        try {\n            context.getAttributes(\"\", null);\n            isValid = true;\n            if (log.isDebugEnabled()) {\n                log.debug(\"User \" + dn + \" successfully bound.\");\n            }\n        } catch (AuthenticationException e) {\n            isValid = false;\n            if (log.isDebugEnabled()) {\n                log.debug(\"Authentication failed for dn=\" + dn);\n            }\n        }\n\n        if (isLoginPropertySet(CONNECTION_USERNAME)) {\n            context.addToEnvironment(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));\n        } else {\n            context.removeFromEnvironment(Context.SECURITY_PRINCIPAL);\n        }\n        if (isLoginPropertySet(CONNECTION_PASSWORD)) {\n            context.addToEnvironment(Context.SECURITY_CREDENTIALS, getLDAPPropertyValue(CONNECTION_PASSWORD));\n        } else {\n            context.removeFromEnvironment(Context.SECURITY_CREDENTIALS);\n        }\n\n        return isValid;\n    }", "code_tokens": ["protected", "boolean", "bindUser", "(", "DirContext", "context", ",", "String", "dn", ",", "String", "password", ")", "throws", "NamingException", "{", "boolean", "isValid", "=", "false", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Binding the user.", "\"", ")", ";", "}", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "dn", ")", ";", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "password", ")", ";", "try", "{", "context", ".", "getAttributes", "(", "\"", "\"", ",", "null", ")", ";", "isValid", "=", "true", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "User ", "\"", "+", "dn", "+", "\"", " successfully bound.", "\"", ")", ";", "}", "}", "catch", "(", "AuthenticationException", "e", ")", "{", "isValid", "=", "false", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Authentication failed for dn=", "\"", "+", "dn", ")", ";", "}", "}", "if", "(", "isLoginPropertySet", "(", "CONNECTION_USERNAME", ")", ")", "{", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "getLDAPPropertyValue", "(", "CONNECTION_USERNAME", ")", ")", ";", "}", "else", "{", "context", ".", "removeFromEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ")", ";", "}", "if", "(", "isLoginPropertySet", "(", "CONNECTION_PASSWORD", ")", ")", "{", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "getLDAPPropertyValue", "(", "CONNECTION_PASSWORD", ")", ")", ";", "}", "else", "{", "context", ".", "removeFromEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ")", ";", "}", "return", "isValid", ";", "}"], "idx": 38234, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "73e291693d59a96c0054fc7e7e09c2c67b192911", "function_name": "bindUser", "body_hash": "60d79d03794fed189aad7f6bb6ad33214aa6f02f"}
{"code": "@Override\n    public void onTrigger(final ProcessContext context, final ProcessSession session) {\n        final FlowFile original = session.get();\n        if (original == null) {\n            return;\n        }\n\n        final int depth = context.getProperty(SPLIT_DEPTH).asInteger();\n        final ComponentLog logger = getLogger();\n\n        final List<FlowFile> splits = new ArrayList<>();\n        final String fragmentIdentifier = UUID.randomUUID().toString();\n        final AtomicInteger numberOfRecords = new AtomicInteger(0);\n        final XmlSplitterSaxParser parser = new XmlSplitterSaxParser(xmlTree -> {\n            FlowFile split = session.create(original);\n            split = session.write(split, out -> out.write(xmlTree.getBytes(\"UTF-8\")));\n            split = session.putAttribute(split, FRAGMENT_ID.key(), fragmentIdentifier);\n            split = session.putAttribute(split, FRAGMENT_INDEX.key(), Integer.toString(numberOfRecords.getAndIncrement()));\n            split = session.putAttribute(split, SEGMENT_ORIGINAL_FILENAME.key(), split.getAttribute(CoreAttributes.FILENAME.key()));\n            splits.add(split);\n        }, depth);\n\n        final AtomicBoolean failed = new AtomicBoolean(false);\n        session.read(original, rawIn -> {\n            try (final InputStream in = new BufferedInputStream(rawIn)) {\n                SAXParser saxParser = null;\n                try {\n                    saxParser = saxParserFactory.newSAXParser();\n                    final XMLReader reader = saxParser.getXMLReader();\n                    reader.setContentHandler(parser);\n                    reader.parse(new InputSource(in));\n                } catch (final ParserConfigurationException | SAXException e) {\n                    logger.error(\"Unable to parse {} due to {}\", new Object[]{original, e});\n                    failed.set(true);\n                }\n            }\n        });\n\n        if (failed.get()) {\n            session.transfer(original, REL_FAILURE);\n            session.remove(splits);\n        } else {\n            splits.forEach((split) -> {\n                split = session.putAttribute(split, FRAGMENT_COUNT.key(), Integer.toString(numberOfRecords.get()));\n                session.transfer(split, REL_SPLIT);\n            });\n\n            final FlowFile originalToTransfer = copyAttributesToOriginal(session, original, fragmentIdentifier, numberOfRecords.get());\n            session.transfer(originalToTransfer, REL_ORIGINAL);\n            logger.info(\"Split {} into {} FlowFiles\", new Object[]{originalToTransfer, splits.size()});\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "onTrigger", "(", "final", "ProcessContext", "context", ",", "final", "ProcessSession", "session", ")", "{", "final", "FlowFile", "original", "=", "session", ".", "get", "(", ")", ";", "if", "(", "original", "==", "null", ")", "{", "return", ";", "}", "final", "int", "depth", "=", "context", ".", "getProperty", "(", "SPLIT_DEPTH", ")", ".", "asInteger", "(", ")", ";", "final", "ComponentLog", "logger", "=", "getLogger", "(", ")", ";", "final", "List", "<", "FlowFile", ">", "splits", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "final", "String", "fragmentIdentifier", "=", "UUID", ".", "randomUUID", "(", ")", ".", "toString", "(", ")", ";", "final", "AtomicInteger", "numberOfRecords", "=", "new", "AtomicInteger", "(", "0", ")", ";", "final", "XmlSplitterSaxParser", "parser", "=", "new", "XmlSplitterSaxParser", "(", "xmlTree", "->", "{", "FlowFile", "split", "=", "session", ".", "create", "(", "original", ")", ";", "split", "=", "session", ".", "write", "(", "split", ",", "out", "->", "out", ".", "write", "(", "xmlTree", ".", "getBytes", "(", "\"", "UTF-8", "\"", ")", ")", ")", ";", "split", "=", "session", ".", "putAttribute", "(", "split", ",", "FRAGMENT_ID", ".", "key", "(", ")", ",", "fragmentIdentifier", ")", ";", "split", "=", "session", ".", "putAttribute", "(", "split", ",", "FRAGMENT_INDEX", ".", "key", "(", ")", ",", "Integer", ".", "toString", "(", "numberOfRecords", ".", "getAndIncrement", "(", ")", ")", ")", ";", "split", "=", "session", ".", "putAttribute", "(", "split", ",", "SEGMENT_ORIGINAL_FILENAME", ".", "key", "(", ")", ",", "split", ".", "getAttribute", "(", "CoreAttributes", ".", "FILENAME", ".", "key", "(", ")", ")", ")", ";", "splits", ".", "add", "(", "split", ")", ";", "}", ",", "depth", ")", ";", "final", "AtomicBoolean", "failed", "=", "new", "AtomicBoolean", "(", "false", ")", ";", "session", ".", "read", "(", "original", ",", "rawIn", "->", "{", "try", "(", "final", "InputStream", "in", "=", "new", "BufferedInputStream", "(", "rawIn", ")", ")", "{", "SAXParser", "saxParser", "=", "null", ";", "try", "{", "saxParser", "=", "saxParserFactory", ".", "newSAXParser", "(", ")", ";", "final", "XMLReader", "reader", "=", "saxParser", ".", "getXMLReader", "(", ")", ";", "reader", ".", "setContentHandler", "(", "parser", ")", ";", "reader", ".", "parse", "(", "new", "InputSource", "(", "in", ")", ")", ";", "}", "catch", "(", "final", "ParserConfigurationException", "|", "SAXException", "e", ")", "{", "logger", ".", "error", "(", "\"", "Unable to parse {} due to {}", "\"", ",", "new", "Object", "[", "]", "{", "original", ",", "e", "}", ")", ";", "failed", ".", "set", "(", "true", ")", ";", "}", "}", "}", ")", ";", "if", "(", "failed", ".", "get", "(", ")", ")", "{", "session", ".", "transfer", "(", "original", ",", "REL_FAILURE", ")", ";", "session", ".", "remove", "(", "splits", ")", ";", "}", "else", "{", "splits", ".", "forEach", "(", "(", "split", ")", "->", "{", "split", "=", "session", ".", "putAttribute", "(", "split", ",", "FRAGMENT_COUNT", ".", "key", "(", ")", ",", "Integer", ".", "toString", "(", "numberOfRecords", ".", "get", "(", ")", ")", ")", ";", "session", ".", "transfer", "(", "split", ",", "REL_SPLIT", ")", ";", "}", ")", ";", "final", "FlowFile", "originalToTransfer", "=", "copyAttributesToOriginal", "(", "session", ",", "original", ",", "fragmentIdentifier", ",", "numberOfRecords", ".", "get", "(", ")", ")", ";", "session", ".", "transfer", "(", "originalToTransfer", ",", "REL_ORIGINAL", ")", ";", "logger", ".", "info", "(", "\"", "Split {} into {} FlowFiles", "\"", ",", "new", "Object", "[", "]", "{", "originalToTransfer", ",", "splits", ".", "size", "(", ")", "}", ")", ";", "}", "}"], "idx": 67999, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "28067a29fd13cdf8e21b440fc65c6dd67872522f", "function_name": "onTrigger", "body_hash": "2eea10713b55cc88873f2a079d3e59e5df393146"}
{"code": "@Override\n  public AccessControlList getAccessControlList(String mediaPackageId) throws NotFoundException,\n  SearchServiceDatabaseException {\n    EntityManager em = null;\n    try {\n      em = emf.createEntityManager();\n      SearchEntity entity = getSearchEntity(mediaPackageId, em);\n      if (entity == null) {\n        throw new NotFoundException(\"Could not found media package with ID \" + mediaPackageId);\n      }\n      if (entity.getAccessControl() == null) {\n        return null;\n      } else {\n        return AccessControlParser.parseAcl(entity.getAccessControl());\n      }\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not retrieve ACL {}: {}\", mediaPackageId, e.getMessage());\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n  }", "code_tokens": ["@", "Override", "public", "AccessControlList", "getAccessControlList", "(", "String", "mediaPackageId", ")", "throws", "NotFoundException", ",", "SearchServiceDatabaseException", "{", "EntityManager", "em", "=", "null", ";", "try", "{", "em", "=", "emf", ".", "createEntityManager", "(", ")", ";", "SearchEntity", "entity", "=", "getSearchEntity", "(", "mediaPackageId", ",", "em", ")", ";", "if", "(", "entity", "==", "null", ")", "{", "throw", "new", "NotFoundException", "(", "\"", "Could not found media package with ID ", "\"", "+", "mediaPackageId", ")", ";", "}", "if", "(", "entity", ".", "getAccessControl", "(", ")", "==", "null", ")", "{", "return", "null", ";", "}", "else", "{", "return", "AccessControlParser", ".", "parseAcl", "(", "entity", ".", "getAccessControl", "(", ")", ")", ";", "}", "}", "catch", "(", "NotFoundException", "e", ")", "{", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "logger", ".", "error", "(", "\"", "Could not retrieve ACL {}: {}", "\"", ",", "mediaPackageId", ",", "e", ".", "getMessage", "(", ")", ")", ";", "throw", "new", "SearchServiceDatabaseException", "(", "e", ")", ";", "}", "finally", "{", "em", ".", "close", "(", ")", ";", "}", "}"], "idx": 88843, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "b18c6a7f81f08ed14884592a6c14c9ab611ad450", "function_name": "getAccessControlList", "body_hash": "bd14962ed70f718cc673b9435f06e0fa26e9808e"}
{"code": "@PresetData(DataSet.ANONYMOUS_READONLY)\n    @Email(\"http://www.nabble.com/Launching-slave-by-JNLP-with-Active-Directory-plugin-and-matrix-security-problem-td18980323.html\")\n    public void test() throws Exception {\n        jenkins.setNodes(Collections.singletonList(createNewJnlpSlave(\"test\")));\n        HudsonTestCase.WebClient wc = new WebClient();\n        HtmlPage p = wc.login(\"alice\").goTo(\"computer/test/\");\n\n        // this fresh WebClient doesn't have a login cookie and represent JNLP launcher\n        HudsonTestCase.WebClient jnlpAgent = new WebClient();\n\n        // parse the JNLP page into DOM to list up the jars.\n        XmlPage jnlp = (XmlPage) wc.goTo(\"computer/test/slave-agent.jnlp\",\"application/x-java-jnlp-file\");\n        URL baseUrl = jnlp.getWebResponse().getUrl();\n        Document dom = new DOMReader().read(jnlp.getXmlDocument());\n        for( Element jar : (List<Element>)dom.selectNodes(\"//jar\") ) {\n            URL url = new URL(baseUrl,jar.attributeValue(\"href\"));\n            System.out.println(url);\n            \n            // now make sure that these URLs are unprotected\n            Page jarResource = jnlpAgent.getPage(url);\n            assertTrue(jarResource.getWebResponse().getContentType().toLowerCase(Locale.ENGLISH).startsWith(\"application/\"));\n        }\n\n\n        try {\n            jnlp = (XmlPage) jnlpAgent.goTo(\"computer/test/slave-agent.jnlp\", \"application/x-java-jnlp-file\");\n            fail(\"anonymous users must not be able to get secrets\");\n        } catch (FailingHttpStatusCodeException x) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, x.getStatusCode());\n        }\n    }", "code_tokens": ["@", "PresetData", "(", "DataSet", ".", "ANONYMOUS_READONLY", ")", "@", "Email", "(", "\"", "http://www.nabble.com/Launching-slave-by-JNLP-with-Active-Directory-plugin-and-matrix-security-problem-td18980323.html", "\"", ")", "public", "void", "test", "(", ")", "throws", "Exception", "{", "jenkins", ".", "setNodes", "(", "Collections", ".", "singletonList", "(", "createNewJnlpSlave", "(", "\"", "test", "\"", ")", ")", ")", ";", "HudsonTestCase", ".", "WebClient", "wc", "=", "new", "WebClient", "(", ")", ";", "HtmlPage", "p", "=", "wc", ".", "login", "(", "\"", "alice", "\"", ")", ".", "goTo", "(", "\"", "computer/test/", "\"", ")", ";", "HudsonTestCase", ".", "WebClient", "jnlpAgent", "=", "new", "WebClient", "(", ")", ";", "XmlPage", "jnlp", "=", "(", "XmlPage", ")", "wc", ".", "goTo", "(", "\"", "computer/test/slave-agent.jnlp", "\"", ",", "\"", "application/x-java-jnlp-file", "\"", ")", ";", "URL", "baseUrl", "=", "jnlp", ".", "getWebResponse", "(", ")", ".", "getUrl", "(", ")", ";", "Document", "dom", "=", "new", "DOMReader", "(", ")", ".", "read", "(", "jnlp", ".", "getXmlDocument", "(", ")", ")", ";", "for", "(", "Element", "jar", ":", "(", "List", "<", "Element", ">", ")", "dom", ".", "selectNodes", "(", "\"", "//jar", "\"", ")", ")", "{", "URL", "url", "=", "new", "URL", "(", "baseUrl", ",", "jar", ".", "attributeValue", "(", "\"", "href", "\"", ")", ")", ";", "System", ".", "out", ".", "println", "(", "url", ")", ";", "Page", "jarResource", "=", "jnlpAgent", ".", "getPage", "(", "url", ")", ";", "assertTrue", "(", "jarResource", ".", "getWebResponse", "(", ")", ".", "getContentType", "(", ")", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ".", "startsWith", "(", "\"", "application/", "\"", ")", ")", ";", "}", "try", "{", "jnlp", "=", "(", "XmlPage", ")", "jnlpAgent", ".", "goTo", "(", "\"", "computer/test/slave-agent.jnlp", "\"", ",", "\"", "application/x-java-jnlp-file", "\"", ")", ";", "fail", "(", "\"", "anonymous users must not be able to get secrets", "\"", ")", ";", "}", "catch", "(", "FailingHttpStatusCodeException", "x", ")", "{", "assertEquals", "(", "HttpURLConnection", ".", "HTTP_FORBIDDEN", ",", "x", ".", "getStatusCode", "(", ")", ")", ";", "}", "}"], "idx": 108130, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "a9aff088f327278a8873aef47fa8f80d3c5932fd", "function_name": "test", "body_hash": "716d634288a50ed19521ac3870be7ef87115e8cb"}
{"code": "public String getApiToken() {\n        return Util.getDigestOf(apiToken.getPlainText());\n    }", "code_tokens": ["public", "String", "getApiToken", "(", ")", "{", "return", "Util", ".", "getDigestOf", "(", "apiToken", ".", "getPlainText", "(", ")", ")", ";", "}"], "idx": 98922, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "94a8789b699132dd706021a6be1b78bc47f19602", "function_name": "getApiToken", "body_hash": "c70ce84b46647aab7ce741dd2027408696edddd4"}
{"code": "public FormValidation doCheckDriver(@QueryParameter String value) {\n            if (value.length()==0)\n                return FormValidation.ok(); // no value typed yet.\n\n            try {\n                getClassLoader().loadClass(value);\n                return FormValidation.ok();\n            } catch (ClassNotFoundException e) {\n                return FormValidation.error(\"No such class: \"+value);\n            }\n        }", "code_tokens": ["public", "FormValidation", "doCheckDriver", "(", "@", "QueryParameter", "String", "value", ")", "{", "if", "(", "value", ".", "length", "(", ")", "==", "0", ")", "return", "FormValidation", ".", "ok", "(", ")", ";", "try", "{", "getClassLoader", "(", ")", ".", "loadClass", "(", "value", ")", ";", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "\"", "No such class: ", "\"", "+", "value", ")", ";", "}", "}"], "idx": 47021, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "7a438d9", "function_name": "doCheckDriver", "body_hash": "2faa3344a07d2e094d4984c754573e7bc31f5dac"}
{"code": "@POST\n        public FormValidation doCheckDriver(@QueryParameter String value) {\n            Jenkins.get().checkPermission(Jenkins.ADMINISTER);\n            \n            if (value.length()==0)\n                return FormValidation.ok(); // no value typed yet.\n\n            try {\n                getClassLoader().loadClass(value);\n                return FormValidation.ok();\n            } catch (ClassNotFoundException e) {\n                return FormValidation.error(\"No such class: \"+value);\n            }\n        }", "code_tokens": ["@", "POST", "public", "FormValidation", "doCheckDriver", "(", "@", "QueryParameter", "String", "value", ")", "{", "Jenkins", ".", "get", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "if", "(", "value", ".", "length", "(", ")", "==", "0", ")", "return", "FormValidation", ".", "ok", "(", ")", ";", "try", "{", "getClassLoader", "(", ")", ".", "loadClass", "(", "value", ")", ";", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "return", "FormValidation", ".", "error", "(", "\"", "No such class: ", "\"", "+", "value", ")", ";", "}", "}"], "idx": 47022, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "7a438d9", "function_name": "doCheckDriver", "body_hash": "edac4095cc377c550760e697b751a7ae14036a83"}
{"code": "private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {\n        // Create the NamingService, needed by JSR 160\n        try {\n            if (registry == null) {\n                LOG.debug(\"Creating RMIRegistry on port {}\", connectorPort);\n                registry = new JmxRegistry(connectorPort);\n            }\n\n            namingServiceObjectName = ObjectName.getInstance(\"naming:type=rmiregistry\");\n\n            // Do not use the createMBean as the mx4j jar may not be in the\n            // same class loader than the server\n            Class<?> cl = Class.forName(\"mx4j.tools.naming.NamingService\");\n            mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);\n\n            // set the naming port\n            Attribute attr = new Attribute(\"Port\", Integer.valueOf(connectorPort));\n            mbeanServer.setAttribute(namingServiceObjectName, attr);\n        } catch(ClassNotFoundException e) {\n            LOG.debug(\"Probably not using JRE 1.4: {}\", e.getLocalizedMessage());\n        } catch (Throwable e) {\n            LOG.debug(\"Failed to create local registry. This exception will be ignored.\", e);\n        }\n\n        // Create the JMXConnectorServer\n        String rmiServer = \"\";\n        if (rmiServerPort != 0) {\n            // This is handy to use if you have a firewall and need to force JMX to use fixed ports.\n            rmiServer = \"\"+getConnectorHost()+\":\" + rmiServerPort;\n        }\n\n        final Map<String,Object> env = new HashMap<>();\n        server = new RMIJRMPServerImpl(connectorPort, null, null, environment);\n\n        final String serviceURL = \"service:jmx:rmi://\" + rmiServer + \"/jndi/rmi://\" +getConnectorHost()+\":\" + connectorPort + connectorPath;\n        final JMXServiceURL url = new JMXServiceURL(serviceURL);\n\n        connectorServer = new RMIConnectorServer(url, env, server, ManagementFactory.getPlatformMBeanServer());\n        LOG.debug(\"Created JMXConnectorServer {}\", connectorServer);\n    }", "code_tokens": ["private", "void", "createConnector", "(", "MBeanServer", "mbeanServer", ")", "throws", "MalformedObjectNameException", ",", "IOException", "{", "try", "{", "if", "(", "registry", "==", "null", ")", "{", "LOG", ".", "debug", "(", "\"", "Creating RMIRegistry on port {}", "\"", ",", "connectorPort", ")", ";", "registry", "=", "new", "JmxRegistry", "(", "connectorPort", ")", ";", "}", "namingServiceObjectName", "=", "ObjectName", ".", "getInstance", "(", "\"", "naming:type=rmiregistry", "\"", ")", ";", "Class", "<", "?", ">", "cl", "=", "Class", ".", "forName", "(", "\"", "mx4j.tools.naming.NamingService", "\"", ")", ";", "mbeanServer", ".", "registerMBean", "(", "cl", ".", "newInstance", "(", ")", ",", "namingServiceObjectName", ")", ";", "Attribute", "attr", "=", "new", "Attribute", "(", "\"", "Port", "\"", ",", "Integer", ".", "valueOf", "(", "connectorPort", ")", ")", ";", "mbeanServer", ".", "setAttribute", "(", "namingServiceObjectName", ",", "attr", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "LOG", ".", "debug", "(", "\"", "Probably not using JRE 1.4: {}", "\"", ",", "e", ".", "getLocalizedMessage", "(", ")", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "LOG", ".", "debug", "(", "\"", "Failed to create local registry. This exception will be ignored.", "\"", ",", "e", ")", ";", "}", "String", "rmiServer", "=", "\"", "\"", ";", "if", "(", "rmiServerPort", "!=", "0", ")", "{", "rmiServer", "=", "\"", "\"", "+", "getConnectorHost", "(", ")", "+", "\"", ":", "\"", "+", "rmiServerPort", ";", "}", "final", "Map", "<", "String", ",", "Object", ">", "env", "=", "new", "HashMap", "<", ">", "(", ")", ";", "server", "=", "new", "RMIJRMPServerImpl", "(", "connectorPort", ",", "null", ",", "null", ",", "environment", ")", ";", "final", "String", "serviceURL", "=", "\"", "service:jmx:rmi://", "\"", "+", "rmiServer", "+", "\"", "/jndi/rmi://", "\"", "+", "getConnectorHost", "(", ")", "+", "\"", ":", "\"", "+", "connectorPort", "+", "connectorPath", ";", "final", "JMXServiceURL", "url", "=", "new", "JMXServiceURL", "(", "serviceURL", ")", ";", "connectorServer", "=", "new", "RMIConnectorServer", "(", "url", ",", "env", ",", "server", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "LOG", ".", "debug", "(", "\"", "Created JMXConnectorServer {}", "\"", ",", "connectorServer", ")", ";", "}"], "idx": 96197, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "aa8900ca70e6f9422490c1a03627400375d3ff83", "function_name": "createConnector", "body_hash": "2292c04728f77c25bb822e96ee398bee0b6010f7"}
{"code": "@Override\n    public void setServerUrl(final String url) {\n        try {\n            final URISupport.CompositeData compositeData = URISupport.parseComposite(URLs.uri(url));\n            if (\"vm\".equals(compositeData.getScheme())) {\n                super.setServerUrl(URISupport.addParameters(URLs.uri(url), PREVENT_CREATION_PARAMS).toString());\n                return;\n            }\n        } catch (URISyntaxException e) {\n            // if we hit an exception, we'll log this and simple pass the URL we were given to ActiveMQ.\n            LOGGER.error(\"Error occurred while processing ActiveMQ ServerUrl: \" + url, e);\n        }\n\n        super.setServerUrl(url);\n    }", "code_tokens": ["@", "Override", "public", "void", "setServerUrl", "(", "final", "String", "url", ")", "{", "try", "{", "final", "URISupport", ".", "CompositeData", "compositeData", "=", "URISupport", ".", "parseComposite", "(", "URLs", ".", "uri", "(", "url", ")", ")", ";", "if", "(", "\"", "vm", "\"", ".", "equals", "(", "compositeData", ".", "getScheme", "(", ")", ")", ")", "{", "super", ".", "setServerUrl", "(", "URISupport", ".", "addParameters", "(", "URLs", ".", "uri", "(", "url", ")", ",", "PREVENT_CREATION_PARAMS", ")", ".", "toString", "(", ")", ")", ";", "return", ";", "}", "}", "catch", "(", "URISyntaxException", "e", ")", "{", "LOGGER", ".", "error", "(", "\"", "Error occurred while processing ActiveMQ ServerUrl: ", "\"", "+", "url", ",", "e", ")", ";", "}", "super", ".", "setServerUrl", "(", "url", ")", ";", "}"], "idx": 98074, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "a59ca1cc8839e7d7be48d3f2d7977747a59bd107", "function_name": "setServerUrl", "body_hash": "bd5f1e990eba0ad38bc3b56e02fda95dddd771f2"}
{"code": "void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n  }", "code_tokens": ["void", "addPathParam", "(", "String", "name", ",", "String", "value", ",", "boolean", "encoded", ")", "{", "if", "(", "relativeUrl", "==", "null", ")", "{", "throw", "new", "AssertionError", "(", ")", ";", "}", "relativeUrl", "=", "relativeUrl", ".", "replace", "(", "\"", "{", "\"", "+", "name", "+", "\"", "}", "\"", ",", "canonicalizeForPath", "(", "value", ",", "encoded", ")", ")", ";", "}"], "idx": 25844, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "b9a7f6ad72073ddd40254c0058710e87a073047d", "function_name": "addPathParam", "body_hash": "aa8d76d161de448781bc5704006c371e050aee8d"}
{"code": "protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\n            \"java.beans.EventHandler\", //\n            \"java.lang.ProcessBuilder\", //\n            \"javax.imageio.ImageIO$ContainsFilter\", //\n            \"jdk.nashorn.internal.objects.NativeString\", //\n            \"com.sun.corba.se.impl.activation.ServerTableEntry\", //\n            \"com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator\", //\n            \"sun.awt.datatransfer.DataTransferer$IndexOrderComparator\", //\n            \"sun.swing.SwingLazyValue\"});\n        denyTypesByRegExp(new Pattern[]{\n            LAZY_ITERATORS, GETTER_SETTER_REFLECTION, PRIVILEGED_GETTER, JAVAX_CRYPTO, JAXWS_ITERATORS,\n            JAVAFX_OBSERVABLE_LIST__, BCEL_CL});\n        denyTypeHierarchy(InputStream.class);\n        denyTypeHierarchyDynamically(\"java.nio.channels.Channel\");\n        denyTypeHierarchyDynamically(\"javax.activation.DataSource\");\n        denyTypeHierarchyDynamically(\"javax.sql.rowset.BaseRowSet\");\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }", "code_tokens": ["protected", "void", "setupSecurity", "(", ")", "{", "if", "(", "securityMapper", "==", "null", ")", "{", "return", ";", "}", "addPermission", "(", "AnyTypePermission", ".", "ANY", ")", ";", "denyTypes", "(", "new", "String", "[", "]", "{", "\"", "java.beans.EventHandler", "\"", ",", "\"", "java.lang.ProcessBuilder", "\"", ",", "\"", "javax.imageio.ImageIO$ContainsFilter", "\"", ",", "\"", "jdk.nashorn.internal.objects.NativeString", "\"", ",", "\"", "com.sun.corba.se.impl.activation.ServerTableEntry", "\"", ",", "\"", "com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator", "\"", ",", "\"", "sun.awt.datatransfer.DataTransferer$IndexOrderComparator", "\"", ",", "\"", "sun.swing.SwingLazyValue", "\"", "}", ")", ";", "denyTypesByRegExp", "(", "new", "Pattern", "[", "]", "{", "LAZY_ITERATORS", ",", "GETTER_SETTER_REFLECTION", ",", "PRIVILEGED_GETTER", ",", "JAVAX_CRYPTO", ",", "JAXWS_ITERATORS", ",", "JAVAFX_OBSERVABLE_LIST__", ",", "BCEL_CL", "}", ")", ";", "denyTypeHierarchy", "(", "InputStream", ".", "class", ")", ";", "denyTypeHierarchyDynamically", "(", "\"", "java.nio.channels.Channel", "\"", ")", ";", "denyTypeHierarchyDynamically", "(", "\"", "javax.activation.DataSource", "\"", ")", ";", "denyTypeHierarchyDynamically", "(", "\"", "javax.sql.rowset.BaseRowSet", "\"", ")", ";", "allowTypeHierarchy", "(", "Exception", ".", "class", ")", ";", "securityInitialized", "=", "false", ";", "}"], "idx": 95900, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "f0c4a8d861b68ffc3119cfbbbd632deee624e227", "function_name": "setupSecurity", "body_hash": "ca3ab0935891429821e387c83354950739486792"}
{"code": "@Override\n\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t\tif (this.jsonPrefix != null) {\n\t\t\tgenerator.writeRaw(this.jsonPrefix);\n\t\t}\n\n\t\tString jsonpFunction = null;\n\t\tif (object instanceof MappingJacksonValue) {\n\t\t\tjsonpFunction = ((MappingJacksonValue) object).getJsonpFunction();\n\t\t}\n\t\tif (jsonpFunction != null) {\n\t\t\tgenerator.writeRaw(\"/**/\");\n\t\t\tgenerator.writeRaw(jsonpFunction + \"(\");\n\t\t}\n\t}", "code_tokens": ["@", "Override", "protected", "void", "writePrefix", "(", "JsonGenerator", "generator", ",", "Object", "object", ")", "throws", "IOException", "{", "if", "(", "this", ".", "jsonPrefix", "!=", "null", ")", "{", "generator", ".", "writeRaw", "(", "this", ".", "jsonPrefix", ")", ";", "}", "String", "jsonpFunction", "=", "null", ";", "if", "(", "object", "instanceof", "MappingJacksonValue", ")", "{", "jsonpFunction", "=", "(", "(", "MappingJacksonValue", ")", "object", ")", ".", "getJsonpFunction", "(", ")", ";", "}", "if", "(", "jsonpFunction", "!=", "null", ")", "{", "generator", ".", "writeRaw", "(", "\"", "/**/", "\"", ")", ";", "generator", ".", "writeRaw", "(", "jsonpFunction", "+", "\"", "(", "\"", ")", ";", "}", "}"], "idx": 81969, "cwe": "CWE-829", "target": 1, "status": "VULNERABLE", "commit": "ac37b678a3ac9ee541a10e8ad74d612bb9ec5b88", "function_name": "writePrefix", "body_hash": "76eec8c5dd09458d4c681e79dbdd0b7c00e4d5ba"}
{"code": "@Override\n  public AccessControlList getAccessControlList(String mediaPackageId) throws NotFoundException,\n  SearchServiceDatabaseException {\n    EntityManager em = null;\n    try {\n      em = emf.createEntityManager();\n      SearchEntity entity = getSearchEntity(mediaPackageId, em);\n      if (entity == null) {\n        throw new NotFoundException(\"Could not found media package with ID \" + mediaPackageId);\n      }\n      if (entity.getAccessControl() == null) {\n        return null;\n      } else {\n        return AccessControlParser.parseAcl(entity.getAccessControl());\n      }\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not retrieve ACL {}\", mediaPackageId, e);\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n  }", "code_tokens": ["@", "Override", "public", "AccessControlList", "getAccessControlList", "(", "String", "mediaPackageId", ")", "throws", "NotFoundException", ",", "SearchServiceDatabaseException", "{", "EntityManager", "em", "=", "null", ";", "try", "{", "em", "=", "emf", ".", "createEntityManager", "(", ")", ";", "SearchEntity", "entity", "=", "getSearchEntity", "(", "mediaPackageId", ",", "em", ")", ";", "if", "(", "entity", "==", "null", ")", "{", "throw", "new", "NotFoundException", "(", "\"", "Could not found media package with ID ", "\"", "+", "mediaPackageId", ")", ";", "}", "if", "(", "entity", ".", "getAccessControl", "(", ")", "==", "null", ")", "{", "return", "null", ";", "}", "else", "{", "return", "AccessControlParser", ".", "parseAcl", "(", "entity", ".", "getAccessControl", "(", ")", ")", ";", "}", "}", "catch", "(", "NotFoundException", "e", ")", "{", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "logger", ".", "error", "(", "\"", "Could not retrieve ACL {}", "\"", ",", "mediaPackageId", ",", "e", ")", ";", "throw", "new", "SearchServiceDatabaseException", "(", "e", ")", ";", "}", "finally", "{", "em", ".", "close", "(", ")", ";", "}", "}"], "idx": 88844, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "b18c6a7f81f08ed14884592a6c14c9ab611ad450", "function_name": "getAccessControlList", "body_hash": "510007523577a225b5feef5a87fd599b4c427c04"}
{"code": "public void register(ContainerBuilder builder, LocatableProperties props) {\n        alias(ObjectFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY, builder, props);\n        alias(FileManagerFactory.class, StrutsConstants.STRUTS_FILE_MANAGER_FACTORY, builder, props, Scope.SINGLETON);\n\n        alias(XWorkConverter.class, StrutsConstants.STRUTS_XWORKCONVERTER, builder, props);\n        alias(CollectionConverter.class, StrutsConstants.STRUTS_CONVERTER_COLLECTION, builder, props);\n        alias(ArrayConverter.class, StrutsConstants.STRUTS_CONVERTER_ARRAY, builder, props);\n        alias(DateConverter.class, StrutsConstants.STRUTS_CONVERTER_DATE, builder, props);\n        alias(NumberConverter.class, StrutsConstants.STRUTS_CONVERTER_NUMBER, builder, props);\n        alias(StringConverter.class, StrutsConstants.STRUTS_CONVERTER_STRING, builder, props);\n\n        alias(ConversionPropertiesProcessor.class, StrutsConstants.STRUTS_CONVERTER_PROPERTIES_PROCESSOR, builder, props);\n        alias(ConversionFileProcessor.class, StrutsConstants.STRUTS_CONVERTER_FILE_PROCESSOR, builder, props);\n        alias(ConversionAnnotationProcessor.class, StrutsConstants.STRUTS_CONVERTER_ANNOTATION_PROCESSOR, builder, props);\n        alias(TypeConverterCreator.class, StrutsConstants.STRUTS_CONVERTER_CREATOR, builder, props);\n        alias(TypeConverterHolder.class, StrutsConstants.STRUTS_CONVERTER_HOLDER, builder, props);\n\n        alias(TextProvider.class, StrutsConstants.STRUTS_XWORKTEXTPROVIDER, builder, props, Scope.DEFAULT);\n\n        alias(LocaleProvider.class, StrutsConstants.STRUTS_LOCALE_PROVIDER, builder, props);\n        alias(ActionProxyFactory.class, StrutsConstants.STRUTS_ACTIONPROXYFACTORY, builder, props);\n        alias(ObjectTypeDeterminer.class, StrutsConstants.STRUTS_OBJECTTYPEDETERMINER, builder, props);\n        alias(ActionMapper.class, StrutsConstants.STRUTS_MAPPER_CLASS, builder, props);\n        alias(MultiPartRequest.class, StrutsConstants.STRUTS_MULTIPART_PARSER, builder, props, Scope.DEFAULT);\n        alias(FreemarkerManager.class, StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME, builder, props);\n        alias(VelocityManager.class, StrutsConstants.STRUTS_VELOCITY_MANAGER_CLASSNAME, builder, props);\n        alias(UrlRenderer.class, StrutsConstants.STRUTS_URL_RENDERER, builder, props);\n        alias(ActionValidatorManager.class, StrutsConstants.STRUTS_ACTIONVALIDATORMANAGER, builder, props);\n        alias(ValueStackFactory.class, StrutsConstants.STRUTS_VALUESTACKFACTORY, builder, props);\n        alias(ReflectionProvider.class, StrutsConstants.STRUTS_REFLECTIONPROVIDER, builder, props);\n        alias(ReflectionContextFactory.class, StrutsConstants.STRUTS_REFLECTIONCONTEXTFACTORY, builder, props);\n        alias(PatternMatcher.class, StrutsConstants.STRUTS_PATTERNMATCHER, builder, props);\n        alias(StaticContentLoader.class, StrutsConstants.STRUTS_STATIC_CONTENT_LOADER, builder, props);\n        alias(UnknownHandlerManager.class, StrutsConstants.STRUTS_UNKNOWN_HANDLER_MANAGER, builder, props);\n        alias(UrlHelper.class, StrutsConstants.STRUTS_URL_HELPER, builder, props);\n\n        alias(TextParser.class, StrutsConstants.STRUTS_EXPRESSION_PARSER, builder, props);\n\n        if (\"true\".equalsIgnoreCase(props.getProperty(StrutsConstants.STRUTS_DEVMODE))) {\n            props.setProperty(StrutsConstants.STRUTS_I18N_RELOAD, \"true\");\n            props.setProperty(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, \"true\");\n            props.setProperty(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE, \"false\");\n            props.setProperty(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE_UPDATE_DELAY, \"0\");\n            // Convert struts properties into ones that xwork expects\n            props.setProperty(XWorkConstants.DEV_MODE, \"true\");\n        } else {\n            props.setProperty(XWorkConstants.DEV_MODE, \"false\");\n        }\n\n        // Convert Struts properties into XWork properties\n        convertIfExist(props, StrutsConstants.STRUTS_LOG_MISSING_PROPERTIES, XWorkConstants.LOG_MISSING_PROPERTIES);\n        convertIfExist(props, StrutsConstants.STRUTS_ENABLE_OGNL_EXPRESSION_CACHE, XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE);\n        convertIfExist(props, StrutsConstants.STRUTS_ALLOW_STATIC_METHOD_ACCESS, XWorkConstants.ALLOW_STATIC_METHOD_ACCESS);\n        convertIfExist(props, StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, XWorkConstants.RELOAD_XML_CONFIGURATION);\n\n        LocalizedTextUtil.addDefaultResourceBundle(\"org/apache/struts2/struts-messages\");\n        loadCustomResourceBundles(props);\n    }", "code_tokens": ["public", "void", "register", "(", "ContainerBuilder", "builder", ",", "LocatableProperties", "props", ")", "{", "alias", "(", "ObjectFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_OBJECTFACTORY", ",", "builder", ",", "props", ")", ";", "alias", "(", "FileManagerFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_FILE_MANAGER_FACTORY", ",", "builder", ",", "props", ",", "Scope", ".", "SINGLETON", ")", ";", "alias", "(", "XWorkConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_XWORKCONVERTER", ",", "builder", ",", "props", ")", ";", "alias", "(", "CollectionConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_COLLECTION", ",", "builder", ",", "props", ")", ";", "alias", "(", "ArrayConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_ARRAY", ",", "builder", ",", "props", ")", ";", "alias", "(", "DateConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_DATE", ",", "builder", ",", "props", ")", ";", "alias", "(", "NumberConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_NUMBER", ",", "builder", ",", "props", ")", ";", "alias", "(", "StringConverter", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_STRING", ",", "builder", ",", "props", ")", ";", "alias", "(", "ConversionPropertiesProcessor", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_PROPERTIES_PROCESSOR", ",", "builder", ",", "props", ")", ";", "alias", "(", "ConversionFileProcessor", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_FILE_PROCESSOR", ",", "builder", ",", "props", ")", ";", "alias", "(", "ConversionAnnotationProcessor", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_ANNOTATION_PROCESSOR", ",", "builder", ",", "props", ")", ";", "alias", "(", "TypeConverterCreator", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_CREATOR", ",", "builder", ",", "props", ")", ";", "alias", "(", "TypeConverterHolder", ".", "class", ",", "StrutsConstants", ".", "STRUTS_CONVERTER_HOLDER", ",", "builder", ",", "props", ")", ";", "alias", "(", "TextProvider", ".", "class", ",", "StrutsConstants", ".", "STRUTS_XWORKTEXTPROVIDER", ",", "builder", ",", "props", ",", "Scope", ".", "DEFAULT", ")", ";", "alias", "(", "LocaleProvider", ".", "class", ",", "StrutsConstants", ".", "STRUTS_LOCALE_PROVIDER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ActionProxyFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_ACTIONPROXYFACTORY", ",", "builder", ",", "props", ")", ";", "alias", "(", "ObjectTypeDeterminer", ".", "class", ",", "StrutsConstants", ".", "STRUTS_OBJECTTYPEDETERMINER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ActionMapper", ".", "class", ",", "StrutsConstants", ".", "STRUTS_MAPPER_CLASS", ",", "builder", ",", "props", ")", ";", "alias", "(", "MultiPartRequest", ".", "class", ",", "StrutsConstants", ".", "STRUTS_MULTIPART_PARSER", ",", "builder", ",", "props", ",", "Scope", ".", "DEFAULT", ")", ";", "alias", "(", "FreemarkerManager", ".", "class", ",", "StrutsConstants", ".", "STRUTS_FREEMARKER_MANAGER_CLASSNAME", ",", "builder", ",", "props", ")", ";", "alias", "(", "VelocityManager", ".", "class", ",", "StrutsConstants", ".", "STRUTS_VELOCITY_MANAGER_CLASSNAME", ",", "builder", ",", "props", ")", ";", "alias", "(", "UrlRenderer", ".", "class", ",", "StrutsConstants", ".", "STRUTS_URL_RENDERER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ActionValidatorManager", ".", "class", ",", "StrutsConstants", ".", "STRUTS_ACTIONVALIDATORMANAGER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ValueStackFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_VALUESTACKFACTORY", ",", "builder", ",", "props", ")", ";", "alias", "(", "ReflectionProvider", ".", "class", ",", "StrutsConstants", ".", "STRUTS_REFLECTIONPROVIDER", ",", "builder", ",", "props", ")", ";", "alias", "(", "ReflectionContextFactory", ".", "class", ",", "StrutsConstants", ".", "STRUTS_REFLECTIONCONTEXTFACTORY", ",", "builder", ",", "props", ")", ";", "alias", "(", "PatternMatcher", ".", "class", ",", "StrutsConstants", ".", "STRUTS_PATTERNMATCHER", ",", "builder", ",", "props", ")", ";", "alias", "(", "StaticContentLoader", ".", "class", ",", "StrutsConstants", ".", "STRUTS_STATIC_CONTENT_LOADER", ",", "builder", ",", "props", ")", ";", "alias", "(", "UnknownHandlerManager", ".", "class", ",", "StrutsConstants", ".", "STRUTS_UNKNOWN_HANDLER_MANAGER", ",", "builder", ",", "props", ")", ";", "alias", "(", "UrlHelper", ".", "class", ",", "StrutsConstants", ".", "STRUTS_URL_HELPER", ",", "builder", ",", "props", ")", ";", "alias", "(", "TextParser", ".", "class", ",", "StrutsConstants", ".", "STRUTS_EXPRESSION_PARSER", ",", "builder", ",", "props", ")", ";", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "props", ".", "getProperty", "(", "StrutsConstants", ".", "STRUTS_DEVMODE", ")", ")", ")", "{", "props", ".", "setProperty", "(", "StrutsConstants", ".", "STRUTS_I18N_RELOAD", ",", "\"", "true", "\"", ")", ";", "props", ".", "setProperty", "(", "StrutsConstants", ".", "STRUTS_CONFIGURATION_XML_RELOAD", ",", "\"", "true", "\"", ")", ";", "props", ".", "setProperty", "(", "StrutsConstants", ".", "STRUTS_FREEMARKER_TEMPLATES_CACHE", ",", "\"", "false", "\"", ")", ";", "props", ".", "setProperty", "(", "StrutsConstants", ".", "STRUTS_FREEMARKER_TEMPLATES_CACHE_UPDATE_DELAY", ",", "\"", "0", "\"", ")", ";", "props", ".", "setProperty", "(", "XWorkConstants", ".", "DEV_MODE", ",", "\"", "true", "\"", ")", ";", "}", "else", "{", "props", ".", "setProperty", "(", "XWorkConstants", ".", "DEV_MODE", ",", "\"", "false", "\"", ")", ";", "}", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_LOG_MISSING_PROPERTIES", ",", "XWorkConstants", ".", "LOG_MISSING_PROPERTIES", ")", ";", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_ENABLE_OGNL_EXPRESSION_CACHE", ",", "XWorkConstants", ".", "ENABLE_OGNL_EXPRESSION_CACHE", ")", ";", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_ALLOW_STATIC_METHOD_ACCESS", ",", "XWorkConstants", ".", "ALLOW_STATIC_METHOD_ACCESS", ")", ";", "convertIfExist", "(", "props", ",", "StrutsConstants", ".", "STRUTS_CONFIGURATION_XML_RELOAD", ",", "XWorkConstants", ".", "RELOAD_XML_CONFIGURATION", ")", ";", "LocalizedTextUtil", ".", "addDefaultResourceBundle", "(", "\"", "org/apache/struts2/struts-messages", "\"", ")", ";", "loadCustomResourceBundles", "(", "props", ")", ";", "}"], "idx": 95029, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "7e6f641ebb142663cbd1653dc49bed725edf7f56", "function_name": "register", "body_hash": "3a57deeeb93d320b97177d645939022908f5398b"}
{"code": "protected void prepareRequest() throws IOException {\n\n        http11 = true;\n        http09 = false;\n        contentDelimitation = false;\n        expectation = false;\n\n        prepareRequestInternal();\n\n        if (endpoint.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n        MessageBytes protocolMB = request.protocol();\n        if (protocolMB.equals(Constants.HTTP_11)) {\n            http11 = true;\n            protocolMB.setString(Constants.HTTP_11);\n        } else if (protocolMB.equals(Constants.HTTP_10)) {\n            http11 = false;\n            keepAlive = false;\n            protocolMB.setString(Constants.HTTP_10);\n        } else if (protocolMB.equals(\"\")) {\n            // HTTP/0.9\n            http09 = true;\n            http11 = false;\n            keepAlive = false;\n        } else {\n            // Unsupported protocol\n            http11 = false;\n            // Send 505; Unsupported HTTP version\n            response.setStatus(505);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n            }\n        }\n\n        MessageBytes methodMB = request.method();\n        if (methodMB.equals(Constants.GET)) {\n            methodMB.setString(Constants.GET);\n        } else if (methodMB.equals(Constants.POST)) {\n            methodMB.setString(Constants.POST);\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<String>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEPALIVE)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    getInputBuffer().setSwallowInput(false);\n                    expectation = true;\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        if ((restrictedUserAgents != null) && ((http11) || (keepAlive))) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        // Check host header\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            // Multiple Host headers are not permitted\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        // Check for an absolute-URI less the query string which has already\n        // been removed during the parsing of the request line\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            // Check for https\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            // Next 3 characters must be \"://\"\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                // '/' does not appear in the authority so use the first\n                // instance to split the authority and the path segments\n                int slashPos = uriBC.indexOf('/', pos);\n                // '@' in the authority delimits the userinfo\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    // First '@' is in the path segments so no userinfo\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\". Use 6 as it will always be a '/'.\n                    // 01234567\n                    // http://\n                    // https://\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                // Skip any user info\n                if (atPos != -1) {\n                    // Validate the userinfo\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            // Strictly there needs to be a check for valid %nn\n                            // encoding here but skip it since it will never be\n                            // decoded because the userinfo is ignored\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    // Skip the '@'\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    // Missing host header is illegal but handled above\n                    if (hostValueMB != null) {\n                        // Any host in the request line must be consistent with\n                        // the Host header\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (allowHostHeaderMismatch) {\n                                // The requirements of RFC 2616 are being\n                                // applied. If the host header and the request\n                                // line do not agree, the request line takes\n                                // precedence\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                // The requirements of RFC 7230 are being\n                                // applied. If the host header and the request\n                                // line do not agree, trigger a 400 response.\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    // Not HTTP/1.1 - no Host header so generate one since\n                    // Tomcat internals assume it is set\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                        // Edge case\n                        // If the request has too many headers it won't be\n                        // possible to create the host header. Ignore this as\n                        // processing won't reach the point where the Tomcat\n                        // internals expect there to be a host header.\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        // Validate the characters in the URI. %nn decoding will be checked at\n        // the point of decoding.\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = getInputBuffer().getFilters();\n\n        // Parse transfer-encoding header\n        MessageBytes transferEncodingValueMB = null;\n        if (http11) {\n            transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n        }\n        if (transferEncodingValueMB != null) {\n            List<String> encodingNames = new ArrayList<String>();\n            TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames);\n            for (String encodingName : encodingNames) {\n                // \"identity\" codings are ignored\n                addInputFilter(inputFilters, encodingName);\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n            } else {\n                getInputBuffer().addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        // Validate host name and extract port if present\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            getInputBuffer().addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        // Advertise sendfile support through a request attribute\n        if (endpoint.getUseSendfile()) {\n            request.setAttribute(\n                    org.apache.coyote.Constants.SENDFILE_SUPPORTED_ATTR,\n                    Boolean.TRUE);\n        }\n\n        // Advertise comet support through a request attribute\n        if (endpoint.getUseComet()) {\n            request.setAttribute(\n                    org.apache.coyote.Constants.COMET_SUPPORTED_ATTR,\n                    Boolean.TRUE);\n        }\n        // Advertise comet timeout support\n        if (endpoint.getUseCometTimeout()) {\n            request.setAttribute(\n                    org.apache.coyote.Constants.COMET_TIMEOUT_SUPPORTED_ATTR,\n                    Boolean.TRUE);\n        }\n        if (getErrorState().isError()) {\n            adapter.log(request, response, 0);\n        }\n    }", "code_tokens": ["protected", "void", "prepareRequest", "(", ")", "throws", "IOException", "{", "http11", "=", "true", ";", "http09", "=", "false", ";", "contentDelimitation", "=", "false", ";", "expectation", "=", "false", ";", "prepareRequestInternal", "(", ")", ";", "if", "(", "endpoint", ".", "isSSLEnabled", "(", ")", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MessageBytes", "protocolMB", "=", "request", ".", "protocol", "(", ")", ";", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_11", ")", ")", "{", "http11", "=", "true", ";", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_11", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "Constants", ".", "HTTP_10", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "protocolMB", ".", "setString", "(", "Constants", ".", "HTTP_10", ")", ";", "}", "else", "if", "(", "protocolMB", ".", "equals", "(", "\"", "\"", ")", ")", "{", "http09", "=", "true", ";", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "else", "{", "http11", "=", "false", ";", "response", ".", "setStatus", "(", "505", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Unsupported HTTP version ", "\\\"", "\"", "+", "protocolMB", "+", "\"", "\\\"", "\"", ")", ";", "}", "}", "MessageBytes", "methodMB", "=", "request", ".", "method", "(", ")", ";", "if", "(", "methodMB", ".", "equals", "(", "Constants", ".", "GET", ")", ")", "{", "methodMB", ".", "setString", "(", "Constants", ".", "GET", ")", ";", "}", "else", "if", "(", "methodMB", ".", "equals", "(", "Constants", ".", "POST", ")", ")", "{", "methodMB", ".", "setString", "(", "Constants", ".", "POST", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "MessageBytes", "connectionValueMB", "=", "headers", ".", "getValue", "(", "Constants", ".", "CONNECTION", ")", ";", "if", "(", "connectionValueMB", "!=", "null", "&&", "!", "connectionValueMB", ".", "isNull", "(", ")", ")", "{", "Set", "<", "String", ">", "tokens", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "Constants", ".", "CONNECTION", ")", ",", "tokens", ")", ";", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "CLOSE", ")", ")", "{", "keepAlive", "=", "false", ";", "}", "else", "if", "(", "tokens", ".", "contains", "(", "Constants", ".", "KEEPALIVE", ")", ")", "{", "keepAlive", "=", "true", ";", "}", "}", "if", "(", "http11", ")", "{", "MessageBytes", "expectMB", "=", "headers", ".", "getValue", "(", "\"", "expect", "\"", ")", ";", "if", "(", "expectMB", "!=", "null", "&&", "!", "expectMB", ".", "isNull", "(", ")", ")", "{", "if", "(", "expectMB", ".", "toString", "(", ")", ".", "trim", "(", ")", ".", "equalsIgnoreCase", "(", "\"", "100-continue", "\"", ")", ")", "{", "getInputBuffer", "(", ")", ".", "setSwallowInput", "(", "false", ")", ";", "expectation", "=", "true", ";", "}", "else", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_EXPECTATION_FAILED", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "if", "(", "(", "restrictedUserAgents", "!=", "null", ")", "&&", "(", "(", "http11", ")", "||", "(", "keepAlive", ")", ")", ")", "{", "MessageBytes", "userAgentValueMB", "=", "headers", ".", "getValue", "(", "\"", "user-agent", "\"", ")", ";", "if", "(", "userAgentValueMB", "!=", "null", "&&", "!", "userAgentValueMB", ".", "isNull", "(", ")", ")", "{", "String", "userAgentValue", "=", "userAgentValueMB", ".", "toString", "(", ")", ";", "if", "(", "restrictedUserAgents", ".", "matcher", "(", "userAgentValue", ")", ".", "matches", "(", ")", ")", "{", "http11", "=", "false", ";", "keepAlive", "=", "false", ";", "}", "}", "}", "MessageBytes", "hostValueMB", "=", "null", ";", "try", "{", "hostValueMB", "=", "headers", ".", "getUniqueValue", "(", "\"", "host", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleHosts", "\"", ")", ";", "}", "if", "(", "http11", "&&", "hostValueMB", "==", "null", ")", "{", "badRequest", "(", "\"", "http11processor.request.noHostHeader", "\"", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "4", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "s", "\"", ",", "pos", ")", ")", "{", "pos", "++", ";", "}", "if", "(", "uriBC", ".", "startsWith", "(", "\"", "://", "\"", ",", "pos", ")", ")", "{", "pos", "+=", "3", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", ")", ";", "int", "atPos", "=", "uriBC", ".", "indexOf", "(", "'@'", ",", "pos", ")", ";", "if", "(", "slashPos", ">", "-", "1", "&&", "atPos", ">", "slashPos", ")", "{", "atPos", "=", "-", "1", ";", "}", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "6", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "if", "(", "atPos", "!=", "-", "1", ")", "{", "for", "(", ";", "pos", "<", "atPos", ";", "pos", "++", ")", "{", "byte", "c", "=", "uriB", "[", "uriBCStart", "+", "pos", "]", ";", "if", "(", "!", "HttpParser", ".", "isUserInfo", "(", "c", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUserInfo", "\"", ")", ";", "break", ";", "}", "}", "pos", "=", "atPos", "+", "1", ";", "}", "if", "(", "http11", ")", "{", "if", "(", "hostValueMB", "!=", "null", ")", "{", "if", "(", "!", "hostValueMB", ".", "getByteChunk", "(", ")", ".", "equals", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ")", "{", "if", "(", "allowHostHeaderMismatch", ")", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.inconsistentHosts", "\"", ")", ";", "}", "}", "}", "}", "else", "{", "try", "{", "hostValueMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostValueMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", ",", "slashPos", "-", "pos", ")", ";", "}", "catch", "(", "IllegalStateException", "e", ")", "{", "}", "}", "}", "else", "{", "badRequest", "(", "\"", "http11processor.request.invalidScheme", "\"", ")", ";", "}", "}", "for", "(", "int", "i", "=", "uriBC", ".", "getStart", "(", ")", ";", "i", "<", "uriBC", ".", "getEnd", "(", ")", ";", "i", "++", ")", "{", "if", "(", "!", "httpParser", ".", "isAbsolutePathRelaxed", "(", "uriB", "[", "i", "]", ")", ")", "{", "badRequest", "(", "\"", "http11processor.request.invalidUri", "\"", ")", ";", "break", ";", "}", "}", "InputFilter", "[", "]", "inputFilters", "=", "getInputBuffer", "(", ")", ".", "getFilters", "(", ")", ";", "MessageBytes", "transferEncodingValueMB", "=", "null", ";", "if", "(", "http11", ")", "{", "transferEncodingValueMB", "=", "headers", ".", "getValue", "(", "\"", "transfer-encoding", "\"", ")", ";", "}", "if", "(", "transferEncodingValueMB", "!=", "null", ")", "{", "List", "<", "String", ">", "encodingNames", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "TokenList", ".", "parseTokenList", "(", "headers", ".", "values", "(", "\"", "transfer-encoding", "\"", ")", ",", "encodingNames", ")", ";", "for", "(", "String", "encodingName", ":", "encodingNames", ")", "{", "addInputFilter", "(", "inputFilters", ",", "encodingName", ")", ";", "}", "}", "long", "contentLength", "=", "-", "1", ";", "try", "{", "contentLength", "=", "request", ".", "getContentLengthLong", "(", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.nonNumericContentLength", "\"", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "badRequest", "(", "\"", "http11processor.request.multipleContentLength", "\"", ")", ";", "}", "if", "(", "contentLength", ">=", "0", ")", "{", "if", "(", "contentDelimitation", ")", "{", "headers", ".", "removeHeader", "(", "\"", "content-length", "\"", ")", ";", "request", ".", "setContentLength", "(", "-", "1", ")", ";", "}", "else", "{", "getInputBuffer", "(", ")", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "IDENTITY_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "}", "parseHost", "(", "hostValueMB", ")", ";", "if", "(", "!", "contentDelimitation", ")", "{", "getInputBuffer", "(", ")", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "VOID_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "if", "(", "endpoint", ".", "getUseSendfile", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "org", ".", "apache", ".", "coyote", ".", "Constants", ".", "SENDFILE_SUPPORTED_ATTR", ",", "Boolean", ".", "TRUE", ")", ";", "}", "if", "(", "endpoint", ".", "getUseComet", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "org", ".", "apache", ".", "coyote", ".", "Constants", ".", "COMET_SUPPORTED_ATTR", ",", "Boolean", ".", "TRUE", ")", ";", "}", "if", "(", "endpoint", ".", "getUseCometTimeout", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "org", ".", "apache", ".", "coyote", ".", "Constants", ".", "COMET_TIMEOUT_SUPPORTED_ATTR", ",", "Boolean", ".", "TRUE", ")", ";", "}", "if", "(", "getErrorState", "(", ")", ".", "isError", "(", ")", ")", "{", "adapter", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 55732, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "b191a0d", "function_name": "prepareRequest", "body_hash": "4ed56b039b933e92d4ce92df95f4b764c49b0c4a"}
{"code": "public FormValidation doCheckCommand(@QueryParameter String value) {\n            if (!Jenkins.getInstance().hasPermission(Jenkins.RUN_SCRIPTS)) {\n                return FormValidation.warning(Messages.CommandLauncher_cannot_be_configured_by_non_administrato());\n            }\n            if(Util.fixEmptyAndTrim(value)==null)\n                return FormValidation.error(Messages.CommandLauncher_NoLaunchCommand());\n            else\n                return FormValidation.ok();\n        }", "code_tokens": ["public", "FormValidation", "doCheckCommand", "(", "@", "QueryParameter", "String", "value", ")", "{", "if", "(", "!", "Jenkins", ".", "getInstance", "(", ")", ".", "hasPermission", "(", "Jenkins", ".", "RUN_SCRIPTS", ")", ")", "{", "return", "FormValidation", ".", "warning", "(", "Messages", ".", "CommandLauncher_cannot_be_configured_by_non_administrato", "(", ")", ")", ";", "}", "if", "(", "Util", ".", "fixEmptyAndTrim", "(", "value", ")", "==", "null", ")", "return", "FormValidation", ".", "error", "(", "Messages", ".", "CommandLauncher_NoLaunchCommand", "(", ")", ")", ";", "else", "return", "FormValidation", ".", "ok", "(", ")", ";", "}"], "idx": 76677, "cwe": "CWE-78", "target": 0, "status": "FIXED", "commit": "d7ea3f40efedd50541a57b943d5f7bbed046d091", "function_name": "doCheckCommand", "body_hash": "0dbb6d6b36d39f337bc7135703ae6804a2c2b2ac"}
{"code": "protected Object readResolve()\n        throws ObjectStreamException {\n        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);\n        if (factory != null)\n            return factory;\n\n        // reset these transient fields to empty values\n        _transactional = new ConcurrentHashMap<Object,Collection<Broker>>();\n        _brokers = newBrokerSet();\n        \n        // turn off logging while de-serializing BrokerFactory\n        String saveLogConfig = _conf.getLog();\n        _conf.setLog(\"none\");\n        makeReadOnly();\n        // re-enable any logging which was in effect\n        _conf.setLog(saveLogConfig);  \n        \n        return this;\n    }", "code_tokens": ["protected", "Object", "readResolve", "(", ")", "throws", "ObjectStreamException", "{", "AbstractBrokerFactory", "factory", "=", "getPooledFactoryForKey", "(", "_poolKey", ")", ";", "if", "(", "factory", "!=", "null", ")", "return", "factory", ";", "_transactional", "=", "new", "ConcurrentHashMap", "<", "Object", ",", "Collection", "<", "Broker", ">", ">", "(", ")", ";", "_brokers", "=", "newBrokerSet", "(", ")", ";", "String", "saveLogConfig", "=", "_conf", ".", "getLog", "(", ")", ";", "_conf", ".", "setLog", "(", "\"", "none", "\"", ")", ";", "makeReadOnly", "(", ")", ";", "_conf", ".", "setLog", "(", "saveLogConfig", ")", ";", "return", "this", ";", "}"], "idx": 33050, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "4487017fbf57fb7aed4024e0991850bb89fc1c43", "function_name": "readResolve", "body_hash": "8f41d84dfe10819adab35d3e9b6b11ebb581619d"}
{"code": "@Override\n        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.process\",\n                        wrapper.getSocket(), status));\n            }\n            if (wrapper == null) {\n                // Nothing to do. Socket has been closed.\n                return SocketState.CLOSED;\n            }\n\n            S socket = wrapper.getSocket();\n\n            Processor processor = (Processor) wrapper.getCurrentProcessor();\n            if (getLog().isDebugEnabled()) {\n                getLog().debug(sm.getString(\"abstractConnectionHandler.connectionsGet\",\n                        processor, socket));\n            }\n\n            // Timeouts are calculated on a dedicated thread and then\n            // dispatched. Because of delays in the dispatch process, the\n            // timeout may no longer be required. Check here and avoid\n            // unnecessary processing.\n            if (SocketEvent.TIMEOUT == status &&\n                    (processor == null ||\n                    !processor.isAsync() && !processor.isUpgrade() ||\n                    processor.isAsync() && !processor.checkAsyncTimeoutGeneration())) {\n                // This is effectively a NO-OP\n                return SocketState.OPEN;\n            }\n\n            if (processor != null) {\n                // Make sure an async timeout doesn't fire\n                getProtocol().removeWaitingProcessor(processor);\n            } else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) {\n                // Nothing to do. Endpoint requested a close and there is no\n                // longer a processor associated with this socket.\n                return SocketState.CLOSED;\n            }\n\n            ContainerThreadMarker.set();\n\n            try {\n                if (processor == null) {\n                    String negotiatedProtocol = wrapper.getNegotiatedProtocol();\n                    // OpenSSL typically returns null whereas JSSE typically\n                    // returns \"\" when no protocol is negotiated\n                    if (negotiatedProtocol != null && negotiatedProtocol.length() > 0) {\n                        UpgradeProtocol upgradeProtocol = getProtocol().getNegotiatedProtocol(negotiatedProtocol);\n                        if (upgradeProtocol != null) {\n                            processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                            }\n                        } else if (negotiatedProtocol.equals(\"http/1.1\")) {\n                            // Explicitly negotiated the default protocol.\n                            // Obtain a processor below.\n                        } else {\n                            // TODO:\n                            // OpenSSL 1.0.2's ALPN callback doesn't support\n                            // failing the handshake with an error if no\n                            // protocol can be negotiated. Therefore, we need to\n                            // fail the connection here. Once this is fixed,\n                            // replace the code below with the commented out\n                            // block.\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        negotiatedProtocol));\n                            }\n                            return SocketState.CLOSED;\n                            /*\n                             * To replace the code above once OpenSSL 1.1.0 is\n                             * used.\n                            // Failed to create processor. This is a bug.\n                            throw new IllegalStateException(sm.getString(\n                                    \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                    negotiatedProtocol));\n                            */\n                        }\n                    }\n                }\n                if (processor == null) {\n                    processor = recycledProcessors.pop();\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorPop\", processor));\n                    }\n                }\n                if (processor == null) {\n                    processor = getProtocol().createProcessor();\n                    register(processor);\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                    }\n                }\n\n                processor.setSslSupport(\n                        wrapper.getSslSupport(getProtocol().getClientCertProvider()));\n\n                // Associate the processor with the connection\n                wrapper.setCurrentProcessor(processor);\n\n                SocketState state = SocketState.CLOSED;\n                do {\n                    state = processor.process(wrapper, status);\n\n                    if (state == SocketState.UPGRADING) {\n                        // Get the HTTP upgrade handler\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        // Retrieve leftover input\n                        ByteBuffer leftOverInput = processor.getLeftoverInput();\n                        if (upgradeToken == null) {\n                            // Assume direct HTTP/2 connection\n                            UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(\"h2c\");\n                            if (upgradeProtocol != null) {\n                                // Release the Http11 processor to be re-used\n                                release(processor);\n                                // Create the upgrade processor\n                                processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                                wrapper.unRead(leftOverInput);\n                                // Associate with the processor with the connection\n                                wrapper.setCurrentProcessor(processor);\n                            } else {\n                                if (getLog().isDebugEnabled()) {\n                                    getLog().debug(sm.getString(\n                                        \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                        \"h2c\"));\n                                }\n                                // Exit loop and trigger appropriate clean-up\n                                state = SocketState.CLOSED;\n                            }\n                        } else {\n                            HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                            // Release the Http11 processor to be re-used\n                            release(processor);\n                            // Create the upgrade processor\n                            processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);\n                            if (getLog().isDebugEnabled()) {\n                                getLog().debug(sm.getString(\"abstractConnectionHandler.upgradeCreate\",\n                                        processor, wrapper));\n                            }\n                            wrapper.unRead(leftOverInput);\n                            // Associate with the processor with the connection\n                            wrapper.setCurrentProcessor(processor);\n                            // Initialise the upgrade handler (which may trigger\n                            // some IO using the new protocol which is why the lines\n                            // above are necessary)\n                            // This cast should be safe. If it fails the error\n                            // handling for the surrounding try/catch will deal with\n                            // it.\n                            if (upgradeToken.getInstanceManager() == null) {\n                                httpUpgradeHandler.init((WebConnection) processor);\n                            } else {\n                                ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                                try {\n                                    httpUpgradeHandler.init((WebConnection) processor);\n                                } finally {\n                                    upgradeToken.getContextBind().unbind(false, oldCL);\n                                }\n                            }\n                            if (httpUpgradeHandler instanceof InternalHttpUpgradeHandler) {\n                                if (((InternalHttpUpgradeHandler) httpUpgradeHandler).hasAsyncIO()) {\n                                    // The handler will initiate all further I/O\n                                    state = SocketState.UPGRADED;\n                                }\n                            }\n                        }\n                    }\n                } while ( state == SocketState.UPGRADING);\n\n                if (state == SocketState.LONG) {\n                    // In the middle of processing a request/response. Keep the\n                    // socket associated with the processor. Exact requirements\n                    // depend on type of long poll\n                    longPoll(wrapper, processor);\n                    if (processor.isAsync()) {\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.OPEN) {\n                    // In keep-alive but between requests. OK to recycle\n                    // processor. Continue to poll for the next request.\n                    wrapper.setCurrentProcessor(null);\n                    release(processor);\n                    wrapper.registerReadInterest();\n                } else if (state == SocketState.SENDFILE) {\n                    // Sendfile in progress. If it fails, the socket will be\n                    // closed. If it works, the socket either be added to the\n                    // poller (or equivalent) to await more data or processed\n                    // if there are any pipe-lined requests remaining.\n                } else if (state == SocketState.UPGRADED) {\n                    // Don't add sockets back to the poller if this was a\n                    // non-blocking write otherwise the poller may trigger\n                    // multiple read events which may lead to thread starvation\n                    // in the connector. The write() method will add this socket\n                    // to the poller if necessary.\n                    if (status != SocketEvent.OPEN_WRITE) {\n                        longPoll(wrapper, processor);\n                        getProtocol().addWaitingProcessor(processor);\n                    }\n                } else if (state == SocketState.SUSPENDED) {\n                    // Don't add sockets back to the poller.\n                    // The resumeProcessing() method will add this socket\n                    // to the poller.\n                } else {\n                    // Connection closed. OK to recycle the processor.\n                    // Processors handling upgrades require additional clean-up\n                    // before release.\n                    wrapper.setCurrentProcessor(null);\n                    if (processor.isUpgrade()) {\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                        InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                        if (instanceManager == null) {\n                            httpUpgradeHandler.destroy();\n                        } else {\n                            ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                            try {\n                                httpUpgradeHandler.destroy();\n                            } finally {\n                                try {\n                                    instanceManager.destroyInstance(httpUpgradeHandler);\n                                } catch (Throwable e) {\n                                    ExceptionUtils.handleThrowable(e);\n                                    getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n                                }\n                                upgradeToken.getContextBind().unbind(false, oldCL);\n                            }\n                        }\n                    }\n                    release(processor);\n                }\n                return state;\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.ioexception.debug\"), e);\n            } catch (ProtocolException e) {\n                // Protocol exceptions normally mean the client sent invalid or\n                // incomplete data.\n                getLog().debug(sm.getString(\n                        \"abstractConnectionHandler.protocolexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (OutOfMemoryError oome) {\n                // Try and handle this here to give Tomcat a chance to close the\n                // connection and prevent clients waiting until they time out.\n                // Worst case, it isn't recoverable and the attempt at logging\n                // will trigger another OOME.\n                getLog().error(sm.getString(\"abstractConnectionHandler.oome\"), oome);\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n            } finally {\n                ContainerThreadMarker.clear();\n            }\n\n            // Make sure socket/processor is removed from the list of current\n            // connections\n            wrapper.setCurrentProcessor(null);\n            release(processor);\n            return SocketState.CLOSED;\n        }", "code_tokens": ["@", "Override", "public", "SocketState", "process", "(", "SocketWrapperBase", "<", "S", ">", "wrapper", ",", "SocketEvent", "status", ")", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.process", "\"", ",", "wrapper", ".", "getSocket", "(", ")", ",", "status", ")", ")", ";", "}", "if", "(", "wrapper", "==", "null", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "S", "socket", "=", "wrapper", ".", "getSocket", "(", ")", ";", "Processor", "processor", "=", "(", "Processor", ")", "wrapper", ".", "getCurrentProcessor", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.connectionsGet", "\"", ",", "processor", ",", "socket", ")", ")", ";", "}", "if", "(", "SocketEvent", ".", "TIMEOUT", "==", "status", "&&", "(", "processor", "==", "null", "||", "!", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "isUpgrade", "(", ")", "||", "processor", ".", "isAsync", "(", ")", "&&", "!", "processor", ".", "checkAsyncTimeoutGeneration", "(", ")", ")", ")", "{", "return", "SocketState", ".", "OPEN", ";", "}", "if", "(", "processor", "!=", "null", ")", "{", "getProtocol", "(", ")", ".", "removeWaitingProcessor", "(", "processor", ")", ";", "}", "else", "if", "(", "status", "==", "SocketEvent", ".", "DISCONNECT", "||", "status", "==", "SocketEvent", ".", "ERROR", ")", "{", "return", "SocketState", ".", "CLOSED", ";", "}", "ContainerThreadMarker", ".", "set", "(", ")", ";", "try", "{", "if", "(", "processor", "==", "null", ")", "{", "String", "negotiatedProtocol", "=", "wrapper", ".", "getNegotiatedProtocol", "(", ")", ";", "if", "(", "negotiatedProtocol", "!=", "null", "&&", "negotiatedProtocol", ".", "length", "(", ")", ">", "0", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getNegotiatedProtocol", "(", "negotiatedProtocol", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "else", "if", "(", "negotiatedProtocol", ".", "equals", "(", "\"", "http/1.1", "\"", ")", ")", "{", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "negotiatedProtocol", ")", ")", ";", "}", "return", "SocketState", ".", "CLOSED", ";", "}", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "recycledProcessors", ".", "pop", "(", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorPop", "\"", ",", "processor", ")", ")", ";", "}", "}", "if", "(", "processor", "==", "null", ")", "{", "processor", "=", "getProtocol", "(", ")", ".", "createProcessor", "(", ")", ";", "register", "(", "processor", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.processorCreate", "\"", ",", "processor", ")", ")", ";", "}", "}", "processor", ".", "setSslSupport", "(", "wrapper", ".", "getSslSupport", "(", "getProtocol", "(", ")", ".", "getClientCertProvider", "(", ")", ")", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "SocketState", "state", "=", "SocketState", ".", "CLOSED", ";", "do", "{", "state", "=", "processor", ".", "process", "(", "wrapper", ",", "status", ")", ";", "if", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "ByteBuffer", "leftOverInput", "=", "processor", ".", "getLeftoverInput", "(", ")", ";", "if", "(", "upgradeToken", "==", "null", ")", "{", "UpgradeProtocol", "upgradeProtocol", "=", "getProtocol", "(", ")", ".", "getUpgradeProtocol", "(", "\"", "h2c", "\"", ")", ";", "if", "(", "upgradeProtocol", "!=", "null", ")", "{", "release", "(", "processor", ")", ";", "processor", "=", "upgradeProtocol", ".", "getProcessor", "(", "wrapper", ",", "getProtocol", "(", ")", ".", "getAdapter", "(", ")", ")", ";", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "}", "else", "{", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.negotiatedProcessor.fail", "\"", ",", "\"", "h2c", "\"", ")", ")", ";", "}", "state", "=", "SocketState", ".", "CLOSED", ";", "}", "}", "else", "{", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "release", "(", "processor", ")", ";", "processor", "=", "getProtocol", "(", ")", ".", "createUpgradeProcessor", "(", "wrapper", ",", "upgradeToken", ")", ";", "if", "(", "getLog", "(", ")", ".", "isDebugEnabled", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.upgradeCreate", "\"", ",", "processor", ",", "wrapper", ")", ")", ";", "}", "wrapper", ".", "unRead", "(", "leftOverInput", ")", ";", "wrapper", ".", "setCurrentProcessor", "(", "processor", ")", ";", "if", "(", "upgradeToken", ".", "getInstanceManager", "(", ")", "==", "null", ")", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "init", "(", "(", "WebConnection", ")", "processor", ")", ";", "}", "finally", "{", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "if", "(", "httpUpgradeHandler", "instanceof", "InternalHttpUpgradeHandler", ")", "{", "if", "(", "(", "(", "InternalHttpUpgradeHandler", ")", "httpUpgradeHandler", ")", ".", "hasAsyncIO", "(", ")", ")", "{", "state", "=", "SocketState", ".", "UPGRADED", ";", "}", "}", "}", "}", "}", "while", "(", "state", "==", "SocketState", ".", "UPGRADING", ")", ";", "if", "(", "state", "==", "SocketState", ".", "LONG", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "if", "(", "processor", ".", "isAsync", "(", ")", ")", "{", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "OPEN", ")", "{", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "release", "(", "processor", ")", ";", "wrapper", ".", "registerReadInterest", "(", ")", ";", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SENDFILE", ")", "{", "}", "else", "if", "(", "state", "==", "SocketState", ".", "UPGRADED", ")", "{", "if", "(", "status", "!=", "SocketEvent", ".", "OPEN_WRITE", ")", "{", "longPoll", "(", "wrapper", ",", "processor", ")", ";", "getProtocol", "(", ")", ".", "addWaitingProcessor", "(", "processor", ")", ";", "}", "}", "else", "if", "(", "state", "==", "SocketState", ".", "SUSPENDED", ")", "{", "}", "else", "{", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "if", "(", "processor", ".", "isUpgrade", "(", ")", ")", "{", "UpgradeToken", "upgradeToken", "=", "processor", ".", "getUpgradeToken", "(", ")", ";", "HttpUpgradeHandler", "httpUpgradeHandler", "=", "upgradeToken", ".", "getHttpUpgradeHandler", "(", ")", ";", "InstanceManager", "instanceManager", "=", "upgradeToken", ".", "getInstanceManager", "(", ")", ";", "if", "(", "instanceManager", "==", "null", ")", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "else", "{", "ClassLoader", "oldCL", "=", "upgradeToken", ".", "getContextBind", "(", ")", ".", "bind", "(", "false", ",", "null", ")", ";", "try", "{", "httpUpgradeHandler", ".", "destroy", "(", ")", ";", "}", "finally", "{", "try", "{", "instanceManager", ".", "destroyInstance", "(", "httpUpgradeHandler", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "upgradeToken", ".", "getContextBind", "(", ")", ".", "unbind", "(", "false", ",", "oldCL", ")", ";", "}", "}", "}", "release", "(", "processor", ")", ";", "}", "return", "state", ";", "}", "catch", "(", "java", ".", "net", ".", "SocketException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.socketexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "java", ".", "io", ".", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.ioexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "ProtocolException", "e", ")", "{", "getLog", "(", ")", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.protocolexception.debug", "\"", ")", ",", "e", ")", ";", "}", "catch", "(", "OutOfMemoryError", "oome", ")", "{", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.oome", "\"", ")", ",", "oome", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "ExceptionUtils", ".", "handleThrowable", "(", "e", ")", ";", "getLog", "(", ")", ".", "error", "(", "sm", ".", "getString", "(", "\"", "abstractConnectionHandler.error", "\"", ")", ",", "e", ")", ";", "}", "finally", "{", "ContainerThreadMarker", ".", "clear", "(", ")", ";", "}", "wrapper", ".", "setCurrentProcessor", "(", "null", ")", ";", "release", "(", "processor", ")", ";", "return", "SocketState", ".", "CLOSED", ";", "}"], "idx": 17641, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "dd757c0a893e2e35f8bc1385d6967221ae8b9b9b", "function_name": "process", "body_hash": "16f8aa0e01990106404234536707c9b36b25e131"}
{"code": "private void checkRestrictedClass(Object o, Object method) {\n    if (\n      o instanceof Class ||\n      o instanceof ClassLoader ||\n      o instanceof Thread ||\n      o instanceof Method\n    ) {\n      throw new MethodNotFoundException(\n        \"Cannot find method '\" + method + \"' in \" + o.getClass()\n      );\n    }\n  }", "code_tokens": ["private", "void", "checkRestrictedClass", "(", "Object", "o", ",", "Object", "method", ")", "{", "if", "(", "o", "instanceof", "Class", "||", "o", "instanceof", "ClassLoader", "||", "o", "instanceof", "Thread", "||", "o", "instanceof", "Method", ")", "{", "throw", "new", "MethodNotFoundException", "(", "\"", "Cannot find method '", "\"", "+", "method", "+", "\"", "' in ", "\"", "+", "o", ".", "getClass", "(", ")", ")", ";", "}", "}"], "idx": 89792, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "5dfa5b87318744a4d020b66d5f7747acc36b213b", "function_name": "checkRestrictedClass", "body_hash": "eff979113125dc22830f77ec18a3ee41a9bfae6c"}
{"code": "public static String normalize(String path, boolean replaceBackSlash) {\n\n        if (path == null) {\n            return null;\n        }\n\n        // Create a place for the normalized path\n        String normalized = path;\n\n        if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n            normalized = normalized.replace('\\\\', '/');\n\n        // Add a leading \"/\" if necessary\n        if (!normalized.startsWith(\"/\"))\n            normalized = \"/\" + normalized;\n\n        // Resolve occurrences of \"//\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"//\");\n            if (index < 0) {\n                break;\n            }\n            normalized = normalized.substring(0, index) + normalized.substring(index + 1);\n        }\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/./\");\n            if (index < 0) {\n                break;\n            }\n            normalized = normalized.substring(0, index) + normalized.substring(index + 2);\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/../\");\n            if (index < 0) {\n                break;\n            }\n            if (index == 0) {\n                return null;  // Trying to go outside our context\n            }\n            int index2 = normalized.lastIndexOf('/', index - 1);\n            normalized = normalized.substring(0, index2) + normalized.substring(index + 3);\n        }\n\n        if (normalized.equals(\"/.\")) {\n            return \"/\";\n        }\n\n        if (normalized.equals(\"/..\")) {\n            return null;  // Trying to go outside our context\n        }\n\n        // Return the normalized path that we have completed\n        return normalized;\n    }", "code_tokens": ["public", "static", "String", "normalize", "(", "String", "path", ",", "boolean", "replaceBackSlash", ")", "{", "if", "(", "path", "==", "null", ")", "{", "return", "null", ";", "}", "String", "normalized", "=", "path", ";", "if", "(", "replaceBackSlash", "&&", "normalized", ".", "indexOf", "(", "'\\\\'", ")", ">=", "0", ")", "normalized", "=", "normalized", ".", "replace", "(", "'\\\\'", ",", "'/'", ")", ";", "if", "(", "!", "normalized", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "normalized", "=", "\"", "/", "\"", "+", "normalized", ";", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "//", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "{", "break", ";", "}", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index", ")", "+", "normalized", ".", "substring", "(", "index", "+", "1", ")", ";", "}", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "/./", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "{", "break", ";", "}", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index", ")", "+", "normalized", ".", "substring", "(", "index", "+", "2", ")", ";", "}", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "/../", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "{", "break", ";", "}", "if", "(", "index", "==", "0", ")", "{", "return", "null", ";", "}", "int", "index2", "=", "normalized", ".", "lastIndexOf", "(", "'/'", ",", "index", "-", "1", ")", ";", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index2", ")", "+", "normalized", ".", "substring", "(", "index", "+", "3", ")", ";", "}", "if", "(", "normalized", ".", "equals", "(", "\"", "/.", "\"", ")", ")", "{", "return", "\"", "/", "\"", ";", "}", "if", "(", "normalized", ".", "equals", "(", "\"", "/..", "\"", ")", ")", "{", "return", "null", ";", "}", "return", "normalized", ";", "}"], "idx": 23760, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "50f0179c78721e7fc60f679d8af9b8889ab1f106", "function_name": "normalize", "body_hash": "c4b9bec406f29bf9aa638d2904c5dd0a509fc001"}
{"code": "protected int indexOf(char c, int pos) {\n\t\tfor (int i = pos; pos < len; i++)\n\t\t\tif (in[i] == (byte) c)\n\t\t\t\treturn i;\n\t\treturn -1;\n\t}", "code_tokens": ["protected", "int", "indexOf", "(", "char", "c", ",", "int", "pos", ")", "{", "for", "(", "int", "i", "=", "pos", ";", "pos", "<", "len", ";", "i", "++", ")", "if", "(", "in", "[", "i", "]", "==", "(", "byte", ")", "c", ")", "return", "i", ";", "return", "-", "1", ";", "}"], "idx": 77449, "cwe": "CWE-787", "target": 1, "status": "VULNERABLE", "commit": "6ecff1c2974eaaab2e74e441bdf5ba8495227bf5", "function_name": "indexOf", "body_hash": "0551144e4b9ce0d5615edb18a99eb551eeb712b2"}
{"code": "private void testCreateReport(String requestPath, String printSpec) throws Exception {\n        ClientHttpRequest request = getPrintRequest(requestPath, HttpMethod.POST);\n        setPrintSpec(printSpec, request);\n        final String ref;\n        final String downloadUrl;\n        try (ClientHttpResponse response = request.execute()) {\n            assertEquals(HttpStatus.OK, response.getStatusCode());\n            assertEquals(getJsonMediaType(), response.getHeaders().getContentType());\n\n            String responseAsText = getBodyAsText(response);\n            JSONObject createResult = new JSONObject(responseAsText);\n\n            ref = createResult.getString(MapPrinterServlet.JSON_PRINT_JOB_REF);\n            String statusUrl = createResult.getString(MapPrinterServlet.JSON_STATUS_LINK);\n            downloadUrl = createResult.getString(MapPrinterServlet.JSON_DOWNLOAD_LINK);\n            assertEquals(\"/print/status/\" + ref + \".json\", statusUrl);\n            assertEquals(\"/print/report/\" + ref, downloadUrl);\n        }\n\n        // check status\n        request = getPrintRequest(MapPrinterServlet.STATUS_URL + \"/\" + ref + \".json\", HttpMethod.GET);\n        try (ClientHttpResponse response = request.execute()) {\n            assertEquals(HttpStatus.OK, response.getStatusCode());\n            assertEquals(getJsonMediaType(), response.getHeaders().getContentType());\n            assertEquals(\"max-age=0, must-revalidate, no-cache, no-store\",\n                         String.join(\", \", response.getHeaders().get(\"Cache-Control\")));\n\n            String responseAsText = getBodyAsText(response);\n            JSONObject statusResult = new JSONObject(responseAsText);\n\n            assertTrue(statusResult.has(MapPrinterServlet.JSON_DONE));\n            assertEquals(downloadUrl, statusResult.getString(MapPrinterServlet.JSON_DOWNLOAD_LINK));\n        }\n\n        final boolean hasAppId = !requestPath.startsWith(MapPrinterServlet.REPORT_URL);\n        String appId = null;\n        if (hasAppId) {\n            appId = requestPath.substring(0, requestPath.indexOf('/'));\n\n            // app specific status option\n            request = getPrintRequest(appId + MapPrinterServlet.STATUS_URL + \"/\" + ref + \".json\",\n                                      HttpMethod.GET);\n            try (ClientHttpResponse response = request.execute()) {\n                assertEquals(HttpStatus.OK, response.getStatusCode());\n                assertEquals(getJsonMediaType(), response.getHeaders().getContentType());\n\n                String responseAsText = getBodyAsText(response);\n                JSONObject statusResult = new JSONObject(responseAsText);\n\n                assertTrue(statusResult.has(MapPrinterServlet.JSON_DONE));\n                assertEquals(downloadUrl, statusResult.getString(MapPrinterServlet.JSON_DOWNLOAD_LINK));\n            }\n        }\n\n        // check status with JSONP\n        request = getPrintRequest(MapPrinterServlet.STATUS_URL + \"/\" + ref + \".json?jsonp=getStatus\",\n                                  HttpMethod.GET);\n        try (ClientHttpResponse response = request.execute()) {\n            assertEquals(HttpStatus.OK, response.getStatusCode());\n            assertEquals(getJavaScriptMediaType(), response.getHeaders().getContentType());\n\n            String responseAsText = getBodyAsText(response);\n            assertTrue(responseAsText.startsWith(\"getStatus(\"));\n\n            responseAsText = responseAsText.replace(\"getStatus(\", \"\").replace(\");\", \"\");\n            JSONObject statusResult = new JSONObject(responseAsText);\n\n            assertTrue(statusResult.has(MapPrinterServlet.JSON_DONE));\n            assertEquals(downloadUrl, statusResult.getString(MapPrinterServlet.JSON_DOWNLOAD_LINK));\n        }\n\n        waitUntilDoneOrError(ref);\n\n        // check download\n        request = getPrintRequest(MapPrinterServlet.REPORT_URL + \"/\" + ref, HttpMethod.GET);\n        try (ClientHttpResponse response = request.execute()) {\n            assertEquals(HttpStatus.OK, response.getStatusCode());\n            assertEquals(new MediaType(\"application\", \"pdf\"), response.getHeaders().getContentType());\n            assertTrue(response.getBody().read() >= 0);\n        }\n\n        if (hasAppId) {\n            // check download with appId url\n            request = getPrintRequest(\"/\" + appId + MapPrinterServlet.REPORT_URL + \"/\" + ref, HttpMethod.GET);\n            try (ClientHttpResponse response = request.execute()) {\n                assertEquals(HttpStatus.OK, response.getStatusCode());\n                assertEquals(new MediaType(\"application\", \"pdf\"), response.getHeaders().getContentType());\n                assertTrue(response.getBody().read() >= 0);\n            }\n        }\n    }", "code_tokens": ["private", "void", "testCreateReport", "(", "String", "requestPath", ",", "String", "printSpec", ")", "throws", "Exception", "{", "ClientHttpRequest", "request", "=", "getPrintRequest", "(", "requestPath", ",", "HttpMethod", ".", "POST", ")", ";", "setPrintSpec", "(", "printSpec", ",", "request", ")", ";", "final", "String", "ref", ";", "final", "String", "downloadUrl", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "getJsonMediaType", "(", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "String", "responseAsText", "=", "getBodyAsText", "(", "response", ")", ";", "JSONObject", "createResult", "=", "new", "JSONObject", "(", "responseAsText", ")", ";", "ref", "=", "createResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_PRINT_JOB_REF", ")", ";", "String", "statusUrl", "=", "createResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_STATUS_LINK", ")", ";", "downloadUrl", "=", "createResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_DOWNLOAD_LINK", ")", ";", "assertEquals", "(", "\"", "/print/status/", "\"", "+", "ref", "+", "\"", ".json", "\"", ",", "statusUrl", ")", ";", "assertEquals", "(", "\"", "/print/report/", "\"", "+", "ref", ",", "downloadUrl", ")", ";", "}", "request", "=", "getPrintRequest", "(", "MapPrinterServlet", ".", "STATUS_URL", "+", "\"", "/", "\"", "+", "ref", "+", "\"", ".json", "\"", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "getJsonMediaType", "(", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "assertEquals", "(", "\"", "max-age=0, must-revalidate, no-cache, no-store", "\"", ",", "String", ".", "join", "(", "\"", ", ", "\"", ",", "response", ".", "getHeaders", "(", ")", ".", "get", "(", "\"", "Cache-Control", "\"", ")", ")", ")", ";", "String", "responseAsText", "=", "getBodyAsText", "(", "response", ")", ";", "JSONObject", "statusResult", "=", "new", "JSONObject", "(", "responseAsText", ")", ";", "assertTrue", "(", "statusResult", ".", "has", "(", "MapPrinterServlet", ".", "JSON_DONE", ")", ")", ";", "assertEquals", "(", "downloadUrl", ",", "statusResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_DOWNLOAD_LINK", ")", ")", ";", "}", "final", "boolean", "hasAppId", "=", "!", "requestPath", ".", "startsWith", "(", "MapPrinterServlet", ".", "REPORT_URL", ")", ";", "String", "appId", "=", "null", ";", "if", "(", "hasAppId", ")", "{", "appId", "=", "requestPath", ".", "substring", "(", "0", ",", "requestPath", ".", "indexOf", "(", "'/'", ")", ")", ";", "request", "=", "getPrintRequest", "(", "appId", "+", "MapPrinterServlet", ".", "STATUS_URL", "+", "\"", "/", "\"", "+", "ref", "+", "\"", ".json", "\"", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "getJsonMediaType", "(", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "String", "responseAsText", "=", "getBodyAsText", "(", "response", ")", ";", "JSONObject", "statusResult", "=", "new", "JSONObject", "(", "responseAsText", ")", ";", "assertTrue", "(", "statusResult", ".", "has", "(", "MapPrinterServlet", ".", "JSON_DONE", ")", ")", ";", "assertEquals", "(", "downloadUrl", ",", "statusResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_DOWNLOAD_LINK", ")", ")", ";", "}", "}", "request", "=", "getPrintRequest", "(", "MapPrinterServlet", ".", "STATUS_URL", "+", "\"", "/", "\"", "+", "ref", "+", "\"", ".json?jsonp=getStatus", "\"", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "getJavaScriptMediaType", "(", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "String", "responseAsText", "=", "getBodyAsText", "(", "response", ")", ";", "assertTrue", "(", "responseAsText", ".", "startsWith", "(", "\"", "getStatus(", "\"", ")", ")", ";", "responseAsText", "=", "responseAsText", ".", "replace", "(", "\"", "getStatus(", "\"", ",", "\"", "\"", ")", ".", "replace", "(", "\"", ");", "\"", ",", "\"", "\"", ")", ";", "JSONObject", "statusResult", "=", "new", "JSONObject", "(", "responseAsText", ")", ";", "assertTrue", "(", "statusResult", ".", "has", "(", "MapPrinterServlet", ".", "JSON_DONE", ")", ")", ";", "assertEquals", "(", "downloadUrl", ",", "statusResult", ".", "getString", "(", "MapPrinterServlet", ".", "JSON_DOWNLOAD_LINK", ")", ")", ";", "}", "waitUntilDoneOrError", "(", "ref", ")", ";", "request", "=", "getPrintRequest", "(", "MapPrinterServlet", ".", "REPORT_URL", "+", "\"", "/", "\"", "+", "ref", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "new", "MediaType", "(", "\"", "application", "\"", ",", "\"", "pdf", "\"", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "assertTrue", "(", "response", ".", "getBody", "(", ")", ".", "read", "(", ")", ">=", "0", ")", ";", "}", "if", "(", "hasAppId", ")", "{", "request", "=", "getPrintRequest", "(", "\"", "/", "\"", "+", "appId", "+", "MapPrinterServlet", ".", "REPORT_URL", "+", "\"", "/", "\"", "+", "ref", ",", "HttpMethod", ".", "GET", ")", ";", "try", "(", "ClientHttpResponse", "response", "=", "request", ".", "execute", "(", ")", ")", "{", "assertEquals", "(", "HttpStatus", ".", "OK", ",", "response", ".", "getStatusCode", "(", ")", ")", ";", "assertEquals", "(", "new", "MediaType", "(", "\"", "application", "\"", ",", "\"", "pdf", "\"", ")", ",", "response", ".", "getHeaders", "(", ")", ".", "getContentType", "(", ")", ")", ";", "assertTrue", "(", "response", ".", "getBody", "(", ")", ".", "read", "(", ")", ">=", "0", ")", ";", "}", "}", "}"], "idx": 79137, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "89155f2506b9cee822e15ce60ccae390a1419d5e", "function_name": "testCreateReport", "body_hash": "0c7836aad38389d9a74500eb0717b8567ebab336"}
{"code": "public static Document parse(LSInput source)\n    {\n        try {\n            LSParser p = LS_IMPL.createLSParser(DOMImplementationLS.MODE_SYNCHRONOUS, null);\n            // Disable validation, since this takes a lot of time and causes unneeded network traffic\n            p.getDomConfig().setParameter(\"validate\", false);\n            if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {\n                p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);\n            }\n            return p.parse(source);\n        } catch (Exception ex) {\n            LOGGER.warn(\"Cannot parse XML document: [{}]\", ex.getMessage());\n            return null;\n        }\n    }", "code_tokens": ["public", "static", "Document", "parse", "(", "LSInput", "source", ")", "{", "try", "{", "LSParser", "p", "=", "LS_IMPL", ".", "createLSParser", "(", "DOMImplementationLS", ".", "MODE_SYNCHRONOUS", ",", "null", ")", ";", "p", ".", "getDomConfig", "(", ")", ".", "setParameter", "(", "\"", "validate", "\"", ",", "false", ")", ";", "if", "(", "p", ".", "getDomConfig", "(", ")", ".", "canSetParameter", "(", "DISABLE_DTD_PARAM", ",", "false", ")", ")", "{", "p", ".", "getDomConfig", "(", ")", ".", "setParameter", "(", "DISABLE_DTD_PARAM", ",", "false", ")", ";", "}", "return", "p", ".", "parse", "(", "source", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "LOGGER", ".", "warn", "(", "\"", "Cannot parse XML document: [{}]", "\"", ",", "ex", ".", "getMessage", "(", ")", ")", ";", "return", "null", ";", "}", "}"], "idx": 70854, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "947e8921ebd95462d5a7928f397dd1b64f77c7d5", "function_name": "parse", "body_hash": "9c8ad459e8d7566b1c20dbcfec86f64fa02eb2a6"}
{"code": "public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        if (path.startsWith(\"/META-INF/\") || path.startsWith(\"/WEB-INF/\")) {\n            throw HttpResponses.notFound();\n        }\n\n        if(path.length()==0)\n            path = \"/\";\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        try {\n            rsp.serveLocalizedFile(req, wrapper.baseResourceURL.toURI().resolve(new URI(null, '.' + path, null)).toURL(), expires);\n        } catch (URISyntaxException x) {\n            throw new IOException(x);\n        }\n    }", "code_tokens": ["public", "void", "doDynamic", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "req", ".", "getRestOfPath", "(", ")", ";", "if", "(", "path", ".", "startsWith", "(", "\"", "/META-INF/", "\"", ")", "||", "path", ".", "startsWith", "(", "\"", "/WEB-INF/", "\"", ")", ")", "{", "throw", "HttpResponses", ".", "notFound", "(", ")", ";", "}", "if", "(", "path", ".", "length", "(", ")", "==", "0", ")", "path", "=", "\"", "/", "\"", ";", "String", "requestPath", "=", "req", ".", "getRequestURI", "(", ")", ".", "substring", "(", "req", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "boolean", "staticLink", "=", "requestPath", ".", "startsWith", "(", "\"", "/static/", "\"", ")", ";", "long", "expires", "=", "staticLink", "?", "TimeUnit2", ".", "DAYS", ".", "toMillis", "(", "365", ")", ":", "-", "1", ";", "try", "{", "rsp", ".", "serveLocalizedFile", "(", "req", ",", "wrapper", ".", "baseResourceURL", ".", "toURI", "(", ")", ".", "resolve", "(", "new", "URI", "(", "null", ",", "'.'", "+", "path", ",", "null", ")", ")", ".", "toURL", "(", ")", ",", "expires", ")", ";", "}", "catch", "(", "URISyntaxException", "x", ")", "{", "throw", "new", "IOException", "(", "x", ")", ";", "}", "}"], "idx": 15670, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "f0a29b562e14d837912c6b35fa4e81478563813a", "function_name": "doDynamic", "body_hash": "f6d3f4d96285b1676072b5a130a3df439fc43ea5"}
{"code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        DelegatingSerializationFilter.builder()\n                .addAllowedClass(KeycloakSecurityContext.class)\n                .setFilter(in);\n        in.defaultReadObject();\n\n        token = parseToken(tokenString, AccessToken.class);\n        idToken = parseToken(idTokenString, IDToken.class);\n    }", "code_tokens": ["private", "void", "readObject", "(", "ObjectInputStream", "in", ")", "throws", "IOException", ",", "ClassNotFoundException", "{", "DelegatingSerializationFilter", ".", "builder", "(", ")", ".", "addAllowedClass", "(", "KeycloakSecurityContext", ".", "class", ")", ".", "setFilter", "(", "in", ")", ";", "in", ".", "defaultReadObject", "(", ")", ";", "token", "=", "parseToken", "(", "tokenString", ",", "AccessToken", ".", "class", ")", ";", "idToken", "=", "parseToken", "(", "idTokenString", ",", "IDToken", ".", "class", ")", ";", "}"], "idx": 6240, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "33863ba161", "function_name": "readObject", "body_hash": "3ff085ecb5d69f9e3fc787ff3fe4a096edabec06"}
{"code": "protected void parseNameAndNamespace(String uri, ActionMapping mapping, ConfigurationManager configManager) {\n        String namespace, name;\n        int lastSlash = uri.lastIndexOf(\"/\");\n        if (lastSlash == -1) {\n            namespace = \"\";\n            name = uri;\n        } else if (lastSlash == 0) {\n            // ww-1046, assume it is the root namespace, it will fallback to\n            // default\n            // namespace anyway if not found in root namespace.\n            namespace = \"/\";\n            name = uri.substring(lastSlash + 1);\n        } else {\n            // Try to find the namespace in those defined, defaulting to \"\"\n            Configuration config = configManager.getConfiguration();\n            String prefix = uri.substring(0, lastSlash);\n            namespace = \"\";\n            // Find the longest matching namespace, defaulting to the default\n            for (Object o : config.getPackageConfigs().values()) {\n                String ns = ((PackageConfig) o).getNamespace();\n                if (ns != null && prefix.startsWith(ns) && (prefix.length() == ns.length() || prefix.charAt(ns.length()) == '/')) {\n                    if (ns.length() > namespace.length()) {\n                        namespace = ns;\n                    }\n                }\n            }\n\n            name = uri.substring(namespace.length() + 1);\n        }\n\n        mapping.setNamespace(cleanupNamespaceName(namespace));\n        mapping.setName(name);\n    }", "code_tokens": ["protected", "void", "parseNameAndNamespace", "(", "String", "uri", ",", "ActionMapping", "mapping", ",", "ConfigurationManager", "configManager", ")", "{", "String", "namespace", ",", "name", ";", "int", "lastSlash", "=", "uri", ".", "lastIndexOf", "(", "\"", "/", "\"", ")", ";", "if", "(", "lastSlash", "==", "-", "1", ")", "{", "namespace", "=", "\"", "\"", ";", "name", "=", "uri", ";", "}", "else", "if", "(", "lastSlash", "==", "0", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "{", "Configuration", "config", "=", "configManager", ".", "getConfiguration", "(", ")", ";", "String", "prefix", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "namespace", "=", "\"", "\"", ";", "for", "(", "Object", "o", ":", "config", ".", "getPackageConfigs", "(", ")", ".", "values", "(", ")", ")", "{", "String", "ns", "=", "(", "(", "PackageConfig", ")", "o", ")", ".", "getNamespace", "(", ")", ";", "if", "(", "ns", "!=", "null", "&&", "prefix", ".", "startsWith", "(", "ns", ")", "&&", "(", "prefix", ".", "length", "(", ")", "==", "ns", ".", "length", "(", ")", "||", "prefix", ".", "charAt", "(", "ns", ".", "length", "(", ")", ")", "==", "'/'", ")", ")", "{", "if", "(", "ns", ".", "length", "(", ")", ">", "namespace", ".", "length", "(", ")", ")", "{", "namespace", "=", "ns", ";", "}", "}", "}", "name", "=", "uri", ".", "substring", "(", "namespace", ".", "length", "(", ")", "+", "1", ")", ";", "}", "mapping", ".", "setNamespace", "(", "cleanupNamespaceName", "(", "namespace", ")", ")", ";", "mapping", ".", "setName", "(", "name", ")", ";", "}"], "idx": 10580, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "6e87474f9ad0549f07dd2c37d50a9ccd0977c6e", "function_name": "parseNameAndNamespace", "body_hash": "d00b3662983012d075042a0c9d296352bac1eb54"}
{"code": "@POST\n    public synchronized void doConfigure(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, Descriptor.FormException {\n        Jenkins.get().checkPermission(Jenkins.ADMINISTER);\n        // for compatibility reasons, the actual value is stored in Jenkins\n        BulkChange bc = new BulkChange(Jenkins.get());\n        try{\n            boolean result = configure(req, req.getSubmittedForm());\n            LOGGER.log(Level.FINE, \"security saved: \"+result);\n            Jenkins.get().save();\n            FormApply.success(req.getContextPath()+\"/manage\").generateResponse(req, rsp, null);\n        } finally {\n            bc.commit();\n        }\n    }", "code_tokens": ["@", "POST", "public", "synchronized", "void", "doConfigure", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", ",", "Descriptor", ".", "FormException", "{", "Jenkins", ".", "get", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "BulkChange", "bc", "=", "new", "BulkChange", "(", "Jenkins", ".", "get", "(", ")", ")", ";", "try", "{", "boolean", "result", "=", "configure", "(", "req", ",", "req", ".", "getSubmittedForm", "(", ")", ")", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "security saved: ", "\"", "+", "result", ")", ";", "Jenkins", ".", "get", "(", ")", ".", "save", "(", ")", ";", "FormApply", ".", "success", "(", "req", ".", "getContextPath", "(", ")", "+", "\"", "/manage", "\"", ")", ".", "generateResponse", "(", "req", ",", "rsp", ",", "null", ")", ";", "}", "finally", "{", "bc", ".", "commit", "(", ")", ";", "}", "}"], "idx": 85236, "cwe": "CWE-862", "target": 0, "status": "FIXED", "commit": "783618f", "function_name": "doConfigure", "body_hash": "3f11d4792bfbc2f63a63698fa6508c8979a7ce0b"}
{"code": "@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        String url = this.url;\n        if (url.startsWith(\"/\")) {\n            StaplerRequest req = Stapler.getCurrentRequest();\n            if (req!=null) {\n                // if we are serving HTTP request, we want to use app relative URL\n                url = req.getContextPath()+url;\n            } else {\n                // otherwise presumably this is rendered for e-mails and other non-HTTP stuff\n                url = Jenkins.get().getRootUrl()+url.substring(1);\n            }\n        }\n        text.addMarkup(charPos, charPos + length, \"<a href='\" + Util.escape(url) + \"'\"+extraAttributes()+\">\", \"</a>\");\n        return null;\n    }", "code_tokens": ["@", "Override", "public", "ConsoleAnnotator", "annotate", "(", "Object", "context", ",", "MarkupText", "text", ",", "int", "charPos", ")", "{", "String", "url", "=", "this", ".", "url", ";", "if", "(", "url", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "{", "StaplerRequest", "req", "=", "Stapler", ".", "getCurrentRequest", "(", ")", ";", "if", "(", "req", "!=", "null", ")", "{", "url", "=", "req", ".", "getContextPath", "(", ")", "+", "url", ";", "}", "else", "{", "url", "=", "Jenkins", ".", "get", "(", ")", ".", "getRootUrl", "(", ")", "+", "url", ".", "substring", "(", "1", ")", ";", "}", "}", "text", ".", "addMarkup", "(", "charPos", ",", "charPos", "+", "length", ",", "\"", "<a href='", "\"", "+", "Util", ".", "escape", "(", "url", ")", "+", "\"", "'", "\"", "+", "extraAttributes", "(", ")", "+", "\"", ">", "\"", ",", "\"", "</a>", "\"", ")", ";", "return", "null", ";", "}"], "idx": 77678, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "11f4a351224ef04cfeb9c7636fb1590b67543f3c", "function_name": "annotate", "body_hash": "35c0924f1357b4f452db22a7910426c52440caa1"}
{"code": "private static boolean contains(final String[] list, String name) {\n            if (list != null) {\n                for (final String white : list) {\n                    if (\"*\".equals(white) || name.startsWith(white)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "code_tokens": ["private", "static", "boolean", "contains", "(", "final", "String", "[", "]", "list", ",", "String", "name", ")", "{", "if", "(", "list", "!=", "null", ")", "{", "for", "(", "final", "String", "white", ":", "list", ")", "{", "if", "(", "\"", "*", "\"", ".", "equals", "(", "white", ")", "||", "name", ".", "startsWith", "(", "white", ")", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "idx": 61611, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "58cdbbef9c77ab2b44870f9d606593b49cde76d9", "function_name": "contains", "body_hash": "71f50f2ae003bd85c89916185b4e7dd361b2d6aa"}
{"code": "public Socket connectSocket(\n            final int connectTimeout,\n            final Socket socket,\n            final HttpHost host,\n            final InetSocketAddress remoteAddress,\n            final InetSocketAddress localAddress,\n            final HttpContext context) throws IOException {\n        Args.notNull(host, \"HTTP host\");\n        Args.notNull(remoteAddress, \"Remote address\");\n        final Socket sock = socket != null ? socket : createSocket(context);\n        if (localAddress != null) {\n            sock.bind(localAddress);\n        }\n        try {\n            sock.connect(remoteAddress, connectTimeout);\n        } catch (final IOException ex) {\n            try {\n                sock.close();\n            } catch (final IOException ignore) {\n            }\n            throw ex;\n        }\n        // Setup SSL layering if necessary\n        if (sock instanceof SSLSocket) {\n            final SSLSocket sslsock = (SSLSocket) sock;\n            sslsock.startHandshake();\n            verifyHostname(sslsock, host.getHostName());\n            return sock;\n        } else {\n            return createLayeredSocket(sock, host.getHostName(), remoteAddress.getPort(), context);\n        }\n    }", "code_tokens": ["public", "Socket", "connectSocket", "(", "final", "int", "connectTimeout", ",", "final", "Socket", "socket", ",", "final", "HttpHost", "host", ",", "final", "InetSocketAddress", "remoteAddress", ",", "final", "InetSocketAddress", "localAddress", ",", "final", "HttpContext", "context", ")", "throws", "IOException", "{", "Args", ".", "notNull", "(", "host", ",", "\"", "HTTP host", "\"", ")", ";", "Args", ".", "notNull", "(", "remoteAddress", ",", "\"", "Remote address", "\"", ")", ";", "final", "Socket", "sock", "=", "socket", "!=", "null", "?", "socket", ":", "createSocket", "(", "context", ")", ";", "if", "(", "localAddress", "!=", "null", ")", "{", "sock", ".", "bind", "(", "localAddress", ")", ";", "}", "try", "{", "sock", ".", "connect", "(", "remoteAddress", ",", "connectTimeout", ")", ";", "}", "catch", "(", "final", "IOException", "ex", ")", "{", "try", "{", "sock", ".", "close", "(", ")", ";", "}", "catch", "(", "final", "IOException", "ignore", ")", "{", "}", "throw", "ex", ";", "}", "if", "(", "sock", "instanceof", "SSLSocket", ")", "{", "final", "SSLSocket", "sslsock", "=", "(", "SSLSocket", ")", "sock", ";", "sslsock", ".", "startHandshake", "(", ")", ";", "verifyHostname", "(", "sslsock", ",", "host", ".", "getHostName", "(", ")", ")", ";", "return", "sock", ";", "}", "else", "{", "return", "createLayeredSocket", "(", "sock", ",", "host", ".", "getHostName", "(", ")", ",", "remoteAddress", ".", "getPort", "(", ")", ",", "context", ")", ";", "}", "}"], "idx": 51214, "cwe": "CWE-399", "target": 1, "status": "VULNERABLE", "commit": "d954cd287dfcdad8f153e61181e20d253175ca8c", "function_name": "connectSocket", "body_hash": "747e3a3f55acb84f257496288092ce2af59c2cb4"}
{"code": "public void setPreservedState(String stateKey, Object preservedState) {\n\t\tstate.clear();\n\t\tstate.put(stateKey, preservedState);\n\t}", "code_tokens": ["public", "void", "setPreservedState", "(", "String", "stateKey", ",", "Object", "preservedState", ")", "{", "state", ".", "clear", "(", ")", ";", "state", ".", "put", "(", "stateKey", ",", "preservedState", ")", ";", "}"], "idx": 52671, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "3379a36e64c13e4118c7e179f3a874a64de5f5a2", "function_name": "setPreservedState", "body_hash": "0b651b5e720c18e1a9cdb0edc9c8016976ca581d"}
{"code": "public static String fillAuthentication(String mavenSettingsContent, final Boolean isReplaceAllServerDefinitions,\n                                            Map<String, StandardUsernameCredentials> mavenServerId2jenkinsCredential,\n                                            FilePath workDir, List<String> tempFiles) throws Exception {\n        String content = mavenSettingsContent;\n\n        if (mavenServerId2jenkinsCredential.isEmpty()) {\n            return mavenSettingsContent;\n        }\n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(new StringReader(content)));\n\n        Map<String, Node> removedMavenServers = Collections.emptyMap();\n\n        // locate the server node(s)\n        XPath xpath = XPathFactory.newInstance().newXPath();\n        Node serversNode = (Node) xpath.evaluate(\"/settings/servers\", doc, XPathConstants.NODE);\n        if (serversNode == null) {\n            // need to create a 'servers' node\n            Node settingsNode = (Node) xpath.evaluate(\"/settings\", doc, XPathConstants.NODE);\n            serversNode = doc.createElement(\"servers\");\n            settingsNode.appendChild(serversNode);\n        } else {\n            // remove the server nodes\n        \tremovedMavenServers = removeMavenServerDefinitions(serversNode, mavenServerId2jenkinsCredential.keySet(), Boolean.TRUE.equals(isReplaceAllServerDefinitions));\n        }\n\n        for (Entry<String, StandardUsernameCredentials> mavenServerId2JenkinsCredential : mavenServerId2jenkinsCredential.entrySet()) {\n\n            final StandardUsernameCredentials credential = mavenServerId2JenkinsCredential.getValue();\n            String mavenServerId = mavenServerId2JenkinsCredential.getKey();\n\n            Node currentDefinition = removedMavenServers.get(mavenServerId);\n            if (credential instanceof StandardUsernamePasswordCredentials) {\n\n                StandardUsernamePasswordCredentials usernamePasswordCredentials = (StandardUsernamePasswordCredentials) credential;\n                LOGGER.log(Level.FINE, \"Maven Server ID {0}: use {1} / {2}\", new Object[]{mavenServerId, usernamePasswordCredentials.getId(), usernamePasswordCredentials.getDescription()});\n\n                final Element server = doc.createElement(\"server\");\n\n                // create and add the relevant xml elements\n                final Element id = doc.createElement(\"id\");\n                id.setTextContent(mavenServerId);\n                final Element password = doc.createElement(\"password\");\n                password.setTextContent(Secret.toString(usernamePasswordCredentials.getPassword()));\n                final Element username = doc.createElement(\"username\");\n                username.setTextContent(usernamePasswordCredentials.getUsername());\n\n                server.appendChild(id);\n                server.appendChild(username);\n                server.appendChild(password);\n                copyServerAttributes(currentDefinition,\tserver);\n\n                serversNode.appendChild(server);\n            } else if (credential instanceof SSHUserPrivateKey) {\n                SSHUserPrivateKey sshUserPrivateKey = (SSHUserPrivateKey) credential;\n                List<String> privateKeys = sshUserPrivateKey.getPrivateKeys();\n                String privateKeyContent;\n\n                if (privateKeys.isEmpty()) {\n                    LOGGER.log(Level.WARNING, \"Maven Server ID {0}: not private key defined in {1}, skip\", new Object[]{mavenServerId, sshUserPrivateKey.getId()});\n                    continue;\n                } else if (privateKeys.size() == 1) {\n                    LOGGER.log(Level.FINE, \"Maven Server ID {0}: use {1}\", new Object[]{mavenServerId, sshUserPrivateKey.getId()});\n                    privateKeyContent = privateKeys.get(0);\n                } else {\n                    LOGGER.log(Level.WARNING, \"Maven Server ID {0}: more than one ({1}) private key defined in {1}, use first private key\", new Object[]{mavenServerId, privateKeys.size(), sshUserPrivateKey.getId()});\n                    privateKeyContent = privateKeys.get(0);\n                }\n\n                final Element server = doc.createElement(\"server\");\n\n                // create and add the relevant xml elements\n                final Element id = doc.createElement(\"id\");\n                id.setTextContent(mavenServerId);\n\n                final Element username = doc.createElement(\"username\");\n                username.setTextContent(sshUserPrivateKey.getUsername());\n\n                workDir.mkdirs();\n                FilePath privateKeyFile = workDir.createTextTempFile(\"private-key-\", \".pem\", privateKeyContent, true);\n                privateKeyFile.chmod(0600);\n                tempFiles.add(privateKeyFile.getRemote());\n                LOGGER.log(Level.FINE, \"Create {0}\", new Object[]{privateKeyFile.getRemote()});\n\n                final Element privateKey = doc.createElement(\"privateKey\");\n                privateKey.setTextContent(privateKeyFile.getRemote());\n\n                final Element passphrase = doc.createElement(\"passphrase\");\n                passphrase.setTextContent(Secret.toString(sshUserPrivateKey.getPassphrase()));\n\n                server.appendChild(id);\n                server.appendChild(username);\n                server.appendChild(privateKey);\n                server.appendChild(passphrase);\n                copyServerAttributes(currentDefinition,\tserver);\n\n                serversNode.appendChild(server);\n            } else {\n                LOGGER.log(Level.WARNING, \"Maven Server ID {0}: credentials type of {1} not supported: {2}\",\n                        new Object[]{mavenServerId, credential == null ? null : credential.getId(), credential == null ? null : credential.getClass()});\n            }\n\n        }\n\n        // save the result\n        StringWriter writer = new StringWriter();\n        Transformer xformer = TransformerFactory.newInstance().newTransformer();\n        xformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        xformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n        xformer.transform(new DOMSource(doc), new StreamResult(writer));\n        content = writer.toString();\n\n        return content;\n    }", "code_tokens": ["public", "static", "String", "fillAuthentication", "(", "String", "mavenSettingsContent", ",", "final", "Boolean", "isReplaceAllServerDefinitions", ",", "Map", "<", "String", ",", "StandardUsernameCredentials", ">", "mavenServerId2jenkinsCredential", ",", "FilePath", "workDir", ",", "List", "<", "String", ">", "tempFiles", ")", "throws", "Exception", "{", "String", "content", "=", "mavenSettingsContent", ";", "if", "(", "mavenServerId2jenkinsCredential", ".", "isEmpty", "(", ")", ")", "{", "return", "mavenSettingsContent", ";", "}", "Document", "doc", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ".", "newDocumentBuilder", "(", ")", ".", "parse", "(", "new", "InputSource", "(", "new", "StringReader", "(", "content", ")", ")", ")", ";", "Map", "<", "String", ",", "Node", ">", "removedMavenServers", "=", "Collections", ".", "emptyMap", "(", ")", ";", "XPath", "xpath", "=", "XPathFactory", ".", "newInstance", "(", ")", ".", "newXPath", "(", ")", ";", "Node", "serversNode", "=", "(", "Node", ")", "xpath", ".", "evaluate", "(", "\"", "/settings/servers", "\"", ",", "doc", ",", "XPathConstants", ".", "NODE", ")", ";", "if", "(", "serversNode", "==", "null", ")", "{", "Node", "settingsNode", "=", "(", "Node", ")", "xpath", ".", "evaluate", "(", "\"", "/settings", "\"", ",", "doc", ",", "XPathConstants", ".", "NODE", ")", ";", "serversNode", "=", "doc", ".", "createElement", "(", "\"", "servers", "\"", ")", ";", "settingsNode", ".", "appendChild", "(", "serversNode", ")", ";", "}", "else", "{", "removedMavenServers", "=", "removeMavenServerDefinitions", "(", "serversNode", ",", "mavenServerId2jenkinsCredential", ".", "keySet", "(", ")", ",", "Boolean", ".", "TRUE", ".", "equals", "(", "isReplaceAllServerDefinitions", ")", ")", ";", "}", "for", "(", "Entry", "<", "String", ",", "StandardUsernameCredentials", ">", "mavenServerId2JenkinsCredential", ":", "mavenServerId2jenkinsCredential", ".", "entrySet", "(", ")", ")", "{", "final", "StandardUsernameCredentials", "credential", "=", "mavenServerId2JenkinsCredential", ".", "getValue", "(", ")", ";", "String", "mavenServerId", "=", "mavenServerId2JenkinsCredential", ".", "getKey", "(", ")", ";", "Node", "currentDefinition", "=", "removedMavenServers", ".", "get", "(", "mavenServerId", ")", ";", "if", "(", "credential", "instanceof", "StandardUsernamePasswordCredentials", ")", "{", "StandardUsernamePasswordCredentials", "usernamePasswordCredentials", "=", "(", "StandardUsernamePasswordCredentials", ")", "credential", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Maven Server ID {0}: use {1} / {2}", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "usernamePasswordCredentials", ".", "getId", "(", ")", ",", "usernamePasswordCredentials", ".", "getDescription", "(", ")", "}", ")", ";", "final", "Element", "server", "=", "doc", ".", "createElement", "(", "\"", "server", "\"", ")", ";", "final", "Element", "id", "=", "doc", ".", "createElement", "(", "\"", "id", "\"", ")", ";", "id", ".", "setTextContent", "(", "mavenServerId", ")", ";", "final", "Element", "password", "=", "doc", ".", "createElement", "(", "\"", "password", "\"", ")", ";", "password", ".", "setTextContent", "(", "Secret", ".", "toString", "(", "usernamePasswordCredentials", ".", "getPassword", "(", ")", ")", ")", ";", "final", "Element", "username", "=", "doc", ".", "createElement", "(", "\"", "username", "\"", ")", ";", "username", ".", "setTextContent", "(", "usernamePasswordCredentials", ".", "getUsername", "(", ")", ")", ";", "server", ".", "appendChild", "(", "id", ")", ";", "server", ".", "appendChild", "(", "username", ")", ";", "server", ".", "appendChild", "(", "password", ")", ";", "copyServerAttributes", "(", "currentDefinition", ",", "server", ")", ";", "serversNode", ".", "appendChild", "(", "server", ")", ";", "}", "else", "if", "(", "credential", "instanceof", "SSHUserPrivateKey", ")", "{", "SSHUserPrivateKey", "sshUserPrivateKey", "=", "(", "SSHUserPrivateKey", ")", "credential", ";", "List", "<", "String", ">", "privateKeys", "=", "sshUserPrivateKey", ".", "getPrivateKeys", "(", ")", ";", "String", "privateKeyContent", ";", "if", "(", "privateKeys", ".", "isEmpty", "(", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Maven Server ID {0}: not private key defined in {1}, skip", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "sshUserPrivateKey", ".", "getId", "(", ")", "}", ")", ";", "continue", ";", "}", "else", "if", "(", "privateKeys", ".", "size", "(", ")", "==", "1", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Maven Server ID {0}: use {1}", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "sshUserPrivateKey", ".", "getId", "(", ")", "}", ")", ";", "privateKeyContent", "=", "privateKeys", ".", "get", "(", "0", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Maven Server ID {0}: more than one ({1}) private key defined in {1}, use first private key", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "privateKeys", ".", "size", "(", ")", ",", "sshUserPrivateKey", ".", "getId", "(", ")", "}", ")", ";", "privateKeyContent", "=", "privateKeys", ".", "get", "(", "0", ")", ";", "}", "final", "Element", "server", "=", "doc", ".", "createElement", "(", "\"", "server", "\"", ")", ";", "final", "Element", "id", "=", "doc", ".", "createElement", "(", "\"", "id", "\"", ")", ";", "id", ".", "setTextContent", "(", "mavenServerId", ")", ";", "final", "Element", "username", "=", "doc", ".", "createElement", "(", "\"", "username", "\"", ")", ";", "username", ".", "setTextContent", "(", "sshUserPrivateKey", ".", "getUsername", "(", ")", ")", ";", "workDir", ".", "mkdirs", "(", ")", ";", "FilePath", "privateKeyFile", "=", "workDir", ".", "createTextTempFile", "(", "\"", "private-key-", "\"", ",", "\"", ".pem", "\"", ",", "privateKeyContent", ",", "true", ")", ";", "privateKeyFile", ".", "chmod", "(", "0600", ")", ";", "tempFiles", ".", "add", "(", "privateKeyFile", ".", "getRemote", "(", ")", ")", ";", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Create {0}", "\"", ",", "new", "Object", "[", "]", "{", "privateKeyFile", ".", "getRemote", "(", ")", "}", ")", ";", "final", "Element", "privateKey", "=", "doc", ".", "createElement", "(", "\"", "privateKey", "\"", ")", ";", "privateKey", ".", "setTextContent", "(", "privateKeyFile", ".", "getRemote", "(", ")", ")", ";", "final", "Element", "passphrase", "=", "doc", ".", "createElement", "(", "\"", "passphrase", "\"", ")", ";", "passphrase", ".", "setTextContent", "(", "Secret", ".", "toString", "(", "sshUserPrivateKey", ".", "getPassphrase", "(", ")", ")", ")", ";", "server", ".", "appendChild", "(", "id", ")", ";", "server", ".", "appendChild", "(", "username", ")", ";", "server", ".", "appendChild", "(", "privateKey", ")", ";", "server", ".", "appendChild", "(", "passphrase", ")", ";", "copyServerAttributes", "(", "currentDefinition", ",", "server", ")", ";", "serversNode", ".", "appendChild", "(", "server", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Maven Server ID {0}: credentials type of {1} not supported: {2}", "\"", ",", "new", "Object", "[", "]", "{", "mavenServerId", ",", "credential", "==", "null", "?", "null", ":", "credential", ".", "getId", "(", ")", ",", "credential", "==", "null", "?", "null", ":", "credential", ".", "getClass", "(", ")", "}", ")", ";", "}", "}", "StringWriter", "writer", "=", "new", "StringWriter", "(", ")", ";", "Transformer", "xformer", "=", "TransformerFactory", ".", "newInstance", "(", ")", ".", "newTransformer", "(", ")", ";", "xformer", ".", "setOutputProperty", "(", "OutputKeys", ".", "INDENT", ",", "\"", "yes", "\"", ")", ";", "xformer", ".", "setOutputProperty", "(", "\"", "{http://xml.apache.org/xslt}indent-amount", "\"", ",", "\"", "2", "\"", ")", ";", "xformer", ".", "transform", "(", "new", "DOMSource", "(", "doc", ")", ",", "new", "StreamResult", "(", "writer", ")", ")", ";", "content", "=", "writer", ".", "toString", "(", ")", ";", "return", "content", ";", "}"], "idx": 69654, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "5f845bc", "function_name": "fillAuthentication", "body_hash": "4612a1936bc269828c614f45ab57f36f3395bf45"}
{"code": "@RequirePOST\n        public FormValidation doCheckRepoUrl(@QueryParameter(fixEmpty = true) String value, @AncestorInPath AbstractProject project) throws IOException,\n                ServletException {\n\n            // Connect to URL and check content only if we have admin permission\n            if (!Jenkins.get().hasPermission(Jenkins.ADMINISTER))\n                return FormValidation.ok();\n\n            if (value == null) // nothing entered yet\n                value = \"origin\";\n\n            if (!value.contains(\"/\") && project != null) {\n                GitSCM scm = (GitSCM) project.getScm();\n                RemoteConfig remote = scm.getRepositoryByName(value);\n                if (remote == null)\n                    return FormValidation.errorWithMarkup(\"There is no remote with the name <code>\" + Util.escape(value) + \"</code>\");\n                \n                value = remote.getURIs().get(0).toString();\n            }\n            \n            if (!value.endsWith(\"/\"))\n                value += '/';\n            if (!URL_PATTERN.matcher(value).matches())\n                return FormValidation.errorWithMarkup(\"The URL should end like <code>.../_git/foobar/</code>\");\n\n            final String finalValue = value;\n            return new FormValidation.URLCheck() {\n                @Override\n                protected FormValidation check() throws IOException, ServletException {\n                    try {\n                        if (findText(open(new URL(finalValue)), REPOSITORY_BROWSER_LABEL)) {\n                            return FormValidation.ok();\n                        } else {\n                            return FormValidation.error(\"This is a valid URL but it doesn't look like Microsoft TFS 2013\");\n                        }\n                    } catch (IOException e) {\n                        return handleIOException(finalValue, e);\n                    }\n                }\n            }.check();\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doCheckRepoUrl", "(", "@", "QueryParameter", "(", "fixEmpty", "=", "true", ")", "String", "value", ",", "@", "AncestorInPath", "AbstractProject", "project", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "!", "Jenkins", ".", "get", "(", ")", ".", "hasPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ")", "return", "FormValidation", ".", "ok", "(", ")", ";", "if", "(", "value", "==", "null", ")", "value", "=", "\"", "origin", "\"", ";", "if", "(", "!", "value", ".", "contains", "(", "\"", "/", "\"", ")", "&&", "project", "!=", "null", ")", "{", "GitSCM", "scm", "=", "(", "GitSCM", ")", "project", ".", "getScm", "(", ")", ";", "RemoteConfig", "remote", "=", "scm", ".", "getRepositoryByName", "(", "value", ")", ";", "if", "(", "remote", "==", "null", ")", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "There is no remote with the name <code>", "\"", "+", "Util", ".", "escape", "(", "value", ")", "+", "\"", "</code>", "\"", ")", ";", "value", "=", "remote", ".", "getURIs", "(", ")", ".", "get", "(", "0", ")", ".", "toString", "(", ")", ";", "}", "if", "(", "!", "value", ".", "endsWith", "(", "\"", "/", "\"", ")", ")", "value", "+=", "'/'", ";", "if", "(", "!", "URL_PATTERN", ".", "matcher", "(", "value", ")", ".", "matches", "(", ")", ")", "return", "FormValidation", ".", "errorWithMarkup", "(", "\"", "The URL should end like <code>.../_git/foobar/</code>", "\"", ")", ";", "final", "String", "finalValue", "=", "value", ";", "return", "new", "FormValidation", ".", "URLCheck", "(", ")", "{", "@", "Override", "protected", "FormValidation", "check", "(", ")", "throws", "IOException", ",", "ServletException", "{", "try", "{", "if", "(", "findText", "(", "open", "(", "new", "URL", "(", "finalValue", ")", ")", ",", "REPOSITORY_BROWSER_LABEL", ")", ")", "{", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "else", "{", "return", "FormValidation", ".", "error", "(", "\"", "This is a valid URL but it doesn't look like Microsoft TFS 2013", "\"", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "return", "handleIOException", "(", "finalValue", ",", "e", ")", ";", "}", "}", "}", ".", "check", "(", ")", ";", "}"], "idx": 81304, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "f581998b", "function_name": "doCheckRepoUrl", "body_hash": "1fecae66554a9e9cbf8d4013f1607136deca3ff3"}
{"code": "@BeforeClass\n  public static void setupClass() {\n    functionStringMap.put(new AlterConnectionFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new AlterMappingFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new CreateConnectionFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new CreateMappingFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new DescribeConnectionFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new DescribeMappingFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new DestroyConnectionFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new DestroyMappingFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new ListConnectionFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListMappingFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new InheritsDefaultPermissionsJDBCFunction(), \"CLUSTER:READ\");\n    functionStringMap.keySet().forEach(FunctionService::registerFunction);\n  }", "code_tokens": ["@", "BeforeClass", "public", "static", "void", "setupClass", "(", ")", "{", "functionStringMap", ".", "put", "(", "new", "AlterConnectionFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "AlterMappingFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateConnectionFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "CreateMappingFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DescribeConnectionFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DescribeMappingFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyConnectionFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "DestroyMappingFunction", "(", ")", ",", "\"", "CLUSTER:MANAGE", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListConnectionFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "ListMappingFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "put", "(", "new", "InheritsDefaultPermissionsJDBCFunction", "(", ")", ",", "\"", "CLUSTER:READ", "\"", ")", ";", "functionStringMap", ".", "keySet", "(", ")", ".", "forEach", "(", "FunctionService", "::", "registerFunction", ")", ";", "}"], "idx": 87263, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "00be4f9774e1adf8e7ccc2664da8005fc30bb11d", "function_name": "setupClass", "body_hash": "7dbd0be680190c3465827f53b0592af17d5e04e8"}
{"code": "public void recycle() {\n        bytesRead=0;\n\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        trailerFields.clear();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTime = -1;\n    }", "code_tokens": ["public", "void", "recycle", "(", ")", "{", "bytesRead", "=", "0", ";", "contentLength", "=", "-", "1", ";", "contentTypeMB", "=", "null", ";", "charset", "=", "null", ";", "characterEncoding", "=", "null", ";", "expectation", "=", "false", ";", "headers", ".", "recycle", "(", ")", ";", "trailerFields", ".", "clear", "(", ")", ";", "serverNameMB", ".", "recycle", "(", ")", ";", "serverPort", "=", "-", "1", ";", "localAddrMB", ".", "recycle", "(", ")", ";", "localNameMB", ".", "recycle", "(", ")", ";", "localPort", "=", "-", "1", ";", "peerAddrMB", ".", "recycle", "(", ")", ";", "remoteAddrMB", ".", "recycle", "(", ")", ";", "remoteHostMB", ".", "recycle", "(", ")", ";", "remotePort", "=", "-", "1", ";", "available", "=", "0", ";", "sendfile", "=", "true", ";", "serverCookies", ".", "recycle", "(", ")", ";", "parameters", ".", "recycle", "(", ")", ";", "pathParameters", ".", "clear", "(", ")", ";", "uriMB", ".", "recycle", "(", ")", ";", "decodedUriMB", ".", "recycle", "(", ")", ";", "queryMB", ".", "recycle", "(", ")", ";", "methodMB", ".", "recycle", "(", ")", ";", "protoMB", ".", "recycle", "(", ")", ";", "schemeMB", ".", "recycle", "(", ")", ";", "remoteUser", ".", "recycle", "(", ")", ";", "remoteUserNeedsAuthorization", "=", "false", ";", "authType", ".", "recycle", "(", ")", ";", "attributes", ".", "clear", "(", ")", ";", "listener", "=", "null", ";", "synchronized", "(", "nonBlockingStateLock", ")", "{", "fireListener", "=", "false", ";", "registeredForRead", "=", "false", ";", "}", "allDataReadEventSent", ".", "set", "(", "false", ")", ";", "startTime", "=", "-", "1", ";", "}"], "idx": 74649, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "8ece47c4a9fb9349e8862c84358a4dd23c643a24", "function_name": "recycle", "body_hash": "7df9906d06fd030f342a0fe046bbdbb82c94bd6a"}
{"code": "public CloseableHttpClient build() {\n        // Create main request executor\n        HttpRequestExecutor requestExec = this.requestExec;\n        if (requestExec == null) {\n            requestExec = new HttpRequestExecutor();\n        }\n        HttpClientConnectionManager connManager = this.connManager;\n        if (connManager == null) {\n            LayeredConnectionSocketFactory sslSocketFactory = this.sslSocketFactory;\n            if (sslSocketFactory == null) {\n                if (sslcontext != null) {\n                    sslSocketFactory = new SSLConnectionSocketFactory(sslcontext, hostnameVerifier);\n                } else {\n                    if (systemProperties) {\n                        sslSocketFactory = new SSLConnectionSocketFactory(\n                                (javax.net.ssl.SSLSocketFactory) javax.net.ssl.SSLSocketFactory.getDefault(),\n                                split(System.getProperty(\"https.protocols\")),\n                                split(System.getProperty(\"https.cipherSuites\")),\n                                hostnameVerifier);\n                    } else {\n                        sslSocketFactory = new SSLConnectionSocketFactory(\n                                SSLContexts.createDefault(),\n                                hostnameVerifier);\n                    }\n                }\n            }\n            @SuppressWarnings(\"resource\")\n            final PoolingHttpClientConnectionManager poolingmgr = new PoolingHttpClientConnectionManager(\n                    RegistryBuilder.<ConnectionSocketFactory>create()\n                        .register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n                        .register(\"https\", sslSocketFactory)\n                        .build());\n            if (defaultSocketConfig != null) {\n                poolingmgr.setDefaultSocketConfig(defaultSocketConfig);\n            }\n            if (defaultConnectionConfig != null) {\n                poolingmgr.setDefaultConnectionConfig(defaultConnectionConfig);\n            }\n            if (systemProperties) {\n                String s = System.getProperty(\"http.keepAlive\", \"true\");\n                if (\"true\".equalsIgnoreCase(s)) {\n                    s = System.getProperty(\"http.maxConnections\", \"5\");\n                    final int max = Integer.parseInt(s);\n                    poolingmgr.setDefaultMaxPerRoute(max);\n                    poolingmgr.setMaxTotal(2 * max);\n                }\n            }\n            if (maxConnTotal > 0) {\n                poolingmgr.setMaxTotal(maxConnTotal);\n            }\n            if (maxConnPerRoute > 0) {\n                poolingmgr.setDefaultMaxPerRoute(maxConnPerRoute);\n            }\n            connManager = poolingmgr;\n        }\n        ConnectionReuseStrategy reuseStrategy = this.reuseStrategy;\n        if (reuseStrategy == null) {\n            if (systemProperties) {\n                final String s = System.getProperty(\"http.keepAlive\", \"true\");\n                if (\"true\".equalsIgnoreCase(s)) {\n                    reuseStrategy = DefaultConnectionReuseStrategy.INSTANCE;\n                } else {\n                    reuseStrategy = NoConnectionReuseStrategy.INSTANCE;\n                }\n            } else {\n                reuseStrategy = DefaultConnectionReuseStrategy.INSTANCE;\n            }\n        }\n        ConnectionKeepAliveStrategy keepAliveStrategy = this.keepAliveStrategy;\n        if (keepAliveStrategy == null) {\n            keepAliveStrategy = DefaultConnectionKeepAliveStrategy.INSTANCE;\n        }\n        AuthenticationStrategy targetAuthStrategy = this.targetAuthStrategy;\n        if (targetAuthStrategy == null) {\n            targetAuthStrategy = TargetAuthenticationStrategy.INSTANCE;\n        }\n        AuthenticationStrategy proxyAuthStrategy = this.proxyAuthStrategy;\n        if (proxyAuthStrategy == null) {\n            proxyAuthStrategy = ProxyAuthenticationStrategy.INSTANCE;\n        }\n        UserTokenHandler userTokenHandler = this.userTokenHandler;\n        if (userTokenHandler == null) {\n            if (!connectionStateDisabled) {\n                userTokenHandler = DefaultUserTokenHandler.INSTANCE;\n            } else {\n                userTokenHandler = NoopUserTokenHandler.INSTANCE;\n            }\n        }\n        ClientExecChain execChain = new MainClientExec(\n                requestExec,\n                connManager,\n                reuseStrategy,\n                keepAliveStrategy,\n                targetAuthStrategy,\n                proxyAuthStrategy,\n                userTokenHandler);\n\n        execChain = decorateMainExec(execChain);\n\n        HttpProcessor httpprocessor = this.httpprocessor;\n        if (httpprocessor == null) {\n\n            String userAgent = this.userAgent;\n            if (userAgent == null) {\n                if (systemProperties) {\n                    userAgent = System.getProperty(\"http.agent\");\n                }\n                if (userAgent == null) {\n                    userAgent = DEFAULT_USER_AGENT;\n                }\n            }\n\n            final HttpProcessorBuilder b = HttpProcessorBuilder.create();\n            if (requestFirst != null) {\n                for (final HttpRequestInterceptor i: requestFirst) {\n                    b.addFirst(i);\n                }\n            }\n            if (responseFirst != null) {\n                for (final HttpResponseInterceptor i: responseFirst) {\n                    b.addFirst(i);\n                }\n            }\n            b.addAll(\n                    new RequestDefaultHeaders(defaultHeaders),\n                    new RequestContent(),\n                    new RequestTargetHost(),\n                    new RequestClientConnControl(),\n                    new RequestUserAgent(userAgent),\n                    new RequestExpectContinue());\n            if (!cookieManagementDisabled) {\n                b.add(new RequestAddCookies());\n            }\n            if (!contentCompressionDisabled) {\n                b.add(new RequestAcceptEncoding());\n            }\n            if (!authCachingDisabled) {\n                b.add(new RequestAuthCache());\n            }\n            if (!cookieManagementDisabled) {\n                b.add(new ResponseProcessCookies());\n            }\n            if (!contentCompressionDisabled) {\n                b.add(new ResponseContentEncoding());\n            }\n            if (requestLast != null) {\n                for (final HttpRequestInterceptor i: requestLast) {\n                    b.addLast(i);\n                }\n            }\n            if (responseLast != null) {\n                for (final HttpResponseInterceptor i: responseLast) {\n                    b.addLast(i);\n                }\n            }\n            httpprocessor = b.build();\n        }\n        execChain = new ProtocolExec(execChain, httpprocessor);\n\n        execChain = decorateProtocolExec(execChain);\n\n        // Add request retry executor, if not disabled\n        if (!automaticRetriesDisabled) {\n            HttpRequestRetryHandler retryHandler = this.retryHandler;\n            if (retryHandler == null) {\n                retryHandler = DefaultHttpRequestRetryHandler.INSTANCE;\n            }\n            execChain = new RetryExec(execChain, retryHandler);\n        }\n\n        HttpRoutePlanner routePlanner = this.routePlanner;\n        if (routePlanner == null) {\n            SchemePortResolver schemePortResolver = this.schemePortResolver;\n            if (schemePortResolver == null) {\n                schemePortResolver = DefaultSchemePortResolver.INSTANCE;\n            }\n            if (proxy != null) {\n                routePlanner = new DefaultProxyRoutePlanner(proxy, schemePortResolver);\n            } else if (systemProperties) {\n                routePlanner = new SystemDefaultRoutePlanner(\n                        schemePortResolver, ProxySelector.getDefault());\n            } else {\n                routePlanner = new DefaultRoutePlanner(schemePortResolver);\n            }\n        }\n        // Add redirect executor, if not disabled\n        if (!redirectHandlingDisabled) {\n            RedirectStrategy redirectStrategy = this.redirectStrategy;\n            if (redirectStrategy == null) {\n                redirectStrategy = DefaultRedirectStrategy.INSTANCE;\n            }\n            execChain = new RedirectExec(execChain, routePlanner, redirectStrategy);\n        }\n\n        // Optionally, add service unavailable retry executor\n        final ServiceUnavailableRetryStrategy serviceUnavailStrategy = this.serviceUnavailStrategy;\n        if (serviceUnavailStrategy != null) {\n            execChain = new ServiceUnavailableRetryExec(execChain, serviceUnavailStrategy);\n        }\n        // Optionally, add connection back-off executor\n        final BackoffManager backoffManager = this.backoffManager;\n        final ConnectionBackoffStrategy connectionBackoffStrategy = this.connectionBackoffStrategy;\n        if (backoffManager != null && connectionBackoffStrategy != null) {\n            execChain = new BackoffStrategyExec(execChain, connectionBackoffStrategy, backoffManager);\n        }\n\n        Lookup<AuthSchemeProvider> authSchemeRegistry = this.authSchemeRegistry;\n        if (authSchemeRegistry == null) {\n            authSchemeRegistry = RegistryBuilder.<AuthSchemeProvider>create()\n                .register(AuthSchemes.BASIC, new BasicSchemeFactory())\n                .register(AuthSchemes.DIGEST, new DigestSchemeFactory())\n                .register(AuthSchemes.NTLM, new NTLMSchemeFactory())\n                .register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory())\n                .register(AuthSchemes.KERBEROS, new KerberosSchemeFactory())\n                .build();\n        }\n        Lookup<CookieSpecProvider> cookieSpecRegistry = this.cookieSpecRegistry;\n        if (cookieSpecRegistry == null) {\n            cookieSpecRegistry = RegistryBuilder.<CookieSpecProvider>create()\n                .register(CookieSpecs.BEST_MATCH, new BestMatchSpecFactory())\n                .register(CookieSpecs.STANDARD, new RFC2965SpecFactory())\n                .register(CookieSpecs.BROWSER_COMPATIBILITY, new BrowserCompatSpecFactory())\n                .register(CookieSpecs.NETSCAPE, new NetscapeDraftSpecFactory())\n                .register(CookieSpecs.IGNORE_COOKIES, new IgnoreSpecFactory())\n                .register(\"rfc2109\", new RFC2109SpecFactory())\n                .register(\"rfc2965\", new RFC2965SpecFactory())\n                .build();\n        }\n\n        CookieStore defaultCookieStore = this.cookieStore;\n        if (defaultCookieStore == null) {\n            defaultCookieStore = new BasicCookieStore();\n        }\n\n        CredentialsProvider defaultCredentialsProvider = this.credentialsProvider;\n        if (defaultCredentialsProvider == null) {\n            if (systemProperties) {\n                defaultCredentialsProvider = new SystemDefaultCredentialsProvider();\n            } else {\n                defaultCredentialsProvider = new BasicCredentialsProvider();\n            }\n        }\n\n        return new InternalHttpClient(\n                execChain,\n                connManager,\n                routePlanner,\n                cookieSpecRegistry,\n                authSchemeRegistry,\n                defaultCookieStore,\n                defaultCredentialsProvider,\n                defaultRequestConfig != null ? defaultRequestConfig : RequestConfig.DEFAULT,\n                closeables != null ? new ArrayList<Closeable>(closeables) : null);\n    }", "code_tokens": ["public", "CloseableHttpClient", "build", "(", ")", "{", "HttpRequestExecutor", "requestExec", "=", "this", ".", "requestExec", ";", "if", "(", "requestExec", "==", "null", ")", "{", "requestExec", "=", "new", "HttpRequestExecutor", "(", ")", ";", "}", "HttpClientConnectionManager", "connManager", "=", "this", ".", "connManager", ";", "if", "(", "connManager", "==", "null", ")", "{", "LayeredConnectionSocketFactory", "sslSocketFactory", "=", "this", ".", "sslSocketFactory", ";", "if", "(", "sslSocketFactory", "==", "null", ")", "{", "if", "(", "sslcontext", "!=", "null", ")", "{", "sslSocketFactory", "=", "new", "SSLConnectionSocketFactory", "(", "sslcontext", ",", "hostnameVerifier", ")", ";", "}", "else", "{", "if", "(", "systemProperties", ")", "{", "sslSocketFactory", "=", "new", "SSLConnectionSocketFactory", "(", "(", "javax", ".", "net", ".", "ssl", ".", "SSLSocketFactory", ")", "javax", ".", "net", ".", "ssl", ".", "SSLSocketFactory", ".", "getDefault", "(", ")", ",", "split", "(", "System", ".", "getProperty", "(", "\"", "https.protocols", "\"", ")", ")", ",", "split", "(", "System", ".", "getProperty", "(", "\"", "https.cipherSuites", "\"", ")", ")", ",", "hostnameVerifier", ")", ";", "}", "else", "{", "sslSocketFactory", "=", "new", "SSLConnectionSocketFactory", "(", "SSLContexts", ".", "createDefault", "(", ")", ",", "hostnameVerifier", ")", ";", "}", "}", "}", "@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "final", "PoolingHttpClientConnectionManager", "poolingmgr", "=", "new", "PoolingHttpClientConnectionManager", "(", "RegistryBuilder", ".", "<", "ConnectionSocketFactory", ">", "create", "(", ")", ".", "register", "(", "\"", "http", "\"", ",", "PlainConnectionSocketFactory", ".", "getSocketFactory", "(", ")", ")", ".", "register", "(", "\"", "https", "\"", ",", "sslSocketFactory", ")", ".", "build", "(", ")", ")", ";", "if", "(", "defaultSocketConfig", "!=", "null", ")", "{", "poolingmgr", ".", "setDefaultSocketConfig", "(", "defaultSocketConfig", ")", ";", "}", "if", "(", "defaultConnectionConfig", "!=", "null", ")", "{", "poolingmgr", ".", "setDefaultConnectionConfig", "(", "defaultConnectionConfig", ")", ";", "}", "if", "(", "systemProperties", ")", "{", "String", "s", "=", "System", ".", "getProperty", "(", "\"", "http.keepAlive", "\"", ",", "\"", "true", "\"", ")", ";", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "s", ")", ")", "{", "s", "=", "System", ".", "getProperty", "(", "\"", "http.maxConnections", "\"", ",", "\"", "5", "\"", ")", ";", "final", "int", "max", "=", "Integer", ".", "parseInt", "(", "s", ")", ";", "poolingmgr", ".", "setDefaultMaxPerRoute", "(", "max", ")", ";", "poolingmgr", ".", "setMaxTotal", "(", "2", "*", "max", ")", ";", "}", "}", "if", "(", "maxConnTotal", ">", "0", ")", "{", "poolingmgr", ".", "setMaxTotal", "(", "maxConnTotal", ")", ";", "}", "if", "(", "maxConnPerRoute", ">", "0", ")", "{", "poolingmgr", ".", "setDefaultMaxPerRoute", "(", "maxConnPerRoute", ")", ";", "}", "connManager", "=", "poolingmgr", ";", "}", "ConnectionReuseStrategy", "reuseStrategy", "=", "this", ".", "reuseStrategy", ";", "if", "(", "reuseStrategy", "==", "null", ")", "{", "if", "(", "systemProperties", ")", "{", "final", "String", "s", "=", "System", ".", "getProperty", "(", "\"", "http.keepAlive", "\"", ",", "\"", "true", "\"", ")", ";", "if", "(", "\"", "true", "\"", ".", "equalsIgnoreCase", "(", "s", ")", ")", "{", "reuseStrategy", "=", "DefaultConnectionReuseStrategy", ".", "INSTANCE", ";", "}", "else", "{", "reuseStrategy", "=", "NoConnectionReuseStrategy", ".", "INSTANCE", ";", "}", "}", "else", "{", "reuseStrategy", "=", "DefaultConnectionReuseStrategy", ".", "INSTANCE", ";", "}", "}", "ConnectionKeepAliveStrategy", "keepAliveStrategy", "=", "this", ".", "keepAliveStrategy", ";", "if", "(", "keepAliveStrategy", "==", "null", ")", "{", "keepAliveStrategy", "=", "DefaultConnectionKeepAliveStrategy", ".", "INSTANCE", ";", "}", "AuthenticationStrategy", "targetAuthStrategy", "=", "this", ".", "targetAuthStrategy", ";", "if", "(", "targetAuthStrategy", "==", "null", ")", "{", "targetAuthStrategy", "=", "TargetAuthenticationStrategy", ".", "INSTANCE", ";", "}", "AuthenticationStrategy", "proxyAuthStrategy", "=", "this", ".", "proxyAuthStrategy", ";", "if", "(", "proxyAuthStrategy", "==", "null", ")", "{", "proxyAuthStrategy", "=", "ProxyAuthenticationStrategy", ".", "INSTANCE", ";", "}", "UserTokenHandler", "userTokenHandler", "=", "this", ".", "userTokenHandler", ";", "if", "(", "userTokenHandler", "==", "null", ")", "{", "if", "(", "!", "connectionStateDisabled", ")", "{", "userTokenHandler", "=", "DefaultUserTokenHandler", ".", "INSTANCE", ";", "}", "else", "{", "userTokenHandler", "=", "NoopUserTokenHandler", ".", "INSTANCE", ";", "}", "}", "ClientExecChain", "execChain", "=", "new", "MainClientExec", "(", "requestExec", ",", "connManager", ",", "reuseStrategy", ",", "keepAliveStrategy", ",", "targetAuthStrategy", ",", "proxyAuthStrategy", ",", "userTokenHandler", ")", ";", "execChain", "=", "decorateMainExec", "(", "execChain", ")", ";", "HttpProcessor", "httpprocessor", "=", "this", ".", "httpprocessor", ";", "if", "(", "httpprocessor", "==", "null", ")", "{", "String", "userAgent", "=", "this", ".", "userAgent", ";", "if", "(", "userAgent", "==", "null", ")", "{", "if", "(", "systemProperties", ")", "{", "userAgent", "=", "System", ".", "getProperty", "(", "\"", "http.agent", "\"", ")", ";", "}", "if", "(", "userAgent", "==", "null", ")", "{", "userAgent", "=", "DEFAULT_USER_AGENT", ";", "}", "}", "final", "HttpProcessorBuilder", "b", "=", "HttpProcessorBuilder", ".", "create", "(", ")", ";", "if", "(", "requestFirst", "!=", "null", ")", "{", "for", "(", "final", "HttpRequestInterceptor", "i", ":", "requestFirst", ")", "{", "b", ".", "addFirst", "(", "i", ")", ";", "}", "}", "if", "(", "responseFirst", "!=", "null", ")", "{", "for", "(", "final", "HttpResponseInterceptor", "i", ":", "responseFirst", ")", "{", "b", ".", "addFirst", "(", "i", ")", ";", "}", "}", "b", ".", "addAll", "(", "new", "RequestDefaultHeaders", "(", "defaultHeaders", ")", ",", "new", "RequestContent", "(", ")", ",", "new", "RequestTargetHost", "(", ")", ",", "new", "RequestClientConnControl", "(", ")", ",", "new", "RequestUserAgent", "(", "userAgent", ")", ",", "new", "RequestExpectContinue", "(", ")", ")", ";", "if", "(", "!", "cookieManagementDisabled", ")", "{", "b", ".", "add", "(", "new", "RequestAddCookies", "(", ")", ")", ";", "}", "if", "(", "!", "contentCompressionDisabled", ")", "{", "b", ".", "add", "(", "new", "RequestAcceptEncoding", "(", ")", ")", ";", "}", "if", "(", "!", "authCachingDisabled", ")", "{", "b", ".", "add", "(", "new", "RequestAuthCache", "(", ")", ")", ";", "}", "if", "(", "!", "cookieManagementDisabled", ")", "{", "b", ".", "add", "(", "new", "ResponseProcessCookies", "(", ")", ")", ";", "}", "if", "(", "!", "contentCompressionDisabled", ")", "{", "b", ".", "add", "(", "new", "ResponseContentEncoding", "(", ")", ")", ";", "}", "if", "(", "requestLast", "!=", "null", ")", "{", "for", "(", "final", "HttpRequestInterceptor", "i", ":", "requestLast", ")", "{", "b", ".", "addLast", "(", "i", ")", ";", "}", "}", "if", "(", "responseLast", "!=", "null", ")", "{", "for", "(", "final", "HttpResponseInterceptor", "i", ":", "responseLast", ")", "{", "b", ".", "addLast", "(", "i", ")", ";", "}", "}", "httpprocessor", "=", "b", ".", "build", "(", ")", ";", "}", "execChain", "=", "new", "ProtocolExec", "(", "execChain", ",", "httpprocessor", ")", ";", "execChain", "=", "decorateProtocolExec", "(", "execChain", ")", ";", "if", "(", "!", "automaticRetriesDisabled", ")", "{", "HttpRequestRetryHandler", "retryHandler", "=", "this", ".", "retryHandler", ";", "if", "(", "retryHandler", "==", "null", ")", "{", "retryHandler", "=", "DefaultHttpRequestRetryHandler", ".", "INSTANCE", ";", "}", "execChain", "=", "new", "RetryExec", "(", "execChain", ",", "retryHandler", ")", ";", "}", "HttpRoutePlanner", "routePlanner", "=", "this", ".", "routePlanner", ";", "if", "(", "routePlanner", "==", "null", ")", "{", "SchemePortResolver", "schemePortResolver", "=", "this", ".", "schemePortResolver", ";", "if", "(", "schemePortResolver", "==", "null", ")", "{", "schemePortResolver", "=", "DefaultSchemePortResolver", ".", "INSTANCE", ";", "}", "if", "(", "proxy", "!=", "null", ")", "{", "routePlanner", "=", "new", "DefaultProxyRoutePlanner", "(", "proxy", ",", "schemePortResolver", ")", ";", "}", "else", "if", "(", "systemProperties", ")", "{", "routePlanner", "=", "new", "SystemDefaultRoutePlanner", "(", "schemePortResolver", ",", "ProxySelector", ".", "getDefault", "(", ")", ")", ";", "}", "else", "{", "routePlanner", "=", "new", "DefaultRoutePlanner", "(", "schemePortResolver", ")", ";", "}", "}", "if", "(", "!", "redirectHandlingDisabled", ")", "{", "RedirectStrategy", "redirectStrategy", "=", "this", ".", "redirectStrategy", ";", "if", "(", "redirectStrategy", "==", "null", ")", "{", "redirectStrategy", "=", "DefaultRedirectStrategy", ".", "INSTANCE", ";", "}", "execChain", "=", "new", "RedirectExec", "(", "execChain", ",", "routePlanner", ",", "redirectStrategy", ")", ";", "}", "final", "ServiceUnavailableRetryStrategy", "serviceUnavailStrategy", "=", "this", ".", "serviceUnavailStrategy", ";", "if", "(", "serviceUnavailStrategy", "!=", "null", ")", "{", "execChain", "=", "new", "ServiceUnavailableRetryExec", "(", "execChain", ",", "serviceUnavailStrategy", ")", ";", "}", "final", "BackoffManager", "backoffManager", "=", "this", ".", "backoffManager", ";", "final", "ConnectionBackoffStrategy", "connectionBackoffStrategy", "=", "this", ".", "connectionBackoffStrategy", ";", "if", "(", "backoffManager", "!=", "null", "&&", "connectionBackoffStrategy", "!=", "null", ")", "{", "execChain", "=", "new", "BackoffStrategyExec", "(", "execChain", ",", "connectionBackoffStrategy", ",", "backoffManager", ")", ";", "}", "Lookup", "<", "AuthSchemeProvider", ">", "authSchemeRegistry", "=", "this", ".", "authSchemeRegistry", ";", "if", "(", "authSchemeRegistry", "==", "null", ")", "{", "authSchemeRegistry", "=", "RegistryBuilder", ".", "<", "AuthSchemeProvider", ">", "create", "(", ")", ".", "register", "(", "AuthSchemes", ".", "BASIC", ",", "new", "BasicSchemeFactory", "(", ")", ")", ".", "register", "(", "AuthSchemes", ".", "DIGEST", ",", "new", "DigestSchemeFactory", "(", ")", ")", ".", "register", "(", "AuthSchemes", ".", "NTLM", ",", "new", "NTLMSchemeFactory", "(", ")", ")", ".", "register", "(", "AuthSchemes", ".", "SPNEGO", ",", "new", "SPNegoSchemeFactory", "(", ")", ")", ".", "register", "(", "AuthSchemes", ".", "KERBEROS", ",", "new", "KerberosSchemeFactory", "(", ")", ")", ".", "build", "(", ")", ";", "}", "Lookup", "<", "CookieSpecProvider", ">", "cookieSpecRegistry", "=", "this", ".", "cookieSpecRegistry", ";", "if", "(", "cookieSpecRegistry", "==", "null", ")", "{", "cookieSpecRegistry", "=", "RegistryBuilder", ".", "<", "CookieSpecProvider", ">", "create", "(", ")", ".", "register", "(", "CookieSpecs", ".", "BEST_MATCH", ",", "new", "BestMatchSpecFactory", "(", ")", ")", ".", "register", "(", "CookieSpecs", ".", "STANDARD", ",", "new", "RFC2965SpecFactory", "(", ")", ")", ".", "register", "(", "CookieSpecs", ".", "BROWSER_COMPATIBILITY", ",", "new", "BrowserCompatSpecFactory", "(", ")", ")", ".", "register", "(", "CookieSpecs", ".", "NETSCAPE", ",", "new", "NetscapeDraftSpecFactory", "(", ")", ")", ".", "register", "(", "CookieSpecs", ".", "IGNORE_COOKIES", ",", "new", "IgnoreSpecFactory", "(", ")", ")", ".", "register", "(", "\"", "rfc2109", "\"", ",", "new", "RFC2109SpecFactory", "(", ")", ")", ".", "register", "(", "\"", "rfc2965", "\"", ",", "new", "RFC2965SpecFactory", "(", ")", ")", ".", "build", "(", ")", ";", "}", "CookieStore", "defaultCookieStore", "=", "this", ".", "cookieStore", ";", "if", "(", "defaultCookieStore", "==", "null", ")", "{", "defaultCookieStore", "=", "new", "BasicCookieStore", "(", ")", ";", "}", "CredentialsProvider", "defaultCredentialsProvider", "=", "this", ".", "credentialsProvider", ";", "if", "(", "defaultCredentialsProvider", "==", "null", ")", "{", "if", "(", "systemProperties", ")", "{", "defaultCredentialsProvider", "=", "new", "SystemDefaultCredentialsProvider", "(", ")", ";", "}", "else", "{", "defaultCredentialsProvider", "=", "new", "BasicCredentialsProvider", "(", ")", ";", "}", "}", "return", "new", "InternalHttpClient", "(", "execChain", ",", "connManager", ",", "routePlanner", ",", "cookieSpecRegistry", ",", "authSchemeRegistry", ",", "defaultCookieStore", ",", "defaultCredentialsProvider", ",", "defaultRequestConfig", "!=", "null", "?", "defaultRequestConfig", ":", "RequestConfig", ".", "DEFAULT", ",", "closeables", "!=", "null", "?", "new", "ArrayList", "<", "Closeable", ">", "(", "closeables", ")", ":", "null", ")", ";", "}"], "idx": 7807, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "08140864e3e4c0994e094c4cf0507932baf6a66", "function_name": "build", "body_hash": "73786a9228b3d596872f59efc4d17d8eb5958447"}
{"code": "private static File getTmpFolder() {\n        try {\n            File outputFolder = File.createTempFile(\"codegen-\", \"-tmp\");\n            outputFolder.delete();\n            outputFolder.mkdir();\n            outputFolder.deleteOnExit();\n            return outputFolder;\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Cannot access tmp folder\");\n        }\n    }", "code_tokens": ["private", "static", "File", "getTmpFolder", "(", ")", "{", "try", "{", "File", "outputFolder", "=", "File", ".", "createTempFile", "(", "\"", "codegen-", "\"", ",", "\"", "-tmp", "\"", ")", ";", "outputFolder", ".", "delete", "(", ")", ";", "outputFolder", ".", "mkdir", "(", ")", ";", "outputFolder", ".", "deleteOnExit", "(", ")", ";", "return", "outputFolder", ";", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "throw", "new", "RuntimeException", "(", "\"", "Cannot access tmp folder", "\"", ")", ";", "}", "}"], "idx": 35409, "cwe": "CWE-269", "target": 1, "status": "VULNERABLE", "commit": "c31e6e79d02d9f59d3b727cfc766cd4e0c27f75a", "function_name": "getTmpFolder", "body_hash": "34b65ececc832bc39d6da48ab839f4e82090461c"}
{"code": "protected boolean parseChunkHeader()\n        throws IOException {\n\n        int result = 0;\n        boolean eol = false;\n        boolean readDigit = false;\n        boolean extension = false;\n\n        while (!eol) {\n\n            if (pos >= lastValid) {\n                if (readBytes() <= 0)\n                    return false;\n            }\n\n            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {\n                parseCRLF(false);\n                eol = true;\n            } else if (buf[pos] == Constants.SEMI_COLON && !extension) {\n                // First semi-colon marks the start of the extension. Further\n                // semi-colons may appear to separate multiple chunk-extensions.\n                // These need to be processed as part of parsing the extensions.\n                extension = true;\n                extensionSize++;\n            } else if (!extension) {\n                //don't read data after the trailer\n                int charValue = HexUtils.getDec(buf[pos]);\n                if (charValue != -1) {\n                    readDigit = true;\n                    result *= 16;\n                    result += charValue;\n                } else {\n                    //we shouldn't allow invalid, non hex characters\n                    //in the chunked header\n                    return false;\n                }\n            } else {\n                // Extension 'parsing'\n                // Note that the chunk-extension is neither parsed nor\n                // validated. Currently it is simply ignored.\n                extensionSize++;\n                if (maxExtensionSize > -1 && extensionSize > maxExtensionSize) {\n                    throw new IOException(\"maxExtensionSize exceeded\");\n                }\n            }\n\n            // Parsing the CRLF increments pos\n            if (!eol) {\n                pos++;\n            }\n\n        }\n\n        if (!readDigit)\n            return false;\n\n        if (result == 0)\n            endChunk = true;\n\n        remaining = result;\n        if (remaining < 0)\n            return false;\n\n        return true;\n\n    }", "code_tokens": ["protected", "boolean", "parseChunkHeader", "(", ")", "throws", "IOException", "{", "int", "result", "=", "0", ";", "boolean", "eol", "=", "false", ";", "boolean", "readDigit", "=", "false", ";", "boolean", "extension", "=", "false", ";", "while", "(", "!", "eol", ")", "{", "if", "(", "pos", ">=", "lastValid", ")", "{", "if", "(", "readBytes", "(", ")", "<=", "0", ")", "return", "false", ";", "}", "if", "(", "buf", "[", "pos", "]", "==", "Constants", ".", "CR", "||", "buf", "[", "pos", "]", "==", "Constants", ".", "LF", ")", "{", "parseCRLF", "(", "false", ")", ";", "eol", "=", "true", ";", "}", "else", "if", "(", "buf", "[", "pos", "]", "==", "Constants", ".", "SEMI_COLON", "&&", "!", "extension", ")", "{", "extension", "=", "true", ";", "extensionSize", "++", ";", "}", "else", "if", "(", "!", "extension", ")", "{", "int", "charValue", "=", "HexUtils", ".", "getDec", "(", "buf", "[", "pos", "]", ")", ";", "if", "(", "charValue", "!=", "-", "1", ")", "{", "readDigit", "=", "true", ";", "result", "*=", "16", ";", "result", "+=", "charValue", ";", "}", "else", "{", "return", "false", ";", "}", "}", "else", "{", "extensionSize", "++", ";", "if", "(", "maxExtensionSize", ">", "-", "1", "&&", "extensionSize", ">", "maxExtensionSize", ")", "{", "throw", "new", "IOException", "(", "\"", "maxExtensionSize exceeded", "\"", ")", ";", "}", "}", "if", "(", "!", "eol", ")", "{", "pos", "++", ";", "}", "}", "if", "(", "!", "readDigit", ")", "return", "false", ";", "if", "(", "result", "==", "0", ")", "endChunk", "=", "true", ";", "remaining", "=", "result", ";", "if", "(", "remaining", "<", "0", ")", "return", "false", ";", "return", "true", ";", "}"], "idx": 3089, "cwe": "CWE-189", "target": 1, "status": "VULNERABLE", "commit": "f646a5acd5e32d6f5a2d9bf1d94ca66b65477675", "function_name": "parseChunkHeader", "body_hash": "3786904ab620f51fa0879ad08b2f6e3e8a7c73cf"}
{"code": "protected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n        }\n\n        // This is returned from the directory so will be attribute value\n        // escaped if required\n        String dn = user.getDN();\n        // This is the name the user provided to the authentication process so\n        // it will not be escaped\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        // Start with roles retrieved from the user entry\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        // Are we configured to do role searches?\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        // Set up parameters for an appropriate search filter\n        // The dn is already attribute value escaped but the others are not\n        // This is a filter so all input will require filter escaping\n        String filter = connection.roleFormat.format(new String[] {\n                doFilterEscaping(dn),\n                doFilterEscaping(doAttributeValueEscaping(username)),\n                doFilterEscaping(doAttributeValueEscaping(userRoleId)) });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                nameParts[i] = name.get(i);\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        // Perform the configured search and process the results\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;  // Should never happen, but just in case ...\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n                }\n                String dname = getDistinguishedName(connection.context, roleBase, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n                }\n            }\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        // if nested group search is enabled, perform searches for nested groups until no new group is found\n        if (getRoleNested()) {\n\n            // The following efficient algorithm is known as memberOf Algorithm, as described in \"Practices in\n            // Directory Groups\". It avoids group slurping and handles cyclic group memberships as well.\n            // See http://middleware.internet2.edu/dir/ for details\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>(); // Stores the groups we find in this iteration\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    filter = connection.roleFormat.format(new String[] { doFilterEscaping(group.getKey()),\n                            group.getValue(), group.getValue() });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, roleBase, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n    }", "code_tokens": ["protected", "List", "<", "String", ">", "getRoles", "(", "JNDIConnection", "connection", ",", "User", "user", ")", "throws", "NamingException", "{", "if", "(", "user", "==", "null", ")", "{", "return", "null", ";", "}", "String", "dn", "=", "user", ".", "getDN", "(", ")", ";", "String", "username", "=", "user", ".", "getUserName", "(", ")", ";", "String", "userRoleId", "=", "user", ".", "getUserRoleId", "(", ")", ";", "if", "(", "dn", "==", "null", "||", "username", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  getRoles(", "\"", "+", "dn", "+", "\"", ")", "\"", ")", ";", "}", "List", "<", "String", ">", "list", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "String", ">", "userRoles", "=", "user", ".", "getRoles", "(", ")", ";", "if", "(", "userRoles", "!=", "null", ")", "{", "list", ".", "addAll", "(", "userRoles", ")", ";", "}", "if", "(", "commonRole", "!=", "null", ")", "{", "list", ".", "add", "(", "commonRole", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "list", ".", "size", "(", ")", "+", "\"", " user internal roles", "\"", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found user internal roles ", "\"", "+", "list", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "(", "connection", ".", "roleFormat", "==", "null", ")", "||", "(", "roleName", "==", "null", ")", ")", "{", "return", "list", ";", "}", "String", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "dn", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "username", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "userRoleId", ")", ")", "}", ")", ";", "SearchControls", "controls", "=", "new", "SearchControls", "(", ")", ";", "if", "(", "roleSubtree", ")", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "}", "else", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "ONELEVEL_SCOPE", ")", ";", "}", "controls", ".", "setReturningAttributes", "(", "new", "String", "[", "]", "{", "roleName", "}", ")", ";", "String", "base", "=", "null", ";", "if", "(", "connection", ".", "roleBaseFormat", "!=", "null", ")", "{", "NameParser", "np", "=", "connection", ".", "context", ".", "getNameParser", "(", "\"", "\"", ")", ";", "Name", "name", "=", "np", ".", "parse", "(", "dn", ")", ";", "String", "nameParts", "[", "]", "=", "new", "String", "[", "name", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "name", ".", "size", "(", ")", ";", "i", "++", ")", "{", "nameParts", "[", "i", "]", "=", "name", ".", "get", "(", "i", ")", ";", "}", "base", "=", "connection", ".", "roleBaseFormat", ".", "format", "(", "nameParts", ")", ";", "}", "else", "{", "base", "=", "\"", "\"", ";", "}", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "base", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "if", "(", "results", "==", "null", ")", "{", "return", "list", ";", "}", "Map", "<", "String", ",", "String", ">", "groupMap", "=", "new", "HashMap", "<", ">", "(", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "Set", "<", "Entry", "<", "String", ",", "String", ">", ">", "entries", "=", "groupMap", ".", "entrySet", "(", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "entries", ".", "size", "(", ")", "+", "\"", " direct roles", "\"", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "entry", ":", "entries", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found direct role ", "\"", "+", "entry", ".", "getKey", "(", ")", "+", "\"", " -> ", "\"", "+", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}", "if", "(", "getRoleNested", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newGroups", "=", "new", "HashMap", "<", ">", "(", "groupMap", ")", ";", "while", "(", "!", "newGroups", ".", "isEmpty", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newThisRound", "=", "new", "HashMap", "<", ">", "(", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "group", ":", "newGroups", ".", "entrySet", "(", ")", ")", "{", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "group", ".", "getKey", "(", ")", ")", ",", "group", ".", "getValue", "(", ")", ",", "group", ".", "getValue", "(", ")", "}", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "Perform a nested group search with base ", "\"", "+", "roleBase", "+", "\"", " and filter ", "\"", "+", "filter", ")", ";", "}", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "roleBase", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", "&&", "!", "groupMap", ".", "keySet", "(", ")", ".", "contains", "(", "dname", ")", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "newThisRound", ".", "put", "(", "dname", ",", "name", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found nested role ", "\"", "+", "dname", "+", "\"", " -> ", "\"", "+", "name", ")", ";", "}", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "}", "newGroups", "=", "newThisRound", ";", "}", "}", "list", ".", "addAll", "(", "groupMap", ".", "values", "(", ")", ")", ";", "return", "list", ";", "}"], "idx": 162, "cwe": "CWE-116", "target": 0, "status": "FIXED", "commit": "17208c645d68d2af1444ee8c64f36a9b8f0ba76f", "function_name": "getRoles", "body_hash": "5939cb96a7b100ec0c152b11ff20d4e988a10fb3"}
{"code": "public void recycle() {\n        bytesRead=0;\n\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        trailerFields.clear();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        errorException = null;\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTime = -1;\n    }", "code_tokens": ["public", "void", "recycle", "(", ")", "{", "bytesRead", "=", "0", ";", "contentLength", "=", "-", "1", ";", "contentTypeMB", "=", "null", ";", "charset", "=", "null", ";", "characterEncoding", "=", "null", ";", "expectation", "=", "false", ";", "headers", ".", "recycle", "(", ")", ";", "trailerFields", ".", "clear", "(", ")", ";", "serverNameMB", ".", "recycle", "(", ")", ";", "serverPort", "=", "-", "1", ";", "localAddrMB", ".", "recycle", "(", ")", ";", "localNameMB", ".", "recycle", "(", ")", ";", "localPort", "=", "-", "1", ";", "peerAddrMB", ".", "recycle", "(", ")", ";", "remoteAddrMB", ".", "recycle", "(", ")", ";", "remoteHostMB", ".", "recycle", "(", ")", ";", "remotePort", "=", "-", "1", ";", "available", "=", "0", ";", "sendfile", "=", "true", ";", "serverCookies", ".", "recycle", "(", ")", ";", "parameters", ".", "recycle", "(", ")", ";", "pathParameters", ".", "clear", "(", ")", ";", "uriMB", ".", "recycle", "(", ")", ";", "decodedUriMB", ".", "recycle", "(", ")", ";", "queryMB", ".", "recycle", "(", ")", ";", "methodMB", ".", "recycle", "(", ")", ";", "protoMB", ".", "recycle", "(", ")", ";", "schemeMB", ".", "recycle", "(", ")", ";", "remoteUser", ".", "recycle", "(", ")", ";", "remoteUserNeedsAuthorization", "=", "false", ";", "authType", ".", "recycle", "(", ")", ";", "attributes", ".", "clear", "(", ")", ";", "errorException", "=", "null", ";", "listener", "=", "null", ";", "synchronized", "(", "nonBlockingStateLock", ")", "{", "fireListener", "=", "false", ";", "registeredForRead", "=", "false", ";", "}", "allDataReadEventSent", ".", "set", "(", "false", ")", ";", "startTime", "=", "-", "1", ";", "}"], "idx": 74650, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "8ece47c4a9fb9349e8862c84358a4dd23c643a24", "function_name": "recycle", "body_hash": "968e6097851b131f1e7993838b03e8f4259622f7"}
{"code": "@Override\n    protected void doExecute(CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n        final Authentication authentication = securityContext.getAuthentication();\n        if (authentication == null) {\n            listener.onFailure(new IllegalStateException(\"authentication is required\"));\n        } else {\n            rolesStore.getRoleDescriptors(new HashSet<>(Arrays.asList(authentication.getUser().roles())),\n                ActionListener.wrap(roleDescriptors -> apiKeyService.createApiKey(authentication, request, roleDescriptors, listener),\n                    listener::onFailure));\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "doExecute", "(", "CreateApiKeyRequest", "request", ",", "ActionListener", "<", "CreateApiKeyResponse", ">", "listener", ")", "{", "final", "Authentication", "authentication", "=", "securityContext", ".", "getAuthentication", "(", ")", ";", "if", "(", "authentication", "==", "null", ")", "{", "listener", ".", "onFailure", "(", "new", "IllegalStateException", "(", "\"", "authentication is required", "\"", ")", ")", ";", "}", "else", "{", "rolesStore", ".", "getRoleDescriptors", "(", "new", "HashSet", "<", ">", "(", "Arrays", ".", "asList", "(", "authentication", ".", "getUser", "(", ")", ".", "roles", "(", ")", ")", ")", ",", "ActionListener", ".", "wrap", "(", "roleDescriptors", "->", "apiKeyService", ".", "createApiKey", "(", "authentication", ",", "request", ",", "roleDescriptors", ",", "listener", ")", ",", "listener", "::", "onFailure", ")", ")", ";", "}", "}"], "idx": 36387, "cwe": "CWE-269", "target": 1, "status": "VULNERABLE", "commit": "1c5f53076b625c44111c1e9430dc36327a088583", "function_name": "doExecute", "body_hash": "d34c037c24dc71bf79cd4134216278baa43aacec"}
{"code": "public static String compileMustache(Map<String, Object> context, String template) {\n\t\tif (context == null || StringUtils.isBlank(template)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tWriter writer = new StringWriter();\n\t\ttry {\n\t\t\tMustache.compiler().escapeHTML(false).emptyStringIsFalse(true).compile(template).execute(context, writer);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\twriter.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tlogger.error(null, e);\n\t\t\t}\n\t\t}\n\t\treturn writer.toString();\n\t}", "code_tokens": ["public", "static", "String", "compileMustache", "(", "Map", "<", "String", ",", "Object", ">", "context", ",", "String", "template", ")", "{", "if", "(", "context", "==", "null", "||", "StringUtils", ".", "isBlank", "(", "template", ")", ")", "{", "return", "\"", "\"", ";", "}", "Writer", "writer", "=", "new", "StringWriter", "(", ")", ";", "try", "{", "Mustache", ".", "compiler", "(", ")", ".", "escapeHTML", "(", "false", ")", ".", "emptyStringIsFalse", "(", "true", ")", ".", "compile", "(", "template", ")", ".", "execute", "(", "context", ",", "writer", ")", ";", "}", "finally", "{", "try", "{", "writer", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "logger", ".", "error", "(", "null", ",", "e", ")", ";", "}", "}", "return", "writer", ".", "toString", "(", ")", ";", "}"], "idx": 79741, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "9d844f31333475a0394dd14b901ea50674b281f8", "function_name": "compileMustache", "body_hash": "371bd38ae288bed070ae19ed3738abbcfb794a27"}
{"code": "protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {\n        boolean isValid = false;\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Binding the user.\");\n        }\n        context.addToEnvironment(Context.SECURITY_AUTHENTICATION, \"simple\");\n        context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);\n        context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n        try {\n            context.getAttributes(\"\", null);\n            isValid = true;\n            if (log.isDebugEnabled()) {\n                log.debug(\"User \" + dn + \" successfully bound.\");\n            }\n        } catch (AuthenticationException e) {\n            isValid = false;\n            if (log.isDebugEnabled()) {\n                log.debug(\"Authentication failed for dn=\" + dn);\n            }\n        }\n\n        if (isLoginPropertySet(CONNECTION_USERNAME)) {\n            context.addToEnvironment(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));\n        } else {\n            context.removeFromEnvironment(Context.SECURITY_PRINCIPAL);\n        }\n        if (isLoginPropertySet(CONNECTION_PASSWORD)) {\n            context.addToEnvironment(Context.SECURITY_CREDENTIALS, getLDAPPropertyValue(CONNECTION_PASSWORD));\n        } else {\n            context.removeFromEnvironment(Context.SECURITY_CREDENTIALS);\n        }\n        context.addToEnvironment(Context.SECURITY_AUTHENTICATION, getLDAPPropertyValue(AUTHENTICATION));\n        return isValid;\n    }", "code_tokens": ["protected", "boolean", "bindUser", "(", "DirContext", "context", ",", "String", "dn", ",", "String", "password", ")", "throws", "NamingException", "{", "boolean", "isValid", "=", "false", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Binding the user.", "\"", ")", ";", "}", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "\"", "simple", "\"", ")", ";", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "dn", ")", ";", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "password", ")", ";", "try", "{", "context", ".", "getAttributes", "(", "\"", "\"", ",", "null", ")", ";", "isValid", "=", "true", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "User ", "\"", "+", "dn", "+", "\"", " successfully bound.", "\"", ")", ";", "}", "}", "catch", "(", "AuthenticationException", "e", ")", "{", "isValid", "=", "false", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "\"", "Authentication failed for dn=", "\"", "+", "dn", ")", ";", "}", "}", "if", "(", "isLoginPropertySet", "(", "CONNECTION_USERNAME", ")", ")", "{", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ",", "getLDAPPropertyValue", "(", "CONNECTION_USERNAME", ")", ")", ";", "}", "else", "{", "context", ".", "removeFromEnvironment", "(", "Context", ".", "SECURITY_PRINCIPAL", ")", ";", "}", "if", "(", "isLoginPropertySet", "(", "CONNECTION_PASSWORD", ")", ")", "{", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ",", "getLDAPPropertyValue", "(", "CONNECTION_PASSWORD", ")", ")", ";", "}", "else", "{", "context", ".", "removeFromEnvironment", "(", "Context", ".", "SECURITY_CREDENTIALS", ")", ";", "}", "context", ".", "addToEnvironment", "(", "Context", ".", "SECURITY_AUTHENTICATION", ",", "getLDAPPropertyValue", "(", "AUTHENTICATION", ")", ")", ";", "return", "isValid", ";", "}"], "idx": 38235, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "73e291693d59a96c0054fc7e7e09c2c67b192911", "function_name": "bindUser", "body_hash": "0b78c21e9e387777859b6d7b460fee7605f6ddf6"}
{"code": "private void prepareRequest() {\n\n        // Translate the HTTP method code to a String.\n        byte methodCode = requestHeaderMessage.getByte();\n        if (methodCode != Constants.SC_M_JK_STORED) {\n            String methodName = Constants.getMethodForCode(methodCode - 1);\n            request.method().setString(methodName);\n        }\n\n        requestHeaderMessage.getBytes(request.protocol());\n        requestHeaderMessage.getBytes(request.requestURI());\n\n        requestHeaderMessage.getBytes(request.remoteAddr());\n        requestHeaderMessage.getBytes(request.remoteHost());\n        requestHeaderMessage.getBytes(request.localName());\n        request.setLocalPort(requestHeaderMessage.getInt());\n\n        boolean isSSL = requestHeaderMessage.getByte() != 0;\n        if (isSSL) {\n            request.scheme().setString(\"https\");\n        }\n\n        // Decode headers\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Set this every time in case limit has been changed via JMX\n        headers.setLimit(protocol.getMaxHeaderCount());\n\n        boolean contentLengthSet = false;\n        int hCount = requestHeaderMessage.getInt();\n        for(int i = 0 ; i < hCount ; i++) {\n            String hName = null;\n\n            // Header names are encoded as either an integer code starting\n            // with 0xA0, or as a normal string (in which case the first\n            // two bytes are the length).\n            int isc = requestHeaderMessage.peekInt();\n            int hId = isc & 0xFF;\n\n            MessageBytes vMB = null;\n            isc &= 0xFF00;\n            if(0xA000 == isc) {\n                requestHeaderMessage.getInt(); // To advance the read position\n                hName = Constants.getHeaderForCode(hId - 1);\n                vMB = headers.addValue(hName);\n            } else {\n                // reset hId -- if the header currently being read\n                // happens to be 7 or 8 bytes long, the code below\n                // will think it's the content-type header or the\n                // content-length header - SC_REQ_CONTENT_TYPE=7,\n                // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected\n                // behaviour.  see bug 5861 for more information.\n                hId = -1;\n                requestHeaderMessage.getBytes(tmpMB);\n                ByteChunk bc = tmpMB.getByteChunk();\n                vMB = headers.addValue(bc.getBuffer(),\n                        bc.getStart(), bc.getLength());\n            }\n\n            requestHeaderMessage.getBytes(vMB);\n\n            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Length\"))) {\n                long cl = vMB.getLong();\n                if (contentLengthSet) {\n                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                } else {\n                    contentLengthSet = true;\n                    // Set the content-length header for the request\n                    request.setContentLength(cl);\n                }\n            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Type\"))) {\n                // just read the content-type header, so set it\n                ByteChunk bchunk = vMB.getByteChunk();\n                request.contentType().setBytes(bchunk.getBytes(),\n                        bchunk.getOffset(),\n                        bchunk.getLength());\n            }\n        }\n\n        // Decode extra attributes\n        String secret = protocol.getSecret();\n        boolean secretPresentInRequest = false;\n        byte attributeCode;\n        while ((attributeCode = requestHeaderMessage.getByte())\n                != Constants.SC_A_ARE_DONE) {\n\n            switch (attributeCode) {\n\n            case Constants.SC_A_REQ_ATTRIBUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                String n = tmpMB.toString();\n                requestHeaderMessage.getBytes(tmpMB);\n                String v = tmpMB.toString();\n                /*\n                 * AJP13 misses to forward the local IP address and the\n                 * remote port. Allow the AJP connector to add this info via\n                 * private request attributes.\n                 * We will accept the forwarded data and remove it from the\n                 * public list of request attributes.\n                 */\n                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {\n                    request.localAddr().setString(v);\n                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {\n                    try {\n                        request.setRemotePort(Integer.parseInt(v));\n                    } catch (NumberFormatException nfe) {\n                        // Ignore invalid value\n                    }\n                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {\n                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);\n                } else {\n                    request.setAttribute(n, v );\n                }\n                break;\n\n            case Constants.SC_A_CONTEXT :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SERVLET_PATH :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_REMOTE_USER :\n                boolean tomcatAuthorization  = protocol.getTomcatAuthorization();\n                if (tomcatAuthorization || !protocol.getTomcatAuthentication()) {\n                    // Implies tomcatAuthentication == false\n                    requestHeaderMessage.getBytes(request.getRemoteUser());\n                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);\n                } else {\n                    // Ignore user information from reverse proxy\n                    requestHeaderMessage.getBytes(tmpMB);\n                }\n                break;\n\n            case Constants.SC_A_AUTH_TYPE :\n                if (protocol.getTomcatAuthentication()) {\n                    // ignore server\n                    requestHeaderMessage.getBytes(tmpMB);\n                } else {\n                    requestHeaderMessage.getBytes(request.getAuthType());\n                }\n                break;\n\n            case Constants.SC_A_QUERY_STRING :\n                requestHeaderMessage.getBytes(request.queryString());\n                break;\n\n            case Constants.SC_A_JVM_ROUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SSL_CERT :\n                // SSL certificate extraction is lazy, moved to JkCoyoteHandler\n                requestHeaderMessage.getBytes(certificates);\n                break;\n\n            case Constants.SC_A_SSL_CIPHER :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_SESSION :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.SESSION_ID_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_KEY_SIZE :\n                request.setAttribute(SSLSupport.KEY_SIZE_KEY,\n                        Integer.valueOf(requestHeaderMessage.getInt()));\n                break;\n\n            case Constants.SC_A_STORED_METHOD:\n                requestHeaderMessage.getBytes(request.method());\n                break;\n\n            case Constants.SC_A_SECRET:\n                requestHeaderMessage.getBytes(tmpMB);\n                if (secret != null) {\n                    secretPresentInRequest = true;\n                    if (!tmpMB.equals(secret)) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    }\n                }\n                break;\n\n            default:\n                // Ignore unknown attribute for backward compatibility\n                break;\n\n            }\n\n        }\n\n        // Check if secret was submitted if required\n        if ((secret != null) && !secretPresentInRequest) {\n            response.setStatus(403);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n        }\n\n        // Check for a full URI (including protocol://host:port/)\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\"\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + slashPos,\n                            uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                        slashPos - pos - 3);\n            }\n\n        }\n\n        MessageBytes valueMB = request.getMimeHeaders().getValue(\"host\");\n        parseHost(valueMB);\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "{", "byte", "methodCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ";", "if", "(", "methodCode", "!=", "Constants", ".", "SC_M_JK_STORED", ")", "{", "String", "methodName", "=", "Constants", ".", "getMethodForCode", "(", "methodCode", "-", "1", ")", ";", "request", ".", "method", "(", ")", ".", "setString", "(", "methodName", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "protocol", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "requestURI", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteAddr", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteHost", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "localName", "(", ")", ")", ";", "request", ".", "setLocalPort", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ";", "boolean", "isSSL", "=", "requestHeaderMessage", ".", "getByte", "(", ")", "!=", "0", ";", "if", "(", "isSSL", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "headers", ".", "setLimit", "(", "protocol", ".", "getMaxHeaderCount", "(", ")", ")", ";", "boolean", "contentLengthSet", "=", "false", ";", "int", "hCount", "=", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hCount", ";", "i", "++", ")", "{", "String", "hName", "=", "null", ";", "int", "isc", "=", "requestHeaderMessage", ".", "peekInt", "(", ")", ";", "int", "hId", "=", "isc", "&", "0xFF", ";", "MessageBytes", "vMB", "=", "null", ";", "isc", "&=", "0xFF00", ";", "if", "(", "0xA000", "==", "isc", ")", "{", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "hName", "=", "Constants", ".", "getHeaderForCode", "(", "hId", "-", "1", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "hName", ")", ";", "}", "else", "{", "hId", "=", "-", "1", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "ByteChunk", "bc", "=", "tmpMB", ".", "getByteChunk", "(", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "bc", ".", "getBuffer", "(", ")", ",", "bc", ".", "getStart", "(", ")", ",", "bc", ".", "getLength", "(", ")", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "vMB", ")", ";", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_LENGTH", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Length", "\"", ")", ")", ")", "{", "long", "cl", "=", "vMB", ".", "getLong", "(", ")", ";", "if", "(", "contentLengthSet", ")", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "else", "{", "contentLengthSet", "=", "true", ";", "request", ".", "setContentLength", "(", "cl", ")", ";", "}", "}", "else", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_TYPE", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Type", "\"", ")", ")", ")", "{", "ByteChunk", "bchunk", "=", "vMB", ".", "getByteChunk", "(", ")", ";", "request", ".", "contentType", "(", ")", ".", "setBytes", "(", "bchunk", ".", "getBytes", "(", ")", ",", "bchunk", ".", "getOffset", "(", ")", ",", "bchunk", ".", "getLength", "(", ")", ")", ";", "}", "}", "String", "secret", "=", "protocol", ".", "getSecret", "(", ")", ";", "boolean", "secretPresentInRequest", "=", "false", ";", "byte", "attributeCode", ";", "while", "(", "(", "attributeCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ")", "!=", "Constants", ".", "SC_A_ARE_DONE", ")", "{", "switch", "(", "attributeCode", ")", "{", "case", "Constants", ".", "SC_A_REQ_ATTRIBUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "n", "=", "tmpMB", ".", "toString", "(", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "v", "=", "tmpMB", ".", "toString", "(", ")", ";", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_LOCAL_ADDR", ")", ")", "{", "request", ".", "localAddr", "(", ")", ".", "setString", "(", "v", ")", ";", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_REMOTE_PORT", ")", ")", "{", "try", "{", "request", ".", "setRemotePort", "(", "Integer", ".", "parseInt", "(", "v", ")", ")", ";", "}", "catch", "(", "NumberFormatException", "nfe", ")", "{", "}", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_SSL_PROTOCOL", ")", ")", "{", "request", ".", "setAttribute", "(", "SSLSupport", ".", "PROTOCOL_VERSION_KEY", ",", "v", ")", ";", "}", "else", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_CONTEXT", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SERVLET_PATH", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_REMOTE_USER", ":", "boolean", "tomcatAuthorization", "=", "protocol", ".", "getTomcatAuthorization", "(", ")", ";", "if", "(", "tomcatAuthorization", "||", "!", "protocol", ".", "getTomcatAuthentication", "(", ")", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getRemoteUser", "(", ")", ")", ";", "request", ".", "setRemoteUserNeedsAuthorization", "(", "tomcatAuthorization", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_AUTH_TYPE", ":", "if", "(", "protocol", ".", "getTomcatAuthentication", "(", ")", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getAuthType", "(", ")", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_QUERY_STRING", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "queryString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_JVM_ROUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CERT", ":", "requestHeaderMessage", ".", "getBytes", "(", "certificates", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CIPHER", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "CIPHER_SUITE_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_SESSION", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "SESSION_ID_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_KEY_SIZE", ":", "request", ".", "setAttribute", "(", "SSLSupport", ".", "KEY_SIZE_KEY", ",", "Integer", ".", "valueOf", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_STORED_METHOD", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "method", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SECRET", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "if", "(", "secret", "!=", "null", ")", "{", "secretPresentInRequest", "=", "true", ";", "if", "(", "!", "tmpMB", ".", "equals", "(", "secret", ")", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "break", ";", "default", ":", "break", ";", "}", "}", "if", "(", "(", "secret", "!=", "null", ")", "&&", "!", "secretPresentInRequest", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "uriBC", ".", "indexOf", "(", "\"", "://", "\"", ",", "0", ",", "3", ",", "4", ")", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "-", "1", ";", "if", "(", "pos", "!=", "-", "1", ")", "{", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", "+", "3", ")", ";", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "1", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "MessageBytes", "hostMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "3", ",", "slashPos", "-", "pos", "-", "3", ")", ";", "}", "}", "MessageBytes", "valueMB", "=", "request", ".", "getMimeHeaders", "(", ")", ".", "getValue", "(", "\"", "host", "\"", ")", ";", "parseHost", "(", "valueMB", ")", ";", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 112500, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "64fa5b99442589ef0bf2a7fcd71ad2bc68b35fad", "function_name": "prepareRequest", "body_hash": "45a9ed35c12367c1ec14e2673b0ef519371942df"}
{"code": "protected void error(HttpServletRequest request,\n                         HttpServletResponse response,\n                         Throwable e)\n    {\n        String path = ServletUtils.getPath(request);\n        if (response.isCommitted())\n        {\n            getLog().error(\"An error occured but the response headers have already been sent.\");\n            getLog().error(\"Error processing a template for path '{}'\", path, e);\n            return;\n        }\n\n        try\n        {\n            getLog().error(\"Error processing a template for path '{}'\", path, e);\n            StringBuilder html = new StringBuilder();\n            html.append(\"<html>\\n\");\n            html.append(\"<head><title>Error</title></head>\\n\");\n            html.append(\"<body>\\n\");\n            html.append(\"<h2>VelocityView : Error processing a template for path '\");\n            html.append(path);\n            html.append(\"'</h2>\\n\");\n\n            Throwable cause = e;\n\n            String why = cause.getMessage();\n            if (why != null && why.length() > 0)\n            {\n                html.append(StringEscapeUtils.escapeHtml4(why));\n                html.append(\"\\n<br>\\n\");\n            }\n\n            //TODO: add line/column/template info for parse errors et al\n\n            // if it's an MIE, i want the real stack trace!\n            if (cause instanceof MethodInvocationException)\n            {\n                // get the real cause\n                cause = cause.getCause();\n            }\n\n            StringWriter sw = new StringWriter();\n            cause.printStackTrace(new PrintWriter(sw));\n\n            html.append(\"<pre>\\n\");\n            html.append(StringEscapeUtils.escapeHtml4(sw.toString()));\n            html.append(\"</pre>\\n\");\n            html.append(\"</body>\\n\");\n            html.append(\"</html>\");\n            response.getWriter().write(html.toString());\n        }\n        catch (Exception e2)\n        {\n            // clearly something is quite wrong.\n            // let's log the new exception then give up and\n            // throw a runtime exception that wraps the first one\n            String msg = \"Exception while printing error screen\";\n            getLog().error(msg, e2);\n            throw new RuntimeException(msg, e);\n        }\n    }", "code_tokens": ["protected", "void", "error", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "Throwable", "e", ")", "{", "String", "path", "=", "ServletUtils", ".", "getPath", "(", "request", ")", ";", "if", "(", "response", ".", "isCommitted", "(", ")", ")", "{", "getLog", "(", ")", ".", "error", "(", "\"", "An error occured but the response headers have already been sent.", "\"", ")", ";", "getLog", "(", ")", ".", "error", "(", "\"", "Error processing a template for path '{}'", "\"", ",", "path", ",", "e", ")", ";", "return", ";", "}", "try", "{", "getLog", "(", ")", ".", "error", "(", "\"", "Error processing a template for path '{}'", "\"", ",", "path", ",", "e", ")", ";", "StringBuilder", "html", "=", "new", "StringBuilder", "(", ")", ";", "html", ".", "append", "(", "\"", "<html>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "<head><title>Error</title></head>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "<body>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "<h2>VelocityView : Error processing a template for path '", "\"", ")", ";", "html", ".", "append", "(", "path", ")", ";", "html", ".", "append", "(", "\"", "'</h2>", "\\n", "\"", ")", ";", "Throwable", "cause", "=", "e", ";", "String", "why", "=", "cause", ".", "getMessage", "(", ")", ";", "if", "(", "why", "!=", "null", "&&", "why", ".", "length", "(", ")", ">", "0", ")", "{", "html", ".", "append", "(", "StringEscapeUtils", ".", "escapeHtml4", "(", "why", ")", ")", ";", "html", ".", "append", "(", "\"", "\\n", "<br>", "\\n", "\"", ")", ";", "}", "if", "(", "cause", "instanceof", "MethodInvocationException", ")", "{", "cause", "=", "cause", ".", "getCause", "(", ")", ";", "}", "StringWriter", "sw", "=", "new", "StringWriter", "(", ")", ";", "cause", ".", "printStackTrace", "(", "new", "PrintWriter", "(", "sw", ")", ")", ";", "html", ".", "append", "(", "\"", "<pre>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "StringEscapeUtils", ".", "escapeHtml4", "(", "sw", ".", "toString", "(", ")", ")", ")", ";", "html", ".", "append", "(", "\"", "</pre>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "</body>", "\\n", "\"", ")", ";", "html", ".", "append", "(", "\"", "</html>", "\"", ")", ";", "response", ".", "getWriter", "(", ")", ".", "write", "(", "html", ".", "toString", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e2", ")", "{", "String", "msg", "=", "\"", "Exception while printing error screen", "\"", ";", "getLog", "(", ")", ".", "error", "(", "msg", ",", "e2", ")", ";", "throw", "new", "RuntimeException", "(", "msg", ",", "e", ")", ";", "}", "}"], "idx": 81495, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "e141828a4eb03e4b0224535eed12b5c463a24152", "function_name": "error", "body_hash": "ad11680a426fdaf168d2c94c5fa210675388dd97"}
{"code": "protected int indexOf(char c, int pos) {\n\t\tfor (int i = pos; i < len; i++)\n\t\t\tif (in[i] == (byte) c)\n\t\t\t\treturn i;\n\t\treturn -1;\n\t}", "code_tokens": ["protected", "int", "indexOf", "(", "char", "c", ",", "int", "pos", ")", "{", "for", "(", "int", "i", "=", "pos", ";", "i", "<", "len", ";", "i", "++", ")", "if", "(", "in", "[", "i", "]", "==", "(", "byte", ")", "c", ")", "return", "i", ";", "return", "-", "1", ";", "}"], "idx": 77450, "cwe": "CWE-787", "target": 0, "status": "FIXED", "commit": "6ecff1c2974eaaab2e74e441bdf5ba8495227bf5", "function_name": "indexOf", "body_hash": "381192fc2b74c1c83c488dfde921ff2d3acac382"}
{"code": "@Override\n    public void encodeBegin(FacesContext context, UIComponent component) throws IOException\n    {\n        super.encodeBegin(context, component);\n\n        lazyInit();\n\n        ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =\n                clientWindowConfig.getClientWindowRenderMode(context);\n\n        // see DELTASPIKE-1113\n        boolean delegatedWindowMode =\n            ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode);\n        if (delegatedWindowMode)\n        {\n            return;\n        }\n\n        String windowId = clientWindow.getWindowId(context);\n        // just to get sure if a user provides a own client window\n        windowId = secureWindowId(windowId);\n\n        ResponseWriter writer = context.getResponseWriter();\n        writer.write(\"<script type=\\\"text/javascript\\\">\");\n        writer.write(\"(function(){\");\n        writer.write(\"dswh.init('\");\n        writer.writeText(windowId, null);\n        writer.write(\"','\"\n                + clientWindowRenderMode.name() + \"',\"\n                + maxWindowIdLength + \",{\");\n\n        writer.write(\"'tokenizedRedirect':\" + clientWindowConfig.isClientWindowTokenizedRedirectEnabled());\n        writer.write(\",'storeWindowTreeOnLinkClick':\"\n                + clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnLinkClick());\n        writer.write(\",'storeWindowTreeOnButtonClick':\"\n                + clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnButtonClick());\n\n        // see #729\n        if (clientWindow.isInitialRedirectSupported(context))\n        {\n            Object cookie = ClientWindowHelper.getRequestWindowIdCookie(context, windowId);\n            if (cookie != null && cookie instanceof Cookie)\n            {\n                Cookie servletCookie = (Cookie) cookie;\n                writer.write(\",'initialRedirectWindowId':'\" + secureWindowId(servletCookie.getValue()) + \"'\");\n                // expire/remove cookie\n                servletCookie.setMaxAge(0);\n                ((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(servletCookie);\n            }\n        }\n\n        writer.write(\"});\");\n        writer.write(\"})();\");\n        writer.write(\"</script>\");\n    }", "code_tokens": ["@", "Override", "public", "void", "encodeBegin", "(", "FacesContext", "context", ",", "UIComponent", "component", ")", "throws", "IOException", "{", "super", ".", "encodeBegin", "(", "context", ",", "component", ")", ";", "lazyInit", "(", ")", ";", "ClientWindowConfig", ".", "ClientWindowRenderMode", "clientWindowRenderMode", "=", "clientWindowConfig", ".", "getClientWindowRenderMode", "(", "context", ")", ";", "boolean", "delegatedWindowMode", "=", "ClientWindowConfig", ".", "ClientWindowRenderMode", ".", "DELEGATED", ".", "equals", "(", "clientWindowRenderMode", ")", ";", "if", "(", "delegatedWindowMode", ")", "{", "return", ";", "}", "String", "windowId", "=", "clientWindow", ".", "getWindowId", "(", "context", ")", ";", "windowId", "=", "secureWindowId", "(", "windowId", ")", ";", "ResponseWriter", "writer", "=", "context", ".", "getResponseWriter", "(", ")", ";", "writer", ".", "write", "(", "\"", "<script type=", "\\\"", "text/javascript", "\\\"", ">", "\"", ")", ";", "writer", ".", "write", "(", "\"", "(function(){", "\"", ")", ";", "writer", ".", "write", "(", "\"", "dswh.init('", "\"", ")", ";", "writer", ".", "writeText", "(", "windowId", ",", "null", ")", ";", "writer", ".", "write", "(", "\"", "','", "\"", "+", "clientWindowRenderMode", ".", "name", "(", ")", "+", "\"", "',", "\"", "+", "maxWindowIdLength", "+", "\"", ",{", "\"", ")", ";", "writer", ".", "write", "(", "\"", "'tokenizedRedirect':", "\"", "+", "clientWindowConfig", ".", "isClientWindowTokenizedRedirectEnabled", "(", ")", ")", ";", "writer", ".", "write", "(", "\"", ",'storeWindowTreeOnLinkClick':", "\"", "+", "clientWindowConfig", ".", "isClientWindowStoreWindowTreeEnabledOnLinkClick", "(", ")", ")", ";", "writer", ".", "write", "(", "\"", ",'storeWindowTreeOnButtonClick':", "\"", "+", "clientWindowConfig", ".", "isClientWindowStoreWindowTreeEnabledOnButtonClick", "(", ")", ")", ";", "if", "(", "clientWindow", ".", "isInitialRedirectSupported", "(", "context", ")", ")", "{", "Object", "cookie", "=", "ClientWindowHelper", ".", "getRequestWindowIdCookie", "(", "context", ",", "windowId", ")", ";", "if", "(", "cookie", "!=", "null", "&&", "cookie", "instanceof", "Cookie", ")", "{", "Cookie", "servletCookie", "=", "(", "Cookie", ")", "cookie", ";", "writer", ".", "write", "(", "\"", ",'initialRedirectWindowId':'", "\"", "+", "secureWindowId", "(", "servletCookie", ".", "getValue", "(", ")", ")", "+", "\"", "'", "\"", ")", ";", "servletCookie", ".", "setMaxAge", "(", "0", ")", ";", "(", "(", "HttpServletResponse", ")", "context", ".", "getExternalContext", "(", ")", ".", "getResponse", "(", ")", ")", ".", "addCookie", "(", "servletCookie", ")", ";", "}", "}", "writer", ".", "write", "(", "\"", "});", "\"", ")", ";", "writer", ".", "write", "(", "\"", "})();", "\"", ")", ";", "writer", ".", "write", "(", "\"", "</script>", "\"", ")", ";", "}"], "idx": 79081, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "4e250235", "function_name": "encodeBegin", "body_hash": "bcbef312d302816da85c1fba692df4876c614105"}
{"code": "@Override\n\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t\tif (this.jsonPrefix != null) {\n\t\t\tgenerator.writeRaw(this.jsonPrefix);\n\t\t}\n\t\tString jsonpFunction =\n\t\t\t\t(object instanceof MappingJacksonValue ? ((MappingJacksonValue) object).getJsonpFunction() : null);\n\t\tif (jsonpFunction != null) {\n\t\t\tgenerator.writeRaw(\"/**/\");\n\t\t\tgenerator.writeRaw(jsonpFunction + \"(\");\n\t\t}\n\t}", "code_tokens": ["@", "Override", "protected", "void", "writePrefix", "(", "JsonGenerator", "generator", ",", "Object", "object", ")", "throws", "IOException", "{", "if", "(", "this", ".", "jsonPrefix", "!=", "null", ")", "{", "generator", ".", "writeRaw", "(", "this", ".", "jsonPrefix", ")", ";", "}", "String", "jsonpFunction", "=", "(", "object", "instanceof", "MappingJacksonValue", "?", "(", "(", "MappingJacksonValue", ")", "object", ")", ".", "getJsonpFunction", "(", ")", ":", "null", ")", ";", "if", "(", "jsonpFunction", "!=", "null", ")", "{", "generator", ".", "writeRaw", "(", "\"", "/**/", "\"", ")", ";", "generator", ".", "writeRaw", "(", "jsonpFunction", "+", "\"", "(", "\"", ")", ";", "}", "}"], "idx": 81892, "cwe": "CWE-829", "target": 1, "status": "VULNERABLE", "commit": "ac37b678a3ac9ee541a10e8ad74d612bb9ec5b88", "function_name": "writePrefix", "body_hash": "3e574dd1b59485ef567a70b75871da7643eed728"}
{"code": "private static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n\n\t\tif (base.size() > 1000) {\n\t\t\tthrow new IllegalArgumentException(PARSE_DEPTH_EXCEEDED);\n\t\t}\n\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n\n\t\ttry {\n\n\t\t\tcurrent = new PropertyPath(source, type, base);\n\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n\n\t\t\tList<PropertyPath> newBase = new ArrayList<PropertyPath>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.type, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}", "code_tokens": ["private", "static", "PropertyPath", "create", "(", "String", "source", ",", "TypeInformation", "<", "?", ">", "type", ",", "String", "addTail", ",", "List", "<", "PropertyPath", ">", "base", ")", "{", "if", "(", "base", ".", "size", "(", ")", ">", "1000", ")", "{", "throw", "new", "IllegalArgumentException", "(", "PARSE_DEPTH_EXCEEDED", ")", ";", "}", "PropertyReferenceException", "exception", "=", "null", ";", "PropertyPath", "current", "=", "null", ";", "try", "{", "current", "=", "new", "PropertyPath", "(", "source", ",", "type", ",", "base", ")", ";", "if", "(", "!", "base", ".", "isEmpty", "(", ")", ")", "{", "base", ".", "get", "(", "base", ".", "size", "(", ")", "-", "1", ")", ".", "next", "=", "current", ";", "}", "List", "<", "PropertyPath", ">", "newBase", "=", "new", "ArrayList", "<", "PropertyPath", ">", "(", "base", ")", ";", "newBase", ".", "add", "(", "current", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "addTail", ")", ")", "{", "current", ".", "next", "=", "create", "(", "addTail", ",", "current", ".", "type", ",", "newBase", ")", ";", "}", "return", "current", ";", "}", "catch", "(", "PropertyReferenceException", "e", ")", "{", "if", "(", "current", "!=", "null", ")", "{", "throw", "e", ";", "}", "exception", "=", "e", ";", "}", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "\"", "\\\\", "p{Lu}+", "\\\\", "p{Ll}*$", "\"", ")", ";", "Matcher", "matcher", "=", "pattern", ".", "matcher", "(", "source", ")", ";", "if", "(", "matcher", ".", "find", "(", ")", "&&", "matcher", ".", "start", "(", ")", "!=", "0", ")", "{", "int", "position", "=", "matcher", ".", "start", "(", ")", ";", "String", "head", "=", "source", ".", "substring", "(", "0", ",", "position", ")", ";", "String", "tail", "=", "source", ".", "substring", "(", "position", ")", ";", "try", "{", "return", "create", "(", "head", ",", "type", ",", "tail", "+", "addTail", ",", "base", ")", ";", "}", "catch", "(", "PropertyReferenceException", "e", ")", "{", "throw", "e", ".", "hasDeeperResolutionDepthThan", "(", "exception", ")", "?", "e", ":", "exception", ";", "}", "}", "throw", "exception", ";", "}"], "idx": 76309, "cwe": "CWE-770", "target": 0, "status": "FIXED", "commit": "371f6590c509c72f8e600f3d05e110941607fba", "function_name": "create", "body_hash": "66f647d9c784f0f7c47c1f8c2966b4d5face5815"}
{"code": "public void install(\n            String displayName, String description, String[] dependencies,\n            String account, String password, String config) throws URISyntaxException {\n\n        String javaHome = System.getProperty(\"java.home\");\n        String javaBinary = javaHome + \"\\\\bin\\\\java.exe\";\n\n        File jar = new File(WindowsService.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n        String command = javaBinary\n                + \" -Duser.dir=\\\"\" + jar.getParentFile().getAbsolutePath() + \"\\\"\"\n                + \" -jar \\\"\" + jar.getAbsolutePath() + \"\\\"\"\n                + \" --service \\\"\" + config + \"\\\"\";\n\n        StringBuilder dep = new StringBuilder();\n\n        if (dependencies != null) {\n            for (String s : dependencies) {\n                dep.append(s);\n                dep.append(\"\\0\");\n            }\n        }\n        dep.append(\"\\0\");\n\n        SERVICE_DESCRIPTION desc = new SERVICE_DESCRIPTION();\n        desc.lpDescription = description;\n\n        SC_HANDLE serviceManager = openServiceControlManager(null, Winsvc.SC_MANAGER_ALL_ACCESS);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = ADVAPI_32.CreateService(serviceManager, serviceName, displayName,\n                    Winsvc.SERVICE_ALL_ACCESS, WinNT.SERVICE_WIN32_OWN_PROCESS, WinNT.SERVICE_AUTO_START,\n                    WinNT.SERVICE_ERROR_NORMAL,\n                    command,\n                    null, null, dep.toString(), account, password);\n\n            if (service != null) {\n                ADVAPI_32.ChangeServiceConfig2(service, Winsvc.SERVICE_CONFIG_DESCRIPTION, desc);\n                ADVAPI_32.CloseServiceHandle(service);\n            }\n            ADVAPI_32.CloseServiceHandle(serviceManager);\n        }\n    }", "code_tokens": ["public", "void", "install", "(", "String", "displayName", ",", "String", "description", ",", "String", "[", "]", "dependencies", ",", "String", "account", ",", "String", "password", ",", "String", "config", ")", "throws", "URISyntaxException", "{", "String", "javaHome", "=", "System", ".", "getProperty", "(", "\"", "java.home", "\"", ")", ";", "String", "javaBinary", "=", "javaHome", "+", "\"", "\\\\", "bin", "\\\\", "java.exe", "\"", ";", "File", "jar", "=", "new", "File", "(", "WindowsService", ".", "class", ".", "getProtectionDomain", "(", ")", ".", "getCodeSource", "(", ")", ".", "getLocation", "(", ")", ".", "toURI", "(", ")", ")", ";", "String", "command", "=", "javaBinary", "+", "\"", " -Duser.dir=", "\\\"", "\"", "+", "jar", ".", "getParentFile", "(", ")", ".", "getAbsolutePath", "(", ")", "+", "\"", "\\\"", "\"", "+", "\"", " -jar ", "\\\"", "\"", "+", "jar", ".", "getAbsolutePath", "(", ")", "+", "\"", "\\\"", "\"", "+", "\"", " --service ", "\\\"", "\"", "+", "config", "+", "\"", "\\\"", "\"", ";", "StringBuilder", "dep", "=", "new", "StringBuilder", "(", ")", ";", "if", "(", "dependencies", "!=", "null", ")", "{", "for", "(", "String", "s", ":", "dependencies", ")", "{", "dep", ".", "append", "(", "s", ")", ";", "dep", ".", "append", "(", "\"", "\\0", "\"", ")", ";", "}", "}", "dep", ".", "append", "(", "\"", "\\0", "\"", ")", ";", "SERVICE_DESCRIPTION", "desc", "=", "new", "SERVICE_DESCRIPTION", "(", ")", ";", "desc", ".", "lpDescription", "=", "description", ";", "SC_HANDLE", "serviceManager", "=", "openServiceControlManager", "(", "null", ",", "Winsvc", ".", "SC_MANAGER_ALL_ACCESS", ")", ";", "if", "(", "serviceManager", "!=", "null", ")", "{", "SC_HANDLE", "service", "=", "ADVAPI_32", ".", "CreateService", "(", "serviceManager", ",", "serviceName", ",", "displayName", ",", "Winsvc", ".", "SERVICE_ALL_ACCESS", ",", "WinNT", ".", "SERVICE_WIN32_OWN_PROCESS", ",", "WinNT", ".", "SERVICE_AUTO_START", ",", "WinNT", ".", "SERVICE_ERROR_NORMAL", ",", "command", ",", "null", ",", "null", ",", "dep", ".", "toString", "(", ")", ",", "account", ",", "password", ")", ";", "if", "(", "service", "!=", "null", ")", "{", "ADVAPI_32", ".", "ChangeServiceConfig2", "(", "service", ",", "Winsvc", ".", "SERVICE_CONFIG_DESCRIPTION", ",", "desc", ")", ";", "ADVAPI_32", ".", "CloseServiceHandle", "(", "service", ")", ";", "}", "ADVAPI_32", ".", "CloseServiceHandle", "(", "serviceManager", ")", ";", "}", "}"], "idx": 53693, "cwe": "CWE-428", "target": 1, "status": "VULNERABLE", "commit": "cc69a9907ac9878db3750aa14ffedb28626455da", "function_name": "install", "body_hash": "ae9bc902fcf4de192fd79b639cb2972d6befbe5b"}
{"code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n\n        token = parseToken(tokenString, AccessToken.class);\n        idToken = parseToken(idTokenString, IDToken.class);\n    }", "code_tokens": ["private", "void", "readObject", "(", "ObjectInputStream", "in", ")", "throws", "IOException", ",", "ClassNotFoundException", "{", "in", ".", "defaultReadObject", "(", ")", ";", "token", "=", "parseToken", "(", "tokenString", ",", "AccessToken", ".", "class", ")", ";", "idToken", "=", "parseToken", "(", "idTokenString", ",", "IDToken", ".", "class", ")", ";", "}"], "idx": 6239, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "33863ba161", "function_name": "readObject", "body_hash": "ae3f84ca64705cb4431389c1246a15574b5da024"}
{"code": "public Column<T, V> setCaption(String caption) {\n            Objects.requireNonNull(caption, \"Header caption can't be null\");\n            if (caption.equals(getState(false).caption)) {\n                return this;\n            }\n            getState().caption = caption;\n\n            HeaderRow row = getGrid().getDefaultHeaderRow();\n            if (row != null) {\n                row.getCell(this).setText(caption);\n            }\n\n            return this;\n        }", "code_tokens": ["public", "Column", "<", "T", ",", "V", ">", "setCaption", "(", "String", "caption", ")", "{", "Objects", ".", "requireNonNull", "(", "caption", ",", "\"", "Header caption can't be null", "\"", ")", ";", "if", "(", "caption", ".", "equals", "(", "getState", "(", "false", ")", ".", "caption", ")", ")", "{", "return", "this", ";", "}", "getState", "(", ")", ".", "caption", "=", "caption", ";", "HeaderRow", "row", "=", "getGrid", "(", ")", ".", "getDefaultHeaderRow", "(", ")", ";", "if", "(", "row", "!=", "null", ")", "{", "row", ".", "getCell", "(", "this", ")", ".", "setText", "(", "caption", ")", ";", "}", "return", "this", ";", "}"], "idx": 80328, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "2584e9ad44fa9135daa405df8cbc9ae7d4a3ee33", "function_name": "setCaption", "body_hash": "30fbf63661d9573851112a8177c7ed3974147cff"}
{"code": "@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (unmarshalType != null) {\n            setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n        }\n        if (prettyPrint != null) {\n            setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n        }\n        if (jsonView != null) {\n            setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n        }\n        if (include != null) {\n            setProperty(camelContext, dataFormat, \"include\", include);\n        }\n        if (allowJmsType != null) {\n            setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n        }\n        if (collectionType != null) {\n            setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n        }\n        if (useList != null) {\n            setProperty(camelContext, dataFormat, \"useList\", useList);\n        }\n        if (enableJaxbAnnotationModule != null) {\n            setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n        }\n        if (moduleClassNames != null) {\n            setProperty(camelContext, dataFormat, \"modulesClassNames\", moduleClassNames);\n        }\n        if (moduleRefs != null) {\n            setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n        }\n        if (enableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n        }\n        if (disableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n        }\n    }", "code_tokens": ["@", "Override", "protected", "void", "configureDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "if", "(", "unmarshalType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "unmarshalType", "\"", ",", "unmarshalType", ")", ";", "}", "if", "(", "prettyPrint", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "prettyPrint", "\"", ",", "prettyPrint", ")", ";", "}", "if", "(", "jsonView", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "jsonView", "\"", ",", "jsonView", ")", ";", "}", "if", "(", "include", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "include", "\"", ",", "include", ")", ";", "}", "if", "(", "allowJmsType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "allowJmsType", "\"", ",", "allowJmsType", ")", ";", "}", "if", "(", "collectionType", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "collectionType", "\"", ",", "collectionType", ")", ";", "}", "if", "(", "useList", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "useList", "\"", ",", "useList", ")", ";", "}", "if", "(", "enableJaxbAnnotationModule", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableJaxbAnnotationModule", "\"", ",", "enableJaxbAnnotationModule", ")", ";", "}", "if", "(", "moduleClassNames", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "modulesClassNames", "\"", ",", "moduleClassNames", ")", ";", "}", "if", "(", "moduleRefs", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "moduleRefs", "\"", ",", "moduleRefs", ")", ";", "}", "if", "(", "enableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "enableFeatures", "\"", ",", "enableFeatures", ")", ";", "}", "if", "(", "disableFeatures", "!=", "null", ")", "{", "setProperty", "(", "camelContext", ",", "dataFormat", ",", "\"", "disableFeatures", "\"", ",", "disableFeatures", ")", ";", "}", "}"], "idx": 57501, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "ccf149c76bf37adc5977dc626e141a14e60b5ae", "function_name": "configureDataFormat", "body_hash": "10e415cf50dcc342bf3b89da709f7effc1eb3aa4"}
{"code": "@Override\n\tpublic void convertInput()\n\t{\n\t\tsuper.convertInput();\n\n\t\tfinal PolicyFactory policy = this.newPolicyFactory();\n\t\tfinal String input = this.getConvertedInput();\n\n\t\tthis.setConvertedInput(policy.sanitize(input));\n\t}", "code_tokens": ["@", "Override", "public", "void", "convertInput", "(", ")", "{", "super", ".", "convertInput", "(", ")", ";", "final", "PolicyFactory", "policy", "=", "this", ".", "newPolicyFactory", "(", ")", ";", "final", "String", "input", "=", "this", ".", "getConvertedInput", "(", ")", ";", "this", ".", "setConvertedInput", "(", "policy", ".", "sanitize", "(", "input", ")", ")", ";", "}"], "idx": 81753, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "936c12a2db262cf471c781f0d3c0d0ad61c35c7", "function_name": "convertInput", "body_hash": "2aea31ec3be27f2ac11f4a33f393a4576f939c61"}
{"code": "@SuppressWarnings(\"unchecked\")\n    private Jwt<?, Claims> authenticateToken(final String token) throws AuthenticationException {\n        try {\n            Jwt<?, Claims> jwt = Jwts.parser()\n                    .setSigningKey(validationKey)\n                    .parse(token);\n\n            if (audienceClaim != null) {\n                Object object = jwt.getBody().get(audienceClaim);\n                if (object == null) {\n                    throw new JwtException(\"Found null Audience in token, for claimed field: \" + audienceClaim);\n                }\n\n                if (object instanceof List) {\n                    List<String> audiences = (List<String>) object;\n                    // audience not contains this broker, throw exception.\n                    if (!audiences.stream().anyMatch(audienceInToken -> audienceInToken.equals(audience))) {\n                        throw new AuthenticationException(\"Audiences in token: [\" + String.join(\", \", audiences)\n                                                          + \"] not contains this broker: \" + audience);\n                    }\n                } else if (object instanceof String) {\n                    if (!object.equals(audience)) {\n                        throw new AuthenticationException(\"Audiences in token: [\" + object\n                                                          + \"] not contains this broker: \" + audience);\n                    }\n                } else {\n                    // should not reach here.\n                    throw new AuthenticationException(\"Audiences in token is not in expected format: \" + object);\n                }\n            }\n\n            return jwt;\n        } catch (JwtException e) {\n            throw new AuthenticationException(\"Failed to authentication token: \" + e.getMessage());\n        }\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "private", "Jwt", "<", "?", ",", "Claims", ">", "authenticateToken", "(", "final", "String", "token", ")", "throws", "AuthenticationException", "{", "try", "{", "Jwt", "<", "?", ",", "Claims", ">", "jwt", "=", "Jwts", ".", "parser", "(", ")", ".", "setSigningKey", "(", "validationKey", ")", ".", "parse", "(", "token", ")", ";", "if", "(", "audienceClaim", "!=", "null", ")", "{", "Object", "object", "=", "jwt", ".", "getBody", "(", ")", ".", "get", "(", "audienceClaim", ")", ";", "if", "(", "object", "==", "null", ")", "{", "throw", "new", "JwtException", "(", "\"", "Found null Audience in token, for claimed field: ", "\"", "+", "audienceClaim", ")", ";", "}", "if", "(", "object", "instanceof", "List", ")", "{", "List", "<", "String", ">", "audiences", "=", "(", "List", "<", "String", ">", ")", "object", ";", "if", "(", "!", "audiences", ".", "stream", "(", ")", ".", "anyMatch", "(", "audienceInToken", "->", "audienceInToken", ".", "equals", "(", "audience", ")", ")", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Audiences in token: [", "\"", "+", "String", ".", "join", "(", "\"", ", ", "\"", ",", "audiences", ")", "+", "\"", "] not contains this broker: ", "\"", "+", "audience", ")", ";", "}", "}", "else", "if", "(", "object", "instanceof", "String", ")", "{", "if", "(", "!", "object", ".", "equals", "(", "audience", ")", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Audiences in token: [", "\"", "+", "object", "+", "\"", "] not contains this broker: ", "\"", "+", "audience", ")", ";", "}", "}", "else", "{", "throw", "new", "AuthenticationException", "(", "\"", "Audiences in token is not in expected format: ", "\"", "+", "object", ")", ";", "}", "}", "return", "jwt", ";", "}", "catch", "(", "JwtException", "e", ")", "{", "throw", "new", "AuthenticationException", "(", "\"", "Failed to authentication token: ", "\"", "+", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}"], "idx": 43688, "cwe": "CWE-347", "target": 1, "status": "VULNERABLE", "commit": "67e7e0cd231", "function_name": "authenticateToken", "body_hash": "bc3860489c2978311b3320a1254da6f245e45877"}
{"code": "protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\n            \"java.beans.EventHandler\", //\n            \"java.lang.ProcessBuilder\", //\n            \"javax.imageio.ImageIO$ContainsFilter\", //\n            \"jdk.nashorn.internal.objects.NativeString\", //\n            \"com.sun.corba.se.impl.activation.ServerTableEntry\", //\n            \"com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator\", //\n            \"sun.awt.datatransfer.DataTransferer$IndexOrderComparator\", //\n            \"sun.swing.SwingLazyValue\"});\n        denyTypesByRegExp(new Pattern[]{\n            LAZY_ITERATORS, LAZY_ENUMERATORS, GETTER_SETTER_REFLECTION, PRIVILEGED_GETTER, JAVA_RMI, JAVAX_CRYPTO,\n            JAXWS_ITERATORS, JAVAFX_OBSERVABLE_LIST__, BCEL_CL});\n        denyTypeHierarchy(InputStream.class);\n        denyTypeHierarchyDynamically(\"java.nio.channels.Channel\");\n        denyTypeHierarchyDynamically(\"javax.activation.DataSource\");\n        denyTypeHierarchyDynamically(\"javax.sql.rowset.BaseRowSet\");\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }", "code_tokens": ["protected", "void", "setupSecurity", "(", ")", "{", "if", "(", "securityMapper", "==", "null", ")", "{", "return", ";", "}", "addPermission", "(", "AnyTypePermission", ".", "ANY", ")", ";", "denyTypes", "(", "new", "String", "[", "]", "{", "\"", "java.beans.EventHandler", "\"", ",", "\"", "java.lang.ProcessBuilder", "\"", ",", "\"", "javax.imageio.ImageIO$ContainsFilter", "\"", ",", "\"", "jdk.nashorn.internal.objects.NativeString", "\"", ",", "\"", "com.sun.corba.se.impl.activation.ServerTableEntry", "\"", ",", "\"", "com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator", "\"", ",", "\"", "sun.awt.datatransfer.DataTransferer$IndexOrderComparator", "\"", ",", "\"", "sun.swing.SwingLazyValue", "\"", "}", ")", ";", "denyTypesByRegExp", "(", "new", "Pattern", "[", "]", "{", "LAZY_ITERATORS", ",", "LAZY_ENUMERATORS", ",", "GETTER_SETTER_REFLECTION", ",", "PRIVILEGED_GETTER", ",", "JAVA_RMI", ",", "JAVAX_CRYPTO", ",", "JAXWS_ITERATORS", ",", "JAVAFX_OBSERVABLE_LIST__", ",", "BCEL_CL", "}", ")", ";", "denyTypeHierarchy", "(", "InputStream", ".", "class", ")", ";", "denyTypeHierarchyDynamically", "(", "\"", "java.nio.channels.Channel", "\"", ")", ";", "denyTypeHierarchyDynamically", "(", "\"", "javax.activation.DataSource", "\"", ")", ";", "denyTypeHierarchyDynamically", "(", "\"", "javax.sql.rowset.BaseRowSet", "\"", ")", ";", "allowTypeHierarchy", "(", "Exception", ".", "class", ")", ";", "securityInitialized", "=", "false", ";", "}"], "idx": 95901, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "f0c4a8d861b68ffc3119cfbbbd632deee624e227", "function_name": "setupSecurity", "body_hash": "0c28cf655d006745922374df90dbb68a0ec88092"}
{"code": "protected String resolveAction() throws JspException {\n\t\tString action = getAction();\n\t\tString servletRelativeAction = getServletRelativeAction();\n\t\tif (StringUtils.hasText(action)) {\n\t\t\taction = getDisplayString(evaluate(ACTION_ATTRIBUTE, action));\n\t\t\treturn processAction(action);\n\t\t}\n\t\telse if (StringUtils.hasText(servletRelativeAction)) {\n\t\t\tString pathToServlet = getRequestContext().getPathToServlet();\n\t\t\tif (servletRelativeAction.startsWith(\"/\") && !servletRelativeAction.startsWith(getRequestContext().getContextPath())) {\n\t\t\t\tservletRelativeAction = pathToServlet + servletRelativeAction;\n\t\t\t}\n\t\t\tservletRelativeAction = getDisplayString(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));\n\t\t\treturn processAction(servletRelativeAction);\n\t\t}\n\t\telse {\n\t\t\tString requestUri = getRequestContext().getRequestUri();\n\t\t\tString encoding = pageContext.getResponse().getCharacterEncoding();\n\t\t\ttry {\n\t\t\t\trequestUri = UriUtils.encodePath(requestUri, encoding);\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException e) {\n\t\t\t\tthrow new JspException(e);\n\t\t\t}\n\t\t\tServletResponse response = this.pageContext.getResponse();\n\t\t\tif (response instanceof HttpServletResponse) {\n\t\t\t\trequestUri = ((HttpServletResponse) response).encodeURL(requestUri);\n\t\t\t\tString queryString = getRequestContext().getQueryString();\n\t\t\t\tif (StringUtils.hasText(queryString)) {\n\t\t\t\t\trequestUri += \"?\" + HtmlUtils.htmlEscape(queryString);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (StringUtils.hasText(requestUri)) {\n\t\t\t\treturn processAction(requestUri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Attribute 'action' is required. \" +\n\t\t\t\t\t\t\"Attempted to resolve against current request URI but request URI was null.\");\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["protected", "String", "resolveAction", "(", ")", "throws", "JspException", "{", "String", "action", "=", "getAction", "(", ")", ";", "String", "servletRelativeAction", "=", "getServletRelativeAction", "(", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "action", ")", ")", "{", "action", "=", "getDisplayString", "(", "evaluate", "(", "ACTION_ATTRIBUTE", ",", "action", ")", ")", ";", "return", "processAction", "(", "action", ")", ";", "}", "else", "if", "(", "StringUtils", ".", "hasText", "(", "servletRelativeAction", ")", ")", "{", "String", "pathToServlet", "=", "getRequestContext", "(", ")", ".", "getPathToServlet", "(", ")", ";", "if", "(", "servletRelativeAction", ".", "startsWith", "(", "\"", "/", "\"", ")", "&&", "!", "servletRelativeAction", ".", "startsWith", "(", "getRequestContext", "(", ")", ".", "getContextPath", "(", ")", ")", ")", "{", "servletRelativeAction", "=", "pathToServlet", "+", "servletRelativeAction", ";", "}", "servletRelativeAction", "=", "getDisplayString", "(", "evaluate", "(", "ACTION_ATTRIBUTE", ",", "servletRelativeAction", ")", ")", ";", "return", "processAction", "(", "servletRelativeAction", ")", ";", "}", "else", "{", "String", "requestUri", "=", "getRequestContext", "(", ")", ".", "getRequestUri", "(", ")", ";", "String", "encoding", "=", "pageContext", ".", "getResponse", "(", ")", ".", "getCharacterEncoding", "(", ")", ";", "try", "{", "requestUri", "=", "UriUtils", ".", "encodePath", "(", "requestUri", ",", "encoding", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e", ")", "{", "throw", "new", "JspException", "(", "e", ")", ";", "}", "ServletResponse", "response", "=", "this", ".", "pageContext", ".", "getResponse", "(", ")", ";", "if", "(", "response", "instanceof", "HttpServletResponse", ")", "{", "requestUri", "=", "(", "(", "HttpServletResponse", ")", "response", ")", ".", "encodeURL", "(", "requestUri", ")", ";", "String", "queryString", "=", "getRequestContext", "(", ")", ".", "getQueryString", "(", ")", ";", "if", "(", "StringUtils", ".", "hasText", "(", "queryString", ")", ")", "{", "requestUri", "+=", "\"", "?", "\"", "+", "HtmlUtils", ".", "htmlEscape", "(", "queryString", ")", ";", "}", "}", "if", "(", "StringUtils", ".", "hasText", "(", "requestUri", ")", ")", "{", "return", "processAction", "(", "requestUri", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Attribute 'action' is required. ", "\"", "+", "\"", "Attempted to resolve against current request URI but request URI was null.", "\"", ")", ";", "}", "}", "}"], "idx": 80447, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "741b4b229ae032bd17175b46f98673ce0bd2d485", "function_name": "resolveAction", "body_hash": "a1162fe63f279a50a9ded0737c6bf2b0645f232a"}
{"code": "public String getDivUUID() {\n        StringBuilder randomSelectName = new StringBuilder();\n        randomSelectName.append(getName().replaceAll(\"\\\\W\", \"_\")).append(\"-\").append(uuid);\n        return randomSelectName.toString();\n    }", "code_tokens": ["public", "String", "getDivUUID", "(", ")", "{", "StringBuilder", "randomSelectName", "=", "new", "StringBuilder", "(", ")", ";", "randomSelectName", ".", "append", "(", "getName", "(", ")", ".", "replaceAll", "(", "\"", "\\\\", "W", "\"", ",", "\"", "_", "\"", ")", ")", ".", "append", "(", "\"", "-", "\"", ")", ".", "append", "(", "uuid", ")", ";", "return", "randomSelectName", ".", "toString", "(", ")", ";", "}"], "idx": 80824, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "6fd933c", "function_name": "getDivUUID", "body_hash": "78c02044449241117d790296c117cb3269ec088f"}
{"code": "public void onTaskSelectionEvent(@Observes TaskSelectionEvent event){\n        selectedTaskId = event.getTaskId();\n        selectedTaskName = event.getTaskName();\n        \n        view.getTaskIdAndName().setText(String.valueOf(selectedTaskId) + \" - \"+selectedTaskName);\n        \n        view.getContent().clear();\n        \n        String placeToGo;\n        if(event.getPlace() != null && !event.getPlace().equals(\"\")){\n            placeToGo = event.getPlace();\n        }else{\n            placeToGo = \"Task Details\";\n        }\n        \n        \n\n        DefaultPlaceRequest defaultPlaceRequest = new DefaultPlaceRequest(placeToGo);\n        //Set Parameters here: \n        defaultPlaceRequest.addParameter(\"taskId\", String.valueOf(selectedTaskId));\n        defaultPlaceRequest.addParameter(\"taskName\", selectedTaskName);\n\n        Set<Activity> activities = activityManager.getActivities(defaultPlaceRequest);\n        AbstractWorkbenchScreenActivity activity = ((AbstractWorkbenchScreenActivity) activities.iterator().next());\n        \n        activitiesMap.put(placeToGo, activity);\n        \n        IsWidget widget = activity.getWidget();\n        activity.launch(place, null);\n        activity.onStartup(defaultPlaceRequest);\n        view.getContent().add(widget);\n        activity.onOpen();\n    }", "code_tokens": ["public", "void", "onTaskSelectionEvent", "(", "@", "Observes", "TaskSelectionEvent", "event", ")", "{", "selectedTaskId", "=", "event", ".", "getTaskId", "(", ")", ";", "selectedTaskName", "=", "event", ".", "getTaskName", "(", ")", ";", "view", ".", "getTaskIdAndName", "(", ")", ".", "setText", "(", "String", ".", "valueOf", "(", "selectedTaskId", ")", "+", "\"", " - ", "\"", "+", "selectedTaskName", ")", ";", "view", ".", "getContent", "(", ")", ".", "clear", "(", ")", ";", "String", "placeToGo", ";", "if", "(", "event", ".", "getPlace", "(", ")", "!=", "null", "&&", "!", "event", ".", "getPlace", "(", ")", ".", "equals", "(", "\"", "\"", ")", ")", "{", "placeToGo", "=", "event", ".", "getPlace", "(", ")", ";", "}", "else", "{", "placeToGo", "=", "\"", "Task Details", "\"", ";", "}", "DefaultPlaceRequest", "defaultPlaceRequest", "=", "new", "DefaultPlaceRequest", "(", "placeToGo", ")", ";", "defaultPlaceRequest", ".", "addParameter", "(", "\"", "taskId", "\"", ",", "String", ".", "valueOf", "(", "selectedTaskId", ")", ")", ";", "defaultPlaceRequest", ".", "addParameter", "(", "\"", "taskName", "\"", ",", "selectedTaskName", ")", ";", "Set", "<", "Activity", ">", "activities", "=", "activityManager", ".", "getActivities", "(", "defaultPlaceRequest", ")", ";", "AbstractWorkbenchScreenActivity", "activity", "=", "(", "(", "AbstractWorkbenchScreenActivity", ")", "activities", ".", "iterator", "(", ")", ".", "next", "(", ")", ")", ";", "activitiesMap", ".", "put", "(", "placeToGo", ",", "activity", ")", ";", "IsWidget", "widget", "=", "activity", ".", "getWidget", "(", ")", ";", "activity", ".", "launch", "(", "place", ",", "null", ")", ";", "activity", ".", "onStartup", "(", "defaultPlaceRequest", ")", ";", "view", ".", "getContent", "(", ")", ".", "add", "(", "widget", ")", ";", "activity", ".", "onOpen", "(", ")", ";", "}"], "idx": 79352, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "4818204506e8e94645b52adb9426bedfa9ffdd04", "function_name": "onTaskSelectionEvent", "body_hash": "3e697cd6c5e21145cf4b3fcba1fa6b3d61b56c17"}
{"code": "private void copyJarEntryTrimmingBasePath(JarFile jarFile,\n            ZipEntry jarEntry, String basePath, File outputDirectory) {\n        String fullPath = jarEntry.getName();\n        String relativePath = fullPath\n                .substring(fullPath.toLowerCase(Locale.ENGLISH)\n                        .indexOf(basePath.toLowerCase(Locale.ENGLISH))\n                        + basePath.length());\n        File target = new File(outputDirectory, relativePath);\n        try {\n            if (target.exists()) {\n                File tempFile = File.createTempFile(fullPath, null);\n                FileUtils.copyInputStreamToFile(\n                        jarFile.getInputStream(jarEntry), tempFile);\n                if (!FileUtils.contentEquals(tempFile, target)) {\n                    FileUtils.forceDelete(target);\n                    FileUtils.moveFile(tempFile, target);\n                } else {\n                    tempFile.delete();\n                }\n            } else {\n                FileUtils.copyInputStreamToFile(\n                        jarFile.getInputStream(jarEntry), target);\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(String.format(\n                    \"Failed to extract jar entry '%s' from jarFile '%s'\",\n                    jarEntry, outputDirectory), e);\n        }\n    }", "code_tokens": ["private", "void", "copyJarEntryTrimmingBasePath", "(", "JarFile", "jarFile", ",", "ZipEntry", "jarEntry", ",", "String", "basePath", ",", "File", "outputDirectory", ")", "{", "String", "fullPath", "=", "jarEntry", ".", "getName", "(", ")", ";", "String", "relativePath", "=", "fullPath", ".", "substring", "(", "fullPath", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ".", "indexOf", "(", "basePath", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ")", "+", "basePath", ".", "length", "(", ")", ")", ";", "File", "target", "=", "new", "File", "(", "outputDirectory", ",", "relativePath", ")", ";", "try", "{", "if", "(", "target", ".", "exists", "(", ")", ")", "{", "File", "tempFile", "=", "File", ".", "createTempFile", "(", "fullPath", ",", "null", ")", ";", "FileUtils", ".", "copyInputStreamToFile", "(", "jarFile", ".", "getInputStream", "(", "jarEntry", ")", ",", "tempFile", ")", ";", "if", "(", "!", "FileUtils", ".", "contentEquals", "(", "tempFile", ",", "target", ")", ")", "{", "FileUtils", ".", "forceDelete", "(", "target", ")", ";", "FileUtils", ".", "moveFile", "(", "tempFile", ",", "target", ")", ";", "}", "else", "{", "tempFile", ".", "delete", "(", ")", ";", "}", "}", "else", "{", "FileUtils", ".", "copyInputStreamToFile", "(", "jarFile", ".", "getInputStream", "(", "jarEntry", ")", ",", "target", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "UncheckedIOException", "(", "String", ".", "format", "(", "\"", "Failed to extract jar entry '%s' from jarFile '%s'", "\"", ",", "jarEntry", ",", "outputDirectory", ")", ",", "e", ")", ";", "}", "}"], "idx": 110818, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "dde115adfbcc9484e60a34d603251edf94fae529", "function_name": "copyJarEntryTrimmingBasePath", "body_hash": "cb6c23d7cb57ca57049ff6642fb511996a9061a1"}
{"code": "protected boolean parseChunkHeader()\n        throws IOException {\n\n        int result = 0;\n        boolean eol = false;\n        int readDigit = 0;\n        boolean extension = false;\n\n        while (!eol) {\n\n            if (pos >= lastValid) {\n                if (readBytes() <= 0)\n                    return false;\n            }\n\n            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {\n                parseCRLF(false);\n                eol = true;\n            } else if (buf[pos] == Constants.SEMI_COLON && !extension) {\n                // First semi-colon marks the start of the extension. Further\n                // semi-colons may appear to separate multiple chunk-extensions.\n                // These need to be processed as part of parsing the extensions.\n                extension = true;\n                extensionSize++;\n            } else if (!extension) {\n                //don't read data after the trailer\n                int charValue = HexUtils.getDec(buf[pos]);\n                if (charValue != -1 && readDigit < 8) {\n                    readDigit++;\n                    result = (result << 4) | charValue;\n                } else {\n                    //we shouldn't allow invalid, non hex characters\n                    //in the chunked header\n                    return false;\n                }\n            } else {\n                // Extension 'parsing'\n                // Note that the chunk-extension is neither parsed nor\n                // validated. Currently it is simply ignored.\n                extensionSize++;\n                if (maxExtensionSize > -1 && extensionSize > maxExtensionSize) {\n                    throw new IOException(\"maxExtensionSize exceeded\");\n                }\n            }\n\n            // Parsing the CRLF increments pos\n            if (!eol) {\n                pos++;\n            }\n\n        }\n\n        if (readDigit == 0 || result < 0)\n            return false;\n\n        if (result == 0)\n            endChunk = true;\n\n        remaining = result;\n        if (remaining < 0)\n            return false;\n\n        return true;\n\n    }", "code_tokens": ["protected", "boolean", "parseChunkHeader", "(", ")", "throws", "IOException", "{", "int", "result", "=", "0", ";", "boolean", "eol", "=", "false", ";", "int", "readDigit", "=", "0", ";", "boolean", "extension", "=", "false", ";", "while", "(", "!", "eol", ")", "{", "if", "(", "pos", ">=", "lastValid", ")", "{", "if", "(", "readBytes", "(", ")", "<=", "0", ")", "return", "false", ";", "}", "if", "(", "buf", "[", "pos", "]", "==", "Constants", ".", "CR", "||", "buf", "[", "pos", "]", "==", "Constants", ".", "LF", ")", "{", "parseCRLF", "(", "false", ")", ";", "eol", "=", "true", ";", "}", "else", "if", "(", "buf", "[", "pos", "]", "==", "Constants", ".", "SEMI_COLON", "&&", "!", "extension", ")", "{", "extension", "=", "true", ";", "extensionSize", "++", ";", "}", "else", "if", "(", "!", "extension", ")", "{", "int", "charValue", "=", "HexUtils", ".", "getDec", "(", "buf", "[", "pos", "]", ")", ";", "if", "(", "charValue", "!=", "-", "1", "&&", "readDigit", "<", "8", ")", "{", "readDigit", "++", ";", "result", "=", "(", "result", "<<", "4", ")", "|", "charValue", ";", "}", "else", "{", "return", "false", ";", "}", "}", "else", "{", "extensionSize", "++", ";", "if", "(", "maxExtensionSize", ">", "-", "1", "&&", "extensionSize", ">", "maxExtensionSize", ")", "{", "throw", "new", "IOException", "(", "\"", "maxExtensionSize exceeded", "\"", ")", ";", "}", "}", "if", "(", "!", "eol", ")", "{", "pos", "++", ";", "}", "}", "if", "(", "readDigit", "==", "0", "||", "result", "<", "0", ")", "return", "false", ";", "if", "(", "result", "==", "0", ")", "endChunk", "=", "true", ";", "remaining", "=", "result", ";", "if", "(", "remaining", "<", "0", ")", "return", "false", ";", "return", "true", ";", "}"], "idx": 3090, "cwe": "CWE-189", "target": 0, "status": "FIXED", "commit": "f646a5acd5e32d6f5a2d9bf1d94ca66b65477675", "function_name": "parseChunkHeader", "body_hash": "18c6728503dfe3ec45eea6035b2c69ba01199b80"}
{"code": "public static void doAuthorization(BaseSemanticAnalyzer sem, String command)\n      throws HiveException, AuthorizationException {\n    HashSet<ReadEntity> inputs = sem.getInputs();\n    HashSet<WriteEntity> outputs = sem.getOutputs();\n    SessionState ss = SessionState.get();\n    HiveOperation op = ss.getHiveOperation();\n    Hive db = sem.getDb();\n\n    if (ss.isAuthorizationModeV2()) {\n      // get mapping of tables to columns used\n      ColumnAccessInfo colAccessInfo = sem.getColumnAccessInfo();\n      // colAccessInfo is set only in case of SemanticAnalyzer\n      Map<String, List<String>> selectTab2Cols = colAccessInfo != null ? colAccessInfo\n          .getTableToColumnAccessMap() : null;\n      Map<String, List<String>> updateTab2Cols = sem.getUpdateColumnAccessInfo() != null ?\n          sem.getUpdateColumnAccessInfo().getTableToColumnAccessMap() : null;\n      doAuthorizationV2(ss, op, inputs, outputs, command, selectTab2Cols, updateTab2Cols);\n     return;\n    }\n    if (op == null) {\n      throw new HiveException(\"Operation should not be null\");\n    }\n    HiveAuthorizationProvider authorizer = ss.getAuthorizer();\n    if (op.equals(HiveOperation.CREATEDATABASE)) {\n      authorizer.authorize(\n          op.getInputRequiredPrivileges(), op.getOutputRequiredPrivileges());\n    } else if (op.equals(HiveOperation.CREATETABLE_AS_SELECT)\n        || op.equals(HiveOperation.CREATETABLE)) {\n      authorizer.authorize(\n          db.getDatabase(SessionState.get().getCurrentDatabase()), null,\n          HiveOperation.CREATETABLE_AS_SELECT.getOutputRequiredPrivileges());\n    } else {\n      if (op.equals(HiveOperation.IMPORT)) {\n        ImportSemanticAnalyzer isa = (ImportSemanticAnalyzer) sem;\n        if (!isa.existsTable()) {\n          authorizer.authorize(\n              db.getDatabase(SessionState.get().getCurrentDatabase()), null,\n              HiveOperation.CREATETABLE_AS_SELECT.getOutputRequiredPrivileges());\n        }\n      }\n    }\n    if (outputs != null && outputs.size() > 0) {\n      for (WriteEntity write : outputs) {\n        if (write.isDummy() || write.isPathType()) {\n          continue;\n        }\n        if (write.getType() == Entity.Type.DATABASE) {\n          if (!op.equals(HiveOperation.IMPORT)){\n            // We skip DB check for import here because we already handle it above\n            // as a CTAS check.\n            authorizer.authorize(write.getDatabase(),\n                null, op.getOutputRequiredPrivileges());\n          }\n          continue;\n        }\n\n        if (write.getType() == WriteEntity.Type.PARTITION) {\n          Partition part = db.getPartition(write.getTable(), write\n              .getPartition().getSpec(), false);\n          if (part != null) {\n            authorizer.authorize(write.getPartition(), null,\n                    op.getOutputRequiredPrivileges());\n            continue;\n          }\n        }\n\n        if (write.getTable() != null) {\n          authorizer.authorize(write.getTable(), null,\n                  op.getOutputRequiredPrivileges());\n        }\n      }\n    }\n\n    if (inputs != null && inputs.size() > 0) {\n      Map<Table, List<String>> tab2Cols = new HashMap<Table, List<String>>();\n      Map<Partition, List<String>> part2Cols = new HashMap<Partition, List<String>>();\n\n      //determine if partition level privileges should be checked for input tables\n      Map<String, Boolean> tableUsePartLevelAuth = new HashMap<String, Boolean>();\n      for (ReadEntity read : inputs) {\n        if (read.isDummy() || read.isPathType() || read.getType() == Entity.Type.DATABASE) {\n          continue;\n        }\n        Table tbl = read.getTable();\n        if ((read.getPartition() != null) || (tbl != null && tbl.isPartitioned())) {\n          String tblName = tbl.getTableName();\n          if (tableUsePartLevelAuth.get(tblName) == null) {\n            boolean usePartLevelPriv = (tbl.getParameters().get(\n                \"PARTITION_LEVEL_PRIVILEGE\") != null && (\"TRUE\"\n                .equalsIgnoreCase(tbl.getParameters().get(\n                    \"PARTITION_LEVEL_PRIVILEGE\"))));\n            if (usePartLevelPriv) {\n              tableUsePartLevelAuth.put(tblName, Boolean.TRUE);\n            } else {\n              tableUsePartLevelAuth.put(tblName, Boolean.FALSE);\n            }\n          }\n        }\n      }\n\n      getTablePartitionUsedColumns(op, sem, tab2Cols, part2Cols, tableUsePartLevelAuth);\n\n\n\n      // cache the results for table authorization\n      Set<String> tableAuthChecked = new HashSet<String>();\n      for (ReadEntity read : inputs) {\n        if (read.isDummy() || read.isPathType()) {\n          continue;\n        }\n        if (read.getType() == Entity.Type.DATABASE) {\n          authorizer.authorize(read.getDatabase(), op.getInputRequiredPrivileges(), null);\n          continue;\n        }\n        Table tbl = read.getTable();\n        if (read.getPartition() != null) {\n          Partition partition = read.getPartition();\n          tbl = partition.getTable();\n          // use partition level authorization\n          if (Boolean.TRUE.equals(tableUsePartLevelAuth.get(tbl.getTableName()))) {\n            List<String> cols = part2Cols.get(partition);\n            if (cols != null && cols.size() > 0) {\n              authorizer.authorize(partition.getTable(),\n                  partition, cols, op.getInputRequiredPrivileges(),\n                  null);\n            } else {\n              authorizer.authorize(partition,\n                  op.getInputRequiredPrivileges(), null);\n            }\n            continue;\n          }\n        }\n\n        // if we reach here, it means it needs to do a table authorization\n        // check, and the table authorization may already happened because of other\n        // partitions\n        if (tbl != null && !tableAuthChecked.contains(tbl.getTableName()) &&\n            !(Boolean.TRUE.equals(tableUsePartLevelAuth.get(tbl.getTableName())))) {\n          List<String> cols = tab2Cols.get(tbl);\n          if (cols != null && cols.size() > 0) {\n            authorizer.authorize(tbl, null, cols,\n                op.getInputRequiredPrivileges(), null);\n          } else {\n            authorizer.authorize(tbl, op.getInputRequiredPrivileges(),\n                null);\n          }\n          tableAuthChecked.add(tbl.getTableName());\n        }\n      }\n\n    }\n  }", "code_tokens": ["public", "static", "void", "doAuthorization", "(", "BaseSemanticAnalyzer", "sem", ",", "String", "command", ")", "throws", "HiveException", ",", "AuthorizationException", "{", "HashSet", "<", "ReadEntity", ">", "inputs", "=", "sem", ".", "getInputs", "(", ")", ";", "HashSet", "<", "WriteEntity", ">", "outputs", "=", "sem", ".", "getOutputs", "(", ")", ";", "SessionState", "ss", "=", "SessionState", ".", "get", "(", ")", ";", "HiveOperation", "op", "=", "ss", ".", "getHiveOperation", "(", ")", ";", "Hive", "db", "=", "sem", ".", "getDb", "(", ")", ";", "if", "(", "ss", ".", "isAuthorizationModeV2", "(", ")", ")", "{", "ColumnAccessInfo", "colAccessInfo", "=", "sem", ".", "getColumnAccessInfo", "(", ")", ";", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "selectTab2Cols", "=", "colAccessInfo", "!=", "null", "?", "colAccessInfo", ".", "getTableToColumnAccessMap", "(", ")", ":", "null", ";", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "updateTab2Cols", "=", "sem", ".", "getUpdateColumnAccessInfo", "(", ")", "!=", "null", "?", "sem", ".", "getUpdateColumnAccessInfo", "(", ")", ".", "getTableToColumnAccessMap", "(", ")", ":", "null", ";", "doAuthorizationV2", "(", "ss", ",", "op", ",", "inputs", ",", "outputs", ",", "command", ",", "selectTab2Cols", ",", "updateTab2Cols", ")", ";", "return", ";", "}", "if", "(", "op", "==", "null", ")", "{", "throw", "new", "HiveException", "(", "\"", "Operation should not be null", "\"", ")", ";", "}", "HiveAuthorizationProvider", "authorizer", "=", "ss", ".", "getAuthorizer", "(", ")", ";", "if", "(", "op", ".", "equals", "(", "HiveOperation", ".", "CREATEDATABASE", ")", ")", "{", "authorizer", ".", "authorize", "(", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "op", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "else", "if", "(", "op", ".", "equals", "(", "HiveOperation", ".", "CREATETABLE_AS_SELECT", ")", "||", "op", ".", "equals", "(", "HiveOperation", ".", "CREATETABLE", ")", ")", "{", "authorizer", ".", "authorize", "(", "db", ".", "getDatabase", "(", "SessionState", ".", "get", "(", ")", ".", "getCurrentDatabase", "(", ")", ")", ",", "null", ",", "HiveOperation", ".", "CREATETABLE_AS_SELECT", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "else", "{", "if", "(", "op", ".", "equals", "(", "HiveOperation", ".", "IMPORT", ")", ")", "{", "ImportSemanticAnalyzer", "isa", "=", "(", "ImportSemanticAnalyzer", ")", "sem", ";", "if", "(", "!", "isa", ".", "existsTable", "(", ")", ")", "{", "authorizer", ".", "authorize", "(", "db", ".", "getDatabase", "(", "SessionState", ".", "get", "(", ")", ".", "getCurrentDatabase", "(", ")", ")", ",", "null", ",", "HiveOperation", ".", "CREATETABLE_AS_SELECT", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "}", "}", "if", "(", "outputs", "!=", "null", "&&", "outputs", ".", "size", "(", ")", ">", "0", ")", "{", "for", "(", "WriteEntity", "write", ":", "outputs", ")", "{", "if", "(", "write", ".", "isDummy", "(", ")", "||", "write", ".", "isPathType", "(", ")", ")", "{", "continue", ";", "}", "if", "(", "write", ".", "getType", "(", ")", "==", "Entity", ".", "Type", ".", "DATABASE", ")", "{", "if", "(", "!", "op", ".", "equals", "(", "HiveOperation", ".", "IMPORT", ")", ")", "{", "authorizer", ".", "authorize", "(", "write", ".", "getDatabase", "(", ")", ",", "null", ",", "op", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "continue", ";", "}", "if", "(", "write", ".", "getType", "(", ")", "==", "WriteEntity", ".", "Type", ".", "PARTITION", ")", "{", "Partition", "part", "=", "db", ".", "getPartition", "(", "write", ".", "getTable", "(", ")", ",", "write", ".", "getPartition", "(", ")", ".", "getSpec", "(", ")", ",", "false", ")", ";", "if", "(", "part", "!=", "null", ")", "{", "authorizer", ".", "authorize", "(", "write", ".", "getPartition", "(", ")", ",", "null", ",", "op", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "continue", ";", "}", "}", "if", "(", "write", ".", "getTable", "(", ")", "!=", "null", ")", "{", "authorizer", ".", "authorize", "(", "write", ".", "getTable", "(", ")", ",", "null", ",", "op", ".", "getOutputRequiredPrivileges", "(", ")", ")", ";", "}", "}", "}", "if", "(", "inputs", "!=", "null", "&&", "inputs", ".", "size", "(", ")", ">", "0", ")", "{", "Map", "<", "Table", ",", "List", "<", "String", ">", ">", "tab2Cols", "=", "new", "HashMap", "<", "Table", ",", "List", "<", "String", ">", ">", "(", ")", ";", "Map", "<", "Partition", ",", "List", "<", "String", ">", ">", "part2Cols", "=", "new", "HashMap", "<", "Partition", ",", "List", "<", "String", ">", ">", "(", ")", ";", "Map", "<", "String", ",", "Boolean", ">", "tableUsePartLevelAuth", "=", "new", "HashMap", "<", "String", ",", "Boolean", ">", "(", ")", ";", "for", "(", "ReadEntity", "read", ":", "inputs", ")", "{", "if", "(", "read", ".", "isDummy", "(", ")", "||", "read", ".", "isPathType", "(", ")", "||", "read", ".", "getType", "(", ")", "==", "Entity", ".", "Type", ".", "DATABASE", ")", "{", "continue", ";", "}", "Table", "tbl", "=", "read", ".", "getTable", "(", ")", ";", "if", "(", "(", "read", ".", "getPartition", "(", ")", "!=", "null", ")", "||", "(", "tbl", "!=", "null", "&&", "tbl", ".", "isPartitioned", "(", ")", ")", ")", "{", "String", "tblName", "=", "tbl", ".", "getTableName", "(", ")", ";", "if", "(", "tableUsePartLevelAuth", ".", "get", "(", "tblName", ")", "==", "null", ")", "{", "boolean", "usePartLevelPriv", "=", "(", "tbl", ".", "getParameters", "(", ")", ".", "get", "(", "\"", "PARTITION_LEVEL_PRIVILEGE", "\"", ")", "!=", "null", "&&", "(", "\"", "TRUE", "\"", ".", "equalsIgnoreCase", "(", "tbl", ".", "getParameters", "(", ")", ".", "get", "(", "\"", "PARTITION_LEVEL_PRIVILEGE", "\"", ")", ")", ")", ")", ";", "if", "(", "usePartLevelPriv", ")", "{", "tableUsePartLevelAuth", ".", "put", "(", "tblName", ",", "Boolean", ".", "TRUE", ")", ";", "}", "else", "{", "tableUsePartLevelAuth", ".", "put", "(", "tblName", ",", "Boolean", ".", "FALSE", ")", ";", "}", "}", "}", "}", "getTablePartitionUsedColumns", "(", "op", ",", "sem", ",", "tab2Cols", ",", "part2Cols", ",", "tableUsePartLevelAuth", ")", ";", "Set", "<", "String", ">", "tableAuthChecked", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "for", "(", "ReadEntity", "read", ":", "inputs", ")", "{", "if", "(", "read", ".", "isDummy", "(", ")", "||", "read", ".", "isPathType", "(", ")", ")", "{", "continue", ";", "}", "if", "(", "read", ".", "getType", "(", ")", "==", "Entity", ".", "Type", ".", "DATABASE", ")", "{", "authorizer", ".", "authorize", "(", "read", ".", "getDatabase", "(", ")", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "continue", ";", "}", "Table", "tbl", "=", "read", ".", "getTable", "(", ")", ";", "if", "(", "read", ".", "getPartition", "(", ")", "!=", "null", ")", "{", "Partition", "partition", "=", "read", ".", "getPartition", "(", ")", ";", "tbl", "=", "partition", ".", "getTable", "(", ")", ";", "if", "(", "Boolean", ".", "TRUE", ".", "equals", "(", "tableUsePartLevelAuth", ".", "get", "(", "tbl", ".", "getTableName", "(", ")", ")", ")", ")", "{", "List", "<", "String", ">", "cols", "=", "part2Cols", ".", "get", "(", "partition", ")", ";", "if", "(", "cols", "!=", "null", "&&", "cols", ".", "size", "(", ")", ">", "0", ")", "{", "authorizer", ".", "authorize", "(", "partition", ".", "getTable", "(", ")", ",", "partition", ",", "cols", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "}", "else", "{", "authorizer", ".", "authorize", "(", "partition", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "}", "continue", ";", "}", "}", "if", "(", "tbl", "!=", "null", "&&", "!", "tableAuthChecked", ".", "contains", "(", "tbl", ".", "getTableName", "(", ")", ")", "&&", "!", "(", "Boolean", ".", "TRUE", ".", "equals", "(", "tableUsePartLevelAuth", ".", "get", "(", "tbl", ".", "getTableName", "(", ")", ")", ")", ")", ")", "{", "List", "<", "String", ">", "cols", "=", "tab2Cols", ".", "get", "(", "tbl", ")", ";", "if", "(", "cols", "!=", "null", "&&", "cols", ".", "size", "(", ")", ">", "0", ")", "{", "authorizer", ".", "authorize", "(", "tbl", ",", "null", ",", "cols", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "}", "else", "{", "authorizer", ".", "authorize", "(", "tbl", ",", "op", ".", "getInputRequiredPrivileges", "(", ")", ",", "null", ")", ";", "}", "tableAuthChecked", ".", "add", "(", "tbl", ".", "getTableName", "(", ")", ")", ";", "}", "}", "}", "}"], "idx": 39016, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "98f933f269e6b528ef84912b3d701ca3272ec04b", "function_name": "doAuthorization", "body_hash": "7512c271a74e8095a0426c87df19df7e141f783f"}
{"code": "@Activate\n    @SuppressWarnings(\"unused\")\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n        try {\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (Exception e) {\n            LOGGER.error(\"SAX parser configuration error: \" + e.getMessage(), e);\n        }\n    }", "code_tokens": ["@", "Activate", "@", "SuppressWarnings", "(", "\"", "unused", "\"", ")", "protected", "void", "activate", "(", ")", "{", "factory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setValidating", "(", "false", ")", ";", "factory", ".", "setNamespaceAware", "(", "true", ")", ";", "try", "{", "factory", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/nonvalidating/load-external-dtd", "\"", ",", "false", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "factory", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOGGER", ".", "error", "(", "\"", "SAX parser configuration error: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "}"], "idx": 66821, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "fb2719e8299fadddae62245482de112052a0e08c", "function_name": "activate", "body_hash": "4af18f2f0eb87a723a69919c250b02bcb3d84e63"}
{"code": "protected void parseNameAndNamespace(String uri, ActionMapping mapping, ConfigurationManager configManager) {\n        String namespace, name;\n        int lastSlash = uri.lastIndexOf('/');\n        if (lastSlash == -1) {\n            namespace = \"\";\n            name = uri;\n        } else if (lastSlash == 0) {\n            // ww-1046, assume it is the root namespace, it will fallback to\n            // default\n            // namespace anyway if not found in root namespace.\n            namespace = \"/\";\n            name = uri.substring(lastSlash + 1);\n        } else if (alwaysSelectFullNamespace) {\n            // Simply select the namespace as everything before the last slash\n            namespace = uri.substring(0, lastSlash);\n            name = uri.substring(lastSlash + 1);\n        } else {\n            // Try to find the namespace in those defined, defaulting to \"\"\n            Configuration config = configManager.getConfiguration();\n            String prefix = uri.substring(0, lastSlash);\n            namespace = \"\";\n            boolean rootAvailable = false;\n            // Find the longest matching namespace, defaulting to the default\n            for (PackageConfig cfg : config.getPackageConfigs().values()) {\n                String ns = cfg.getNamespace();\n                if (ns != null && prefix.startsWith(ns) && (prefix.length() == ns.length() || prefix.charAt(ns.length()) == '/')) {\n                    if (ns.length() > namespace.length()) {\n                        namespace = ns;\n                    }\n                }\n                if (\"/\".equals(ns)) {\n                    rootAvailable = true;\n                }\n            }\n\n            name = uri.substring(namespace.length() + 1);\n\n            // Still none found, use root namespace if found\n            if (rootAvailable && \"\".equals(namespace)) {\n                namespace = \"/\";\n            }\n        }\n\n        if (!allowSlashesInActionNames) {\n            int pos = name.lastIndexOf('/');\n            if (pos > -1 && pos < name.length() - 1) {\n                name = name.substring(pos + 1);\n            }\n        }\n\n        mapping.setNamespace(cleanupNamespaceName(namespace));\n        mapping.setName(cleanupActionName(name));\n    }", "code_tokens": ["protected", "void", "parseNameAndNamespace", "(", "String", "uri", ",", "ActionMapping", "mapping", ",", "ConfigurationManager", "configManager", ")", "{", "String", "namespace", ",", "name", ";", "int", "lastSlash", "=", "uri", ".", "lastIndexOf", "(", "'/'", ")", ";", "if", "(", "lastSlash", "==", "-", "1", ")", "{", "namespace", "=", "\"", "\"", ";", "name", "=", "uri", ";", "}", "else", "if", "(", "lastSlash", "==", "0", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "if", "(", "alwaysSelectFullNamespace", ")", "{", "namespace", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "name", "=", "uri", ".", "substring", "(", "lastSlash", "+", "1", ")", ";", "}", "else", "{", "Configuration", "config", "=", "configManager", ".", "getConfiguration", "(", ")", ";", "String", "prefix", "=", "uri", ".", "substring", "(", "0", ",", "lastSlash", ")", ";", "namespace", "=", "\"", "\"", ";", "boolean", "rootAvailable", "=", "false", ";", "for", "(", "PackageConfig", "cfg", ":", "config", ".", "getPackageConfigs", "(", ")", ".", "values", "(", ")", ")", "{", "String", "ns", "=", "cfg", ".", "getNamespace", "(", ")", ";", "if", "(", "ns", "!=", "null", "&&", "prefix", ".", "startsWith", "(", "ns", ")", "&&", "(", "prefix", ".", "length", "(", ")", "==", "ns", ".", "length", "(", ")", "||", "prefix", ".", "charAt", "(", "ns", ".", "length", "(", ")", ")", "==", "'/'", ")", ")", "{", "if", "(", "ns", ".", "length", "(", ")", ">", "namespace", ".", "length", "(", ")", ")", "{", "namespace", "=", "ns", ";", "}", "}", "if", "(", "\"", "/", "\"", ".", "equals", "(", "ns", ")", ")", "{", "rootAvailable", "=", "true", ";", "}", "}", "name", "=", "uri", ".", "substring", "(", "namespace", ".", "length", "(", ")", "+", "1", ")", ";", "if", "(", "rootAvailable", "&&", "\"", "\"", ".", "equals", "(", "namespace", ")", ")", "{", "namespace", "=", "\"", "/", "\"", ";", "}", "}", "if", "(", "!", "allowSlashesInActionNames", ")", "{", "int", "pos", "=", "name", ".", "lastIndexOf", "(", "'/'", ")", ";", "if", "(", "pos", ">", "-", "1", "&&", "pos", "<", "name", ".", "length", "(", ")", "-", "1", ")", "{", "name", "=", "name", ".", "substring", "(", "pos", "+", "1", ")", ";", "}", "}", "mapping", ".", "setNamespace", "(", "cleanupNamespaceName", "(", "namespace", ")", ")", ";", "mapping", ".", "setName", "(", "cleanupActionName", "(", "name", ")", ")", ";", "}"], "idx": 6704, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "6e87474f9ad0549f07dd2c37d50a9ccd0977c6e", "function_name": "parseNameAndNamespace", "body_hash": "84fa8c1c1c62a13fffb4c5d38486a5892d51a15d"}
{"code": "public void install(\n            String displayName, String description, String[] dependencies,\n            String account, String password, String config) throws URISyntaxException {\n\n        String javaHome = System.getProperty(\"java.home\");\n        String javaBinary = \"\\\"\" + javaHome + \"\\\\bin\\\\java.exe\\\"\";\n\n        File jar = new File(WindowsService.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n        String command = javaBinary\n                + \" -Duser.dir=\\\"\" + jar.getParentFile().getAbsolutePath() + \"\\\"\"\n                + \" -jar \\\"\" + jar.getAbsolutePath() + \"\\\"\"\n                + \" --service \\\"\" + config + \"\\\"\";\n\n        StringBuilder dep = new StringBuilder();\n\n        if (dependencies != null) {\n            for (String s : dependencies) {\n                dep.append(s);\n                dep.append(\"\\0\");\n            }\n        }\n        dep.append(\"\\0\");\n\n        SERVICE_DESCRIPTION desc = new SERVICE_DESCRIPTION();\n        desc.lpDescription = description;\n\n        SC_HANDLE serviceManager = openServiceControlManager(null, Winsvc.SC_MANAGER_ALL_ACCESS);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = ADVAPI_32.CreateService(serviceManager, serviceName, displayName,\n                    Winsvc.SERVICE_ALL_ACCESS, WinNT.SERVICE_WIN32_OWN_PROCESS, WinNT.SERVICE_AUTO_START,\n                    WinNT.SERVICE_ERROR_NORMAL,\n                    command,\n                    null, null, dep.toString(), account, password);\n\n            if (service != null) {\n                ADVAPI_32.ChangeServiceConfig2(service, Winsvc.SERVICE_CONFIG_DESCRIPTION, desc);\n                ADVAPI_32.CloseServiceHandle(service);\n            }\n            ADVAPI_32.CloseServiceHandle(serviceManager);\n        }\n    }", "code_tokens": ["public", "void", "install", "(", "String", "displayName", ",", "String", "description", ",", "String", "[", "]", "dependencies", ",", "String", "account", ",", "String", "password", ",", "String", "config", ")", "throws", "URISyntaxException", "{", "String", "javaHome", "=", "System", ".", "getProperty", "(", "\"", "java.home", "\"", ")", ";", "String", "javaBinary", "=", "\"", "\\\"", "\"", "+", "javaHome", "+", "\"", "\\\\", "bin", "\\\\", "java.exe", "\\\"", "\"", ";", "File", "jar", "=", "new", "File", "(", "WindowsService", ".", "class", ".", "getProtectionDomain", "(", ")", ".", "getCodeSource", "(", ")", ".", "getLocation", "(", ")", ".", "toURI", "(", ")", ")", ";", "String", "command", "=", "javaBinary", "+", "\"", " -Duser.dir=", "\\\"", "\"", "+", "jar", ".", "getParentFile", "(", ")", ".", "getAbsolutePath", "(", ")", "+", "\"", "\\\"", "\"", "+", "\"", " -jar ", "\\\"", "\"", "+", "jar", ".", "getAbsolutePath", "(", ")", "+", "\"", "\\\"", "\"", "+", "\"", " --service ", "\\\"", "\"", "+", "config", "+", "\"", "\\\"", "\"", ";", "StringBuilder", "dep", "=", "new", "StringBuilder", "(", ")", ";", "if", "(", "dependencies", "!=", "null", ")", "{", "for", "(", "String", "s", ":", "dependencies", ")", "{", "dep", ".", "append", "(", "s", ")", ";", "dep", ".", "append", "(", "\"", "\\0", "\"", ")", ";", "}", "}", "dep", ".", "append", "(", "\"", "\\0", "\"", ")", ";", "SERVICE_DESCRIPTION", "desc", "=", "new", "SERVICE_DESCRIPTION", "(", ")", ";", "desc", ".", "lpDescription", "=", "description", ";", "SC_HANDLE", "serviceManager", "=", "openServiceControlManager", "(", "null", ",", "Winsvc", ".", "SC_MANAGER_ALL_ACCESS", ")", ";", "if", "(", "serviceManager", "!=", "null", ")", "{", "SC_HANDLE", "service", "=", "ADVAPI_32", ".", "CreateService", "(", "serviceManager", ",", "serviceName", ",", "displayName", ",", "Winsvc", ".", "SERVICE_ALL_ACCESS", ",", "WinNT", ".", "SERVICE_WIN32_OWN_PROCESS", ",", "WinNT", ".", "SERVICE_AUTO_START", ",", "WinNT", ".", "SERVICE_ERROR_NORMAL", ",", "command", ",", "null", ",", "null", ",", "dep", ".", "toString", "(", ")", ",", "account", ",", "password", ")", ";", "if", "(", "service", "!=", "null", ")", "{", "ADVAPI_32", ".", "ChangeServiceConfig2", "(", "service", ",", "Winsvc", ".", "SERVICE_CONFIG_DESCRIPTION", ",", "desc", ")", ";", "ADVAPI_32", ".", "CloseServiceHandle", "(", "service", ")", ";", "}", "ADVAPI_32", ".", "CloseServiceHandle", "(", "serviceManager", ")", ";", "}", "}"], "idx": 53694, "cwe": "CWE-428", "target": 0, "status": "FIXED", "commit": "cc69a9907ac9878db3750aa14ffedb28626455da", "function_name": "install", "body_hash": "19dc7e22a52e852100678db8da9f62cf783fe6bc"}
{"code": "public void installConfigFiles(final boolean builtIn) {\n        final File openejbCoreJar = paths.getOpenEJBCoreJar();\n        final File confDir = paths.getCatalinaConfDir();\n        final Alerts alerts = this.alerts;\n\n        if (openejbCoreJar == null) {\n            // the core jar contains the config files\n            return;\n        }\n        final JarFile coreJar;\n        try {\n            coreJar = new JarFile(openejbCoreJar);\n        } catch (final IOException e) {\n            return;\n        }\n\n        //\n        // conf/tomee.xml\n        //\n        final File openEjbXmlFile = new File(confDir, \"tomee.xml\");\n        if (!openEjbXmlFile.exists()) {\n            // read in the openejb.xml file from the openejb core jar\n            final String openEjbXml = Installers.readEntry(coreJar, \"default.openejb.conf\", alerts);\n            if (openEjbXml != null) {\n                if (Installers.writeAll(openEjbXmlFile, openEjbXml.replace(\"<openejb>\", \"<tomee>\").replace(\"</openejb>\", \"</tomee>\"), alerts)) {\n                    alerts.addInfo(\"Copy tomee.xml to conf\");\n                }\n            }\n        }\n\n\n        //\n        // conf/logging.properties\n        // now we are using tomcat one of jdk one by default\n        //\n        final String openejbLoggingProps = \"################################\\r\\n\" +\n                \"# OpenEJB/TomEE specific loggers\\r\\n\" +\n                \"################################\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# ACTIVATE LEVEL/HANDLERS YOU WANT\\r\\n\" +\n                \"# IF YOU ACTIVATE 5tomee.org.apache.juli.FileHandler\\r\\n\" +\n                \"# ADD IT TO handlers LINE LIKE:\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# LEVELS:\\r\\n\" +\n                \"# =======\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.options.level     = INFO\\r\\n\" +\n                \"# OpenEJB.server.level      = INFO\\r\\n\" +\n                \"# OpenEJB.startup.level     = INFO\\r\\n\" +\n                \"# OpenEJB.startup.service.level = WARNING\\r\\n\" +\n                \"# OpenEJB.startup.config.level = INFO\\r\\n\" +\n                \"# OpenEJB.hsql.level        = INFO\\r\\n\" +\n                \"# CORBA-Adapter.level       = WARNING\\r\\n\" +\n                \"# Transaction.level         = WARNING\\r\\n\" +\n                \"# org.apache.activemq.level = SEVERE\\r\\n\" +\n                \"# org.apache.geronimo.level = SEVERE\\r\\n\" +\n                \"# openjpa.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.cdi.level         = INFO\\r\\n\" +\n                \"# org.apache.webbeans.level = INFO\\r\\n\" +\n                \"# org.apache.openejb.level = FINE\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# HANDLERS:\\r\\n\" +\n                \"# =========\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.options.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.server.handlers      = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.service.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.config.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.hsql.handlers        = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# CORBA-Adapter.handlers       = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# Transaction.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.activemq.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.geronimo.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# openjpa.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.cdi.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.webbeans.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.openejb.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# TOMEE HANDLER SAMPLE:\\r\\n\" +\n                \"# =====================\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.level = FINEST\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.prefix = tomee.\\r\\n\";\n        final File loggingPropsFile = new File(confDir, \"logging.properties\");\n        String newLoggingProps = null;\n        if (!loggingPropsFile.exists()) {\n            newLoggingProps = openejbLoggingProps;\n        } else {\n            final String loggingPropsOriginal = Installers.readAll(loggingPropsFile, alerts);\n            if (!loggingPropsOriginal.toLowerCase().contains(\"openejb\")) {\n                // append our properties\n                newLoggingProps = loggingPropsOriginal +\n                        \"\\r\\n\\r\\n\" +\n                        openejbLoggingProps + \"\\r\\n\";\n            }\n        }\n        if (builtIn) {\n            installTomEEJuli(alerts, loggingPropsFile, newLoggingProps);\n        }\n\n        final File openejbSystemProperties = new File(confDir, \"system.properties\");\n        if (!openejbSystemProperties.exists()) {\n            FileWriter systemPropertiesWriter = null;\n            try {\n                systemPropertiesWriter = new FileWriter(openejbSystemProperties);\n\n                systemPropertiesWriter.write(\"# all this properties are added at JVM system properties at startup\\n\");\n                systemPropertiesWriter.write(\"# here some default Apache TomEE system properties\\n\");\n                systemPropertiesWriter.write(\"# for more information please see http://tomee.apache.org/properties-listing.html\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader.verbose = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.subcontext = webservices\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.oldsubcontext = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# if you want to propagate a deployment on a cluster when a tomcat cluster is defined\\n\");\n                systemPropertiesWriter.write(\"# tomee.cluster.deployment = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.system.apps = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.servicemanager.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.descriptors.output = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.strict.interface.declaration = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.conf.file = conf/tomee.xml\\n\");\n                systemPropertiesWriter.write(\"# openejb.debuggable-vm-hackery = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.skip = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.webservices.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.output.level = MEDIUM\\n\");\n                systemPropertiesWriter.write(\"# openejb.user.mbeans.list = *\\n\");\n                systemPropertiesWriter.write(\"# openejb.deploymentId.format = {appId}/{ejbJarId}/{ejbName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.format = {deploymentId}{interfaceType.annotationName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.include = .*\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.exclude = \\n\");\n                systemPropertiesWriter.write(\"# openejb.autocreate.jta-datasource-from-non-jta-one = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.altdd.prefix = \\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.default.system.interceptors = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.failoncollision = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.wsAddress.format = /{ejbDeploymentId}\\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.server.webservices.saaj.provider = \\n\");\n                systemPropertiesWriter.write(\"# openejb.nobanner = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.offline = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.exclude-include.order = include-exclude\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.exclude =\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.include =\\n\");\n                systemPropertiesWriter.write(\"# openejb.crosscontext = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jsessionid-support = \\n\");\n                systemPropertiesWriter.write(\"# openejb.myfaces.disable-default-values = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.web.xml.major = \\n\");\n                systemPropertiesWriter.write(\"# openjpa.Log = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jdbc.log = false\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.provider = org.apache.openjpa.persistence.PersistenceProviderImpl\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.transactionType = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.jtaDataSource = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.nonJtaDataSource = \\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# Properties for JAS RS\\n\");\n                systemPropertiesWriter.write(\"# openejb.jaxrs.application = \\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreRequests = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreMessageWriters = true\\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# These properties are only for cxf service (SOAP webservices) and TomEE+\\n\");\n                systemPropertiesWriter.write(\"# If you don't use special tricks and sun default implementation, uncommenting these 4 lines forces TomEE to use it without overhead at all = \\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MessageFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPConnectionFactory = com.sun.xml.messaging.saaj.client.p2p.HttpSOAPConnectionFactory\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MetaFactory = com.sun.xml.messaging.saaj.soap.SAAJMetaFactoryImpl\\n\");\n            } catch (final IOException e) {\n                // ignored, this file is far to be mandatory\n            } finally {\n                if (systemPropertiesWriter != null) {\n                    try {\n                        systemPropertiesWriter.close();\n                    } catch (final IOException e) {\n                        // no-op\n                    }\n                }\n            }\n        }\n\n        //\n        // conf/web.xml\n        //\n        final JarFile openejbTomcatCommonJar;\n        try {\n            openejbTomcatCommonJar = new JarFile(paths.geOpenEJBTomcatCommonJar());\n        } catch (final IOException e) {\n            return;\n        }\n        final File webXmlFile = new File(confDir, \"web.xml\");\n        final String webXml = Installers.readEntry(openejbTomcatCommonJar, \"conf/web.xml\", alerts);\n        if (Installers.writeAll(webXmlFile, webXml, alerts)) {\n            alerts.addInfo(\"Set jasper in production mode in TomEE web.xml\");\n        }\n    }", "code_tokens": ["public", "void", "installConfigFiles", "(", "final", "boolean", "builtIn", ")", "{", "final", "File", "openejbCoreJar", "=", "paths", ".", "getOpenEJBCoreJar", "(", ")", ";", "final", "File", "confDir", "=", "paths", ".", "getCatalinaConfDir", "(", ")", ";", "final", "Alerts", "alerts", "=", "this", ".", "alerts", ";", "if", "(", "openejbCoreJar", "==", "null", ")", "{", "return", ";", "}", "final", "JarFile", "coreJar", ";", "try", "{", "coreJar", "=", "new", "JarFile", "(", "openejbCoreJar", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "return", ";", "}", "final", "File", "openEjbXmlFile", "=", "new", "File", "(", "confDir", ",", "\"", "tomee.xml", "\"", ")", ";", "if", "(", "!", "openEjbXmlFile", ".", "exists", "(", ")", ")", "{", "final", "String", "openEjbXml", "=", "Installers", ".", "readEntry", "(", "coreJar", ",", "\"", "default.openejb.conf", "\"", ",", "alerts", ")", ";", "if", "(", "openEjbXml", "!=", "null", ")", "{", "if", "(", "Installers", ".", "writeAll", "(", "openEjbXmlFile", ",", "openEjbXml", ".", "replace", "(", "\"", "<openejb>", "\"", ",", "\"", "<tomee>", "\"", ")", ".", "replace", "(", "\"", "</openejb>", "\"", ",", "\"", "</tomee>", "\"", ")", ",", "alerts", ")", ")", "{", "alerts", ".", "addInfo", "(", "\"", "Copy tomee.xml to conf", "\"", ")", ";", "}", "}", "}", "final", "String", "openejbLoggingProps", "=", "\"", "################################", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB/TomEE specific loggers", "\\r", "\\n", "\"", "+", "\"", "################################", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# ACTIVATE LEVEL/HANDLERS YOU WANT", "\\r", "\\n", "\"", "+", "\"", "# IF YOU ACTIVATE 5tomee.org.apache.juli.FileHandler", "\\r", "\\n", "\"", "+", "\"", "# ADD IT TO handlers LINE LIKE:", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# LEVELS:", "\\r", "\\n", "\"", "+", "\"", "# =======", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.level             = WARNING", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.options.level     = INFO", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.server.level      = INFO", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.level     = INFO", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.service.level = WARNING", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.config.level = INFO", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.hsql.level        = INFO", "\\r", "\\n", "\"", "+", "\"", "# CORBA-Adapter.level       = WARNING", "\\r", "\\n", "\"", "+", "\"", "# Transaction.level         = WARNING", "\\r", "\\n", "\"", "+", "\"", "# org.apache.activemq.level = SEVERE", "\\r", "\\n", "\"", "+", "\"", "# org.apache.geronimo.level = SEVERE", "\\r", "\\n", "\"", "+", "\"", "# openjpa.level             = WARNING", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.cdi.level         = INFO", "\\r", "\\n", "\"", "+", "\"", "# org.apache.webbeans.level = INFO", "\\r", "\\n", "\"", "+", "\"", "# org.apache.openejb.level = FINE", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# HANDLERS:", "\\r", "\\n", "\"", "+", "\"", "# =========", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.options.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.server.handlers      = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.service.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.startup.config.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.hsql.handlers        = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# CORBA-Adapter.handlers       = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# Transaction.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# org.apache.activemq.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# org.apache.geronimo.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# openjpa.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# OpenEJB.cdi.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# org.apache.webbeans.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "# org.apache.openejb.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# TOMEE HANDLER SAMPLE:", "\\r", "\\n", "\"", "+", "\"", "# =====================", "\\r", "\\n", "\"", "+", "\"", "#", "\\r", "\\n", "\"", "+", "\"", "# 5tomee.org.apache.juli.FileHandler.level = FINEST", "\\r", "\\n", "\"", "+", "\"", "# 5tomee.org.apache.juli.FileHandler.directory = ${catalina.base}/logs", "\\r", "\\n", "\"", "+", "\"", "# 5tomee.org.apache.juli.FileHandler.prefix = tomee.", "\\r", "\\n", "\"", ";", "final", "File", "loggingPropsFile", "=", "new", "File", "(", "confDir", ",", "\"", "logging.properties", "\"", ")", ";", "String", "newLoggingProps", "=", "null", ";", "if", "(", "!", "loggingPropsFile", ".", "exists", "(", ")", ")", "{", "newLoggingProps", "=", "openejbLoggingProps", ";", "}", "else", "{", "final", "String", "loggingPropsOriginal", "=", "Installers", ".", "readAll", "(", "loggingPropsFile", ",", "alerts", ")", ";", "if", "(", "!", "loggingPropsOriginal", ".", "toLowerCase", "(", ")", ".", "contains", "(", "\"", "openejb", "\"", ")", ")", "{", "newLoggingProps", "=", "loggingPropsOriginal", "+", "\"", "\\r", "\\n", "\\r", "\\n", "\"", "+", "openejbLoggingProps", "+", "\"", "\\r", "\\n", "\"", ";", "}", "}", "if", "(", "builtIn", ")", "{", "installTomEEJuli", "(", "alerts", ",", "loggingPropsFile", ",", "newLoggingProps", ")", ";", "}", "final", "File", "openejbSystemProperties", "=", "new", "File", "(", "confDir", ",", "\"", "system.properties", "\"", ")", ";", "if", "(", "!", "openejbSystemProperties", ".", "exists", "(", ")", ")", "{", "FileWriter", "systemPropertiesWriter", "=", "null", ";", "try", "{", "systemPropertiesWriter", "=", "new", "FileWriter", "(", "openejbSystemProperties", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# all this properties are added at JVM system properties at startup", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# here some default Apache TomEE system properties", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# for more information please see http://tomee.apache.org/properties-listing.html", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.check.classloader = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.check.classloader.verbose = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# tomee.jaxws.subcontext = webservices", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# tomee.jaxws.oldsubcontext = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# if you want to propagate a deployment on a cluster when a tomcat cluster is defined", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# tomee.cluster.deployment = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.system.apps = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.servicemanager.enabled = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jmx.active = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.descriptors.output = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.strict.interface.declaration = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.conf.file = conf/tomee.xml", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.debuggable-vm-hackery = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.validation.skip = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.webservices.enabled = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.validation.output.level = MEDIUM", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.user.mbeans.list = *", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.deploymentId.format = {appId}/{ejbJarId}/{ejbName}", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jndiname.format = {deploymentId}{interfaceType.annotationName}", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.deployments.package.include = .*", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.deployments.package.exclude = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.autocreate.jta-datasource-from-non-jta-one = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.altdd.prefix = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# org.apache.openejb.default.system.interceptors = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jndiname.failoncollision = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.wsAddress.format = /{ejbDeploymentId}", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# org.apache.openejb.server.webservices.saaj.provider = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.nobanner = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.offline = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jmx.active = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.exclude-include.order = include-exclude", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.additional.exclude =", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.additional.include =", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.crosscontext = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jsessionid-support = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.myfaces.disable-default-values = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.web.xml.major = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openjpa.Log = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jdbc.log = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.persistence.provider = org.apache.openjpa.persistence.PersistenceProviderImpl", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.persistence.transactionType = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.persistence.jtaDataSource = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.persistence.nonJtaDataSource = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "#", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# Properties for JAS RS", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.jaxrs.application = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.cxf-rs.wadl-generator.ignoreRequests = false", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# openejb.cxf-rs.wadl-generator.ignoreMessageWriters = true", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "#", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# These properties are only for cxf service (SOAP webservices) and TomEE+", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# If you don't use special tricks and sun default implementation, uncommenting these 4 lines forces TomEE to use it without overhead at all = ", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.xml.soap.MessageFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.xml.soap.SOAPFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPFactory1_1Impl", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.xml.soap.SOAPConnectionFactory = com.sun.xml.messaging.saaj.client.p2p.HttpSOAPConnectionFactory", "\\n", "\"", ")", ";", "systemPropertiesWriter", ".", "write", "(", "\"", "# javax.xml.soap.MetaFactory = com.sun.xml.messaging.saaj.soap.SAAJMetaFactoryImpl", "\\n", "\"", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "}", "finally", "{", "if", "(", "systemPropertiesWriter", "!=", "null", ")", "{", "try", "{", "systemPropertiesWriter", ".", "close", "(", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "}", "}", "}", "}", "final", "JarFile", "openejbTomcatCommonJar", ";", "try", "{", "openejbTomcatCommonJar", "=", "new", "JarFile", "(", "paths", ".", "geOpenEJBTomcatCommonJar", "(", ")", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "return", ";", "}", "final", "File", "webXmlFile", "=", "new", "File", "(", "confDir", ",", "\"", "web.xml", "\"", ")", ";", "final", "String", "webXml", "=", "Installers", ".", "readEntry", "(", "openejbTomcatCommonJar", ",", "\"", "conf/web.xml", "\"", ",", "alerts", ")", ";", "if", "(", "Installers", ".", "writeAll", "(", "webXmlFile", ",", "webXml", ",", "alerts", ")", ")", "{", "alerts", ".", "addInfo", "(", "\"", "Set jasper in production mode in TomEE web.xml", "\"", ")", ";", "}", "}"], "idx": 62847, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "58cdbbef9c77ab2b44870f9d606593b49cde76d9", "function_name": "installConfigFiles", "body_hash": "4df78d3ba8bfbfa56762d000ca9252e6cb2075c2"}
{"code": "public String getApiToken() {\n        String p = apiToken.getPlainText();\n        if (p.equals(Util.getDigestOf(Jenkins.getInstance().getSecretKey()+\":\"+user.getId()))) {\n            // if the current token is the initial value created by pre SECURITY-49 Jenkins, we can't use that.\n            // force using the newer value\n            apiToken = Secret.fromString(p=API_KEY_SEED.mac(user.getId()));\n        }\n        return Util.getDigestOf(p);\n    }", "code_tokens": ["public", "String", "getApiToken", "(", ")", "{", "String", "p", "=", "apiToken", ".", "getPlainText", "(", ")", ";", "if", "(", "p", ".", "equals", "(", "Util", ".", "getDigestOf", "(", "Jenkins", ".", "getInstance", "(", ")", ".", "getSecretKey", "(", ")", "+", "\"", ":", "\"", "+", "user", ".", "getId", "(", ")", ")", ")", ")", "{", "apiToken", "=", "Secret", ".", "fromString", "(", "p", "=", "API_KEY_SEED", ".", "mac", "(", "user", ".", "getId", "(", ")", ")", ")", ";", "}", "return", "Util", ".", "getDigestOf", "(", "p", ")", ";", "}"], "idx": 98923, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "94a8789b699132dd706021a6be1b78bc47f19602", "function_name": "getApiToken", "body_hash": "a2113c080240a950935e7095cee75b83ff5ad288"}
{"code": "private SCIMFilter scimFilter(String filter) throws SCIMException {\n        SCIMFilter scimFilter;\n        try {\n            scimFilter = SCIMFilter.parse(filter);\n        } catch (SCIMException e) {\n            logger.debug(\"Attempting legacy scim filter conversion for [\" + filter + \"]\", e);\n            filter = filter.replaceAll(\"'\",\"\\\"\");\n            scimFilter = SCIMFilter.parse(filter);\n        }\n        return scimFilter;\n    }", "code_tokens": ["private", "SCIMFilter", "scimFilter", "(", "String", "filter", ")", "throws", "SCIMException", "{", "SCIMFilter", "scimFilter", ";", "try", "{", "scimFilter", "=", "SCIMFilter", ".", "parse", "(", "filter", ")", ";", "}", "catch", "(", "SCIMException", "e", ")", "{", "logger", ".", "debug", "(", "\"", "Attempting legacy scim filter conversion for [", "\"", "+", "filter", "+", "\"", "]", "\"", ",", "e", ")", ";", "filter", "=", "filter", ".", "replaceAll", "(", "\"", "'", "\"", ",", "\"", "\\\"", "\"", ")", ";", "scimFilter", "=", "SCIMFilter", ".", "parse", "(", "filter", ")", ";", "}", "return", "scimFilter", ";", "}"], "idx": 90826, "cwe": "CWE-89", "target": 1, "status": "VULNERABLE", "commit": "01edea6337c8ddb2ab80906aa1254d3c1dc02fb", "function_name": "scimFilter", "body_hash": "709ac977784c1f1f3023b6177ed0204e3cd05bc7"}
{"code": "@Override\n  public void refreshRow() throws SQLException {\n    checkUpdateable();\n    if (onInsertRow) {\n      throw new PSQLException(GT.tr(\"Can''t refresh the insert row.\"),\n          PSQLState.INVALID_CURSOR_STATE);\n    }\n\n    if (isBeforeFirst() || isAfterLast() || castNonNull(rows, \"rows\").isEmpty()) {\n      return;\n    }\n\n    StringBuilder selectSQL = new StringBuilder(\"select \");\n\n    ResultSetMetaData rsmd = getMetaData();\n    PGResultSetMetaData pgmd = (PGResultSetMetaData) rsmd;\n    for (int i = 1; i <= rsmd.getColumnCount(); i++) {\n      if (i > 1) {\n        selectSQL.append(\", \");\n      }\n      Utils.escapeIdentifier(selectSQL, pgmd.getBaseColumnName(i));\n    }\n    selectSQL.append(\" from \").append(onlyTable).append(tableName).append(\" where \");\n\n    List<PrimaryKey> primaryKeys = castNonNull(this.primaryKeys, \"primaryKeys\");\n    int numKeys = primaryKeys.size();\n\n    for (int i = 0; i < numKeys; i++) {\n\n      PrimaryKey primaryKey = primaryKeys.get(i);\n      Utils.escapeIdentifier(selectSQL, primaryKey.name);\n      selectSQL.append(\" = ?\");\n\n      if (i < numKeys - 1) {\n        selectSQL.append(\" and \");\n      }\n    }\n    String sqlText = selectSQL.toString();\n    if (connection.getLogger().isLoggable(Level.FINE)) {\n      connection.getLogger().log(Level.FINE, \"selecting {0}\", sqlText);\n    }\n    // because updateable result sets do not yet support binary transfers we must request refresh\n    // with updateable result set to get field data in correct format\n    PreparedStatement selectStatement = null;\n    try {\n      selectStatement = connection.prepareStatement(sqlText,\n          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);\n\n      for (int i = 0; i < numKeys; i++) {\n        selectStatement.setObject(i + 1, primaryKeys.get(i).getValue());\n      }\n\n      PgResultSet rs = (PgResultSet) selectStatement.executeQuery();\n\n      if (rs.next()) {\n        // we know that the row is updatable as it was tested above.\n        if ( rs.thisRow == null ) {\n          rowBuffer = null;\n        } else {\n          rowBuffer = castNonNull(rs.thisRow).updateableCopy();\n        }\n      }\n\n      castNonNull(rows).set(currentRow, castNonNull(rowBuffer));\n      thisRow = rowBuffer;\n\n      connection.getLogger().log(Level.FINE, \"done updates\");\n\n      rs.close();\n    } finally {\n      JdbcBlackHole.close(selectStatement);\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "refreshRow", "(", ")", "throws", "SQLException", "{", "checkUpdateable", "(", ")", ";", "if", "(", "onInsertRow", ")", "{", "throw", "new", "PSQLException", "(", "GT", ".", "tr", "(", "\"", "Can''t refresh the insert row.", "\"", ")", ",", "PSQLState", ".", "INVALID_CURSOR_STATE", ")", ";", "}", "if", "(", "isBeforeFirst", "(", ")", "||", "isAfterLast", "(", ")", "||", "castNonNull", "(", "rows", ",", "\"", "rows", "\"", ")", ".", "isEmpty", "(", ")", ")", "{", "return", ";", "}", "StringBuilder", "selectSQL", "=", "new", "StringBuilder", "(", "\"", "select ", "\"", ")", ";", "ResultSetMetaData", "rsmd", "=", "getMetaData", "(", ")", ";", "PGResultSetMetaData", "pgmd", "=", "(", "PGResultSetMetaData", ")", "rsmd", ";", "for", "(", "int", "i", "=", "1", ";", "i", "<=", "rsmd", ".", "getColumnCount", "(", ")", ";", "i", "++", ")", "{", "if", "(", "i", ">", "1", ")", "{", "selectSQL", ".", "append", "(", "\"", ", ", "\"", ")", ";", "}", "Utils", ".", "escapeIdentifier", "(", "selectSQL", ",", "pgmd", ".", "getBaseColumnName", "(", "i", ")", ")", ";", "}", "selectSQL", ".", "append", "(", "\"", " from ", "\"", ")", ".", "append", "(", "onlyTable", ")", ".", "append", "(", "tableName", ")", ".", "append", "(", "\"", " where ", "\"", ")", ";", "List", "<", "PrimaryKey", ">", "primaryKeys", "=", "castNonNull", "(", "this", ".", "primaryKeys", ",", "\"", "primaryKeys", "\"", ")", ";", "int", "numKeys", "=", "primaryKeys", ".", "size", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "numKeys", ";", "i", "++", ")", "{", "PrimaryKey", "primaryKey", "=", "primaryKeys", ".", "get", "(", "i", ")", ";", "Utils", ".", "escapeIdentifier", "(", "selectSQL", ",", "primaryKey", ".", "name", ")", ";", "selectSQL", ".", "append", "(", "\"", " = ?", "\"", ")", ";", "if", "(", "i", "<", "numKeys", "-", "1", ")", "{", "selectSQL", ".", "append", "(", "\"", " and ", "\"", ")", ";", "}", "}", "String", "sqlText", "=", "selectSQL", ".", "toString", "(", ")", ";", "if", "(", "connection", ".", "getLogger", "(", ")", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "connection", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "selecting {0}", "\"", ",", "sqlText", ")", ";", "}", "PreparedStatement", "selectStatement", "=", "null", ";", "try", "{", "selectStatement", "=", "connection", ".", "prepareStatement", "(", "sqlText", ",", "ResultSet", ".", "TYPE_SCROLL_INSENSITIVE", ",", "ResultSet", ".", "CONCUR_UPDATABLE", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "numKeys", ";", "i", "++", ")", "{", "selectStatement", ".", "setObject", "(", "i", "+", "1", ",", "primaryKeys", ".", "get", "(", "i", ")", ".", "getValue", "(", ")", ")", ";", "}", "PgResultSet", "rs", "=", "(", "PgResultSet", ")", "selectStatement", ".", "executeQuery", "(", ")", ";", "if", "(", "rs", ".", "next", "(", ")", ")", "{", "if", "(", "rs", ".", "thisRow", "==", "null", ")", "{", "rowBuffer", "=", "null", ";", "}", "else", "{", "rowBuffer", "=", "castNonNull", "(", "rs", ".", "thisRow", ")", ".", "updateableCopy", "(", ")", ";", "}", "}", "castNonNull", "(", "rows", ")", ".", "set", "(", "currentRow", ",", "castNonNull", "(", "rowBuffer", ")", ")", ";", "thisRow", "=", "rowBuffer", ";", "connection", ".", "getLogger", "(", ")", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "done updates", "\"", ")", ";", "rs", ".", "close", "(", ")", ";", "}", "finally", "{", "JdbcBlackHole", ".", "close", "(", "selectStatement", ")", ";", "}", "}"], "idx": 91573, "cwe": "CWE-89", "target": 0, "status": "FIXED", "commit": "739e599d52ad80f8dcd6efedc6157859b1a9d637", "function_name": "refreshRow", "body_hash": "e527f16e828233f923bacc9923e99292239a4f3e"}
{"code": "@Override\n    protected synchronized String issueCrumb(ServletRequest request, String salt) {\n        if (request instanceof HttpServletRequest) {\n            if (md != null) {\n                HttpServletRequest req = (HttpServletRequest) request;\n                StringBuilder buffer = new StringBuilder();\n                Authentication a = Jenkins.getAuthentication();\n                buffer.append(a.getName());\n                buffer.append(';');\n                if (!isExcludeClientIPFromCrumb()) {\n                    buffer.append(getClientIP(req));\n                }\n                if (!EXCLUDE_SESSION_ID) {\n                    buffer.append(';');\n                    buffer.append(getSessionId(req));\n                }\n\n                md.update(buffer.toString().getBytes());\n                return Util.toHexString(md.digest(salt.getBytes()));\n            }\n        }\n        return null;\n    }", "code_tokens": ["@", "Override", "protected", "synchronized", "String", "issueCrumb", "(", "ServletRequest", "request", ",", "String", "salt", ")", "{", "if", "(", "request", "instanceof", "HttpServletRequest", ")", "{", "if", "(", "md", "!=", "null", ")", "{", "HttpServletRequest", "req", "=", "(", "HttpServletRequest", ")", "request", ";", "StringBuilder", "buffer", "=", "new", "StringBuilder", "(", ")", ";", "Authentication", "a", "=", "Jenkins", ".", "getAuthentication", "(", ")", ";", "buffer", ".", "append", "(", "a", ".", "getName", "(", ")", ")", ";", "buffer", ".", "append", "(", "';'", ")", ";", "if", "(", "!", "isExcludeClientIPFromCrumb", "(", ")", ")", "{", "buffer", ".", "append", "(", "getClientIP", "(", "req", ")", ")", ";", "}", "if", "(", "!", "EXCLUDE_SESSION_ID", ")", "{", "buffer", ".", "append", "(", "';'", ")", ";", "buffer", ".", "append", "(", "getSessionId", "(", "req", ")", ")", ";", "}", "md", ".", "update", "(", "buffer", ".", "toString", "(", ")", ".", "getBytes", "(", ")", ")", ";", "return", "Util", ".", "toHexString", "(", "md", ".", "digest", "(", "salt", ".", "getBytes", "(", ")", ")", ")", ";", "}", "}", "return", "null", ";", "}"], "idx": 44420, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "772152315aa0a9ba27b812a4ba0f3f9b64af78d9", "function_name": "issueCrumb", "body_hash": "ea4a9c130501f1b3cf2125d42f65741c5c55bceb"}
{"code": "private void updateStatus() {\n        if (config.getHIDMode() == 0) {\n            config.setNetworkStatus(false);\n            EditorActivity.stopNetworkSocketService(this);\n            ipButton.setVisibility(View.GONE);\n            ipStatusDivider.setVisibility(View.GONE);\n            if (config.getUSBStatus()) {\n                statusText.setText(R.string.config_status_usb_on);\n                statusImage.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_usb));\n            } else {\n                statusText.setText(R.string.config_status_usb_off);\n                statusImage.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_usb_off));\n            }\n        } else if (config.getHIDMode() == 1) {\n            EditorActivity.startNetworkSocketService(this);\n            ipButton.setVisibility(View.VISIBLE);\n            ipStatusDivider.setVisibility(View.VISIBLE);\n            if (config.getNetworkStatus()) {\n                statusText.setText(R.string.config_status_net_on);\n                statusImage.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_net));\n            } else {\n                statusText.setText(R.string.config_status_net_off);\n                statusImage.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_net_off));\n            }\n            EditorActivity.updateNotification(this);\n        }\n    }", "code_tokens": ["private", "void", "updateStatus", "(", ")", "{", "if", "(", "config", ".", "getHIDMode", "(", ")", "==", "0", ")", "{", "config", ".", "setNetworkStatus", "(", "false", ")", ";", "EditorActivity", ".", "stopNetworkSocketService", "(", "this", ")", ";", "ipButton", ".", "setVisibility", "(", "View", ".", "GONE", ")", ";", "ipStatusDivider", ".", "setVisibility", "(", "View", ".", "GONE", ")", ";", "if", "(", "config", ".", "getUSBStatus", "(", ")", ")", "{", "statusText", ".", "setText", "(", "R", ".", "string", ".", "config_status_usb_on", ")", ";", "statusImage", ".", "setImageDrawable", "(", "ContextCompat", ".", "getDrawable", "(", "this", ",", "R", ".", "drawable", ".", "ic_usb", ")", ")", ";", "}", "else", "{", "statusText", ".", "setText", "(", "R", ".", "string", ".", "config_status_usb_off", ")", ";", "statusImage", ".", "setImageDrawable", "(", "ContextCompat", ".", "getDrawable", "(", "this", ",", "R", ".", "drawable", ".", "ic_usb_off", ")", ")", ";", "}", "}", "else", "if", "(", "config", ".", "getHIDMode", "(", ")", "==", "1", ")", "{", "EditorActivity", ".", "startNetworkSocketService", "(", "this", ")", ";", "ipButton", ".", "setVisibility", "(", "View", ".", "VISIBLE", ")", ";", "ipStatusDivider", ".", "setVisibility", "(", "View", ".", "VISIBLE", ")", ";", "if", "(", "config", ".", "getNetworkStatus", "(", ")", ")", "{", "statusText", ".", "setText", "(", "R", ".", "string", ".", "config_status_net_on", ")", ";", "statusImage", ".", "setImageDrawable", "(", "ContextCompat", ".", "getDrawable", "(", "this", ",", "R", ".", "drawable", ".", "ic_net", ")", ")", ";", "}", "else", "{", "statusText", ".", "setText", "(", "R", ".", "string", ".", "config_status_net_off", ")", ";", "statusImage", ".", "setImageDrawable", "(", "ContextCompat", ".", "getDrawable", "(", "this", ",", "R", ".", "drawable", ".", "ic_net_off", ")", ")", ";", "}", "EditorActivity", ".", "updateNotification", "(", "this", ")", ";", "}", "}"], "idx": 42138, "cwe": "CWE-327", "target": 1, "status": "VULNERABLE", "commit": "5e3a477365009f488a73efd26a91168502de1b93", "function_name": "updateStatus", "body_hash": "177cb03ed8bd05d63761c669acccf1cc42da1e49"}
{"code": "private void renderState(FacesContext context) throws IOException {\n        // Get the view state and write it to the response..\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        String viewStateId = Util.getViewStateId(context);\n\n        writer.startUpdate(viewStateId);\n        String state = context.getApplication().getStateManager().getViewState(context);\n        writer.write(state);\n        writer.endUpdate();\n\n        ClientWindow window = context.getExternalContext().getClientWindow();\n        if (null != window) {\n            String clientWindowId = Util.getClientWindowId(context);\n            writer.startUpdate(clientWindowId);\n            writer.write(window.getId());\n            writer.endUpdate();\n        }\n    }", "code_tokens": ["private", "void", "renderState", "(", "FacesContext", "context", ")", "throws", "IOException", "{", "PartialViewContext", "pvc", "=", "context", ".", "getPartialViewContext", "(", ")", ";", "PartialResponseWriter", "writer", "=", "pvc", ".", "getPartialResponseWriter", "(", ")", ";", "String", "viewStateId", "=", "Util", ".", "getViewStateId", "(", "context", ")", ";", "writer", ".", "startUpdate", "(", "viewStateId", ")", ";", "String", "state", "=", "context", ".", "getApplication", "(", ")", ".", "getStateManager", "(", ")", ".", "getViewState", "(", "context", ")", ";", "writer", ".", "write", "(", "state", ")", ";", "writer", ".", "endUpdate", "(", ")", ";", "ClientWindow", "window", "=", "context", ".", "getExternalContext", "(", ")", ".", "getClientWindow", "(", ")", ";", "if", "(", "null", "!=", "window", ")", "{", "String", "clientWindowId", "=", "Util", ".", "getClientWindowId", "(", "context", ")", ";", "writer", ".", "startUpdate", "(", "clientWindowId", ")", ";", "writer", ".", "write", "(", "window", ".", "getId", "(", ")", ")", ";", "writer", ".", "endUpdate", "(", ")", ";", "}", "}"], "idx": 79222, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "a3fa9573789ed5e867c43ea38374f4dbd5a8f81f", "function_name": "renderState", "body_hash": "498e9b7c5fd914346d3e495c5831924e3c7b7f96"}
{"code": "protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\n            \"java.beans.EventHandler\", //\n            \"java.lang.ProcessBuilder\", //\n            \"javax.imageio.ImageIO$ContainsFilter\", //\n            \"jdk.nashorn.internal.objects.NativeString\"});\n        denyTypesByRegExp(new Pattern[]{LAZY_ITERATORS, JAVAX_CRYPTO});\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }", "code_tokens": ["protected", "void", "setupSecurity", "(", ")", "{", "if", "(", "securityMapper", "==", "null", ")", "{", "return", ";", "}", "addPermission", "(", "AnyTypePermission", ".", "ANY", ")", ";", "denyTypes", "(", "new", "String", "[", "]", "{", "\"", "java.beans.EventHandler", "\"", ",", "\"", "java.lang.ProcessBuilder", "\"", ",", "\"", "javax.imageio.ImageIO$ContainsFilter", "\"", ",", "\"", "jdk.nashorn.internal.objects.NativeString", "\"", "}", ")", ";", "denyTypesByRegExp", "(", "new", "Pattern", "[", "]", "{", "LAZY_ITERATORS", ",", "JAVAX_CRYPTO", "}", ")", ";", "allowTypeHierarchy", "(", "Exception", ".", "class", ")", ";", "securityInitialized", "=", "false", ";", "}"], "idx": 77030, "cwe": "CWE-78", "target": 1, "status": "VULNERABLE", "commit": "0bcbf50126a62dfcd65f93a0da0c6d1ae92aa738", "function_name": "setupSecurity", "body_hash": "56512436612a68b0327addd882d6d939db10856c"}
{"code": "@Override\n    protected synchronized String issueCrumb(ServletRequest request, String salt) {\n        if (request instanceof HttpServletRequest) {\n            if (md != null) {\n                HttpServletRequest req = (HttpServletRequest) request;\n                StringBuilder buffer = new StringBuilder();\n                Authentication a = Jenkins.getAuthentication();\n                if (a != null) {\n                    buffer.append(a.getName());\n                }\n                buffer.append(';');\n                if (!isExcludeClientIPFromCrumb()) {\n                    buffer.append(getClientIP(req));\n                }\n\n                md.update(buffer.toString().getBytes());\n                return Util.toHexString(md.digest(salt.getBytes()));\n            }\n        }\n        return null;\n    }", "code_tokens": ["@", "Override", "protected", "synchronized", "String", "issueCrumb", "(", "ServletRequest", "request", ",", "String", "salt", ")", "{", "if", "(", "request", "instanceof", "HttpServletRequest", ")", "{", "if", "(", "md", "!=", "null", ")", "{", "HttpServletRequest", "req", "=", "(", "HttpServletRequest", ")", "request", ";", "StringBuilder", "buffer", "=", "new", "StringBuilder", "(", ")", ";", "Authentication", "a", "=", "Jenkins", ".", "getAuthentication", "(", ")", ";", "if", "(", "a", "!=", "null", ")", "{", "buffer", ".", "append", "(", "a", ".", "getName", "(", ")", ")", ";", "}", "buffer", ".", "append", "(", "';'", ")", ";", "if", "(", "!", "isExcludeClientIPFromCrumb", "(", ")", ")", "{", "buffer", ".", "append", "(", "getClientIP", "(", "req", ")", ")", ";", "}", "md", ".", "update", "(", "buffer", ".", "toString", "(", ")", ".", "getBytes", "(", ")", ")", ";", "return", "Util", ".", "toHexString", "(", "md", ".", "digest", "(", "salt", ".", "getBytes", "(", ")", ")", ")", ";", "}", "}", "return", "null", ";", "}"], "idx": 44419, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "772152315aa0a9ba27b812a4ba0f3f9b64af78d9", "function_name": "issueCrumb", "body_hash": "bdaeebe8ab166bd1304e23519f90d906bdfbcaa5"}
{"code": "@Override\n    public long skip(long ln) throws IOException {\n        //On TIKA-3092, we found that using the static byte array buffer\n        //caused problems with multithreading with the FlateInputStream\n        //from a POIFS document stream\n        if (skipBuffer == null) {\n            skipBuffer = new byte[4096];\n        }\n        long n = IOUtils.skip(super.in, ln, skipBuffer);\n        if (n != ln) {\n            throw new IOException(\"tried to skip \"+ln + \" but actually skipped: \"+n);\n        }\n        position += n;\n        return n;\n    }", "code_tokens": ["@", "Override", "public", "long", "skip", "(", "long", "ln", ")", "throws", "IOException", "{", "if", "(", "skipBuffer", "==", "null", ")", "{", "skipBuffer", "=", "new", "byte", "[", "4096", "]", ";", "}", "long", "n", "=", "IOUtils", ".", "skip", "(", "super", ".", "in", ",", "ln", ",", "skipBuffer", ")", ";", "if", "(", "n", "!=", "ln", ")", "{", "throw", "new", "IOException", "(", "\"", "tried to skip ", "\"", "+", "ln", "+", "\"", " but actually skipped: ", "\"", "+", "n", ")", ";", "}", "position", "+=", "n", ";", "return", "n", ";", "}"], "idx": 82933, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "e9b2c38", "function_name": "skip", "body_hash": "23733d21a55b2b422d60f3c28a148729271ff7c1"}
{"code": "protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        PrintWriter out = response.getWriter();\n        String[] stocks = request.getParameterValues(\"stocks\");\n        if (stocks == null || stocks.length == 0) {\n            out.println(\"<html><body>No <b>stocks</b> query parameter specified. Cannot publish market data</body></html>\");\n        } else {\n            Integer total = (Integer)request.getSession(true).getAttribute(\"total\");\n            if (total == null) {\n                total = Integer.valueOf(0);\n            }\n\n            int count = getNumberOfMessages(request);\n            total = Integer.valueOf(total.intValue() + count);\n            request.getSession().setAttribute(\"total\", total);\n\n            try {\n                WebClient client = WebClient.getWebClient(request);\n                for (int i = 0; i < count; i++) {\n                    sendMessage(client, stocks);\n                }\n                out.print(\"<html><head><meta http-equiv='refresh' content='\");\n                String refreshRate = request.getParameter(\"refresh\");\n                if (refreshRate == null || refreshRate.length() == 0) {\n                    refreshRate = \"1\";\n                }\n                out.print(refreshRate);\n                out.println(\"'/></head>\");\n                out.println(\"<body>Published <b>\" + escape(Integer.toString(count)) + \"</b> of \" + escape(Integer.toString(total))\n                        + \" price messages.  Refresh = \" + escape(refreshRate) + \"s\");\n                out.println(\"</body></html>\");\n\n            } catch (JMSException e) {\n                out.println(\"<html><body>Failed sending price messages due to <b>\" + e + \"</b></body></html>\");\n                log(\"Failed to send message: \" + e, e);\n            }\n        }\n    }", "code_tokens": ["protected", "void", "doGet", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "PrintWriter", "out", "=", "response", ".", "getWriter", "(", ")", ";", "String", "[", "]", "stocks", "=", "request", ".", "getParameterValues", "(", "\"", "stocks", "\"", ")", ";", "if", "(", "stocks", "==", "null", "||", "stocks", ".", "length", "==", "0", ")", "{", "out", ".", "println", "(", "\"", "<html><body>No <b>stocks</b> query parameter specified. Cannot publish market data</body></html>", "\"", ")", ";", "}", "else", "{", "Integer", "total", "=", "(", "Integer", ")", "request", ".", "getSession", "(", "true", ")", ".", "getAttribute", "(", "\"", "total", "\"", ")", ";", "if", "(", "total", "==", "null", ")", "{", "total", "=", "Integer", ".", "valueOf", "(", "0", ")", ";", "}", "int", "count", "=", "getNumberOfMessages", "(", "request", ")", ";", "total", "=", "Integer", ".", "valueOf", "(", "total", ".", "intValue", "(", ")", "+", "count", ")", ";", "request", ".", "getSession", "(", ")", ".", "setAttribute", "(", "\"", "total", "\"", ",", "total", ")", ";", "try", "{", "WebClient", "client", "=", "WebClient", ".", "getWebClient", "(", "request", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "{", "sendMessage", "(", "client", ",", "stocks", ")", ";", "}", "out", ".", "print", "(", "\"", "<html><head><meta http-equiv='refresh' content='", "\"", ")", ";", "String", "refreshRate", "=", "request", ".", "getParameter", "(", "\"", "refresh", "\"", ")", ";", "if", "(", "refreshRate", "==", "null", "||", "refreshRate", ".", "length", "(", ")", "==", "0", ")", "{", "refreshRate", "=", "\"", "1", "\"", ";", "}", "out", ".", "print", "(", "refreshRate", ")", ";", "out", ".", "println", "(", "\"", "'/></head>", "\"", ")", ";", "out", ".", "println", "(", "\"", "<body>Published <b>", "\"", "+", "escape", "(", "Integer", ".", "toString", "(", "count", ")", ")", "+", "\"", "</b> of ", "\"", "+", "escape", "(", "Integer", ".", "toString", "(", "total", ")", ")", "+", "\"", " price messages.  Refresh = ", "\"", "+", "escape", "(", "refreshRate", ")", "+", "\"", "s", "\"", ")", ";", "out", ".", "println", "(", "\"", "</body></html>", "\"", ")", ";", "}", "catch", "(", "JMSException", "e", ")", "{", "out", ".", "println", "(", "\"", "<html><body>Failed sending price messages due to <b>", "\"", "+", "e", "+", "\"", "</b></body></html>", "\"", ")", ";", "log", "(", "\"", "Failed to send message: ", "\"", "+", "e", ",", "e", ")", ";", "}", "}", "}"], "idx": 77485, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "51eb87a84be88d28383ea48f6e341ffe1203c5ba", "function_name": "doGet", "body_hash": "416d2ba416406b0ae94c5976fffe07050af42a5e"}
{"code": "private synchronized TaskBuilder loadTasks() throws IOException {\n        File projectsDir = new File(root,\"jobs\");\n        if(!projectsDir.getCanonicalFile().isDirectory() && !projectsDir.mkdirs()) {\n            if(projectsDir.exists())\n                throw new IOException(projectsDir+\" is not a directory\");\n            throw new IOException(\"Unable to create \"+projectsDir+\"\\nPermission issue? Please create this directory manually.\");\n        }\n        File[] subdirs = projectsDir.listFiles();\n\n        final Set<String> loadedNames = Collections.synchronizedSet(new HashSet<String>());\n\n        TaskGraphBuilder g = new TaskGraphBuilder();\n        Handle loadJenkins = g.requires(EXTENSIONS_AUGMENTED).attains(JOB_LOADED).add(\"Loading global config\", new Executable() {\n            public void run(Reactor session) throws Exception {\n                loadConfig();\n                // if we are loading old data that doesn't have this field\n                if (slaves != null && !slaves.isEmpty() && nodes.isLegacy()) {\n                    nodes.setNodes(slaves);\n                    slaves = null;\n                } else {\n                    nodes.load();\n                }\n\n                clouds.setOwner(Jenkins.this);\n            }\n        });\n\n        for (final File subdir : subdirs) {\n            g.requires(loadJenkins).attains(JOB_LOADED).notFatal().add(\"Loading item \" + subdir.getName(), new Executable() {\n                public void run(Reactor session) throws Exception {\n                    if(!Items.getConfigFile(subdir).exists()) {\n                        //Does not have job config file, so it is not a jenkins job hence skip it\n                        return;\n                    }\n                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);\n                    items.put(item.getName(), item);\n                    loadedNames.add(item.getName());\n                }\n            });\n        }\n\n        g.requires(JOB_LOADED).add(\"Cleaning up obsolete items deleted from the disk\", new Executable() {\n            public void run(Reactor reactor) throws Exception {\n                // anything we didn't load from disk, throw them away.\n                // doing this after loading from disk allows newly loaded items\n                // to inspect what already existed in memory (in case of reloading)\n\n                // retainAll doesn't work well because of CopyOnWriteMap implementation, so remove one by one\n                // hopefully there shouldn't be too many of them.\n                for (String name : items.keySet()) {\n                    if (!loadedNames.contains(name))\n                        items.remove(name);\n                }\n            }\n        });\n\n        g.requires(JOB_LOADED).add(\"Finalizing set up\",new Executable() {\n            public void run(Reactor session) throws Exception {\n                rebuildDependencyGraph();\n\n                {// recompute label objects - populates the labels mapping.\n                    for (Node slave : nodes.getNodes())\n                        // Note that not all labels are visible until the agents have connected.\n                        slave.getAssignedLabels();\n                    getAssignedLabels();\n                }\n\n                // initialize views by inserting the default view if necessary\n                // this is both for clean Jenkins and for backward compatibility.\n                if(views.size()==0 || primaryView==null) {\n                    View v = new AllView(AllView.DEFAULT_VIEW_NAME);\n                    setViewOwner(v);\n                    views.add(0,v);\n                    primaryView = v.getViewName();\n                }\n                primaryView = AllView.migrateLegacyPrimaryAllViewLocalizedName(views, primaryView);\n\n                if (useSecurity!=null && !useSecurity) {\n                    // forced reset to the unsecure mode.\n                    // this works as an escape hatch for people who locked themselves out.\n                    authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                } else {\n                    // read in old data that doesn't have the security field set\n                    if(authorizationStrategy==null) {\n                        if(useSecurity==null)\n                            authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                        else\n                            authorizationStrategy = new LegacyAuthorizationStrategy();\n                    }\n                    if(securityRealm==null) {\n                        if(useSecurity==null)\n                            setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                        else\n                            setSecurityRealm(new LegacySecurityRealm());\n                    } else {\n                        // force the set to proxy\n                        setSecurityRealm(securityRealm);\n                    }\n                }\n\n\n                // Initialize the filter with the crumb issuer\n                setCrumbIssuer(crumbIssuer);\n\n                // auto register root actions\n                for (Action a : getExtensionList(RootAction.class))\n                    if (!actions.contains(a)) actions.add(a);\n            }\n        });\n\n        return g;\n    }", "code_tokens": ["private", "synchronized", "TaskBuilder", "loadTasks", "(", ")", "throws", "IOException", "{", "File", "projectsDir", "=", "new", "File", "(", "root", ",", "\"", "jobs", "\"", ")", ";", "if", "(", "!", "projectsDir", ".", "getCanonicalFile", "(", ")", ".", "isDirectory", "(", ")", "&&", "!", "projectsDir", ".", "mkdirs", "(", ")", ")", "{", "if", "(", "projectsDir", ".", "exists", "(", ")", ")", "throw", "new", "IOException", "(", "projectsDir", "+", "\"", " is not a directory", "\"", ")", ";", "throw", "new", "IOException", "(", "\"", "Unable to create ", "\"", "+", "projectsDir", "+", "\"", "\\n", "Permission issue? Please create this directory manually.", "\"", ")", ";", "}", "File", "[", "]", "subdirs", "=", "projectsDir", ".", "listFiles", "(", ")", ";", "final", "Set", "<", "String", ">", "loadedNames", "=", "Collections", ".", "synchronizedSet", "(", "new", "HashSet", "<", "String", ">", "(", ")", ")", ";", "TaskGraphBuilder", "g", "=", "new", "TaskGraphBuilder", "(", ")", ";", "Handle", "loadJenkins", "=", "g", ".", "requires", "(", "EXTENSIONS_AUGMENTED", ")", ".", "attains", "(", "JOB_LOADED", ")", ".", "add", "(", "\"", "Loading global config", "\"", ",", "new", "Executable", "(", ")", "{", "public", "void", "run", "(", "Reactor", "session", ")", "throws", "Exception", "{", "loadConfig", "(", ")", ";", "if", "(", "slaves", "!=", "null", "&&", "!", "slaves", ".", "isEmpty", "(", ")", "&&", "nodes", ".", "isLegacy", "(", ")", ")", "{", "nodes", ".", "setNodes", "(", "slaves", ")", ";", "slaves", "=", "null", ";", "}", "else", "{", "nodes", ".", "load", "(", ")", ";", "}", "clouds", ".", "setOwner", "(", "Jenkins", ".", "this", ")", ";", "}", "}", ")", ";", "for", "(", "final", "File", "subdir", ":", "subdirs", ")", "{", "g", ".", "requires", "(", "loadJenkins", ")", ".", "attains", "(", "JOB_LOADED", ")", ".", "notFatal", "(", ")", ".", "add", "(", "\"", "Loading item ", "\"", "+", "subdir", ".", "getName", "(", ")", ",", "new", "Executable", "(", ")", "{", "public", "void", "run", "(", "Reactor", "session", ")", "throws", "Exception", "{", "if", "(", "!", "Items", ".", "getConfigFile", "(", "subdir", ")", ".", "exists", "(", ")", ")", "{", "return", ";", "}", "TopLevelItem", "item", "=", "(", "TopLevelItem", ")", "Items", ".", "load", "(", "Jenkins", ".", "this", ",", "subdir", ")", ";", "items", ".", "put", "(", "item", ".", "getName", "(", ")", ",", "item", ")", ";", "loadedNames", ".", "add", "(", "item", ".", "getName", "(", ")", ")", ";", "}", "}", ")", ";", "}", "g", ".", "requires", "(", "JOB_LOADED", ")", ".", "add", "(", "\"", "Cleaning up obsolete items deleted from the disk", "\"", ",", "new", "Executable", "(", ")", "{", "public", "void", "run", "(", "Reactor", "reactor", ")", "throws", "Exception", "{", "for", "(", "String", "name", ":", "items", ".", "keySet", "(", ")", ")", "{", "if", "(", "!", "loadedNames", ".", "contains", "(", "name", ")", ")", "items", ".", "remove", "(", "name", ")", ";", "}", "}", "}", ")", ";", "g", ".", "requires", "(", "JOB_LOADED", ")", ".", "add", "(", "\"", "Finalizing set up", "\"", ",", "new", "Executable", "(", ")", "{", "public", "void", "run", "(", "Reactor", "session", ")", "throws", "Exception", "{", "rebuildDependencyGraph", "(", ")", ";", "{", "for", "(", "Node", "slave", ":", "nodes", ".", "getNodes", "(", ")", ")", "slave", ".", "getAssignedLabels", "(", ")", ";", "getAssignedLabels", "(", ")", ";", "}", "if", "(", "views", ".", "size", "(", ")", "==", "0", "||", "primaryView", "==", "null", ")", "{", "View", "v", "=", "new", "AllView", "(", "AllView", ".", "DEFAULT_VIEW_NAME", ")", ";", "setViewOwner", "(", "v", ")", ";", "views", ".", "add", "(", "0", ",", "v", ")", ";", "primaryView", "=", "v", ".", "getViewName", "(", ")", ";", "}", "primaryView", "=", "AllView", ".", "migrateLegacyPrimaryAllViewLocalizedName", "(", "views", ",", "primaryView", ")", ";", "if", "(", "useSecurity", "!=", "null", "&&", "!", "useSecurity", ")", "{", "authorizationStrategy", "=", "AuthorizationStrategy", ".", "UNSECURED", ";", "setSecurityRealm", "(", "SecurityRealm", ".", "NO_AUTHENTICATION", ")", ";", "}", "else", "{", "if", "(", "authorizationStrategy", "==", "null", ")", "{", "if", "(", "useSecurity", "==", "null", ")", "authorizationStrategy", "=", "AuthorizationStrategy", ".", "UNSECURED", ";", "else", "authorizationStrategy", "=", "new", "LegacyAuthorizationStrategy", "(", ")", ";", "}", "if", "(", "securityRealm", "==", "null", ")", "{", "if", "(", "useSecurity", "==", "null", ")", "setSecurityRealm", "(", "SecurityRealm", ".", "NO_AUTHENTICATION", ")", ";", "else", "setSecurityRealm", "(", "new", "LegacySecurityRealm", "(", ")", ")", ";", "}", "else", "{", "setSecurityRealm", "(", "securityRealm", ")", ";", "}", "}", "setCrumbIssuer", "(", "crumbIssuer", ")", ";", "for", "(", "Action", "a", ":", "getExtensionList", "(", "RootAction", ".", "class", ")", ")", "if", "(", "!", "actions", ".", "contains", "(", "a", ")", ")", "actions", ".", "add", "(", "a", ")", ";", "}", "}", ")", ";", "return", "g", ";", "}"], "idx": 48616, "cwe": "CWE-362", "target": 1, "status": "VULNERABLE", "commit": "ccc374a7176d7704941fb494589790b7673efe2e", "function_name": "loadTasks", "body_hash": "54adb6e5d1cbd73a64044df116490f2fbe958903"}
{"code": "public static HttpHost extractHost(final URI uri) {\n        if (uri == null) {\n            return null;\n        }\n        if (uri.isAbsolute()) {\n            if (uri.getHost() == null) { // normal parse failed; let's do it ourselves\n                // authority does not seem to care about the valid character-set for host names\n                if (uri.getAuthority() != null) {\n                    String content = uri.getAuthority();\n                    // Strip off any leading user credentials\n                    int at = content.indexOf('@');\n                    if (at != -1) {\n                        content = content.substring(at + 1);\n                    }\n                    final String scheme = uri.getScheme();\n                    final String hostname;\n                    final int port;\n                    at = content.indexOf(\":\");\n                    if (at != -1) {\n                        hostname = content.substring(0, at);\n                        try {\n                            final String portText = content.substring(at + 1);\n                            port = !TextUtils.isEmpty(portText) ? Integer.parseInt(portText) : -1;\n                        } catch (final NumberFormatException ex) {\n                            return null;\n                        }\n                    } else {\n                        hostname = content;\n                        port = -1;\n                    }\n                    try {\n                        return new HttpHost(hostname, port, scheme);\n                    } catch (final IllegalArgumentException ex) {\n                        return null;\n                    }\n                }\n            } else {\n                return new HttpHost(uri.getHost(), uri.getPort(), uri.getScheme());\n            }\n        }\n        return null;\n    }", "code_tokens": ["public", "static", "HttpHost", "extractHost", "(", "final", "URI", "uri", ")", "{", "if", "(", "uri", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "uri", ".", "isAbsolute", "(", ")", ")", "{", "if", "(", "uri", ".", "getHost", "(", ")", "==", "null", ")", "{", "if", "(", "uri", ".", "getAuthority", "(", ")", "!=", "null", ")", "{", "String", "content", "=", "uri", ".", "getAuthority", "(", ")", ";", "int", "at", "=", "content", ".", "indexOf", "(", "'@'", ")", ";", "if", "(", "at", "!=", "-", "1", ")", "{", "content", "=", "content", ".", "substring", "(", "at", "+", "1", ")", ";", "}", "final", "String", "scheme", "=", "uri", ".", "getScheme", "(", ")", ";", "final", "String", "hostname", ";", "final", "int", "port", ";", "at", "=", "content", ".", "indexOf", "(", "\"", ":", "\"", ")", ";", "if", "(", "at", "!=", "-", "1", ")", "{", "hostname", "=", "content", ".", "substring", "(", "0", ",", "at", ")", ";", "try", "{", "final", "String", "portText", "=", "content", ".", "substring", "(", "at", "+", "1", ")", ";", "port", "=", "!", "TextUtils", ".", "isEmpty", "(", "portText", ")", "?", "Integer", ".", "parseInt", "(", "portText", ")", ":", "-", "1", ";", "}", "catch", "(", "final", "NumberFormatException", "ex", ")", "{", "return", "null", ";", "}", "}", "else", "{", "hostname", "=", "content", ";", "port", "=", "-", "1", ";", "}", "try", "{", "return", "new", "HttpHost", "(", "hostname", ",", "port", ",", "scheme", ")", ";", "}", "catch", "(", "final", "IllegalArgumentException", "ex", ")", "{", "return", "null", ";", "}", "}", "}", "else", "{", "return", "new", "HttpHost", "(", "uri", ".", "getHost", "(", ")", ",", "uri", ".", "getPort", "(", ")", ",", "uri", ".", "getScheme", "(", ")", ")", ";", "}", "}", "return", "null", ";", "}"], "idx": 99559, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "e628b4c5c464c2fa346385596cc78e035a91a62e", "function_name": "extractHost", "body_hash": "fc7c6f9786de626b250839c9e8a8d89053dc3751"}
{"code": "@Override\n    public final void emitHeader(String name, String value) throws HpackException {\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"stream.header.debug\", getConnectionId(), getIdentifier(),\n                    name, value));\n        }\n\n        // Header names must be lower case\n        if (!name.toLowerCase(Locale.US).equals(name)) {\n            throw new HpackException(sm.getString(\"stream.header.case\",\n                    getConnectionId(), getIdentifier(), name));\n        }\n\n        if (\"connection\".equals(name)) {\n            throw new HpackException(sm.getString(\"stream.header.connection\",\n                    getConnectionId(), getIdentifier()));\n        }\n\n        if (\"te\".equals(name)) {\n            if (!\"trailers\".equals(value)) {\n                throw new HpackException(sm.getString(\"stream.header.te\",\n                        getConnectionId(), getIdentifier(), value));\n            }\n        }\n\n        if (headerStateErrorMsg != null) {\n            // Don't bother processing the header since the stream is going to\n            // be reset anyway\n            return;\n        }\n\n        boolean pseudoHeader = name.charAt(0) == ':';\n\n        if (pseudoHeader && headerState != HEADER_STATE_PSEUDO) {\n            headerStateErrorMsg = sm.getString(\"stream.header.unexpectedPseudoHeader\",\n                    getConnectionId(), getIdentifier(), name);\n            // No need for further processing. The stream will be reset.\n            return;\n        }\n\n        if (headerState == HEADER_STATE_PSEUDO && !pseudoHeader) {\n            headerState = HEADER_STATE_REGULAR;\n        }\n\n        switch(name) {\n        case \":method\": {\n            if (coyoteRequest.method().isNull()) {\n                coyoteRequest.method().setString(value);\n            } else {\n                throw new HpackException(sm.getString(\"stream.header.duplicate\",\n                        getConnectionId(), getIdentifier(), \":method\" ));\n            }\n            break;\n        }\n        case \":scheme\": {\n            if (coyoteRequest.scheme().isNull()) {\n                coyoteRequest.scheme().setString(value);\n            } else {\n                throw new HpackException(sm.getString(\"stream.header.duplicate\",\n                        getConnectionId(), getIdentifier(), \":scheme\" ));\n            }\n            break;\n        }\n        case \":path\": {\n            if (!coyoteRequest.requestURI().isNull()) {\n                throw new HpackException(sm.getString(\"stream.header.duplicate\",\n                        getConnectionId(), getIdentifier(), \":path\" ));\n            }\n            if (value.length() == 0) {\n                throw new HpackException(sm.getString(\"stream.header.noPath\",\n                        getConnectionId(), getIdentifier()));\n            }\n            int queryStart = value.indexOf('?');\n            if (queryStart == -1) {\n                coyoteRequest.requestURI().setString(value);\n                coyoteRequest.decodedURI().setString(\n                        coyoteRequest.getURLDecoder().convert(value, false));\n            } else {\n                String uri = value.substring(0, queryStart);\n                String query = value.substring(queryStart + 1);\n                coyoteRequest.requestURI().setString(uri);\n                coyoteRequest.decodedURI().setString(\n                        coyoteRequest.getURLDecoder().convert(uri, false));\n                coyoteRequest.queryString().setString(query);\n            }\n            break;\n        }\n        case \":authority\": {\n            if (coyoteRequest.serverName().isNull()) {\n                int i = value.lastIndexOf(':');\n                if (i > -1) {\n                    coyoteRequest.serverName().setString(value.substring(0, i));\n                    coyoteRequest.setServerPort(Integer.parseInt(value.substring(i + 1)));\n                } else {\n                    coyoteRequest.serverName().setString(value);\n                }\n            } else {\n                throw new HpackException(sm.getString(\"stream.header.duplicate\",\n                        getConnectionId(), getIdentifier(), \":authority\" ));\n            }\n            break;\n        }\n        case \"cookie\": {\n            // Cookie headers need to be concatenated into a single header\n            // See RFC 7540 8.1.2.5\n            if (cookieHeader == null) {\n                cookieHeader = new StringBuilder();\n            } else {\n                cookieHeader.append(\"; \");\n            }\n            cookieHeader.append(value);\n            break;\n        }\n        default: {\n            if (headerState == HEADER_STATE_TRAILER && !handler.isTrailerHeaderAllowed(name)) {\n                break;\n            }\n            if (\"expect\".equals(name) && \"100-continue\".equals(value)) {\n                coyoteRequest.setExpectation(true);\n            }\n            if (pseudoHeader) {\n                headerStateErrorMsg = sm.getString(\"stream.header.unknownPseudoHeader\",\n                        getConnectionId(), getIdentifier(), name);\n            }\n\n            if (headerState == HEADER_STATE_TRAILER) {\n                // HTTP/2 headers are already always lower case\n                coyoteRequest.getTrailerFields().put(name, value);\n            } else {\n                coyoteRequest.getMimeHeaders().addValue(name).setString(value);\n            }\n        }\n        }\n    }", "code_tokens": ["@", "Override", "public", "final", "void", "emitHeader", "(", "String", "name", ",", "String", "value", ")", "throws", "HpackException", "{", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "stream.header.debug", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "name", ",", "value", ")", ")", ";", "}", "if", "(", "!", "name", ".", "toLowerCase", "(", "Locale", ".", "US", ")", ".", "equals", "(", "name", ")", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.case", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "name", ")", ")", ";", "}", "if", "(", "\"", "connection", "\"", ".", "equals", "(", "name", ")", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.connection", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ")", ")", ";", "}", "if", "(", "\"", "te", "\"", ".", "equals", "(", "name", ")", ")", "{", "if", "(", "!", "\"", "trailers", "\"", ".", "equals", "(", "value", ")", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.te", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "value", ")", ")", ";", "}", "}", "if", "(", "headerStateErrorMsg", "!=", "null", ")", "{", "return", ";", "}", "boolean", "pseudoHeader", "=", "name", ".", "charAt", "(", "0", ")", "==", "':'", ";", "if", "(", "pseudoHeader", "&&", "headerState", "!=", "HEADER_STATE_PSEUDO", ")", "{", "headerStateErrorMsg", "=", "sm", ".", "getString", "(", "\"", "stream.header.unexpectedPseudoHeader", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "name", ")", ";", "return", ";", "}", "if", "(", "headerState", "==", "HEADER_STATE_PSEUDO", "&&", "!", "pseudoHeader", ")", "{", "headerState", "=", "HEADER_STATE_REGULAR", ";", "}", "switch", "(", "name", ")", "{", "case", "\"", ":method", "\"", ":", "{", "if", "(", "coyoteRequest", ".", "method", "(", ")", ".", "isNull", "(", ")", ")", "{", "coyoteRequest", ".", "method", "(", ")", ".", "setString", "(", "value", ")", ";", "}", "else", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.duplicate", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "\"", ":method", "\"", ")", ")", ";", "}", "break", ";", "}", "case", "\"", ":scheme", "\"", ":", "{", "if", "(", "coyoteRequest", ".", "scheme", "(", ")", ".", "isNull", "(", ")", ")", "{", "coyoteRequest", ".", "scheme", "(", ")", ".", "setString", "(", "value", ")", ";", "}", "else", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.duplicate", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "\"", ":scheme", "\"", ")", ")", ";", "}", "break", ";", "}", "case", "\"", ":path", "\"", ":", "{", "if", "(", "!", "coyoteRequest", ".", "requestURI", "(", ")", ".", "isNull", "(", ")", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.duplicate", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "\"", ":path", "\"", ")", ")", ";", "}", "if", "(", "value", ".", "length", "(", ")", "==", "0", ")", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.noPath", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ")", ")", ";", "}", "int", "queryStart", "=", "value", ".", "indexOf", "(", "'?'", ")", ";", "if", "(", "queryStart", "==", "-", "1", ")", "{", "coyoteRequest", ".", "requestURI", "(", ")", ".", "setString", "(", "value", ")", ";", "coyoteRequest", ".", "decodedURI", "(", ")", ".", "setString", "(", "coyoteRequest", ".", "getURLDecoder", "(", ")", ".", "convert", "(", "value", ",", "false", ")", ")", ";", "}", "else", "{", "String", "uri", "=", "value", ".", "substring", "(", "0", ",", "queryStart", ")", ";", "String", "query", "=", "value", ".", "substring", "(", "queryStart", "+", "1", ")", ";", "coyoteRequest", ".", "requestURI", "(", ")", ".", "setString", "(", "uri", ")", ";", "coyoteRequest", ".", "decodedURI", "(", ")", ".", "setString", "(", "coyoteRequest", ".", "getURLDecoder", "(", ")", ".", "convert", "(", "uri", ",", "false", ")", ")", ";", "coyoteRequest", ".", "queryString", "(", ")", ".", "setString", "(", "query", ")", ";", "}", "break", ";", "}", "case", "\"", ":authority", "\"", ":", "{", "if", "(", "coyoteRequest", ".", "serverName", "(", ")", ".", "isNull", "(", ")", ")", "{", "int", "i", "=", "value", ".", "lastIndexOf", "(", "':'", ")", ";", "if", "(", "i", ">", "-", "1", ")", "{", "coyoteRequest", ".", "serverName", "(", ")", ".", "setString", "(", "value", ".", "substring", "(", "0", ",", "i", ")", ")", ";", "coyoteRequest", ".", "setServerPort", "(", "Integer", ".", "parseInt", "(", "value", ".", "substring", "(", "i", "+", "1", ")", ")", ")", ";", "}", "else", "{", "coyoteRequest", ".", "serverName", "(", ")", ".", "setString", "(", "value", ")", ";", "}", "}", "else", "{", "throw", "new", "HpackException", "(", "sm", ".", "getString", "(", "\"", "stream.header.duplicate", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "\"", ":authority", "\"", ")", ")", ";", "}", "break", ";", "}", "case", "\"", "cookie", "\"", ":", "{", "if", "(", "cookieHeader", "==", "null", ")", "{", "cookieHeader", "=", "new", "StringBuilder", "(", ")", ";", "}", "else", "{", "cookieHeader", ".", "append", "(", "\"", "; ", "\"", ")", ";", "}", "cookieHeader", ".", "append", "(", "value", ")", ";", "break", ";", "}", "default", ":", "{", "if", "(", "headerState", "==", "HEADER_STATE_TRAILER", "&&", "!", "handler", ".", "isTrailerHeaderAllowed", "(", "name", ")", ")", "{", "break", ";", "}", "if", "(", "\"", "expect", "\"", ".", "equals", "(", "name", ")", "&&", "\"", "100-continue", "\"", ".", "equals", "(", "value", ")", ")", "{", "coyoteRequest", ".", "setExpectation", "(", "true", ")", ";", "}", "if", "(", "pseudoHeader", ")", "{", "headerStateErrorMsg", "=", "sm", ".", "getString", "(", "\"", "stream.header.unknownPseudoHeader", "\"", ",", "getConnectionId", "(", ")", ",", "getIdentifier", "(", ")", ",", "name", ")", ";", "}", "if", "(", "headerState", "==", "HEADER_STATE_TRAILER", ")", "{", "coyoteRequest", ".", "getTrailerFields", "(", ")", ".", "put", "(", "name", ",", "value", ")", ";", "}", "else", "{", "coyoteRequest", ".", "getMimeHeaders", "(", ")", ".", "addValue", "(", "name", ")", ".", "setString", "(", "value", ")", ";", "}", "}", "}", "}"], "idx": 25676, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "cf181edc9a8c239cde704cffc3c503425bdcae2b", "function_name": "emitHeader", "body_hash": "50bb4a8ac1d2a60b0ea4acd29a2f22ec203841b0"}
