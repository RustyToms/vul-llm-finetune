{"code":"static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}\n","idx":2,"target":0}
{"code":"int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n","idx":4,"target":0}
{"code":"static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    int i;\n\n\n\n    r3d->video_offsets_count = (atom->size - 8) \/ 4;\n\n    r3d->video_offsets = av_malloc(atom->size);\n\n    if (!r3d->video_offsets)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < r3d->video_offsets_count; i++) {\n\n        r3d->video_offsets[i] = avio_rb32(s->pb);\n\n        if (!r3d->video_offsets[i]) {\n\n            r3d->video_offsets_count = i;\n\n            break;\n\n        }\n\n        av_dlog(s, \"video offset %d: %#x\\n\", i, r3d->video_offsets[i]);\n\n    }\n\n\n\n    if (st->r_frame_rate.num)\n\n        st->duration = av_rescale_q(r3d->video_offsets_count,\n\n                                    (AVRational){st->r_frame_rate.den,\n\n                                                 st->r_frame_rate.num},\n\n                                    st->time_base);\n\n    av_dlog(s, \"duration %\"PRId64\"\\n\", st->duration);\n\n\n\n    return 0;\n\n}\n","idx":5,"target":1}
{"code":"static void check_lowpass_line(int depth){\n\n    LOCAL_ALIGNED_32(uint8_t, src,     [SRC_SIZE]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_ref, [WIDTH_PADDED]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_new, [WIDTH_PADDED]);\n\n    int w = WIDTH;\n\n    int mref = WIDTH_PADDED * -1;\n\n    int pref = WIDTH_PADDED;\n\n    int i, depth_byte;\n\n    InterlaceContext s;\n\n\n\n    declare_func(void, uint8_t *dstp, ptrdiff_t linesize, const uint8_t *srcp,\n\n                 ptrdiff_t mref, ptrdiff_t pref, int clip_max);\n\n\n\n    s.lowpass = 1;\n\n    s.lowpass = VLPF_LIN;\n\n    depth_byte = depth >> 3;\n\n    w \/= depth_byte;\n\n\n\n    memset(src,     0, SRC_SIZE);\n\n    memset(dst_ref, 0, WIDTH_PADDED);\n\n    memset(dst_new, 0, WIDTH_PADDED);\n\n    randomize_buffers(src, SRC_SIZE);\n\n\n\n    ff_interlace_init(&s, depth);\n\n\n\n    if (check_func(s.lowpass_line, \"lowpass_line_%d\", depth)) {\n\n        for (i = 0; i < 32; i++) { \/* simulate crop *\/\n\n            call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            if (memcmp(dst_ref, dst_new, WIDTH - i))\n\n                fail();\n\n        }\n\n        bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);\n\n    }\n\n}\n","idx":7,"target":1}
{"code":"static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n{\n    MirrorState *s = FILTER_MIRROR(nf);\n    Chardev *chr;\n    chr = qemu_chr_find(s->outdev);\n    if (chr == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", s->outdev);\n    qemu_chr_fe_init(&s->chr_out, chr, errp);","idx":8,"target":1}
{"code":"static void test_init(TestData *d)\n\n{\n\n    QPCIBus *bus;\n\n    QTestState *qs;\n\n    char *s;\n\n\n\n    s = g_strdup_printf(\"-machine q35 %s %s\",\n\n                        d->noreboot ? \"\" : \"-global ICH9-LPC.noreboot=false\",\n\n                        !d->args ? \"\" : d->args);\n\n    qs = qtest_start(s);\n\n    qtest_irq_intercept_in(qs, \"ioapic\");\n\n    g_free(s);\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    d->dev = qpci_device_find(bus, QPCI_DEVFN(0x1f, 0x00));\n\n    g_assert(d->dev != NULL);\n\n\n\n    qpci_device_enable(d->dev);\n\n\n\n    \/* set ACPI PM I\/O space base address *\/\n\n    qpci_config_writel(d->dev, ICH9_LPC_PMBASE, PM_IO_BASE_ADDR | 0x1);\n\n    \/* enable ACPI I\/O *\/\n\n    qpci_config_writeb(d->dev, ICH9_LPC_ACPI_CTRL, 0x80);\n\n    \/* set Root Complex BAR *\/\n\n    qpci_config_writel(d->dev, ICH9_LPC_RCBA, RCBA_BASE_ADDR | 0x1);\n\n\n\n    d->tco_io_base = qpci_legacy_iomap(d->dev, PM_IO_BASE_ADDR + 0x60);\n\n}\n","idx":9,"target":1}
{"code":"static inline int64_t sub64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a - b;\n\n}\n","idx":10,"target":1}
{"code":"void assert_avoptions(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t;\n\n    if ((t = av_dict_get(m, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Option %s not found.\\n\", t->key);\n\n        exit(1);\n\n    }\n\n}\n","idx":11,"target":1}
{"code":"static void nbd_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    QDict *opts = qdict_new();\n\n    QObject *saddr_qdict;\n\n    Visitor *ov;\n\n    const char *host = NULL, *port = NULL, *path = NULL;\n\n\n\n    if (s->saddr->type == SOCKET_ADDRESS_KIND_INET) {\n\n        const InetSocketAddress *inet = s->saddr->u.inet.data;\n\n        if (!inet->has_ipv4 && !inet->has_ipv6 && !inet->has_to) {\n\n            host = inet->host;\n\n            port = inet->port;\n\n        }\n\n    } else if (s->saddr->type == SOCKET_ADDRESS_KIND_UNIX) {\n\n        path = s->saddr->u.q_unix.data->path;\n\n    }\n\n\n\n    qdict_put(opts, \"driver\", qstring_from_str(\"nbd\"));\n\n\n\n    if (path && s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix:\/\/\/%s?socket=%s\", s->export, path);\n\n    } else if (path && !s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix:\/\/?socket=%s\", path);\n\n    } else if (host && s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd:\/\/%s:%s\/%s\", host, port, s->export);\n\n    } else if (host && !s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd:\/\/%s:%s\", host, port);\n\n    }\n\n\n\n    ov = qobject_output_visitor_new(&saddr_qdict);\n\n    visit_type_SocketAddress(ov, NULL, &s->saddr, &error_abort);\n\n    visit_complete(ov, &saddr_qdict);\n\n\n    assert(qobject_type(saddr_qdict) == QTYPE_QDICT);\n\n\n\n    qdict_put_obj(opts, \"server\", saddr_qdict);\n\n\n\n    if (s->export) {\n\n        qdict_put(opts, \"export\", qstring_from_str(s->export));\n\n    }\n\n    if (s->tlscredsid) {\n\n        qdict_put(opts, \"tls-creds\", qstring_from_str(s->tlscredsid));\n\n    }\n\n\n\n    qdict_flatten(opts);\n\n    bs->full_open_options = opts;\n\n}","idx":13,"target":1}
{"code":"int net_init_tap(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    const char *ifname;\n\n\n\n    ifname = qemu_opt_get(opts, \"ifname\");\n\n\n\n    if (!ifname) {\n\n        error_report(\"tap: no interface name\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap_win32_init(vlan, \"tap\", name, ifname) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":14,"target":1}
{"code":"void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                         void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    assert(key & FW_CFG_WRITE_CHANNEL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n}\n","idx":15,"target":1}
{"code":"static int vncws_start_tls_handshake(VncState *vs)\n\n{\n\n    int ret = gnutls_handshake(vs->tls.session);\n\n\n\n    if (ret < 0) {\n\n        if (!gnutls_error_is_fatal(ret)) {\n\n            VNC_DEBUG(\"Handshake interrupted (blocking)\\n\");\n\n            if (!gnutls_record_get_direction(vs->tls.session)) {\n\n                qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io,\n\n                                    NULL, vs);\n\n            } else {\n\n                qemu_set_fd_handler(vs->csock, NULL, vncws_tls_handshake_io,\n\n                                    vs);\n\n            }\n\n            return 0;\n\n        }\n\n        VNC_DEBUG(\"Handshake failed %s\\n\", gnutls_strerror(ret));\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (vs->vd->tls.x509verify) {\n\n        if (vnc_tls_validate_certificate(vs) < 0) {\n\n            VNC_DEBUG(\"Client verification failed\\n\");\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        } else {\n\n            VNC_DEBUG(\"Client verification passed\\n\");\n\n        }\n\n    }\n\n\n\n    VNC_DEBUG(\"Handshake done, switching to TLS data mode\\n\");\n\n    qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n\n\n    return 0;\n\n}\n","idx":18,"target":1}
{"code":"av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n","idx":19,"target":0}
{"code":"static void quantize_mantissas(AC3EncodeContext *s)\n\n{\n\n    int blk, ch;\n\n\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        AC3Block *block = &s->blocks[blk];\n\n        s->mant1_cnt  = s->mant2_cnt  = s->mant4_cnt  = 0;\n\n        s->qmant1_ptr = s->qmant2_ptr = s->qmant4_ptr = NULL;\n\n\n\n        for (ch = 0; ch < s->channels; ch++) {\n\n            quantize_mantissas_blk_ch(s, block->fixed_coef[ch], block->exp_shift[ch],\n\n                                      block->exp[ch], block->bap[ch],\n\n                                      block->qmant[ch], s->nb_coefs[ch]);\n\n        }\n\n    }\n\n}\n","idx":21,"target":1}
{"code":"static void emulated_push_error(EmulatedState *card, uint64_t code)\n\n{\n\n    EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent));\n\n\n\n    assert(event);\n\n    event->p.error.type = EMUL_ERROR;\n\n    event->p.error.code = code;\n\n    emulated_push_event(card, event);\n\n}\n","idx":22,"target":1}
{"code":"static void dma_blk_cb(void *opaque, int ret)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n    dma_addr_t cur_addr, cur_len;\n\n    void *mem;\n\n\n\n    trace_dma_blk_cb(dbs, ret);\n\n\n\n    dbs->acb = NULL;\n\n    dbs->sector_num += dbs->iov.size \/ 512;\n\n\n\n    if (dbs->sg_cur_index == dbs->sg->nsg || ret < 0) {\n\n        dma_complete(dbs, ret);\n\n        return;\n\n    }\n\n    dma_blk_unmap(dbs);\n\n\n\n    while (dbs->sg_cur_index < dbs->sg->nsg) {\n\n        cur_addr = dbs->sg->sg[dbs->sg_cur_index].base + dbs->sg_cur_byte;\n\n        cur_len = dbs->sg->sg[dbs->sg_cur_index].len - dbs->sg_cur_byte;\n\n        mem = dma_memory_map(dbs->sg->as, cur_addr, &cur_len, dbs->dir);\n\n        if (!mem)\n\n            break;\n\n        qemu_iovec_add(&dbs->iov, mem, cur_len);\n\n        dbs->sg_cur_byte += cur_len;\n\n        if (dbs->sg_cur_byte == dbs->sg->sg[dbs->sg_cur_index].len) {\n\n            dbs->sg_cur_byte = 0;\n\n            ++dbs->sg_cur_index;\n\n        }\n\n    }\n\n\n\n    if (dbs->iov.size == 0) {\n\n        trace_dma_map_wait(dbs);\n\n        cpu_register_map_client(dbs, continue_after_map_failure);\n\n        return;\n\n    }\n\n\n\n    if (dbs->iov.size & ~BDRV_SECTOR_MASK) {\n\n        qemu_iovec_discard_back(&dbs->iov, dbs->iov.size & ~BDRV_SECTOR_MASK);\n\n    }\n\n\n\n    dbs->acb = dbs->io_func(dbs->blk, dbs->sector_num, &dbs->iov,\n\n                            dbs->iov.size \/ 512, dma_blk_cb, dbs);\n\n    assert(dbs->acb);\n\n}\n","idx":23,"target":1}
{"code":"long do_sigreturn(CPUPPCState *env)\n\n{\n\n    struct target_sigcontext *sc = NULL;\n\n    struct target_mcontext *sr = NULL;\n\n    target_ulong sr_addr = 0, sc_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t set;\n\n\n\n    sc_addr = env->gpr[1] + SIGNAL_FRAMESIZE;\n\n    if (!lock_user_struct(VERIFY_READ, sc, sc_addr, 1))\n\n        goto sigsegv;\n\n\n\n#if defined(TARGET_PPC64)\n\n    set.sig[0] = sc->oldmask + ((uint64_t)(sc->_unused[3]) << 32);\n\n#else\n\n    __get_user(set.sig[0], &sc->oldmask);\n\n    __get_user(set.sig[1], &sc->_unused[3]);\n\n#endif\n\n    target_to_host_sigset_internal(&blocked, &set);\n\n    set_sigmask(&blocked);\n\n\n\n    __get_user(sr_addr, &sc->regs);\n\n    if (!lock_user_struct(VERIFY_READ, sr, sr_addr, 1))\n\n        goto sigsegv;\n\n    restore_user_regs(env, sr, 1);\n\n\n\n    unlock_user_struct(sr, sr_addr, 1);\n\n    unlock_user_struct(sc, sc_addr, 1);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nsigsegv:\n\n    unlock_user_struct(sr, sr_addr, 1);\n\n    unlock_user_struct(sc, sc_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n","idx":24,"target":1}
{"code":"static av_cold int iv_alloc_frames(Indeo3DecodeContext *s)\n\n{\n\n    int luma_width    = (s->width           + 3) & ~3,\n\n        luma_height   = (s->height          + 3) & ~3,\n\n        chroma_width  = ((luma_width  >> 2) + 3) & ~3,\n\n        chroma_height = ((luma_height >> 2) + 3) & ~3,\n\n        luma_pixels   = luma_width   * luma_height,\n\n        chroma_pixels = chroma_width * chroma_height,\n\n        i;\n\n    unsigned int bufsize = luma_pixels * 2 + luma_width * 3 +\n\n                          (chroma_pixels   + chroma_width) * 4;\n\n\n\n\n    if(!(s->buf = av_malloc(bufsize)))\n\n        return AVERROR(ENOMEM);\n\n    s->iv_frame[0].y_w = s->iv_frame[1].y_w = luma_width;\n\n    s->iv_frame[0].y_h = s->iv_frame[1].y_h = luma_height;\n\n    s->iv_frame[0].uv_w = s->iv_frame[1].uv_w = chroma_width;\n\n    s->iv_frame[0].uv_h = s->iv_frame[1].uv_h = chroma_height;\n\n\n\n    s->iv_frame[0].Ybuf = s->buf + luma_width;\n\n    i = luma_pixels + luma_width * 2;\n\n    s->iv_frame[1].Ybuf = s->buf + i;\n\n    i += (luma_pixels + luma_width);\n\n    s->iv_frame[0].Ubuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[1].Ubuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[0].Vbuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[1].Vbuf = s->buf + i;\n\n\n\n    for(i = 1; i <= luma_width; i++)\n\n        s->iv_frame[0].Ybuf[-i] = s->iv_frame[1].Ybuf[-i] =\n\n            s->iv_frame[0].Ubuf[-i] = 0x80;\n\n\n\n    for(i = 1; i <= chroma_width; i++) {\n\n        s->iv_frame[1].Ubuf[-i] = 0x80;\n\n        s->iv_frame[0].Vbuf[-i] = 0x80;\n\n        s->iv_frame[1].Vbuf[-i] = 0x80;\n\n        s->iv_frame[1].Vbuf[chroma_pixels+i-1] = 0x80;\n\n    }\n\n\n\n    return 0;\n\n}","idx":26,"target":1}
{"code":"static int mov_write_minf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    int ret;\n\n\n\n    avio_wb32(pb, 0); \/* size *\/\n\n    ffio_wfourcc(pb, \"minf\");\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        mov_write_vmhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        mov_write_smhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n\n            mov_write_gmhd_tag(pb, track);\n\n        } else {\n\n            mov_write_nmhd_tag(pb);\n\n        }\n\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n\n        mov_write_hmhd_tag(pb);\n\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n\n        mov_write_gmhd_tag(pb, track);\n\n    }\n\n    if (track->mode == MODE_MOV) \/* FIXME: Why do it for MODE_MOV only ? *\/\n\n        mov_write_hdlr_tag(pb, NULL);\n\n    mov_write_dinf_tag(pb);\n\n    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)\n\n        return ret;\n\n    return update_size(pb, pos);\n\n}\n","idx":27,"target":0}
{"code":"int av_packet_ref(AVPacket *dst, AVPacket *src)\n\n{\n\n    int ret;\n\n\n\n    ret = av_packet_copy_props(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!src->buf) {\n\n        ret = packet_alloc(&dst->buf, src->size);\n\n        if (ret < 0)\n\n            goto fail;\n\n        memcpy(dst->buf->data, src->data, src->size);\n\n    } else\n\n        dst->buf = av_buffer_ref(src->buf);\n\n\n\n    dst->size = src->size;\n\n    dst->data = dst->buf->data;\n\n    return 0;\n\nfail:\n\n    av_packet_free_side_data(dst);\n\n    return ret;\n\n}\n","idx":28,"target":0}
{"code":"av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)\n\n{\n\n#if HAVE_ALTIVEC\n\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n\n        return;\n\n\n\n    fdsp->vector_fmul = ff_vector_fmul_altivec;\n\n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;\n\n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;\n\n\n\n    if (!bit_exact) {\n\n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;\n\n    }\n\n#endif\n\n}\n","idx":29,"target":0}
{"code":"static av_cold int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n","idx":31,"target":0}
{"code":"void helper_slbie(CPUPPCState *env, target_ulong addr)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    ppc_slb_t *slb;\n\n\n\n    slb = slb_lookup(cpu, addr);\n\n    if (!slb) {\n\n        return;\n\n    }\n\n\n\n    if (slb->esid & SLB_ESID_V) {\n\n        slb->esid &= ~SLB_ESID_V;\n\n\n\n        \/* XXX: given the fact that segment size is 256 MB or 1TB,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask)\n\n         *      in QEMU, we just invalidate all TLBs\n\n         *\/\n\n        tlb_flush(CPU(cpu), 1);\n\n    }\n\n}\n","idx":33,"target":1}
{"code":"static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr)\n\n{\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n\n\n    \/* MSR:POW cannot be set by any form of rfi *\/\n\n    msr &= ~(1ULL << MSR_POW);\n\n\n\n#if defined(TARGET_PPC64)\n\n    \/* Switching to 32-bit ? Crop the nip *\/\n\n    if (!msr_is_64bit(env, msr)) {\n\n        nip = (uint32_t)nip;\n\n    }\n\n#else\n\n    nip = (uint32_t)nip;\n\n#endif\n\n    \/* XXX: beware: this is false if VLE is supported *\/\n\n    env->nip = nip & ~((target_ulong)0x00000003);\n\n    hreg_store_msr(env, msr, 1);\n\n#if defined(DEBUG_OP)\n\n    cpu_dump_rfi(env->nip, env->msr);\n\n#endif\n\n    \/* No need to raise an exception here,\n\n     * as rfi is always the last insn of a TB\n\n     *\/\n\n    cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n\n\n    \/* Context synchronizing: check if TCG TLB needs flush *\/\n\n    check_tlb_flush(env);\n\n}\n","idx":34,"target":1}
{"code":"static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,\n\n                                int pred_order)\n\n{\n\n    int p, porder, psize;\n\n    int i, part_end;\n\n    int count = 0;\n\n\n\n    \/* subframe header *\/\n\n    count += 8;\n\n\n\n    \/* subframe *\/\n\n    if (sub->type == FLAC_SUBFRAME_CONSTANT) {\n\n        count += sub->obits;\n\n    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {\n\n        count += s->frame.blocksize * sub->obits;\n\n    } else {\n\n        \/* warm-up samples *\/\n\n        count += pred_order * sub->obits;\n\n\n\n        \/* LPC coefficients *\/\n\n        if (sub->type == FLAC_SUBFRAME_LPC)\n\n            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;\n\n\n\n        \/* rice-encoded block *\/\n\n        count += 2;\n\n\n\n        \/* partition order *\/\n\n        porder = sub->rc.porder;\n\n        psize  = s->frame.blocksize >> porder;\n\n        count += 4;\n\n\n\n        \/* residual *\/\n\n        i        = pred_order;\n\n        part_end = psize;\n\n        for (p = 0; p < 1 << porder; p++) {\n\n            int k = sub->rc.params[p];\n\n            count += 4;\n\n            count += rice_count_exact(&sub->residual[i], part_end - i, k);\n\n            i = part_end;\n\n            part_end = FFMIN(s->frame.blocksize, part_end + psize);\n\n        }\n\n    }\n\n\n\n    return count;\n\n}\n","idx":35,"target":1}
{"code":"static void d3d11va_device_uninit(AVHWDeviceContext *hwdev)\n\n{\n\n    AVD3D11VADeviceContext *device_hwctx = hwdev->hwctx;\n\n\n\n    if (device_hwctx->device)\n\n        ID3D11Device_Release(device_hwctx->device);\n\n\n\n    if (device_hwctx->device_context)\n\n        ID3D11DeviceContext_Release(device_hwctx->device_context);\n\n\n\n    if (device_hwctx->video_device)\n\n        ID3D11VideoDevice_Release(device_hwctx->video_device);\n\n\n\n    if (device_hwctx->video_context)\n\n        ID3D11VideoContext_Release(device_hwctx->video_context);\n\n\n\n    if (device_hwctx->lock == d3d11va_default_lock)\n\n        CloseHandle(device_hwctx->lock_ctx);\n\n}\n","idx":36,"target":1}
{"code":"static void test_acpi_asl(test_data *data)\n\n{\n\n    int i;\n\n    AcpiSdtTable *sdt, *exp_sdt;\n\n    test_data exp_data;\n\n    gboolean exp_err, err;\n\n\n\n    memset(&exp_data, 0, sizeof(exp_data));\n\n    exp_data.tables = load_expected_aml(data);\n\n    dump_aml_files(data, false);\n\n    for (i = 0; i < data->tables->len; ++i) {\n\n        GString *asl, *exp_asl;\n\n\n\n        sdt = &g_array_index(data->tables, AcpiSdtTable, i);\n\n        exp_sdt = &g_array_index(exp_data.tables, AcpiSdtTable, i);\n\n\n\n        err = load_asl(data->tables, sdt);\n\n        asl = normalize_asl(sdt->asl);\n\n\n\n        exp_err = load_asl(exp_data.tables, exp_sdt);\n\n        exp_asl = normalize_asl(exp_sdt->asl);\n\n\n\n        \/* TODO: check for warnings *\/\n\n        g_assert(!err || exp_err);\n\n\n\n        if (g_strcmp0(asl->str, exp_asl->str)) {\n\n            uint32_t signature = cpu_to_le32(exp_sdt->header.signature);\n\n            sdt->tmp_files_retain = true;\n\n            exp_sdt->tmp_files_retain = true;\n\n            fprintf(stderr,\n\n                    \"acpi-test: Warning! %.4s mismatch. \"\n\n                    \"Actual [asl:%s, aml:%s], Expected [asl:%s, aml:%s].\\n\",\n\n                    (gchar *)&signature,\n\n                    sdt->asl_file, sdt->aml_file,\n\n                    exp_sdt->asl_file, exp_sdt->aml_file);\n\n        }\n\n        g_string_free(asl, true);\n\n        g_string_free(exp_asl, true);\n\n    }\n\n\n\n    free_test_data(&exp_data);\n\n}\n","idx":38,"target":1}
{"code":"static int parse_picture_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n\n\n    if (buf_size <= 4)\n\n        return -1;\n\n    buf_size -= 4;\n\n\n\n    \/* skip 3 unknown bytes: Object ID (2 bytes), Version Number *\/\n\n    buf += 3;\n\n\n\n    \/* Read the Sequence Description to determine if start of RLE data or appended to previous RLE *\/\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        \/* Additional RLE data *\/\n\n        if (buf_size > ctx->picture.rle_remaining_len)\n\n            return -1;\n\n\n\n        memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);\n\n        ctx->picture.rle_data_len += buf_size;\n\n        ctx->picture.rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return -1;\n\n    buf_size -= 7;\n\n\n\n    \/* Decode rle bitmap length, stored size includes width\/height data *\/\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    \/* Get bitmap dimensions from data *\/\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    \/* Make sure the bitmap is not too large *\/\n\n    if (avctx->width < width || avctx->height < height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->picture.w = width;\n\n    ctx->picture.h = height;\n\n\n\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!ctx->picture.rle)\n\n        return -1;\n\n\n\n    memcpy(ctx->picture.rle, buf, buf_size);\n\n    ctx->picture.rle_data_len = buf_size;\n\n    ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n","idx":40,"target":0}
{"code":"void hmp_info_io_apic(Monitor *mon, const QDict *qdict)\n\n{\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_ioapic_dump_state(mon, qdict);\n\n    } else {\n\n        ioapic_dump_state(mon, qdict);\n\n    }\n\n}\n","idx":41,"target":1}
{"code":"static av_cold int split_init(AVFilterContext *ctx)\n\n{\n\n    SplitContext *s = ctx->priv;\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_outputs; i++) {\n\n        char name[32];\n\n        AVFilterPad pad = { 0 };\n\n\n\n        snprintf(name, sizeof(name), \"output%d\", i);\n\n        pad.type = ctx->filter->inputs[0].type;\n\n        pad.name = av_strdup(name);\n\n        if (!pad.name)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ff_insert_outpad(ctx, i, &pad);\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":42,"target":1}
{"code":"static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; \/* clear head *\/\n\n    \/* put signature *\/\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n","idx":44,"target":0}
{"code":"void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)\n\n{\n\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n\n\n\n    isa_mmio_setup(mr, size);\n\n    memory_region_add_subregion(get_system_memory(), base, mr);\n\n}\n","idx":45,"target":0}
{"code":"static void test_validate_struct_nested(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n\n                           \"'dict1': { 'string1': 'string1', \"\n\n                           \"'dict2': { 'userdef': { 'integer': 42, \"\n\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n","idx":47,"target":0}
{"code":"void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n}\n","idx":48,"target":0}
{"code":"static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)\n\n{\n\n    AVIOContext *in, *out;\n\n    int ret = 0;\n\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n\n        avio_close(in);\n\n        return ret;\n\n    }\n\n    while (size > 0) {\n\n        uint8_t buf[8192];\n\n        int n = FFMIN(size, sizeof(buf));\n\n        n = avio_read(in, buf, n);\n\n        if (n <= 0) {\n\n            ret = AVERROR(EIO);\n\n            break;\n\n        }\n\n        avio_write(out, buf, n);\n\n        size -= n;\n\n    }\n\n    avio_flush(out);\n\n    avio_close(out);\n\n    avio_close(in);\n\n    return ret;\n\n}\n","idx":49,"target":0}
{"code":"static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,\n\n                                VMStateField *field)\n\n{\n\n    uint64_t *v = pv;\n\n    *v = qemu_get_be32(f);\n\n    return 0;\n\n}\n","idx":50,"target":0}
{"code":"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n","idx":51,"target":0}
{"code":"void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n\n\n    if (!dc->hotpluggable) {\n\n        return;\n\n    }\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    if (dev->hotplugged) {\n\n        mdev->is_inserting = true;\n\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n\n    }\n\n}\n","idx":52,"target":0}
{"code":"static void usb_hid_changed(HIDState *hs)\n\n{\n\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n\n\n\n    us->changed = 1;\n\n\n\n    if (us->datain) {\n\n        us->datain(us->datain_opaque);\n\n    }\n\n\n\n    usb_wakeup(&us->dev);\n\n}\n","idx":54,"target":0}
{"code":"static int nbd_errno_to_system_errno(int err)\n\n{\n\n    switch (err) {\n\n    case NBD_SUCCESS:\n\n        return 0;\n\n    case NBD_EPERM:\n\n        return EPERM;\n\n    case NBD_EIO:\n\n        return EIO;\n\n    case NBD_ENOMEM:\n\n        return ENOMEM;\n\n    case NBD_ENOSPC:\n\n        return ENOSPC;\n\n    default:\n\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n\n        \/* fallthrough *\/\n\n    case NBD_EINVAL:\n\n        return EINVAL;\n\n    }\n\n}\n","idx":55,"target":0}
{"code":"static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, uint16_t **refcount_table,\n\n                               int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    *refcount_table = g_try_new0(uint16_t, *nb_clusters);\n\n    if (*nb_clusters && *refcount_table == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    \/* header *\/\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* current L1 table *\/\n\n    ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* snapshots *\/\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* refcount data *\/\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n\n}\n","idx":56,"target":0}
{"code":"void aio_context_setup(AioContext *ctx)\n\n{\n\n}\n","idx":57,"target":0}
{"code":"static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    LM32TimerState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SR:\n\n    case R_CR:\n\n    case R_PERIOD:\n\n        r = s->regs[addr];\n\n        break;\n\n    case R_SNAPSHOT:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_lm32_timer_memory_read(addr << 2, r);\n\n    return r;\n\n}\n","idx":58,"target":0}
{"code":"void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIRequest *sreq = req->sreq;\n\n    if (scsi_req_enqueue(sreq)) {\n\n        scsi_req_continue(sreq);\n\n    }\n\n    bdrv_io_unplug(sreq->dev->conf.bs);\n\n    scsi_req_unref(sreq);\n\n}\n","idx":59,"target":0}
{"code":"static int truespeech_decode_frame(AVCodecContext *avctx,\n\n                void *data, int *data_size,\n\n                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TSContext *c = avctx->priv_data;\n\n\n\n    int i, j;\n\n    short *samples = data;\n\n    int consumed = 0;\n\n    int16_t out_buf[240];\n\n    int iterations;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 32) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Too small input buffer (%d bytes), need at least 32 bytes\\n\", buf_size);\n\n        return -1;\n\n    }\n\n    iterations = FFMIN(buf_size \/ 32, *data_size \/ 480);\n\n    for(j = 0; j < iterations; j++) {\n\n        truespeech_read_frame(c, buf + consumed);\n\n        consumed += 32;\n\n\n\n        truespeech_correlate_filter(c);\n\n        truespeech_filters_merge(c);\n\n\n\n        memset(out_buf, 0, 240 * 2);\n\n        for(i = 0; i < 4; i++) {\n\n            truespeech_apply_twopoint_filter(c, i);\n\n            truespeech_place_pulses(c, out_buf + i * 60, i);\n\n            truespeech_update_filters(c, out_buf + i * 60, i);\n\n            truespeech_synth(c, out_buf + i * 60, i);\n\n        }\n\n\n\n        truespeech_save_prevvec(c);\n\n\n\n        \/* finally output decoded frame *\/\n\n        for(i = 0; i < 240; i++)\n\n            *samples++ = out_buf[i];\n\n\n\n    }\n\n\n\n    *data_size = consumed * 15;\n\n\n\n    return consumed;\n\n}\n","idx":61,"target":0}
{"code":"static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (blit_is_unsafe(s, false))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n","idx":63,"target":0}
{"code":"static void listener_add_address_space(MemoryListener *listener,\n\n                                       AddressSpace *as)\n\n{\n\n    FlatView *view;\n\n    FlatRange *fr;\n\n\n\n    if (listener->address_space_filter\n\n        && listener->address_space_filter != as) {\n\n        return;\n\n    }\n\n\n\n    if (global_dirty_log) {\n\n        if (listener->log_global_start) {\n\n            listener->log_global_start(listener);\n\n        }\n\n    }\n\n\n\n    view = as->current_map;\n\n    FOR_EACH_FLAT_RANGE(fr, view) {\n\n        MemoryRegionSection section = {\n\n            .mr = fr->mr,\n\n            .address_space = as,\n\n            .offset_within_region = fr->offset_in_region,\n\n            .size = fr->addr.size,\n\n            .offset_within_address_space = int128_get64(fr->addr.start),\n\n            .readonly = fr->readonly,\n\n        };\n\n        if (listener->region_add) {\n\n            listener->region_add(listener, &section);\n\n        }\n\n    }\n\n}\n","idx":65,"target":0}
{"code":"long do_sigreturn(CPUM68KState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr = env->aregs[7] - 4;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int d0, i;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    \/* set blocked signals *\/\n\n\n\n    if (__get_user(target_set.sig[0], &frame->sc.sc_mask))\n\n        goto badframe;\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    \/* restore registers *\/\n\n\n\n    if (restore_sigcontext(env, &frame->sc, &d0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return d0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n","idx":66,"target":0}
{"code":"static int tcg_match_cmpi(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        \/* The COMPARE IMMEDIATE instruction is available.  *\/\n\n        if (type == TCG_TYPE_I32) {\n\n            \/* We have a 32-bit immediate and can compare against anything.  *\/\n\n            return 1;\n\n        } else {\n\n            \/* ??? We have no insight here into whether the comparison is\n\n               signed or unsigned.  The COMPARE IMMEDIATE insn uses a 32-bit\n\n               signed immediate, and the COMPARE LOGICAL IMMEDIATE insn uses\n\n               a 32-bit unsigned immediate.  If we were to use the (semi)\n\n               obvious \"val == (int32_t)val\" we would be enabling unsigned\n\n               comparisons vs very large numbers.  The only solution is to\n\n               take the intersection of the ranges.  *\/\n\n            \/* ??? Another possible solution is to simply lie and allow all\n\n               constants here and force the out-of-range values into a temp\n\n               register in tgen_cmp when we have knowledge of the actual\n\n               comparison code in use.  *\/\n\n            return val >= 0 && val <= 0x7fffffff;\n\n        }\n\n    } else {\n\n        \/* Only the LOAD AND TEST instruction is available.  *\/\n\n        return val == 0;\n\n    }\n\n}\n","idx":67,"target":0}
{"code":"static inline bool vhost_needs_vring_endian(VirtIODevice *vdev)\n\n{\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        return false;\n\n    }\n\n#ifdef TARGET_IS_BIENDIAN\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    return !virtio_is_big_endian(vdev);\n\n#else\n\n    return virtio_is_big_endian(vdev);\n\n#endif\n\n#else\n\n    return false;\n\n#endif\n\n}\n","idx":68,"target":0}
{"code":"int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n\n{\n\n    QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    QXLCursor *cursor;\n\n    QEMUCursor *c;\n\n\n\n    if (!cmd) {\n\n        return 1;\n\n    }\n\n\n\n    if (!dpy_cursor_define_supported(qxl->vga.con)) {\n\n        return 0;\n\n    }\n\n\n\n    if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n\n        fprintf(stderr, \"%s\", __FUNCTION__);\n\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n\n        fprintf(stderr, \"\\n\");\n\n    }\n\n    switch (cmd->type) {\n\n    case QXL_CURSOR_SET:\n\n        cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n\n        if (!cursor) {\n\n            return 1;\n\n        }\n\n        c = qxl_cursor(qxl, cursor, ext->group_id);\n\n        if (c == NULL) {\n\n            c = cursor_builtin_left_ptr();\n\n        }\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        if (qxl->ssd.cursor) {\n\n            cursor_put(qxl->ssd.cursor);\n\n        }\n\n        qxl->ssd.cursor = c;\n\n        qxl->ssd.mouse_x = cmd->u.set.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.set.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    case QXL_CURSOR_MOVE:\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        qxl->ssd.mouse_x = cmd->u.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n","idx":69,"target":0}
{"code":"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n","idx":70,"target":0}
{"code":"void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    char buf[256];\n\n    char *p;\n\n    target_ulong addr;\n\n    uint64_t i64;\n\n    GDBState *s;\n\n\n\n    s = gdbserver_state;\n\n    if (!s)\n\n        return;\n\n    gdb_current_syscall_cb = cb;\n\n    s->state = RS_SYSCALL;\n\n#ifndef CONFIG_USER_ONLY\n\n    vm_stop(EXCP_DEBUG);\n\n#endif\n\n    s->state = RS_IDLE;\n\n    va_start(va, fmt);\n\n    p = buf;\n\n    *(p++) = 'F';\n\n    while (*fmt) {\n\n        if (*fmt == '%') {\n\n            fmt++;\n\n            switch (*fmt++) {\n\n            case 'x':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx, addr);\n\n                break;\n\n            case 'l':\n\n                if (*(fmt++) != 'x')\n\n                    goto bad_format;\n\n                i64 = va_arg(va, uint64_t);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, \"%\" PRIx64, i64);\n\n                break;\n\n            case 's':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx \"\/%x\",\n\n                              addr, va_arg(va, int));\n\n                break;\n\n            default:\n\n            bad_format:\n\n                fprintf(stderr, \"gdbstub: Bad syscall format string '%s'\\n\",\n\n                        fmt - 1);\n\n                break;\n\n            }\n\n        } else {\n\n            *(p++) = *(fmt++);\n\n        }\n\n    }\n\n    *p = 0;\n\n    va_end(va);\n\n    put_packet(s, buf);\n\n#ifdef CONFIG_USER_ONLY\n\n    gdb_handlesig(s->c_cpu, 0);\n\n#else\n\n    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);\n\n#endif\n\n}\n","idx":71,"target":0}
{"code":"static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwl.base = base;\n\n    omap_pwl_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn,\n\n                    omap_pwl_writefn, s);\n\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n}\n","idx":73,"target":0}
{"code":"static void virt_acpi_build_update(void *build_opaque)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    \/* No state to update or already patched? Nothing to do. *\/\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = true;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    virt_acpi_build(build_state->guest_info, &tables);\n\n\n\n    acpi_ram_update(build_state->table_mr, tables.table_data);\n\n    acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n\n    acpi_ram_update(build_state->linker_mr, tables.linker);\n\n\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n","idx":74,"target":0}
{"code":"static void uart_rx_reset(UartState *s)\n\n{\n\n    s->rx_wpos = 0;\n\n    s->rx_count = 0;\n\n    qemu_chr_accept_input(s->chr);\n\n\n\n    s->r[R_SR] |= UART_SR_INTR_REMPTY;\n\n    s->r[R_SR] &= ~UART_SR_INTR_RFUL;\n\n}\n","idx":76,"target":0}
{"code":"static int rndis_set_response(USBNetState *s,\n\n                rndis_set_msg_type *buf, unsigned int length)\n\n{\n\n    rndis_set_cmplt_type *resp =\n\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n\n    uint32_t bufoffs, buflen;\n\n    int ret;\n\n\n\n    if (!resp)\n\n        return USB_RET_STALL;\n\n\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n\n    if (bufoffs + buflen > length)\n\n        return USB_RET_STALL;\n\n\n\n    ret = ndis_set(s, le32_to_cpu(buf->OID),\n\n                    bufoffs + (uint8_t *) buf, buflen);\n\n    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);\n\n    resp->RequestID = buf->RequestID; \/* Still LE in msg buffer *\/\n\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n\n    if (ret < 0) {\n\n        \/* OID not supported *\/\n\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\n        return 0;\n\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\n\n    return 0;\n\n}\n","idx":77,"target":1}
{"code":"SwsContext *sws_alloc_context(void)\n\n{\n\n    SwsContext *c = av_mallocz(sizeof(SwsContext));\n\n\n\n    c->av_class = &sws_context_class;\n\n    av_opt_set_defaults(c);\n\n\n\n    return c;\n\n}\n","idx":78,"target":1}
{"code":"static i2c_interface *musicpal_audio_init(qemu_irq irq)\n\n{\n\n    AudioState *audio;\n\n    musicpal_audio_state *s;\n\n    i2c_interface *i2c;\n\n    int iomemtype;\n\n\n\n    audio = AUD_init();\n\n    if (!audio) {\n\n        AUD_log(audio_name, \"No audio state\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(musicpal_audio_state));\n\n    s->irq = irq;\n\n\n\n    i2c = qemu_mallocz(sizeof(i2c_interface));\n\n    i2c->bus = i2c_init_bus();\n\n    i2c->current_addr = -1;\n\n\n\n    s->wm = wm8750_init(i2c->bus, audio);\n\n    if (!s->wm)\n\n        return NULL;\n\n    i2c_set_slave_address(s->wm, MP_WM_ADDR);\n\n    wm8750_data_req_set(s->wm, audio_callback, s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, musicpal_audio_readfn,\n\n                       musicpal_audio_writefn, s);\n\n    cpu_register_physical_memory(MP_AUDIO_BASE, MP_AUDIO_SIZE, iomemtype);\n\n\n\n    qemu_register_reset(musicpal_audio_reset, s);\n\n\n\n    return i2c;\n\n}\n","idx":79,"target":1}
{"code":"void bdrv_error_action(BlockDriverState *bs, BlockErrorAction action,\n\n                       bool is_read, int error)\n\n{\n\n    assert(error >= 0);\n\n    bdrv_emit_qmp_error_event(bs, QEVENT_BLOCK_IO_ERROR, action, is_read);\n\n    if (action == BDRV_ACTION_STOP) {\n\n        vm_stop(RUN_STATE_IO_ERROR);\n\n        bdrv_iostatus_set_err(bs, error);\n\n    }\n\n}\n","idx":80,"target":1}
{"code":"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size,\n\n                     uint64_t max_mem)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    \/* allocate RAM *\/\n\n    if ((uint64_t)RAM_size > max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size \/ (1024 * 1024)),\n\n                (unsigned int)(max_mem \/ (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n","idx":81,"target":1}
{"code":"int xics_alloc_block(XICSState *icp, int src, int num, bool lsi, bool align)\n\n{\n\n    int i, first = -1;\n\n    ICSState *ics = &icp->ics[src];\n\n\n\n    assert(src == 0);\n\n    \/*\n\n     * MSIMesage::data is used for storing VIRQ so\n\n     * it has to be aligned to num to support multiple\n\n     * MSI vectors. MSI-X is not affected by this.\n\n     * The hint is used for the first IRQ, the rest should\n\n     * be allocated continuously.\n\n     *\/\n\n    if (align) {\n\n        assert((num == 1) || (num == 2) || (num == 4) ||\n\n               (num == 8) || (num == 16) || (num == 32));\n\n        first = ics_find_free_block(ics, num, num);\n\n    } else {\n\n        first = ics_find_free_block(ics, num, 1);\n\n    }\n\n\n\n    if (first >= 0) {\n\n        for (i = first; i < first + num; ++i) {\n\n            ics_set_irq_type(ics, i, lsi);\n\n        }\n\n    }\n\n    first += ics->offset;\n\n\n\n    trace_xics_alloc_block(src, first, num, lsi, align);\n\n\n\n    return first;\n\n}\n","idx":82,"target":1}
{"code":"static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    \/* No data transfer may already be in progress *\/\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE \/ 512)\n\n        n = SCSI_DMA_BUF_SIZE \/ 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n","idx":83,"target":1}
{"code":"void object_property_get_uint16List(Object *obj, const char *name,\n\n                                    uint16List **list, Error **errp)\n\n{\n\n    StringOutputVisitor *ov;\n\n    StringInputVisitor *iv;\n\n\n\n    ov = string_output_visitor_new(false);\n\n    object_property_get(obj, string_output_get_visitor(ov),\n\n                        name, errp);\n\n    iv = string_input_visitor_new(string_output_get_string(ov));\n\n    visit_type_uint16List(string_input_get_visitor(iv),\n\n                          list, NULL, errp);\n\n    string_output_visitor_cleanup(ov);\n\n    string_input_visitor_cleanup(iv);\n\n}\n","idx":85,"target":1}
{"code":"static int raw_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int fd;\n\n    int64_t total_size = 0;\n\n\n\n    \/* Read out options *\/\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            total_size = options->value.n \/ 512;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,\n\n              0644);\n\n    if (fd < 0)\n\n        return -EIO;\n\n    ftruncate(fd, total_size * 512);\n\n    close(fd);\n\n    return 0;\n\n}\n","idx":86,"target":1}
{"code":"static inline void RENAME(rgb24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)\n\n{\n\n    int i;\n\n    assert(src1==src2);\n\n    for (i=0; i<width; i++) {\n\n        int r= src1[6*i + 0] + src1[6*i + 3];\n\n        int g= src1[6*i + 1] + src1[6*i + 4];\n\n        int b= src1[6*i + 2] + src1[6*i + 5];\n\n\n\n        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n    }\n\n}\n","idx":87,"target":1}
{"code":"static void tricore_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    TriCoreCPU *cpu = TRICORE_CPU(obj);\n\n    CPUTriCoreState *env = &cpu->env;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        tricore_tcg_init();\n\n    }\n\n}\n","idx":88,"target":1}
{"code":"void ff_xvmc_init_block(MpegEncContext *s)\n\n{\n\n    struct xvmc_render_state *render = (struct xvmc_render_state*)s->current_picture.data[2];\n\n    assert(render);\n\n    if (!render || render->magic != AV_XVMC_RENDER_MAGIC) {\n\n        assert(0);\n\n        return; \/\/ make sure that this is a render packet\n\n    }\n\n    s->block = (DCTELEM *)(render->data_blocks + render->next_free_data_block_num * 64);\n\n}\n","idx":90,"target":1}
{"code":"void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n","idx":91,"target":1}
{"code":"static uint32_t ecc_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    ECCState *s = opaque;\n\n    uint32_t ret = 0;\n\n\n\n    switch (addr & ECC_ADDR_MASK) {\n\n    case ECC_MER:\n\n        ret = s->regs[0];\n\n        DPRINTF(\"Read memory enable %08x\\n\", ret);\n\n        break;\n\n    case ECC_MDR:\n\n        ret = s->regs[1];\n\n        DPRINTF(\"Read memory delay %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFSR:\n\n        ret = s->regs[2];\n\n        DPRINTF(\"Read memory fault status %08x\\n\", ret);\n\n        break;\n\n    case ECC_VCR:\n\n        ret = s->regs[3];\n\n        DPRINTF(\"Read slot configuration %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFAR0:\n\n        ret = s->regs[4];\n\n        DPRINTF(\"Read memory fault address 0 %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFAR1:\n\n        ret = s->regs[5];\n\n        DPRINTF(\"Read memory fault address 1 %08x\\n\", ret);\n\n        break;\n\n    case ECC_DR:\n\n        ret = s->regs[6];\n\n        DPRINTF(\"Read diagnostic %08x\\n\", ret);\n\n        break;\n\n    case ECC_ECR0:\n\n        ret = s->regs[7];\n\n        DPRINTF(\"Read event count 1 %08x\\n\", ret);\n\n        break;\n\n    case ECC_ECR1:\n\n        ret = s->regs[7];\n\n        DPRINTF(\"Read event count 2 %08x\\n\", ret);\n\n        break;\n\n    }\n\n    return ret;\n\n}\n","idx":92,"target":1}
{"code":"static int mp_decode_frame(MPADecodeContext *s, \n\n                           short *samples)\n\n{\n\n    int i, nb_frames, ch;\n\n    short *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, s->inbuf + HEADER_SIZE, \n\n                  s->inbuf_ptr - s->inbuf - HEADER_SIZE);\n\n    \n\n    \/* skip error protection field *\/\n\n    if (s->error_protection)\n\n        get_bits(&s->gb, 16);\n\n\n\n    dprintf(\"frame %d:\\n\", s->frame_count);\n\n    switch(s->layer) {\n\n    case 1:\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n        break;\n\n    }\n\n#if defined(DEBUG)\n\n    for(i=0;i<nb_frames;i++) {\n\n        for(ch=0;ch<s->nb_channels;ch++) {\n\n            int j;\n\n            printf(\"%d-%d:\", i, ch);\n\n            for(j=0;j<SBLIMIT;j++)\n\n                printf(\" %0.6f\", (double)s->sb_samples[ch][i][j] \/ FRAC_ONE);\n\n            printf(\"\\n\");\n\n        }\n\n    }\n\n#endif\n\n    \/* apply the synthesis filter *\/\n\n    for(ch=0;ch<s->nb_channels;ch++) {\n\n        samples_ptr = samples + ch;\n\n        for(i=0;i<nb_frames;i++) {\n\n            synth_filter(s, ch, samples_ptr, s->nb_channels,\n\n                         s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * s->nb_channels;\n\n        }\n\n    }\n\n#ifdef DEBUG\n\n    s->frame_count++;        \n\n#endif\n\n    return nb_frames * 32 * sizeof(short) * s->nb_channels;\n\n}\n","idx":94,"target":0}
{"code":"static int write_trailer(AVFormatContext *s)\n\n{\n\n    WVMuxContext *wc = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n\n\n    ff_ape_write(s);\n\n\n\n    if (pb->seekable) {\n\n        avio_seek(pb, 12, SEEK_SET);\n\n        avio_wl32(pb, wc->duration);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":96,"target":0}
{"code":"void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    \/* virtio-1 compliant devices cannot change the alignment *\/\n\n    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    \/* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     *\/\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n","idx":97,"target":0}
{"code":"int qcrypto_init(Error **errp)\n\n{\n\n    int ret;\n\n    ret = gnutls_global_init();\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Unable to initialize GNUTLS library: %s\",\n\n                   gnutls_strerror(ret));\n\n        return -1;\n\n    }\n\n#ifdef DEBUG_GNUTLS\n\n    gnutls_global_set_log_level(10);\n\n    gnutls_global_set_log_function(qcrypto_gnutls_log);\n\n#endif\n\n\n\n#ifdef CONFIG_GNUTLS_GCRYPT\n\n    if (!gcry_check_version(GCRYPT_VERSION)) {\n\n        error_setg(errp, \"Unable to initialize gcrypt\");\n\n        return -1;\n\n    }\n\n#ifdef QCRYPTO_INIT_GCRYPT_THREADS\n\n    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);\n\n#endif \/* QCRYPTO_INIT_GCRYPT_THREADS *\/\n\n    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n\n#endif\n\n\n\n    return 0;\n\n}\n","idx":99,"target":0}
{"code":"static void read_vec_element_i32(DisasContext *s, TCGv_i32 tcg_dest, int srcidx,\n\n                                 int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_8|MO_SIGN:\n\n        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16|MO_SIGN:\n\n        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n    case MO_32|MO_SIGN:\n\n        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n","idx":100,"target":0}
{"code":"static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,\n\n                            hwaddr desc_pa, int i)\n\n{\n\n    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc),\n\n                       MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));\n\n    virtio_tswap64s(vdev, &desc->addr);\n\n    virtio_tswap32s(vdev, &desc->len);\n\n    virtio_tswap16s(vdev, &desc->flags);\n\n    virtio_tswap16s(vdev, &desc->next);\n\n}\n","idx":101,"target":0}
{"code":"static AddressSpace *q35_host_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    IntelIOMMUState *s = opaque;\n\n    VTDAddressSpace **pvtd_as;\n\n    int bus_num = pci_bus_num(bus);\n\n\n\n    assert(0 <= bus_num && bus_num <= VTD_PCI_BUS_MAX);\n\n    assert(0 <= devfn && devfn <= VTD_PCI_DEVFN_MAX);\n\n\n\n    pvtd_as = s->address_spaces[bus_num];\n\n    if (!pvtd_as) {\n\n        \/* No corresponding free() *\/\n\n        pvtd_as = g_malloc0(sizeof(VTDAddressSpace *) * VTD_PCI_DEVFN_MAX);\n\n        s->address_spaces[bus_num] = pvtd_as;\n\n    }\n\n    if (!pvtd_as[devfn]) {\n\n        pvtd_as[devfn] = g_malloc0(sizeof(VTDAddressSpace));\n\n\n\n        pvtd_as[devfn]->bus_num = (uint8_t)bus_num;\n\n        pvtd_as[devfn]->devfn = (uint8_t)devfn;\n\n        pvtd_as[devfn]->iommu_state = s;\n\n        pvtd_as[devfn]->context_cache_entry.context_cache_gen = 0;\n\n        memory_region_init_iommu(&pvtd_as[devfn]->iommu, OBJECT(s),\n\n                                 &s->iommu_ops, \"intel_iommu\", UINT64_MAX);\n\n        address_space_init(&pvtd_as[devfn]->as,\n\n                           &pvtd_as[devfn]->iommu, \"intel_iommu\");\n\n    }\n\n    return &pvtd_as[devfn]->as;\n\n}\n","idx":102,"target":0}
{"code":"static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent *extent,\n\n                                                   int64_t offset)\n\n{\n\n    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;\n\n    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    extent_begin_offset =\n\n        (extent->end_sector - extent->sectors) * BDRV_SECTOR_SIZE;\n\n    extent_relative_offset = offset - extent_begin_offset;\n\n    offset_in_cluster = extent_relative_offset % cluster_size;\n\n\n\n    return offset_in_cluster;\n\n}\n","idx":103,"target":0}
{"code":"static unsigned int dec_move_pr(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"move $p%u, $r%u\\n\", dc->op1, dc->op2));\n\n\tcris_cc_mask(dc, 0);\n\n\n\n\tif (dc->op2 == PR_CCS)\n\n\t\tcris_evaluate_flags(dc);\n\n\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_gen_mov_TN_preg(t0, dc->op2);\n\n\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t cpu_R[dc->op1], cpu_R[dc->op1], t0, preg_sizes[dc->op2]);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n","idx":104,"target":0}
{"code":"static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = virtio_balloon_init_pci;\n\n    k->exit = virtio_balloon_exit_pci;\n\n    k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;\n\n    k->device_id = PCI_DEVICE_ID_VIRTIO_BALLOON;\n\n    k->revision = VIRTIO_PCI_ABI_VERSION;\n\n    k->class_id = PCI_CLASS_MEMORY_RAM;\n\n    dc->alias = \"virtio-balloon\";\n\n    dc->reset = virtio_pci_reset;\n\n    dc->props = virtio_balloon_properties;\n\n}\n","idx":105,"target":0}
{"code":"static int fetch_active_ports_list(QEMUFile *f,\n\n                                   VirtIOSerial *s, uint32_t nr_active_ports)\n\n{\n\n    uint32_t i;\n\n\n\n    s->post_load = g_malloc0(sizeof(*s->post_load));\n\n    s->post_load->nr_active_ports = nr_active_ports;\n\n    s->post_load->connected =\n\n        g_malloc0(sizeof(*s->post_load->connected) * nr_active_ports);\n\n\n\n    s->post_load->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                                            virtio_serial_post_load_timer_cb,\n\n                                            s);\n\n\n\n    \/* Items in struct VirtIOSerialPort *\/\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        VirtIOSerialPort *port;\n\n        uint32_t elem_popped;\n\n        uint32_t id;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        s->post_load->connected[i].port = port;\n\n        s->post_load->connected[i].host_connected = qemu_get_byte(f);\n\n\n\n        qemu_get_be32s(f, &elem_popped);\n\n        if (elem_popped) {\n\n            qemu_get_be32s(f, &port->iov_idx);\n\n            qemu_get_be64s(f, &port->iov_offset);\n\n\n\n            port->elem =\n\n                qemu_get_virtqueue_element(f, sizeof(VirtQueueElement));\n\n\n\n            \/*\n\n             *  Port was throttled on source machine.  Let's\n\n             *  unthrottle it here so data starts flowing again.\n\n             *\/\n\n            virtio_serial_throttle_port(port, false);\n\n        }\n\n    }\n\n    timer_mod(s->post_load->timer, 1);\n\n    return 0;\n\n}\n","idx":106,"target":0}
{"code":"void HELPER(ucf64_cmps)(float32 a, float32 b, uint32_t c, CPUUniCore32State *env)\n\n{\n\n    int flag;\n\n    flag = float32_compare_quiet(a, b, &env->ucf64.fp_status);\n\n    env->CF = 0;\n\n    switch (c & 0x7) {\n\n    case 0: \/* F *\/\n\n        break;\n\n    case 1: \/* UN *\/\n\n        if (flag == 2) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 2: \/* EQ *\/\n\n        if (flag == 0) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 3: \/* UEQ *\/\n\n        if ((flag == 0) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 4: \/* OLT *\/\n\n        if (flag == -1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 5: \/* ULT *\/\n\n        if ((flag == -1) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 6: \/* OLE *\/\n\n        if ((flag == -1) || (flag == 0)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 7: \/* ULE *\/\n\n        if (flag != 1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    }\n\n    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)\n\n                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);\n\n}\n","idx":107,"target":0}
{"code":"aio_write_f(int argc, char **argv)\n\n{\n\n\tchar *p;\n\n\tint count = 0;\n\n\tint nr_iov, i, c;\n\n\tint pattern = 0xcd;\n\n\tstruct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n\tBlockDriverAIOCB *acb;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tctx->Cflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tctx->qflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&aio_write_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (count & 0x1ff) {\n\n\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\tcount);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tfor (i = optind; i < argc; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tqemu_iovec_init(&ctx->qiov, nr_iov);\n\n\tctx->buf = p = qemu_io_alloc(count, pattern);\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\",\n\n\t\t\t\targv[optind]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\n\n\t\tqemu_iovec_add(&ctx->qiov, p, len);\n\n\t\tp += len;\n\n\t\toptind++;\n\n\t}\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n","idx":108,"target":0}
{"code":"static void RENAME(yuv2yuyv422_2)(SwsContext *c, const uint16_t *buf0,\n\n                                  const uint16_t *buf1, const uint16_t *ubuf0,\n\n                                  const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                                  const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                                  const uint16_t *abuf1, uint8_t *dest,\n\n                                  int dstW, int yalpha, int uvalpha, int y)\n\n{\n\n    \/\/Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(\n\n    __asm__ volatile(\n\n        \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n        \"mov %4, %%\"REG_b\"                        \\n\\t\"\n\n        \"push %%\"REG_BP\"                        \\n\\t\"\n\n        YSCALEYUV2PACKED(%%REGBP, %5)\n\n        WRITEYUY2(%%REGb, 8280(%5), %%REGBP)\n\n        \"pop %%\"REG_BP\"                         \\n\\t\"\n\n        \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n        :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n           \"a\" (&c->redDither)\n\n    );\n\n}\n","idx":109,"target":0}
{"code":"static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    bool start = req->cmd.buf[4] & 1;\n\n    bool loej = req->cmd.buf[4] & 2; \/* load on start, eject on !start *\/\n\n\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n\n        if (!start && !s->tray_open && s->tray_locked) {\n\n            scsi_check_condition(r,\n\n                                 bdrv_is_inserted(s->qdev.conf.bs)\n\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n\n            return -1;\n\n        }\n\n\n\n        if (s->tray_open != !start) {\n\n            bdrv_eject(s->qdev.conf.bs, !start);\n\n            s->tray_open = !start;\n\n        }\n\n    }\n\n    return 0;\n\n}\n","idx":110,"target":0}
{"code":"static void ecc_mem_writew(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    printf(\"ECC: Unsupported write 0x\" TARGET_FMT_plx \" %04x\\n\",\n\n           addr, val & 0xffff);\n\n}\n","idx":111,"target":0}
{"code":"int kvm_arch_debug(struct kvm_debug_exit_arch *arch_info)\n\n{\n\n    int handle = 0;\n\n    int n;\n\n\n\n    if (arch_info->exception == 1) {\n\n        if (arch_info->dr6 & (1 << 14)) {\n\n            if (cpu_single_env->singlestep_enabled)\n\n                handle = 1;\n\n        } else {\n\n            for (n = 0; n < 4; n++)\n\n                if (arch_info->dr6 & (1 << n))\n\n                    switch ((arch_info->dr7 >> (16 + n*4)) & 0x3) {\n\n                    case 0x0:\n\n                        handle = 1;\n\n                        break;\n\n                    case 0x1:\n\n                        handle = 1;\n\n                        cpu_single_env->watchpoint_hit = &hw_watchpoint;\n\n                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;\n\n                        hw_watchpoint.flags = BP_MEM_WRITE;\n\n                        break;\n\n                    case 0x3:\n\n                        handle = 1;\n\n                        cpu_single_env->watchpoint_hit = &hw_watchpoint;\n\n                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;\n\n                        hw_watchpoint.flags = BP_MEM_ACCESS;\n\n                        break;\n\n                    }\n\n        }\n\n    } else if (kvm_find_sw_breakpoint(cpu_single_env, arch_info->pc))\n\n        handle = 1;\n\n\n\n    if (!handle) {\n\n        cpu_synchronize_state(cpu_single_env);\n\n        assert(cpu_single_env->exception_injected == -1);\n\n\n\n        cpu_single_env->exception_injected = arch_info->exception;\n\n        cpu_single_env->has_error_code = 0;\n\n    }\n\n\n\n    return handle;\n\n}\n","idx":112,"target":0}
{"code":"static void qemu_chr_parse_stdio(QemuOpts *opts, ChardevBackend *backend,\n\n                                 Error **errp)\n\n{\n\n    ChardevStdio *stdio;\n\n\n\n    stdio = backend->u.stdio = g_new0(ChardevStdio, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevStdio_base(stdio));\n\n    stdio->has_signal = true;\n\n    stdio->signal = qemu_opt_get_bool(opts, \"signal\", true);\n\n}\n","idx":113,"target":0}
{"code":"static void mirror_complete(BlockJob *job, Error **errp)\n\n{\n\n    MirrorBlockJob *s = container_of(job, MirrorBlockJob, common);\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    ret = bdrv_open_backing_file(s->target, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (!s->synced) {\n\n        error_setg(errp, QERR_BLOCK_JOB_NOT_READY,\n\n                   bdrv_get_device_name(job->bs));\n\n        return;\n\n    }\n\n\n\n    \/* check the target bs is not blocked and block all operations on it *\/\n\n    if (s->replaces) {\n\n        AioContext *replace_aio_context;\n\n\n\n        s->to_replace = check_to_replace_node(s->replaces, &local_err);\n\n        if (!s->to_replace) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n\n\n        replace_aio_context = bdrv_get_aio_context(s->to_replace);\n\n        aio_context_acquire(replace_aio_context);\n\n\n\n        error_setg(&s->replace_blocker,\n\n                   \"block device is in use by block-job-complete\");\n\n        bdrv_op_block_all(s->to_replace, s->replace_blocker);\n\n        bdrv_ref(s->to_replace);\n\n\n\n        aio_context_release(replace_aio_context);\n\n    }\n\n\n\n    s->should_complete = true;\n\n    block_job_enter(&s->common);\n\n}\n","idx":114,"target":0}
{"code":"static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n\n\n    scsi_target_alloc_buf(&r->req, SCSI_INQUIRY_LEN);\n\n\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        \/* Command support data - optional, not implemented *\/\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        \/* Vital product data *\/\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; \/* this page *\/\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: \/* Supported page codes, mandatory *\/\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; \/* list of supported pages (this page) *\/\n\n            r->buf[pages] = r->len - pages - 1; \/* number of pages *\/\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        \/* done with EVPD *\/\n\n        assert(r->len < r->buf_len);\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    \/* Standard INQUIRY data *\/\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    \/* PAGE CODE == 0 *\/\n\n    r->len = MIN(r->req.cmd.xfer, SCSI_INQUIRY_LEN);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; \/* Version *\/\n\n        r->buf[3] = 2 | 0x10; \/* HiSup, response data format *\/\n\n        r->buf[4] = r->len - 5; \/* Additional Length = (Len - 1) - 4 *\/\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); \/* Sync, TCQ.  *\/\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n","idx":115,"target":0}
{"code":"void OPPROTO op_movl_npc_T0(void)\n\n{\n\n    env->npc = T0;\n\n}\n","idx":116,"target":0}
{"code":"int ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec)\n\n{\n\n    _Bool exp = 0;\n\n    if (codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || !codec->init)\n\n        return 0;\n\n\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n\n\n    if (atomic_fetch_add(&entangled_thread_counter, 1)) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Insufficient thread locking. At least %d threads are \"\n\n               \"calling avcodec_open2() at the same time right now.\\n\",\n\n               atomic_load(&entangled_thread_counter));\n\n        if (!lockmgr_cb)\n\n            av_log(log_ctx, AV_LOG_ERROR, \"No lock manager is set, please see av_lockmgr_register()\\n\");\n\n        atomic_store(&ff_avcodec_locked, 1);\n\n        ff_unlock_avcodec(codec);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_assert0(atomic_compare_exchange_strong(&ff_avcodec_locked, &exp, 1));\n\n    return 0;\n\n}\n","idx":118,"target":0}
{"code":"void FUNCC(ff_h264_idct_add)(uint8_t *_dst, int16_t *_block, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= av_clip_pixel(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= av_clip_pixel(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= av_clip_pixel(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= av_clip_pixel(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n\n\n    memset(block, 0, 16 * sizeof(dctcoef));\n\n}\n","idx":119,"target":1}
{"code":"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n","idx":121,"target":1}
{"code":"static void put_swf_matrix(ByteIOContext *pb,\n\n                           int a, int b, int c, int d, int tx, int ty)\n\n{\n\n    PutBitContext p;\n\n    uint8_t buf[256];\n\n\n\n    init_put_bits(&p, buf, sizeof(buf));\n\n    \n\n    put_bits(&p, 1, 1); \/* a, d present *\/\n\n    put_bits(&p, 5, 20); \/* nb bits *\/\n\n    put_bits(&p, 20, a);\n\n    put_bits(&p, 20, d);\n\n    \n\n    put_bits(&p, 1, 1); \/* b, c present *\/\n\n    put_bits(&p, 5, 20); \/* nb bits *\/\n\n    put_bits(&p, 20, c);\n\n    put_bits(&p, 20, b);\n\n\n\n    put_bits(&p, 5, 20); \/* nb bits *\/\n\n    put_bits(&p, 20, tx);\n\n    put_bits(&p, 20, ty);\n\n\n\n    flush_put_bits(&p);\n\n    put_buffer(pb, buf, pbBufPtr(&p) - p.buf);\n\n}\n","idx":124,"target":1}
{"code":"static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag)\n\n{\n\n    switch (tag) {\n\n    case 0x1901:\n\n        mxf->packages_count = get_be32(pb);\n\n        if (mxf->packages_count >= UINT_MAX \/ sizeof(UID))\n\n            return -1;\n\n        mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID));\n\n        if (!mxf->packages_refs)\n\n            return -1;\n\n        url_fskip(pb, 4); \/* useless size of objects, always 16 according to specs *\/\n\n        get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID));\n\n        break;\n\n    }\n\n    return 0;\n\n}\n","idx":125,"target":1}
{"code":"int ff_nvdec_start_frame(AVCodecContext *avctx, AVFrame *frame)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n    FrameDecodeData *fdd = (FrameDecodeData*)frame->private_ref->data;\n\n    NVDECFrame *cf = NULL;\n\n    int ret;\n\n\n\n    ctx->bitstream_len = 0;\n\n    ctx->nb_slices     = 0;\n\n\n\n    if (fdd->hwaccel_priv)\n\n        return 0;\n\n\n\n    cf = av_mallocz(sizeof(*cf));\n\n    if (!cf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    cf->decoder_ref = av_buffer_ref(ctx->decoder_ref);\n\n    if (!cf->decoder_ref)\n\n        goto fail;\n\n\n\n    cf->idx_ref = av_buffer_pool_get(ctx->decoder_pool);\n\n    if (!cf->idx_ref) {\n\n        av_log(avctx, AV_LOG_ERROR, \"No decoder surfaces left\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    cf->idx = *(unsigned int*)cf->idx_ref->data;\n\n\n\n    fdd->hwaccel_priv      = cf;\n\n    fdd->hwaccel_priv_free = nvdec_fdd_priv_free;\n\n    fdd->post_process      = nvdec_retrieve_data;\n\n\n\n    return 0;\n\nfail:\n\n    nvdec_fdd_priv_free(cf);\n\n    return ret;\n\n\n\n}\n","idx":126,"target":0}
{"code":"int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n\n{\n\n    void **ptrptr = ptr;\n\n    void *ret;\n\n    if (size <= 0 || nmemb >= INT_MAX \/ size)\n\n        return AVERROR(ENOMEM);\n\n    if (nmemb <= 0) {\n\n        av_freep(ptr);\n\n        return 0;\n\n    }\n\n    ret = av_realloc(*ptrptr, nmemb * size);\n\n    if (!ret) {\n\n        av_freep(ptr);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    *ptrptr = ret;\n\n    return 0;\n\n}\n","idx":127,"target":0}
{"code":"static void sha256_transform(uint32_t *state, const uint8_t buffer[64])\n\n{\n\n    unsigned int i, a, b, c, d, e, f, g, h;\n\n    uint32_t block[64];\n\n    uint32_t T1;\n\n\n\n    a = state[0];\n\n    b = state[1];\n\n    c = state[2];\n\n    d = state[3];\n\n    e = state[4];\n\n    f = state[5];\n\n    g = state[6];\n\n    h = state[7];\n\n#if CONFIG_SMALL\n\n    for (i = 0; i < 64; i++) {\n\n        uint32_t T2;\n\n        if (i < 16)\n\n            T1 = blk0(i);\n\n        else\n\n            T1 = blk(i);\n\n        T1 += h + Sigma1_256(e) + Ch(e, f, g) + K256[i];\n\n        T2 = Sigma0_256(a) + Maj(a, b, c);\n\n        h = g;\n\n        g = f;\n\n        f = e;\n\n        e = d + T1;\n\n        d = c;\n\n        c = b;\n\n        b = a;\n\n        a = T1 + T2;\n\n    }\n\n#else\n\n    for (i = 0; i < 16;) {\n\n        ROUND256_0_TO_15(a, b, c, d, e, f, g, h);\n\n        ROUND256_0_TO_15(h, a, b, c, d, e, f, g);\n\n        ROUND256_0_TO_15(g, h, a, b, c, d, e, f);\n\n        ROUND256_0_TO_15(f, g, h, a, b, c, d, e);\n\n        ROUND256_0_TO_15(e, f, g, h, a, b, c, d);\n\n        ROUND256_0_TO_15(d, e, f, g, h, a, b, c);\n\n        ROUND256_0_TO_15(c, d, e, f, g, h, a, b);\n\n        ROUND256_0_TO_15(b, c, d, e, f, g, h, a);\n\n    }\n\n\n\n    for (; i < 64;) {\n\n        ROUND256_16_TO_63(a, b, c, d, e, f, g, h);\n\n        ROUND256_16_TO_63(h, a, b, c, d, e, f, g);\n\n        ROUND256_16_TO_63(g, h, a, b, c, d, e, f);\n\n        ROUND256_16_TO_63(f, g, h, a, b, c, d, e);\n\n        ROUND256_16_TO_63(e, f, g, h, a, b, c, d);\n\n        ROUND256_16_TO_63(d, e, f, g, h, a, b, c);\n\n        ROUND256_16_TO_63(c, d, e, f, g, h, a, b);\n\n        ROUND256_16_TO_63(b, c, d, e, f, g, h, a);\n\n    }\n\n#endif\n\n    state[0] += a;\n\n    state[1] += b;\n\n    state[2] += c;\n\n    state[3] += d;\n\n    state[4] += e;\n\n    state[5] += f;\n\n    state[6] += g;\n\n    state[7] += h;\n\n}\n","idx":130,"target":0}
{"code":"static void device_finalize(Object *obj)\n\n{\n\n    NamedGPIOList *ngl, *next;\n\n\n\n    DeviceState *dev = DEVICE(obj);\n\n    qemu_opts_del(dev->opts);\n\n\n\n    QLIST_FOREACH_SAFE(ngl, &dev->gpios, node, next) {\n\n        QLIST_REMOVE(ngl, node);\n\n        qemu_free_irqs(ngl->in, ngl->num_in);\n\n        g_free(ngl->name);\n\n        g_free(ngl);\n\n        \/* ngl->out irqs are owned by the other end and should not be freed\n\n         * here\n\n         *\/\n\n    }\n\n}\n","idx":131,"target":1}
{"code":"static void i440fx_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = i440fx_initfn;\n\n    k->config_write = i440fx_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82441;\n\n    k->revision = 0x02;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"Host bridge\";\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_i440fx;\n\n}\n","idx":133,"target":1}
{"code":"target_ulong helper_udiv(target_ulong a, target_ulong b)\n\n{\n\n    uint64_t x0;\n\n    uint32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 \/ x1;\n\n    if (x0 > 0xffffffff) {\n\n        env->cc_src2 = 1;\n\n        return 0xffffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n","idx":135,"target":1}
{"code":"void ff_put_h264_qpel16_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_16w_msa(src - 2,\n\n                            src - (stride * 2) +\n\n                            sizeof(uint8_t), stride, dst, stride, 16);\n\n}\n","idx":137,"target":0}
{"code":"static int xan_huffman_decode(unsigned char *dest, const unsigned char *src,\n\n    int dest_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    init_get_bits(&gb, ptr, 0); \/\/ FIXME: no src size available\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest + 1 > dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":139,"target":1}
{"code":"static int kvm_log_stop(CPUPhysMemoryClient *client,\n\n                        target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n    return kvm_dirty_pages_log_change(phys_addr, size, false);\n\n}\n","idx":140,"target":1}
{"code":"void MPV_common_end(MpegEncContext *s)\n\n{\n\n    int i;\n\n\n\n    if (s->motion_val)\n\n        free(s->motion_val);\n\n    if (s->h263_pred) {\n\n        free(s->dc_val[0]);\n\n        free(s->ac_val[0]);\n\n        free(s->coded_block);\n\n        free(s->mbintra_table);\n\n    }\n\n    if (s->mbskip_table)\n\n        free(s->mbskip_table);\n\n    for(i=0;i<3;i++) {\n\n        free(s->last_picture_base[i]);\n\n        free(s->next_picture_base[i]);\n\n        if (s->has_b_frames)\n\n            free(s->aux_picture_base[i]);\n\n    }\n\n    s->context_initialized = 0;\n\n}\n","idx":141,"target":1}
{"code":"static void blkdebug_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QDict *opts;\n\n    const QDictEntry *e;\n\n    bool force_json = false;\n\n\n\n    for (e = qdict_first(options); e; e = qdict_next(options, e)) {\n\n        if (strcmp(qdict_entry_key(e), \"config\") &&\n\n            strcmp(qdict_entry_key(e), \"x-image\"))\n\n        {\n\n            force_json = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (force_json && !bs->file->bs->full_open_options) {\n\n        \/* The config file cannot be recreated, so creating a plain filename\n\n         * is impossible *\/\n\n        return;\n\n    }\n\n\n\n    if (!force_json && bs->file->bs->exact_filename[0]) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"blkdebug:%s:%s\", s->config_file ?: \"\",\n\n                 bs->file->bs->exact_filename);\n\n    }\n\n\n\n    opts = qdict_new();\n\n    qdict_put_str(opts, \"driver\", \"blkdebug\");\n\n\n\n    QINCREF(bs->file->bs->full_open_options);\n\n    qdict_put(opts, \"image\", bs->file->bs->full_open_options);\n\n\n\n    for (e = qdict_first(options); e; e = qdict_next(options, e)) {\n\n        if (strcmp(qdict_entry_key(e), \"x-image\")) {\n\n            qobject_incref(qdict_entry_value(e));\n\n            qdict_put_obj(opts, qdict_entry_key(e), qdict_entry_value(e));\n\n        }\n\n    }\n\n\n\n    bs->full_open_options = opts;\n\n}\n","idx":142,"target":1}
{"code":"struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n\n    return NULL;\n\n}","idx":143,"target":1}
{"code":"static inline int usb_bt_fifo_dequeue(struct usb_hci_in_fifo_s *fifo,\n\n                USBPacket *p)\n\n{\n\n    int len;\n\n\n\n    if (likely(!fifo->len))\n\n        return USB_RET_STALL;\n\n\n\n    len = MIN(p->len, fifo->fifo[fifo->start].len);\n\n    memcpy(p->data, fifo->fifo[fifo->start].data, len);\n\n    if (len == p->len) {\n\n        fifo->fifo[fifo->start].len -= len;\n\n        fifo->fifo[fifo->start].data += len;\n\n    } else {\n\n        fifo->start ++;\n\n        fifo->start &= CFIFO_LEN_MASK;\n\n        fifo->len --;\n\n    }\n\n\n\n    fifo->dstart += len;\n\n    fifo->dlen -= len;\n\n    if (fifo->dstart >= fifo->dsize) {\n\n        fifo->dstart = 0;\n\n        fifo->dsize = DFIFO_LEN_MASK + 1;\n\n    }\n\n\n\n    return len;\n\n}\n","idx":144,"target":1}
{"code":"static int block_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    static int banner_printed;\n\n    int len, flags;\n\n    char device_name[256];\n\n    int64_t addr;\n\n    BlockDriverState *bs;\n\n    uint8_t *buf;\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~BDRV_SECTOR_MASK;\n\n        addr >>= BDRV_SECTOR_BITS;\n\n\n\n        if (flags & BLK_MIG_FLAG_DEVICE_BLOCK) {\n\n            int ret;\n\n            \/* get device name *\/\n\n            len = qemu_get_byte(f);\n\n            qemu_get_buffer(f, (uint8_t *)device_name, len);\n\n            device_name[len] = '\\0';\n\n\n\n            bs = bdrv_find(device_name);\n\n            if (!bs) {\n\n                fprintf(stderr, \"Error unknown block device %s\\n\",\n\n                        device_name);\n\n                return -EINVAL;\n\n            }\n\n\n\n            buf = qemu_malloc(BLOCK_SIZE);\n\n\n\n            qemu_get_buffer(f, buf, BLOCK_SIZE);\n\n            ret = bdrv_write(bs, addr, buf, BDRV_SECTORS_PER_DIRTY_CHUNK);\n\n\n\n            qemu_free(buf);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n        } else if (flags & BLK_MIG_FLAG_PROGRESS) {\n\n            if (!banner_printed) {\n\n                printf(\"Receiving block device images\\n\");\n\n                banner_printed = 1;\n\n            }\n\n            printf(\"Completed %d %%%c\", (int)addr,\n\n                   (addr == 100) ? '\\n' : '\\r');\n\n            fflush(stdout);\n\n        } else if (!(flags & BLK_MIG_FLAG_EOS)) {\n\n            fprintf(stderr, \"Unknown flags\\n\");\n\n            return -EINVAL;\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & BLK_MIG_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n","idx":145,"target":1}
{"code":"static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,\n\n                    ptrdiff_t stride, int h)\n\n{\n\n    const uint8_t *scantable = s->intra_scantable.permutated;\n\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n\n    int i, last, run, bits, level, start_i;\n\n    const int esc_length = s->ac_esc_length;\n\n    uint8_t *length, *last_length;\n\n\n\n    av_assert2(h == 8);\n\n\n\n    s->pdsp.diff_pixels(temp, src1, src2, stride);\n\n\n\n    s->block_last_index[0 \/* FIXME *\/] =\n\n    last                               =\n\n        s->fast_dct_quantize(s, temp, 0 \/* FIXME *\/, s->qscale, &i);\n\n\n\n    bits = 0;\n\n\n\n    if (s->mb_intra) {\n\n        start_i     = 1;\n\n        length      = s->intra_ac_vlc_length;\n\n        last_length = s->intra_ac_vlc_last_length;\n\n        bits       += s->luma_dc_vlc_length[temp[0] + 256]; \/\/ FIXME: chroma\n\n    } else {\n\n        start_i     = 0;\n\n        length      = s->inter_ac_vlc_length;\n\n        last_length = s->inter_ac_vlc_last_length;\n\n    }\n\n\n\n    if (last >= start_i) {\n\n        run = 0;\n\n        for (i = start_i; i < last; i++) {\n\n            int j = scantable[i];\n\n            level = temp[j];\n\n\n\n            if (level) {\n\n                level += 64;\n\n                if ((level & (~127)) == 0)\n\n                    bits += length[UNI_AC_ENC_INDEX(run, level)];\n\n                else\n\n                    bits += esc_length;\n\n                run = 0;\n\n            } else\n\n                run++;\n\n        }\n\n        i = scantable[last];\n\n\n\n        level = temp[i] + 64;\n\n\n\n        av_assert2(level - 64);\n\n\n\n        if ((level & (~127)) == 0)\n\n            bits += last_length[UNI_AC_ENC_INDEX(run, level)];\n\n        else\n\n            bits += esc_length;\n\n    }\n\n\n\n    return bits;\n\n}\n","idx":146,"target":1}
{"code":"static int alsa_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    ALSAVoiceIn *alsa = (ALSAVoiceIn *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    struct audsettings obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_in;\n\n    req.buffer_size = conf.buffer_size_in;\n\n    req.size_in_usec = conf.size_in_usec_in;\n\n    req.override_mask =\n\n        (conf.period_size_in_overridden ? 1 : 0) |\n\n        (conf.buffer_size_in_overridden ? 2 : 0);\n\n\n\n    if (alsa_open (1, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate ADC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close1 (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n","idx":147,"target":1}
{"code":"static uint32_t m5206_mbar_readb(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    if (m5206_mbar_width[offset >> 2] > 1) {\n\n        uint16_t val;\n\n        val = m5206_mbar_readw(opaque, offset & ~1);\n\n        if ((offset & 1) == 0) {\n\n            val >>= 8;\n\n        }\n\n        return val & 0xff;\n\n    }\n\n    return m5206_mbar_read(s, offset, 1);\n\n}\n","idx":148,"target":1}
{"code":"static void compute_rematrixing_strategy(AC3EncodeContext *s)\n\n{\n\n    int nb_coefs;\n\n    int blk, bnd, i;\n\n    AC3Block *block, *block0;\n\n\n\n    s->num_rematrixing_bands = 4;\n\n\n\n    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)\n\n        return;\n\n\n\n    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        block = &s->blocks[blk];\n\n        block->new_rematrixing_strategy = !blk;\n\n        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {\n\n            \/* calculate calculate sum of squared coeffs for one band in one block *\/\n\n            int start = ff_ac3_rematrix_band_tab[bnd];\n\n            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);\n\n            CoefSumType sum[4] = {0,};\n\n            for (i = start; i < end; i++) {\n\n                CoefType lt = block->mdct_coef[0][i];\n\n                CoefType rt = block->mdct_coef[1][i];\n\n                CoefType md = lt + rt;\n\n                CoefType sd = lt - rt;\n\n                sum[0] += lt * lt;\n\n                sum[1] += rt * rt;\n\n                sum[2] += md * md;\n\n                sum[3] += sd * sd;\n\n            }\n\n\n\n            \/* compare sums to determine if rematrixing will be used for this band *\/\n\n            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))\n\n                block->rematrixing_flags[bnd] = 1;\n\n            else\n\n                block->rematrixing_flags[bnd] = 0;\n\n\n\n            \/* determine if new rematrixing flags will be sent *\/\n\n            if (blk &&\n\n                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {\n\n                block->new_rematrixing_strategy = 1;\n\n            }\n\n        }\n\n        block0 = block;\n\n    }\n\n}\n","idx":149,"target":1}
{"code":"static int vnc_zlib_stop(VncState *vs, int stream_id)\n\n{\n\n    z_streamp zstream = &vs->zlib_stream[stream_id];\n\n    int previous_out;\n\n\n\n    \/\/ switch back to normal output\/zlib buffers\n\n    vs->zlib = vs->output;\n\n    vs->output = vs->zlib_tmp;\n\n\n\n    \/\/ compress the zlib buffer\n\n\n\n    \/\/ initialize the stream\n\n    \/\/ XXX need one stream per session\n\n    if (zstream->opaque != vs) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: initializing zlib stream %d\\n\", stream_id);\n\n        VNC_DEBUG(\"VNC: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = Z_NULL;\n\n        zstream->zfree = Z_NULL;\n\n\n\n        err = deflateInit2(zstream, vs->tight_compression, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    \/\/ XXX what to do if tight_compression changed in between?\n\n\n\n    \/\/ reserve memory in output buffer\n\n    buffer_reserve(&vs->output, vs->zlib.offset + 64);\n\n\n\n    \/\/ set pointers\n\n    zstream->next_in = vs->zlib.buffer;\n\n    zstream->avail_in = vs->zlib.offset;\n\n    zstream->next_out = vs->output.buffer + vs->output.offset;\n\n    zstream->avail_out = vs->output.capacity - vs->output.offset;\n\n    zstream->data_type = Z_BINARY;\n\n    previous_out = zstream->total_out;\n\n\n\n    \/\/ start encoding\n\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n\n        fprintf(stderr, \"VNC: error during zlib compression\\n\");\n\n        return -1;\n\n    }\n\n\n\n    vs->output.offset = vs->output.capacity - zstream->avail_out;\n\n    return zstream->total_out - previous_out;\n\n}\n","idx":150,"target":1}
{"code":"static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= 0;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb=\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n","idx":153,"target":1}
{"code":"static void cg3_initfn(Object *obj)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    CG3State *s = CG3(obj);\n\n\n\n    memory_region_init_ram(&s->rom, NULL, \"cg3.prom\", FCODE_MAX_ROM_SIZE,\n\n                           &error_abort);\n\n    memory_region_set_readonly(&s->rom, true);\n\n    sysbus_init_mmio(sbd, &s->rom);\n\n\n\n    memory_region_init_io(&s->reg, NULL, &cg3_reg_ops, s, \"cg3.reg\",\n\n                          CG3_REG_SIZE);\n\n    sysbus_init_mmio(sbd, &s->reg);\n\n}\n","idx":154,"target":1}
{"code":"static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    fprintf(stderr, \"EHCI doesn't handle 16-bit writes to MMIO\\n\");\n\n    exit(1);\n\n}\n","idx":155,"target":1}
{"code":"static void parse_context_init(SchroParseUnitContext *parse_ctx,\n\n                               const uint8_t *buf, int buf_size)\n\n{\n\n    parse_ctx->buf           = buf;\n\n    parse_ctx->buf_size      = buf_size;\n\n}\n","idx":157,"target":1}
{"code":"static void wm8750_audio_out_cb(void *opaque, int free_b)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n    wm8750_out_flush(s);\n\n\n\n    s->req_out = free_b;\n\n    s->data_req(s->opaque, free_b >> 2, s->req_in >> 2);\n\n}\n","idx":160,"target":1}
{"code":"static void xendev_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->props = xendev_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n\n\n\n\n\n}","idx":161,"target":1}
{"code":"static uint64_t qdev_get_prop_mask64(Property *prop)\n\n{\n\n    assert(prop->info == &qdev_prop_bit);\n\n    return 0x1 << prop->bitnr;\n\n}\n","idx":162,"target":1}
{"code":"static void unix_process_msgfd(CharDriverState *chr, struct msghdr *msg)\n{\n    TCPCharDriver *s = chr->opaque;\n    struct cmsghdr *cmsg;\n    for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\n        int fd;\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n            cmsg->cmsg_level != SOL_SOCKET ||\n            cmsg->cmsg_type != SCM_RIGHTS)\n            continue;\n        fd = *((int *)CMSG_DATA(cmsg));\n        if (fd < 0)\n            continue;\n#ifndef MSG_CMSG_CLOEXEC\n        qemu_set_cloexec(fd);\n#endif\n        if (s->msgfd != -1)\n            close(s->msgfd);\n        s->msgfd = fd;\n    }\n}","idx":163,"target":1}
{"code":"void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 \/ x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();","idx":164,"target":1}
{"code":"void ga_channel_free(GAChannel *c)\n\n{\n\n    if (c->method == GA_CHANNEL_UNIX_LISTEN\n\n        && c->listen_channel) {\n\n        ga_channel_listen_close(c);\n\n    }\n\n    if (c->client_channel) {\n\n        ga_channel_client_close(c);\n\n    }\n\n    g_free(c);\n\n}\n","idx":165,"target":0}
{"code":"static int create_ppc_opcodes (CPUPPCState *env, ppc_def_t *def)\n\n{\n\n    opcode_t *opc, *start, *end;\n\n\n\n    fill_new_table(env->opcodes, 0x40);\n\n#if defined(PPC_DUMP_CPU)\n\n    printf(\"* PowerPC instructions for PVR %08x: %s flags %016\" PRIx64\n\n           \" %08x\\n\",\n\n           def->pvr, def->name, def->insns_flags, def->flags);\n\n#endif\n\n    if (&opc_start < &opc_end) {\n\n        start = &opc_start;\n\n        end = &opc_end;\n\n    } else {\n\n        start = &opc_end;\n\n        end = &opc_start;\n\n    }\n\n    for (opc = start + 1; opc != end; opc++) {\n\n        if ((opc->handler.type & def->insns_flags) != 0) {\n\n            if (register_insn(env->opcodes, opc) < 0) {\n\n                printf(\"*** ERROR initializing PowerPC instruction \"\n\n                       \"0x%02x 0x%02x 0x%02x\\n\", opc->opc1, opc->opc2,\n\n                       opc->opc3);\n\n                return -1;\n\n            }\n\n#if defined(PPC_DUMP_CPU)\n\n            if (opc1 != 0x00) {\n\n                if (opc->opc3 == 0xFF) {\n\n                    if (opc->opc2 == 0xFF) {\n\n                        printf(\" %02x -- -- (%2d ----) : %s\\n\",\n\n                               opc->opc1, opc->opc1, opc->oname);\n\n                    } else {\n\n                        printf(\" %02x %02x -- (%2d %4d) : %s\\n\",\n\n                               opc->opc1, opc->opc2, opc->opc1, opc->opc2,\n\n                               opc->oname);\n\n                    }\n\n                } else {\n\n                    printf(\" %02x %02x %02x (%2d %4d) : %s\\n\",\n\n                           opc->opc1, opc->opc2, opc->opc3,\n\n                           opc->opc1, (opc->opc3 << 5) | opc->opc2,\n\n                           opc->oname);\n\n                }\n\n            }\n\n#endif\n\n        }\n\n    }\n\n    fix_opcode_tables(env->opcodes);\n\n    fflush(stdout);\n\n    fflush(stderr);\n\n\n\n    return 0;\n\n}\n","idx":166,"target":0}
{"code":"ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,\n\n                                   MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    ram_addr_t addr;\n\n    Error *local_err = NULL;\n\n\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    addr = ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return -1;\n\n    }\n\n    return addr;\n\n}\n","idx":167,"target":0}
{"code":"void kvm_s390_io_interrupt(S390CPU *cpu, uint16_t subchannel_id,\n\n                           uint16_t subchannel_nr, uint32_t io_int_parm,\n\n                           uint32_t io_int_word)\n\n{\n\n    uint32_t type;\n\n\n\n    if (io_int_word & IO_INT_WORD_AI) {\n\n        type = KVM_S390_INT_IO(1, 0, 0, 0);\n\n    } else {\n\n        type = ((subchannel_id & 0xff00) << 24) |\n\n            ((subchannel_id & 0x00060) << 22) | (subchannel_nr << 16);\n\n    }\n\n    kvm_s390_interrupt_internal(cpu, type,\n\n                                ((uint32_t)subchannel_id << 16) | subchannel_nr,\n\n                                ((uint64_t)io_int_parm << 32) | io_int_word, 1);\n\n}\n","idx":168,"target":0}
{"code":"static void elcr_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t val, unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    s->elcr = val & s->elcr_mask;\n\n}\n","idx":169,"target":0}
{"code":"void nonono(const char* file, int line, const char* msg) {\n\n    fprintf(stderr, \"Nonono! %s:%d %s\\n\", file, line, msg);\n\n    exit(-5);\n\n}\n","idx":170,"target":0}
{"code":"static void spitz_i2c_setup(PXA2xxState *cpu)\n\n{\n\n    \/* Attach the CPU on one end of our I2C bus.  *\/\n\n    i2c_bus *bus = pxa2xx_i2c_bus(cpu->i2c[0]);\n\n\n\n#ifdef HAS_AUDIO\n\n    DeviceState *wm;\n\n\n\n    \/* Attach a WM8750 to the bus *\/\n\n    wm = i2c_create_slave(bus, \"wm8750\", 0);\n\n\n\n    spitz_wm8750_addr(wm, 0, 0);\n\n    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_WM,\n\n                    qemu_allocate_irqs(spitz_wm8750_addr, wm, 1)[0]);\n\n    \/* .. and to the sound interface.  *\/\n\n    cpu->i2s->opaque = wm;\n\n    cpu->i2s->codec_out = wm8750_dac_dat;\n\n    cpu->i2s->codec_in = wm8750_adc_dat;\n\n    wm8750_data_req_set(wm, cpu->i2s->data_req, cpu->i2s);\n\n#endif\n\n}\n","idx":171,"target":0}
{"code":"void restore_boot_order(void *opaque)\n\n{\n\n    char *normal_boot_order = opaque;\n\n    static int first = 1;\n\n\n\n    \/* Restore boot order and remove ourselves after the first boot *\/\n\n    if (first) {\n\n        first = 0;\n\n        return;\n\n    }\n\n\n\n    qemu_boot_set(normal_boot_order);\n\n\n\n    qemu_unregister_reset(restore_boot_order, normal_boot_order);\n\n    g_free(normal_boot_order);\n\n}\n","idx":173,"target":0}
{"code":"static void smp_parse(const char *optarg)\n\n{\n\n    int smp, sockets = 0, threads = 0, cores = 0;\n\n    char *endptr;\n\n    char option[128];\n\n\n\n    smp = strtoul(optarg, &endptr, 10);\n\n    if (endptr != optarg) {\n\n        if (*endptr == ',') {\n\n            endptr++;\n\n        }\n\n    }\n\n    if (get_param_value(option, 128, \"sockets\", endptr) != 0)\n\n        sockets = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"cores\", endptr) != 0)\n\n        cores = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"threads\", endptr) != 0)\n\n        threads = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"maxcpus\", endptr) != 0)\n\n        max_cpus = strtoull(option, NULL, 10);\n\n\n\n    \/* compute missing values, prefer sockets over cores over threads *\/\n\n    if (smp == 0 || sockets == 0) {\n\n        sockets = sockets > 0 ? sockets : 1;\n\n        cores = cores > 0 ? cores : 1;\n\n        threads = threads > 0 ? threads : 1;\n\n        if (smp == 0) {\n\n            smp = cores * threads * sockets;\n\n        }\n\n    } else {\n\n        if (cores == 0) {\n\n            threads = threads > 0 ? threads : 1;\n\n            cores = smp \/ (sockets * threads);\n\n        } else {\n\n            threads = smp \/ (cores * sockets);\n\n        }\n\n    }\n\n    smp_cpus = smp;\n\n    smp_cores = cores > 0 ? cores : 1;\n\n    smp_threads = threads > 0 ? threads : 1;\n\n    if (max_cpus == 0)\n\n        max_cpus = smp_cpus;\n\n}\n","idx":174,"target":0}
{"code":"void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n","idx":176,"target":0}
{"code":"void block_job_pause(BlockJob *job)\n\n{\n\n    job->paused = true;\n\n}\n","idx":177,"target":0}
{"code":"int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n","idx":178,"target":0}
{"code":"static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n","idx":179,"target":0}
{"code":"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf, int bytes)\n\n{\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {\n\n        .iov_base   = (void *) buf,\n\n        .iov_len    = bytes,\n\n    };\n\n\n\n    if (bytes < 0) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n    return bdrv_pwritev(bs, offset, &qiov);\n\n}\n","idx":181,"target":0}
{"code":"static int ppc_fixup_cpu(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n    \/* TCG doesn't (yet) emulate some groups of instructions that\n\n     * are implemented on some otherwise supported CPUs (e.g. VSX\n\n     * and decimal floating point instructions on POWER7).  We\n\n     * remove unsupported instruction groups from the cpu state's\n\n     * instruction masks and hope the guest can cope.  For at\n\n     * least the pseries machine, the unavailability of these\n\n     * instructions can be advertised to the guest via the device\n\n     * tree. *\/\n\n    if ((env->insns_flags & ~PPC_TCG_INSNS)\n\n        || (env->insns_flags2 & ~PPC_TCG_INSNS2)) {\n\n        fprintf(stderr, \"Warning: Disabling some instructions which are not \"\n\n                \"emulated by TCG (0x%\" PRIx64 \", 0x%\" PRIx64 \")\\n\",\n\n                env->insns_flags & ~PPC_TCG_INSNS,\n\n                env->insns_flags2 & ~PPC_TCG_INSNS2);\n\n    }\n\n    env->insns_flags &= PPC_TCG_INSNS;\n\n    env->insns_flags2 &= PPC_TCG_INSNS2;\n\n    return 0;\n\n}\n","idx":182,"target":0}
{"code":"static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        output[1][i] -= output[3][i];\n\n        output[2][i] += output[3][i];\n\n    }\n\n    memset(output[3], 0, sizeof(output[3]));\n\n}\n","idx":183,"target":0}
{"code":"static int config_props(AVFilterLink *outlink)\n\n{\n\n    AVFilterContext *ctx = outlink->src;\n\n    AVFilterLink *inlink = outlink->src->inputs[0];\n\n    ScaleContext *scale = ctx->priv;\n\n    int64_t w, h;\n\n\n\n    if (!(w = scale->w))\n\n        w = inlink->w;\n\n    if (!(h = scale->h))\n\n        h = inlink->h;\n\n    if (w == -1)\n\n        w = av_rescale(h, inlink->w, inlink->h);\n\n    if (h == -1)\n\n        h = av_rescale(w, inlink->h, inlink->w);\n\n\n\n    if (w > INT_MAX || h > INT_MAX ||\n\n        (h * inlink->w) > INT_MAX  ||\n\n        (w * inlink->h) > INT_MAX)\n\n        av_log(ctx, AV_LOG_ERROR, \"Rescaled value for width or height is too big.\\n\");\n\n\n\n    outlink->w = w;\n\n    outlink->h = h;\n\n\n\n    \/* TODO: make algorithm configurable *\/\n\n    scale->sws = sws_getContext(inlink ->w, inlink ->h, inlink ->format,\n\n                                outlink->w, outlink->h, outlink->format,\n\n                                SWS_BILINEAR, NULL, NULL, NULL);\n\n\n\n    av_log(ctx, AV_LOG_INFO, \"w:%d h:%d fmt:%s\\n\",\n\n           outlink->w, outlink->h, av_pix_fmt_descriptors[outlink->format].name);\n\n\n\n    scale->input_is_pal = inlink->format == PIX_FMT_PAL8      ||\n\n                          inlink->format == PIX_FMT_BGR4_BYTE ||\n\n                          inlink->format == PIX_FMT_RGB4_BYTE ||\n\n                          inlink->format == PIX_FMT_BGR8      ||\n\n                          inlink->format == PIX_FMT_RGB8;\n\n\n\n    return !scale->sws;\n\n}\n","idx":188,"target":0}
{"code":"static void libopus_write_header(AVCodecContext *avctx, int stream_count,\n\n                                 int coupled_stream_count,\n\n                                 const uint8_t *channel_mapping)\n\n{\n\n    uint8_t *p   = avctx->extradata;\n\n    int channels = avctx->channels;\n\n\n\n    bytestream_put_buffer(&p, \"OpusHead\", 8);\n\n    bytestream_put_byte(&p, 1); \/* Version *\/\n\n    bytestream_put_byte(&p, channels);\n\n    bytestream_put_le16(&p, avctx->delay); \/* Lookahead samples at 48kHz *\/\n\n    bytestream_put_le32(&p, avctx->sample_rate); \/* Original sample rate *\/\n\n    bytestream_put_le16(&p, 0); \/* Gain of 0dB is recommended. *\/\n\n\n\n    \/* Channel mapping *\/\n\n    if (channels > 2) {\n\n        bytestream_put_byte(&p, channels <= 8 ? 1 : 255);\n\n        bytestream_put_byte(&p, stream_count);\n\n        bytestream_put_byte(&p, coupled_stream_count);\n\n        bytestream_put_buffer(&p, channel_mapping, channels);\n\n    } else {\n\n        bytestream_put_byte(&p, 0);\n\n    }\n\n}\n","idx":189,"target":0}
{"code":"static int mov_write_tmcd_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n#if 1\n\n    int frame_duration = av_rescale(track->timescale, track->enc->time_base.num, track->enc->time_base.den);\n\n    int nb_frames = ROUNDED_DIV(track->enc->time_base.den, track->enc->time_base.num);\n\n    AVDictionaryEntry *t = NULL;\n\n\n\n    if (nb_frames > 255) {\n\n        av_log(NULL, AV_LOG_ERROR, \"fps %d is too large\\n\", nb_frames);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avio_wb32(pb, 0); \/* size *\/\n\n    ffio_wfourcc(pb, \"tmcd\");               \/* Data format *\/\n\n    avio_wb32(pb, 0);                       \/* Reserved *\/\n\n    avio_wb32(pb, 1);                       \/* Data reference index *\/\n\n    avio_wb32(pb, 0);                       \/* Flags *\/\n\n    avio_wb32(pb, track->timecode_flags);   \/* Flags (timecode) *\/\n\n    avio_wb32(pb, track->timescale);        \/* Timescale *\/\n\n    avio_wb32(pb, frame_duration);          \/* Frame duration *\/\n\n    avio_w8(pb, nb_frames);                 \/* Number of frames *\/\n\n    avio_w8(pb, 0);                         \/* Reserved *\/\n\n\n\n    if (track->st)\n\n        t = av_dict_get(track->st->metadata, \"reel_name\", NULL, 0);\n\n\n\n    if (t && utf8len(t->value))\n\n        mov_write_source_reference_tag(pb, track, t->value);\n\n    else\n\n        avio_wb16(pb, 0); \/* zero size *\/\n\n#else\n\n\n\n    avio_wb32(pb, 0); \/* size *\/\n\n    ffio_wfourcc(pb, \"tmcd\");               \/* Data format *\/\n\n    avio_wb32(pb, 0);                       \/* Reserved *\/\n\n    avio_wb32(pb, 1);                       \/* Data reference index *\/\n\n    if (track->enc->extradata_size)\n\n        avio_write(pb, track->enc->extradata, track->enc->extradata_size);\n\n#endif\n\n    return update_size(pb, pos);\n\n}\n","idx":190,"target":0}
{"code":"static int expand_rle_row16(SgiState *s, uint16_t *out_buf,\n\n                            int len, int pixelstride)\n\n{\n\n    unsigned short pixel;\n\n    unsigned char count;\n\n    unsigned short *orig = out_buf;\n\n    uint16_t *out_end = out_buf + len;\n\n\n\n    while (out_buf < out_end) {\n\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n\n            return AVERROR_INVALIDDATA;\n\n        pixel = bytestream2_get_be16u(&s->g);\n\n        if (!(count = (pixel & 0x7f)))\n\n            break;\n\n\n\n        \/* Check for buffer overflow. *\/\n\n        if (pixelstride * (count - 1) >= len) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid pixel count.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (pixel & 0x80) {\n\n            while (count--) {\n\n                pixel = bytestream2_get_ne16(&s->g);\n\n                AV_WN16A(out_buf, pixel);\n\n                out_buf += pixelstride;\n\n            }\n\n        } else {\n\n            pixel = bytestream2_get_ne16(&s->g);\n\n\n\n            while (count--) {\n\n                AV_WN16A(out_buf, pixel);\n\n                out_buf += pixelstride;\n\n            }\n\n        }\n\n    }\n\n    return (out_buf - orig) \/ pixelstride;\n\n}\n","idx":192,"target":0}
{"code":"void tlb_fill(CPUState *env1, target_ulong addr, int is_write, int mmu_idx,\n\n              void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    CPUState *saved_env;\n\n    unsigned long pc;\n\n    int ret;\n\n\n\n    saved_env = env;\n\n\n    ret = cpu_arm_handle_mmu_fault(env, addr, is_write, mmu_idx);\n\n    if (unlikely(ret)) {\n\n        if (retaddr) {\n\n            \/* now we have a real cpu fault *\/\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                \/* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault *\/\n\n                cpu_restore_state(tb, env, pc);\n\n            }\n\n        }\n\n        raise_exception(env->exception_index);\n\n    }\n\n    env = saved_env;\n\n}","idx":193,"target":1}
{"code":"int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)\n\n{\n\n    BufferSinkContext *s    = ctx->priv;\n\n    AVFilterLink      *link = ctx->inputs[0];\n\n    int ret;\n\n\n\n    if ((ret = ff_request_frame(link)) < 0)\n\n        return ret;\n\n\n\n    if (!s->cur_frame)\n\n        return AVERROR(EINVAL);\n\n\n\n    av_frame_move_ref(frame, s->cur_frame);\n\n    av_frame_free(&s->cur_frame);\n\n\n\n    return 0;\n\n}\n","idx":197,"target":1}
{"code":"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    sPAPRTCE *tcep;\n\n\n\n    if (ioba >= tcet->window_size) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-boards IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcep = tcet->table + (ioba >> SPAPR_TCE_PAGE_SHIFT);\n\n    tcep->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n","idx":199,"target":1}
{"code":"static void gen_lq(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    int ra, rd;\n\n    TCGv EA;\n\n\n\n    \/* Restore CPU state *\/\n\n    if (unlikely(ctx->mem_idx == 0)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    ra = rA(ctx->opcode);\n\n    rd = rD(ctx->opcode);\n\n    if (unlikely((rd & 1) || rd == ra)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        return;\n\n    }\n\n    if (unlikely(ctx->le_mode)) {\n\n        \/* Little-endian mode is not handled *\/\n\n        gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    EA = tcg_temp_new();\n\n    gen_addr_imm_index(ctx, EA, 0x0F);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd], EA);\n\n    gen_addr_add(ctx, EA, EA, 8);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd+1], EA);\n\n    tcg_temp_free(EA);\n\n#endif\n\n}\n","idx":201,"target":1}
{"code":"static uint32_t esp_mem_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    ESPState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr >> s->it_shift) & (ESP_REGS - 1);\n\n    DPRINTF(\"read reg[%d]: 0x%2.2x\\n\", saddr, s->rregs[saddr]);\n\n    switch (saddr) {\n\n    case ESP_FIFO:\n\n        if (s->ti_size > 0) {\n\n            s->ti_size--;\n\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n\n                \/* Data in\/out.  *\/\n\n                fprintf(stderr, \"esp: PIO data read not implemented\\n\");\n\n                s->rregs[ESP_FIFO] = 0;\n\n            } else {\n\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n\n            }\n\n            esp_raise_irq(s);\n\n        }\n\n        if (s->ti_size == 0) {\n\n            s->ti_rptr = 0;\n\n            s->ti_wptr = 0;\n\n        }\n\n        break;\n\n    case ESP_RINTR:\n\n        \/\/ Clear interrupt\/error status bits\n\n        s->rregs[ESP_RSTAT] &= ~(STAT_GE | STAT_PE);\n\n        esp_lower_irq(s);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return s->rregs[saddr];\n\n}\n","idx":202,"target":1}
{"code":"static void pcie_cap_slot_hotplug_common(PCIDevice *hotplug_dev,\n\n                                         DeviceState *dev,\n\n                                         uint8_t **exp_cap, Error **errp)\n\n{\n\n    *exp_cap = hotplug_dev->config + hotplug_dev->exp.exp_cap;\n\n    uint16_t sltsta = pci_get_word(*exp_cap + PCI_EXP_SLTSTA);\n\n\n\n    PCIE_DEV_PRINTF(PCI_DEVICE(dev), \"hotplug state: 0x%x\\n\", sltsta);\n\n    if (sltsta & PCI_EXP_SLTSTA_EIS) {\n\n        \/* the slot is electromechanically locked.\n\n         * This error is propagated up to qdev and then to HMP\/QMP.\n\n         *\/\n\n        error_setg_errno(errp, -EBUSY, \"slot is electromechanically locked\");\n\n    }\n\n}\n","idx":204,"target":1}
{"code":"void qmp_getfd(const char *fdname, Error **errp)\n\n{\n\n    mon_fd_t *monfd;\n\n    int fd;\n\n\n\n    fd = qemu_chr_fe_get_msgfd(cur_mon->chr);\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_FD_NOT_SUPPLIED);\n\n        return;\n\n    }\n\n\n\n    if (qemu_isdigit(fdname[0])) {\n\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"fdname\",\n\n                  \"a name not starting with a digit\");\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(monfd, &cur_mon->fds, next) {\n\n        if (strcmp(monfd->name, fdname) != 0) {\n\n            continue;\n\n        }\n\n\n\n        close(monfd->fd);\n\n        monfd->fd = fd;\n\n        return;\n\n    }\n\n\n\n    monfd = g_malloc0(sizeof(mon_fd_t));\n\n    monfd->name = g_strdup(fdname);\n\n    monfd->fd = fd;\n\n\n\n    QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);\n\n}","idx":205,"target":1}
{"code":"static void qmp_deserialize(void **native_out, void *datap,\n\n                            VisitorFunc visit, Error **errp)\n\n{\n\n    QmpSerializeData *d = datap;\n\n    QString *output_json = qobject_to_json(qmp_output_get_qobject(d->qov));\n\n    QObject *obj = qobject_from_json(qstring_get_str(output_json));\n\n\n\n    QDECREF(output_json);\n\n    d->qiv = qmp_input_visitor_new(obj);\n\n    qobject_decref(obj);\n\n    visit(qmp_input_get_visitor(d->qiv), native_out, errp);\n\n}\n","idx":206,"target":1}
{"code":"static bool coroutine_fn yield_and_check(BackupBlockJob *job)\n\n{\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    \/* we need to yield so that bdrv_drain_all() returns.\n\n     * (without, VM does not reboot)\n\n     *\/\n\n    if (job->common.speed) {\n\n        uint64_t delay_ns = ratelimit_calculate_delay(&job->limit,\n\n                                                      job->sectors_read);\n\n        job->sectors_read = 0;\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, delay_ns);\n\n    } else {\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, 0);\n\n    }\n\n\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n","idx":207,"target":1}
{"code":"int ffurl_read_complete(URLContext *h, unsigned char *buf, int size)\n\n{\n\n    if (h->flags & AVIO_FLAG_WRITE)\n\n        return AVERROR(EIO);\n\n    return retry_transfer_wrapper(h, buf, size, size, h->prot->url_read);\n\n}\n","idx":209,"target":1}
{"code":"int msix_init_exclusive_bar(PCIDevice *dev, unsigned short nentries,\n\n                            uint8_t bar_nr)\n\n{\n\n    int ret;\n\n    char *name;\n\n    uint32_t bar_size = 4096;\n\n    uint32_t bar_pba_offset = bar_size \/ 2;\n\n    uint32_t bar_pba_size = (nentries \/ 8 + 1) * 8;\n\n\n\n    \/*\n\n     * Migration compatibility dictates that this remains a 4k\n\n     * BAR with the vector table in the lower half and PBA in\n\n     * the upper half for nentries which is lower or equal to 128.\n\n     * No need to care about using more than 65 entries for legacy\n\n     * machine types who has at most 64 queues.\n\n     *\/\n\n    if (nentries * PCI_MSIX_ENTRY_SIZE > bar_pba_offset) {\n\n        bar_pba_offset = nentries * PCI_MSIX_ENTRY_SIZE;\n\n    }\n\n\n\n    if (bar_pba_offset + bar_pba_size > 4096) {\n\n        bar_size = bar_pba_offset + bar_pba_size;\n\n    }\n\n\n\n    if (bar_size & (bar_size - 1)) {\n\n        bar_size = 1 << qemu_fls(bar_size);\n\n    }\n\n\n\n    name = g_strdup_printf(\"%s-msix\", dev->name);\n\n    memory_region_init(&dev->msix_exclusive_bar, OBJECT(dev), name, bar_size);\n\n    g_free(name);\n\n\n\n    ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,\n\n                    0, &dev->msix_exclusive_bar,\n\n                    bar_nr, bar_pba_offset,\n\n                    0);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    pci_register_bar(dev, bar_nr, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &dev->msix_exclusive_bar);\n\n\n\n    return 0;\n\n}\n","idx":210,"target":1}
{"code":"void qemu_del_timer(QEMUTimer *ts)\n\n{\n\n}\n","idx":211,"target":0}
{"code":"static void restore_native_fp_frstor(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    fp->fpuc = env->fpuc;\n\n    fp->fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;\n\n    fptag = 0;\n\n    for (i=7; i>=0; i--) {\n\n\tfptag <<= 2;\n\n\tif (env->fptags[i]) {\n\n            fptag |= 3;\n\n        } else {\n\n            \/* the FPU automatically computes it *\/\n\n        }\n\n    }\n\n    fp->fptag = fptag;\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&fp->fpregs1[i * 10], &env->fpregs[j].d, 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    asm volatile (\"frstor %0\" : \"=m\" (*fp));\n\n}\n","idx":212,"target":0}
{"code":"static void cpu_exec_nocache(int max_cycles, TranslationBlock *orig_tb)\n\n{\n\n    unsigned long next_tb;\n\n    TranslationBlock *tb;\n\n\n\n    \/* Should never happen.\n\n       We only end up here when an existing TB is too long.  *\/\n\n    if (max_cycles > CF_COUNT_MASK)\n\n        max_cycles = CF_COUNT_MASK;\n\n\n\n    tb = tb_gen_code(env, orig_tb->pc, orig_tb->cs_base, orig_tb->flags,\n\n                     max_cycles);\n\n    env->current_tb = tb;\n\n    \/* execute the generated code *\/\n\n    next_tb = tcg_qemu_tb_exec(tb->tc_ptr);\n\n    env->current_tb = NULL;\n\n\n\n    if ((next_tb & 3) == 2) {\n\n        \/* Restore PC.  This may happen if async event occurs before\n\n           the TB starts executing.  *\/\n\n        cpu_pc_from_tb(env, tb);\n\n    }\n\n    tb_phys_invalidate(tb, -1);\n\n    tb_free(tb);\n\n}\n","idx":213,"target":0}
{"code":"static char *regname(uint32_t addr)\n\n{\n\n    static char buf[16];\n\n    if (addr < PCI_IO_SIZE) {\n\n        const char *r = reg[addr \/ 4];\n\n        if (r != 0) {\n\n            sprintf(buf, \"%s+%u\", r, addr % 4);\n\n        } else {\n\n            sprintf(buf, \"0x%02x\", addr);\n\n        }\n\n    } else {\n\n        sprintf(buf, \"??? 0x%08x\", addr);\n\n    }\n\n    return buf;\n\n}\n","idx":214,"target":0}
{"code":"static int on2avc_decode_band_scales(On2AVCContext *c, GetBitContext *gb)\n\n{\n\n    int w, w2, b, scale, first = 1;\n\n    int band_off = 0;\n\n\n\n    for (w = 0; w < c->num_windows; w++) {\n\n        if (!c->grouping[w]) {\n\n            memcpy(c->band_scales + band_off,\n\n                   c->band_scales + band_off - c->num_bands,\n\n                   c->num_bands * sizeof(*c->band_scales));\n\n            band_off += c->num_bands;\n\n            continue;\n\n        }\n\n        for (b = 0; b < c->num_bands; b++) {\n\n            if (!c->band_type[band_off]) {\n\n                int all_zero = 1;\n\n                for (w2 = w + 1; w2 < c->num_windows; w2++) {\n\n                    if (c->grouping[w2])\n\n                        break;\n\n                    if (c->band_type[w2 * c->num_bands + b]) {\n\n                        all_zero = 0;\n\n                        break;\n\n                    }\n\n                }\n\n                if (all_zero) {\n\n                    c->band_scales[band_off++] = 0;\n\n                    continue;\n\n                }\n\n            }\n\n            if (first) {\n\n                scale = get_bits(gb, 7);\n\n                first = 0;\n\n            } else {\n\n                scale += get_vlc2(gb, c->scale_diff.table, 9, 3) - 60;\n\n            }\n\n            if (scale < 0 || scale > 128) {\n\n                av_log(c->avctx, AV_LOG_ERROR, \"Invalid scale value %d\\n\",\n\n                       scale);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            c->band_scales[band_off++] = c->scale_tab[scale];\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":216,"target":0}
{"code":"static inline void writer_print_rational(WriterContext *wctx,\n\n                                         const char *key, AVRational q, char sep)\n\n{\n\n    AVBPrint buf;\n\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n    av_bprintf(&buf, \"%d%c%d\", q.num, sep, q.den);\n\n    wctx->writer->print_string(wctx, key, buf.str);\n\n    wctx->nb_item++;\n\n}\n","idx":217,"target":0}
{"code":"START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n","idx":218,"target":0}
{"code":"int cpu_watchpoint_insert(CPUState *env, target_ulong addr, target_ulong len,\n\n                          int flags, CPUWatchpoint **watchpoint)\n\n{\n\n    target_ulong len_mask = ~(len - 1);\n\n    CPUWatchpoint *wp;\n\n\n\n    \/* sanity checks: allow power-of-2 lengths, deny unaligned watchpoints *\/\n\n    if ((len != 1 && len != 2 && len != 4 && len != 8) || (addr & ~len_mask)) {\n\n        fprintf(stderr, \"qemu: tried to set invalid watchpoint at \"\n\n                TARGET_FMT_lx \", len=\" TARGET_FMT_lu \"\\n\", addr, len);\n\n        return -EINVAL;\n\n    }\n\n    wp = qemu_malloc(sizeof(*wp));\n\n\n\n    wp->vaddr = addr;\n\n    wp->len_mask = len_mask;\n\n    wp->flags = flags;\n\n\n\n    \/* keep all GDB-injected watchpoints in front *\/\n\n    if (flags & BP_GDB)\n\n        TAILQ_INSERT_HEAD(&env->watchpoints, wp, entry);\n\n    else\n\n        TAILQ_INSERT_TAIL(&env->watchpoints, wp, entry);\n\n\n\n    tlb_flush_page(env, addr);\n\n\n\n    if (watchpoint)\n\n        *watchpoint = wp;\n\n    return 0;\n\n}\n","idx":219,"target":0}
{"code":"static off_t read_off(int fd, int64_t offset)\n\n{\n\n\tuint64_t buffer;\n\n\tif (pread(fd, &buffer, 8, offset) < 8)\n\n\t\treturn 0;\n\n\treturn be64_to_cpu(buffer);\n\n}\n","idx":220,"target":0}
{"code":"void pc_machine_done(Notifier *notifier, void *data)\n\n{\n\n    PCMachineState *pcms = container_of(notifier,\n\n                                        PCMachineState, machine_done);\n\n    PCIBus *bus = pcms->bus;\n\n\n\n    \/* set the number of CPUs *\/\n\n    rtc_set_cpus_count(pcms->rtc, pcms->boot_cpus);\n\n\n\n    if (bus) {\n\n        int extra_hosts = 0;\n\n\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            \/* look for expander root buses *\/\n\n            if (pci_bus_is_root(bus)) {\n\n                extra_hosts++;\n\n            }\n\n        }\n\n        if (extra_hosts && pcms->fw_cfg) {\n\n            uint64_t *val = g_malloc(sizeof(*val));\n\n            *val = cpu_to_le64(extra_hosts);\n\n            fw_cfg_add_file(pcms->fw_cfg,\n\n                    \"etc\/extra-pci-roots\", val, sizeof(*val));\n\n        }\n\n    }\n\n\n\n    acpi_setup();\n\n    if (pcms->fw_cfg) {\n\n        pc_build_smbios(pcms);\n\n        pc_build_feature_control_file(pcms);\n\n        \/* update FW_CFG_NB_CPUS to account for -device added CPUs *\/\n\n        fw_cfg_modify_i16(pcms->fw_cfg, FW_CFG_NB_CPUS, pcms->boot_cpus);\n\n    }\n\n\n\n    if (pcms->apic_id_limit > 255) {\n\n        IntelIOMMUState *iommu = INTEL_IOMMU_DEVICE(x86_iommu_get_default());\n\n\n\n        if (!iommu || !iommu->x86_iommu.intr_supported ||\n\n            iommu->intr_eim != ON_OFF_AUTO_ON) {\n\n            error_report(\"current -smp configuration requires \"\n\n                         \"Extended Interrupt Mode enabled. \"\n\n                         \"You can add an IOMMU using: \"\n\n                         \"-device intel-iommu,intremap=on,eim=on\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n    }\n\n}\n","idx":221,"target":0}
{"code":"bool replay_next_event_is(int event)\n\n{\n\n    bool res = false;\n\n\n\n    \/* nothing to skip - not all instructions used *\/\n\n    if (replay_state.instructions_count != 0) {\n\n        assert(replay_data_kind == EVENT_INSTRUCTION);\n\n        return event == EVENT_INSTRUCTION;\n\n    }\n\n\n\n    while (true) {\n\n        if (event == replay_data_kind) {\n\n            res = true;\n\n        }\n\n        switch (replay_data_kind) {\n\n        case EVENT_SHUTDOWN:\n\n            replay_finish_event();\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        default:\n\n            \/* clock, time_t, checkpoint and other events *\/\n\n            return res;\n\n        }\n\n    }\n\n    return res;\n\n}\n","idx":223,"target":0}
{"code":"void kvm_init_irq_routing(KVMState *s)\n\n{\n\n    int gsi_count, i;\n\n\n\n    gsi_count = kvm_check_extension(s, KVM_CAP_IRQ_ROUTING);\n\n    if (gsi_count > 0) {\n\n        unsigned int gsi_bits, i;\n\n\n\n        \/* Round up so we can search ints using ffs *\/\n\n        gsi_bits = ALIGN(gsi_count, 32);\n\n        s->used_gsi_bitmap = g_malloc0(gsi_bits \/ 8);\n\n        s->gsi_count = gsi_count;\n\n\n\n        \/* Mark any over-allocated bits as already in use *\/\n\n        for (i = gsi_count; i < gsi_bits; i++) {\n\n            set_gsi(s, i);\n\n        }\n\n    }\n\n\n\n    s->irq_routes = g_malloc0(sizeof(*s->irq_routes));\n\n    s->nr_allocated_irq_routes = 0;\n\n\n\n    if (!s->direct_msi) {\n\n        for (i = 0; i < KVM_MSI_HASHTAB_SIZE; i++) {\n\n            QTAILQ_INIT(&s->msi_hashtab[i]);\n\n        }\n\n    }\n\n\n\n    kvm_arch_init_irq_routing(s);\n\n}\n","idx":224,"target":0}
{"code":"static uint16_t *phys_page_find_alloc(target_phys_addr_t index, int alloc)\n\n{\n\n    PhysPageEntry *lp, *p;\n\n    int i, j;\n\n\n\n    lp = &phys_map;\n\n\n\n    \/* Level 1..N.  *\/\n\n    for (i = P_L2_LEVELS - 1; i >= 0; i--) {\n\n        if (lp->u.node == NULL) {\n\n            if (!alloc) {\n\n                return NULL;\n\n            }\n\n            lp->u.node = p = g_malloc0(sizeof(PhysPageEntry) * L2_SIZE);\n\n            if (i == 0) {\n\n                for (j = 0; j < L2_SIZE; j++) {\n\n                    p[j].u.leaf = phys_section_unassigned;\n\n                }\n\n            }\n\n        }\n\n        lp = &lp->u.node[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    return &lp->u.leaf;\n\n}\n","idx":225,"target":0}
{"code":"void qemu_cpu_kick(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n\n\n    qemu_cond_broadcast(env->halt_cond);\n\n    if (!env->thread_kicked) {\n\n        qemu_cpu_kick_thread(env);\n\n        env->thread_kicked = true;\n\n    }\n\n}\n","idx":226,"target":0}
{"code":"static uint64_t omap_pwt_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_read8(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t\/* FRC *\/\n\n        return s->frc;\n\n    case 0x04:\t\/* VCR *\/\n\n        return s->vrc;\n\n    case 0x08:\t\/* GCR *\/\n\n        return s->gcr;\n\n    }\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n","idx":227,"target":0}
{"code":"static int local_create_mapped_attr_dir(FsContext *ctx, const char *path)\n\n{\n\n    int err;\n\n    char attr_dir[PATH_MAX];\n\n    char *tmp_path = g_strdup(path);\n\n\n\n    snprintf(attr_dir, PATH_MAX, \"%s\/%s\/%s\",\n\n             ctx->fs_root, dirname(tmp_path), VIRTFS_META_DIR);\n\n\n\n    err = mkdir(attr_dir, 0700);\n\n    if (err < 0 && errno == EEXIST) {\n\n        err = 0;\n\n    }\n\n    g_free(tmp_path);\n\n    return err;\n\n}\n","idx":230,"target":0}
{"code":"static inline void sync_jmpstate(DisasContext *dc)\n\n{\n\n    if (dc->jmp == JMP_DIRECT) {\n\n            dc->jmp = JMP_INDIRECT;\n\n            tcg_gen_movi_tl(env_btaken, 1);\n\n            tcg_gen_movi_tl(env_btarget, dc->jmp_pc);\n\n    }\n\n}\n","idx":231,"target":0}
{"code":"void register_device_unmigratable(DeviceState *dev, const char *idstr,\n\n                                                            void *opaque)\n\n{\n\n    SaveStateEntry *se;\n\n    char id[256] = \"\";\n\n\n\n    if (dev && dev->parent_bus && dev->parent_bus->info->get_dev_path) {\n\n        char *path = dev->parent_bus->info->get_dev_path(dev);\n\n        if (path) {\n\n            pstrcpy(id, sizeof(id), path);\n\n            pstrcat(id, sizeof(id), \"\/\");\n\n            g_free(path);\n\n        }\n\n    }\n\n    pstrcat(id, sizeof(id), idstr);\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if (strcmp(se->idstr, id) == 0 && se->opaque == opaque) {\n\n            se->no_migrate = 1;\n\n        }\n\n    }\n\n}\n","idx":232,"target":0}
{"code":"int css_do_rsch(SubchDev *sch)\n\n{\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    int ret;\n\n\n\n    if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & SCSW_STCTL_STATUS_PEND) {\n\n        ret = -EINPROGRESS;\n\n        goto out;\n\n    }\n\n\n\n    if (((s->ctrl & SCSW_CTRL_MASK_FCTL) != SCSW_FCTL_START_FUNC) ||\n\n        (s->ctrl & SCSW_ACTL_RESUME_PEND) ||\n\n        (!(s->ctrl & SCSW_ACTL_SUSP))) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    \/* If monitoring is active, update counter. *\/\n\n    if (channel_subsys.chnmon_active) {\n\n        css_update_chnmon(sch);\n\n    }\n\n\n\n    s->ctrl |= SCSW_ACTL_RESUME_PEND;\n\n    do_subchannel_work(sch, NULL);\n\n    ret = 0;\n\n\n\nout:\n\n    return ret;\n\n}\n","idx":233,"target":0}
{"code":"CPUState *cpu_copy(CPUState *env)\n\n{\n\n    CPUState *new_env = cpu_init(env->cpu_model_str);\n\n    CPUState *next_cpu = new_env->next_cpu;\n\n    int cpu_index = new_env->cpu_index;\n\n#if defined(TARGET_HAS_ICE)\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n#endif\n\n\n\n    memcpy(new_env, env, sizeof(CPUState));\n\n\n\n    \/* Preserve chaining and index. *\/\n\n    new_env->next_cpu = next_cpu;\n\n    new_env->cpu_index = cpu_index;\n\n\n\n    \/* Clone all break\/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break\/watchpoints are handled correctly on clone. *\/\n\n    TAILQ_INIT(&env->breakpoints);\n\n    TAILQ_INIT(&env->watchpoints);\n\n#if defined(TARGET_HAS_ICE)\n\n    TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_env, bp->pc, bp->flags, NULL);\n\n    }\n\n    TAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_env, wp->vaddr, (~wp->len_mask) + 1,\n\n                              wp->flags, NULL);\n\n    }\n\n#endif\n\n\n\n    return new_env;\n\n}\n","idx":234,"target":0}
{"code":"uint32_t lduw_be_phys(target_phys_addr_t addr)\n\n{\n\n    return lduw_phys_internal(addr, DEVICE_BIG_ENDIAN);\n\n}\n","idx":235,"target":0}
{"code":"xilinx_axidma_data_stream_push(StreamSlave *obj, unsigned char *buf, size_t len,\n\n                               uint32_t *app)\n\n{\n\n    XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(obj);\n\n    struct Stream *s = &ds->dma->streams[1];\n\n    size_t ret;\n\n\n\n    if (!app) {\n\n        hw_error(\"No stream app data!\\n\");\n\n    }\n\n    ret = stream_process_s2mem(s, buf, len, app);\n\n    stream_update_irq(s);\n\n    return ret;\n\n}\n","idx":236,"target":0}
{"code":"void *av_realloc(void *ptr, unsigned int size)\n\n{\n\n#ifdef MEMALIGN_HACK\n\n    int diff;\n\n#endif\n\n\n\n    \/* let's disallow possible ambiguous cases *\/\n\n    if(size > INT_MAX)\n\n        return NULL;\n\n\n\n#ifdef MEMALIGN_HACK\n\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n\n    if(!ptr) return av_malloc(size);\n\n    diff= ((char*)ptr)[-1];\n\n    return realloc(ptr - diff, size + diff) + diff;\n\n#else\n\n    return realloc(ptr, size);\n\n#endif\n\n}\n","idx":237,"target":0}
{"code":"static int mmf_probe(AVProbeData *p)\n\n{\n\n    \/* check file header *\/\n\n    if (p->buf_size <= 32)\n\n        return 0;\n\n    if (p->buf[0] == 'M' && p->buf[1] == 'M' &&\n\n        p->buf[2] == 'M' && p->buf[3] == 'D' &&\n\n        p->buf[8] == 'C' && p->buf[9] == 'N' &&\n\n        p->buf[10] == 'T' && p->buf[11] == 'I')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n","idx":238,"target":0}
{"code":"static XICSState *try_create_xics(const char *type, int nr_servers,\n\n                                  int nr_irqs)\n\n{\n\n    DeviceState *dev;\n\n\n\n    dev = qdev_create(NULL, type);\n\n    qdev_prop_set_uint32(dev, \"nr_servers\", nr_servers);\n\n    qdev_prop_set_uint32(dev, \"nr_irqs\", nr_irqs);\n\n    if (qdev_init(dev) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    return XICS_COMMON(dev);\n\n}\n","idx":239,"target":1}
{"code":"static VncServerInfo *vnc_server_info_get(VncDisplay *vd)\n\n{\n\n    VncServerInfo *info;\n\n    Error *err = NULL;\n\n\n\n    info = g_malloc(sizeof(*info));\n\n    vnc_init_basic_info_from_server_addr(vd->lsock,\n\n                                         qapi_VncServerInfo_base(info), &err);\n\n    info->has_auth = true;\n\n    info->auth = g_strdup(vnc_auth_name(vd));\n\n    if (err) {\n\n        qapi_free_VncServerInfo(info);\n\n        info = NULL;\n\n        error_free(err);\n\n    }\n\n    return info;\n\n}\n","idx":240,"target":1}
{"code":"static int vm_request_pending(void)\n\n{\n\n    return powerdown_requested ||\n\n           reset_requested ||\n\n           shutdown_requested ||\n\n           debug_requested ||\n\n           vmstop_requested;\n\n}\n","idx":241,"target":1}
{"code":"yuv2rgb_full_2_c_template(SwsContext *c, const int16_t *buf[2],\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum AVPixelFormat target, int hasAlpha)\n\n{\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int uvalpha1 = 4096 - uvalpha;\n\n    int i;\n\n    int step = (target == AV_PIX_FMT_RGB24 || target == AV_PIX_FMT_BGR24) ? 3 : 4;\n\n    int err[4] = {0};\n\n\n\n    if(   target == AV_PIX_FMT_BGR4_BYTE || target == AV_PIX_FMT_RGB4_BYTE\n\n       || target == AV_PIX_FMT_BGR8      || target == AV_PIX_FMT_RGB8)\n\n        step = 1;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = ( buf0[i] * yalpha1  +  buf1[i] * yalpha             ) >> 10; \/\/FIXME rounding\n\n        int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha-(128 << 19)) >> 10;\n\n        int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha-(128 << 19)) >> 10;\n\n        int A;\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i] * yalpha1 + abuf1[i] * yalpha + (1<<18)) >> 19;\n\n            if (A & 0x100)\n\n                A = av_clip_uint8(A);\n\n        }\n\n\n\n        yuv2rgb_write_full(c, dest, i, Y, A, U, V, y, target, hasAlpha, err);\n\n        dest += step;\n\n    }\n\n    c->dither_error[0][i] = err[0];\n\n    c->dither_error[1][i] = err[1];\n\n    c->dither_error[2][i] = err[2];\n\n}\n","idx":243,"target":1}
{"code":"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)\/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);","idx":244,"target":1}
{"code":"static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n","idx":246,"target":1}
{"code":"static void clone_slice(H264Context *dst, H264Context *src)\n\n{\n\n    memcpy(dst->block_offset, src->block_offset, sizeof(dst->block_offset));\n\n    dst->s.current_picture_ptr = src->s.current_picture_ptr;\n\n    dst->s.current_picture     = src->s.current_picture;\n\n    dst->s.linesize            = src->s.linesize;\n\n    dst->s.uvlinesize          = src->s.uvlinesize;\n\n    dst->s.first_field         = src->s.first_field;\n\n\n\n    dst->prev_poc_msb          = src->prev_poc_msb;\n\n    dst->prev_poc_lsb          = src->prev_poc_lsb;\n\n    dst->prev_frame_num_offset = src->prev_frame_num_offset;\n\n    dst->prev_frame_num        = src->prev_frame_num;\n\n    dst->short_ref_count       = src->short_ref_count;\n\n\n\n    memcpy(dst->short_ref,        src->short_ref,        sizeof(dst->short_ref));\n\n    memcpy(dst->long_ref,         src->long_ref,         sizeof(dst->long_ref));\n\n    memcpy(dst->default_ref_list, src->default_ref_list, sizeof(dst->default_ref_list));\n\n    memcpy(dst->ref_list,         src->ref_list,         sizeof(dst->ref_list));\n\n\n\n    memcpy(dst->dequant4_coeff,   src->dequant4_coeff,   sizeof(src->dequant4_coeff));\n\n    memcpy(dst->dequant8_coeff,   src->dequant8_coeff,   sizeof(src->dequant8_coeff));\n\n}\n","idx":247,"target":1}
{"code":"static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n","idx":248,"target":1}
{"code":"static inline void gen_op_arith_subf(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                     TCGv arg2, int add_ca, int compute_ca,\n\n                                     int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret, arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        \/* Start with XER CA disabled, the most likely case *\/\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        \/* Start with XER OV disabled, the most likely case *\/\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    if (add_ca) {\n\n        tcg_gen_not_tl(t0, arg1);\n\n        tcg_gen_add_tl(t0, t0, arg2);\n\n        gen_op_arith_compute_ca(ctx, t0, arg2, 0);\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    } else {\n\n        tcg_gen_sub_tl(t0, arg2, arg1);\n\n        if (compute_ca) {\n\n            gen_op_arith_compute_ca(ctx, t0, arg2, 1);\n\n        }\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 1);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n","idx":249,"target":1}
{"code":"static void mxf_packet_timestamps(MXFContext *mxf, AVPacket *pkt)\n\n{\n\n    int64_t last_ofs = -1, next_ofs;\n\n    MXFIndexTable *t = &mxf->index_tables[0];\n\n\n\n    \/* this is called from the OP1a demuxing logic, which means there\n\n     * may be no index tables *\/\n\n    if (mxf->nb_index_tables <= 0)\n\n        return;\n\n\n\n    \/* find mxf->current_edit_unit so that the next edit unit starts ahead of pkt->pos *\/\n\n    for (;;) {\n\n        if (mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit + 1, NULL, &next_ofs, 0) < 0)\n\n            break;\n\n\n\n        if (next_ofs <= last_ofs) {\n\n            \/* large next_ofs didn't change or current_edit_unit wrapped\n\n             * around this fixes the infinite loop on zzuf3.mxf *\/\n\n            av_log(mxf->fc, AV_LOG_ERROR,\n\n                   \"next_ofs didn't change. not deriving packet timestamps\\n\");\n\n            return;\n\n        }\n\n\n\n        if (next_ofs > pkt->pos)\n\n            break;\n\n\n\n        last_ofs = next_ofs;\n\n        mxf->current_edit_unit++;\n\n    }\n\n\n\n    if (mxf->current_edit_unit >= t->nb_ptses)\n\n        return;\n\n\n\n    pkt->dts = mxf->current_edit_unit + t->first_dts;\n\n    pkt->pts = t->ptses[mxf->current_edit_unit];\n\n}\n","idx":250,"target":1}
{"code":"static void ff_h264_idct_add16intra_mmx(uint8_t *dst, const int *block_offset, DCTELEM *block, int stride, const uint8_t nnzc[6*8]){\n\n    int i;\n\n    for(i=0; i<16; i++){\n\n        if(nnzc[ scan8[i] ] || block[i*16])\n\n            ff_h264_idct_add_mmx(dst + block_offset[i], block + i*16, stride);\n\n    }\n\n}\n","idx":251,"target":0}
{"code":"static void process_subpacket_9 (QDM2Context *q, QDM2SubPNode *node)\n\n{\n\n    GetBitContext gb;\n\n    int i, j, k, n, ch, run, level, diff;\n\n\n\n    init_get_bits(&gb, node->packet->data, node->packet->size*8);\n\n\n\n    n = coeff_per_sb_for_avg[q->coeff_per_sb_select][QDM2_SB_USED(q->sub_sampling) - 1] + 1; \/\/ same as averagesomething function\n\n\n\n    for (i = 1; i < n; i++)\n\n        for (ch=0; ch < q->nb_channels; ch++) {\n\n            level = qdm2_get_vlc(&gb, &vlc_tab_level, 0, 2);\n\n            q->quantized_coeffs[ch][i][0] = level;\n\n\n\n            for (j = 0; j < (8 - 1); ) {\n\n                run = qdm2_get_vlc(&gb, &vlc_tab_run, 0, 1) + 1;\n\n                diff = qdm2_get_se_vlc(&vlc_tab_diff, &gb, 2);\n\n\n\n                for (k = 1; k <= run; k++)\n\n                    q->quantized_coeffs[ch][i][j + k] = (level + ((k*diff) \/ run));\n\n\n\n                level += diff;\n\n                j += run;\n\n            }\n\n        }\n\n\n\n    for (ch = 0; ch < q->nb_channels; ch++)\n\n        for (i = 0; i < 8; i++)\n\n            q->quantized_coeffs[ch][0][i] = 0;\n\n}\n","idx":252,"target":0}
{"code":"static int find_stream_index(AVFormatContext *s)\n\n{\n\n    int i;\n\n    AVStream *st;\n\n\n\n    if (s->nb_streams <= 0)\n\n        return -1;\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n        if (st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n            return i;\n\n        }\n\n    }\n\n    return 0;\n\n}\n","idx":253,"target":0}
{"code":"static inline void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    \/* p0' *\/\n\n                pix[0]        = av_clip_uint8( q0 - delta );    \/* q0' *\/\n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}\n","idx":254,"target":0}
{"code":"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n                                    const uint8_t *src, const uint8_t *src_end,\n                                    int width, int esc_count)\n{\n    int i = 0;\n    int count;\n    uint8_t zero_run = 0;\n    const uint8_t *src_start = src;\n    uint8_t mask1 = -(esc_count < 2);\n    uint8_t mask2 = -(esc_count < 3);\n    uint8_t *end = dst + (width - 2);\noutput_zeros:\n    if (l->zeros_rem) {\n        count = FFMIN(l->zeros_rem, width - i);\n        if (end - dst < count) {\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        memset(dst, 0, count);\n        l->zeros_rem -= count;\n        dst += count;\n    }\n    while (dst < end) {\n        i = 0;\n        while (!zero_run && dst + i < end) {\n            i++;\n            if (i+2 >= src_end - src)\n                return AVERROR_INVALIDDATA;\n            zero_run =\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n        }\n        if (zero_run) {\n            zero_run = 0;\n            i += esc_count;\n            memcpy(dst, src, i);\n            dst += i;\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n            src += i + 1;\n            goto output_zeros;\n        } else {\n            memcpy(dst, src, i);\n            src += i;\n            dst += i;\n        }\n    }\n    return  src - src_start;\n}","idx":256,"target":1}
{"code":"static void parse_type_bool(Visitor *v, const char *name, bool *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (siv->string) {\n\n        if (!strcasecmp(siv->string, \"on\") ||\n\n            !strcasecmp(siv->string, \"yes\") ||\n\n            !strcasecmp(siv->string, \"true\")) {\n\n            *obj = true;\n\n            return;\n\n        }\n\n        if (!strcasecmp(siv->string, \"off\") ||\n\n            !strcasecmp(siv->string, \"no\") ||\n\n            !strcasecmp(siv->string, \"false\")) {\n\n            *obj = false;\n\n            return;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n               \"boolean\");\n\n}\n","idx":257,"target":1}
{"code":"static int mxf_read_close(AVFormatContext *s)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    MXFIndexTableSegment *seg;\n\n    int i;\n\n\n\n    av_freep(&mxf->packages_refs);\n\n\n\n    for (i = 0; i < s->nb_streams; i++)\n\n        s->streams[i]->priv_data = NULL;\n\n\n\n    for (i = 0; i < mxf->metadata_sets_count; i++) {\n\n        switch (mxf->metadata_sets[i]->type) {\n\n        case MultipleDescriptor:\n\n            av_freep(&((MXFDescriptor *)mxf->metadata_sets[i])->sub_descriptors_refs);\n\n            break;\n\n        case Sequence:\n\n            av_freep(&((MXFSequence *)mxf->metadata_sets[i])->structural_components_refs);\n\n            break;\n\n        case SourcePackage:\n\n        case MaterialPackage:\n\n            av_freep(&((MXFPackage *)mxf->metadata_sets[i])->tracks_refs);\n\n            break;\n\n        case IndexTableSegment:\n\n            seg = (MXFIndexTableSegment *)mxf->metadata_sets[i];\n\n            av_freep(&seg->temporal_offset_entries);\n\n            av_freep(&seg->flag_entries);\n\n            av_freep(&seg->stream_offset_entries);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        av_freep(&mxf->metadata_sets[i]);\n\n    }\n\n    av_freep(&mxf->partitions);\n\n    av_freep(&mxf->metadata_sets);\n\n    av_freep(&mxf->aesc);\n\n    av_freep(&mxf->local_tags);\n\n\n\n    for (i = 0; i < mxf->nb_index_tables; i++) {\n\n        av_freep(&mxf->index_tables[i].segments);\n\n        av_freep(&mxf->index_tables[i].ptses);\n\n        av_freep(&mxf->index_tables[i].fake_index);\n\n    }\n\n    av_freep(&mxf->index_tables);\n\n\n\n    return 0;\n\n}\n","idx":260,"target":1}
{"code":"static int adts_aac_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    int ret, fsize;\n\n\n\n    ret = av_get_packet(s->pb, pkt, ADTS_HEADER_SIZE);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (ret < ADTS_HEADER_SIZE) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    if ((AV_RB16(pkt->data) >> 4) != 0xfff) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    fsize = (AV_RB32(pkt->data + 3) >> 13) & 0x1FFF;\n\n    if (fsize < ADTS_HEADER_SIZE) {\n\n        av_packet_unref(pkt);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return av_append_packet(s->pb, pkt, fsize - ADTS_HEADER_SIZE);\n\n}\n","idx":261,"target":1}
{"code":"static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}","idx":262,"target":1}
{"code":"static int bgr24ToYv12Wrapper(SwsContext *c, const uint8_t *src[],\n\n                              int srcStride[], int srcSliceY, int srcSliceH,\n\n                              uint8_t *dst[], int dstStride[])\n\n{\n\n    rgb24toyv12(\n\n        src[0],\n\n        dst[0] +  srcSliceY       * dstStride[0],\n\n        dst[1] + (srcSliceY >> 1) * dstStride[1],\n\n        dst[2] + (srcSliceY >> 1) * dstStride[2],\n\n        c->srcW, srcSliceH,\n\n        dstStride[0], dstStride[1], srcStride[0]);\n\n    if (dst[3])\n\n        fillPlane(dst[3], dstStride[3], c->srcW, srcSliceH, srcSliceY, 255);\n\n    return srcSliceH;\n\n}\n","idx":263,"target":1}
{"code":"void rgb15tobgr32(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tconst uint16_t *end;\n\n\tuint8_t *d = (uint8_t *)dst;\n\n\tconst uint16_t *s = (const uint16_t *)src;\n\n\tend = s + src_size\/2;\n\n\twhile(s < end)\n\n\t{\n\n\t\tregister uint16_t bgr;\n\n\t\tbgr = *s++;\n\n\t\t*d++ = (bgr&0x7C00)>>7;\n\n\t\t*d++ = (bgr&0x3E0)>>2;\n\n\t\t*d++ = (bgr&0x1F)<<3;\n\n\t\t*d++ = 0;\n\n\t}\n\n}\n","idx":264,"target":1}
{"code":"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    \/* read the palette *\/\n\n    n = length \/ 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     \/* crc *\/\n\n\n\n    return 0;\n\n}\n","idx":265,"target":1}
{"code":"static int vp5_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n    int rows, cols;\n\n\n\n    ff_vp56_init_range_decoder(&s->c, buf, buf_size);\n\n    s->frames[VP56_FRAME_CURRENT]->key_frame = !vp56_rac_get(c);\n\n    vp56_rac_get(c);\n\n    ff_vp56_init_dequant(s, vp56_rac_gets(c, 6));\n\n    if (s->frames[VP56_FRAME_CURRENT]->key_frame)\n\n    {\n\n        vp56_rac_gets(c, 8);\n\n        if(vp56_rac_gets(c, 5) > 5)\n\n            return AVERROR_INVALIDDATA;\n\n        vp56_rac_gets(c, 2);\n\n        if (vp56_rac_get(c)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"interlacing not supported\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        rows = vp56_rac_gets(c, 8);  \/* number of stored macroblock rows *\/\n\n        cols = vp56_rac_gets(c, 8);  \/* number of stored macroblock cols *\/\n\n        if (!rows || !cols) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid size %dx%d\\n\",\n\n                   cols << 4, rows << 4);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        vp56_rac_gets(c, 8);  \/* number of displayed macroblock rows *\/\n\n        vp56_rac_gets(c, 8);  \/* number of displayed macroblock cols *\/\n\n        vp56_rac_gets(c, 2);\n\n        if (!s->macroblocks || \/* first frame *\/\n\n            16*cols != s->avctx->coded_width ||\n\n            16*rows != s->avctx->coded_height) {\n\n            int ret = ff_set_dimensions(s->avctx, 16 * cols, 16 * rows);\n\n            if (ret < 0)\n\n                return ret;\n\n            return VP56_SIZE_CHANGE;\n\n        }\n\n    } else if (!s->macroblocks)\n\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n\n}\n","idx":266,"target":1}
{"code":"static inline int coeff_unpack_golomb(GetBitContext *gb, int qfactor, int qoffset)\n\n{\n\n    int coeff = dirac_get_se_golomb(gb);\n\n    const int sign = FFSIGN(coeff);\n\n    if (coeff)\n\n        coeff = sign*((sign * coeff * qfactor + qoffset) >> 2);\n\n    return coeff;\n\n}\n","idx":267,"target":1}
{"code":"void ff_rtsp_undo_setup(AVFormatContext *s)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n\n        if (!rtsp_st)\n\n            continue;\n\n        if (rtsp_st->transport_priv) {\n\n            if (s->oformat) {\n\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n\n                av_write_trailer(rtpctx);\n\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    uint8_t *ptr;\n\n                    url_close_dyn_buf(rtpctx->pb, &ptr);\n\n                    av_free(ptr);\n\n                } else {\n\n                    url_fclose(rtpctx->pb);\n\n                }\n\n                av_metadata_free(&rtpctx->streams[0]->metadata);\n\n                av_metadata_free(&rtpctx->metadata);\n\n\n                av_free(rtpctx->streams[0]);\n\n                av_free(rtpctx);\n\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n\n            else if (CONFIG_RTPDEC)\n\n                rtp_parse_close(rtsp_st->transport_priv);\n\n        }\n\n        rtsp_st->transport_priv = NULL;\n\n        if (rtsp_st->rtp_handle)\n\n            url_close(rtsp_st->rtp_handle);\n\n        rtsp_st->rtp_handle = NULL;\n\n    }\n\n}","idx":268,"target":1}
{"code":"static void gen_rfe(DisasContext *s, TCGv_i32 pc, TCGv_i32 cpsr)\n\n{\n\n    gen_set_cpsr(cpsr, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(cpsr);\n\n    store_reg(s, 15, pc);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n","idx":270,"target":1}
{"code":"static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        \/* TODO: report error *\/\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        \/* Drop this interrupt *\/\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n","idx":272,"target":1}
{"code":"static void decode_ac_filter(WmallDecodeCtx *s)\n\n{\n\n    int i;\n\n    s->acfilter_order = get_bits(&s->gb, 4) + 1;\n\n    s->acfilter_scaling = get_bits(&s->gb, 4);\n\n\n\n    for(i = 0; i < s->acfilter_order; i++) {\n\n\ts->acfilter_coeffs[i] = get_bits(&s->gb, s->acfilter_scaling) + 1;\n\n    }\n\n}\n","idx":275,"target":1}
{"code":"QDict *qdict_get_qdict(const QDict *qdict, const char *key)\n\n{\n\n    return qobject_to_qdict(qdict_get_obj(qdict, key, QTYPE_QDICT));\n\n}\n","idx":279,"target":1}
{"code":"void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    \/* Discard written trace records *\/\n\n    trace_idx = 0;\n\n}\n","idx":280,"target":1}
{"code":"static int guess_ni_flag(AVFormatContext *s){\n\n    int i;\n\n    int64_t last_start=0;\n\n    int64_t first_end= INT64_MAX;\n\n    int64_t oldpos= avio_tell(s->pb);\n\n    int *idx;\n\n    int64_t min_pos, pos;\n\n\n\n    for(i=0; i<s->nb_streams; i++){\n\n        AVStream *st = s->streams[i];\n\n        int n= st->nb_index_entries;\n\n        unsigned int size;\n\n\n\n        if(n <= 0)\n\n            continue;\n\n\n\n        if(n >= 2){\n\n            int64_t pos= st->index_entries[0].pos;\n\n            avio_seek(s->pb, pos + 4, SEEK_SET);\n\n            size= avio_rl32(s->pb);\n\n            if(pos + size > st->index_entries[1].pos)\n\n                last_start= INT64_MAX;\n\n        }\n\n\n\n        if(st->index_entries[0].pos > last_start)\n\n            last_start= st->index_entries[0].pos;\n\n        if(st->index_entries[n-1].pos < first_end)\n\n            first_end= st->index_entries[n-1].pos;\n\n    }\n\n    avio_seek(s->pb, oldpos, SEEK_SET);\n\n    if (last_start > first_end)\n\n        return 1;\n\n    idx= av_mallocz(sizeof(*idx) * s->nb_streams);\n\n    for (min_pos=pos=0; min_pos!=INT64_MAX; pos= min_pos+1) {\n\n        int64_t max_dts = INT64_MIN\/2, min_dts= INT64_MAX\/2;\n\n        min_pos = INT64_MAX;\n\n\n\n        for (i=0; i<s->nb_streams; i++) {\n\n            AVStream *st = s->streams[i];\n\n            int n= st->nb_index_entries;\n\n            while (idx[i]<n && st->index_entries[idx[i]].pos < pos)\n\n                idx[i]++;\n\n            if (idx[i] < n) {\n\n                min_dts = FFMIN(min_dts, av_rescale_q(st->index_entries[idx[i]].timestamp, st->time_base, AV_TIME_BASE_Q));\n\n                min_pos = FFMIN(min_pos, st->index_entries[idx[i]].pos);\n\n            }\n\n            if (idx[i])\n\n                max_dts = FFMAX(max_dts, av_rescale_q(st->index_entries[idx[i]-1].timestamp, st->time_base, AV_TIME_BASE_Q));\n\n        }\n\n        if(max_dts - min_dts > 2*AV_TIME_BASE) {\n\n            av_free(idx);\n\n            return 1;\n\n        }\n\n    }\n\n    av_free(idx);\n\n    return 0;\n\n}\n","idx":281,"target":1}
{"code":"static int nut_write_trailer(AVFormatContext *s)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    AVIOContext *bc = s->pb, *dyn_bc;\n\n    int i, ret;\n\n\n\n    while (nut->header_count < 3)\n\n        write_headers(s, bc);\n\n\n\n    ret = avio_open_dyn_buf(&dyn_bc);\n\n    if (ret >= 0 && nut->sp_count) {\n\n        av_assert1(nut->write_index);\n\n        write_index(nut, dyn_bc);\n\n        put_packet(nut, bc, dyn_bc, 1, INDEX_STARTCODE);\n\n    }\n\n\n\n    ff_nut_free_sp(nut);\n\n    for (i=0; i<s->nb_streams; i++)\n\n        av_freep(&nut->stream[i].keyframe_pts);\n\n\n\n    av_freep(&nut->stream);\n\n    av_freep(&nut->chapter);\n\n    av_freep(&nut->time_base);\n\n\n\n    return 0;\n\n}\n","idx":282,"target":1}
{"code":"static uint32_t arm_ldl_ptw(CPUState *cs, hwaddr addr, bool is_secure,\n\n                            ARMMMUIdx mmu_idx, ARMMMUFaultInfo *fi)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    MemTxAttrs attrs = {};\n\n    AddressSpace *as;\n\n\n\n    attrs.secure = is_secure;\n\n    as = arm_addressspace(cs, attrs);\n\n    addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fi);\n\n    if (fi->s1ptw) {\n\n        return 0;\n\n    }\n\n    if (regime_translation_big_endian(env, mmu_idx)) {\n\n        return address_space_ldl_be(as, addr, attrs, NULL);\n\n    } else {\n\n        return address_space_ldl_le(as, addr, attrs, NULL);\n\n    }\n\n}\n","idx":283,"target":1}
{"code":"void aio_context_acquire(AioContext *ctx)\n\n{\n\n    qemu_rec_mutex_lock(&ctx->lock);\n\n}\n","idx":284,"target":0}
{"code":"static void qjson_finalizefn(Object *obj)\n\n{\n\n    QJSON *json = QJSON(obj);\n\n\n\n    qobject_decref(QOBJECT(json->str));\n\n}\n","idx":285,"target":0}
{"code":"static void visitor_output_setup(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    data->qov = qmp_output_visitor_new();\n\n    g_assert(data->qov != NULL);\n\n\n\n    data->ov = qmp_output_get_visitor(data->qov);\n\n    g_assert(data->ov != NULL);\n\n}\n","idx":287,"target":0}
{"code":"static void group_exponents(AC3EncodeContext *s)\n\n{\n\n    int blk, ch, i;\n\n    int group_size, nb_groups, bit_count;\n\n    uint8_t *p;\n\n    int delta0, delta1, delta2;\n\n    int exp0, exp1;\n\n\n\n    bit_count = 0;\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        AC3Block *block = &s->blocks[blk];\n\n        for (ch = 0; ch < s->channels; ch++) {\n\n            if (s->exp_strategy[ch][blk] == EXP_REUSE)\n\n                continue;\n\n            group_size = s->exp_strategy[ch][blk] + (s->exp_strategy[ch][blk] == EXP_D45);\n\n            nb_groups = exponent_group_tab[s->exp_strategy[ch][blk]-1][s->nb_coefs[ch]];\n\n            bit_count += 4 + (nb_groups * 7);\n\n            p = block->exp[ch];\n\n\n\n            \/* DC exponent *\/\n\n            exp1 = *p++;\n\n            block->grouped_exp[ch][0] = exp1;\n\n\n\n            \/* remaining exponents are delta encoded *\/\n\n            for (i = 1; i <= nb_groups; i++) {\n\n                \/* merge three delta in one code *\/\n\n                exp0   = exp1;\n\n                exp1   = p[0];\n\n                p     += group_size;\n\n                delta0 = exp1 - exp0 + 2;\n\n\n\n                exp0   = exp1;\n\n                exp1   = p[0];\n\n                p     += group_size;\n\n                delta1 = exp1 - exp0 + 2;\n\n\n\n                exp0   = exp1;\n\n                exp1   = p[0];\n\n                p     += group_size;\n\n                delta2 = exp1 - exp0 + 2;\n\n\n\n                block->grouped_exp[ch][i] = ((delta0 * 5 + delta1) * 5) + delta2;\n\n            }\n\n        }\n\n    }\n\n\n\n    s->exponent_bits = bit_count;\n\n}\n","idx":288,"target":0}
{"code":"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        \/* try to fall back to value set with legacy -drive serial=... *\/\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size \/ BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"\/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n","idx":289,"target":0}
{"code":"int event_notifier_get_fd(EventNotifier *e)\n\n{\n\n    return e->fd;\n\n}\n","idx":291,"target":0}
{"code":"static uint64_t sp804_read(void *opaque, target_phys_addr_t offset,\n\n                           unsigned size)\n\n{\n\n    sp804_state *s = (sp804_state *)opaque;\n\n\n\n    if (offset < 0x20) {\n\n        return arm_timer_read(s->timer[0], offset);\n\n    }\n\n    if (offset < 0x40) {\n\n        return arm_timer_read(s->timer[1], offset - 0x20);\n\n    }\n\n\n\n    \/* TimerPeriphID *\/\n\n    if (offset >= 0xfe0 && offset <= 0xffc) {\n\n        return sp804_ids[(offset - 0xfe0) >> 2];\n\n    }\n\n\n\n    switch (offset) {\n\n    \/* Integration Test control registers, which we won't support *\/\n\n    case 0xf00: \/* TimerITCR *\/\n\n    case 0xf04: \/* TimerITOP (strictly write only but..) *\/\n\n        return 0;\n\n    }\n\n\n\n    hw_error(\"%s: Bad offset %x\\n\", __func__, (int)offset);\n\n    return 0;\n\n}\n","idx":292,"target":0}
{"code":"opts_type_size(Visitor *v, const char *name, uint64_t *obj, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    const QemuOpt *opt;\n\n    int64_t val;\n\n\n\n    opt = lookup_scalar(ov, name, errp);\n\n    if (!opt) {\n\n        return;\n\n    }\n\n\n\n    val = qemu_strtosz(opt->str ? opt->str : \"\", NULL);\n\n    if (val < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, opt->name,\n\n                   \"a size value representible as a non-negative int64\");\n\n        return;\n\n    }\n\n\n\n    *obj = val;\n\n    processed(ov, name);\n\n}\n","idx":293,"target":0}
{"code":"static void handle_mousemotion(SDL_Event *ev)\n\n{\n\n    int max_x, max_y;\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n\n\n    if (qemu_input_is_absolute() || absolute_enabled) {\n\n        int scr_w, scr_h;\n\n        SDL_GetWindowSize(scon->real_window, &scr_w, &scr_h);\n\n        max_x = scr_w - 1;\n\n        max_y = scr_h - 1;\n\n        if (gui_grab && (ev->motion.x == 0 || ev->motion.y == 0 ||\n\n                         ev->motion.x == max_x || ev->motion.y == max_y)) {\n\n            sdl_grab_end(scon);\n\n        }\n\n        if (!gui_grab &&\n\n            (ev->motion.x > 0 && ev->motion.x < max_x &&\n\n             ev->motion.y > 0 && ev->motion.y < max_y)) {\n\n            sdl_grab_start(scon);\n\n        }\n\n    }\n\n    if (gui_grab || qemu_input_is_absolute() || absolute_enabled) {\n\n        sdl_send_mouse_event(scon, ev->motion.xrel, ev->motion.yrel,\n\n                             ev->motion.x, ev->motion.y, ev->motion.state);\n\n    }\n\n}\n","idx":294,"target":0}
{"code":"static void xen_platform_ioport_writeb(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIXenPlatformState *s = opaque;\n\n\n\n    addr &= 0xff;\n\n    val  &= 0xff;\n\n\n\n    switch (addr) {\n\n    case 0: \/* Platform flags *\/\n\n        platform_fixed_ioport_writeb(opaque, XEN_PLATFORM_IOPORT, val);\n\n        break;\n\n    case 8:\n\n        log_writeb(s, val);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n","idx":296,"target":0}
{"code":"static uint32_t nabm_readb (void *opaque, uint32_t addr)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    AC97BusMasterRegs *r = NULL;\n\n    uint32_t index = addr - s->base[1];\n\n    uint32_t val = ~0U;\n\n\n\n    switch (index) {\n\n    case CAS:\n\n        dolog (\"CAS %d\\n\", s->cas);\n\n        val = s->cas;\n\n        s->cas = 1;\n\n        break;\n\n    case PI_CIV:\n\n    case PO_CIV:\n\n    case MC_CIV:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->civ;\n\n        dolog (\"CIV[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_LVI:\n\n    case PO_LVI:\n\n    case MC_LVI:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->lvi;\n\n        dolog (\"LVI[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_PIV:\n\n    case PO_PIV:\n\n    case MC_PIV:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->piv;\n\n        dolog (\"PIV[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_CR:\n\n    case PO_CR:\n\n    case MC_CR:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->cr;\n\n        dolog (\"CR[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    case PI_SR:\n\n    case PO_SR:\n\n    case MC_SR:\n\n        r = &s->bm_regs[GET_BM (index)];\n\n        val = r->sr & 0xff;\n\n        dolog (\"SRb[%d] -> %#x\\n\", GET_BM (index), val);\n\n        break;\n\n    default:\n\n        dolog (\"U nabm readb %#x -> %#x\\n\", addr, val);\n\n        break;\n\n    }\n\n    return val;\n\n}\n","idx":297,"target":0}
{"code":"static void timerlist_rearm(QEMUTimerList *timer_list)\n\n{\n\n    \/* Interrupt execution to force deadline recalculation.  *\/\n\n    if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {\n\n        qemu_start_warp_timer();\n\n    }\n\n    timerlist_notify(timer_list);\n\n}\n","idx":298,"target":0}
{"code":"static int ac3_encode_frame(AVCodecContext *avctx,\n\n                            unsigned char *frame, int buf_size, void *data)\n\n{\n\n    AC3EncodeContext *s = avctx->priv_data;\n\n    const int16_t *samples = data;\n\n    int16_t planar_samples[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE+AC3_FRAME_SIZE];\n\n    int32_t mdct_coef[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    uint8_t exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    uint8_t exp_strategy[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];\n\n    uint8_t encoded_exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    uint8_t num_exp_groups[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];\n\n    uint8_t grouped_exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_EXP_GROUPS];\n\n    uint8_t bap[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    int8_t exp_shift[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];\n\n    uint16_t qmant[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];\n\n    int frame_bits;\n\n\n\n    if (s->bit_alloc.sr_code == 1)\n\n        adjust_frame_size(s);\n\n\n\n    deinterleave_input_samples(s, samples, planar_samples);\n\n\n\n    apply_mdct(s, planar_samples, exp_shift, mdct_coef);\n\n\n\n    frame_bits = process_exponents(s, mdct_coef, exp_shift, exp, exp_strategy,\n\n                                   encoded_exp, num_exp_groups, grouped_exp);\n\n\n\n    compute_bit_allocation(s, bap, encoded_exp, exp_strategy, frame_bits);\n\n\n\n    quantize_mantissas(s, mdct_coef, exp_shift, encoded_exp, bap, qmant);\n\n\n\n    output_frame(s, frame, exp_strategy, num_exp_groups, grouped_exp, bap, qmant);\n\n\n\n    return s->frame_size;\n\n}\n","idx":299,"target":0}
{"code":"CharDriverState *text_console_init(DisplayState *ds, const char *p)\n\n{\n\n    CharDriverState *chr;\n\n    TextConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n    static int color_inited;\n\n\n\n    chr = qemu_mallocz(sizeof(CharDriverState));\n\n    if (!chr)\n\n        return NULL;\n\n    s = new_console(ds, TEXT_CONSOLE);\n\n    if (!s) {\n\n        free(chr);\n\n        return NULL;\n\n    }\n\n    if (!p)\n\n        p = DEFAULT_MONITOR_SIZE;\n\n\n\n    chr->opaque = s;\n\n    chr->chr_write = console_puts;\n\n    chr->chr_send_event = console_send_event;\n\n\n\n    s->chr = chr;\n\n    s->out_fifo.buf = s->out_fifo_buf;\n\n    s->out_fifo.buf_size = sizeof(s->out_fifo_buf);\n\n    s->kbd_timer = qemu_new_timer(rt_clock, kbd_send_chars, s);\n\n\n\n    if (!color_inited) {\n\n        color_inited = 1;\n\n        console_color_init(s->ds);\n\n    }\n\n    s->y_displayed = 0;\n\n    s->y_base = 0;\n\n    s->total_height = DEFAULT_BACKSCROLL;\n\n    s->x = 0;\n\n    s->y = 0;\n\n    width = s->ds->width;\n\n    height = s->ds->height;\n\n    if (p != 0) {\n\n        width = strtoul(p, (char **)&p, 10);\n\n        if (*p == 'C') {\n\n            p++;\n\n            width *= FONT_WIDTH;\n\n        }\n\n        if (*p == 'x') {\n\n            p++;\n\n            height = strtoul(p, (char **)&p, 10);\n\n            if (*p == 'C') {\n\n                p++;\n\n                height *= FONT_HEIGHT;\n\n            }\n\n        }\n\n    }\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n\n\n    s->hw_invalidate = text_console_invalidate;\n\n    s->hw_text_update = text_console_update;\n\n    s->hw = s;\n\n\n\n    \/* Set text attribute defaults *\/\n\n    s->t_attrib_default.bold = 0;\n\n    s->t_attrib_default.uline = 0;\n\n    s->t_attrib_default.blink = 0;\n\n    s->t_attrib_default.invers = 0;\n\n    s->t_attrib_default.unvisible = 0;\n\n    s->t_attrib_default.fgcol = COLOR_WHITE;\n\n    s->t_attrib_default.bgcol = COLOR_BLACK;\n\n\n\n    \/* set current text attributes to default *\/\n\n    s->t_attrib = s->t_attrib_default;\n\n    text_console_resize(s);\n\n\n\n    qemu_chr_reset(chr);\n\n\n\n    return chr;\n\n}\n","idx":300,"target":0}
{"code":"void cpu_physical_memory_write_rom(target_phys_addr_t addr,\n\n                                   const uint8_t *buf, int len)\n\n{\n\n    AddressSpaceDispatch *d = address_space_memory.dispatch;\n\n    int l;\n\n    uint8_t *ptr;\n\n    target_phys_addr_t page;\n\n    MemoryRegionSection *section;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        section = phys_page_find(d, page >> TARGET_PAGE_BITS);\n\n\n\n        if (!(memory_region_is_ram(section->mr) ||\n\n              memory_region_is_romd(section->mr))) {\n\n            \/* do nothing *\/\n\n        } else {\n\n            unsigned long addr1;\n\n            addr1 = memory_region_get_ram_addr(section->mr)\n\n                + memory_region_section_addr(section, addr);\n\n            \/* ROM\/RAM case *\/\n\n            ptr = qemu_get_ram_ptr(addr1);\n\n            memcpy(ptr, buf, l);\n\n            invalidate_and_set_dirty(addr1, l);\n\n            qemu_put_ram_ptr(ptr);\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n}\n","idx":302,"target":0}
{"code":"av_cold int ff_lpc_init(LPCContext *s, int blocksize, int max_order,\n\n                        enum FFLPCType lpc_type)\n\n{\n\n    s->blocksize = blocksize;\n\n    s->max_order = max_order;\n\n    s->lpc_type  = lpc_type;\n\n\n\n    if (lpc_type == FF_LPC_TYPE_LEVINSON) {\n\n        s->windowed_samples = av_mallocz((blocksize + max_order + 2) *\n\n                                         sizeof(*s->windowed_samples));\n\n        if (!s->windowed_samples)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        s->windowed_samples = NULL;\n\n    }\n\n\n\n    s->lpc_apply_welch_window = lpc_apply_welch_window_c;\n\n    s->lpc_compute_autocorr   = lpc_compute_autocorr_c;\n\n\n\n    if (HAVE_MMX)\n\n        ff_lpc_init_x86(s);\n\n\n\n    return 0;\n\n}\n","idx":303,"target":1}
{"code":"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n","idx":304,"target":1}
{"code":"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n","idx":305,"target":1}
{"code":"void YM3812UpdateOne(FM_OPL *OPL, INT16 *buffer, int length)\n\n{\n\n    int i;\n\n\tint data;\n\n\tOPLSAMPLE *buf = buffer;\n\n\tUINT32 amsCnt  = OPL->amsCnt;\n\n\tUINT32 vibCnt  = OPL->vibCnt;\n\n\tUINT8 rythm = OPL->rythm&0x20;\n\n\tOPL_CH *CH,*R_CH;\n\n\n\n\tif( (void *)OPL != cur_chip ){\n\n\t\tcur_chip = (void *)OPL;\n\n\t\t\/* channel pointers *\/\n\n\t\tS_CH = OPL->P_CH;\n\n\t\tE_CH = &S_CH[9];\n\n\t\t\/* rythm slot *\/\n\n\t\tSLOT7_1 = &S_CH[7].SLOT[SLOT1];\n\n\t\tSLOT7_2 = &S_CH[7].SLOT[SLOT2];\n\n\t\tSLOT8_1 = &S_CH[8].SLOT[SLOT1];\n\n\t\tSLOT8_2 = &S_CH[8].SLOT[SLOT2];\n\n\t\t\/* LFO state *\/\n\n\t\tamsIncr = OPL->amsIncr;\n\n\t\tvibIncr = OPL->vibIncr;\n\n\t\tams_table = OPL->ams_table;\n\n\t\tvib_table = OPL->vib_table;\n\n\t}\n\n\tR_CH = rythm ? &S_CH[6] : E_CH;\n\n    for( i=0; i < length ; i++ )\n\n\t{\n\n\t\t\/*            channel A         channel B         channel C      *\/\n\n\t\t\/* LFO *\/\n\n\t\tams = ams_table[(amsCnt+=amsIncr)>>AMS_SHIFT];\n\n\t\tvib = vib_table[(vibCnt+=vibIncr)>>VIB_SHIFT];\n\n\t\toutd[0] = 0;\n\n\t\t\/* FM part *\/\n\n\t\tfor(CH=S_CH ; CH < R_CH ; CH++)\n\n\t\t\tOPL_CALC_CH(CH);\n\n\t\t\/* Rythn part *\/\n\n\t\tif(rythm)\n\n\t\t\tOPL_CALC_RH(S_CH);\n\n\t\t\/* limit check *\/\n\n\t\tdata = Limit( outd[0] , OPL_MAXOUT, OPL_MINOUT );\n\n\t\t\/* store to sound buffer *\/\n\n\t\tbuf[i] = data >> OPL_OUTSB;\n\n\t}\n\n\n\n\tOPL->amsCnt = amsCnt;\n\n\tOPL->vibCnt = vibCnt;\n\n#ifdef OPL_OUTPUT_LOG\n\n\tif(opl_dbg_fp)\n\n\t{\n\n\t\tfor(opl_dbg_chip=0;opl_dbg_chip<opl_dbg_maxchip;opl_dbg_chip++)\n\n\t\t\tif( opl_dbg_opl[opl_dbg_chip] == OPL) break;\n\n\t\tfprintf(opl_dbg_fp,\"%c%c%c\",0x20+opl_dbg_chip,length&0xff,length\/256);\n\n\t}\n\n#endif\n\n}\n","idx":307,"target":0}
{"code":"static void omap_tipb_bridge_write(void *opaque, target_phys_addr_t addr,\n\n                                   uint64_t value, unsigned size)\n\n{\n\n    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *) opaque;\n\n\n\n    if (size < 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t\/* TIPB_CNTL *\/\n\n        s->control = value & 0xffff;\n\n        break;\n\n\n\n    case 0x04:\t\/* TIPB_BUS_ALLOC *\/\n\n        s->alloc = value & 0x003f;\n\n        break;\n\n\n\n    case 0x08:\t\/* MPU_TIPB_CNTL *\/\n\n        s->buffer = value & 0x0003;\n\n        break;\n\n\n\n    case 0x0c:\t\/* ENHANCED_TIPB_CNTL *\/\n\n        s->width_intr = !(value & 2);\n\n        s->enh_control = value & 0x000f;\n\n        break;\n\n\n\n    case 0x10:\t\/* ADDRESS_DBG *\/\n\n    case 0x14:\t\/* DATA_DEBUG_LOW *\/\n\n    case 0x18:\t\/* DATA_DEBUG_HIGH *\/\n\n    case 0x1c:\t\/* DEBUG_CNTR_SIG *\/\n\n        OMAP_RO_REG(addr);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n","idx":308,"target":0}
{"code":"PCIDevice *pci_register_device(PCIBus *bus, const char *name,\n\n                               int instance_size, int devfn,\n\n                               PCIConfigReadFunc *config_read,\n\n                               PCIConfigWriteFunc *config_write)\n\n{\n\n    PCIDevice *pci_dev;\n\n\n\n    pci_dev = qemu_mallocz(instance_size);\n\n    pci_dev = do_pci_register_device(pci_dev, bus, name, devfn,\n\n                                     config_read, config_write);\n\n    return pci_dev;\n\n}\n","idx":309,"target":0}
{"code":"int64 float64_to_int64_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    bits64 aSig;\n\n    int64 z;\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( aExp ) aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = aExp - 0x433;\n\n    if ( 0 <= shiftCount ) {\n\n        if ( 0x43E <= aExp ) {\n\n            if ( a != LIT64( 0xC3E0000000000000 ) ) {\n\n                float_raise( float_flag_invalid STATUS_VAR);\n\n                if (    ! aSign\n\n                     || (    ( aExp == 0x7FF )\n\n                          && ( aSig != LIT64( 0x0010000000000000 ) ) )\n\n                   ) {\n\n                    return LIT64( 0x7FFFFFFFFFFFFFFF );\n\n                }\n\n            }\n\n            return (sbits64) LIT64( 0x8000000000000000 );\n\n        }\n\n        z = aSig<<shiftCount;\n\n    }\n\n    else {\n\n        if ( aExp < 0x3FE ) {\n\n            if ( aExp | aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n            return 0;\n\n        }\n\n        z = aSig>>( - shiftCount );\n\n        if ( (bits64) ( aSig<<( shiftCount & 63 ) ) ) {\n\n            STATUS(float_exception_flags) |= float_flag_inexact;\n\n        }\n\n    }\n\n    if ( aSign ) z = - z;\n\n    return z;\n\n\n\n}\n","idx":310,"target":0}
{"code":"bool error_is_type(Error *err, const char *fmt)\n\n{\n\n    const char *error_class;\n\n    char *ptr;\n\n    char *end;\n\n\n\n    if (!err) {\n\n        return false;\n\n    }\n\n\n\n    ptr = strstr(fmt, \"'class': '\");\n\n    assert(ptr != NULL);\n\n    ptr += strlen(\"'class': '\");\n\n\n\n    end = strchr(ptr, '\\'');\n\n    assert(end != NULL);\n\n\n\n    error_class = error_get_field(err, \"class\");\n\n    if (strlen(error_class) != end - ptr) {\n\n        return false;\n\n    }\n\n\n\n    return strncmp(ptr, error_class, end - ptr) == 0;\n\n}\n","idx":311,"target":0}
{"code":"static void icount_warp_rt(void)\n\n{\n\n    unsigned seq;\n\n    int64_t warp_start;\n\n\n\n    \/* The icount_warp_timer is rescheduled soon after vm_clock_warp_start\n\n     * changes from -1 to another value, so the race here is okay.\n\n     *\/\n\n    do {\n\n        seq = seqlock_read_begin(&timers_state.vm_clock_seqlock);\n\n        warp_start = vm_clock_warp_start;\n\n    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, seq));\n\n\n\n    if (warp_start == -1) {\n\n        return;\n\n    }\n\n\n\n    seqlock_write_begin(&timers_state.vm_clock_seqlock);\n\n    if (runstate_is_running()) {\n\n        int64_t clock = REPLAY_CLOCK(REPLAY_CLOCK_VIRTUAL_RT,\n\n                                     cpu_get_clock_locked());\n\n        int64_t warp_delta;\n\n\n\n        warp_delta = clock - vm_clock_warp_start;\n\n        if (use_icount == 2) {\n\n            \/*\n\n             * In adaptive mode, do not let QEMU_CLOCK_VIRTUAL run too\n\n             * far ahead of real time.\n\n             *\/\n\n            int64_t cur_icount = cpu_get_icount_locked();\n\n            int64_t delta = clock - cur_icount;\n\n            warp_delta = MIN(warp_delta, delta);\n\n        }\n\n        timers_state.qemu_icount_bias += warp_delta;\n\n    }\n\n    vm_clock_warp_start = -1;\n\n    seqlock_write_end(&timers_state.vm_clock_seqlock);\n\n\n\n    if (qemu_clock_expired(QEMU_CLOCK_VIRTUAL)) {\n\n        qemu_clock_notify(QEMU_CLOCK_VIRTUAL);\n\n    }\n\n}\n","idx":312,"target":0}
{"code":"void bdrv_aio_cancel(BlockAIOCB *acb)\n\n{\n\n    qemu_aio_ref(acb);\n\n    bdrv_aio_cancel_async(acb);\n\n    while (acb->refcnt > 1) {\n\n        if (acb->aiocb_info->get_aio_context) {\n\n            aio_poll(acb->aiocb_info->get_aio_context(acb), true);\n\n        } else if (acb->bs) {\n\n            aio_poll(bdrv_get_aio_context(acb->bs), true);\n\n        } else {\n\n            abort();\n\n        }\n\n    }\n\n    qemu_aio_unref(acb);\n\n}\n","idx":313,"target":0}
{"code":"static void vnc_listen_read(void *opaque, bool websocket)\n\n{\n\n    VncDisplay *vs = opaque;\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int csock;\n\n\n\n    \/* Catch-up *\/\n\n    graphic_hw_update(vs->dcl.con);\n\n#ifdef CONFIG_VNC_WS\n\n    if (websocket) {\n\n        csock = qemu_accept(vs->lwebsock, (struct sockaddr *)&addr, &addrlen);\n\n    } else\n\n#endif \/* CONFIG_VNC_WS *\/\n\n    {\n\n        csock = qemu_accept(vs->lsock, (struct sockaddr *)&addr, &addrlen);\n\n    }\n\n\n\n    if (csock != -1) {\n\n        socket_set_nodelay(csock);\n\n        vnc_connect(vs, csock, false, websocket);\n\n    }\n\n}\n","idx":314,"target":0}
{"code":"static void gen_sraq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_sar_tl(t1, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_subfi_tl(t2, 32, t2);\n\n    tcg_gen_shl_tl(t2, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_or_tl(t0, t0, t2);\n\n    gen_store_spr(SPR_MQ, t0);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, l1);\n\n    tcg_gen_mov_tl(t2, cpu_gpr[rS(ctx->opcode)]);\n\n    tcg_gen_sari_tl(t1, cpu_gpr[rS(ctx->opcode)], 31);\n\n    gen_set_label(l1);\n\n    tcg_temp_free(t0);\n\n    tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], t1);\n\n    tcg_gen_movi_tl(cpu_ca, 0);\n\n    tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l2);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, l2);\n\n    tcg_gen_movi_tl(cpu_ca, 1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n","idx":315,"target":0}
{"code":"static PhysPageDesc *phys_page_find_alloc(target_phys_addr_t index, int alloc)\n\n{\n\n    void **lp, **p;\n\n\n\n    p = (void **)l1_phys_map;\n\n#if TARGET_PHYS_ADDR_SPACE_BITS > 32\n\n\n\n#if TARGET_PHYS_ADDR_SPACE_BITS > (32 + L1_BITS)\n\n#error unsupported TARGET_PHYS_ADDR_SPACE_BITS\n\n#endif\n\n    lp = p + ((index >> (L1_BITS + L2_BITS)) & (L1_SIZE - 1));\n\n    p = *lp;\n\n    if (!p) {\n\n        \/* allocate if not found *\/\n\n        if (!alloc)\n\n            return NULL;\n\n        p = qemu_vmalloc(sizeof(void *) * L1_SIZE);\n\n        memset(p, 0, sizeof(void *) * L1_SIZE);\n\n        *lp = p;\n\n    }\n\n#endif\n\n    lp = p + ((index >> L2_BITS) & (L1_SIZE - 1));\n\n    p = *lp;\n\n    if (!p) {\n\n        \/* allocate if not found *\/\n\n        if (!alloc)\n\n            return NULL;\n\n        p = qemu_vmalloc(sizeof(PhysPageDesc) * L2_SIZE);\n\n        memset(p, 0, sizeof(PhysPageDesc) * L2_SIZE);\n\n        *lp = p;\n\n    }\n\n    return ((PhysPageDesc *)p) + (index & (L2_SIZE - 1));\n\n}\n","idx":317,"target":0}
{"code":"static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    if (s->bdrv_cur)\n\n        return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0;\n\n    else if (sec + secn > s->secs_cur)\n\n        return 1;\n\n\n\n    memcpy(dest, s->current + (sec << 9), secn << 9);\n\n\n\n    return 0;\n\n}\n","idx":319,"target":0}
{"code":"static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n","idx":321,"target":0}
{"code":"void s390_pci_sclp_configure(SCCB *sccb)\n\n{\n\n    PciCfgSccb *psccb = (PciCfgSccb *)sccb;\n\n    S390PCIBusDevice *pbdev = s390_pci_find_dev_by_fid(be32_to_cpu(psccb->aid));\n\n    uint16_t rc;\n\n\n\n    if (be16_to_cpu(sccb->h.length) < 16) {\n\n        rc = SCLP_RC_INSUFFICIENT_SCCB_LENGTH;\n\n        goto out;\n\n    }\n\n\n\n    if (pbdev) {\n\n        if (pbdev->configured) {\n\n            rc = SCLP_RC_NO_ACTION_REQUIRED;\n\n        } else {\n\n            pbdev->configured = true;\n\n            rc = SCLP_RC_NORMAL_COMPLETION;\n\n        }\n\n    } else {\n\n        DPRINTF(\"sclp config no dev found\\n\");\n\n        rc = SCLP_RC_ADAPTER_ID_NOT_RECOGNIZED;\n\n    }\n\nout:\n\n    psccb->header.response_code = cpu_to_be16(rc);\n\n}\n","idx":322,"target":0}
{"code":"static BlockJob *find_block_job(const char *device)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs || !bs->job) {\n\n        return NULL;\n\n    }\n\n    return bs->job;\n\n}\n","idx":323,"target":0}
{"code":"static void usb_host_realize(USBDevice *udev, Error **errp)\n\n{\n\n    USBHostDevice *s = USB_HOST_DEVICE(udev);\n\n\n\n    if (s->match.vendor_id > 0xffff) {\n\n        error_setg(errp, \"vendorid out of range\");\n\n        return;\n\n    }\n\n    if (s->match.product_id > 0xffff) {\n\n        error_setg(errp, \"productid out of range\");\n\n        return;\n\n    }\n\n    if (s->match.addr > 127) {\n\n        error_setg(errp, \"hostaddr out of range\");\n\n        return;\n\n    }\n\n\n\n    loglevel = s->loglevel;\n\n    udev->flags |= (1 << USB_DEV_FLAG_IS_HOST);\n\n    udev->auto_attach = 0;\n\n    QTAILQ_INIT(&s->requests);\n\n    QTAILQ_INIT(&s->isorings);\n\n\n\n    s->exit.notify = usb_host_exit_notifier;\n\n    qemu_add_exit_notifier(&s->exit);\n\n\n\n    QTAILQ_INSERT_TAIL(&hostdevs, s, next);\n\n    usb_host_auto_check(NULL);\n\n}\n","idx":324,"target":0}
{"code":"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n","idx":325,"target":0}
{"code":"static void rtas_int_off(sPAPREnvironment *spapr, uint32_t token,\n\n                         uint32_t nargs, target_ulong args,\n\n                         uint32_t nret, target_ulong rets)\n\n{\n\n    struct ics_state *ics = spapr->icp->ics;\n\n    uint32_t nr;\n\n\n\n    if ((nargs != 1) || (nret != 1)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    nr = rtas_ld(args, 0);\n\n\n\n    if (!ics_valid_irq(ics, nr)) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    ics_write_xive(ics, nr, ics->irqs[nr - ics->offset].server, 0xff,\n\n                   ics->irqs[nr - ics->offset].priority);\n\n\n\n    rtas_st(rets, 0, 0); \/* Success *\/\n\n}\n","idx":326,"target":0}
{"code":"static void filter_mb_mbaff_edgecv( H264Context *h, uint8_t *pix, int stride, int16_t bS[7], int bsi, int qp ) {\n\n    int index_a = qp + h->slice_alpha_c0_offset;\n\n    int alpha = alpha_table[index_a];\n\n    int beta  = beta_table[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0*bsi]] + 1;\n\n        tc[1] = tc0_table[index_a][bS[1*bsi]] + 1;\n\n        tc[2] = tc0_table[index_a][bS[2*bsi]] + 1;\n\n        tc[3] = tc0_table[index_a][bS[3*bsi]] + 1;\n\n        h->h264dsp.h264_h_loop_filter_chroma_mbaff(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_h_loop_filter_chroma_mbaff_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n","idx":327,"target":0}
{"code":"static void qmp_serialize(void *native_in, void **datap,\n\n                          VisitorFunc visit, Error **errp)\n\n{\n\n    QmpSerializeData *d = g_malloc0(sizeof(*d));\n\n\n\n    d->qov = qmp_output_visitor_new(&d->obj);\n\n    visit(d->qov, &native_in, errp);\n\n    *datap = d;\n\n}\n","idx":329,"target":0}
{"code":"static void tcg_target_init(TCGContext *s)\n\n{\n\n    tcg_regset_set32(tcg_target_available_regs[TCG_TYPE_I32], 0, 0xffffffff);\n\n    tcg_regset_set32(tcg_target_call_clobber_regs, 0,\n\n                     (1 << TCG_REG_R0) |\n\n#ifdef _CALL_DARWIN\n\n                     (1 << TCG_REG_R2) |\n\n#endif\n\n                     (1 << TCG_REG_R3) |\n\n                     (1 << TCG_REG_R4) |\n\n                     (1 << TCG_REG_R5) |\n\n                     (1 << TCG_REG_R6) |\n\n                     (1 << TCG_REG_R7) |\n\n                     (1 << TCG_REG_R8) |\n\n                     (1 << TCG_REG_R9) |\n\n                     (1 << TCG_REG_R10) |\n\n                     (1 << TCG_REG_R11) |\n\n                     (1 << TCG_REG_R12)\n\n        );\n\n\n\n    tcg_regset_clear(s->reserved_regs);\n\n    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R0);\n\n    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R1);\n\n#ifndef _CALL_DARWIN\n\n    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R2);\n\n#endif\n\n#ifdef _CALL_SYSV\n\n    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R13);\n\n#endif\n\n\n\n    tcg_add_target_add_op_defs(ppc_op_defs);\n\n}\n","idx":330,"target":1}
{"code":"static void emulate_spapr_hypercall(PPCVirtualHypervisor *vhyp,\n                                    PowerPCCPU *cpu)\n{\n    CPUPPCState *env = &cpu->env;\n    if (msr_pr) {\n        hcall_dprintf(\"Hypercall made with MSR[PR]=1\\n\");\n        env->gpr[3] = H_PRIVILEGE;\n    } else {\n        env->gpr[3] = spapr_hypercall(cpu, env->gpr[3], &env->gpr[4]);\n    }\n}","idx":331,"target":1}
{"code":"test_opts_range_unvisited(void)\n\n{\n\n    intList *list = NULL;\n\n    intList *tail;\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"ilist=0-2\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(v, NULL, NULL, 0, &error_abort);\n\n\n\n    \/* Would be simpler if the visitor genuinely supported virtual walks *\/\n\n    visit_start_list(v, \"ilist\", (GenericList **)&list, sizeof(*list),\n\n                     &error_abort);\n\n    tail = list;\n\n    visit_type_int(v, NULL, &tail->value, &error_abort);\n\n    g_assert_cmpint(tail->value, ==, 0);\n\n    tail = (intList *)visit_next_list(v, (GenericList *)tail, sizeof(*list));\n\n    g_assert(tail);\n\n    visit_type_int(v, NULL, &tail->value, &error_abort);\n\n    g_assert_cmpint(tail->value, ==, 1);\n\n    tail = (intList *)visit_next_list(v, (GenericList *)tail, sizeof(*list));\n\n    g_assert(tail);\n\n    visit_check_list(v, &error_abort); \/* BUG: unvisited tail not reported *\/\n\n    visit_end_list(v, (void **)&list);\n\n\n\n    visit_check_struct(v, &error_abort);\n\n    visit_end_struct(v, NULL);\n\n\n\n    qapi_free_intList(list);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n}\n","idx":332,"target":1}
{"code":"static int find_vdi_name(BDRVSheepdogState *s, char *filename, uint32_t snapid,\n\n                         char *tag, uint32_t *vid, int for_snapshot)\n\n{\n\n    int ret, fd;\n\n    SheepdogVdiReq hdr;\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n    unsigned int wlen, rlen = 0;\n\n    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    strncpy(buf, filename, SD_MAX_VDI_LEN);\n\n    strncpy(buf + SD_MAX_VDI_LEN, tag, SD_MAX_VDI_TAG_LEN);\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n    if (for_snapshot) {\n\n        hdr.opcode = SD_OP_GET_VDI_INFO;\n\n    } else {\n\n        hdr.opcode = SD_OP_LOCK_VDI;\n\n    }\n\n    wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN;\n\n    hdr.proto_ver = SD_PROTO_VER;\n\n    hdr.data_length = wlen;\n\n    hdr.snapid = snapid;\n\n    hdr.flags = SD_FLAG_CMD_WRITE;\n\n\n\n    ret = do_req(fd, (SheepdogReq *)&hdr, buf, &wlen, &rlen);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    if (rsp->result != SD_RES_SUCCESS) {\n\n        error_report(\"cannot get vdi info, %s, %s %d %s\",\n\n                     sd_strerror(rsp->result), filename, snapid, tag);\n\n        if (rsp->result == SD_RES_NO_VDI) {\n\n            ret = -ENOENT;\n\n        } else {\n\n            ret = -EIO;\n\n        }\n\n        goto out;\n\n    }\n\n    *vid = rsp->vdi_id;\n\n\n\n    ret = 0;\n\nout:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n","idx":334,"target":1}
{"code":"static void ahci_pci_enable(AHCIQState *ahci)\n\n{\n\n    uint8_t reg;\n\n\n\n    start_ahci_device(ahci);\n\n\n\n    switch (ahci->fingerprint) {\n\n    case AHCI_INTEL_ICH9:\n\n        \/* ICH9 has a register at PCI 0x92 that\n\n         * acts as a master port enabler mask. *\/\n\n        reg = qpci_config_readb(ahci->dev, 0x92);\n\n        reg |= 0x3F;\n\n        qpci_config_writeb(ahci->dev, 0x92, reg);\n\n        \/* 0...0111111b -- bit significant, ports 0-5 enabled. *\/\n\n        ASSERT_BIT_SET(qpci_config_readb(ahci->dev, 0x92), 0x3F);\n\n        break;\n\n    }\n\n\n\n}\n","idx":336,"target":1}
{"code":"static VFIOINTp *vfio_init_intp(VFIODevice *vbasedev,\n\n                                struct vfio_irq_info info)\n\n{\n\n    int ret;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n    SysBusDevice *sbdev = SYS_BUS_DEVICE(vdev);\n\n    VFIOINTp *intp;\n\n\n\n    intp = g_malloc0(sizeof(*intp));\n\n    intp->vdev = vdev;\n\n    intp->pin = info.index;\n\n    intp->flags = info.flags;\n\n    intp->state = VFIO_IRQ_INACTIVE;\n\n    intp->kvm_accel = false;\n\n\n\n    sysbus_init_irq(sbdev, &intp->qemuirq);\n\n\n\n    \/* Get an eventfd for trigger *\/\n\n    intp->interrupt = g_malloc0(sizeof(EventNotifier));\n\n    ret = event_notifier_init(intp->interrupt, 0);\n\n    if (ret) {\n\n        g_free(intp->interrupt);\n\n        g_free(intp);\n\n        error_report(\"vfio: Error: trigger event_notifier_init failed \");\n\n        return NULL;\n\n    }\n\n    \/* Get an eventfd for resample\/unmask *\/\n\n    intp->unmask = g_malloc0(sizeof(EventNotifier));\n\n    ret = event_notifier_init(intp->unmask, 0);\n\n    if (ret) {\n\n        g_free(intp->interrupt);\n\n        g_free(intp->unmask);\n\n        g_free(intp);\n\n        error_report(\"vfio: Error: resamplefd event_notifier_init failed\");\n\n        return NULL;\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&vdev->intp_list, intp, next);\n\n    return intp;\n\n}\n","idx":339,"target":1}
{"code":"void OPPROTO op_udivx_T1_T0(void)\n\n{\n\n\n\n\n    T0 \/= T1;\n\n    FORCE_RET();\n","idx":340,"target":1}
{"code":"void address_space_init(AddressSpace *as, MemoryRegion *root)\n\n{\n\n    memory_region_transaction_begin();\n\n    as->root = root;\n\n    as->current_map = g_new(FlatView, 1);\n\n    flatview_init(as->current_map);\n\n\n\n    QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);\n\n    as->name = NULL;\n\n    memory_region_transaction_commit();\n\n    address_space_init_dispatch(as);\n\n}","idx":341,"target":1}
{"code":"static void generate_offset_lut(DiracGolombLUT *lut, int off)\n\n{\n\n    int idx;\n\n    for (idx = 0; idx < LUT_SIZE; idx++) {\n\n        DiracGolombLUT *l = &lut[idx];\n\n\n\n        INIT_RESIDUE(res);\n\n        SET_RESIDUE(res, idx, LUT_BITS);\n\n\n\n        l->preamble      = CONVERT_TO_RESIDUE(res >> (RSIZE_BITS - off), off);\n\n        l->preamble_bits = off;\n\n        l->sign = ((l->preamble >> (RSIZE_BITS - l->preamble_bits)) & 1) ? -1 : +1;\n\n\n\n        search_for_golomb(l, res << off, LUT_BITS - off);\n\n    }\n\n}\n","idx":342,"target":1}
{"code":"ebml_read_ascii (MatroskaDemuxContext *matroska,\n\n                 uint32_t             *id,\n\n                 char                **str)\n\n{\n\n    ByteIOContext *pb = matroska->ctx->pb;\n\n    int size, res;\n\n    uint64_t rlength;\n\n\n\n    if ((res = ebml_read_element_id(matroska, id, NULL)) < 0 ||\n\n        (res = ebml_read_element_length(matroska, &rlength)) < 0)\n\n        return res;\n\n    size = rlength;\n\n\n\n    \/* ebml strings are usually not 0-terminated, so we allocate one\n\n     * byte more, read the string and NULL-terminate it ourselves. *\/\n\n    if (size < 0 || !(*str = av_malloc(size + 1))) {\n\n        av_log(matroska->ctx, AV_LOG_ERROR, \"Memory allocation failed\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    if (get_buffer(pb, (uint8_t *) *str, size) != size) {\n\n        offset_t pos = url_ftell(pb);\n\n        av_log(matroska->ctx, AV_LOG_ERROR,\n\n               \"Read error at pos. %\"PRIu64\" (0x%\"PRIx64\")\\n\", pos, pos);\n\n\n        return AVERROR(EIO);\n\n    }\n\n    (*str)[size] = '\\0';\n\n\n\n    return 0;\n\n}","idx":343,"target":1}
{"code":"vmxnet3_pop_next_tx_descr(VMXNET3State *s,\n\n                          int qidx,\n\n                          struct Vmxnet3_TxDesc *txd,\n\n                          uint32_t *descr_idx)\n\n{\n\n    Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n    if (txd->gen == vmxnet3_ring_curr_gen(ring)) {\n\n        \/* Only read after generation field verification *\/\n\n        smp_rmb();\n\n        \/* Re-read to be sure we got the latest version *\/\n\n        vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n        VMXNET3_RING_DUMP(VMW_RIPRN, \"TX\", qidx, ring);\n\n        *descr_idx = vmxnet3_ring_curr_cell_idx(ring);\n\n        vmxnet3_inc_tx_consumption_counter(s, qidx);\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n","idx":345,"target":1}
{"code":"static void init_excp_BookE (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_APU]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00000000;\n\n    env->excp_prefix = 0x00000000;\n\n    env->ivor_mask = 0x0000FFE0;\n\n    env->ivpr_mask = 0xFFFF0000;\n\n    \/* Hardware reset vector *\/\n\n    env->hreset_vector = 0xFFFFFFFCUL;\n\n#endif\n\n}\n","idx":346,"target":1}
{"code":"RGB_FUNCTIONS(rgba32)\n\n\n\n#undef RGB_IN\n\n#undef RGB_OUT\n\n#undef BPP\n\n\n\n\n\nstatic void rgb24_to_rgb565(AVPicture *dst, AVPicture *src,\n\n                            int width, int height)\n\n{\n\n    const unsigned char *p;\n\n    unsigned char *q;\n\n    int r, g, b, dst_wrap, src_wrap;\n\n    int x, y;\n\n\n\n    p = src->data[0];\n\n    src_wrap = src->linesize[0] - 3 * width;\n\n\n\n    q = dst->data[0];\n\n    dst_wrap = dst->linesize[0] - 2 * width;\n\n\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            r = p[0];\n\n            g = p[1];\n\n            b = p[2];\n\n\n\n            ((unsigned short *)q)[0] = \n\n                ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);\n\n            q += 2;\n\n            p += 3;\n\n        }\n\n        p += src_wrap;\n\n        q += dst_wrap;\n\n    }\n\n}\n","idx":347,"target":0}
{"code":"static void avc_luma_mid_and_aver_dst_16x16_msa(const uint8_t *src,\n\n                                                int32_t src_stride,\n\n                                                uint8_t *dst,\n\n                                                int32_t dst_stride)\n\n{\n\n    avc_luma_mid_and_aver_dst_8w_msa(src, src_stride, dst, dst_stride, 16);\n\n    avc_luma_mid_and_aver_dst_8w_msa(src + 8, src_stride, dst + 8, dst_stride,\n\n                                     16);\n\n}\n","idx":348,"target":0}
{"code":"void MPV_common_init_armv4l(MpegEncContext *s)\n\n{\n\n    int i;\n\n    const int idct_algo= s->avctx->idct_algo;\n\n\n\n    ff_put_pixels_clamped = s->avctx->dsp.put_pixels_clamped;\n\n    ff_add_pixels_clamped = s->avctx->dsp.put_pixels_clamped;\n\n\n\n    if(idct_algo==FF_IDCT_AUTO || idct_algo==FF_IDCT_ARM){\n\n        s->idct_put= arm_idct_put;\n\n        s->idct_add= arm_idct_add;\n\n        s->idct_permutation_type= FF_NO_IDCT_PERM;\n\n    }\n\n}\n","idx":349,"target":0}
{"code":"static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n\n{\n\n    int i, k, sb = 0;\n\n    int msb = sbr->k[0];\n\n    int usb = sbr->kx[1];\n\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) \/ sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        \/\/ Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5.\n\n        \/\/ After this check the final number of patches can still be six which is\n\n        \/\/ illegal however the Coding Technologies decoder check stream has a final\n\n        \/\/ count of 6 patches\n\n        if (sbr->num_patches > 5) {\n\n            av_log(ac->avctx, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n            return -1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    return 0;\n\n}\n","idx":350,"target":0}
{"code":"void ff_rtp_send_h263(AVFormatContext *s1, const uint8_t *buf1, int size)\n\n{\n\n    RTPMuxContext *s = s1->priv_data;\n\n    int len, max_packet_size;\n\n    uint8_t *q;\n\n\n\n    max_packet_size = s->max_payload_size;\n\n\n\n    while (size > 0) {\n\n        q = s->buf;\n\n        if ((buf1[0] == 0) && (buf1[1] == 0)) {\n\n            *q++ = 0x04;\n\n            buf1 += 2;\n\n            size -= 2;\n\n        } else {\n\n            *q++ = 0;\n\n        }\n\n        *q++ = 0;\n\n\n\n        len = FFMIN(max_packet_size - 2, size);\n\n\n\n        \/* Look for a better place to split the frame into packets. *\/\n\n        if (len < size) {\n\n            const uint8_t *end = find_resync_marker_reverse(buf1, buf1 + len);\n\n            len = end - buf1;\n\n        }\n\n\n\n        memcpy(q, buf1, len);\n\n        q += len;\n\n\n\n        \/* 90 KHz time stamp *\/\n\n        s->timestamp = s->cur_timestamp;\n\n        ff_rtp_send_data(s1, s->buf, q - s->buf, (len == size));\n\n\n\n        buf1 += len;\n\n        size -= len;\n\n    }\n\n}\n","idx":352,"target":1}
{"code":"DISAS_INSN(divw)\n\n{\n\n    TCGv reg;\n\n    TCGv tmp;\n\n    TCGv src;\n\n    int sign;\n\n\n\n    sign = (insn & 0x100) != 0;\n\n    reg = DREG(insn, 9);\n\n    if (sign) {\n\n        tcg_gen_ext16s_i32(QREG_DIV1, reg);\n\n    } else {\n\n        tcg_gen_ext16u_i32(QREG_DIV1, reg);\n\n    }\n\n    SRC_EA(env, src, OS_WORD, sign, NULL);\n\n    tcg_gen_mov_i32(QREG_DIV2, src);\n\n    if (sign) {\n\n        gen_helper_divs(cpu_env, tcg_const_i32(1));\n\n    } else {\n\n        gen_helper_divu(cpu_env, tcg_const_i32(1));\n\n    }\n\n\n\n    tmp = tcg_temp_new();\n\n    src = tcg_temp_new();\n\n    tcg_gen_ext16u_i32(tmp, QREG_DIV1);\n\n    tcg_gen_shli_i32(src, QREG_DIV2, 16);\n\n    tcg_gen_or_i32(reg, tmp, src);\n\n\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n","idx":354,"target":1}
{"code":"void block_job_enter(BlockJob *job)\n\n{\n\n    if (!block_job_started(job)) {\n\n        return;\n\n    }\n\n    if (job->deferred_to_main_loop) {\n\n        return;\n\n    }\n\n\n\n    if (!job->busy) {\n\n        bdrv_coroutine_enter(blk_bs(job->blk), job->co);\n\n    }\n\n}\n","idx":356,"target":1}
{"code":"static int vorbis_decode_frame(AVCodecContext *avccontext,\n\n                               void *data, int *data_size,\n\n                               AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    vorbis_context *vc = avccontext->priv_data ;\n\n    GetBitContext *gb = &(vc->gb);\n\n    const float *channel_ptrs[255];\n\n    int i, len;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    av_dlog(NULL, \"packet length %d \\n\", buf_size);\n\n\n\n    init_get_bits(gb, buf, buf_size*8);\n\n\n\n    len = vorbis_parse_audio_packet(vc);\n\n\n\n    if (len <= 0) {\n\n        *data_size = 0;\n\n        return buf_size;\n\n    }\n\n\n\n    if (!vc->first_frame) {\n\n        vc->first_frame = 1;\n\n        *data_size = 0;\n\n        return buf_size ;\n\n    }\n\n\n\n    av_dlog(NULL, \"parsed %d bytes %d bits, returned %d samples (*ch*bits) \\n\",\n\n            get_bits_count(gb) \/ 8, get_bits_count(gb) % 8, len);\n\n\n\n    if (vc->audio_channels > 8) {\n\n        for (i = 0; i < vc->audio_channels; i++)\n\n            channel_ptrs[i] = vc->channel_floors + i * len;\n\n    } else {\n\n        for (i = 0; i < vc->audio_channels; i++)\n\n            channel_ptrs[i] = vc->channel_floors +\n\n                              len * ff_vorbis_channel_layout_offsets[vc->audio_channels - 1][i];\n\n    }\n\n\n\n    if (avccontext->sample_fmt == AV_SAMPLE_FMT_FLT)\n\n        vc->fmt_conv.float_interleave(data, channel_ptrs, len, vc->audio_channels);\n\n    else\n\n        vc->fmt_conv.float_to_int16_interleave(data, channel_ptrs, len,\n\n                                               vc->audio_channels);\n\n\n\n    *data_size = len * vc->audio_channels *\n\n                 av_get_bytes_per_sample(avccontext->sample_fmt);\n\n\n\n    return buf_size ;\n\n}\n","idx":357,"target":0}
{"code":"void qmp_guest_shutdown(bool has_mode, const char *mode, Error **err)\n\n{\n\n    UINT shutdown_flag = EWX_FORCE;\n\n\n\n    slog(\"guest-shutdown called, mode: %s\", mode);\n\n\n\n    if (!has_mode || strcmp(mode, \"powerdown\") == 0) {\n\n        shutdown_flag |= EWX_POWEROFF;\n\n    } else if (strcmp(mode, \"halt\") == 0) {\n\n        shutdown_flag |= EWX_SHUTDOWN;\n\n    } else if (strcmp(mode, \"reboot\") == 0) {\n\n        shutdown_flag |= EWX_REBOOT;\n\n    } else {\n\n        error_set(err, QERR_INVALID_PARAMETER_VALUE, \"mode\",\n\n                  \"halt|powerdown|reboot\");\n\n        return;\n\n    }\n\n\n\n    \/* Request a shutdown privilege, but try to shut down the system\n\n       anyway. *\/\n\n    acquire_privilege(SE_SHUTDOWN_NAME, err);\n\n    if (error_is_set(err)) {\n\n        return;\n\n    }\n\n\n\n    if (!ExitWindowsEx(shutdown_flag, SHTDN_REASON_FLAG_PLANNED)) {\n\n        slog(\"guest-shutdown failed: %d\", GetLastError());\n\n        error_set(err, QERR_UNDEFINED_ERROR);\n\n    }\n\n}\n","idx":358,"target":1}
