{"code":"DVMuxContext* dv_init_mux(AVFormatContext* s)\n\n{\n\n    DVMuxContext *c;\n\n    AVStream *vst = NULL;\n\n    int i;\n\n\n\n    \/* we support at most 1 video and 2 audio streams *\/\n\n    if (s->nb_streams > 3)\n\n        return NULL;\n\n\n\n    c = av_mallocz(sizeof(DVMuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->n_ast = 0;\n\n    c->ast[0] = c->ast[1] = NULL;\n\n\n\n    \/* We have to sort out where audio and where video stream is *\/\n\n    for (i=0; i<s->nb_streams; i++) {\n\n         switch (s->streams[i]->codec->codec_type) {\n\n         case CODEC_TYPE_VIDEO:\n\n               vst = s->streams[i];\n\n               break;\n\n         case CODEC_TYPE_AUDIO:\n\n             c->ast[c->n_ast++] = s->streams[i];\n\n             break;\n\n         default:\n\n               goto bail_out;\n\n         }\n\n    }\n\n\n\n    \/* Some checks -- DV format is very picky about its incoming streams *\/\n\n    if (!vst || vst->codec->codec_id != CODEC_ID_DVVIDEO)\n\n        goto bail_out;\n\n    for (i=0; i<c->n_ast; i++) {\n\n        if (c->ast[i] && (c->ast[i]->codec->codec_id != CODEC_ID_PCM_S16LE ||\n\n                          c->ast[i]->codec->sample_rate != 48000 ||\n\n                          c->ast[i]->codec->channels != 2))\n\n            goto bail_out;\n\n    }\n\n    c->sys = dv_codec_profile(vst->codec);\n\n    if (!c->sys)\n\n        goto bail_out;\n\n\n\n    if((c->n_ast > 1) && (c->sys->n_difchan < 2)) {\n\n        \/* only 1 stereo pair is allowed in 25Mbps mode *\/\n\n        goto bail_out;\n\n    }\n\n\n\n    \/* Ok, everything seems to be in working order *\/\n\n    c->frames = 0;\n\n    c->has_audio = 0;\n\n    c->has_video = 0;\n\n    c->start_time = (time_t)s->timestamp;\n\n\n\n    for (i=0; i<c->n_ast; i++) {\n\n        if (c->ast[i] && av_fifo_init(&c->audio_data[i], 100*AVCODEC_MAX_AUDIO_FRAME_SIZE) < 0) {\n\n            while (i>0) {\n\n                i--;\n\n                av_fifo_free(&c->audio_data[i]);\n\n            }\n\n            goto bail_out;\n\n        }\n\n    }\n\n\n\n    return c;\n\n\n\nbail_out:\n\n    av_free(c);\n\n    return NULL;\n\n}\n","idx":4229,"target":1}
{"code":"static void adpcm_compress_trellis(AVCodecContext *avctx,\n\n                                   const int16_t *samples, uint8_t *dst,\n\n                                   ADPCMChannelStatus *c, int n, int stride)\n\n{\n\n    \/\/FIXME 6% faster if frontier is a compile-time constant\n\n    ADPCMEncodeContext *s = avctx->priv_data;\n\n    const int frontier = 1 << avctx->trellis;\n\n    const int version  = avctx->codec->id;\n\n    TrellisPath *paths       = s->paths, *p;\n\n    TrellisNode *node_buf    = s->node_buf;\n\n    TrellisNode **nodep_buf  = s->nodep_buf;\n\n    TrellisNode **nodes      = nodep_buf; \/\/ nodes[] is always sorted by .ssd\n\n    TrellisNode **nodes_next = nodep_buf + frontier;\n\n    int pathn = 0, froze = -1, i, j, k, generation = 0;\n\n    uint8_t *hash = s->trellis_hash;\n\n    memset(hash, 0xff, 65536 * sizeof(*hash));\n\n\n\n    memset(nodep_buf, 0, 2 * frontier * sizeof(*nodep_buf));\n\n    nodes[0]          = node_buf + frontier;\n\n    nodes[0]->ssd     = 0;\n\n    nodes[0]->path    = 0;\n\n    nodes[0]->step    = c->step_index;\n\n    nodes[0]->sample1 = c->sample1;\n\n    nodes[0]->sample2 = c->sample2;\n\n    if (version == AV_CODEC_ID_ADPCM_IMA_WAV ||\n\n        version == AV_CODEC_ID_ADPCM_IMA_QT  ||\n\n        version == AV_CODEC_ID_ADPCM_SWF)\n\n        nodes[0]->sample1 = c->prev_sample;\n\n    if (version == AV_CODEC_ID_ADPCM_MS)\n\n        nodes[0]->step = c->idelta;\n\n    if (version == AV_CODEC_ID_ADPCM_YAMAHA) {\n\n        if (c->step == 0) {\n\n            nodes[0]->step    = 127;\n\n            nodes[0]->sample1 = 0;\n\n        } else {\n\n            nodes[0]->step    = c->step;\n\n            nodes[0]->sample1 = c->predictor;\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < n; i++) {\n\n        TrellisNode *t = node_buf + frontier*(i&1);\n\n        TrellisNode **u;\n\n        int sample   = samples[i * stride];\n\n        int heap_pos = 0;\n\n        memset(nodes_next, 0, frontier * sizeof(TrellisNode*));\n\n        for (j = 0; j < frontier && nodes[j]; j++) {\n\n            \/\/ higher j have higher ssd already, so they're likely\n\n            \/\/ to yield a suboptimal next sample too\n\n            const int range = (j < frontier \/ 2) ? 1 : 0;\n\n            const int step  = nodes[j]->step;\n\n            int nidx;\n\n            if (version == AV_CODEC_ID_ADPCM_MS) {\n\n                const int predictor = ((nodes[j]->sample1 * c->coeff1) +\n\n                                       (nodes[j]->sample2 * c->coeff2)) \/ 64;\n\n                const int div  = (sample - predictor) \/ step;\n\n                const int nmin = av_clip(div-range, -8, 6);\n\n                const int nmax = av_clip(div+range, -7, 7);\n\n                for (nidx = nmin; nidx <= nmax; nidx++) {\n\n                    const int nibble = nidx & 0xf;\n\n                    int dec_sample   = predictor + nidx * step;\n\n#define STORE_NODE(NAME, STEP_INDEX)\\\n\n                    int d;\\\n\n                    uint32_t ssd;\\\n\n                    int pos;\\\n\n                    TrellisNode *u;\\\n\n                    uint8_t *h;\\\n\n                    dec_sample = av_clip_int16(dec_sample);\\\n\n                    d = sample - dec_sample;\\\n\n                    ssd = nodes[j]->ssd + d*d;\\\n\n                    \/* Check for wraparound, skip such samples completely. \\\n\n                     * Note, changing ssd to a 64 bit variable would be \\\n\n                     * simpler, avoiding this check, but it's slower on \\\n\n                     * x86 32 bit at the moment. *\/\\\n\n                    if (ssd < nodes[j]->ssd)\\\n\n                        goto next_##NAME;\\\n\n                    \/* Collapse any two states with the same previous sample value. \\\n\n                     * One could also distinguish states by step and by 2nd to last\n\n                     * sample, but the effects of that are negligible.\n\n                     * Since nodes in the previous generation are iterated\n\n                     * through a heap, they're roughly ordered from better to\n\n                     * worse, but not strictly ordered. Therefore, an earlier\n\n                     * node with the same sample value is better in most cases\n\n                     * (and thus the current is skipped), but not strictly\n\n                     * in all cases. Only skipping samples where ssd >=\n\n                     * ssd of the earlier node with the same sample gives\n\n                     * slightly worse quality, though, for some reason. *\/ \\\n\n                    h = &hash[(uint16_t) dec_sample];\\\n\n                    if (*h == generation)\\\n\n                        goto next_##NAME;\\\n\n                    if (heap_pos < frontier) {\\\n\n                        pos = heap_pos++;\\\n\n                    } else {\\\n\n                        \/* Try to replace one of the leaf nodes with the new \\\n\n                         * one, but try a different slot each time. *\/\\\n\n                        pos = (frontier >> 1) +\\\n\n                              (heap_pos & ((frontier >> 1) - 1));\\\n\n                        if (ssd > nodes_next[pos]->ssd)\\\n\n                            goto next_##NAME;\\\n\n                        heap_pos++;\\\n\n                    }\\\n\n                    *h = generation;\\\n\n                    u  = nodes_next[pos];\\\n\n                    if (!u) {\\\n\n                        av_assert1(pathn < FREEZE_INTERVAL << avctx->trellis);\\\n\n                        u = t++;\\\n\n                        nodes_next[pos] = u;\\\n\n                        u->path = pathn++;\\\n\n                    }\\\n\n                    u->ssd  = ssd;\\\n\n                    u->step = STEP_INDEX;\\\n\n                    u->sample2 = nodes[j]->sample1;\\\n\n                    u->sample1 = dec_sample;\\\n\n                    paths[u->path].nibble = nibble;\\\n\n                    paths[u->path].prev   = nodes[j]->path;\\\n\n                    \/* Sift the newly inserted node up in the heap to \\\n\n                     * restore the heap property. *\/\\\n\n                    while (pos > 0) {\\\n\n                        int parent = (pos - 1) >> 1;\\\n\n                        if (nodes_next[parent]->ssd <= ssd)\\\n\n                            break;\\\n\n                        FFSWAP(TrellisNode*, nodes_next[parent], nodes_next[pos]);\\\n\n                        pos = parent;\\\n\n                    }\\\n\n                    next_##NAME:;\n\n                    STORE_NODE(ms, FFMAX(16,\n\n                               (ff_adpcm_AdaptationTable[nibble] * step) >> 8));\n\n                }\n\n            } else if (version == AV_CODEC_ID_ADPCM_IMA_WAV ||\n\n                       version == AV_CODEC_ID_ADPCM_IMA_QT  ||\n\n                       version == AV_CODEC_ID_ADPCM_SWF) {\n\n#define LOOP_NODES(NAME, STEP_TABLE, STEP_INDEX)\\\n\n                const int predictor = nodes[j]->sample1;\\\n\n                const int div = (sample - predictor) * 4 \/ STEP_TABLE;\\\n\n                int nmin = av_clip(div - range, -7, 6);\\\n\n                int nmax = av_clip(div + range, -6, 7);\\\n\n                if (nmin <= 0)\\\n\n                    nmin--; \/* distinguish -0 from +0 *\/\\\n\n                if (nmax < 0)\\\n\n                    nmax--;\\\n\n                for (nidx = nmin; nidx <= nmax; nidx++) {\\\n\n                    const int nibble = nidx < 0 ? 7 - nidx : nidx;\\\n\n                    int dec_sample = predictor +\\\n\n                                    (STEP_TABLE *\\\n\n                                     ff_adpcm_yamaha_difflookup[nibble]) \/ 8;\\\n\n                    STORE_NODE(NAME, STEP_INDEX);\\\n\n                }\n\n                LOOP_NODES(ima, ff_adpcm_step_table[step],\n\n                           av_clip(step + ff_adpcm_index_table[nibble], 0, 88));\n\n            } else { \/\/AV_CODEC_ID_ADPCM_YAMAHA\n\n                LOOP_NODES(yamaha, step,\n\n                           av_clip((step * ff_adpcm_yamaha_indexscale[nibble]) >> 8,\n\n                                   127, 24567));\n\n#undef LOOP_NODES\n\n#undef STORE_NODE\n\n            }\n\n        }\n\n\n\n        u = nodes;\n\n        nodes = nodes_next;\n\n        nodes_next = u;\n\n\n\n        generation++;\n\n        if (generation == 255) {\n\n            memset(hash, 0xff, 65536 * sizeof(*hash));\n\n            generation = 0;\n\n        }\n\n\n\n        \/\/ prevent overflow\n\n        if (nodes[0]->ssd > (1 << 28)) {\n\n            for (j = 1; j < frontier && nodes[j]; j++)\n\n                nodes[j]->ssd -= nodes[0]->ssd;\n\n            nodes[0]->ssd = 0;\n\n        }\n\n\n\n        \/\/ merge old paths to save memory\n\n        if (i == froze + FREEZE_INTERVAL) {\n\n            p = &paths[nodes[0]->path];\n\n            for (k = i; k > froze; k--) {\n\n                dst[k] = p->nibble;\n\n                p = &paths[p->prev];\n\n            }\n\n            froze = i;\n\n            pathn = 0;\n\n            \/\/ other nodes might use paths that don't coincide with the frozen one.\n\n            \/\/ checking which nodes do so is too slow, so just kill them all.\n\n            \/\/ this also slightly improves quality, but I don't know why.\n\n            memset(nodes + 1, 0, (frontier - 1) * sizeof(TrellisNode*));\n\n        }\n\n    }\n\n\n\n    p = &paths[nodes[0]->path];\n\n    for (i = n - 1; i > froze; i--) {\n\n        dst[i] = p->nibble;\n\n        p = &paths[p->prev];\n\n    }\n\n\n\n    c->predictor  = nodes[0]->sample1;\n\n    c->sample1    = nodes[0]->sample1;\n\n    c->sample2    = nodes[0]->sample2;\n\n    c->step_index = nodes[0]->step;\n\n    c->step       = nodes[0]->step;\n\n    c->idelta     = nodes[0]->step;\n\n}\n","idx":14295,"target":1}
{"code":"static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if ((layer_info->channel_info[channel].type < -1) &&\n      (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))\n    {\n      const char\n        *option;\n\n      \/*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      *\/\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n       if ((layer_info->channel_info[channel].type != -2) ||\n           (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n            (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n      }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n       if (mask != (Image *) NULL)\n        {\n          SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n","idx":183188,"target":1}
{"code":"static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,\n\n                                VMStateField *field)\n\n{\n\n    uint64_t *v = pv;\n\n    *v = qemu_get_be32(f);\n\n    return 0;\n\n}\n","idx":50,"target":0}
{"code":"static void perf_lifecycle(void)\n\n{\n\n    Coroutine *coroutine;\n\n    unsigned int i, max;\n\n    double duration;\n\n\n\n    max = 1000000;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < max; i++) {\n\n        coroutine = qemu_coroutine_create(empty_coroutine);\n\n        qemu_coroutine_enter(coroutine, NULL);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Lifecycle %u iterations: %f s\\n\", max, duration);\n\n}\n","idx":6630,"target":1}
{"code":"CPUState *ppc440ep_init(ram_addr_t *ram_size, PCIBus **pcip,\n\n                        const unsigned int pci_irq_nrs[4], int do_init,\n\n                        const char *cpu_model)\n\n{\n\n    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    qemu_irq *pci_irqs;\n\n\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"405\"; \/\/ XXX: should be 440EP\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    \/* interrupt controller *\/\n\n    irqs = qemu_mallocz(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    \/* SDRAM controller *\/\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    \/* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. *\/\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_bases,\n\n                      ram_sizes, do_init);\n\n\n\n    \/* PCI *\/\n\n    pci_irqs = qemu_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(0xef600300, 0, pic[0], PPC_SERIAL_MM_BAUDBASE,\n\n                       serial_hds[0], 1, 1);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(0xef600400, 0, pic[1], PPC_SERIAL_MM_BAUDBASE,\n\n                       serial_hds[1], 1, 1);\n\n    }\n\n\n\n    return env;\n\n}\n","idx":14618,"target":1}
{"code":"static void virt_acpi_build_update(void *build_opaque)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    \/* No state to update or already patched? Nothing to do. *\/\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = true;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    virt_acpi_build(build_state->guest_info, &tables);\n\n\n\n    acpi_ram_update(build_state->table_mr, tables.table_data);\n\n    acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n\n    acpi_ram_update(build_state->linker_mr, tables.linker);\n\n\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n","idx":74,"target":0}
{"code":"static void encode_gray_bitstream(HYuvContext *s, int count){\n\n    int i;\n\n    \n\n    count\/=2;\n\n    if(s->flags&CODEC_FLAG_PASS1){\n\n        for(i=0; i<count; i++){\n\n            s->stats[0][ s->temp[0][2*i  ] ]++;\n\n            s->stats[0][ s->temp[0][2*i+1] ]++;\n\n        }\n\n    }else if(s->context){\n\n        for(i=0; i<count; i++){\n\n            s->stats[0][ s->temp[0][2*i  ] ]++;\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);\n\n            s->stats[0][ s->temp[0][2*i+1] ]++;\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);\n\n        }\n\n    }else{\n\n        for(i=0; i<count; i++){\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);\n\n        }\n\n    }\n\n}\n","idx":27219,"target":1}
{"code":"void PrintPreviewDataService::RemoveEntry(\n    const std::string& preview_ui_addr_str) {\n  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);\n  if (it != data_store_map_.end())\n    data_store_map_.erase(it);\n }\n","idx":184397,"target":1}
{"code":"static void m68k_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    M68kCPU *cpu = M68K_CPU(dev);\n\n    M68kCPUClass *mcc = M68K_CPU_GET_CLASS(dev);\n\n\n\n    m68k_cpu_init_gdb(cpu);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    mcc->parent_realize(dev, errp);\n\n}\n","idx":18694,"target":1}
{"code":"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    AVFrame *const p   = data;\n\n    int compressed, xmin, ymin, xmax, ymax;\n\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n\n                 bytes_per_scanline;\n\n    uint8_t *ptr;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n    const uint8_t *bufstart = buf;\n\n    uint8_t *scanline;\n\n    int ret = -1;\n\n\n\n    if (buf[0] != 0x0a || buf[1] > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    compressed = buf[2];\n\n    xmin       = AV_RL16(buf + 4);\n\n    ymin       = AV_RL16(buf + 6);\n\n    xmax       = AV_RL16(buf + 8);\n\n    ymax       = AV_RL16(buf + 10);\n\n\n\n    if (xmax < xmin || ymax < ymin) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    w = xmax - xmin + 1;\n\n    h = ymax - ymin + 1;\n\n\n\n    bits_per_pixel     = buf[3];\n\n    bytes_per_line     = AV_RL16(buf + 66);\n\n    nplanes            = buf[65];\n\n    bytes_per_scanline = nplanes * bytes_per_line;\n\n\n\n    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) \/ 8 ||\n\n        (!compressed && bytes_per_scanline > buf_size \/ h)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((nplanes << 8) + bits_per_pixel) {\n\n    case 0x0308:\n\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n        break;\n\n    case 0x0108:\n\n    case 0x0104:\n\n    case 0x0102:\n\n    case 0x0101:\n\n    case 0x0401:\n\n    case 0x0301:\n\n    case 0x0201:\n\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    buf += 128;\n\n\n\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    scanline = av_malloc(bytes_per_scanline);\n\n    if (!scanline)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (nplanes == 3 && bits_per_pixel == 8) {\n\n        for (y = 0; y < h; y++) {\n\n            buf = pcx_rle_decode(buf, buf_end,\n\n                                 scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x = 0; x < w; x++) {\n\n                ptr[3 * x]     = scanline[x];\n\n                ptr[3 * x + 1] = scanline[x + bytes_per_line];\n\n                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];\n\n            }\n\n\n\n            ptr += stride;\n\n        }\n\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n\n        const uint8_t *palstart = bufstart + buf_size - 769;\n\n\n\n        if (buf_size < 769) {\n\n            av_log(avctx, AV_LOG_ERROR, \"File is too short\\n\");\n\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n\n                  AVERROR_INVALIDDATA : buf_size;\n\n            goto end;\n\n        }\n\n\n\n        for (y = 0; y < h; y++, ptr += stride) {\n\n            buf = pcx_rle_decode(buf, buf_end,\n\n                                 scanline, bytes_per_scanline, compressed);\n\n            memcpy(ptr, scanline, w);\n\n        }\n\n\n\n        if (buf != palstart) {\n\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n\n            buf = palstart;\n\n        }\n\n        if (*buf++ != 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n\n                  AVERROR_INVALIDDATA : buf_size;\n\n            goto end;\n\n        }\n\n    } else if (nplanes == 1) {   \/* all packed formats, max. 16 colors *\/\n\n        GetBitContext s;\n\n\n\n        for (y = 0; y < h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline << 3);\n\n\n\n            buf = pcx_rle_decode(buf, buf_end,\n\n                                 scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x = 0; x < w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n    } else {    \/* planar, 4, 8 or 16 colors *\/\n\n        int i;\n\n\n\n        for (y = 0; y < h; y++) {\n\n            buf = pcx_rle_decode(buf, buf_end,\n\n                                 scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x = 0; x < w; x++) {\n\n                int m = 0x80 >> (x & 7), v = 0;\n\n                for (i = nplanes - 1; i >= 0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *)p->data[1], 256);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart + 16;\n\n        pcx_palette(&palette, (uint32_t *)p->data[1], 16);\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n","idx":15259,"target":1}
{"code":"static int announce_self_create(uint8_t *buf, \n\n\t\t\t\tuint8_t *mac_addr)\n\n{\n\n    uint32_t magic = EXPERIMENTAL_MAGIC;\n\n    uint16_t proto = htons(ETH_P_EXPERIMENTAL);\n\n\n\n    \/* FIXME: should we send a different packet (arp\/rarp\/ping)? *\/\n\n\n\n    memset(buf, 0, 64);\n\n    memset(buf, 0xff, 6);         \/* h_dst *\/\n\n    memcpy(buf + 6, mac_addr, 6); \/* h_src *\/\n\n    memcpy(buf + 12, &proto, 2);  \/* h_proto *\/\n\n    memcpy(buf + 14, &magic, 4);  \/* magic *\/\n\n\n\n    return 64; \/* len *\/\n\n}\n","idx":18951,"target":1}
{"code":"static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int stride, int n){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    switch(w->abt_type_table[n]){\n\n    case 0:\n\n        if (s->block_last_index[n] >= 0) {\n\n            s->dsp.idct_add (dst, stride, block1);\n\n        }\n\n        break;\n\n    case 1:\n\n        simple_idct84_add(dst           , stride, block1);\n\n        simple_idct84_add(dst + 4*stride, stride, w->abt_block2[n]);\n\n        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n\n        break;\n\n    case 2:\n\n        simple_idct48_add(dst           , stride, block1);\n\n        simple_idct48_add(dst + 4       , stride, w->abt_block2[n]);\n\n        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n\n        break;\n\n    default:\n\n        av_log(s->avctx, AV_LOG_ERROR, \"internal error in WMV2 abt\\n\");\n\n    }\n\n}\n","idx":11866,"target":1}
{"code":"long do_sigreturn(CPUM68KState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr = env->aregs[7] - 4;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int d0, i;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    \/* set blocked signals *\/\n\n\n\n    if (__get_user(target_set.sig[0], &frame->sc.sc_mask))\n\n        goto badframe;\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    \/* restore registers *\/\n\n\n\n    if (restore_sigcontext(env, &frame->sc, &d0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return d0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n","idx":66,"target":0}
{"code":"int attribute_align_arg avresample_convert(AVAudioResampleContext *avr,\n\n                                           uint8_t **output, int out_plane_size,\n\n                                           int out_samples, uint8_t **input,\n\n                                           int in_plane_size, int in_samples)\n\n{\n\n    AudioData input_buffer;\n\n    AudioData output_buffer;\n\n    AudioData *current_buffer;\n\n    int ret, direct_output;\n\n\n\n    \/* reset internal buffers *\/\n\n    if (avr->in_buffer) {\n\n        avr->in_buffer->nb_samples = 0;\n\n        ff_audio_data_set_channels(avr->in_buffer,\n\n                                   avr->in_buffer->allocated_channels);\n\n    }\n\n    if (avr->resample_out_buffer) {\n\n        avr->resample_out_buffer->nb_samples = 0;\n\n        ff_audio_data_set_channels(avr->resample_out_buffer,\n\n                                   avr->resample_out_buffer->allocated_channels);\n\n    }\n\n    if (avr->out_buffer) {\n\n        avr->out_buffer->nb_samples = 0;\n\n        ff_audio_data_set_channels(avr->out_buffer,\n\n                                   avr->out_buffer->allocated_channels);\n\n    }\n\n\n\n    av_dlog(avr, \"[start conversion]\\n\");\n\n\n\n    \/* initialize output_buffer with output data *\/\n\n    direct_output = output && av_audio_fifo_size(avr->out_fifo) == 0;\n\n    if (output) {\n\n        ret = ff_audio_data_init(&output_buffer, output, out_plane_size,\n\n                                 avr->out_channels, out_samples,\n\n                                 avr->out_sample_fmt, 0, \"output\");\n\n        if (ret < 0)\n\n            return ret;\n\n        output_buffer.nb_samples = 0;\n\n    }\n\n\n\n    if (input) {\n\n        \/* initialize input_buffer with input data *\/\n\n        ret = ff_audio_data_init(&input_buffer, input, in_plane_size,\n\n                                 avr->in_channels, in_samples,\n\n                                 avr->in_sample_fmt, 1, \"input\");\n\n        if (ret < 0)\n\n            return ret;\n\n        current_buffer = &input_buffer;\n\n\n\n        if (avr->upmix_needed && !avr->in_convert_needed && !avr->resample_needed &&\n\n            !avr->out_convert_needed && direct_output && out_samples >= in_samples) {\n\n            \/* in some rare cases we can copy input to output and upmix\n\n               directly in the output buffer *\/\n\n            av_dlog(avr, \"[copy] %s to output\\n\", current_buffer->name);\n\n            ret = ff_audio_data_copy(&output_buffer, current_buffer,\n\n                                     avr->remap_point == REMAP_OUT_COPY ?\n\n                                     &avr->ch_map_info : NULL);\n\n            if (ret < 0)\n\n                return ret;\n\n            current_buffer = &output_buffer;\n\n        } else if (avr->remap_point == REMAP_OUT_COPY &&\n\n                   (!direct_output || out_samples < in_samples)) {\n\n            \/* if remapping channels during output copy, we may need to\n\n             * use an intermediate buffer in order to remap before adding\n\n             * samples to the output fifo *\/\n\n            av_dlog(avr, \"[copy] %s to out_buffer\\n\", current_buffer->name);\n\n            ret = ff_audio_data_copy(avr->out_buffer, current_buffer,\n\n                                     &avr->ch_map_info);\n\n            if (ret < 0)\n\n                return ret;\n\n            current_buffer = avr->out_buffer;\n\n        } else if (avr->in_copy_needed || avr->in_convert_needed) {\n\n            \/* if needed, copy or convert input to in_buffer, and downmix if\n\n               applicable *\/\n\n            if (avr->in_convert_needed) {\n\n                ret = ff_audio_data_realloc(avr->in_buffer,\n\n                                            current_buffer->nb_samples);\n\n                if (ret < 0)\n\n                    return ret;\n\n                av_dlog(avr, \"[convert] %s to in_buffer\\n\", current_buffer->name);\n\n                ret = ff_audio_convert(avr->ac_in, avr->in_buffer,\n\n                                       current_buffer);\n\n                if (ret < 0)\n\n                    return ret;\n\n            } else {\n\n                av_dlog(avr, \"[copy] %s to in_buffer\\n\", current_buffer->name);\n\n                ret = ff_audio_data_copy(avr->in_buffer, current_buffer,\n\n                                         avr->remap_point == REMAP_IN_COPY ?\n\n                                         &avr->ch_map_info : NULL);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n            ff_audio_data_set_channels(avr->in_buffer, avr->in_channels);\n\n            if (avr->downmix_needed) {\n\n                av_dlog(avr, \"[downmix] in_buffer\\n\");\n\n                ret = ff_audio_mix(avr->am, avr->in_buffer);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n            current_buffer = avr->in_buffer;\n\n        }\n\n    } else {\n\n        \/* flush resampling buffer and\/or output FIFO if input is NULL *\/\n\n        if (!avr->resample_needed)\n\n            return handle_buffered_output(avr, output ? &output_buffer : NULL,\n\n                                          NULL);\n\n        current_buffer = NULL;\n\n    }\n\n\n\n    if (avr->resample_needed) {\n\n        AudioData *resample_out;\n\n\n\n        if (!avr->out_convert_needed && direct_output && out_samples > 0)\n\n            resample_out = &output_buffer;\n\n        else\n\n            resample_out = avr->resample_out_buffer;\n\n        av_dlog(avr, \"[resample] %s to %s\\n\", current_buffer->name,\n\n                resample_out->name);\n\n        ret = ff_audio_resample(avr->resample, resample_out,\n\n                                current_buffer);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        \/* if resampling did not produce any samples, just return 0 *\/\n\n        if (resample_out->nb_samples == 0) {\n\n            av_dlog(avr, \"[end conversion]\\n\");\n\n            return 0;\n\n        }\n\n\n\n        current_buffer = resample_out;\n\n    }\n\n\n\n    if (avr->upmix_needed) {\n\n        av_dlog(avr, \"[upmix] %s\\n\", current_buffer->name);\n\n        ret = ff_audio_mix(avr->am, current_buffer);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    \/* if we resampled or upmixed directly to output, return here *\/\n\n    if (current_buffer == &output_buffer) {\n\n        av_dlog(avr, \"[end conversion]\\n\");\n\n        return current_buffer->nb_samples;\n\n    }\n\n\n\n    if (avr->out_convert_needed) {\n\n        if (direct_output && out_samples >= current_buffer->nb_samples) {\n\n            \/* convert directly to output *\/\n\n            av_dlog(avr, \"[convert] %s to output\\n\", current_buffer->name);\n\n            ret = ff_audio_convert(avr->ac_out, &output_buffer, current_buffer);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            av_dlog(avr, \"[end conversion]\\n\");\n\n            return output_buffer.nb_samples;\n\n        } else {\n\n            ret = ff_audio_data_realloc(avr->out_buffer,\n\n                                        current_buffer->nb_samples);\n\n            if (ret < 0)\n\n                return ret;\n\n            av_dlog(avr, \"[convert] %s to out_buffer\\n\", current_buffer->name);\n\n            ret = ff_audio_convert(avr->ac_out, avr->out_buffer,\n\n                                   current_buffer);\n\n            if (ret < 0)\n\n                return ret;\n\n            current_buffer = avr->out_buffer;\n\n        }\n\n    }\n\n\n\n    return handle_buffered_output(avr, output ? &output_buffer : NULL,\n\n                                  current_buffer);\n\n}\n","idx":24111,"target":1}
{"code":"static void tcp_wait_for_connect(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    int val, ret;\n\n    socklen_t valsize = sizeof(val);\n\n\n\n    DPRINTF(\"connect completed\\n\");\n\n    do {\n\n        ret = getsockopt(s->fd, SOL_SOCKET, SO_ERROR, (void *) &val, &valsize);\n\n    } while (ret == -1 && (socket_error()) == EINTR);\n\n\n\n    if (ret < 0) {\n\n        migrate_fd_error(s);\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s->fd, NULL, NULL, NULL, NULL);\n\n\n\n    if (val == 0)\n\n        migrate_fd_connect(s);\n\n    else {\n\n        DPRINTF(\"error connecting %d\\n\", val);\n\n        migrate_fd_error(s);\n\n    }\n\n}\n","idx":23032,"target":1}
{"code":"static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    \/* Allocate RMA if necessary *\/\n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        \/* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         *\/\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    \/* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary *\/\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    \/* We aim for a hash table of size 1\/128 the size of RAM.  The\n\n     * normal rule of thumb is 1\/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. *\/\n\n    spapr->htab_shift = 18; \/* Minimum architected size *\/\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    \/* Set up Interrupt Controller before we create the VCPUs *\/\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() \/ smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        \/* Set time-base frequency to 512 MHz *\/\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        \/* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         *\/\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        \/* Tell KVM that we're in PAPR mode *\/\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    \/* allocate RAM *\/\n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    \/* Set up EPOW events infrastructure *\/\n\n    spapr_events_init(spapr);\n\n\n\n    \/* Set up VIO bus *\/\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    \/* We always have at least the nvram device on VIO *\/\n\n    spapr_create_nvram(spapr);\n\n\n\n    \/* Set up PCI *\/\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    \/* Graphics *\/\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        \/* load initrd *\/\n\n        if (initrd_filename) {\n\n            \/* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             *\/\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr\/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    \/* Prepare the device tree *\/\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n","idx":43,"target":0}
{"code":"static void read_apic(AVFormatContext *s, AVIOContext *pb, int taglen, char *tag, ID3v2ExtraMeta **extra_meta)\n\n{\n\n    int enc, pic_type;\n\n    char             mimetype[64];\n\n    const CodecMime     *mime = ff_id3v2_mime_tags;\n\n    enum AVCodecID           id = AV_CODEC_ID_NONE;\n\n    ID3v2ExtraMetaAPIC  *apic = NULL;\n\n    ID3v2ExtraMeta *new_extra = NULL;\n\n    int64_t               end = avio_tell(pb) + taglen;\n\n\n\n    if (taglen <= 4)\n\n        goto fail;\n\n\n\n    new_extra = av_mallocz(sizeof(*new_extra));\n\n    apic      = av_mallocz(sizeof(*apic));\n\n    if (!new_extra || !apic)\n\n        goto fail;\n\n\n\n    enc = avio_r8(pb);\n\n    taglen--;\n\n\n\n    \/* mimetype *\/\n\n    taglen -= avio_get_str(pb, taglen, mimetype, sizeof(mimetype));\n\n    while (mime->id != AV_CODEC_ID_NONE) {\n\n        if (!av_strncasecmp(mime->str, mimetype, sizeof(mimetype))) {\n\n            id = mime->id;\n\n            break;\n\n        }\n\n        mime++;\n\n    }\n\n    if (id == AV_CODEC_ID_NONE) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture mimetype: %s, skipping.\\n\", mimetype);\n\n        goto fail;\n\n    }\n\n    apic->id = id;\n\n\n\n    \/* picture type *\/\n\n    pic_type = avio_r8(pb);\n\n    taglen--;\n\n    if (pic_type < 0 || pic_type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types)) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type %d.\\n\", pic_type);\n\n        pic_type = 0;\n\n    }\n\n    apic->type = ff_id3v2_picture_types[pic_type];\n\n\n\n    \/* description and picture data *\/\n\n    if (decode_str(s, pb, enc, &apic->description, &taglen) < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"Error decoding attached picture description.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    apic->buf = av_buffer_alloc(taglen);\n\n    if (!apic->buf || !taglen || avio_read(pb, apic->buf->data, taglen) != taglen)\n\n        goto fail;\n\n\n\n    new_extra->tag    = \"APIC\";\n\n    new_extra->data   = apic;\n\n    new_extra->next   = *extra_meta;\n\n    *extra_meta       = new_extra;\n\n\n\n    return;\n\n\n\nfail:\n\n    if (apic)\n\n        free_apic(apic);\n\n    av_freep(&new_extra);\n\n    avio_seek(pb, end, SEEK_SET);\n\n}\n","idx":6127,"target":1}
{"code":"static int write_trailer(AVFormatContext *s)\n\n{\n\n    WVMuxContext *wc = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n\n\n    ff_ape_write(s);\n\n\n\n    if (pb->seekable) {\n\n        avio_seek(pb, 12, SEEK_SET);\n\n        avio_wl32(pb, wc->duration);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":96,"target":0}
{"code":"OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n    ALOGV(\"SoftFlacEncoder::internalGetParameter(index=0x%x)\", index);\n\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n\n         case OMX_IndexParamAudioFlac:\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             flacParams->nCompressionLevel = mCompressionLevel;\n             flacParams->nChannels = mNumChannels;\n             flacParams->nSampleRate = mSampleRate;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","idx":188225,"target":1}
{"code":"OMX_ERRORTYPE SoftFlacEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamAudioPcm)\");\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams = (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 ALOGE(\"SoftFlacEncoder::internalSetParameter() Error #1\");\n                 return OMX_ErrorUndefined;\n }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n            ALOGV(\"will encode %d channels at %dHz\", mNumChannels, mSampleRate);\n\n return configureEncoder();\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\");\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                     \"audio_encoder.flac\",\n                     OMX_MAX_STRINGNAME_SIZE - 1)) {\n                ALOGE(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\"\n \"error\");\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioFlac:\n\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             mCompressionLevel = flacParams->nCompressionLevel; \/\/ range clamping done inside encoder\n             return OMX_ErrorNone;\n         }\n\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex == 0) {\n                 if (defParams->nBufferSize > kMaxInputBufferSize) {\n                     ALOGE(\"Input buffer size must be at most %d bytes\",\n                        kMaxInputBufferSize);\n return OMX_ErrorUnsupportedSetting;\n }\n }\n\n }\n\n default:\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(default)\");\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","idx":188226,"target":1}
{"code":"av_cold static int auto_matrix(SwrContext *s)\n\n{\n\n    int i, j, out_i;\n\n    double matrix[NUM_NAMED_CHANNELS][NUM_NAMED_CHANNELS]={{0}};\n\n    int64_t unaccounted, in_ch_layout, out_ch_layout;\n\n    double maxcoef=0;\n\n    char buf[128];\n\n    const int matrix_encoding = s->matrix_encoding;\n\n    float maxval;\n\n\n\n    in_ch_layout = clean_layout(s, s->in_ch_layout);\n\n    out_ch_layout = clean_layout(s, s->out_ch_layout);\n\n\n\n    if(   out_ch_layout == AV_CH_LAYOUT_STEREO_DOWNMIX\n\n       && (in_ch_layout & AV_CH_LAYOUT_STEREO_DOWNMIX) == 0\n\n    )\n\n        out_ch_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n    if(    in_ch_layout == AV_CH_LAYOUT_STEREO_DOWNMIX\n\n       && (out_ch_layout & AV_CH_LAYOUT_STEREO_DOWNMIX) == 0\n\n    )\n\n        in_ch_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n    if(!sane_layout(in_ch_layout)){\n\n        av_get_channel_layout_string(buf, sizeof(buf), -1, s->in_ch_layout);\n\n        av_log(s, AV_LOG_ERROR, \"Input channel layout '%s' is not supported\\n\", buf);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if(!sane_layout(out_ch_layout)){\n\n        av_get_channel_layout_string(buf, sizeof(buf), -1, s->out_ch_layout);\n\n        av_log(s, AV_LOG_ERROR, \"Output channel layout '%s' is not supported\\n\", buf);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    memset(s->matrix, 0, sizeof(s->matrix));\n\n    for(i=0; i<FF_ARRAY_ELEMS(matrix); i++){\n\n        if(in_ch_layout & out_ch_layout & (1ULL<<i))\n\n            matrix[i][i]= 1.0;\n\n    }\n\n\n\n    unaccounted= in_ch_layout & ~out_ch_layout;\n\n\n\n\/\/FIXME implement dolby surround\n\n\/\/FIXME implement full ac3\n\n\n\n\n\n    if(unaccounted & AV_CH_FRONT_CENTER){\n\n        if((out_ch_layout & AV_CH_LAYOUT_STEREO) == AV_CH_LAYOUT_STEREO){\n\n            if(in_ch_layout & AV_CH_LAYOUT_STEREO) {\n\n                matrix[ FRONT_LEFT][FRONT_CENTER]+= s->clev;\n\n                matrix[FRONT_RIGHT][FRONT_CENTER]+= s->clev;\n\n            } else {\n\n                matrix[ FRONT_LEFT][FRONT_CENTER]+= M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][FRONT_CENTER]+= M_SQRT1_2;\n\n            }\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n    if(unaccounted & AV_CH_LAYOUT_STEREO){\n\n        if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[FRONT_CENTER][ FRONT_LEFT]+= M_SQRT1_2;\n\n            matrix[FRONT_CENTER][FRONT_RIGHT]+= M_SQRT1_2;\n\n            if(in_ch_layout & AV_CH_FRONT_CENTER)\n\n                matrix[FRONT_CENTER][ FRONT_CENTER] = s->clev*sqrt(2);\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n\n\n    if(unaccounted & AV_CH_BACK_CENTER){\n\n        if(out_ch_layout & AV_CH_BACK_LEFT){\n\n            matrix[ BACK_LEFT][BACK_CENTER]+= M_SQRT1_2;\n\n            matrix[BACK_RIGHT][BACK_CENTER]+= M_SQRT1_2;\n\n        }else if(out_ch_layout & AV_CH_SIDE_LEFT){\n\n            matrix[ SIDE_LEFT][BACK_CENTER]+= M_SQRT1_2;\n\n            matrix[SIDE_RIGHT][BACK_CENTER]+= M_SQRT1_2;\n\n        }else if(out_ch_layout & AV_CH_FRONT_LEFT){\n\n            if (matrix_encoding == AV_MATRIX_ENCODING_DOLBY ||\n\n                matrix_encoding == AV_MATRIX_ENCODING_DPLII) {\n\n                if (unaccounted & (AV_CH_BACK_LEFT | AV_CH_SIDE_LEFT)) {\n\n                    matrix[FRONT_LEFT ][BACK_CENTER] -= s->slev * M_SQRT1_2;\n\n                    matrix[FRONT_RIGHT][BACK_CENTER] += s->slev * M_SQRT1_2;\n\n                } else {\n\n                    matrix[FRONT_LEFT ][BACK_CENTER] -= s->slev;\n\n                    matrix[FRONT_RIGHT][BACK_CENTER] += s->slev;\n\n                }\n\n            } else {\n\n                matrix[ FRONT_LEFT][BACK_CENTER]+= s->slev*M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_CENTER]+= s->slev*M_SQRT1_2;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[ FRONT_CENTER][BACK_CENTER]+= s->slev*M_SQRT1_2;\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n    if(unaccounted & AV_CH_BACK_LEFT){\n\n        if(out_ch_layout & AV_CH_BACK_CENTER){\n\n            matrix[BACK_CENTER][ BACK_LEFT]+= M_SQRT1_2;\n\n            matrix[BACK_CENTER][BACK_RIGHT]+= M_SQRT1_2;\n\n        }else if(out_ch_layout & AV_CH_SIDE_LEFT){\n\n            if(in_ch_layout & AV_CH_SIDE_LEFT){\n\n                matrix[ SIDE_LEFT][ BACK_LEFT]+= M_SQRT1_2;\n\n                matrix[SIDE_RIGHT][BACK_RIGHT]+= M_SQRT1_2;\n\n            }else{\n\n            matrix[ SIDE_LEFT][ BACK_LEFT]+= 1.0;\n\n            matrix[SIDE_RIGHT][BACK_RIGHT]+= 1.0;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_FRONT_LEFT){\n\n            if (matrix_encoding == AV_MATRIX_ENCODING_DOLBY) {\n\n                matrix[FRONT_LEFT ][BACK_LEFT ] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_LEFT ][BACK_RIGHT] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_LEFT ] += s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_RIGHT] += s->slev * M_SQRT1_2;\n\n            } else if (matrix_encoding == AV_MATRIX_ENCODING_DPLII) {\n\n                matrix[FRONT_LEFT ][BACK_LEFT ] -= s->slev * SQRT3_2;\n\n                matrix[FRONT_LEFT ][BACK_RIGHT] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_LEFT ] += s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][BACK_RIGHT] += s->slev * SQRT3_2;\n\n            } else {\n\n                matrix[ FRONT_LEFT][ BACK_LEFT] += s->slev;\n\n                matrix[FRONT_RIGHT][BACK_RIGHT] += s->slev;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[ FRONT_CENTER][BACK_LEFT ]+= s->slev*M_SQRT1_2;\n\n            matrix[ FRONT_CENTER][BACK_RIGHT]+= s->slev*M_SQRT1_2;\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n\n\n    if(unaccounted & AV_CH_SIDE_LEFT){\n\n        if(out_ch_layout & AV_CH_BACK_LEFT){\n\n            \/* if back channels do not exist in the input, just copy side\n\n               channels to back channels, otherwise mix side into back *\/\n\n            if (in_ch_layout & AV_CH_BACK_LEFT) {\n\n                matrix[BACK_LEFT ][SIDE_LEFT ] += M_SQRT1_2;\n\n                matrix[BACK_RIGHT][SIDE_RIGHT] += M_SQRT1_2;\n\n            } else {\n\n                matrix[BACK_LEFT ][SIDE_LEFT ] += 1.0;\n\n                matrix[BACK_RIGHT][SIDE_RIGHT] += 1.0;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_BACK_CENTER){\n\n            matrix[BACK_CENTER][ SIDE_LEFT]+= M_SQRT1_2;\n\n            matrix[BACK_CENTER][SIDE_RIGHT]+= M_SQRT1_2;\n\n        }else if(out_ch_layout & AV_CH_FRONT_LEFT){\n\n            if (matrix_encoding == AV_MATRIX_ENCODING_DOLBY) {\n\n                matrix[FRONT_LEFT ][SIDE_LEFT ] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_LEFT ][SIDE_RIGHT] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][SIDE_LEFT ] += s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][SIDE_RIGHT] += s->slev * M_SQRT1_2;\n\n            } else if (matrix_encoding == AV_MATRIX_ENCODING_DPLII) {\n\n                matrix[FRONT_LEFT ][SIDE_LEFT ] -= s->slev * SQRT3_2;\n\n                matrix[FRONT_LEFT ][SIDE_RIGHT] -= s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][SIDE_LEFT ] += s->slev * M_SQRT1_2;\n\n                matrix[FRONT_RIGHT][SIDE_RIGHT] += s->slev * SQRT3_2;\n\n            } else {\n\n                matrix[ FRONT_LEFT][ SIDE_LEFT] += s->slev;\n\n                matrix[FRONT_RIGHT][SIDE_RIGHT] += s->slev;\n\n            }\n\n        }else if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[ FRONT_CENTER][SIDE_LEFT ]+= s->slev*M_SQRT1_2;\n\n            matrix[ FRONT_CENTER][SIDE_RIGHT]+= s->slev*M_SQRT1_2;\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n\n\n    if(unaccounted & AV_CH_FRONT_LEFT_OF_CENTER){\n\n        if(out_ch_layout & AV_CH_FRONT_LEFT){\n\n            matrix[ FRONT_LEFT][ FRONT_LEFT_OF_CENTER]+= 1.0;\n\n            matrix[FRONT_RIGHT][FRONT_RIGHT_OF_CENTER]+= 1.0;\n\n        }else if(out_ch_layout & AV_CH_FRONT_CENTER){\n\n            matrix[ FRONT_CENTER][ FRONT_LEFT_OF_CENTER]+= M_SQRT1_2;\n\n            matrix[ FRONT_CENTER][FRONT_RIGHT_OF_CENTER]+= M_SQRT1_2;\n\n        }else\n\n            av_assert0(0);\n\n    }\n\n    \/* mix LFE into front left\/right or center *\/\n\n    if (unaccounted & AV_CH_LOW_FREQUENCY) {\n\n        if (out_ch_layout & AV_CH_FRONT_CENTER) {\n\n            matrix[FRONT_CENTER][LOW_FREQUENCY] += s->lfe_mix_level;\n\n        } else if (out_ch_layout & AV_CH_FRONT_LEFT) {\n\n            matrix[FRONT_LEFT ][LOW_FREQUENCY] += s->lfe_mix_level * M_SQRT1_2;\n\n            matrix[FRONT_RIGHT][LOW_FREQUENCY] += s->lfe_mix_level * M_SQRT1_2;\n\n        } else\n\n            av_assert0(0);\n\n    }\n\n\n\n    for(out_i=i=0; i<64; i++){\n\n        double sum=0;\n\n        int in_i=0;\n\n        for(j=0; j<64; j++){\n\n            if (i < FF_ARRAY_ELEMS(matrix) && j < FF_ARRAY_ELEMS(matrix[0]))\n\n                s->matrix[out_i][in_i]= matrix[i][j];\n\n            else\n\n                s->matrix[out_i][in_i]= i == j && (in_ch_layout & out_ch_layout & (1ULL<<i));\n\n            sum += fabs(s->matrix[out_i][in_i]);\n\n            if(in_ch_layout & (1ULL<<j))\n\n                in_i++;\n\n        }\n\n        maxcoef= FFMAX(maxcoef, sum);\n\n        if(out_ch_layout & (1ULL<<i))\n\n            out_i++;\n\n    }\n\n    if(s->rematrix_volume  < 0)\n\n        maxcoef = -s->rematrix_volume;\n\n\n\n    if (s->rematrix_maxval > 0) {\n\n        maxval = s->rematrix_maxval;\n\n    } else if (   av_get_packed_sample_fmt(s->out_sample_fmt) < AV_SAMPLE_FMT_FLT\n\n               || av_get_packed_sample_fmt(s->int_sample_fmt) < AV_SAMPLE_FMT_FLT) {\n\n        maxval = 1.0;\n\n    } else\n\n        maxval = INT_MAX;\n\n\n\n    if(maxcoef > maxval || s->rematrix_volume  < 0){\n\n        maxcoef \/= maxval;\n\n        for(i=0; i<SWR_CH_MAX; i++)\n\n            for(j=0; j<SWR_CH_MAX; j++){\n\n                s->matrix[i][j] \/= maxcoef;\n\n            }\n\n    }\n\n\n\n    if(s->rematrix_volume > 0){\n\n        for(i=0; i<SWR_CH_MAX; i++)\n\n            for(j=0; j<SWR_CH_MAX; j++){\n\n                s->matrix[i][j] *= s->rematrix_volume;\n\n            }\n\n    }\n\n\n\n    for(i=0; i<av_get_channel_layout_nb_channels(out_ch_layout); i++){\n\n        for(j=0; j<av_get_channel_layout_nb_channels(in_ch_layout); j++){\n\n            av_log(NULL, AV_LOG_DEBUG, \"%f \", s->matrix[i][j]);\n\n        }\n\n        av_log(NULL, AV_LOG_DEBUG, \"\\n\");\n\n    }\n\n    return 0;\n\n}\n","idx":7634,"target":1}
{"code":"av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n","idx":19,"target":0}
{"code":"av_cold int swri_rematrix_init(SwrContext *s){\n\n    int i, j;\n\n    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);\n\n    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    s->mix_any_f = NULL;\n\n\n\n    if (!s->rematrix_custom) {\n\n        int r = auto_matrix(s);\n\n        if (r)\n\n            return r;\n\n    }\n\n    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++) {\n\n            double rem = 0;\n\n\n\n            for (j = 0; j < nb_in; j++) {\n\n                double target = s->matrix[i][j] * 32768 + rem;\n\n                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);\n\n                rem += target - ((int*)s->native_matrix)[i * nb_in + j];\n\n            }\n\n        }\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));\n\n        s->native_one    = av_mallocz(sizeof(float));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((float*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(double));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((double*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){\n\n        \/\/ Only for dithering currently\n\n\/\/         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_one)\n\n            return AVERROR(ENOMEM);\n\n\/\/         for (i = 0; i < nb_out; i++)\n\n\/\/             for (j = 0; j < nb_in; j++)\n\n\/\/                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);\n\n    }else\n\n        av_assert0(0);\n\n    \/\/FIXME quantize for integeres\n\n    for (i = 0; i < SWR_CH_MAX; i++) {\n\n        int ch_in=0;\n\n        for (j = 0; j < SWR_CH_MAX; j++) {\n\n            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);\n\n            if(s->matrix[i][j])\n\n                s->matrix_ch[i][++ch_in]= j;\n\n        }\n\n        s->matrix_ch[i][0]= ch_in;\n\n    }\n\n\n\n    if(HAVE_YASM && HAVE_MMX)\n\n        return swri_rematrix_init_x86(s);\n\n\n\n    return 0;\n\n}\n","idx":1998,"target":1}
{"code":"void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    char buf[256];\n\n    char *p;\n\n    target_ulong addr;\n\n    uint64_t i64;\n\n    GDBState *s;\n\n\n\n    s = gdbserver_state;\n\n    if (!s)\n\n        return;\n\n    gdb_current_syscall_cb = cb;\n\n    s->state = RS_SYSCALL;\n\n#ifndef CONFIG_USER_ONLY\n\n    vm_stop(EXCP_DEBUG);\n\n#endif\n\n    s->state = RS_IDLE;\n\n    va_start(va, fmt);\n\n    p = buf;\n\n    *(p++) = 'F';\n\n    while (*fmt) {\n\n        if (*fmt == '%') {\n\n            fmt++;\n\n            switch (*fmt++) {\n\n            case 'x':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx, addr);\n\n                break;\n\n            case 'l':\n\n                if (*(fmt++) != 'x')\n\n                    goto bad_format;\n\n                i64 = va_arg(va, uint64_t);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, \"%\" PRIx64, i64);\n\n                break;\n\n            case 's':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx \"\/%x\",\n\n                              addr, va_arg(va, int));\n\n                break;\n\n            default:\n\n            bad_format:\n\n                fprintf(stderr, \"gdbstub: Bad syscall format string '%s'\\n\",\n\n                        fmt - 1);\n\n                break;\n\n            }\n\n        } else {\n\n            *(p++) = *(fmt++);\n\n        }\n\n    }\n\n    *p = 0;\n\n    va_end(va);\n\n    put_packet(s, buf);\n\n#ifdef CONFIG_USER_ONLY\n\n    gdb_handlesig(s->c_cpu, 0);\n\n#else\n\n    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);\n\n#endif\n\n}\n","idx":71,"target":0}
{"code":"hstore_from_arrays(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tDatum\t   *value_datums;\n\tbool\t   *value_nulls;\n\tint\t\t\tvalue_count;\n\tArrayType  *key_array;\n\tArrayType  *value_array;\n\tint\t\t\ti;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tkey_array = PG_GETARG_ARRAYTYPE_P(0);\n\n\tAssert(ARR_ELEMTYPE(key_array) == TEXTOID);\n\n\t\/*\n\t * must check >1 rather than != 1 because empty arrays have 0 dimensions,\n\t * not 1\n\t *\/\n\n\tif (ARR_NDIM(key_array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tdeconstruct_array(key_array,\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n \t\/* value_array might be NULL *\/\n \n \tif (PG_ARGISNULL(1))\n\t{\n\t\tvalue_array = NULL;\n\t\tvalue_count = key_count;\n\t\tvalue_datums = NULL;\n\t\tvalue_nulls = NULL;\n\t}\n\telse\n\t{\n\t\tvalue_array = PG_GETARG_ARRAYTYPE_P(1);\n\n\t\tAssert(ARR_ELEMTYPE(value_array) == TEXTOID);\n\n\t\tif (ARR_NDIM(value_array) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t\tif ((ARR_NDIM(key_array) > 0 || ARR_NDIM(value_array) > 0) &&\n\t\t\t(ARR_NDIM(key_array) != ARR_NDIM(value_array) ||\n\t\t\t ARR_DIMS(key_array)[0] != ARR_DIMS(value_array)[0] ||\n\t\t\t ARR_LBOUND(key_array)[0] != ARR_LBOUND(value_array)[0]))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"arrays must have same bounds\")));\n\n\t\tdeconstruct_array(value_array,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &value_datums, &value_nulls, &value_count);\n\n\t\tAssert(key_count == value_count);\n\t}\n\n\tpairs = palloc(key_count * sizeof(Pairs));\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tif (!value_nulls || value_nulls[i])\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = 4;\n\t\t\tpairs[i].isnull = true;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = VARDATA_ANY(value_datums[i]);\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(value_datums[i]));\n\t\t\tpairs[i].isnull = false;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t}\n\n\tkey_count = hstoreUniquePairs(pairs, key_count, &buflen);\n\n\tout = hstorePairs(pairs, key_count, buflen);\n\n\tPG_RETURN_POINTER(out);\n}\n","idx":179569,"target":1}
{"code":"static int transcode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     InputFile *input_files,\n\n                     int nb_input_files,\n\n                     StreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret = 0, i, j, k, n, nb_ostreams = 0, step;\n\n\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    OutputStream *ost, **ost_table = NULL;\n\n    InputStream *ist;\n\n    char error[1024];\n\n    int key;\n\n    int want_sdp = 1;\n\n    uint8_t no_packet[MAX_FILES]={0};\n\n    int no_packet_count=0;\n\n    int nb_frame_threshold[AVMEDIA_TYPE_NB]={0};\n\n    int nb_streams[AVMEDIA_TYPE_NB]={0};\n\n\n\n    if (rate_emu)\n\n        for (i = 0; i < nb_input_streams; i++)\n\n            input_streams[i].start = av_gettime();\n\n\n\n    \/* output stream init *\/\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n\n            av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n            fprintf(stderr, \"Output file #%d does not contain any stream\\n\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    \/* Sanity check the mapping args -- do the input files & streams exist? *\/\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        fi = stream_maps[i].sync_file_index;\n\n        si = stream_maps[i].sync_stream_index;\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find sync stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ost_table = av_mallocz(sizeof(OutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            nb_streams[os->streams[i]->codec->codec_type]++;\n\n        }\n\n    }\n\n    for(step=1<<30; step; step>>=1){\n\n        int found_streams[AVMEDIA_TYPE_NB]={0};\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            nb_frame_threshold[j] += step;\n\n\n\n        for(j=0; j<nb_input_streams; j++) {\n\n            int skip=0;\n\n            ist = &input_streams[j];\n\n            if(opt_programid){\n\n                int pi,si;\n\n                AVFormatContext *f= input_files[ ist->file_index ].ctx;\n\n                skip=1;\n\n                for(pi=0; pi<f->nb_programs; pi++){\n\n                    AVProgram *p= f->programs[pi];\n\n                    if(p->id == opt_programid)\n\n                        for(si=0; si<p->nb_stream_indexes; si++){\n\n                            if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                skip=0;\n\n                        }\n\n                }\n\n            }\n\n            if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip\n\n                && nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames){\n\n                found_streams[ist->st->codec->codec_type]++;\n\n            }\n\n        }\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            if(found_streams[j] < nb_streams[j])\n\n                nb_frame_threshold[j] -= step;\n\n    }\n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            int found;\n\n            ost = ost_table[n] = output_streams_for_file[k][i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = input_files[stream_maps[n].file_index].ist_index +\n\n                    stream_maps[n].stream_index;\n\n\n\n                \/* Sanity check that the stream types match *\/\n\n                if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {\n\n                    int i= ost->file_index;\n\n                    av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n].file_index, stream_maps[n].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    ffmpeg_exit(1);\n\n                }\n\n\n\n            } else {\n\n                \/* get corresponding input stream index : we select the first one with the right type *\/\n\n                found = 0;\n\n                for (j = 0; j < nb_input_streams; j++) {\n\n                    int skip=0;\n\n                    ist = &input_streams[j];\n\n                    if(opt_programid){\n\n                        int pi,si;\n\n                        AVFormatContext *f = input_files[ist->file_index].ctx;\n\n                        skip=1;\n\n                        for(pi=0; pi<f->nb_programs; pi++){\n\n                            AVProgram *p= f->programs[pi];\n\n                            if(p->id == opt_programid)\n\n                                for(si=0; si<p->nb_stream_indexes; si++){\n\n                                    if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                        skip=0;\n\n                                }\n\n                        }\n\n                    }\n\n                    if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip &&\n\n                        ist->st->codec->codec_type == ost->st->codec->codec_type &&\n\n                        nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                            break;\n\n                    }\n\n                }\n\n\n\n                if (!found) {\n\n                    if(! opt_programid) {\n\n                        \/* try again and reuse existing stream *\/\n\n                        for (j = 0; j < nb_input_streams; j++) {\n\n                            ist = &input_streams[j];\n\n                            if (   ist->st->codec->codec_type == ost->st->codec->codec_type\n\n                                && ist->st->discard != AVDISCARD_ALL) {\n\n                                ost->source_index = j;\n\n                                found = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        int i= ost->file_index;\n\n                        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = &input_streams[ost->source_index];\n\n            ist->discard = 0;\n\n            ost->sync_ist = (nb_stream_maps > 0) ?\n\n                &input_streams[input_files[stream_maps[n].sync_file_index].ist_index +\n\n                         stream_maps[n].sync_stream_index] : ist;\n\n        }\n\n    }\n\n\n\n    \/* for each output stream, we compute the right encoding parameters *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        os = output_files[ost->file_index];\n\n        ist = &input_streams[ost->source_index];\n\n\n\n        codec = ost->st->codec;\n\n        icodec = ist->st->codec;\n\n\n\n        if (metadata_streams_autocopy)\n\n            av_dict_copy(&ost->st->metadata, ist->st->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n\n\n        ost->st->disposition = ist->st->disposition;\n\n        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;\n\n        codec->chroma_sample_location = icodec->chroma_sample_location;\n\n\n\n        if (ost->st->stream_copy) {\n\n            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n\n\n\n            if (extra_size > INT_MAX)\n\n                goto fail;\n\n\n\n            \/* if stream_copy is selected, no need to decode or encode *\/\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n\n\n            if(!codec->codec_tag){\n\n                if(   !os->oformat->codec_tag\n\n                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id\n\n                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)\n\n                    codec->codec_tag = icodec->codec_tag;\n\n            }\n\n\n\n            codec->bit_rate = icodec->bit_rate;\n\n            codec->rc_max_rate    = icodec->rc_max_rate;\n\n            codec->rc_buffer_size = icodec->rc_buffer_size;\n\n            codec->extradata= av_mallocz(extra_size);\n\n            if (!codec->extradata)\n\n                goto fail;\n\n            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n\n            codec->extradata_size= icodec->extradata_size;\n\n            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0\/500){\n\n                codec->time_base = icodec->time_base;\n\n                codec->time_base.num *= icodec->ticks_per_frame;\n\n                av_reduce(&codec->time_base.num, &codec->time_base.den,\n\n                          codec->time_base.num, codec->time_base.den, INT_MAX);\n\n            }else\n\n                codec->time_base = ist->st->time_base;\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                if(audio_volume != 256) {\n\n                    fprintf(stderr,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                codec->channel_layout = icodec->channel_layout;\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                codec->frame_size = icodec->frame_size;\n\n                codec->audio_service_type = icodec->audio_service_type;\n\n                codec->block_align= icodec->block_align;\n\n                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)\n\n                    codec->block_align= 0;\n\n                if(codec->codec_id == CODEC_ID_AC3)\n\n                    codec->block_align= 0;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                codec->pix_fmt = icodec->pix_fmt;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                codec->has_b_frames = icodec->has_b_frames;\n\n                if (!codec->sample_aspect_ratio.num) {\n\n                    codec->sample_aspect_ratio =\n\n                    ost->st->sample_aspect_ratio =\n\n                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :\n\n                        ist->st->codec->sample_aspect_ratio.num ?\n\n                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};\n\n                }\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            case AVMEDIA_TYPE_DATA:\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            if (!ost->enc)\n\n                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ost->fifo= av_fifo_alloc(1024);\n\n                if(!ost->fifo)\n\n                    goto fail;\n\n                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);\n\n                if (!codec->sample_rate) {\n\n                    codec->sample_rate = icodec->sample_rate;\n\n                    if (icodec->lowres)\n\n                        codec->sample_rate >>= icodec->lowres;\n\n                }\n\n                choose_sample_rate(ost->st, ost->enc);\n\n                codec->time_base = (AVRational){1, codec->sample_rate};\n\n                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)\n\n                    codec->sample_fmt = icodec->sample_fmt;\n\n                choose_sample_fmt(ost->st, ost->enc);\n\n                if (!codec->channels) {\n\n                    codec->channels = icodec->channels;\n\n                    codec->channel_layout = icodec->channel_layout;\n\n                }\n\n                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)\n\n                    codec->channel_layout = 0;\n\n                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;\n\n                icodec->request_channels = codec->channels;\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                ost->resample_sample_fmt  = icodec->sample_fmt;\n\n                ost->resample_sample_rate = icodec->sample_rate;\n\n                ost->resample_channels    = icodec->channels;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (codec->pix_fmt == PIX_FMT_NONE)\n\n                    codec->pix_fmt = icodec->pix_fmt;\n\n                choose_pixel_fmt(ost->st, ost->enc);\n\n\n\n                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n\n                    fprintf(stderr, \"Video pixel format is unknown, stream cannot be encoded\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                ost->video_resample = codec->width   != icodec->width  ||\n\n                                      codec->height  != icodec->height ||\n\n                                      codec->pix_fmt != icodec->pix_fmt;\n\n                if (ost->video_resample) {\n\n                    codec->bits_per_raw_sample= frame_bits_per_raw_sample;\n\n                }\n\n                if (!codec->width || !codec->height) {\n\n                    codec->width  = icodec->width;\n\n                    codec->height = icodec->height;\n\n                }\n\n                ost->resample_height = icodec->height;\n\n                ost->resample_width  = icodec->width;\n\n                ost->resample_pix_fmt= icodec->pix_fmt;\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n\n\n                if (!ost->frame_rate.num)\n\n                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};\n\n                if (ost->enc && ost->enc->supported_framerates && !force_fps) {\n\n                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);\n\n                    ost->frame_rate = ost->enc->supported_framerates[idx];\n\n                }\n\n                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};\n\n                if(   av_q2d(codec->time_base) < 0.001 && video_sync_method\n\n                   && (video_sync_method==1 || (video_sync_method<0 && !(os->oformat->flags & AVFMT_VARIABLE_FPS)))){\n\n                    av_log(os, AV_LOG_WARNING, \"Frame rate very high for a muxer not effciciently supporting it.\\n\"\n\n                                               \"Please consider specifiying a lower framerate, a different muxer or -vsync 2\\n\");\n\n                }\n\n\n\n#if CONFIG_AVFILTER\n\n                if (configure_video_filters(ist, ost)) {\n\n                    fprintf(stderr, \"Error opening filters!\\n\");\n\n                    exit(1);\n\n                }\n\n#endif\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                abort();\n\n                break;\n\n            }\n\n            \/* two pass mode *\/\n\n            if (ost->encoding_needed && codec->codec_id != CODEC_ID_H264 &&\n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n\n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\",\n\n                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,\n\n                         i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"wb\");\n\n                    if (!f) {\n\n                        fprintf(stderr, \"Cannot write log file '%s' for pass-1 encoding: %s\\n\", logfilename, strerror(errno));\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    char  *logbuffer;\n\n                    size_t logbuffer_size;\n\n                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n\n                        fprintf(stderr, \"Error reading log file '%s' for pass-2 encoding\\n\", logfilename);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){\n\n            \/* maximum video buffer size is 6-bytes per pixel, plus DPX header size *\/\n\n            int size= codec->width * codec->height;\n\n            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n\n        }\n\n    }\n\n\n\n    if (!bit_buffer)\n\n        bit_buffer = av_malloc(bit_buffer_size);\n\n    if (!bit_buffer) {\n\n        fprintf(stderr, \"Cannot allocate %d bytes output buffer\\n\",\n\n                bit_buffer_size);\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    \/* open each encoder *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec = ost->enc;\n\n            AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Encoder (codec id %d) not found for output stream #%d.%d\",\n\n                         ost->st->codec->codec_id, ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (dec->subtitle_header) {\n\n                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n\n                if (!ost->st->codec->subtitle_header) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto dump_format;\n\n                }\n\n                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n\n                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n\n            }\n\n            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\",\n\n                        ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ost->st->codec, 1);\n\n            assert_avoptions(ost->opts);\n\n            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)\n\n                av_log(NULL, AV_LOG_WARNING, \"The bitrate parameter is set too low.\"\n\n                                             \"It takes bits\/s as argument, not kbits\/s\\n\");\n\n            extra_size += ost->st->codec->extradata_size;\n\n        }\n\n    }\n\n\n\n    \/* open each decoder *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec = ist->dec;\n\n            if (!codec)\n\n                codec = avcodec_find_decoder(ist->st->codec->codec_id);\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Decoder (codec id %d) not found for input stream #%d.%d\",\n\n                        ist->st->codec->codec_id, ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening decoder for input stream #%d.%d\",\n\n                        ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ist->st->codec, 0);\n\n            assert_avoptions(ost->opts);\n\n            \/\/if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            \/\/    ist->st->codec->flags |= CODEC_FLAG_REPEAT_FIELD;\n\n        }\n\n    }\n\n\n\n    \/* init pts *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        AVStream *st;\n\n        ist = &input_streams[i];\n\n        st= ist->st;\n\n        ist->pts = st->avg_frame_rate.num ? - st->codec->has_b_frames*AV_TIME_BASE \/ av_q2d(st->avg_frame_rate) : 0;\n\n        ist->next_pts = AV_NOPTS_VALUE;\n\n        ist->is_start = 1;\n\n    }\n\n\n\n    \/* set meta data information from input file if required *\/\n\n    for (i=0;i<nb_meta_data_maps;i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            snprintf(error, sizeof(error), \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            ret = AVERROR(EINVAL);\\\n\n            goto dump_format;\\\n\n        }\n\n\n\n        int out_file_index = meta_data_maps[i][0].file;\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0 || out_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(out_file_index, nb_output_files, \"output file\")\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = output_files[out_file_index];\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    \/* copy global metadata by default *\/\n\n    if (metadata_global_autocopy) {\n\n\n\n        for (i = 0; i < nb_output_files; i++)\n\n            av_dict_copy(&output_files[i]->metadata, input_files[0].ctx->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    \/* copy chapters according to chapter maps *\/\n\n    for (i = 0; i < nb_chapter_maps; i++) {\n\n        int infile  = chapter_maps[i].in_file;\n\n        int outfile = chapter_maps[i].out_file;\n\n\n\n        if (infile < 0 || outfile < 0)\n\n            continue;\n\n        if (infile >= nb_input_files) {\n\n            snprintf(error, sizeof(error), \"Invalid input file index %d in chapter mapping.\\n\", infile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        if (outfile >= nb_output_files) {\n\n            snprintf(error, sizeof(error), \"Invalid output file index %d in chapter mapping.\\n\",outfile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        copy_chapters(infile, outfile);\n\n    }\n\n\n\n    \/* copy chapters from the first input file that has them*\/\n\n    if (!nb_chapter_maps)\n\n        for (i = 0; i < nb_input_files; i++) {\n\n            if (!input_files[i].ctx->nb_chapters)\n\n                continue;\n\n\n\n            for (j = 0; j < nb_output_files; j++)\n\n                if ((ret = copy_chapters(i, j)) < 0)\n\n                    goto dump_format;\n\n            break;\n\n        }\n\n\n\n    \/* open files and write file headers *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (avformat_write_header(os, &output_opts[i]) < 0) {\n\n            snprintf(error, sizeof(error), \"Could not write header for output file #%d (incorrect codec parameters ?)\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        assert_avoptions(output_opts[i]);\n\n        if (strcmp(output_files[i]->oformat->name, \"rtp\")) {\n\n            want_sdp = 0;\n\n        }\n\n    }\n\n\n\n dump_format:\n\n    \/* dump the file output parameters - cannot be done before in case\n\n       of stream copy *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    \/* dump the stream mapping *\/\n\n    if (verbose >= 0) {\n\n        fprintf(stderr, \"Stream mapping:\\n\");\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\",\n\n                    input_streams[ost->source_index].file_index,\n\n                    input_streams[ost->source_index].st->index,\n\n                    ost->file_index,\n\n                    ost->index);\n\n            if (ost->sync_ist != &input_streams[ost->source_index])\n\n                fprintf(stderr, \" [sync #%d.%d]\",\n\n                        ost->sync_ist->file_index,\n\n                        ost->sync_ist->st->index);\n\n            fprintf(stderr, \"\\n\");\n\n        }\n\n    }\n\n\n\n    if (ret) {\n\n        fprintf(stderr, \"%s\\n\", error);\n\n        goto fail;\n\n    }\n\n\n\n    if (want_sdp) {\n\n        print_sdp(output_files, nb_output_files);\n\n    }\n\n\n\n    if (!using_stdin) {\n\n        if(verbose >= 0)\n\n            fprintf(stderr, \"Press [q] to stop, [?] for help\\n\");\n\n        avio_set_interrupt_cb(decode_interrupt_cb);\n\n    }\n\n    term_init();\n\n\n\n    timer_start = av_gettime();\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        double ipts_min;\n\n        double opts_min;\n\n\n\n    redo:\n\n        ipts_min= 1e100;\n\n        opts_min= 1e100;\n\n        \/* if 'q' pressed, exits *\/\n\n        if (!using_stdin) {\n\n            if (q_pressed)\n\n                break;\n\n            \/* read_key() returns 0 on EOF *\/\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n            if (key == '+') verbose++;\n\n            if (key == '-') verbose--;\n\n            if (key == 's') qp_hist     ^= 1;\n\n            if (key == 'h'){\n\n                if (do_hex_dump){\n\n                    do_hex_dump = do_pkt_dump = 0;\n\n                } else if(do_pkt_dump){\n\n                    do_hex_dump = 1;\n\n                } else\n\n                    do_pkt_dump = 1;\n\n                av_log_set_level(AV_LOG_DEBUG);\n\n            }\n\n            if (key == 'd' || key == 'D'){\n\n                int debug=0;\n\n                if(key == 'D') {\n\n                    debug = input_streams[0].st->codec->debug<<1;\n\n                    if(!debug) debug = 1;\n\n                    while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) \/\/unsupported, would just crash\n\n                        debug += debug;\n\n                }else\n\n                    scanf(\"%d\", &debug);\n\n                for(i=0;i<nb_input_streams;i++) {\n\n                    input_streams[i].st->codec->debug = debug;\n\n                }\n\n                for(i=0;i<nb_ostreams;i++) {\n\n                    ost = ost_table[i];\n\n                    ost->st->codec->debug = debug;\n\n                }\n\n                if(debug) av_log_set_level(AV_LOG_DEBUG);\n\n                fprintf(stderr,\"debug=%d\\n\", debug);\n\n            }\n\n            if (key == '?'){\n\n                fprintf(stderr, \"key    function\\n\"\n\n                                \"?      show this help\\n\"\n\n                                \"+      increase verbosity\\n\"\n\n                                \"-      decrease verbosity\\n\"\n\n                                \"D      cycle through available debug modes\\n\"\n\n                                \"h      dump packets\/hex press to cycle through the 3 states\\n\"\n\n                                \"q      quit\\n\"\n\n                                \"s      Show QP histogram\\n\"\n\n                );\n\n            }\n\n        }\n\n\n\n        \/* select the stream that we must read now by looking at the\n\n           smallest output pts *\/\n\n        file_index = -1;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double ipts, opts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = &input_streams[ost->source_index];\n\n            if(ist->is_past_recording_time || no_packet[ist->file_index])\n\n                continue;\n\n                opts = ost->st->pts.val * av_q2d(ost->st->time_base);\n\n            ipts = (double)ist->pts;\n\n            if (!input_files[ist->file_index].eof_reached){\n\n                if(ipts < ipts_min) {\n\n                    ipts_min = ipts;\n\n                    if(input_sync ) file_index = ist->file_index;\n\n                }\n\n                if(opts < opts_min) {\n\n                    opts_min = opts;\n\n                    if(!input_sync) file_index = ist->file_index;\n\n                }\n\n            }\n\n            if(ost->frame_number >= max_frames[ost->st->codec->codec_type]){\n\n                file_index= -1;\n\n                break;\n\n            }\n\n        }\n\n        \/* if none, if is finished *\/\n\n        if (file_index < 0) {\n\n            if(no_packet_count){\n\n                no_packet_count=0;\n\n                memset(no_packet, 0, sizeof(no_packet));\n\n                usleep(10000);\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n\n\n        \/* finish if limit size exhausted *\/\n\n        if (limit_filesize != 0 && limit_filesize <= avio_tell(output_files[0]->pb))\n\n            break;\n\n\n\n        \/* read a frame from it and output it in the fifo *\/\n\n        is = input_files[file_index].ctx;\n\n        ret= av_read_frame(is, &pkt);\n\n        if(ret == AVERROR(EAGAIN)){\n\n            no_packet[file_index]=1;\n\n            no_packet_count++;\n\n            continue;\n\n        }\n\n        if (ret < 0) {\n\n            input_files[file_index].eof_reached = 1;\n\n            if (opt_shortest)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        no_packet_count=0;\n\n        memset(no_packet, 0, sizeof(no_packet));\n\n\n\n        if (do_pkt_dump) {\n\n            av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,\n\n                             is->streams[pkt.stream_index]);\n\n        }\n\n        \/* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them *\/\n\n        if (pkt.stream_index >= input_files[file_index].ctx->nb_streams)\n\n            goto discard_packet;\n\n        ist_index = input_files[file_index].ist_index + pkt.stream_index;\n\n        ist = &input_streams[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        if (pkt.dts != AV_NOPTS_VALUE)\n\n            pkt.dts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n        if (pkt.pts != AV_NOPTS_VALUE)\n\n            pkt.pts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n\n\n        if (ist->ts_scale) {\n\n            if(pkt.pts != AV_NOPTS_VALUE)\n\n                pkt.pts *= ist->ts_scale;\n\n            if(pkt.dts != AV_NOPTS_VALUE)\n\n                pkt.dts *= ist->ts_scale;\n\n        }\n\n\n\n\/\/        fprintf(stderr, \"next:%\"PRId64\" dts:%\"PRId64\" off:%\"PRId64\" %d\\n\", ist->next_pts, pkt.dts, input_files[ist->file_index].ts_offset, ist->st->codec->codec_type);\n\n        if (pkt.dts != AV_NOPTS_VALUE && ist->next_pts != AV_NOPTS_VALUE\n\n            && (is->iformat->flags & AVFMT_TS_DISCONT)) {\n\n            int64_t pkt_dts= av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            int64_t delta= pkt_dts - ist->next_pts;\n\n            if((FFABS(delta) > 1LL*dts_delta_threshold*AV_TIME_BASE || pkt_dts+1<ist->pts)&& !copy_ts){\n\n                input_files[ist->file_index].ts_offset -= delta;\n\n                if (verbose > 2)\n\n                    fprintf(stderr, \"timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n\n                            delta, input_files[ist->file_index].ts_offset);\n\n                pkt.dts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n                if(pkt.pts != AV_NOPTS_VALUE)\n\n                    pkt.pts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n            }\n\n        }\n\n\n\n        \/* finish if recording time exhausted *\/\n\n        if (recording_time != INT64_MAX &&\n\n            (pkt.pts != AV_NOPTS_VALUE ?\n\n                av_compare_ts(pkt.pts, ist->st->time_base, recording_time + start_time, (AVRational){1, 1000000})\n\n                    :\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, recording_time + start_time, (AVRational){1, 1000000})\n\n            )>= 0) {\n\n            ist->is_past_recording_time = 1;\n\n            goto discard_packet;\n\n        }\n\n\n\n        \/\/fprintf(stderr,\"read #%d.%d size=%d\\n\", ist->file_index, ist->st->index, pkt.size);\n\n        if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n\n\n\n            if (verbose >= 0)\n\n                fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                        ist->file_index, ist->st->index);\n\n            if (exit_on_error)\n\n                ffmpeg_exit(1);\n\n            av_free_packet(&pkt);\n\n            goto redo;\n\n        }\n\n\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n\n\n        \/* dump report by using the output first video and audio streams *\/\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n\n\n    \/* at the end of stream, we must flush the decoder buffers *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            output_packet(ist, i, ost_table, nb_ostreams, NULL);\n\n        }\n\n    }\n\n\n\n    term_exit();\n\n\n\n    \/* write the trailer if needed and close file *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n\n\n    \/* dump report by using the first video and audio streams *\/\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    \/* close each encoder *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec->stats_in);\n\n            avcodec_close(ost->st->codec);\n\n        }\n\n#if CONFIG_AVFILTER\n\n        avfilter_graph_free(&ost->graph);\n\n#endif\n\n    }\n\n\n\n    \/* close each decoder *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(ist->st->codec);\n\n        }\n\n    }\n\n\n\n    \/* finished ! *\/\n\n    ret = 0;\n\n\n\n fail:\n\n    av_freep(&bit_buffer);\n\n\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->st->stream_copy)\n\n                    av_freep(&ost->st->codec->extradata);\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                av_fifo_free(ost->fifo); \/* works even if fifo is not\n\n                                             initialized but set to zero *\/\n\n                av_freep(&ost->st->codec->subtitle_header);\n\n                av_free(ost->resample_frame.data[0]);\n\n                av_free(ost->forced_kf_pts);\n\n                if (ost->video_resample)\n\n                    sws_freeContext(ost->img_resample_ctx);\n\n                if (ost->resample)\n\n                    audio_resample_close(ost->resample);\n\n                if (ost->reformat_ctx)\n\n                    av_audio_convert_free(ost->reformat_ctx);\n\n                av_dict_free(&ost->opts);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n}\n","idx":1,"target":0}
{"code":"static void xvid_idct_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n\n{\n\n    ff_xvid_idct(block);\n\n    ff_put_pixels_clamped(block, dest, line_size);\n\n}\n","idx":22532,"target":1}
{"code":"int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  \/* We're dealing with plain vanilla WAVEFORMAT *\/\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  \/* We're obviously dealing with WAVEFORMATEX *\/\n\n        int cbSize = avio_rl16(pb); \/* cbSize *\/\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { \/* WAVEFORMATEXTENSIBLE *\/\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        \/* It is possible for the chunk to contain garbage at the end *\/\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        \/* Channels and sample_rate values are those prior to applying SBR\n\n         * and\/or PS. *\/\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    \/* override bits_per_coded_sample for G.726 *\/\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate \/ codec->sample_rate;\n\n\n\n    return 0;\n\n}\n","idx":3,"target":0}
{"code":"static int config_props(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    LutContext *lut = ctx->priv;\n\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];\n\n    int min[4], max[4];\n\n    int val, comp, ret;\n\n\n\n    lut->hsub = desc->log2_chroma_w;\n\n    lut->vsub = desc->log2_chroma_h;\n\n\n\n    lut->var_values[VAR_W] = inlink->w;\n\n    lut->var_values[VAR_H] = inlink->h;\n\n\n\n    switch (inlink->format) {\n\n    case PIX_FMT_YUV410P:\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV440P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_YUVA420P:\n\n        min[Y] = min[U] = min[V] = 16;\n\n        max[Y] = 235;\n\n        max[U] = max[V] = 240;\n\n        min[A] = 0; max[A] = 255;\n\n        break;\n\n    default:\n\n        min[0] = min[1] = min[2] = min[3] = 0;\n\n        max[0] = max[1] = max[2] = max[3] = 255;\n\n    }\n\n\n\n    lut->is_yuv = lut->is_rgb = 0;\n\n    if      (ff_fmt_is_in(inlink->format, yuv_pix_fmts)) lut->is_yuv = 1;\n\n    else if (ff_fmt_is_in(inlink->format, rgb_pix_fmts)) lut->is_rgb = 1;\n\n\n\n    if (lut->is_rgb) {\n\n        switch (inlink->format) {\n\n        case PIX_FMT_ARGB:  lut->rgba_map[A] = 0; lut->rgba_map[R] = 1; lut->rgba_map[G] = 2; lut->rgba_map[B] = 3; break;\n\n        case PIX_FMT_ABGR:  lut->rgba_map[A] = 0; lut->rgba_map[B] = 1; lut->rgba_map[G] = 2; lut->rgba_map[R] = 3; break;\n\n        case PIX_FMT_RGBA:\n\n        case PIX_FMT_RGB24: lut->rgba_map[R] = 0; lut->rgba_map[G] = 1; lut->rgba_map[B] = 2; lut->rgba_map[A] = 3; break;\n\n        case PIX_FMT_BGRA:\n\n        case PIX_FMT_BGR24: lut->rgba_map[B] = 0; lut->rgba_map[G] = 1; lut->rgba_map[R] = 2; lut->rgba_map[A] = 3; break;\n\n        }\n\n        lut->step = av_get_bits_per_pixel(desc) >> 3;\n\n    }\n\n\n\n    for (comp = 0; comp < desc->nb_components; comp++) {\n\n        double res;\n\n\n\n        \/* create the parsed expression *\/\n\n        ret = av_expr_parse(&lut->comp_expr[comp], lut->comp_expr_str[comp],\n\n                            var_names, funcs1_names, funcs1, NULL, NULL, 0, ctx);\n\n        if (ret < 0) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Error when parsing the expression '%s' for the component %d.\\n\",\n\n                   lut->comp_expr_str[comp], comp);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        \/* compute the lut *\/\n\n        lut->var_values[VAR_MAXVAL] = max[comp];\n\n        lut->var_values[VAR_MINVAL] = min[comp];\n\n\n\n        for (val = 0; val < 256; val++) {\n\n            lut->var_values[VAR_VAL] = val;\n\n            lut->var_values[VAR_CLIPVAL] = av_clip(val, min[comp], max[comp]);\n\n            lut->var_values[VAR_NEGVAL] =\n\n                av_clip(min[comp] + max[comp] - lut->var_values[VAR_VAL],\n\n                        min[comp], max[comp]);\n\n\n\n            res = av_expr_eval(lut->comp_expr[comp], lut->var_values, lut);\n\n            if (isnan(res)) {\n\n                av_log(ctx, AV_LOG_ERROR,\n\n                       \"Error when evaluating the expression '%s' for the value %d for the component #%d.\\n\",\n\n                       lut->comp_expr_str[comp], val, comp);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            lut->lut[comp][val] = av_clip((int)res, min[comp], max[comp]);\n\n            av_log(ctx, AV_LOG_DEBUG, \"val[%d][%d] = %d\\n\", comp, val, lut->lut[comp][val]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":30,"target":0}
{"code":"static void usb_hid_changed(HIDState *hs)\n\n{\n\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n\n\n\n    us->changed = 1;\n\n\n\n    if (us->datain) {\n\n        us->datain(us->datain_opaque);\n\n    }\n\n\n\n    usb_wakeup(&us->dev);\n\n}\n","idx":54,"target":0}
{"code":"static void destroy_buffers(SANMVideoContext *ctx)\n\n{\n\n    av_freep(&ctx->frm0);\n\n    av_freep(&ctx->frm1);\n\n    av_freep(&ctx->frm2);\n\n    av_freep(&ctx->stored_frame);\n\n    av_freep(&ctx->rle_buf);\n\n    ctx->frm0_size =\n\n    ctx->frm1_size =\n\n    ctx->frm2_size = 0;\n\n\n}","idx":615,"target":1}
{"code":"static av_cold int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n","idx":31,"target":0}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    HQDN3DContext *s = inlink->dst->priv;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    int i;\n    s->hsub  = desc->log2_chroma_w;\n    s->vsub  = desc->log2_chroma_h;\n    s->depth = desc->comp[0].depth_minus1+1;\n    s->line = av_malloc(inlink->w * sizeof(*s->line));\n    if (!s->line)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < 4; i++) {\n        s->coefs[i] = precalc_coefs(s->strength[i], s->depth);\n        if (!s->coefs[i])\n            return AVERROR(ENOMEM);\n    }\n    if (ARCH_X86)\n        ff_hqdn3d_init_x86(s);\n    return 0;\n}","idx":8195,"target":1}
{"code":"int kvm_arch_init(KVMState *s)\n\n{\n\n    uint64_t identity_base = 0xfffbc000;\n\n    int ret;\n\n    struct utsname utsname;\n\n\n\n    ret = kvm_get_supported_msrs(s);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    uname(&utsname);\n\n    lm_capable_kernel = strcmp(utsname.machine, \"x86_64\") == 0;\n\n\n\n    \/*\n\n     * On older Intel CPUs, KVM uses vm86 mode to emulate 16-bit code directly.\n\n     * In order to use vm86 mode, an EPT identity map and a TSS  are needed.\n\n     * Since these must be part of guest physical memory, we need to allocate\n\n     * them, both by setting their start addresses in the kernel and by\n\n     * creating a corresponding e820 entry. We need 4 pages before the BIOS.\n\n     *\n\n     * Older KVM versions may not support setting the identity map base. In\n\n     * that case we need to stick with the default, i.e. a 256K maximum BIOS\n\n     * size.\n\n     *\/\n\n#ifdef KVM_CAP_SET_IDENTITY_MAP_ADDR\n\n    if (kvm_check_extension(s, KVM_CAP_SET_IDENTITY_MAP_ADDR)) {\n\n        \/* Allows up to 16M BIOSes. *\/\n\n        identity_base = 0xfeffc000;\n\n\n\n        ret = kvm_vm_ioctl(s, KVM_SET_IDENTITY_MAP_ADDR, &identity_base);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    \/* Set TSS base one page after EPT identity map. *\/\n\n    ret = kvm_vm_ioctl(s, KVM_SET_TSS_ADDR, identity_base + 0x1000);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Tell fw_cfg to notify the BIOS to reserve the range. *\/\n\n    ret = e820_add_entry(identity_base, 0x4000, E820_RESERVED);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"e820_add_entry() table is full\\n\");\n\n        return ret;\n\n    }\n\n\n\n\n    return 0;\n\n}","idx":8772,"target":1}
{"code":"void hmp_block_set_io_throttle(Monitor *mon, const QDict *qdict)\n\n{\n\n    Error *err = NULL;\n\n\n\n    qmp_block_set_io_throttle(qdict_get_str(qdict, \"device\"),\n\n                              qdict_get_int(qdict, \"bps\"),\n\n                              qdict_get_int(qdict, \"bps_rd\"),\n\n                              qdict_get_int(qdict, \"bps_wr\"),\n\n                              qdict_get_int(qdict, \"iops\"),\n\n                              qdict_get_int(qdict, \"iops_rd\"),\n\n                              qdict_get_int(qdict, \"iops_wr\"), &err);\n\n    hmp_handle_error(mon, &err);\n\n}\n","idx":5533,"target":1}
{"code":"MigrationState *tcp_start_outgoing_migration(Monitor *mon,\n\n                                             const char *host_port,\n\n                                             int64_t bandwidth_limit,\n\n                                             int detach,\n\n\t\t\t\t\t     int blk,\n\n\t\t\t\t\t     int inc)\n\n{\n\n    struct sockaddr_in addr;\n\n    FdMigrationState *s;\n\n    int ret;\n\n\n\n    if (parse_host_port(&addr, host_port) < 0)\n\n        return NULL;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n\n\n    s->get_error = socket_errno;\n\n    s->write = socket_write;\n\n    s->close = tcp_close;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->mig_state.blk = blk;\n\n    s->mig_state.shared = inc;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->mon = NULL;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n    s->fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (s->fd == -1) {\n\n        qemu_free(s);\n\n        return NULL;\n\n    }\n\n\n\n    socket_set_nonblock(s->fd);\n\n\n\n    if (!detach) {\n\n        migrate_fd_monitor_suspend(s, mon);\n\n    }\n\n\n\n    do {\n\n        ret = connect(s->fd, (struct sockaddr *)&addr, sizeof(addr));\n\n        if (ret == -1)\n\n            ret = -(s->get_error(s));\n\n\n\n        if (ret == -EINPROGRESS || ret == -EWOULDBLOCK)\n\n            qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);\n\n    } while (ret == -EINTR);\n\n\n\n    if (ret < 0 && ret != -EINPROGRESS && ret != -EWOULDBLOCK) {\n\n        dprintf(\"connect failed\\n\");\n\n        close(s->fd);\n\n        qemu_free(s);\n\n        return NULL;\n\n    } else if (ret >= 0)\n\n        migrate_fd_connect(s);\n\n\n\n    return &s->mig_state;\n\n}\n","idx":13607,"target":1}
{"code":"PP_Flash_Menu* ReadMenu(int depth,\n                        const IPC::Message* m,\n                        PickleIterator* iter) {\n  if (depth > kMaxMenuDepth)\n    return NULL;\n  ++depth;\n\n  PP_Flash_Menu* menu = new PP_Flash_Menu;\n  menu->items = NULL;\n\n  if (!m->ReadUInt32(iter, &menu->count)) {\n    FreeMenu(menu);\n    return NULL;\n  }\n\n   if (menu->count == 0)\n     return menu;\n \n   menu->items = new PP_Flash_MenuItem[menu->count];\n   memset(menu->items, 0, sizeof(PP_Flash_MenuItem) * menu->count);\n   for (uint32_t i = 0; i < menu->count; ++i) {\n    if (!ReadMenuItem(depth, m, iter, menu->items + i)) {\n      FreeMenu(menu);\n      return NULL;\n    }\n  }\n  return menu;\n}\n","idx":185099,"target":1}
{"code":"static int decode_blocks(SnowContext *s){\n\n    int x, y;\n\n    int w= s->b_width;\n\n    int h= s->b_height;\n\n    int res;\n\n\n\n    for(y=0; y<h; y++){\n\n        for(x=0; x<w; x++){\n\n\n\n            if ((res = decode_q_branch(s, 0, x, y)) < 0)\n\n                return res;\n\n        }\n\n    }\n\n    return 0;\n\n}","idx":5360,"target":1}
{"code":"void helper_divl_EAX_T0(void)\n\n{\n\n    unsigned int den, q, r;\n\n    uint64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = div32(&q, num, den);\n\n#else\n\n    q = (num \/ den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n","idx":13902,"target":1}
{"code":"void ff_celt_quant_bands(CeltFrame *f, OpusRangeCoder *rc)\n\n{\n\n    float lowband_scratch[8 * 22];\n\n    float norm1[2 * 8 * 100];\n\n    float *norm2 = norm1 + 8 * 100;\n\n\n\n    int totalbits = (f->framebits << 3) - f->anticollapse_needed;\n\n\n\n    int update_lowband = 1;\n\n    int lowband_offset = 0;\n\n\n\n    int i, j;\n\n\n\n    for (i = f->start_band; i < f->end_band; i++) {\n\n        uint32_t cm[2] = { (1 << f->blocks) - 1, (1 << f->blocks) - 1 };\n\n        int band_offset = ff_celt_freq_bands[i] << f->size;\n\n        int band_size   = ff_celt_freq_range[i] << f->size;\n\n        float *X = f->block[0].coeffs + band_offset;\n\n        float *Y = (f->channels == 2) ? f->block[1].coeffs + band_offset : NULL;\n\n        float *norm_loc1, *norm_loc2;\n\n\n\n        int consumed = opus_rc_tell_frac(rc);\n\n        int effective_lowband = -1;\n\n        int b = 0;\n\n\n\n        \/* Compute how many bits we want to allocate to this band *\/\n\n        if (i != f->start_band)\n\n            f->remaining -= consumed;\n\n        f->remaining2 = totalbits - consumed - 1;\n\n        if (i <= f->coded_bands - 1) {\n\n            int curr_balance = f->remaining \/ FFMIN(3, f->coded_bands-i);\n\n            b = av_clip_uintp2(FFMIN(f->remaining2 + 1, f->pulses[i] + curr_balance), 14);\n\n        }\n\n\n\n        if ((ff_celt_freq_bands[i] - ff_celt_freq_range[i] >= ff_celt_freq_bands[f->start_band] ||\n\n            i == f->start_band + 1) && (update_lowband || lowband_offset == 0))\n\n            lowband_offset = i;\n\n\n\n        if (i == f->start_band + 1) {\n\n            \/* Special Hybrid Folding (RFC 8251 section 9). Copy the first band into\n\n            the second to ensure the second band never has to use the LCG. *\/\n\n            int offset = 8 * ff_celt_freq_bands[i];\n\n            int count = 8 * (ff_celt_freq_range[i] - ff_celt_freq_range[i-1]);\n\n\n\n            memcpy(&norm1[offset], &norm1[offset - count], count * sizeof(float));\n\n\n\n            if (f->channels == 2)\n\n                memcpy(&norm2[offset], &norm2[offset - count], count * sizeof(float));\n\n        }\n\n\n\n        \/* Get a conservative estimate of the collapse_mask's for the bands we're\n\n           going to be folding from. *\/\n\n        if (lowband_offset != 0 && (f->spread != CELT_SPREAD_AGGRESSIVE ||\n\n                                    f->blocks > 1 || f->tf_change[i] < 0)) {\n\n            int foldstart, foldend;\n\n\n\n            \/* This ensures we never repeat spectral content within one band *\/\n\n            effective_lowband = FFMAX(ff_celt_freq_bands[f->start_band],\n\n                                      ff_celt_freq_bands[lowband_offset] - ff_celt_freq_range[i]);\n\n            foldstart = lowband_offset;\n\n            while (ff_celt_freq_bands[--foldstart] > effective_lowband);\n\n            foldend = lowband_offset - 1;\n\n            while (++foldend < i && ff_celt_freq_bands[foldend] < effective_lowband + ff_celt_freq_range[i]);\n\n\n\n            cm[0] = cm[1] = 0;\n\n            for (j = foldstart; j < foldend; j++) {\n\n                cm[0] |= f->block[0].collapse_masks[j];\n\n                cm[1] |= f->block[f->channels - 1].collapse_masks[j];\n\n            }\n\n        }\n\n\n\n        if (f->dual_stereo && i == f->intensity_stereo) {\n\n            \/* Switch off dual stereo to do intensity *\/\n\n            f->dual_stereo = 0;\n\n            for (j = ff_celt_freq_bands[f->start_band] << f->size; j < band_offset; j++)\n\n                norm1[j] = (norm1[j] + norm2[j]) \/ 2;\n\n        }\n\n\n\n        norm_loc1 = effective_lowband != -1 ? norm1 + (effective_lowband << f->size) : NULL;\n\n        norm_loc2 = effective_lowband != -1 ? norm2 + (effective_lowband << f->size) : NULL;\n\n\n\n        if (f->dual_stereo) {\n\n            cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X, NULL, band_size, b >> 1,\n\n                                       f->blocks, norm_loc1, f->size,\n\n                                       norm1 + band_offset, 0, 1.0f,\n\n                                       lowband_scratch, cm[0]);\n\n\n\n            cm[1] = f->pvq->quant_band(f->pvq, f, rc, i, Y, NULL, band_size, b >> 1,\n\n                                       f->blocks, norm_loc2, f->size,\n\n                                       norm2 + band_offset, 0, 1.0f,\n\n                                       lowband_scratch, cm[1]);\n\n        } else {\n\n            cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X,    Y, band_size, b >> 0,\n\n                                       f->blocks, norm_loc1, f->size,\n\n                                       norm1 + band_offset, 0, 1.0f,\n\n                                       lowband_scratch, cm[0] | cm[1]);\n\n            cm[1] = cm[0];\n\n        }\n\n\n\n        f->block[0].collapse_masks[i]               = (uint8_t)cm[0];\n\n        f->block[f->channels - 1].collapse_masks[i] = (uint8_t)cm[1];\n\n        f->remaining += f->pulses[i] + consumed;\n\n\n\n        \/* Update the folding position only as long as we have 1 bit\/sample depth *\/\n\n        update_lowband = (b > band_size << 3);\n\n    }\n\n}\n","idx":11106,"target":1}
{"code":"static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            const uint8_t *buf, int buf_size)\n\n{\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n;\n\n    short *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    uint8_t *dstu8;\n\n    int16_t *dst_int16_t;\n\n    int32_t *dst_int32_t;\n\n    int64_t *dst_int64_t;\n\n    uint16_t *dst_uint16_t;\n\n    uint32_t *dst_uint32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)\/8;\n\n\n\n    \/* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD *\/\n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        \/* 2 samples are interleaved per block in PCM_DVD *\/\n\n        sample_size = avctx->bits_per_coded_sample * 2 \/ 8;\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n        return -1;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size\/2);\n\n    *data_size=0;\n\n\n\n    n = buf_size\/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; \/\/ sync flags are here\n\n          *samples++ = ff_reverse[(v >> 8) & 0xff] +\n\n                       (ff_reverse[v & 0xff] << 8);\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n \/= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++)\n\n                *samples++ = bytestream_get_le16(&src2[c]);\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        dstu8= (uint8_t*)samples;\n\n        for(;n>0;n--) {\n\n            *dstu8++ = *src++ + 128;\n\n        }\n\n        samples= (short*)dstu8;\n\n        break;\n\n#if WORDS_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif \/* WORDS_BIGENDIAN *\/\n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples = (short*)((uint8_t*)data + n*sample_size);\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            *samples++ = x << 8;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            *samples++ = s->table[*src++];\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n \/= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n            break;\n\n        }\n\n        samples = (short *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n","idx":95,"target":0}
{"code":"static inline bool vhost_needs_vring_endian(VirtIODevice *vdev)\n\n{\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        return false;\n\n    }\n\n#ifdef TARGET_IS_BIENDIAN\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    return !virtio_is_big_endian(vdev);\n\n#else\n\n    return virtio_is_big_endian(vdev);\n\n#endif\n\n#else\n\n    return false;\n\n#endif\n\n}\n","idx":68,"target":0}
{"code":"void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n}\n","idx":48,"target":0}
{"code":"static int decode_idat_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length, AVFrame *p)\n\n{\n\n    int ret;\n\n    size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n\n\n\n    if (!(s->state & PNG_IHDR)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"IDAT without IHDR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!(s->state & PNG_IDAT)) {\n\n        \/* init image info *\/\n\n        avctx->width  = s->width;\n\n        avctx->height = s->height;\n\n\n\n        s->channels       = ff_png_get_nb_channels(s->color_type);\n\n        s->bits_per_pixel = s->bit_depth * s->channels;\n\n        s->bpp            = (s->bits_per_pixel + 7) >> 3;\n\n        s->row_size       = (s->cur_w * s->bits_per_pixel + 7) >> 3;\n\n\n\n        if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n\n                s->color_type == PNG_COLOR_TYPE_RGB) {\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n        } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n\n            avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n        } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n\n                s->color_type == PNG_COLOR_TYPE_GRAY) {\n\n            avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n\n        } else if (s->bit_depth == 16 &&\n\n                s->color_type == PNG_COLOR_TYPE_GRAY) {\n\n            avctx->pix_fmt = AV_PIX_FMT_GRAY16BE;\n\n        } else if (s->bit_depth == 16 &&\n\n                s->color_type == PNG_COLOR_TYPE_RGB) {\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB48BE;\n\n        } else if (s->bit_depth == 16 &&\n\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n\n            avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n\n        } else if ((s->bits_per_pixel == 1 || s->bits_per_pixel == 2 || s->bits_per_pixel == 4 || s->bits_per_pixel == 8) &&\n\n                s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n        } else if (s->bit_depth == 1 && s->bits_per_pixel == 1 && avctx->codec_id != AV_CODEC_ID_APNG) {\n\n            avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n\n        } else if (s->bit_depth == 8 &&\n\n                s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n\n            avctx->pix_fmt = AV_PIX_FMT_YA8;\n\n        } else if (s->bit_depth == 16 &&\n\n                s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n\n            avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n\n        } else {\n\n            av_log(avctx, AV_LOG_ERROR, \"unsupported bit depth %d \"\n\n                    \"and color type %d\\n\",\n\n                    s->bit_depth, s->color_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n\n            switch (avctx->pix_fmt) {\n\n            case AV_PIX_FMT_RGB24:\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n                break;\n\n\n\n            case AV_PIX_FMT_RGB48BE:\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n\n                break;\n\n\n\n            case AV_PIX_FMT_GRAY8:\n\n                avctx->pix_fmt = AV_PIX_FMT_YA8;\n\n                break;\n\n\n\n            case AV_PIX_FMT_GRAY16BE:\n\n                avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n\n                break;\n\n\n\n            default:\n\n                avpriv_request_sample(avctx, \"bit depth %d \"\n\n                        \"and color type %d with TRNS\",\n\n                        s->bit_depth, s->color_type);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            s->bpp += byte_depth;\n\n        }\n\n\n\n        if ((ret = ff_thread_get_buffer(avctx, &s->picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n            return ret;\n\n        if (avctx->codec_id == AV_CODEC_ID_APNG && s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n\n            ff_thread_release_buffer(avctx, &s->previous_picture);\n\n            if ((ret = ff_thread_get_buffer(avctx, &s->previous_picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n                return ret;\n\n        }\n\n        ff_thread_finish_setup(avctx);\n\n\n\n        p->pict_type        = AV_PICTURE_TYPE_I;\n\n        p->key_frame        = 1;\n\n        p->interlaced_frame = !!s->interlace_type;\n\n\n\n        \/* compute the compressed row size *\/\n\n        if (!s->interlace_type) {\n\n            s->crow_size = s->row_size + 1;\n\n        } else {\n\n            s->pass          = 0;\n\n            s->pass_row_size = ff_png_pass_row_size(s->pass,\n\n                    s->bits_per_pixel,\n\n                    s->cur_w);\n\n            s->crow_size = s->pass_row_size + 1;\n\n        }\n\n        ff_dlog(avctx, \"row_size=%d crow_size =%d\\n\",\n\n                s->row_size, s->crow_size);\n\n        s->image_buf      = p->data[0];\n\n        s->image_linesize = p->linesize[0];\n\n        \/* copy the palette if needed *\/\n\n        if (avctx->pix_fmt == AV_PIX_FMT_PAL8)\n\n            memcpy(p->data[1], s->palette, 256 * sizeof(uint32_t));\n\n        \/* empty row is used if differencing to the first row *\/\n\n        av_fast_padded_mallocz(&s->last_row, &s->last_row_size, s->row_size);\n\n        if (!s->last_row)\n\n            return AVERROR_INVALIDDATA;\n\n        if (s->interlace_type ||\n\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n\n            av_fast_padded_malloc(&s->tmp_row, &s->tmp_row_size, s->row_size);\n\n            if (!s->tmp_row)\n\n                return AVERROR_INVALIDDATA;\n\n        }\n\n        \/* compressed row *\/\n\n        av_fast_padded_malloc(&s->buffer, &s->buffer_size, s->row_size + 16);\n\n        if (!s->buffer)\n\n            return AVERROR(ENOMEM);\n\n\n\n        \/* we want crow_buf+1 to be 16-byte aligned *\/\n\n        s->crow_buf          = s->buffer + 15;\n\n        s->zstream.avail_out = s->crow_size;\n\n        s->zstream.next_out  = s->crow_buf;\n\n    }\n\n\n\n    s->state |= PNG_IDAT;\n\n\n\n    \/* set image to non-transparent bpp while decompressing *\/\n\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE)\n\n        s->bpp -= byte_depth;\n\n\n\n    ret = png_decode_idat(s, length);\n\n\n\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE)\n\n        s->bpp += byte_depth;\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    bytestream2_skip(&s->gb, 4); \/* crc *\/\n\n\n\n    return 0;\n\n}\n","idx":11243,"target":1}
{"code":"BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)\n\t{\n\t\/* k = SHA1(PAD(A) || PAD(B) ) -- tls-srp draft 8 *\/\n\n\tBIGNUM *u;\t\n\tunsigned char cu[SHA_DIGEST_LENGTH];\n\tunsigned char *cAB;\n\tEVP_MD_CTX ctxt;\n\tint longN;  \n\tif ((A == NULL) ||(B == NULL) || (N == NULL))\n\t\treturn NULL;\n\n        if ((A == NULL) ||(B == NULL) || (N == NULL))\n                return NULL;\n \n        longN= BN_num_bytes(N);\n \n        if ((cAB = OPENSSL_malloc(2*longN)) == NULL) \n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);\n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);\n\tOPENSSL_free(cAB);\n\tEVP_DigestFinal_ex(&ctxt, cu, NULL);\n\tEVP_MD_CTX_cleanup(&ctxt);\n\n\tif (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))\n\t\treturn NULL;\n\tif (!BN_is_zero(u))\n\t\treturn u;\n\tBN_free(u);\n\treturn NULL;\n}\n","idx":178344,"target":1}
{"code":"static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; \/* clear head *\/\n\n    \/* put signature *\/\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n","idx":44,"target":0}
{"code":"void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIRequest *sreq = req->sreq;\n\n    if (scsi_req_enqueue(sreq)) {\n\n        scsi_req_continue(sreq);\n\n    }\n\n    bdrv_io_unplug(sreq->dev->conf.bs);\n\n    scsi_req_unref(sreq);\n\n}\n","idx":59,"target":0}
{"code":"static int gdb_handle_packet(GDBState *s, const char *line_buf)\n\n{\n\n    CPUArchState *env;\n\n    const char *p;\n\n    uint32_t thread;\n\n    int ch, reg_size, type, res;\n\n    char buf[MAX_PACKET_LENGTH];\n\n    uint8_t mem_buf[MAX_PACKET_LENGTH];\n\n    uint8_t *registers;\n\n    target_ulong addr, len;\n\n\n\n#ifdef DEBUG_GDB\n\n    printf(\"command='%s'\\n\", line_buf);\n\n#endif\n\n    p = line_buf;\n\n    ch = *p++;\n\n    switch(ch) {\n\n    case '?':\n\n        \/* TODO: Make this return the correct value for user-mode.  *\/\n\n        snprintf(buf, sizeof(buf), \"T%02xthread:%02x;\", GDB_SIGNAL_TRAP,\n\n                 cpu_index(ENV_GET_CPU(s->c_cpu)));\n\n        put_packet(s, buf);\n\n        \/* Remove all the breakpoints when this query is issued,\n\n         * because gdb is doing and initial connect and the state\n\n         * should be cleaned up.\n\n         *\/\n\n        gdb_breakpoint_remove_all();\n\n        break;\n\n    case 'c':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n            gdb_set_cpu_pc(s, addr);\n\n        }\n\n        s->signal = 0;\n\n        gdb_continue(s);\n\n\treturn RS_IDLE;\n\n    case 'C':\n\n        s->signal = gdb_signal_to_target (strtoul(p, (char **)&p, 16));\n\n        if (s->signal == -1)\n\n            s->signal = 0;\n\n        gdb_continue(s);\n\n        return RS_IDLE;\n\n    case 'v':\n\n        if (strncmp(p, \"Cont\", 4) == 0) {\n\n            int res_signal, res_thread;\n\n\n\n            p += 4;\n\n            if (*p == '?') {\n\n                put_packet(s, \"vCont;c;C;s;S\");\n\n                break;\n\n            }\n\n            res = 0;\n\n            res_signal = 0;\n\n            res_thread = 0;\n\n            while (*p) {\n\n                int action, signal;\n\n\n\n                if (*p++ != ';') {\n\n                    res = 0;\n\n                    break;\n\n                }\n\n                action = *p++;\n\n                signal = 0;\n\n                if (action == 'C' || action == 'S') {\n\n                    signal = strtoul(p, (char **)&p, 16);\n\n                } else if (action != 'c' && action != 's') {\n\n                    res = 0;\n\n                    break;\n\n                }\n\n                thread = 0;\n\n                if (*p == ':') {\n\n                    thread = strtoull(p+1, (char **)&p, 16);\n\n                }\n\n                action = tolower(action);\n\n                if (res == 0 || (res == 'c' && action == 's')) {\n\n                    res = action;\n\n                    res_signal = signal;\n\n                    res_thread = thread;\n\n                }\n\n            }\n\n            if (res) {\n\n                if (res_thread != -1 && res_thread != 0) {\n\n                    env = find_cpu(res_thread);\n\n                    if (env == NULL) {\n\n                        put_packet(s, \"E22\");\n\n                        break;\n\n                    }\n\n                    s->c_cpu = env;\n\n                }\n\n                if (res == 's') {\n\n                    cpu_single_step(s->c_cpu, sstep_flags);\n\n                }\n\n                s->signal = res_signal;\n\n                gdb_continue(s);\n\n                return RS_IDLE;\n\n            }\n\n            break;\n\n        } else {\n\n            goto unknown_command;\n\n        }\n\n    case 'k':\n\n#ifdef CONFIG_USER_ONLY\n\n        \/* Kill the target *\/\n\n        fprintf(stderr, \"\\nQEMU: Terminated via GDBstub\\n\");\n\n        exit(0);\n\n#endif\n\n    case 'D':\n\n        \/* Detach packet *\/\n\n        gdb_breakpoint_remove_all();\n\n        gdb_syscall_mode = GDB_SYS_DISABLED;\n\n        gdb_continue(s);\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 's':\n\n        if (*p != '\\0') {\n\n            addr = strtoull(p, (char **)&p, 16);\n\n            gdb_set_cpu_pc(s, addr);\n\n        }\n\n        cpu_single_step(s->c_cpu, sstep_flags);\n\n        gdb_continue(s);\n\n\treturn RS_IDLE;\n\n    case 'F':\n\n        {\n\n            target_ulong ret;\n\n            target_ulong err;\n\n\n\n            ret = strtoull(p, (char **)&p, 16);\n\n            if (*p == ',') {\n\n                p++;\n\n                err = strtoull(p, (char **)&p, 16);\n\n            } else {\n\n                err = 0;\n\n            }\n\n            if (*p == ',')\n\n                p++;\n\n            type = *p;\n\n            if (s->current_syscall_cb) {\n\n                s->current_syscall_cb(s->c_cpu, ret, err);\n\n                s->current_syscall_cb = NULL;\n\n            }\n\n            if (type == 'C') {\n\n                put_packet(s, \"T02\");\n\n            } else {\n\n                gdb_continue(s);\n\n            }\n\n        }\n\n        break;\n\n    case 'g':\n\n        cpu_synchronize_state(ENV_GET_CPU(s->g_cpu));\n\n        env = s->g_cpu;\n\n        len = 0;\n\n        for (addr = 0; addr < num_g_regs; addr++) {\n\n            reg_size = gdb_read_register(s->g_cpu, mem_buf + len, addr);\n\n            len += reg_size;\n\n        }\n\n        memtohex(buf, mem_buf, len);\n\n        put_packet(s, buf);\n\n        break;\n\n    case 'G':\n\n        cpu_synchronize_state(ENV_GET_CPU(s->g_cpu));\n\n        env = s->g_cpu;\n\n        registers = mem_buf;\n\n        len = strlen(p) \/ 2;\n\n        hextomem((uint8_t *)registers, p, len);\n\n        for (addr = 0; addr < num_g_regs && len > 0; addr++) {\n\n            reg_size = gdb_write_register(s->g_cpu, registers, addr);\n\n            len -= reg_size;\n\n            registers += reg_size;\n\n        }\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 'm':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, NULL, 16);\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 0) != 0) {\n\n            put_packet (s, \"E14\");\n\n        } else {\n\n            memtohex(buf, mem_buf, len);\n\n            put_packet(s, buf);\n\n        }\n\n        break;\n\n    case 'M':\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (*p == ':')\n\n            p++;\n\n        hextomem(mem_buf, p, len);\n\n        if (target_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 1) != 0) {\n\n            put_packet(s, \"E14\");\n\n        } else {\n\n            put_packet(s, \"OK\");\n\n        }\n\n        break;\n\n    case 'p':\n\n        \/* Older gdb are really dumb, and don't use 'g' if 'p' is avaialable.\n\n           This works, but can be very slow.  Anything new enough to\n\n           understand XML also knows how to use this properly.  *\/\n\n        if (!gdb_has_xml)\n\n            goto unknown_command;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        reg_size = gdb_read_register(s->g_cpu, mem_buf, addr);\n\n        if (reg_size) {\n\n            memtohex(buf, mem_buf, reg_size);\n\n            put_packet(s, buf);\n\n        } else {\n\n            put_packet(s, \"E14\");\n\n        }\n\n        break;\n\n    case 'P':\n\n        if (!gdb_has_xml)\n\n            goto unknown_command;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == '=')\n\n            p++;\n\n        reg_size = strlen(p) \/ 2;\n\n        hextomem(mem_buf, p, reg_size);\n\n        gdb_write_register(s->g_cpu, mem_buf, addr);\n\n        put_packet(s, \"OK\");\n\n        break;\n\n    case 'Z':\n\n    case 'z':\n\n        type = strtoul(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        addr = strtoull(p, (char **)&p, 16);\n\n        if (*p == ',')\n\n            p++;\n\n        len = strtoull(p, (char **)&p, 16);\n\n        if (ch == 'Z')\n\n            res = gdb_breakpoint_insert(addr, len, type);\n\n        else\n\n            res = gdb_breakpoint_remove(addr, len, type);\n\n        if (res >= 0)\n\n             put_packet(s, \"OK\");\n\n        else if (res == -ENOSYS)\n\n            put_packet(s, \"\");\n\n        else\n\n            put_packet(s, \"E22\");\n\n        break;\n\n    case 'H':\n\n        type = *p++;\n\n        thread = strtoull(p, (char **)&p, 16);\n\n        if (thread == -1 || thread == 0) {\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        }\n\n        env = find_cpu(thread);\n\n        if (env == NULL) {\n\n            put_packet(s, \"E22\");\n\n            break;\n\n        }\n\n        switch (type) {\n\n        case 'c':\n\n            s->c_cpu = env;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        case 'g':\n\n            s->g_cpu = env;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        default:\n\n             put_packet(s, \"E22\");\n\n             break;\n\n        }\n\n        break;\n\n    case 'T':\n\n        thread = strtoull(p, (char **)&p, 16);\n\n        env = find_cpu(thread);\n\n\n\n        if (env != NULL) {\n\n            put_packet(s, \"OK\");\n\n        } else {\n\n            put_packet(s, \"E22\");\n\n        }\n\n        break;\n\n    case 'q':\n\n    case 'Q':\n\n        \/* parse any 'q' packets here *\/\n\n        if (!strcmp(p,\"qemu.sstepbits\")) {\n\n            \/* Query Breakpoint bit definitions *\/\n\n            snprintf(buf, sizeof(buf), \"ENABLE=%x,NOIRQ=%x,NOTIMER=%x\",\n\n                     SSTEP_ENABLE,\n\n                     SSTEP_NOIRQ,\n\n                     SSTEP_NOTIMER);\n\n            put_packet(s, buf);\n\n            break;\n\n        } else if (strncmp(p,\"qemu.sstep\",10) == 0) {\n\n            \/* Display or change the sstep_flags *\/\n\n            p += 10;\n\n            if (*p != '=') {\n\n                \/* Display current setting *\/\n\n                snprintf(buf, sizeof(buf), \"0x%x\", sstep_flags);\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n            p++;\n\n            type = strtoul(p, (char **)&p, 16);\n\n            sstep_flags = type;\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        } else if (strcmp(p,\"C\") == 0) {\n\n            \/* \"Current thread\" remains vague in the spec, so always return\n\n             *  the first CPU (gdb returns the first thread). *\/\n\n            put_packet(s, \"QC1\");\n\n            break;\n\n        } else if (strcmp(p,\"fThreadInfo\") == 0) {\n\n            s->query_cpu = first_cpu->env_ptr;\n\n            goto report_cpuinfo;\n\n        } else if (strcmp(p,\"sThreadInfo\") == 0) {\n\n        report_cpuinfo:\n\n            if (s->query_cpu) {\n\n                snprintf(buf, sizeof(buf), \"m%x\",\n\n                         cpu_index(ENV_GET_CPU(s->query_cpu)));\n\n                put_packet(s, buf);\n\n                s->query_cpu = ENV_GET_CPU(s->query_cpu)->next_cpu->env_ptr;\n\n            } else\n\n                put_packet(s, \"l\");\n\n            break;\n\n        } else if (strncmp(p,\"ThreadExtraInfo,\", 16) == 0) {\n\n            thread = strtoull(p+16, (char **)&p, 16);\n\n            env = find_cpu(thread);\n\n            if (env != NULL) {\n\n                CPUState *cpu = ENV_GET_CPU(env);\n\n                cpu_synchronize_state(cpu);\n\n                len = snprintf((char *)mem_buf, sizeof(mem_buf),\n\n                               \"CPU#%d [%s]\", cpu->cpu_index,\n\n                               cpu->halted ? \"halted \" : \"running\");\n\n                memtohex(buf, mem_buf, len);\n\n                put_packet(s, buf);\n\n            }\n\n            break;\n\n        }\n\n#ifdef CONFIG_USER_ONLY\n\n        else if (strncmp(p, \"Offsets\", 7) == 0) {\n\n            TaskState *ts = s->c_cpu->opaque;\n\n\n\n            snprintf(buf, sizeof(buf),\n\n                     \"Text=\" TARGET_ABI_FMT_lx \";Data=\" TARGET_ABI_FMT_lx\n\n                     \";Bss=\" TARGET_ABI_FMT_lx,\n\n                     ts->info->code_offset,\n\n                     ts->info->data_offset,\n\n                     ts->info->data_offset);\n\n            put_packet(s, buf);\n\n            break;\n\n        }\n\n#else \/* !CONFIG_USER_ONLY *\/\n\n        else if (strncmp(p, \"Rcmd,\", 5) == 0) {\n\n            int len = strlen(p + 5);\n\n\n\n            if ((len % 2) != 0) {\n\n                put_packet(s, \"E01\");\n\n                break;\n\n            }\n\n            hextomem(mem_buf, p + 5, len);\n\n            len = len \/ 2;\n\n            mem_buf[len++] = 0;\n\n            qemu_chr_be_write(s->mon_chr, mem_buf, len);\n\n            put_packet(s, \"OK\");\n\n            break;\n\n        }\n\n#endif \/* !CONFIG_USER_ONLY *\/\n\n        if (strncmp(p, \"Supported\", 9) == 0) {\n\n            snprintf(buf, sizeof(buf), \"PacketSize=%x\", MAX_PACKET_LENGTH);\n\n#ifdef GDB_CORE_XML\n\n            pstrcat(buf, sizeof(buf), \";qXfer:features:read+\");\n\n#endif\n\n            put_packet(s, buf);\n\n            break;\n\n        }\n\n#ifdef GDB_CORE_XML\n\n        if (strncmp(p, \"Xfer:features:read:\", 19) == 0) {\n\n            const char *xml;\n\n            target_ulong total_len;\n\n\n\n            gdb_has_xml = 1;\n\n            p += 19;\n\n            xml = get_feature_xml(p, &p);\n\n            if (!xml) {\n\n                snprintf(buf, sizeof(buf), \"E00\");\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n\n\n            if (*p == ':')\n\n                p++;\n\n            addr = strtoul(p, (char **)&p, 16);\n\n            if (*p == ',')\n\n                p++;\n\n            len = strtoul(p, (char **)&p, 16);\n\n\n\n            total_len = strlen(xml);\n\n            if (addr > total_len) {\n\n                snprintf(buf, sizeof(buf), \"E00\");\n\n                put_packet(s, buf);\n\n                break;\n\n            }\n\n            if (len > (MAX_PACKET_LENGTH - 5) \/ 2)\n\n                len = (MAX_PACKET_LENGTH - 5) \/ 2;\n\n            if (len < total_len - addr) {\n\n                buf[0] = 'm';\n\n                len = memtox(buf + 1, xml + addr, len);\n\n            } else {\n\n                buf[0] = 'l';\n\n                len = memtox(buf + 1, xml + addr, total_len - addr);\n\n            }\n\n            put_packet_binary(s, buf, len + 1);\n\n            break;\n\n        }\n\n#endif\n\n        \/* Unrecognised 'q' command.  *\/\n\n        goto unknown_command;\n\n\n\n    default:\n\n    unknown_command:\n\n        \/* put empty packet *\/\n\n        buf[0] = '\\0';\n\n        put_packet(s, buf);\n\n        break;\n\n    }\n\n    return RS_IDLE;\n\n}\n","idx":23774,"target":1}
{"code":"int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t\/*\n\t * This also sets hw\/phys segments, boundary and size\n\t *\/\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n \treturn -ENOMEM;\n }\n","idx":182934,"target":1}
{"code":"int qcow2_alloc_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int n_start, int n_end, int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret, sectors;\n\n    uint64_t *l2_table;\n\n    unsigned int nb_clusters, keep_clusters;\n\n    uint64_t cluster_offset;\n\n\n\n    trace_qcow2_alloc_clusters_offset(qemu_coroutine_self(), offset,\n\n                                      n_start, n_end);\n\n\n\n    \/* Find L2 entry for the first involved cluster *\/\n\nagain:\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/*\n\n     * Calculate the number of clusters to look for. We stop at L2 table\n\n     * boundaries to keep things simple.\n\n     *\/\n\n    nb_clusters = MIN(size_to_clusters(s, n_end << BDRV_SECTOR_BITS),\n\n                      s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    \/*\n\n     * Check how many clusters are already allocated and don't need COW, and how\n\n     * many need a new allocation.\n\n     *\/\n\n    if (qcow2_get_cluster_type(cluster_offset) == QCOW2_CLUSTER_NORMAL\n\n        && (cluster_offset & QCOW_OFLAG_COPIED))\n\n    {\n\n        \/* We keep all QCOW_OFLAG_COPIED clusters *\/\n\n        keep_clusters =\n\n            count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                                      &l2_table[l2_index], 0,\n\n                                      QCOW_OFLAG_COPIED | QCOW_OFLAG_ZERO);\n\n        assert(keep_clusters <= nb_clusters);\n\n        nb_clusters -= keep_clusters;\n\n    } else {\n\n        \/* For the moment, overwrite compressed clusters one by one *\/\n\n        if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            nb_clusters = 1;\n\n        } else {\n\n            nb_clusters = count_cow_clusters(s, nb_clusters, l2_table, l2_index);\n\n        }\n\n\n\n        keep_clusters = 0;\n\n        cluster_offset = 0;\n\n    }\n\n\n\n    cluster_offset &= L2E_OFFSET_MASK;\n\n\n\n    \/*\n\n     * The L2 table isn't used any more after this. As long as the cache works\n\n     * synchronously, it's important to release it before calling\n\n     * do_alloc_cluster_offset, which may yield if we need to wait for another\n\n     * request to complete. If we still had the reference, we could use up the\n\n     * whole cache with sleeping requests.\n\n     *\/\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* If there is something left to allocate, do that now *\/\n\n    *m = (QCowL2Meta) {\n\n        .cluster_offset     = cluster_offset,\n\n        .nb_clusters        = 0,\n\n    };\n\n    qemu_co_queue_init(&m->dependent_requests);\n\n\n\n    if (nb_clusters > 0) {\n\n        uint64_t alloc_offset;\n\n        uint64_t alloc_cluster_offset;\n\n        uint64_t keep_bytes = keep_clusters * s->cluster_size;\n\n\n\n        \/* Calculate start and size of allocation *\/\n\n        alloc_offset = offset + keep_bytes;\n\n\n\n        if (keep_clusters == 0) {\n\n            alloc_cluster_offset = 0;\n\n        } else {\n\n            alloc_cluster_offset = cluster_offset + keep_bytes;\n\n        }\n\n\n\n        \/* Allocate, if necessary at a given offset in the image file *\/\n\n        ret = do_alloc_cluster_offset(bs, alloc_offset, &alloc_cluster_offset,\n\n                                      &nb_clusters);\n\n        if (ret == -EAGAIN) {\n\n            goto again;\n\n        } else if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        \/* save info needed for meta data update *\/\n\n        if (nb_clusters > 0) {\n\n            int requested_sectors = n_end - keep_clusters * s->cluster_sectors;\n\n            int avail_sectors = (keep_clusters + nb_clusters)\n\n                                << (s->cluster_bits - BDRV_SECTOR_BITS);\n\n\n\n            *m = (QCowL2Meta) {\n\n                .cluster_offset = keep_clusters == 0 ?\n\n                                  alloc_cluster_offset : cluster_offset,\n\n                .alloc_offset   = alloc_cluster_offset,\n\n                .offset         = alloc_offset,\n\n                .n_start        = keep_clusters == 0 ? n_start : 0,\n\n                .nb_clusters    = nb_clusters,\n\n                .nb_available   = MIN(requested_sectors, avail_sectors),\n\n            };\n\n            qemu_co_queue_init(&m->dependent_requests);\n\n            QLIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n        }\n\n    }\n\n\n\n    \/* Some cleanup work *\/\n\n    sectors = (keep_clusters + nb_clusters) << (s->cluster_bits - 9);\n\n    if (sectors > n_end) {\n\n        sectors = n_end;\n\n    }\n\n\n\n    assert(sectors > n_start);\n\n    *num = sectors - n_start;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (m->nb_clusters > 0) {\n\n        QLIST_REMOVE(m, next_in_flight);\n\n    }\n\n    return ret;\n\n}\n","idx":22580,"target":1}
{"code":"int recv_files(int f_in, int f_out, char *local_name)\n{\n\tint fd1,fd2;\n\tSTRUCT_STAT st;\n\tint iflags, xlen;\n\tchar *fname, fbuf[MAXPATHLEN];\n\tchar xname[MAXPATHLEN];\n\tchar fnametmp[MAXPATHLEN];\n\tchar *fnamecmp, *partialptr;\n\tchar fnamecmpbuf[MAXPATHLEN];\n\tuchar fnamecmp_type;\n\tstruct file_struct *file;\n\tint itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;\n\tenum logcode log_code = log_before_transfer ? FLOG : FINFO;\n\tint max_phase = protocol_version >= 29 ? 2 : 1;\n\tint dflt_perms = (ACCESSPERMS & ~orig_umask);\n#ifdef SUPPORT_ACLS\n\tconst char *parent_dirname = \"\";\n#endif\n\tint ndx, recv_ok;\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO, \"recv_files(%d) starting\\n\", cur_flist->used);\n\n\tif (delay_updates)\n\t\tdelayed_bits = bitbag_create(cur_flist->used + 1);\n\n\twhile (1) {\n\t\tcleanup_disable();\n\n\t\t\/* This call also sets cur_flist. *\/\n\t\tndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,\n\t\t\t\t\t xname, &xlen);\n\t\tif (ndx == NDX_DONE) {\n\t\t\tif (!am_server && INFO_GTE(PROGRESS, 2) && cur_flist) {\n\t\t\t\tset_current_file_index(NULL, 0);\n\t\t\t\tend_progress(0);\n\t\t\t}\n\t\t\tif (inc_recurse && first_flist) {\n\t\t\t\tif (read_batch) {\n\t\t\t\t\tndx = first_flist->used + first_flist->ndx_start;\n\t\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t\t}\n\t\t\t\tflist_free(first_flist);\n\t\t\t\tif (first_flist)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (read_batch && first_flist) {\n\t\t\t\tndx = first_flist->used;\n\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t}\n\t\t\tif (++phase > max_phase)\n\t\t\t\tbreak;\n\t\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\t\trprintf(FINFO, \"recv_files phase=%d\\n\", phase);\n\t\t\tif (phase == 2 && delay_updates)\n\t\t\t\thandle_delayed_updates(local_name);\n\t\t\twrite_int(f_out, NDX_DONE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ndx - cur_flist->ndx_start >= 0)\n\t\t\tfile = cur_flist->files[ndx - cur_flist->ndx_start];\n\t\telse\n\t\t\tfile = dir_flist->files[cur_flist->parent_ndx];\n\t\tfname = local_name ? local_name : f_name(file, fbuf);\n\n\t\tif (daemon_filter_list.head\n\t\t    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {\n\t\t\trprintf(FERROR, \"attempt to hack rsync failed.\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\trprintf(FINFO, \"recv_files(%s)\\n\", fname);\n\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))\n\t\t\trecv_xattr_request(file, f_in);\n#endif\n\n\t\tif (!(iflags & ITEM_TRANSFER)) {\n\t\t\tmaybe_log_item(file, iflags, itemizing, xname);\n#ifdef SUPPORT_XATTRS\n\t\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t\t && !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))\n\t\t\t\tset_file_attrs(fname, file, NULL, fname, 0);\n#endif\n\t\t\tif (iflags & ITEM_IS_NEW) {\n\t\t\t\tstats.created_files++;\n\t\t\t\tif (S_ISREG(file->mode)) {\n\t\t\t\t\t\/* Nothing further to count. *\/\n\t\t\t\t} else if (S_ISDIR(file->mode))\n\t\t\t\t\tstats.created_dirs++;\n#ifdef SUPPORT_LINKS\n\t\t\t\telse if (S_ISLNK(file->mode))\n\t\t\t\t\tstats.created_symlinks++;\n#endif\n\t\t\t\telse if (IS_DEVICE(file->mode))\n\t\t\t\t\tstats.created_devices++;\n\t\t\t\telse\n\t\t\t\t\tstats.created_specials++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (phase == 2) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"got transfer request in phase 2 [%s]\\n\",\n\t\t\t\twho_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (file->flags & FLAG_FILE_SENT) {\n\t\t\tif (csum_length == SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups; \/* prevents double backup *\/\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SUM_LENGTH;\n\t\t\t\tredoing = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (csum_length != SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups;\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SHORT_SUM_LENGTH;\n\t\t\t\tredoing = 0;\n\t\t\t}\n\t\t\tif (iflags & ITEM_IS_NEW)\n\t\t\t\tstats.created_files++;\n\t\t}\n\n\t\tif (!am_server && INFO_GTE(PROGRESS, 1))\n\t\t\tset_current_file_index(file, ndx);\n\t\tstats.xferred_files++;\n\t\tstats.total_transferred_size += F_LENGTH(file);\n\n\t\tcleanup_got_literal = 0;\n\n\t\tif (read_batch) {\n\t\t\tint wanted = redoing\n\t\t\t\t   ? we_want_redo(ndx)\n\t\t\t\t   : gen_wants_ndx(ndx, cur_flist->flist_num);\n\t\t\tif (!wanted) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"(Skipping batched update for%s \\\"%s\\\")\\n\",\n\t\t\t\t\tredoing ? \" resend of\" : \"\",\n\t\t\t\t\tfname);\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tremember_initial_stats();\n\n\t\tif (!do_xfers) { \/* log the transfer *\/\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (read_batch)\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tcontinue;\n\t\t}\n\t\tif (write_batch < 0) {\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (!am_server)\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpartialptr = partial_dir ? partial_dir_fname(fname) : fname;\n\n\t\tif (protocol_version >= 29) {\n\t\t\tswitch (fnamecmp_type) {\n\t\t\tcase FNAMECMP_FNAME:\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_PARTIAL_DIR:\n\t\t\t\tfnamecmp = partialptr;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_BACKUP:\n\t\t\t\tfnamecmp = get_backup_name(fname);\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_FUZZY:\n\t\t\t\tif (file->dirname) {\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, file->dirname, xname);\n\t\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\t} else\n\t\t\t\t\tfnamecmp = xname;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fnamecmp_type > FNAMECMP_FUZZY && fnamecmp_type-FNAMECMP_FUZZY <= basis_dir_cnt) {\n\t\t\t\t\tfnamecmp_type -= FNAMECMP_FUZZY + 1;\n\t\t\t\t\tif (file->dirname) {\n\t\t\t\t\t\tstringjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t\t\t   basis_dir[fnamecmp_type], \"\/\", file->dirname, \"\/\", xname, NULL);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], xname);\n\t\t\t\t} else if (fnamecmp_type >= basis_dir_cnt) {\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\"invalid basis_dir index: %d.\\n\",\n\t\t\t\t\t\tfnamecmp_type);\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t\t} else\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n                                break;\n                        }\n                        if (!fnamecmp || (daemon_filter_list.head\n                         && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {\n                                fnamecmp = fname;\n                                fnamecmp_type = FNAMECMP_FNAME;\n                        }\n\t\t} else {\n\t\t\t\/* Reminder: --inplace && --partial-dir are never\n\t\t\t * enabled at the same time. *\/\n\t\t\tif (inplace && make_backups > 0) {\n\t\t\t\tif (!(fnamecmp = get_backup_name(fname)))\n\t\t\t\t\tfnamecmp = fname;\n\t\t\t\telse\n\t\t\t\t\tfnamecmp_type = FNAMECMP_BACKUP;\n\t\t\t} else if (partial_dir && partialptr)\n\t\t\t\tfnamecmp = partialptr;\n\t\t\telse\n\t\t\t\tfnamecmp = fname;\n\t\t}\n\n\t\t\/* open the file *\/\n\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\n\t\tif (fd1 == -1 && protocol_version < 29) {\n\t\t\tif (fnamecmp != fname) {\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\n\t\t\tif (fd1 == -1 && basis_dir[0]) {\n\t\t\t\t\/* pre-29 allowed only one alternate basis *\/\n\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t basis_dir[0], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\t\t}\n\n\t\tupdating_basis_or_equiv = inplace\n\t\t    && (fnamecmp == fname || fnamecmp_type == FNAMECMP_BACKUP);\n\n\t\tif (fd1 == -1) {\n\t\t\tst.st_mode = 0;\n\t\t\tst.st_size = 0;\n\t\t} else if (do_fstat(fd1,&st) != 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"fstat %s failed\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {\n\t\t\t\/* this special handling for directories\n\t\t\t * wouldn't be necessary if robust_rename()\n\t\t\t * and the underlying robust_unlink could cope\n\t\t\t * with directories\n\t\t\t *\/\n\t\t\trprintf(FERROR_XFER, \"recv_files: %s is a directory\\n\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && !S_ISREG(st.st_mode)) {\n\t\t\tclose(fd1);\n\t\t\tfd1 = -1;\n\t\t}\n\n\t\t\/* If we're not preserving permissions, change the file-list's\n\t\t * mode based on the local permissions and some heuristics. *\/\n\t\tif (!preserve_perms) {\n\t\t\tint exists = fd1 != -1;\n#ifdef SUPPORT_ACLS\n\t\t\tconst char *dn = file->dirname ? file->dirname : \".\";\n\t\t\tif (parent_dirname != dn\n\t\t\t && strcmp(parent_dirname, dn) != 0) {\n\t\t\t\tdflt_perms = default_perms_for_dir(dn);\n\t\t\t\tparent_dirname = dn;\n\t\t\t}\n#endif\n\t\t\tfile->mode = dest_mode(file->mode, st.st_mode,\n\t\t\t\t\t       dflt_perms, exists);\n\t\t}\n\n\t\t\/* We now check to see if we are writing the file \"inplace\" *\/\n\t\tif (inplace)  {\n\t\t\tfd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);\n\t\t\tif (fd2 == -1) {\n\t\t\t\trsyserr(FERROR_XFER, errno, \"open %s failed\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t} else if (updating_basis_or_equiv)\n\t\t\t\tcleanup_set(NULL, NULL, file, fd1, fd2);\n\t\t} else {\n\t\t\tfd2 = open_tmpfile(fnametmp, fname, file);\n\t\t\tif (fd2 != -1)\n\t\t\t\tcleanup_set(fnametmp, partialptr, file, fd1, fd2);\n\t\t}\n\n\t\tif (fd2 == -1) {\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tif (fd1 != -1)\n\t\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\/* log the transfer *\/\n\t\tif (log_before_transfer)\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\telse if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))\n\t\t\trprintf(FINFO, \"%s\\n\", fname);\n\n\t\t\/* recv file data *\/\n\t\trecv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,\n\t\t\t\t       fname, fd2, F_LENGTH(file));\n\n\t\tlog_item(log_code, file, iflags, NULL);\n\n\t\tif (fd1 != -1)\n\t\t\tclose(fd1);\n\t\tif (close(fd2) < 0) {\n\t\t\trsyserr(FERROR, errno, \"close failed on %s\",\n\t\t\t\tfull_fname(fnametmp));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\n\t\tif ((recv_ok && (!delay_updates || !partialptr)) || inplace) {\n\t\t\tif (partialptr == fname)\n\t\t\t\tpartialptr = NULL;\n\t\t\tif (!finish_transfer(fname, fnametmp, fnamecmp,\n\t\t\t\t\t     partialptr, file, recv_ok, 1))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (fnamecmp == partialptr) {\n\t\t\t\tdo_unlink(partialptr);\n\t\t\t\thandle_partial_dir(partialptr, PDIR_DELETE);\n\t\t\t}\n\t\t} else if (keep_partial && partialptr) {\n\t\t\tif (!handle_partial_dir(partialptr, PDIR_CREATE)) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t    \"Unable to create partial-dir for %s -- discarding %s.\\n\",\n\t\t\t\t    local_name ? local_name : f_name(file, NULL),\n\t\t\t\t    recv_ok ? \"completed file\" : \"partial file\");\n\t\t\t\tdo_unlink(fnametmp);\n\t\t\t\trecv_ok = -1;\n\t\t\t} else if (!finish_transfer(partialptr, fnametmp, fnamecmp, NULL,\n\t\t\t\t\t\t    file, recv_ok, !partial_dir))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (delay_updates && recv_ok) {\n\t\t\t\tbitbag_set_bit(delayed_bits, ndx);\n\t\t\t\trecv_ok = 2;\n\t\t\t} else\n\t\t\t\tpartialptr = NULL;\n\t\t} else\n\t\t\tdo_unlink(fnametmp);\n\n\t\tcleanup_disable();\n\n\t\tif (read_batch)\n\t\t\tfile->flags |= FLAG_FILE_SENT;\n\n\t\tswitch (recv_ok) {\n\t\tcase 2:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (remove_source_files || inc_recurse\n\t\t\t || (preserve_hard_links && F_IS_HLINKED(file)))\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t\tbreak;\n\t\tcase 0: {\n\t\t\tenum logcode msgtype = redoing ? FERROR_XFER : FWARNING;\n\t\t\tif (msgtype == FERROR_XFER || INFO_GTE(NAME, 1)) {\n\t\t\t\tchar *errstr, *redostr, *keptstr;\n\t\t\t\tif (!(keep_partial && partialptr) && !inplace)\n\t\t\t\t\tkeptstr = \"discarded\";\n\t\t\t\telse if (partial_dir)\n\t\t\t\t\tkeptstr = \"put into partial-dir\";\n\t\t\t\telse\n\t\t\t\t\tkeptstr = \"retained\";\n\t\t\t\tif (msgtype == FERROR_XFER) {\n\t\t\t\t\terrstr = \"ERROR\";\n\t\t\t\t\tredostr = \"\";\n\t\t\t\t} else {\n\t\t\t\t\terrstr = \"WARNING\";\n\t\t\t\t\tredostr = read_batch ? \" (may try again)\"\n\t\t\t\t\t\t\t     : \" (will try again)\";\n\t\t\t\t}\n\t\t\t\trprintf(msgtype,\n\t\t\t\t\t\"%s: %s failed verification -- update %s%s.\\n\",\n\t\t\t\t\terrstr, local_name ? f_name(file, NULL) : fname,\n\t\t\t\t\tkeptstr, redostr);\n\t\t\t}\n\t\t\tif (!redoing) {\n\t\t\t\tif (read_batch)\n\t\t\t\t\tflist_ndx_push(&batch_redo_list, ndx);\n\t\t\t\tsend_msg_int(MSG_REDO, ndx);\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t} else if (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t    }\n\t\tcase -1:\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (make_backups < 0)\n\t\tmake_backups = -make_backups;\n\n\tif (phase == 2 && delay_updates) \/* for protocol_version < 29 *\/\n\t\thandle_delayed_updates(local_name);\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO,\"recv_files finished\\n\");\n\n\treturn 0;\n}\n","idx":177769,"target":1}
{"code":"int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n","idx":4,"target":0}
{"code":"static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (blit_is_unsafe(s, false))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n","idx":63,"target":0}
{"code":"static int truespeech_decode_frame(AVCodecContext *avctx,\n\n                void *data, int *data_size,\n\n                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TSContext *c = avctx->priv_data;\n\n\n\n    int i, j;\n\n    short *samples = data;\n\n    int consumed = 0;\n\n    int16_t out_buf[240];\n\n    int iterations;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 32) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Too small input buffer (%d bytes), need at least 32 bytes\\n\", buf_size);\n\n        return -1;\n\n    }\n\n    iterations = FFMIN(buf_size \/ 32, *data_size \/ 480);\n\n    for(j = 0; j < iterations; j++) {\n\n        truespeech_read_frame(c, buf + consumed);\n\n        consumed += 32;\n\n\n\n        truespeech_correlate_filter(c);\n\n        truespeech_filters_merge(c);\n\n\n\n        memset(out_buf, 0, 240 * 2);\n\n        for(i = 0; i < 4; i++) {\n\n            truespeech_apply_twopoint_filter(c, i);\n\n            truespeech_place_pulses(c, out_buf + i * 60, i);\n\n            truespeech_update_filters(c, out_buf + i * 60, i);\n\n            truespeech_synth(c, out_buf + i * 60, i);\n\n        }\n\n\n\n        truespeech_save_prevvec(c);\n\n\n\n        \/* finally output decoded frame *\/\n\n        for(i = 0; i < 240; i++)\n\n            *samples++ = out_buf[i];\n\n\n\n    }\n\n\n\n    *data_size = consumed * 15;\n\n\n\n    return consumed;\n\n}\n","idx":61,"target":0}
{"code":"WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n  const int argc,const char **argv,Image **images,ExceptionInfo *exception)\n{\n  ChannelType\n    channel;\n\n  const char\n    *option;\n\n  ImageInfo\n    *mogrify_info;\n\n  MagickStatusType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    index;\n\n  \/*\n    Apply options to the image list.\n  *\/\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image **) NULL);\n  assert((*images)->previous == (Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  if ((argc <= 0) || (*argv == (char *) NULL))\n    return(MagickTrue);\n  mogrify_info=CloneImageInfo(image_info);\n  quantize_info=AcquireQuantizeInfo(mogrify_info);\n  channel=mogrify_info->channel;\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    if (*images == (Image *) NULL)\n      break;\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=ParseCommandOption(MagickCommandOptions,MagickFalse,option);\n    count=MagickMax(count,0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    status=MogrifyImageInfo(mogrify_info,(int) count+1,argv+i,exception);\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"affinity\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                InheritException(exception,&(*images)->exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"append\",option+1) == 0)\n          {\n            Image\n              *append_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            append_image=AppendImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            if (append_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=append_image;\n            break;\n          }\n        if (LocaleCompare(\"average\",option+1) == 0)\n          {\n            Image\n              *average_image;\n\n            \/*\n              Average an image sequence (deprecated).\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            average_image=EvaluateImages(*images,MeanEvaluateOperator,\n              exception);\n            if (average_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=average_image;\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                channel=DefaultChannels;\n                break;\n              }\n            channel=(ChannelType) ParseChannelOption(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"clut\",option+1) == 0)\n          {\n            Image\n              *clut_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n            clut_image=RemoveFirstImageFromList(images);\n            if (clut_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) ClutImageChannel(image,channel,clut_image);\n            clut_image=DestroyImage(clut_image);\n            InheritException(exception,&image->exception);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"coalesce\",option+1) == 0)\n          {\n            Image\n              *coalesce_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            coalesce_image=CoalesceImages(*images,exception);\n            if (coalesce_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=coalesce_image;\n            break;\n          }\n        if (LocaleCompare(\"combine\",option+1) == 0)\n          {\n            Image\n              *combine_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            combine_image=CombineImages(*images,channel,exception);\n            if (combine_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=combine_image;\n            break;\n          }\n        if (LocaleCompare(\"compare\",option+1) == 0)\n          {\n            const char\n              *option;\n\n            double\n              distortion;\n\n            Image\n              *difference_image,\n              *image,\n              *reconstruct_image;\n\n            MetricType\n              metric;\n\n            \/*\n              Mathematically and visually annotate the difference between an\n              image and its reconstruction.\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n            reconstruct_image=RemoveFirstImageFromList(images);\n            if (reconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            metric=UndefinedMetric;\n            option=GetImageOption(image_info,\"metric\");\n            if (option != (const char *) NULL)\n              metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n                MagickFalse,option);\n            difference_image=CompareImageChannels(image,reconstruct_image,\n               channel,metric,&distortion,exception);\n             if (difference_image == (Image *) NULL)\n               break;\n             if (*images != (Image *) NULL)\n               *images=DestroyImageList(*images);\n             *images=difference_image;\n            break;\n          }\n        if (LocaleCompare(\"complex\",option+1) == 0)\n          {\n            ComplexOperator\n              op;\n\n            Image\n              *complex_images;\n\n            (void) SyncImageSettings(mogrify_info,*images);\n            op=(ComplexOperator) ParseCommandOption(MagickComplexOptions,\n              MagickFalse,argv[i+1]);\n            complex_images=ComplexImages(*images,op,exception);\n            if (complex_images == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=complex_images;\n            break;\n          }\n        if (LocaleCompare(\"composite\",option+1) == 0)\n          {\n            Image\n              *mask_image,\n              *composite_image,\n              *image;\n\n            RectangleInfo\n              geometry;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n            composite_image=RemoveFirstImageFromList(images);\n            if (composite_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) TransformImage(&composite_image,(char *) NULL,\n              composite_image->geometry);\n            SetGeometry(composite_image,&geometry);\n            (void) ParseAbsoluteGeometry(composite_image->geometry,&geometry);\n            GravityAdjustGeometry(image->columns,image->rows,image->gravity,\n              &geometry);\n            mask_image=RemoveFirstImageFromList(images);\n            if (mask_image != (Image *) NULL)\n              {\n                if ((image->compose == DisplaceCompositeOp) ||\n                    (image->compose == DistortCompositeOp))\n                  {\n                    \/*\n                      Merge Y displacement into X displacement image.\n                    *\/\n                    (void) CompositeImage(composite_image,CopyGreenCompositeOp,\n                      mask_image,0,0);\n                    mask_image=DestroyImage(mask_image);\n                  }\n                else\n                  {\n                    \/*\n                      Set a blending mask for the composition.\n                    *\/\n                    if (image->mask != (Image *) NULL)\n                      image->mask=DestroyImage(image->mask);\n                    image->mask=mask_image;\n                    (void) NegateImage(image->mask,MagickFalse);\n                  }\n              }\n            (void) CompositeImageChannel(image,channel,image->compose,\n              composite_image,geometry.x,geometry.y);\n            if (mask_image != (Image *) NULL)\n              {\n                image->mask=DestroyImage(image->mask);\n                mask_image=image->mask;\n              }\n            composite_image=DestroyImage(composite_image);\n            InheritException(exception,&image->exception);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            \/*\n              Copy image pixels.\n            *\/\n            (void) SyncImageSettings(mogrify_info,*images);\n            (void) ParsePageGeometry(*images,argv[i+2],&geometry,exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=(*images);\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,argv[i+1],&geometry,\n              exception);\n            status=CopyImagePixels(*images,source_image,&geometry,&offset,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"deconstruct\",option+1) == 0)\n          {\n            Image\n              *deconstruct_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            deconstruct_image=DeconstructImages(*images,exception);\n            if (deconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=deconstruct_image;\n            break;\n          }\n        if (LocaleCompare(\"delete\",option+1) == 0)\n          {\n            if (*option == '+')\n              DeleteImages(images,\"-1\",exception);\n            else\n              DeleteImages(images,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->dither=MagickFalse;\n                break;\n              }\n            quantize_info->dither=MagickTrue;\n            quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n              MagickDitherOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"duplicate\",option+1) == 0)\n          {\n            Image\n              *duplicate_images;\n\n            if (*option == '+')\n              duplicate_images=DuplicateImages(*images,1,\"-1\",exception);\n            else\n              {\n                const char\n                  *p;\n\n                size_t\n                  number_duplicates;\n\n                number_duplicates=(size_t) StringToLong(argv[i+1]);\n                p=strchr(argv[i+1],',');\n                if (p == (const char *) NULL)\n                  duplicate_images=DuplicateImages(*images,number_duplicates,\n                    \"-1\",exception);\n                else\n                  duplicate_images=DuplicateImages(*images,number_duplicates,p,\n                    exception);\n              }\n            AppendImageToList(images, duplicate_images);\n            (void) SyncImagesSettings(mogrify_info,*images);\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n          {\n            Image\n              *evaluate_image;\n\n            MagickEvaluateOperator\n              op;\n\n            (void) SyncImageSettings(mogrify_info,*images);\n            op=(MagickEvaluateOperator) ParseCommandOption(\n              MagickEvaluateOptions,MagickFalse,argv[i+1]);\n            evaluate_image=EvaluateImages(*images,op,exception);\n            if (evaluate_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=evaluate_image;\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"fft\",option+1) == 0)\n          {\n            Image\n              *fourier_image;\n\n            \/*\n              Implements the discrete Fourier transform (DFT).\n            *\/\n            (void) SyncImageSettings(mogrify_info,*images);\n            fourier_image=ForwardFourierTransformImage(*images,*option == '-' ?\n              MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"flatten\",option+1) == 0)\n          {\n            Image\n              *flatten_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            flatten_image=MergeImageLayers(*images,FlattenLayer,exception);\n            if (flatten_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=flatten_image;\n            break;\n          }\n        if (LocaleCompare(\"fx\",option+1) == 0)\n          {\n            Image\n              *fx_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            fx_image=FxImageChannel(*images,channel,argv[i+1],exception);\n            if (fx_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=fx_image;\n            break;\n          }\n        break;\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"hald-clut\",option+1) == 0)\n          {\n            Image\n              *hald_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n            hald_image=RemoveFirstImageFromList(images);\n            if (hald_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) HaldClutImageChannel(image,channel,hald_image);\n            hald_image=DestroyImage(hald_image);\n            InheritException(exception,&image->exception);\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"ift\",option+1) == 0)\n          {\n            Image\n              *fourier_image,\n              *magnitude_image,\n              *phase_image;\n\n            \/*\n              Implements the inverse fourier discrete Fourier transform (DFT).\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            magnitude_image=RemoveFirstImageFromList(images);\n            phase_image=RemoveFirstImageFromList(images);\n            if (phase_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            fourier_image=InverseFourierTransformImage(magnitude_image,\n              phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"insert\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q;\n\n            index=0;\n            if (*option != '+')\n              index=(ssize_t) StringToLong(argv[i+1]);\n            p=RemoveLastImageFromList(images);\n            if (p == (Image *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                status=MagickFalse;\n                break;\n              }\n            q=p;\n            if (index == 0)\n              PrependImageToList(images,q);\n            else\n              if (index == (ssize_t) GetImageListLength(*images))\n                AppendImageToList(images,q);\n              else\n                {\n                    q=GetImageFromList(*images,index-1);\n                    if (q == (Image *) NULL)\n                      {\n                        (void) ThrowMagickException(exception,GetMagickModule(),\n                          OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                        status=MagickFalse;\n                       break;\n                     }\n                  InsertImageInList(&q,p);\n                }\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"layers\",option+1) == 0)\n          {\n            Image\n              *layers;\n\n            ImageLayerMethod\n              method;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            layers=(Image *) NULL;\n            method=(ImageLayerMethod) ParseCommandOption(MagickLayerOptions,\n              MagickFalse,argv[i+1]);\n            switch (method)\n            {\n              case CoalesceLayer:\n              {\n                layers=CoalesceImages(*images,exception);\n                break;\n              }\n              case CompareAnyLayer:\n              case CompareClearLayer:\n              case CompareOverlayLayer:\n              default:\n              {\n                layers=CompareImageLayers(*images,method,exception);\n                break;\n              }\n              case MergeLayer:\n              case FlattenLayer:\n              case MosaicLayer:\n              case TrimBoundsLayer:\n              {\n                layers=MergeImageLayers(*images,method,exception);\n                break;\n              }\n              case DisposeLayer:\n              {\n                layers=DisposeImages(*images,exception);\n                break;\n              }\n              case OptimizeImageLayer:\n              {\n                layers=OptimizeImageLayers(*images,exception);\n                break;\n              }\n              case OptimizePlusLayer:\n              {\n                layers=OptimizePlusImageLayers(*images,exception);\n                break;\n              }\n              case OptimizeTransLayer:\n              {\n                OptimizeImageTransparency(*images,exception);\n                break;\n              }\n              case RemoveDupsLayer:\n              {\n                RemoveDuplicateLayers(images,exception);\n                break;\n              }\n              case RemoveZeroLayer:\n              {\n                RemoveZeroDelayLayers(images,exception);\n                break;\n              }\n              case OptimizeLayer:\n              {\n                \/*\n                  General Purpose, GIF Animation Optimizer.\n                *\/\n                layers=CoalesceImages(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                InheritException(exception,&layers->exception);\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=OptimizeImageLayers(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                InheritException(exception,&layers->exception);\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=(Image *) NULL;\n                OptimizeImageTransparency(*images,exception);\n                InheritException(exception,&(*images)->exception);\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                break;\n              }\n              case CompositeLayer:\n              {\n                CompositeOperator\n                  compose;\n\n                Image\n                  *source;\n\n                RectangleInfo\n                  geometry;\n\n                \/*\n                  Split image sequence at the first 'NULL:' image.\n                *\/\n                source=(*images);\n                while (source != (Image *) NULL)\n                {\n                  source=GetNextImageInList(source);\n                  if ((source != (Image *) NULL) &&\n                      (LocaleCompare(source->magick,\"NULL\") == 0))\n                    break;\n                }\n                if (source != (Image *) NULL)\n                  {\n                    if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                        (GetNextImageInList(source) == (Image *) NULL))\n                      source=(Image *) NULL;\n                    else\n                      {\n                        \/*\n                          Separate the two lists, junk the null: image.\n                        *\/\n                        source=SplitImageList(source->previous);\n                        DeleteImageFromList(&source);\n                      }\n                  }\n                if (source == (Image *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                    status=MagickFalse;\n                    break;\n                  }\n                \/*\n                  Adjust offset with gravity and virtual canvas.\n                *\/\n                SetGeometry(*images,&geometry);\n                (void) ParseAbsoluteGeometry((*images)->geometry,&geometry);\n                geometry.width=source->page.width != 0 ?\n                  source->page.width : source->columns;\n                geometry.height=source->page.height != 0 ?\n                 source->page.height : source->rows;\n                GravityAdjustGeometry((*images)->page.width != 0 ?\n                  (*images)->page.width : (*images)->columns,\n                  (*images)->page.height != 0 ? (*images)->page.height :\n                  (*images)->rows,(*images)->gravity,&geometry);\n                compose=OverCompositeOp;\n                option=GetImageOption(mogrify_info,\"compose\");\n                if (option != (const char *) NULL)\n                  compose=(CompositeOperator) ParseCommandOption(\n                    MagickComposeOptions,MagickFalse,option);\n                CompositeLayers(*images,compose,source,geometry.x,geometry.y,\n                  exception);\n                source=DestroyImageList(source);\n                break;\n              }\n            }\n            if (layers == (Image *) NULL)\n              break;\n            InheritException(exception,&layers->exception);\n            *images=DestroyImageList(*images);\n            *images=layers;\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                InheritException(exception,&(*images)->exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"maximum\",option+1) == 0)\n          {\n            Image\n              *maximum_image;\n\n            \/*\n              Maximum image sequence (deprecated).\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            maximum_image=EvaluateImages(*images,MaxEvaluateOperator,exception);\n            if (maximum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=maximum_image;\n            break;\n          }\n        if (LocaleCompare(\"minimum\",option+1) == 0)\n          {\n            Image\n              *minimum_image;\n\n            \/*\n              Minimum image sequence (deprecated).\n            *\/\n            (void) SyncImagesSettings(mogrify_info,*images);\n            minimum_image=EvaluateImages(*images,MinEvaluateOperator,exception);\n            if (minimum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=minimum_image;\n            break;\n          }\n        if (LocaleCompare(\"morph\",option+1) == 0)\n          {\n            Image\n              *morph_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            morph_image=MorphImages(*images,StringToUnsignedLong(argv[i+1]),\n              exception);\n            if (morph_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=morph_image;\n            break;\n          }\n        if (LocaleCompare(\"mosaic\",option+1) == 0)\n          {\n            Image\n              *mosaic_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            mosaic_image=MergeImageLayers(*images,MosaicLayer,exception);\n            if (mosaic_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=mosaic_image;\n            break;\n          }\n        break;\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"poly\",option+1) == 0)\n          {\n            char\n              *args,\n              token[MaxTextExtent];\n\n            const char\n              *p;\n\n            double\n              *arguments;\n\n            Image\n              *polynomial_image;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_arguments;\n\n            \/*\n              Polynomial image.\n            *\/\n            (void) SyncImageSettings(mogrify_info,*images);\n            args=InterpretImageProperties(mogrify_info,*images,argv[i+1]);\n            InheritException(exception,&(*images)->exception);\n            if (args == (char *) NULL)\n              break;\n            p=(char *) args;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MaxTextExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MaxTextExtent,token);\n            }\n            number_arguments=(size_t) x;\n            arguments=(double *) AcquireQuantumMemory(number_arguments,\n              sizeof(*arguments));\n            if (arguments == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*images)->filename);\n            (void) memset(arguments,0,number_arguments*\n              sizeof(*arguments));\n            p=(char *) args;\n            for (x=0; (x < (ssize_t) number_arguments) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MaxTextExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MaxTextExtent,token);\n              arguments[x]=StringToDouble(token,(char **) NULL);\n            }\n            args=DestroyString(args);\n            polynomial_image=PolynomialImageChannel(*images,channel,\n              number_arguments >> 1,arguments,exception);\n            arguments=(double *) RelinquishMagickMemory(arguments);\n            if (polynomial_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=polynomial_image;\n            break;\n          }\n        if (LocaleCompare(\"print\",option+1) == 0)\n          {\n            char\n              *string;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            string=InterpretImageProperties(mogrify_info,*images,argv[i+1]);\n            if (string == (char *) NULL)\n              break;\n            InheritException(exception,&(*images)->exception);\n            (void) FormatLocaleFile(stdout,\"%s\",string);\n            string=DestroyString(string);\n          }\n        if (LocaleCompare(\"process\",option+1) == 0)\n          {\n            char\n              **arguments;\n\n            int\n              j,\n              number_arguments;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            arguments=StringToArgv(argv[i+1],&number_arguments);\n            if (arguments == (char **) NULL)\n              break;\n            if ((argc > 1) && (strchr(arguments[1],'=') != (char *) NULL))\n              {\n                char\n                  breaker,\n                  quote,\n                  *token;\n\n                const char\n                  *arguments;\n\n                int\n                  next,\n                  status;\n\n                size_t\n                  length;\n\n                TokenInfo\n                  *token_info;\n\n                \/*\n                  Support old style syntax, filter=\"-option arg\".\n                *\/\n                length=strlen(argv[i+1]);\n                token=(char *) NULL;\n                if (~length >= (MaxTextExtent-1))\n                  token=(char *) AcquireQuantumMemory(length+MaxTextExtent,\n                    sizeof(*token));\n                if (token == (char *) NULL)\n                  break;\n                next=0;\n                arguments=argv[i+1];\n                token_info=AcquireTokenInfo();\n                status=Tokenizer(token_info,0,token,length,arguments,\"\",\"=\",\n                  \"\\\"\",'\\0',&breaker,&next,&quote);\n                token_info=DestroyTokenInfo(token_info);\n                if (status == 0)\n                  {\n                    const char\n                      *argv;\n\n                    argv=(&(arguments[next]));\n                    (void) InvokeDynamicImageFilter(token,&(*images),1,&argv,\n                      exception);\n                  }\n                token=DestroyString(token);\n                break;\n              }\n            (void) SubstituteString(&arguments[1],\"-\",\"\");\n            (void) InvokeDynamicImageFilter(arguments[1],&(*images),\n              number_arguments-2,(const char **) arguments+2,exception);\n            for (j=0; j < number_arguments; j++)\n              arguments[j]=DestroyString(arguments[j]);\n            arguments=(char **) RelinquishMagickMemory(arguments);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"reverse\",option+1) == 0)\n          {\n            ReverseImageList(images);\n            InheritException(exception,&(*images)->exception);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"smush\",option+1) == 0)\n          {\n            Image\n              *smush_image;\n\n            ssize_t\n              offset;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            offset=(ssize_t) StringToLong(argv[i+1]);\n            smush_image=SmushImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,offset,exception);\n            if (smush_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=smush_image;\n            break;\n          }\n        if (LocaleCompare(\"swap\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q,\n              *u,\n              *v;\n\n            ssize_t\n              swap_index;\n\n            index=(-1);\n            swap_index=(-2);\n            if (*option != '+')\n              {\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                swap_index=(-1);\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                index=(ssize_t) geometry_info.rho;\n                if ((flags & SigmaValue) != 0)\n                  swap_index=(ssize_t) geometry_info.sigma;\n              }\n            p=GetImageFromList(*images,index);\n            q=GetImageFromList(*images,swap_index);\n            if ((p == (Image *) NULL) || (q == (Image *) NULL))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",(*images)->filename);\n                status=MagickFalse;\n                break;\n              }\n            if (p == q)\n              break;\n            u=CloneImage(p,0,0,MagickTrue,exception);\n            if (u == (Image *) NULL)\n              break;\n            v=CloneImage(q,0,0,MagickTrue,exception);\n            if (v == (Image *) NULL)\n              {\n                u=DestroyImage(u);\n                break;\n              }\n            ReplaceImageInList(&p,v);\n            ReplaceImageInList(&q,u);\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"write\",option+1) == 0)\n          {\n            char\n              key[MaxTextExtent];\n\n            Image\n              *write_images;\n\n            ImageInfo\n              *write_info;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            (void) FormatLocaleString(key,MaxTextExtent,\"cache:%s\",argv[i+1]);\n            (void) DeleteImageRegistry(key);\n            write_images=(*images);\n            if (*option == '+')\n              write_images=CloneImageList(*images,exception);\n            write_info=CloneImageInfo(mogrify_info);\n            status&=WriteImages(write_info,write_images,argv[i+1],exception);\n            write_info=DestroyImageInfo(write_info);\n            if (*option == '+')\n              write_images=DestroyImageList(write_images);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    i+=count;\n  }\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  mogrify_info=DestroyImageInfo(mogrify_info);\n  status&=MogrifyImageInfo(image_info,argc,argv,exception);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n","idx":182764,"target":1}
{"code":"  void CallbackAndDie(bool succeeded) {\n    v8::Isolate* isolate = context_->isolate();\n    v8::HandleScope handle_scope(isolate);\n    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};\n    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),\n                           arraysize(args), args);\n     delete this;\n   }\n","idx":186112,"target":1}
{"code":"static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}\n","idx":2,"target":0}
{"code":" pim_print(netdissect_options *ndo,\n           register const u_char *bp, register u_int len, const u_char *bp2)\n {\n\tregister const u_char *ep;\n \tregister const struct pim *pim = (const struct pim *)bp;\n \n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n #ifdef notyet\t\t\t\/* currently we see only version and type *\/\n \tND_TCHECK(pim->pim_rsv);\n #endif\n \n \tswitch (PIM_VER(pim->pim_typever)) {\n \tcase 2:\n \t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n \t\tbreak;\n \t}\n \treturn;\n }\n","idx":181026,"target":1}
{"code":"void ExtensionServiceBackend::OnExtensionInstalled(\n     const scoped_refptr<const Extension>& extension) {\n   CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n   if (frontend_.get())\n    frontend_->OnExtensionInstalled(extension);\n }\n","idx":183865,"target":1}
{"code":"static int encode_residual_ch(FlacEncodeContext *s, int ch)\n\n{\n\n    int i, n;\n\n    int min_order, max_order, opt_order, omethod;\n\n    FlacFrame *frame;\n\n    FlacSubframe *sub;\n\n    int32_t coefs[MAX_LPC_ORDER][MAX_LPC_ORDER];\n\n    int shift[MAX_LPC_ORDER];\n\n    int32_t *res, *smp;\n\n\n\n    frame = &s->frame;\n\n    sub   = &frame->subframes[ch];\n\n    res   = sub->residual;\n\n    smp   = sub->samples;\n\n    n     = frame->blocksize;\n\n\n\n    \/* CONSTANT *\/\n\n    for (i = 1; i < n; i++)\n\n        if(smp[i] != smp[0])\n\n            break;\n\n    if (i == n) {\n\n        sub->type = sub->type_code = FLAC_SUBFRAME_CONSTANT;\n\n        res[0] = smp[0];\n\n        return subframe_count_exact(s, sub, 0);\n\n    }\n\n\n\n    \/* VERBATIM *\/\n\n    if (frame->verbatim_only || n < 5) {\n\n        sub->type = sub->type_code = FLAC_SUBFRAME_VERBATIM;\n\n        memcpy(res, smp, n * sizeof(int32_t));\n\n        return subframe_count_exact(s, sub, 0);\n\n    }\n\n\n\n    min_order  = s->options.min_prediction_order;\n\n    max_order  = s->options.max_prediction_order;\n\n    omethod    = s->options.prediction_order_method;\n\n\n\n    \/* FIXED *\/\n\n    sub->type = FLAC_SUBFRAME_FIXED;\n\n    if (s->options.lpc_type == FF_LPC_TYPE_NONE  ||\n\n        s->options.lpc_type == FF_LPC_TYPE_FIXED || n <= max_order) {\n\n        uint32_t bits[MAX_FIXED_ORDER+1];\n\n        if (max_order > MAX_FIXED_ORDER)\n\n            max_order = MAX_FIXED_ORDER;\n\n        opt_order = 0;\n\n        bits[0]   = UINT32_MAX;\n\n        for (i = min_order; i <= max_order; i++) {\n\n            encode_residual_fixed(res, smp, n, i);\n\n            bits[i] = find_subframe_rice_params(s, sub, i);\n\n            if (bits[i] < bits[opt_order])\n\n                opt_order = i;\n\n        }\n\n        sub->order     = opt_order;\n\n        sub->type_code = sub->type | sub->order;\n\n        if (sub->order != max_order) {\n\n            encode_residual_fixed(res, smp, n, sub->order);\n\n            find_subframe_rice_params(s, sub, sub->order);\n\n        }\n\n        return subframe_count_exact(s, sub, sub->order);\n\n    }\n\n\n\n    \/* LPC *\/\n\n    sub->type = FLAC_SUBFRAME_LPC;\n\n    opt_order = ff_lpc_calc_coefs(&s->lpc_ctx, smp, n, min_order, max_order,\n\n                                  s->options.lpc_coeff_precision, coefs, shift, s->options.lpc_type,\n\n                                  s->options.lpc_passes, omethod,\n\n                                  MAX_LPC_SHIFT, 0);\n\n\n\n    if (omethod == ORDER_METHOD_2LEVEL ||\n\n        omethod == ORDER_METHOD_4LEVEL ||\n\n        omethod == ORDER_METHOD_8LEVEL) {\n\n        int levels = 1 << omethod;\n\n        uint32_t bits[1 << ORDER_METHOD_8LEVEL];\n\n        int order;\n\n        int opt_index   = levels-1;\n\n        opt_order       = max_order-1;\n\n        bits[opt_index] = UINT32_MAX;\n\n        for (i = levels-1; i >= 0; i--) {\n\n            order = min_order + (((max_order-min_order+1) * (i+1)) \/ levels)-1;\n\n            if (order < 0)\n\n                order = 0;\n\n            encode_residual_lpc(res, smp, n, order+1, coefs[order], shift[order]);\n\n            bits[i] = find_subframe_rice_params(s, sub, order+1);\n\n            if (bits[i] < bits[opt_index]) {\n\n                opt_index = i;\n\n                opt_order = order;\n\n            }\n\n        }\n\n        opt_order++;\n\n    } else if (omethod == ORDER_METHOD_SEARCH) {\n\n        \/\/ brute-force optimal order search\n\n        uint32_t bits[MAX_LPC_ORDER];\n\n        opt_order = 0;\n\n        bits[0]   = UINT32_MAX;\n\n        for (i = min_order-1; i < max_order; i++) {\n\n            encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]);\n\n            bits[i] = find_subframe_rice_params(s, sub, i+1);\n\n            if (bits[i] < bits[opt_order])\n\n                opt_order = i;\n\n        }\n\n        opt_order++;\n\n    } else if (omethod == ORDER_METHOD_LOG) {\n\n        uint32_t bits[MAX_LPC_ORDER];\n\n        int step;\n\n\n\n        opt_order = min_order - 1 + (max_order-min_order)\/3;\n\n        memset(bits, -1, sizeof(bits));\n\n\n\n        for (step = 16; step; step >>= 1) {\n\n            int last = opt_order;\n\n            for (i = last-step; i <= last+step; i += step) {\n\n                if (i < min_order-1 || i >= max_order || bits[i] < UINT32_MAX)\n\n                    continue;\n\n                encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]);\n\n                bits[i] = find_subframe_rice_params(s, sub, i+1);\n\n                if (bits[i] < bits[opt_order])\n\n                    opt_order = i;\n\n            }\n\n        }\n\n        opt_order++;\n\n    }\n\n\n\n    sub->order     = opt_order;\n\n    sub->type_code = sub->type | (sub->order-1);\n\n    sub->shift     = shift[sub->order-1];\n\n    for (i = 0; i < sub->order; i++)\n\n        sub->coefs[i] = coefs[sub->order-1][i];\n\n\n\n    encode_residual_lpc(res, smp, n, sub->order, sub->coefs, sub->shift);\n\n\n\n    find_subframe_rice_params(s, sub, sub->order);\n\n\n\n    return subframe_count_exact(s, sub, sub->order);\n\n}\n","idx":9234,"target":1}
{"code":"acl_get_file_mode(const char *path_p)\n{\n\tstruct stat st;\n\n\tif (stat(path_p, &st) != 0)\n\t\treturn NULL;\n\treturn acl_from_mode(st.st_mode);\n}\n","idx":24,"target":0}
{"code":"void acl_mask_perm_str(acl_t acl, char *str)\n{\n\tacl_entry_t entry;\n\n\tstr[0] = '\\0';\n\tif (acl_get_entry(acl, ACL_FIRST_ENTRY, &entry) != 1)\n\t\treturn;\n\tfor(;;) {\n\t\tacl_tag_t tag;\n\n\t\tacl_get_tag_type(entry, &tag);\n\t\tif (tag == ACL_MASK) {\n\t\t\tacl_perm_str(entry, str);\n\t\t\treturn;\n\t\t}\n\t\tif (acl_get_entry(acl, ACL_NEXT_ENTRY, &entry) != 1)\n\t\t\treturn;\n\t}\n}\n","idx":25,"target":0}
{"code":"void acl_perm_str(acl_entry_t entry, char *str)\n{\n\tacl_permset_t permset;\n\tint n;\n\n\tacl_get_permset(entry, &permset);\n\tfor (n = 0; n < (int) ACL_PERMS; n++) {\n\t\tstr[n] = (acl_get_perm(permset, acl_perm_defs[n].tag) ?\n\t\t          acl_perm_defs[n].c : '-');\n\t}\n\tstr[n] = '\\0';\n}\n","idx":26,"target":0}
{"code":"void apply_mask(char *perm, const char *mask)\n{\n\twhile (*perm) {\n\t\tif (*mask == '-' && *perm >= 'a' && *perm <= 'z')\n\t\t\t*perm = *perm - 'a' + 'A';\n\t\tperm++;\n\t\tif (*mask)\n\t\t\tmask++;\n\t}\n}\n","idx":27,"target":0}
{"code":"int do_print(const char *path_p, const struct stat *st, int walk_flags, void *unused)\n{\n\tconst char *default_prefix = NULL;\n\tacl_t acl = NULL, default_acl = NULL;\n\tint error = 0;\n\n\tif (walk_flags & WALK_TREE_FAILED) {\n\t\tfprintf(stderr, \"%s: %s: %s\\n\", progname, xquote(path_p, \"\\n\\r\"),\n\t\t\tstrerror(errno));\n\t\treturn 1;\n\t}\n\n\t\/*\n\t * Symlinks can never have ACLs, so when doing a physical walk, we\n\t * skip symlinks altogether, and when doing a half-logical walk, we\n\t * skip all non-toplevel symlinks. \n\t *\/\n\tif ((walk_flags & WALK_TREE_SYMLINK) &&\n\t    ((walk_flags & WALK_TREE_PHYSICAL) ||\n\t     !(walk_flags & (WALK_TREE_TOPLEVEL | WALK_TREE_LOGICAL))))\n\t\treturn 0;\n\n\tif (opt_print_acl) {\n\t\tacl = acl_get_file(path_p, ACL_TYPE_ACCESS);\n\t\tif (acl == NULL && (errno == ENOSYS || errno == ENOTSUP))\n\t\t\tacl = acl_get_file_mode(path_p);\n\t\tif (acl == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (opt_print_default_acl && S_ISDIR(st->st_mode)) {\n\t\tdefault_acl = acl_get_file(path_p, ACL_TYPE_DEFAULT);\n\t\tif (default_acl == NULL) {\n\t\t\tif (errno != ENOSYS && errno != ENOTSUP)\n\t\t\t\tgoto fail;\n\t\t} else if (acl_entries(default_acl) == 0) {\n\t\t\tacl_free(default_acl);\n\t\t\tdefault_acl = NULL;\n\t\t}\n\t}\n\n\tif (opt_skip_base &&\n\t    (!acl || acl_equiv_mode(acl, NULL) == 0) && !default_acl)\n\t\treturn 0;\n\n\tif (opt_print_acl && opt_print_default_acl)\n\t\tdefault_prefix = \"default:\";\n\n\tif (opt_strip_leading_slash) {\n\t\tif (*path_p == '\/') {\n\t\t\tif (!absolute_warning) {\n\t\t\t\tfprintf(stderr, _(\"%s: Removing leading \"\n\t\t\t\t\t\"'\/' from absolute path names\\n\"),\n\t\t\t\t        progname);\n\t\t\t\tabsolute_warning = 1;\n\t\t\t}\n\t\t\twhile (*path_p == '\/')\n\t\t\t\tpath_p++;\n\t\t} else if (*path_p == '.' && *(path_p+1) == '\/')\n\t\t\twhile (*++path_p == '\/')\n\t\t\t\t\/* nothing *\/ ;\n\t\tif (*path_p == '\\0')\n\t\t\tpath_p = \".\";\n\t}\n\n\tif (opt_tabular)  {\n\t\tif (do_show(stdout, path_p, st, acl, default_acl) != 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tif (opt_comments) {\n\t\t\tprintf(\"# file: %s\\n\", xquote(path_p, \"\\n\\r\"));\n\t\t\tprintf(\"# owner: %s\\n\",\n\t\t\t       xquote(user_name(st->st_uid, opt_numeric), \" \\t\\n\\r\"));\n\t\t\tprintf(\"# group: %s\\n\",\n\t\t\t       xquote(group_name(st->st_gid, opt_numeric), \" \\t\\n\\r\"));\n\t\t}\n\t\tif (acl != NULL) {\n\t\t\tchar *acl_text = acl_to_any_text(acl, NULL, '\\n',\n\t\t\t\t\t\t\t print_options);\n\t\t\tif (!acl_text)\n\t\t\t\tgoto fail;\n\t\t\tif (puts(acl_text) < 0) {\n\t\t\t\tacl_free(acl_text);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tacl_free(acl_text);\n\t\t}\n\t\tif (default_acl != NULL) {\n\t\t\tchar *acl_text = acl_to_any_text(default_acl, \n\t\t\t\t\t\t\t default_prefix, '\\n',\n\t\t\t\t\t\t\t print_options);\n\t\t\tif (!acl_text)\n\t\t\t\tgoto fail;\n\t\t\tif (puts(acl_text) < 0) {\n\t\t\t\tacl_free(acl_text);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tacl_free(acl_text);\n\t\t}\n\t}\n\tif (acl || default_acl || opt_comments)\n\t\tprintf(\"\\n\");\n\ncleanup:\n\tif (acl)\n\t\tacl_free(acl);\n\tif (default_acl)\n\t\tacl_free(default_acl);\n\treturn error;\n\nfail:\n\tfprintf(stderr, \"%s: %s: %s\\n\", progname, xquote(path_p, \"\\n\\r\"),\n\t\tstrerror(errno));\n\terror = -1;\n\tgoto cleanup;\n}\n","idx":28,"target":0}
{"code":"int do_show(FILE *stream, const char *path_p, const struct stat *st,\n            acl_t acl, acl_t dacl)\n{\n\tstruct name_list *acl_names = get_list(st, acl),\n\t                 *first_acl_name = acl_names;\n\tstruct name_list *dacl_names = get_list(st, dacl),\n\t                 *first_dacl_name = dacl_names;\n\t\n\tint acl_names_width = max_name_length(acl_names);\n\tint dacl_names_width = max_name_length(dacl_names);\n\tacl_entry_t acl_ent;\n\tacl_entry_t dacl_ent;\n\tchar acl_mask[ACL_PERMS+1], dacl_mask[ACL_PERMS+1];\n\tint ret;\n\n\tnames_width = 8;\n\tif (acl_names_width > names_width)\n\t\tnames_width = acl_names_width;\n\tif (dacl_names_width > names_width)\n\t\tnames_width = dacl_names_width;\n\n\tacl_mask[0] = '\\0';\n\tif (acl) {\n\t\tacl_mask_perm_str(acl, acl_mask);\n\t\tret = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_ent);\n\t\tif (ret == 0)\n\t\t\tacl = NULL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tdacl_mask[0] = '\\0';\n\tif (dacl) {\n\t\tacl_mask_perm_str(dacl, dacl_mask);\n\t\tret = acl_get_entry(dacl, ACL_FIRST_ENTRY, &dacl_ent);\n\t\tif (ret == 0)\n\t\t\tdacl = NULL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tfprintf(stream, \"# file: %s\\n\", xquote(path_p, \"\\n\\r\"));\n\twhile (acl_names != NULL || dacl_names != NULL) {\n\t\tacl_tag_t acl_tag, dacl_tag;\n\n\t\tif (acl)\n\t\t\tacl_get_tag_type(acl_ent, &acl_tag);\n\t\tif (dacl)\n\t\t\tacl_get_tag_type(dacl_ent, &dacl_tag);\n\n\t\tif (acl && (!dacl || acl_tag < dacl_tag)) {\n\t\t\tshow_line(stream, &acl_names, acl, &acl_ent, acl_mask,\n\t\t\t          NULL, NULL, NULL, NULL);\n\t\t\tcontinue;\n\t\t} else if (dacl && (!acl || dacl_tag < acl_tag)) {\n\t\t\tshow_line(stream, NULL, NULL, NULL, NULL,\n\t\t\t          &dacl_names, dacl, &dacl_ent, dacl_mask);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (acl_tag == ACL_USER || acl_tag == ACL_GROUP) {\n\t\t\t\tid_t  *acl_id_p = NULL, *dacl_id_p = NULL;\n\t\t\t\tif (acl_ent)\n\t\t\t\t\tacl_id_p = acl_get_qualifier(acl_ent);\n\t\t\t\tif (dacl_ent)\n\t\t\t\t\tdacl_id_p = acl_get_qualifier(dacl_ent);\n\t\t\t\t\n\t\t\t\tif (acl && (!dacl || *acl_id_p < *dacl_id_p)) {\n\t\t\t\t\tshow_line(stream, &acl_names, acl,\n\t\t\t\t\t          &acl_ent, acl_mask,\n\t\t\t\t\t\t  NULL, NULL, NULL, NULL);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (dacl &&\n\t\t\t\t\t(!acl || *dacl_id_p < *acl_id_p)) {\n\t\t\t\t\tshow_line(stream, NULL, NULL, NULL,\n\t\t\t\t\t          NULL, &dacl_names, dacl,\n\t\t\t\t\t\t  &dacl_ent, dacl_mask);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshow_line(stream, &acl_names,  acl,  &acl_ent, acl_mask,\n\t\t\t\t  &dacl_names, dacl, &dacl_ent, dacl_mask);\n\t\t}\n\t}\n\n\tfree_list(first_acl_name);\n\tfree_list(first_dacl_name);\n\n\treturn 0;\n}\n","idx":29,"target":0}
{"code":"void free_list(struct name_list *names)\n{\n\tstruct name_list *next;\n\n\twhile (names) {\n\t\tnext = names->next;\n\t\tfree(names);\n\t\tnames = next;\n\t}\n}\n","idx":30,"target":0}
{"code":"struct name_list *get_list(const struct stat *st, acl_t acl)\n{\n\tstruct name_list *first = NULL, *last = NULL;\n\tacl_entry_t ent;\n\tint ret = 0;\n\n\tif (acl != NULL)\n\t\tret = acl_get_entry(acl, ACL_FIRST_ENTRY, &ent);\n\tif (ret != 1)\n\t\treturn NULL;\n\twhile (ret > 0) {\n\t\tacl_tag_t e_type;\n\t\tconst id_t *id_p;\n\t\tconst char *name = \"\";\n\t\tint len;\n\n\t\tacl_get_tag_type(ent, &e_type);\n\t\tswitch(e_type) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tname = user_name(st->st_uid, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tid_p = acl_get_qualifier(ent);\n\t\t\t\tif (id_p != NULL)\n\t\t\t\t\tname = user_name(*id_p, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tname = group_name(st->st_gid, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tid_p = acl_get_qualifier(ent);\n\t\t\t\tif (id_p != NULL)\n\t\t\t\t\tname = group_name(*id_p, opt_numeric);\n\t\t\t\tbreak;\n\t\t}\n\t\tname = xquote(name, \"\\t\\n\\r\");\n\t\tlen = strlen(name);\n\t\tif (last == NULL) {\n\t\t\tfirst = last = (struct name_list *)\n\t\t\t\tmalloc(sizeof(struct name_list) + len + 1);\n\t\t} else {\n\t\t\tlast->next = (struct name_list *)\n\t\t\t\tmalloc(sizeof(struct name_list) + len + 1);\n\t\t\tlast = last->next;\n\t\t}\n\t\tif (last == NULL) {\n\t\t\tfree_list(first);\n\t\t\treturn NULL;\n\t\t}\n\t\tlast->next = NULL;\n\t\tstrcpy(last->name, name);\n\n\t\tret = acl_get_entry(acl, ACL_NEXT_ENTRY, &ent);\n\t}\n\treturn first;\n}\n","idx":31,"target":0}
{"code":"void help(void)\n{\n\tprintf(_(\"%s %s -- get file access control lists\\n\"),\n\t       progname, VERSION);\n\tprintf(_(\"Usage: %s [-%s] file ...\\n\"),\n\t         progname, cmd_line_options);\n#if !POSIXLY_CORRECT\n\tif (posixly_correct) {\n#endif\n\t\tprintf(_(\n\"  -d, --default           display the default access control list\\n\"));\n#if !POSIXLY_CORRECT\n\t} else {\n\t\tprintf(_(\n\"  -a,  --access           display the file access control list only\\n\"\n\"  -d, --default           display the default access control list only\\n\"\n\"  -c, --omit-header       do not display the comment header\\n\"\n\"  -e, --all-effective     print all effective rights\\n\"\n\"  -E, --no-effective      print no effective rights\\n\"\n\"  -s, --skip-base         skip files that only have the base entries\\n\"\n\"  -R, --recursive         recurse into subdirectories\\n\"\n\"  -L, --logical           logical walk, follow symbolic links\\n\"\n\"  -P, --physical          physical walk, do not follow symbolic links\\n\"\n\"  -t, --tabular           use tabular output format\\n\"\n\"  -n, --numeric           print numeric user\/group identifiers\\n\"\n\"  -p, --absolute-names    don't strip leading '\/' in pathnames\\n\"));\n\t}\n#endif\n\tprintf(_(\n\"  -v, --version           print version and exit\\n\"\n\"  -h, --help              this help text\\n\"));\n}\n","idx":32,"target":0}
{"code":"int main(int argc, char *argv[])\n{\n\tint opt;\n\tchar *line;\n\n\tprogname = basename(argv[0]);\n\n#if POSIXLY_CORRECT\n\tcmd_line_options = POSIXLY_CMD_LINE_OPTIONS;\n#else\n\tif (getenv(POSIXLY_CORRECT_STR))\n\t\tposixly_correct = 1;\n\tif (!posixly_correct)\n\t\tcmd_line_options = CMD_LINE_OPTIONS;\n\telse\n\t\tcmd_line_options = POSIXLY_CMD_LINE_OPTIONS;\n#endif\n\n\tsetlocale(LC_CTYPE, \"\");\n\tsetlocale(LC_MESSAGES, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\n\t\/* Align `#effective:' comments to column 40 for tty's *\/\n\tif (!posixly_correct && isatty(fileno(stdout)))\n\t\tprint_options |= TEXT_SMART_INDENT;\n\n\twhile ((opt = getopt_long(argc, argv, cmd_line_options,\n\t\t                 long_options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\t\tcase 'a':  \/* acl only *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_print_acl = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':  \/* default acl only *\/\n\t\t\t\topt_print_default_acl = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':  \/* no comments *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_comments = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'e':  \/* all #effective comments *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\tprint_options |= TEXT_ALL_EFFECTIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':  \/* no #effective comments *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\tprint_options &= ~(TEXT_SOME_EFFECTIVE |\n\t\t\t\t                   TEXT_ALL_EFFECTIVE);\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':  \/* recursive *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_RECURSIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'L':  \/* follow all symlinks *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_LOGICAL;\n\t\t\t\twalk_flags &= ~WALK_TREE_PHYSICAL;\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':  \/* skip all symlinks *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_PHYSICAL;\n\t\t\t\twalk_flags &= ~WALK_TREE_LOGICAL;\n\t\t\t\tbreak;\n\n\t\t\tcase 's':  \/* skip files with only base entries *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_skip_base = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_strip_leading_slash = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_tabular = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':  \/* numeric *\/\n\t\t\t\topt_numeric = 1;\n\t\t\t\tprint_options |= TEXT_NUMERIC_IDS;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':  \/* print version *\/\n\t\t\t\tprintf(\"%s \" VERSION \"\\n\", progname);\n\t\t\t\treturn 0;\n\n\t\t\tcase 'h':  \/* help *\/\n\t\t\t\thelp();\n\t\t\t\treturn 0;\n\n\t\t\tcase ':':  \/* option missing *\/\n\t\t\tcase '?':  \/* unknown option *\/\n\t\t\tdefault:\n\t\t\t\tgoto synopsis;\n\t\t}\n\t}\n\n\tif (!(opt_print_acl || opt_print_default_acl)) {\n\t\topt_print_acl = 1;\n\t\tif (!posixly_correct)\n\t\t\topt_print_default_acl = 1;\n\t}\n\t\t\n\tif ((optind == argc) && !posixly_correct)\n\t\tgoto synopsis;\n\n\tdo {\n\t\tif (optind == argc ||\n\t\t    strcmp(argv[optind], \"-\") == 0) {\n\t\t\twhile ((line = next_line(stdin)) != NULL) {\n\t\t\t\tif (*line == '\\0')\n\t\t\t\t\tcontinue;\n\n\t\t\t\thad_errors += walk_tree(line, walk_flags, 0,\n\t\t\t\t\t\t\tdo_print, NULL);\n\t\t\t}\n\t\t\tif (!feof(stdin)) {\n\t\t\t\tfprintf(stderr, _(\"%s: Standard input: %s\\n\"),\n\t\t\t\t        progname, strerror(errno));\n\t\t\t\thad_errors++;\n\t\t\t}\n\t\t} else\n\t\t\thad_errors += walk_tree(argv[optind], walk_flags, 0,\n\t\t\t\t\t\tdo_print, NULL);\n\t\toptind++;\n\t} while (optind < argc);\n\n\treturn had_errors ? 1 : 0;\n\nsynopsis:\n\tfprintf(stderr, _(\"Usage: %s [-%s] file ...\\n\"),\n\t        progname, cmd_line_options);\n\tfprintf(stderr, _(\"Try `%s --help' for more information.\\n\"),\n\t\tprogname);\n\treturn 2;\n}\n","idx":33,"target":0}
{"code":"int max_name_length(struct name_list *names)\n{\n\tint max_len = 0;\n\twhile (names != NULL) {\n\t\tstruct name_list *next = names->next;\n\t\tint len = strlen(names->name);\n\n\t\tif (len > max_len)\n\t\t\tmax_len = len;\n\t\tnames = next;\n\t}\n\treturn max_len;\n}\n","idx":34,"target":0}
{"code":"int show_line(FILE *stream, struct name_list **acl_names,  acl_t acl,\n              acl_entry_t *acl_ent, const char *acl_mask,\n              struct name_list **dacl_names, acl_t dacl,\n\t      acl_entry_t *dacl_ent, const char *dacl_mask)\n{\n\tacl_tag_t tag_type;\n\tconst char *tag, *name;\n\tchar acl_perm[ACL_PERMS+1], dacl_perm[ACL_PERMS+1];\n\n\tif (acl) {\n\t\tacl_get_tag_type(*acl_ent, &tag_type);\n\t\tname = (*acl_names)->name;\n\t} else {\n\t\tacl_get_tag_type(*dacl_ent, &tag_type);\n\t\tname = (*dacl_names)->name;\n\t}\n\n\tswitch(tag_type) {\n\t\tcase ACL_USER_OBJ:\n\t\t\ttag = \"USER\";\n\t\t\tbreak;\n\t\tcase ACL_USER:\n\t\t\ttag = \"user\";\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\ttag = \"GROUP\";\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\ttag = \"group\";\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\ttag = \"mask\";\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\ttag = \"other\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\n\tmemset(acl_perm, ' ', ACL_PERMS);\n\tacl_perm[ACL_PERMS] = '\\0';\n\tif (acl_ent) {\n\t\tacl_perm_str(*acl_ent, acl_perm);\n\t\tif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&\n\t\t    tag_type != ACL_MASK)\n\t\t\tapply_mask(acl_perm, acl_mask);\n\t}\n\tmemset(dacl_perm, ' ', ACL_PERMS);\n\tdacl_perm[ACL_PERMS] = '\\0';\n\tif (dacl_ent) {\n\t\tacl_perm_str(*dacl_ent, dacl_perm);\n\t\tif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&\n\t\t    tag_type != ACL_MASK)\n\t\t\tapply_mask(dacl_perm, dacl_mask);\n\t}\n\n\tfprintf(stream, \"%-5s  %*s  %*s  %*s\\n\",\n\t        tag, -names_width, name,\n\t        -(int)ACL_PERMS, acl_perm,\n\t\t-(int)ACL_PERMS, dacl_perm);\n\n\tif (acl_names) {\n\t\tacl_get_entry(acl, ACL_NEXT_ENTRY, acl_ent);\n\t\t(*acl_names) = (*acl_names)->next;\n\t}\n\tif (dacl_names) {\n\t\tacl_get_entry(dacl, ACL_NEXT_ENTRY, dacl_ent);\n\t\t(*dacl_names) = (*dacl_names)->next;\n\t}\n\treturn 0;\n}\n","idx":35,"target":0}
{"code":"static const char *xquote(const char *str, const char *quote_chars)\n{\n\tconst char *q = quote(str, quote_chars);\n\tif (q == NULL) {\n\t\tfprintf(stderr, \"%s: %s\\n\", progname, strerror(errno));\n\t\texit(1);\n\t}\n\treturn q;\n}\n","idx":36,"target":0}
{"code":"static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, uint16_t **refcount_table,\n\n                               int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    *refcount_table = g_try_new0(uint16_t, *nb_clusters);\n\n    if (*nb_clusters && *refcount_table == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    \/* header *\/\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* current L1 table *\/\n\n    ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* snapshots *\/\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* refcount data *\/\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n\n}\n","idx":56,"target":0}
{"code":"static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n \t\treturn;\n \t}\n \tif (status) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n \t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n \t\t\/* These are unsolicited reports from the firmware, hence no\n \t\t   waiting command to wakeup *\/\n \t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n \t\tmemcpy(command_info->result_buffer, &data[1],\n \t\t\t\t\t\turb->actual_length - 1);\n \t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t\/* Continue trying to always read *\/\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}\n","idx":179541,"target":1}
{"code":"static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width\/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) \/* marker *\/\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        \/* start new mpeg1 context decoding *\/\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            \/* at least give a valid frame rate (some old mpeg1 have this) *\/\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); \/* vbv_buffer_size *\/\n\n    skip_bits(&s->gb, 1);\n\n\n\n    \/* get matrix *\/\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    \/* we set mpeg2 parameters so that it emulates mpeg1 *\/\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; \/* indicates mpeg1 *\/\n\n    return 0;\n\n}\n","idx":60,"target":0}
{"code":"static int mp_decode_frame(MPADecodeContext *s, \n\n                           short *samples)\n\n{\n\n    int i, nb_frames, ch;\n\n    short *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, s->inbuf + HEADER_SIZE, \n\n                  s->inbuf_ptr - s->inbuf - HEADER_SIZE);\n\n    \n\n    \/* skip error protection field *\/\n\n    if (s->error_protection)\n\n        get_bits(&s->gb, 16);\n\n\n\n    dprintf(\"frame %d:\\n\", s->frame_count);\n\n    switch(s->layer) {\n\n    case 1:\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n        break;\n\n    }\n\n#if defined(DEBUG)\n\n    for(i=0;i<nb_frames;i++) {\n\n        for(ch=0;ch<s->nb_channels;ch++) {\n\n            int j;\n\n            printf(\"%d-%d:\", i, ch);\n\n            for(j=0;j<SBLIMIT;j++)\n\n                printf(\" %0.6f\", (double)s->sb_samples[ch][i][j] \/ FRAC_ONE);\n\n            printf(\"\\n\");\n\n        }\n\n    }\n\n#endif\n\n    \/* apply the synthesis filter *\/\n\n    for(ch=0;ch<s->nb_channels;ch++) {\n\n        samples_ptr = samples + ch;\n\n        for(i=0;i<nb_frames;i++) {\n\n            synth_filter(s, ch, samples_ptr, s->nb_channels,\n\n                         s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * s->nb_channels;\n\n        }\n\n    }\n\n#ifdef DEBUG\n\n    s->frame_count++;        \n\n#endif\n\n    return nb_frames * 32 * sizeof(short) * s->nb_channels;\n\n}\n","idx":94,"target":0}
{"code":"void ASessionDescription::getFormatType(\n size_t index, unsigned long *PT,\n AString *desc, AString *params) const {\n AString format;\n    getFormat(index, &format);\n\n const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n char *end;\n unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n \n     *PT = x;\n \n    char key[20];\n    sprintf(key, \"a=rtpmap:%lu\", x);\n \n     CHECK(findAttribute(index, key, desc));\n \n    sprintf(key, \"a=fmtp:%lu\", x);\n     if (!findAttribute(index, key, params)) {\n         params->clear();\n     }\n}\n","idx":187433,"target":1}
{"code":"static void ehci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    EHCIPCIInfo *i = data;\n\n\n\n    k->init = usb_ehci_pci_initfn;\n\n    k->vendor_id = i->vendor_id;\n\n    k->device_id = i->device_id;\n\n    k->revision = i->revision;\n\n    k->class_id = PCI_CLASS_SERIAL_USB;\n\n    k->config_write = usb_ehci_pci_write_config;\n\n\n    dc->vmsd = &vmstate_ehci_pci;\n\n    dc->props = ehci_pci_properties;\n\n}","idx":21407,"target":1}
{"code":"static int bdrv_qed_open(BlockDriverState *bs, int flags)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    QEDHeader le_header;\n\n    int64_t file_size;\n\n    int ret;\n\n\n\n    s->bs = bs;\n\n    QSIMPLEQ_INIT(&s->allocating_write_reqs);\n\n\n\n    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    ret = 0; \/* ret should always be 0 or -errno *\/\n\n    qed_header_le_to_cpu(&le_header, &s->header);\n\n\n\n    if (s->header.magic != QED_MAGIC) {\n\n        return -EINVAL;\n\n    }\n\n    if (s->header.features & ~QED_FEATURE_MASK) {\n\n        \/* image uses unsupported feature bits *\/\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"%\" PRIx64,\n\n            s->header.features & ~QED_FEATURE_MASK);\n\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n            bs->device_name, \"QED\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    \/* Round down file size to the last cluster *\/\n\n    file_size = bdrv_getlength(bs->file);\n\n    if (file_size < 0) {\n\n        return file_size;\n\n    }\n\n    s->file_size = qed_start_of_cluster(s, file_size);\n\n\n\n    if (!qed_is_table_size_valid(s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_is_image_size_valid(s->header.image_size,\n\n                                 s->header.cluster_size,\n\n                                 s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    s->table_nelems = (s->header.cluster_size * s->header.table_size) \/\n\n                      sizeof(uint64_t);\n\n    s->l2_shift = ffs(s->header.cluster_size) - 1;\n\n    s->l2_mask = s->table_nelems - 1;\n\n    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;\n\n\n\n    if ((s->header.features & QED_F_BACKING_FILE)) {\n\n        if ((uint64_t)s->header.backing_filename_offset +\n\n            s->header.backing_filename_size >\n\n            s->header.cluster_size * s->header.header_size) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = qed_read_string(bs->file, s->header.backing_filename_offset,\n\n                              s->header.backing_filename_size, bs->backing_file,\n\n                              sizeof(bs->backing_file));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {\n\n            pstrcpy(bs->backing_format, sizeof(bs->backing_format), \"raw\");\n\n        }\n\n    }\n\n\n\n    \/* Reset unknown autoclear feature bits.  This is a backwards\n\n     * compatibility mechanism that allows images to be opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     *\/\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        \/* From here on only known autoclear feature bits are valid *\/\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    \/* If image was not closed cleanly, check consistency *\/\n\n    if (s->header.features & QED_F_NEED_CHECK) {\n\n        \/* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         *\/\n\n        if (!bdrv_is_read_only(bs->file)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (!ret && !result.corruptions && !result.check_errors) {\n\n                \/* Ensure fixes reach storage before clearing check bit *\/\n\n                bdrv_flush(s->bs);\n\n\n\n                s->header.features &= ~QED_F_NEED_CHECK;\n\n                qed_write_header_sync(s);\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n","idx":6631,"target":1}
{"code":"static void render_line(int x0, int y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { \/\/ optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base = dy \/ adx;\n\n        int x    = x0;\n\n        int y    = y0;\n\n        int err  = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n","idx":15155,"target":1}
{"code":"static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) \/* {{{ *\/\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\n \tif (intern->oth_handler && intern->oth_handler->dtor) {\n \t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n \t}\n \tzend_object_std_dtor(&intern->std TSRMLS_CC);\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n \t\t}\n \t\tif (intern->u.dir.sub_path) {\n \t\t\tefree(intern->u.dir.sub_path);\n\t\t}\t\t\n \t\tbreak;\n \tcase SPL_FS_FILE:\n \t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n\/*\t\t\t\tzend_list_delref(Z_RESVAL_P(intern->zcontext));*\/\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n } \/* }}} *\/\n","idx":180255,"target":1}
{"code":"static av_cold int ulti_decode_init(AVCodecContext *avctx)\n\n{\n\n    UltimotionDecodeContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n    s->blocks = (s->width \/ 8) * (s->height \/ 8);\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n\n    s->ulti_codebook = ulti_codebook;\n\n\n\n    s->frame = av_frame_alloc();\n\n    if (!s->frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    return 0;\n\n}","idx":18716,"target":1}
{"code":"static int decode_frame_header(NUTContext *nut, int64_t *pts, int *stream_id,\n\n                               uint8_t *header_idx, int frame_code)\n\n{\n\n    AVFormatContext *s = nut->avf;\n\n    AVIOContext *bc    = s->pb;\n\n    StreamContext *stc;\n\n    int size, flags, size_mul, pts_delta, i, reserved_count;\n\n    uint64_t tmp;\n\n\n\n    if (avio_tell(bc) > nut->last_syncpoint_pos + nut->max_distance) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Last frame must have been damaged %\"PRId64\" > %\"PRId64\" + %d\\n\",\n\n               avio_tell(bc), nut->last_syncpoint_pos, nut->max_distance);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    flags          = nut->frame_code[frame_code].flags;\n\n    size_mul       = nut->frame_code[frame_code].size_mul;\n\n    size           = nut->frame_code[frame_code].size_lsb;\n\n    *stream_id     = nut->frame_code[frame_code].stream_id;\n\n    pts_delta      = nut->frame_code[frame_code].pts_delta;\n\n    reserved_count = nut->frame_code[frame_code].reserved_count;\n\n    *header_idx    = nut->frame_code[frame_code].header_idx;\n\n\n\n    if (flags & FLAG_INVALID)\n\n        return AVERROR_INVALIDDATA;\n\n    if (flags & FLAG_CODED)\n\n        flags ^= ffio_read_varlen(bc);\n\n    if (flags & FLAG_STREAM_ID) {\n\n        GET_V(*stream_id, tmp < s->nb_streams);\n\n    }\n\n    stc = &nut->stream[*stream_id];\n\n    if (flags & FLAG_CODED_PTS) {\n\n        int coded_pts = ffio_read_varlen(bc);\n\n        \/\/ FIXME check last_pts validity?\n\n        if (coded_pts < (1 << stc->msb_pts_shift)) {\n\n            *pts = ff_lsb2full(stc, coded_pts);\n\n        } else\n\n            *pts = coded_pts - (1 << stc->msb_pts_shift);\n\n    } else\n\n        *pts = stc->last_pts + pts_delta;\n\n    if (flags & FLAG_SIZE_MSB)\n\n        size += size_mul * ffio_read_varlen(bc);\n\n    if (flags & FLAG_MATCH_TIME)\n\n        get_s(bc);\n\n    if (flags & FLAG_HEADER_IDX)\n\n        *header_idx = ffio_read_varlen(bc);\n\n    if (flags & FLAG_RESERVED)\n\n        reserved_count = ffio_read_varlen(bc);\n\n    for (i = 0; i < reserved_count; i++)\n\n        ffio_read_varlen(bc);\n\n\n\n    if (*header_idx >= (unsigned)nut->header_count) {\n\n        av_log(s, AV_LOG_ERROR, \"header_idx invalid\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (size > 4096)\n\n        *header_idx = 0;\n\n    size -= nut->header_len[*header_idx];\n\n\n\n    if (flags & FLAG_CHECKSUM) {\n\n        avio_rb32(bc); \/\/ FIXME check this\n\n    } else if (size > 2 * nut->max_distance || FFABS(stc->last_pts - *pts) >\n\n               stc->max_pts_distance) {\n\n        av_log(s, AV_LOG_ERROR, \"frame size > 2max_distance and no checksum\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    stc->last_pts   = *pts;\n\n    stc->last_flags = flags;\n\n\n\n    return size;\n\n}\n","idx":20044,"target":1}
{"code":"RenderProcessImpl::RenderProcessImpl()\n     : ALLOW_THIS_IN_INITIALIZER_LIST(shared_mem_cache_cleaner_(\n           FROM_HERE, base::TimeDelta::FromSeconds(5),\n           this, &RenderProcessImpl::ClearTransportDIBCache)),\n      transport_dib_next_sequence_number_(0) {\n   in_process_plugins_ = InProcessPlugins();\n   for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i)\n     shared_mem_cache_[i] = NULL;\n\n#if defined(OS_WIN)\n  if (GetModuleHandle(L\"LPK.DLL\") == NULL) {\n    typedef BOOL (__stdcall *GdiInitializeLanguagePack)(int LoadedShapingDLLs);\n    GdiInitializeLanguagePack gdi_init_lpk =\n        reinterpret_cast<GdiInitializeLanguagePack>(GetProcAddress(\n            GetModuleHandle(L\"GDI32.DLL\"),\n            \"GdiInitializeLanguagePack\"));\n    DCHECK(gdi_init_lpk);\n    if (gdi_init_lpk) {\n      gdi_init_lpk(0);\n    }\n  }\n#endif\n\n  webkit_glue::SetJavaScriptFlags(\n      \"--debugger-auto-break\"\n      \" --prof --prof-lazy\");\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kJavaScriptFlags)) {\n    webkit_glue::SetJavaScriptFlags(\n        command_line.GetSwitchValueASCII(switches::kJavaScriptFlags));\n  }\n}\n","idx":184709,"target":1}
{"code":"static int decode_interrupt_cb(void *ctx)\n\n{\n\n    return received_nb_signals > transcode_init_done;\n\n}\n","idx":25377,"target":1}
{"code":"void ff_mpeg4_encode_picture_header(MpegEncContext *s, int picture_number)\n\n{\n\n    int time_incr;\n\n    int time_div, time_mod;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        if (!(s->avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)) {\n\n            if (s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT)  \/\/ HACK, the reference sw is buggy\n\n                mpeg4_encode_visual_object_header(s);\n\n            if (s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number == 0)  \/\/ HACK, the reference sw is buggy\n\n                mpeg4_encode_vol_header(s, 0, 0);\n\n        }\n\n        if (!(s->workaround_bugs & FF_BUG_MS))\n\n            mpeg4_encode_gop_header(s);\n\n    }\n\n\n\n    s->partitioned_frame = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_B;\n\n\n\n    put_bits(&s->pb, 16, 0);                \/* vop header *\/\n\n    put_bits(&s->pb, 16, VOP_STARTCODE);    \/* vop header *\/\n\n    put_bits(&s->pb, 2, s->pict_type - 1);  \/* pict type: I = 0 , P = 1 *\/\n\n\n\n    time_div  = FFUDIV(s->time, s->avctx->time_base.den);\n\n    time_mod  = FFUMOD(s->time, s->avctx->time_base.den);\n\n    time_incr = time_div - s->last_time_base;\n\n    av_assert0(time_incr >= 0);\n\n    while (time_incr--)\n\n        put_bits(&s->pb, 1, 1);\n\n\n\n    put_bits(&s->pb, 1, 0);\n\n\n\n    put_bits(&s->pb, 1, 1);                             \/* marker *\/\n\n    put_bits(&s->pb, s->time_increment_bits, time_mod); \/* time increment *\/\n\n    put_bits(&s->pb, 1, 1);                             \/* marker *\/\n\n    put_bits(&s->pb, 1, 1);                             \/* vop coded *\/\n\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n\n        put_bits(&s->pb, 1, s->no_rounding);    \/* rounding type *\/\n\n    }\n\n    put_bits(&s->pb, 3, 0);     \/* intra dc VLC threshold *\/\n\n    if (!s->progressive_sequence) {\n\n        put_bits(&s->pb, 1, s->current_picture_ptr->f->top_field_first);\n\n        put_bits(&s->pb, 1, s->alternate_scan);\n\n    }\n\n    \/\/ FIXME sprite stuff\n\n\n\n    put_bits(&s->pb, 5, s->qscale);\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n\n        put_bits(&s->pb, 3, s->f_code);  \/* fcode_for *\/\n\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n\n        put_bits(&s->pb, 3, s->b_code);  \/* fcode_back *\/\n\n}\n","idx":8909,"target":1}
{"code":"static AddressSpace *q35_host_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    IntelIOMMUState *s = opaque;\n\n    VTDAddressSpace **pvtd_as;\n\n    int bus_num = pci_bus_num(bus);\n\n\n\n    assert(0 <= bus_num && bus_num <= VTD_PCI_BUS_MAX);\n\n    assert(0 <= devfn && devfn <= VTD_PCI_DEVFN_MAX);\n\n\n\n    pvtd_as = s->address_spaces[bus_num];\n\n    if (!pvtd_as) {\n\n        \/* No corresponding free() *\/\n\n        pvtd_as = g_malloc0(sizeof(VTDAddressSpace *) * VTD_PCI_DEVFN_MAX);\n\n        s->address_spaces[bus_num] = pvtd_as;\n\n    }\n\n    if (!pvtd_as[devfn]) {\n\n        pvtd_as[devfn] = g_malloc0(sizeof(VTDAddressSpace));\n\n\n\n        pvtd_as[devfn]->bus_num = (uint8_t)bus_num;\n\n        pvtd_as[devfn]->devfn = (uint8_t)devfn;\n\n        pvtd_as[devfn]->iommu_state = s;\n\n        pvtd_as[devfn]->context_cache_entry.context_cache_gen = 0;\n\n        memory_region_init_iommu(&pvtd_as[devfn]->iommu, OBJECT(s),\n\n                                 &s->iommu_ops, \"intel_iommu\", UINT64_MAX);\n\n        address_space_init(&pvtd_as[devfn]->as,\n\n                           &pvtd_as[devfn]->iommu, \"intel_iommu\");\n\n    }\n\n    return &pvtd_as[devfn]->as;\n\n}\n","idx":102,"target":0}
{"code":"static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    uint8_t *outbuf;\n\n    int buflen;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case INQUIRY:\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n    case RESERVE:\n\n    case RESERVE_10:\n\n    case RELEASE:\n\n    case RELEASE_10:\n\n    case START_STOP:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case GET_CONFIGURATION:\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n    case MECHANISM_STATUS:\n\n    case REQUEST_SENSE:\n\n        break;\n\n\n\n    default:\n\n        if (s->tray_open || !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n\n\n    \/*\n\n     * FIXME: we shouldn't return anything bigger than 4k, but the code\n\n     * requires the buffer to be as big as req->cmd.xfer in several\n\n     * places.  So, do not allow CDBs with a very large ALLOCATION\n\n     * LENGTH.  The real fix would be to modify scsi_read_data and\n\n     * dma_buf_read, so that they return data beyond the buflen\n\n     * as all zeros.\n\n     *\/\n\n    if (req->cmd.xfer > 65536) {\n\n        goto illegal_request;\n\n    }\n\n    r->buflen = MAX(4096, req->cmd.xfer);\n\n\n\n    if (!r->iov.iov_base) {\n\n        r->iov.iov_base = qemu_blockalign(s->qdev.conf.bs, r->buflen);\n\n    }\n\n\n\n    buflen = req->cmd.xfer;\n\n    outbuf = r->iov.iov_base;\n\n    memset(outbuf, 0, r->buflen);\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        assert(!s->tray_open && bdrv_is_inserted(s->qdev.conf.bs));\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case START_STOP:\n\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n\n            return 0;\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        s->tray_locked = req->cmd.buf[4] & 1;\n\n        bdrv_lock_medium(s->qdev.conf.bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        \/* The normal LEN field for this command is zero.  *\/\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n        if (!nb_sectors) {\n\n            scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n            return 0;\n\n        }\n\n        if ((req->cmd.buf[8] & 1) == 0 && req->cmd.lba) {\n\n            goto illegal_request;\n\n        }\n\n        nb_sectors \/= s->qdev.blocksize \/ 512;\n\n        \/* Returned value is the address of the last sector.  *\/\n\n        nb_sectors--;\n\n        \/* Remember the new size for read\/write sanity checking. *\/\n\n        s->qdev.max_lba = nb_sectors;\n\n        \/* Clip to 2TB, instead of returning capacity modulo 2TB. *\/\n\n        if (nb_sectors > UINT32_MAX) {\n\n            nb_sectors = UINT32_MAX;\n\n        }\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->qdev.blocksize >> 8;\n\n        outbuf[7] = 0;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        \/* Just return \"NO SENSE\".  *\/\n\n        buflen = scsi_build_sense(NULL, 0, outbuf, r->buflen,\n\n                                  (req->cmd.buf[1] & 1) == 0);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n        buflen = scsi_emulate_mechanism_status(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        buflen = scsi_get_configuration(s, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case GET_EVENT_STATUS_NOTIFICATION:\n\n        buflen = scsi_get_event_status_notification(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DISC_INFORMATION:\n\n        buflen = scsi_read_disc_information(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case READ_DVD_STRUCTURE:\n\n        buflen = scsi_read_dvd_structure(s, r, outbuf);\n\n        if (buflen < 0) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case SERVICE_ACTION_IN_16:\n\n        \/* Service Action In subcommands. *\/\n\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n            if (!nb_sectors) {\n\n                scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n                return 0;\n\n            }\n\n            if ((req->cmd.buf[14] & 1) == 0 && req->cmd.lba) {\n\n                goto illegal_request;\n\n            }\n\n            nb_sectors \/= s->qdev.blocksize \/ 512;\n\n            \/* Returned value is the address of the last sector.  *\/\n\n            nb_sectors--;\n\n            \/* Remember the new size for read\/write sanity checking. *\/\n\n            s->qdev.max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->qdev.blocksize >> 8;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            \/* set TPE bit if the format supports discard *\/\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            \/* Protection, exponent and lowest lba field left blank. *\/\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case SYNCHRONIZE_CACHE:\n\n        \/* The request is used as the AIO opaque value, so add a ref.  *\/\n\n        scsi_req_ref(&r->req);\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n\n        r->req.aiocb = bdrv_aio_flush(s->qdev.conf.bs, scsi_aio_complete, r);\n\n        return 0;\n\n    case SEEK_10:\n\n        DPRINTF(\"Seek(10) (sector %\" PRId64 \")\\n\", r->req.cmd.lba);\n\n        if (r->req.cmd.lba > s->qdev.max_lba) {\n\n            goto illegal_lba;\n\n        }\n\n        break;\n\n    case MODE_SELECT:\n\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case MODE_SELECT_10:\n\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case UNMAP:\n\n        DPRINTF(\"Unmap (len %lu)\\n\", (long)r->req.cmd.xfer);\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        nb_sectors = scsi_data_cdb_length(r->req.cmd.buf);\n\n        if (bdrv_is_read_only(s->qdev.conf.bs)) {\n\n            scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));\n\n            return 0;\n\n        }\n\n        if (!check_lba_range(s, r->req.cmd.lba, nb_sectors)) {\n\n            goto illegal_lba;\n\n        }\n\n\n\n        \/*\n\n         * We only support WRITE SAME with the unmap bit set for now.\n\n         *\/\n\n        if (!(req->cmd.buf[1] & 0x8)) {\n\n            goto illegal_request;\n\n        }\n\n\n\n        \/* The request is used as the AIO opaque value, so add a ref.  *\/\n\n        scsi_req_ref(&r->req);\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        r->req.cmd.lba * (s->qdev.blocksize \/ 512),\n\n                                        nb_sectors * (s->qdev.blocksize \/ 512),\n\n                                        scsi_aio_complete, r);\n\n        return 0;\n\n    default:\n\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return 0;\n\n    }\n\n    assert(!r->req.aiocb);\n\n    r->iov.iov_len = MIN(r->buflen, req->cmd.xfer);\n\n    if (r->iov.iov_len == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        assert(r->iov.iov_len == req->cmd.xfer);\n\n        return -r->iov.iov_len;\n\n    } else {\n\n        return r->iov.iov_len;\n\n    }\n\n\n\nillegal_request:\n\n    if (r->req.status == -1) {\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    }\n\n    return 0;\n\n\n\nillegal_lba:\n\n    scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n    return 0;\n\n}\n","idx":8582,"target":1}
{"code":"modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n {\n     static generic_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n         if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n     }\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n","idx":180692,"target":1}
{"code":"static int decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y, *src[4];\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    \/* Loop on tile components *\/\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        \/* Loop on resolution levels *\/\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            \/* Loop on bands *\/\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkx, cblky, cblkno=0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                \/* Loop on precincts *\/\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    \/* Loop on codeblocks *\/\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        int i, j;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        \/* Manage band offsets *\/\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } \/* end cblk *\/\n\n                } \/*end prec *\/\n\n            } \/* end band *\/\n\n        } \/* end reslevel *\/\n\n\n\n        ff_dwt_decode(&comp->dwt, comp->data);\n\n        src[compno] = comp->data;\n\n    } \/*end comp *\/\n\n\n\n    \/* inverse MCT transformation *\/\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            y = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = s->picture->data[0] + y * s->picture->linesize[0];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * s->ncomponents + compno;\n\n\n\n                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s->cdx[compno]) {\n\n                    int val = *src[compno]++ << (8 - s->cbps[compno]);\n\n                    val += 1 << 7;\n\n                    val = av_clip(val, 0, (1 << 8) - 1);\n\n                    *dst = val;\n\n                    dst += s->ncomponents;\n\n                }\n\n                line += s->picture->linesize[0];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            y = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = s->picture->data[0] + y * s->picture->linesize[0];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = (uint16_t *)(line + (x * s->ncomponents + compno) * 2);\n\n                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s-> cdx[compno]) {\n\n                    int32_t val;\n\n\n\n                    val = *src[compno]++ << (16 - s->cbps[compno]);\n\n                    val += 1 << 15;\n\n                    val = av_clip(val, 0, (1 << 16) - 1);\n\n                    *dst = val;\n\n                    dst += s->ncomponents;\n\n                }\n\n                line += s->picture->linesize[0];\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n","idx":72,"target":0}
{"code":"static void listener_add_address_space(MemoryListener *listener,\n\n                                       AddressSpace *as)\n\n{\n\n    FlatView *view;\n\n    FlatRange *fr;\n\n\n\n    if (listener->address_space_filter\n\n        && listener->address_space_filter != as) {\n\n        return;\n\n    }\n\n\n\n    if (global_dirty_log) {\n\n        if (listener->log_global_start) {\n\n            listener->log_global_start(listener);\n\n        }\n\n    }\n\n\n\n    view = as->current_map;\n\n    FOR_EACH_FLAT_RANGE(fr, view) {\n\n        MemoryRegionSection section = {\n\n            .mr = fr->mr,\n\n            .address_space = as,\n\n            .offset_within_region = fr->offset_in_region,\n\n            .size = fr->addr.size,\n\n            .offset_within_address_space = int128_get64(fr->addr.start),\n\n            .readonly = fr->readonly,\n\n        };\n\n        if (listener->region_add) {\n\n            listener->region_add(listener, &section);\n\n        }\n\n    }\n\n}\n","idx":65,"target":0}
{"code":"static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,\n\n                            hwaddr desc_pa, int i)\n\n{\n\n    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc),\n\n                       MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));\n\n    virtio_tswap64s(vdev, &desc->addr);\n\n    virtio_tswap32s(vdev, &desc->len);\n\n    virtio_tswap16s(vdev, &desc->flags);\n\n    virtio_tswap16s(vdev, &desc->next);\n\n}\n","idx":101,"target":0}
{"code":"uint8_t *xen_map_cache(hwaddr phys_addr, hwaddr size,\n\n                       uint8_t lock)\n\n{\n\n    MapCacheEntry *entry, *pentry = NULL;\n\n    hwaddr address_index;\n\n    hwaddr address_offset;\n\n    hwaddr cache_size = size;\n\n    hwaddr test_bit_size;\n\n    bool translated = false;\n\n\n\ntryagain:\n\n    address_index  = phys_addr >> MCACHE_BUCKET_SHIFT;\n\n    address_offset = phys_addr & (MCACHE_BUCKET_SIZE - 1);\n\n\n\n    trace_xen_map_cache(phys_addr);\n\n\n\n    \/* test_bit_size is always a multiple of XC_PAGE_SIZE *\/\n\n    if (size) {\n\n        test_bit_size = size + (phys_addr & (XC_PAGE_SIZE - 1));\n\n\n\n        if (test_bit_size % XC_PAGE_SIZE) {\n\n            test_bit_size += XC_PAGE_SIZE - (test_bit_size % XC_PAGE_SIZE);\n\n        }\n\n    } else {\n\n        test_bit_size = XC_PAGE_SIZE;\n\n    }\n\n\n\n    if (mapcache->last_entry != NULL &&\n\n        mapcache->last_entry->paddr_index == address_index &&\n\n        !lock && !size &&\n\n        test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                  test_bit_size >> XC_PAGE_SHIFT,\n\n                  mapcache->last_entry->valid_mapping)) {\n\n        trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n        return mapcache->last_entry->vaddr_base + address_offset;\n\n    }\n\n\n\n    \/* size is always a multiple of MCACHE_BUCKET_SIZE *\/\n\n    if (size) {\n\n        cache_size = size + address_offset;\n\n        if (cache_size % MCACHE_BUCKET_SIZE) {\n\n            cache_size += MCACHE_BUCKET_SIZE - (cache_size % MCACHE_BUCKET_SIZE);\n\n        }\n\n    } else {\n\n        cache_size = MCACHE_BUCKET_SIZE;\n\n    }\n\n\n\n    entry = &mapcache->entry[address_index % mapcache->nr_buckets];\n\n\n\n    while (entry && entry->lock && entry->vaddr_base &&\n\n            (entry->paddr_index != address_index || entry->size != cache_size ||\n\n             !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                 test_bit_size >> XC_PAGE_SHIFT,\n\n                 entry->valid_mapping))) {\n\n        pentry = entry;\n\n        entry = entry->next;\n\n    }\n\n    if (!entry) {\n\n        entry = g_malloc0(sizeof (MapCacheEntry));\n\n        pentry->next = entry;\n\n        xen_remap_bucket(entry, cache_size, address_index);\n\n    } else if (!entry->lock) {\n\n        if (!entry->vaddr_base || entry->paddr_index != address_index ||\n\n                entry->size != cache_size ||\n\n                !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                    test_bit_size >> XC_PAGE_SHIFT,\n\n                    entry->valid_mapping)) {\n\n            xen_remap_bucket(entry, cache_size, address_index);\n\n        }\n\n    }\n\n\n\n    if(!test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                test_bit_size >> XC_PAGE_SHIFT,\n\n                entry->valid_mapping)) {\n\n        mapcache->last_entry = NULL;\n\n        if (!translated && mapcache->phys_offset_to_gaddr) {\n\n            phys_addr = mapcache->phys_offset_to_gaddr(phys_addr, size, mapcache->opaque);\n\n            translated = true;\n\n            goto tryagain;\n\n        }\n\n        trace_xen_map_cache_return(NULL);\n\n        return NULL;\n\n    }\n\n\n\n    mapcache->last_entry = entry;\n\n    if (lock) {\n\n        MapCacheRev *reventry = g_malloc0(sizeof(MapCacheRev));\n\n        entry->lock++;\n\n        reventry->vaddr_req = mapcache->last_entry->vaddr_base + address_offset;\n\n        reventry->paddr_index = mapcache->last_entry->paddr_index;\n\n        reventry->size = entry->size;\n\n        QTAILQ_INSERT_HEAD(&mapcache->locked_entries, reventry, next);\n\n    }\n\n\n\n    trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n    return mapcache->last_entry->vaddr_base + address_offset;\n\n}\n","idx":53,"target":0}
{"code":" beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n {\n \n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \/* A REQuest *\/\n \t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n \t\tND_PRINT((ndo, \" BEEP END\"));\n \telse\n \t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}\n","idx":181056,"target":1}
{"code":"static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 int flags, Error **errp)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        \/* Sanity check *\/\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (offset > end_offset || ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n            s->image_backing_format = g_strdup(bs->backing_format);\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_CRYPTO_HEADER: {\n\n            unsigned int cflags = 0;\n\n            if (s->crypt_method_header != QCOW_CRYPT_LUKS) {\n\n                error_setg(errp, \"CRYPTO header extension only \"\n\n                           \"expected with LUKS encryption method\");\n\n                return -EINVAL;\n\n            }\n\n            if (ext.len != sizeof(Qcow2CryptoHeaderExtension)) {\n\n                error_setg(errp, \"CRYPTO header extension size %u, \"\n\n                           \"but expected size %zu\", ext.len,\n\n                           sizeof(Qcow2CryptoHeaderExtension));\n\n                return -EINVAL;\n\n            }\n\n\n\n            ret = bdrv_pread(bs->file, offset, &s->crypto_header, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret,\n\n                                 \"Unable to read CRYPTO header extension\");\n\n                return ret;\n\n            }\n\n            be64_to_cpus(&s->crypto_header.offset);\n\n            be64_to_cpus(&s->crypto_header.length);\n\n\n\n            if ((s->crypto_header.offset % s->cluster_size) != 0) {\n\n                error_setg(errp, \"Encryption header offset '%\" PRIu64 \"' is \"\n\n                           \"not a multiple of cluster size '%u'\",\n\n                           s->crypto_header.offset, s->cluster_size);\n\n                return -EINVAL;\n\n            }\n\n\n\n            if (flags & BDRV_O_NO_IO) {\n\n                cflags |= QCRYPTO_BLOCK_OPEN_NO_IO;\n\n            }\n\n            s->crypto = qcrypto_block_open(s->crypto_opts, \"encrypt.\",\n\n                                           qcow2_crypto_hdr_read_func,\n\n                                           bs, cflags, errp);\n\n            if (!s->crypto) {\n\n                return -EINVAL;\n\n            }\n\n        }   break;\n\n\n\n        default:\n\n            \/* unknown magic - save it in case we need to rewrite the header *\/\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":64,"target":0}
{"code":"static int nbd_errno_to_system_errno(int err)\n\n{\n\n    switch (err) {\n\n    case NBD_SUCCESS:\n\n        return 0;\n\n    case NBD_EPERM:\n\n        return EPERM;\n\n    case NBD_EIO:\n\n        return EIO;\n\n    case NBD_ENOMEM:\n\n        return ENOMEM;\n\n    case NBD_ENOSPC:\n\n        return ENOSPC;\n\n    default:\n\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n\n        \/* fallthrough *\/\n\n    case NBD_EINVAL:\n\n        return EINVAL;\n\n    }\n\n}\n","idx":55,"target":0}
{"code":"static int openfile(char *name, int flags, QDict *opts)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n\n    if (qemuio_blk) {\n\n        fprintf(stderr, \"file open already, try 'help close'\\n\");\n\n        QDECREF(opts);\n\n        return 1;\n\n    }\n\n\n\n    qemuio_blk = blk_new_open(\"hda\", name, NULL, opts, flags, &local_err);\n\n    if (!qemuio_blk) {\n\n        fprintf(stderr, \"%s: can't open%s%s: %s\\n\", progname,\n\n                name ? \" device \" : \"\", name ?: \"\",\n\n                error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        return 1;\n\n    }\n\n\n\n    bs = blk_bs(qemuio_blk);\n\n    if (bdrv_is_encrypted(bs)) {\n\n        char password[256];\n\n        printf(\"Disk image '%s' is encrypted.\\n\", name);\n\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n\n            error_report(\"No password given\");\n\n            goto error;\n\n        }\n\n        if (bdrv_set_key(bs, password) < 0) {\n\n            error_report(\"invalid password\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n\n\n    return 0;\n\n\n\n error:\n\n    blk_unref(qemuio_blk);\n\n    qemuio_blk = NULL;\n\n    return 1;\n\n}","idx":8022,"target":1}
{"code":"void gicv3_cpuif_update(GICv3CPUState *cs)\n{\n    \/* Tell the CPU about its highest priority pending interrupt *\/\n    int irqlevel = 0;\n    int fiqlevel = 0;\n    ARMCPU *cpu = ARM_CPU(cs->cpu);\n    CPUARMState *env = &cpu->env;\n    trace_gicv3_cpuif_update(gicv3_redist_affid(cs), cs->hppi.irq,\n                             cs->hppi.grp, cs->hppi.prio);\n    if (cs->hppi.grp == GICV3_G1 && !arm_feature(env, ARM_FEATURE_EL3)) {\n        \/* If a Security-enabled GIC sends a G1S interrupt to a\n         * Security-disabled CPU, we must treat it as if it were G0.\n         *\/\n        cs->hppi.grp = GICV3_G0;\n    }\n    if (icc_hppi_can_preempt(cs)) {\n        \/* We have an interrupt: should we signal it as IRQ or FIQ?\n         * This is described in the GICv3 spec section 4.6.2.\n         *\/\n        bool isfiq;\n        switch (cs->hppi.grp) {\n        case GICV3_G0:\n            isfiq = true;\n            break;\n        case GICV3_G1:\n            isfiq = (!arm_is_secure(env) ||\n                     (arm_current_el(env) == 3 && arm_el_is_aa64(env, 3)));\n            break;\n        case GICV3_G1NS:\n            isfiq = arm_is_secure(env);\n            break;\n        default:\n            g_assert_not_reached();\n        }\n        if (isfiq) {\n            fiqlevel = 1;\n        } else {\n            irqlevel = 1;\n        }\n    }\n    trace_gicv3_cpuif_set_irqs(gicv3_redist_affid(cs), fiqlevel, irqlevel);\n    qemu_set_irq(cs->parent_fiq, fiqlevel);\n    qemu_set_irq(cs->parent_irq, irqlevel);\n}","idx":5259,"target":1}
{"code":"aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct aiptek *aiptek;\n\tstruct input_dev *inputdev;\n\tint i;\n\tint speeds[] = { 0,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_50,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_400,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_25,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_100,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_200,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_300\n\t};\n\tint err = -ENOMEM;\n\n\t\/* programmableDelay is where the command-line specified\n\t * delay is kept. We make it the first element of speeds[],\n\t * so therefore, your override speed is tried first, then the\n\t * remainder. Note that the default value of 400ms will be tried\n\t * if you do not specify any command line parameter.\n\t *\/\n\tspeeds[0] = programmableDelay;\n\n\taiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);\n\tinputdev = input_allocate_device();\n\tif (!aiptek || !inputdev) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"cannot allocate memory or input device\\n\");\n\t\tgoto fail1;\n        }\n\n\taiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH,\n\t\t\t\t\t  GFP_ATOMIC, &aiptek->data_dma);\n        if (!aiptek->data) {\n\t\tdev_warn(&intf->dev, \"cannot allocate usb buffer\\n\");\n\t\tgoto fail1;\n\t}\n\n\taiptek->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!aiptek->urb) {\n\t        dev_warn(&intf->dev, \"cannot allocate urb\\n\");\n\t\tgoto fail2;\n\t}\n\n\taiptek->inputdev = inputdev;\n\taiptek->usbdev = usbdev;\n\taiptek->intf = intf;\n\taiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\taiptek->inDelay = 0;\n\taiptek->endDelay = 0;\n\taiptek->previousJitterable = 0;\n\taiptek->lastMacro = -1;\n\n\t\/* Set up the curSettings struct. Said struct contains the current\n\t * programmable parameters. The newSetting struct contains changes\n\t * the user makes to the settings via the sysfs interface. Those\n\t * changes are not \"committed\" to curSettings until the user\n\t * writes to the sysfs\/...\/execute file.\n\t *\/\n\taiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;\n\taiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE;\n\taiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;\n\taiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;\n\taiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON;\n\taiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;\n\taiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON;\n\taiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON;\n\taiptek->curSetting.jitterDelay = jitterDelay;\n\taiptek->curSetting.programmableDelay = programmableDelay;\n\n\t\/* Both structs should have equivalent settings\n\t *\/\n\taiptek->newSetting = aiptek->curSetting;\n\n\t\/* Determine the usb devices' physical path.\n\t * Asketh not why we always pretend we're using \"..\/input0\",\n\t * but I suspect this will have to be refactored one\n\t * day if a single USB device can be a keyboard & a mouse\n\t * & a tablet, and the inputX number actually will tell\n\t * us something...\n\t *\/\n\tusb_make_path(usbdev, aiptek->features.usbPath,\n\t\t\tsizeof(aiptek->features.usbPath));\n\tstrlcat(aiptek->features.usbPath, \"\/input0\",\n\t\tsizeof(aiptek->features.usbPath));\n\n\t\/* Set up client data, pointers to open and close routines\n\t * for the input device.\n\t *\/\n\tinputdev->name = \"Aiptek\";\n\tinputdev->phys = aiptek->features.usbPath;\n\tusb_to_input_id(usbdev, &inputdev->id);\n\tinputdev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(inputdev, aiptek);\n\n\tinputdev->open = aiptek_open;\n\tinputdev->close = aiptek_close;\n\n\t\/* Now program the capacities of the tablet, in terms of being\n\t * an input device.\n\t *\/\n\tfor (i = 0; i < ARRAY_SIZE(eventTypes); ++i)\n\t        __set_bit(eventTypes[i], inputdev->evbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(absEvents); ++i)\n\t        __set_bit(absEvents[i], inputdev->absbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(relEvents); ++i)\n\t        __set_bit(relEvents[i], inputdev->relbit);\n\n\t__set_bit(MSC_SERIAL, inputdev->mscbit);\n\n\t\/* Set up key and button codes *\/\n\tfor (i = 0; i < ARRAY_SIZE(buttonEvents); ++i)\n\t\t__set_bit(buttonEvents[i], inputdev->keybit);\n\n\tfor (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i)\n\t\t__set_bit(macroKeyEvents[i], inputdev->keybit);\n\n\t\/*\n\t * Program the input device coordinate capacities. We do not yet\n\t * know what maximum X, Y, and Z values are, so we're putting fake\n\t * values in. Later, we'll ask the tablet to put in the correct\n\t * values.\n\t *\/\n\tinput_set_abs_params(inputdev, ABS_X, 0, 2999, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, 0, 2249, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_PRESSURE, 0, 511, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_X, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n \tinput_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n \tinput_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);\n \n \tendpoint = &intf->altsetting[0].endpoint[0].desc;\n \n \t\/* Go set up our URB, which is called when the tablet receives\n\t * input.\n\t *\/\n\tusb_fill_int_urb(aiptek->urb,\n\t\t\t aiptek->usbdev,\n\t\t\t usb_rcvintpipe(aiptek->usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t aiptek->data, 8, aiptek_irq, aiptek,\n\t\t\t endpoint->bInterval);\n\n\taiptek->urb->transfer_dma = aiptek->data_dma;\n\taiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\/* Program the tablet. This sets the tablet up in the mode\n\t * specified in newSetting, and also queries the tablet's\n\t * physical capacities.\n\t *\n\t * Sanity check: if a tablet doesn't like the slow programmatic\n\t * delay, we often get sizes of 0x0. Let's use that as an indicator\n\t * to try faster delays, up to 25 ms. If that logic fails, well, you'll\n\t * have to explain to us how your tablet thinks it's 0x0, and yet that's\n\t * not an error :-)\n\t *\/\n\n\tfor (i = 0; i < ARRAY_SIZE(speeds); ++i) {\n\t\taiptek->curSetting.programmableDelay = speeds[i];\n\t\t(void)aiptek_program_tablet(aiptek);\n\t\tif (input_abs_get_max(aiptek->inputdev, ABS_X) > 0) {\n\t\t\tdev_info(&intf->dev,\n\t\t\t\t \"Aiptek using %d ms programming speed\\n\",\n\t\t\t\t aiptek->curSetting.programmableDelay);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\/* Murphy says that some day someone will have a tablet that fails the\n\t   above test. That's you, Frederic Rodrigo *\/\n \tif (i == ARRAY_SIZE(speeds)) {\n \t\tdev_info(&intf->dev,\n \t\t\t \"Aiptek tried all speeds, no sane response\\n\");\n \t\tgoto fail3;\n \t}\n \n\t\/* Associate this driver's struct with the usb interface.\n\t *\/\n\tusb_set_intfdata(intf, aiptek);\n\n\t\/* Set up the sysfs files\n\t *\/\n\terr = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group);\n\tif (err) {\n\t\tdev_warn(&intf->dev, \"cannot create sysfs group err: %d\\n\",\n\t\t\t err);\n\t\tgoto fail3;\n        }\n\n\t\/* Register the tablet as an Input Device\n\t *\/\n\terr = input_register_device(aiptek->inputdev);\n\tif (err) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"input_register_device returned err: %d\\n\", err);\n\t\tgoto fail4;\n        }\n\treturn 0;\n\n fail4:\tsysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);\n fail3: usb_free_urb(aiptek->urb);\n fail2:\tusb_free_coherent(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,\n\t\t\t  aiptek->data_dma);\n fail1: usb_set_intfdata(intf, NULL);\n\tinput_free_device(inputdev);\n\tkfree(aiptek);\n\treturn err;\n}\n","idx":180731,"target":1}
{"code":"static void read_vec_element_i32(DisasContext *s, TCGv_i32 tcg_dest, int srcidx,\n\n                                 int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_8|MO_SIGN:\n\n        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16|MO_SIGN:\n\n        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n    case MO_32|MO_SIGN:\n\n        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n","idx":100,"target":0}
{"code":"static void uart_rx_reset(UartState *s)\n\n{\n\n    s->rx_wpos = 0;\n\n    s->rx_count = 0;\n\n    qemu_chr_accept_input(s->chr);\n\n\n\n    s->r[R_SR] |= UART_SR_INTR_REMPTY;\n\n    s->r[R_SR] &= ~UART_SR_INTR_RFUL;\n\n}\n","idx":76,"target":0}
{"code":"int qcrypto_init(Error **errp)\n\n{\n\n    int ret;\n\n    ret = gnutls_global_init();\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Unable to initialize GNUTLS library: %s\",\n\n                   gnutls_strerror(ret));\n\n        return -1;\n\n    }\n\n#ifdef DEBUG_GNUTLS\n\n    gnutls_global_set_log_level(10);\n\n    gnutls_global_set_log_function(qcrypto_gnutls_log);\n\n#endif\n\n\n\n#ifdef CONFIG_GNUTLS_GCRYPT\n\n    if (!gcry_check_version(GCRYPT_VERSION)) {\n\n        error_setg(errp, \"Unable to initialize gcrypt\");\n\n        return -1;\n\n    }\n\n#ifdef QCRYPTO_INIT_GCRYPT_THREADS\n\n    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);\n\n#endif \/* QCRYPTO_INIT_GCRYPT_THREADS *\/\n\n    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n\n#endif\n\n\n\n    return 0;\n\n}\n","idx":99,"target":0}
{"code":"void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    \/* virtio-1 compliant devices cannot change the alignment *\/\n\n    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    \/* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     *\/\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n","idx":97,"target":0}
{"code":"print_syscall_ret(int num, abi_long ret)\n\n{\n\n    int i;\n\n\n\n    for(i=0;i<nsyscalls;i++)\n\n        if( scnames[i].nr == num ) {\n\n            if( scnames[i].result != NULL ) {\n\n                scnames[i].result(&scnames[i],ret);\n\n            } else {\n\n                if( ret < 0 ) {\n\n                    gemu_log(\" = -1 errno=\" TARGET_ABI_FMT_ld \" (%s)\\n\", -ret, target_strerror(-ret));\n\n                } else {\n\n                    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n                }\n\n            }\n\n            break;\n\n        }\n\n}\n","idx":10957,"target":1}
{"code":"xsltAddTemplate(xsltStylesheetPtr style, xsltTemplatePtr cur,\n\t        const xmlChar *mode, const xmlChar *modeURI) {\n    xsltCompMatchPtr pat, list, next;\n    \/*\n     * 'top' will point to style->xxxMatch ptr - declaring as 'void'\n     *  avoids gcc 'type-punned pointer' warning.\n     *\/\n    void **top = NULL;\n     const xmlChar *name = NULL;\n     float priority;              \/* the priority *\/\n \n    if ((style == NULL) || (cur == NULL) || (cur->match == NULL))\n \treturn(-1);\n \n     priority = cur->priority;\n     pat = xsltCompilePatternInternal(cur->match, style->doc, cur->elem,\n \t\t    style, NULL, 1);\n    if (pat == NULL)\n\treturn(-1);\n    while (pat) {\n\tnext = pat->next;\n\tpat->next = NULL;\n\tname = NULL;\n\n\tpat->template = cur;\n\tif (mode != NULL)\n\t    pat->mode = xmlDictLookup(style->dict, mode, -1);\n\tif (modeURI != NULL)\n\t    pat->modeURI = xmlDictLookup(style->dict, modeURI, -1);\n\tif (priority != XSLT_PAT_NO_PRIORITY)\n\t    pat->priority = priority;\n\n\t\/*\n\t * insert it in the hash table list corresponding to its lookup name\n\t *\/\n\tswitch (pat->steps[0].op) {\n        case XSLT_OP_ATTR:\n\t    if (pat->steps[0].value != NULL)\n\t\tname = pat->steps[0].value;\n\t    else\n\t\ttop = &(style->attrMatch);\n\t    break;\n        case XSLT_OP_PARENT:\n        case XSLT_OP_ANCESTOR:\n\t    top = &(style->elemMatch);\n\t    break;\n        case XSLT_OP_ROOT:\n\t    top = &(style->rootMatch);\n\t    break;\n        case XSLT_OP_KEY:\n\t    top = &(style->keyMatch);\n\t    break;\n        case XSLT_OP_ID:\n\t    \/* TODO optimize ID !!! *\/\n        case XSLT_OP_NS:\n        case XSLT_OP_ALL:\n\t    top = &(style->elemMatch);\n\t    break;\n        case XSLT_OP_END:\n\tcase XSLT_OP_PREDICATE:\n\t    xsltTransformError(NULL, style, NULL,\n\t\t\t     \"xsltAddTemplate: invalid compiled pattern\\n\");\n\t    xsltFreeCompMatch(pat);\n\t    return(-1);\n\t    \/*\n\t     * TODO: some flags at the top level about type based patterns\n\t     *       would be faster than inclusion in the hash table.\n\t     *\/\n\tcase XSLT_OP_PI:\n\t    if (pat->steps[0].value != NULL)\n\t\tname = pat->steps[0].value;\n\t    else\n\t\ttop = &(style->piMatch);\n\t    break;\n\tcase XSLT_OP_COMMENT:\n\t    top = &(style->commentMatch);\n\t    break;\n\tcase XSLT_OP_TEXT:\n\t    top = &(style->textMatch);\n\t    break;\n        case XSLT_OP_ELEM:\n\tcase XSLT_OP_NODE:\n\t    if (pat->steps[0].value != NULL)\n\t\tname = pat->steps[0].value;\n\t    else\n\t\ttop = &(style->elemMatch);\n\t    break;\n\t}\n\tif (name != NULL) {\n\t    if (style->templatesHash == NULL) {\n\t\tstyle->templatesHash = xmlHashCreate(1024);\n\t\tif (style->templatesHash == NULL) {\n\t\t    xsltFreeCompMatch(pat);\n\t\t    return(-1);\n\t\t}\n\t\txmlHashAddEntry3(style->templatesHash, name, mode, modeURI, pat);\n\t    } else {\n\t\tlist = (xsltCompMatchPtr) xmlHashLookup3(style->templatesHash,\n\t\t\t\t\t\t\t name, mode, modeURI);\n\t\tif (list == NULL) {\n\t\t    xmlHashAddEntry3(style->templatesHash, name,\n\t\t\t\t     mode, modeURI, pat);\n\t\t} else {\n\t\t    \/*\n\t\t     * Note '<=' since one must choose among the matching\n\t\t     * template rules that are left, the one that occurs\n\t\t     * last in the stylesheet\n\t\t     *\/\n\t\t    if (list->priority <= pat->priority) {\n\t\t\tpat->next = list;\n\t\t\txmlHashUpdateEntry3(style->templatesHash, name,\n\t\t\t\t\t    mode, modeURI, pat, NULL);\n\t\t    } else {\n\t\t\twhile (list->next != NULL) {\n\t\t\t    if (list->next->priority <= pat->priority)\n\t\t\t\tbreak;\n\t\t\t    list = list->next;\n\t\t\t}\n\t\t\tpat->next = list->next;\n\t\t\tlist->next = pat;\n\t\t    }\n\t\t}\n\t    }\n\t} else if (top != NULL) {\n\t    list = *top;\n\t    if (list == NULL) {\n\t\t*top = pat;\n\t\tpat->next = NULL;\n\t    } else if (list->priority <= pat->priority) {\n\t\tpat->next = list;\n\t\t*top = pat;\n\t    } else {\n\t\twhile (list->next != NULL) {\n\t\t    if (list->next->priority <= pat->priority)\n\t\t\tbreak;\n\t\t    list = list->next;\n\t\t}\n\t\tpat->next = list->next;\n\t\tlist->next = pat;\n\t    }\n\t} else {\n\t    xsltTransformError(NULL, style, NULL,\n\t\t\t     \"xsltAddTemplate: invalid compiled pattern\\n\");\n\t    xsltFreeCompMatch(pat);\n\t    return(-1);\n\t}\n#ifdef WITH_XSLT_DEBUG_PATTERN\n\tif (mode)\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"added pattern : '%s' mode '%s' priority %f\\n\",\n\t\t\t     pat->pattern, pat->mode, pat->priority);\n\telse\n\t    xsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"added pattern : '%s' priority %f\\n\",\n\t\t\t     pat->pattern, pat->priority);\n#endif\n\n\tpat = next;\n    }\n    return(0);\n}\n","idx":187332,"target":1}
{"code":"static av_cold int vdadec_init(AVCodecContext *avctx)\n\n{\n\n    VDADecoderContext *ctx = avctx->priv_data;\n\n    struct vda_context *vda_ctx = &ctx->vda_ctx;\n\n    OSStatus status;\n\n    int ret;\n\n\n\n    ctx->h264_initialized = 0;\n\n\n\n    \/* init pix_fmts of codec *\/\n\n    if (!ff_h264_vda_decoder.pix_fmts) {\n\n        if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;\n\n        else\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts;\n\n    }\n\n\n\n    \/* init vda *\/\n\n    memset(vda_ctx, 0, sizeof(struct vda_context));\n\n    vda_ctx->width = avctx->width;\n\n    vda_ctx->height = avctx->height;\n\n    vda_ctx->format = 'avc1';\n\n    vda_ctx->use_sync_decoding = 1;\n\n    vda_ctx->use_ref_buffer = 1;\n\n    ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);\n\n    switch (ctx->pix_fmt) {\n\n    case AV_PIX_FMT_UYVY422:\n\n        vda_ctx->cv_pix_fmt_type = '2vuy';\n\n        break;\n\n    case AV_PIX_FMT_YUYV422:\n\n        vda_ctx->cv_pix_fmt_type = 'yuvs';\n\n        break;\n\n    case AV_PIX_FMT_NV12:\n\n        vda_ctx->cv_pix_fmt_type = '420v';\n\n        break;\n\n    case AV_PIX_FMT_YUV420P:\n\n        vda_ctx->cv_pix_fmt_type = 'y420';\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported pixel format: %d\\n\", avctx->pix_fmt);\n\n        goto failed;\n\n    }\n\n    status = ff_vda_create_decoder(vda_ctx,\n\n                                   avctx->extradata, avctx->extradata_size);\n\n    if (status != kVDADecoderNoErr) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n                \"Failed to init VDA decoder: %d.\\n\", status);\n\n        goto failed;\n\n    }\n\n    avctx->hwaccel_context = vda_ctx;\n\n\n\n    \/* changes callback functions *\/\n\n    avctx->get_format = get_format;\n\n    avctx->get_buffer2 = get_buffer2;\n\n#if FF_API_GET_BUFFER\n\n    \/\/ force the old get_buffer to be empty\n\n    avctx->get_buffer = NULL;\n\n#endif\n\n\n\n    \/* init H.264 decoder *\/\n\n    ret = ff_h264_decoder.init(avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 decoder.\\n\");\n\n        goto failed;\n\n    }\n\n    ctx->h264_initialized = 1;\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    vdadec_close(avctx);\n\n    return -1;\n\n}\n","idx":0,"target":0}
{"code":"void ZLIB_INTERNAL inflate_fast(strm, start)\nz_streamp strm;\nunsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *in;      \/* local strm->next_in *\/\n    z_const unsigned char FAR *last;    \/* have enough input while in < last *\/\n    unsigned char FAR *out;     \/* local strm->next_out *\/\n    unsigned char FAR *beg;     \/* inflate()'s initial strm->next_out *\/\n    unsigned char FAR *end;     \/* while out < end, enough space available *\/\n#ifdef INFLATE_STRICT\n    unsigned dmax;              \/* maximum distance from zlib header *\/\n#endif\n    unsigned wsize;             \/* window size or zero if not using window *\/\n    unsigned whave;             \/* valid bytes in the window *\/\n    unsigned wnext;             \/* window write index *\/\n    unsigned char FAR *window;  \/* allocated sliding window, if wsize != 0 *\/\n    unsigned long hold;         \/* local strm->hold *\/\n    unsigned bits;              \/* local strm->bits *\/\n    code const FAR *lcode;      \/* local strm->lencode *\/\n    code const FAR *dcode;      \/* local strm->distcode *\/\n    unsigned lmask;             \/* mask for first level of length codes *\/\n    unsigned dmask;             \/* mask for first level of distance codes *\/\n    code here;                  \/* retrieved table entry *\/\n    unsigned op;                \/* code bits, operation, extra bits, or *\/\n                                \/*  window position, window bytes to copy *\/\n    unsigned len;               \/* match length, unused bytes *\/\n    unsigned dist;              \/* match distance *\/\n    unsigned char FAR *from;    \/* where to copy match from *\/\n \n     \/* copy state to local variables *\/\n     state = (struct inflate_state FAR *)strm->state;\n    in = strm->next_in - OFF;\n     last = in + (strm->avail_in - 5);\n    out = strm->next_out - OFF;\n     beg = out - (start - strm->avail_out);\n     end = out + (strm->avail_out - 257);\n #ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    \/* decode literals and length\/distances until end-of-block or not enough\n        input data or output space *\/\n     do {\n         if (bits < 15) {\n            hold += (unsigned long)(PUP(in)) << bits;\n             bits += 8;\n            hold += (unsigned long)(PUP(in)) << bits;\n             bits += 8;\n         }\n         here = lcode[hold & lmask];\n      dolen:\n        op = (unsigned)(here.bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(here.op);\n        if (op == 0) {                          \/* literal *\/\n             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                     \"inflate:         literal '%c'\\n\" :\n                     \"inflate:         literal 0x%02x\\n\", here.val));\n            PUP(out) = (unsigned char)(here.val);\n         }\n         else if (op & 16) {                     \/* length base *\/\n             len = (unsigned)(here.val);\n             op &= 15;                           \/* number of extra bits *\/\n             if (op) {\n                 if (bits < op) {\n                    hold += (unsigned long)(PUP(in)) << bits;\n                     bits += 8;\n                 }\n                 len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n             }\n             Tracevv((stderr, \"inflate:         length %u\\n\", len));\n             if (bits < 15) {\n                hold += (unsigned long)(PUP(in)) << bits;\n                 bits += 8;\n                hold += (unsigned long)(PUP(in)) << bits;\n                 bits += 8;\n             }\n             here = dcode[hold & dmask];\n          dodist:\n            op = (unsigned)(here.bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(here.op);\n            if (op & 16) {                      \/* distance base *\/\n                 dist = (unsigned)(here.val);\n                 op &= 15;                       \/* number of extra bits *\/\n                 if (bits < op) {\n                    hold += (unsigned long)(PUP(in)) << bits;\n                     bits += 8;\n                     if (bits < op) {\n                        hold += (unsigned long)(PUP(in)) << bits;\n                         bits += 8;\n                     }\n                 }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     \/* max distance in output *\/\n                if (dist > op) {                \/* see if copy from window *\/\n                    op = dist - op;             \/* distance back in window *\/\n                    if (op > whave) {\n                        if (state->sane) {\n                            strm->msg =\n                                (char *)\"invalid distance too far back\";\n                            state->mode = BAD;\n                            break;\n                        }\n #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                         if (len <= op - whave) {\n                             do {\n                                PUP(out) = 0;\n                             } while (--len);\n                             continue;\n                         }\n                         len -= op - whave;\n                         do {\n                            PUP(out) = 0;\n                         } while (--op > whave);\n                         if (op == 0) {\n                             from = out - dist;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--len);\n                             continue;\n                         }\n #endif\n                     }\n                    from = window - OFF;\n                     if (wnext == 0) {           \/* very common case *\/\n                         from += wsize - op;\n                         if (op < len) {         \/* some from window *\/\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                             from = out - dist;  \/* rest from output *\/\n                         }\n                    }\n                    else if (wnext < op) {      \/* wrap around window *\/\n                        from += wsize + wnext - op;\n                        op -= wnext;\n                         if (op < len) {         \/* some from end of window *\/\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                            from = window - OFF;\n                             if (wnext < len) {  \/* some from start of window *\/\n                                 op = wnext;\n                                 len -= op;\n                                 do {\n                                    PUP(out) = PUP(from);\n                                 } while (--op);\n                                 from = out - dist;      \/* rest from output *\/\n                             }\n                        }\n                    }\n                    else {                      \/* contiguous in window *\/\n                        from += wnext - op;\n                         if (op < len) {         \/* some from window *\/\n                             len -= op;\n                             do {\n                                PUP(out) = PUP(from);\n                             } while (--op);\n                             from = out - dist;  \/* rest from output *\/\n                         }\n                     }\n                     while (len > 2) {\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                         len -= 3;\n                     }\n                     if (len) {\n                        PUP(out) = PUP(from);\n                         if (len > 1)\n                            PUP(out) = PUP(from);\n                     }\n                 }\n                 else {\n                     from = out - dist;          \/* copy direct from output *\/\n                     do {                        \/* minimum length is three *\/\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                        PUP(out) = PUP(from);\n                         len -= 3;\n                     } while (len > 2);\n                     if (len) {\n                        PUP(out) = PUP(from);\n                         if (len > 1)\n                            PUP(out) = PUP(from);\n                     }\n                 }\n             }\n            else if ((op & 64) == 0) {          \/* 2nd level distance code *\/\n                here = dcode[here.val + (hold & ((1U << op) - 1))];\n                goto dodist;\n            }\n            else {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {              \/* 2nd level length code *\/\n            here = lcode[here.val + (hold & ((1U << op) - 1))];\n            goto dolen;\n        }\n        else if (op & 32) {                     \/* end-of-block *\/\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (char *)\"invalid literal\/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n    \/* return unused bytes (on entry, bits < 8, so in won't go too far back) *\/\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n     hold &= (1U << bits) - 1;\n \n     \/* update state and return *\/\n    strm->next_in = in + OFF;\n    strm->next_out = out + OFF;\n     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n     strm->avail_out = (unsigned)(out < end ?\n                                  257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}\n","idx":181846,"target":1}
{"code":"static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent *extent,\n\n                                                   int64_t offset)\n\n{\n\n    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;\n\n    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    extent_begin_offset =\n\n        (extent->end_sector - extent->sectors) * BDRV_SECTOR_SIZE;\n\n    extent_relative_offset = offset - extent_begin_offset;\n\n    offset_in_cluster = extent_relative_offset % cluster_size;\n\n\n\n    return offset_in_cluster;\n\n}\n","idx":103,"target":0}
{"code":"deinterlace_row(png_bytep buffer, png_const_bytep row,\n   unsigned int pixel_size, png_uint_32 w, int pass)\n{\n   \/* The inverse of the above, 'row' is part of row 'y' of the output image,\n    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute\n    * the pixels of row into buffer and return the number written (to allow\n    * this to be checked).\n    *\/\n   png_uint_32 xin, xout, xstep;\n   xout = PNG_PASS_START_COL(pass);\n   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);\n   for (xin=0; xout<w; xout+=xstep)\n   {\n      pixel_copy(buffer, xout, row, xin, pixel_size);\n      ++xin;\n   }\n}\n","idx":187629,"target":1}
{"code":"void gd_egl_scanout(DisplayChangeListener *dcl,\n\n                    uint32_t backing_id, bool backing_y_0_top,\n\n\n                    uint32_t x, uint32_t y,\n\n                    uint32_t w, uint32_t h)\n\n{\n\n    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);\n\n\n\n    vc->gfx.x = x;\n\n    vc->gfx.y = y;\n\n    vc->gfx.w = w;\n\n    vc->gfx.h = h;\n\n    vc->gfx.tex_id = backing_id;\n\n    vc->gfx.y0_top = backing_y_0_top;\n\n\n\n    eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,\n\n                   vc->gfx.esurface, vc->gfx.ectx);\n\n\n\n    if (vc->gfx.tex_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0) {\n\n        gtk_egl_set_scanout_mode(vc, false);\n\n        return;\n\n    }\n\n\n\n    gtk_egl_set_scanout_mode(vc, true);\n\n    if (!vc->gfx.fbo_id) {\n\n        glGenFramebuffers(1, &vc->gfx.fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, vc->gfx.fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, vc->gfx.tex_id, 0);\n\n}","idx":6457,"target":1}
{"code":"static int v4l2_read_header(AVFormatContext *s1)\n\n{\n\n    struct video_data *s = s1->priv_data;\n\n    AVStream *st;\n\n    int res = 0;\n\n    uint32_t desired_format;\n\n    enum AVCodecID codec_id = AV_CODEC_ID_NONE;\n\n    enum AVPixelFormat pix_fmt = AV_PIX_FMT_NONE;\n\n    struct v4l2_input input = { 0 };\n\n\n\n    st = avformat_new_stream(s1, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n#if CONFIG_LIBV4L2\n\n    \/* silence libv4l2 logging. if fopen() fails v4l2_log_file will be NULL\n\n       and errors will get sent to stderr *\/\n\n    v4l2_log_file = fopen(\"\/dev\/null\", \"w\");\n\n#endif\n\n\n\n    s->fd = device_open(s1);\n\n    if (s->fd < 0)\n\n        return s->fd;\n\n\n\n    if (s->channel != -1) {\n\n        \/* set video input *\/\n\n        av_log(s1, AV_LOG_DEBUG, \"Selecting input_channel: %d\\n\", s->channel);\n\n        if (v4l2_ioctl(s->fd, VIDIOC_S_INPUT, &s->channel) < 0) {\n\n            res = AVERROR(errno);\n\n            av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_S_INPUT): %s\\n\", av_err2str(res));\n\n            return res;\n\n        }\n\n    } else {\n\n        \/* get current video input *\/\n\n        if (v4l2_ioctl(s->fd, VIDIOC_G_INPUT, &s->channel) < 0) {\n\n            res = AVERROR(errno);\n\n            av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_G_INPUT): %s\\n\", av_err2str(res));\n\n            return res;\n\n        }\n\n    }\n\n\n\n    \/* enum input *\/\n\n    input.index = s->channel;\n\n    if (v4l2_ioctl(s->fd, VIDIOC_ENUMINPUT, &input) < 0) {\n\n        res = AVERROR(errno);\n\n        av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_ENUMINPUT): %s\\n\", av_err2str(res));\n\n        return res;\n\n    }\n\n    s->std_id = input.std;\n\n    av_log(s1, AV_LOG_DEBUG, \"Current input_channel: %d, input_name: %s\\n\",\n\n           s->channel, input.name);\n\n\n\n    if (s->list_format) {\n\n        list_formats(s1, s->fd, s->list_format);\n\n        return AVERROR_EXIT;\n\n    }\n\n\n\n    if (s->list_standard) {\n\n        list_standards(s1);\n\n        return AVERROR_EXIT;\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000000); \/* 64 bits pts in us *\/\n\n\n\n    if (s->pixel_format) {\n\n        AVCodec *codec = avcodec_find_decoder_by_name(s->pixel_format);\n\n\n\n        if (codec)\n\n            s1->video_codec_id = codec->id;\n\n\n\n        pix_fmt = av_get_pix_fmt(s->pixel_format);\n\n\n\n        if (pix_fmt == AV_PIX_FMT_NONE && !codec) {\n\n            av_log(s1, AV_LOG_ERROR, \"No such input format: %s.\\n\",\n\n                   s->pixel_format);\n\n\n\n            return AVERROR(EINVAL);\n\n        }\n\n    }\n\n\n\n    if (!s->width && !s->height) {\n\n        struct v4l2_format fmt;\n\n\n\n        av_log(s1, AV_LOG_VERBOSE,\n\n               \"Querying the device for the current frame size\\n\");\n\n        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n        if (v4l2_ioctl(s->fd, VIDIOC_G_FMT, &fmt) < 0) {\n\n            res = AVERROR(errno);\n\n            av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_G_FMT): %s\\n\", av_err2str(res));\n\n            return res;\n\n        }\n\n\n\n        s->width  = fmt.fmt.pix.width;\n\n        s->height = fmt.fmt.pix.height;\n\n        av_log(s1, AV_LOG_VERBOSE,\n\n               \"Setting frame size to %dx%d\\n\", s->width, s->height);\n\n    }\n\n\n\n    res = device_try_init(s1, pix_fmt, &s->width, &s->height, &desired_format, &codec_id);\n\n    if (res < 0) {\n\n        v4l2_close(s->fd);\n\n        return res;\n\n    }\n\n\n\n    \/* If no pixel_format was specified, the codec_id was not known up\n\n     * until now. Set video_codec_id in the context, as codec_id will\n\n     * not be available outside this function\n\n     *\/\n\n    if (codec_id != AV_CODEC_ID_NONE && s1->video_codec_id == AV_CODEC_ID_NONE)\n\n        s1->video_codec_id = codec_id;\n\n\n\n    if ((res = av_image_check_size(s->width, s->height, 0, s1)) < 0)\n\n        return res;\n\n\n\n    s->frame_format = desired_format;\n\n\n\n    if ((res = v4l2_set_parameters(s1)) < 0)\n\n        return res;\n\n\n\n    st->codec->pix_fmt = fmt_v4l2ff(desired_format, codec_id);\n\n    s->frame_size =\n\n        avpicture_get_size(st->codec->pix_fmt, s->width, s->height);\n\n\n\n    if ((res = mmap_init(s1)) ||\n\n        (res = mmap_start(s1)) < 0) {\n\n        v4l2_close(s->fd);\n\n        return res;\n\n    }\n\n\n\n    s->top_field_first = first_field(s->fd);\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = codec_id;\n\n    if (codec_id == AV_CODEC_ID_RAWVIDEO)\n\n        st->codec->codec_tag =\n\n            avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);\n\n    if (desired_format == V4L2_PIX_FMT_YVU420)\n\n        st->codec->codec_tag = MKTAG('Y', 'V', '1', '2');\n\n    else if (desired_format == V4L2_PIX_FMT_YVU410)\n\n        st->codec->codec_tag = MKTAG('Y', 'V', 'U', '9');\n\n    st->codec->width = s->width;\n\n    st->codec->height = s->height;\n\n    st->codec->bit_rate = s->frame_size * av_q2d(st->avg_frame_rate) * 8;\n\n\n\n    return 0;\n\n}\n","idx":17881,"target":1}
{"code":"static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)\n\n{\n\n    AVIOContext *in, *out;\n\n    int ret = 0;\n\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n\n        avio_close(in);\n\n        return ret;\n\n    }\n\n    while (size > 0) {\n\n        uint8_t buf[8192];\n\n        int n = FFMIN(size, sizeof(buf));\n\n        n = avio_read(in, buf, n);\n\n        if (n <= 0) {\n\n            ret = AVERROR(EIO);\n\n            break;\n\n        }\n\n        avio_write(out, buf, n);\n\n        size -= n;\n\n    }\n\n    avio_flush(out);\n\n    avio_close(out);\n\n    avio_close(in);\n\n    return ret;\n\n}\n","idx":49,"target":0}
{"code":"apprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tphp_stream *dir;\n\tphp_stream_dirent d;\n \n\tTSRMLS_FETCH();\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t\/* Enable checks for parsed files *\/\n\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t\/* print silly verbose header for USG compat. *\/\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t\/* load directory or file *\/\n\t\/* FIXME: Read file names and sort them to prevent\n\t   non-determinism. See Debian bug #488562. *\/\n\tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tint mflen;\n\t\tchar mfn[MAXPATHLEN];\n\n\t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile (php_stream_readdir(dir, &d)) {\n\t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s\/%s\", fn, d.d_name)) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n                                if ((filearr = CAST(char **,\n                                    erealloc(filearr, mlen))) == NULL) {\n                                        file_oomem(ms, mlen);\n                                       efree(mfn);\n                                        php_stream_closedir(dir);\n                                        errs++;\n                                        goto out;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n\t\t}\n\t\tphp_stream_closedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tefree(filearr[i]);\n\t\t}\n\t\tefree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\/* Set types of tests *\/\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t\/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t *\/\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t\/* coalesce per file arrays into a single one *\/\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\tif (map->magic[j])\n\t\t\t\tefree(map->magic[j]);\n\t\t}\n\t\tefree(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}\n","idx":178054,"target":1}
{"code":"void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)\n\n{\n\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n\n\n\n    isa_mmio_setup(mr, size);\n\n    memory_region_add_subregion(get_system_memory(), base, mr);\n\n}\n","idx":45,"target":0}
{"code":"static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    LM32TimerState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SR:\n\n    case R_CR:\n\n    case R_PERIOD:\n\n        r = s->regs[addr];\n\n        break;\n\n    case R_SNAPSHOT:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_lm32_timer_memory_read(addr << 2, r);\n\n    return r;\n\n}\n","idx":58,"target":0}
{"code":"int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n\n{\n\n    QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    QXLCursor *cursor;\n\n    QEMUCursor *c;\n\n\n\n    if (!cmd) {\n\n        return 1;\n\n    }\n\n\n\n    if (!dpy_cursor_define_supported(qxl->vga.con)) {\n\n        return 0;\n\n    }\n\n\n\n    if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n\n        fprintf(stderr, \"%s\", __FUNCTION__);\n\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n\n        fprintf(stderr, \"\\n\");\n\n    }\n\n    switch (cmd->type) {\n\n    case QXL_CURSOR_SET:\n\n        cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n\n        if (!cursor) {\n\n            return 1;\n\n        }\n\n        c = qxl_cursor(qxl, cursor, ext->group_id);\n\n        if (c == NULL) {\n\n            c = cursor_builtin_left_ptr();\n\n        }\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        if (qxl->ssd.cursor) {\n\n            cursor_put(qxl->ssd.cursor);\n\n        }\n\n        qxl->ssd.cursor = c;\n\n        qxl->ssd.mouse_x = cmd->u.set.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.set.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    case QXL_CURSOR_MOVE:\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        qxl->ssd.mouse_x = cmd->u.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n","idx":69,"target":0}
{"code":"static void ptrace_hbptriggered(struct perf_event *bp, int unused,\n \t\t\t\t     struct perf_sample_data *data,\n \t\t\t\t     struct pt_regs *regs)\n {\n\tstruct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);\n\tlong num;\n\tint i;\n\tsiginfo_t info;\n\n\tfor (i = 0; i < ARM_MAX_HBP_SLOTS; ++i)\n\t\tif (current->thread.debug.hbp[i] == bp)\n\t\t\tbreak;\n\n\tnum = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i);\n\n\tinfo.si_signo\t= SIGTRAP;\n\tinfo.si_errno\t= (int)num;\n\tinfo.si_code\t= TRAP_HWBKPT;\n\tinfo.si_addr\t= (void __user *)(bkpt->trigger);\n\n\tforce_sig_info(SIGTRAP, &info, current);\n}\n","idx":178949,"target":1}
{"code":"int do_mathemu(struct pt_regs *regs, struct task_struct *fpt)\n{\n\t\/* regs->pc isn't necessarily the PC at which the offending insn is sitting.\n\t * The FPU maintains a queue of FPops which cause traps.\n\t * When it hits an instruction that requires that the trapped op succeeded\n\t * (usually because it reads a reg. that the trapped op wrote) then it\n\t * causes this exception. We need to emulate all the insns on the queue\n\t * and then allow the op to proceed.\n\t * This code should also handle the case where the trap was precise,\n\t * in which case the queue length is zero and regs->pc points at the\n\t * single FPop to be emulated. (this case is untested, though :->)\n\t * You'll need this case if you want to be able to emulate all FPops\n\t * because the FPU either doesn't exist or has been software-disabled.\n\t * [The UltraSPARC makes FP a precise trap; this isn't as stupid as it\n\t * might sound because the Ultra does funky things with a superscalar\n\t * architecture.]\n\t *\/\n\n\t\/* You wouldn't believe how often I typed 'ftp' when I meant 'fpt' :-> *\/\n\n\tint i;\n \tint retcode = 0;                               \/* assume all succeed *\/\n \tunsigned long insn;\n \n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n \n #ifdef DEBUG_MATHEMU\n \tprintk(\"In do_mathemu()... pc is %08lx\\n\", regs->pc);\n\tprintk(\"fpqdepth is %ld\\n\", fpt->thread.fpqdepth);\n\tfor (i = 0; i < fpt->thread.fpqdepth; i++)\n\t\tprintk(\"%d: %08lx at %08lx\\n\", i, fpt->thread.fpqueue[i].insn,\n\t\t       (unsigned long)fpt->thread.fpqueue[i].insn_addr);\n#endif\n\n\tif (fpt->thread.fpqdepth == 0) {                   \/* no queue, guilty insn is at regs->pc *\/\n#ifdef DEBUG_MATHEMU\n\t\tprintk(\"precise trap at %08lx\\n\", regs->pc);\n#endif\n\t\tif (!get_user(insn, (u32 __user *) regs->pc)) {\n\t\t\tretcode = do_one_mathemu(insn, &fpt->thread.fsr, fpt->thread.float_regs);\n\t\t\tif (retcode) {\n\t\t\t\t\/* in this case we need to fix up PC & nPC *\/\n\t\t\t\tregs->pc = regs->npc;\n\t\t\t\tregs->npc += 4;\n\t\t\t}\n\t\t}\n\t\treturn retcode;\n\t}\n\n\t\/* Normal case: need to empty the queue... *\/\n\tfor (i = 0; i < fpt->thread.fpqdepth; i++) {\n\t\tretcode = do_one_mathemu(fpt->thread.fpqueue[i].insn, &(fpt->thread.fsr), fpt->thread.float_regs);\n\t\tif (!retcode)                               \/* insn failed, no point doing any more *\/\n\t\t\tbreak;\n\t}\n\t\/* Now empty the queue and clear the queue_not_empty flag *\/\n\tif (retcode)\n\t\tfpt->thread.fsr &= ~(0x3000 | FSR_CEXC_MASK);\n\telse\n\t\tfpt->thread.fsr &= ~0x3000;\n\tfpt->thread.fpqdepth = 0;\n\n\treturn retcode;\n}\n","idx":178986,"target":1}
{"code":"static int mov_text_decode_close(AVCodecContext *avctx)\n\n{\n\n    MovTextContext *m = avctx->priv_data;\n\n    mov_text_cleanup_ftab(m);\n\n\n    return 0;\n\n}","idx":639,"target":1}
{"code":"static bool check_rodc_critical_attribute(struct ldb_message *msg)\n{\n\tuint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n\n\tschemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n\tsearchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n\trodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE\n\t\t\t      | SEARCH_FLAG_CONFIDENTIAL);\n\n\tif ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&\n\t\t((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n","idx":0,"target":0}
{"code":"static int samldb_add_entry(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tret = ldb_build_add_req(&req, ldb, ac,\n\t\t\t\tac->msg,\n\t\t\t\tac->req->controls,\n\t\t\t\tac, samldb_add_entry_callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, req);\n}\n","idx":1,"target":0}
{"code":"static int samldb_add_entry_callback(struct ldb_request *req,\n\t\t\t\t\tstruct ldb_reply *ares)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\tif (ares->type == LDB_REPLY_REFERRAL) {\n\t\treturn ldb_module_send_referral(ac->req, ares->referral);\n\t}\n\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\tif (ares->type != LDB_REPLY_DONE) {\n\t\tldb_asprintf_errstring(ldb, \"Invalid LDB reply type %d\", ares->type);\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\t\/* The caller may wish to get controls back from the add *\/\n\tac->ares = talloc_steal(ac, ares);\n\n\tret = samldb_next_step(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, ret);\n\t}\n\treturn ret;\n}\n","idx":2,"target":0}
{"code":"static int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool id_exists;\n\tuint32_t msds_intid;\n\tint32_t system_flags;\n\tstruct ldb_context *ldb;\n\tstruct ldb_result *ldb_res;\n\tstruct ldb_dn *schema_dn;\n\tstruct samldb_msds_intid_persistant *msds_intid_struct;\n\tstruct dsdb_schema *schema;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\t\/* replicated update should always go through *\/\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* msDS-IntId is handled by system and should never be\n\t * passed by clients *\/\n\tif (ldb_msg_find_element(ac->msg, \"msDS-IntId\")) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t\/* do not generate msDS-IntId if Relax control is passed *\/\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* check Functional Level *\/\n\tif (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* check systemFlags for SCHEMA_BASE_OBJECT flag *\/\n\tsystem_flags = ldb_msg_find_attr_as_int(ac->msg, \"systemFlags\", 0);\n\tif (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tmsds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);\n\tif (!msds_intid_struct) {\n\t\tmsds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);\n\t\t\/* Generate new value for msDs-IntId\n\t\t* Value should be in 0x80000000..0xBFFFFFFF range *\/\n\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\tmsds_intid += 0x80000000;\n\t\tmsds_intid_struct->msds_intid = msds_intid;\n\t\tmsds_intid_struct->usn = schema->loaded_usn;\n\t\tDEBUG(2, (\"No samldb_msds_intid_persistant struct, allocating a new one\\n\"));\n\t} else {\n\t\tmsds_intid = msds_intid_struct->msds_intid;\n\t}\n\n\t\/* probe id values until unique one is found *\/\n\tdo {\n\t\tuint64_t current_usn;\n\t\tmsds_intid++;\n\t\tif (msds_intid > 0xBFFFFFFF) {\n\t\t\tmsds_intid = 0x80000001;\n\t\t}\n\t\t\/*\n\t\t * Alternative strategy to a costly (even indexed search) to the\n\t\t * database.\n\t\t * We search in the schema if we have already this intid (using dsdb_attribute_by_attributeID_id because\n\t\t * in the range 0x80000000 0xBFFFFFFFF, attributeID is a DSDB_ATTID_TYPE_INTID).\n\t\t * If so generate another random value.\n\t\t * If not check if the highest USN in the database for the schema partition is the\n\t\t * one that we know.\n\t\t * If so it means that's only this ldb context that is touching the schema in the database.\n\t\t * If not it means that's someone else has modified the database while we are doing our changes too\n\t\t * (this case should be very bery rare) in order to be sure do the search in the database.\n\t\t *\/\n\t\tif (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {\n\t\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\t\tmsds_intid += 0x80000000;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = dsdb_module_load_partition_usn(ac->module, schema_dn,\n\t\t\t\t\t\t     &current_usn, NULL, NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t      __location__\": Searching for schema USN failed: %s\\n\",\n\t\t\t\t      ldb_errstring(ldb));\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\n\t\t\/* current_usn can be lesser than msds_intid_struct-> if there is\n\t\t * uncommited changes.\n\t\t *\/\n\t\tif (current_usn > msds_intid_struct->usn) {\n\t\t\t\/* oups something has changed, someone\/something\n\t\t\t * else is modifying or has modified the schema\n\t\t\t * we'd better check this intid is the database directly\n\t\t\t *\/\n\n\t\t\tDEBUG(2, (\"Schema has changed, searching the database for the unicity of %d\\n\",\n\t\t\t\t\tmsds_intid));\n\n\t\t\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t\t\t&ldb_res,\n\t\t\t\t\t\tschema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t\t\tDSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t\tac->req,\n\t\t\t\t\t\t\"(msDS-IntId=%d)\", msds_intid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t\t__location__\": Searching for msDS-IntId=%d failed - %s\\n\",\n\t\t\t\t\tmsds_intid,\n\t\t\t\t\tldb_errstring(ldb));\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\t\t\tid_exists = (ldb_res->count > 0);\n\t\t\ttalloc_free(ldb_res);\n\t\t} else {\n\t\t\tid_exists = 0;\n\t\t}\n\n\t} while(id_exists);\n\tmsds_intid_struct->msds_intid = msds_intid;\n\tldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);\n\n\treturn samdb_msg_add_int(ldb, ac->msg, ac->msg, \"msDS-IntId\",\n\t\t\t\t msds_intid);\n}\n","idx":3,"target":0}
{"code":"static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)\n{\n\tstruct samldb_step *step, *stepper;\n\n\tstep = talloc_zero(ac, struct samldb_step);\n\tif (step == NULL) {\n\t\treturn ldb_oom(ldb_module_get_ctx(ac->module));\n\t}\n\n\tstep->fn = fn;\n\n\tif (ac->steps == NULL) {\n\t\tac->steps = step;\n\t\tac->curstep = step;\n\t} else {\n\t\tif (ac->curstep == NULL)\n\t\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t\tfor (stepper = ac->curstep; stepper->next != NULL;\n\t\t\tstepper = stepper->next);\n\t\tstepper->next = step;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n","idx":4,"target":0}
{"code":"static int samldb_allocate_sid(struct samldb_ctx *ac)\n{\n\tuint32_t rid;\n\tstruct dom_sid *sid;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\tret = ridalloc_allocate_rid(ac->module, &rid, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tif ( ! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n","idx":5,"target":0}
{"code":"static int samldb_check_sAMAccountName(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char *name;\n\tint ret;\n\tstruct ldb_result *res;\n\tconst char * const noattrs[] = { NULL };\n\n\tif (ldb_msg_find_element(ac->msg, \"sAMAccountName\") == NULL) {\n\t\tret = samldb_generate_sAMAccountName(ldb, ac->msg);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tname = ldb_msg_find_attr_as_string(ac->msg, \"sAMAccountName\", NULL);\n\tif (name == NULL) {\n\t\t\/* The \"sAMAccountName\" cannot be nothing *\/\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: Empty account names aren't allowed!\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb), LDB_SCOPE_SUBTREE, noattrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(sAMAccountName=%s)\",\n\t\t\t\t ldb_binary_encode_string(ac, name));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb: Account name (sAMAccountName) '%s' already in use!\",\n\t\t\t\t       name);\n\t\ttalloc_free(res);\n\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t}\n\ttalloc_free(res);\n\n\treturn samldb_next_step(ac);\n}\n","idx":6,"target":0}
{"code":"static int samldb_check_user_account_control_invariants(struct samldb_ctx *ac,\n\t\t\t\t\t\t    uint32_t user_account_control)\n{\n\tint i, ret = 0;\n\tbool need_check = false;\n\tconst struct uac_to_guid {\n\t\tuint32_t uac;\n\t\tbool never;\n\t\tuint32_t needs;\n\t\tuint32_t not_with;\n\t\tconst char *error_string;\n\t} map[] = {\n\t\t{\n\t\t\t.uac = UF_TEMP_DUPLICATE_ACCOUNT,\n\t\t\t.never = true,\n\t\t\t.error_string = \"Updating the UF_TEMP_DUPLICATE_ACCOUNT flag is never allowed\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.needs = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_PARTIAL_SECRETS_ACCOUNT only permitted with UF_WORKSTATION_TRUST_ACCOUNT\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.not_with = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_NORMAL_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_NORMAL_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.not_with = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT\"\n\t\t}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tif (user_account_control & map[i].uac) {\n\t\t\tneed_check = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (need_check == false) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tuint32_t this_uac = user_account_control & map[i].uac;\n\t\tif (this_uac != 0) {\n\t\t\tif (map[i].never) {\n\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\tbreak;\n\t\t\t} else if (map[i].needs != 0) {\n\t\t\t\tif ((map[i].needs & user_account_control) == 0) {\n\t\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (map[i].not_with != 0) {\n\t\t\t\tif ((map[i].not_with & user_account_control) != 0) {\n\t\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\tswitch (ac->req->operation) {\n\t\tcase LDB_ADD:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to add %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tcase LDB_MODIFY:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to modify %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ldb_module_operr(ac->module);\n\t\t}\n\t}\n\treturn ret;\n}\n","idx":7,"target":0}
{"code":"static struct samldb_ctx *samldb_ctx_init(struct ldb_module *module,\n\t\t\t\t\t  struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\n\tldb = ldb_module_get_ctx(module);\n\n\tac = talloc_zero(req, struct samldb_ctx);\n\tif (ac == NULL) {\n\t\tldb_oom(ldb);\n\t\treturn NULL;\n\t}\n\n\tac->module = module;\n\tac->req = req;\n\n\treturn ac;\n}\n","idx":8,"target":0}
{"code":"static int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tconst struct ldb_val *rdn_value;\n\tstruct dom_sid *sid;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tsid = samdb_result_dom_sid(ac->msg, ac->msg, \"objectSid\");\n\tif (sid == NULL) {\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tsid = dom_sid_parse_talloc(ac->msg,\n\t\t\t\t\t   (const char *)rdn_value->data);\n\t\tif (sid == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: No valid SID found in ForeignSecurityPrincipal CN!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tif (! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t}\n\n\t\/* finally proceed with adding the entry *\/\n\tret = samldb_add_step(ac, samldb_add_entry);\n\tif (ret != LDB_SUCCESS) return ret;\n\n\treturn samldb_first_step(ac);\n}\n","idx":9,"target":0}
{"code":"static int samldb_fill_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\t\/* Add information for the different account types *\/\n\tswitch(ac->type) {\n\tcase SAMLDB_TYPE_USER: {\n\t\tstruct ldb_control *rodc_control = ldb_request_get_control(ac->req,\n\t\t\t\t\t\t\t\t\t   LDB_CONTROL_RODC_DCPROMO_OID);\n\t\tif (rodc_control != NULL) {\n\t\t\t\/* see [MS-ADTS] 3.1.1.3.4.1.23 LDAP_SERVER_RODC_DCPROMO_OID *\/\n\t\t\trodc_control->critical = false;\n\t\t\tret = samldb_add_step(ac, samldb_rodc_add);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t}\n\n\t\t\/* check if we have a valid sAMAccountName *\/\n\t\tret = samldb_add_step(ac, samldb_check_sAMAccountName);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_GROUP: {\n\t\t\/* check if we have a valid sAMAccountName *\/\n\t\tret = samldb_add_step(ac, samldb_check_sAMAccountName);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_CLASS: {\n\t\tconst struct ldb_val *rdn_value, *def_obj_cat_val;\n\t\tunsigned int v = ldb_msg_find_attr_as_uint(ac->msg, \"objectClassCategory\", -2);\n\n\t\t\/* As discussed with Microsoft through dochelp in April 2012 this is the behavior of windows*\/\n\t\tif (!ldb_msg_find_element(ac->msg, \"subClassOf\")) {\n\t\t\tret = ldb_msg_add_string(ac->msg, \"subClassOf\", \"top\");\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t}\n\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"rdnAttId\", \"cn\");\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* do not allow to mark an attributeSchema as RODC filtered if it\n\t\t * is system-critical *\/\n\t\tif (check_rodc_critical_attribute(ac->msg)) {\n\t\t\tldb_asprintf_errstring(ldb, \"Refusing schema add of %s - cannot combine critical class with RODC filtering\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tif (!ldb_msg_find_element(ac->msg, \"lDAPDisplayName\")) {\n\t\t\t\/* the RDN has prefix \"CN\" *\/\n\t\t\tret = ldb_msg_add_string(ac->msg, \"lDAPDisplayName\",\n\t\t\t\tsamdb_cn_to_lDAPDisplayName(ac->msg,\n\t\t\t\t\t\t\t    (const char *) rdn_value->data));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (!ldb_msg_find_element(ac->msg, \"schemaIDGUID\")) {\n\t\t\tstruct GUID guid;\n\t\t\t\/* a new GUID *\/\n\t\t\tguid = GUID_random();\n\t\t\tret = dsdb_msg_add_guid(ac->msg, &guid, \"schemaIDGUID\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tdef_obj_cat_val = ldb_msg_find_ldb_val(ac->msg,\n\t\t\t\t\t\t       \"defaultObjectCategory\");\n\t\tif (def_obj_cat_val != NULL) {\n\t\t\t\/* \"defaultObjectCategory\" has been set by the caller.\n\t\t\t * Do some checks for consistency.\n\t\t\t * NOTE: The real constraint check (that\n\t\t\t * 'defaultObjectCategory' is the DN of the new\n\t\t\t * objectclass or any parent of it) is still incomplete.\n\t\t\t * For now we say that 'defaultObjectCategory' is valid\n\t\t\t * if it exists and it is of objectclass \"classSchema\".\n\t\t\t *\/\n\t\t\tac->dn = ldb_dn_from_ldb_val(ac, ldb, def_obj_cat_val);\n\t\t\tif (ac->dn == NULL) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t\t}\n\t\t} else {\n\t\t\t\/* \"defaultObjectCategory\" has not been set by the\n\t\t\t * caller. Use the entry DN for it. *\/\n\t\t\tac->dn = ac->msg->dn;\n\n\t\t\tret = ldb_msg_add_string(ac->msg, \"defaultObjectCategory\",\n\t\t\t\t\t\t ldb_dn_alloc_linearized(ac->msg, ac->dn));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* Now perform the checks for the 'defaultObjectCategory'. The\n\t\t * lookup DN was already saved in \"ac->dn\" *\/\n\t\tret = samldb_add_step(ac, samldb_find_for_defaultObjectCategory);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* -2 is not a valid objectClassCategory so it means the attribute wasn't present *\/\n\t\tif (v == -2) {\n\t\t\t\/* Windows 2003 does this*\/\n\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"objectClassCategory\", 0);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_ATTRIBUTE: {\n\t\tconst struct ldb_val *rdn_value;\n\t\tstruct ldb_message_element *el;\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tif (!ldb_msg_find_element(ac->msg, \"lDAPDisplayName\")) {\n\t\t\t\/* the RDN has prefix \"CN\" *\/\n\t\t\tret = ldb_msg_add_string(ac->msg, \"lDAPDisplayName\",\n\t\t\t\tsamdb_cn_to_lDAPDisplayName(ac->msg,\n\t\t\t\t\t\t\t    (const char *) rdn_value->data));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t\/* do not allow to mark an attributeSchema as RODC filtered if it\n\t\t * is system-critical *\/\n\t\tif (check_rodc_critical_attribute(ac->msg)) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: refusing schema add of %s - cannot combine critical attribute with RODC filtering\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"isSingleValued\", \"FALSE\");\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tif (!ldb_msg_find_element(ac->msg, \"schemaIDGUID\")) {\n\t\t\tstruct GUID guid;\n\t\t\t\/* a new GUID *\/\n\t\t\tguid = GUID_random();\n\t\t\tret = dsdb_msg_add_guid(ac->msg, &guid, \"schemaIDGUID\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tel = ldb_msg_find_element(ac->msg, \"attributeSyntax\");\n\t\tif (el) {\n\t\t\t\/*\n\t\t\t * No need to scream if there isn't as we have code later on\n\t\t\t * that will take care of it.\n\t\t\t *\/\n\t\t\tconst struct dsdb_syntax *syntax = find_syntax_map_by_ad_oid((const char *)el->values[0].data);\n\t\t\tif (!syntax) {\n\t\t\t\tDEBUG(9, (\"Can't find dsdb_syntax object for attributeSyntax %s\\n\",\n\t\t\t\t\t\t(const char *)el->values[0].data));\n\t\t\t} else {\n\t\t\t\tunsigned int v = ldb_msg_find_attr_as_uint(ac->msg, \"oMSyntax\", 0);\n\t\t\t\tconst struct ldb_val *val = ldb_msg_find_ldb_val(ac->msg, \"oMObjectClass\");\n\n\t\t\t\tif (v == 0) {\n\t\t\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"oMSyntax\", syntax->oMSyntax);\n\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!val) {\n\t\t\t\t\tstruct ldb_val val2 = ldb_val_dup(ldb, &syntax->oMObjectClass);\n\t\t\t\t\tif (val2.length > 0) {\n\t\t\t\t\t\tret = ldb_msg_add_value(ac->msg, \"oMObjectClass\", &val2, NULL);\n\t\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\/* handle msDS-IntID attribute *\/\n\t\tret = samldb_add_handle_msDS_IntId(ac);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb, \"Invalid entry type!\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\tbreak;\n\t}\n\n\treturn samldb_first_step(ac);\n}\n","idx":10,"target":0}
{"code":"static int samldb_find_for_defaultObjectCategory(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tac->res_dn = NULL;\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ac->dn, LDB_SCOPE_BASE, no_attrs,\n\t\t\t\t DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT\n\t\t\t\t | DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectClass=classSchema)\");\n\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\/* Don't be pricky when the DN doesn't exist if we have the *\/\n\t\t\/* RELAX control specified *\/\n\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb_find_defaultObjectCategory: \"\n\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\tif ((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)) {\n\t\treturn ret;\n\t}\n\n\tif (ret == LDB_SUCCESS) {\n\t\t\/* ensure the defaultObjectCategory has a full GUID *\/\n\t\tstruct ldb_message *m;\n\t\tm = ldb_msg_new(ac->msg);\n\t\tif (m == NULL) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->dn = ac->msg->dn;\n\t\tif (ldb_msg_add_string(m, \"defaultObjectCategory\",\n\t\t\t\t       ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1)) !=\n\t\t    LDB_SUCCESS) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->elements[0].flags = LDB_FLAG_MOD_REPLACE;\n\n\t\tret = dsdb_module_modify(ac->module, m,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\n\tac->res_dn = ac->dn;\n\n\treturn samldb_next_step(ac);\n}\n","idx":11,"target":0}
{"code":"static int samldb_first_step(struct samldb_ctx *ac)\n{\n\tif (ac->steps == NULL) {\n\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t}\n\n\tac->curstep = ac->steps;\n\treturn ac->curstep->fn(ac);\n}\n","idx":12,"target":0}
{"code":"static int samldb_generate_sAMAccountName(struct ldb_context *ldb,\n\t\t\t\t\t  struct ldb_message *msg)\n{\n\tchar *name;\n\n\t\/* Format: $000000-000000000000 *\/\n\n\tname = talloc_asprintf(msg, \"$%.6X-%.6X%.6X\",\n\t\t\t\t(unsigned int)generate_random(),\n\t\t\t\t(unsigned int)generate_random(),\n\t\t\t\t(unsigned int)generate_random());\n\tif (name == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\treturn ldb_msg_add_steal_string(msg, \"sAMAccountName\", name);\n}\n","idx":13,"target":0}
{"code":"static bool samldb_krbtgtnumber_available(struct samldb_ctx *ac,\n\t\t\t\t\t  uint32_t krbtgt_number)\n{\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tret = dsdb_module_search(ac->module, tmp_ctx, &res,\n\t\t\t\t ldb_get_default_basedn(ldb_module_get_ctx(ac->module)),\n\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(msDC-SecondaryKrbTgtNumber=%u)\",\n\t\t\t\t krbtgt_number);\n\tif (ret == LDB_SUCCESS && res->count == 0) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn true;\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn false;\n}\n","idx":14,"target":0}
{"code":"static bool samldb_msg_add_sid(struct ldb_message *msg,\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct dom_sid *sid)\n{\n\tstruct ldb_val v;\n\tenum ndr_err_code ndr_err;\n\n\tndr_err = ndr_push_struct_blob(&v, msg, sid,\n\t\t\t\t       (ndr_push_flags_fn_t)ndr_push_dom_sid);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\treturn false;\n\t}\n\treturn (ldb_msg_add_value(msg, name, &v, NULL) == 0);\n}\n","idx":15,"target":0}
{"code":"static int samldb_next_step(struct samldb_ctx *ac)\n{\n\tif (ac->curstep->next) {\n\t\tac->curstep = ac->curstep->next;\n\t\treturn ac->curstep->fn(ac);\n\t}\n\n\t\/* We exit the samldb module here. If someone set an \"ares\" to forward\n\t * controls and response back to the caller, use them. *\/\n\tif (ac->ares) {\n\t\treturn ldb_module_done(ac->req, ac->ares->controls,\n\t\t\t\t       ac->ares->response, LDB_SUCCESS);\n\t} else {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);\n\t}\n}\n","idx":16,"target":0}
{"code":"static int samldb_objectclass_trigger(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tvoid *skip_allocate_sids = ldb_get_opaque(ldb,\n\t\t\t\t\t\t  \"skip_allocate_sids\");\n\tstruct ldb_message_element *el, *el2;\n\tstruct dom_sid *sid;\n\tint ret;\n\n\t\/* make sure that \"sAMAccountType\" is not specified *\/\n\tel = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\tif (el != NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: sAMAccountType must not be specified!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t\/* Step 1: objectSid assignment *\/\n\n\t\/* Don't allow the objectSid to be changed. But beside the RELAX\n\t * control we have also to guarantee that it can always be set with\n\t * SYSTEM permissions. This is needed for the \"samba3sam\" backend. *\/\n\tsid = samdb_result_dom_sid(ac, ac->msg, \"objectSid\");\n\tif ((sid != NULL) && (!dsdb_module_am_system(ac->module)) &&\n\t    (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: objectSid must not be specified!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t\/* but generate a new SID when we do have an add operations *\/\n\tif ((sid == NULL) && (ac->req->operation == LDB_ADD) && !skip_allocate_sids) {\n\t\tret = samldb_add_step(ac, samldb_allocate_sid);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t}\n\n\tswitch(ac->type) {\n\tcase SAMLDB_TYPE_USER: {\n\t\tbool uac_generated = false, uac_add_flags = false;\n\n\t\t\/* Step 1.2: Default values *\/\n\t\tret = dsdb_user_obj_set_defaults(ldb, ac->msg);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* On add operations we might need to generate a\n\t\t * \"userAccountControl\" (if it isn't specified). *\/\n\t\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\t\tif ((el == NULL) && (ac->req->operation == LDB_ADD)) {\n\t\t\tret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t UF_NORMAL_ACCOUNT);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tuac_generated = true;\n\t\t\tuac_add_flags = true;\n\t\t}\n\n\t\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\t\tif (el != NULL) {\n\t\t\tuint32_t user_account_control;\n\t\t\t\/* Step 1.3: \"userAccountControl\" -> \"sAMAccountType\" mapping *\/\n\t\t\tuser_account_control = ldb_msg_find_attr_as_uint(ac->msg,\n\t\t\t\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\t\/*\n\t\t\t * \"userAccountControl\" = 0 or missing one of\n\t\t\t * the types means \"UF_NORMAL_ACCOUNT\".  See\n\t\t\t * MS-SAMR 3.1.1.8.10 point 8\n\t\t\t *\/\n\t\t\tif ((user_account_control & UF_ACCOUNT_TYPE_MASK) == 0) {\n\t\t\t\tuser_account_control = UF_NORMAL_ACCOUNT | user_account_control;\n\t\t\t\tuac_generated = true;\n\t\t\t}\n\n\t\t\t\/*\n\t\t\t * As per MS-SAMR 3.1.1.8.10 these flags have not to be set\n\t\t\t *\/\n\t\t\tif ((user_account_control & UF_LOCKOUT) != 0) {\n\t\t\t\tuser_account_control &= ~UF_LOCKOUT;\n\t\t\t\tuac_generated = true;\n\t\t\t}\n\t\t\tif ((user_account_control & UF_PASSWORD_EXPIRED) != 0) {\n\t\t\t\tuser_account_control &= ~UF_PASSWORD_EXPIRED;\n\t\t\t\tuac_generated = true;\n\t\t\t}\n\n\t\t\tret = samldb_check_user_account_control_rules(ac, NULL,\n\t\t\t\t\t\t\t\t      user_account_control, 0);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t\/* Workstation and (read-only) DC objects do need objectclass \"computer\" *\/\n\t\t\tif ((samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"objectclass\", \"computer\") == NULL) &&\n\t\t\t    (user_account_control &\n\t\t\t     (UF_SERVER_TRUST_ACCOUNT | UF_WORKSTATION_TRUST_ACCOUNT))) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\t  \"samldb: Requested account type does need objectclass 'computer'!\");\n\t\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t\t}\n\n\t\t\t\/* add \"sAMAccountType\" attribute *\/\n\t\t\tret = dsdb_user_obj_set_account_type(ldb, ac->msg, user_account_control, NULL);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t\/* \"isCriticalSystemObject\" might be set *\/\n\t\t\tif (user_account_control &\n\t\t\t    (UF_SERVER_TRUST_ACCOUNT | UF_PARTIAL_SECRETS_ACCOUNT)) {\n\t\t\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t\t\t \"TRUE\");\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tel2 = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t\t} else if (user_account_control & UF_WORKSTATION_TRUST_ACCOUNT) {\n\t\t\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t\t\t \"FALSE\");\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tel2 = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t\t}\n\n\t\t\t\/* Step 1.4: \"userAccountControl\" -> \"primaryGroupID\" mapping *\/\n\t\t\tif (!ldb_msg_find_element(ac->msg, \"primaryGroupID\")) {\n\t\t\t\tuint32_t rid;\n\n\t\t\t\tret = dsdb_user_obj_set_primary_group_id(ldb, ac->msg, user_account_control, &rid);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\t\/*\n\t\t\t\t * Older AD deployments don't know about the\n\t\t\t\t * RODC group\n\t\t\t\t *\/\n\t\t\t\tif (rid == DOMAIN_RID_READONLY_DCS) {\n\t\t\t\t\tret = samldb_prim_group_tester(ac, rid);\n\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/* Step 1.5: Add additional flags when needed *\/\n\t\t\t\/* Obviously this is done when the \"userAccountControl\"\n\t\t\t * has been generated here (tested against Windows\n\t\t\t * Server) *\/\n\t\t\tif (uac_generated) {\n\t\t\t\tif (uac_add_flags) {\n\t\t\t\t\tuser_account_control |= UF_ACCOUNTDISABLE;\n\t\t\t\t\tuser_account_control |= UF_PASSWD_NOTREQD;\n\t\t\t\t}\n\n\t\t\t\tret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t\t user_account_control);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_GROUP: {\n\t\tconst char *tempstr;\n\n\t\t\/* Step 2.2: Default values *\/\n\t\ttempstr = talloc_asprintf(ac->msg, \"%d\",\n\t\t\t\t\t  GTYPE_SECURITY_GLOBAL_GROUP);\n\t\tif (tempstr == NULL) return ldb_operr(ldb);\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\"groupType\", tempstr);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* Step 2.3: \"groupType\" -> \"sAMAccountType\" *\/\n\t\tel = ldb_msg_find_element(ac->msg, \"groupType\");\n\t\tif (el != NULL) {\n\t\t\tuint32_t group_type, account_type;\n\n\t\t\tgroup_type = ldb_msg_find_attr_as_uint(ac->msg,\n\t\t\t\t\t\t\t       \"groupType\", 0);\n\n\t\t\t\/* The creation of builtin groups requires the\n\t\t\t * RELAX control *\/\n\t\t\tif (group_type == GTYPE_SECURITY_BUILTIN_LOCAL_GROUP) {\n\t\t\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taccount_type = ds_gtype2atype(group_type);\n\t\t\tif (account_type == 0) {\n\t\t\t\tldb_set_errstring(ldb, \"samldb: Unrecognized account type!\");\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"sAMAccountType\",\n\t\t\t\t\t\t account_type);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tel2 = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"Invalid entry type!\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\tbreak;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n","idx":17,"target":0}
{"code":"static int samldb_prim_group_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const attrs[] = {\n\t\t\"primaryGroupID\",\n\t\t\"memberOf\",\n\t\t\"userAccountControl\",\n\t\tNULL };\n\tstruct ldb_result *res, *group_res;\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *msg;\n\tuint32_t prev_rid, new_rid, uac;\n\tstruct dom_sid *prev_sid, *new_sid;\n\tstruct ldb_dn *prev_prim_group_dn, *new_prim_group_dn;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tel = dsdb_get_single_valued_attr(ac->msg, \"primaryGroupID\",\n\t\t\t\t\t ac->req->operation);\n\tif (el == NULL) {\n\t\t\/* we are not affected *\/\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* Fetch information from the existing object *\/\n\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tuac = ldb_msg_find_attr_as_uint(res->msgs[0], \"userAccountControl\", 0);\n\n\t\/* Finds out the DN of the old primary group *\/\n\n\tprev_rid = ldb_msg_find_attr_as_uint(res->msgs[0], \"primaryGroupID\",\n\t\t\t\t\t     (uint32_t) -1);\n\tif (prev_rid == (uint32_t) -1) {\n\t\t\/* User objects do always have a mandatory \"primaryGroupID\"\n\t\t * attribute. If this doesn't exist then the object is of the\n\t\t * wrong type. This is the exact Windows error code *\/\n\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t}\n\n\tprev_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), prev_rid);\n\tif (prev_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t\/* Finds out the DN of the new primary group\n\t * Notice: in order to parse the primary group ID correctly we create\n\t * a temporary message here. *\/\n\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tnew_rid = ldb_msg_find_attr_as_uint(msg, \"primaryGroupID\", (uint32_t) -1);\n\ttalloc_free(msg);\n\tif (new_rid == (uint32_t) -1) {\n\t\t\/* we aren't affected of any primary group change *\/\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif (prev_rid == new_rid) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif ((uac & UF_SERVER_TRUST_ACCOUNT) && new_rid != DOMAIN_RID_DCS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: UF_SERVER_TRUST_ACCOUNT requires \"\n\t\t\t\"primaryGroupID=%u!\",\n\t\t\tW_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),\n\t\t\tDOMAIN_RID_DCS);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tif ((uac & UF_PARTIAL_SECRETS_ACCOUNT) && new_rid != DOMAIN_RID_READONLY_DCS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: UF_PARTIAL_SECRETS_ACCOUNT requires \"\n\t\t\t\"primaryGroupID=%u!\",\n\t\t\tW_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),\n\t\t\tDOMAIN_RID_READONLY_DCS);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &group_res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, prev_sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (group_res->count != 1) {\n\t\treturn ldb_operr(ldb);\n\t}\n\tprev_prim_group_dn = group_res->msgs[0]->dn;\n\n\tnew_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), new_rid);\n\tif (new_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &group_res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, new_sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (group_res->count != 1) {\n\t\t\/* Here we know if the specified new primary group candidate is\n\t\t * valid or not. *\/\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tnew_prim_group_dn = group_res->msgs[0]->dn;\n\n\t\/* We need to be already a normal member of the new primary\n\t * group in order to be successful. *\/\n\tel = samdb_find_attribute(ldb, res->msgs[0], \"memberOf\",\n\t\t\t\t  ldb_dn_get_linearized(new_prim_group_dn));\n\tif (el == NULL) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t\/* Remove the \"member\" attribute on the new primary group *\/\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tmsg->dn = new_prim_group_dn;\n\n\tret = samdb_msg_add_delval(ldb, msg, msg, \"member\",\n\t\t\t\t   ldb_dn_get_linearized(ac->msg->dn));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\n\t\/* Add a \"member\" attribute for the previous primary group *\/\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tmsg->dn = prev_prim_group_dn;\n\n\tret = samdb_msg_add_addval(ldb, msg, msg, \"member\",\n\t\t\t\t   ldb_dn_get_linearized(ac->msg->dn));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\n\treturn LDB_SUCCESS;\n}\n","idx":18,"target":0}
{"code":"static int samldb_prim_group_set(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t rid;\n\n\trid = ldb_msg_find_attr_as_uint(ac->msg, \"primaryGroupID\", (uint32_t) -1);\n\tif (rid == (uint32_t) -1) {\n\t\t\/* we aren't affected of any primary group set *\/\n\t\treturn LDB_SUCCESS;\n\n\t} else if (!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"The primary group isn't settable on add operations!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\treturn samldb_prim_group_tester(ac, rid);\n}\n","idx":19,"target":0}
{"code":"static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct dom_sid *sid;\n\tstruct ldb_result *res;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\ttalloc_free(res);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"Failed to find primary group with RID %u!\",\n\t\t\t\t       rid);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n","idx":20,"target":0}
{"code":"static int samldb_prim_group_trigger(struct samldb_ctx *ac)\n{\n\tint ret;\n\n\tif (ac->req->operation == LDB_ADD) {\n\t\tret = samldb_prim_group_set(ac);\n\t} else {\n\t\tret = samldb_prim_group_change(ac);\n\t}\n\n\treturn ret;\n}\n","idx":21,"target":0}
{"code":"static int samldb_rodc_add(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t krbtgt_number, i_start, i;\n\tint ret;\n\tchar *newpass;\n\tstruct ldb_val newpass_utf16;\n\n\t\/* find a unused msDC-SecondaryKrbTgtNumber *\/\n\ti_start = generate_random() & 0xFFFF;\n\tif (i_start == 0) {\n\t\ti_start = 1;\n\t}\n\n\tfor (i=i_start; i<=0xFFFF; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\tfor (i=1; i<i_start; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tldb_asprintf_errstring(ldb,\n\t\t\t       \"%08X: Unable to find available msDS-SecondaryKrbTgtNumber\",\n\t\t\t       W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));\n\treturn LDB_ERR_OTHER;\n\nfound:\n\tret = ldb_msg_add_empty(ac->msg, \"msDS-SecondaryKrbTgtNumber\",\n\t\t\t\tLDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t \"msDS-SecondaryKrbTgtNumber\", krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = ldb_msg_add_fmt(ac->msg, \"sAMAccountName\", \"krbtgt_%u\",\n\t\t\t      krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tnewpass = generate_random_password(ac->msg, 128, 255);\n\tif (newpass == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tif (!convert_string_talloc(ac,\n\t\t\t\t   CH_UNIX, CH_UTF16,\n\t\t\t\t   newpass, strlen(newpass),\n\t\t\t\t   (void *)&newpass_utf16.data,\n\t\t\t\t   &newpass_utf16.length)) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb_rodc_add: \"\n\t\t\t\t       \"failed to generate UTF16 password from random password\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tret = ldb_msg_add_steal_value(ac->msg, \"clearTextPassword\", &newpass_utf16);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n","idx":22,"target":0}
{"code":"static int samldb_schema_info_update(struct samldb_ctx *ac)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct dsdb_schema *schema;\n\n\t\/* replicated update should always go through *\/\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* do not update schemaInfo during provisioning *\/\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_schema_info_update(ac->module, schema,\n\t\t\t\t\t     DSDB_FLAG_NEXT_MODULE|\n\t\t\t\t\t     DSDB_FLAG_AS_SYSTEM,\n\t\t\t\t\t     ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb_schema_info_update: dsdb_module_schema_info_update failed with %s\",\n\t\t\t\t       ldb_errstring(ldb));\n\t\treturn ret;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n","idx":23,"target":0}
{"code":"void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n\n\n    if (!dc->hotpluggable) {\n\n        return;\n\n    }\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    if (dev->hotplugged) {\n\n        mdev->is_inserting = true;\n\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n\n    }\n\n}\n","idx":52,"target":0}
{"code":"static int tcg_match_cmpi(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        \/* The COMPARE IMMEDIATE instruction is available.  *\/\n\n        if (type == TCG_TYPE_I32) {\n\n            \/* We have a 32-bit immediate and can compare against anything.  *\/\n\n            return 1;\n\n        } else {\n\n            \/* ??? We have no insight here into whether the comparison is\n\n               signed or unsigned.  The COMPARE IMMEDIATE insn uses a 32-bit\n\n               signed immediate, and the COMPARE LOGICAL IMMEDIATE insn uses\n\n               a 32-bit unsigned immediate.  If we were to use the (semi)\n\n               obvious \"val == (int32_t)val\" we would be enabling unsigned\n\n               comparisons vs very large numbers.  The only solution is to\n\n               take the intersection of the ranges.  *\/\n\n            \/* ??? Another possible solution is to simply lie and allow all\n\n               constants here and force the out-of-range values into a temp\n\n               register in tgen_cmp when we have knowledge of the actual\n\n               comparison code in use.  *\/\n\n            return val >= 0 && val <= 0x7fffffff;\n\n        }\n\n    } else {\n\n        \/* Only the LOAD AND TEST instruction is available.  *\/\n\n        return val == 0;\n\n    }\n\n}\n","idx":67,"target":0}
{"code":"static void test_validate_struct_nested(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n\n                           \"'dict1': { 'string1': 'string1', \"\n\n                           \"'dict2': { 'userdef': { 'integer': 42, \"\n\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n","idx":47,"target":0}
{"code":"static int mov_write_minf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    int ret;\n\n\n\n    avio_wb32(pb, 0); \/* size *\/\n\n    ffio_wfourcc(pb, \"minf\");\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        mov_write_vmhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        mov_write_smhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n\n            mov_write_gmhd_tag(pb, track);\n\n        } else {\n\n            mov_write_nmhd_tag(pb);\n\n        }\n\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n\n        mov_write_hmhd_tag(pb);\n\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n\n        mov_write_gmhd_tag(pb, track);\n\n    }\n\n    if (track->mode == MODE_MOV) \/* FIXME: Why do it for MODE_MOV only ? *\/\n\n        mov_write_hdlr_tag(pb, NULL);\n\n    mov_write_dinf_tag(pb);\n\n    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)\n\n        return ret;\n\n    return update_size(pb, pos);\n\n}\n","idx":27,"target":0}
{"code":"static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwl.base = base;\n\n    omap_pwl_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn,\n\n                    omap_pwl_writefn, s);\n\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n}\n","idx":73,"target":0}
{"code":"static void decode_plane(FFV1Context *s, uint8_t *src,\n\n                         int w, int h, int stride, int plane_index,\n\n                         int pixel_stride)\n\n{\n\n    int x, y;\n\n    int16_t *sample[2];\n\n    sample[0] = s->sample_buffer + 3;\n\n    sample[1] = s->sample_buffer + w + 6 + 3;\n\n\n\n    s->run_index = 0;\n\n\n\n    memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));\n\n\n\n    for (y = 0; y < h; y++) {\n\n        int16_t *temp = sample[0]; \/\/ FIXME: try a normal buffer\n\n\n\n        sample[0] = sample[1];\n\n        sample[1] = temp;\n\n\n\n        sample[1][-1] = sample[0][0];\n\n        sample[0][w]  = sample[0][w - 1];\n\n\n\n\/\/ { START_TIMER\n\n        if (s->avctx->bits_per_raw_sample <= 8) {\n\n            decode_line(s, w, sample, plane_index, 8);\n\n            for (x = 0; x < w; x++)\n\n                src[x*pixel_stride + stride * y] = sample[1][x];\n\n        } else {\n\n            decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);\n\n            if (s->packed_at_lsb) {\n\n                for (x = 0; x < w; x++) {\n\n                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x];\n\n                }\n\n            } else {\n\n                for (x = 0; x < w; x++) {\n\n                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample) | ((uint16_t **)sample)[1][x] >> (2 * s->avctx->bits_per_raw_sample - 16);\n\n                }\n\n            }\n\n        }\n\n\/\/ STOP_TIMER(\"decode-line\") }\n\n    }\n\n}\n","idx":8200,"target":1}
{"code":"void aio_context_setup(AioContext *ctx)\n\n{\n\n}\n","idx":57,"target":0}
{"code":"setup_server_realm(krb5_principal sprinc)\n{\n    krb5_error_code     kret;\n     kdc_realm_t         *newrealm;\n \n     kret = 0;\n     if (kdc_numrealms > 1) {\n         if (!(newrealm = find_realm_data(sprinc->realm.data,\n                                          (krb5_ui_4) sprinc->realm.length)))\n            kret = ENOENT;\n        else\n            kdc_active_realm = newrealm;\n    }\n    else\n        kdc_active_realm = kdc_realmlist[0];\n    return(kret);\n}\n","idx":179105,"target":1}
{"code":"static PHP_FUNCTION(preg_match)\n{\n\tphp_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n","idx":37,"target":0}
{"code":"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n","idx":51,"target":0}
{"code":"static int reap_filters(void)\n\n{\n\n    AVFilterBufferRef *picref;\n\n    AVFrame *filtered_frame = NULL;\n\n    int i;\n\n    int64_t frame_pts;\n\n\n\n    \/* Reap all buffers present in the buffer sinks *\/\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n        OutputFile    *of = output_files[ost->file_index];\n\n        int ret = 0;\n\n\n\n        if (!ost->filter)\n\n            continue;\n\n\n\n        if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {\n\n            return AVERROR(ENOMEM);\n\n        } else\n\n            avcodec_get_frame_defaults(ost->filtered_frame);\n\n        filtered_frame = ost->filtered_frame;\n\n\n\n        while (1) {\n\n            ret = av_buffersink_get_buffer_ref(ost->filter->filter, &picref,\n\n                                               AV_BUFFERSINK_FLAG_NO_REQUEST);\n\n            if (ret < 0) {\n\n                if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF) {\n\n                    char buf[256];\n\n                    av_strerror(ret, buf, sizeof(buf));\n\n                    av_log(NULL, AV_LOG_WARNING,\n\n                           \"Error in av_buffersink_get_buffer_ref(): %s\\n\", buf);\n\n\n\n\n            frame_pts = AV_NOPTS_VALUE;\n\n            if (picref->pts != AV_NOPTS_VALUE) {\n\n                filtered_frame->pts = frame_pts = av_rescale_q(picref->pts,\n\n                                                ost->filter->filter->inputs[0]->time_base,\n\n                                                ost->st->codec->time_base) -\n\n                                    av_rescale_q(of->start_time,\n\n                                                AV_TIME_BASE_Q,\n\n                                                ost->st->codec->time_base);\n\n\n\n                if (of->start_time && filtered_frame->pts < 0) {\n\n                    avfilter_unref_buffer(picref);\n\n                    continue;\n\n\n\n            \/\/if (ost->source_index >= 0)\n\n            \/\/    *filtered_frame= *input_streams[ost->source_index]->decoded_frame; \/\/for me_threshold\n\n\n\n\n\n            switch (ost->filter->filter->inputs[0]->type) {\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                avfilter_copy_buf_props(filtered_frame, picref);\n\n                filtered_frame->pts = frame_pts;\n\n                if (!ost->frame_aspect_ratio)\n\n                    ost->st->codec->sample_aspect_ratio = picref->video->sample_aspect_ratio;\n\n\n\n                do_video_out(of->ctx, ost, filtered_frame);\n\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                avfilter_copy_buf_props(filtered_frame, picref);\n\n                filtered_frame->pts = frame_pts;\n\n\n\n\n\n\n\n                do_audio_out(of->ctx, ost, filtered_frame);\n\n\n            default:\n\n                \/\/ TODO support subtitle filters\n\n                av_assert0(0);\n\n\n\n\n            avfilter_unref_buffer(picref);\n\n\n\n\n\n    return 0;\n","idx":26140,"target":1}
{"code":"static int film_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    FilmDemuxContext *film = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char scratch[256];\n\n    int i;\n\n    unsigned int data_offset;\n\n    unsigned int audio_frame_counter;\n\n\n\n    film->sample_table = NULL;\n\n    film->stereo_buffer = NULL;\n\n    film->stereo_buffer_size = 0;\n\n\n\n    \/* load the main FILM header *\/\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    data_offset = AV_RB32(&scratch[4]);\n\n    film->version = AV_RB32(&scratch[8]);\n\n\n\n    \/* load the FDSC chunk *\/\n\n    if (film->version == 0) {\n\n        \/* special case for Lemmings .film files; 20-byte header *\/\n\n        if (avio_read(pb, scratch, 20) != 20)\n\n            return AVERROR(EIO);\n\n        \/* make some assumptions about the audio parameters *\/\n\n        film->audio_type = CODEC_ID_PCM_S8;\n\n        film->audio_samplerate = 22050;\n\n        film->audio_channels = 1;\n\n        film->audio_bits = 8;\n\n    } else {\n\n        \/* normal Saturn .cpk files; 32-byte header *\/\n\n        if (avio_read(pb, scratch, 32) != 32)\n\n            return AVERROR(EIO);\n\n        film->audio_samplerate = AV_RB16(&scratch[24]);\n\n        film->audio_channels = scratch[21];\n\n        film->audio_bits = scratch[22];\n\n        if (scratch[23] == 2)\n\n            film->audio_type = CODEC_ID_ADPCM_ADX;\n\n        else if (film->audio_bits == 8)\n\n            film->audio_type = CODEC_ID_PCM_S8;\n\n        else if (film->audio_bits == 16)\n\n            film->audio_type = CODEC_ID_PCM_S16BE;\n\n        else\n\n            film->audio_type = CODEC_ID_NONE;\n\n    }\n\n\n\n    if (AV_RB32(&scratch[0]) != FDSC_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (AV_RB32(&scratch[8]) == CVID_TAG) {\n\n        film->video_type = CODEC_ID_CINEPAK;\n\n    } else\n\n        film->video_type = CODEC_ID_NONE;\n\n\n\n    \/* initialize the decoder streams *\/\n\n    if (film->video_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->video_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->codec->codec_id = film->video_type;\n\n        st->codec->codec_tag = 0;  \/* no fourcc *\/\n\n        st->codec->width = AV_RB32(&scratch[16]);\n\n        st->codec->height = AV_RB32(&scratch[12]);\n\n    }\n\n\n\n    if (film->audio_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->audio_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = film->audio_type;\n\n        st->codec->codec_tag = 1;\n\n        st->codec->channels = film->audio_channels;\n\n        st->codec->sample_rate = film->audio_samplerate;\n\n\n\n        if (film->audio_type == CODEC_ID_ADPCM_ADX) {\n\n            st->codec->bits_per_coded_sample = 18 * 8 \/ 32;\n\n            st->codec->block_align = st->codec->channels * 18;\n\n        } else {\n\n            st->codec->bits_per_coded_sample = film->audio_bits;\n\n            st->codec->block_align = st->codec->channels *\n\n                st->codec->bits_per_coded_sample \/ 8;\n\n        }\n\n\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample;\n\n    }\n\n\n\n    \/* load the sample table *\/\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    if (AV_RB32(&scratch[0]) != STAB_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n    film->base_clock = AV_RB32(&scratch[8]);\n\n    film->sample_count = AV_RB32(&scratch[12]);\n\n    if(film->sample_count >= UINT_MAX \/ sizeof(film_sample))\n\n        return -1;\n\n    film->sample_table = av_malloc(film->sample_count * sizeof(film_sample));\n\n    if (!film->sample_table)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for(i=0; i<s->nb_streams; i++)\n\n        av_set_pts_info(s->streams[i], 33, 1, film->base_clock);\n\n\n\n    audio_frame_counter = 0;\n\n    for (i = 0; i < film->sample_count; i++) {\n\n        \/* load the next sample record and transfer it to an internal struct *\/\n\n        if (avio_read(pb, scratch, 16) != 16) {\n\n            av_free(film->sample_table);\n\n            return AVERROR(EIO);\n\n        }\n\n        film->sample_table[i].sample_offset =\n\n            data_offset + AV_RB32(&scratch[0]);\n\n        film->sample_table[i].sample_size = AV_RB32(&scratch[4]);\n\n        if (AV_RB32(&scratch[8]) == 0xFFFFFFFF) {\n\n            film->sample_table[i].stream = film->audio_stream_index;\n\n            film->sample_table[i].pts = audio_frame_counter;\n\n            film->sample_table[i].pts *= film->base_clock;\n\n            film->sample_table[i].pts \/= film->audio_samplerate;\n\n\n\n            if (film->audio_type == CODEC_ID_ADPCM_ADX)\n\n                audio_frame_counter += (film->sample_table[i].sample_size * 32 \/\n\n                    (18 * film->audio_channels));\n\n            else\n\n                audio_frame_counter += (film->sample_table[i].sample_size \/\n\n                    (film->audio_channels * film->audio_bits \/ 8));\n\n        } else {\n\n            film->sample_table[i].stream = film->video_stream_index;\n\n            film->sample_table[i].pts = AV_RB32(&scratch[8]) & 0x7FFFFFFF;\n\n            film->sample_table[i].keyframe = (scratch[8] & 0x80) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    film->current_sample = 0;\n\n\n\n    return 0;\n\n}\n","idx":14612,"target":1}
{"code":"static int xan_huffman_decode(unsigned char *dest, int dest_len,\n\n                              const unsigned char *src, int src_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    int ptr_len = src_len - 1 - byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    if (ptr_len < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    init_get_bits(&gb, ptr, ptr_len * 8);\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest >= dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":5130,"target":1}
{"code":"static int ea_read_header(AVFormatContext *s,\n                          AVFormatParameters *ap)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVStream *st;\n    if (!process_ea_header(s))\n        return AVERROR(EIO);\n    if (ea->video_codec) {\n        \/* initialize the video decoder stream *\/\n        st = av_new_stream(s, 0);\n        if (!st)\n            return AVERROR(ENOMEM);\n        ea->video_stream_index = st->index;\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codec->codec_id = ea->video_codec;\n        st->codec->codec_tag = 0;  \/* no fourcc *\/\n        st->codec->time_base = ea->time_base;\n        st->codec->width = ea->width;\n        st->codec->height = ea->height;\n    if (ea->num_channels <= 0) {\n        av_log(s, AV_LOG_WARNING, \"Unsupported number of channels: %d\\n\", ea->num_channels);\n    if (ea->audio_codec) {\n        \/* initialize the audio decoder stream *\/\n        st = av_new_stream(s, 0);\n        if (!st)\n            return AVERROR(ENOMEM);\n        av_set_pts_info(st, 33, 1, ea->sample_rate);\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_id = ea->audio_codec;\n        st->codec->codec_tag = 0;  \/* no tag *\/\n        st->codec->channels = ea->num_channels;\n        st->codec->sample_rate = ea->sample_rate;\n        st->codec->bits_per_coded_sample = ea->bytes * 8;\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n            st->codec->bits_per_coded_sample \/ 4;\n        st->codec->block_align = st->codec->channels*st->codec->bits_per_coded_sample;\n        ea->audio_stream_index = st->index;\n        ea->audio_frame_counter = 0;\n    return 1;","idx":7050,"target":1}
{"code":"static void s390_msi_ctrl_write(void *opaque, hwaddr addr, uint64_t data,\n\n                                unsigned int size)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    uint32_t io_int_word;\n\n    uint32_t fid = data >> ZPCI_MSI_VEC_BITS;\n\n    uint32_t vec = data & ZPCI_MSI_VEC_MASK;\n\n    uint64_t ind_bit;\n\n    uint32_t sum_bit;\n\n    uint32_t e = 0;\n\n\n\n    DPRINTF(\"write_msix data 0x%\" PRIx64 \" fid %d vec 0x%x\\n\", data, fid, vec);\n\n\n\n    pbdev = s390_pci_find_dev_by_fid(fid);\n\n    if (!pbdev) {\n\n        e |= (vec << ERR_EVENT_MVN_OFFSET);\n\n        s390_pci_generate_error_event(ERR_EVENT_NOMSI, 0, fid, addr, e);\n\n        return;\n\n    }\n\n\n\n    if (pbdev->state != ZPCI_FS_ENABLED) {\n\n        return;\n\n    }\n\n\n\n    ind_bit = pbdev->routes.adapter.ind_offset;\n\n    sum_bit = pbdev->routes.adapter.summary_offset;\n\n\n\n    set_ind_atomic(pbdev->routes.adapter.ind_addr + (ind_bit + vec) \/ 8,\n\n                   0x80 >> ((ind_bit + vec) % 8));\n\n    if (!set_ind_atomic(pbdev->routes.adapter.summary_addr + sum_bit \/ 8,\n\n                                       0x80 >> (sum_bit % 8))) {\n\n        io_int_word = (pbdev->isc << 27) | IO_INT_WORD_AI;\n\n        s390_io_interrupt(0, 0, 0, io_int_word);\n\n    }\n\n}\n","idx":2226,"target":1}
{"code":"int net_init_tap(const NetClientOptions *opts, const char *name,\n                 NetClientState *peer)\n{\n    const NetdevTapOptions *tap;\n    int fd, vnet_hdr = 0, i = 0, queues;\n    \/* for the no-fd, no-helper case *\/\n    const char *script = NULL; \/* suppress wrong \"uninit'd use\" gcc warning *\/\n    const char *downscript = NULL;\n    const char *vhostfdname;\n    char ifname[128];\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_TAP);\n    tap = opts->tap;\n    queues = tap->has_queues ? tap->queues : 1;\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n    if (tap->has_fd) {\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n            tap->has_fds) {\n            error_report(\"ifname=, script=, downscript=, vnet_hdr=, \"\n                         \"helper=, queues=, and fds= are invalid with fd=\");\n        fd = monitor_handle_fd_param(cur_mon, tap->fd);\n        if (fd == -1) {\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n        if (net_init_tap_one(tap, peer, \"tap\", name, NULL,\n                             script, downscript,\n                             vhostfdname, vnet_hdr, fd)) {\n    } else if (tap->has_fds) {\n        char *fds[MAX_TAP_QUEUES];\n        char *vhost_fds[MAX_TAP_QUEUES];\n        int nfds, nvhosts;\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n            tap->has_fd) {\n            error_report(\"ifname=, script=, downscript=, vnet_hdr=, \"\n                         \"helper=, queues=, and fd= are invalid with fds=\");\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n        if (tap->has_vhostfds) {\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n            if (nfds != nvhosts) {\n                error_report(\"The number of fds passed does not match the \"\n                             \"number of vhostfds passed\");\n        for (i = 0; i < nfds; i++) {\n            fd = monitor_handle_fd_param(cur_mon, fds[i]);\n            if (fd == -1) {\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n            if (i == 0) {\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n                error_report(\"vnet_hdr not consistent across given tap fds\");\n            if (net_init_tap_one(tap, peer, \"tap\", name, ifname,\n                                 script, downscript,\n                                 tap->has_vhostfds ? vhost_fds[i] : NULL,\n                                 vnet_hdr, fd)) {\n    } else if (tap->has_helper) {\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n            tap->has_vnet_hdr || tap->has_queues || tap->has_fds) {\n            error_report(\"ifname=, script=, downscript=, and vnet_hdr= \"\n                         \"queues=, and fds= are invalid with helper=\");\n        fd = net_bridge_run_helper(tap->helper, DEFAULT_BRIDGE_INTERFACE);\n        if (fd == -1) {\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n        if (net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n                             script, downscript, vhostfdname,\n                             vnet_hdr, fd)) {\n    } else {\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n        downscript = tap->has_downscript ? tap->downscript :\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n        if (tap->has_ifname) {\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n        } else {\n            ifname[0] = '\\0';\n        for (i = 0; i < queues; i++) {\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n                              ifname, sizeof ifname, queues > 1);\n            if (fd == -1) {\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n                if (tap_fd_get_ifname(fd, ifname)) {\n                    error_report(\"Fail to get ifname\");\n            if (net_init_tap_one(tap, peer, \"tap\", name, ifname,\n                                 i >= 1 ? \"no\" : script,\n                                 i >= 1 ? \"no\" : downscript,\n                                 vhostfdname, vnet_hdr, fd)) {\n    return 0;","idx":12272,"target":1}
{"code":"process_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        \/* either this, or the server is printing bad messages,\n           or the caller passed in garbage *\/\n         ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto chpwfail;\n     }\n \n     ptr = req->data;\n\n    \/* verify length *\/\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request length was inconsistent\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     \/* verify version number *\/\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n         numresult = KRB5_KPASSWD_BAD_VERSION;\n         snprintf(strresult, sizeof(strresult),\n                  \"Request contained unknown protocol version number %d\", vno);\n        goto chpwfail;\n     }\n \n     \/* read, check ap-req length *\/\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     \/* verify ap_req *\/\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin\/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    \/* construct the ap-rep *\/\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    \/* decrypt the ChangePasswdData *\/\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    \/*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     *\/\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    \/* decode ChangePasswdData for setpw requests *\/\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    \/* for cpw, verify that this is an AS_REQ ticket *\/\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    \/* change the password *\/\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    \/* zap the password *\/\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    \/* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. *\/\n\n    if (cipher.length == 0) {\n        \/* clear out ap_rep now, so that it won't be inserted in the\n           reply *\/\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        \/* this is really icky.  but it's what all the other callers\n           to mk_error do. *\/\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    \/* construct the reply *\/\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    \/* length *\/\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    \/* version == 0x0001 big-endian *\/\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    \/* ap_rep length, big-endian *\/\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    \/* ap-rep data *\/\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    \/* krb-priv or krb-error *\/\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}\n","idx":179407,"target":1}
{"code":" static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n {\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n }\n","idx":180738,"target":1}
{"code":"static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)\n\n{\n\n    uint16_t data = addr;\n\n\n\n    memwrite(s->addr + OMAP_I2C_SA, &data, 2);\n\n    memread(s->addr + OMAP_I2C_SA, &data, 2);\n\n    g_assert_cmphex(data, ==, addr);\n\n}\n","idx":14943,"target":1}
{"code":"static int parse_picture_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n\n\n    if (buf_size <= 4)\n\n        return -1;\n\n    buf_size -= 4;\n\n\n\n    \/* skip 3 unknown bytes: Object ID (2 bytes), Version Number *\/\n\n    buf += 3;\n\n\n\n    \/* Read the Sequence Description to determine if start of RLE data or appended to previous RLE *\/\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        \/* Additional RLE data *\/\n\n        if (buf_size > ctx->picture.rle_remaining_len)\n\n            return -1;\n\n\n\n        memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);\n\n        ctx->picture.rle_data_len += buf_size;\n\n        ctx->picture.rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return -1;\n\n    buf_size -= 7;\n\n\n\n    \/* Decode rle bitmap length, stored size includes width\/height data *\/\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    \/* Get bitmap dimensions from data *\/\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    \/* Make sure the bitmap is not too large *\/\n\n    if (avctx->width < width || avctx->height < height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->picture.w = width;\n\n    ctx->picture.h = height;\n\n\n\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!ctx->picture.rle)\n\n        return -1;\n\n\n\n    memcpy(ctx->picture.rle, buf, buf_size);\n\n    ctx->picture.rle_data_len = buf_size;\n\n    ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n","idx":40,"target":0}
{"code":"static inline void RENAME(yuvPlanartouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                           long width, long height,\n\n                                           long lumStride, long chromStride, long dstStride, long vertLumPerChroma)\n\n{\n\n    long y;\n\n    const x86_reg chromWidth= width>>1;\n\n    for (y=0; y<height; y++) {\n\n#if COMPILE_TEMPLATE_MMX\n\n        \/\/FIXME handle 2 lines at once (fewer prefetches, reuse some chroma, but very likely memory-limited anyway)\n\n        __asm__ volatile(\n\n            \"xor                %%\"REG_a\", %%\"REG_a\"    \\n\\t\"\n\n            \".p2align                   4               \\n\\t\"\n\n            \"1:                                         \\n\\t\"\n\n            PREFETCH\"   32(%1, %%\"REG_a\", 2)            \\n\\t\"\n\n            PREFETCH\"   32(%2, %%\"REG_a\")               \\n\\t\"\n\n            PREFETCH\"   32(%3, %%\"REG_a\")               \\n\\t\"\n\n            \"movq         (%2, %%\"REG_a\"), %%mm0        \\n\\t\" \/\/ U(0)\n\n            \"movq                   %%mm0, %%mm2        \\n\\t\" \/\/ U(0)\n\n            \"movq         (%3, %%\"REG_a\"), %%mm1        \\n\\t\" \/\/ V(0)\n\n            \"punpcklbw              %%mm1, %%mm0        \\n\\t\" \/\/ UVUV UVUV(0)\n\n            \"punpckhbw              %%mm1, %%mm2        \\n\\t\" \/\/ UVUV UVUV(8)\n\n\n\n            \"movq       (%1, %%\"REG_a\",2), %%mm3        \\n\\t\" \/\/ Y(0)\n\n            \"movq      8(%1, %%\"REG_a\",2), %%mm5        \\n\\t\" \/\/ Y(8)\n\n            \"movq                   %%mm0, %%mm4        \\n\\t\" \/\/ Y(0)\n\n            \"movq                   %%mm2, %%mm6        \\n\\t\" \/\/ Y(8)\n\n            \"punpcklbw              %%mm3, %%mm0        \\n\\t\" \/\/ YUYV YUYV(0)\n\n            \"punpckhbw              %%mm3, %%mm4        \\n\\t\" \/\/ YUYV YUYV(4)\n\n            \"punpcklbw              %%mm5, %%mm2        \\n\\t\" \/\/ YUYV YUYV(8)\n\n            \"punpckhbw              %%mm5, %%mm6        \\n\\t\" \/\/ YUYV YUYV(12)\n\n\n\n            MOVNTQ\"                 %%mm0,   (%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm4,  8(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm2, 16(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm6, 24(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n\n\n            \"add                       $8, %%\"REG_a\"    \\n\\t\"\n\n            \"cmp                       %4, %%\"REG_a\"    \\n\\t\"\n\n            \" jb                       1b               \\n\\t\"\n\n            ::\"r\"(dst), \"r\"(ysrc), \"r\"(usrc), \"r\"(vsrc), \"g\" (chromWidth)\n\n            : \"%\"REG_a\n\n        );\n\n#else\n\n\/\/FIXME adapt the Alpha ASM code from yv12->yuy2\n\n\n\n#if HAVE_FAST_64BIT\n\n        int i;\n\n        uint64_t *ldst = (uint64_t *) dst;\n\n        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n        for (i = 0; i < chromWidth; i += 2) {\n\n            uint64_t k, l;\n\n            k = uc[0] + (yc[0] << 8) +\n\n                (vc[0] << 16) + (yc[1] << 24);\n\n            l = uc[1] + (yc[2] << 8) +\n\n                (vc[1] << 16) + (yc[3] << 24);\n\n            *ldst++ = k + (l << 32);\n\n            yc += 4;\n\n            uc += 2;\n\n            vc += 2;\n\n        }\n\n\n\n#else\n\n        int i, *idst = (int32_t *) dst;\n\n        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n        for (i = 0; i < chromWidth; i++) {\n\n#if HAVE_BIGENDIAN\n\n            *idst++ = (uc[0] << 24)+ (yc[0] << 16) +\n\n                (vc[0] << 8) + (yc[1] << 0);\n\n#else\n\n            *idst++ = uc[0] + (yc[0] << 8) +\n\n               (vc[0] << 16) + (yc[1] << 24);\n\n#endif\n\n            yc += 2;\n\n            uc++;\n\n            vc++;\n\n        }\n\n#endif\n\n#endif\n\n        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1) {\n\n            usrc += chromStride;\n\n            vsrc += chromStride;\n\n        }\n\n        ysrc += lumStride;\n\n        dst += dstStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            :::\"memory\");\n\n#endif\n\n}\n","idx":98,"target":0}
{"code":"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n \tjas_image_cmpt_t *cmpt;\n \tsize_t size;\n \n \tcmpt = 0;\n \tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n \t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n \t  !jas_safe_intfast32_add(tly, height, 0)) {\n \t\tgoto error;\n \t}\n \n \tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n \t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) \/ 8;\n\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n \t\tgoto error;\n \t}\n \tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t\/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. *\/\n\t\/* Note: conversion of size - 1 to long can overflow *\/\n\tif (size > 0) {\n\t\tif (size - 1 > LONG_MAX) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}\n","idx":181865,"target":1}
{"code":"static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                                uint32_t token, uint32_t nargs,\n\n                                target_ulong args, uint32_t nret,\n\n                                target_ulong rets)\n\n{\n\n    uint32_t config_addr = rtas_ld(args, 0);\n\n    uint64_t buid = rtas_ldq(args, 1);\n\n    unsigned int func = rtas_ld(args, 3);\n\n    unsigned int req_num = rtas_ld(args, 4); \/* 0 == remove all *\/\n\n    unsigned int seq_num = rtas_ld(args, 5);\n\n    unsigned int ret_intr_type;\n\n    unsigned int irq, max_irqs = 0, num = 0;\n\n    sPAPRPHBState *phb = NULL;\n\n    PCIDevice *pdev = NULL;\n\n    spapr_pci_msi *msi;\n\n    int *config_addr_key;\n\n\n\n    switch (func) {\n\n    case RTAS_CHANGE_MSI_FN:\n\n    case RTAS_CHANGE_FN:\n\n        ret_intr_type = RTAS_TYPE_MSI;\n\n        break;\n\n    case RTAS_CHANGE_MSIX_FN:\n\n        ret_intr_type = RTAS_TYPE_MSIX;\n\n        break;\n\n    default:\n\n        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    \/* Fins sPAPRPHBState *\/\n\n    phb = spapr_pci_find_phb(spapr, buid);\n\n    if (phb) {\n\n        pdev = spapr_pci_find_dev(spapr, buid, config_addr);\n\n    }\n\n    if (!phb || !pdev) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    \/* Releasing MSIs *\/\n\n    if (!req_num) {\n\n        msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr);\n\n        if (!msi) {\n\n            trace_spapr_pci_msi(\"Releasing wrong config\", config_addr);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        xics_free(spapr->icp, msi->first_irq, msi->num);\n\n        if (msi_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, false, 0, num);\n\n        }\n\n        if (msix_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, true, 0, num);\n\n        }\n\n        g_hash_table_remove(phb->msi, &config_addr);\n\n\n\n        trace_spapr_pci_msi(\"Released MSIs\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        rtas_st(rets, 1, 0);\n\n        return;\n\n    }\n\n\n\n    \/* Enabling MSI *\/\n\n\n\n    \/* Check if the device supports as many IRQs as requested *\/\n\n    if (ret_intr_type == RTAS_TYPE_MSI) {\n\n        max_irqs = msi_nr_vectors_allocated(pdev);\n\n    } else if (ret_intr_type == RTAS_TYPE_MSIX) {\n\n        max_irqs = pdev->msix_entries_nr;\n\n    }\n\n    if (!max_irqs) {\n\n        error_report(\"Requested interrupt type %d is not enabled for device %x\",\n\n                     ret_intr_type, config_addr);\n\n        rtas_st(rets, 0, -1); \/* Hardware error *\/\n\n        return;\n\n    }\n\n    \/* Correct the number if the guest asked for too many *\/\n\n    if (req_num > max_irqs) {\n\n        trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);\n\n        req_num = max_irqs;\n\n        irq = 0; \/* to avoid misleading trace *\/\n\n        goto out;\n\n    }\n\n\n\n    \/* Allocate MSIs *\/\n\n    irq = xics_alloc_block(spapr->icp, 0, req_num, false,\n\n                           ret_intr_type == RTAS_TYPE_MSI);\n\n    if (!irq) {\n\n        error_report(\"Cannot allocate MSIs for device %x\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    \/* Setup MSI\/MSIX vectors in the device (via cfgspace or MSIX BAR) *\/\n\n    spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX,\n\n                     irq, req_num);\n\n\n\n    \/* Add MSI device to cache *\/\n\n    msi = g_new(spapr_pci_msi, 1);\n\n    msi->first_irq = irq;\n\n    msi->num = req_num;\n\n    config_addr_key = g_new(int, 1);\n\n    *config_addr_key = config_addr;\n\n    g_hash_table_insert(phb->msi, config_addr_key, msi);\n\n\n\nout:\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, req_num);\n\n    rtas_st(rets, 2, ++seq_num);\n\n    if (nret > 3) {\n\n        rtas_st(rets, 3, ret_intr_type);\n\n    }\n\n\n\n    trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq);\n\n}\n","idx":62,"target":0}
{"code":"static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n {\n \tsize_t n;\n \tuint32_t types = up->types;\n\n\tp->types = types;\n \tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n \t\tuintptr_t a = up->vals[n * 2];\n \t\tsize_t b = up->vals[n * 2 + 1];\n \n \t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n \t\t\tp->u[n].mem.mobj = &mobj_virt;\n \t\t\tp->u[n].mem.offs = a;\n \t\t\tp->u[n].mem.size = b;\n \t\t\tbreak;\n \t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n \t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n \t\t\tbreak;\n \t\t}\n \t}\n }\n","idx":182643,"target":1}
{"code":" nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (config != NULL, FALSE);\n\n\t\/* Addresses *\/\n\tnm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);\n\n\t\/* Routes *\/\n\t{\n\t\tint count = nm_ip4_config_get_num_routes (config);\n\t\tGArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);\n\t\tconst NMPlatformIP4Route *route;\n\t\tgboolean success;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\troute = nm_ip4_config_get_route (config, i);\n\n\t\t\t\/* Don't add the route if it's more specific than one of the subnets\n\t\t\t * the device already has an IP address on.\n\t\t\t *\/\n\t\t\tif (   route->gateway == 0\n\t\t\t    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))\n\t\t\t\tcontinue;\n\n\t\t\tg_array_append_vals (routes, route, 1);\n\t\t}\n\n\t\tsuccess = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);\n\t\tg_array_unref (routes);\n \t\t\treturn FALSE;\n \t}\n \n\t\/* MTU *\/\n\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n\t\tnm_platform_link_set_mtu (ifindex, mtu);\n \treturn TRUE;\n }\n","idx":177987,"target":1}
{"code":"devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,\n    int *eofp, caller_context_t *ct_unused, int flags_unused)\n{\n\tstruct sdev_node *sdvp = VTOSDEV(dvp);\n\tchar *ptr;\n\n\tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,\n\t    sdvp->sdev_name));\n\n\tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {\n\t\tstruct vnode *vp;\n\n\t\trw_exit(&sdvp->sdev_contents);\n\t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tif (uiop->uio_offset == 0)\n\t\tdevzvol_prunedir(sdvp);\n\tptr = sdvp->sdev_path + strlen(ZVOL_DIR);\n\tif ((strcmp(ptr, \"\/dsk\") == 0) || (strcmp(ptr, \"\/rdsk\") == 0)) {\n\t\trw_exit(&sdvp->sdev_contents);\n\t\tdevzvol_create_pool_dirs(dvp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n \t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n \t}\n \n\tptr = strchr(ptr + 1, '\/') + 1;\n \trw_exit(&sdvp->sdev_contents);\n \tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);\n \trw_enter(&sdvp->sdev_contents, RW_READER);\n\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n}\n","idx":179957,"target":1}
{"code":"static TCGv gen_lea_indexed(CPUM68KState *env, DisasContext *s, TCGv base)\n{\n    uint32_t offset;\n    uint16_t ext;\n    TCGv add;\n    TCGv tmp;\n    uint32_t bd, od;\n    offset = s->pc;\n    ext = cpu_lduw_code(env, s->pc);\n    s->pc += 2;\n    if ((ext & 0x800) == 0 && !m68k_feature(s->env, M68K_FEATURE_WORD_INDEX))\n        return NULL_QREG;\n    if (ext & 0x100) {\n        \/* full extension word format *\/\n        if (!m68k_feature(s->env, M68K_FEATURE_EXT_FULL))\n            return NULL_QREG;\n        if ((ext & 0x30) > 0x10) {\n            \/* base displacement *\/\n            if ((ext & 0x30) == 0x20) {\n                bd = (int16_t)cpu_lduw_code(env, s->pc);\n                s->pc += 2;\n            } else {\n                bd = read_im32(env, s);\n        } else {\n            bd = 0;\n        tmp = tcg_temp_new();\n        if ((ext & 0x44) == 0) {\n            \/* pre-index *\/\n            add = gen_addr_index(ext, tmp);\n        } else {\n            add = NULL_QREG;\n        if ((ext & 0x80) == 0) {\n            \/* base not suppressed *\/\n            if (IS_NULL_QREG(base)) {\n                base = tcg_const_i32(offset + bd);\n                bd = 0;\n            if (!IS_NULL_QREG(add)) {\n                tcg_gen_add_i32(tmp, add, base);\n                add = tmp;\n            } else {\n                add = base;\n        if (!IS_NULL_QREG(add)) {\n            if (bd != 0) {\n                tcg_gen_addi_i32(tmp, add, bd);\n                add = tmp;\n        } else {\n            add = tcg_const_i32(bd);\n        if ((ext & 3) != 0) {\n            \/* memory indirect *\/\n            base = gen_load(s, OS_LONG, add, 0);\n            if ((ext & 0x44) == 4) {\n                add = gen_addr_index(ext, tmp);\n                tcg_gen_add_i32(tmp, add, base);\n                add = tmp;\n            } else {\n                add = base;\n            if ((ext & 3) > 1) {\n                \/* outer displacement *\/\n                if ((ext & 3) == 2) {\n                    od = (int16_t)cpu_lduw_code(env, s->pc);\n                    s->pc += 2;\n                } else {\n                    od = read_im32(env, s);\n            } else {\n                od = 0;\n            if (od != 0) {\n                tcg_gen_addi_i32(tmp, add, od);\n                add = tmp;\n    } else {\n        \/* brief extension word format *\/\n        tmp = tcg_temp_new();\n        add = gen_addr_index(ext, tmp);\n        if (!IS_NULL_QREG(base)) {\n            tcg_gen_add_i32(tmp, add, base);\n            if ((int8_t)ext)\n                tcg_gen_addi_i32(tmp, tmp, (int8_t)ext);\n        } else {\n            tcg_gen_addi_i32(tmp, add, offset + (int8_t)ext);\n        add = tmp;\n    return add;","idx":20451,"target":1}
{"code":"static int find_allocation(BlockDriverState *bs, off_t start,\n\n                           off_t *data, off_t *hole)\n\n{\n\n    BDRVGlusterState *s = bs->opaque;\n\n    off_t offs;\n\n\n\n    if (!s->supports_seek_data) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    \/*\n\n     * SEEK_DATA cases:\n\n     * D1. offs == start: start is in data\n\n     * D2. offs > start: start is in a hole, next data at offs\n\n     * D3. offs < 0, errno = ENXIO: either start is in a trailing hole\n\n     *                              or start is beyond EOF\n\n     *     If the latter happens, the file has been truncated behind\n\n     *     our back since we opened it.  All bets are off then.\n\n     *     Treating like a trailing hole is simplest.\n\n     * D4. offs < 0, errno != ENXIO: we learned nothing\n\n     *\/\n\n    offs = glfs_lseek(s->fd, start, SEEK_DATA);\n\n    if (offs < 0) {\n\n        return -errno;          \/* D3 or D4 *\/\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        \/* D2: in hole, next data at offs *\/\n\n        *hole = start;\n\n        *data = offs;\n\n        return 0;\n\n    }\n\n\n\n    \/* D1: in data, end not yet known *\/\n\n\n\n    \/*\n\n     * SEEK_HOLE cases:\n\n     * H1. offs == start: start is in a hole\n\n     *     If this happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H2. offs > start: either start is in data, next hole at offs,\n\n     *                   or start is in trailing hole, EOF at offs\n\n     *     Linux treats trailing holes like any other hole: offs ==\n\n     *     start.  Solaris seeks to EOF instead: offs > start (blech).\n\n     *     If that happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H3. offs < 0, errno = ENXIO: start is beyond EOF\n\n     *     If this happens, the file has been truncated behind our\n\n     *     back since we opened it.  Treat it like a trailing hole.\n\n     * H4. offs < 0, errno != ENXIO: we learned nothing\n\n     *     Pretend we know nothing at all, i.e. \"forget\" about D1.\n\n     *\/\n\n    offs = glfs_lseek(s->fd, start, SEEK_HOLE);\n\n    if (offs < 0) {\n\n        return -errno;          \/* D1 and (H3 or H4) *\/\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        \/*\n\n         * D1 and H2: either in data, next hole at offs, or it was in\n\n         * data but is now in a trailing hole.  In the latter case,\n\n         * all bets are off.  Treating it as if it there was data all\n\n         * the way to EOF is safe, so simply do that.\n\n         *\/\n\n        *data = start;\n\n        *hole = offs;\n\n        return 0;\n\n    }\n\n\n\n    \/* D1 and H1 *\/\n\n    return -EBUSY;\n\n}\n","idx":46,"target":0}
{"code":"static gboolean register_signal_handlers(void)\n\n{\n\n    struct sigaction sigact, sigact_chld;\n\n    int ret;\n\n\n\n    memset(&sigact, 0, sizeof(struct sigaction));\n\n    sigact.sa_handler = quit_handler;\n\n\n\n    ret = sigaction(SIGINT, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n    ret = sigaction(SIGTERM, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n\n\n    memset(&sigact_chld, 0, sizeof(struct sigaction));\n\n    sigact_chld.sa_handler = child_handler;\n\n    sigact_chld.sa_flags = SA_NOCLDSTOP;\n\n    ret = sigaction(SIGCHLD, &sigact_chld, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n    }\n\n\n\n    return true;\n\n}\n","idx":4015,"target":1}
{"code":" static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n {\n        xml_parser *parser = (xml_parser *)rsrc->ptr;\n        if (parser->parser) {\n                XML_ParserFree(parser->parser);\n        }\n\tif (parser->ltags) {\n\t\tint inx;\n\t\tfor (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)\n\t\t\tefree(parser->ltags[ inx ]);\n\t\tefree(parser->ltags);\n\t}\n\tif (parser->startElementHandler) {\n\t\tzval_ptr_dtor(&parser->startElementHandler);\n\t}\n\tif (parser->endElementHandler) {\n\t\tzval_ptr_dtor(&parser->endElementHandler);\n\t}\n\tif (parser->characterDataHandler) {\n\t\tzval_ptr_dtor(&parser->characterDataHandler);\n\t}\n\tif (parser->processingInstructionHandler) {\n\t\tzval_ptr_dtor(&parser->processingInstructionHandler);\n\t}\n\tif (parser->defaultHandler) {\n\t\tzval_ptr_dtor(&parser->defaultHandler);\n\t}\n\tif (parser->unparsedEntityDeclHandler) {\n\t\tzval_ptr_dtor(&parser->unparsedEntityDeclHandler);\n\t}\n\tif (parser->notationDeclHandler) {\n\t\tzval_ptr_dtor(&parser->notationDeclHandler);\n\t}\n\tif (parser->externalEntityRefHandler) {\n\t\tzval_ptr_dtor(&parser->externalEntityRefHandler);\n\t}\n\tif (parser->unknownEncodingHandler) {\n\t\tzval_ptr_dtor(&parser->unknownEncodingHandler);\n\t}\n\tif (parser->startNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->startNamespaceDeclHandler);\n\t}\n\tif (parser->endNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->endNamespaceDeclHandler);\n\t}\n\tif (parser->baseURI) {\n\t\tefree(parser->baseURI);\n\t}\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n\n\tefree(parser);\n}\n","idx":178219,"target":1}
{"code":"static void gen_cp0 (CPUState *env, DisasContext *ctx, uint32_t opc, int rt, int rd)\n\n{\n\n    const char *opn = \"ldst\";\n\n\n\n    switch (opc) {\n\n    case OPC_MFC0:\n\n        if (rt == 0) {\n\n            \/* Treat as NOP *\/\n\n            return;\n\n        }\n\n        gen_mfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"mfc0\";\n\n        break;\n\n    case OPC_MTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_mtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"mtc0\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case OPC_DMFC0:\n\n        if (rt == 0) {\n\n            \/* Treat as NOP *\/\n\n            return;\n\n        }\n\n        gen_dmfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"dmfc0\";\n\n        break;\n\n    case OPC_DMTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_dmtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"dmtc0\";\n\n        break;\n\n#endif\n\n    case OPC_TLBWI:\n\n        opn = \"tlbwi\";\n\n        if (!env->do_tlbwi)\n\n            goto die;\n\n        gen_op_tlbwi();\n\n        break;\n\n    case OPC_TLBWR:\n\n        opn = \"tlbwr\";\n\n        if (!env->do_tlbwr)\n\n            goto die;\n\n        gen_op_tlbwr();\n\n        break;\n\n    case OPC_TLBP:\n\n        opn = \"tlbp\";\n\n        if (!env->do_tlbp)\n\n            goto die;\n\n        gen_op_tlbp();\n\n        break;\n\n    case OPC_TLBR:\n\n        opn = \"tlbr\";\n\n        if (!env->do_tlbr)\n\n            goto die;\n\n        gen_op_tlbr();\n\n        break;\n\n    case OPC_ERET:\n\n        opn = \"eret\";\n\n        save_cpu_state(ctx, 0);\n\n        gen_op_eret();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    case OPC_DERET:\n\n        opn = \"deret\";\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            MIPS_INVAL(opn);\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            save_cpu_state(ctx, 0);\n\n            gen_op_deret();\n\n            ctx->bstate = BS_EXCP;\n\n        }\n\n        break;\n\n    case OPC_WAIT:\n\n        opn = \"wait\";\n\n        \/* If we get an exception, we want to restart at next instruction *\/\n\n        ctx->pc += 4;\n\n        save_cpu_state(ctx, 1);\n\n        ctx->pc -= 4;\n\n        gen_op_wait();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    default:\n\n die:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    MIPS_DEBUG(\"%s %s %d\", opn, regnames[rt], rd);\n\n}\n","idx":75,"target":0}
{"code":"static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n \t\t\t       const struct in6_addr *dst,\n \t\t\t       const struct in6_addr *src)\n {\n \tu32 hash, id;\n \n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n \n \t\/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n \t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t *\/\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}\n","idx":182889,"target":1}
{"code":"void Document::finishedParsing()\n{\n    ASSERT(!scriptableDocumentParser() || !m_parser->isParsing());\n    ASSERT(!scriptableDocumentParser() || m_readyState != Loading);\n    setParsingState(InDOMContentLoaded);\n\n    if (!m_documentTiming.domContentLoadedEventStart())\n        m_documentTiming.setDomContentLoadedEventStart(monotonicallyIncreasingTime());\n    dispatchEvent(Event::createBubble(EventTypeNames::DOMContentLoaded));\n    if (!m_documentTiming.domContentLoadedEventEnd())\n        m_documentTiming.setDomContentLoadedEventEnd(monotonicallyIncreasingTime());\n    setParsingState(FinishedParsing);\n\n    RefPtrWillBeRawPtr<Document> protect(this);\n\n    Microtask::performCheckpoint();\n \n     if (RefPtrWillBeRawPtr<LocalFrame> frame = this->frame()) {\n        const bool mainResourceWasAlreadyRequested = frame->loader().stateMachine()->committedFirstRealDocumentLoad();\n\n        if (mainResourceWasAlreadyRequested)\n            updateLayoutTreeIfNeeded();\n\n        frame->loader().finishedParsing();\n\n        TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"MarkDOMContent\", TRACE_EVENT_SCOPE_THREAD, \"data\", InspectorMarkLoadEvent::data(frame.get()));\n        InspectorInstrumentation::domContentLoadedEventFired(frame.get());\n    }\n\n    m_elementDataCacheClearTimer.startOneShot(10, FROM_HERE);\n\n    m_fetcher->clearPreloads();\n}\n","idx":185822,"target":1}
{"code":"static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\n\tspin_lock_irqsave(&m->lock, flags);\n\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n \n \tspin_unlock_irqrestore(&m->lock, flags);\n \n \treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n }\n","idx":178896,"target":1}
{"code":"htmlCheckEncodingDirect(htmlParserCtxtPtr ctxt, const xmlChar *encoding) {\n\n    if ((ctxt == NULL) || (encoding == NULL) ||\n        (ctxt->options & HTML_PARSE_IGNORE_ENC))\n\treturn;\n\n    \/* do not change encoding *\/\n    if (ctxt->input->encoding != NULL)\n        return;\n\n    if (encoding != NULL) {\n\txmlCharEncoding enc;\n\txmlCharEncodingHandlerPtr handler;\n\n\twhile ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n\n\tif (ctxt->input->encoding != NULL)\n\t    xmlFree((xmlChar *) ctxt->input->encoding);\n\tctxt->input->encoding = xmlStrdup(encoding);\n\n\tenc = xmlParseCharEncoding((const char *) encoding);\n\t\/*\n\t * registered set of known encodings\n\t *\/\n\tif (enc != XML_CHAR_ENCODING_ERROR) {\n\t    if (((enc == XML_CHAR_ENCODING_UTF16LE) ||\n\t         (enc == XML_CHAR_ENCODING_UTF16BE) ||\n\t\t (enc == XML_CHAR_ENCODING_UCS4LE) ||\n\t\t (enc == XML_CHAR_ENCODING_UCS4BE)) &&\n\t\t(ctxt->input->buf != NULL) &&\n\t\t(ctxt->input->buf->encoder == NULL)) {\n\t\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t             \"htmlCheckEncoding: wrong encoding meta\\n\",\n\t\t\t     NULL, NULL);\n\t    } else {\n\t\txmlSwitchEncoding(ctxt, enc);\n\t    }\n\t    ctxt->charset = XML_CHAR_ENCODING_UTF8;\n\t} else {\n\t    \/*\n\t     * fallback for unknown encodings\n\t     *\/\n\t    handler = xmlFindCharEncodingHandler((const char *) encoding);\n\t    if (handler != NULL) {\n\t\txmlSwitchToEncoding(ctxt, handler);\n\t\tctxt->charset = XML_CHAR_ENCODING_UTF8;\n\t    } else {\n\t\thtmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n\t\t             \"htmlCheckEncoding: unknown encoding %s\\n\",\n\t\t\t     encoding, NULL);\n\t    }\n\t}\n\n\tif ((ctxt->input->buf != NULL) &&\n\t    (ctxt->input->buf->encoder != NULL) &&\n\t    (ctxt->input->buf->raw != NULL) &&\n\t    (ctxt->input->buf->buffer != NULL)) {\n\t    int nbchars;\n\t    int processed;\n\n\t    \/*\n\t     * convert as much as possible to the parser reading buffer.\n\t     *\/\n \t    processed = ctxt->input->cur - ctxt->input->base;\n \t    xmlBufShrink(ctxt->input->buf->buffer, processed);\n \t    nbchars = xmlCharEncInput(ctxt->input->buf, 1);\n \t    if (nbchars < 0) {\n \t\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n \t\t             \"htmlCheckEncoding: encoder error\\n\",\n \t\t\t     NULL, NULL);\n \t    }\n            xmlBufResetInput(ctxt->input->buf->buffer, ctxt->input);\n \t}\n     }\n }\n","idx":186995,"target":1}
{"code":"void ppc40x_chip_reset (CPUState *env)\n\n{\n\n    target_ulong dbsr;\n\n\n\n    printf(\"Reset PowerPC chip\\n\");\n\n    cpu_ppc_reset(env);\n\n    \/* XXX: TODO reset all internal peripherals *\/\n\n    dbsr = env->spr[SPR_40x_DBSR];\n\n    dbsr &= ~0x00000300;\n\n    dbsr |= 0x00000200;\n\n    env->spr[SPR_40x_DBSR] = dbsr;\n\n    cpu_loop_exit();\n\n}\n","idx":12057,"target":1}
{"code":"static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n","idx":17554,"target":1}
{"code":"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n","idx":70,"target":0}
{"code":"static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band,\n\n                          IVITile *tile, AVCodecContext *avctx)\n\n{\n\n    int         x, y, mv_x, mv_y, mv_delta, offs, mb_offset,\n\n                mv_scale, blks_per_mb;\n\n    IVIMbInfo   *mb, *ref_mb;\n\n    int         row_offset = band->mb_size * band->pitch;\n\n\n\n    mb     = tile->mbs;\n\n    ref_mb = tile->ref_mbs;\n\n    offs   = tile->ypos * band->pitch + tile->xpos;\n\n\n\n    \/* scale factor for motion vectors *\/\n\n    mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3);\n\n    mv_x = mv_y = 0;\n\n\n\n    for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) {\n\n        mb_offset = offs;\n\n\n\n        for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) {\n\n            mb->xpos     = x;\n\n            mb->ypos     = y;\n\n            mb->buf_offs = mb_offset;\n\n\n\n            if (get_bits1(&ctx->gb)) {\n\n                if (ctx->frame_type == FRAMETYPE_INTRA) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Empty macroblock in an INTRA picture!\\n\");\n\n                    return -1;\n\n                }\n\n                mb->type = 1; \/* empty macroblocks are always INTER *\/\n\n                mb->cbp  = 0; \/* all blocks are empty *\/\n\n\n\n                mb->q_delta = 0;\n\n                if (!band->plane && !band->band_num && (ctx->frame_flags & 8)) {\n\n                    mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n\n                                           IVI_VLC_BITS, 1);\n\n                    mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n\n                }\n\n\n\n                mb->mv_x = mb->mv_y = 0; \/* no motion vector coded *\/\n\n                if (band->inherit_mv){\n\n                    \/* motion vector inheritance *\/\n\n                    if (mv_scale) {\n\n                        mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n\n                        mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n\n                    } else {\n\n                        mb->mv_x = ref_mb->mv_x;\n\n                        mb->mv_y = ref_mb->mv_y;\n\n                    }\n\n                }\n\n            } else {\n\n                if (band->inherit_mv) {\n\n                    mb->type = ref_mb->type; \/* copy mb_type from corresponding reference mb *\/\n\n                } else if (ctx->frame_type == FRAMETYPE_INTRA) {\n\n                    mb->type = 0; \/* mb_type is always INTRA for intra-frames *\/\n\n                } else {\n\n                    mb->type = get_bits1(&ctx->gb);\n\n                }\n\n\n\n                blks_per_mb = band->mb_size != band->blk_size ? 4 : 1;\n\n                mb->cbp = get_bits(&ctx->gb, blks_per_mb);\n\n\n\n                mb->q_delta = 0;\n\n                if (band->qdelta_present) {\n\n                    if (band->inherit_qdelta) {\n\n                        if (ref_mb) mb->q_delta = ref_mb->q_delta;\n\n                    } else if (mb->cbp || (!band->plane && !band->band_num &&\n\n                                           (ctx->frame_flags & 8))) {\n\n                        mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n\n                                               IVI_VLC_BITS, 1);\n\n                        mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n\n                    }\n\n                }\n\n\n\n                if (!mb->type) {\n\n                    mb->mv_x = mb->mv_y = 0; \/* there is no motion vector in intra-macroblocks *\/\n\n                } else {\n\n                    if (band->inherit_mv){\n\n                        \/* motion vector inheritance *\/\n\n                        if (mv_scale) {\n\n                            mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n\n                            mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n\n                        } else {\n\n                            mb->mv_x = ref_mb->mv_x;\n\n                            mb->mv_y = ref_mb->mv_y;\n\n                        }\n\n                    } else {\n\n                        \/* decode motion vector deltas *\/\n\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n\n                                            IVI_VLC_BITS, 1);\n\n                        mv_y += IVI_TOSIGNED(mv_delta);\n\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n\n                                            IVI_VLC_BITS, 1);\n\n                        mv_x += IVI_TOSIGNED(mv_delta);\n\n                        mb->mv_x = mv_x;\n\n                        mb->mv_y = mv_y;\n\n                    }\n\n                }\n\n            }\n\n\n\n            mb++;\n\n            if (ref_mb)\n\n                ref_mb++;\n\n            mb_offset += band->mb_size;\n\n        }\n\n\n\n        offs += row_offset;\n\n    }\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return 0;\n\n}\n","idx":8708,"target":1}
{"code":"av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)\n\n{\n\n#if HAVE_ALTIVEC\n\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n\n        return;\n\n\n\n    fdsp->vector_fmul = ff_vector_fmul_altivec;\n\n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;\n\n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;\n\n\n\n    if (!bit_exact) {\n\n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;\n\n    }\n\n#endif\n\n}\n","idx":29,"target":0}
{"code":"static void init_excp_620 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;\n\n    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;\n\n    \/* Hardware reset vector *\/\n\n    env->hreset_vector = 0x0000000000000100ULL; \/* ? *\/\n\n#endif\n\n}\n","idx":3547,"target":1}
{"code":"int av_packet_ref(AVPacket *dst, AVPacket *src)\n\n{\n\n    int ret;\n\n\n\n    ret = av_packet_copy_props(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!src->buf) {\n\n        ret = packet_alloc(&dst->buf, src->size);\n\n        if (ret < 0)\n\n            goto fail;\n\n        memcpy(dst->buf->data, src->data, src->size);\n\n    } else\n\n        dst->buf = av_buffer_ref(src->buf);\n\n\n\n    dst->size = src->size;\n\n    dst->data = dst->buf->data;\n\n    return 0;\n\nfail:\n\n    av_packet_free_side_data(dst);\n\n    return ret;\n\n}\n","idx":28,"target":0}
{"code":"static int decode_header(EXRContext *s)\n\n{\n\n    int magic_number, version, i, flags, sar = 0;\n\n    int layer_match = 0;\n\n\n\n    s->current_channel_offset = 0;\n\n    s->xmin               = ~0;\n\n    s->xmax               = ~0;\n\n    s->ymin               = ~0;\n\n    s->ymax               = ~0;\n\n    s->xdelta             = ~0;\n\n    s->ydelta             = ~0;\n\n    s->channel_offsets[0] = -1;\n\n    s->channel_offsets[1] = -1;\n\n    s->channel_offsets[2] = -1;\n\n    s->channel_offsets[3] = -1;\n\n    s->pixel_type         = EXR_UNKNOWN;\n\n    s->compression        = EXR_UNKN;\n\n    s->nb_channels        = 0;\n\n    s->w                  = 0;\n\n    s->h                  = 0;\n\n    s->tile_attr.xSize    = -1;\n\n    s->tile_attr.ySize    = -1;\n\n    s->is_tile            = 0;\n\n    s->is_luma            = 0;\n\n\n\n    if (bytestream2_get_bytes_left(&s->gb) < 10) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_number = bytestream2_get_le32(&s->gb);\n\n    if (magic_number != 20000630) {\n\n        \/* As per documentation of OpenEXR, it is supposed to be\n\n         * int 20000630 little-endian *\/\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong magic number %d.\\n\", magic_number);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    version = bytestream2_get_byte(&s->gb);\n\n    if (version != 2) {\n\n        avpriv_report_missing_feature(s->avctx, \"Version %d\", version);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    flags = bytestream2_get_le24(&s->gb);\n\n\n\n    if (flags == 0x00)\n\n        s->is_tile = 0;\n\n    else if (flags & 0x02)\n\n        s->is_tile = 1;\n\n    else{\n\n        avpriv_report_missing_feature(s->avctx, \"flags %d\", flags);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    \/\/ Parse the header\n\n    while (bytestream2_get_bytes_left(&s->gb) > 0 && *s->gb.buffer) {\n\n        int var_size;\n\n        if ((var_size = check_header_variable(s, \"channels\",\n\n                                              \"chlist\", 38)) >= 0) {\n\n            GetByteContext ch_gb;\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            bytestream2_init(&ch_gb, s->gb.buffer, var_size);\n\n\n\n            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {\n\n                EXRChannel *channel;\n\n                enum ExrPixelType current_pixel_type;\n\n                int channel_index = -1;\n\n                int xsub, ysub;\n\n\n\n                if (strcmp(s->layer, \"\") != 0) {\n\n                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {\n\n                        layer_match = 1;\n\n                        av_log(s->avctx, AV_LOG_INFO,\n\n                               \"Channel match layer : %s.\\n\", ch_gb.buffer);\n\n                        ch_gb.buffer += strlen(s->layer);\n\n                        if (*ch_gb.buffer == '.')\n\n                            ch_gb.buffer++;         \/* skip dot if not given *\/\n\n                    } else {\n\n                        av_log(s->avctx, AV_LOG_INFO,\n\n                               \"Channel doesn't match layer : %s.\\n\", ch_gb.buffer);\n\n                    }\n\n                } else {\n\n                    layer_match = 1;\n\n                }\n\n\n\n                if (layer_match) { \/* only search channel if the layer match is valid *\/\n\n                    if (!strcmp(ch_gb.buffer, \"R\") ||\n\n                        !strcmp(ch_gb.buffer, \"X\") ||\n\n                        !strcmp(ch_gb.buffer, \"U\")) {\n\n                        channel_index = 0;\n\n                        s->is_luma = 0;\n\n                    } else if (!strcmp(ch_gb.buffer, \"G\") ||\n\n                               !strcmp(ch_gb.buffer, \"V\")) {\n\n                        channel_index = 1;\n\n                        s->is_luma = 0;\n\n                    } else if (!strcmp(ch_gb.buffer, \"Y\")) {\n\n                        channel_index = 1;\n\n                        s->is_luma = 1;\n\n                    } else if (!strcmp(ch_gb.buffer, \"B\") ||\n\n                               !strcmp(ch_gb.buffer, \"Z\") ||\n\n                               !strcmp(ch_gb.buffer, \"W\")){\n\n                               channel_index = 2;\n\n                        s->is_luma = 0;\n\n                    } else if (!strcmp(ch_gb.buffer, \"A\")) {\n\n                        channel_index = 3;\n\n                    } else {\n\n                        av_log(s->avctx, AV_LOG_WARNING,\n\n                               \"Unsupported channel %.256s.\\n\", ch_gb.buffer);\n\n                    }\n\n                }\n\n\n\n                \/* skip until you get a 0 *\/\n\n                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&\n\n                       bytestream2_get_byte(&ch_gb))\n\n                    continue;\n\n\n\n                if (bytestream2_get_bytes_left(&ch_gb) < 4) {\n\n                    av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header.\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                current_pixel_type = bytestream2_get_le32(&ch_gb);\n\n                if (current_pixel_type >= EXR_UNKNOWN) {\n\n                    avpriv_report_missing_feature(s->avctx, \"Pixel type %d\",\n\n                                                  current_pixel_type);\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n\n\n                bytestream2_skip(&ch_gb, 4);\n\n                xsub = bytestream2_get_le32(&ch_gb);\n\n                ysub = bytestream2_get_le32(&ch_gb);\n\n\n\n                if (xsub != 1 || ysub != 1) {\n\n                    avpriv_report_missing_feature(s->avctx,\n\n                                                  \"Subsampling %dx%d\",\n\n                                                  xsub, ysub);\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n\n\n                if (s->channel_offsets[channel_index] == -1){\/* channel have not been previously assign *\/\n\n                    if (channel_index >= 0) {\n\n                        if (s->pixel_type != EXR_UNKNOWN &&\n\n                            s->pixel_type != current_pixel_type) {\n\n                            av_log(s->avctx, AV_LOG_ERROR,\n\n                                   \"RGB channels not of the same depth.\\n\");\n\n                            return AVERROR_INVALIDDATA;\n\n                        }\n\n                        s->pixel_type                     = current_pixel_type;\n\n                        s->channel_offsets[channel_index] = s->current_channel_offset;\n\n                    }\n\n                }\n\n\n\n                s->channels = av_realloc(s->channels,\n\n                                         ++s->nb_channels * sizeof(EXRChannel));\n\n                if (!s->channels)\n\n                    return AVERROR(ENOMEM);\n\n                channel             = &s->channels[s->nb_channels - 1];\n\n                channel->pixel_type = current_pixel_type;\n\n                channel->xsub       = xsub;\n\n                channel->ysub       = ysub;\n\n\n\n                s->current_channel_offset += 1 << current_pixel_type;\n\n            }\n\n\n\n            \/* Check if all channels are set with an offset or if the channels\n\n             * are causing an overflow  *\/\n\n            if (!s->is_luma){\/* if we expected to have at least 3 channels *\/\n\n                if (FFMIN3(s->channel_offsets[0],\n\n                           s->channel_offsets[1],\n\n                           s->channel_offsets[2]) < 0) {\n\n                    if (s->channel_offsets[0] < 0)\n\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing red channel.\\n\");\n\n                    if (s->channel_offsets[1] < 0)\n\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing green channel.\\n\");\n\n                    if (s->channel_offsets[2] < 0)\n\n                        av_log(s->avctx, AV_LOG_ERROR, \"Missing blue channel.\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n            }\n\n\n\n            \/\/ skip one last byte and update main gb\n\n            s->gb.buffer = ch_gb.buffer + 1;\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"dataWindow\", \"box2i\",\n\n                                                     31)) >= 0) {\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            s->xmin   = bytestream2_get_le32(&s->gb);\n\n            s->ymin   = bytestream2_get_le32(&s->gb);\n\n            s->xmax   = bytestream2_get_le32(&s->gb);\n\n            s->ymax   = bytestream2_get_le32(&s->gb);\n\n            s->xdelta = (s->xmax - s->xmin) + 1;\n\n            s->ydelta = (s->ymax - s->ymin) + 1;\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"displayWindow\",\n\n                                                     \"box2i\", 34)) >= 0) {\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            bytestream2_skip(&s->gb, 8);\n\n            s->w = bytestream2_get_le32(&s->gb) + 1;\n\n            s->h = bytestream2_get_le32(&s->gb) + 1;\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"lineOrder\",\n\n                                                     \"lineOrder\", 25)) >= 0) {\n\n            int line_order;\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            line_order = bytestream2_get_byte(&s->gb);\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"line order: %d.\\n\", line_order);\n\n            if (line_order > 2) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"Unknown line order.\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"pixelAspectRatio\",\n\n                                                     \"float\", 31)) >= 0) {\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            sar = bytestream2_get_le32(&s->gb);\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"compression\",\n\n                                                     \"compression\", 29)) >= 0) {\n\n            if (!var_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (s->compression == EXR_UNKN)\n\n                s->compression = bytestream2_get_byte(&s->gb);\n\n            else\n\n                av_log(s->avctx, AV_LOG_WARNING,\n\n                       \"Found more than one compression attribute.\\n\");\n\n\n\n            continue;\n\n        } else if ((var_size = check_header_variable(s, \"tiles\",\n\n                                                     \"tiledesc\", 22)) >= 0) {\n\n            char tileLevel;\n\n\n\n            if (!s->is_tile)\n\n                av_log(s->avctx, AV_LOG_WARNING,\n\n                       \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\");\n\n\n\n            s->tile_attr.xSize = bytestream2_get_le32(&s->gb);\n\n            s->tile_attr.ySize = bytestream2_get_le32(&s->gb);\n\n\n\n            tileLevel = bytestream2_get_byte(&s->gb);\n\n            s->tile_attr.level_mode = tileLevel & 0x0f;\n\n            s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;\n\n\n\n            if (s->tile_attr.level_mode >= EXR_TILE_LEVEL_UNKNOWN){\n\n                avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",\n\n                                              s->tile_attr.level_mode);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            if (s->tile_attr.level_round >= EXR_TILE_ROUND_UNKNOWN) {\n\n                avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",\n\n                                              s->tile_attr.level_round);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            continue;\n\n        }\n\n\n\n        \/\/ Check if there are enough bytes for a header\n\n        if (bytestream2_get_bytes_left(&s->gb) <= 9) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        \/\/ Process unknown variables\n\n        for (i = 0; i < 2; i++) \/\/ value_name and value_type\n\n            while (bytestream2_get_byte(&s->gb) != 0);\n\n\n\n        \/\/ Skip variable length\n\n        bytestream2_skip(&s->gb, bytestream2_get_le32(&s->gb));\n\n    }\n\n\n\n    ff_set_sar(s->avctx, av_d2q(av_int2float(sar), 255));\n\n\n\n    if (s->compression == EXR_UNKN) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->is_tile) {\n\n        if (s->tile_attr.xSize < 1 || s->tile_attr.ySize < 1) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    if (bytestream2_get_bytes_left(&s->gb) <= 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    \/\/ aaand we are done\n\n    bytestream2_skip(&s->gb, 1);\n\n    return 0;\n\n}\n","idx":26750,"target":1}
{"code":"void ff_celp_lp_synthesis_filterf(float *out, const float *filter_coeffs,\n                                  const float* in, int buffer_length,\n                                  int filter_length)\n{\n    int i,n;\n\n#if 0 \/\/ Unoptimized code path for improved readability\n    for (n = 0; n < buffer_length; n++) {\n        out[n] = in[n];\n        for (i = 1; i <= filter_length; i++)\n            out[n] -= filter_coeffs[i-1] * out[n-i];\n    }\n#else\n    float out0, out1, out2, out3;\n    float old_out0, old_out1, old_out2, old_out3;\n    float a,b,c;\n\n    a = filter_coeffs[0];\n    b = filter_coeffs[1];\n    c = filter_coeffs[2];\n    b -= filter_coeffs[0] * filter_coeffs[0];\n    c -= filter_coeffs[1] * filter_coeffs[0];\n    c -= filter_coeffs[0] * b;\n\n    old_out0 = out[-4];\n    old_out1 = out[-3];\n    old_out2 = out[-2];\n    old_out3 = out[-1];\n    for (n = 0; n <= buffer_length - 4; n+=4) {\n        float tmp0,tmp1,tmp2;\n        float val;\n\n        out0 = in[0];\n        out1 = in[1];\n        out2 = in[2];\n        out3 = in[3];\n\n        out0 -= filter_coeffs[2] * old_out1;\n        out1 -= filter_coeffs[2] * old_out2;\n        out2 -= filter_coeffs[2] * old_out3;\n\n        out0 -= filter_coeffs[1] * old_out2;\n        out1 -= filter_coeffs[1] * old_out3;\n\n        out0 -= filter_coeffs[0] * old_out3;\n\n        val = filter_coeffs[3];\n\n        out0 -= val * old_out0;\n        out1 -= val * old_out1;\n        out2 -= val * old_out2;\n        out3 -= val * old_out3;\n\n        for (i = 5; i <= filter_length; i += 2) {\n            old_out3 = out[-i];\n            val = filter_coeffs[i-1];\n\n            out0 -= val * old_out3;\n            out1 -= val * old_out0;\n            out2 -= val * old_out1;\n            out3 -= val * old_out2;\n\n            old_out2 = out[-i-1];\n\n            val = filter_coeffs[i];\n\n            out0 -= val * old_out2;\n            out1 -= val * old_out3;\n            out2 -= val * old_out0;\n            out3 -= val * old_out1;\n\n            FFSWAP(float, old_out0, old_out2);\n            old_out1 = old_out3;\n        }\n\n        tmp0 = out0;\n        tmp1 = out1;\n        tmp2 = out2;\n\n        out3 -= a * tmp2;\n        out2 -= a * tmp1;\n        out1 -= a * tmp0;\n\n        out3 -= b * tmp1;\n        out2 -= b * tmp0;\n\n        out3 -= c * tmp0;\n\n\n        out[0] = out0;\n        out[1] = out1;\n        out[2] = out2;\n        out[3] = out3;\n\n        old_out0 = out0;\n        old_out1 = out1;\n        old_out2 = out2;\n        old_out3 = out3;\n\n        out += 4;\n        in  += 4;\n    }\n\n    out -= n;\n    in -= n;\n    for (; n < buffer_length; n++) {\n        out[n] = in[n];\n        for (i = 1; i <= filter_length; i++)\n            out[n] -= filter_coeffs[i-1] * out[n-i];\n    }\n#endif\n}","idx":1292303,"target":1}
{"code":"static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n    static const uint8_t header_prefixhr[] = { 0x00, 0x00, 0x02, 0x80, 0x03 };\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth;\n\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5) && memcmp(buf, header_prefixhr, 5)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { \/* interlaced *\/\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: ctx->bit_depth = 8; break;\n    case 2: ctx->bit_depth = 10; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth;\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (ctx->bit_depth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n        ctx->pix_fmt = AV_PIX_FMT_YUV444P10;\n    } else if (ctx->bit_depth == 10) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    cid = AV_RB32(buf + 0x28);\n\n    if ((ret = dnxhd_init_vlc(ctx, cid)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    \/\/ make sure profile size constraints are respected\n    \/\/ DNx100 allows 1920->1440 and 1280->960 subsampling\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %d).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = buf[0x16d];\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n    if (ctx->mb_height > 68 ||\n        (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"mb height too big: %d\\n\", ctx->mb_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);\n        if (buf_size < ctx->mb_scan_index[i] + 0x280LL) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%d < %d).\\n\",\n                   buf_size, ctx->mb_scan_index[i] + 0x280);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}","idx":1294649,"target":1}
{"code":"static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt,\n                      uint8_t block_type, AVFormatContext *s)\n{\n    uint8_t * vidbuf_start = NULL;\n    int vidbuf_nbytes = 0;\n    int code;\n    int bytes_copied = 0;\n    int position, duration, npixels;\n    unsigned int vidbuf_capacity;\n    int ret = 0;\n    AVStream *st;\n\n    if (vid->video_index < 0) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        vid->video_index = st->index;\n        if (vid->audio_index < 0) {\n            av_log_ask_for_sample(s, \"No audio packet before first video \"\n                                  \"packet. Using default video time base.\\n\");\n        }\n        avpriv_set_pts_info(st, 64, 185, vid->sample_rate);\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codec->codec_id   = AV_CODEC_ID_BETHSOFTVID;\n        st->codec->width      = vid->width;\n        st->codec->height     = vid->height;\n    }\n    st      = s->streams[vid->video_index];\n    npixels = st->codec->width * st->codec->height;\n\n    vidbuf_start = av_malloc(vidbuf_capacity = BUFFER_PADDING_SIZE);\n    if(!vidbuf_start)\n        return AVERROR(ENOMEM);\n\n    \/\/ save the file position for the packet, include block type\n    position = avio_tell(pb) - 1;\n\n    vidbuf_start[vidbuf_nbytes++] = block_type;\n\n    \/\/ get the current packet duration\n    duration = vid->bethsoft_global_delay + avio_rl16(pb);\n\n    \/\/ set the y offset if it exists (decoder header data should be in data section)\n    if(block_type == VIDEO_YOFF_P_FRAME){\n        if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], 2) != 2) {\n            ret = AVERROR(EIO);\n            goto fail;\n        }\n        vidbuf_nbytes += 2;\n    }\n\n    do{\n        vidbuf_start = av_fast_realloc(vidbuf_start, &vidbuf_capacity, vidbuf_nbytes + BUFFER_PADDING_SIZE);\n        if(!vidbuf_start)\n            return AVERROR(ENOMEM);\n\n        code = avio_r8(pb);\n        vidbuf_start[vidbuf_nbytes++] = code;\n\n        if(code >= 0x80){ \/\/ rle sequence\n            if(block_type == VIDEO_I_FRAME)\n                vidbuf_start[vidbuf_nbytes++] = avio_r8(pb);\n        } else if(code){ \/\/ plain sequence\n            if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], code) != code) {\n                ret = AVERROR(EIO);\n                goto fail;\n            }\n            vidbuf_nbytes += code;\n        }\n        bytes_copied += code & 0x7F;\n        if(bytes_copied == npixels){ \/\/ sometimes no stop character is given, need to keep track of bytes copied\n            \/\/ may contain a 0 byte even if read all pixels\n            if(avio_r8(pb))\n                avio_seek(pb, -1, SEEK_CUR);\n            break;\n        }\n        if (bytes_copied > npixels) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    } while(code);\n\n    \/\/ copy data into packet\n    if ((ret = av_new_packet(pkt, vidbuf_nbytes)) < 0)\n        goto fail;\n    memcpy(pkt->data, vidbuf_start, vidbuf_nbytes);\n    av_free(vidbuf_start);\n\n    pkt->pos = position;\n    pkt->stream_index = vid->video_index;\n    pkt->duration = duration;\n    if (block_type == VIDEO_I_FRAME)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    \/* if there is a new palette available, add it to packet side data *\/\n    if (vid->palette) {\n        uint8_t *pdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n                                                 BVID_PALETTE_SIZE);\n        memcpy(pdata, vid->palette, BVID_PALETTE_SIZE);\n        av_freep(&vid->palette);\n    }\n\n    vid->nframes--;  \/\/ used to check if all the frames were read\n    return 0;\nfail:\n    av_free(vidbuf_start);\n    return ret;\n}","idx":1292945,"target":1}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    AVFilterContext *ctx = inlink->dst;\n    FrameRateContext *s = ctx->priv;\n    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);\n    int plane;\n\n    for (plane = 0; plane < 4; plane++) {\n        s->line_size[plane] = av_image_get_linesize(inlink->format, inlink->w,\n                                                    plane);\n    }\n\n    s->bitdepth = pix_desc->comp[0].depth;\n    s->vsub = pix_desc->log2_chroma_h;\n    s->interp_start = s->interp_start_param << (s->bitdepth - 8);\n    s->interp_end = s->interp_end_param << (s->bitdepth - 8);\n\n    s->sad = av_pixelutils_get_sad_fn(3, 3, 2, s); \/\/ 8x8 both sources aligned\n    if (!s->sad)\n        return AVERROR(EINVAL);\n\n    s->srce_time_base = inlink->time_base;\n\n    s->max = 1 << (s->bitdepth);\n    if (s->bitdepth == 8)\n        s->blend = blend_frames_c;\n    else\n        s->blend = blend_frames16_c;\n\n    return 0;\n}","idx":1291695,"target":1}
{"code":"static void blend_frame(AVFilterContext *ctx,\n                        AVFrame *top_buf,\n                        AVFrame *bottom_buf,\n                        AVFrame *dst_buf)\n{\n    BlendContext *b = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    FilterParams *param;\n    int plane;\n\n    for (plane = 0; dst_buf->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? b->hsub : 0;\n        int vsub = plane == 1 || plane == 2 ? b->vsub : 0;\n        int outw = dst_buf->width  >> hsub;\n        int outh = dst_buf->height >> vsub;\n        uint8_t *dst    = dst_buf->data[plane];\n        uint8_t *top    = top_buf->data[plane];\n        uint8_t *bottom = bottom_buf->data[plane];\n\n        param = &b->params[plane];\n        param->values[VAR_N]  = inlink->frame_count;\n        param->values[VAR_T]  = dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts * av_q2d(inlink->time_base);\n        param->values[VAR_W]  = outw;\n        param->values[VAR_H]  = outh;\n        param->values[VAR_SW] = outw \/ dst_buf->width;\n        param->values[VAR_SH] = outh \/ dst_buf->height;\n        param->blend(top, top_buf->linesize[plane],\n                     bottom, bottom_buf->linesize[plane],\n                     dst, dst_buf->linesize[plane], outw, outh, param);\n    }\n}","idx":1292326,"target":1}
{"code":"static int init_tile(Jpeg2000DecoderContext *s, int tileno)\n{\n    int compno;\n    int tilex = tileno % s->numXtiles;\n    int tiley = tileno \/ s->numXtiles;\n    Jpeg2000Tile *tile = s->tile + tileno;\n\n    if (!tile->comp)\n        return AVERROR(ENOMEM);\n\n    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;\n        int ret; \/\/ global bandno\n\n        comp->coord_o[0][0] = tile->coord[0][0];\n        comp->coord_o[0][1] = tile->coord[0][1];\n        comp->coord_o[1][0] = tile->coord[1][0];\n        comp->coord_o[1][1] = tile->coord[1][1];\n        if (compno) {\n            comp->coord_o[0][0] \/= s->cdx[compno];\n            comp->coord_o[0][1] \/= s->cdx[compno];\n            comp->coord_o[1][0] \/= s->cdy[compno];\n            comp->coord_o[1][1] \/= s->cdy[compno];\n        }\n\n        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);\n        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);\n        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);\n        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);\n\n        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,\n                                             s->cbps[compno], s->cdx[compno],\n                                             s->cdy[compno], s->avctx))\n            return ret;\n    }\n    return 0;\n}","idx":1295382,"target":1}
{"code":"int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type,\n                            uint8_t *data, size_t size)\n{\n    AVPacketSideData *sd, *tmp;\n    int i;\n\n    for (i = 0; i < st->nb_side_data; i++) {\n        sd = &st->side_data[i];\n\n        if (sd->type == type) {\n            av_freep(&sd->data);\n            sd->data = data;\n            sd->size = size;\n            return 0;\n        }\n    }\n\n    tmp = av_realloc_array(st->side_data, st->nb_side_data + 1, sizeof(*tmp));\n    if (!tmp) {\n        return AVERROR(ENOMEM);\n    }\n\n    st->side_data = tmp;\n    st->nb_side_data++;\n\n    sd = &st->side_data[st->nb_side_data - 1];\n    sd->type = type;\n    sd->data = data;\n    sd->size = size;\n\n    return 0;\n}","idx":1291528,"target":1}
{"code":"static inline void refill_32(BitstreamContext *bc)\n{\n    if (bc->ptr >= bc->buffer_end)\n        return;\n\n#ifdef BITSTREAM_READER_LE\n    bc->bits       = (uint64_t)AV_RL32(bc->ptr) << bc->bits_left | bc->bits;\n#else\n    bc->bits       = bc->bits | (uint64_t)AV_RB32(bc->ptr) << (32 - bc->bits_left);\n#endif\n    bc->ptr       += 4;\n    bc->bits_left += 32;\n}","idx":1295451,"target":1}
{"code":"SwsContext *sws_getContext(int srcW, int srcH, enum PixelFormat srcFormat, int dstW, int dstH, enum PixelFormat dstFormat, int flags,\n                           SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)\n{\n\n    SwsContext *c;\n    int i;\n    int usesVFilter, usesHFilter;\n    int unscaled, needsDither;\n    int srcRange, dstRange;\n    SwsFilter dummyFilter= {NULL, NULL, NULL, NULL};\n#if ARCH_X86\n    if (flags & SWS_CPU_CAPS_MMX)\n        __asm__ volatile(\"emms\\n\\t\"::: \"memory\");\n#endif\n\n#if !CONFIG_RUNTIME_CPUDETECT \/\/ensure that the flags match the compiled variant if cpudetect is off\n    flags &= ~(SWS_CPU_CAPS_MMX|SWS_CPU_CAPS_MMX2|SWS_CPU_CAPS_3DNOW|SWS_CPU_CAPS_ALTIVEC|SWS_CPU_CAPS_BFIN);\n#if   COMPILE_TEMPLATE_MMX2\n    flags |= SWS_CPU_CAPS_MMX|SWS_CPU_CAPS_MMX2;\n#elif COMPILE_TEMPLATE_AMD3DNOW\n    flags |= SWS_CPU_CAPS_MMX|SWS_CPU_CAPS_3DNOW;\n#elif COMPILE_TEMPLATE_MMX\n    flags |= SWS_CPU_CAPS_MMX;\n#elif COMPILE_TEMPLATE_ALTIVEC\n    flags |= SWS_CPU_CAPS_ALTIVEC;\n#elif ARCH_BFIN\n    flags |= SWS_CPU_CAPS_BFIN;\n#endif\n#endif \/* CONFIG_RUNTIME_CPUDETECT *\/\n    if (clip_table[512] != 255) globalInit();\n    if (!rgb15to16) sws_rgb2rgb_init(flags);\n\n    unscaled = (srcW == dstW && srcH == dstH);\n    needsDither= (isBGR(dstFormat) || isRGB(dstFormat))\n        && (fmt_depth(dstFormat))<24\n        && ((fmt_depth(dstFormat))<(fmt_depth(srcFormat)) || (!(isRGB(srcFormat) || isBGR(srcFormat))));\n\n    srcRange = handle_jpeg(&srcFormat);\n    dstRange = handle_jpeg(&dstFormat);\n\n    if (!isSupportedIn(srcFormat)) {\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: %s is not supported as input pixel format\\n\", sws_format_name(srcFormat));\n        return NULL;\n    }\n    if (!isSupportedOut(dstFormat)) {\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: %s is not supported as output pixel format\\n\", sws_format_name(dstFormat));\n        return NULL;\n    }\n\n    i= flags & ( SWS_POINT\n                |SWS_AREA\n                |SWS_BILINEAR\n                |SWS_FAST_BILINEAR\n                |SWS_BICUBIC\n                |SWS_X\n                |SWS_GAUSS\n                |SWS_LANCZOS\n                |SWS_SINC\n                |SWS_SPLINE\n                |SWS_BICUBLIN);\n    if(!i || (i & (i-1))) {\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: Exactly one scaler algorithm must be chosen\\n\");\n        return NULL;\n    }\n\n    \/* sanity check *\/\n    if (srcW<4 || srcH<1 || dstW<8 || dstH<1) { \/\/FIXME check if these are enough and try to lowwer them after fixing the relevant parts of the code\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: %dx%d -> %dx%d is invalid scaling dimension\\n\",\n               srcW, srcH, dstW, dstH);\n        return NULL;\n    }\n    if(srcW > VOFW || dstW > VOFW) {\n        av_log(NULL, AV_LOG_ERROR, \"swScaler: Compile-time maximum width is \"AV_STRINGIFY(VOFW)\" change VOF\/VOFW and recompile\\n\");\n        return NULL;\n    }\n\n    if (!dstFilter) dstFilter= &dummyFilter;\n    if (!srcFilter) srcFilter= &dummyFilter;\n\n    c= av_mallocz(sizeof(SwsContext));\n\n    c->av_class = &sws_context_class;\n    c->srcW= srcW;\n    c->srcH= srcH;\n    c->dstW= dstW;\n    c->dstH= dstH;\n    c->lumXInc= ((srcW<<16) + (dstW>>1))\/dstW;\n    c->lumYInc= ((srcH<<16) + (dstH>>1))\/dstH;\n    c->flags= flags;\n    c->dstFormat= dstFormat;\n    c->srcFormat= srcFormat;\n    c->vRounder= 4* 0x0001000100010001ULL;\n\n    usesHFilter= usesVFilter= 0;\n    if (dstFilter->lumV && dstFilter->lumV->length>1) usesVFilter=1;\n    if (dstFilter->lumH && dstFilter->lumH->length>1) usesHFilter=1;\n    if (dstFilter->chrV && dstFilter->chrV->length>1) usesVFilter=1;\n    if (dstFilter->chrH && dstFilter->chrH->length>1) usesHFilter=1;\n    if (srcFilter->lumV && srcFilter->lumV->length>1) usesVFilter=1;\n    if (srcFilter->lumH && srcFilter->lumH->length>1) usesHFilter=1;\n    if (srcFilter->chrV && srcFilter->chrV->length>1) usesVFilter=1;\n    if (srcFilter->chrH && srcFilter->chrH->length>1) usesHFilter=1;\n\n    getSubSampleFactors(&c->chrSrcHSubSample, &c->chrSrcVSubSample, srcFormat);\n    getSubSampleFactors(&c->chrDstHSubSample, &c->chrDstVSubSample, dstFormat);\n\n    \/\/ reuse chroma for 2 pixels RGB\/BGR unless user wants full chroma interpolation\n    if ((isBGR(dstFormat) || isRGB(dstFormat)) && !(flags&SWS_FULL_CHR_H_INT)) c->chrDstHSubSample=1;\n\n    \/\/ drop some chroma lines if the user wants it\n    c->vChrDrop= (flags&SWS_SRC_V_CHR_DROP_MASK)>>SWS_SRC_V_CHR_DROP_SHIFT;\n    c->chrSrcVSubSample+= c->vChrDrop;\n\n    \/\/ drop every other pixel for chroma calculation unless user wants full chroma\n    if ((isBGR(srcFormat) || isRGB(srcFormat)) && !(flags&SWS_FULL_CHR_H_INP)\n      && srcFormat!=PIX_FMT_RGB8      && srcFormat!=PIX_FMT_BGR8\n      && srcFormat!=PIX_FMT_RGB4      && srcFormat!=PIX_FMT_BGR4\n      && srcFormat!=PIX_FMT_RGB4_BYTE && srcFormat!=PIX_FMT_BGR4_BYTE\n      && ((dstW>>c->chrDstHSubSample) <= (srcW>>1) || (flags&(SWS_FAST_BILINEAR|SWS_POINT))))\n        c->chrSrcHSubSample=1;\n\n    if (param) {\n        c->param[0] = param[0];\n        c->param[1] = param[1];\n    } else {\n        c->param[0] =\n        c->param[1] = SWS_PARAM_DEFAULT;\n    }\n\n    \/\/ Note the -((-x)>>y) is so that we always round toward +inf.\n    c->chrSrcW= -((-srcW) >> c->chrSrcHSubSample);\n    c->chrSrcH= -((-srcH) >> c->chrSrcVSubSample);\n    c->chrDstW= -((-dstW) >> c->chrDstHSubSample);\n    c->chrDstH= -((-dstH) >> c->chrDstVSubSample);\n\n    sws_setColorspaceDetails(c, ff_yuv2rgb_coeffs[SWS_CS_DEFAULT], srcRange, ff_yuv2rgb_coeffs[SWS_CS_DEFAULT] \/* FIXME*\/, dstRange, 0, 1<<16, 1<<16);\n\n    \/* unscaled special cases *\/\n    if (unscaled && !usesHFilter && !usesVFilter && (srcRange == dstRange || isBGR(dstFormat) || isRGB(dstFormat))) {\n        \/* yv12_to_nv12 *\/\n        if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) && (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) {\n            c->swScale= PlanarToNV12Wrapper;\n        }\n        \/* yuv2bgr *\/\n        if ((srcFormat==PIX_FMT_YUV420P || srcFormat==PIX_FMT_YUV422P || srcFormat==PIX_FMT_YUVA420P) && (isBGR(dstFormat) || isRGB(dstFormat))\n            && !(flags & SWS_ACCURATE_RND) && !(dstH&1)) {\n            c->swScale= ff_yuv2rgb_get_func_ptr(c);\n        }\n\n        if (srcFormat==PIX_FMT_YUV410P && (dstFormat==PIX_FMT_YUV420P || dstFormat==PIX_FMT_YUVA420P) && !(flags & SWS_BITEXACT)) {\n            c->swScale= yvu9toyv12Wrapper;\n        }\n\n        \/* bgr24toYV12 *\/\n        if (srcFormat==PIX_FMT_BGR24 && (dstFormat==PIX_FMT_YUV420P || dstFormat==PIX_FMT_YUVA420P) && !(flags & SWS_ACCURATE_RND))\n            c->swScale= bgr24toyv12Wrapper;\n\n        \/* RGB\/BGR -> RGB\/BGR (no dither needed forms) *\/\n        if (  (isBGR(srcFormat) || isRGB(srcFormat))\n           && (isBGR(dstFormat) || isRGB(dstFormat))\n           && srcFormat != PIX_FMT_BGR8      && dstFormat != PIX_FMT_BGR8\n           && srcFormat != PIX_FMT_RGB8      && dstFormat != PIX_FMT_RGB8\n           && srcFormat != PIX_FMT_BGR4      && dstFormat != PIX_FMT_BGR4\n           && srcFormat != PIX_FMT_RGB4      && dstFormat != PIX_FMT_RGB4\n           && srcFormat != PIX_FMT_BGR4_BYTE && dstFormat != PIX_FMT_BGR4_BYTE\n           && srcFormat != PIX_FMT_RGB4_BYTE && dstFormat != PIX_FMT_RGB4_BYTE\n           && srcFormat != PIX_FMT_MONOBLACK && dstFormat != PIX_FMT_MONOBLACK\n           && srcFormat != PIX_FMT_MONOWHITE && dstFormat != PIX_FMT_MONOWHITE\n                                             && dstFormat != PIX_FMT_RGB32_1\n                                             && dstFormat != PIX_FMT_BGR32_1\n           && srcFormat != PIX_FMT_RGB48LE   && dstFormat != PIX_FMT_RGB48LE\n           && srcFormat != PIX_FMT_RGB48BE   && dstFormat != PIX_FMT_RGB48BE\n           && (!needsDither || (c->flags&(SWS_FAST_BILINEAR|SWS_POINT))))\n             c->swScale= rgb2rgbWrapper;\n\n        if ((usePal(srcFormat) && (\n                 dstFormat == PIX_FMT_RGB32   ||\n                 dstFormat == PIX_FMT_RGB32_1 ||\n                 dstFormat == PIX_FMT_RGB24   ||\n                 dstFormat == PIX_FMT_BGR32   ||\n                 dstFormat == PIX_FMT_BGR32_1 ||\n                 dstFormat == PIX_FMT_BGR24)))\n             c->swScale= pal2rgbWrapper;\n\n        if (srcFormat == PIX_FMT_YUV422P) {\n            if (dstFormat == PIX_FMT_YUYV422)\n                c->swScale= YUV422PToYuy2Wrapper;\n            else if (dstFormat == PIX_FMT_UYVY422)\n                c->swScale= YUV422PToUyvyWrapper;\n        }\n\n        \/* LQ converters if -sws 0 or -sws 4*\/\n        if (c->flags&(SWS_FAST_BILINEAR|SWS_POINT)) {\n            \/* yv12_to_yuy2 *\/\n            if (srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) {\n                if (dstFormat == PIX_FMT_YUYV422)\n                    c->swScale= PlanarToYuy2Wrapper;\n                else if (dstFormat == PIX_FMT_UYVY422)\n                    c->swScale= PlanarToUyvyWrapper;\n            }\n        }\n        if(srcFormat == PIX_FMT_YUYV422 && (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n            c->swScale= YUYV2YUV420Wrapper;\n        if(srcFormat == PIX_FMT_UYVY422 && (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n            c->swScale= UYVY2YUV420Wrapper;\n        if(srcFormat == PIX_FMT_YUYV422 && dstFormat == PIX_FMT_YUV422P)\n            c->swScale= YUYV2YUV422Wrapper;\n        if(srcFormat == PIX_FMT_UYVY422 && dstFormat == PIX_FMT_YUV422P)\n            c->swScale= UYVY2YUV422Wrapper;\n\n#ifdef COMPILE_ALTIVEC\n        if ((c->flags & SWS_CPU_CAPS_ALTIVEC) &&\n            !(c->flags & SWS_BITEXACT) &&\n            srcFormat == PIX_FMT_YUV420P) {\n          \/\/ unscaled YV12 -> packed YUV, we want speed\n          if (dstFormat == PIX_FMT_YUYV422)\n              c->swScale= yv12toyuy2_unscaled_altivec;\n          else if (dstFormat == PIX_FMT_UYVY422)\n              c->swScale= yv12touyvy_unscaled_altivec;\n        }\n#endif\n\n        \/* simple copy *\/\n        if (  srcFormat == dstFormat\n            || (srcFormat == PIX_FMT_YUVA420P && dstFormat == PIX_FMT_YUV420P)\n            || (srcFormat == PIX_FMT_YUV420P && dstFormat == PIX_FMT_YUVA420P)\n            || (isPlanarYUV(srcFormat) && isGray(dstFormat))\n            || (isPlanarYUV(dstFormat) && isGray(srcFormat))\n            || (isGray(dstFormat) && isGray(srcFormat))\n            || (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat)\n                && c->chrDstHSubSample == c->chrSrcHSubSample\n                && c->chrDstVSubSample == c->chrSrcVSubSample\n                && dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21\n                && srcFormat != PIX_FMT_NV12 && srcFormat != PIX_FMT_NV21))\n        {\n            if (isPacked(c->srcFormat))\n                c->swScale= packedCopy;\n            else \/* Planar YUV or gray *\/\n                c->swScale= planarCopy;\n        }\n#if ARCH_BFIN\n        if (flags & SWS_CPU_CAPS_BFIN)\n            ff_bfin_get_unscaled_swscale (c);\n#endif\n\n        if (c->swScale) {\n            if (flags&SWS_PRINT_INFO)\n                av_log(c, AV_LOG_INFO, \"using unscaled %s -> %s special converter\\n\",\n                       sws_format_name(srcFormat), sws_format_name(dstFormat));\n            return c;\n        }\n    }\n\n    if (flags & SWS_CPU_CAPS_MMX2) {\n        c->canMMX2BeUsed= (dstW >=srcW && (dstW&31)==0 && (srcW&15)==0) ? 1 : 0;\n        if (!c->canMMX2BeUsed && dstW >=srcW && (srcW&15)==0 && (flags&SWS_FAST_BILINEAR)) {\n            if (flags&SWS_PRINT_INFO)\n                av_log(c, AV_LOG_INFO, \"output width is not a multiple of 32 -> no MMX2 scaler\\n\");\n        }\n        if (usesHFilter) c->canMMX2BeUsed=0;\n    }\n    else\n        c->canMMX2BeUsed=0;\n\n    c->chrXInc= ((c->chrSrcW<<16) + (c->chrDstW>>1))\/c->chrDstW;\n    c->chrYInc= ((c->chrSrcH<<16) + (c->chrDstH>>1))\/c->chrDstH;\n\n    \/\/ match pixel 0 of the src to pixel 0 of dst and match pixel n-2 of src to pixel n-2 of dst\n    \/\/ but only for the FAST_BILINEAR mode otherwise do correct scaling\n    \/\/ n-2 is the last chrominance sample available\n    \/\/ this is not perfect, but no one should notice the difference, the more correct variant\n    \/\/ would be like the vertical one, but that would require some special code for the\n    \/\/ first and last pixel\n    if (flags&SWS_FAST_BILINEAR) {\n        if (c->canMMX2BeUsed) {\n            c->lumXInc+= 20;\n            c->chrXInc+= 20;\n        }\n        \/\/we don't use the x86 asm scaler if MMX is available\n        else if (flags & SWS_CPU_CAPS_MMX) {\n            c->lumXInc = ((srcW-2)<<16)\/(dstW-2) - 20;\n            c->chrXInc = ((c->chrSrcW-2)<<16)\/(c->chrDstW-2) - 20;\n        }\n    }\n\n    \/* precalculate horizontal scaler filter coefficients *\/\n    {\n        const int filterAlign=\n            (flags & SWS_CPU_CAPS_MMX) ? 4 :\n            (flags & SWS_CPU_CAPS_ALTIVEC) ? 8 :\n            1;\n\n        initFilter(&c->hLumFilter, &c->hLumFilterPos, &c->hLumFilterSize, c->lumXInc,\n                   srcW      ,       dstW, filterAlign, 1<<14,\n                   (flags&SWS_BICUBLIN) ? (flags|SWS_BICUBIC)  : flags,\n                   srcFilter->lumH, dstFilter->lumH, c->param);\n        initFilter(&c->hChrFilter, &c->hChrFilterPos, &c->hChrFilterSize, c->chrXInc,\n                   c->chrSrcW, c->chrDstW, filterAlign, 1<<14,\n                   (flags&SWS_BICUBLIN) ? (flags|SWS_BILINEAR) : flags,\n                   srcFilter->chrH, dstFilter->chrH, c->param);\n\n#if defined(COMPILE_MMX2)\n\/\/ can't downscale !!!\n        if (c->canMMX2BeUsed && (flags & SWS_FAST_BILINEAR)) {\n            c->lumMmx2FilterCodeSize = initMMX2HScaler(      dstW, c->lumXInc, NULL, NULL, NULL, 8);\n            c->chrMmx2FilterCodeSize = initMMX2HScaler(c->chrDstW, c->chrXInc, NULL, NULL, NULL, 4);\n\n#ifdef MAP_ANONYMOUS\n            c->lumMmx2FilterCode = mmap(NULL, c->lumMmx2FilterCodeSize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n            c->chrMmx2FilterCode = mmap(NULL, c->chrMmx2FilterCodeSize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n#elif HAVE_VIRTUALALLOC\n            c->lumMmx2FilterCode = VirtualAlloc(NULL, c->lumMmx2FilterCodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n            c->chrMmx2FilterCode = VirtualAlloc(NULL, c->chrMmx2FilterCodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n#else\n            c->lumMmx2FilterCode = av_malloc(c->lumMmx2FilterCodeSize);\n            c->chrMmx2FilterCode = av_malloc(c->chrMmx2FilterCodeSize);\n#endif\n\n            c->lumMmx2Filter   = av_malloc((dstW        \/8+8)*sizeof(int16_t));\n            c->chrMmx2Filter   = av_malloc((c->chrDstW  \/4+8)*sizeof(int16_t));\n            c->lumMmx2FilterPos= av_malloc((dstW      \/2\/8+8)*sizeof(int32_t));\n            c->chrMmx2FilterPos= av_malloc((c->chrDstW\/2\/4+8)*sizeof(int32_t));\n\n            initMMX2HScaler(      dstW, c->lumXInc, c->lumMmx2FilterCode, c->lumMmx2Filter, c->lumMmx2FilterPos, 8);\n            initMMX2HScaler(c->chrDstW, c->chrXInc, c->chrMmx2FilterCode, c->chrMmx2Filter, c->chrMmx2FilterPos, 4);\n\n#ifdef MAP_ANONYMOUS\n            mprotect(c->lumMmx2FilterCode, c->lumMmx2FilterCodeSize, PROT_EXEC | PROT_READ);\n            mprotect(c->chrMmx2FilterCode, c->chrMmx2FilterCodeSize, PROT_EXEC | PROT_READ);\n#endif\n        }\n#endif \/* defined(COMPILE_MMX2) *\/\n    } \/\/ initialize horizontal stuff\n\n\n\n    \/* precalculate vertical scaler filter coefficients *\/\n    {\n        const int filterAlign=\n            (flags & SWS_CPU_CAPS_MMX) && (flags & SWS_ACCURATE_RND) ? 2 :\n            (flags & SWS_CPU_CAPS_ALTIVEC) ? 8 :\n            1;\n\n        initFilter(&c->vLumFilter, &c->vLumFilterPos, &c->vLumFilterSize, c->lumYInc,\n                   srcH      ,        dstH, filterAlign, (1<<12),\n                   (flags&SWS_BICUBLIN) ? (flags|SWS_BICUBIC)  : flags,\n                   srcFilter->lumV, dstFilter->lumV, c->param);\n        initFilter(&c->vChrFilter, &c->vChrFilterPos, &c->vChrFilterSize, c->chrYInc,\n                   c->chrSrcH, c->chrDstH, filterAlign, (1<<12),\n                   (flags&SWS_BICUBLIN) ? (flags|SWS_BILINEAR) : flags,\n                   srcFilter->chrV, dstFilter->chrV, c->param);\n\n#ifdef COMPILE_ALTIVEC\n        c->vYCoeffsBank = av_malloc(sizeof (vector signed short)*c->vLumFilterSize*c->dstH);\n        c->vCCoeffsBank = av_malloc(sizeof (vector signed short)*c->vChrFilterSize*c->chrDstH);\n\n        for (i=0;i<c->vLumFilterSize*c->dstH;i++) {\n            int j;\n            short *p = (short *)&c->vYCoeffsBank[i];\n            for (j=0;j<8;j++)\n                p[j] = c->vLumFilter[i];\n        }\n\n        for (i=0;i<c->vChrFilterSize*c->chrDstH;i++) {\n            int j;\n            short *p = (short *)&c->vCCoeffsBank[i];\n            for (j=0;j<8;j++)\n                p[j] = c->vChrFilter[i];\n        }\n#endif\n    }\n\n    \/\/ calculate buffer sizes so that they won't run out while handling these damn slices\n    c->vLumBufSize= c->vLumFilterSize;\n    c->vChrBufSize= c->vChrFilterSize;\n    for (i=0; i<dstH; i++) {\n        int chrI= i*c->chrDstH \/ dstH;\n        int nextSlice= FFMAX(c->vLumFilterPos[i   ] + c->vLumFilterSize - 1,\n                           ((c->vChrFilterPos[chrI] + c->vChrFilterSize - 1)<<c->chrSrcVSubSample));\n\n        nextSlice>>= c->chrSrcVSubSample;\n        nextSlice<<= c->chrSrcVSubSample;\n        if (c->vLumFilterPos[i   ] + c->vLumBufSize < nextSlice)\n            c->vLumBufSize= nextSlice - c->vLumFilterPos[i];\n        if (c->vChrFilterPos[chrI] + c->vChrBufSize < (nextSlice>>c->chrSrcVSubSample))\n            c->vChrBufSize= (nextSlice>>c->chrSrcVSubSample) - c->vChrFilterPos[chrI];\n    }\n\n    \/\/ allocate pixbufs (we use dynamic allocation because otherwise we would need to\n    \/\/ allocate several megabytes to handle all possible cases)\n    c->lumPixBuf= av_malloc(c->vLumBufSize*2*sizeof(int16_t*));\n    c->chrPixBuf= av_malloc(c->vChrBufSize*2*sizeof(int16_t*));\n    if (CONFIG_SWSCALE_ALPHA && isALPHA(c->srcFormat) && isALPHA(c->dstFormat))\n        c->alpPixBuf= av_malloc(c->vLumBufSize*2*sizeof(int16_t*));\n    \/\/Note we need at least one pixel more at the end because of the MMX code (just in case someone wanna replace the 4000\/8000)\n    \/* align at 16 bytes for AltiVec *\/\n    for (i=0; i<c->vLumBufSize; i++)\n        c->lumPixBuf[i]= c->lumPixBuf[i+c->vLumBufSize]= av_mallocz(VOF+1);\n    for (i=0; i<c->vChrBufSize; i++)\n        c->chrPixBuf[i]= c->chrPixBuf[i+c->vChrBufSize]= av_malloc((VOF+1)*2);\n    if (CONFIG_SWSCALE_ALPHA && c->alpPixBuf)\n        for (i=0; i<c->vLumBufSize; i++)\n            c->alpPixBuf[i]= c->alpPixBuf[i+c->vLumBufSize]= av_mallocz(VOF+1);\n\n    \/\/try to avoid drawing green stuff between the right end and the stride end\n    for (i=0; i<c->vChrBufSize; i++) memset(c->chrPixBuf[i], 64, (VOF+1)*2);\n\n    assert(2*VOFW == VOF);\n\n    assert(c->chrDstH <= dstH);\n\n    if (flags&SWS_PRINT_INFO) {\n#ifdef DITHER1XBPP\n        const char *dither= \" dithered\";\n#else\n        const char *dither= \"\";\n#endif\n        if (flags&SWS_FAST_BILINEAR)\n            av_log(c, AV_LOG_INFO, \"FAST_BILINEAR scaler, \");\n        else if (flags&SWS_BILINEAR)\n            av_log(c, AV_LOG_INFO, \"BILINEAR scaler, \");\n        else if (flags&SWS_BICUBIC)\n            av_log(c, AV_LOG_INFO, \"BICUBIC scaler, \");\n        else if (flags&SWS_X)\n            av_log(c, AV_LOG_INFO, \"Experimental scaler, \");\n        else if (flags&SWS_POINT)\n            av_log(c, AV_LOG_INFO, \"Nearest Neighbor \/ POINT scaler, \");\n        else if (flags&SWS_AREA)\n            av_log(c, AV_LOG_INFO, \"Area Averageing scaler, \");\n        else if (flags&SWS_BICUBLIN)\n            av_log(c, AV_LOG_INFO, \"luma BICUBIC \/ chroma BILINEAR scaler, \");\n        else if (flags&SWS_GAUSS)\n            av_log(c, AV_LOG_INFO, \"Gaussian scaler, \");\n        else if (flags&SWS_SINC)\n            av_log(c, AV_LOG_INFO, \"Sinc scaler, \");\n        else if (flags&SWS_LANCZOS)\n            av_log(c, AV_LOG_INFO, \"Lanczos scaler, \");\n        else if (flags&SWS_SPLINE)\n            av_log(c, AV_LOG_INFO, \"Bicubic spline scaler, \");\n        else\n            av_log(c, AV_LOG_INFO, \"ehh flags invalid?! \");\n\n        if (dstFormat==PIX_FMT_BGR555 || dstFormat==PIX_FMT_BGR565)\n            av_log(c, AV_LOG_INFO, \"from %s to%s %s \",\n                   sws_format_name(srcFormat), dither, sws_format_name(dstFormat));\n        else\n            av_log(c, AV_LOG_INFO, \"from %s to %s \",\n                   sws_format_name(srcFormat), sws_format_name(dstFormat));\n\n        if (flags & SWS_CPU_CAPS_MMX2)\n            av_log(c, AV_LOG_INFO, \"using MMX2\\n\");\n        else if (flags & SWS_CPU_CAPS_3DNOW)\n            av_log(c, AV_LOG_INFO, \"using 3DNOW\\n\");\n        else if (flags & SWS_CPU_CAPS_MMX)\n            av_log(c, AV_LOG_INFO, \"using MMX\\n\");\n        else if (flags & SWS_CPU_CAPS_ALTIVEC)\n            av_log(c, AV_LOG_INFO, \"using AltiVec\\n\");\n        else\n            av_log(c, AV_LOG_INFO, \"using C\\n\");\n    }\n\n    if (flags & SWS_PRINT_INFO) {\n        if (flags & SWS_CPU_CAPS_MMX) {\n            if (c->canMMX2BeUsed && (flags&SWS_FAST_BILINEAR))\n                av_log(c, AV_LOG_VERBOSE, \"using FAST_BILINEAR MMX2 scaler for horizontal scaling\\n\");\n            else {\n                if (c->hLumFilterSize==4)\n                    av_log(c, AV_LOG_VERBOSE, \"using 4-tap MMX scaler for horizontal luminance scaling\\n\");\n                else if (c->hLumFilterSize==8)\n                    av_log(c, AV_LOG_VERBOSE, \"using 8-tap MMX scaler for horizontal luminance scaling\\n\");\n                else\n                    av_log(c, AV_LOG_VERBOSE, \"using n-tap MMX scaler for horizontal luminance scaling\\n\");\n\n                if (c->hChrFilterSize==4)\n                    av_log(c, AV_LOG_VERBOSE, \"using 4-tap MMX scaler for horizontal chrominance scaling\\n\");\n                else if (c->hChrFilterSize==8)\n                    av_log(c, AV_LOG_VERBOSE, \"using 8-tap MMX scaler for horizontal chrominance scaling\\n\");\n                else\n                    av_log(c, AV_LOG_VERBOSE, \"using n-tap MMX scaler for horizontal chrominance scaling\\n\");\n            }\n        } else {\n#if ARCH_X86\n            av_log(c, AV_LOG_VERBOSE, \"using x86 asm scaler for horizontal scaling\\n\");\n#else\n            if (flags & SWS_FAST_BILINEAR)\n                av_log(c, AV_LOG_VERBOSE, \"using FAST_BILINEAR C scaler for horizontal scaling\\n\");\n            else\n                av_log(c, AV_LOG_VERBOSE, \"using C scaler for horizontal scaling\\n\");\n#endif\n        }\n        if (isPlanarYUV(dstFormat)) {\n            if (c->vLumFilterSize==1)\n                av_log(c, AV_LOG_VERBOSE, \"using 1-tap %s \\\"scaler\\\" for vertical scaling (YV12 like)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n            else\n                av_log(c, AV_LOG_VERBOSE, \"using n-tap %s scaler for vertical scaling (YV12 like)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n        } else {\n            if (c->vLumFilterSize==1 && c->vChrFilterSize==2)\n                av_log(c, AV_LOG_VERBOSE, \"using 1-tap %s \\\"scaler\\\" for vertical luminance scaling (BGR)\\n\"\n                       \"      2-tap scaler for vertical chrominance scaling (BGR)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n            else if (c->vLumFilterSize==2 && c->vChrFilterSize==2)\n                av_log(c, AV_LOG_VERBOSE, \"using 2-tap linear %s scaler for vertical scaling (BGR)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n            else\n                av_log(c, AV_LOG_VERBOSE, \"using n-tap %s scaler for vertical scaling (BGR)\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n        }\n\n        if (dstFormat==PIX_FMT_BGR24)\n            av_log(c, AV_LOG_VERBOSE, \"using %s YV12->BGR24 converter\\n\",\n                   (flags & SWS_CPU_CAPS_MMX2) ? \"MMX2\" : ((flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\"));\n        else if (dstFormat==PIX_FMT_RGB32)\n            av_log(c, AV_LOG_VERBOSE, \"using %s YV12->BGR32 converter\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n        else if (dstFormat==PIX_FMT_BGR565)\n            av_log(c, AV_LOG_VERBOSE, \"using %s YV12->BGR16 converter\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n        else if (dstFormat==PIX_FMT_BGR555)\n            av_log(c, AV_LOG_VERBOSE, \"using %s YV12->BGR15 converter\\n\", (flags & SWS_CPU_CAPS_MMX) ? \"MMX\" : \"C\");\n\n        av_log(c, AV_LOG_VERBOSE, \"%dx%d -> %dx%d\\n\", srcW, srcH, dstW, dstH);\n    }\n    if (flags & SWS_PRINT_INFO) {\n        av_log(c, AV_LOG_DEBUG, \"lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\\n\",\n               c->srcW, c->srcH, c->dstW, c->dstH, c->lumXInc, c->lumYInc);\n        av_log(c, AV_LOG_DEBUG, \"chr srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\\n\",\n               c->chrSrcW, c->chrSrcH, c->chrDstW, c->chrDstH, c->chrXInc, c->chrYInc);\n    }\n\n    c->swScale= getSwsFunc(c);\n    return c;\n}","idx":1290891,"target":1}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}","idx":1291672,"target":1}
{"code":"int main (int argc, const char * const argv[])\n{\n    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];\n    int tLogEnd = 0, tRotation = 0, utc_offset = 0;\n    unsigned int sRotation = 0;\n    int nMessCount = 0;\n    apr_size_t nRead, nWrite;\n    int use_strftime = 0;\n    int use_localtime = 0;\n    int now = 0;\n    const char *szLogRoot;\n    apr_file_t *f_stdin, *nLogFD = NULL, *nLogFDprev = NULL;\n    apr_pool_t *pool;\n    char *ptr = NULL;\n    int argBase = 0;\n    int argFile = 1;\n    int argIntv = 2;\n    int argOffset = 3;\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    apr_pool_create(&pool, NULL);\n    if ((argc > 2) && (strcmp(argv[1], \"-l\") == 0)) {\n        argBase++;\n        argFile += argBase;\n        argIntv += argBase;\n        argOffset += argBase;\n        use_localtime = 1;\n    }\n    if (argc < (argBase + 3) || argc > (argBase + 4)) {\n        fprintf(stderr,\n                \"Usage: %s [-l] <logfile> <rotation time in seconds> \"\n                \"[offset minutes from UTC] or <rotation size in megabytes>\\n\\n\",\n                argv[0]);\n#ifdef OS2\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s.exe \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n#else\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n        fprintf(stderr,\n                \"or \\n\\nTransferLog \\\"|%s \/some\/where 5M\\\"\\n\\n\", argv[0]);\n#endif\n        fprintf(stderr,\n                \"to httpd.conf. The generated name will be \/some\/where.nnnn \"\n                \"where nnnn is the\\nsystem time at which the log nominally \"\n                \"starts (N.B. if using a rotation time,\\nthe time will always \"\n                \"be a multiple of the rotation time, so you can synchronize\\n\"\n                \"cron scripts with it). At the end of each rotation time or \"\n                \"when the file size\\nis reached a new log is started.\\n\");\n        exit(1);\n    }\n\n    szLogRoot = argv[argFile];\n\n    ptr = strchr(argv[argIntv], 'M');\n    if (ptr) {\n        if (*(ptr+1) == '\\0') {\n            sRotation = atoi(argv[argIntv]) * 1048576;\n        }\n        if (sRotation == 0) {\n            fprintf(stderr, \"Invalid rotation size parameter\\n\");\n            exit(1);\n        }\n    }\n    else {\n        if (argc >= (argBase + 4)) {\n            utc_offset = atoi(argv[argOffset]) * 60;\n        }\n        tRotation = atoi(argv[argIntv]);\n        if (tRotation <= 0) {\n            fprintf(stderr, \"Rotation time must be > 0\\n\");\n            exit(6);\n        }\n    }\n\n    use_strftime = (strchr(szLogRoot, '%') != NULL);\n    if (apr_file_open_stdin(&f_stdin, pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n        if (apr_file_read(f_stdin, buf, &nRead) != APR_SUCCESS) {\n            exit(3);\n        }\n        if (tRotation) {\n            \/*\n             * Check for our UTC offset every time through the loop, since\n             * it might change if there's a switch between standard and\n             * daylight savings time.\n             *\/\n            if (use_localtime) {\n                apr_time_exp_t lt;\n                apr_time_exp_lt(&lt, apr_time_now());\n                utc_offset = lt.tm_gmtoff;\n            }\n            now = (int)(apr_time_now() \/ APR_USEC_PER_SEC) + utc_offset;\n            if (nLogFD != NULL && now >= tLogEnd) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else if (sRotation) {\n            apr_finfo_t finfo;\n            apr_off_t current_size = -1;\n\n            if ((nLogFD != NULL) &&\n                (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {\n                current_size = finfo.size;\n            }\n\n            if (current_size > sRotation) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else {\n            fprintf(stderr, \"No rotation time or size specified\\n\");\n            exit(2);\n        }\n\n        if (nLogFD == NULL) {\n            int tLogStart;\n\n            if (tRotation) {\n                tLogStart = (now \/ tRotation) * tRotation;\n            }\n            else {\n                tLogStart = (int)apr_time_sec(apr_time_now());\n            }\n\n            if (use_strftime) {\n                apr_time_t tNow = apr_time_from_sec(tLogStart);\n                apr_time_exp_t e;\n                apr_size_t rs;\n\n                apr_time_exp_gmt(&e, tNow);\n                apr_strftime(buf2, &rs, sizeof(buf2), szLogRoot, &e);\n            }\n            else {\n                sprintf(buf2, \"%s.%010d\", szLogRoot, tLogStart);\n            }\n            tLogEnd = tLogStart + tRotation;\n            apr_file_open(&nLogFD, buf2, APR_READ | APR_WRITE | APR_CREATE | APR_APPEND,\n                          APR_OS_DEFAULT, pool);\n            if (nLogFD == NULL) {\n                \/* Uh-oh. Failed to open the new log file. Try to clear\n                 * the previous log file, note the lost log entries,\n                 * and keep on truckin'. *\/\n                if (nLogFDprev == NULL) {\n                    fprintf(stderr, \"1 Previous file handle doesn't exists %s\\n\", buf2);\n                    exit(2);\n                }\n                else {\n                    nLogFD = nLogFDprev;\n                    sprintf(errbuf,\n                            \"Resetting log file due to error opening \"\n                            \"new log file. %10d messages lost.\\n\",\n                            nMessCount);\n                    nWrite = strlen(errbuf);\n                    apr_file_trunc(nLogFD, 0);\n                    if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                        fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                        exit(2);\n                    }\n                }\n            }\n            else if (nLogFDprev) {\n                apr_file_close(nLogFDprev);\n            }\n            nMessCount = 0;\n        }\n        nWrite = nRead;\n        apr_file_write(nLogFD, buf, &nWrite);\n        if (nWrite != nRead) {\n            nMessCount++;\n            sprintf(errbuf,\n                    \"Error writing to log file. \"\n                    \"%10d messages lost.\\n\",\n                    nMessCount);\n            nWrite = strlen(errbuf);\n            apr_file_trunc(nLogFD, 0);\n            if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                exit(2);\n            }\n        }\n        else {\n            nMessCount++;\n        }\n    }\n    \/* Of course we never, but prevent compiler warnings *\/\n    return 0;\n}","idx":7,"target":0}
{"code":"static void brigade_move(apr_bucket_brigade *b, apr_bucket_brigade *a,\n                         apr_bucket *e)\n{\n    apr_bucket *f;\n\n    if (e != APR_BRIGADE_SENTINEL(b)) {\n        f = APR_RING_LAST(&b->list);\n        APR_RING_UNSPLICE(e, f, link);\n        APR_RING_SPLICE_HEAD(&a->list, e, f, apr_bucket, link);\n    }\n\n    APR_BRIGADE_CHECK_CONSISTENCY(a);\n    APR_BRIGADE_CHECK_CONSISTENCY(b);\n}","idx":15,"target":0}
{"code":"","idx":18,"target":0}
{"code":"static long get_chunk_size(char *b)\n{\n    long chunksize = 0;\n    size_t chunkbits = sizeof(long) * 8;\n\n    ap_xlate_proto_from_ascii(b, strlen(b));\n\n    \/* Skip leading zeros *\/\n    while (*b == '0') {\n        ++b;\n    }\n\n    while (apr_isxdigit(*b) && (chunkbits > 0)) {\n        int xvalue = 0;\n\n        if (*b >= '0' && *b <= '9') {\n            xvalue = *b - '0';\n        }\n        else if (*b >= 'A' && *b <= 'F') {\n            xvalue = *b - 'A' + 0xa;\n        }\n        else if (*b >= 'a' && *b <= 'f') {\n            xvalue = *b - 'a' + 0xa;\n        }\n\n        chunksize = (chunksize << 4) | xvalue;\n        chunkbits -= 4;\n        ++b;\n    }\n    if (apr_isxdigit(*b) && (chunkbits <= 0)) {\n        \/* overflow *\/\n        return -1;\n    }\n\n    return chunksize;\n}","idx":12,"target":0}
{"code":"static int asis_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    apr_file_t *f = NULL;\n    apr_status_t rv;\n    const char *location;\n\n    if(strcmp(r->handler,ASIS_MAGIC_TYPE) && strcmp(r->handler,\"send-as-is\"))\n        return DECLINED;\n\n    r->allowed |= (AP_METHOD_BIT << M_GET);\n    if (r->method_number != M_GET)\n        return DECLINED;\n    if (r->finfo.filetype == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                    \"File does not exist: %s\", r->filename);\n        return HTTP_NOT_FOUND;\n    }\n\n    if ((rv = apr_file_open(&f, r->filename, APR_READ,\n                APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                    \"file permissions deny server access: %s\", r->filename);\n        return HTTP_FORBIDDEN;\n    }\n\n    ap_scan_script_header_err(r, f, NULL);\n    location = apr_table_get(r->headers_out, \"Location\");\n\n    if (location && location[0] == '\/' &&\n        ((r->status == HTTP_OK) || ap_is_HTTP_REDIRECT(r->status))) {\n\n        apr_file_close(f);\n\n        \/* Internal redirect -- fake-up a pseudo-request *\/\n        r->status = HTTP_OK;\n\n        \/* This redirect needs to be a GET no matter what the original\n         * method was.\n         *\/\n        r->method = apr_pstrdup(r->pool, \"GET\");\n        r->method_number = M_GET;\n\n        ap_internal_redirect_handler(location, r);\n        return OK;\n    }\n\n    if (!r->header_only) {\n        apr_bucket_brigade *bb;\n        apr_bucket *b;\n        apr_off_t pos = 0;\n\n        rv = apr_file_seek(f, APR_CUR, &pos);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          \"mod_asis: failed to find end-of-headers position \"\n                          \"for %s\", r->filename);\n            apr_file_close(f);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bb = apr_brigade_create(r->pool, c->bucket_alloc);\n#if APR_HAS_LARGE_FILES\n        if (r->finfo.size - pos > AP_MAX_SENDFILE) {\n            \/* APR_HAS_LARGE_FILES issue; must split into mutiple buckets,\n             * no greater than MAX(apr_size_t), and more granular than that\n             * in case the brigade code\/filters attempt to read it directly.\n             *\/\n            apr_off_t fsize = r->finfo.size - pos;\n            b = apr_bucket_file_create(f, pos, AP_MAX_SENDFILE,\n                                       r->pool, c->bucket_alloc);\n            while (fsize > AP_MAX_SENDFILE) {\n                APR_BRIGADE_INSERT_TAIL(bb, b);\n                apr_bucket_copy(b, &b);\n                b->start += AP_MAX_SENDFILE;\n                fsize -= AP_MAX_SENDFILE;\n            }\n            b->length = (apr_size_t)fsize; \/* Resize just the last bucket *\/\n        }\n        else\n#endif\n        b = apr_bucket_file_create(f, pos, (apr_size_t) (r->finfo.size - pos),\n                                   r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n        b = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n        rv = ap_pass_brigade(r->output_filters, bb);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          \"mod_asis: ap_pass_brigade failed for file %s\", r->filename);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n    }\n    else {\n        apr_file_close(f);\n    }\n\n    return OK;\n}","idx":1,"target":0}
{"code":"int main (int argc, const char * const argv[])\n{\n    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];\n    int tLogEnd = 0, tRotation = 0, utc_offset = 0;\n    unsigned int sRotation = 0;\n    int nMessCount = 0;\n    apr_size_t nRead, nWrite;\n    int use_strftime = 0;\n    int use_localtime = 0;\n    int now = 0;\n    const char *szLogRoot;\n    apr_file_t *f_stdin, *nLogFD = NULL, *nLogFDprev = NULL;\n    apr_pool_t *pool;\n    char *ptr = NULL;\n    int argBase = 0;\n    int argFile = 1;\n    int argIntv = 2;\n    int argOffset = 3;\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    apr_pool_create(&pool, NULL);\n    if ((argc > 2) && (strcmp(argv[1], \"-l\") == 0)) {\n        argBase++;\n        argFile += argBase;\n        argIntv += argBase;\n        argOffset += argBase;\n        use_localtime = 1;\n    }\n    if (argc < (argBase + 3) || argc > (argBase + 4)) {\n        fprintf(stderr,\n                \"Usage: %s [-l] <logfile> <rotation time in seconds> \"\n                \"[offset minutes from UTC] or <rotation size in megabytes>\\n\\n\",\n                argv[0]);\n#ifdef OS2\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s.exe \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n#else\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n        fprintf(stderr,\n                \"or \\n\\nTransferLog \\\"|%s \/some\/where 5M\\\"\\n\\n\", argv[0]);\n#endif\n        fprintf(stderr,\n                \"to httpd.conf. The generated name will be \/some\/where.nnnn \"\n                \"where nnnn is the\\nsystem time at which the log nominally \"\n                \"starts (N.B. if using a rotation time,\\nthe time will always \"\n                \"be a multiple of the rotation time, so you can synchronize\\n\"\n                \"cron scripts with it). At the end of each rotation time or \"\n                \"when the file size\\nis reached a new log is started.\\n\");\n        exit(1);\n    }\n\n    szLogRoot = argv[argFile];\n\n    ptr = strchr(argv[argIntv], 'M');\n    if (ptr) {\n        if (*(ptr+1) == '\\0') {\n            sRotation = atoi(argv[argIntv]) * 1048576;\n        }\n        if (sRotation == 0) {\n            fprintf(stderr, \"Invalid rotation size parameter\\n\");\n            exit(1);\n        }\n    }\n    else {\n        if (argc >= (argBase + 4)) {\n            utc_offset = atoi(argv[argOffset]) * 60;\n        }\n        tRotation = atoi(argv[argIntv]);\n        if (tRotation <= 0) {\n            fprintf(stderr, \"Rotation time must be > 0\\n\");\n            exit(6);\n        }\n    }\n\n    use_strftime = (strchr(szLogRoot, '%') != NULL);\n    if (apr_file_open_stdin(&f_stdin, pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n        if (apr_file_read(f_stdin, buf, &nRead) != APR_SUCCESS) {\n            exit(3);\n        }\n        if (tRotation) {\n            \/*\n             * Check for our UTC offset every time through the loop, since\n             * it might change if there's a switch between standard and\n             * daylight savings time.\n             *\/\n            if (use_localtime) {\n                apr_time_exp_t lt;\n                apr_time_exp_lt(&lt, apr_time_now());\n                utc_offset = lt.tm_gmtoff;\n            }\n            now = (int)(apr_time_now() \/ APR_USEC_PER_SEC) + utc_offset;\n            if (nLogFD != NULL && now >= tLogEnd) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else if (sRotation) {\n            apr_finfo_t finfo;\n            apr_off_t current_size = -1;\n\n            if ((nLogFD != NULL) &&\n                (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {\n                current_size = finfo.size;\n            }\n\n            if (current_size > sRotation) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else {\n            fprintf(stderr, \"No rotation time or size specified\\n\");\n            exit(2);\n        }\n\n        if (nLogFD == NULL) {\n            int tLogStart;\n\n            if (tRotation) {\n                tLogStart = (now \/ tRotation) * tRotation;\n            }\n            else {\n                tLogStart = (int)apr_time_sec(apr_time_now());\n            }\n\n            if (use_strftime) {\n                apr_time_t tNow = apr_time_from_sec(tLogStart);\n                apr_time_exp_t e;\n                apr_size_t rs;\n\n                apr_time_exp_gmt(&e, tNow);\n                apr_strftime(buf2, &rs, sizeof(buf2), szLogRoot, &e);\n            }\n            else {\n                sprintf(buf2, \"%s.%010d\", szLogRoot, tLogStart);\n            }\n            tLogEnd = tLogStart + tRotation;\n            apr_file_open(&nLogFD, buf2, APR_READ | APR_WRITE | APR_CREATE | APR_APPEND,\n                          APR_OS_DEFAULT, pool);\n            if (nLogFD == NULL) {\n                \/* Uh-oh. Failed to open the new log file. Try to clear\n                 * the previous log file, note the lost log entries,\n                 * and keep on truckin'. *\/\n                if (nLogFDprev == NULL) {\n                    fprintf(stderr, \"1 Previous file handle doesn't exists %s\\n\", buf2);\n                    exit(2);\n                }\n                else {\n                    nLogFD = nLogFDprev;\n                    sprintf(errbuf,\n                            \"Resetting log file due to error opening \"\n                            \"new log file. %10d messages lost.\\n\",\n                            nMessCount);\n                    nWrite = strlen(errbuf);\n                    apr_file_trunc(nLogFD, 0);\n                    if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                        fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                        exit(2);\n                    }\n                }\n            }\n            else if (nLogFDprev) {\n                apr_file_close(nLogFDprev);\n            }\n            nMessCount = 0;\n        }\n        nWrite = nRead;\n        apr_file_write(nLogFD, buf, &nWrite);\n        if (nWrite != nRead) {\n            nMessCount++;\n            sprintf(errbuf,\n                    \"Error writing to log file. \"\n                    \"%10d messages lost.\\n\",\n                    nMessCount);\n            nWrite = strlen(errbuf);\n            apr_file_trunc(nLogFD, 0);\n            if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                exit(2);\n            }\n        }\n        else {\n            nMessCount++;\n        }\n    }\n    \/* Of course we never, but prevent compiler warnings *\/\n    return 0;\n}","idx":8,"target":0}
{"code":"","idx":5,"target":0}
{"code":"AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int length)\n{\n    const char *hex = \"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;\n    unsigned char hash[APR_MD5_DIGESTSIZE];\n    char *r, result[33]; \/* (MD5_DIGESTSIZE * 2) + 1 *\/\n    int i;\n\n    \/*\n     * Take the MD5 hash of the string argument.\n     *\/\n\n    apr_md5_init(&my_md5);\n#if APR_CHARSET_EBCDIC\n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);\n#endif\n    apr_md5_update(&my_md5, buf, (unsigned int)length);\n    apr_md5_final(hash, &my_md5);\n\n    for (i = 0, r = result; i < APR_MD5_DIGESTSIZE; i++) {\n        *r++ = hex[hash[i] >> 4];\n        *r++ = hex[hash[i] & 0xF];\n    }\n    *r = '\\0';\n\n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);\n}","idx":3,"target":0}
{"code":"AP_DECLARE(apr_port_t) ap_get_server_port(const request_rec *r)\n{\n    apr_port_t port;\n    core_dir_config *d =\n      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);\n\n    switch (d->use_canonical_name) {\n        case USE_CANONICAL_NAME_OFF:\n        case USE_CANONICAL_NAME_DNS:\n        case USE_CANONICAL_NAME_UNSET:\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            else \/* USE_CANONICAL_PHYS_PORT_OFF or USE_CANONICAL_PHYS_PORT_UNSET *\/\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        case USE_CANONICAL_NAME_ON:\n            \/* With UseCanonicalName on (and in all versions prior to 1.3)\n             * Apache will use the hostname and port specified in the\n             * ServerName directive to construct a canonical name for the\n             * server. (If no port was specified in the ServerName\n             * directive, Apache uses the port supplied by the client if\n             * any is supplied, and finally the default port for the protocol\n             * used.\n             *\/\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->server->port ? r->server->port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       ap_default_port(r);\n            else \/* USE_CANONICAL_PHYS_PORT_OFF or USE_CANONICAL_PHYS_PORT_UNSET *\/\n                port = r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                         \"ap_get_server_port: Invalid UCN Option somehow\");\n            port = ap_default_port(r);\n            break;\n    }\n\n    return port;\n}","idx":11,"target":0}
{"code":"int main (int argc, const char * const argv[])\n{\n    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];\n    int tLogEnd = 0, tRotation = 0, utc_offset = 0;\n    unsigned int sRotation = 0;\n    int nMessCount = 0;\n    apr_size_t nRead, nWrite;\n    int use_strftime = 0;\n    int use_localtime = 0;\n    int now = 0;\n    const char *szLogRoot;\n    apr_file_t *f_stdin, *nLogFD = NULL, *nLogFDprev = NULL;\n    apr_pool_t *pool;\n    char *ptr = NULL;\n    int argBase = 0;\n    int argFile = 1;\n    int argIntv = 2;\n    int argOffset = 3;\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    apr_pool_create(&pool, NULL);\n    if ((argc > 2) && (strcmp(argv[1], \"-l\") == 0)) {\n        argBase++;\n        argFile += argBase;\n        argIntv += argBase;\n        argOffset += argBase;\n        use_localtime = 1;\n    }\n    if (argc < (argBase + 3) || argc > (argBase + 4)) {\n        fprintf(stderr,\n                \"Usage: %s [-l] <logfile> <rotation time in seconds> \"\n                \"[offset minutes from UTC] or <rotation size in megabytes>\\n\\n\",\n                argv[0]);\n#ifdef OS2\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s.exe \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n#else\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n        fprintf(stderr,\n                \"or \\n\\nTransferLog \\\"|%s \/some\/where 5M\\\"\\n\\n\", argv[0]);\n#endif\n        fprintf(stderr,\n                \"to httpd.conf. The generated name will be \/some\/where.nnnn \"\n                \"where nnnn is the\\nsystem time at which the log nominally \"\n                \"starts (N.B. if using a rotation time,\\nthe time will always \"\n                \"be a multiple of the rotation time, so you can synchronize\\n\"\n                \"cron scripts with it). At the end of each rotation time or \"\n                \"when the file size\\nis reached a new log is started.\\n\");\n        exit(1);\n    }\n\n    szLogRoot = argv[argFile];\n\n    ptr = strchr(argv[argIntv], 'M');\n    if (ptr) {\n        if (*(ptr+1) == '\\0') {\n            sRotation = atoi(argv[argIntv]) * 1048576;\n        }\n        if (sRotation == 0) {\n            fprintf(stderr, \"Invalid rotation size parameter\\n\");\n            exit(1);\n        }\n    }\n    else {\n        if (argc >= (argBase + 4)) {\n            utc_offset = atoi(argv[argOffset]) * 60;\n        }\n        tRotation = atoi(argv[argIntv]);\n        if (tRotation <= 0) {\n            fprintf(stderr, \"Rotation time must be > 0\\n\");\n            exit(6);\n        }\n    }\n\n    use_strftime = (strchr(szLogRoot, '%') != NULL);\n    if (apr_file_open_stdin(&f_stdin, pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n        if (apr_file_read(f_stdin, buf, &nRead) != APR_SUCCESS) {\n            exit(3);\n        }\n        if (tRotation) {\n            \/*\n             * Check for our UTC offset every time through the loop, since\n             * it might change if there's a switch between standard and\n             * daylight savings time.\n             *\/\n            if (use_localtime) {\n                apr_time_exp_t lt;\n                apr_time_exp_lt(&lt, apr_time_now());\n                utc_offset = lt.tm_gmtoff;\n            }\n            now = (int)(apr_time_now() \/ APR_USEC_PER_SEC) + utc_offset;\n            if (nLogFD != NULL && now >= tLogEnd) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else if (sRotation) {\n            apr_finfo_t finfo;\n            apr_off_t current_size = -1;\n\n            if ((nLogFD != NULL) &&\n                (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {\n                current_size = finfo.size;\n            }\n\n            if (current_size > sRotation) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else {\n            fprintf(stderr, \"No rotation time or size specified\\n\");\n            exit(2);\n        }\n\n        if (nLogFD == NULL) {\n            int tLogStart;\n\n            if (tRotation) {\n                tLogStart = (now \/ tRotation) * tRotation;\n            }\n            else {\n                tLogStart = (int)apr_time_sec(apr_time_now());\n            }\n\n            if (use_strftime) {\n                apr_time_t tNow = apr_time_from_sec(tLogStart);\n                apr_time_exp_t e;\n                apr_size_t rs;\n\n                apr_time_exp_gmt(&e, tNow);\n                apr_strftime(buf2, &rs, sizeof(buf2), szLogRoot, &e);\n            }\n            else {\n                sprintf(buf2, \"%s.%010d\", szLogRoot, tLogStart);\n            }\n            tLogEnd = tLogStart + tRotation;\n            apr_file_open(&nLogFD, buf2, APR_READ | APR_WRITE | APR_CREATE | APR_APPEND,\n                          APR_OS_DEFAULT, pool);\n            if (nLogFD == NULL) {\n                \/* Uh-oh. Failed to open the new log file. Try to clear\n                 * the previous log file, note the lost log entries,\n                 * and keep on truckin'. *\/\n                if (nLogFDprev == NULL) {\n                    fprintf(stderr, \"1 Previous file handle doesn't exists %s\\n\", buf2);\n                    exit(2);\n                }\n                else {\n                    nLogFD = nLogFDprev;\n                    sprintf(errbuf,\n                            \"Resetting log file due to error opening \"\n                            \"new log file. %10d messages lost.\\n\",\n                            nMessCount);\n                    nWrite = strlen(errbuf);\n                    apr_file_trunc(nLogFD, 0);\n                    if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                        fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                        exit(2);\n                    }\n                }\n            }\n            else if (nLogFDprev) {\n                apr_file_close(nLogFDprev);\n            }\n            nMessCount = 0;\n        }\n        nWrite = nRead;\n        apr_file_write(nLogFD, buf, &nWrite);\n        if (nWrite != nRead) {\n            nMessCount++;\n            sprintf(errbuf,\n                    \"Error writing to log file. \"\n                    \"%10d messages lost.\\n\",\n                    nMessCount);\n            nWrite = strlen(errbuf);\n            apr_file_trunc(nLogFD, 0);\n            if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                exit(2);\n            }\n        }\n        else {\n            nMessCount++;\n        }\n    }\n    \/* Of course we never, but prevent compiler warnings *\/\n    return 0;\n}","idx":9,"target":0}
{"code":"","idx":2,"target":0}
{"code":"static int set_group_privs(void)\n{\n    if (!geteuid()) {\n        const char *name;\n\n        \/* Get username if passed as a uid *\/\n\n        if (unixd_config.user_name[0] == '#') {\n            struct passwd *ent;\n            uid_t uid = atoi(&unixd_config.user_name[1]);\n\n            if ((ent = getpwuid(uid)) == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"getpwuid: couldn't determine user name from uid %u, \"\n                         \"you probably need to modify the User directive\",\n                         (unsigned)uid);\n                return -1;\n            }\n\n            name = ent->pw_name;\n        }\n        else\n            name = unixd_config.user_name;\n\n#if !defined(OS2) && !defined(TPF)\n        \/* OS\/2 and TPF don't support groups. *\/\n\n        \/*\n         * Set the GID before initgroups(), since on some platforms\n         * setgid() is known to zap the group list.\n         *\/\n        if (setgid(unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"setgid: unable to set group id to Group %u\",\n                        (unsigned)unixd_config.group_id);\n            return -1;\n        }\n\n        \/* Reset `groups' attributes. *\/\n\n        if (initgroups(name, unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"initgroups: unable to set groups for User %s \"\n                        \"and Group %u\", name, (unsigned)unixd_config.group_id);\n            return -1;\n        }\n#endif \/* !defined(OS2) && !defined(TPF) *\/\n    }\n    return 0;\n}","idx":6,"target":0}
{"code":"AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int length)\n{\n    const char *hex = \"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;\n    unsigned char hash[APR_MD5_DIGESTSIZE];\n    char *r, result[33]; \/* (MD5_DIGESTSIZE * 2) + 1 *\/\n    int i;\n\n    \/*\n     * Take the MD5 hash of the string argument.\n     *\/\n\n    apr_md5_init(&my_md5);\n#if APR_CHARSET_EBCDIC\n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);\n#endif\n    apr_md5_update(&my_md5, buf, (unsigned int)length);\n    apr_md5_final(hash, &my_md5);\n\n    for (i = 0, r = result; i < APR_MD5_DIGESTSIZE; i++) {\n        *r++ = hex[hash[i] >> 4];\n        *r++ = hex[hash[i] & 0xF];\n    }\n    *r = '\\0';\n\n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);\n}","idx":4,"target":0}
{"code":"void ap_init_scoreboard(void *shared_score)\n{\n    char *more_storage;\n    int i;\n\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image =\n        calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *) +\n               server_limit * lb_limit * sizeof(lb_score *));\n    more_storage = shared_score;\n    ap_scoreboard_image->global = (global_score *)more_storage;\n    more_storage += sizeof(global_score);\n    ap_scoreboard_image->parent = (process_score *)more_storage;\n    more_storage += sizeof(process_score) * server_limit;\n    ap_scoreboard_image->servers =\n        (worker_score **)((char*)ap_scoreboard_image + sizeof(scoreboard));\n    for (i = 0; i < server_limit; i++) {\n        ap_scoreboard_image->servers[i] = (worker_score *)more_storage;\n        more_storage += thread_limit * sizeof(worker_score);\n    }\n    if (lb_limit) {\n        ap_scoreboard_image->balancers = (lb_score *)more_storage;\n        more_storage += lb_limit * sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score + scoreboard_size);\n    ap_scoreboard_image->global->server_limit = server_limit;\n    ap_scoreboard_image->global->thread_limit = thread_limit;\n    ap_scoreboard_image->global->lb_limit     = lb_limit;\n}","idx":19,"target":0}
{"code":"AP_DECLARE(char *) ap_field_noparam(apr_pool_t *p, const char *intype)\n{\n    const char *semi;\n\n    if (intype == NULL) return NULL;\n\n    semi = ap_strchr_c(intype, ';');\n    if (semi == NULL) {\n        return apr_pstrdup(p, intype);\n    }\n    else {\n        while ((semi > intype) && apr_isspace(semi[-1])) {\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi - intype);\n    }\n}","idx":17,"target":0}
{"code":"AP_DECLARE(char *) ap_field_noparam(apr_pool_t *p, const char *intype)\n{\n    const char *semi;\n\n    if (intype == NULL) return NULL;\n\n    semi = ap_strchr_c(intype, ';');\n    if (semi == NULL) {\n        return apr_pstrdup(p, intype);\n    }\n    else {\n        while ((semi > intype) && apr_isspace(semi[-1])) {\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi - intype);\n    }\n}","idx":16,"target":0}
{"code":"apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,\n                            ap_input_mode_t mode, apr_read_type_e block,\n                            apr_off_t readbytes)\n{\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    apr_off_t totalread;\n\n    \/* just get out of the way of things we don't want. *\/\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_palloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n        ctx->remaining = 0;\n        ctx->limit_used = 0;\n        ctx->eos_sent = 0;\n\n        \/* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         *\/\n        if (!f->r->proxyreq) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (!strcasecmp(tenc, \"chunked\")) {\n                ctx->state = BODY_CHUNK;\n            }\n        }\n        else if (lenp) {\n            char *endstr;\n\n            ctx->state = BODY_LENGTH;\n            errno = 0;\n\n            \/* Protects against over\/underflow, non-digit chars in the\n             * string (excluding leading space) (the endstr checks)\n             * and a negative number. *\/\n            if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n                || endstr == lenp || *endstr || ctx->remaining < 0) {\n                apr_bucket_brigade *bb;\n\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                              \"Invalid Content-Length\");\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n\n            \/* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             *\/\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                apr_bucket_brigade *bb;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n        }\n\n        \/* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         *\/\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        }\n\n        \/* Since we're about to read data, send 100-Continue if needed.\n         * Only valid on chunked and C-L bodies where the C-L is > 0. *\/\n        if ((ctx->state == BODY_CHUNK ||\n            (ctx->state == BODY_LENGTH && ctx->remaining > 0)) &&\n            f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)) {\n            char *tmp;\n            apr_bucket_brigade *bb;\n\n            tmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL, \" \",\n                              ap_get_status_line(100), CRLF CRLF, NULL);\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n            e = apr_bucket_pool_create(tmp, strlen(tmp), f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_HEAD(bb, e);\n            e = apr_bucket_flush_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n\n            ap_pass_brigade(f->c->output_filters, bb);\n        }\n\n        \/* We can't read the chunk until after sending 100 if required. *\/\n        if (ctx->state == BODY_CHUNK) {\n            char line[30];\n            apr_bucket_brigade *bb;\n            apr_size_t len = 30;\n            apr_off_t brigade_length;\n\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                APR_BLOCK_READ, 0);\n\n            if (rv == APR_SUCCESS) {\n                \/* We have to check the length of the brigade we got back.\n                 * We will not accept partial lines.\n                 *\/\n                rv = apr_brigade_length(bb, 1, &brigade_length);\n                if (rv == APR_SUCCESS\n                    && brigade_length > f->r->server->limit_req_line) {\n                    rv = APR_ENOSPC;\n                }\n                if (rv == APR_SUCCESS) {\n                    rv = apr_brigade_flatten(bb, line, &len);\n                    if (rv == APR_SUCCESS) {\n                        ctx->remaining = get_chunk_size(line);\n                    }\n                }\n            }\n            apr_brigade_cleanup(bb);\n\n            \/* Detect chunksize error (such as overflow) *\/\n            if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                ctx->remaining = 0; \/* Reset it in case we have to\n                                     * come back here later *\/\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool,\n                                           f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n\n            if (!ctx->remaining) {\n                \/* Handle trailers by calling ap_get_mime_headers again! *\/\n                ctx->state = BODY_NONE;\n                ap_get_mime_headers(f->r);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->eos_sent = 1;\n                return APR_SUCCESS;\n            }\n        }\n    }\n\n    if (ctx->eos_sent) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    if (!ctx->remaining) {\n        switch (ctx->state) {\n        case BODY_NONE:\n            break;\n        case BODY_LENGTH:\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        case BODY_CHUNK:\n            {\n                char line[30];\n                apr_bucket_brigade *bb;\n                apr_size_t len = 30;\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n                \/* We need to read the CRLF after the chunk.  *\/\n                rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                    APR_BLOCK_READ, 0);\n                apr_brigade_cleanup(bb);\n\n                if (rv == APR_SUCCESS) {\n                    \/* Read the real chunk line. *\/\n                    rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                        APR_BLOCK_READ, 0);\n                    if (rv == APR_SUCCESS) {\n                        rv = apr_brigade_flatten(bb, line, &len);\n                        if (rv == APR_SUCCESS) {\n                            ctx->remaining = get_chunk_size(line);\n                        }\n                    }\n                    apr_brigade_cleanup(bb);\n                }\n\n                \/* Detect chunksize error (such as overflow) *\/\n                if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                    ctx->remaining = 0; \/* Reset it in case we have to\n                                         * come back here later *\/\n                    e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE,\n                                               NULL, f->r->pool,\n                                               f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(bb, e);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(bb, e);\n                    ctx->eos_sent = 1;\n                    return ap_pass_brigade(f->r->output_filters, bb);\n                }\n\n                if (!ctx->remaining) {\n                    \/* Handle trailers by calling ap_get_mime_headers again! *\/\n                    ctx->state = BODY_NONE;\n                    ap_get_mime_headers(f->r);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    ctx->eos_sent = 1;\n                    return APR_SUCCESS;\n                }\n            }\n            break;\n        }\n    }\n\n    \/* Ensure that the caller can not go over our boundary point. *\/\n    if (ctx->state == BODY_LENGTH || ctx->state == BODY_CHUNK) {\n        if (ctx->remaining < readbytes) {\n            readbytes = ctx->remaining;\n        }\n        AP_DEBUG_ASSERT(readbytes > 0);\n    }\n\n    rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    \/* How many bytes did we just read? *\/\n    apr_brigade_length(b, 0, &totalread);\n\n    \/* If this happens, we have a bucket of unknown length.  Die because\n     * it means our assumptions have changed. *\/\n    AP_DEBUG_ASSERT(totalread >= 0);\n\n    if (ctx->state != BODY_NONE) {\n        ctx->remaining -= totalread;\n    }\n\n    \/* If we have no more bytes remaining on a C-L request,\n     * save the callter a roundtrip to discover EOS.\n     *\/\n    if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n    }\n\n    \/* We have a limit in effect. *\/\n    if (ctx->limit) {\n        \/* FIXME: Note that we might get slightly confused on chunked inputs\n         * as we'd need to compensate for the chunk lengths which may not\n         * really count.  This seems to be up for interpretation.  *\/\n        ctx->limit_used += totalread;\n        if (ctx->limit < ctx->limit_used) {\n            apr_bucket_brigade *bb;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Read content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n            e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                       f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            ctx->eos_sent = 1;\n            return ap_pass_brigade(f->r->output_filters, bb);\n        }\n    }\n\n    return APR_SUCCESS;\n}","idx":13,"target":0}
{"code":"AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n\n    \/* http:\/\/issues.apache.org\/bugzilla\/show_bug.cgi?id=31875\n     * http:\/\/issues.apache.org\/bugzilla\/show_bug.cgi?id=28450\n     *\n     * This is not in fact a URI, it's a path.  That matters in the\n     * case of a leading double-slash.  We need to resolve the issue\n     * by normalising that out before treating it as a URI.\n     *\/\n    while ((uri[0] == '\/') && (uri[1] == '\/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        \/* Simple syntax Errors in URLs are trapped by\n         * parse_uri_components().\n         *\/\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n\n    if (status == APR_SUCCESS) {\n        \/* if it has a scheme we may need to do absoluteURI vhost stuff *\/\n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"\/\");\n\n#if defined(OS2) || defined(WIN32)\n        \/* Handle path translations for OS\/2 and plug security hole.\n         * This will prevent \"http:\/\/www.wherever.com\/..\\..\\\/\" from\n         * returning a directory for the root drive.\n         *\/\n        {\n            char *x;\n\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '\/';\n        }\n#endif \/* OS2 || WIN32 *\/\n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \/* set error status *\/\n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}","idx":0,"target":0}
{"code":"static void *merge_action_dir_configs(apr_pool_t *p, void *basev, void *addv)\n{\n    action_dir_config *base = (action_dir_config *) basev;\n    action_dir_config *add = (action_dir_config *) addv;\n    action_dir_config *new = (action_dir_config *) apr_palloc(p,\n                                  sizeof(action_dir_config));\n    int i;\n\n    new->action_types = apr_table_overlay(p, add->action_types,\n                                       base->action_types);\n\n    for (i = 0; i < METHODS; ++i) {\n        new->scripted[i] = add->scripted[i] ? add->scripted[i]\n                                            : base->scripted[i];\n    }\n\n    new->configured = (base->configured || add->configured);\n    return new;\n}","idx":10,"target":0}
{"code":"apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,\n                            ap_input_mode_t mode, apr_read_type_e block,\n                            apr_off_t readbytes)\n{\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    apr_off_t totalread;\n\n    \/* just get out of the way of things we don't want. *\/\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_palloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n        ctx->remaining = 0;\n        ctx->limit_used = 0;\n        ctx->eos_sent = 0;\n\n        \/* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         *\/\n        if (!f->r->proxyreq) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (!strcasecmp(tenc, \"chunked\")) {\n                ctx->state = BODY_CHUNK;\n            }\n        }\n        else if (lenp) {\n            char *endstr;\n\n            ctx->state = BODY_LENGTH;\n            errno = 0;\n\n            \/* Protects against over\/underflow, non-digit chars in the\n             * string (excluding leading space) (the endstr checks)\n             * and a negative number. *\/\n            if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n                || endstr == lenp || *endstr || ctx->remaining < 0) {\n                apr_bucket_brigade *bb;\n\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                              \"Invalid Content-Length\");\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n\n            \/* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             *\/\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                apr_bucket_brigade *bb;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n        }\n\n        \/* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         *\/\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        }\n\n        \/* Since we're about to read data, send 100-Continue if needed.\n         * Only valid on chunked and C-L bodies where the C-L is > 0. *\/\n        if ((ctx->state == BODY_CHUNK ||\n            (ctx->state == BODY_LENGTH && ctx->remaining > 0)) &&\n            f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)) {\n            char *tmp;\n            apr_bucket_brigade *bb;\n\n            tmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL, \" \",\n                              ap_get_status_line(100), CRLF CRLF, NULL);\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n            e = apr_bucket_pool_create(tmp, strlen(tmp), f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_HEAD(bb, e);\n            e = apr_bucket_flush_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n\n            ap_pass_brigade(f->c->output_filters, bb);\n        }\n\n        \/* We can't read the chunk until after sending 100 if required. *\/\n        if (ctx->state == BODY_CHUNK) {\n            char line[30];\n            apr_bucket_brigade *bb;\n            apr_size_t len = 30;\n            apr_off_t brigade_length;\n\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                APR_BLOCK_READ, 0);\n\n            if (rv == APR_SUCCESS) {\n                \/* We have to check the length of the brigade we got back.\n                 * We will not accept partial lines.\n                 *\/\n                rv = apr_brigade_length(bb, 1, &brigade_length);\n                if (rv == APR_SUCCESS\n                    && brigade_length > f->r->server->limit_req_line) {\n                    rv = APR_ENOSPC;\n                }\n                if (rv == APR_SUCCESS) {\n                    rv = apr_brigade_flatten(bb, line, &len);\n                    if (rv == APR_SUCCESS) {\n                        ctx->remaining = get_chunk_size(line);\n                    }\n                }\n            }\n            apr_brigade_cleanup(bb);\n\n            \/* Detect chunksize error (such as overflow) *\/\n            if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                ctx->remaining = 0; \/* Reset it in case we have to\n                                     * come back here later *\/\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool,\n                                           f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n\n            if (!ctx->remaining) {\n                \/* Handle trailers by calling ap_get_mime_headers again! *\/\n                ctx->state = BODY_NONE;\n                ap_get_mime_headers(f->r);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->eos_sent = 1;\n                return APR_SUCCESS;\n            }\n        }\n    }\n\n    if (ctx->eos_sent) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    if (!ctx->remaining) {\n        switch (ctx->state) {\n        case BODY_NONE:\n            break;\n        case BODY_LENGTH:\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        case BODY_CHUNK:\n            {\n                char line[30];\n                apr_bucket_brigade *bb;\n                apr_size_t len = 30;\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n                \/* We need to read the CRLF after the chunk.  *\/\n                rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                    APR_BLOCK_READ, 0);\n                apr_brigade_cleanup(bb);\n\n                if (rv == APR_SUCCESS) {\n                    \/* Read the real chunk line. *\/\n                    rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                        APR_BLOCK_READ, 0);\n                    if (rv == APR_SUCCESS) {\n                        rv = apr_brigade_flatten(bb, line, &len);\n                        if (rv == APR_SUCCESS) {\n                            ctx->remaining = get_chunk_size(line);\n                        }\n                    }\n                    apr_brigade_cleanup(bb);\n                }\n\n                \/* Detect chunksize error (such as overflow) *\/\n                if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                    ctx->remaining = 0; \/* Reset it in case we have to\n                                         * come back here later *\/\n                    e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE,\n                                               NULL, f->r->pool,\n                                               f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(bb, e);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(bb, e);\n                    ctx->eos_sent = 1;\n                    return ap_pass_brigade(f->r->output_filters, bb);\n                }\n\n                if (!ctx->remaining) {\n                    \/* Handle trailers by calling ap_get_mime_headers again! *\/\n                    ctx->state = BODY_NONE;\n                    ap_get_mime_headers(f->r);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    ctx->eos_sent = 1;\n                    return APR_SUCCESS;\n                }\n            }\n            break;\n        }\n    }\n\n    \/* Ensure that the caller can not go over our boundary point. *\/\n    if (ctx->state == BODY_LENGTH || ctx->state == BODY_CHUNK) {\n        if (ctx->remaining < readbytes) {\n            readbytes = ctx->remaining;\n        }\n        AP_DEBUG_ASSERT(readbytes > 0);\n    }\n\n    rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    \/* How many bytes did we just read? *\/\n    apr_brigade_length(b, 0, &totalread);\n\n    \/* If this happens, we have a bucket of unknown length.  Die because\n     * it means our assumptions have changed. *\/\n    AP_DEBUG_ASSERT(totalread >= 0);\n\n    if (ctx->state != BODY_NONE) {\n        ctx->remaining -= totalread;\n    }\n\n    \/* If we have no more bytes remaining on a C-L request,\n     * save the callter a roundtrip to discover EOS.\n     *\/\n    if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n    }\n\n    \/* We have a limit in effect. *\/\n    if (ctx->limit) {\n        \/* FIXME: Note that we might get slightly confused on chunked inputs\n         * as we'd need to compensate for the chunk lengths which may not\n         * really count.  This seems to be up for interpretation.  *\/\n        ctx->limit_used += totalread;\n        if (ctx->limit < ctx->limit_used) {\n            apr_bucket_brigade *bb;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Read content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n            e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                       f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            ctx->eos_sent = 1;\n            return ap_pass_brigade(f->r->output_filters, bb);\n        }\n    }\n\n    return APR_SUCCESS;\n}","idx":14,"target":0}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (INT_MAX - 16))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    return (char *)realloc((char *)ptr - diff, size + diff) + diff;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size, 32);\n#else\n    return realloc(ptr, size);\n#endif\n}","idx":635446,"target":1}
{"code":"static int biquad_init_coeffs(void *avc, struct FFIIRFilterCoeffs *c,\n                              enum IIRFilterMode filt_mode, int order,\n                              float cutoff_ratio, float stopband)\n{\n    double cos_w0, sin_w0;\n    double a0, x0, x1;\n\n    if (filt_mode != FF_FILTER_MODE_HIGHPASS &&\n        filt_mode != FF_FILTER_MODE_LOWPASS) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter currently only supports \"\n               \"high-pass and low-pass filter modes\\n\");\n        return -1;\n    }\n    if (order != 2) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter must have order of 2\\n\");\n        return -1;\n    }\n\n    cos_w0 = cos(M_PI * cutoff_ratio);\n    sin_w0 = sin(M_PI * cutoff_ratio);\n\n    a0 = 1.0 + (sin_w0 \/ 2.0);\n\n    if (filt_mode == FF_FILTER_MODE_HIGHPASS) {\n        c->gain  =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x1       = (-(1.0 + cos_w0))        \/ a0;\n    } else { \/\/ FF_FILTER_MODE_LOWPASS\n        c->gain  =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x1       =   (1.0 - cos_w0)         \/ a0;\n    }\n    c->cy[0] = (-1.0 + (sin_w0 \/ 2.0)) \/ a0;\n    c->cy[1] =  (2.0 *  cos_w0)        \/ a0;\n\n    \/\/ divide by gain to make the x coeffs integers.\n    \/\/ during filtering, the delay state will include the gain multiplication\n    c->cx[0] = lrintf(x0 \/ c->gain);\n    c->cx[1] = lrintf(x1 \/ c->gain);\n\n    return 0;\n}","idx":634857,"target":1}
{"code":"static inline void init_get_bits(GetBitContext *s, const uint8_t *buffer,\n                                 int bit_size)\n{\n    int buffer_size = (bit_size+7)>>3;\n    if (buffer_size < 0 || bit_size < 0) {\n        buffer_size = bit_size = 0;\n        buffer = NULL;\n    }\n\n    s->buffer       = buffer;\n    s->size_in_bits = bit_size;\n#if !UNCHECKED_BITSTREAM_READER\n    s->size_in_bits_plus8 = bit_size + 8;\n#endif\n    s->buffer_end   = buffer + buffer_size;\n    s->index        = 0;\n}","idx":633355,"target":1}
{"code":"tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t\/* tsize_t tilesize=0; *\/\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t\/* Fail if prior error (in particular, can't trust tiff_datasize) *\/\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count > 4) {\n                                        int retTIFFReadRawTile;\n                    \/* Ignore EOI marker of JpegTables *\/\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    \/* Store last 2 bytes of the JpegTables *\/\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    \/* Overwrite SOI marker of image scan with previously *\/\n                    \/* saved end of JpegTables *\/\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t\/* tilesize=septilesize*t2p->tiff_samplesperpixel; *\/\n\t\t\ttilecount=septilecount\/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer,\n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tif ((uint64)t2p->tiff_datasize < (uint64)TIFFTileRowSize(input) * (uint64)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength) {\n\t\t\t\/* we don't know how to handle PLANARCONFIG_CONTIG, PHOTOMETRIC_YCBCR with 3 samples per pixel *\/\n\t\t\tTIFFWarning(\n\t\t\t\tTIFF2PDF_MODULE,\n\t\t\t\t\"Don't know how to collapse tile to the left\");\n\t\t} else {\n\t\t\tt2p_tile_collapse_left(\n\t\t\t\tbuffer,\n\t\t\t\tTIFFTileRowSize(input),\n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth,\n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); \/* JPEGTABLESMODE_NONE *\/\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality\/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality \/ 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}","idx":43603,"target":1}
{"code":"static\nECDSA_SIG *SM2_sig_gen(const EC_KEY *key, const BIGNUM *e)\n{\n    const BIGNUM *dA = EC_KEY_get0_private_key(key);\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n\n    ECDSA_SIG *sig = NULL;\n    EC_POINT *kG = NULL;\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *rk = NULL;\n    BIGNUM *r = NULL;\n    BIGNUM *s = NULL;\n    BIGNUM *x1 = NULL;\n    BIGNUM *tmp = NULL;\n\n    kG = EC_POINT_new(group);\n    if (kG == NULL)\n        goto done;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto done;\n\n    BN_CTX_start(ctx);\n\n    k = BN_CTX_get(ctx);\n    rk = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n\n    if (tmp == NULL)\n        goto done;\n\n    \/* These values are returned and so should not be allocated out of the context *\/\n    r = BN_new();\n    s = BN_new();\n\n    if (r == NULL || s == NULL)\n        goto done;\n\n    for (;;) {\n        BN_priv_rand_range(k, order);\n\n        if (EC_POINT_mul(group, kG, k, NULL, NULL, ctx) == 0)\n            goto done;\n\n        if (EC_POINT_get_affine_coordinates_GFp(group, kG, x1, NULL, ctx) == 0)\n            goto done;\n\n        if (BN_mod_add(r, e, x1, order, ctx) == 0)\n            goto done;\n\n        \/* try again if r == 0 or r+k == n *\/\n        if (BN_is_zero(r))\n            continue;\n\n        BN_add(rk, r, k);\n\n        if (BN_cmp(rk, order) == 0)\n            continue;\n\n        BN_add(s, dA, BN_value_one());\n        BN_mod_inverse(s, s, order, ctx);\n\n        BN_mod_mul(tmp, dA, r, order, ctx);\n        BN_sub(tmp, k, tmp);\n\n        BN_mod_mul(s, s, tmp, order, ctx);\n\n        sig = ECDSA_SIG_new();\n\n        if (sig == NULL)\n            goto done;\n\n         \/* takes ownership of r and s *\/\n        ECDSA_SIG_set0(sig, r, s);\n        break;\n    }\n\n done:\n\n    if (sig == NULL) {\n        BN_free(r);\n        BN_free(s);\n    }\n\n    BN_CTX_free(ctx);\n    EC_POINT_free(kG);\n    return sig;\n\n}","idx":394008,"target":1}
{"code":"int BN_num_bits_word(BN_ULONG l)\n{\n    static const unsigned char bits[256] = {\n        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    };\n\n#if defined(SIXTY_FOUR_BIT_LONG)\n    if (l & 0xffffffff00000000L) {\n        if (l & 0xffff000000000000L) {\n            if (l & 0xff00000000000000L) {\n                return (bits[(int)(l >> 56)] + 56);\n            } else\n                return (bits[(int)(l >> 48)] + 48);\n        } else {\n            if (l & 0x0000ff0000000000L) {\n                return (bits[(int)(l >> 40)] + 40);\n            } else\n                return (bits[(int)(l >> 32)] + 32);\n        }\n    } else\n#else\n# ifdef SIXTY_FOUR_BIT\n    if (l & 0xffffffff00000000LL) {\n        if (l & 0xffff000000000000LL) {\n            if (l & 0xff00000000000000LL) {\n                return (bits[(int)(l >> 56)] + 56);\n            } else\n                return (bits[(int)(l >> 48)] + 48);\n        } else {\n            if (l & 0x0000ff0000000000LL) {\n                return (bits[(int)(l >> 40)] + 40);\n            } else\n                return (bits[(int)(l >> 32)] + 32);\n        }\n    } else\n# endif\n#endif\n    {\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\n        if (l & 0xffff0000L) {\n            if (l & 0xff000000L)\n                return (bits[(int)(l >> 24L)] + 24);\n            else\n                return (bits[(int)(l >> 16L)] + 16);\n        } else\n#endif\n        {\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\n            if (l & 0xff00L)\n                return (bits[(int)(l >> 8)] + 8);\n            else\n#endif\n                return (bits[(int)(l)]);\n        }\n    }\n}","idx":392213,"target":1}
{"code":"void CRYPTO_destroy_dynlockid(int i)\n\t{\n\tCRYPTO_dynlock *pointer = NULL;\n\tif (i)\n\t\ti = -i-1;\n\tif (dynlock_destroy_callback == NULL)\n\t\treturn;\n\n\tCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))\n\t\treturn;\n\tpointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\n\tif (pointer != NULL)\n\t\t{\n\t\t--pointer->references;\n#ifdef REF_CHECK\n\t\tif (pointer->references < 0)\n\t\t\t{\n\t\t\tfprintf(stderr,\"CRYPTO_destroy_dynlockid, bad reference count\\n\");\n\t\t\tabort();\n\t\t\t}\n\t\telse\n#endif\n\t\t\tif (pointer->references <= 0)\n\t\t\t\t{\n\t\t\t\tsk_CRYPTO_dynlock_set(dyn_locks, i, NULL);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tpointer = NULL;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (pointer)\n\t\t{\n\t\tdynlock_destroy_callback(pointer->data,__FILE__,__LINE__);\n\t\tOPENSSL_free(pointer);\n\t\t}\n\t}","idx":391838,"target":1}
{"code":"void PEM_dek_info(char *buf, const char *type, int len, char *str)\n\t{\n\tstatic const unsigned char map[17]=\"0123456789ABCDEF\";\n\tlong i;\n\tint j;\n\n\tstrcat(buf,\"DEK-Info: \");\n\tstrcat(buf,type);\n\tstrcat(buf,\",\");\n\tj=strlen(buf);\n\tfor (i=0; i<len; i++)\n\t\t{\n\t\tbuf[j+i*2]  =map[(str[i]>>4)&0x0f];\n\t\tbuf[j+i*2+1]=map[(str[i]   )&0x0f];\n\t\t}\n\tbuf[j+i*2]='\\n';\n\tbuf[j+i*2+1]='\\0';\n\t}","idx":387288,"target":1}
{"code":"BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n        {\n\tBN_ULONG t1,t2;\n\tint c=0;\n\n\tassert(n >= 0);\n\tif (n <= 0) return((BN_ULONG)0);\n\n\tfor (;;)\n\t\t{\n\t\tt1=a[0]; t2=b[0];\n\t\tr[0]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[1]; t2=b[1];\n\t\tr[1]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[2]; t2=b[2];\n\t\tr[2]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[3]; t2=b[3];\n\t\tr[3]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\ta+=4;\n\t\tb+=4;\n\t\tr+=4;\n\t\t}\n\treturn(c);\n\t}","idx":392600,"target":1}
{"code":"static int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           int max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned int i;\n\n    if (max-- < 1)\n        return (0);\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (max < (int)i)\n                return 0;\n            \/* Skip leading zeroes *\/\n            while (i && *p == 0) {\n                p++;\n                i--;\n            }\n            if (i > sizeof(long))\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return (1);\n}","idx":392777,"target":1}
