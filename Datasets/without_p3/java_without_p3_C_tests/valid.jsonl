{"code": "public TokenValidatorResponse validateToken(TokenValidatorParameters tokenParameters) {\n        LOG.fine(\"Validating SAML Token\");\n        STSPropertiesMBean stsProperties = tokenParameters.getStsProperties();\n        Crypto sigCrypto = stsProperties.getSignatureCrypto();\n        CallbackHandler callbackHandler = stsProperties.getCallbackHandler();\n        \n        TokenValidatorResponse response = new TokenValidatorResponse();\n        ReceivedToken validateTarget = tokenParameters.getToken();\n        validateTarget.setState(STATE.INVALID);\n        response.setToken(validateTarget);\n        \n        if (!validateTarget.isDOMElement()) {\n            return response;\n        }\n        \n        try {\n            Element validateTargetElement = (Element)validateTarget.getToken();\n            SamlAssertionWrapper assertion = new SamlAssertionWrapper(validateTargetElement);\n            \n            SAMLTokenPrincipal samlPrincipal = new SAMLTokenPrincipalImpl(assertion);\n            response.setPrincipal(samlPrincipal);\n            \n            SecurityToken secToken = null;\n            byte[] signatureValue = assertion.getSignatureValue();\n            if (tokenParameters.getTokenStore() != null && signatureValue != null\n                && signatureValue.length > 0) {\n                int hash = Arrays.hashCode(signatureValue);\n                secToken = tokenParameters.getTokenStore().getToken(Integer.toString(hash));\n                if (secToken != null && secToken.getTokenHash() != hash) {\n                    secToken = null;\n                }\n            }\n            if (secToken != null && secToken.isExpired()) {\n                LOG.fine(\"Token: \" + secToken.getId() + \" is in the cache but expired - revalidating\");\n                secToken = null;\n            }\n            \n            if (secToken == null) {\n                if (!assertion.isSigned()) {\n                    LOG.log(Level.WARNING, \"The received assertion is not signed, and therefore not trusted\");\n                    return response;\n                }\n                \n                RequestData requestData = new RequestData();\n                requestData.setSigVerCrypto(sigCrypto);\n                WSSConfig wssConfig = WSSConfig.getNewInstance();\n                requestData.setWssConfig(wssConfig);\n                requestData.setCallbackHandler(callbackHandler);\n                requestData.setMsgContext(tokenParameters.getWebServiceContext().getMessageContext());\n\n                WSDocInfo docInfo = new WSDocInfo(validateTargetElement.getOwnerDocument());\n                \n                // Verify the signature\n                Signature sig = assertion.getSignature();\n                KeyInfo keyInfo = sig.getKeyInfo();\n                SAMLKeyInfo samlKeyInfo = \n                    SAMLUtil.getCredentialFromKeyInfo(\n                        keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, docInfo), sigCrypto\n                    );\n                assertion.verifySignature(samlKeyInfo);\n                \n                // Validate the assertion against schemas/profiles\n                validateAssertion(assertion);\n\n                // Now verify trust on the signature\n                Credential trustCredential = new Credential();\n                trustCredential.setPublicKey(samlKeyInfo.getPublicKey());\n                trustCredential.setCertificates(samlKeyInfo.getCerts());\n    \n                trustCredential = validator.validate(trustCredential, requestData);\n\n                // Finally check that subject DN of the signing certificate matches a known constraint\n                X509Certificate cert = null;\n                if (trustCredential.getCertificates() != null) {\n                    cert = trustCredential.getCertificates()[0];\n                }\n                \n                if (!certConstraints.matches(cert)) {\n                    return response;\n                }\n                \n            }\n            \n            // Parse roles from the validated token\n            if (samlRoleParser != null) {\n                Set<Principal> roles = \n                    samlRoleParser.parseRolesFromAssertion(samlPrincipal, null, assertion);\n                response.setRoles(roles);\n            }\n           \n            // Get the realm of the SAML token\n            String tokenRealm = null;\n            if (samlRealmCodec != null) {\n                tokenRealm = samlRealmCodec.getRealmFromToken(assertion);\n                // verify the realm against the cached token\n                if (secToken != null) {\n                    Properties props = secToken.getProperties();\n                    if (props != null) {\n                        String cachedRealm = props.getProperty(STSConstants.TOKEN_REALM);\n                        if (cachedRealm != null && !tokenRealm.equals(cachedRealm)) {\n                            return response;\n                        }\n                    }\n                }\n            }\n            response.setTokenRealm(tokenRealm);\n            \n            if (!validateConditions(assertion, validateTarget)) {\n                return response;\n            }\n            \n            // Store the successfully validated token in the cache\n            if (secToken == null) {\n                storeTokenInCache(\n                    tokenParameters.getTokenStore(), assertion, tokenParameters.getPrincipal(), tokenRealm\n                );\n            }\n            \n            // Add the SamlAssertionWrapper to the properties, as the claims are required to be transformed\n            Map<String, Object> addProps = new HashMap<String, Object>();\n            addProps.put(SamlAssertionWrapper.class.getName(), assertion);\n            response.setAdditionalProperties(addProps);\n            \n            validateTarget.setState(STATE.VALID);\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n        }\n\n        return response;\n    }", "code_tokens": ["public", "TokenValidatorResponse", "validateToken", "(", "TokenValidatorParameters", "tokenParameters", ")", "{", "LOG", ".", "fine", "(", "\"", "Validating SAML Token", "\"", ")", ";", "STSPropertiesMBean", "stsProperties", "=", "tokenParameters", ".", "getStsProperties", "(", ")", ";", "Crypto", "sigCrypto", "=", "stsProperties", ".", "getSignatureCrypto", "(", ")", ";", "CallbackHandler", "callbackHandler", "=", "stsProperties", ".", "getCallbackHandler", "(", ")", ";", "TokenValidatorResponse", "response", "=", "new", "TokenValidatorResponse", "(", ")", ";", "ReceivedToken", "validateTarget", "=", "tokenParameters", ".", "getToken", "(", ")", ";", "validateTarget", ".", "setState", "(", "STATE", ".", "INVALID", ")", ";", "response", ".", "setToken", "(", "validateTarget", ")", ";", "if", "(", "!", "validateTarget", ".", "isDOMElement", "(", ")", ")", "{", "return", "response", ";", "}", "try", "{", "Element", "validateTargetElement", "=", "(", "Element", ")", "validateTarget", ".", "getToken", "(", ")", ";", "SamlAssertionWrapper", "assertion", "=", "new", "SamlAssertionWrapper", "(", "validateTargetElement", ")", ";", "SAMLTokenPrincipal", "samlPrincipal", "=", "new", "SAMLTokenPrincipalImpl", "(", "assertion", ")", ";", "response", ".", "setPrincipal", "(", "samlPrincipal", ")", ";", "SecurityToken", "secToken", "=", "null", ";", "byte", "[", "]", "signatureValue", "=", "assertion", ".", "getSignatureValue", "(", ")", ";", "if", "(", "tokenParameters", ".", "getTokenStore", "(", ")", "!=", "null", "&&", "signatureValue", "!=", "null", "&&", "signatureValue", ".", "length", ">", "0", ")", "{", "int", "hash", "=", "Arrays", ".", "hashCode", "(", "signatureValue", ")", ";", "secToken", "=", "tokenParameters", ".", "getTokenStore", "(", ")", ".", "getToken", "(", "Integer", ".", "toString", "(", "hash", ")", ")", ";", "if", "(", "secToken", "!=", "null", "&&", "secToken", ".", "getTokenHash", "(", ")", "!=", "hash", ")", "{", "secToken", "=", "null", ";", "}", "}", "if", "(", "secToken", "!=", "null", "&&", "secToken", ".", "isExpired", "(", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "Token: ", "\"", "+", "secToken", ".", "getId", "(", ")", "+", "\"", " is in the cache but expired - revalidating", "\"", ")", ";", "secToken", "=", "null", ";", "}", "if", "(", "secToken", "==", "null", ")", "{", "if", "(", "!", "assertion", ".", "isSigned", "(", ")", ")", "{", "LOG", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "The received assertion is not signed, and therefore not trusted", "\"", ")", ";", "return", "response", ";", "}", "RequestData", "requestData", "=", "new", "RequestData", "(", ")", ";", "requestData", ".", "setSigVerCrypto", "(", "sigCrypto", ")", ";", "WSSConfig", "wssConfig", "=", "WSSConfig", ".", "getNewInstance", "(", ")", ";", "requestData", ".", "setWssConfig", "(", "wssConfig", ")", ";", "requestData", ".", "setCallbackHandler", "(", "callbackHandler", ")", ";", "requestData", ".", "setMsgContext", "(", "tokenParameters", ".", "getWebServiceContext", "(", ")", ".", "getMessageContext", "(", ")", ")", ";", "WSDocInfo", "docInfo", "=", "new", "WSDocInfo", "(", "validateTargetElement", ".", "getOwnerDocument", "(", ")", ")", ";", "Signature", "sig", "=", "assertion", ".", "getSignature", "(", ")", ";", "KeyInfo", "keyInfo", "=", "sig", ".", "getKeyInfo", "(", ")", ";", "SAMLKeyInfo", "samlKeyInfo", "=", "SAMLUtil", ".", "getCredentialFromKeyInfo", "(", "keyInfo", ".", "getDOM", "(", ")", ",", "new", "WSSSAMLKeyInfoProcessor", "(", "requestData", ",", "docInfo", ")", ",", "sigCrypto", ")", ";", "assertion", ".", "verifySignature", "(", "samlKeyInfo", ")", ";", "validateAssertion", "(", "assertion", ")", ";", "Credential", "trustCredential", "=", "new", "Credential", "(", ")", ";", "trustCredential", ".", "setPublicKey", "(", "samlKeyInfo", ".", "getPublicKey", "(", ")", ")", ";", "trustCredential", ".", "setCertificates", "(", "samlKeyInfo", ".", "getCerts", "(", ")", ")", ";", "trustCredential", "=", "validator", ".", "validate", "(", "trustCredential", ",", "requestData", ")", ";", "X509Certificate", "cert", "=", "null", ";", "if", "(", "trustCredential", ".", "getCertificates", "(", ")", "!=", "null", ")", "{", "cert", "=", "trustCredential", ".", "getCertificates", "(", ")", "[", "0", "]", ";", "}", "if", "(", "!", "certConstraints", ".", "matches", "(", "cert", ")", ")", "{", "return", "response", ";", "}", "}", "if", "(", "samlRoleParser", "!=", "null", ")", "{", "Set", "<", "Principal", ">", "roles", "=", "samlRoleParser", ".", "parseRolesFromAssertion", "(", "samlPrincipal", ",", "null", ",", "assertion", ")", ";", "response", ".", "setRoles", "(", "roles", ")", ";", "}", "String", "tokenRealm", "=", "null", ";", "if", "(", "samlRealmCodec", "!=", "null", ")", "{", "tokenRealm", "=", "samlRealmCodec", ".", "getRealmFromToken", "(", "assertion", ")", ";", "if", "(", "secToken", "!=", "null", ")", "{", "Properties", "props", "=", "secToken", ".", "getProperties", "(", ")", ";", "if", "(", "props", "!=", "null", ")", "{", "String", "cachedRealm", "=", "props", ".", "getProperty", "(", "STSConstants", ".", "TOKEN_REALM", ")", ";", "if", "(", "cachedRealm", "!=", "null", "&&", "!", "tokenRealm", ".", "equals", "(", "cachedRealm", ")", ")", "{", "return", "response", ";", "}", "}", "}", "}", "response", ".", "setTokenRealm", "(", "tokenRealm", ")", ";", "if", "(", "!", "validateConditions", "(", "assertion", ",", "validateTarget", ")", ")", "{", "return", "response", ";", "}", "if", "(", "secToken", "==", "null", ")", "{", "storeTokenInCache", "(", "tokenParameters", ".", "getTokenStore", "(", ")", ",", "assertion", ",", "tokenParameters", ".", "getPrincipal", "(", ")", ",", "tokenRealm", ")", ";", "}", "Map", "<", "String", ",", "Object", ">", "addProps", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "addProps", ".", "put", "(", "SamlAssertionWrapper", ".", "class", ".", "getName", "(", ")", ",", "assertion", ")", ";", "response", ".", "setAdditionalProperties", "(", "addProps", ")", ";", "validateTarget", ".", "setState", "(", "STATE", ".", "VALID", ")", ";", "}", "catch", "(", "WSSecurityException", "ex", ")", "{", "LOG", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "\"", ",", "ex", ")", ";", "}", "return", "response", ";", "}"], "idx": 10856, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "b4b9a010bb23059251400455afabddee15b46127", "function_name": "validateToken", "body_hash": "b0ae63625a8799d89f0967b0581c8bfba865ced2"}
{"code": "protected Configuration createConfiguration(ServletContext servletContext) throws TemplateException {\n        Configuration configuration = new Configuration(Configuration.VERSION_2_3_0);\n\n        configuration.setTemplateExceptionHandler(TemplateExceptionHandler.HTML_DEBUG_HANDLER);\n\n        if (mruMaxStrongSize > 0) {\n            configuration.setSetting(Configuration.CACHE_STORAGE_KEY, \"strong:\" + mruMaxStrongSize);\n        }\n        if (templateUpdateDelay != null) {\n            configuration.setSetting(Configuration.TEMPLATE_UPDATE_DELAY_KEY, templateUpdateDelay);\n        }\n        if (encoding != null) {\n            configuration.setDefaultEncoding(encoding);\n        }\n        configuration.setLocalizedLookup(false);\n        configuration.setWhitespaceStripping(true);\n\n        return configuration;\n    }", "code_tokens": ["protected", "Configuration", "createConfiguration", "(", "ServletContext", "servletContext", ")", "throws", "TemplateException", "{", "Configuration", "configuration", "=", "new", "Configuration", "(", "Configuration", ".", "VERSION_2_3_0", ")", ";", "configuration", ".", "setTemplateExceptionHandler", "(", "TemplateExceptionHandler", ".", "HTML_DEBUG_HANDLER", ")", ";", "if", "(", "mruMaxStrongSize", ">", "0", ")", "{", "configuration", ".", "setSetting", "(", "Configuration", ".", "CACHE_STORAGE_KEY", ",", "\"", "strong:", "\"", "+", "mruMaxStrongSize", ")", ";", "}", "if", "(", "templateUpdateDelay", "!=", "null", ")", "{", "configuration", ".", "setSetting", "(", "Configuration", ".", "TEMPLATE_UPDATE_DELAY_KEY", ",", "templateUpdateDelay", ")", ";", "}", "if", "(", "encoding", "!=", "null", ")", "{", "configuration", ".", "setDefaultEncoding", "(", "encoding", ")", ";", "}", "configuration", ".", "setLocalizedLookup", "(", "false", ")", ";", "configuration", ".", "setWhitespaceStripping", "(", "true", ")", ";", "return", "configuration", ";", "}"], "idx": 6218, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "2306f5f7fad7f0157f216f34331238feb0539fa", "function_name": "createConfiguration", "body_hash": "716e658eeb27565666cc9202c46f78193c470110"}
{"code": "default Argument<?> getErrorType(MediaType mediaType) {\n        if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {\n            return Argument.of(JsonError.class);\n        } else if (mediaType.equals(MediaType.APPLICATION_VND_ERROR_TYPE)) {\n            return Argument.of(VndError.class);\n        } else {\n            return Argument.STRING;\n        }\n    }", "code_tokens": ["default", "Argument", "<", "?", ">", "getErrorType", "(", "MediaType", "mediaType", ")", "{", "if", "(", "mediaType", ".", "equals", "(", "MediaType", ".", "APPLICATION_JSON_TYPE", ")", ")", "{", "return", "Argument", ".", "of", "(", "JsonError", ".", "class", ")", ";", "}", "else", "if", "(", "mediaType", ".", "equals", "(", "MediaType", ".", "APPLICATION_VND_ERROR_TYPE", ")", ")", "{", "return", "Argument", ".", "of", "(", "VndError", ".", "class", ")", ";", "}", "else", "{", "return", "Argument", ".", "STRING", ";", "}", "}"], "idx": 52565, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3", "function_name": "getErrorType", "body_hash": "95ddc079018e90b328dacdcda3f6cb4f3f05b39b"}
{"code": "private RootBeanDefinition registerMessageBroker(Element brokerElement,\n\t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n\t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate, RuntimeBeanReference userRegistry,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n\t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n\n\t\tConstructorArgumentValues cargs = new ConstructorArgumentValues();\n\t\tcargs.addIndexedArgumentValue(0, inChannel);\n\t\tcargs.addIndexedArgumentValue(1, outChannel);\n\t\tcargs.addIndexedArgumentValue(2, brokerChannel);\n\n\t\tRootBeanDefinition brokerDef;\n\t\tif (simpleBrokerElem != null) {\n\t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n\t\t\tcargs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cargs, null);\n\t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n\t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n\t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n\t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n\t\t\t}\n\t\t}\n\t\telse if (brokerRelayElem != null) {\n\t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n\t\t\tcargs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\n\t\t\tMutablePropertyValues values = new MutablePropertyValues();\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n\t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n\t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n\t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n\t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n\t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n\t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n\t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n\t\t\t}\n\t\t\tManagedMap<String, Object> map = new ManagedMap<>();\n\t\t\tmap.setSource(source);\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n\t\t\t\tmap.put(destination, userDestHandler);\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n\t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n\t\t\t\t\t\tbrokerTemplate, destination, context, source));\n\t\t\t}\n\t\t\tif (!map.isEmpty()) {\n\t\t\t\tvalues.add(\"systemSubscriptions\", map);\n\t\t\t}\n\t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n\t\t\tbrokerDef = new RootBeanDefinition(handlerType, cargs, values);\n\t\t}\n\t\telse {\n\t\t\t// Should not happen\n\t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n\t\t}\n\t\tregisterBeanDef(brokerDef, context, source);\n\t\treturn brokerDef;\n\t}", "code_tokens": ["private", "RootBeanDefinition", "registerMessageBroker", "(", "Element", "brokerElement", ",", "RuntimeBeanReference", "inChannel", ",", "RuntimeBeanReference", "outChannel", ",", "RuntimeBeanReference", "brokerChannel", ",", "Object", "userDestHandler", ",", "RuntimeBeanReference", "brokerTemplate", ",", "RuntimeBeanReference", "userRegistry", ",", "ParserContext", "context", ",", "@", "Nullable", "Object", "source", ")", "{", "Element", "simpleBrokerElem", "=", "DomUtils", ".", "getChildElementByTagName", "(", "brokerElement", ",", "\"", "simple-broker", "\"", ")", ";", "Element", "brokerRelayElem", "=", "DomUtils", ".", "getChildElementByTagName", "(", "brokerElement", ",", "\"", "stomp-broker-relay", "\"", ")", ";", "ConstructorArgumentValues", "cargs", "=", "new", "ConstructorArgumentValues", "(", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "0", ",", "inChannel", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "1", ",", "outChannel", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "2", ",", "brokerChannel", ")", ";", "RootBeanDefinition", "brokerDef", ";", "if", "(", "simpleBrokerElem", "!=", "null", ")", "{", "String", "prefix", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "prefix", "\"", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "3", ",", "Arrays", ".", "asList", "(", "StringUtils", ".", "tokenizeToStringArray", "(", "prefix", ",", "\"", ",", "\"", ")", ")", ")", ";", "brokerDef", "=", "new", "RootBeanDefinition", "(", "SimpleBrokerMessageHandler", ".", "class", ",", "cargs", ",", "null", ")", ";", "if", "(", "brokerElement", ".", "hasAttribute", "(", "\"", "path-matcher", "\"", ")", ")", "{", "String", "pathMatcherRef", "=", "brokerElement", ".", "getAttribute", "(", "\"", "path-matcher", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "pathMatcher", "\"", ",", "new", "RuntimeBeanReference", "(", "pathMatcherRef", ")", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "scheduler", "\"", ")", ")", "{", "String", "scheduler", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "scheduler", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "taskScheduler", "\"", ",", "new", "RuntimeBeanReference", "(", "scheduler", ")", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "heartbeat", "\"", ")", ")", "{", "String", "heartbeatValue", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "heartbeat", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "heartbeatValue", "\"", ",", "heartbeatValue", ")", ";", "}", "}", "else", "if", "(", "brokerRelayElem", "!=", "null", ")", "{", "String", "prefix", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "prefix", "\"", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "3", ",", "Arrays", ".", "asList", "(", "StringUtils", ".", "tokenizeToStringArray", "(", "prefix", ",", "\"", ",", "\"", ")", ")", ")", ";", "MutablePropertyValues", "values", "=", "new", "MutablePropertyValues", "(", ")", ";", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "relay-host", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "relayHost", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "relay-host", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "relay-port", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "relayPort", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "relay-port", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "client-login", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "clientLogin", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "client-login", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "client-passcode", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "clientPasscode", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "client-passcode", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "system-login", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemLogin", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "system-login", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "system-passcode", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemPasscode", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "system-passcode", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "heartbeat-send-interval", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemHeartbeatSendInterval", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "heartbeat-send-interval", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "heartbeat-receive-interval", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemHeartbeatReceiveInterval", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "heartbeat-receive-interval", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "virtual-host", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "virtualHost", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "virtual-host", "\"", ")", ")", ";", "}", "ManagedMap", "<", "String", ",", "Object", ">", "map", "=", "new", "ManagedMap", "<", ">", "(", ")", ";", "map", ".", "setSource", "(", "source", ")", ";", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "user-destination-broadcast", "\"", ")", ")", "{", "String", "destination", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "user-destination-broadcast", "\"", ")", ";", "map", ".", "put", "(", "destination", ",", "userDestHandler", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "user-registry-broadcast", "\"", ")", ")", "{", "String", "destination", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "user-registry-broadcast", "\"", ")", ";", "map", ".", "put", "(", "destination", ",", "registerUserRegistryMessageHandler", "(", "userRegistry", ",", "brokerTemplate", ",", "destination", ",", "context", ",", "source", ")", ")", ";", "}", "if", "(", "!", "map", ".", "isEmpty", "(", ")", ")", "{", "values", ".", "add", "(", "\"", "systemSubscriptions", "\"", ",", "map", ")", ";", "}", "Class", "<", "?", ">", "handlerType", "=", "StompBrokerRelayMessageHandler", ".", "class", ";", "brokerDef", "=", "new", "RootBeanDefinition", "(", "handlerType", ",", "cargs", ",", "values", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Neither <simple-broker> nor <stomp-broker-relay> elements found.", "\"", ")", ";", "}", "registerBeanDef", "(", "brokerDef", ",", "context", ",", "source", ")", ";", "return", "brokerDef", ";", "}"], "idx": 103471, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "ff2228fdaf131d57b5c8c5918ee8d07c6dd9bba", "function_name": "registerMessageBroker", "body_hash": "c5184d94696e5099872fbf7b510a0491b9eec3fa"}
{"code": "PublicKey getRemotePublicKey(String nodename) {\n    String url = cores.getZkController().getZkStateReader().getBaseUrlForNodeName(nodename);\n    try {\n      String uri = url + PATH + \"?wt=json&omitHeader=true\";\n      log.debug(\"Fetching fresh public key from : {}\",uri);\n      HttpResponse rsp = cores.getUpdateShardHandler().getHttpClient().execute(new HttpGet(uri));\n      byte[] bytes = EntityUtils.toByteArray(rsp.getEntity());\n      Map m = (Map) Utils.fromJSON(bytes);\n      String key = (String) m.get(\"key\");\n      if (key == null) {\n        log.error(\"No key available from \" + url + PATH);\n        return null;\n      } else {\n        log.info(\"New Key obtained from  node: {} / {}\", nodename, key);\n      }\n      PublicKey pubKey = CryptoKeys.deserializeX509PublicKey(key);\n      keyCache.put(nodename, pubKey);\n      return pubKey;\n    } catch (Exception e) {\n      log.error(\"Exception trying to get public key from : \" + url, e);\n      return null;\n    }\n\n  }", "code_tokens": ["PublicKey", "getRemotePublicKey", "(", "String", "nodename", ")", "{", "String", "url", "=", "cores", ".", "getZkController", "(", ")", ".", "getZkStateReader", "(", ")", ".", "getBaseUrlForNodeName", "(", "nodename", ")", ";", "try", "{", "String", "uri", "=", "url", "+", "PATH", "+", "\"", "?wt=json&omitHeader=true", "\"", ";", "log", ".", "debug", "(", "\"", "Fetching fresh public key from : {}", "\"", ",", "uri", ")", ";", "HttpResponse", "rsp", "=", "cores", ".", "getUpdateShardHandler", "(", ")", ".", "getHttpClient", "(", ")", ".", "execute", "(", "new", "HttpGet", "(", "uri", ")", ")", ";", "byte", "[", "]", "bytes", "=", "EntityUtils", ".", "toByteArray", "(", "rsp", ".", "getEntity", "(", ")", ")", ";", "Map", "m", "=", "(", "Map", ")", "Utils", ".", "fromJSON", "(", "bytes", ")", ";", "String", "key", "=", "(", "String", ")", "m", ".", "get", "(", "\"", "key", "\"", ")", ";", "if", "(", "key", "==", "null", ")", "{", "log", ".", "error", "(", "\"", "No key available from ", "\"", "+", "url", "+", "PATH", ")", ";", "return", "null", ";", "}", "else", "{", "log", ".", "info", "(", "\"", "New Key obtained from  node: {} / {}", "\"", ",", "nodename", ",", "key", ")", ";", "}", "PublicKey", "pubKey", "=", "CryptoKeys", ".", "deserializeX509PublicKey", "(", "key", ")", ";", "keyCache", ".", "put", "(", "nodename", ",", "pubKey", ")", ";", "return", "pubKey", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "Exception trying to get public key from : ", "\"", "+", "url", ",", "e", ")", ";", "return", "null", ";", "}", "}"], "idx": 39298, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "2f5ecbcf9ed7a3a4fd37b5c55860ad8eace1bea", "function_name": "getRemotePublicKey", "body_hash": "c5a231ca5c0cc0f04d1c9f6dc2847a60c840c611"}
{"code": "public Document readFrom(Class<Document> clazz, Type type,\r\n                            Annotation[] annotations, MediaType mediaType,\r\n                            MultivaluedMap<String, String> headers, InputStream input)\r\n           throws IOException, WebApplicationException\r\n   {\r\n      try\r\n      {\r\n         documentBuilder.setExpandEntityReferences(expandEntityReferences);\r\n         documentBuilder.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, enableSecureProcessingFeature);\r\n         documentBuilder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", disableDTDs);\r\n         return documentBuilder.newDocumentBuilder().parse(input);\r\n      }\r\n      catch (Exception e)\r\n      {\r\n         throw new ReaderException(e);\r\n      }\r\n   }", "code_tokens": ["public", "Document", "readFrom", "(", "Class", "<", "Document", ">", "clazz", ",", "Type", "type", ",", "Annotation", "[", "]", "annotations", ",", "MediaType", "mediaType", ",", "MultivaluedMap", "<", "String", ",", "String", ">", "headers", ",", "InputStream", "input", ")", "throws", "IOException", ",", "WebApplicationException", "{", "try", "{", "documentBuilder", ".", "setExpandEntityReferences", "(", "expandEntityReferences", ")", ";", "documentBuilder", ".", "setFeature", "(", "XMLConstants", ".", "FEATURE_SECURE_PROCESSING", ",", "enableSecureProcessingFeature", ")", ";", "documentBuilder", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "disableDTDs", ")", ";", "return", "documentBuilder", ".", "newDocumentBuilder", "(", ")", ".", "parse", "(", "input", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "ReaderException", "(", "e", ")", ";", "}", "}"], "idx": 10774, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "7a0b80f57f9258e035b9584ddaa72414454e07b2", "function_name": "readFrom", "body_hash": "f3a59d500b6613c9e948e02fc2e8fd8f29a8c3ed"}
{"code": "private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                if (inIndexLimit - inIndex < 1 + tail) {\n                    // Apache Tomcat added test - detects invalid sequence as\n                    // early as possible\n                    if (jchar == 0x74 && inIndexLimit > inIndex + 1) {\n                        if ((bArr[inIndex + 1] & 0xFF) > 0x8F) {\n                            return CoderResult.unmappableForLength(4);\n                        }\n                    }\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ? CoderResult.OVERFLOW\n                : CoderResult.UNDERFLOW;\n    }", "code_tokens": ["private", "CoderResult", "decodeHasArray", "(", "ByteBuffer", "in", ",", "CharBuffer", "out", ")", "{", "int", "outRemaining", "=", "out", ".", "remaining", "(", ")", ";", "int", "pos", "=", "in", ".", "position", "(", ")", ";", "int", "limit", "=", "in", ".", "limit", "(", ")", ";", "final", "byte", "[", "]", "bArr", "=", "in", ".", "array", "(", ")", ";", "final", "char", "[", "]", "cArr", "=", "out", ".", "array", "(", ")", ";", "final", "int", "inIndexLimit", "=", "limit", "+", "in", ".", "arrayOffset", "(", ")", ";", "int", "inIndex", "=", "pos", "+", "in", ".", "arrayOffset", "(", ")", ";", "int", "outIndex", "=", "out", ".", "position", "(", ")", "+", "out", ".", "arrayOffset", "(", ")", ";", "for", "(", ";", "inIndex", "<", "inIndexLimit", "&&", "outRemaining", ">", "0", ";", "inIndex", "++", ")", "{", "int", "jchar", "=", "bArr", "[", "inIndex", "]", ";", "if", "(", "jchar", "<", "0", ")", "{", "jchar", "=", "jchar", "&", "0x7F", ";", "int", "tail", "=", "remainingBytes", "[", "jchar", "]", ";", "if", "(", "tail", "==", "-", "1", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "inIndexLimit", "-", "inIndex", "<", "1", "+", "tail", ")", "{", "if", "(", "jchar", "==", "0x74", "&&", "inIndexLimit", ">", "inIndex", "+", "1", ")", "{", "if", "(", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xFF", ")", ">", "0x8F", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "4", ")", ";", "}", "}", "break", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "tail", ";", "i", "++", ")", "{", "int", "nextByte", "=", "bArr", "[", "inIndex", "+", "i", "+", "1", "]", "&", "0xFF", ";", "if", "(", "(", "nextByte", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", "+", "i", ")", ";", "}", "jchar", "=", "(", "jchar", "<<", "6", ")", "+", "nextByte", ";", "}", "jchar", "-=", "remainingNumbers", "[", "tail", "]", ";", "if", "(", "jchar", "<", "lowerEncodingLimit", "[", "tail", "]", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "inIndex", "+=", "tail", ";", "}", "if", "(", "jchar", ">=", "0xD800", "&&", "jchar", "<=", "0xDFFF", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "3", ")", ";", "}", "if", "(", "jchar", ">", "0x10FFFF", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "4", ")", ";", "}", "if", "(", "jchar", "<=", "0xffff", ")", "{", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "jchar", ";", "outRemaining", "--", ";", "}", "else", "{", "if", "(", "outRemaining", "<", "2", ")", "{", "return", "CoderResult", ".", "OVERFLOW", ";", "}", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "(", "(", "jchar", ">>", "0xA", ")", "+", "0xD7C0", ")", ";", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "(", "(", "jchar", "&", "0x3FF", ")", "+", "0xDC00", ")", ";", "outRemaining", "-=", "2", ";", "}", "}", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "(", "outRemaining", "==", "0", "&&", "inIndex", "<", "inIndexLimit", ")", "?", "CoderResult", ".", "OVERFLOW", ":", "CoderResult", ".", "UNDERFLOW", ";", "}"], "idx": 23579, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "150bc791ac3ba40081425dd1c37a053fbb02b339", "function_name": "decodeHasArray", "body_hash": "62de13562fb50831a843c86d766e78d2ac378a73"}
{"code": "static void securityClassLoad(ClassLoader loader, boolean requireSecurityManager)\n            throws Exception {\n\n        if (requireSecurityManager && System.getSecurityManager() == null) {\n            return;\n        }\n\n        loadCorePackage(loader);\n        loadCoyotePackage(loader);\n        loadLoaderPackage(loader);\n        loadRealmPackage(loader);\n        loadSessionPackage(loader);\n        loadUtilPackage(loader);\n        loadValvesPackage(loader);\n        loadJavaxPackage(loader);\n        loadConnectorPackage(loader);\n        loadTomcatPackage(loader);\n    }", "code_tokens": ["static", "void", "securityClassLoad", "(", "ClassLoader", "loader", ",", "boolean", "requireSecurityManager", ")", "throws", "Exception", "{", "if", "(", "requireSecurityManager", "&&", "System", ".", "getSecurityManager", "(", ")", "==", "null", ")", "{", "return", ";", "}", "loadCorePackage", "(", "loader", ")", ";", "loadCoyotePackage", "(", "loader", ")", ";", "loadLoaderPackage", "(", "loader", ")", ";", "loadRealmPackage", "(", "loader", ")", ";", "loadSessionPackage", "(", "loader", ")", ";", "loadUtilPackage", "(", "loader", ")", ";", "loadValvesPackage", "(", "loader", ")", ";", "loadJavaxPackage", "(", "loader", ")", ";", "loadConnectorPackage", "(", "loader", ")", ";", "loadTomcatPackage", "(", "loader", ")", ";", "}"], "idx": 32740, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "ce70ee6b8fe437a498a375215011056702b0c481", "function_name": "securityClassLoad", "body_hash": "cee4e15f2c704e8beeb6f266d4ad1db043df758c"}
{"code": "static void securityClassLoad(ClassLoader loader, boolean requireSecurityManager)\n            throws Exception {\n\n        if (requireSecurityManager && System.getSecurityManager() == null) {\n            return;\n        }\n\n        loadCorePackage(loader);\n        loadCoyotePackage(loader);\n        loadLoaderPackage(loader);\n        loadRealmPackage(loader);\n        loadServletsPackage(loader);\n        loadSessionPackage(loader);\n        loadUtilPackage(loader);\n        loadValvesPackage(loader);\n        loadJavaxPackage(loader);\n        loadConnectorPackage(loader);\n        loadTomcatPackage(loader);\n    }", "code_tokens": ["static", "void", "securityClassLoad", "(", "ClassLoader", "loader", ",", "boolean", "requireSecurityManager", ")", "throws", "Exception", "{", "if", "(", "requireSecurityManager", "&&", "System", ".", "getSecurityManager", "(", ")", "==", "null", ")", "{", "return", ";", "}", "loadCorePackage", "(", "loader", ")", ";", "loadCoyotePackage", "(", "loader", ")", ";", "loadLoaderPackage", "(", "loader", ")", ";", "loadRealmPackage", "(", "loader", ")", ";", "loadServletsPackage", "(", "loader", ")", ";", "loadSessionPackage", "(", "loader", ")", ";", "loadUtilPackage", "(", "loader", ")", ";", "loadValvesPackage", "(", "loader", ")", ";", "loadJavaxPackage", "(", "loader", ")", ";", "loadConnectorPackage", "(", "loader", ")", ";", "loadTomcatPackage", "(", "loader", ")", ";", "}"], "idx": 32741, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "ce70ee6b8fe437a498a375215011056702b0c481", "function_name": "securityClassLoad", "body_hash": "0f247f7b43d80e3dfa7623d53bdc399111c5a640"}
{"code": "@Override\n    protected boolean op(String name, File path) throws SecurityException {\n        if (SystemProperties.getBoolean(SKIP_PROPERTY)) {\n            LOGGER.log(Level.FINE, () -> \"Skipping check for '\" + name + \"' on '\" + path + \"'\");\n            return false;\n        }\n        if (!(context instanceof Computer)) {\n            LOGGER.log(Level.FINE, \"No context provided for path access: \" + path);\n            return false;\n        }\n        Computer c = (Computer) context;\n\n        final Jenkins jenkins = Jenkins.get();\n\n        String patternString;\n        try {\n            patternString = Jenkins.expandVariablesForDirectory(jenkins.getRawBuildsDir(), \"(.+)\", \"\\\\Q\" + Jenkins.get().getRootDir().getCanonicalPath().replace('\\\\', '/') + \"\\\\E/jobs/(.+)\") + \"/[0-9]+(/.*)?\";\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to obtain canonical path to Jenkins home directory\", e);\n            throw new SecurityException(\"Failed to obtain canonical path\"); // Minimal details\n        }\n        final Pattern pattern = Pattern.compile(patternString);\n\n        String absolutePath;\n        try {\n            absolutePath = path.getCanonicalPath().replace('\\\\', '/');\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to obtain canonical path to '\" + path + \"'\", e);\n            throw new SecurityException(\"Failed to obtain canonical path\"); // Minimal details\n        }\n        if (!pattern.matcher(absolutePath).matches()) {\n            /* This is not a build directory, so another filter will take care of it */\n            LOGGER.log(Level.FINE, \"Not a build directory, so skipping: \" + absolutePath);\n            return false;\n        }\n\n        final Path thePath = path.getAbsoluteFile().toPath();\n        for (Executor executor : c.getExecutors()) {\n            Run<?, ?> build = findRun(executor.getCurrentExecutable());\n            if (build == null) {\n                continue;\n            }\n            final Path buildDir = build.getRootDir().getAbsoluteFile().toPath();\n            // If the directory being accessed is for a build currently running on this node, allow it\n            if (thePath.startsWith(buildDir)) {\n                return false;\n            }\n        }\n\n        final String computerName = c.getName();\n        if (SystemProperties.getBoolean(FAIL_PROPERTY, true)) {\n            // This filter can only prohibit by throwing a SecurityException; it never allows on its own.\n            LOGGER.log(Level.WARNING, \"Rejecting unexpected agent-to-controller file path access: Agent '\" + computerName + \"' is attempting to access '\" + absolutePath + \"' using operation '\" + name + \"'. Learn more: https://www.jenkins.io/redirect/security-144/\");\n            throw new SecurityException(\"Agent tried to access build directory of a build not currently running on this system. Learn more: https://www.jenkins.io/redirect/security-144/\");\n        } else {\n            LOGGER.log(Level.WARNING, \"Unexpected agent-to-controller file path access: Agent '\" + computerName + \"' is accessing '\" + absolutePath + \"' using operation '\" + name + \"'. Learn more: https://www.jenkins.io/redirect/security-144/\");\n            return false;\n        }\n    }", "code_tokens": ["@", "Override", "protected", "boolean", "op", "(", "String", "name", ",", "File", "path", ")", "throws", "SecurityException", "{", "if", "(", "SystemProperties", ".", "getBoolean", "(", "SKIP_PROPERTY", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "(", ")", "->", "\"", "Skipping check for '", "\"", "+", "name", "+", "\"", "' on '", "\"", "+", "path", "+", "\"", "'", "\"", ")", ";", "return", "false", ";", "}", "if", "(", "!", "(", "context", "instanceof", "Computer", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "No context provided for path access: ", "\"", "+", "path", ")", ";", "return", "false", ";", "}", "Computer", "c", "=", "(", "Computer", ")", "context", ";", "final", "Jenkins", "jenkins", "=", "Jenkins", ".", "get", "(", ")", ";", "String", "patternString", ";", "try", "{", "patternString", "=", "Jenkins", ".", "expandVariablesForDirectory", "(", "jenkins", ".", "getRawBuildsDir", "(", ")", ",", "\"", "(.+)", "\"", ",", "\"", "\\\\", "Q", "\"", "+", "Jenkins", ".", "get", "(", ")", ".", "getRootDir", "(", ")", ".", "getCanonicalPath", "(", ")", ".", "replace", "(", "'\\\\'", ",", "'/'", ")", "+", "\"", "\\\\", "E/jobs/(.+)", "\"", ")", "+", "\"", "/[0-9]+(/.*)?", "\"", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to obtain canonical path to Jenkins home directory", "\"", ",", "e", ")", ";", "throw", "new", "SecurityException", "(", "\"", "Failed to obtain canonical path", "\"", ")", ";", "}", "final", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "patternString", ")", ";", "String", "absolutePath", ";", "try", "{", "absolutePath", "=", "path", ".", "getCanonicalPath", "(", ")", ".", "replace", "(", "'\\\\'", ",", "'/'", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to obtain canonical path to '", "\"", "+", "path", "+", "\"", "'", "\"", ",", "e", ")", ";", "throw", "new", "SecurityException", "(", "\"", "Failed to obtain canonical path", "\"", ")", ";", "}", "if", "(", "!", "pattern", ".", "matcher", "(", "absolutePath", ")", ".", "matches", "(", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Not a build directory, so skipping: ", "\"", "+", "absolutePath", ")", ";", "return", "false", ";", "}", "final", "Path", "thePath", "=", "path", ".", "getAbsoluteFile", "(", ")", ".", "toPath", "(", ")", ";", "for", "(", "Executor", "executor", ":", "c", ".", "getExecutors", "(", ")", ")", "{", "Run", "<", "?", ",", "?", ">", "build", "=", "findRun", "(", "executor", ".", "getCurrentExecutable", "(", ")", ")", ";", "if", "(", "build", "==", "null", ")", "{", "continue", ";", "}", "final", "Path", "buildDir", "=", "build", ".", "getRootDir", "(", ")", ".", "getAbsoluteFile", "(", ")", ".", "toPath", "(", ")", ";", "if", "(", "thePath", ".", "startsWith", "(", "buildDir", ")", ")", "{", "return", "false", ";", "}", "}", "final", "String", "computerName", "=", "c", ".", "getName", "(", ")", ";", "if", "(", "SystemProperties", ".", "getBoolean", "(", "FAIL_PROPERTY", ",", "true", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Rejecting unexpected agent-to-controller file path access: Agent '", "\"", "+", "computerName", "+", "\"", "' is attempting to access '", "\"", "+", "absolutePath", "+", "\"", "' using operation '", "\"", "+", "name", "+", "\"", "'. Learn more: https://www.jenkins.io/redirect/security-144/", "\"", ")", ";", "throw", "new", "SecurityException", "(", "\"", "Agent tried to access build directory of a build not currently running on this system. Learn more: https://www.jenkins.io/redirect/security-144/", "\"", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Unexpected agent-to-controller file path access: Agent '", "\"", "+", "computerName", "+", "\"", "' is accessing '", "\"", "+", "absolutePath", "+", "\"", "' using operation '", "\"", "+", "name", "+", "\"", "'. Learn more: https://www.jenkins.io/redirect/security-144/", "\"", ")", ";", "return", "false", ";", "}", "}"], "idx": 2526, "cwe": "CWE-184", "target": 1, "status": "VULNERABLE", "commit": "eae33841b587da787f37d5b6c8451d483edc04d9", "function_name": "op", "body_hash": "bf3a654f555c6b4cfdd356bd72613a0a2bc385ea"}
{"code": "@Override\n      public boolean process(final TProtocol inProt, final TProtocol outProt) throws TException {\n        TTransport trans = inProt.getTransport();\n        if (!(trans instanceof TSaslServerTransport)) {\n          throw new TException(\"Unexpected non-SASL transport \" + trans.getClass());\n        }\n        TSaslServerTransport saslTrans = (TSaslServerTransport)trans;\n        SaslServer saslServer = saslTrans.getSaslServer();\n        String authId = saslServer.getAuthorizationID();\n        authenticationMethod.set(AuthenticationMethod.KERBEROS);\n        LOG.debug(\"AUTH ID ======>\" + authId);\n        String endUser = authId;\n\n        if(saslServer.getMechanismName().equals(\"DIGEST-MD5\")) {\n          try {\n            TokenIdentifier tokenId = SaslRpcServer.getIdentifier(authId,\n                secretManager);\n            endUser = tokenId.getUser().getUserName();\n            authenticationMethod.set(AuthenticationMethod.TOKEN);\n          } catch (InvalidToken e) {\n            throw new TException(e.getMessage());\n          }\n        }\n        Socket socket = ((TSocket)(saslTrans.getUnderlyingTransport())).getSocket();\n        remoteAddress.set(socket.getInetAddress());\n        UserGroupInformation clientUgi = null;\n        try {\n          if (useProxy) {\n            clientUgi = UserGroupInformation.createProxyUser(\n                endUser, UserGroupInformation.getLoginUser());\n            remoteUser.set(clientUgi.getShortUserName());\n            LOG.debug(\"Set remoteUser :\" + remoteUser.get());\n            return clientUgi.doAs(new PrivilegedExceptionAction<Boolean>() {\n              @Override\n              public Boolean run() {\n                try {\n                  return wrapped.process(inProt, outProt);\n                } catch (TException te) {\n                  throw new RuntimeException(te);\n                }\n              }\n            });\n          } else {\n            // use the short user name for the request\n            UserGroupInformation endUserUgi = UserGroupInformation.createRemoteUser(endUser);\n            remoteUser.set(endUserUgi.getShortUserName());\n            LOG.debug(\"Set remoteUser :\" + remoteUser.get() + \", from endUser :\" + endUser);\n            return wrapped.process(inProt, outProt);\n          }\n        } catch (RuntimeException rte) {\n          if (rte.getCause() instanceof TException) {\n            throw (TException)rte.getCause();\n          }\n          throw rte;\n        } catch (InterruptedException ie) {\n          throw new RuntimeException(ie); // unexpected!\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe); // unexpected!\n        }\n        finally {\n          if (clientUgi != null) {\n            try { FileSystem.closeAllForUGI(clientUgi); }\n            catch(IOException exception) {\n              LOG.error(\"Could not clean up file-system handles for UGI: \" + clientUgi, exception);\n            }\n          }\n        }\n      }", "code_tokens": ["@", "Override", "public", "boolean", "process", "(", "final", "TProtocol", "inProt", ",", "final", "TProtocol", "outProt", ")", "throws", "TException", "{", "TTransport", "trans", "=", "inProt", ".", "getTransport", "(", ")", ";", "if", "(", "!", "(", "trans", "instanceof", "TSaslServerTransport", ")", ")", "{", "throw", "new", "TException", "(", "\"", "Unexpected non-SASL transport ", "\"", "+", "trans", ".", "getClass", "(", ")", ")", ";", "}", "TSaslServerTransport", "saslTrans", "=", "(", "TSaslServerTransport", ")", "trans", ";", "SaslServer", "saslServer", "=", "saslTrans", ".", "getSaslServer", "(", ")", ";", "String", "authId", "=", "saslServer", ".", "getAuthorizationID", "(", ")", ";", "authenticationMethod", ".", "set", "(", "AuthenticationMethod", ".", "KERBEROS", ")", ";", "LOG", ".", "debug", "(", "\"", "AUTH ID ======>", "\"", "+", "authId", ")", ";", "String", "endUser", "=", "authId", ";", "if", "(", "saslServer", ".", "getMechanismName", "(", ")", ".", "equals", "(", "\"", "DIGEST-MD5", "\"", ")", ")", "{", "try", "{", "TokenIdentifier", "tokenId", "=", "SaslRpcServer", ".", "getIdentifier", "(", "authId", ",", "secretManager", ")", ";", "endUser", "=", "tokenId", ".", "getUser", "(", ")", ".", "getUserName", "(", ")", ";", "authenticationMethod", ".", "set", "(", "AuthenticationMethod", ".", "TOKEN", ")", ";", "}", "catch", "(", "InvalidToken", "e", ")", "{", "throw", "new", "TException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "Socket", "socket", "=", "(", "(", "TSocket", ")", "(", "saslTrans", ".", "getUnderlyingTransport", "(", ")", ")", ")", ".", "getSocket", "(", ")", ";", "remoteAddress", ".", "set", "(", "socket", ".", "getInetAddress", "(", ")", ")", ";", "UserGroupInformation", "clientUgi", "=", "null", ";", "try", "{", "if", "(", "useProxy", ")", "{", "clientUgi", "=", "UserGroupInformation", ".", "createProxyUser", "(", "endUser", ",", "UserGroupInformation", ".", "getLoginUser", "(", ")", ")", ";", "remoteUser", ".", "set", "(", "clientUgi", ".", "getShortUserName", "(", ")", ")", ";", "LOG", ".", "debug", "(", "\"", "Set remoteUser :", "\"", "+", "remoteUser", ".", "get", "(", ")", ")", ";", "return", "clientUgi", ".", "doAs", "(", "new", "PrivilegedExceptionAction", "<", "Boolean", ">", "(", ")", "{", "@", "Override", "public", "Boolean", "run", "(", ")", "{", "try", "{", "return", "wrapped", ".", "process", "(", "inProt", ",", "outProt", ")", ";", "}", "catch", "(", "TException", "te", ")", "{", "throw", "new", "RuntimeException", "(", "te", ")", ";", "}", "}", "}", ")", ";", "}", "else", "{", "UserGroupInformation", "endUserUgi", "=", "UserGroupInformation", ".", "createRemoteUser", "(", "endUser", ")", ";", "remoteUser", ".", "set", "(", "endUserUgi", ".", "getShortUserName", "(", ")", ")", ";", "LOG", ".", "debug", "(", "\"", "Set remoteUser :", "\"", "+", "remoteUser", ".", "get", "(", ")", "+", "\"", ", from endUser :", "\"", "+", "endUser", ")", ";", "return", "wrapped", ".", "process", "(", "inProt", ",", "outProt", ")", ";", "}", "}", "catch", "(", "RuntimeException", "rte", ")", "{", "if", "(", "rte", ".", "getCause", "(", ")", "instanceof", "TException", ")", "{", "throw", "(", "TException", ")", "rte", ".", "getCause", "(", ")", ";", "}", "throw", "rte", ";", "}", "catch", "(", "InterruptedException", "ie", ")", "{", "throw", "new", "RuntimeException", "(", "ie", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "RuntimeException", "(", "ioe", ")", ";", "}", "finally", "{", "if", "(", "clientUgi", "!=", "null", ")", "{", "try", "{", "FileSystem", ".", "closeAllForUGI", "(", "clientUgi", ")", ";", "}", "catch", "(", "IOException", "exception", ")", "{", "LOG", ".", "error", "(", "\"", "Could not clean up file-system handles for UGI: ", "\"", "+", "clientUgi", ",", "exception", ")", ";", "}", "}", "}", "}"], "idx": 37961, "cwe": "CWE-284", "target": 0, "status": "FIXED", "commit": "5831be0c57", "function_name": "process", "body_hash": "7306a70fbd27a24b7c3b1a373c03c719cc2f88f3"}
{"code": "private boolean isSensitiveValue(ModelNode value) {\n            if (value.getType() == ModelType.EXPRESSION\n                    || value.getType() == ModelType.STRING) {\n                String valueString = value.asString();\n                return VAULT_EXPRESSION_PATTERN.matcher(valueString).matches();\n            }\n            return false;\n        }", "code_tokens": ["private", "boolean", "isSensitiveValue", "(", "ModelNode", "value", ")", "{", "if", "(", "value", ".", "getType", "(", ")", "==", "ModelType", ".", "EXPRESSION", "||", "value", ".", "getType", "(", ")", "==", "ModelType", ".", "STRING", ")", "{", "String", "valueString", "=", "value", ".", "asString", "(", ")", ";", "return", "VAULT_EXPRESSION_PATTERN", ".", "matcher", "(", "valueString", ")", ".", "matches", "(", ")", ";", "}", "return", "false", ";", "}"], "idx": 98146, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "6d8db43cd43b5994b7a14003db978064e086090b", "function_name": "isSensitiveValue", "body_hash": "98a073ebd9df7027eaf40e2b7e58bcc43ca91023"}
{"code": "@Override\n    public Argument<Session> argumentType() {\n        return TYPE;\n    }", "code_tokens": ["@", "Override", "public", "Argument", "<", "Session", ">", "argumentType", "(", ")", "{", "return", "TYPE", ";", "}"], "idx": 52665, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3", "function_name": "argumentType", "body_hash": "e9ead336c271a9f00c4715231f395a63fc6b1670"}
{"code": "Augmentations handleStartElement(QName element, XMLAttributes attributes, Augmentations augs) {\n\n        if (DEBUG) {\n            System.out.println(\"==>handleStartElement: \" + element);\n        }\n\n        // root element\n        if (fElementDepth == -1 && fValidationManager.isGrammarFound()) {\n            if (fSchemaType == null && !fUseGrammarPoolOnly) {\n                // schemaType is not specified\n                // if a DTD grammar is found, we do the same thing as Dynamic:\n                // if a schema grammar is found, validation is performed;\n                // otherwise, skip the whole document.\n                fSchemaDynamicValidation = true;\n            } else {\n                // [1] Either schemaType is DTD, and in this case validate/schema is turned off\n                // [2] Validating against XML Schemas only\n                //   [a] dynamic validation is false: report error if SchemaGrammar is not found\n                //   [b] dynamic validation is true: if grammar is not found ignore.\n            }\n\n        }\n\n        // get xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes,\n        // parse them to get the grammars. But only do this if the grammar can grow.\n        if (!fUseGrammarPoolOnly) {\n            String sLocation =\n                attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_SCHEMALOCATION);\n            String nsLocation =\n                attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION);\n            //store the location hints..  we need to do it so that we can defer the loading of grammar until\n            //there is a reference to a component from that namespace. To provide location hints to the\n            //application for a namespace\n            storeLocations(sLocation, nsLocation);\n        }\n\n        // if we are in the content of \"skip\", then just skip this element\n        // REVISIT:  is this the correct behaviour for ID constraints?  -NG\n        if (fSkipValidationDepth >= 0) {\n            fElementDepth++;\n            if (fAugPSVI)\n            \taugs = getEmptyAugs(augs);\n            return augs;\n        }\n\n        // if we are not skipping this element, and there is a content model,\n        // we try to find the corresponding decl object for this element.\n        // the reason we move this part of code here is to make sure the\n        // error reported here (if any) is stored within the parent element's\n        // context, instead of that of the current element.\n        Object decl = null;\n        if (fCurrentCM != null) {\n            decl = fCurrentCM.oneTransition(element, fCurrCMState, fSubGroupHandler);\n            // it could be an element decl or a wildcard decl\n            if (fCurrCMState[0] == XSCMValidator.FIRST_ERROR) {\n                XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n                //REVISIT: is it the only case we will have particle = null?\n                Vector next;\n                if (ctype.fParticle != null\n                    && (next = fCurrentCM.whatCanGoHere(fCurrCMState)).size() > 0) {\n                    String expected = expectedStr(next);\n                    final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);\n                    String elemExpandedQname = (element.uri != null) ? \"{\"+'\"'+element.uri+'\"'+\":\"+element.localpart+\"}\" : element.localpart;\n                    if (occurenceInfo != null) {\n                        final int minOccurs = occurenceInfo[0];\n                        final int maxOccurs = occurenceInfo[1];\n                        final int count = occurenceInfo[2];\n                        // Check if this is a violation of minOccurs\n                        if (count < minOccurs) {\n                            final int required = minOccurs - count;\n                            if (required > 1) {\n                                reportSchemaError(\"cvc-complex-type.2.4.h\", new Object[] { element.rawname, \n                                        fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs), Integer.toString(required) });\n                            }\n                            else {\n                                reportSchemaError(\"cvc-complex-type.2.4.g\", new Object[] { element.rawname, \n                                        fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs) });\n                            }\n                        }\n                        // Check if this is a violation of maxOccurs\n                        else if (count >= maxOccurs && maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {\n                            reportSchemaError(\"cvc-complex-type.2.4.e\", new Object[] { element.rawname, \n                                    expected, Integer.toString(maxOccurs) });\n                        }\n                        else {\n                            reportSchemaError(\"cvc-complex-type.2.4.a\", new Object[] { elemExpandedQname, expected });\n                        }\n                    }\n                    else {\n                        reportSchemaError(\"cvc-complex-type.2.4.a\", new Object[] { elemExpandedQname, expected });\n                    }\n                }\n                else {\n                    final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);\n                    if (occurenceInfo != null) {\n                        final int maxOccurs = occurenceInfo[1];\n                        final int count = occurenceInfo[2];\n                        // Check if this is a violation of maxOccurs\n                        if (count >= maxOccurs && maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {\n                            reportSchemaError(\"cvc-complex-type.2.4.f\", new Object[] { fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(maxOccurs) });\n                        }\n                        else {\n                            reportSchemaError(\"cvc-complex-type.2.4.d\", new Object[] { element.rawname });\n                        }\n                    }\n                    else {\n                        reportSchemaError(\"cvc-complex-type.2.4.d\", new Object[] { element.rawname });\n                    }\n                }\n            }\n        }\n\n        // if it's not the root element, we push the current states in the stacks\n        if (fElementDepth != -1) {\n            ensureStackCapacity();\n            fSubElementStack[fElementDepth] = true;\n            fSubElement = false;\n            fElemDeclStack[fElementDepth] = fCurrentElemDecl;\n            fNilStack[fElementDepth] = fNil;\n            fNotationStack[fElementDepth] = fNotation;\n            fTypeStack[fElementDepth] = fCurrentType;\n            fStrictAssessStack[fElementDepth] = fStrictAssess;\n            fCMStack[fElementDepth] = fCurrentCM;\n            fCMStateStack[fElementDepth] = fCurrCMState;\n            fSawTextStack[fElementDepth] = fSawText;\n            fStringContent[fElementDepth] = fSawCharacters;\n        }\n\n        // increase the element depth after we've saved\n        // all states for the parent element\n        fElementDepth++;\n        fCurrentElemDecl = null;\n        XSWildcardDecl wildcard = null;\n        fCurrentType = null;\n        fStrictAssess = true;\n        fNil = false;\n        fNotation = null;\n\n        // and the buffer to hold the value of the element\n        fBuffer.setLength(0);\n        fSawText = false;\n        fSawCharacters = false;\n\n        // check what kind of declaration the \"decl\" from\n        // oneTransition() maps to\n        if (decl != null) {\n            if (decl instanceof XSElementDecl) {\n                fCurrentElemDecl = (XSElementDecl) decl;\n            } else {\n                wildcard = (XSWildcardDecl) decl;\n            }\n        }\n\n        // if the wildcard is skip, then return\n        if (wildcard != null && wildcard.fProcessContents == XSWildcardDecl.PC_SKIP) {\n            fSkipValidationDepth = fElementDepth;\n            if (fAugPSVI)\n                augs = getEmptyAugs(augs);\n            return augs;\n        }\n        \n        if (fElementDepth == 0) {\n            // 1.1.1.1 An element declaration was stipulated by the processor\n            if (fRootElementDeclaration != null) {\n                fCurrentElemDecl = fRootElementDeclaration;\n                checkElementMatchesRootElementDecl(fCurrentElemDecl, element);\n            }\n            else if (fRootElementDeclQName != null) {\n                processRootElementDeclQName(fRootElementDeclQName, element);\n            }\n            // 1.2.1.1 A type definition was stipulated by the processor\n            else if (fRootTypeDefinition != null) {\n                fCurrentType = fRootTypeDefinition;\n            }\n            else if (fRootTypeQName != null) {\n                processRootTypeQName(fRootTypeQName);\n            }\n        }\n        \n        // if there was no processor stipulated type\n        if (fCurrentType == null) {\n            // try again to get the element decl:\n            // case 1: find declaration for root element\n            // case 2: find declaration for element from another namespace\n            if (fCurrentElemDecl == null) {\n                // try to find schema grammar by different means..\n                SchemaGrammar sGrammar =\n                    findSchemaGrammar(\n                        XSDDescription.CONTEXT_ELEMENT,\n                        element.uri,\n                        null,\n                        element,\n                        attributes);\n                if (sGrammar != null) {\n                    fCurrentElemDecl = sGrammar.getGlobalElementDecl(element.localpart);\n                }\n            }\n            \n            if (fCurrentElemDecl != null) {\n                // then get the type\n                fCurrentType = fCurrentElemDecl.fType;\n            }\n        }\n        \n        // check if we should be ignoring xsi:type on this element\n        if (fElementDepth == fIgnoreXSITypeDepth && fCurrentElemDecl == null) {\n            fIgnoreXSITypeDepth++;\n        }\n        \n        // process xsi:type attribute information\n        String xsiType = null;\n        if (fElementDepth >= fIgnoreXSITypeDepth) {\n            xsiType = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_TYPE);\n        }\n        \n        // if no decl/type found for the current element\n        if (fCurrentType == null && xsiType == null) {\n            // if this is the validation root, report an error, because\n            // we can't find eith decl or type for this element\n            // REVISIT: should we report error, or warning?\n            if (fElementDepth == 0) {\n                // for dynamic validation, skip the whole content,\n                // because no grammar was found.\n                if (fDynamicValidation || fSchemaDynamicValidation) {\n                    // no schema grammar was found, but it's either dynamic\n                    // validation, or another kind of grammar was found (DTD,\n                    // for example). The intended behavior here is to skip\n                    // the whole document. To improve performance, we try to\n                    // remove the validator from the pipeline, since it's not\n                    // supposed to do anything.\n                    if (fDocumentSource != null) {\n                        fDocumentSource.setDocumentHandler(fDocumentHandler);\n                        if (fDocumentHandler != null)\n                            fDocumentHandler.setDocumentSource(fDocumentSource);\n                        // indicate that the validator was removed.\n                        fElementDepth = -2;\n                        return augs;\n                    }\n\n                    fSkipValidationDepth = fElementDepth;\n                    if (fAugPSVI)\n                        augs = getEmptyAugs(augs);\n                    return augs;\n                }\n                // We don't call reportSchemaError here, because the spec\n                // doesn't think it's invalid not to be able to find a\n                // declaration or type definition for an element. Xerces is\n                // reporting it as an error for historical reasons, but in\n                // PSVI, we shouldn't mark this element as invalid because\n                // of this. - SG\n                fXSIErrorReporter.fErrorReporter.reportError(\n                    XSMessageFormatter.SCHEMA_DOMAIN,\n                    \"cvc-elt.1.a\",\n                    new Object[] { element.rawname },\n                    XMLErrorReporter.SEVERITY_ERROR);\n            }\n            // if wildcard = strict, report error.\n            // needs to be called before fXSIErrorReporter.pushContext()\n            // so that the error belongs to the parent element.\n            else if (wildcard != null && wildcard.fProcessContents == XSWildcardDecl.PC_STRICT) {\n                // report error, because wilcard = strict\n                reportSchemaError(\"cvc-complex-type.2.4.c\", new Object[] { element.rawname });\n            }\n            // no element decl or type found for this element.\n            // Allowed by the spec, we can choose to either laxly assess this\n            // element, or to skip it. Now we choose lax assessment.\n            fCurrentType = SchemaGrammar.fAnyType;\n            fStrictAssess = false;\n            fNFullValidationDepth = fElementDepth;\n            // any type has mixed content, so we don't need to append buffer\n            fAppendBuffer = false;\n\n            // push error reporter context: record the current position\n            // This has to happen after we process skip contents,\n            // otherwise push and pop won't be correctly paired.\n            fXSIErrorReporter.pushContext();\n        } else {\n            // push error reporter context: record the current position\n            // This has to happen after we process skip contents,\n            // otherwise push and pop won't be correctly paired.\n            fXSIErrorReporter.pushContext();\n\n            // get xsi:type\n            if (xsiType != null) {\n                XSTypeDefinition oldType = fCurrentType;\n                fCurrentType = getAndCheckXsiType(element, xsiType, attributes);\n                // If it fails, use the old type. Use anyType if ther is no old type.\n                if (fCurrentType == null) {\n                    if (oldType == null)\n                        fCurrentType = SchemaGrammar.fAnyType;\n                    else\n                        fCurrentType = oldType;\n                }\n            }\n\n            fNNoneValidationDepth = fElementDepth;\n            // if the element has a fixed value constraint, we need to append\n            if (fCurrentElemDecl != null\n                && fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED) {\n                fAppendBuffer = true;\n            }\n            // if the type is simple, we need to append\n            else if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {\n                fAppendBuffer = true;\n            } else {\n                // if the type is simple content complex type, we need to append\n                XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n                fAppendBuffer = (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE);\n            }\n        }\n\n        // Element Locally Valid (Element)\n        // 2 Its {abstract} must be false.\n        if (fCurrentElemDecl != null && fCurrentElemDecl.getAbstract())\n            reportSchemaError(\"cvc-elt.2\", new Object[] { element.rawname });\n\n        // make the current element validation root\n        if (fElementDepth == 0) {\n            fValidationRoot = element.rawname;\n        }\n\n        // update normalization flags\n        if (fNormalizeData) {\n            // reset values\n            fFirstChunk = true;\n            fTrailing = false;\n            fUnionType = false;\n            fWhiteSpace = -1;\n        }\n\n        // Element Locally Valid (Type)\n        // 2 Its {abstract} must be false.\n        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n            XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n            if (ctype.getAbstract()) {\n                reportSchemaError(\"cvc-type.2\", new Object[] { element.rawname });\n            }\n            if (fNormalizeData) {\n                // find out if the content type is simple and if variety is union\n                // to be able to do character normalization\n                if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {\n                    if (ctype.fXSSimpleType.getVariety() == XSSimpleType.VARIETY_UNION) {\n                        fUnionType = true;\n                    } else {\n                        try {\n                            fWhiteSpace = ctype.fXSSimpleType.getWhitespace();\n                        } catch (DatatypeException e) {\n                            // do nothing\n                        }\n                    }\n                }\n            }\n        }\n        // normalization: simple type\n        else if (fNormalizeData) {\n            // if !union type\n            XSSimpleType dv = (XSSimpleType) fCurrentType;\n            if (dv.getVariety() == XSSimpleType.VARIETY_UNION) {\n                fUnionType = true;\n            } else {\n                try {\n                    fWhiteSpace = dv.getWhitespace();\n                } catch (DatatypeException e) {\n                    // do nothing\n                }\n            }\n        }\n\n        // then try to get the content model\n        fCurrentCM = null;\n        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n            fCurrentCM = ((XSComplexTypeDecl) fCurrentType).getContentModel(fCMBuilder);\n        }\n\n        // and get the initial content model state\n        fCurrCMState = null;\n        if (fCurrentCM != null)\n            fCurrCMState = fCurrentCM.startContentModel();\n\n        // get information about xsi:nil\n        String xsiNil = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NIL);\n        // only deal with xsi:nil when there is an element declaration\n        if (xsiNil != null && fCurrentElemDecl != null)\n            fNil = getXsiNil(element, xsiNil);\n\n        // now validate everything related with the attributes\n        // first, get the attribute group\n        XSAttributeGroupDecl attrGrp = null;\n        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n            XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n            attrGrp = ctype.getAttrGrp();\n        }\n        \n        if (fIDCChecking) {\n            // activate identity constraints\n            fValueStoreCache.startElement();\n            fMatcherStack.pushContext();\n            //if (fCurrentElemDecl != null && fCurrentElemDecl.fIDCPos > 0 && !fIgnoreIDC) {\n            if (fCurrentElemDecl != null && fCurrentElemDecl.fIDCPos > 0) {\n                fIdConstraint = true;\n                // initialize when identity constrains are defined for the elem\n                fValueStoreCache.initValueStoresFor(fCurrentElemDecl, this);\n            }\n        }\n        processAttributes(element, attributes, attrGrp);\n\n        // add default attributes\n        if (attrGrp != null) {\n            addDefaultAttributes(element, attributes, attrGrp);\n        }\n\n        // call all active identity constraints\n        int count = fMatcherStack.getMatcherCount();\n        for (int i = 0; i < count; i++) {\n            XPathMatcher matcher = fMatcherStack.getMatcherAt(i);\n            matcher.startElement( element, attributes);\n        }\n\n        if (fAugPSVI) {\n            augs = getEmptyAugs(augs);\n\n            // PSVI: add validation context\n            fCurrentPSVI.fValidationContext = fValidationRoot;\n            // PSVI: add element declaration\n            fCurrentPSVI.fDeclaration = fCurrentElemDecl;\n            // PSVI: add element type\n            fCurrentPSVI.fTypeDecl = fCurrentType;\n            // PSVI: add notation attribute\n            fCurrentPSVI.fNotation = fNotation;\n            // PSVI: add nil\n            fCurrentPSVI.fNil = fNil;\n        }\n\n        return augs;\n\n    }", "code_tokens": ["Augmentations", "handleStartElement", "(", "QName", "element", ",", "XMLAttributes", "attributes", ",", "Augmentations", "augs", ")", "{", "if", "(", "DEBUG", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "==>handleStartElement: ", "\"", "+", "element", ")", ";", "}", "if", "(", "fElementDepth", "==", "-", "1", "&&", "fValidationManager", ".", "isGrammarFound", "(", ")", ")", "{", "if", "(", "fSchemaType", "==", "null", "&&", "!", "fUseGrammarPoolOnly", ")", "{", "fSchemaDynamicValidation", "=", "true", ";", "}", "else", "{", "}", "}", "if", "(", "!", "fUseGrammarPoolOnly", ")", "{", "String", "sLocation", "=", "attributes", ".", "getValue", "(", "SchemaSymbols", ".", "URI_XSI", ",", "SchemaSymbols", ".", "XSI_SCHEMALOCATION", ")", ";", "String", "nsLocation", "=", "attributes", ".", "getValue", "(", "SchemaSymbols", ".", "URI_XSI", ",", "SchemaSymbols", ".", "XSI_NONAMESPACESCHEMALOCATION", ")", ";", "storeLocations", "(", "sLocation", ",", "nsLocation", ")", ";", "}", "if", "(", "fSkipValidationDepth", ">=", "0", ")", "{", "fElementDepth", "++", ";", "if", "(", "fAugPSVI", ")", "augs", "=", "getEmptyAugs", "(", "augs", ")", ";", "return", "augs", ";", "}", "Object", "decl", "=", "null", ";", "if", "(", "fCurrentCM", "!=", "null", ")", "{", "decl", "=", "fCurrentCM", ".", "oneTransition", "(", "element", ",", "fCurrCMState", ",", "fSubGroupHandler", ")", ";", "if", "(", "fCurrCMState", "[", "0", "]", "==", "XSCMValidator", ".", "FIRST_ERROR", ")", "{", "XSComplexTypeDecl", "ctype", "=", "(", "XSComplexTypeDecl", ")", "fCurrentType", ";", "Vector", "next", ";", "if", "(", "ctype", ".", "fParticle", "!=", "null", "&&", "(", "next", "=", "fCurrentCM", ".", "whatCanGoHere", "(", "fCurrCMState", ")", ")", ".", "size", "(", ")", ">", "0", ")", "{", "String", "expected", "=", "expectedStr", "(", "next", ")", ";", "final", "int", "[", "]", "occurenceInfo", "=", "fCurrentCM", ".", "occurenceInfo", "(", "fCurrCMState", ")", ";", "String", "elemExpandedQname", "=", "(", "element", ".", "uri", "!=", "null", ")", "?", "\"", "{", "\"", "+", "'\"'", "+", "element", ".", "uri", "+", "'\"'", "+", "\"", ":", "\"", "+", "element", ".", "localpart", "+", "\"", "}", "\"", ":", "element", ".", "localpart", ";", "if", "(", "occurenceInfo", "!=", "null", ")", "{", "final", "int", "minOccurs", "=", "occurenceInfo", "[", "0", "]", ";", "final", "int", "maxOccurs", "=", "occurenceInfo", "[", "1", "]", ";", "final", "int", "count", "=", "occurenceInfo", "[", "2", "]", ";", "if", "(", "count", "<", "minOccurs", ")", "{", "final", "int", "required", "=", "minOccurs", "-", "count", ";", "if", "(", "required", ">", "1", ")", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.h", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", ",", "fCurrentCM", ".", "getTermName", "(", "occurenceInfo", "[", "3", "]", ")", ",", "Integer", ".", "toString", "(", "minOccurs", ")", ",", "Integer", ".", "toString", "(", "required", ")", "}", ")", ";", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.g", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", ",", "fCurrentCM", ".", "getTermName", "(", "occurenceInfo", "[", "3", "]", ")", ",", "Integer", ".", "toString", "(", "minOccurs", ")", "}", ")", ";", "}", "}", "else", "if", "(", "count", ">=", "maxOccurs", "&&", "maxOccurs", "!=", "SchemaSymbols", ".", "OCCURRENCE_UNBOUNDED", ")", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.e", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", ",", "expected", ",", "Integer", ".", "toString", "(", "maxOccurs", ")", "}", ")", ";", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.a", "\"", ",", "new", "Object", "[", "]", "{", "elemExpandedQname", ",", "expected", "}", ")", ";", "}", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.a", "\"", ",", "new", "Object", "[", "]", "{", "elemExpandedQname", ",", "expected", "}", ")", ";", "}", "}", "else", "{", "final", "int", "[", "]", "occurenceInfo", "=", "fCurrentCM", ".", "occurenceInfo", "(", "fCurrCMState", ")", ";", "if", "(", "occurenceInfo", "!=", "null", ")", "{", "final", "int", "maxOccurs", "=", "occurenceInfo", "[", "1", "]", ";", "final", "int", "count", "=", "occurenceInfo", "[", "2", "]", ";", "if", "(", "count", ">=", "maxOccurs", "&&", "maxOccurs", "!=", "SchemaSymbols", ".", "OCCURRENCE_UNBOUNDED", ")", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.f", "\"", ",", "new", "Object", "[", "]", "{", "fCurrentCM", ".", "getTermName", "(", "occurenceInfo", "[", "3", "]", ")", ",", "Integer", ".", "toString", "(", "maxOccurs", ")", "}", ")", ";", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.d", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "}", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.d", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "}", "}", "}", "}", "if", "(", "fElementDepth", "!=", "-", "1", ")", "{", "ensureStackCapacity", "(", ")", ";", "fSubElementStack", "[", "fElementDepth", "]", "=", "true", ";", "fSubElement", "=", "false", ";", "fElemDeclStack", "[", "fElementDepth", "]", "=", "fCurrentElemDecl", ";", "fNilStack", "[", "fElementDepth", "]", "=", "fNil", ";", "fNotationStack", "[", "fElementDepth", "]", "=", "fNotation", ";", "fTypeStack", "[", "fElementDepth", "]", "=", "fCurrentType", ";", "fStrictAssessStack", "[", "fElementDepth", "]", "=", "fStrictAssess", ";", "fCMStack", "[", "fElementDepth", "]", "=", "fCurrentCM", ";", "fCMStateStack", "[", "fElementDepth", "]", "=", "fCurrCMState", ";", "fSawTextStack", "[", "fElementDepth", "]", "=", "fSawText", ";", "fStringContent", "[", "fElementDepth", "]", "=", "fSawCharacters", ";", "}", "fElementDepth", "++", ";", "fCurrentElemDecl", "=", "null", ";", "XSWildcardDecl", "wildcard", "=", "null", ";", "fCurrentType", "=", "null", ";", "fStrictAssess", "=", "true", ";", "fNil", "=", "false", ";", "fNotation", "=", "null", ";", "fBuffer", ".", "setLength", "(", "0", ")", ";", "fSawText", "=", "false", ";", "fSawCharacters", "=", "false", ";", "if", "(", "decl", "!=", "null", ")", "{", "if", "(", "decl", "instanceof", "XSElementDecl", ")", "{", "fCurrentElemDecl", "=", "(", "XSElementDecl", ")", "decl", ";", "}", "else", "{", "wildcard", "=", "(", "XSWildcardDecl", ")", "decl", ";", "}", "}", "if", "(", "wildcard", "!=", "null", "&&", "wildcard", ".", "fProcessContents", "==", "XSWildcardDecl", ".", "PC_SKIP", ")", "{", "fSkipValidationDepth", "=", "fElementDepth", ";", "if", "(", "fAugPSVI", ")", "augs", "=", "getEmptyAugs", "(", "augs", ")", ";", "return", "augs", ";", "}", "if", "(", "fElementDepth", "==", "0", ")", "{", "if", "(", "fRootElementDeclaration", "!=", "null", ")", "{", "fCurrentElemDecl", "=", "fRootElementDeclaration", ";", "checkElementMatchesRootElementDecl", "(", "fCurrentElemDecl", ",", "element", ")", ";", "}", "else", "if", "(", "fRootElementDeclQName", "!=", "null", ")", "{", "processRootElementDeclQName", "(", "fRootElementDeclQName", ",", "element", ")", ";", "}", "else", "if", "(", "fRootTypeDefinition", "!=", "null", ")", "{", "fCurrentType", "=", "fRootTypeDefinition", ";", "}", "else", "if", "(", "fRootTypeQName", "!=", "null", ")", "{", "processRootTypeQName", "(", "fRootTypeQName", ")", ";", "}", "}", "if", "(", "fCurrentType", "==", "null", ")", "{", "if", "(", "fCurrentElemDecl", "==", "null", ")", "{", "SchemaGrammar", "sGrammar", "=", "findSchemaGrammar", "(", "XSDDescription", ".", "CONTEXT_ELEMENT", ",", "element", ".", "uri", ",", "null", ",", "element", ",", "attributes", ")", ";", "if", "(", "sGrammar", "!=", "null", ")", "{", "fCurrentElemDecl", "=", "sGrammar", ".", "getGlobalElementDecl", "(", "element", ".", "localpart", ")", ";", "}", "}", "if", "(", "fCurrentElemDecl", "!=", "null", ")", "{", "fCurrentType", "=", "fCurrentElemDecl", ".", "fType", ";", "}", "}", "if", "(", "fElementDepth", "==", "fIgnoreXSITypeDepth", "&&", "fCurrentElemDecl", "==", "null", ")", "{", "fIgnoreXSITypeDepth", "++", ";", "}", "String", "xsiType", "=", "null", ";", "if", "(", "fElementDepth", ">=", "fIgnoreXSITypeDepth", ")", "{", "xsiType", "=", "attributes", ".", "getValue", "(", "SchemaSymbols", ".", "URI_XSI", ",", "SchemaSymbols", ".", "XSI_TYPE", ")", ";", "}", "if", "(", "fCurrentType", "==", "null", "&&", "xsiType", "==", "null", ")", "{", "if", "(", "fElementDepth", "==", "0", ")", "{", "if", "(", "fDynamicValidation", "||", "fSchemaDynamicValidation", ")", "{", "if", "(", "fDocumentSource", "!=", "null", ")", "{", "fDocumentSource", ".", "setDocumentHandler", "(", "fDocumentHandler", ")", ";", "if", "(", "fDocumentHandler", "!=", "null", ")", "fDocumentHandler", ".", "setDocumentSource", "(", "fDocumentSource", ")", ";", "fElementDepth", "=", "-", "2", ";", "return", "augs", ";", "}", "fSkipValidationDepth", "=", "fElementDepth", ";", "if", "(", "fAugPSVI", ")", "augs", "=", "getEmptyAugs", "(", "augs", ")", ";", "return", "augs", ";", "}", "fXSIErrorReporter", ".", "fErrorReporter", ".", "reportError", "(", "XSMessageFormatter", ".", "SCHEMA_DOMAIN", ",", "\"", "cvc-elt.1.a", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ",", "XMLErrorReporter", ".", "SEVERITY_ERROR", ")", ";", "}", "else", "if", "(", "wildcard", "!=", "null", "&&", "wildcard", ".", "fProcessContents", "==", "XSWildcardDecl", ".", "PC_STRICT", ")", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.c", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "}", "fCurrentType", "=", "SchemaGrammar", ".", "fAnyType", ";", "fStrictAssess", "=", "false", ";", "fNFullValidationDepth", "=", "fElementDepth", ";", "fAppendBuffer", "=", "false", ";", "fXSIErrorReporter", ".", "pushContext", "(", ")", ";", "}", "else", "{", "fXSIErrorReporter", ".", "pushContext", "(", ")", ";", "if", "(", "xsiType", "!=", "null", ")", "{", "XSTypeDefinition", "oldType", "=", "fCurrentType", ";", "fCurrentType", "=", "getAndCheckXsiType", "(", "element", ",", "xsiType", ",", "attributes", ")", ";", "if", "(", "fCurrentType", "==", "null", ")", "{", "if", "(", "oldType", "==", "null", ")", "fCurrentType", "=", "SchemaGrammar", ".", "fAnyType", ";", "else", "fCurrentType", "=", "oldType", ";", "}", "}", "fNNoneValidationDepth", "=", "fElementDepth", ";", "if", "(", "fCurrentElemDecl", "!=", "null", "&&", "fCurrentElemDecl", ".", "getConstraintType", "(", ")", "==", "XSConstants", ".", "VC_FIXED", ")", "{", "fAppendBuffer", "=", "true", ";", "}", "else", "if", "(", "fCurrentType", ".", "getTypeCategory", "(", ")", "==", "XSTypeDefinition", ".", "SIMPLE_TYPE", ")", "{", "fAppendBuffer", "=", "true", ";", "}", "else", "{", "XSComplexTypeDecl", "ctype", "=", "(", "XSComplexTypeDecl", ")", "fCurrentType", ";", "fAppendBuffer", "=", "(", "ctype", ".", "fContentType", "==", "XSComplexTypeDecl", ".", "CONTENTTYPE_SIMPLE", ")", ";", "}", "}", "if", "(", "fCurrentElemDecl", "!=", "null", "&&", "fCurrentElemDecl", ".", "getAbstract", "(", ")", ")", "reportSchemaError", "(", "\"", "cvc-elt.2", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "if", "(", "fElementDepth", "==", "0", ")", "{", "fValidationRoot", "=", "element", ".", "rawname", ";", "}", "if", "(", "fNormalizeData", ")", "{", "fFirstChunk", "=", "true", ";", "fTrailing", "=", "false", ";", "fUnionType", "=", "false", ";", "fWhiteSpace", "=", "-", "1", ";", "}", "if", "(", "fCurrentType", ".", "getTypeCategory", "(", ")", "==", "XSTypeDefinition", ".", "COMPLEX_TYPE", ")", "{", "XSComplexTypeDecl", "ctype", "=", "(", "XSComplexTypeDecl", ")", "fCurrentType", ";", "if", "(", "ctype", ".", "getAbstract", "(", ")", ")", "{", "reportSchemaError", "(", "\"", "cvc-type.2", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "}", "if", "(", "fNormalizeData", ")", "{", "if", "(", "ctype", ".", "fContentType", "==", "XSComplexTypeDecl", ".", "CONTENTTYPE_SIMPLE", ")", "{", "if", "(", "ctype", ".", "fXSSimpleType", ".", "getVariety", "(", ")", "==", "XSSimpleType", ".", "VARIETY_UNION", ")", "{", "fUnionType", "=", "true", ";", "}", "else", "{", "try", "{", "fWhiteSpace", "=", "ctype", ".", "fXSSimpleType", ".", "getWhitespace", "(", ")", ";", "}", "catch", "(", "DatatypeException", "e", ")", "{", "}", "}", "}", "}", "}", "else", "if", "(", "fNormalizeData", ")", "{", "XSSimpleType", "dv", "=", "(", "XSSimpleType", ")", "fCurrentType", ";", "if", "(", "dv", ".", "getVariety", "(", ")", "==", "XSSimpleType", ".", "VARIETY_UNION", ")", "{", "fUnionType", "=", "true", ";", "}", "else", "{", "try", "{", "fWhiteSpace", "=", "dv", ".", "getWhitespace", "(", ")", ";", "}", "catch", "(", "DatatypeException", "e", ")", "{", "}", "}", "}", "fCurrentCM", "=", "null", ";", "if", "(", "fCurrentType", ".", "getTypeCategory", "(", ")", "==", "XSTypeDefinition", ".", "COMPLEX_TYPE", ")", "{", "fCurrentCM", "=", "(", "(", "XSComplexTypeDecl", ")", "fCurrentType", ")", ".", "getContentModel", "(", "fCMBuilder", ")", ";", "}", "fCurrCMState", "=", "null", ";", "if", "(", "fCurrentCM", "!=", "null", ")", "fCurrCMState", "=", "fCurrentCM", ".", "startContentModel", "(", ")", ";", "String", "xsiNil", "=", "attributes", ".", "getValue", "(", "SchemaSymbols", ".", "URI_XSI", ",", "SchemaSymbols", ".", "XSI_NIL", ")", ";", "if", "(", "xsiNil", "!=", "null", "&&", "fCurrentElemDecl", "!=", "null", ")", "fNil", "=", "getXsiNil", "(", "element", ",", "xsiNil", ")", ";", "XSAttributeGroupDecl", "attrGrp", "=", "null", ";", "if", "(", "fCurrentType", ".", "getTypeCategory", "(", ")", "==", "XSTypeDefinition", ".", "COMPLEX_TYPE", ")", "{", "XSComplexTypeDecl", "ctype", "=", "(", "XSComplexTypeDecl", ")", "fCurrentType", ";", "attrGrp", "=", "ctype", ".", "getAttrGrp", "(", ")", ";", "}", "if", "(", "fIDCChecking", ")", "{", "fValueStoreCache", ".", "startElement", "(", ")", ";", "fMatcherStack", ".", "pushContext", "(", ")", ";", "if", "(", "fCurrentElemDecl", "!=", "null", "&&", "fCurrentElemDecl", ".", "fIDCPos", ">", "0", ")", "{", "fIdConstraint", "=", "true", ";", "fValueStoreCache", ".", "initValueStoresFor", "(", "fCurrentElemDecl", ",", "this", ")", ";", "}", "}", "processAttributes", "(", "element", ",", "attributes", ",", "attrGrp", ")", ";", "if", "(", "attrGrp", "!=", "null", ")", "{", "addDefaultAttributes", "(", "element", ",", "attributes", ",", "attrGrp", ")", ";", "}", "int", "count", "=", "fMatcherStack", ".", "getMatcherCount", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "{", "XPathMatcher", "matcher", "=", "fMatcherStack", ".", "getMatcherAt", "(", "i", ")", ";", "matcher", ".", "startElement", "(", "element", ",", "attributes", ")", ";", "}", "if", "(", "fAugPSVI", ")", "{", "augs", "=", "getEmptyAugs", "(", "augs", ")", ";", "fCurrentPSVI", ".", "fValidationContext", "=", "fValidationRoot", ";", "fCurrentPSVI", ".", "fDeclaration", "=", "fCurrentElemDecl", ";", "fCurrentPSVI", ".", "fTypeDecl", "=", "fCurrentType", ";", "fCurrentPSVI", ".", "fNotation", "=", "fNotation", ";", "fCurrentPSVI", ".", "fNil", "=", "fNil", ";", "}", "return", "augs", ";", "}"], "idx": 11596, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "76348d1f67c20a658ff47ba009762372a7a47300", "function_name": "handleStartElement", "body_hash": "478d32b7b144073f92672727d78373dbda030532"}
{"code": "private void enumerateChmDirectoryListingList(ChmItsfHeader chmItsHeader,\n            ChmItspHeader chmItspHeader) throws TikaException {\n        try {\n            int startPmgl = chmItspHeader.getIndex_head();\n            int stopPmgl = chmItspHeader.getUnknown_0024();\n            int dir_offset = (int) (chmItsHeader.getDirOffset() + chmItspHeader\n                    .getHeader_len());\n            setDataOffset(chmItsHeader.getDataOffset());\n\n            /* loops over all pmgls */\n            byte[] dir_chunk = null;\n            Set<Integer> processed = new HashSet<>();\n            for (int i = startPmgl; i>=0; ) {\n                dir_chunk = new byte[(int) chmItspHeader.getBlock_len()];\n                int start = i * (int) chmItspHeader.getBlock_len() + dir_offset;\n                dir_chunk = ChmCommons\n                        .copyOfRange(getData(), start,\n                                start +(int) chmItspHeader.getBlock_len());\n\n                PMGLheader = new ChmPmglHeader();\n                PMGLheader.parse(dir_chunk, PMGLheader);\n                enumerateOneSegment(dir_chunk);\n                int nextBlock = PMGLheader.getBlockNext();\n                processed.add(i);\n                if (processed.contains(nextBlock)) {\n                    throw new ChmParsingException(\"already processed block; avoiding cycle\");\n                }\n                i=nextBlock;\n                dir_chunk = null;\n            }\n\n        } catch (ChmParsingException e) {\n            LOG.warn(\"Chm parse exception\", e);\n        } finally {\n            setData(null);\n        }\n    }", "code_tokens": ["private", "void", "enumerateChmDirectoryListingList", "(", "ChmItsfHeader", "chmItsHeader", ",", "ChmItspHeader", "chmItspHeader", ")", "throws", "TikaException", "{", "try", "{", "int", "startPmgl", "=", "chmItspHeader", ".", "getIndex_head", "(", ")", ";", "int", "stopPmgl", "=", "chmItspHeader", ".", "getUnknown_0024", "(", ")", ";", "int", "dir_offset", "=", "(", "int", ")", "(", "chmItsHeader", ".", "getDirOffset", "(", ")", "+", "chmItspHeader", ".", "getHeader_len", "(", ")", ")", ";", "setDataOffset", "(", "chmItsHeader", ".", "getDataOffset", "(", ")", ")", ";", "byte", "[", "]", "dir_chunk", "=", "null", ";", "Set", "<", "Integer", ">", "processed", "=", "new", "HashSet", "<", ">", "(", ")", ";", "for", "(", "int", "i", "=", "startPmgl", ";", "i", ">=", "0", ";", ")", "{", "dir_chunk", "=", "new", "byte", "[", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", "]", ";", "int", "start", "=", "i", "*", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", "+", "dir_offset", ";", "dir_chunk", "=", "ChmCommons", ".", "copyOfRange", "(", "getData", "(", ")", ",", "start", ",", "start", "+", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", ")", ";", "PMGLheader", "=", "new", "ChmPmglHeader", "(", ")", ";", "PMGLheader", ".", "parse", "(", "dir_chunk", ",", "PMGLheader", ")", ";", "enumerateOneSegment", "(", "dir_chunk", ")", ";", "int", "nextBlock", "=", "PMGLheader", ".", "getBlockNext", "(", ")", ";", "processed", ".", "add", "(", "i", ")", ";", "if", "(", "processed", ".", "contains", "(", "nextBlock", ")", ")", "{", "throw", "new", "ChmParsingException", "(", "\"", "already processed block; avoiding cycle", "\"", ")", ";", "}", "i", "=", "nextBlock", ";", "dir_chunk", "=", "null", ";", "}", "}", "catch", "(", "ChmParsingException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Chm parse exception", "\"", ",", "e", ")", ";", "}", "finally", "{", "setData", "(", "null", ")", ";", "}", "}"], "idx": 108888, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "5d983aad0b68a228f180686a4135ed8c7cd589f1", "function_name": "enumerateChmDirectoryListingList", "body_hash": "86850c4ef8c4c5595b7ab8ccf3e1abf936dd6286"}
{"code": "@BeforeEach\n    public void startServer() throws Exception\n    {\n        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n        sslContextFactory = new SslContextFactory.Server();\n        sslContextFactory.setKeyStorePath(keystore);\n        sslContextFactory.setKeyStorePassword(\"storepwd\");\n        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n\n        server = new Server();\n        HttpConnectionFactory http = new HttpConnectionFactory();\n        http.setInputBufferSize(512);\n        http.getHttpConfiguration().setRequestHeaderSize(512);\n        connector = new ServerConnector(server, sslContextFactory, http);\n        connector.setPort(0);\n        connector.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n\n        server.addConnector(connector);\n    }", "code_tokens": ["@", "BeforeEach", "public", "void", "startServer", "(", ")", "throws", "Exception", "{", "String", "keystore", "=", "MavenTestingUtils", ".", "getTestResourceFile", "(", "\"", "keystore", "\"", ")", ".", "getAbsolutePath", "(", ")", ";", "sslContextFactory", "=", "new", "SslContextFactory", ".", "Server", "(", ")", ";", "sslContextFactory", ".", "setKeyStorePath", "(", "keystore", ")", ";", "sslContextFactory", ".", "setKeyStorePassword", "(", "\"", "storepwd", "\"", ")", ";", "sslContextFactory", ".", "setKeyManagerPassword", "(", "\"", "keypwd", "\"", ")", ";", "server", "=", "new", "Server", "(", ")", ";", "HttpConnectionFactory", "http", "=", "new", "HttpConnectionFactory", "(", ")", ";", "http", ".", "setInputBufferSize", "(", "512", ")", ";", "http", ".", "getHttpConfiguration", "(", ")", ".", "setRequestHeaderSize", "(", "512", ")", ";", "connector", "=", "new", "ServerConnector", "(", "server", ",", "sslContextFactory", ",", "http", ")", ";", "connector", ".", "setPort", "(", "0", ")", ";", "connector", ".", "getConnectionFactory", "(", "HttpConnectionFactory", ".", "class", ")", ".", "getHttpConfiguration", "(", ")", ".", "setSendDateHeader", "(", "false", ")", ";", "server", ".", "addConnector", "(", "connector", ")", ";", "}"], "idx": 65382, "cwe": "CWE-59", "target": 0, "status": "FIXED", "commit": "00d379c94ba865dced2025c2d1bc3e2e0e41e880", "function_name": "startServer", "body_hash": "252ab6d244fa3cc569805ecf8e5261afca6720da"}
{"code": "public Socket connectSocket(\n            final Socket socket,\n            final InetSocketAddress remoteAddress,\n            final InetSocketAddress localAddress,\n            final HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        Args.notNull(remoteAddress, \"Remote address\");\n        Args.notNull(params, \"HTTP parameters\");\n        final HttpHost host;\n        if (remoteAddress instanceof HttpInetSocketAddress) {\n            host = ((HttpInetSocketAddress) remoteAddress).getHttpHost();\n        } else {\n            host = new HttpHost(remoteAddress.getHostName(), remoteAddress.getPort(), \"https\");\n        }\n        final int socketTimeout = HttpConnectionParams.getSoTimeout(params);\n        final int connectTimeout = HttpConnectionParams.getConnectionTimeout(params);\n        socket.setSoTimeout(socketTimeout);\n        return connectSocket(connectTimeout, socket, host, remoteAddress, localAddress, null);\n    }", "code_tokens": ["public", "Socket", "connectSocket", "(", "final", "Socket", "socket", ",", "final", "InetSocketAddress", "remoteAddress", ",", "final", "InetSocketAddress", "localAddress", ",", "final", "HttpParams", "params", ")", "throws", "IOException", ",", "UnknownHostException", ",", "ConnectTimeoutException", "{", "Args", ".", "notNull", "(", "remoteAddress", ",", "\"", "Remote address", "\"", ")", ";", "Args", ".", "notNull", "(", "params", ",", "\"", "HTTP parameters", "\"", ")", ";", "final", "HttpHost", "host", ";", "if", "(", "remoteAddress", "instanceof", "HttpInetSocketAddress", ")", "{", "host", "=", "(", "(", "HttpInetSocketAddress", ")", "remoteAddress", ")", ".", "getHttpHost", "(", ")", ";", "}", "else", "{", "host", "=", "new", "HttpHost", "(", "remoteAddress", ".", "getHostName", "(", ")", ",", "remoteAddress", ".", "getPort", "(", ")", ",", "\"", "https", "\"", ")", ";", "}", "final", "int", "socketTimeout", "=", "HttpConnectionParams", ".", "getSoTimeout", "(", "params", ")", ";", "final", "int", "connectTimeout", "=", "HttpConnectionParams", ".", "getConnectionTimeout", "(", "params", ")", ";", "socket", ".", "setSoTimeout", "(", "socketTimeout", ")", ";", "return", "connectSocket", "(", "connectTimeout", ",", "socket", ",", "host", ",", "remoteAddress", ",", "localAddress", ",", "null", ")", ";", "}"], "idx": 51175, "cwe": "CWE-399", "target": 0, "status": "FIXED", "commit": "09027e7286974bf6b61f4106395da2623121db8d", "function_name": "connectSocket", "body_hash": "83e7474a33144197470be32567b216d3c28e4379"}
{"code": "public File createTempFile(final Project project, String prefix, String suffix,\n            final File parentDir, final boolean deleteOnExit, final boolean createFile) {\n        File result;\n        final String parent;\n        if (parentDir != null) {\n            parent = parentDir.getPath();\n        } else if (project != null && project.getProperty(MagicNames.TMPDIR) != null) {\n            parent = project.getProperty(MagicNames.TMPDIR);\n        } else {\n            parent = System.getProperty(\"java.io.tmpdir\");\n        }\n        if (prefix == null) {\n            prefix = NULL_PLACEHOLDER;\n        }\n        if (suffix == null) {\n            suffix = NULL_PLACEHOLDER;\n        }\n\n        if (createFile) {\n            try {\n                final Path parentPath = new File(parent).toPath();\n                final PosixFileAttributeView parentPosixAttributes =\n                    Files.getFileAttributeView(parentPath, PosixFileAttributeView.class);\n                result = Files.createTempFile(parentPath, prefix, suffix,\n                    parentPosixAttributes != null ? TMPFILE_ATTRIBUTES : NO_TMPFILE_ATTRIBUTES)\n                    .toFile();\n            } catch (IOException e) {\n                throw new BuildException(\"Could not create tempfile in \"\n                        + parent, e);\n            }\n        } else {\n            DecimalFormat fmt = new DecimalFormat(\"#####\");\n            synchronized (rand) {\n                do {\n                    result = new File(parent, prefix\n                            + fmt.format(rand.nextInt(Integer.MAX_VALUE)) + suffix);\n                } while (result.exists());\n            }\n        }\n\n        if (deleteOnExit) {\n            result.deleteOnExit();\n        }\n        return result;\n    }", "code_tokens": ["public", "File", "createTempFile", "(", "final", "Project", "project", ",", "String", "prefix", ",", "String", "suffix", ",", "final", "File", "parentDir", ",", "final", "boolean", "deleteOnExit", ",", "final", "boolean", "createFile", ")", "{", "File", "result", ";", "final", "String", "parent", ";", "if", "(", "parentDir", "!=", "null", ")", "{", "parent", "=", "parentDir", ".", "getPath", "(", ")", ";", "}", "else", "if", "(", "project", "!=", "null", "&&", "project", ".", "getProperty", "(", "MagicNames", ".", "TMPDIR", ")", "!=", "null", ")", "{", "parent", "=", "project", ".", "getProperty", "(", "MagicNames", ".", "TMPDIR", ")", ";", "}", "else", "{", "parent", "=", "System", ".", "getProperty", "(", "\"", "java.io.tmpdir", "\"", ")", ";", "}", "if", "(", "prefix", "==", "null", ")", "{", "prefix", "=", "NULL_PLACEHOLDER", ";", "}", "if", "(", "suffix", "==", "null", ")", "{", "suffix", "=", "NULL_PLACEHOLDER", ";", "}", "if", "(", "createFile", ")", "{", "try", "{", "final", "Path", "parentPath", "=", "new", "File", "(", "parent", ")", ".", "toPath", "(", ")", ";", "final", "PosixFileAttributeView", "parentPosixAttributes", "=", "Files", ".", "getFileAttributeView", "(", "parentPath", ",", "PosixFileAttributeView", ".", "class", ")", ";", "result", "=", "Files", ".", "createTempFile", "(", "parentPath", ",", "prefix", ",", "suffix", ",", "parentPosixAttributes", "!=", "null", "?", "TMPFILE_ATTRIBUTES", ":", "NO_TMPFILE_ATTRIBUTES", ")", ".", "toFile", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "BuildException", "(", "\"", "Could not create tempfile in ", "\"", "+", "parent", ",", "e", ")", ";", "}", "}", "else", "{", "DecimalFormat", "fmt", "=", "new", "DecimalFormat", "(", "\"", "#####", "\"", ")", ";", "synchronized", "(", "rand", ")", "{", "do", "{", "result", "=", "new", "File", "(", "parent", ",", "prefix", "+", "fmt", ".", "format", "(", "rand", ".", "nextInt", "(", "Integer", ".", "MAX_VALUE", ")", ")", "+", "suffix", ")", ";", "}", "while", "(", "result", ".", "exists", "(", ")", ")", ";", "}", "}", "if", "(", "deleteOnExit", ")", "{", "result", ".", "deleteOnExit", "(", ")", ";", "}", "return", "result", ";", "}"], "idx": 115681, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "87ac51d3c22bcf7cfd0dc07cb0bd04a496e0d428", "function_name": "createTempFile", "body_hash": "586a708281b3d4734ab62a72fc535f748a3c426d"}
{"code": "public TimelineEventList doData(StaplerRequest req, @QueryParameter long min, @QueryParameter long max) throws IOException {\n        TimelineEventList result = new TimelineEventList();\n        for (Run r : builds.byTimestamp(min,max)) {\n            Event e = new Event();\n            e.start = new Date(r.getStartTimeInMillis());\n            e.end   = new Date(r.getStartTimeInMillis()+r.getDuration());\n            // due to SimileAjax.HTML.deEntify (in simile-ajax-bundle.js), \"&lt;\" are transformed back to \"<\", but not the \"&#60\";\n            // to protect against XSS\n            e.title = Util.escape(r.getFullDisplayName()).replace(\"&lt;\", \"&#60;\");\n            // what to put in the description?\n            // e.description = \"Longish description of event \"+r.getFullDisplayName();\n            // e.durationEvent = true;\n            e.link = req.getContextPath()+'/'+r.getUrl();\n            BallColor c = r.getIconColor();\n            e.color = String.format(\"#%06X\",c.getBaseColor().darker().getRGB()&0xFFFFFF);\n            e.classname = \"event-\"+c.noAnime().toString()+\" \" + (c.isAnimated()?\"animated\":\"\");\n            result.add(e);\n        }\n        return result;\n    }", "code_tokens": ["public", "TimelineEventList", "doData", "(", "StaplerRequest", "req", ",", "@", "QueryParameter", "long", "min", ",", "@", "QueryParameter", "long", "max", ")", "throws", "IOException", "{", "TimelineEventList", "result", "=", "new", "TimelineEventList", "(", ")", ";", "for", "(", "Run", "r", ":", "builds", ".", "byTimestamp", "(", "min", ",", "max", ")", ")", "{", "Event", "e", "=", "new", "Event", "(", ")", ";", "e", ".", "start", "=", "new", "Date", "(", "r", ".", "getStartTimeInMillis", "(", ")", ")", ";", "e", ".", "end", "=", "new", "Date", "(", "r", ".", "getStartTimeInMillis", "(", ")", "+", "r", ".", "getDuration", "(", ")", ")", ";", "e", ".", "title", "=", "Util", ".", "escape", "(", "r", ".", "getFullDisplayName", "(", ")", ")", ".", "replace", "(", "\"", "&lt;", "\"", ",", "\"", "&#60;", "\"", ")", ";", "e", ".", "link", "=", "req", ".", "getContextPath", "(", ")", "+", "'/'", "+", "r", ".", "getUrl", "(", ")", ";", "BallColor", "c", "=", "r", ".", "getIconColor", "(", ")", ";", "e", ".", "color", "=", "String", ".", "format", "(", "\"", "#%06X", "\"", ",", "c", ".", "getBaseColor", "(", ")", ".", "darker", "(", ")", ".", "getRGB", "(", ")", "&", "0xFFFFFF", ")", ";", "e", ".", "classname", "=", "\"", "event-", "\"", "+", "c", ".", "noAnime", "(", ")", ".", "toString", "(", ")", "+", "\"", " ", "\"", "+", "(", "c", ".", "isAnimated", "(", ")", "?", "\"", "animated", "\"", ":", "\"", "\"", ")", ";", "result", ".", "add", "(", "e", ")", ";", "}", "return", "result", ";", "}"], "idx": 77817, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "8697bdff0342421e22230028d84aaa265719e86c", "function_name": "doData", "body_hash": "9a63d3b186a8c2ff83bd0f1aa9a2c86cecafb172"}
{"code": "private void prepareRequest() {\n\n        // Translate the HTTP method code to a String.\n        byte methodCode = requestHeaderMessage.getByte();\n        if (methodCode != Constants.SC_M_JK_STORED) {\n            String methodName = Constants.getMethodForCode(methodCode - 1);\n            request.method().setString(methodName);\n        }\n\n        requestHeaderMessage.getBytes(request.protocol());\n        requestHeaderMessage.getBytes(request.requestURI());\n\n        requestHeaderMessage.getBytes(request.remoteAddr());\n        requestHeaderMessage.getBytes(request.remoteHost());\n        requestHeaderMessage.getBytes(request.localName());\n        request.setLocalPort(requestHeaderMessage.getInt());\n\n        boolean isSSL = requestHeaderMessage.getByte() != 0;\n        if (isSSL) {\n            request.scheme().setString(\"https\");\n        }\n\n        // Decode headers\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Set this every time in case limit has been changed via JMX\n        headers.setLimit(protocol.getMaxHeaderCount());\n\n        boolean contentLengthSet = false;\n        int hCount = requestHeaderMessage.getInt();\n        for(int i = 0 ; i < hCount ; i++) {\n            String hName = null;\n\n            // Header names are encoded as either an integer code starting\n            // with 0xA0, or as a normal string (in which case the first\n            // two bytes are the length).\n            int isc = requestHeaderMessage.peekInt();\n            int hId = isc & 0xFF;\n\n            MessageBytes vMB = null;\n            isc &= 0xFF00;\n            if(0xA000 == isc) {\n                requestHeaderMessage.getInt(); // To advance the read position\n                hName = Constants.getHeaderForCode(hId - 1);\n                vMB = headers.addValue(hName);\n            } else {\n                // reset hId -- if the header currently being read\n                // happens to be 7 or 8 bytes long, the code below\n                // will think it's the content-type header or the\n                // content-length header - SC_REQ_CONTENT_TYPE=7,\n                // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected\n                // behaviour.  see bug 5861 for more information.\n                hId = -1;\n                requestHeaderMessage.getBytes(tmpMB);\n                ByteChunk bc = tmpMB.getByteChunk();\n                vMB = headers.addValue(bc.getBuffer(),\n                        bc.getStart(), bc.getLength());\n            }\n\n            requestHeaderMessage.getBytes(vMB);\n\n            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Length\"))) {\n                long cl = vMB.getLong();\n                if (contentLengthSet) {\n                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                } else {\n                    contentLengthSet = true;\n                    // Set the content-length header for the request\n                    request.setContentLength(cl);\n                }\n            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Type\"))) {\n                // just read the content-type header, so set it\n                ByteChunk bchunk = vMB.getByteChunk();\n                request.contentType().setBytes(bchunk.getBytes(),\n                        bchunk.getOffset(),\n                        bchunk.getLength());\n            }\n        }\n\n        // Decode extra attributes\n        String secret = protocol.getSecret();\n        boolean secretPresentInRequest = false;\n        byte attributeCode;\n        while ((attributeCode = requestHeaderMessage.getByte())\n                != Constants.SC_A_ARE_DONE) {\n\n            switch (attributeCode) {\n\n            case Constants.SC_A_REQ_ATTRIBUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                String n = tmpMB.toString();\n                requestHeaderMessage.getBytes(tmpMB);\n                String v = tmpMB.toString();\n                /*\n                 * AJP13 misses to forward the local IP address and the\n                 * remote port. Allow the AJP connector to add this info via\n                 * private request attributes.\n                 * We will accept the forwarded data and remove it from the\n                 * public list of request attributes.\n                 */\n                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {\n                    request.localAddr().setString(v);\n                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {\n                    try {\n                        request.setRemotePort(Integer.parseInt(v));\n                    } catch (NumberFormatException nfe) {\n                        // Ignore invalid value\n                    }\n                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {\n                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);\n                } else if (n.equals(\"JK_LB_ACTIVATION\")) {\n                    request.setAttribute(n, v);\n                } else if (javaxAttributes.contains(n)) {\n                    request.setAttribute(n, v);\n                } else {\n                    // All 'known' attributes will be processed by the previous\n                    // blocks. Any remaining attribute is an 'arbitrary' one.\n                    Pattern pattern = protocol.getAllowedRequestAttributesPatternInternal();\n                    if (pattern == null) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    } else {\n                        Matcher m = pattern.matcher(n);\n                        if (m.matches()) {\n                            request.setAttribute(n, v);\n                        } else {\n                            response.setStatus(403);\n                            setErrorState(ErrorState.CLOSE_CLEAN, null);\n                        }\n                    }\n                }\n                break;\n\n            case Constants.SC_A_CONTEXT :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SERVLET_PATH :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_REMOTE_USER :\n                boolean tomcatAuthorization  = protocol.getTomcatAuthorization();\n                if (tomcatAuthorization || !protocol.getTomcatAuthentication()) {\n                    // Implies tomcatAuthentication == false\n                    requestHeaderMessage.getBytes(request.getRemoteUser());\n                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);\n                } else {\n                    // Ignore user information from reverse proxy\n                    requestHeaderMessage.getBytes(tmpMB);\n                }\n                break;\n\n            case Constants.SC_A_AUTH_TYPE :\n                if (protocol.getTomcatAuthentication()) {\n                    // ignore server\n                    requestHeaderMessage.getBytes(tmpMB);\n                } else {\n                    requestHeaderMessage.getBytes(request.getAuthType());\n                }\n                break;\n\n            case Constants.SC_A_QUERY_STRING :\n                requestHeaderMessage.getBytes(request.queryString());\n                break;\n\n            case Constants.SC_A_JVM_ROUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SSL_CERT :\n                // SSL certificate extraction is lazy, moved to JkCoyoteHandler\n                requestHeaderMessage.getBytes(certificates);\n                break;\n\n            case Constants.SC_A_SSL_CIPHER :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_SESSION :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.SESSION_ID_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_KEY_SIZE :\n                request.setAttribute(SSLSupport.KEY_SIZE_KEY,\n                        Integer.valueOf(requestHeaderMessage.getInt()));\n                break;\n\n            case Constants.SC_A_STORED_METHOD:\n                requestHeaderMessage.getBytes(request.method());\n                break;\n\n            case Constants.SC_A_SECRET:\n                requestHeaderMessage.getBytes(tmpMB);\n                if (secret != null) {\n                    secretPresentInRequest = true;\n                    if (!tmpMB.equals(secret)) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    }\n                }\n                break;\n\n            default:\n                // Ignore unknown attribute for backward compatibility\n                break;\n\n            }\n\n        }\n\n        // Check if secret was submitted if required\n        if ((secret != null) && !secretPresentInRequest) {\n            response.setStatus(403);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n        }\n\n        // Check for a full URI (including protocol://host:port/)\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\"\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + slashPos,\n                            uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                        slashPos - pos - 3);\n            }\n\n        }\n\n        MessageBytes valueMB = request.getMimeHeaders().getValue(\"host\");\n        parseHost(valueMB);\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "{", "byte", "methodCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ";", "if", "(", "methodCode", "!=", "Constants", ".", "SC_M_JK_STORED", ")", "{", "String", "methodName", "=", "Constants", ".", "getMethodForCode", "(", "methodCode", "-", "1", ")", ";", "request", ".", "method", "(", ")", ".", "setString", "(", "methodName", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "protocol", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "requestURI", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteAddr", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteHost", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "localName", "(", ")", ")", ";", "request", ".", "setLocalPort", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ";", "boolean", "isSSL", "=", "requestHeaderMessage", ".", "getByte", "(", ")", "!=", "0", ";", "if", "(", "isSSL", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "headers", ".", "setLimit", "(", "protocol", ".", "getMaxHeaderCount", "(", ")", ")", ";", "boolean", "contentLengthSet", "=", "false", ";", "int", "hCount", "=", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hCount", ";", "i", "++", ")", "{", "String", "hName", "=", "null", ";", "int", "isc", "=", "requestHeaderMessage", ".", "peekInt", "(", ")", ";", "int", "hId", "=", "isc", "&", "0xFF", ";", "MessageBytes", "vMB", "=", "null", ";", "isc", "&=", "0xFF00", ";", "if", "(", "0xA000", "==", "isc", ")", "{", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "hName", "=", "Constants", ".", "getHeaderForCode", "(", "hId", "-", "1", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "hName", ")", ";", "}", "else", "{", "hId", "=", "-", "1", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "ByteChunk", "bc", "=", "tmpMB", ".", "getByteChunk", "(", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "bc", ".", "getBuffer", "(", ")", ",", "bc", ".", "getStart", "(", ")", ",", "bc", ".", "getLength", "(", ")", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "vMB", ")", ";", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_LENGTH", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Length", "\"", ")", ")", ")", "{", "long", "cl", "=", "vMB", ".", "getLong", "(", ")", ";", "if", "(", "contentLengthSet", ")", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "else", "{", "contentLengthSet", "=", "true", ";", "request", ".", "setContentLength", "(", "cl", ")", ";", "}", "}", "else", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_TYPE", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Type", "\"", ")", ")", ")", "{", "ByteChunk", "bchunk", "=", "vMB", ".", "getByteChunk", "(", ")", ";", "request", ".", "contentType", "(", ")", ".", "setBytes", "(", "bchunk", ".", "getBytes", "(", ")", ",", "bchunk", ".", "getOffset", "(", ")", ",", "bchunk", ".", "getLength", "(", ")", ")", ";", "}", "}", "String", "secret", "=", "protocol", ".", "getSecret", "(", ")", ";", "boolean", "secretPresentInRequest", "=", "false", ";", "byte", "attributeCode", ";", "while", "(", "(", "attributeCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ")", "!=", "Constants", ".", "SC_A_ARE_DONE", ")", "{", "switch", "(", "attributeCode", ")", "{", "case", "Constants", ".", "SC_A_REQ_ATTRIBUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "n", "=", "tmpMB", ".", "toString", "(", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "v", "=", "tmpMB", ".", "toString", "(", ")", ";", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_LOCAL_ADDR", ")", ")", "{", "request", ".", "localAddr", "(", ")", ".", "setString", "(", "v", ")", ";", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_REMOTE_PORT", ")", ")", "{", "try", "{", "request", ".", "setRemotePort", "(", "Integer", ".", "parseInt", "(", "v", ")", ")", ";", "}", "catch", "(", "NumberFormatException", "nfe", ")", "{", "}", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_SSL_PROTOCOL", ")", ")", "{", "request", ".", "setAttribute", "(", "SSLSupport", ".", "PROTOCOL_VERSION_KEY", ",", "v", ")", ";", "}", "else", "if", "(", "n", ".", "equals", "(", "\"", "JK_LB_ACTIVATION", "\"", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "if", "(", "javaxAttributes", ".", "contains", "(", "n", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "{", "Pattern", "pattern", "=", "protocol", ".", "getAllowedRequestAttributesPatternInternal", "(", ")", ";", "if", "(", "pattern", "==", "null", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "else", "{", "Matcher", "m", "=", "pattern", ".", "matcher", "(", "n", ")", ";", "if", "(", "m", ".", "matches", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "break", ";", "case", "Constants", ".", "SC_A_CONTEXT", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SERVLET_PATH", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_REMOTE_USER", ":", "boolean", "tomcatAuthorization", "=", "protocol", ".", "getTomcatAuthorization", "(", ")", ";", "if", "(", "tomcatAuthorization", "||", "!", "protocol", ".", "getTomcatAuthentication", "(", ")", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getRemoteUser", "(", ")", ")", ";", "request", ".", "setRemoteUserNeedsAuthorization", "(", "tomcatAuthorization", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_AUTH_TYPE", ":", "if", "(", "protocol", ".", "getTomcatAuthentication", "(", ")", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getAuthType", "(", ")", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_QUERY_STRING", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "queryString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_JVM_ROUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CERT", ":", "requestHeaderMessage", ".", "getBytes", "(", "certificates", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CIPHER", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "CIPHER_SUITE_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_SESSION", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "SESSION_ID_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_KEY_SIZE", ":", "request", ".", "setAttribute", "(", "SSLSupport", ".", "KEY_SIZE_KEY", ",", "Integer", ".", "valueOf", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_STORED_METHOD", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "method", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SECRET", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "if", "(", "secret", "!=", "null", ")", "{", "secretPresentInRequest", "=", "true", ";", "if", "(", "!", "tmpMB", ".", "equals", "(", "secret", ")", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "break", ";", "default", ":", "break", ";", "}", "}", "if", "(", "(", "secret", "!=", "null", ")", "&&", "!", "secretPresentInRequest", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "uriBC", ".", "indexOf", "(", "\"", "://", "\"", ",", "0", ",", "3", ",", "4", ")", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "-", "1", ";", "if", "(", "pos", "!=", "-", "1", ")", "{", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", "+", "3", ")", ";", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "1", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "MessageBytes", "hostMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "3", ",", "slashPos", "-", "pos", "-", "3", ")", ";", "}", "}", "MessageBytes", "valueMB", "=", "request", ".", "getMimeHeaders", "(", ")", ".", "getValue", "(", "\"", "host", "\"", ")", ";", "parseHost", "(", "valueMB", ")", ";", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 112580, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "7a1406a3cd20fdd90656add6cd8f27ef8f24e957", "function_name": "prepareRequest", "body_hash": "d3f26b1d2a254202c68693c73fb9bf1e4f9417c7"}
{"code": "public void parseDmozFile(File dmozFile, int subsetDenom,\n      boolean includeAdult, int skew, Pattern topicPattern) \n              throws IOException, SAXException, ParserConfigurationException {\n\n    SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n    parserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    parserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    SAXParser parser = parserFactory.newSAXParser();\n    XMLReader reader = parser.getXMLReader();\n    reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n    // Create our own processor to receive SAX events\n    RDFProcessor rp = new RDFProcessor(reader, subsetDenom, includeAdult, skew,\n        topicPattern);\n    reader.setContentHandler(rp);\n    reader.setErrorHandler(rp);\n    LOG.info(\"skew = \" + rp.hashSkew);\n\n    //\n    // Open filtered text stream. The TextFilter makes sure that\n    // only appropriate XML-approved Text characters are received.\n    // Any non-conforming characters are silently skipped.\n    //\n    try (XMLCharFilter in = new XMLCharFilter(new BufferedReader(\n        new InputStreamReader(new BufferedInputStream(new FileInputStream(\n            dmozFile)), \"UTF-8\")))) {\n      InputSource is = new InputSource(in);\n      reader.parse(is);\n    } catch (Exception e) {\n      if (LOG.isErrorEnabled()) {\n        LOG.error(e.toString());\n      }\n      System.exit(0);\n    }\n  }", "code_tokens": ["public", "void", "parseDmozFile", "(", "File", "dmozFile", ",", "int", "subsetDenom", ",", "boolean", "includeAdult", ",", "int", "skew", ",", "Pattern", "topicPattern", ")", "throws", "IOException", ",", "SAXException", ",", "ParserConfigurationException", "{", "SAXParserFactory", "parserFactory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "parserFactory", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "parserFactory", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "SAXParser", "parser", "=", "parserFactory", ".", "newSAXParser", "(", ")", ";", "XMLReader", "reader", "=", "parser", ".", "getXMLReader", "(", ")", ";", "reader", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "RDFProcessor", "rp", "=", "new", "RDFProcessor", "(", "reader", ",", "subsetDenom", ",", "includeAdult", ",", "skew", ",", "topicPattern", ")", ";", "reader", ".", "setContentHandler", "(", "rp", ")", ";", "reader", ".", "setErrorHandler", "(", "rp", ")", ";", "LOG", ".", "info", "(", "\"", "skew = ", "\"", "+", "rp", ".", "hashSkew", ")", ";", "try", "(", "XMLCharFilter", "in", "=", "new", "XMLCharFilter", "(", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "new", "BufferedInputStream", "(", "new", "FileInputStream", "(", "dmozFile", ")", ")", ",", "\"", "UTF-8", "\"", ")", ")", ")", ")", "{", "InputSource", "is", "=", "new", "InputSource", "(", "in", ")", ";", "reader", ".", "parse", "(", "is", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "if", "(", "LOG", ".", "isErrorEnabled", "(", ")", ")", "{", "LOG", ".", "error", "(", "e", ".", "toString", "(", ")", ")", ";", "}", "System", ".", "exit", "(", "0", ")", ";", "}", "}"], "idx": 69588, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "59c63c7d8a13b0de1fd1da6aa4a1ab6e20fa478d", "function_name": "parseDmozFile", "body_hash": "01c20638105cc27f6f625ec45dcab2a42ff4e2e6"}
{"code": "private void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        for (Stream stream : streams.values()) {\n            // The connection is closing. Close the associated streams as no\n            // longer required.\n            stream.receiveReset(Http2Error.CANCEL.getCode());\n        }\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }", "code_tokens": ["private", "void", "close", "(", ")", "{", "connectionState", ".", "set", "(", "ConnectionState", ".", "CLOSED", ")", ";", "for", "(", "Stream", "stream", ":", "streams", ".", "values", "(", ")", ")", "{", "stream", ".", "receiveReset", "(", "Http2Error", ".", "CANCEL", ".", "getCode", "(", ")", ")", ";", "}", "try", "{", "socketWrapper", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "upgradeHandler.socketCloseFailed", "\"", ")", ",", "ioe", ")", ";", "}", "}"], "idx": 53639, "cwe": "CWE-404", "target": 0, "status": "FIXED", "commit": "5496e193a89b8b8b3177e516358df2f07ab852b3", "function_name": "close", "body_hash": "766587c6212dbba0eed5a9f1f20163eab488916e"}
{"code": "@Override\n    public String getWhyKeepLog() {\n        // if any of the downstream project is configured with 'keep dependency component',\n        // we need to keep this log\n        OUTER:\n        for (AbstractProject<?,?> p : getParent().getDownstreamProjects()) {\n            if (!p.isKeepDependencies()) continue;\n\n            AbstractBuild<?,?> fb = p.getFirstBuild();\n            if (fb==null)        continue; // no active record\n\n            // is there any active build that depends on us?\n            for (int i : getDownstreamRelationship(p).listNumbersReverse()) {\n                // TODO: this is essentially a \"find intersection between two sparse sequences\"\n                // and we should be able to do much better.\n\n                if (i<fb.getNumber())\n                    continue OUTER; // all the other records are younger than the first record, so pointless to search.\n\n                AbstractBuild<?,?> b = p.getBuildByNumber(i);\n                if (b!=null)\n                    return Messages.AbstractBuild_KeptBecause(p.hasPermission(Item.READ) ? b.toString() : \"?\");\n            }\n        }\n\n        return super.getWhyKeepLog();\n    }", "code_tokens": ["@", "Override", "public", "String", "getWhyKeepLog", "(", ")", "{", "OUTER", ":", "for", "(", "AbstractProject", "<", "?", ",", "?", ">", "p", ":", "getParent", "(", ")", ".", "getDownstreamProjects", "(", ")", ")", "{", "if", "(", "!", "p", ".", "isKeepDependencies", "(", ")", ")", "continue", ";", "AbstractBuild", "<", "?", ",", "?", ">", "fb", "=", "p", ".", "getFirstBuild", "(", ")", ";", "if", "(", "fb", "==", "null", ")", "continue", ";", "for", "(", "int", "i", ":", "getDownstreamRelationship", "(", "p", ")", ".", "listNumbersReverse", "(", ")", ")", "{", "if", "(", "i", "<", "fb", ".", "getNumber", "(", ")", ")", "continue", "OUTER", ";", "AbstractBuild", "<", "?", ",", "?", ">", "b", "=", "p", ".", "getBuildByNumber", "(", "i", ")", ";", "if", "(", "b", "!=", "null", ")", "return", "Messages", ".", "AbstractBuild_KeptBecause", "(", "p", ".", "hasPermission", "(", "Item", ".", "READ", ")", "?", "b", ".", "toString", "(", ")", ":", "\"", "?", "\"", ")", ";", "}", "}", "return", "super", ".", "getWhyKeepLog", "(", ")", ";", "}"], "idx": 84493, "cwe": "CWE-862", "target": 0, "status": "FIXED", "commit": "b2083a387a5bdb6f7ee7f7c81a1f6312aca2a558", "function_name": "getWhyKeepLog", "body_hash": "bd3e1911afd7eb08838f19eba1e9c7d45d42850b"}
{"code": "public String getRepoPassword() {\n        if (repoPassword != null) {\n            String plainText = repoPassword.getPlainText();\n            if (!plainText.isEmpty()) {\n                return plainText;\n            }\n        }\n        return \"admin\";\n    }", "code_tokens": ["public", "String", "getRepoPassword", "(", ")", "{", "if", "(", "repoPassword", "!=", "null", ")", "{", "String", "plainText", "=", "repoPassword", ".", "getPlainText", "(", ")", ";", "if", "(", "!", "plainText", ".", "isEmpty", "(", ")", ")", "{", "return", "plainText", ";", "}", "}", "return", "\"", "admin", "\"", ";", "}"], "idx": 63887, "cwe": "CWE-522", "target": 0, "status": "FIXED", "commit": "a2511b9", "function_name": "getRepoPassword", "body_hash": "c150ada13dac9620de9c85404c8e4215387f3b70"}
{"code": "@Before\n    public void createCaptor() throws Exception {\n        applicationEventPublisher = mock(ApplicationEventPublisher.class);\n        ClientAdminEventPublisher eventPublisher = (ClientAdminEventPublisher) getWebApplicationContext().getBean(\"clientAdminEventPublisher\");\n        originalApplicationEventPublisher = eventPublisher.getPublisher();\n        eventPublisher.setApplicationEventPublisher(applicationEventPublisher);\n        captor = ArgumentCaptor.forClass(AbstractUaaEvent.class);\n        scimUserEndpoints = getWebApplicationContext().getBean(ScimUserEndpoints.class);\n        scimGroupEndpoints = getWebApplicationContext().getBean(ScimGroupEndpoints.class);\n\n        testClient = new TestClient(getMockMvc());\n        testAccounts = UaaTestAccounts.standard(null);\n        adminToken = testClient.getClientCredentialsOAuthAccessToken(\n                testAccounts.getAdminClientId(),\n                testAccounts.getAdminClientSecret(),\n                \"clients.admin clients.read clients.write clients.secret scim.read scim.write\");\n\n        testPassword = \"password\";\n        String username = new RandomValueStringGenerator().generate() + \"@test.org\";\n        testUser = new ScimUser(null, username, \"givenname\",\"familyname\");\n        testUser.setPrimaryEmail(username);\n        testUser.setPassword(testPassword);\n        testUser = MockMvcUtils.utils().createUser(getMockMvc(), adminToken, testUser);\n        testUser.setPassword(testPassword);\n\n        applicationEventPublisher = mock(ApplicationEventPublisher.class);\n        eventPublisher.setApplicationEventPublisher(applicationEventPublisher);\n        captor = ArgumentCaptor.forClass(AbstractUaaEvent.class);\n    }", "code_tokens": ["@", "Before", "public", "void", "createCaptor", "(", ")", "throws", "Exception", "{", "applicationEventPublisher", "=", "mock", "(", "ApplicationEventPublisher", ".", "class", ")", ";", "ClientAdminEventPublisher", "eventPublisher", "=", "(", "ClientAdminEventPublisher", ")", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "\"", "clientAdminEventPublisher", "\"", ")", ";", "originalApplicationEventPublisher", "=", "eventPublisher", ".", "getPublisher", "(", ")", ";", "eventPublisher", ".", "setApplicationEventPublisher", "(", "applicationEventPublisher", ")", ";", "captor", "=", "ArgumentCaptor", ".", "forClass", "(", "AbstractUaaEvent", ".", "class", ")", ";", "scimUserEndpoints", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "ScimUserEndpoints", ".", "class", ")", ";", "scimGroupEndpoints", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "ScimGroupEndpoints", ".", "class", ")", ";", "testClient", "=", "new", "TestClient", "(", "getMockMvc", "(", ")", ")", ";", "testAccounts", "=", "UaaTestAccounts", ".", "standard", "(", "null", ")", ";", "adminToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "testAccounts", ".", "getAdminClientId", "(", ")", ",", "testAccounts", ".", "getAdminClientSecret", "(", ")", ",", "\"", "clients.admin clients.read clients.write clients.secret scim.read scim.write", "\"", ")", ";", "testPassword", "=", "\"", "password", "\"", ";", "String", "username", "=", "new", "RandomValueStringGenerator", "(", ")", ".", "generate", "(", ")", "+", "\"", "@test.org", "\"", ";", "testUser", "=", "new", "ScimUser", "(", "null", ",", "username", ",", "\"", "givenname", "\"", ",", "\"", "familyname", "\"", ")", ";", "testUser", ".", "setPrimaryEmail", "(", "username", ")", ";", "testUser", ".", "setPassword", "(", "testPassword", ")", ";", "testUser", "=", "MockMvcUtils", ".", "utils", "(", ")", ".", "createUser", "(", "getMockMvc", "(", ")", ",", "adminToken", ",", "testUser", ")", ";", "testUser", ".", "setPassword", "(", "testPassword", ")", ";", "applicationEventPublisher", "=", "mock", "(", "ApplicationEventPublisher", ".", "class", ")", ";", "eventPublisher", ".", "setApplicationEventPublisher", "(", "applicationEventPublisher", ")", ";", "captor", "=", "ArgumentCaptor", ".", "forClass", "(", "AbstractUaaEvent", ".", "class", ")", ";", "}"], "idx": 92766, "cwe": "CWE-89", "target": 1, "status": "VULNERABLE", "commit": "6bf1c0ae1abc9aaba957708e0b2dfb6a70aab826", "function_name": "createCaptor", "body_hash": "3725aae39665885ac862e2736dfefac40e21e436"}
{"code": "public void handleMessage(Message message) {\n        Exchange ex = message.getExchange();\n        BindingOperationInfo binding = ex.get(BindingOperationInfo.class);\n        //if we get this far, we're going to be outputting some valid content, but we COULD\n        //also be \"echoing\" some of the content from the input.   Thus, we need to \n        //mark it as requiring the input to be cached.   \n        message.put(\"cxf.io.cacheinput\", Boolean.TRUE);\n        if (null != binding && null != binding.getOperationInfo() && binding.getOperationInfo().isOneWay()) {\n            closeInput(message);\n            return;\n        }\n        Message out = ex.getOutMessage();\n        if (out != null) {\n            getBackChannelConduit(message);\n            if (binding != null) {\n                out.put(MessageInfo.class, binding.getOperationInfo().getOutput());\n                out.put(BindingMessageInfo.class, binding.getOutput());\n            }\n            \n            InterceptorChain outChain = out.getInterceptorChain();\n            if (outChain == null) {\n                outChain = OutgoingChainInterceptor.getChain(ex, chainCache);\n                out.setInterceptorChain(outChain);\n            }\n            outChain.doIntercept(out);\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "{", "Exchange", "ex", "=", "message", ".", "getExchange", "(", ")", ";", "BindingOperationInfo", "binding", "=", "ex", ".", "get", "(", "BindingOperationInfo", ".", "class", ")", ";", "message", ".", "put", "(", "\"", "cxf.io.cacheinput", "\"", ",", "Boolean", ".", "TRUE", ")", ";", "if", "(", "null", "!=", "binding", "&&", "null", "!=", "binding", ".", "getOperationInfo", "(", ")", "&&", "binding", ".", "getOperationInfo", "(", ")", ".", "isOneWay", "(", ")", ")", "{", "closeInput", "(", "message", ")", ";", "return", ";", "}", "Message", "out", "=", "ex", ".", "getOutMessage", "(", ")", ";", "if", "(", "out", "!=", "null", ")", "{", "getBackChannelConduit", "(", "message", ")", ";", "if", "(", "binding", "!=", "null", ")", "{", "out", ".", "put", "(", "MessageInfo", ".", "class", ",", "binding", ".", "getOperationInfo", "(", ")", ".", "getOutput", "(", ")", ")", ";", "out", ".", "put", "(", "BindingMessageInfo", ".", "class", ",", "binding", ".", "getOutput", "(", ")", ")", ";", "}", "InterceptorChain", "outChain", "=", "out", ".", "getInterceptorChain", "(", ")", ";", "if", "(", "outChain", "==", "null", ")", "{", "outChain", "=", "OutgoingChainInterceptor", ".", "getChain", "(", "ex", ",", "chainCache", ")", ";", "out", ".", "setInterceptorChain", "(", "outChain", ")", ";", "}", "outChain", ".", "doIntercept", "(", "out", ")", ";", "}", "}"], "idx": 51124, "cwe": "CWE-399", "target": 0, "status": "FIXED", "commit": "35cd29270b77b489cb23552637d66d47ce480f4c", "function_name": "handleMessage", "body_hash": "fb706349217f0ecedcecc06408540f6ec710e8fc"}
{"code": "public void check(String hostname, List<Certificate> peerCertificates)\n      throws SSLPeerUnverifiedException {\n    if (trustRootIndex != null) {\n      peerCertificates = new CertificateChainCleaner(trustRootIndex).clean(peerCertificates);\n    }\n\n    Set<ByteString> pins = findMatchingPins(hostname);\n\n    if (pins == null) return;\n\n    for (int i = 0, size = peerCertificates.size(); i < size; i++) {\n      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);\n      if (pins.contains(sha1(x509Certificate))) return; // Success!\n    }\n\n    // If we couldn't find a matching pin, format a nice exception.\n    StringBuilder message = new StringBuilder()\n        .append(\"Certificate pinning failure!\")\n        .append(\"\\n  Peer certificate chain:\");\n    for (int i = 0, size = peerCertificates.size(); i < size; i++) {\n      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);\n      message.append(\"\\n    \").append(pin(x509Certificate))\n          .append(\": \").append(x509Certificate.getSubjectDN().getName());\n    }\n    message.append(\"\\n  Pinned certificates for \").append(hostname).append(\":\");\n    for (ByteString pin : pins) {\n      message.append(\"\\n    sha1/\").append(pin.base64());\n    }\n    throw new SSLPeerUnverifiedException(message.toString());\n  }", "code_tokens": ["public", "void", "check", "(", "String", "hostname", ",", "List", "<", "Certificate", ">", "peerCertificates", ")", "throws", "SSLPeerUnverifiedException", "{", "if", "(", "trustRootIndex", "!=", "null", ")", "{", "peerCertificates", "=", "new", "CertificateChainCleaner", "(", "trustRootIndex", ")", ".", "clean", "(", "peerCertificates", ")", ";", "}", "Set", "<", "ByteString", ">", "pins", "=", "findMatchingPins", "(", "hostname", ")", ";", "if", "(", "pins", "==", "null", ")", "return", ";", "for", "(", "int", "i", "=", "0", ",", "size", "=", "peerCertificates", ".", "size", "(", ")", ";", "i", "<", "size", ";", "i", "++", ")", "{", "X509Certificate", "x509Certificate", "=", "(", "X509Certificate", ")", "peerCertificates", ".", "get", "(", "i", ")", ";", "if", "(", "pins", ".", "contains", "(", "sha1", "(", "x509Certificate", ")", ")", ")", "return", ";", "}", "StringBuilder", "message", "=", "new", "StringBuilder", "(", ")", ".", "append", "(", "\"", "Certificate pinning failure!", "\"", ")", ".", "append", "(", "\"", "\\n", "  Peer certificate chain:", "\"", ")", ";", "for", "(", "int", "i", "=", "0", ",", "size", "=", "peerCertificates", ".", "size", "(", ")", ";", "i", "<", "size", ";", "i", "++", ")", "{", "X509Certificate", "x509Certificate", "=", "(", "X509Certificate", ")", "peerCertificates", ".", "get", "(", "i", ")", ";", "message", ".", "append", "(", "\"", "\\n", "    ", "\"", ")", ".", "append", "(", "pin", "(", "x509Certificate", ")", ")", ".", "append", "(", "\"", ": ", "\"", ")", ".", "append", "(", "x509Certificate", ".", "getSubjectDN", "(", ")", ".", "getName", "(", ")", ")", ";", "}", "message", ".", "append", "(", "\"", "\\n", "  Pinned certificates for ", "\"", ")", ".", "append", "(", "hostname", ")", ".", "append", "(", "\"", ":", "\"", ")", ";", "for", "(", "ByteString", "pin", ":", "pins", ")", "{", "message", ".", "append", "(", "\"", "\\n", "    sha1/", "\"", ")", ".", "append", "(", "pin", ".", "base64", "(", ")", ")", ";", "}", "throw", "new", "SSLPeerUnverifiedException", "(", "message", ".", "toString", "(", ")", ")", ";", "}"], "idx": 40161, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "3ccb46dd16b6ec98f70b0ee53eafe5ed6380891e", "function_name": "check", "body_hash": "b93284ae8c9b3183c8d95fdfdd49df39955ece11"}
{"code": "@Override\n    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName)\n            throws InvocationTargetException {\n        try {\n            Digester digester = new Digester();\n            digester.setValidating(false);\n            digester.setClassLoader(LintParser.class.getClassLoader());\n\n            List<LintIssue> issues = new ArrayList<LintIssue>();\n            digester.push(issues);\n\n            String issueXPath = \"issues/issue\";\n            digester.addObjectCreate(issueXPath, LintIssue.class);\n            digester.addSetProperties(issueXPath);\n            digester.addSetNext(issueXPath, \"add\");\n\n            String locationXPath = issueXPath + \"/location\";\n            digester.addObjectCreate(locationXPath, Location.class);\n            digester.addSetProperties(locationXPath);\n            digester.addSetNext(locationXPath, \"addLocation\", Location.class.getName());\n\n            digester.parse(file);\n\n            return convert(issues, moduleName);\n        } catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        } catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }", "code_tokens": ["@", "Override", "public", "Collection", "<", "FileAnnotation", ">", "parse", "(", "final", "InputStream", "file", ",", "final", "String", "moduleName", ")", "throws", "InvocationTargetException", "{", "try", "{", "Digester", "digester", "=", "new", "Digester", "(", ")", ";", "digester", ".", "setValidating", "(", "false", ")", ";", "digester", ".", "setClassLoader", "(", "LintParser", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "List", "<", "LintIssue", ">", "issues", "=", "new", "ArrayList", "<", "LintIssue", ">", "(", ")", ";", "digester", ".", "push", "(", "issues", ")", ";", "String", "issueXPath", "=", "\"", "issues/issue", "\"", ";", "digester", ".", "addObjectCreate", "(", "issueXPath", ",", "LintIssue", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "issueXPath", ")", ";", "digester", ".", "addSetNext", "(", "issueXPath", ",", "\"", "add", "\"", ")", ";", "String", "locationXPath", "=", "issueXPath", "+", "\"", "/location", "\"", ";", "digester", ".", "addObjectCreate", "(", "locationXPath", ",", "Location", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "locationXPath", ")", ";", "digester", ".", "addSetNext", "(", "locationXPath", ",", "\"", "addLocation", "\"", ",", "Location", ".", "class", ".", "getName", "(", ")", ")", ";", "digester", ".", "parse", "(", "file", ")", ";", "return", "convert", "(", "issues", ",", "moduleName", ")", ";", "}", "catch", "(", "IOException", "exception", ")", "{", "throw", "new", "InvocationTargetException", "(", "exception", ")", ";", "}", "catch", "(", "SAXException", "exception", ")", "{", "throw", "new", "InvocationTargetException", "(", "exception", ")", ";", "}", "}"], "idx": 69583, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "4a19f962ebde3f705880b0e8148731d8dac9db2d", "function_name": "parse", "body_hash": "a93fa04220320c1f7532de685a0186b8124c3808"}
{"code": "@Restricted(NoExternalUse.class)\n    public User getUser(String id) {\n        return User.getById(id, User.ALLOW_USER_CREATION_VIA_URL && hasPermission(Jenkins.ADMINISTER));\n    }", "code_tokens": ["@", "Restricted", "(", "NoExternalUse", ".", "class", ")", "public", "User", "getUser", "(", "String", "id", ")", "{", "return", "User", ".", "getById", "(", "id", ",", "User", ".", "ALLOW_USER_CREATION_VIA_URL", "&&", "hasPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ")", ";", "}"], "idx": 98175, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "01157a699f611ca7492e872103ac01526a982cf2", "function_name": "getUser", "body_hash": "260490594deae0f5c39e4dad6b0542679c2dcbc2"}
{"code": "protected Object readResolve()\n        throws ObjectStreamException {\n        AbstractBrokerFactory factory = getPooledFactory(_conf);\n        if (factory != null)\n            return factory;\n\n        // reset these transient fields to empty values\n        _transactional = new ConcurrentHashMap();\n        _brokers = new ConcurrentReferenceHashSet(\n                ConcurrentReferenceHashSet.WEAK);\n\n        // turn off logging while de-serializing BrokerFactory\n        String saveLogConfig = _conf.getLog();\n        _conf.setLog(\"none\");\n        makeReadOnly();\n        // re-enable any logging which was in effect\n        _conf.setLog(saveLogConfig);\n        \n        return this;\n    }", "code_tokens": ["protected", "Object", "readResolve", "(", ")", "throws", "ObjectStreamException", "{", "AbstractBrokerFactory", "factory", "=", "getPooledFactory", "(", "_conf", ")", ";", "if", "(", "factory", "!=", "null", ")", "return", "factory", ";", "_transactional", "=", "new", "ConcurrentHashMap", "(", ")", ";", "_brokers", "=", "new", "ConcurrentReferenceHashSet", "(", "ConcurrentReferenceHashSet", ".", "WEAK", ")", ";", "String", "saveLogConfig", "=", "_conf", ".", "getLog", "(", ")", ";", "_conf", ".", "setLog", "(", "\"", "none", "\"", ")", ";", "makeReadOnly", "(", ")", ";", "_conf", ".", "setLog", "(", "saveLogConfig", ")", ";", "return", "this", ";", "}"], "idx": 33008, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "01bc0d257b38743372af91cb88269524634db7d3", "function_name": "readResolve", "body_hash": "c564c183e7609b92f4bf015208dd5b5222a67312"}
{"code": "@PresetData(DataSet.NO_ANONYMOUS_READACCESS)\n    @SuppressWarnings(\"SleepWhileInLoop\")\n    public void testServiceUsingDirectSecret() throws Exception {\n        Slave slave = createNewJnlpSlave(\"test\");\n        jenkins.setNodes(Collections.singletonList(slave));\n        new WebClient().goTo(\"computer/test/slave-agent.jnlp?encrypt=true\", \"application/octet-stream\");\n        String secret = slave.getComputer().getJnlpMac();\n        // To watch it fail: secret = secret.replace('1', '2');\n        ProcessBuilder pb = new ProcessBuilder(JavaEnvUtils.getJreExecutable(\"java\"), \"-jar\", Which.jarFile(Launcher.class).getAbsolutePath(), \"-jnlpUrl\", getURL() + \"computer/test/slave-agent.jnlp\", \"-secret\", secret);\n        try {\n            pb = (ProcessBuilder) ProcessBuilder.class.getMethod(\"inheritIO\").invoke(pb);\n        } catch (NoSuchMethodException x) {\n            // prior to Java 7\n        }\n        System.err.println(\"Running: \" + pb.command());\n        Process p = pb.start();\n        try {\n            for (int i = 0; i < /* one minute */600; i++) {\n                if (slave.getComputer().isOnline()) {\n                    System.err.println(\"JNLP slave successfully connected\");\n                    Channel channel = slave.getComputer().getChannel();\n                    assertFalse(\"SECURITY-206\", channel.isRemoteClassLoadingAllowed());\n                    jenkins.getExtensionList(AdminWhitelistRule.class).get(AdminWhitelistRule.class).setMasterKillSwitch(false);\n                    final File f = new File(jenkins.getRootDir(), \"config.xml\");\n                    assertTrue(f.exists());\n                    try {\n                        fail(\"SECURITY-206: \" + channel.call(new Attack(f.getAbsolutePath())));\n                    } catch (SecurityException x) {\n                        System.out.println(\"expected: \" + x);\n                        assertTrue(x.getMessage().contains(\"http://jenkins-ci.org/security-144\"));\n                    }\n                    return;\n                }\n                Thread.sleep(100);\n            }\n            fail(\"JNLP slave agent failed to connect\");\n        } finally {\n            p.destroy();\n        }\n    }", "code_tokens": ["@", "PresetData", "(", "DataSet", ".", "NO_ANONYMOUS_READACCESS", ")", "@", "SuppressWarnings", "(", "\"", "SleepWhileInLoop", "\"", ")", "public", "void", "testServiceUsingDirectSecret", "(", ")", "throws", "Exception", "{", "Slave", "slave", "=", "createNewJnlpSlave", "(", "\"", "test", "\"", ")", ";", "jenkins", ".", "setNodes", "(", "Collections", ".", "singletonList", "(", "slave", ")", ")", ";", "new", "WebClient", "(", ")", ".", "goTo", "(", "\"", "computer/test/slave-agent.jnlp?encrypt=true", "\"", ",", "\"", "application/octet-stream", "\"", ")", ";", "String", "secret", "=", "slave", ".", "getComputer", "(", ")", ".", "getJnlpMac", "(", ")", ";", "ProcessBuilder", "pb", "=", "new", "ProcessBuilder", "(", "JavaEnvUtils", ".", "getJreExecutable", "(", "\"", "java", "\"", ")", ",", "\"", "-jar", "\"", ",", "Which", ".", "jarFile", "(", "Launcher", ".", "class", ")", ".", "getAbsolutePath", "(", ")", ",", "\"", "-jnlpUrl", "\"", ",", "getURL", "(", ")", "+", "\"", "computer/test/slave-agent.jnlp", "\"", ",", "\"", "-secret", "\"", ",", "secret", ")", ";", "try", "{", "pb", "=", "(", "ProcessBuilder", ")", "ProcessBuilder", ".", "class", ".", "getMethod", "(", "\"", "inheritIO", "\"", ")", ".", "invoke", "(", "pb", ")", ";", "}", "catch", "(", "NoSuchMethodException", "x", ")", "{", "}", "System", ".", "err", ".", "println", "(", "\"", "Running: ", "\"", "+", "pb", ".", "command", "(", ")", ")", ";", "Process", "p", "=", "pb", ".", "start", "(", ")", ";", "try", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "600", ";", "i", "++", ")", "{", "if", "(", "slave", ".", "getComputer", "(", ")", ".", "isOnline", "(", ")", ")", "{", "System", ".", "err", ".", "println", "(", "\"", "JNLP slave successfully connected", "\"", ")", ";", "Channel", "channel", "=", "slave", ".", "getComputer", "(", ")", ".", "getChannel", "(", ")", ";", "assertFalse", "(", "\"", "SECURITY-206", "\"", ",", "channel", ".", "isRemoteClassLoadingAllowed", "(", ")", ")", ";", "jenkins", ".", "getExtensionList", "(", "AdminWhitelistRule", ".", "class", ")", ".", "get", "(", "AdminWhitelistRule", ".", "class", ")", ".", "setMasterKillSwitch", "(", "false", ")", ";", "final", "File", "f", "=", "new", "File", "(", "jenkins", ".", "getRootDir", "(", ")", ",", "\"", "config.xml", "\"", ")", ";", "assertTrue", "(", "f", ".", "exists", "(", ")", ")", ";", "try", "{", "fail", "(", "\"", "SECURITY-206: ", "\"", "+", "channel", ".", "call", "(", "new", "Attack", "(", "f", ".", "getAbsolutePath", "(", ")", ")", ")", ")", ";", "}", "catch", "(", "SecurityException", "x", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "expected: ", "\"", "+", "x", ")", ";", "assertTrue", "(", "x", ".", "getMessage", "(", ")", ".", "contains", "(", "\"", "http://jenkins-ci.org/security-144", "\"", ")", ")", ";", "}", "return", ";", "}", "Thread", ".", "sleep", "(", "100", ")", ";", "}", "fail", "(", "\"", "JNLP slave agent failed to connect", "\"", ")", ";", "}", "finally", "{", "p", ".", "destroy", "(", ")", ";", "}", "}"], "idx": 38190, "cwe": "CWE-284", "target": 0, "status": "FIXED", "commit": "ed407e66bcd3743a3b458ea8284977e5cac56c2a", "function_name": "testServiceUsingDirectSecret", "body_hash": "123279477cea08262b671148351e3d2d32a5fea0"}
{"code": "@PresetData(DataSet.NO_ANONYMOUS_READACCESS)\n    @SuppressWarnings(\"SleepWhileInLoop\")\n    public void testServiceUsingDirectSecret() throws Exception {\n        Slave slave = createNewJnlpSlave(\"test\");\n        jenkins.setNodes(Collections.singletonList(slave));\n        new WebClient().goTo(\"computer/test/slave-agent.jnlp?encrypt=true\", \"application/octet-stream\");\n        String secret = slave.getComputer().getJnlpMac();\n        // To watch it fail: secret = secret.replace('1', '2');\n        ProcessBuilder pb = new ProcessBuilder(JavaEnvUtils.getJreExecutable(\"java\"), \"-jar\", Which.jarFile(Launcher.class).getAbsolutePath(), \"-jnlpUrl\", getURL() + \"computer/test/slave-agent.jnlp\", \"-secret\", secret);\n        try {\n            pb = (ProcessBuilder) ProcessBuilder.class.getMethod(\"inheritIO\").invoke(pb);\n        } catch (NoSuchMethodException x) {\n            // prior to Java 7\n        }\n        System.err.println(\"Running: \" + pb.command());\n        Process p = pb.start();\n        try {\n            for (int i = 0; i < /* one minute */600; i++) {\n                if (slave.getComputer().isOnline()) {\n                    System.err.println(\"JNLP slave successfully connected\");\n                    return;\n                }\n                Thread.sleep(100);\n            }\n            fail(\"JNLP slave agent failed to connect\");\n        } finally {\n            p.destroy();\n        }\n    }", "code_tokens": ["@", "PresetData", "(", "DataSet", ".", "NO_ANONYMOUS_READACCESS", ")", "@", "SuppressWarnings", "(", "\"", "SleepWhileInLoop", "\"", ")", "public", "void", "testServiceUsingDirectSecret", "(", ")", "throws", "Exception", "{", "Slave", "slave", "=", "createNewJnlpSlave", "(", "\"", "test", "\"", ")", ";", "jenkins", ".", "setNodes", "(", "Collections", ".", "singletonList", "(", "slave", ")", ")", ";", "new", "WebClient", "(", ")", ".", "goTo", "(", "\"", "computer/test/slave-agent.jnlp?encrypt=true", "\"", ",", "\"", "application/octet-stream", "\"", ")", ";", "String", "secret", "=", "slave", ".", "getComputer", "(", ")", ".", "getJnlpMac", "(", ")", ";", "ProcessBuilder", "pb", "=", "new", "ProcessBuilder", "(", "JavaEnvUtils", ".", "getJreExecutable", "(", "\"", "java", "\"", ")", ",", "\"", "-jar", "\"", ",", "Which", ".", "jarFile", "(", "Launcher", ".", "class", ")", ".", "getAbsolutePath", "(", ")", ",", "\"", "-jnlpUrl", "\"", ",", "getURL", "(", ")", "+", "\"", "computer/test/slave-agent.jnlp", "\"", ",", "\"", "-secret", "\"", ",", "secret", ")", ";", "try", "{", "pb", "=", "(", "ProcessBuilder", ")", "ProcessBuilder", ".", "class", ".", "getMethod", "(", "\"", "inheritIO", "\"", ")", ".", "invoke", "(", "pb", ")", ";", "}", "catch", "(", "NoSuchMethodException", "x", ")", "{", "}", "System", ".", "err", ".", "println", "(", "\"", "Running: ", "\"", "+", "pb", ".", "command", "(", ")", ")", ";", "Process", "p", "=", "pb", ".", "start", "(", ")", ";", "try", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "600", ";", "i", "++", ")", "{", "if", "(", "slave", ".", "getComputer", "(", ")", ".", "isOnline", "(", ")", ")", "{", "System", ".", "err", ".", "println", "(", "\"", "JNLP slave successfully connected", "\"", ")", ";", "return", ";", "}", "Thread", ".", "sleep", "(", "100", ")", ";", "}", "fail", "(", "\"", "JNLP slave agent failed to connect", "\"", ")", ";", "}", "finally", "{", "p", ".", "destroy", "(", ")", ";", "}", "}"], "idx": 38189, "cwe": "CWE-284", "target": 1, "status": "VULNERABLE", "commit": "ed407e66bcd3743a3b458ea8284977e5cac56c2a", "function_name": "testServiceUsingDirectSecret", "body_hash": "facc1c1d2d9a4071adbbb4afa0029fdc856fc058"}
{"code": "public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        String pathUC = path.toUpperCase(Locale.ENGLISH);\n        if (path.isEmpty() || path.contains(\"..\") || path.startsWith(\".\") || path.contains(\"%\")\n                || pathUC.contains(\"META-INF\") || pathUC.contains(\"WEB-INF\")\n                // ClassicPluginStrategy#explode produce that file to know if a new explosion is required or not\n                || pathUC.equals(\"/.TIMESTAMP2\")\n        ) {\n            LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n    }", "code_tokens": ["public", "void", "doDynamic", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "req", ".", "getRestOfPath", "(", ")", ";", "String", "pathUC", "=", "path", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ";", "if", "(", "path", ".", "isEmpty", "(", ")", "||", "path", ".", "contains", "(", "\"", "..", "\"", ")", "||", "path", ".", "startsWith", "(", "\"", ".", "\"", ")", "||", "path", ".", "contains", "(", "\"", "%", "\"", ")", "||", "pathUC", ".", "contains", "(", "\"", "META-INF", "\"", ")", "||", "pathUC", ".", "contains", "(", "\"", "WEB-INF", "\"", ")", "||", "pathUC", ".", "equals", "(", "\"", "/.TIMESTAMP2", "\"", ")", ")", "{", "LOGGER", ".", "warning", "(", "\"", "rejecting possibly malicious ", "\"", "+", "req", ".", "getRequestURIWithQueryString", "(", ")", ")", ";", "rsp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "String", "requestPath", "=", "req", ".", "getRequestURI", "(", ")", ".", "substring", "(", "req", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "boolean", "staticLink", "=", "requestPath", ".", "startsWith", "(", "\"", "/static/", "\"", ")", ";", "long", "expires", "=", "staticLink", "?", "TimeUnit2", ".", "DAYS", ".", "toMillis", "(", "365", ")", ":", "-", "1", ";", "rsp", ".", "serveLocalizedFile", "(", "req", ",", "new", "URL", "(", "wrapper", ".", "baseResourceURL", ",", "'.'", "+", "path", ")", ",", "expires", ")", ";", "}"], "idx": 15682, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "f46842c7a2c916170ac457a039a2f7f019afd885", "function_name": "doDynamic", "body_hash": "1253c344082a56368a2d1b6310850188863a3c64"}
{"code": "private void parse(State state, final String uri)\n        {\n            int mark = 0; // the start of the current section being parsed\n            int pathMark = 0; // the start of the path section\n            int segment = 0; // the start of the current segment within the path\n            boolean encoded = false; // set to true if the path contains % encoded characters\n            boolean dot = false; // set to true if the path containers . or .. segments\n            int escapedTwo = 0; // state of parsing a %2<x>\n            int end = uri.length();\n            for (int i = 0; i < end; i++)\n            {\n                char c = uri.charAt(i);\n\n                switch (state)\n                {\n                    case START:\n                    {\n                        switch (c)\n                        {\n                            case '/':\n                                mark = i;\n                                state = State.HOST_OR_PATH;\n                                break;\n                            case ';':\n                                mark = i + 1;\n                                state = State.PARAM;\n                                break;\n                            case '?':\n                                // assume empty path (if seen at start)\n                                _path = \"\";\n                                mark = i + 1;\n                                state = State.QUERY;\n                                break;\n                            case '#':\n                                mark = i + 1;\n                                state = State.FRAGMENT;\n                                break;\n                            case '*':\n                                _path = \"*\";\n                                state = State.ASTERISK;\n                                break;\n                            case '%':\n                                encoded = true;\n                                escapedTwo = 1;\n                                mark = pathMark = segment = i;\n                                state = State.PATH;\n                                break;\n                            case '.':\n                                dot = true;\n                                pathMark = segment = i;\n                                state = State.PATH;\n                                break;\n                            default:\n                                mark = i;\n                                if (_scheme == null)\n                                    state = State.SCHEME_OR_PATH;\n                                else\n                                {\n                                    pathMark = segment = i;\n                                    state = State.PATH;\n                                }\n                                break;\n                        }\n                        continue;\n                    }\n\n                    case SCHEME_OR_PATH:\n                    {\n                        switch (c)\n                        {\n                            case ':':\n                                // must have been a scheme\n                                _scheme = uri.substring(mark, i);\n                                // Start again with scheme set\n                                state = State.START;\n                                break;\n                            case '/':\n                                // must have been in a path and still are\n                                segment = i + 1;\n                                state = State.PATH;\n                                break;\n                            case ';':\n                                // must have been in a path\n                                mark = i + 1;\n                                state = State.PARAM;\n                                break;\n                            case '?':\n                                // must have been in a path\n                                _path = uri.substring(mark, i);\n                                mark = i + 1;\n                                state = State.QUERY;\n                                break;\n                            case '%':\n                                // must have be in an encoded path\n                                encoded = true;\n                                escapedTwo = 1;\n                                state = State.PATH;\n                                break;\n                            case '#':\n                                // must have been in a path\n                                _path = uri.substring(mark, i);\n                                state = State.FRAGMENT;\n                                break;\n                            default:\n                                break;\n                        }\n                        continue;\n                    }\n                    case HOST_OR_PATH:\n                    {\n                        switch (c)\n                        {\n                            case '/':\n                                _host = \"\";\n                                mark = i + 1;\n                                state = State.HOST;\n                                break;\n                            case '%':\n                            case '@':\n                            case ';':\n                            case '?':\n                            case '#':\n                            case '.':\n                                // was a path, look again\n                                i--;\n                                pathMark = mark;\n                                segment = mark + 1;\n                                state = State.PATH;\n                                break;\n                            default:\n                                // it is a path\n                                pathMark = mark;\n                                segment = mark + 1;\n                                state = State.PATH;\n                        }\n                        continue;\n                    }\n\n                    case HOST:\n                    {\n                        switch (c)\n                        {\n                            case '/':\n                                _host = uri.substring(mark, i);\n                                pathMark = mark = i;\n                                segment = mark + 1;\n                                state = State.PATH;\n                                break;\n                            case ':':\n                                if (i > mark)\n                                    _host = uri.substring(mark, i);\n                                mark = i + 1;\n                                state = State.PORT;\n                                break;\n                            case '@':\n                                if (_user != null)\n                                    throw new IllegalArgumentException(\"Bad authority\");\n                                _user = uri.substring(mark, i);\n                                mark = i + 1;\n                                break;\n                            case '[':\n                                state = State.IPV6;\n                                break;\n                            default:\n                                break;\n                        }\n                        break;\n                    }\n                    case IPV6:\n                    {\n                        switch (c)\n                        {\n                            case '/':\n                                throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n                            case ']':\n                                c = uri.charAt(++i);\n                                _host = uri.substring(mark, i);\n                                if (c == ':')\n                                {\n                                    mark = i + 1;\n                                    state = State.PORT;\n                                }\n                                else\n                                {\n                                    pathMark = mark = i;\n                                    state = State.PATH;\n                                }\n                                break;\n                            default:\n                                break;\n                        }\n                        break;\n                    }\n                    case PORT:\n                    {\n                        if (c == '@')\n                        {\n                            if (_user != null)\n                                throw new IllegalArgumentException(\"Bad authority\");\n                            // It wasn't a port, but a password!\n                            _user = _host + \":\" + uri.substring(mark, i);\n                            mark = i + 1;\n                            state = State.HOST;\n                        }\n                        else if (c == '/')\n                        {\n                            _port = TypeUtil.parseInt(uri, mark, i - mark, 10);\n                            pathMark = mark = i;\n                            segment = i + 1;\n                            state = State.PATH;\n                        }\n                        break;\n                    }\n                    case PATH:\n                    {\n                        switch (c)\n                        {\n                            case ';':\n                                checkSegment(uri, segment, i, true);\n                                mark = i + 1;\n                                state = State.PARAM;\n                                break;\n                            case '?':\n                                checkSegment(uri, segment, i, false);\n                                _path = uri.substring(pathMark, i);\n                                mark = i + 1;\n                                state = State.QUERY;\n                                break;\n                            case '#':\n                                checkSegment(uri, segment, i, false);\n                                _path = uri.substring(pathMark, i);\n                                mark = i + 1;\n                                state = State.FRAGMENT;\n                                break;\n                            case '/':\n                                checkSegment(uri, segment, i, false);\n                                segment = i + 1;\n                                break;\n                            case '.':\n                                dot |= segment == i;\n                                break;\n                            case '%':\n                                encoded = true;\n                                escapedTwo = 1;\n                                break;\n                            case '2':\n                                escapedTwo = escapedTwo == 1 ? 2 : 0;\n                                break;\n                            case 'f':\n                            case 'F':\n                                if (escapedTwo == 2)\n                                    _ambiguous.add(Ambiguous.SEPARATOR);\n                                escapedTwo = 0;\n                                break;\n                            case '5':\n                                if (escapedTwo == 2)\n                                    _ambiguous.add(Ambiguous.ENCODING);\n                                escapedTwo = 0;\n                                break;\n                            default:\n                                escapedTwo = 0;\n                                break;\n                        }\n                        break;\n                    }\n                    case PARAM:\n                    {\n                        switch (c)\n                        {\n                            case '?':\n                                _path = uri.substring(pathMark, i);\n                                _param = uri.substring(mark, i);\n                                mark = i + 1;\n                                state = State.QUERY;\n                                break;\n                            case '#':\n                                _path = uri.substring(pathMark, i);\n                                _param = uri.substring(mark, i);\n                                mark = i + 1;\n                                state = State.FRAGMENT;\n                                break;\n                            case '/':\n                                encoded = true;\n                                segment = i + 1;\n                                state = State.PATH;\n                                break;\n                            case ';':\n                                // multiple parameters\n                                mark = i + 1;\n                                break;\n                            default:\n                                break;\n                        }\n                        break;\n                    }\n                    case QUERY:\n                    {\n                        if (c == '#')\n                        {\n                            _query = uri.substring(mark, i);\n                            mark = i + 1;\n                            state = State.FRAGMENT;\n                        }\n                        break;\n                    }\n                    case ASTERISK:\n                    {\n                        throw new IllegalArgumentException(\"Bad character '*'\");\n                    }\n                    case FRAGMENT:\n                    {\n                        _fragment = uri.substring(mark, end);\n                        i = end;\n                        break;\n                    }\n                    default:\n                        throw new IllegalStateException(state.toString());\n                }\n            }\n\n            switch (state)\n            {\n                case START:\n                case ASTERISK:\n                    break;\n                case SCHEME_OR_PATH:\n                case HOST_OR_PATH:\n                    _path = uri.substring(mark, end);\n                    break;\n                case HOST:\n                    if (end > mark)\n                        _host = uri.substring(mark, end);\n                    break;\n                case IPV6:\n                    throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n                case PORT:\n                    _port = TypeUtil.parseInt(uri, mark, end - mark, 10);\n                    break;\n                case PARAM:\n                    _path = uri.substring(pathMark, end);\n                    _param = uri.substring(mark, end);\n                    break;\n                case PATH:\n                    checkSegment(uri, segment, end, false);\n                    _path = uri.substring(pathMark, end);\n                    break;\n                case QUERY:\n                    _query = uri.substring(mark, end);\n                    break;\n                case FRAGMENT:\n                    _fragment = uri.substring(mark, end);\n                    break;\n                default:\n                    throw new IllegalStateException(state.toString());\n            }\n\n            if (!encoded && !dot)\n            {\n                if (_param == null)\n                    _decodedPath = _path;\n                else\n                    _decodedPath = _path.substring(0, _path.length() - _param.length() - 1);\n            }\n            else if (_path != null)\n            {\n                String canonical = URIUtil.canonicalPath(_path);\n                if (canonical == null)\n                    throw new BadMessageException(\"Bad URI\");\n                _decodedPath = URIUtil.decodePath(canonical);\n            }\n        }", "code_tokens": ["private", "void", "parse", "(", "State", "state", ",", "final", "String", "uri", ")", "{", "int", "mark", "=", "0", ";", "int", "pathMark", "=", "0", ";", "int", "segment", "=", "0", ";", "boolean", "encoded", "=", "false", ";", "boolean", "dot", "=", "false", ";", "int", "escapedTwo", "=", "0", ";", "int", "end", "=", "uri", ".", "length", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "end", ";", "i", "++", ")", "{", "char", "c", "=", "uri", ".", "charAt", "(", "i", ")", ";", "switch", "(", "state", ")", "{", "case", "START", ":", "{", "switch", "(", "c", ")", "{", "case", "'/'", ":", "mark", "=", "i", ";", "state", "=", "State", ".", "HOST_OR_PATH", ";", "break", ";", "case", "';'", ":", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PARAM", ";", "break", ";", "case", "'?'", ":", "_path", "=", "\"", "\"", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "QUERY", ";", "break", ";", "case", "'#'", ":", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "FRAGMENT", ";", "break", ";", "case", "'*'", ":", "_path", "=", "\"", "*", "\"", ";", "state", "=", "State", ".", "ASTERISK", ";", "break", ";", "case", "'%'", ":", "encoded", "=", "true", ";", "escapedTwo", "=", "1", ";", "mark", "=", "pathMark", "=", "segment", "=", "i", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "'.'", ":", "dot", "=", "true", ";", "pathMark", "=", "segment", "=", "i", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "default", ":", "mark", "=", "i", ";", "if", "(", "_scheme", "==", "null", ")", "state", "=", "State", ".", "SCHEME_OR_PATH", ";", "else", "{", "pathMark", "=", "segment", "=", "i", ";", "state", "=", "State", ".", "PATH", ";", "}", "break", ";", "}", "continue", ";", "}", "case", "SCHEME_OR_PATH", ":", "{", "switch", "(", "c", ")", "{", "case", "':'", ":", "_scheme", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "state", "=", "State", ".", "START", ";", "break", ";", "case", "'/'", ":", "segment", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "';'", ":", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PARAM", ";", "break", ";", "case", "'?'", ":", "_path", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "QUERY", ";", "break", ";", "case", "'%'", ":", "encoded", "=", "true", ";", "escapedTwo", "=", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "'#'", ":", "_path", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "state", "=", "State", ".", "FRAGMENT", ";", "break", ";", "default", ":", "break", ";", "}", "continue", ";", "}", "case", "HOST_OR_PATH", ":", "{", "switch", "(", "c", ")", "{", "case", "'/'", ":", "_host", "=", "\"", "\"", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "HOST", ";", "break", ";", "case", "'%'", ":", "case", "'@'", ":", "case", "';'", ":", "case", "'?'", ":", "case", "'#'", ":", "case", "'.'", ":", "i", "--", ";", "pathMark", "=", "mark", ";", "segment", "=", "mark", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "default", ":", "pathMark", "=", "mark", ";", "segment", "=", "mark", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "}", "continue", ";", "}", "case", "HOST", ":", "{", "switch", "(", "c", ")", "{", "case", "'/'", ":", "_host", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "pathMark", "=", "mark", "=", "i", ";", "segment", "=", "mark", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "':'", ":", "if", "(", "i", ">", "mark", ")", "_host", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PORT", ";", "break", ";", "case", "'@'", ":", "if", "(", "_user", "!=", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"", "Bad authority", "\"", ")", ";", "_user", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "break", ";", "case", "'['", ":", "state", "=", "State", ".", "IPV6", ";", "break", ";", "default", ":", "break", ";", "}", "break", ";", "}", "case", "IPV6", ":", "{", "switch", "(", "c", ")", "{", "case", "'/'", ":", "throw", "new", "IllegalArgumentException", "(", "\"", "No closing ']' for ipv6 in ", "\"", "+", "uri", ")", ";", "case", "']'", ":", "c", "=", "uri", ".", "charAt", "(", "++", "i", ")", ";", "_host", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "if", "(", "c", "==", "':'", ")", "{", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PORT", ";", "}", "else", "{", "pathMark", "=", "mark", "=", "i", ";", "state", "=", "State", ".", "PATH", ";", "}", "break", ";", "default", ":", "break", ";", "}", "break", ";", "}", "case", "PORT", ":", "{", "if", "(", "c", "==", "'@'", ")", "{", "if", "(", "_user", "!=", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"", "Bad authority", "\"", ")", ";", "_user", "=", "_host", "+", "\"", ":", "\"", "+", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "HOST", ";", "}", "else", "if", "(", "c", "==", "'/'", ")", "{", "_port", "=", "TypeUtil", ".", "parseInt", "(", "uri", ",", "mark", ",", "i", "-", "mark", ",", "10", ")", ";", "pathMark", "=", "mark", "=", "i", ";", "segment", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "}", "break", ";", "}", "case", "PATH", ":", "{", "switch", "(", "c", ")", "{", "case", "';'", ":", "checkSegment", "(", "uri", ",", "segment", ",", "i", ",", "true", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PARAM", ";", "break", ";", "case", "'?'", ":", "checkSegment", "(", "uri", ",", "segment", ",", "i", ",", "false", ")", ";", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "QUERY", ";", "break", ";", "case", "'#'", ":", "checkSegment", "(", "uri", ",", "segment", ",", "i", ",", "false", ")", ";", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "FRAGMENT", ";", "break", ";", "case", "'/'", ":", "checkSegment", "(", "uri", ",", "segment", ",", "i", ",", "false", ")", ";", "segment", "=", "i", "+", "1", ";", "break", ";", "case", "'.'", ":", "dot", "|=", "segment", "==", "i", ";", "break", ";", "case", "'%'", ":", "encoded", "=", "true", ";", "escapedTwo", "=", "1", ";", "break", ";", "case", "'2'", ":", "escapedTwo", "=", "escapedTwo", "==", "1", "?", "2", ":", "0", ";", "break", ";", "case", "'f'", ":", "case", "'F'", ":", "if", "(", "escapedTwo", "==", "2", ")", "_ambiguous", ".", "add", "(", "Ambiguous", ".", "SEPARATOR", ")", ";", "escapedTwo", "=", "0", ";", "break", ";", "case", "'5'", ":", "if", "(", "escapedTwo", "==", "2", ")", "_ambiguous", ".", "add", "(", "Ambiguous", ".", "ENCODING", ")", ";", "escapedTwo", "=", "0", ";", "break", ";", "default", ":", "escapedTwo", "=", "0", ";", "break", ";", "}", "break", ";", "}", "case", "PARAM", ":", "{", "switch", "(", "c", ")", "{", "case", "'?'", ":", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "i", ")", ";", "_param", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "QUERY", ";", "break", ";", "case", "'#'", ":", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "i", ")", ";", "_param", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "FRAGMENT", ";", "break", ";", "case", "'/'", ":", "encoded", "=", "true", ";", "segment", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "';'", ":", "mark", "=", "i", "+", "1", ";", "break", ";", "default", ":", "break", ";", "}", "break", ";", "}", "case", "QUERY", ":", "{", "if", "(", "c", "==", "'#'", ")", "{", "_query", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "FRAGMENT", ";", "}", "break", ";", "}", "case", "ASTERISK", ":", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Bad character '*'", "\"", ")", ";", "}", "case", "FRAGMENT", ":", "{", "_fragment", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "i", "=", "end", ";", "break", ";", "}", "default", ":", "throw", "new", "IllegalStateException", "(", "state", ".", "toString", "(", ")", ")", ";", "}", "}", "switch", "(", "state", ")", "{", "case", "START", ":", "case", "ASTERISK", ":", "break", ";", "case", "SCHEME_OR_PATH", ":", "case", "HOST_OR_PATH", ":", "_path", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "case", "HOST", ":", "if", "(", "end", ">", "mark", ")", "_host", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "case", "IPV6", ":", "throw", "new", "IllegalArgumentException", "(", "\"", "No closing ']' for ipv6 in ", "\"", "+", "uri", ")", ";", "case", "PORT", ":", "_port", "=", "TypeUtil", ".", "parseInt", "(", "uri", ",", "mark", ",", "end", "-", "mark", ",", "10", ")", ";", "break", ";", "case", "PARAM", ":", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "end", ")", ";", "_param", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "case", "PATH", ":", "checkSegment", "(", "uri", ",", "segment", ",", "end", ",", "false", ")", ";", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "end", ")", ";", "break", ";", "case", "QUERY", ":", "_query", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "case", "FRAGMENT", ":", "_fragment", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "state", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "!", "encoded", "&&", "!", "dot", ")", "{", "if", "(", "_param", "==", "null", ")", "_decodedPath", "=", "_path", ";", "else", "_decodedPath", "=", "_path", ".", "substring", "(", "0", ",", "_path", ".", "length", "(", ")", "-", "_param", ".", "length", "(", ")", "-", "1", ")", ";", "}", "else", "if", "(", "_path", "!=", "null", ")", "{", "String", "canonical", "=", "URIUtil", ".", "canonicalPath", "(", "_path", ")", ";", "if", "(", "canonical", "==", "null", ")", "throw", "new", "BadMessageException", "(", "\"", "Bad URI", "\"", ")", ";", "_decodedPath", "=", "URIUtil", ".", "decodePath", "(", "canonical", ")", ";", "}", "}"], "idx": 114640, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "f58dbedcd05b2aee43c8faa709ba2deaa4361036", "function_name": "parse", "body_hash": "0373b9d01e76c4cfd88670b9668b31859e47a6c5"}
{"code": "protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        List<String> clusterUrls = new LinkedList<>();\n        try {\n          // Note that we are not checking ports here.\n          clusterUrls = organizationDirectoryService.getOrganization(uri.toURL()).getServers()\n                          .keySet()\n                          .stream()\n                          .collect(Collectors.toUnmodifiableList());\n        } catch (NotFoundException e) {\n          logger.warn(\"Unable to determine cluster members, will not be able to authenticate any downloads from them\", e);\n        }\n\n        if (uri.toString().matches(downloadSource)) {\n          //NB: We're creating a new client here with *different* auth than the system auth creds\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          // Only using the system-level httpclient and digest credentials against our own servers\n          response = httpClient.execute(get);\n        } else {\n          //NB: No auth here at all\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n        }\n\n        if (null == response) {\n          // If you get here then chances are you're using a mock httpClient which does not have appropriate\n          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n        //If it does not start with file, or we're in test mode (ie, to allow arbitrary file:// access)\n      } else if (!uri.toString().startsWith(\"file\") || testMode) {\n        in = uri.toURL().openStream();\n      } else {\n        throw new IOException(\"Refusing to fetch files from the local filesystem\");\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }", "code_tokens": ["protected", "URI", "addContentToRepo", "(", "MediaPackage", "mp", ",", "String", "elementId", ",", "URI", "uri", ")", "throws", "IOException", "{", "InputStream", "in", "=", "null", ";", "HttpResponse", "response", "=", "null", ";", "CloseableHttpClient", "externalHttpClient", "=", "null", ";", "try", "{", "if", "(", "uri", ".", "toString", "(", ")", ".", "startsWith", "(", "\"", "http", "\"", ")", ")", "{", "HttpGet", "get", "=", "new", "HttpGet", "(", "uri", ")", ";", "List", "<", "String", ">", "clusterUrls", "=", "new", "LinkedList", "<", ">", "(", ")", ";", "try", "{", "clusterUrls", "=", "organizationDirectoryService", ".", "getOrganization", "(", "uri", ".", "toURL", "(", ")", ")", ".", "getServers", "(", ")", ".", "keySet", "(", ")", ".", "stream", "(", ")", ".", "collect", "(", "Collectors", ".", "toUnmodifiableList", "(", ")", ")", ";", "}", "catch", "(", "NotFoundException", "e", ")", "{", "logger", ".", "warn", "(", "\"", "Unable to determine cluster members, will not be able to authenticate any downloads from them", "\"", ",", "e", ")", ";", "}", "if", "(", "uri", ".", "toString", "(", ")", ".", "matches", "(", "downloadSource", ")", ")", "{", "externalHttpClient", "=", "getAuthedHttpClient", "(", ")", ";", "response", "=", "externalHttpClient", ".", "execute", "(", "get", ")", ";", "}", "else", "if", "(", "clusterUrls", ".", "contains", "(", "uri", ".", "getScheme", "(", ")", "+", "\"", "://", "\"", "+", "uri", ".", "getHost", "(", ")", ")", ")", "{", "response", "=", "httpClient", ".", "execute", "(", "get", ")", ";", "}", "else", "{", "externalHttpClient", "=", "getNoAuthHttpClient", "(", ")", ";", "response", "=", "externalHttpClient", ".", "execute", "(", "get", ")", ";", "}", "if", "(", "null", "==", "response", ")", "{", "throw", "new", "IOException", "(", "\"", "Null response object from the http client, refer to code for explanation", "\"", ")", ";", "}", "int", "httpStatusCode", "=", "response", ".", "getStatusLine", "(", ")", ".", "getStatusCode", "(", ")", ";", "if", "(", "httpStatusCode", "!=", "200", ")", "{", "throw", "new", "IOException", "(", "uri", "+", "\"", " returns http ", "\"", "+", "httpStatusCode", ")", ";", "}", "in", "=", "response", ".", "getEntity", "(", ")", ".", "getContent", "(", ")", ";", "}", "else", "if", "(", "!", "uri", ".", "toString", "(", ")", ".", "startsWith", "(", "\"", "file", "\"", ")", "||", "testMode", ")", "{", "in", "=", "uri", ".", "toURL", "(", ")", ".", "openStream", "(", ")", ";", "}", "else", "{", "throw", "new", "IOException", "(", "\"", "Refusing to fetch files from the local filesystem", "\"", ")", ";", "}", "String", "fileName", "=", "FilenameUtils", ".", "getName", "(", "uri", ".", "getPath", "(", ")", ")", ";", "if", "(", "isBlank", "(", "FilenameUtils", ".", "getExtension", "(", "fileName", ")", ")", ")", "fileName", "=", "getContentDispositionFileName", "(", "response", ")", ";", "if", "(", "isBlank", "(", "FilenameUtils", ".", "getExtension", "(", "fileName", ")", ")", ")", "throw", "new", "IOException", "(", "\"", "No filename extension found: ", "\"", "+", "fileName", ")", ";", "return", "addContentToRepo", "(", "mp", ",", "elementId", ",", "fileName", ",", "in", ")", ";", "}", "finally", "{", "if", "(", "in", "!=", "null", ")", "{", "in", ".", "close", "(", ")", ";", "}", "if", "(", "externalHttpClient", "!=", "null", ")", "{", "externalHttpClient", ".", "close", "(", ")", ";", "}", "httpClient", ".", "close", "(", "response", ")", ";", "}", "}"], "idx": 38966, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "8d5ec1614eed109b812bc27b0c6d3214e456d4e7", "function_name": "addContentToRepo", "body_hash": "d5495ba4315d40ad1b4a080af5f8e46d22af3ac4"}
{"code": "public void testEncryptHeader() throws Exception {\n        ENCRYPT.EncryptHeader hdr=new ENCRYPT.EncryptHeader((short)1, null);\n        _testSize(hdr);\n        hdr=new ENCRYPT.EncryptHeader((short)2, \"Hello world\");\n        _testSize(hdr);\n    }", "code_tokens": ["public", "void", "testEncryptHeader", "(", ")", "throws", "Exception", "{", "ENCRYPT", ".", "EncryptHeader", "hdr", "=", "new", "ENCRYPT", ".", "EncryptHeader", "(", "(", "short", ")", "1", ",", "null", ")", ";", "_testSize", "(", "hdr", ")", ";", "hdr", "=", "new", "ENCRYPT", ".", "EncryptHeader", "(", "(", "short", ")", "2", ",", "\"", "Hello world", "\"", ")", ";", "_testSize", "(", "hdr", ")", ";", "}"], "idx": 108721, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "c3ad22234ef84d06d04d908b3c94c0d11df8afd", "function_name": "testEncryptHeader", "body_hash": "4dc8745f9bffdb0e554872ade971f56b6e94b63e"}
{"code": "protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        var clusterUrls = securityService.getOrganization().getServers().keySet();\n\n        if (uri.toString().matches(downloadSource)) {\n          //NB: We're creating a new client here with *different* auth than the system auth creds\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          // Only using the system-level httpclient and digest credentials against our own servers\n          response = httpClient.execute(get);\n        } else {\n          //NB: No auth here at all\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n        }\n\n        if (null == response) {\n          // If you get here then chances are you're using a mock httpClient which does not have appropriate\n          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n        //If it does not start with file, or we're in test mode (ie, to allow arbitrary file:// access)\n      } else if (!uri.toString().startsWith(\"file\") || testMode) {\n        in = uri.toURL().openStream();\n      } else {\n        throw new IOException(\"Refusing to fetch files from the local filesystem\");\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }", "code_tokens": ["protected", "URI", "addContentToRepo", "(", "MediaPackage", "mp", ",", "String", "elementId", ",", "URI", "uri", ")", "throws", "IOException", "{", "InputStream", "in", "=", "null", ";", "HttpResponse", "response", "=", "null", ";", "CloseableHttpClient", "externalHttpClient", "=", "null", ";", "try", "{", "if", "(", "uri", ".", "toString", "(", ")", ".", "startsWith", "(", "\"", "http", "\"", ")", ")", "{", "HttpGet", "get", "=", "new", "HttpGet", "(", "uri", ")", ";", "var", "clusterUrls", "=", "securityService", ".", "getOrganization", "(", ")", ".", "getServers", "(", ")", ".", "keySet", "(", ")", ";", "if", "(", "uri", ".", "toString", "(", ")", ".", "matches", "(", "downloadSource", ")", ")", "{", "externalHttpClient", "=", "getAuthedHttpClient", "(", ")", ";", "response", "=", "externalHttpClient", ".", "execute", "(", "get", ")", ";", "}", "else", "if", "(", "clusterUrls", ".", "contains", "(", "uri", ".", "getScheme", "(", ")", "+", "\"", "://", "\"", "+", "uri", ".", "getHost", "(", ")", ")", ")", "{", "response", "=", "httpClient", ".", "execute", "(", "get", ")", ";", "}", "else", "{", "externalHttpClient", "=", "getNoAuthHttpClient", "(", ")", ";", "response", "=", "externalHttpClient", ".", "execute", "(", "get", ")", ";", "}", "if", "(", "null", "==", "response", ")", "{", "throw", "new", "IOException", "(", "\"", "Null response object from the http client, refer to code for explanation", "\"", ")", ";", "}", "int", "httpStatusCode", "=", "response", ".", "getStatusLine", "(", ")", ".", "getStatusCode", "(", ")", ";", "if", "(", "httpStatusCode", "!=", "200", ")", "{", "throw", "new", "IOException", "(", "uri", "+", "\"", " returns http ", "\"", "+", "httpStatusCode", ")", ";", "}", "in", "=", "response", ".", "getEntity", "(", ")", ".", "getContent", "(", ")", ";", "}", "else", "if", "(", "!", "uri", ".", "toString", "(", ")", ".", "startsWith", "(", "\"", "file", "\"", ")", "||", "testMode", ")", "{", "in", "=", "uri", ".", "toURL", "(", ")", ".", "openStream", "(", ")", ";", "}", "else", "{", "throw", "new", "IOException", "(", "\"", "Refusing to fetch files from the local filesystem", "\"", ")", ";", "}", "String", "fileName", "=", "FilenameUtils", ".", "getName", "(", "uri", ".", "getPath", "(", ")", ")", ";", "if", "(", "isBlank", "(", "FilenameUtils", ".", "getExtension", "(", "fileName", ")", ")", ")", "fileName", "=", "getContentDispositionFileName", "(", "response", ")", ";", "if", "(", "isBlank", "(", "FilenameUtils", ".", "getExtension", "(", "fileName", ")", ")", ")", "throw", "new", "IOException", "(", "\"", "No filename extension found: ", "\"", "+", "fileName", ")", ";", "return", "addContentToRepo", "(", "mp", ",", "elementId", ",", "fileName", ",", "in", ")", ";", "}", "finally", "{", "if", "(", "in", "!=", "null", ")", "{", "in", ".", "close", "(", ")", ";", "}", "if", "(", "externalHttpClient", "!=", "null", ")", "{", "externalHttpClient", ".", "close", "(", ")", ";", "}", "httpClient", ".", "close", "(", "response", ")", ";", "}", "}"], "idx": 38967, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "8d5ec1614eed109b812bc27b0c6d3214e456d4e7", "function_name": "addContentToRepo", "body_hash": "e13ec91b4e83000a701a5332fde80686c0a906ea"}
{"code": "private void configureJwtProxySecureProvisioner(String infrastructure) {\n    install(new FactoryModuleBuilder().build(JwtProxyConfigBuilderFactory.class));\n    install(new FactoryModuleBuilder().build(JwtProxyProvisionerFactory.class));\n    if (KubernetesInfrastructure.NAME.equals(infrastructure)) {\n      install(\n          new FactoryModuleBuilder()\n              .build(\n                  new TypeLiteral<JwtProxySecureServerExposerFactory<KubernetesEnvironment>>() {}));\n      MapBinder.newMapBinder(\n              binder(),\n              new TypeLiteral<String>() {},\n              new TypeLiteral<SecureServerExposerFactory<KubernetesEnvironment>>() {})\n          .addBinding(\"jwtproxy\")\n          .to(new TypeLiteral<JwtProxySecureServerExposerFactory<KubernetesEnvironment>>() {});\n    } else {\n      install(\n          new FactoryModuleBuilder()\n              .build(\n                  new TypeLiteral<JwtProxySecureServerExposerFactory<OpenShiftEnvironment>>() {}));\n      MapBinder.newMapBinder(\n              binder(),\n              new TypeLiteral<String>() {},\n              new TypeLiteral<SecureServerExposerFactory<OpenShiftEnvironment>>() {})\n          .addBinding(\"jwtproxy\")\n          .to(new TypeLiteral<JwtProxySecureServerExposerFactory<OpenShiftEnvironment>>() {});\n    }\n  }", "code_tokens": ["private", "void", "configureJwtProxySecureProvisioner", "(", "String", "infrastructure", ")", "{", "install", "(", "new", "FactoryModuleBuilder", "(", ")", ".", "build", "(", "JwtProxyConfigBuilderFactory", ".", "class", ")", ")", ";", "install", "(", "new", "FactoryModuleBuilder", "(", ")", ".", "build", "(", "JwtProxyProvisionerFactory", ".", "class", ")", ")", ";", "if", "(", "KubernetesInfrastructure", ".", "NAME", ".", "equals", "(", "infrastructure", ")", ")", "{", "install", "(", "new", "FactoryModuleBuilder", "(", ")", ".", "build", "(", "new", "TypeLiteral", "<", "JwtProxySecureServerExposerFactory", "<", "KubernetesEnvironment", ">", ">", "(", ")", "{", "}", ")", ")", ";", "MapBinder", ".", "newMapBinder", "(", "binder", "(", ")", ",", "new", "TypeLiteral", "<", "String", ">", "(", ")", "{", "}", ",", "new", "TypeLiteral", "<", "SecureServerExposerFactory", "<", "KubernetesEnvironment", ">", ">", "(", ")", "{", "}", ")", ".", "addBinding", "(", "\"", "jwtproxy", "\"", ")", ".", "to", "(", "new", "TypeLiteral", "<", "JwtProxySecureServerExposerFactory", "<", "KubernetesEnvironment", ">", ">", "(", ")", "{", "}", ")", ";", "}", "else", "{", "install", "(", "new", "FactoryModuleBuilder", "(", ")", ".", "build", "(", "new", "TypeLiteral", "<", "JwtProxySecureServerExposerFactory", "<", "OpenShiftEnvironment", ">", ">", "(", ")", "{", "}", ")", ")", ";", "MapBinder", ".", "newMapBinder", "(", "binder", "(", ")", ",", "new", "TypeLiteral", "<", "String", ">", "(", ")", "{", "}", ",", "new", "TypeLiteral", "<", "SecureServerExposerFactory", "<", "OpenShiftEnvironment", ">", ">", "(", ")", "{", "}", ")", ".", "addBinding", "(", "\"", "jwtproxy", "\"", ")", ".", "to", "(", "new", "TypeLiteral", "<", "JwtProxySecureServerExposerFactory", "<", "OpenShiftEnvironment", ">", ">", "(", ")", "{", "}", ")", ";", "}", "}"], "idx": 110108, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "333bfcd23a1fc72ec527cc4675046339f018cd24", "function_name": "configureJwtProxySecureProvisioner", "body_hash": "f85968193c3dcd6afadf71f761f00c68b11edd89"}
{"code": "public DIHConfiguration loadDataConfig(InputSource configFile) {\n\n    DIHConfiguration dihcfg = null;\n    try {\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      \n      // only enable xinclude, if a a SolrCore and SystemId is present (makes no sense otherwise)\n      if (core != null && configFile.getSystemId() != null) {\n        try {\n          dbf.setXIncludeAware(true);\n          dbf.setNamespaceAware(true);\n        } catch( UnsupportedOperationException e ) {\n          LOG.warn( \"XML parser doesn't support XInclude option\" );\n        }\n      }\n      \n      DocumentBuilder builder = dbf.newDocumentBuilder();\n      if (core != null)\n        builder.setEntityResolver(new SystemIdResolver(core.getResourceLoader()));\n      builder.setErrorHandler(XMLLOG);\n      Document document;\n      try {\n        document = builder.parse(configFile);\n      } finally {\n        // some XML parsers are broken and don't close the byte stream (but they should according to spec)\n        IOUtils.closeQuietly(configFile.getByteStream());\n      }\n\n      dihcfg = readFromXml(document);\n      LOG.info(\"Data Configuration loaded successfully\");\n    } catch (Exception e) {\n      throw new DataImportHandlerException(SEVERE,\n              \"Data Config problem: \" + e.getMessage(), e);\n    }\n    for (Entity e : dihcfg.getEntities()) {\n      if (e.getAllAttributes().containsKey(SqlEntityProcessor.DELTA_QUERY)) {\n        isDeltaImportSupported = true;\n        break;\n      }\n    }\n    return dihcfg;\n  }", "code_tokens": ["public", "DIHConfiguration", "loadDataConfig", "(", "InputSource", "configFile", ")", "{", "DIHConfiguration", "dihcfg", "=", "null", ";", "try", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "if", "(", "core", "!=", "null", "&&", "configFile", ".", "getSystemId", "(", ")", "!=", "null", ")", "{", "try", "{", "dbf", ".", "setXIncludeAware", "(", "true", ")", ";", "dbf", ".", "setNamespaceAware", "(", "true", ")", ";", "}", "catch", "(", "UnsupportedOperationException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "XML parser doesn't support XInclude option", "\"", ")", ";", "}", "}", "DocumentBuilder", "builder", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "if", "(", "core", "!=", "null", ")", "builder", ".", "setEntityResolver", "(", "new", "SystemIdResolver", "(", "core", ".", "getResourceLoader", "(", ")", ")", ")", ";", "builder", ".", "setErrorHandler", "(", "XMLLOG", ")", ";", "Document", "document", ";", "try", "{", "document", "=", "builder", ".", "parse", "(", "configFile", ")", ";", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "configFile", ".", "getByteStream", "(", ")", ")", ";", "}", "dihcfg", "=", "readFromXml", "(", "document", ")", ";", "LOG", ".", "info", "(", "\"", "Data Configuration loaded successfully", "\"", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "DataImportHandlerException", "(", "SEVERE", ",", "\"", "Data Config problem: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "for", "(", "Entity", "e", ":", "dihcfg", ".", "getEntities", "(", ")", ")", "{", "if", "(", "e", ".", "getAllAttributes", "(", ")", ".", "containsKey", "(", "SqlEntityProcessor", ".", "DELTA_QUERY", ")", ")", "{", "isDeltaImportSupported", "=", "true", ";", "break", ";", "}", "}", "return", "dihcfg", ";", "}"], "idx": 68711, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "02c693f3713add1b4891cbaa87127de3a55c10f", "function_name": "loadDataConfig", "body_hash": "ec5f0b46d5a71a4ed34068edf51cb9a4d4987b0f"}
{"code": "public static JMXConnectorServer createJMXServer(int port, boolean local)\n    throws IOException\n    {\n        Map<String, Object> env = new HashMap<>();\n\n        InetAddress serverAddress = null;\n        if (local)\n        {\n            serverAddress = InetAddress.getLoopbackAddress();\n            System.setProperty(\"java.rmi.server.hostname\", serverAddress.getHostAddress());\n        }\n\n        // Configure the RMI client & server socket factories, including SSL config.\n        env.putAll(configureJmxSocketFactories(serverAddress, local));\n\n\n        // Configure authn, using a JMXAuthenticator which either wraps a set log LoginModules configured\n        // via a JAAS configuration entry, or one which delegates to the standard file based authenticator.\n        // Authn is disabled if com.sun.management.jmxremote.authenticate=false\n        env.putAll(configureJmxAuthentication());\n\n        // Configure authz - if a custom proxy class is specified an instance will be returned.\n        // If not, but a location for the standard access file is set in system properties, the\n        // return value is null, and an entry is added to the env map detailing that location\n        // If neither method is specified, no access control is applied\n        MBeanServerForwarder authzProxy = configureJmxAuthorization(env);\n\n        // Make sure we use our custom exporter so a full GC doesn't get scheduled every\n        // sun.rmi.dgc.server.gcInterval millis (default is 3600000ms/1 hour)\n        env.put(RMIExporter.EXPORTER_ATTRIBUTE, new Exporter());\n\n\n        int rmiPort = Integer.getInteger(\"com.sun.management.jmxremote.rmi.port\", 0);\n        JMXConnectorServer jmxServer =\n            JMXConnectorServerFactory.newJMXConnectorServer(new JMXServiceURL(\"rmi\", null, rmiPort),\n                                                            env,\n                                                            ManagementFactory.getPlatformMBeanServer());\n\n        // If a custom authz proxy was created, attach it to the server now.\n        if (authzProxy != null)\n            jmxServer.setMBeanServerForwarder(authzProxy);\n\n        jmxServer.start();\n\n        // use a custom Registry to avoid having to interact with it internally using the remoting interface\n        configureRMIRegistry(port, env);\n\n        logJmxServiceUrl(serverAddress, port);\n        return jmxServer;\n    }", "code_tokens": ["public", "static", "JMXConnectorServer", "createJMXServer", "(", "int", "port", ",", "boolean", "local", ")", "throws", "IOException", "{", "Map", "<", "String", ",", "Object", ">", "env", "=", "new", "HashMap", "<", ">", "(", ")", ";", "InetAddress", "serverAddress", "=", "null", ";", "if", "(", "local", ")", "{", "serverAddress", "=", "InetAddress", ".", "getLoopbackAddress", "(", ")", ";", "System", ".", "setProperty", "(", "\"", "java.rmi.server.hostname", "\"", ",", "serverAddress", ".", "getHostAddress", "(", ")", ")", ";", "}", "env", ".", "putAll", "(", "configureJmxSocketFactories", "(", "serverAddress", ",", "local", ")", ")", ";", "env", ".", "putAll", "(", "configureJmxAuthentication", "(", ")", ")", ";", "MBeanServerForwarder", "authzProxy", "=", "configureJmxAuthorization", "(", "env", ")", ";", "env", ".", "put", "(", "RMIExporter", ".", "EXPORTER_ATTRIBUTE", ",", "new", "Exporter", "(", ")", ")", ";", "int", "rmiPort", "=", "Integer", ".", "getInteger", "(", "\"", "com.sun.management.jmxremote.rmi.port", "\"", ",", "0", ")", ";", "JMXConnectorServer", "jmxServer", "=", "JMXConnectorServerFactory", ".", "newJMXConnectorServer", "(", "new", "JMXServiceURL", "(", "\"", "rmi", "\"", ",", "null", ",", "rmiPort", ")", ",", "env", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "if", "(", "authzProxy", "!=", "null", ")", "jmxServer", ".", "setMBeanServerForwarder", "(", "authzProxy", ")", ";", "jmxServer", ".", "start", "(", ")", ";", "configureRMIRegistry", "(", "port", ",", "env", ")", ";", "logJmxServiceUrl", "(", "serverAddress", ",", "port", ")", ";", "return", "jmxServer", ";", "}"], "idx": 41210, "cwe": "CWE-306", "target": 1, "status": "VULNERABLE", "commit": "28ee665b3c0c9238b61a871064f024d54cddcc79", "function_name": "createJMXServer", "body_hash": "e87302c3de7bd463343b3c0086e1f4b7cc080739"}
{"code": "private boolean isSensitiveValue(ModelNode value) {\n            if (value.getType() == ModelType.EXPRESSION\n                    || value.getType() == ModelType.STRING) {\n                String valueString = value.asString();\n                if (ExpressionResolver.EXPRESSION_PATTERN.matcher(valueString).matches()) {\n                    int start = valueString.indexOf(\"${\") + 2;\n                    int end = valueString.indexOf(\"}\", start);\n                    valueString = valueString.substring(start, end);\n                    return VaultReader.STANDARD_VAULT_PATTERN.matcher(valueString).matches();\n                }\n            }\n            return false;\n        }", "code_tokens": ["private", "boolean", "isSensitiveValue", "(", "ModelNode", "value", ")", "{", "if", "(", "value", ".", "getType", "(", ")", "==", "ModelType", ".", "EXPRESSION", "||", "value", ".", "getType", "(", ")", "==", "ModelType", ".", "STRING", ")", "{", "String", "valueString", "=", "value", ".", "asString", "(", ")", ";", "if", "(", "ExpressionResolver", ".", "EXPRESSION_PATTERN", ".", "matcher", "(", "valueString", ")", ".", "matches", "(", ")", ")", "{", "int", "start", "=", "valueString", ".", "indexOf", "(", "\"", "${", "\"", ")", "+", "2", ";", "int", "end", "=", "valueString", ".", "indexOf", "(", "\"", "}", "\"", ",", "start", ")", ";", "valueString", "=", "valueString", ".", "substring", "(", "start", ",", "end", ")", ";", "return", "VaultReader", ".", "STANDARD_VAULT_PATTERN", ".", "matcher", "(", "valueString", ")", ".", "matches", "(", ")", ";", "}", "}", "return", "false", ";", "}"], "idx": 98145, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "6d8db43cd43b5994b7a14003db978064e086090b", "function_name": "isSensitiveValue", "body_hash": "fc762e1d40ce790fa8077aecbfc0a61736ca667a"}
{"code": "public void createWebXmlDigester(boolean namespaceAware,\n            boolean validation) {\n        \n        if (!namespaceAware && !validation) {\n            if (webDigesters[0] == null) {\n                webDigesters[0] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webRuleSet);\n                webFragmentDigesters[0] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webFragmentRuleSet);\n            }\n            webDigester = webDigesters[0];\n            webFragmentDigester = webFragmentDigesters[0];\n            \n        } else if (!namespaceAware && validation) {\n            if (webDigesters[1] == null) {\n                webDigesters[1] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webRuleSet);\n                webFragmentDigesters[1] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webFragmentRuleSet);\n            }\n            webDigester = webDigesters[1];\n            webFragmentDigester = webFragmentDigesters[1];\n            \n        } else if (namespaceAware && !validation) {\n            if (webDigesters[2] == null) {\n                webDigesters[2] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webRuleSet);\n                webFragmentDigesters[2] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webFragmentRuleSet);\n            }\n            webDigester = webDigesters[2];\n            webFragmentDigester = webFragmentDigesters[2];\n            \n        } else {\n            if (webDigesters[3] == null) {\n                webDigesters[3] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webRuleSet);\n                webFragmentDigesters[3] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webFragmentRuleSet);\n            }\n            webDigester = webDigesters[3];\n            webFragmentDigester = webFragmentDigesters[3];\n        }\n    }", "code_tokens": ["public", "void", "createWebXmlDigester", "(", "boolean", "namespaceAware", ",", "boolean", "validation", ")", "{", "if", "(", "!", "namespaceAware", "&&", "!", "validation", ")", "{", "if", "(", "webDigesters", "[", "0", "]", "==", "null", ")", "{", "webDigesters", "[", "0", "]", "=", "DigesterFactory", ".", "newDigester", "(", "validation", ",", "namespaceAware", ",", "webRuleSet", ")", ";", "webFragmentDigesters", "[", "0", "]", "=", "DigesterFactory", ".", "newDigester", "(", "validation", ",", "namespaceAware", ",", "webFragmentRuleSet", ")", ";", "}", "webDigester", "=", "webDigesters", "[", "0", "]", ";", "webFragmentDigester", "=", "webFragmentDigesters", "[", "0", "]", ";", "}", "else", "if", "(", "!", "namespaceAware", "&&", "validation", ")", "{", "if", "(", "webDigesters", "[", "1", "]", "==", "null", ")", "{", "webDigesters", "[", "1", "]", "=", "DigesterFactory", ".", "newDigester", "(", "validation", ",", "namespaceAware", ",", "webRuleSet", ")", ";", "webFragmentDigesters", "[", "1", "]", "=", "DigesterFactory", ".", "newDigester", "(", "validation", ",", "namespaceAware", ",", "webFragmentRuleSet", ")", ";", "}", "webDigester", "=", "webDigesters", "[", "1", "]", ";", "webFragmentDigester", "=", "webFragmentDigesters", "[", "1", "]", ";", "}", "else", "if", "(", "namespaceAware", "&&", "!", "validation", ")", "{", "if", "(", "webDigesters", "[", "2", "]", "==", "null", ")", "{", "webDigesters", "[", "2", "]", "=", "DigesterFactory", ".", "newDigester", "(", "validation", ",", "namespaceAware", ",", "webRuleSet", ")", ";", "webFragmentDigesters", "[", "2", "]", "=", "DigesterFactory", ".", "newDigester", "(", "validation", ",", "namespaceAware", ",", "webFragmentRuleSet", ")", ";", "}", "webDigester", "=", "webDigesters", "[", "2", "]", ";", "webFragmentDigester", "=", "webFragmentDigesters", "[", "2", "]", ";", "}", "else", "{", "if", "(", "webDigesters", "[", "3", "]", "==", "null", ")", "{", "webDigesters", "[", "3", "]", "=", "DigesterFactory", ".", "newDigester", "(", "validation", ",", "namespaceAware", ",", "webRuleSet", ")", ";", "webFragmentDigesters", "[", "3", "]", "=", "DigesterFactory", ".", "newDigester", "(", "validation", ",", "namespaceAware", ",", "webFragmentRuleSet", ")", ";", "}", "webDigester", "=", "webDigesters", "[", "3", "]", ";", "webFragmentDigester", "=", "webFragmentDigesters", "[", "3", "]", ";", "}", "}"], "idx": 111220, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "279e4451cb996f810fbca2f78b6340412d9daa7b", "function_name": "createWebXmlDigester", "body_hash": "4204948ffc372037f94e6741f53673c67d031c42"}
{"code": "private void prepareRequest() {\n\n        // Translate the HTTP method code to a String.\n        byte methodCode = requestHeaderMessage.getByte();\n        if (methodCode != Constants.SC_M_JK_STORED) {\n            String methodName = Constants.getMethodForCode(methodCode - 1);\n            request.method().setString(methodName);\n        }\n\n        requestHeaderMessage.getBytes(request.protocol());\n        requestHeaderMessage.getBytes(request.requestURI());\n\n        requestHeaderMessage.getBytes(request.remoteAddr());\n        requestHeaderMessage.getBytes(request.remoteHost());\n        requestHeaderMessage.getBytes(request.localName());\n        request.setLocalPort(requestHeaderMessage.getInt());\n\n        boolean isSSL = requestHeaderMessage.getByte() != 0;\n        if (isSSL) {\n            request.scheme().setString(\"https\");\n        }\n\n        // Decode headers\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Set this every time in case limit has been changed via JMX\n        headers.setLimit(endpoint.getMaxHeaderCount());\n\n        boolean contentLengthSet = false;\n        int hCount = requestHeaderMessage.getInt();\n        for(int i = 0 ; i < hCount ; i++) {\n            String hName = null;\n\n            // Header names are encoded as either an integer code starting\n            // with 0xA0, or as a normal string (in which case the first\n            // two bytes are the length).\n            int isc = requestHeaderMessage.peekInt();\n            int hId = isc & 0xFF;\n\n            MessageBytes vMB = null;\n            isc &= 0xFF00;\n            if(0xA000 == isc) {\n                requestHeaderMessage.getInt(); // To advance the read position\n                hName = Constants.getHeaderForCode(hId - 1);\n                vMB = headers.addValue(hName);\n            } else {\n                // reset hId -- if the header currently being read\n                // happens to be 7 or 8 bytes long, the code below\n                // will think it's the content-type header or the\n                // content-length header - SC_REQ_CONTENT_TYPE=7,\n                // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected\n                // behaviour.  see bug 5861 for more information.\n                hId = -1;\n                requestHeaderMessage.getBytes(tmpMB);\n                ByteChunk bc = tmpMB.getByteChunk();\n                vMB = headers.addValue(bc.getBuffer(),\n                        bc.getStart(), bc.getLength());\n            }\n\n            requestHeaderMessage.getBytes(vMB);\n\n            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Length\"))) {\n                long cl = vMB.getLong();\n                if (contentLengthSet) {\n                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                } else {\n                    contentLengthSet = true;\n                    // Set the content-length header for the request\n                    request.setContentLength(cl);\n                }\n            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Type\"))) {\n                // just read the content-type header, so set it\n                ByteChunk bchunk = vMB.getByteChunk();\n                request.contentType().setBytes(bchunk.getBytes(),\n                        bchunk.getOffset(),\n                        bchunk.getLength());\n            }\n        }\n\n        // Decode extra attributes\n        boolean secretPresentInRequest = false;\n        byte attributeCode;\n        while ((attributeCode = requestHeaderMessage.getByte())\n                != Constants.SC_A_ARE_DONE) {\n\n            switch (attributeCode) {\n\n            case Constants.SC_A_REQ_ATTRIBUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                String n = tmpMB.toString();\n                requestHeaderMessage.getBytes(tmpMB);\n                String v = tmpMB.toString();\n                /*\n                 * AJP13 misses to forward the local IP address and the\n                 * remote port. Allow the AJP connector to add this info via\n                 * private request attributes.\n                 * We will accept the forwarded data and remove it from the\n                 * public list of request attributes.\n                 */\n                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {\n                    request.localAddr().setString(v);\n                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {\n                    try {\n                        request.setRemotePort(Integer.parseInt(v));\n                    } catch (NumberFormatException nfe) {\n                        // Ignore invalid value\n                    }\n                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {\n                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);\n                } else {\n                    request.setAttribute(n, v );\n                }\n                break;\n\n            case Constants.SC_A_CONTEXT :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SERVLET_PATH :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_REMOTE_USER :\n                if (tomcatAuthorization || !tomcatAuthentication) {\n                    // Implies tomcatAuthentication == false\n                    requestHeaderMessage.getBytes(request.getRemoteUser());\n                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);\n                } else {\n                    // Ignore user information from reverse proxy\n                    requestHeaderMessage.getBytes(tmpMB);\n                }\n                break;\n\n            case Constants.SC_A_AUTH_TYPE :\n                if (tomcatAuthentication) {\n                    // ignore server\n                    requestHeaderMessage.getBytes(tmpMB);\n                } else {\n                    requestHeaderMessage.getBytes(request.getAuthType());\n                }\n                break;\n\n            case Constants.SC_A_QUERY_STRING :\n                requestHeaderMessage.getBytes(request.queryString());\n                break;\n\n            case Constants.SC_A_JVM_ROUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SSL_CERT :\n                // SSL certificate extraction is lazy, moved to JkCoyoteHandler\n                requestHeaderMessage.getBytes(certificates);\n                break;\n\n            case Constants.SC_A_SSL_CIPHER :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_SESSION :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.SESSION_ID_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_KEY_SIZE :\n                request.setAttribute(SSLSupport.KEY_SIZE_KEY,\n                        Integer.valueOf(requestHeaderMessage.getInt()));\n                break;\n\n            case Constants.SC_A_STORED_METHOD:\n                requestHeaderMessage.getBytes(request.method());\n                break;\n\n            case Constants.SC_A_SECRET:\n                requestHeaderMessage.getBytes(tmpMB);\n                if (secret != null) {\n                    secretPresentInRequest = true;\n                    if (!tmpMB.equals(secret)) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    }\n                }\n                break;\n\n            default:\n                // Ignore unknown attribute for backward compatibility\n                break;\n\n            }\n\n        }\n\n        // Check if secret was submitted if required\n        if ((secret != null) && !secretPresentInRequest) {\n            response.setStatus(403);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n        }\n\n        // Check for a full URI (including protocol://host:port/)\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\"\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + slashPos,\n                            uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                        slashPos - pos - 3);\n            }\n\n        }\n\n        MessageBytes valueMB = request.getMimeHeaders().getValue(\"host\");\n        parseHost(valueMB);\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "{", "byte", "methodCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ";", "if", "(", "methodCode", "!=", "Constants", ".", "SC_M_JK_STORED", ")", "{", "String", "methodName", "=", "Constants", ".", "getMethodForCode", "(", "methodCode", "-", "1", ")", ";", "request", ".", "method", "(", ")", ".", "setString", "(", "methodName", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "protocol", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "requestURI", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteAddr", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteHost", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "localName", "(", ")", ")", ";", "request", ".", "setLocalPort", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ";", "boolean", "isSSL", "=", "requestHeaderMessage", ".", "getByte", "(", ")", "!=", "0", ";", "if", "(", "isSSL", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "headers", ".", "setLimit", "(", "endpoint", ".", "getMaxHeaderCount", "(", ")", ")", ";", "boolean", "contentLengthSet", "=", "false", ";", "int", "hCount", "=", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hCount", ";", "i", "++", ")", "{", "String", "hName", "=", "null", ";", "int", "isc", "=", "requestHeaderMessage", ".", "peekInt", "(", ")", ";", "int", "hId", "=", "isc", "&", "0xFF", ";", "MessageBytes", "vMB", "=", "null", ";", "isc", "&=", "0xFF00", ";", "if", "(", "0xA000", "==", "isc", ")", "{", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "hName", "=", "Constants", ".", "getHeaderForCode", "(", "hId", "-", "1", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "hName", ")", ";", "}", "else", "{", "hId", "=", "-", "1", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "ByteChunk", "bc", "=", "tmpMB", ".", "getByteChunk", "(", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "bc", ".", "getBuffer", "(", ")", ",", "bc", ".", "getStart", "(", ")", ",", "bc", ".", "getLength", "(", ")", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "vMB", ")", ";", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_LENGTH", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Length", "\"", ")", ")", ")", "{", "long", "cl", "=", "vMB", ".", "getLong", "(", ")", ";", "if", "(", "contentLengthSet", ")", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "else", "{", "contentLengthSet", "=", "true", ";", "request", ".", "setContentLength", "(", "cl", ")", ";", "}", "}", "else", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_TYPE", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Type", "\"", ")", ")", ")", "{", "ByteChunk", "bchunk", "=", "vMB", ".", "getByteChunk", "(", ")", ";", "request", ".", "contentType", "(", ")", ".", "setBytes", "(", "bchunk", ".", "getBytes", "(", ")", ",", "bchunk", ".", "getOffset", "(", ")", ",", "bchunk", ".", "getLength", "(", ")", ")", ";", "}", "}", "boolean", "secretPresentInRequest", "=", "false", ";", "byte", "attributeCode", ";", "while", "(", "(", "attributeCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ")", "!=", "Constants", ".", "SC_A_ARE_DONE", ")", "{", "switch", "(", "attributeCode", ")", "{", "case", "Constants", ".", "SC_A_REQ_ATTRIBUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "n", "=", "tmpMB", ".", "toString", "(", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "v", "=", "tmpMB", ".", "toString", "(", ")", ";", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_LOCAL_ADDR", ")", ")", "{", "request", ".", "localAddr", "(", ")", ".", "setString", "(", "v", ")", ";", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_REMOTE_PORT", ")", ")", "{", "try", "{", "request", ".", "setRemotePort", "(", "Integer", ".", "parseInt", "(", "v", ")", ")", ";", "}", "catch", "(", "NumberFormatException", "nfe", ")", "{", "}", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_SSL_PROTOCOL", ")", ")", "{", "request", ".", "setAttribute", "(", "SSLSupport", ".", "PROTOCOL_VERSION_KEY", ",", "v", ")", ";", "}", "else", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_CONTEXT", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SERVLET_PATH", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_REMOTE_USER", ":", "if", "(", "tomcatAuthorization", "||", "!", "tomcatAuthentication", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getRemoteUser", "(", ")", ")", ";", "request", ".", "setRemoteUserNeedsAuthorization", "(", "tomcatAuthorization", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_AUTH_TYPE", ":", "if", "(", "tomcatAuthentication", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getAuthType", "(", ")", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_QUERY_STRING", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "queryString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_JVM_ROUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CERT", ":", "requestHeaderMessage", ".", "getBytes", "(", "certificates", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CIPHER", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "CIPHER_SUITE_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_SESSION", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "SESSION_ID_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_KEY_SIZE", ":", "request", ".", "setAttribute", "(", "SSLSupport", ".", "KEY_SIZE_KEY", ",", "Integer", ".", "valueOf", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_STORED_METHOD", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "method", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SECRET", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "if", "(", "secret", "!=", "null", ")", "{", "secretPresentInRequest", "=", "true", ";", "if", "(", "!", "tmpMB", ".", "equals", "(", "secret", ")", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "break", ";", "default", ":", "break", ";", "}", "}", "if", "(", "(", "secret", "!=", "null", ")", "&&", "!", "secretPresentInRequest", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "uriBC", ".", "indexOf", "(", "\"", "://", "\"", ",", "0", ",", "3", ",", "4", ")", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "-", "1", ";", "if", "(", "pos", "!=", "-", "1", ")", "{", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", "+", "3", ")", ";", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "1", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "MessageBytes", "hostMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "3", ",", "slashPos", "-", "pos", "-", "3", ")", ";", "}", "}", "MessageBytes", "valueMB", "=", "request", ".", "getMimeHeaders", "(", ")", ".", "getValue", "(", "\"", "host", "\"", ")", ";", "parseHost", "(", "valueMB", ")", ";", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 111912, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "5a5494f", "function_name": "prepareRequest", "body_hash": "1bf72a9f9a6feb57ee8a598472b873356e3d0232"}
{"code": "@RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n    public ModelAndView recover(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        String usernameOrEmail = StringUtils.trimToNull(request.getParameter(\"usernameOrEmail\"));\n\n        if (usernameOrEmail != null) {\n\n            map.put(\"usernameOrEmail\", usernameOrEmail);\n            User user = getUserByUsernameOrEmail(usernameOrEmail);\n\n            boolean captchaOk;\n            if (settingsService.isCaptchaEnabled()) {\n                String recaptchaResponse = request.getParameter(\"g-recaptcha-response\");\n                ReCaptcha captcha = new ReCaptcha(settingsService.getRecaptchaSecretKey());\n                captchaOk = recaptchaResponse != null && captcha.isValid(recaptchaResponse);\n            } else {\n                captchaOk = true;\n            }\n            \n            if (!captchaOk) {\n                map.put(\"error\", \"recover.error.invalidcaptcha\");\n            } else if (user == null) {\n                map.put(\"error\", \"recover.error.usernotfound\");\n            } else if (user.getEmail() == null) {\n                map.put(\"error\", \"recover.error.noemail\");\n            } else {\n                String password = RandomStringUtils.randomAlphanumeric(8);\n                if (emailPassword(password, user.getUsername(), user.getEmail())) {\n                    map.put(\"sentTo\", user.getEmail());\n                    user.setLdapAuthenticated(false);\n                    user.setPassword(password);\n                    securityService.updateUser(user);\n                } else {\n                    map.put(\"error\", \"recover.error.sendfailed\");\n                }\n            }\n        }\n\n        if (settingsService.isCaptchaEnabled()) {\n            map.put(\"recaptchaSiteKey\", settingsService.getRecaptchaSiteKey());\n        }\n\n        return new ModelAndView(\"recover\", \"model\", map);\n    }", "code_tokens": ["@", "RequestMapping", "(", "method", "=", "{", "RequestMethod", ".", "GET", ",", "RequestMethod", ".", "POST", "}", ")", "public", "ModelAndView", "recover", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "Exception", "{", "Map", "<", "String", ",", "Object", ">", "map", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "String", "usernameOrEmail", "=", "StringUtils", ".", "trimToNull", "(", "request", ".", "getParameter", "(", "\"", "usernameOrEmail", "\"", ")", ")", ";", "if", "(", "usernameOrEmail", "!=", "null", ")", "{", "map", ".", "put", "(", "\"", "usernameOrEmail", "\"", ",", "usernameOrEmail", ")", ";", "User", "user", "=", "getUserByUsernameOrEmail", "(", "usernameOrEmail", ")", ";", "boolean", "captchaOk", ";", "if", "(", "settingsService", ".", "isCaptchaEnabled", "(", ")", ")", "{", "String", "recaptchaResponse", "=", "request", ".", "getParameter", "(", "\"", "g-recaptcha-response", "\"", ")", ";", "ReCaptcha", "captcha", "=", "new", "ReCaptcha", "(", "settingsService", ".", "getRecaptchaSecretKey", "(", ")", ")", ";", "captchaOk", "=", "recaptchaResponse", "!=", "null", "&&", "captcha", ".", "isValid", "(", "recaptchaResponse", ")", ";", "}", "else", "{", "captchaOk", "=", "true", ";", "}", "if", "(", "!", "captchaOk", ")", "{", "map", ".", "put", "(", "\"", "error", "\"", ",", "\"", "recover.error.invalidcaptcha", "\"", ")", ";", "}", "else", "if", "(", "user", "==", "null", ")", "{", "map", ".", "put", "(", "\"", "error", "\"", ",", "\"", "recover.error.usernotfound", "\"", ")", ";", "}", "else", "if", "(", "user", ".", "getEmail", "(", ")", "==", "null", ")", "{", "map", ".", "put", "(", "\"", "error", "\"", ",", "\"", "recover.error.noemail", "\"", ")", ";", "}", "else", "{", "String", "password", "=", "RandomStringUtils", ".", "randomAlphanumeric", "(", "8", ")", ";", "if", "(", "emailPassword", "(", "password", ",", "user", ".", "getUsername", "(", ")", ",", "user", ".", "getEmail", "(", ")", ")", ")", "{", "map", ".", "put", "(", "\"", "sentTo", "\"", ",", "user", ".", "getEmail", "(", ")", ")", ";", "user", ".", "setLdapAuthenticated", "(", "false", ")", ";", "user", ".", "setPassword", "(", "password", ")", ";", "securityService", ".", "updateUser", "(", "user", ")", ";", "}", "else", "{", "map", ".", "put", "(", "\"", "error", "\"", ",", "\"", "recover.error.sendfailed", "\"", ")", ";", "}", "}", "}", "if", "(", "settingsService", ".", "isCaptchaEnabled", "(", ")", ")", "{", "map", ".", "put", "(", "\"", "recaptchaSiteKey", "\"", ",", "settingsService", ".", "getRecaptchaSiteKey", "(", ")", ")", ";", "}", "return", "new", "ModelAndView", "(", "\"", "recover", "\"", ",", "\"", "model", "\"", ",", "map", ")", ";", "}"], "idx": 42644, "cwe": "CWE-335", "target": 1, "status": "VULNERABLE", "commit": "61c842923a6d60d4aedd126445a8437b53b752c8", "function_name": "recover", "body_hash": "865a1134372204aab97eee147374eed1e78ebdcc"}
{"code": "protected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n        }\n\n        // This is returned from the directory so will be attribute value\n        // escaped if required\n        String dn = user.getDN();\n        // This is the name the user provided to the authentication process so\n        // it will not be escaped\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        // Start with roles retrieved from the user entry\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        // Are we configured to do role searches?\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        // Set up parameters for an appropriate search filter\n        // The dn is already attribute value escaped but the others are not\n        // This is a filter so all input will require filter escaping\n        String filter = connection.roleFormat.format(new String[] {\n                doFilterEscaping(dn),\n                doFilterEscaping(doAttributeValueEscaping(username)),\n                doFilterEscaping(doAttributeValueEscaping(userRoleId)) });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                nameParts[i] = name.get(i);\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        // Perform the configured search and process the results\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;  // Should never happen, but just in case ...\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n                }\n                String dname = getDistinguishedName(connection.context, base, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n                }\n            }\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        // if nested group search is enabled, perform searches for nested groups until no new group is found\n        if (getRoleNested()) {\n\n            // The following efficient algorithm is known as memberOf Algorithm, as described in \"Practices in\n            // Directory Groups\". It avoids group slurping and handles cyclic group memberships as well.\n            // See http://middleware.internet2.edu/dir/ for details\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>(); // Stores the groups we find in this iteration\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    // Group key is already value escaped if required\n                    // Group value is not value escaped\n                    // Everything needs to be filter escaped\n                    filter = connection.roleFormat.format(new String[] {\n                            doFilterEscaping(group.getKey()),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())) });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, base, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n    }", "code_tokens": ["protected", "List", "<", "String", ">", "getRoles", "(", "JNDIConnection", "connection", ",", "User", "user", ")", "throws", "NamingException", "{", "if", "(", "user", "==", "null", ")", "{", "return", "null", ";", "}", "String", "dn", "=", "user", ".", "getDN", "(", ")", ";", "String", "username", "=", "user", ".", "getUserName", "(", ")", ";", "String", "userRoleId", "=", "user", ".", "getUserRoleId", "(", ")", ";", "if", "(", "dn", "==", "null", "||", "username", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  getRoles(", "\"", "+", "dn", "+", "\"", ")", "\"", ")", ";", "}", "List", "<", "String", ">", "list", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "String", ">", "userRoles", "=", "user", ".", "getRoles", "(", ")", ";", "if", "(", "userRoles", "!=", "null", ")", "{", "list", ".", "addAll", "(", "userRoles", ")", ";", "}", "if", "(", "commonRole", "!=", "null", ")", "{", "list", ".", "add", "(", "commonRole", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "list", ".", "size", "(", ")", "+", "\"", " user internal roles", "\"", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found user internal roles ", "\"", "+", "list", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "(", "connection", ".", "roleFormat", "==", "null", ")", "||", "(", "roleName", "==", "null", ")", ")", "{", "return", "list", ";", "}", "String", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "dn", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "username", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "userRoleId", ")", ")", "}", ")", ";", "SearchControls", "controls", "=", "new", "SearchControls", "(", ")", ";", "if", "(", "roleSubtree", ")", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "}", "else", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "ONELEVEL_SCOPE", ")", ";", "}", "controls", ".", "setReturningAttributes", "(", "new", "String", "[", "]", "{", "roleName", "}", ")", ";", "String", "base", "=", "null", ";", "if", "(", "connection", ".", "roleBaseFormat", "!=", "null", ")", "{", "NameParser", "np", "=", "connection", ".", "context", ".", "getNameParser", "(", "\"", "\"", ")", ";", "Name", "name", "=", "np", ".", "parse", "(", "dn", ")", ";", "String", "nameParts", "[", "]", "=", "new", "String", "[", "name", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "name", ".", "size", "(", ")", ";", "i", "++", ")", "{", "nameParts", "[", "i", "]", "=", "name", ".", "get", "(", "i", ")", ";", "}", "base", "=", "connection", ".", "roleBaseFormat", ".", "format", "(", "nameParts", ")", ";", "}", "else", "{", "base", "=", "\"", "\"", ";", "}", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "base", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "if", "(", "results", "==", "null", ")", "{", "return", "list", ";", "}", "Map", "<", "String", ",", "String", ">", "groupMap", "=", "new", "HashMap", "<", ">", "(", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "base", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "Set", "<", "Entry", "<", "String", ",", "String", ">", ">", "entries", "=", "groupMap", ".", "entrySet", "(", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "entries", ".", "size", "(", ")", "+", "\"", " direct roles", "\"", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "entry", ":", "entries", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found direct role ", "\"", "+", "entry", ".", "getKey", "(", ")", "+", "\"", " -> ", "\"", "+", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}", "if", "(", "getRoleNested", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newGroups", "=", "new", "HashMap", "<", ">", "(", "groupMap", ")", ";", "while", "(", "!", "newGroups", ".", "isEmpty", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newThisRound", "=", "new", "HashMap", "<", ">", "(", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "group", ":", "newGroups", ".", "entrySet", "(", ")", ")", "{", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "group", ".", "getKey", "(", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "group", ".", "getValue", "(", ")", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "group", ".", "getValue", "(", ")", ")", ")", "}", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "Perform a nested group search with base ", "\"", "+", "roleBase", "+", "\"", " and filter ", "\"", "+", "filter", ")", ";", "}", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "base", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", "&&", "!", "groupMap", ".", "keySet", "(", ")", ".", "contains", "(", "dname", ")", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "newThisRound", ".", "put", "(", "dname", ",", "name", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found nested role ", "\"", "+", "dname", "+", "\"", " -> ", "\"", "+", "name", ")", ";", "}", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "}", "newGroups", "=", "newThisRound", ";", "}", "}", "list", ".", "addAll", "(", "groupMap", ".", "values", "(", ")", ")", ";", "return", "list", ";", "}"], "idx": 420, "cwe": "CWE-116", "target": 0, "status": "FIXED", "commit": "81f16b0a7186ed02efbfac336589d6cff28d1e89", "function_name": "getRoles", "body_hash": "8afbd6e1ea1c4f00db9588f483e5c5de6f43ed8c"}
{"code": "@SuppressWarnings(\"deprecation\")\n    public void process(final HttpRequest request, final HttpContext context)\n            throws HttpException, IOException {\n        if (request == null) {\n            throw new IllegalArgumentException(\"HTTP request may not be null\");\n        }\n        if (context == null) {\n            throw new IllegalArgumentException(\"HTTP context may not be null\");\n        }\n\n        if (request.containsHeader(AUTH.PROXY_AUTH_RESP)) {\n            return;\n        }\n\n        HttpRoutedConnection conn = (HttpRoutedConnection) context.getAttribute(\n                ExecutionContext.HTTP_CONNECTION);\n        HttpRoute route = conn.getRoute();\n        if (route.isTunnelled()) {\n            return;\n        }\n\n        // Obtain authentication state\n        AuthState authState = (AuthState) context.getAttribute(\n                ClientContext.PROXY_AUTH_STATE);\n        if (authState == null) {\n            return;\n        }\n\n        AuthScheme authScheme = authState.getAuthScheme();\n        if (authScheme == null) {\n            return;\n        }\n\n        Credentials creds = authState.getCredentials();\n        if (creds == null) {\n            this.log.debug(\"User credentials not available\");\n            return;\n        }\n        if (authState.getAuthScope() != null || !authScheme.isConnectionBased()) {\n            try {\n                Header header;\n                if (authScheme instanceof ContextAwareAuthScheme) {\n                    header = ((ContextAwareAuthScheme) authScheme).authenticate(\n                            creds, request, context);\n                } else {\n                    header = authScheme.authenticate(creds, request);\n                }\n                request.addHeader(header);\n            } catch (AuthenticationException ex) {\n                if (this.log.isErrorEnabled()) {\n                    this.log.error(\"Proxy authentication error: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "deprecation", "\"", ")", "public", "void", "process", "(", "final", "HttpRequest", "request", ",", "final", "HttpContext", "context", ")", "throws", "HttpException", ",", "IOException", "{", "if", "(", "request", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "HTTP request may not be null", "\"", ")", ";", "}", "if", "(", "context", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "HTTP context may not be null", "\"", ")", ";", "}", "if", "(", "request", ".", "containsHeader", "(", "AUTH", ".", "PROXY_AUTH_RESP", ")", ")", "{", "return", ";", "}", "HttpRoutedConnection", "conn", "=", "(", "HttpRoutedConnection", ")", "context", ".", "getAttribute", "(", "ExecutionContext", ".", "HTTP_CONNECTION", ")", ";", "HttpRoute", "route", "=", "conn", ".", "getRoute", "(", ")", ";", "if", "(", "route", ".", "isTunnelled", "(", ")", ")", "{", "return", ";", "}", "AuthState", "authState", "=", "(", "AuthState", ")", "context", ".", "getAttribute", "(", "ClientContext", ".", "PROXY_AUTH_STATE", ")", ";", "if", "(", "authState", "==", "null", ")", "{", "return", ";", "}", "AuthScheme", "authScheme", "=", "authState", ".", "getAuthScheme", "(", ")", ";", "if", "(", "authScheme", "==", "null", ")", "{", "return", ";", "}", "Credentials", "creds", "=", "authState", ".", "getCredentials", "(", ")", ";", "if", "(", "creds", "==", "null", ")", "{", "this", ".", "log", ".", "debug", "(", "\"", "User credentials not available", "\"", ")", ";", "return", ";", "}", "if", "(", "authState", ".", "getAuthScope", "(", ")", "!=", "null", "||", "!", "authScheme", ".", "isConnectionBased", "(", ")", ")", "{", "try", "{", "Header", "header", ";", "if", "(", "authScheme", "instanceof", "ContextAwareAuthScheme", ")", "{", "header", "=", "(", "(", "ContextAwareAuthScheme", ")", "authScheme", ")", ".", "authenticate", "(", "creds", ",", "request", ",", "context", ")", ";", "}", "else", "{", "header", "=", "authScheme", ".", "authenticate", "(", "creds", ",", "request", ")", ";", "}", "request", ".", "addHeader", "(", "header", ")", ";", "}", "catch", "(", "AuthenticationException", "ex", ")", "{", "if", "(", "this", ".", "log", ".", "isErrorEnabled", "(", ")", ")", "{", "this", ".", "log", ".", "error", "(", "\"", "Proxy authentication error: ", "\"", "+", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "}"], "idx": 16100, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "a572756592c969affd0ce87885724e74839176fb", "function_name": "process", "body_hash": "37ec75a2812631afe2411dd1435ae96cffb11c19"}
{"code": "void doMaxAttributesFails() throws Exception\r\n   {\r\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n      System.out.println(\"dbf.getClass(): \" + dbf.getClass());\r\n      if (\"org.apache.xerces.jaxp.DocumentBuilderFactoryImpl\".equals(dbf.getClass().getName()))\r\n      {\r\n         System.out.println(\"Testing with Red Hat version of Xerces, skipping max attributes test\");\r\n         return;\r\n      }\r\n      System.out.println(\"entering doMaxAttributesFails()\");\r\n      ClientRequest request = new ClientRequest(generateURL(\"/test\"));\r\n      request.body(\"application/xml\", bigAttributeDoc);\r\n      ClientResponse<?> response = request.post();\r\n      System.out.println(\"doMaxAttributesFails() status: \" + response.getStatus());\r\n      String entity = response.getEntity(String.class);\r\n      System.out.println(\"doMaxAttributesFails() result: \" + entity);\r\n      Assert.assertEquals(400, response.getStatus());\r\n      Assert.assertTrue(entity.contains(\"org.xml.sax.SAXParseException\"));\r\n      Assert.assertTrue(entity.contains(\"has more than \\\"10,00\"));\r\n      int pos = entity.indexOf(\"has more than \\\"10,00\");\r\n      Assert.assertTrue(entity.substring(pos).contains(\"attributes\"));\r\n   }", "code_tokens": ["void", "doMaxAttributesFails", "(", ")", "throws", "Exception", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "dbf.getClass(): ", "\"", "+", "dbf", ".", "getClass", "(", ")", ")", ";", "if", "(", "\"", "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl", "\"", ".", "equals", "(", "dbf", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "Testing with Red Hat version of Xerces, skipping max attributes test", "\"", ")", ";", "return", ";", "}", "System", ".", "out", ".", "println", "(", "\"", "entering doMaxAttributesFails()", "\"", ")", ";", "ClientRequest", "request", "=", "new", "ClientRequest", "(", "generateURL", "(", "\"", "/test", "\"", ")", ")", ";", "request", ".", "body", "(", "\"", "application/xml", "\"", ",", "bigAttributeDoc", ")", ";", "ClientResponse", "<", "?", ">", "response", "=", "request", ".", "post", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "doMaxAttributesFails() status: ", "\"", "+", "response", ".", "getStatus", "(", ")", ")", ";", "String", "entity", "=", "response", ".", "getEntity", "(", "String", ".", "class", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "doMaxAttributesFails() result: ", "\"", "+", "entity", ")", ";", "Assert", ".", "assertEquals", "(", "400", ",", "response", ".", "getStatus", "(", ")", ")", ";", "Assert", ".", "assertTrue", "(", "entity", ".", "contains", "(", "\"", "org.xml.sax.SAXParseException", "\"", ")", ")", ";", "Assert", ".", "assertTrue", "(", "entity", ".", "contains", "(", "\"", "has more than ", "\\\"", "10,00", "\"", ")", ")", ";", "int", "pos", "=", "entity", ".", "indexOf", "(", "\"", "has more than ", "\\\"", "10,00", "\"", ")", ";", "Assert", ".", "assertTrue", "(", "entity", ".", "substring", "(", "pos", ")", ".", "contains", "(", "\"", "attributes", "\"", ")", ")", ";", "}"], "idx": 10789, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "7a0b80f57f9258e035b9584ddaa72414454e07b2", "function_name": "doMaxAttributesFails", "body_hash": "e9e8e1c8183c1c9c0e8512bd581fb7f10a713ac5"}
{"code": "private void cacheInput(Message outMessage) {\n        if (outMessage.getExchange() == null) {\n            return;\n        }\n        Message inMessage = outMessage.getExchange().getInMessage();\n        if (inMessage == null) {\n            return;\n        }\n        Object o = inMessage.get(\"cxf.io.cacheinput\");\n        DelegatingInputStream in = inMessage.getContent(DelegatingInputStream.class);\n        if (MessageUtils.isTrue(o)) {\n            Collection<Attachment> atts = inMessage.getAttachments();\n            if (atts != null) {\n                for (Attachment a : atts) {\n                    if (a.getDataHandler().getDataSource() instanceof AttachmentDataSource) {\n                        try {\n                            ((AttachmentDataSource)a.getDataHandler().getDataSource()).cache(inMessage);\n                        } catch (IOException e) {\n                            throw new Fault(e);\n                        }\n                    }\n                }\n            }\n            if (in != null) {\n                in.cacheInput();\n            }\n        } else if (in != null) {\n            //We don't need to cache it, but we may need to consume it in order for the client \n            // to be able to receive a response. (could be blocked sending)\n            //However, also don't want to consume indefinitely.   We'll limit to 16M.\n            try {\n                IOUtils.consume(in, 16 * 1024 * 1024);\n            } catch (IOException ioe) {\n                //ignore\n            }\n        }\n    }", "code_tokens": ["private", "void", "cacheInput", "(", "Message", "outMessage", ")", "{", "if", "(", "outMessage", ".", "getExchange", "(", ")", "==", "null", ")", "{", "return", ";", "}", "Message", "inMessage", "=", "outMessage", ".", "getExchange", "(", ")", ".", "getInMessage", "(", ")", ";", "if", "(", "inMessage", "==", "null", ")", "{", "return", ";", "}", "Object", "o", "=", "inMessage", ".", "get", "(", "\"", "cxf.io.cacheinput", "\"", ")", ";", "DelegatingInputStream", "in", "=", "inMessage", ".", "getContent", "(", "DelegatingInputStream", ".", "class", ")", ";", "if", "(", "MessageUtils", ".", "isTrue", "(", "o", ")", ")", "{", "Collection", "<", "Attachment", ">", "atts", "=", "inMessage", ".", "getAttachments", "(", ")", ";", "if", "(", "atts", "!=", "null", ")", "{", "for", "(", "Attachment", "a", ":", "atts", ")", "{", "if", "(", "a", ".", "getDataHandler", "(", ")", ".", "getDataSource", "(", ")", "instanceof", "AttachmentDataSource", ")", "{", "try", "{", "(", "(", "AttachmentDataSource", ")", "a", ".", "getDataHandler", "(", ")", ".", "getDataSource", "(", ")", ")", ".", "cache", "(", "inMessage", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "Fault", "(", "e", ")", ";", "}", "}", "}", "}", "if", "(", "in", "!=", "null", ")", "{", "in", ".", "cacheInput", "(", ")", ";", "}", "}", "else", "if", "(", "in", "!=", "null", ")", "{", "try", "{", "IOUtils", ".", "consume", "(", "in", ",", "16", "*", "1024", "*", "1024", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "}", "}", "}"], "idx": 52027, "cwe": "CWE-399", "target": 0, "status": "FIXED", "commit": "35cd29270b77b489cb23552637d66d47ce480f4c", "function_name": "cacheInput", "body_hash": "49a48f50278068a57095a839938cc66d5f93f8ff"}
{"code": "public static String resolvePath(String uri) {\n\t\tif (uri.isEmpty()) {\n\t\t\treturn uri;\n\t\t}\n\n\t\tString path;\n\t\tif (uri.charAt(0) == '/') {\n\t\t\tpath = uri;\n\t\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\t\tchar c = path.charAt(i);\n\t\t\t\tif (c == '?' || c == '#') {\n\t\t\t\t\tpath = path.substring(0, i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpath = URI.create(uri).getPath();\n\t\t}\n\t\tif (!path.isEmpty()) {\n\t\t\tif(path.charAt(0) == '/'){\n\t\t\t\tpath = path.substring(1);\n\t\t\t\tif(path.length() <= 1){\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(path.charAt(path.length() - 1) == '/'){\n\t\t\t\treturn path.substring(0, path.length() - 1);\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}", "code_tokens": ["public", "static", "String", "resolvePath", "(", "String", "uri", ")", "{", "if", "(", "uri", ".", "isEmpty", "(", ")", ")", "{", "return", "uri", ";", "}", "String", "path", ";", "if", "(", "uri", ".", "charAt", "(", "0", ")", "==", "'/'", ")", "{", "path", "=", "uri", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "path", ".", "length", "(", ")", ";", "i", "++", ")", "{", "char", "c", "=", "path", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "'?'", "||", "c", "==", "'#'", ")", "{", "path", "=", "path", ".", "substring", "(", "0", ",", "i", ")", ";", "break", ";", "}", "}", "}", "else", "{", "path", "=", "URI", ".", "create", "(", "uri", ")", ".", "getPath", "(", ")", ";", "}", "if", "(", "!", "path", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "path", ".", "charAt", "(", "0", ")", "==", "'/'", ")", "{", "path", "=", "path", ".", "substring", "(", "1", ")", ";", "if", "(", "path", ".", "length", "(", ")", "<=", "1", ")", "{", "return", "path", ";", "}", "}", "if", "(", "path", ".", "charAt", "(", "path", ".", "length", "(", ")", "-", "1", ")", "==", "'/'", ")", "{", "return", "path", ".", "substring", "(", "0", ",", "path", ".", "length", "(", ")", "-", "1", ")", ";", "}", "}", "return", "path", ";", "}"], "idx": 74840, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "7426c0c", "function_name": "resolvePath", "body_hash": "d6e3811e06dd8ab71d40b27d1aa00566e13aad84"}
{"code": "public static View create(StaplerRequest req, StaplerResponse rsp, ViewGroup owner)\n            throws FormException, IOException, ServletException {\n        String mode = req.getParameter(\"mode\");\n\n        String requestContentType = req.getContentType();\n        if (requestContentType == null\n                && !(mode != null && mode.equals(\"copy\")))\n            throw new Failure(\"No Content-Type header set\");\n\n        boolean isXmlSubmission = requestContentType != null\n                && (requestContentType.startsWith(\"application/xml\")\n                        || requestContentType.startsWith(\"text/xml\"));\n\n        String name = req.getParameter(\"name\");\n        Jenkins.checkGoodName(name);\n        if(owner.getView(name)!=null)\n            throw new Failure(Messages.Hudson_ViewAlreadyExists(name));\n\n        if (mode==null || mode.length()==0) {\n            if(isXmlSubmission) {\n                View v = createViewFromXML(name, req.getInputStream());\n                owner.getACL().checkCreatePermission(owner, v.getDescriptor());\n                v.owner = owner;\n                rsp.setStatus(HttpServletResponse.SC_OK);\n                return v;\n            } else\n                throw new Failure(Messages.View_MissingMode());\n        }\n\n        View v;\n        if (\"copy\".equals(mode)) {\n            v = copy(req, owner, name);\n        } else {\n            ViewDescriptor descriptor = all().findByName(mode);\n            if (descriptor == null) {\n                throw new Failure(\"No view type \u2018\" + mode + \"\u2019 is known\");\n            }\n\n            // create a view\n            v = descriptor.newInstance(req,req.getSubmittedForm());\n        }\n        owner.getACL().checkCreatePermission(owner, v.getDescriptor());\n        v.owner = owner;\n\n        // redirect to the config screen\n        rsp.sendRedirect2(req.getContextPath()+'/'+v.getUrl()+v.getPostConstructLandingPage());\n\n        return v;\n    }", "code_tokens": ["public", "static", "View", "create", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ",", "ViewGroup", "owner", ")", "throws", "FormException", ",", "IOException", ",", "ServletException", "{", "String", "mode", "=", "req", ".", "getParameter", "(", "\"", "mode", "\"", ")", ";", "String", "requestContentType", "=", "req", ".", "getContentType", "(", ")", ";", "if", "(", "requestContentType", "==", "null", "&&", "!", "(", "mode", "!=", "null", "&&", "mode", ".", "equals", "(", "\"", "copy", "\"", ")", ")", ")", "throw", "new", "Failure", "(", "\"", "No Content-Type header set", "\"", ")", ";", "boolean", "isXmlSubmission", "=", "requestContentType", "!=", "null", "&&", "(", "requestContentType", ".", "startsWith", "(", "\"", "application/xml", "\"", ")", "||", "requestContentType", ".", "startsWith", "(", "\"", "text/xml", "\"", ")", ")", ";", "String", "name", "=", "req", ".", "getParameter", "(", "\"", "name", "\"", ")", ";", "Jenkins", ".", "checkGoodName", "(", "name", ")", ";", "if", "(", "owner", ".", "getView", "(", "name", ")", "!=", "null", ")", "throw", "new", "Failure", "(", "Messages", ".", "Hudson_ViewAlreadyExists", "(", "name", ")", ")", ";", "if", "(", "mode", "==", "null", "||", "mode", ".", "length", "(", ")", "==", "0", ")", "{", "if", "(", "isXmlSubmission", ")", "{", "View", "v", "=", "createViewFromXML", "(", "name", ",", "req", ".", "getInputStream", "(", ")", ")", ";", "owner", ".", "getACL", "(", ")", ".", "checkCreatePermission", "(", "owner", ",", "v", ".", "getDescriptor", "(", ")", ")", ";", "v", ".", "owner", "=", "owner", ";", "rsp", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_OK", ")", ";", "return", "v", ";", "}", "else", "throw", "new", "Failure", "(", "Messages", ".", "View_MissingMode", "(", ")", ")", ";", "}", "View", "v", ";", "if", "(", "\"", "copy", "\"", ".", "equals", "(", "mode", ")", ")", "{", "v", "=", "copy", "(", "req", ",", "owner", ",", "name", ")", ";", "}", "else", "{", "ViewDescriptor", "descriptor", "=", "all", "(", ")", ".", "findByName", "(", "mode", ")", ";", "if", "(", "descriptor", "==", "null", ")", "{", "throw", "new", "Failure", "(", "\"", "No view type \u2018", "\"", "+", "mode", "+", "\"", "\u2019 is known", "\"", ")", ";", "}", "v", "=", "descriptor", ".", "newInstance", "(", "req", ",", "req", ".", "getSubmittedForm", "(", ")", ")", ";", "}", "owner", ".", "getACL", "(", ")", ".", "checkCreatePermission", "(", "owner", ",", "v", ".", "getDescriptor", "(", ")", ")", ";", "v", ".", "owner", "=", "owner", ";", "rsp", ".", "sendRedirect2", "(", "req", ".", "getContextPath", "(", ")", "+", "'/'", "+", "v", ".", "getUrl", "(", ")", "+", "v", ".", "getPostConstructLandingPage", "(", ")", ")", ";", "return", "v", ";", "}"], "idx": 28983, "cwe": "CWE-240", "target": 1, "status": "VULNERABLE", "commit": "42e2c74049ddf5e0aca1fe6aadc7b24fdabb5494", "function_name": "create", "body_hash": "a998bfc23eb80a3fc41b32e7753d78071a5ee3d2"}
{"code": "@Override\n    public boolean check(String uri, Resource resource)\n    {\n        // Only support PathResource alias checking\n        if (!(resource instanceof PathResource))\n            return false;\n        \n        PathResource pathResource = (PathResource)resource;\n\n        try\n        {\n            Path path = pathResource.getPath();\n            Path alias = pathResource.getAliasPath();\n\n            if (path.equals(alias))\n                return false; // Unknown why this is an alias\n\n            // is the file itself a symlink?\n            if (Files.isSymbolicLink(path))\n            {        \n                alias = path.getParent().resolve(alias);\n                if (LOG.isDebugEnabled())\n                {\n                    LOG.debug(\"path ={}\",path);\n                    LOG.debug(\"alias={}\",alias);\n                }\n                if (Files.isSameFile(path,alias))\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Allow symlink {} --> {}\",resource,pathResource.getAliasPath());\n                    return true;\n                }\n            }\n\n            // No, so let's check each element ourselves\n            boolean linked=true;\n            Path target=path;\n            int loops=0;\n            while (linked)\n            {\n                if (++loops>100)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Too many symlinks {} --> {}\",resource,target);\n                    return false;\n                }\n                linked=false;\n                Path d = target.getRoot();\n                for (Path e:target)\n                {\n                    Path r=d.resolve(e);\n                    d=r;\n\n                    while (Files.exists(d) && Files.isSymbolicLink(d))\n                    {\n                        Path link=Files.readSymbolicLink(d);    \n                        if (!link.isAbsolute())\n                            link=d.getParent().resolve(link);\n                        d=link;\n                        linked=true;\n                    }\n                }\n                target=d;\n            }\n            \n            if (pathResource.getAliasPath().equals(target))\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Allow path symlink {} --> {}\",resource,target);\n                return true;\n            }\n        }\n        catch(Exception e)\n        {\n            LOG.ignore(e);\n        }\n        \n        return false;\n    }", "code_tokens": ["@", "Override", "public", "boolean", "check", "(", "String", "uri", ",", "Resource", "resource", ")", "{", "if", "(", "!", "(", "resource", "instanceof", "PathResource", ")", ")", "return", "false", ";", "PathResource", "pathResource", "=", "(", "PathResource", ")", "resource", ";", "try", "{", "Path", "path", "=", "pathResource", ".", "getPath", "(", ")", ";", "Path", "alias", "=", "pathResource", ".", "getAliasPath", "(", ")", ";", "if", "(", "path", ".", "equals", "(", "alias", ")", ")", "return", "false", ";", "if", "(", "Files", ".", "isSymbolicLink", "(", "path", ")", ")", "{", "alias", "=", "path", ".", "getParent", "(", ")", ".", "resolve", "(", "alias", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "path ={}", "\"", ",", "path", ")", ";", "LOG", ".", "debug", "(", "\"", "alias={}", "\"", ",", "alias", ")", ";", "}", "if", "(", "Files", ".", "isSameFile", "(", "path", ",", "alias", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "Allow symlink {} --> {}", "\"", ",", "resource", ",", "pathResource", ".", "getAliasPath", "(", ")", ")", ";", "return", "true", ";", "}", "}", "boolean", "linked", "=", "true", ";", "Path", "target", "=", "path", ";", "int", "loops", "=", "0", ";", "while", "(", "linked", ")", "{", "if", "(", "++", "loops", ">", "100", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "Too many symlinks {} --> {}", "\"", ",", "resource", ",", "target", ")", ";", "return", "false", ";", "}", "linked", "=", "false", ";", "Path", "d", "=", "target", ".", "getRoot", "(", ")", ";", "for", "(", "Path", "e", ":", "target", ")", "{", "Path", "r", "=", "d", ".", "resolve", "(", "e", ")", ";", "d", "=", "r", ";", "while", "(", "Files", ".", "exists", "(", "d", ")", "&&", "Files", ".", "isSymbolicLink", "(", "d", ")", ")", "{", "Path", "link", "=", "Files", ".", "readSymbolicLink", "(", "d", ")", ";", "if", "(", "!", "link", ".", "isAbsolute", "(", ")", ")", "link", "=", "d", ".", "getParent", "(", ")", ".", "resolve", "(", "link", ")", ";", "d", "=", "link", ";", "linked", "=", "true", ";", "}", "}", "target", "=", "d", ";", "}", "if", "(", "pathResource", ".", "getAliasPath", "(", ")", ".", "equals", "(", "target", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "Allow path symlink {} --> {}", "\"", ",", "resource", ",", "target", ")", ";", "return", "true", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "ignore", "(", "e", ")", ";", "}", "return", "false", ";", "}"], "idx": 37291, "cwe": "CWE-284", "target": 0, "status": "FIXED", "commit": "97af3d663fd22343129e8364d601640649d9eaea", "function_name": "check", "body_hash": "48e85dc54df3fcfe19f22882af695650266de736"}
{"code": "public static XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\tspf.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\n\t\t// Create a JAXP SAXParser\n\t\tSAXParser saxParser = spf.newSAXParser();\n\n\t\t// Get the encapsulated SAX XMLReader\n\t\treturn saxParser.getXMLReader();\n\t}", "code_tokens": ["public", "static", "XMLReader", "createXmlReader", "(", ")", "throws", "SAXException", ",", "ParserConfigurationException", "{", "SAXParserFactory", "spf", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "true", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "false", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "false", ")", ";", "spf", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/namespaces", "\"", ",", "true", ")", ";", "SAXParser", "saxParser", "=", "spf", ".", "newSAXParser", "(", ")", ";", "return", "saxParser", ".", "getXMLReader", "(", ")", ";", "}"], "idx": 67183, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "6fc896b65ed871be33dcf453cde924bf73cf83db", "function_name": "createXmlReader", "body_hash": "fad328a4f52fbcf77e4e30093512a3fb2025fb2f"}
{"code": "@Override\n    public AbstractBuild<?,?> resolveChild(Child child) {\n        MatrixBuild b = (MatrixBuild)owner;\n        return b.getProject().getItem(Combination.fromString(child.name)).getBuildByNumber(child.build);\n    }", "code_tokens": ["@", "Override", "public", "AbstractBuild", "<", "?", ",", "?", ">", "resolveChild", "(", "Child", "child", ")", "{", "MatrixBuild", "b", "=", "(", "MatrixBuild", ")", "owner", ";", "return", "b", ".", "getProject", "(", ")", ".", "getItem", "(", "Combination", ".", "fromString", "(", "child", ".", "name", ")", ")", ".", "getBuildByNumber", "(", "child", ".", "build", ")", ";", "}"], "idx": 110384, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "07c09bebb8396a48063c1da4fc4b628acddd72a8", "function_name": "resolveChild", "body_hash": "54fcc083ca33c4a5691b03d00c48bb1bc6f975d9"}
{"code": "public Map<String, ResultTypeConfig> getResultTypesByExtension(PackageConfig packageConfig) {\n        Map<String, ResultTypeConfig> results = packageConfig.getAllResultTypeConfigs();\n\n        Map<String, ResultTypeConfig> resultsByExtension = new HashMap<String, ResultTypeConfig>();\n        resultsByExtension.put(\"jsp\", results.get(\"dispatcher\"));\n        resultsByExtension.put(\"jspf\", results.get(\"dispatcher\"));\n        resultsByExtension.put(\"jspx\", results.get(\"dispatcher\"));\n        resultsByExtension.put(\"vm\", results.get(\"velocity\"));\n        resultsByExtension.put(\"ftl\", results.get(\"freemarker\"));\n        resultsByExtension.put(\"html\", results.get(\"dispatcher\"));\n        resultsByExtension.put(\"htm\", results.get(\"dispatcher\"));\n        return resultsByExtension;\n    }", "code_tokens": ["public", "Map", "<", "String", ",", "ResultTypeConfig", ">", "getResultTypesByExtension", "(", "PackageConfig", "packageConfig", ")", "{", "Map", "<", "String", ",", "ResultTypeConfig", ">", "results", "=", "packageConfig", ".", "getAllResultTypeConfigs", "(", ")", ";", "Map", "<", "String", ",", "ResultTypeConfig", ">", "resultsByExtension", "=", "new", "HashMap", "<", "String", ",", "ResultTypeConfig", ">", "(", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "jsp", "\"", ",", "results", ".", "get", "(", "\"", "dispatcher", "\"", ")", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "jspf", "\"", ",", "results", ".", "get", "(", "\"", "dispatcher", "\"", ")", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "jspx", "\"", ",", "results", ".", "get", "(", "\"", "dispatcher", "\"", ")", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "vm", "\"", ",", "results", ".", "get", "(", "\"", "velocity", "\"", ")", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "ftl", "\"", ",", "results", ".", "get", "(", "\"", "freemarker", "\"", ")", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "html", "\"", ",", "results", ".", "get", "(", "\"", "dispatcher", "\"", ")", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "htm", "\"", ",", "results", ".", "get", "(", "\"", "dispatcher", "\"", ")", ")", ";", "return", "resultsByExtension", ";", "}"], "idx": 25794, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "030ffa33543f8953306ed0c0dc815c7fb74d7129", "function_name": "getResultTypesByExtension", "body_hash": "db183267508ab9375a579e8033e6cbe9c55be318"}
{"code": "public Map<String, ResultTypeConfig> getResultTypesByExtension(PackageConfig packageConfig) {\n        Map<String, ResultTypeConfig> results = packageConfig.getAllResultTypeConfigs();\n\n        ResultTypeConfig dispatcher = disableParse(results.get(\"dispatcher\"));\n        ResultTypeConfig velocity = disableParse(results.get(\"velocity\"));\n        ResultTypeConfig freemarker = disableParse(results.get(\"freemarker\"));\n\n        Map<String, ResultTypeConfig> resultsByExtension = new HashMap<String, ResultTypeConfig>();\n        resultsByExtension.put(\"jsp\", dispatcher);\n        resultsByExtension.put(\"jspf\", dispatcher);\n        resultsByExtension.put(\"jspx\", dispatcher);\n        resultsByExtension.put(\"vm\", velocity);\n        resultsByExtension.put(\"ftl\", freemarker);\n        resultsByExtension.put(\"html\", dispatcher);\n        resultsByExtension.put(\"htm\", dispatcher);\n        return resultsByExtension;\n    }", "code_tokens": ["public", "Map", "<", "String", ",", "ResultTypeConfig", ">", "getResultTypesByExtension", "(", "PackageConfig", "packageConfig", ")", "{", "Map", "<", "String", ",", "ResultTypeConfig", ">", "results", "=", "packageConfig", ".", "getAllResultTypeConfigs", "(", ")", ";", "ResultTypeConfig", "dispatcher", "=", "disableParse", "(", "results", ".", "get", "(", "\"", "dispatcher", "\"", ")", ")", ";", "ResultTypeConfig", "velocity", "=", "disableParse", "(", "results", ".", "get", "(", "\"", "velocity", "\"", ")", ")", ";", "ResultTypeConfig", "freemarker", "=", "disableParse", "(", "results", ".", "get", "(", "\"", "freemarker", "\"", ")", ")", ";", "Map", "<", "String", ",", "ResultTypeConfig", ">", "resultsByExtension", "=", "new", "HashMap", "<", "String", ",", "ResultTypeConfig", ">", "(", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "jsp", "\"", ",", "dispatcher", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "jspf", "\"", ",", "dispatcher", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "jspx", "\"", ",", "dispatcher", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "vm", "\"", ",", "velocity", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "ftl", "\"", ",", "freemarker", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "html", "\"", ",", "dispatcher", ")", ";", "resultsByExtension", ".", "put", "(", "\"", "htm", "\"", ",", "dispatcher", ")", ";", "return", "resultsByExtension", ";", "}"], "idx": 25795, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "030ffa33543f8953306ed0c0dc815c7fb74d7129", "function_name": "getResultTypesByExtension", "body_hash": "8105c10945b40448ebfb2680fe9871b70bba7c31"}
{"code": "@BeforeEach\n    public void startServer() throws Exception\n    {\n        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n        sslContextFactory.setKeyStorePath(keystore);\n        sslContextFactory.setKeyStorePassword(\"storepwd\");\n        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n\n        server = new Server();\n        HttpConnectionFactory http = new HttpConnectionFactory();\n        http.setInputBufferSize(512);\n        http.getHttpConfiguration().setRequestHeaderSize(512);\n        connector = new ServerConnector(server, sslContextFactory, http);\n        connector.setPort(0);\n        connector.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n\n        server.addConnector(connector);\n    }", "code_tokens": ["@", "BeforeEach", "public", "void", "startServer", "(", ")", "throws", "Exception", "{", "String", "keystore", "=", "MavenTestingUtils", ".", "getTestResourceFile", "(", "\"", "keystore", "\"", ")", ".", "getAbsolutePath", "(", ")", ";", "SslContextFactory", "sslContextFactory", "=", "new", "SslContextFactory", ".", "Server", "(", ")", ";", "sslContextFactory", ".", "setKeyStorePath", "(", "keystore", ")", ";", "sslContextFactory", ".", "setKeyStorePassword", "(", "\"", "storepwd", "\"", ")", ";", "sslContextFactory", ".", "setKeyManagerPassword", "(", "\"", "keypwd", "\"", ")", ";", "server", "=", "new", "Server", "(", ")", ";", "HttpConnectionFactory", "http", "=", "new", "HttpConnectionFactory", "(", ")", ";", "http", ".", "setInputBufferSize", "(", "512", ")", ";", "http", ".", "getHttpConfiguration", "(", ")", ".", "setRequestHeaderSize", "(", "512", ")", ";", "connector", "=", "new", "ServerConnector", "(", "server", ",", "sslContextFactory", ",", "http", ")", ";", "connector", ".", "setPort", "(", "0", ")", ";", "connector", ".", "getConnectionFactory", "(", "HttpConnectionFactory", ".", "class", ")", ".", "getHttpConfiguration", "(", ")", ".", "setSendDateHeader", "(", "false", ")", ";", "server", ".", "addConnector", "(", "connector", ")", ";", "}"], "idx": 65381, "cwe": "CWE-59", "target": 1, "status": "VULNERABLE", "commit": "00d379c94ba865dced2025c2d1bc3e2e0e41e880", "function_name": "startServer", "body_hash": "3e89e96da038a98a55bb50a2ce3041c7b4cafac5"}
{"code": "@Override\n    public boolean check(String uri, Resource resource)\n    {\n        // Only support PathResource alias checking\n        if (!(resource instanceof PathResource))\n            return false;\n        \n        PathResource pathResource = (PathResource)resource;\n\n        try\n        {\n            Path path = pathResource.getPath();\n            Path alias = pathResource.getAliasPath();\n            \n            // is the file itself a symlink?\n            if (Files.isSymbolicLink(path))\n            {        \n                alias = path.getParent().resolve(alias);\n                if (LOG.isDebugEnabled())\n                {\n                    LOG.debug(\"path ={}\",path);\n                    LOG.debug(\"alias={}\",alias);\n                }\n                if (Files.isSameFile(path,alias))\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Allow symlink {} --> {}\",resource,pathResource.getAliasPath());\n                    return true;\n                }\n            }\n\n            // No, so let's check each element ourselves\n            boolean linked=true;\n            Path target=path;\n            int loops=0;\n            while (linked)\n            {\n                if (++loops>100)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Too many symlinks {} --> {}\",resource,target);\n                    return false;\n                }\n                linked=false;\n                Path d = target.getRoot();\n                for (Path e:target)\n                {\n                    Path r=d.resolve(e);\n                    d=r;\n\n                    while (Files.exists(d) && Files.isSymbolicLink(d))\n                    {\n                        Path link=Files.readSymbolicLink(d);    \n                        if (!link.isAbsolute())\n                            link=d.getParent().resolve(link);\n                        d=link;\n                        linked=true;\n                    }\n                }\n                target=d;\n            }\n            \n            if (pathResource.getAliasPath().equals(target))\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Allow path symlink {} --> {}\",resource,target);\n                return true;\n            }\n        }\n        catch(Exception e)\n        {\n            LOG.ignore(e);\n        }\n        \n        return false;\n    }", "code_tokens": ["@", "Override", "public", "boolean", "check", "(", "String", "uri", ",", "Resource", "resource", ")", "{", "if", "(", "!", "(", "resource", "instanceof", "PathResource", ")", ")", "return", "false", ";", "PathResource", "pathResource", "=", "(", "PathResource", ")", "resource", ";", "try", "{", "Path", "path", "=", "pathResource", ".", "getPath", "(", ")", ";", "Path", "alias", "=", "pathResource", ".", "getAliasPath", "(", ")", ";", "if", "(", "Files", ".", "isSymbolicLink", "(", "path", ")", ")", "{", "alias", "=", "path", ".", "getParent", "(", ")", ".", "resolve", "(", "alias", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "path ={}", "\"", ",", "path", ")", ";", "LOG", ".", "debug", "(", "\"", "alias={}", "\"", ",", "alias", ")", ";", "}", "if", "(", "Files", ".", "isSameFile", "(", "path", ",", "alias", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "Allow symlink {} --> {}", "\"", ",", "resource", ",", "pathResource", ".", "getAliasPath", "(", ")", ")", ";", "return", "true", ";", "}", "}", "boolean", "linked", "=", "true", ";", "Path", "target", "=", "path", ";", "int", "loops", "=", "0", ";", "while", "(", "linked", ")", "{", "if", "(", "++", "loops", ">", "100", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "Too many symlinks {} --> {}", "\"", ",", "resource", ",", "target", ")", ";", "return", "false", ";", "}", "linked", "=", "false", ";", "Path", "d", "=", "target", ".", "getRoot", "(", ")", ";", "for", "(", "Path", "e", ":", "target", ")", "{", "Path", "r", "=", "d", ".", "resolve", "(", "e", ")", ";", "d", "=", "r", ";", "while", "(", "Files", ".", "exists", "(", "d", ")", "&&", "Files", ".", "isSymbolicLink", "(", "d", ")", ")", "{", "Path", "link", "=", "Files", ".", "readSymbolicLink", "(", "d", ")", ";", "if", "(", "!", "link", ".", "isAbsolute", "(", ")", ")", "link", "=", "d", ".", "getParent", "(", ")", ".", "resolve", "(", "link", ")", ";", "d", "=", "link", ";", "linked", "=", "true", ";", "}", "}", "target", "=", "d", ";", "}", "if", "(", "pathResource", ".", "getAliasPath", "(", ")", ".", "equals", "(", "target", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "Allow path symlink {} --> {}", "\"", ",", "resource", ",", "target", ")", ";", "return", "true", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "ignore", "(", "e", ")", ";", "}", "return", "false", ";", "}"], "idx": 37290, "cwe": "CWE-284", "target": 1, "status": "VULNERABLE", "commit": "97af3d663fd22343129e8364d601640649d9eaea", "function_name": "check", "body_hash": "127cc909c2833604cbe66f48eadfd62cfae42aa1"}
{"code": "public boolean matches(final byte[] message, final byte[] digest) {\n\n        if (message == null) {\n            return (digest == null);\n        } else if (digest == null) {\n            return false;\n        }\n        \n        // Check initialization\n        if (!isInitialized()) {\n            initialize();\n        }\n            \n        try {\n\n            // If we are using a salt, extract it to use it.\n            byte[] salt = null;\n            if (this.useSalt) {\n                // If we are using a salt generator which specifies the salt\n                // to be included into the digest itself, get it from there.\n                // If not, the salt is supposed to be fixed and thus the\n                // salt generator can be safely asked for it again.\n                if (this.saltGenerator.includePlainSaltInEncryptionResults()) {\n                    \n                    // Compute size figures and perform length checks\n                    int digestSaltSize = this.saltSizeBytes;\n                    if (this.digestLengthBytes > 0) {\n                        if (this.useLenientSaltSizeCheck) {\n                            if (digest.length < this.digestLengthBytes) {\n                                throw new EncryptionOperationNotPossibleException();\n                            }\n                            digestSaltSize = digest.length - this.digestLengthBytes;\n                        } else {\n                            if (digest.length != (this.digestLengthBytes + this.saltSizeBytes)) {\n                                throw new EncryptionOperationNotPossibleException();\n                            }\n                        }\n                    } else {\n                        // Salt size check behaviour cannot be set to lenient\n                        if (digest.length < this.saltSizeBytes) {\n                            throw new EncryptionOperationNotPossibleException();\n                        }\n                    }\n                    \n                    if (!this.invertPositionOfPlainSaltInEncryptionResults) {\n                        salt = new byte[digestSaltSize];\n                        System.arraycopy(digest, 0, salt, 0, digestSaltSize);\n                    } else {\n                        salt = new byte[digestSaltSize];\n                        System.arraycopy(digest, digest.length - digestSaltSize, salt, 0, digestSaltSize);\n                    }\n                    \n                } else {\n                    salt = this.saltGenerator.generateSalt(this.saltSizeBytes);\n                }\n            }\n            \n            // Digest the message with the extracted digest.\n            final byte[] encryptedMessage = digest(message, salt);\n            \n            // If, using the same salt, digests match, then messages too. \n            return (Arrays.equals(encryptedMessage, digest));\n        \n        } catch (Exception e) {\n            // If digest fails, it is more secure not to return any information\n            // about the cause in nested exceptions. Simply fail.\n            throw new EncryptionOperationNotPossibleException();\n        }\n        \n    }", "code_tokens": ["public", "boolean", "matches", "(", "final", "byte", "[", "]", "message", ",", "final", "byte", "[", "]", "digest", ")", "{", "if", "(", "message", "==", "null", ")", "{", "return", "(", "digest", "==", "null", ")", ";", "}", "else", "if", "(", "digest", "==", "null", ")", "{", "return", "false", ";", "}", "if", "(", "!", "isInitialized", "(", ")", ")", "{", "initialize", "(", ")", ";", "}", "try", "{", "byte", "[", "]", "salt", "=", "null", ";", "if", "(", "this", ".", "useSalt", ")", "{", "if", "(", "this", ".", "saltGenerator", ".", "includePlainSaltInEncryptionResults", "(", ")", ")", "{", "int", "digestSaltSize", "=", "this", ".", "saltSizeBytes", ";", "if", "(", "this", ".", "digestLengthBytes", ">", "0", ")", "{", "if", "(", "this", ".", "useLenientSaltSizeCheck", ")", "{", "if", "(", "digest", ".", "length", "<", "this", ".", "digestLengthBytes", ")", "{", "throw", "new", "EncryptionOperationNotPossibleException", "(", ")", ";", "}", "digestSaltSize", "=", "digest", ".", "length", "-", "this", ".", "digestLengthBytes", ";", "}", "else", "{", "if", "(", "digest", ".", "length", "!=", "(", "this", ".", "digestLengthBytes", "+", "this", ".", "saltSizeBytes", ")", ")", "{", "throw", "new", "EncryptionOperationNotPossibleException", "(", ")", ";", "}", "}", "}", "else", "{", "if", "(", "digest", ".", "length", "<", "this", ".", "saltSizeBytes", ")", "{", "throw", "new", "EncryptionOperationNotPossibleException", "(", ")", ";", "}", "}", "if", "(", "!", "this", ".", "invertPositionOfPlainSaltInEncryptionResults", ")", "{", "salt", "=", "new", "byte", "[", "digestSaltSize", "]", ";", "System", ".", "arraycopy", "(", "digest", ",", "0", ",", "salt", ",", "0", ",", "digestSaltSize", ")", ";", "}", "else", "{", "salt", "=", "new", "byte", "[", "digestSaltSize", "]", ";", "System", ".", "arraycopy", "(", "digest", ",", "digest", ".", "length", "-", "digestSaltSize", ",", "salt", ",", "0", ",", "digestSaltSize", ")", ";", "}", "}", "else", "{", "salt", "=", "this", ".", "saltGenerator", ".", "generateSalt", "(", "this", ".", "saltSizeBytes", ")", ";", "}", "}", "final", "byte", "[", "]", "encryptedMessage", "=", "digest", "(", "message", ",", "salt", ")", ";", "return", "(", "Arrays", ".", "equals", "(", "encryptedMessage", ",", "digest", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "EncryptionOperationNotPossibleException", "(", ")", ";", "}", "}"], "idx": 19225, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "8e62852a8018978ee19d39056c650fb66ffa0ff6", "function_name": "matches", "body_hash": "e776db91896c7c7972379a8b7b85c67ef33b7464"}
{"code": "protected String getRemoteAddr(RequestCycle requestCycle)\n\t{\n\t\tServletWebRequest request = (ServletWebRequest)requestCycle.getRequest();\n\t\treturn request.getContainerRequest().getRemoteAddr();\n\t}", "code_tokens": ["protected", "String", "getRemoteAddr", "(", "RequestCycle", "requestCycle", ")", "{", "ServletWebRequest", "request", "=", "(", "ServletWebRequest", ")", "requestCycle", ".", "getRequest", "(", ")", ";", "return", "request", ".", "getContainerRequest", "(", ")", ".", "getRemoteAddr", "(", ")", ";", "}"], "idx": 12072, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "84f62a5cff462eaa3bfaf171b0638c7e7feea30d", "function_name": "getRemoteAddr", "body_hash": "591751e0d6c99d942d7b47b2e1a455ae0186c004"}
{"code": "public WireFormat createWireFormat() {\n        WireFormatInfo info = new WireFormatInfo();\n        info.setVersion(version);\n\n        try {\n            info.setStackTraceEnabled(stackTraceEnabled);\n            info.setCacheEnabled(cacheEnabled);\n            info.setTcpNoDelayEnabled(tcpNoDelayEnabled);\n            info.setTightEncodingEnabled(tightEncodingEnabled);\n            info.setSizePrefixDisabled(sizePrefixDisabled);\n            info.setMaxInactivityDuration(maxInactivityDuration);\n            info.setMaxInactivityDurationInitalDelay(maxInactivityDurationInitalDelay);\n            info.setCacheSize(cacheSize);\n            info.setMaxFrameSize(maxFrameSize);\n            if( host!=null ) {\n                info.setHost(host);\n            }\n            info.setProviderName(providerName);\n            info.setProviderVersion(providerVersion);\n            info.setPlatformDetails(platformDetails);\n        } catch (Exception e) {\n            IllegalStateException ise = new IllegalStateException(\"Could not configure WireFormatInfo\");\n            ise.initCause(e);\n            throw ise;\n        }\n\n        OpenWireFormat f = new OpenWireFormat(version);\n        f.setMaxFrameSize(maxFrameSize);\n        f.setPreferedWireFormatInfo(info);\n        return f;\n    }", "code_tokens": ["public", "WireFormat", "createWireFormat", "(", ")", "{", "WireFormatInfo", "info", "=", "new", "WireFormatInfo", "(", ")", ";", "info", ".", "setVersion", "(", "version", ")", ";", "try", "{", "info", ".", "setStackTraceEnabled", "(", "stackTraceEnabled", ")", ";", "info", ".", "setCacheEnabled", "(", "cacheEnabled", ")", ";", "info", ".", "setTcpNoDelayEnabled", "(", "tcpNoDelayEnabled", ")", ";", "info", ".", "setTightEncodingEnabled", "(", "tightEncodingEnabled", ")", ";", "info", ".", "setSizePrefixDisabled", "(", "sizePrefixDisabled", ")", ";", "info", ".", "setMaxInactivityDuration", "(", "maxInactivityDuration", ")", ";", "info", ".", "setMaxInactivityDurationInitalDelay", "(", "maxInactivityDurationInitalDelay", ")", ";", "info", ".", "setCacheSize", "(", "cacheSize", ")", ";", "info", ".", "setMaxFrameSize", "(", "maxFrameSize", ")", ";", "if", "(", "host", "!=", "null", ")", "{", "info", ".", "setHost", "(", "host", ")", ";", "}", "info", ".", "setProviderName", "(", "providerName", ")", ";", "info", ".", "setProviderVersion", "(", "providerVersion", ")", ";", "info", ".", "setPlatformDetails", "(", "platformDetails", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "IllegalStateException", "ise", "=", "new", "IllegalStateException", "(", "\"", "Could not configure WireFormatInfo", "\"", ")", ";", "ise", ".", "initCause", "(", "e", ")", ";", "throw", "ise", ";", "}", "OpenWireFormat", "f", "=", "new", "OpenWireFormat", "(", "version", ")", ";", "f", ".", "setMaxFrameSize", "(", "maxFrameSize", ")", ";", "f", ".", "setPreferedWireFormatInfo", "(", "info", ")", ";", "return", "f", ";", "}"], "idx": 12412, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "5fa0bbd5156f29d97dcf48fd9fdb6a0488a8df1a", "function_name": "createWireFormat", "body_hash": "6feb30ad56948f25a33048cc91bba80b3fe0e6fc"}
{"code": "@Override\n        public boolean check(Object credentials)\n        {\n            if (credentials instanceof char[])\n                credentials=new String((char[])credentials);\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n\n            try\n            {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5)\n                {\n                    // Credentials are already a MD5 digest - assume it's in\n                    // form user:realm:password (we have no way to know since\n                    // it's a digest, alright?)\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                }\n                else\n                {\n                    // calc A1 digest\n                    md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                // calc A2 digest\n                md.reset();\n                md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                byte[] ha2 = md.digest();\n\n                // calc digest\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\"\n                // nc-value \":\" unq(cnonce-value) \":\" unq(qop-value) \":\" H(A2) )\n                // <\">\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2)\n                // ) > <\">\n\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                byte[] digest = md.digest();\n\n                // check digest\n                return stringEquals(TypeUtil.toString(digest, 16).toLowerCase(), response == null ? null : response.toLowerCase());\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n            }\n\n            return false;\n        }", "code_tokens": ["@", "Override", "public", "boolean", "check", "(", "Object", "credentials", ")", "{", "if", "(", "credentials", "instanceof", "char", "[", "]", ")", "credentials", "=", "new", "String", "(", "(", "char", "[", "]", ")", "credentials", ")", ";", "String", "password", "=", "(", "credentials", "instanceof", "String", ")", "?", "(", "String", ")", "credentials", ":", "credentials", ".", "toString", "(", ")", ";", "try", "{", "MessageDigest", "md", "=", "MessageDigest", ".", "getInstance", "(", "\"", "MD5", "\"", ")", ";", "byte", "[", "]", "ha1", ";", "if", "(", "credentials", "instanceof", "Credential", ".", "MD5", ")", "{", "ha1", "=", "(", "(", "Credential", ".", "MD5", ")", "credentials", ")", ".", "getDigest", "(", ")", ";", "}", "else", "{", "md", ".", "update", "(", "username", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "realm", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "password", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "ha1", "=", "md", ".", "digest", "(", ")", ";", "}", "md", ".", "reset", "(", ")", ";", "md", ".", "update", "(", "method", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "uri", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "byte", "[", "]", "ha2", "=", "md", ".", "digest", "(", ")", ";", "md", ".", "update", "(", "TypeUtil", ".", "toString", "(", "ha1", ",", "16", ")", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "nonce", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "nc", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "cnonce", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "qop", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "TypeUtil", ".", "toString", "(", "ha2", ",", "16", ")", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "byte", "[", "]", "digest", "=", "md", ".", "digest", "(", ")", ";", "return", "stringEquals", "(", "TypeUtil", ".", "toString", "(", "digest", ",", "16", ")", ".", "toLowerCase", "(", ")", ",", "response", "==", "null", "?", "null", ":", "response", ".", "toLowerCase", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "warn", "(", "e", ")", ";", "}", "return", "false", ";", "}"], "idx": 20336, "cwe": "CWE-203", "target": 0, "status": "FIXED", "commit": "042f325f1cd6e7891d72c7e668f5947b5457dc02", "function_name": "check", "body_hash": "901b5f61aa70b413cb4729d9717e0f2cc44603fc"}
{"code": "public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)\n            throws PresentationException, IndexUnreachableException {\n        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);\n        if (StringUtils.isNotBlank(fileName)) {\n            dataFolderPath = dataFolderPath.resolve(fileName);\n        }\n        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {\n            return getDataFilePath(pi, altDataFolderName, null, fileName);\n        }\n\n        return dataFolderPath;\n    }", "code_tokens": ["public", "static", "Path", "getDataFilePath", "(", "String", "pi", ",", "String", "dataFolderName", ",", "String", "altDataFolderName", ",", "String", "fileName", ")", "throws", "PresentationException", ",", "IndexUnreachableException", "{", "java", ".", "nio", ".", "file", ".", "Path", "dataFolderPath", "=", "getDataFolder", "(", "pi", ",", "dataFolderName", ")", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "fileName", ")", ")", "{", "dataFolderPath", "=", "dataFolderPath", ".", "resolve", "(", "fileName", ")", ";", "}", "if", "(", "StringUtils", ".", "isNotBlank", "(", "altDataFolderName", ")", "&&", "!", "Files", ".", "exists", "(", "dataFolderPath", ")", ")", "{", "return", "getDataFilePath", "(", "pi", ",", "altDataFolderName", ",", "null", ",", "fileName", ")", ";", "}", "return", "dataFolderPath", ";", "}"], "idx": 21853, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "44ceb8e2e7e888391e8a941127171d6366770df3", "function_name": "getDataFilePath", "body_hash": "87c5c6893abd16b212ff2a54b798feab78c1661b"}
{"code": "@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder()\n                .put(InternalNode.HTTP_ENABLED, true)\n                .put(super.nodeSettings(nodeOrdinal)).build();\n    }", "code_tokens": ["@", "Override", "protected", "Settings", "nodeSettings", "(", "int", "nodeOrdinal", ")", "{", "return", "ImmutableSettings", ".", "builder", "(", ")", ".", "put", "(", "InternalNode", ".", "HTTP_ENABLED", ",", "true", ")", ".", "put", "(", "super", ".", "nodeSettings", "(", "nodeOrdinal", ")", ")", ".", "build", "(", ")", ";", "}"], "idx": 27468, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "df1427a2935237fb61fc641984f9c76478627fec", "function_name": "nodeSettings", "body_hash": "7a1e6f176f40751a805ea60ef8b9ae6d5bce7e1b"}
{"code": "@Override\n    public Object unmarshal(final Exchange exchange, final InputStream inputStream) throws Exception {\n        final Hessian2Input in = new Hessian2Input(inputStream);\n        try {\n            in.startMessage();\n            final Object obj = in.readObject();\n            in.completeMessage();\n            return obj;\n        } finally {\n            try {\n                in.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "Object", "unmarshal", "(", "final", "Exchange", "exchange", ",", "final", "InputStream", "inputStream", ")", "throws", "Exception", "{", "final", "Hessian2Input", "in", "=", "new", "Hessian2Input", "(", "inputStream", ")", ";", "try", "{", "in", ".", "startMessage", "(", ")", ";", "final", "Object", "obj", "=", "in", ".", "readObject", "(", ")", ";", "in", ".", "completeMessage", "(", ")", ";", "return", "obj", ";", "}", "finally", "{", "try", "{", "in", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "}", "}"], "idx": 57652, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "260eed35dd5", "function_name": "unmarshal", "body_hash": "1ca5a4ed7e487dc336ee92da70fb49233e7e19ab"}
{"code": "@Override\n    protected boolean op(String name, File path) throws SecurityException {\n        if (SystemProperties.getBoolean(SKIP_PROPERTY)) {\n            LOGGER.log(Level.FINE, () -> \"Skipping check for '\" + name + \"' on '\" + path + \"'\");\n            return false;\n        }\n\n        final Jenkins jenkins = Jenkins.get();\n\n        String patternString;\n        try {\n            patternString = Jenkins.expandVariablesForDirectory(jenkins.getRawBuildsDir(), \"(.+)\", \"\\\\Q\" + Jenkins.get().getRootDir().getCanonicalPath().replace('\\\\', '/') + \"\\\\E/jobs/(.+)\") + \"/[0-9]+(/.*)?\";\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to obtain canonical path to Jenkins home directory\", e);\n            throw new SecurityException(\"Failed to obtain canonical path\"); // Minimal details\n        }\n        final Pattern pattern = Pattern.compile(patternString);\n\n        String absolutePath;\n        try {\n            absolutePath = path.getCanonicalPath().replace('\\\\', '/');\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to obtain canonical path to '\" + path + \"'\", e);\n            throw new SecurityException(\"Failed to obtain canonical path\"); // Minimal details\n        }\n        if (!pattern.matcher(absolutePath).matches()) {\n            /* This is not a build directory, so another filter will take care of it */\n            LOGGER.log(Level.FINE, \"Not a build directory, so skipping: \" + absolutePath);\n            return false;\n        }\n\n        if (!(context instanceof Computer)) {\n            LOGGER.warning(() -> \"Unrecognized context \" + context + \" rejected for \" + name + \" on \" + path);\n            throw new SecurityException(\"Failed to discover context of access to build directory\"); // Minimal details\n        }\n        Computer c = (Computer) context;\n        final Path thePath = path.getAbsoluteFile().toPath();\n        for (Executor executor : c.getExecutors()) {\n            Run<?, ?> build = findRun(executor.getCurrentExecutable());\n            if (build == null) {\n                continue;\n            }\n            final Path buildDir = build.getRootDir().getAbsoluteFile().toPath();\n            // If the directory being accessed is for a build currently running on this node, allow it\n            if (thePath.startsWith(buildDir)) {\n                return false;\n            }\n        }\n\n        final String computerName = c.getName();\n        if (SystemProperties.getBoolean(FAIL_PROPERTY, true)) {\n            // This filter can only prohibit by throwing a SecurityException; it never allows on its own.\n            LOGGER.log(Level.WARNING, \"Rejecting unexpected agent-to-controller file path access: Agent '\" + computerName + \"' is attempting to access '\" + absolutePath + \"' using operation '\" + name + \"'. Learn more: https://www.jenkins.io/redirect/security-144/\");\n            throw new SecurityException(\"Agent tried to access build directory of a build not currently running on this system. Learn more: https://www.jenkins.io/redirect/security-144/\");\n        } else {\n            LOGGER.log(Level.WARNING, \"Unexpected agent-to-controller file path access: Agent '\" + computerName + \"' is accessing '\" + absolutePath + \"' using operation '\" + name + \"'. Learn more: https://www.jenkins.io/redirect/security-144/\");\n            return false;\n        }\n    }", "code_tokens": ["@", "Override", "protected", "boolean", "op", "(", "String", "name", ",", "File", "path", ")", "throws", "SecurityException", "{", "if", "(", "SystemProperties", ".", "getBoolean", "(", "SKIP_PROPERTY", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "(", ")", "->", "\"", "Skipping check for '", "\"", "+", "name", "+", "\"", "' on '", "\"", "+", "path", "+", "\"", "'", "\"", ")", ";", "return", "false", ";", "}", "final", "Jenkins", "jenkins", "=", "Jenkins", ".", "get", "(", ")", ";", "String", "patternString", ";", "try", "{", "patternString", "=", "Jenkins", ".", "expandVariablesForDirectory", "(", "jenkins", ".", "getRawBuildsDir", "(", ")", ",", "\"", "(.+)", "\"", ",", "\"", "\\\\", "Q", "\"", "+", "Jenkins", ".", "get", "(", ")", ".", "getRootDir", "(", ")", ".", "getCanonicalPath", "(", ")", ".", "replace", "(", "'\\\\'", ",", "'/'", ")", "+", "\"", "\\\\", "E/jobs/(.+)", "\"", ")", "+", "\"", "/[0-9]+(/.*)?", "\"", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to obtain canonical path to Jenkins home directory", "\"", ",", "e", ")", ";", "throw", "new", "SecurityException", "(", "\"", "Failed to obtain canonical path", "\"", ")", ";", "}", "final", "Pattern", "pattern", "=", "Pattern", ".", "compile", "(", "patternString", ")", ";", "String", "absolutePath", ";", "try", "{", "absolutePath", "=", "path", ".", "getCanonicalPath", "(", ")", ".", "replace", "(", "'\\\\'", ",", "'/'", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Failed to obtain canonical path to '", "\"", "+", "path", "+", "\"", "'", "\"", ",", "e", ")", ";", "throw", "new", "SecurityException", "(", "\"", "Failed to obtain canonical path", "\"", ")", ";", "}", "if", "(", "!", "pattern", ".", "matcher", "(", "absolutePath", ")", ".", "matches", "(", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "Not a build directory, so skipping: ", "\"", "+", "absolutePath", ")", ";", "return", "false", ";", "}", "if", "(", "!", "(", "context", "instanceof", "Computer", ")", ")", "{", "LOGGER", ".", "warning", "(", "(", ")", "->", "\"", "Unrecognized context ", "\"", "+", "context", "+", "\"", " rejected for ", "\"", "+", "name", "+", "\"", " on ", "\"", "+", "path", ")", ";", "throw", "new", "SecurityException", "(", "\"", "Failed to discover context of access to build directory", "\"", ")", ";", "}", "Computer", "c", "=", "(", "Computer", ")", "context", ";", "final", "Path", "thePath", "=", "path", ".", "getAbsoluteFile", "(", ")", ".", "toPath", "(", ")", ";", "for", "(", "Executor", "executor", ":", "c", ".", "getExecutors", "(", ")", ")", "{", "Run", "<", "?", ",", "?", ">", "build", "=", "findRun", "(", "executor", ".", "getCurrentExecutable", "(", ")", ")", ";", "if", "(", "build", "==", "null", ")", "{", "continue", ";", "}", "final", "Path", "buildDir", "=", "build", ".", "getRootDir", "(", ")", ".", "getAbsoluteFile", "(", ")", ".", "toPath", "(", ")", ";", "if", "(", "thePath", ".", "startsWith", "(", "buildDir", ")", ")", "{", "return", "false", ";", "}", "}", "final", "String", "computerName", "=", "c", ".", "getName", "(", ")", ";", "if", "(", "SystemProperties", ".", "getBoolean", "(", "FAIL_PROPERTY", ",", "true", ")", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Rejecting unexpected agent-to-controller file path access: Agent '", "\"", "+", "computerName", "+", "\"", "' is attempting to access '", "\"", "+", "absolutePath", "+", "\"", "' using operation '", "\"", "+", "name", "+", "\"", "'. Learn more: https://www.jenkins.io/redirect/security-144/", "\"", ")", ";", "throw", "new", "SecurityException", "(", "\"", "Agent tried to access build directory of a build not currently running on this system. Learn more: https://www.jenkins.io/redirect/security-144/", "\"", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Unexpected agent-to-controller file path access: Agent '", "\"", "+", "computerName", "+", "\"", "' is accessing '", "\"", "+", "absolutePath", "+", "\"", "' using operation '", "\"", "+", "name", "+", "\"", "'. Learn more: https://www.jenkins.io/redirect/security-144/", "\"", ")", ";", "return", "false", ";", "}", "}"], "idx": 2527, "cwe": "CWE-184", "target": 0, "status": "FIXED", "commit": "eae33841b587da787f37d5b6c8451d483edc04d9", "function_name": "op", "body_hash": "fea80347cbf15300671924295e336432e821910e"}
{"code": "public InputStream stream(final String host, final ByteBuffer message) throws IOException {\n        ServerAddress serverAddress = host.contains(\":\") ? new ServerAddress(host) : new ServerAddress(host, defaultPort);\n        SSLSocket socket = (SSLSocket) sslContext.getSocketFactory().createSocket();\n\n        try {\n            enableHostNameVerification(socket);\n            socket.setSoTimeout(timeoutMillis);\n            socket.connect(serverAddress.getSocketAddress(), timeoutMillis);\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n        }\n\n        try {\n            OutputStream outputStream = socket.getOutputStream();\n\n            byte[] bytes = new byte[message.remaining()];\n\n            message.get(bytes);\n            outputStream.write(bytes);\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n        }\n\n        try {\n            return socket.getInputStream();\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n        }\n    }", "code_tokens": ["public", "InputStream", "stream", "(", "final", "String", "host", ",", "final", "ByteBuffer", "message", ")", "throws", "IOException", "{", "ServerAddress", "serverAddress", "=", "host", ".", "contains", "(", "\"", ":", "\"", ")", "?", "new", "ServerAddress", "(", "host", ")", ":", "new", "ServerAddress", "(", "host", ",", "defaultPort", ")", ";", "SSLSocket", "socket", "=", "(", "SSLSocket", ")", "sslContext", ".", "getSocketFactory", "(", ")", ".", "createSocket", "(", ")", ";", "try", "{", "enableHostNameVerification", "(", "socket", ")", ";", "socket", ".", "setSoTimeout", "(", "timeoutMillis", ")", ";", "socket", ".", "connect", "(", "serverAddress", ".", "getSocketAddress", "(", ")", ",", "timeoutMillis", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "closeSocket", "(", "socket", ")", ";", "throw", "e", ";", "}", "try", "{", "OutputStream", "outputStream", "=", "socket", ".", "getOutputStream", "(", ")", ";", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "message", ".", "remaining", "(", ")", "]", ";", "message", ".", "get", "(", "bytes", ")", ";", "outputStream", ".", "write", "(", "bytes", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "closeSocket", "(", "socket", ")", ";", "throw", "e", ";", "}", "try", "{", "return", "socket", ".", "getInputStream", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "closeSocket", "(", "socket", ")", ";", "throw", "e", ";", "}", "}"], "idx": 40037, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "60d87d5a76645a331a77ccc45ef7c67aac88b234", "function_name": "stream", "body_hash": "d0af015d6e0fd78106d3ede8eb787783d76a9854"}
{"code": "public void list(HttpServletRequest request,\n                     HttpServletResponse response,\n                     String message) throws IOException {\n\n        PrintWriter writer = response.getWriter();\n\n        // HTML Header Section\n        writer.print(Constants.HTML_HEADER_SECTION);\n\n        // Body Header Section\n        Object[] args = new Object[2];\n        args[0] = request.getContextPath();\n        args[1] = sm.getString(\"htmlHostManagerServlet.title\");\n        writer.print(MessageFormat.format\n                     (Constants.BODY_HEADER_SECTION, args));\n\n        // Message Section\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.messageLabel\");\n        if (message == null || message.length() == 0) {\n            args[1] = \"OK\";\n        } else {\n            args[1] = RequestUtil.filter(message);\n        }\n        writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args));\n\n        // Manager Section\n        args = new Object[9];\n        args[0] = sm.getString(\"htmlHostManagerServlet.manager\");\n        args[1] = response.encodeURL(request.getContextPath() + \"/html/list\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.list\");\n        args[3] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpHtmlManagerFile\"));\n        args[4] = sm.getString(\"htmlHostManagerServlet.helpHtmlManager\");\n        args[5] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpManagerFile\"));\n        args[6] = sm.getString(\"htmlHostManagerServlet.helpManager\");\n        args[7] = response.encodeURL(\"/manager/status\");\n        args[8] = sm.getString(\"statusServlet.title\");\n        writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args));\n\n         // Hosts Header Section\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.hostName\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.hostAliases\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.hostTasks\");\n        writer.print(MessageFormat.format(HOSTS_HEADER_SECTION, args));\n\n        // Hosts Row Section\n        // Create sorted map of host names.\n        Container[] children = engine.findChildren();\n        String hostNames[] = new String[children.length];\n        for (int i = 0; i < children.length; i++)\n            hostNames[i] = children[i].getName();\n\n        TreeMap sortedHostNamesMap = new TreeMap();\n\n        for (int i = 0; i < hostNames.length; i++) {\n            String displayPath = hostNames[i];\n            sortedHostNamesMap.put(displayPath, hostNames[i]);\n        }\n\n        String hostsStart = sm.getString(\"htmlHostManagerServlet.hostsStart\");\n        String hostsStop = sm.getString(\"htmlHostManagerServlet.hostsStop\");\n        String hostsRemove = sm.getString(\"htmlHostManagerServlet.hostsRemove\");\n\n        Iterator iterator = sortedHostNamesMap.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = (Map.Entry) iterator.next();\n            String hostName = (String) entry.getKey();\n            Host host = (Host) engine.findChild(hostName);\n\n            if (host != null ) {\n                args = new Object[2];\n                args[0] = hostName;\n                String[] aliases = host.findAliases();\n                StringBuffer buf = new StringBuffer();\n                if (aliases.length > 0) {\n                    buf.append(aliases[0]);\n                    for (int j = 1; j < aliases.length; j++) {\n                        buf.append(\", \").append(aliases[j]);\n                    }\n                }\n\n                if (buf.length() == 0) {\n                    buf.append(\"&nbsp;\");\n                }\n\n                args[1] = buf.toString();\n                writer.print\n                    (MessageFormat.format(HOSTS_ROW_DETAILS_SECTION, args));\n\n                args = new Object[7];\n                args[0] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/start?name=\" + hostName);\n                args[1] = hostsStart;\n                args[2] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/stop?name=\" + hostName);\n                args[3] = hostsStop;\n                args[4] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/remove?name=\" + hostName);\n                args[5] = hostsRemove;\n                args[6] = hostName;\n                if (host == this.host) {\n                    writer.print(MessageFormat.format(\n                        MANAGER_HOST_ROW_BUTTON_SECTION, args));\n                } else {\n                    writer.print(MessageFormat.format(\n                        HOSTS_ROW_BUTTON_SECTION, args));\n                }\n\n            }\n        }\n\n        // Add Section\n        args = new Object[6];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.addHost\");\n        args[2] = response.encodeURL(request.getContextPath() + \"/html/add\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.addName\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.addAliases\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.addAppBase\");\n        writer.print(MessageFormat.format(ADD_SECTION_START, args));\n \n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addAutoDeploy\");\n        args[1] = \"autoDeploy\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployOnStartup\");\n        args[1] = \"deployOnStartup\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployXML\");\n        args[1] = \"deployXML\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addUnpackWARs\");\n        args[1] = \"unpackWARs\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlNamespaceAware\");\n        args[1] = \"xmlNamespaceAware\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlValidation\");\n        args[1] = \"xmlValidation\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n\n        args[0] = sm.getString(\"htmlHostManagerServlet.addManager\");\n        args[1] = \"manager\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        \n        args = new Object[1];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addButton\");\n        writer.print(MessageFormat.format(ADD_SECTION_END, args));\n\n        // Server Header Section\n        args = new Object[7];\n        args[0] = sm.getString(\"htmlHostManagerServlet.serverTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.serverVersion\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.serverJVMVersion\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.serverJVMVendor\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.serverOSName\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.serverOSVersion\");\n        args[6] = sm.getString(\"htmlHostManagerServlet.serverOSArch\");\n        writer.print(MessageFormat.format\n                     (Constants.SERVER_HEADER_SECTION, args));\n\n        // Server Row Section\n        args = new Object[6];\n        args[0] = ServerInfo.getServerInfo();\n        args[1] = System.getProperty(\"java.runtime.version\");\n        args[2] = System.getProperty(\"java.vm.vendor\");\n        args[3] = System.getProperty(\"os.name\");\n        args[4] = System.getProperty(\"os.version\");\n        args[5] = System.getProperty(\"os.arch\");\n        writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args));\n\n        // HTML Tail Section\n        writer.print(Constants.HTML_TAIL_SECTION);\n\n        // Finish up the response\n        writer.flush();\n        writer.close();\n    }", "code_tokens": ["public", "void", "list", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "String", "message", ")", "throws", "IOException", "{", "PrintWriter", "writer", "=", "response", ".", "getWriter", "(", ")", ";", "writer", ".", "print", "(", "Constants", ".", "HTML_HEADER_SECTION", ")", ";", "Object", "[", "]", "args", "=", "new", "Object", "[", "2", "]", ";", "args", "[", "0", "]", "=", "request", ".", "getContextPath", "(", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.title", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "BODY_HEADER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.messageLabel", "\"", ")", ";", "if", "(", "message", "==", "null", "||", "message", ".", "length", "(", ")", "==", "0", ")", "{", "args", "[", "1", "]", "=", "\"", "OK", "\"", ";", "}", "else", "{", "args", "[", "1", "]", "=", "RequestUtil", ".", "filter", "(", "message", ")", ";", "}", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "MESSAGE_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "9", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.manager", "\"", ")", ";", "args", "[", "1", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/list", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.list", "\"", ")", ";", "args", "[", "3", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/", "\"", "+", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpHtmlManagerFile", "\"", ")", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpHtmlManager", "\"", ")", ";", "args", "[", "5", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/", "\"", "+", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpManagerFile", "\"", ")", ")", ";", "args", "[", "6", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.helpManager", "\"", ")", ";", "args", "[", "7", "]", "=", "response", ".", "encodeURL", "(", "\"", "/manager/status", "\"", ")", ";", "args", "[", "8", "]", "=", "sm", ".", "getString", "(", "\"", "statusServlet.title", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "MANAGER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostName", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostAliases", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostTasks", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_HEADER_SECTION", ",", "args", ")", ")", ";", "Container", "[", "]", "children", "=", "engine", ".", "findChildren", "(", ")", ";", "String", "hostNames", "[", "]", "=", "new", "String", "[", "children", ".", "length", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "children", ".", "length", ";", "i", "++", ")", "hostNames", "[", "i", "]", "=", "children", "[", "i", "]", ".", "getName", "(", ")", ";", "TreeMap", "sortedHostNamesMap", "=", "new", "TreeMap", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hostNames", ".", "length", ";", "i", "++", ")", "{", "String", "displayPath", "=", "hostNames", "[", "i", "]", ";", "sortedHostNamesMap", ".", "put", "(", "displayPath", ",", "hostNames", "[", "i", "]", ")", ";", "}", "String", "hostsStart", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsStart", "\"", ")", ";", "String", "hostsStop", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsStop", "\"", ")", ";", "String", "hostsRemove", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.hostsRemove", "\"", ")", ";", "Iterator", "iterator", "=", "sortedHostNamesMap", ".", "entrySet", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iterator", ".", "hasNext", "(", ")", ")", "{", "Map", ".", "Entry", "entry", "=", "(", "Map", ".", "Entry", ")", "iterator", ".", "next", "(", ")", ";", "String", "hostName", "=", "(", "String", ")", "entry", ".", "getKey", "(", ")", ";", "Host", "host", "=", "(", "Host", ")", "engine", ".", "findChild", "(", "hostName", ")", ";", "if", "(", "host", "!=", "null", ")", "{", "args", "=", "new", "Object", "[", "2", "]", ";", "args", "[", "0", "]", "=", "hostName", ";", "String", "[", "]", "aliases", "=", "host", ".", "findAliases", "(", ")", ";", "StringBuffer", "buf", "=", "new", "StringBuffer", "(", ")", ";", "if", "(", "aliases", ".", "length", ">", "0", ")", "{", "buf", ".", "append", "(", "aliases", "[", "0", "]", ")", ";", "for", "(", "int", "j", "=", "1", ";", "j", "<", "aliases", ".", "length", ";", "j", "++", ")", "{", "buf", ".", "append", "(", "\"", ", ", "\"", ")", ".", "append", "(", "aliases", "[", "j", "]", ")", ";", "}", "}", "if", "(", "buf", ".", "length", "(", ")", "==", "0", ")", "{", "buf", ".", "append", "(", "\"", "&nbsp;", "\"", ")", ";", "}", "args", "[", "1", "]", "=", "buf", ".", "toString", "(", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_ROW_DETAILS_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "7", "]", ";", "args", "[", "0", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/start?name=", "\"", "+", "hostName", ")", ";", "args", "[", "1", "]", "=", "hostsStart", ";", "args", "[", "2", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/stop?name=", "\"", "+", "hostName", ")", ";", "args", "[", "3", "]", "=", "hostsStop", ";", "args", "[", "4", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/remove?name=", "\"", "+", "hostName", ")", ";", "args", "[", "5", "]", "=", "hostsRemove", ";", "args", "[", "6", "]", "=", "hostName", ";", "if", "(", "host", "==", "this", ".", "host", ")", "{", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "MANAGER_HOST_ROW_BUTTON_SECTION", ",", "args", ")", ")", ";", "}", "else", "{", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "HOSTS_ROW_BUTTON_SECTION", ",", "args", ")", ")", ";", "}", "}", "}", "args", "=", "new", "Object", "[", "6", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addTitle", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addHost", "\"", ")", ";", "args", "[", "2", "]", "=", "response", ".", "encodeURL", "(", "request", ".", "getContextPath", "(", ")", "+", "\"", "/html/add", "\"", ")", ";", "args", "[", "3", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addName", "\"", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAliases", "\"", ")", ";", "args", "[", "5", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAppBase", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_START", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "3", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addAutoDeploy", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "autoDeploy", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addDeployOnStartup", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "deployOnStartup", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addDeployXML", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "deployXML", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addUnpackWARs", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "unpackWARs", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addXmlNamespaceAware", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "xmlNamespaceAware", "\"", ";", "args", "[", "2", "]", "=", "\"", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addXmlValidation", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "xmlValidation", "\"", ";", "args", "[", "2", "]", "=", "\"", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addManager", "\"", ")", ";", "args", "[", "1", "]", "=", "\"", "manager", "\"", ";", "args", "[", "2", "]", "=", "\"", "checked", "\"", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_BOOLEAN", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "1", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.addButton", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "ADD_SECTION_END", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "7", "]", ";", "args", "[", "0", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverTitle", "\"", ")", ";", "args", "[", "1", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverVersion", "\"", ")", ";", "args", "[", "2", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverJVMVersion", "\"", ")", ";", "args", "[", "3", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverJVMVendor", "\"", ")", ";", "args", "[", "4", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSName", "\"", ")", ";", "args", "[", "5", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSVersion", "\"", ")", ";", "args", "[", "6", "]", "=", "sm", ".", "getString", "(", "\"", "htmlHostManagerServlet.serverOSArch", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "SERVER_HEADER_SECTION", ",", "args", ")", ")", ";", "args", "=", "new", "Object", "[", "6", "]", ";", "args", "[", "0", "]", "=", "ServerInfo", ".", "getServerInfo", "(", ")", ";", "args", "[", "1", "]", "=", "System", ".", "getProperty", "(", "\"", "java.runtime.version", "\"", ")", ";", "args", "[", "2", "]", "=", "System", ".", "getProperty", "(", "\"", "java.vm.vendor", "\"", ")", ";", "args", "[", "3", "]", "=", "System", ".", "getProperty", "(", "\"", "os.name", "\"", ")", ";", "args", "[", "4", "]", "=", "System", ".", "getProperty", "(", "\"", "os.version", "\"", ")", ";", "args", "[", "5", "]", "=", "System", ".", "getProperty", "(", "\"", "os.arch", "\"", ")", ";", "writer", ".", "print", "(", "MessageFormat", ".", "format", "(", "Constants", ".", "SERVER_ROW_SECTION", ",", "args", ")", ")", ";", "writer", ".", "print", "(", "Constants", ".", "HTML_TAIL_SECTION", ")", ";", "writer", ".", "flush", "(", ")", ";", "writer", ".", "close", "(", ")", ";", "}"], "idx": 79274, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "5202986c8f2a67bb08a360e178bc04bfe986b69b", "function_name": "list", "body_hash": "0ed600942f57c7518df0d5b89a99c6cb3490b711"}
{"code": "protected void configureSnakeDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        Class<?> yamlUnmarshalType =  unmarshalType;\n        if (yamlUnmarshalType == null && unmarshalTypeName != null) {\n            try {\n                yamlUnmarshalType = camelContext.getClassResolver().resolveMandatoryClass(unmarshalTypeName);\n            } catch (ClassNotFoundException e) {\n                throw ObjectHelper.wrapRuntimeCamelException(e);\n            }\n        }\n\n        setProperty(dataFormat, camelContext, \"unmarshalType\", yamlUnmarshalType);\n        setProperty(dataFormat, camelContext, \"classLoader\", classLoader);\n        setProperty(dataFormat, camelContext, \"useApplicationContextClassLoader\", useApplicationContextClassLoader);\n        setProperty(dataFormat, camelContext, \"prettyFlow\", prettyFlow);\n\n        setPropertyRef(dataFormat, camelContext, \"constructor\", constructor);\n        setPropertyRef(dataFormat, camelContext, \"representer\", representer);\n        setPropertyRef(dataFormat, camelContext, \"dumperOptions\", dumperOptions);\n        setPropertyRef(dataFormat, camelContext, \"resolver\", resolver);\n    }", "code_tokens": ["protected", "void", "configureSnakeDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "Class", "<", "?", ">", "yamlUnmarshalType", "=", "unmarshalType", ";", "if", "(", "yamlUnmarshalType", "==", "null", "&&", "unmarshalTypeName", "!=", "null", ")", "{", "try", "{", "yamlUnmarshalType", "=", "camelContext", ".", "getClassResolver", "(", ")", ".", "resolveMandatoryClass", "(", "unmarshalTypeName", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "throw", "ObjectHelper", ".", "wrapRuntimeCamelException", "(", "e", ")", ";", "}", "}", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "unmarshalType", "\"", ",", "yamlUnmarshalType", ")", ";", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "classLoader", "\"", ",", "classLoader", ")", ";", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "useApplicationContextClassLoader", "\"", ",", "useApplicationContextClassLoader", ")", ";", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "prettyFlow", "\"", ",", "prettyFlow", ")", ";", "setPropertyRef", "(", "dataFormat", ",", "camelContext", ",", "\"", "constructor", "\"", ",", "constructor", ")", ";", "setPropertyRef", "(", "dataFormat", ",", "camelContext", ",", "\"", "representer", "\"", ",", "representer", ")", ";", "setPropertyRef", "(", "dataFormat", ",", "camelContext", ",", "\"", "dumperOptions", "\"", ",", "dumperOptions", ")", ";", "setPropertyRef", "(", "dataFormat", ",", "camelContext", ",", "\"", "resolver", "\"", ",", "resolver", ")", ";", "}"], "idx": 57294, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "20e26226107f3133c87d0f5c845e02f824823f69", "function_name": "configureSnakeDataFormat", "body_hash": "b4a7d1776142d00917710f8d24daa83798d6e7c3"}
{"code": "protected Configuration createConfiguration(ServletContext servletContext) throws TemplateException {\n        Configuration configuration = new Configuration(Configuration.VERSION_2_3_0);\n\n        configuration.setTemplateExceptionHandler(TemplateExceptionHandler.HTML_DEBUG_HANDLER);\n\n        if (mruMaxStrongSize > 0) {\n            configuration.setSetting(Configuration.CACHE_STORAGE_KEY, \"strong:\" + mruMaxStrongSize);\n        }\n        if (templateUpdateDelay != null) {\n            configuration.setSetting(Configuration.TEMPLATE_UPDATE_DELAY_KEY, templateUpdateDelay);\n        }\n        if (encoding != null) {\n            configuration.setDefaultEncoding(encoding);\n        }\n        configuration.setLocalizedLookup(false);\n        configuration.setWhitespaceStripping(true);\n\n        LOG.debug(\"Sets NewBuiltinClassResolver to TemplateClassResolver.SAFER_RESOLVER\");\n        configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);\n\n        return configuration;\n    }", "code_tokens": ["protected", "Configuration", "createConfiguration", "(", "ServletContext", "servletContext", ")", "throws", "TemplateException", "{", "Configuration", "configuration", "=", "new", "Configuration", "(", "Configuration", ".", "VERSION_2_3_0", ")", ";", "configuration", ".", "setTemplateExceptionHandler", "(", "TemplateExceptionHandler", ".", "HTML_DEBUG_HANDLER", ")", ";", "if", "(", "mruMaxStrongSize", ">", "0", ")", "{", "configuration", ".", "setSetting", "(", "Configuration", ".", "CACHE_STORAGE_KEY", ",", "\"", "strong:", "\"", "+", "mruMaxStrongSize", ")", ";", "}", "if", "(", "templateUpdateDelay", "!=", "null", ")", "{", "configuration", ".", "setSetting", "(", "Configuration", ".", "TEMPLATE_UPDATE_DELAY_KEY", ",", "templateUpdateDelay", ")", ";", "}", "if", "(", "encoding", "!=", "null", ")", "{", "configuration", ".", "setDefaultEncoding", "(", "encoding", ")", ";", "}", "configuration", ".", "setLocalizedLookup", "(", "false", ")", ";", "configuration", ".", "setWhitespaceStripping", "(", "true", ")", ";", "LOG", ".", "debug", "(", "\"", "Sets NewBuiltinClassResolver to TemplateClassResolver.SAFER_RESOLVER", "\"", ")", ";", "configuration", ".", "setNewBuiltinClassResolver", "(", "TemplateClassResolver", ".", "SAFER_RESOLVER", ")", ";", "return", "configuration", ";", "}"], "idx": 6219, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "2306f5f7fad7f0157f216f34331238feb0539fa", "function_name": "createConfiguration", "body_hash": "203f66a479e0fc53e82531e14533545df3e0d4be"}
{"code": "public Stream<CompilerInput> finalize(URI remoteURI, PackageID moduleID) {\n        try {\n            // only continue if a fixed module version is not set. a module version may be set through Ballerina.toml or\n            // Ballerina.lock already.\n            Matcher matcher = semVerPatchPattern.matcher(moduleID.version.value);\n            if (\"\".equals(moduleID.version.value) || \"*\".equals(moduleID.version.value) || matcher.matches()) {\n                HttpURLConnection conn;\n                // set proxy if exists.\n                if (null == this.proxy) {\n                    conn = (HttpURLConnection) remoteURI.toURL().openConnection();\n                } else {\n                    conn = (HttpURLConnection) remoteURI.toURL().openConnection(this.proxy);\n                }\n                conn.setInstanceFollowRedirects(false);\n                conn.setRequestMethod(\"GET\");\n\n                // status code and meaning\n                //// 200 - module info found\n                //// 400 - bad request sent\n                //// 500 - backend is broken\n                int statusCode = conn.getResponseCode();\n                if (statusCode == 200) {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                            Charset.defaultCharset()))) {\n                        StringBuilder result = new StringBuilder();\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            result.append(line);\n                        }\n                        Object payload = JSONParser.parse(result.toString());\n                        if (payload instanceof MapValue) {\n                            MapValue moduleInfo = ((MapValue) payload).getMapValue(\"module\");\n                            String version = moduleInfo.getStringValue(\"version\");\n                            moduleID.version = new Name(version);\n                        }\n                    }\n                } else if (statusCode == 400 && !loggedError) {\n                    try (BufferedReader errorStream = new BufferedReader(\n                            new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {\n                        String errorContent = errorStream.lines().collect(Collectors.joining(\"\\n\"));\n                        this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                                \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                                \"flag to build in offline mode. reason: \" + errorContent);\n                        setErrorLoggedStatusAsTrue();\n                    }\n                } else if (statusCode == 500 && !loggedError) {\n                    this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                            \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                            \"flag to build in offline mode.\");\n                    setErrorLoggedStatusAsTrue();\n                }\n                conn.disconnect();\n                Authenticator.setDefault(null);\n            }\n        } catch (IOException e) {\n            // ignore error and don't set the version.\n        }\n\n        return Stream.empty();\n    }", "code_tokens": ["public", "Stream", "<", "CompilerInput", ">", "finalize", "(", "URI", "remoteURI", ",", "PackageID", "moduleID", ")", "{", "try", "{", "Matcher", "matcher", "=", "semVerPatchPattern", ".", "matcher", "(", "moduleID", ".", "version", ".", "value", ")", ";", "if", "(", "\"", "\"", ".", "equals", "(", "moduleID", ".", "version", ".", "value", ")", "||", "\"", "*", "\"", ".", "equals", "(", "moduleID", ".", "version", ".", "value", ")", "||", "matcher", ".", "matches", "(", ")", ")", "{", "HttpURLConnection", "conn", ";", "if", "(", "null", "==", "this", ".", "proxy", ")", "{", "conn", "=", "(", "HttpURLConnection", ")", "remoteURI", ".", "toURL", "(", ")", ".", "openConnection", "(", ")", ";", "}", "else", "{", "conn", "=", "(", "HttpURLConnection", ")", "remoteURI", ".", "toURL", "(", ")", ".", "openConnection", "(", "this", ".", "proxy", ")", ";", "}", "conn", ".", "setInstanceFollowRedirects", "(", "false", ")", ";", "conn", ".", "setRequestMethod", "(", "\"", "GET", "\"", ")", ";", "int", "statusCode", "=", "conn", ".", "getResponseCode", "(", ")", ";", "if", "(", "statusCode", "==", "200", ")", "{", "try", "(", "BufferedReader", "reader", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "conn", ".", "getInputStream", "(", ")", ",", "Charset", ".", "defaultCharset", "(", ")", ")", ")", ")", "{", "StringBuilder", "result", "=", "new", "StringBuilder", "(", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "reader", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "result", ".", "append", "(", "line", ")", ";", "}", "Object", "payload", "=", "JSONParser", ".", "parse", "(", "result", ".", "toString", "(", ")", ")", ";", "if", "(", "payload", "instanceof", "MapValue", ")", "{", "MapValue", "moduleInfo", "=", "(", "(", "MapValue", ")", "payload", ")", ".", "getMapValue", "(", "\"", "module", "\"", ")", ";", "String", "version", "=", "moduleInfo", ".", "getStringValue", "(", "\"", "version", "\"", ")", ";", "moduleID", ".", "version", "=", "new", "Name", "(", "version", ")", ";", "}", "}", "}", "else", "if", "(", "statusCode", "==", "400", "&&", "!", "loggedError", ")", "{", "try", "(", "BufferedReader", "errorStream", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "conn", ".", "getInputStream", "(", ")", ",", "Charset", ".", "defaultCharset", "(", ")", ")", ")", ")", "{", "String", "errorContent", "=", "errorStream", ".", "lines", "(", ")", ".", "collect", "(", "Collectors", ".", "joining", "(", "\"", "\\n", "\"", ")", ")", ";", "this", ".", "errStream", ".", "println", "(", "\"", "error: could not connect to remote repository to find the latest ", "\"", "+", "\"", "version of module: ", "\"", "+", "moduleID", ".", "toString", "(", ")", "+", "\"", ". use '--offline' ", "\"", "+", "\"", "flag to build in offline mode. reason: ", "\"", "+", "errorContent", ")", ";", "setErrorLoggedStatusAsTrue", "(", ")", ";", "}", "}", "else", "if", "(", "statusCode", "==", "500", "&&", "!", "loggedError", ")", "{", "this", ".", "errStream", ".", "println", "(", "\"", "error: could not connect to remote repository to find the latest ", "\"", "+", "\"", "version of module: ", "\"", "+", "moduleID", ".", "toString", "(", ")", "+", "\"", ". use '--offline' ", "\"", "+", "\"", "flag to build in offline mode.", "\"", ")", ";", "setErrorLoggedStatusAsTrue", "(", ")", ";", "}", "conn", ".", "disconnect", "(", ")", ";", "Authenticator", ".", "setDefault", "(", "null", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "}", "return", "Stream", ".", "empty", "(", ")", ";", "}"], "idx": 41164, "cwe": "CWE-306", "target": 1, "status": "VULNERABLE", "commit": "4609ffee1744ecd16aac09303b1783bf0a525816", "function_name": "finalize", "body_hash": "404d3bff2a8f40242ab281740fff5a2431fa57dd"}
{"code": "private synchronized File initCacheDir() {\n        if (cacheDir != null) {\n            return cacheDir;\n        }\n\n        File cacheRoot = new File(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\");\n        File cacheDir = new File(cacheRoot, Version.RESOURCES_VERSION);\n\n        if (cacheRoot.isDirectory()) {\n            for (File f : cacheRoot.listFiles()) {\n                if (!f.getName().equals(Version.RESOURCES_VERSION)) {\n                    try {\n                        FileUtils.deleteDirectory(f);\n                    } catch (IOException e) {\n                        logger.warn(\"Failed to delete old gzip cache directory\", e);\n                    }\n                }\n            }\n        }\n\n        if (!cacheDir.isDirectory() && !cacheDir.mkdirs()) {\n            logger.warn(\"Failed to create gzip cache directory\");\n            return null;\n        }\n\n        return cacheDir;\n    }", "code_tokens": ["private", "synchronized", "File", "initCacheDir", "(", ")", "{", "if", "(", "cacheDir", "!=", "null", ")", "{", "return", "cacheDir", ";", "}", "File", "cacheRoot", "=", "new", "File", "(", "System", ".", "getProperty", "(", "\"", "java.io.tmpdir", "\"", ")", ",", "\"", "kc-gzip-cache", "\"", ")", ";", "File", "cacheDir", "=", "new", "File", "(", "cacheRoot", ",", "Version", ".", "RESOURCES_VERSION", ")", ";", "if", "(", "cacheRoot", ".", "isDirectory", "(", ")", ")", "{", "for", "(", "File", "f", ":", "cacheRoot", ".", "listFiles", "(", ")", ")", "{", "if", "(", "!", "f", ".", "getName", "(", ")", ".", "equals", "(", "Version", ".", "RESOURCES_VERSION", ")", ")", "{", "try", "{", "FileUtils", ".", "deleteDirectory", "(", "f", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "logger", ".", "warn", "(", "\"", "Failed to delete old gzip cache directory", "\"", ",", "e", ")", ";", "}", "}", "}", "}", "if", "(", "!", "cacheDir", ".", "isDirectory", "(", ")", "&&", "!", "cacheDir", ".", "mkdirs", "(", ")", ")", "{", "logger", ".", "warn", "(", "\"", "Failed to create gzip cache directory", "\"", ")", ";", "return", "null", ";", "}", "return", "cacheDir", ";", "}"], "idx": 49468, "cwe": "CWE-377", "target": 1, "status": "VULNERABLE", "commit": "853a6d73276849877819f2dc23133557f6e1e601", "function_name": "initCacheDir", "body_hash": "950b60e0571a52c08e3fa1a5fc987387f9c32bc3"}
{"code": "static ClassLoader getContextClassLoader() {\n        if (System.getSecurityManager() == null) {\n            return Thread.currentThread().getContextClassLoader();\n        } else {\n            return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> {\n                ClassLoader tccl = null;\n                try {\n                    tccl = Thread.currentThread().getContextClassLoader();\n                } catch (SecurityException ex) {\n                    LOG.warn(\"Unable to get context classloader instance.\", ex);\n                }\n                return tccl;\n            });\n        }\n    }", "code_tokens": ["static", "ClassLoader", "getContextClassLoader", "(", ")", "{", "if", "(", "System", ".", "getSecurityManager", "(", ")", "==", "null", ")", "{", "return", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "}", "else", "{", "return", "AccessController", ".", "doPrivileged", "(", "(", "PrivilegedAction", "<", "ClassLoader", ">", ")", "(", ")", "->", "{", "ClassLoader", "tccl", "=", "null", ";", "try", "{", "tccl", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "}", "catch", "(", "SecurityException", "ex", ")", "{", "LOG", ".", "warn", "(", "\"", "Unable to get context classloader instance.", "\"", ",", "ex", ")", ";", "}", "return", "tccl", ";", "}", ")", ";", "}", "}"], "idx": 88702, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "fb0def6f61c09a2a80c9145e4ec6521225cd0b99", "function_name": "getContextClassLoader", "body_hash": "020ad1d6ab72e2df3b5beed51a6417bfd52d6f61"}
{"code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }  \n        if (!Boolean.parseBoolean(camelContext.getGlobalOptions().get(ACCESS_EXTERNAL_DTD))) {\n            try {\n                factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            } catch (SAXException e) {\n                LOG.error(e.getMessage(), e);\n                throw new IllegalStateException(e);\n            } \n        }\n        return factory;\n    }", "code_tokens": ["protected", "SchemaFactory", "createSchemaFactory", "(", ")", "{", "SchemaFactory", "factory", "=", "SchemaFactory", ".", "newInstance", "(", "schemaLanguage", ")", ";", "if", "(", "getResourceResolver", "(", ")", "!=", "null", ")", "{", "factory", ".", "setResourceResolver", "(", "getResourceResolver", "(", ")", ")", ";", "}", "if", "(", "!", "Boolean", ".", "parseBoolean", "(", "camelContext", ".", "getGlobalOptions", "(", ")", ".", "get", "(", "ACCESS_EXTERNAL_DTD", ")", ")", ")", "{", "try", "{", "factory", ".", "setProperty", "(", "XMLConstants", ".", "ACCESS_EXTERNAL_DTD", ",", "\"", "\"", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "LOG", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}", "return", "factory", ";", "}"], "idx": 66970, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "2e8f21dec883b083ddcdddd802847b4c378a61a", "function_name": "createSchemaFactory", "body_hash": "57bd2bbb90a7e6b5cd8bf98cd95ddce775f4f64b"}
{"code": "@Override\n    protected JsonNode _at(JsonPointer ptr) {\n        // 02-Jan-2020, tatu: As per [databind#3005] must return `null` and NOT\n        //    \"missing node\"\n        return null;\n    }", "code_tokens": ["@", "Override", "protected", "JsonNode", "_at", "(", "JsonPointer", "ptr", ")", "{", "return", "null", ";", "}"], "idx": 62592, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "972db892f62d66c09d7e8056f87923859bd8086b", "function_name": "_at", "body_hash": "cc37ad06d0c541de7331e6fdf0ca336269efc67d"}
{"code": "public static String normalize(String path, boolean replaceBackSlash) {\n\n        if (path == null)\n            return null;\n\n        // Create a place for the normalized path\n        String normalized = path;\n\n        if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n            normalized = normalized.replace('\\\\', '/');\n\n        if (normalized.equals(\"/.\"))\n            return \"/\";\n\n        // Add a leading \"/\" if necessary\n        if (!normalized.startsWith(\"/\"))\n            normalized = \"/\" + normalized;\n\n        // Resolve occurrences of \"//\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"//\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                normalized.substring(index + 1);\n        }\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/./\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                normalized.substring(index + 2);\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/../\");\n            if (index < 0)\n                break;\n            if (index == 0)\n                return (null);  // Trying to go outside our context\n            int index2 = normalized.lastIndexOf('/', index - 1);\n            normalized = normalized.substring(0, index2) +\n                normalized.substring(index + 3);\n        }\n\n        // Return the normalized path that we have completed\n        return (normalized);\n    }", "code_tokens": ["public", "static", "String", "normalize", "(", "String", "path", ",", "boolean", "replaceBackSlash", ")", "{", "if", "(", "path", "==", "null", ")", "return", "null", ";", "String", "normalized", "=", "path", ";", "if", "(", "replaceBackSlash", "&&", "normalized", ".", "indexOf", "(", "'\\\\'", ")", ">=", "0", ")", "normalized", "=", "normalized", ".", "replace", "(", "'\\\\'", ",", "'/'", ")", ";", "if", "(", "normalized", ".", "equals", "(", "\"", "/.", "\"", ")", ")", "return", "\"", "/", "\"", ";", "if", "(", "!", "normalized", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "normalized", "=", "\"", "/", "\"", "+", "normalized", ";", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "//", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "break", ";", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index", ")", "+", "normalized", ".", "substring", "(", "index", "+", "1", ")", ";", "}", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "/./", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "break", ";", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index", ")", "+", "normalized", ".", "substring", "(", "index", "+", "2", ")", ";", "}", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "/../", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "break", ";", "if", "(", "index", "==", "0", ")", "return", "(", "null", ")", ";", "int", "index2", "=", "normalized", ".", "lastIndexOf", "(", "'/'", ",", "index", "-", "1", ")", ";", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index2", ")", "+", "normalized", ".", "substring", "(", "index", "+", "3", ")", ";", "}", "return", "(", "normalized", ")", ";", "}"], "idx": 23756, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "2fc9d03ffbc3fe7eabfd272380807ac0ddcf748d", "function_name": "normalize", "body_hash": "1e2dec933b8a08309e124370b1a5ece37623dca0"}
{"code": "@Override\n    public void servletSecurityAnnotationScan() throws ServletException {\n        if (getServlet() == null) {\n            Class<?> clazz = null;\n            try {\n                clazz = getParentClassLoader().loadClass(getServletClass());\n                processServletSecurityAnnotation(clazz);\n            } catch (ClassNotFoundException e) {\n                // Safe to ignore. No class means no annotations to process\n            }\n        } else {\n            if (servletSecurityAnnotationScanRequired) {\n                processServletSecurityAnnotation(getServlet().getClass());\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "servletSecurityAnnotationScan", "(", ")", "throws", "ServletException", "{", "if", "(", "getServlet", "(", ")", "==", "null", ")", "{", "Class", "<", "?", ">", "clazz", "=", "null", ";", "try", "{", "clazz", "=", "getParentClassLoader", "(", ")", ".", "loadClass", "(", "getServletClass", "(", ")", ")", ";", "processServletSecurityAnnotation", "(", "clazz", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "}", "}", "else", "{", "if", "(", "servletSecurityAnnotationScanRequired", ")", "{", "processServletSecurityAnnotation", "(", "getServlet", "(", ")", ".", "getClass", "(", ")", ")", ";", "}", "}", "}"], "idx": 31612, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "299b26af66793438c323ea6b18462fa44683080f", "function_name": "servletSecurityAnnotationScan", "body_hash": "180a1f5d25554c21547f0fee60ba652649469b6e"}
{"code": "@Override\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n\n    User delegatedUser = delegatedUserHolder.get();\n\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal != null) && (principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        // If user exists, fetch it from the userDirectory\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\n                    \"Authenticated user '{}' could not be found in any of the current UserProviders. Continuing anyway...\",\n                    userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n        }\n\n        // Add the roles (authorities) in the security context\n        Set<JaxbRole> roles = new HashSet<JaxbRole>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n        }\n\n        if (user == null) {\n          // No user was found. Create one to hold the auth information from the security context\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          // Combine the existing user with the roles in the security context\n          user = JaxbUser.fromUser(user, roles);\n        }\n\n        // Save the user to retrieve it quicker the next time(s) this method is called (by this thread)\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n    }\n\n    // Return the anonymous user by default\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }", "code_tokens": ["@", "Override", "public", "User", "getUser", "(", ")", "throws", "IllegalStateException", "{", "Organization", "org", "=", "getOrganization", "(", ")", ";", "if", "(", "org", "==", "null", ")", "throw", "new", "IllegalStateException", "(", "\"", "No organization is set in security context", "\"", ")", ";", "User", "delegatedUser", "=", "delegatedUserHolder", ".", "get", "(", ")", ";", "if", "(", "delegatedUser", "!=", "null", ")", "{", "return", "delegatedUser", ";", "}", "Authentication", "auth", "=", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "getAuthentication", "(", ")", ";", "JaxbOrganization", "jaxbOrganization", "=", "JaxbOrganization", ".", "fromOrganization", "(", "org", ")", ";", "if", "(", "auth", "!=", "null", ")", "{", "Object", "principal", "=", "auth", ".", "getPrincipal", "(", ")", ";", "if", "(", "(", "principal", "!=", "null", ")", "&&", "(", "principal", "instanceof", "UserDetails", ")", ")", "{", "UserDetails", "userDetails", "=", "(", "UserDetails", ")", "principal", ";", "User", "user", "=", "null", ";", "if", "(", "userDirectory", "!=", "null", ")", "{", "user", "=", "userDirectory", ".", "loadUser", "(", "userDetails", ".", "getUsername", "(", ")", ")", ";", "if", "(", "user", "==", "null", ")", "{", "logger", ".", "debug", "(", "\"", "Authenticated user '{}' could not be found in any of the current UserProviders. Continuing anyway...", "\"", ",", "userDetails", ".", "getUsername", "(", ")", ")", ";", "}", "}", "else", "{", "logger", ".", "debug", "(", "\"", "No UserDirectory was found when trying to search for user '{}'", "\"", ",", "userDetails", ".", "getUsername", "(", ")", ")", ";", "}", "Set", "<", "JaxbRole", ">", "roles", "=", "new", "HashSet", "<", "JaxbRole", ">", "(", ")", ";", "Collection", "<", "?", "extends", "GrantedAuthority", ">", "authorities", "=", "auth", ".", "getAuthorities", "(", ")", ";", "if", "(", "authorities", "!=", "null", ")", "{", "for", "(", "GrantedAuthority", "ga", ":", "authorities", ")", "{", "roles", ".", "add", "(", "new", "JaxbRole", "(", "ga", ".", "getAuthority", "(", ")", ",", "jaxbOrganization", ")", ")", ";", "}", "}", "if", "(", "user", "==", "null", ")", "{", "user", "=", "new", "JaxbUser", "(", "userDetails", ".", "getUsername", "(", ")", ",", "null", ",", "jaxbOrganization", ",", "roles", ")", ";", "}", "else", "{", "user", "=", "JaxbUser", ".", "fromUser", "(", "user", ",", "roles", ")", ";", "}", "delegatedUserHolder", ".", "set", "(", "user", ")", ";", "return", "user", ";", "}", "}", "return", "SecurityUtil", ".", "createAnonymousUser", "(", "jaxbOrganization", ")", ";", "}"], "idx": 38995, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "b157e1fb3b35991ca7bf59f0730329fbe7ce82e8", "function_name": "getUser", "body_hash": "f515a49c910973d4c4ddbf7dbaeeb334c95f2ecb"}
{"code": "@GetMapping(\"/callback/{serverId}\")\n    @ApiOperation(value = \"OAuth2.0\u6388\u6743\u5b8c\u6210\u540e\u56de\u8c03\", hidden = true)\n    public RedirectView callback(@RequestParam(defaultValue = \"/\") String redirect,\n                                 @PathVariable String serverId,\n                                 @RequestParam String code,\n                                 @RequestParam String state,\n                                 HttpServletRequest request,\n                                 HttpSession session) throws UnsupportedEncodingException {\n        try {\n            String cachedState = (String) session.getAttribute(STATE_SESSION_KEY);\n            if (!state.equals(cachedState)) {\n                throw new BusinessException(ErrorType.STATE_ERROR.name());\n            }\n            oAuth2RequestService.doEvent(serverId, new OAuth2CodeAuthBeforeEvent(code, state, request::getParameter));\n            return new RedirectView(URLDecoder.decode(redirect, \"UTF-8\"));\n        } finally {\n            session.removeAttribute(STATE_SESSION_KEY);\n        }\n    }", "code_tokens": ["@", "GetMapping", "(", "\"", "/callback/{serverId}", "\"", ")", "@", "ApiOperation", "(", "value", "=", "\"", "OAuth2.0\u6388\u6743\u5b8c\u6210\u540e\u56de\u8c03", "\"", ",", "hidden", "=", "true", ")", "public", "RedirectView", "callback", "(", "@", "RequestParam", "(", "defaultValue", "=", "\"", "/", "\"", ")", "String", "redirect", ",", "@", "PathVariable", "String", "serverId", ",", "@", "RequestParam", "String", "code", ",", "@", "RequestParam", "String", "state", ",", "HttpServletRequest", "request", ",", "HttpSession", "session", ")", "throws", "UnsupportedEncodingException", "{", "try", "{", "String", "cachedState", "=", "(", "String", ")", "session", ".", "getAttribute", "(", "STATE_SESSION_KEY", ")", ";", "if", "(", "!", "state", ".", "equals", "(", "cachedState", ")", ")", "{", "throw", "new", "BusinessException", "(", "ErrorType", ".", "STATE_ERROR", ".", "name", "(", ")", ")", ";", "}", "oAuth2RequestService", ".", "doEvent", "(", "serverId", ",", "new", "OAuth2CodeAuthBeforeEvent", "(", "code", ",", "state", ",", "request", "::", "getParameter", ")", ")", ";", "return", "new", "RedirectView", "(", "URLDecoder", ".", "decode", "(", "redirect", ",", "\"", "UTF-8", "\"", ")", ")", ";", "}", "finally", "{", "session", ".", "removeAttribute", "(", "STATE_SESSION_KEY", ")", ";", "}", "}"], "idx": 44793, "cwe": "CWE-352", "target": 0, "status": "FIXED", "commit": "40929e9b0d336a26281a5ed2e0e721d54dd8d2f2", "function_name": "callback", "body_hash": "feafd65faa2d83db0e8fb91e1fb9582825d404dd"}
{"code": "@Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException {\n\n        final String path = getRelativePath(req);\n\n        // Block access to special subdirectories.\n        // DefaultServlet assumes it services resources from the root of the web app\n        // and doesn't add any special path protection\n        // WebdavServlet remounts the webapp under a new path, so this check is\n        // necessary on all methods (including GET).\n        if (isSpecialPath(path)) {\n            resp.sendError(WebdavStatus.SC_NOT_FOUND);\n            return;\n        }\n\n        final String method = req.getMethod();\n\n        if (debug > 0) {\n            log(\"[\" + method + \"] \" + path);\n        }\n\n        if (method.equals(METHOD_PROPFIND)) {\n            doPropfind(req, resp);\n        } else if (method.equals(METHOD_PROPPATCH)) {\n            doProppatch(req, resp);\n        } else if (method.equals(METHOD_MKCOL)) {\n            doMkcol(req, resp);\n        } else if (method.equals(METHOD_COPY)) {\n            doCopy(req, resp);\n        } else if (method.equals(METHOD_MOVE)) {\n            doMove(req, resp);\n        } else if (method.equals(METHOD_LOCK)) {\n            doLock(req, resp);\n        } else if (method.equals(METHOD_UNLOCK)) {\n            doUnlock(req, resp);\n        } else {\n            // DefaultServlet processing\n            super.service(req, resp);\n        }\n\n    }", "code_tokens": ["@", "Override", "protected", "void", "service", "(", "HttpServletRequest", "req", ",", "HttpServletResponse", "resp", ")", "throws", "ServletException", ",", "IOException", "{", "final", "String", "path", "=", "getRelativePath", "(", "req", ")", ";", "if", "(", "isSpecialPath", "(", "path", ")", ")", "{", "resp", ".", "sendError", "(", "WebdavStatus", ".", "SC_NOT_FOUND", ")", ";", "return", ";", "}", "final", "String", "method", "=", "req", ".", "getMethod", "(", ")", ";", "if", "(", "debug", ">", "0", ")", "{", "log", "(", "\"", "[", "\"", "+", "method", "+", "\"", "] ", "\"", "+", "path", ")", ";", "}", "if", "(", "method", ".", "equals", "(", "METHOD_PROPFIND", ")", ")", "{", "doPropfind", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_PROPPATCH", ")", ")", "{", "doProppatch", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_MKCOL", ")", ")", "{", "doMkcol", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_COPY", ")", ")", "{", "doCopy", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_MOVE", ")", ")", "{", "doMove", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_LOCK", ")", ")", "{", "doLock", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_UNLOCK", ")", ")", "{", "doUnlock", "(", "req", ",", "resp", ")", ";", "}", "else", "{", "super", ".", "service", "(", "req", ",", "resp", ")", ";", "}", "}"], "idx": 74324, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "25d3c0d93190ef165ecd6c744bc15b5059abfa8f", "function_name": "service", "body_hash": "69046bc6bf039077f61c74a472266384703c6301"}
{"code": "public Object instantiate(Class type, Configuration conf, boolean fatal) {\n        Object obj = newInstance(_name, type, conf, fatal);\n        \n        // ensure plugin value is compatible with plugin type\n        if (obj != null && !type.isAssignableFrom(obj.getClass())) {\n            Log log = (conf == null) ? null : conf.getConfigurationLog();\n            String msg = getIncompatiblePluginMessage(obj, type);\n            if (log != null && log.isErrorEnabled()) {\n            \tlog.error(msg);\n            }\n            if (fatal) {\n            \tthrow new ParseException(msg);\n            }\n            return null;\n        }\n        \n        Configurations.configureInstance(obj, conf, _props,\n            (fatal) ? getProperty() : null);\n        if (_singleton)\n            set(obj, true);\n        return obj;\n    }", "code_tokens": ["public", "Object", "instantiate", "(", "Class", "type", ",", "Configuration", "conf", ",", "boolean", "fatal", ")", "{", "Object", "obj", "=", "newInstance", "(", "_name", ",", "type", ",", "conf", ",", "fatal", ")", ";", "if", "(", "obj", "!=", "null", "&&", "!", "type", ".", "isAssignableFrom", "(", "obj", ".", "getClass", "(", ")", ")", ")", "{", "Log", "log", "=", "(", "conf", "==", "null", ")", "?", "null", ":", "conf", ".", "getConfigurationLog", "(", ")", ";", "String", "msg", "=", "getIncompatiblePluginMessage", "(", "obj", ",", "type", ")", ";", "if", "(", "log", "!=", "null", "&&", "log", ".", "isErrorEnabled", "(", ")", ")", "{", "log", ".", "error", "(", "msg", ")", ";", "}", "if", "(", "fatal", ")", "{", "throw", "new", "ParseException", "(", "msg", ")", ";", "}", "return", "null", ";", "}", "Configurations", ".", "configureInstance", "(", "obj", ",", "conf", ",", "_props", ",", "(", "fatal", ")", "?", "getProperty", "(", ")", ":", "null", ")", ";", "if", "(", "_singleton", ")", "set", "(", "obj", ",", "true", ")", ";", "return", "obj", ";", "}"], "idx": 33400, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "01bc0d257b38743372af91cb88269524634db7d3", "function_name": "instantiate", "body_hash": "3cb65d57f38b5b73236fdcc0e31a3ed5fe2f572a"}
{"code": "private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && Character.isWhitespace(ch))) {\n                break;\n            }\n        }\n\n        if (nameEnd == length) {\n            // There was no colon present at all.\n            throw new IllegalArgumentException(\"No colon found\");\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }", "code_tokens": ["private", "void", "splitHeader", "(", "AppendableCharSequence", "sb", ")", "{", "final", "int", "length", "=", "sb", ".", "length", "(", ")", ";", "int", "nameStart", ";", "int", "nameEnd", ";", "int", "colonEnd", ";", "int", "valueStart", ";", "int", "valueEnd", ";", "nameStart", "=", "findNonWhitespace", "(", "sb", ",", "0", ")", ";", "for", "(", "nameEnd", "=", "nameStart", ";", "nameEnd", "<", "length", ";", "nameEnd", "++", ")", "{", "char", "ch", "=", "sb", ".", "charAtUnsafe", "(", "nameEnd", ")", ";", "if", "(", "ch", "==", "':'", "||", "(", "!", "isDecodingRequest", "(", ")", "&&", "Character", ".", "isWhitespace", "(", "ch", ")", ")", ")", "{", "break", ";", "}", "}", "if", "(", "nameEnd", "==", "length", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "No colon found", "\"", ")", ";", "}", "for", "(", "colonEnd", "=", "nameEnd", ";", "colonEnd", "<", "length", ";", "colonEnd", "++", ")", "{", "if", "(", "sb", ".", "charAtUnsafe", "(", "colonEnd", ")", "==", "':'", ")", "{", "colonEnd", "++", ";", "break", ";", "}", "}", "name", "=", "sb", ".", "subStringUnsafe", "(", "nameStart", ",", "nameEnd", ")", ";", "valueStart", "=", "findNonWhitespace", "(", "sb", ",", "colonEnd", ")", ";", "if", "(", "valueStart", "==", "length", ")", "{", "value", "=", "EMPTY_VALUE", ";", "}", "else", "{", "valueEnd", "=", "findEndOfString", "(", "sb", ")", ";", "value", "=", "sb", ".", "subStringUnsafe", "(", "valueStart", ",", "valueEnd", ")", ";", "}", "}"], "idx": 54061, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "a7c18d44b46e02dadfe3da225a06e5091f5f328e", "function_name": "splitHeader", "body_hash": "abb54d3f11700c11921efd884faa8387a8f462a6"}
{"code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }  \n        if (camelContext != null && !Boolean.parseBoolean(camelContext.getGlobalOptions().get(ACCESS_EXTERNAL_DTD))) {\n            try {\n                factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            } catch (SAXException e) {\n                LOG.error(e.getMessage(), e);\n                throw new IllegalStateException(e);\n            } \n        }\n        return factory;\n    }", "code_tokens": ["protected", "SchemaFactory", "createSchemaFactory", "(", ")", "{", "SchemaFactory", "factory", "=", "SchemaFactory", ".", "newInstance", "(", "schemaLanguage", ")", ";", "if", "(", "getResourceResolver", "(", ")", "!=", "null", ")", "{", "factory", ".", "setResourceResolver", "(", "getResourceResolver", "(", ")", ")", ";", "}", "if", "(", "camelContext", "!=", "null", "&&", "!", "Boolean", ".", "parseBoolean", "(", "camelContext", ".", "getGlobalOptions", "(", ")", ".", "get", "(", "ACCESS_EXTERNAL_DTD", ")", ")", ")", "{", "try", "{", "factory", ".", "setProperty", "(", "XMLConstants", ".", "ACCESS_EXTERNAL_DTD", ",", "\"", "\"", ")", ";", "}", "catch", "(", "SAXException", "e", ")", "{", "LOG", ".", "error", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "throw", "new", "IllegalStateException", "(", "e", ")", ";", "}", "}", "return", "factory", ";", "}"], "idx": 66971, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "2e8f21dec883b083ddcdddd802847b4c378a61a", "function_name": "createSchemaFactory", "body_hash": "2ecb44aaf347f842f2343ef49f48aa9526dc47a9"}
{"code": "public void check(String hostname, List<Certificate> peerCertificates)\n      throws SSLPeerUnverifiedException {\n    Set<ByteString> pins = findMatchingPins(hostname);\n\n    if (pins == null) return;\n\n    if (trustRootIndex != null) {\n      peerCertificates = new CertificateChainCleaner(trustRootIndex).clean(peerCertificates);\n    }\n\n    for (int i = 0, size = peerCertificates.size(); i < size; i++) {\n      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);\n      if (pins.contains(sha1(x509Certificate))) return; // Success!\n    }\n\n    // If we couldn't find a matching pin, format a nice exception.\n    StringBuilder message = new StringBuilder()\n        .append(\"Certificate pinning failure!\")\n        .append(\"\\n  Peer certificate chain:\");\n    for (int i = 0, size = peerCertificates.size(); i < size; i++) {\n      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);\n      message.append(\"\\n    \").append(pin(x509Certificate))\n          .append(\": \").append(x509Certificate.getSubjectDN().getName());\n    }\n    message.append(\"\\n  Pinned certificates for \").append(hostname).append(\":\");\n    for (ByteString pin : pins) {\n      message.append(\"\\n    sha1/\").append(pin.base64());\n    }\n    throw new SSLPeerUnverifiedException(message.toString());\n  }", "code_tokens": ["public", "void", "check", "(", "String", "hostname", ",", "List", "<", "Certificate", ">", "peerCertificates", ")", "throws", "SSLPeerUnverifiedException", "{", "Set", "<", "ByteString", ">", "pins", "=", "findMatchingPins", "(", "hostname", ")", ";", "if", "(", "pins", "==", "null", ")", "return", ";", "if", "(", "trustRootIndex", "!=", "null", ")", "{", "peerCertificates", "=", "new", "CertificateChainCleaner", "(", "trustRootIndex", ")", ".", "clean", "(", "peerCertificates", ")", ";", "}", "for", "(", "int", "i", "=", "0", ",", "size", "=", "peerCertificates", ".", "size", "(", ")", ";", "i", "<", "size", ";", "i", "++", ")", "{", "X509Certificate", "x509Certificate", "=", "(", "X509Certificate", ")", "peerCertificates", ".", "get", "(", "i", ")", ";", "if", "(", "pins", ".", "contains", "(", "sha1", "(", "x509Certificate", ")", ")", ")", "return", ";", "}", "StringBuilder", "message", "=", "new", "StringBuilder", "(", ")", ".", "append", "(", "\"", "Certificate pinning failure!", "\"", ")", ".", "append", "(", "\"", "\\n", "  Peer certificate chain:", "\"", ")", ";", "for", "(", "int", "i", "=", "0", ",", "size", "=", "peerCertificates", ".", "size", "(", ")", ";", "i", "<", "size", ";", "i", "++", ")", "{", "X509Certificate", "x509Certificate", "=", "(", "X509Certificate", ")", "peerCertificates", ".", "get", "(", "i", ")", ";", "message", ".", "append", "(", "\"", "\\n", "    ", "\"", ")", ".", "append", "(", "pin", "(", "x509Certificate", ")", ")", ".", "append", "(", "\"", ": ", "\"", ")", ".", "append", "(", "x509Certificate", ".", "getSubjectDN", "(", ")", ".", "getName", "(", ")", ")", ";", "}", "message", ".", "append", "(", "\"", "\\n", "  Pinned certificates for ", "\"", ")", ".", "append", "(", "hostname", ")", ".", "append", "(", "\"", ":", "\"", ")", ";", "for", "(", "ByteString", "pin", ":", "pins", ")", "{", "message", ".", "append", "(", "\"", "\\n", "    sha1/", "\"", ")", ".", "append", "(", "pin", ".", "base64", "(", ")", ")", ";", "}", "throw", "new", "SSLPeerUnverifiedException", "(", "message", ".", "toString", "(", ")", ")", ";", "}"], "idx": 40162, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "3ccb46dd16b6ec98f70b0ee53eafe5ed6380891e", "function_name": "check", "body_hash": "30806c1d2b449ee5620eb5d2a13f02796c9c1347"}
{"code": "protected void configureParser(final XMLReader parser, final SAXHandler contentHandler)\n\t\t\tthrows JDOMException {\n\n\t\t// Setup SAX handlers.\n\n\t\tparser.setContentHandler(contentHandler);\n\n\t\tif (saxEntityResolver != null) {\n\t\t\tparser.setEntityResolver(saxEntityResolver);\n\t\t}\n\n\t\tif (saxDTDHandler != null) {\n\t\t\tparser.setDTDHandler(saxDTDHandler);\n\t\t} else {\n\t\t\tparser.setDTDHandler(contentHandler);\n\t\t}\n\n\t\tif (saxErrorHandler != null) {\n\t\t\tparser.setErrorHandler(saxErrorHandler);\n\t\t} else {\n\t\t\tparser.setErrorHandler(new BuilderErrorHandler());\n\t\t}\n\n\t\tboolean success = false;\n\n\t\ttry {\n\t\t\tparser.setProperty(SAX_PROPERTY_LEXICAL_HANDLER,\n\t\t\t\t\tcontentHandler);\n\t\t\tsuccess = true;\n\t\t} catch (final SAXNotSupportedException e) {\n\t\t\t// No lexical reporting available\n\t\t} catch (final SAXNotRecognizedException e) {\n\t\t\t// No lexical reporting available\n\t\t}\n\n\t\t// Some parsers use alternate property for lexical handling (grr...)\n\t\tif (!success) {\n\t\t\ttry {\n\t\t\t\tparser.setProperty(SAX_PROPERTY_LEXICAL_HANDLER_ALT,\n\t\t\t\t\t\tcontentHandler);\n\t\t\t\tsuccess = true;\n\t\t\t} catch (final SAXNotSupportedException e) {\n\t\t\t\t// No lexical reporting available\n\t\t\t} catch (final SAXNotRecognizedException e) {\n\t\t\t\t// No lexical reporting available\n\t\t\t}\n\t\t}\n\n\t\t// Set any user-specified features on the parser.\n\t\tfor (final Map.Entry<String, Boolean> me : features.entrySet()) {\n\t\t\tinternalSetFeature(parser, me.getKey(), me.getValue().booleanValue(), me.getKey());\n\t\t}\n\n\t\t// Set any user-specified properties on the parser.\n\t\tfor (final Map.Entry<String, Object> me : properties.entrySet()) {\n\t\t\tinternalSetProperty(parser, me.getKey(), me.getValue(), me.getKey());\n\t\t}\n\n\t\t// Set entity expansion\n\t\t// Note SAXHandler can work regardless of how this is set, but when\n\t\t// entity expansion it's worth it to try to tell the parser not to\n\t\t// even bother with external general entities.\n\t\t// Apparently no parsers yet support this feature.\n\t\t// XXX It might make sense to setEntityResolver() with a resolver\n\t\t// that simply ignores external general entities\n\t\ttry {\n\t\t\tif (parser.getFeature(SAX_FEATURE_EXTERNAL_ENT) != expand) {\n\t\t\t\tparser.setFeature(SAX_FEATURE_EXTERNAL_ENT, expand);\n\t\t\t}\n\t\t} catch (final SAXException e) { /* Ignore... */\n\t\t}\n\n\t\t// Try setting the DeclHandler if entity expansion is off\n\t\tif (!expand) {\n\t\t\ttry {\n\t\t\t\tparser.setProperty(SAX_PROPERTY_DECLARATION_HANDLER,\n\t\t\t\t\t\tcontentHandler);\n\t\t\t\tsuccess = true;\n\t\t\t} catch (final SAXNotSupportedException e) {\n\t\t\t\t// No lexical reporting available\n\t\t\t} catch (final SAXNotRecognizedException e) {\n\t\t\t\t// No lexical reporting available\n\t\t\t}\n\t\t}\n\n\t}", "code_tokens": ["protected", "void", "configureParser", "(", "final", "XMLReader", "parser", ",", "final", "SAXHandler", "contentHandler", ")", "throws", "JDOMException", "{", "parser", ".", "setContentHandler", "(", "contentHandler", ")", ";", "if", "(", "saxEntityResolver", "!=", "null", ")", "{", "parser", ".", "setEntityResolver", "(", "saxEntityResolver", ")", ";", "}", "if", "(", "saxDTDHandler", "!=", "null", ")", "{", "parser", ".", "setDTDHandler", "(", "saxDTDHandler", ")", ";", "}", "else", "{", "parser", ".", "setDTDHandler", "(", "contentHandler", ")", ";", "}", "if", "(", "saxErrorHandler", "!=", "null", ")", "{", "parser", ".", "setErrorHandler", "(", "saxErrorHandler", ")", ";", "}", "else", "{", "parser", ".", "setErrorHandler", "(", "new", "BuilderErrorHandler", "(", ")", ")", ";", "}", "boolean", "success", "=", "false", ";", "try", "{", "parser", ".", "setProperty", "(", "SAX_PROPERTY_LEXICAL_HANDLER", ",", "contentHandler", ")", ";", "success", "=", "true", ";", "}", "catch", "(", "final", "SAXNotSupportedException", "e", ")", "{", "}", "catch", "(", "final", "SAXNotRecognizedException", "e", ")", "{", "}", "if", "(", "!", "success", ")", "{", "try", "{", "parser", ".", "setProperty", "(", "SAX_PROPERTY_LEXICAL_HANDLER_ALT", ",", "contentHandler", ")", ";", "success", "=", "true", ";", "}", "catch", "(", "final", "SAXNotSupportedException", "e", ")", "{", "}", "catch", "(", "final", "SAXNotRecognizedException", "e", ")", "{", "}", "}", "for", "(", "final", "Map", ".", "Entry", "<", "String", ",", "Boolean", ">", "me", ":", "features", ".", "entrySet", "(", ")", ")", "{", "internalSetFeature", "(", "parser", ",", "me", ".", "getKey", "(", ")", ",", "me", ".", "getValue", "(", ")", ".", "booleanValue", "(", ")", ",", "me", ".", "getKey", "(", ")", ")", ";", "}", "for", "(", "final", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "me", ":", "properties", ".", "entrySet", "(", ")", ")", "{", "internalSetProperty", "(", "parser", ",", "me", ".", "getKey", "(", ")", ",", "me", ".", "getValue", "(", ")", ",", "me", ".", "getKey", "(", ")", ")", ";", "}", "try", "{", "if", "(", "parser", ".", "getFeature", "(", "SAX_FEATURE_EXTERNAL_ENT", ")", "!=", "expand", ")", "{", "parser", ".", "setFeature", "(", "SAX_FEATURE_EXTERNAL_ENT", ",", "expand", ")", ";", "}", "}", "catch", "(", "final", "SAXException", "e", ")", "{", "}", "if", "(", "!", "expand", ")", "{", "try", "{", "parser", ".", "setProperty", "(", "SAX_PROPERTY_DECLARATION_HANDLER", ",", "contentHandler", ")", ";", "success", "=", "true", ";", "}", "catch", "(", "final", "SAXNotSupportedException", "e", ")", "{", "}", "catch", "(", "final", "SAXNotRecognizedException", "e", ")", "{", "}", "}", "}"], "idx": 67327, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "bd3ab78370098491911d7fe9d7a43b97144a234e", "function_name": "configureParser", "body_hash": "355326a7efb7470d455f1e714d4c220252b4a621"}
{"code": "protected String cleanupActionName(final String rawActionName) {\n        if (rawActionName.matches(allowedActionNames)) {\n            return rawActionName;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Action [#0] do not match allowed action names pattern [#1], cleaning it up!\",\n                        rawActionName, allowedActionNames);\n            }\n            String cleanActionName = rawActionName;\n            for(String chunk : rawActionName.split(allowedActionNames)) {\n                cleanActionName = cleanActionName.replace(chunk, \"\");\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Cleaned action name [#0]\", cleanActionName);\n            }\n            return cleanActionName;\n        }\n    }", "code_tokens": ["protected", "String", "cleanupActionName", "(", "final", "String", "rawActionName", ")", "{", "if", "(", "rawActionName", ".", "matches", "(", "allowedActionNames", ")", ")", "{", "return", "rawActionName", ";", "}", "else", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Action [#0] do not match allowed action names pattern [#1], cleaning it up!", "\"", ",", "rawActionName", ",", "allowedActionNames", ")", ";", "}", "String", "cleanActionName", "=", "rawActionName", ";", "for", "(", "String", "chunk", ":", "rawActionName", ".", "split", "(", "allowedActionNames", ")", ")", "{", "cleanActionName", "=", "cleanActionName", ".", "replace", "(", "chunk", ",", "\"", "\"", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "Cleaned action name [#0]", "\"", ",", "cleanActionName", ")", ";", "}", "return", "cleanActionName", ";", "}", "}"], "idx": 95050, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "8b4fc81daeea3834bcbf73de5f48d0021917aa3", "function_name": "cleanupActionName", "body_hash": "6e113b89349654fc82fa42be96049a98decdb9e9"}
{"code": "@Override\n    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName)\n            throws InvocationTargetException {\n        try {\n            SecureDigester digester = new SecureDigester(LintParser.class);\n\n            List<LintIssue> issues = new ArrayList<LintIssue>();\n            digester.push(issues);\n\n            String issueXPath = \"issues/issue\";\n            digester.addObjectCreate(issueXPath, LintIssue.class);\n            digester.addSetProperties(issueXPath);\n            digester.addSetNext(issueXPath, \"add\");\n\n            String locationXPath = issueXPath + \"/location\";\n            digester.addObjectCreate(locationXPath, Location.class);\n            digester.addSetProperties(locationXPath);\n            digester.addSetNext(locationXPath, \"addLocation\", Location.class.getName());\n\n            digester.parse(file);\n\n            return convert(issues, moduleName);\n        } catch (IOException | SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }", "code_tokens": ["@", "Override", "public", "Collection", "<", "FileAnnotation", ">", "parse", "(", "final", "InputStream", "file", ",", "final", "String", "moduleName", ")", "throws", "InvocationTargetException", "{", "try", "{", "SecureDigester", "digester", "=", "new", "SecureDigester", "(", "LintParser", ".", "class", ")", ";", "List", "<", "LintIssue", ">", "issues", "=", "new", "ArrayList", "<", "LintIssue", ">", "(", ")", ";", "digester", ".", "push", "(", "issues", ")", ";", "String", "issueXPath", "=", "\"", "issues/issue", "\"", ";", "digester", ".", "addObjectCreate", "(", "issueXPath", ",", "LintIssue", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "issueXPath", ")", ";", "digester", ".", "addSetNext", "(", "issueXPath", ",", "\"", "add", "\"", ")", ";", "String", "locationXPath", "=", "issueXPath", "+", "\"", "/location", "\"", ";", "digester", ".", "addObjectCreate", "(", "locationXPath", ",", "Location", ".", "class", ")", ";", "digester", ".", "addSetProperties", "(", "locationXPath", ")", ";", "digester", ".", "addSetNext", "(", "locationXPath", ",", "\"", "addLocation", "\"", ",", "Location", ".", "class", ".", "getName", "(", ")", ")", ";", "digester", ".", "parse", "(", "file", ")", ";", "return", "convert", "(", "issues", ",", "moduleName", ")", ";", "}", "catch", "(", "IOException", "|", "SAXException", "exception", ")", "{", "throw", "new", "InvocationTargetException", "(", "exception", ")", ";", "}", "}"], "idx": 69584, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "4a19f962ebde3f705880b0e8148731d8dac9db2d", "function_name": "parse", "body_hash": "df2795236a4cbcd2276be16f5e26657eaa7f14ea"}
{"code": "public Socket connectSocket(\n            final Socket socket,\n            final InetSocketAddress remoteAddress,\n            final InetSocketAddress localAddress,\n            final HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        Args.notNull(remoteAddress, \"Remote address\");\n        Args.notNull(params, \"HTTP parameters\");\n        final HttpHost host;\n        if (remoteAddress instanceof HttpInetSocketAddress) {\n            host = ((HttpInetSocketAddress) remoteAddress).getHttpHost();\n        } else {\n            host = new HttpHost(remoteAddress.getHostName(), remoteAddress.getPort(), \"https\");\n        }\n        final int connectTimeout = HttpConnectionParams.getConnectionTimeout(params);\n        return connectSocket(connectTimeout, socket, host, remoteAddress, localAddress, null);\n    }", "code_tokens": ["public", "Socket", "connectSocket", "(", "final", "Socket", "socket", ",", "final", "InetSocketAddress", "remoteAddress", ",", "final", "InetSocketAddress", "localAddress", ",", "final", "HttpParams", "params", ")", "throws", "IOException", ",", "UnknownHostException", ",", "ConnectTimeoutException", "{", "Args", ".", "notNull", "(", "remoteAddress", ",", "\"", "Remote address", "\"", ")", ";", "Args", ".", "notNull", "(", "params", ",", "\"", "HTTP parameters", "\"", ")", ";", "final", "HttpHost", "host", ";", "if", "(", "remoteAddress", "instanceof", "HttpInetSocketAddress", ")", "{", "host", "=", "(", "(", "HttpInetSocketAddress", ")", "remoteAddress", ")", ".", "getHttpHost", "(", ")", ";", "}", "else", "{", "host", "=", "new", "HttpHost", "(", "remoteAddress", ".", "getHostName", "(", ")", ",", "remoteAddress", ".", "getPort", "(", ")", ",", "\"", "https", "\"", ")", ";", "}", "final", "int", "connectTimeout", "=", "HttpConnectionParams", ".", "getConnectionTimeout", "(", "params", ")", ";", "return", "connectSocket", "(", "connectTimeout", ",", "socket", ",", "host", ",", "remoteAddress", ",", "localAddress", ",", "null", ")", ";", "}"], "idx": 51174, "cwe": "CWE-399", "target": 1, "status": "VULNERABLE", "commit": "09027e7286974bf6b61f4106395da2623121db8d", "function_name": "connectSocket", "body_hash": "bd64d234f958c3740206bc5e1cc517245fd63b1c"}
{"code": "@Test(description = \"Test pullCount of a package from central\", dependsOnMethods = \"testPull\", enabled = false)\n    public void testPullCount() throws IOException {\n        String url = RepoUtils.getRemoteRepoURL() + \"/modules/info/\" + orgName + \"/\" + moduleName + \"/*/\";\n        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), \"\", 0, \"\", \"\");\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.GET);\n\n        int statusCode = conn.getResponseCode();\n        if (statusCode == 200) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                    Charset.defaultCharset()))) {\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                Object payload = JSONParser.parse(result.toString());\n                if (payload instanceof MapValue) {\n                    long pullCount = ((MapValue) payload).getIntValue(\"totalPullCount\");\n                    Assert.assertEquals(pullCount, totalPullCount);\n                } else {\n                    Assert.fail(\"error: invalid response received\");\n                }\n            }\n        } else {\n            Assert.fail(\"error: could not connect to remote repository to find the latest version of module\");\n        }\n    }", "code_tokens": ["@", "Test", "(", "description", "=", "\"", "Test pullCount of a package from central", "\"", ",", "dependsOnMethods", "=", "\"", "testPull", "\"", ",", "enabled", "=", "false", ")", "public", "void", "testPullCount", "(", ")", "throws", "IOException", "{", "String", "url", "=", "RepoUtils", ".", "getRemoteRepoURL", "(", ")", "+", "\"", "/modules/info/", "\"", "+", "orgName", "+", "\"", "/", "\"", "+", "moduleName", "+", "\"", "/*/", "\"", ";", "HttpsURLConnection", "conn", "=", "createHttpsUrlConnection", "(", "convertToUrl", "(", "url", ")", ",", "\"", "\"", ",", "0", ",", "\"", "\"", ",", "\"", "\"", ")", ";", "conn", ".", "setInstanceFollowRedirects", "(", "false", ")", ";", "setRequestMethod", "(", "conn", ",", "Utils", ".", "RequestMethod", ".", "GET", ")", ";", "int", "statusCode", "=", "conn", ".", "getResponseCode", "(", ")", ";", "if", "(", "statusCode", "==", "200", ")", "{", "try", "(", "BufferedReader", "reader", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "conn", ".", "getInputStream", "(", ")", ",", "Charset", ".", "defaultCharset", "(", ")", ")", ")", ")", "{", "StringBuilder", "result", "=", "new", "StringBuilder", "(", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "reader", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "result", ".", "append", "(", "line", ")", ";", "}", "Object", "payload", "=", "JSONParser", ".", "parse", "(", "result", ".", "toString", "(", ")", ")", ";", "if", "(", "payload", "instanceof", "MapValue", ")", "{", "long", "pullCount", "=", "(", "(", "MapValue", ")", "payload", ")", ".", "getIntValue", "(", "\"", "totalPullCount", "\"", ")", ";", "Assert", ".", "assertEquals", "(", "pullCount", ",", "totalPullCount", ")", ";", "}", "else", "{", "Assert", ".", "fail", "(", "\"", "error: invalid response received", "\"", ")", ";", "}", "}", "}", "else", "{", "Assert", ".", "fail", "(", "\"", "error: could not connect to remote repository to find the latest version of module", "\"", ")", ";", "}", "}"], "idx": 41224, "cwe": "CWE-306", "target": 0, "status": "FIXED", "commit": "4609ffee1744ecd16aac09303b1783bf0a525816", "function_name": "testPullCount", "body_hash": "c4a75152058a8da0360b527270b61b02d8241add"}
{"code": "protected String cleanupActionName(final String rawActionName) {\n        if (rawActionName.matches(allowedActionNames)) {\n            return rawActionName;\n        } else {\n            String cleanActionName = rawActionName;\n            for(String chunk : rawActionName.split(allowedActionNames)) {\n                cleanActionName = cleanActionName.replace(chunk, \"\");\n            }\n            return cleanActionName;\n        }\n    }", "code_tokens": ["protected", "String", "cleanupActionName", "(", "final", "String", "rawActionName", ")", "{", "if", "(", "rawActionName", ".", "matches", "(", "allowedActionNames", ")", ")", "{", "return", "rawActionName", ";", "}", "else", "{", "String", "cleanActionName", "=", "rawActionName", ";", "for", "(", "String", "chunk", ":", "rawActionName", ".", "split", "(", "allowedActionNames", ")", ")", "{", "cleanActionName", "=", "cleanActionName", ".", "replace", "(", "chunk", ",", "\"", "\"", ")", ";", "}", "return", "cleanActionName", ";", "}", "}"], "idx": 95049, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "8b4fc81daeea3834bcbf73de5f48d0021917aa3", "function_name": "cleanupActionName", "body_hash": "b7721d48314965b70c42cfac3e6c519c754936e8"}
{"code": "public Object instantiate(Class type, Configuration conf, boolean fatal) {\n        Object obj = newInstance(_name, type, conf, fatal);\n        Configurations.configureInstance(obj, conf, _props,\n            (fatal) ? getProperty() : null);\n        if (_singleton)\n            set(obj, true);\n        return obj;\n    }", "code_tokens": ["public", "Object", "instantiate", "(", "Class", "type", ",", "Configuration", "conf", ",", "boolean", "fatal", ")", "{", "Object", "obj", "=", "newInstance", "(", "_name", ",", "type", ",", "conf", ",", "fatal", ")", ";", "Configurations", ".", "configureInstance", "(", "obj", ",", "conf", ",", "_props", ",", "(", "fatal", ")", "?", "getProperty", "(", ")", ":", "null", ")", ";", "if", "(", "_singleton", ")", "set", "(", "obj", ",", "true", ")", ";", "return", "obj", ";", "}"], "idx": 33399, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "01bc0d257b38743372af91cb88269524634db7d3", "function_name": "instantiate", "body_hash": "7a6f33ccba88cf23012d01bb518e25bdb29f66cc"}
{"code": "protected void scanPI() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanPI: \");\n            }\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1008\", null);\n            }\n\n            // scan processing instruction\n            String target = scanName(true);\n            if (target != null && !target.equalsIgnoreCase(\"xml\")) {\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    if (c == -1) {\n                        break;\n                    }\n                    if (c != ' ' && c != '\\t') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                fStringBuffer.clear();\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '?' || c == '/') {\n                        char c0 = (char)c;\n                        c = fCurrentEntity.read();\n                        if (c == '>') {\n                            break;\n                        }\n                        fStringBuffer.append(c0);\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        fStringBuffer.append('\\n');\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    else if (c == -1) {\n                        break;\n                    }\n                    else {\n                        appendChar(fStringBuffer, c);\n                    }\n                }\n                XMLString data = fStringBuffer;\n                if (fDocumentHandler != null) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.processingInstruction(target, data, locationAugs());\n                }\n            }\n\n            // scan xml/text declaration\n            else {\n                int beginLineNumber = fBeginLineNumber;\n                int beginColumnNumber = fBeginColumnNumber;\n                int beginCharacterOffset = fBeginCharacterOffset;\n                fAttributes.removeAllAttributes();\n                int aindex = 0;\n                while (scanPseudoAttribute(fAttributes)) {\n                \t// if we haven't scanned a value, remove the entry as values have special signification\n                \tif (fAttributes.getValue(aindex).length() == 0) {\n                \t\tfAttributes.removeAttributeAt(aindex); \n                \t}\n                \telse {\n\t                    fAttributes.getName(aindex,fQName);\n\t                    fQName.rawname = fQName.rawname.toLowerCase();\n\t                    fAttributes.setName(aindex,fQName);\n\t                    aindex++;\n                \t}\n                }\n                if (fDocumentHandler != null) {\n                    String version = fAttributes.getValue(\"version\");\n                    String encoding = fAttributes.getValue(\"encoding\");\n                    String standalone = fAttributes.getValue(\"standalone\");\n\n                    // if the encoding is successfully changed, the stream will be processed again\n                    // with the right encoding an we will come here again but without need to change the encoding\n                    final boolean xmlDeclNow = fIgnoreSpecifiedCharset || !changeEncoding(encoding);\n                    if (xmlDeclNow) {\n\t                    fBeginLineNumber = beginLineNumber;\n\t                    fBeginColumnNumber = beginColumnNumber;\n\t                    fBeginCharacterOffset = beginCharacterOffset;\n\t                    fEndLineNumber = fCurrentEntity.getLineNumber();\n\t                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n\t                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n\t                    fDocumentHandler.xmlDecl(version, encoding, standalone,\n\t                                             locationAugs());\n                    }\n                }\n            }\n\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanPI: \");\n            }\n        }", "code_tokens": ["protected", "void", "scanPI", "(", ")", "throws", "IOException", "{", "if", "(", "DEBUG_BUFFER", ")", "{", "fCurrentEntity", ".", "debugBufferIfNeeded", "(", "\"", "(scanPI: ", "\"", ")", ";", "}", "if", "(", "fReportErrors", ")", "{", "fErrorReporter", ".", "reportWarning", "(", "\"", "HTML1008", "\"", ",", "null", ")", ";", "}", "String", "target", "=", "scanName", "(", "true", ")", ";", "if", "(", "target", "!=", "null", "&&", "!", "target", ".", "equalsIgnoreCase", "(", "\"", "xml", "\"", ")", ")", "{", "while", "(", "true", ")", "{", "int", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "==", "'\\r'", "||", "c", "==", "'\\n'", ")", "{", "if", "(", "c", "==", "'\\r'", ")", "{", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "!=", "'\\n'", ")", "{", "fCurrentEntity", ".", "offset", "--", ";", "fCurrentEntity", ".", "characterOffset_", "--", ";", "}", "}", "fCurrentEntity", ".", "incLine", "(", ")", ";", "continue", ";", "}", "if", "(", "c", "==", "-", "1", ")", "{", "break", ";", "}", "if", "(", "c", "!=", "' '", "&&", "c", "!=", "'\\t'", ")", "{", "fCurrentEntity", ".", "rewind", "(", ")", ";", "break", ";", "}", "}", "fStringBuffer", ".", "clear", "(", ")", ";", "while", "(", "true", ")", "{", "int", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "==", "'?'", "||", "c", "==", "'/'", ")", "{", "char", "c0", "=", "(", "char", ")", "c", ";", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "==", "'>'", ")", "{", "break", ";", "}", "fStringBuffer", ".", "append", "(", "c0", ")", ";", "fCurrentEntity", ".", "rewind", "(", ")", ";", "continue", ";", "}", "else", "if", "(", "c", "==", "'\\r'", "||", "c", "==", "'\\n'", ")", "{", "fStringBuffer", ".", "append", "(", "'\\n'", ")", ";", "if", "(", "c", "==", "'\\r'", ")", "{", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "!=", "'\\n'", ")", "{", "fCurrentEntity", ".", "offset", "--", ";", "fCurrentEntity", ".", "characterOffset_", "--", ";", "}", "}", "fCurrentEntity", ".", "incLine", "(", ")", ";", "continue", ";", "}", "else", "if", "(", "c", "==", "-", "1", ")", "{", "break", ";", "}", "else", "{", "appendChar", "(", "fStringBuffer", ",", "c", ")", ";", "}", "}", "XMLString", "data", "=", "fStringBuffer", ";", "if", "(", "fDocumentHandler", "!=", "null", ")", "{", "fEndLineNumber", "=", "fCurrentEntity", ".", "getLineNumber", "(", ")", ";", "fEndColumnNumber", "=", "fCurrentEntity", ".", "getColumnNumber", "(", ")", ";", "fEndCharacterOffset", "=", "fCurrentEntity", ".", "getCharacterOffset", "(", ")", ";", "fDocumentHandler", ".", "processingInstruction", "(", "target", ",", "data", ",", "locationAugs", "(", ")", ")", ";", "}", "}", "else", "{", "int", "beginLineNumber", "=", "fBeginLineNumber", ";", "int", "beginColumnNumber", "=", "fBeginColumnNumber", ";", "int", "beginCharacterOffset", "=", "fBeginCharacterOffset", ";", "fAttributes", ".", "removeAllAttributes", "(", ")", ";", "int", "aindex", "=", "0", ";", "while", "(", "scanPseudoAttribute", "(", "fAttributes", ")", ")", "{", "if", "(", "fAttributes", ".", "getValue", "(", "aindex", ")", ".", "length", "(", ")", "==", "0", ")", "{", "fAttributes", ".", "removeAttributeAt", "(", "aindex", ")", ";", "}", "else", "{", "fAttributes", ".", "getName", "(", "aindex", ",", "fQName", ")", ";", "fQName", ".", "rawname", "=", "fQName", ".", "rawname", ".", "toLowerCase", "(", ")", ";", "fAttributes", ".", "setName", "(", "aindex", ",", "fQName", ")", ";", "aindex", "++", ";", "}", "}", "if", "(", "fDocumentHandler", "!=", "null", ")", "{", "String", "version", "=", "fAttributes", ".", "getValue", "(", "\"", "version", "\"", ")", ";", "String", "encoding", "=", "fAttributes", ".", "getValue", "(", "\"", "encoding", "\"", ")", ";", "String", "standalone", "=", "fAttributes", ".", "getValue", "(", "\"", "standalone", "\"", ")", ";", "final", "boolean", "xmlDeclNow", "=", "fIgnoreSpecifiedCharset", "||", "!", "changeEncoding", "(", "encoding", ")", ";", "if", "(", "xmlDeclNow", ")", "{", "fBeginLineNumber", "=", "beginLineNumber", ";", "fBeginColumnNumber", "=", "beginColumnNumber", ";", "fBeginCharacterOffset", "=", "beginCharacterOffset", ";", "fEndLineNumber", "=", "fCurrentEntity", ".", "getLineNumber", "(", ")", ";", "fEndColumnNumber", "=", "fCurrentEntity", ".", "getColumnNumber", "(", ")", ";", "fEndCharacterOffset", "=", "fCurrentEntity", ".", "getCharacterOffset", "(", ")", ";", "fDocumentHandler", ".", "xmlDecl", "(", "version", ",", "encoding", ",", "standalone", ",", "locationAugs", "(", ")", ")", ";", "}", "}", "}", "if", "(", "DEBUG_BUFFER", ")", "{", "fCurrentEntity", ".", "debugBufferIfNeeded", "(", "\"", ")scanPI: ", "\"", ")", ";", "}", "}"], "idx": 52762, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "a800fce3b079def130ed42a408ff1d09f89e773d", "function_name": "scanPI", "body_hash": "ac84c0742d616836039edcf8c48ffb13442931ed"}
{"code": "public void performTest()\n        throws Exception\n    {\n        byte[]  testIv = { 1, 2, 3, 4, 5, 6, 7, 8 };\n        \n        ASN1Encodable[]     values = {\n            new CAST5CBCParameters(testIv, 128), \n            new NetscapeCertType(NetscapeCertType.smime),    \n            new VerisignCzagExtension(new DERIA5String(\"hello\")),\n            new IDEACBCPar(testIv),        \n            new NetscapeRevocationURL(new DERIA5String(\"http://test\"))\n        };\n        \n        byte[] data = Base64.decode(\"MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA==\");\n\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ASN1OutputStream aOut = new ASN1OutputStream(bOut);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            aOut.writeObject(values[i]);\n        }\n\n        ASN1Primitive[] readValues = new ASN1Primitive[values.length];\n\n        if (!isSameAs(bOut.toByteArray(), data))\n        {\n            fail(\"Failed data check\");\n        }\n\n        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());\n        ASN1InputStream aIn = new ASN1InputStream(bIn);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            ASN1Primitive o = aIn.readObject();\n            if (!values[i].equals(o))\n            {\n                fail(\"Failed equality test for \" + o);\n            }\n\n            if (o.hashCode() != values[i].hashCode())\n            {\n                fail(\"Failed hashCode test for \" + o);\n            }\n        }\n\n        shouldFailOnExtraData();\n    }", "code_tokens": ["public", "void", "performTest", "(", ")", "throws", "Exception", "{", "byte", "[", "]", "testIv", "=", "{", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "}", ";", "ASN1Encodable", "[", "]", "values", "=", "{", "new", "CAST5CBCParameters", "(", "testIv", ",", "128", ")", ",", "new", "NetscapeCertType", "(", "NetscapeCertType", ".", "smime", ")", ",", "new", "VerisignCzagExtension", "(", "new", "DERIA5String", "(", "\"", "hello", "\"", ")", ")", ",", "new", "IDEACBCPar", "(", "testIv", ")", ",", "new", "NetscapeRevocationURL", "(", "new", "DERIA5String", "(", "\"", "http://test", "\"", ")", ")", "}", ";", "byte", "[", "]", "data", "=", "Base64", ".", "decode", "(", "\"", "MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA==", "\"", ")", ";", "ByteArrayOutputStream", "bOut", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "ASN1OutputStream", "aOut", "=", "new", "ASN1OutputStream", "(", "bOut", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "values", ".", "length", ";", "i", "++", ")", "{", "aOut", ".", "writeObject", "(", "values", "[", "i", "]", ")", ";", "}", "ASN1Primitive", "[", "]", "readValues", "=", "new", "ASN1Primitive", "[", "values", ".", "length", "]", ";", "if", "(", "!", "isSameAs", "(", "bOut", ".", "toByteArray", "(", ")", ",", "data", ")", ")", "{", "fail", "(", "\"", "Failed data check", "\"", ")", ";", "}", "ByteArrayInputStream", "bIn", "=", "new", "ByteArrayInputStream", "(", "bOut", ".", "toByteArray", "(", ")", ")", ";", "ASN1InputStream", "aIn", "=", "new", "ASN1InputStream", "(", "bIn", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "values", ".", "length", ";", "i", "++", ")", "{", "ASN1Primitive", "o", "=", "aIn", ".", "readObject", "(", ")", ";", "if", "(", "!", "values", "[", "i", "]", ".", "equals", "(", "o", ")", ")", "{", "fail", "(", "\"", "Failed equality test for ", "\"", "+", "o", ")", ";", "}", "if", "(", "o", ".", "hashCode", "(", ")", "!=", "values", "[", "i", "]", ".", "hashCode", "(", ")", ")", "{", "fail", "(", "\"", "Failed hashCode test for ", "\"", "+", "o", ")", ";", "}", "}", "shouldFailOnExtraData", "(", ")", ";", "}"], "idx": 43473, "cwe": "CWE-347", "target": 1, "status": "VULNERABLE", "commit": "843c2e60f67d71faf81d236f448ebbe56c62c647", "function_name": "performTest", "body_hash": "ba39d67b803c5cf180431bac22f57ad8975ee740"}
{"code": "private synchronized File initCacheDir() {\n        if (cacheDir != null) {\n            return cacheDir;\n        }\n\n        File cacheRoot = new File(Platform.getPlatform().getTmpDirectory(), \"kc-gzip-cache\");\n        File cacheDir = new File(cacheRoot, Version.RESOURCES_VERSION);\n\n        if (cacheRoot.isDirectory()) {\n            for (File f : cacheRoot.listFiles()) {\n                if (!f.getName().equals(Version.RESOURCES_VERSION)) {\n                    try {\n                        FileUtils.deleteDirectory(f);\n                    } catch (IOException e) {\n                        logger.warn(\"Failed to delete old gzip cache directory\", e);\n                    }\n                }\n            }\n        }\n\n        if (!cacheDir.isDirectory() && !cacheDir.mkdirs()) {\n            logger.warn(\"Failed to create gzip cache directory\");\n            return null;\n        }\n\n        return cacheDir;\n    }", "code_tokens": ["private", "synchronized", "File", "initCacheDir", "(", ")", "{", "if", "(", "cacheDir", "!=", "null", ")", "{", "return", "cacheDir", ";", "}", "File", "cacheRoot", "=", "new", "File", "(", "Platform", ".", "getPlatform", "(", ")", ".", "getTmpDirectory", "(", ")", ",", "\"", "kc-gzip-cache", "\"", ")", ";", "File", "cacheDir", "=", "new", "File", "(", "cacheRoot", ",", "Version", ".", "RESOURCES_VERSION", ")", ";", "if", "(", "cacheRoot", ".", "isDirectory", "(", ")", ")", "{", "for", "(", "File", "f", ":", "cacheRoot", ".", "listFiles", "(", ")", ")", "{", "if", "(", "!", "f", ".", "getName", "(", ")", ".", "equals", "(", "Version", ".", "RESOURCES_VERSION", ")", ")", "{", "try", "{", "FileUtils", ".", "deleteDirectory", "(", "f", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "logger", ".", "warn", "(", "\"", "Failed to delete old gzip cache directory", "\"", ",", "e", ")", ";", "}", "}", "}", "}", "if", "(", "!", "cacheDir", ".", "isDirectory", "(", ")", "&&", "!", "cacheDir", ".", "mkdirs", "(", ")", ")", "{", "logger", ".", "warn", "(", "\"", "Failed to create gzip cache directory", "\"", ")", ";", "return", "null", ";", "}", "return", "cacheDir", ";", "}"], "idx": 49469, "cwe": "CWE-377", "target": 0, "status": "FIXED", "commit": "853a6d73276849877819f2dc23133557f6e1e601", "function_name": "initCacheDir", "body_hash": "9a08abd0fb784b350781f3bda58f9e9a27334b0d"}
{"code": "public void parseDmozFile(File dmozFile, int subsetDenom,\n      boolean includeAdult, int skew, Pattern topicPattern) \n              throws IOException, SAXException, ParserConfigurationException {\n\n    SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n    SAXParser parser = parserFactory.newSAXParser();\n    XMLReader reader = parser.getXMLReader();\n\n    // Create our own processor to receive SAX events\n    RDFProcessor rp = new RDFProcessor(reader, subsetDenom, includeAdult, skew,\n        topicPattern);\n    reader.setContentHandler(rp);\n    reader.setErrorHandler(rp);\n    LOG.info(\"skew = \" + rp.hashSkew);\n\n    //\n    // Open filtered text stream. The TextFilter makes sure that\n    // only appropriate XML-approved Text characters are received.\n    // Any non-conforming characters are silently skipped.\n    //\n    try (XMLCharFilter in = new XMLCharFilter(new BufferedReader(\n        new InputStreamReader(new BufferedInputStream(new FileInputStream(\n            dmozFile)), \"UTF-8\")))) {\n      InputSource is = new InputSource(in);\n      reader.parse(is);\n    } catch (Exception e) {\n      if (LOG.isErrorEnabled()) {\n        LOG.error(e.toString());\n      }\n      System.exit(0);\n    }\n  }", "code_tokens": ["public", "void", "parseDmozFile", "(", "File", "dmozFile", ",", "int", "subsetDenom", ",", "boolean", "includeAdult", ",", "int", "skew", ",", "Pattern", "topicPattern", ")", "throws", "IOException", ",", "SAXException", ",", "ParserConfigurationException", "{", "SAXParserFactory", "parserFactory", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "SAXParser", "parser", "=", "parserFactory", ".", "newSAXParser", "(", ")", ";", "XMLReader", "reader", "=", "parser", ".", "getXMLReader", "(", ")", ";", "RDFProcessor", "rp", "=", "new", "RDFProcessor", "(", "reader", ",", "subsetDenom", ",", "includeAdult", ",", "skew", ",", "topicPattern", ")", ";", "reader", ".", "setContentHandler", "(", "rp", ")", ";", "reader", ".", "setErrorHandler", "(", "rp", ")", ";", "LOG", ".", "info", "(", "\"", "skew = ", "\"", "+", "rp", ".", "hashSkew", ")", ";", "try", "(", "XMLCharFilter", "in", "=", "new", "XMLCharFilter", "(", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "new", "BufferedInputStream", "(", "new", "FileInputStream", "(", "dmozFile", ")", ")", ",", "\"", "UTF-8", "\"", ")", ")", ")", ")", "{", "InputSource", "is", "=", "new", "InputSource", "(", "in", ")", ";", "reader", ".", "parse", "(", "is", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "if", "(", "LOG", ".", "isErrorEnabled", "(", ")", ")", "{", "LOG", ".", "error", "(", "e", ".", "toString", "(", ")", ")", ";", "}", "System", ".", "exit", "(", "0", ")", ";", "}", "}"], "idx": 69587, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "59c63c7d8a13b0de1fd1da6aa4a1ab6e20fa478d", "function_name": "parseDmozFile", "body_hash": "cd05855a9b21de29633dac0cfacc39f66754432f"}
{"code": "public String filter(String expression) {\n        if (forbiddenExpressionPatterns != null && expressionMatches(expression, forbiddenExpressionPatterns)) {\n            logger.warn(\"Expression filtered because forbidden. See debug log level for more information\");\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Expression {} is forbidden by expression filter\", expression);\n            }\n\n            return null;\n        }\n        if (allowedExpressionPatterns != null && !expressionMatches(expression, allowedExpressionPatterns)) {\n            logger.warn(\"Expression filtered because not allowed. See debug log level for more information\");\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Expression {} is not allowed by expression filter\", expression);\n            }\n\n            return null;\n        }\n        return expression;\n    }", "code_tokens": ["public", "String", "filter", "(", "String", "expression", ")", "{", "if", "(", "forbiddenExpressionPatterns", "!=", "null", "&&", "expressionMatches", "(", "expression", ",", "forbiddenExpressionPatterns", ")", ")", "{", "logger", ".", "warn", "(", "\"", "Expression filtered because forbidden. See debug log level for more information", "\"", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Expression {} is forbidden by expression filter", "\"", ",", "expression", ")", ";", "}", "return", "null", ";", "}", "if", "(", "allowedExpressionPatterns", "!=", "null", "&&", "!", "expressionMatches", "(", "expression", ",", "allowedExpressionPatterns", ")", ")", "{", "logger", ".", "warn", "(", "\"", "Expression filtered because not allowed. See debug log level for more information", "\"", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Expression {} is not allowed by expression filter", "\"", ",", "expression", ")", ";", "}", "return", "null", ";", "}", "return", "expression", ";", "}"], "idx": 73775, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "1c088702511ef44a056244cb968682daf8f21946", "function_name": "filter", "body_hash": "67ef1c00c79975e2b88dfcaa3e541a8fadbd1b31"}
{"code": "public static ClassLoader getContextClassLoader() {\n        return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> {\n            ClassLoader tccl = null;\n            try {\n                tccl = Thread.currentThread().getContextClassLoader();\n            } catch (SecurityException ex) {\n                LOG.warn(\"Unable to get context classloader instance.\", ex);\n            }\n            return tccl;\n        });\n    }", "code_tokens": ["public", "static", "ClassLoader", "getContextClassLoader", "(", ")", "{", "return", "AccessController", ".", "doPrivileged", "(", "(", "PrivilegedAction", "<", "ClassLoader", ">", ")", "(", ")", "->", "{", "ClassLoader", "tccl", "=", "null", ";", "try", "{", "tccl", "=", "Thread", ".", "currentThread", "(", ")", ".", "getContextClassLoader", "(", ")", ";", "}", "catch", "(", "SecurityException", "ex", ")", "{", "LOG", ".", "warn", "(", "\"", "Unable to get context classloader instance.", "\"", ",", "ex", ")", ";", "}", "return", "tccl", ";", "}", ")", ";", "}"], "idx": 88701, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "fb0def6f61c09a2a80c9145e4ec6521225cd0b99", "function_name": "getContextClassLoader", "body_hash": "156676e62c019179207fce3d5a45107ddfd3e803"}
{"code": "@Override\n    public void onCommand(final Object o) {\n        final Command command = (Command)o;\n        if (!closed.get() && command != null) {\n            try {\n                command.visit(new CommandVisitorAdapter() {\n                    @Override\n                    public Response processMessageDispatch(MessageDispatch md) throws Exception {\n                        waitForTransportInterruptionProcessingToComplete();\n                        ActiveMQDispatcher dispatcher = dispatchers.get(md.getConsumerId());\n                        if (dispatcher != null) {\n                            // Copy in case a embedded broker is dispatching via\n                            // vm://\n                            // md.getMessage() == null to signal end of queue\n                            // browse.\n                            Message msg = md.getMessage();\n                            if (msg != null) {\n                                msg = msg.copy();\n                                msg.setReadOnlyBody(true);\n                                msg.setReadOnlyProperties(true);\n                                msg.setRedeliveryCounter(md.getRedeliveryCounter());\n                                msg.setConnection(ActiveMQConnection.this);\n                                msg.setMemoryUsage(null);\n                                md.setMessage(msg);\n                            }\n                            dispatcher.dispatch(md);\n                        } else {\n                            LOG.debug(\"{} no dispatcher for {} in {}\", this, md, dispatchers);\n                        }\n                        return null;\n                    }\n\n                    @Override\n                    public Response processProducerAck(ProducerAck pa) throws Exception {\n                        if (pa != null && pa.getProducerId() != null) {\n                            ActiveMQMessageProducer producer = producers.get(pa.getProducerId());\n                            if (producer != null) {\n                                producer.onProducerAck(pa);\n                            }\n                        }\n                        return null;\n                    }\n\n                    @Override\n                    public Response processBrokerInfo(BrokerInfo info) throws Exception {\n                        brokerInfo = info;\n                        brokerInfoReceived.countDown();\n                        optimizeAcknowledge &= !brokerInfo.isFaultTolerantConfiguration();\n                        getBlobTransferPolicy().setBrokerUploadUrl(info.getBrokerUploadUrl());\n                        return null;\n                    }\n\n                    @Override\n                    public Response processConnectionError(final ConnectionError error) throws Exception {\n                        executor.execute(new Runnable() {\n                            @Override\n                            public void run() {\n                                onAsyncException(error.getException());\n                            }\n                        });\n                        return null;\n                    }\n\n                    @Override\n                    public Response processControlCommand(ControlCommand command) throws Exception {\n                        onControlCommand(command);\n                        return null;\n                    }\n\n                    @Override\n                    public Response processConnectionControl(ConnectionControl control) throws Exception {\n                        onConnectionControl((ConnectionControl)command);\n                        return null;\n                    }\n\n                    @Override\n                    public Response processConsumerControl(ConsumerControl control) throws Exception {\n                        onConsumerControl((ConsumerControl)command);\n                        return null;\n                    }\n\n                    @Override\n                    public Response processWireFormat(WireFormatInfo info) throws Exception {\n                        onWireFormatInfo((WireFormatInfo)command);\n                        return null;\n                    }\n                });\n            } catch (Exception e) {\n                onClientInternalException(e);\n            }\n        }\n\n        for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {\n            TransportListener listener = iter.next();\n            listener.onCommand(command);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "onCommand", "(", "final", "Object", "o", ")", "{", "final", "Command", "command", "=", "(", "Command", ")", "o", ";", "if", "(", "!", "closed", ".", "get", "(", ")", "&&", "command", "!=", "null", ")", "{", "try", "{", "command", ".", "visit", "(", "new", "CommandVisitorAdapter", "(", ")", "{", "@", "Override", "public", "Response", "processMessageDispatch", "(", "MessageDispatch", "md", ")", "throws", "Exception", "{", "waitForTransportInterruptionProcessingToComplete", "(", ")", ";", "ActiveMQDispatcher", "dispatcher", "=", "dispatchers", ".", "get", "(", "md", ".", "getConsumerId", "(", ")", ")", ";", "if", "(", "dispatcher", "!=", "null", ")", "{", "Message", "msg", "=", "md", ".", "getMessage", "(", ")", ";", "if", "(", "msg", "!=", "null", ")", "{", "msg", "=", "msg", ".", "copy", "(", ")", ";", "msg", ".", "setReadOnlyBody", "(", "true", ")", ";", "msg", ".", "setReadOnlyProperties", "(", "true", ")", ";", "msg", ".", "setRedeliveryCounter", "(", "md", ".", "getRedeliveryCounter", "(", ")", ")", ";", "msg", ".", "setConnection", "(", "ActiveMQConnection", ".", "this", ")", ";", "msg", ".", "setMemoryUsage", "(", "null", ")", ";", "md", ".", "setMessage", "(", "msg", ")", ";", "}", "dispatcher", ".", "dispatch", "(", "md", ")", ";", "}", "else", "{", "LOG", ".", "debug", "(", "\"", "{} no dispatcher for {} in {}", "\"", ",", "this", ",", "md", ",", "dispatchers", ")", ";", "}", "return", "null", ";", "}", "@", "Override", "public", "Response", "processProducerAck", "(", "ProducerAck", "pa", ")", "throws", "Exception", "{", "if", "(", "pa", "!=", "null", "&&", "pa", ".", "getProducerId", "(", ")", "!=", "null", ")", "{", "ActiveMQMessageProducer", "producer", "=", "producers", ".", "get", "(", "pa", ".", "getProducerId", "(", ")", ")", ";", "if", "(", "producer", "!=", "null", ")", "{", "producer", ".", "onProducerAck", "(", "pa", ")", ";", "}", "}", "return", "null", ";", "}", "@", "Override", "public", "Response", "processBrokerInfo", "(", "BrokerInfo", "info", ")", "throws", "Exception", "{", "brokerInfo", "=", "info", ";", "brokerInfoReceived", ".", "countDown", "(", ")", ";", "optimizeAcknowledge", "&=", "!", "brokerInfo", ".", "isFaultTolerantConfiguration", "(", ")", ";", "getBlobTransferPolicy", "(", ")", ".", "setBrokerUploadUrl", "(", "info", ".", "getBrokerUploadUrl", "(", ")", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processConnectionError", "(", "final", "ConnectionError", "error", ")", "throws", "Exception", "{", "executor", ".", "execute", "(", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "onAsyncException", "(", "error", ".", "getException", "(", ")", ")", ";", "}", "}", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processControlCommand", "(", "ControlCommand", "command", ")", "throws", "Exception", "{", "onControlCommand", "(", "command", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processConnectionControl", "(", "ConnectionControl", "control", ")", "throws", "Exception", "{", "onConnectionControl", "(", "(", "ConnectionControl", ")", "command", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processConsumerControl", "(", "ConsumerControl", "control", ")", "throws", "Exception", "{", "onConsumerControl", "(", "(", "ConsumerControl", ")", "command", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processWireFormat", "(", "WireFormatInfo", "info", ")", "throws", "Exception", "{", "onWireFormatInfo", "(", "(", "WireFormatInfo", ")", "command", ")", ";", "return", "null", ";", "}", "}", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "onClientInternalException", "(", "e", ")", ";", "}", "}", "for", "(", "Iterator", "<", "TransportListener", ">", "iter", "=", "transportListeners", ".", "iterator", "(", ")", ";", "iter", ".", "hasNext", "(", ")", ";", ")", "{", "TransportListener", "listener", "=", "iter", ".", "next", "(", ")", ";", "listener", ".", "onCommand", "(", "command", ")", ";", "}", "}"], "idx": 5059, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "338a74dfa42a7b19d39adecacfa5f626a050e807", "function_name": "onCommand", "body_hash": "e1ee3fc89537c47fd2cfc64eb90ef329b6c50a25"}
{"code": "@Override\n    public void showWebPage(String url, boolean openExternal, boolean clearHistory, Map<String, Object> params) {\n        LOG.d(TAG, \"showWebPage(%s, %b, %b, HashMap)\", url, openExternal, clearHistory);\n\n        // If clearing history\n        if (clearHistory) {\n            engine.clearHistory();\n        }\n\n        // If loading into our webview\n        if (!openExternal) {\n            // Make sure url is in whitelist\n            if (pluginManager.shouldAllowNavigation(url)) {\n                // TODO: What about params?\n                // Load new URL\n                loadUrlIntoView(url, true);\n            } else {\n                LOG.w(TAG, \"showWebPage: Refusing to load URL into webview since it is not in the <allow-navigation> whitelist. URL=\" + url);\n            }\n        }\n        if (!pluginManager.shouldOpenExternalUrl(url)) {\n            LOG.w(TAG, \"showWebPage: Refusing to send intent for URL since it is not in the <allow-intent> whitelist. URL=\" + url);\n            return;\n        }\n        try {\n            // Omitting the MIME type for file: URLs causes \"No Activity found to handle Intent\".\n            // Adding the MIME type to http: URLs causes them to not be handled by the downloader.\n            Intent intent = new Intent(Intent.ACTION_VIEW);\n            Uri uri = Uri.parse(url);\n            if (\"file\".equals(uri.getScheme())) {\n                intent.setDataAndType(uri, resourceApi.getMimeType(uri));\n            } else {\n                intent.setData(uri);\n            }\n            cordova.getActivity().startActivity(intent);\n        } catch (android.content.ActivityNotFoundException e) {\n            LOG.e(TAG, \"Error loading url \" + url, e);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "showWebPage", "(", "String", "url", ",", "boolean", "openExternal", ",", "boolean", "clearHistory", ",", "Map", "<", "String", ",", "Object", ">", "params", ")", "{", "LOG", ".", "d", "(", "TAG", ",", "\"", "showWebPage(%s, %b, %b, HashMap)", "\"", ",", "url", ",", "openExternal", ",", "clearHistory", ")", ";", "if", "(", "clearHistory", ")", "{", "engine", ".", "clearHistory", "(", ")", ";", "}", "if", "(", "!", "openExternal", ")", "{", "if", "(", "pluginManager", ".", "shouldAllowNavigation", "(", "url", ")", ")", "{", "loadUrlIntoView", "(", "url", ",", "true", ")", ";", "}", "else", "{", "LOG", ".", "w", "(", "TAG", ",", "\"", "showWebPage: Refusing to load URL into webview since it is not in the <allow-navigation> whitelist. URL=", "\"", "+", "url", ")", ";", "}", "}", "if", "(", "!", "pluginManager", ".", "shouldOpenExternalUrl", "(", "url", ")", ")", "{", "LOG", ".", "w", "(", "TAG", ",", "\"", "showWebPage: Refusing to send intent for URL since it is not in the <allow-intent> whitelist. URL=", "\"", "+", "url", ")", ";", "return", ";", "}", "try", "{", "Intent", "intent", "=", "new", "Intent", "(", "Intent", ".", "ACTION_VIEW", ")", ";", "Uri", "uri", "=", "Uri", ".", "parse", "(", "url", ")", ";", "if", "(", "\"", "file", "\"", ".", "equals", "(", "uri", ".", "getScheme", "(", ")", ")", ")", "{", "intent", ".", "setDataAndType", "(", "uri", ",", "resourceApi", ".", "getMimeType", "(", "uri", ")", ")", ";", "}", "else", "{", "intent", ".", "setData", "(", "uri", ")", ";", "}", "cordova", ".", "getActivity", "(", ")", ".", "startActivity", "(", "intent", ")", ";", "}", "catch", "(", "android", ".", "content", ".", "ActivityNotFoundException", "e", ")", "{", "LOG", ".", "e", "(", "TAG", ",", "\"", "Error loading url ", "\"", "+", "url", ",", "e", ")", ";", "}", "}"], "idx": 31534, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "af2969dec58ca89150b84b5d57edcf63d4ce1302", "function_name": "showWebPage", "body_hash": "4d3f20cdb42c4d149b274b620a893e90b5c49884"}
{"code": "public String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();\n        if (getIsUnitTest()) {\n            throw new SecurityException(\"attempted to render plaintext \u2018\" + o + \"\u2019 in password field; use a getter of type Secret instead\");\n        }\n        return o.toString();\n    }", "code_tokens": ["public", "String", "getPasswordValue", "(", "Object", "o", ")", "{", "if", "(", "o", "==", "null", ")", "return", "null", ";", "if", "(", "o", "instanceof", "Secret", ")", "return", "(", "(", "Secret", ")", "o", ")", ".", "getEncryptedValue", "(", ")", ";", "if", "(", "getIsUnitTest", "(", ")", ")", "{", "throw", "new", "SecurityException", "(", "\"", "attempted to render plaintext \u2018", "\"", "+", "o", "+", "\"", "\u2019 in password field; use a getter of type Secret instead", "\"", ")", ";", "}", "return", "o", ".", "toString", "(", ")", ";", "}"], "idx": 15028, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "82b42359797e42fa4b2428d5e390e7ce91b74998", "function_name": "getPasswordValue", "body_hash": "6ed55cbd2f5303128ea28edf1081ddfa973e3b78"}
{"code": "@SuppressWarnings(\"ACL.impersonate\")\n    private void loginAndTakeBack(StaplerRequest req, StaplerResponse rsp, User u) throws ServletException, IOException {\n        HttpSession session = req.getSession(false);\n        if (session != null) {\n            // avoid session fixation\n            session.invalidate();\n        }\n        req.getSession(true);\n        \n        // ... and let him login\n        Authentication a = new UsernamePasswordAuthenticationToken(u.getId(),req.getParameter(\"password1\"));\n        a = this.getSecurityComponents().manager.authenticate(a);\n        SecurityContextHolder.getContext().setAuthentication(a);\n\n        // then back to top\n        req.getView(this,\"success.jelly\").forward(req,rsp);\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "ACL.impersonate", "\"", ")", "private", "void", "loginAndTakeBack", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ",", "User", "u", ")", "throws", "ServletException", ",", "IOException", "{", "HttpSession", "session", "=", "req", ".", "getSession", "(", "false", ")", ";", "if", "(", "session", "!=", "null", ")", "{", "session", ".", "invalidate", "(", ")", ";", "}", "req", ".", "getSession", "(", "true", ")", ";", "Authentication", "a", "=", "new", "UsernamePasswordAuthenticationToken", "(", "u", ".", "getId", "(", ")", ",", "req", ".", "getParameter", "(", "\"", "password1", "\"", ")", ")", ";", "a", "=", "this", ".", "getSecurityComponents", "(", ")", ".", "manager", ".", "authenticate", "(", "a", ")", ";", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "setAuthentication", "(", "a", ")", ";", "req", ".", "getView", "(", "this", ",", "\"", "success.jelly", "\"", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "}"], "idx": 50103, "cwe": "CWE-384", "target": 0, "status": "FIXED", "commit": "517da6ed389f0a606dd9bb8595bc79fc93f4331c", "function_name": "loginAndTakeBack", "body_hash": "5e0eea47b144fb474c6a90baa4709f90c22d8a51"}
{"code": "public URL getURL() throws MalformedURLException {\n            String name = fileName;\n            if (name.equals(\"hudson-cli.jar\"))  name=\"jenkins-cli.jar\";\n            \n            // Prevent the sandbox escaping (SECURITY-195)\n            if (name.contains(\"..\")) {\n                throw new MalformedURLException(\"The specified file path \" + fileName + \" contains '..'. \"\n                        + \"The path is not allowed due to security reasons\");\n            }\n            \n            URL res = Jenkins.getInstance().servletContext.getResource(\"/WEB-INF/\" + name);\n            if(res==null) {\n                // during the development this path doesn't have the files.\n                res = new URL(new File(\".\").getAbsoluteFile().toURI().toURL(),\"target/jenkins/WEB-INF/\"+name);\n            }\n            return res;\n        }", "code_tokens": ["public", "URL", "getURL", "(", ")", "throws", "MalformedURLException", "{", "String", "name", "=", "fileName", ";", "if", "(", "name", ".", "equals", "(", "\"", "hudson-cli.jar", "\"", ")", ")", "name", "=", "\"", "jenkins-cli.jar", "\"", ";", "if", "(", "name", ".", "contains", "(", "\"", "..", "\"", ")", ")", "{", "throw", "new", "MalformedURLException", "(", "\"", "The specified file path ", "\"", "+", "fileName", "+", "\"", " contains '..'. ", "\"", "+", "\"", "The path is not allowed due to security reasons", "\"", ")", ";", "}", "URL", "res", "=", "Jenkins", ".", "getInstance", "(", ")", ".", "servletContext", ".", "getResource", "(", "\"", "/WEB-INF/", "\"", "+", "name", ")", ";", "if", "(", "res", "==", "null", ")", "{", "res", "=", "new", "URL", "(", "new", "File", "(", "\"", ".", "\"", ")", ".", "getAbsoluteFile", "(", ")", ".", "toURI", "(", ")", ".", "toURL", "(", ")", ",", "\"", "target/jenkins/WEB-INF/", "\"", "+", "name", ")", ";", "}", "return", "res", ";", "}"], "idx": 21446, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "5431e397216b4ab80e58bdabcb06a0066bce6592", "function_name": "getURL", "body_hash": "9ed144bca4c0bd3f3acadf3d705016f5993dc272"}
{"code": "public void handleMessage(SoapMessage msg) throws Fault {\n        if (msg.containsKey(SECURITY_PROCESSED) || isGET(msg)) {\n            return;\n        }\n        msg.put(SECURITY_PROCESSED, Boolean.TRUE);\n        \n        boolean utWithCallbacks = \n            MessageUtils.getContextualBoolean(msg, SecurityConstants.VALIDATE_TOKEN, true);\n        translateProperties(msg);\n        \n        RequestData reqData = new CXFRequestData();\n\n        WSSConfig config = (WSSConfig)msg.getContextualProperty(WSSConfig.class.getName()); \n        WSSecurityEngine engine;\n        if (config != null) {\n            engine = new WSSecurityEngine();\n            engine.setWssConfig(config);\n        } else {\n            engine = getSecurityEngine(utWithCallbacks);\n            if (engine == null) {\n                engine = new WSSecurityEngine();\n            }\n            config = engine.getWssConfig();\n        }\n        reqData.setWssConfig(config);\n        \n                \n        SOAPMessage doc = getSOAPMessage(msg);\n        \n        boolean doDebug = LOG.isLoggable(Level.FINE);\n        boolean doTimeLog = TIME_LOG.isLoggable(Level.FINE);\n\n        SoapVersion version = msg.getVersion();\n        if (doDebug) {\n            LOG.fine(\"WSS4JInInterceptor: enter handleMessage()\");\n        }\n\n        long t0 = 0;\n        long t1 = 0;\n        long t2 = 0;\n        long t3 = 0;\n\n        if (doTimeLog) {\n            t0 = System.currentTimeMillis();\n        }\n\n        /*\n         * The overall try, just to have a finally at the end to perform some\n         * housekeeping.\n         */\n        try {\n            reqData.setMsgContext(msg);\n            computeAction(msg, reqData);\n            List<Integer> actions = new ArrayList<Integer>();\n            String action = getAction(msg, version);\n\n            int doAction = WSSecurityUtil.decodeAction(action, actions);\n\n            String actor = (String)getOption(WSHandlerConstants.ACTOR);\n\n            reqData.setCallbackHandler(getCallback(reqData, doAction, utWithCallbacks));\n            \n            String passwordTypeStrict = (String)getOption(WSHandlerConstants.PASSWORD_TYPE_STRICT);\n            if (passwordTypeStrict == null) {\n                setProperty(WSHandlerConstants.PASSWORD_TYPE_STRICT, \"true\");\n            }\n            \n            // Configure replay caching\n            ReplayCache nonceCache = \n                getReplayCache(\n                    msg, SecurityConstants.ENABLE_NONCE_CACHE, SecurityConstants.NONCE_CACHE_INSTANCE\n                );\n            reqData.setNonceReplayCache(nonceCache);\n            ReplayCache timestampCache = \n                getReplayCache(\n                    msg, SecurityConstants.ENABLE_TIMESTAMP_CACHE, SecurityConstants.TIMESTAMP_CACHE_INSTANCE\n                );\n            reqData.setTimestampReplayCache(timestampCache);\n\n            /*\n             * Get and check the Signature specific parameters first because\n             * they may be used for encryption too.\n             */\n            doReceiverAction(doAction, reqData);\n            \n            /*get chance to check msg context enableRevocation setting\n             *when use policy based ws-security where the WSHandler configuration\n             *isn't available\n             */\n            boolean enableRevocation = reqData.isRevocationEnabled() \n                || MessageUtils.isTrue(msg.getContextualProperty(SecurityConstants.ENABLE_REVOCATION));\n            reqData.setEnableRevocation(enableRevocation);\n            \n            if (doTimeLog) {\n                t1 = System.currentTimeMillis();\n            }\n            Element elem = WSSecurityUtil.getSecurityHeader(doc.getSOAPPart(), actor);\n\n            List<WSSecurityEngineResult> wsResult = engine.processSecurityHeader(\n                elem, reqData\n            );\n\n            if (doTimeLog) {\n                t2 = System.currentTimeMillis();\n            }\n\n            if (wsResult != null && !wsResult.isEmpty()) { // security header found\n                if (reqData.getWssConfig().isEnableSignatureConfirmation()) {\n                    checkSignatureConfirmation(reqData, wsResult);\n                }\n\n                storeSignature(msg, reqData, wsResult);\n                storeTimestamp(msg, reqData, wsResult);\n                checkActions(msg, reqData, wsResult, actions);\n                doResults(\n                    msg, actor, \n                    SAAJUtils.getHeader(doc),\n                    SAAJUtils.getBody(doc),\n                    wsResult, utWithCallbacks\n                );\n            } else { // no security header found\n                // Create an empty result list to pass into the required validation\n                // methods.\n                wsResult = new ArrayList<WSSecurityEngineResult>();\n                if (doc.getSOAPPart().getEnvelope().getBody().hasFault()) {\n                    LOG.warning(\"Request does not contain Security header, \" \n                                + \"but it's a fault.\");\n                    // We allow lax action matching here for backwards compatibility\n                    // with manually configured WSS4JInInterceptors that previously\n                    // allowed faults to pass through even if their actions aren't\n                    // a strict match against those configured.  In the WS-SP case,\n                    // we will want to still call doResults as it handles asserting\n                    // certain assertions that do not require a WS-S header such as\n                    // a sp:TransportBinding assertion.  In the case of WS-SP,\n                    // the unasserted assertions will provide confirmation that\n                    // security was not sufficient.\n                    // checkActions(msg, reqData, wsResult, actions);\n                    doResults(msg, actor, \n                              SAAJUtils.getHeader(doc),\n                              SAAJUtils.getBody(doc),\n                              wsResult);\n                } else {\n                    checkActions(msg, reqData, wsResult, actions);\n                    doResults(msg, actor,\n                              SAAJUtils.getHeader(doc),\n                              SAAJUtils.getBody(doc),\n                              wsResult);\n                }\n            }\n            advanceBody(msg, SAAJUtils.getBody(doc));\n            SAAJInInterceptor.replaceHeaders(doc, msg);\n\n            if (doTimeLog) {\n                t3 = System.currentTimeMillis();\n                TIME_LOG.fine(\"Receive request: total= \" + (t3 - t0) \n                        + \" request preparation= \" + (t1 - t0)\n                        + \" request processing= \" + (t2 - t1) \n                        + \" header, cert verify, timestamp= \" + (t3 - t2) + \"\\n\");\n            }\n\n            if (doDebug) {\n                LOG.fine(\"WSS4JInInterceptor: exit handleMessage()\");\n            }\n\n        } catch (WSSecurityException e) {\n            LOG.log(Level.WARNING, \"\", e);\n            SoapFault fault = createSoapFault(version, e);\n            throw fault;\n        } catch (XMLStreamException e) {\n            throw new SoapFault(new Message(\"STAX_EX\", LOG), e, version.getSender());\n        } catch (SOAPException e) {\n            throw new SoapFault(new Message(\"SAAJ_EX\", LOG), e, version.getSender());\n        } finally {\n            reqData.clear();\n            reqData = null;\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "SoapMessage", "msg", ")", "throws", "Fault", "{", "if", "(", "msg", ".", "containsKey", "(", "SECURITY_PROCESSED", ")", "||", "isGET", "(", "msg", ")", ")", "{", "return", ";", "}", "msg", ".", "put", "(", "SECURITY_PROCESSED", ",", "Boolean", ".", "TRUE", ")", ";", "boolean", "utWithCallbacks", "=", "MessageUtils", ".", "getContextualBoolean", "(", "msg", ",", "SecurityConstants", ".", "VALIDATE_TOKEN", ",", "true", ")", ";", "translateProperties", "(", "msg", ")", ";", "RequestData", "reqData", "=", "new", "CXFRequestData", "(", ")", ";", "WSSConfig", "config", "=", "(", "WSSConfig", ")", "msg", ".", "getContextualProperty", "(", "WSSConfig", ".", "class", ".", "getName", "(", ")", ")", ";", "WSSecurityEngine", "engine", ";", "if", "(", "config", "!=", "null", ")", "{", "engine", "=", "new", "WSSecurityEngine", "(", ")", ";", "engine", ".", "setWssConfig", "(", "config", ")", ";", "}", "else", "{", "engine", "=", "getSecurityEngine", "(", "utWithCallbacks", ")", ";", "if", "(", "engine", "==", "null", ")", "{", "engine", "=", "new", "WSSecurityEngine", "(", ")", ";", "}", "config", "=", "engine", ".", "getWssConfig", "(", ")", ";", "}", "reqData", ".", "setWssConfig", "(", "config", ")", ";", "SOAPMessage", "doc", "=", "getSOAPMessage", "(", "msg", ")", ";", "boolean", "doDebug", "=", "LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ";", "boolean", "doTimeLog", "=", "TIME_LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ";", "SoapVersion", "version", "=", "msg", ".", "getVersion", "(", ")", ";", "if", "(", "doDebug", ")", "{", "LOG", ".", "fine", "(", "\"", "WSS4JInInterceptor: enter handleMessage()", "\"", ")", ";", "}", "long", "t0", "=", "0", ";", "long", "t1", "=", "0", ";", "long", "t2", "=", "0", ";", "long", "t3", "=", "0", ";", "if", "(", "doTimeLog", ")", "{", "t0", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "}", "try", "{", "reqData", ".", "setMsgContext", "(", "msg", ")", ";", "computeAction", "(", "msg", ",", "reqData", ")", ";", "List", "<", "Integer", ">", "actions", "=", "new", "ArrayList", "<", "Integer", ">", "(", ")", ";", "String", "action", "=", "getAction", "(", "msg", ",", "version", ")", ";", "int", "doAction", "=", "WSSecurityUtil", ".", "decodeAction", "(", "action", ",", "actions", ")", ";", "String", "actor", "=", "(", "String", ")", "getOption", "(", "WSHandlerConstants", ".", "ACTOR", ")", ";", "reqData", ".", "setCallbackHandler", "(", "getCallback", "(", "reqData", ",", "doAction", ",", "utWithCallbacks", ")", ")", ";", "String", "passwordTypeStrict", "=", "(", "String", ")", "getOption", "(", "WSHandlerConstants", ".", "PASSWORD_TYPE_STRICT", ")", ";", "if", "(", "passwordTypeStrict", "==", "null", ")", "{", "setProperty", "(", "WSHandlerConstants", ".", "PASSWORD_TYPE_STRICT", ",", "\"", "true", "\"", ")", ";", "}", "ReplayCache", "nonceCache", "=", "getReplayCache", "(", "msg", ",", "SecurityConstants", ".", "ENABLE_NONCE_CACHE", ",", "SecurityConstants", ".", "NONCE_CACHE_INSTANCE", ")", ";", "reqData", ".", "setNonceReplayCache", "(", "nonceCache", ")", ";", "ReplayCache", "timestampCache", "=", "getReplayCache", "(", "msg", ",", "SecurityConstants", ".", "ENABLE_TIMESTAMP_CACHE", ",", "SecurityConstants", ".", "TIMESTAMP_CACHE_INSTANCE", ")", ";", "reqData", ".", "setTimestampReplayCache", "(", "timestampCache", ")", ";", "doReceiverAction", "(", "doAction", ",", "reqData", ")", ";", "boolean", "enableRevocation", "=", "reqData", ".", "isRevocationEnabled", "(", ")", "||", "MessageUtils", ".", "isTrue", "(", "msg", ".", "getContextualProperty", "(", "SecurityConstants", ".", "ENABLE_REVOCATION", ")", ")", ";", "reqData", ".", "setEnableRevocation", "(", "enableRevocation", ")", ";", "if", "(", "doTimeLog", ")", "{", "t1", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "}", "Element", "elem", "=", "WSSecurityUtil", ".", "getSecurityHeader", "(", "doc", ".", "getSOAPPart", "(", ")", ",", "actor", ")", ";", "List", "<", "WSSecurityEngineResult", ">", "wsResult", "=", "engine", ".", "processSecurityHeader", "(", "elem", ",", "reqData", ")", ";", "if", "(", "doTimeLog", ")", "{", "t2", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "}", "if", "(", "wsResult", "!=", "null", "&&", "!", "wsResult", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "reqData", ".", "getWssConfig", "(", ")", ".", "isEnableSignatureConfirmation", "(", ")", ")", "{", "checkSignatureConfirmation", "(", "reqData", ",", "wsResult", ")", ";", "}", "storeSignature", "(", "msg", ",", "reqData", ",", "wsResult", ")", ";", "storeTimestamp", "(", "msg", ",", "reqData", ",", "wsResult", ")", ";", "checkActions", "(", "msg", ",", "reqData", ",", "wsResult", ",", "actions", ")", ";", "doResults", "(", "msg", ",", "actor", ",", "SAAJUtils", ".", "getHeader", "(", "doc", ")", ",", "SAAJUtils", ".", "getBody", "(", "doc", ")", ",", "wsResult", ",", "utWithCallbacks", ")", ";", "}", "else", "{", "wsResult", "=", "new", "ArrayList", "<", "WSSecurityEngineResult", ">", "(", ")", ";", "if", "(", "doc", ".", "getSOAPPart", "(", ")", ".", "getEnvelope", "(", ")", ".", "getBody", "(", ")", ".", "hasFault", "(", ")", ")", "{", "LOG", ".", "warning", "(", "\"", "Request does not contain Security header, ", "\"", "+", "\"", "but it's a fault.", "\"", ")", ";", "doResults", "(", "msg", ",", "actor", ",", "SAAJUtils", ".", "getHeader", "(", "doc", ")", ",", "SAAJUtils", ".", "getBody", "(", "doc", ")", ",", "wsResult", ")", ";", "}", "else", "{", "checkActions", "(", "msg", ",", "reqData", ",", "wsResult", ",", "actions", ")", ";", "doResults", "(", "msg", ",", "actor", ",", "SAAJUtils", ".", "getHeader", "(", "doc", ")", ",", "SAAJUtils", ".", "getBody", "(", "doc", ")", ",", "wsResult", ")", ";", "}", "}", "advanceBody", "(", "msg", ",", "SAAJUtils", ".", "getBody", "(", "doc", ")", ")", ";", "SAAJInInterceptor", ".", "replaceHeaders", "(", "doc", ",", "msg", ")", ";", "if", "(", "doTimeLog", ")", "{", "t3", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "TIME_LOG", ".", "fine", "(", "\"", "Receive request: total= ", "\"", "+", "(", "t3", "-", "t0", ")", "+", "\"", " request preparation= ", "\"", "+", "(", "t1", "-", "t0", ")", "+", "\"", " request processing= ", "\"", "+", "(", "t2", "-", "t1", ")", "+", "\"", " header, cert verify, timestamp= ", "\"", "+", "(", "t3", "-", "t2", ")", "+", "\"", "\\n", "\"", ")", ";", "}", "if", "(", "doDebug", ")", "{", "LOG", ".", "fine", "(", "\"", "WSS4JInInterceptor: exit handleMessage()", "\"", ")", ";", "}", "}", "catch", "(", "WSSecurityException", "e", ")", "{", "LOG", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "\"", ",", "e", ")", ";", "SoapFault", "fault", "=", "createSoapFault", "(", "version", ",", "e", ")", ";", "throw", "fault", ";", "}", "catch", "(", "XMLStreamException", "e", ")", "{", "throw", "new", "SoapFault", "(", "new", "Message", "(", "\"", "STAX_EX", "\"", ",", "LOG", ")", ",", "e", ",", "version", ".", "getSender", "(", ")", ")", ";", "}", "catch", "(", "SOAPException", "e", ")", "{", "throw", "new", "SoapFault", "(", "new", "Message", "(", "\"", "SAAJ_EX", "\"", ",", "LOG", ")", ",", "e", ",", "version", ".", "getSender", "(", ")", ")", ";", "}", "finally", "{", "reqData", ".", "clear", "(", ")", ";", "reqData", "=", "null", ";", "}", "}"], "idx": 39139, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "db11c9115f31e171de4622149f157d8283f6c720", "function_name": "handleMessage", "body_hash": "6a0b1d4c2ce0424dd399413e8443dc83c7b4ad0c"}
{"code": "private String getBodyContentAsString() {\n\t\tif (this.body == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tString contentType = (this.messageProperties != null) ? this.messageProperties.getContentType() : null;\n\t\t\tif (MessageProperties.CONTENT_TYPE_SERIALIZED_OBJECT.equals(contentType)) {\n\t\t\t\treturn SerializationUtils.deserialize(this.body).toString();\n\t\t\t}\n\t\t\tif (MessageProperties.CONTENT_TYPE_TEXT_PLAIN.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON_ALT.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_XML.equals(contentType)) {\n\t\t\t\treturn new String(this.body, ENCODING);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t\t// Comes out as '[B@....b' (so harmless)\n\t\treturn this.body.toString() + \"(byte[\" + this.body.length + \"])\"; //NOSONAR\n\t}", "code_tokens": ["private", "String", "getBodyContentAsString", "(", ")", "{", "if", "(", "this", ".", "body", "==", "null", ")", "{", "return", "null", ";", "}", "try", "{", "String", "contentType", "=", "(", "this", ".", "messageProperties", "!=", "null", ")", "?", "this", ".", "messageProperties", ".", "getContentType", "(", ")", ":", "null", ";", "if", "(", "MessageProperties", ".", "CONTENT_TYPE_SERIALIZED_OBJECT", ".", "equals", "(", "contentType", ")", ")", "{", "return", "SerializationUtils", ".", "deserialize", "(", "this", ".", "body", ")", ".", "toString", "(", ")", ";", "}", "if", "(", "MessageProperties", ".", "CONTENT_TYPE_TEXT_PLAIN", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_JSON", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_JSON_ALT", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_XML", ".", "equals", "(", "contentType", ")", ")", "{", "return", "new", "String", "(", "this", ".", "body", ",", "ENCODING", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "}", "return", "this", ".", "body", ".", "toString", "(", ")", "+", "\"", "(byte[", "\"", "+", "this", ".", "body", ".", "length", "+", "\"", "])", "\"", ";", "}"], "idx": 61671, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "296d481f980fcbecbee01244e3644e254470a86", "function_name": "getBodyContentAsString", "body_hash": "86641f7b5521a92cefc8b2b64af00200abffb865"}
{"code": "protected void sendWindowHandlerHtml(ExternalContext externalContext, String windowId)\n    {\n        HttpServletResponse httpResponse = (HttpServletResponse) externalContext.getResponse();\n\n        try\n        {\n            httpResponse.setStatus(HttpServletResponse.SC_OK);\n            httpResponse.setContentType(\"text/html\");\n\n            String windowHandlerHtml = clientWindowConfig.getClientWindowHtml();\n\n            if (windowId == null)\n            {\n                windowId = UNINITIALIZED_WINDOW_ID_VALUE;\n            }\n\n            // set the windowId value in the javascript code\n            windowHandlerHtml = windowHandlerHtml.replace(WINDOW_ID_REPLACE_PATTERN,\n                    windowId);\n            // set the current request url\n            // on the client we can't use window.location as the location\n            // could be a different when using forwards\n            windowHandlerHtml = windowHandlerHtml.replace(REQUEST_URL_REPLACE_PATTERN,\n                    ClientWindowHelper.constructRequestUrl(externalContext));\n            // set the noscript-URL for users with no JavaScript\n            windowHandlerHtml =\n                    windowHandlerHtml.replace(NOSCRIPT_URL_REPLACE_PATTERN, getNoscriptUrl(externalContext));\n\n            OutputStream os = httpResponse.getOutputStream();\n            try\n            {\n                os.write(windowHandlerHtml.getBytes());\n            }\n            finally\n            {\n                os.close();\n            }\n        }\n        catch (IOException ioe)\n        {\n            throw new FacesException(ioe);\n        }\n    }", "code_tokens": ["protected", "void", "sendWindowHandlerHtml", "(", "ExternalContext", "externalContext", ",", "String", "windowId", ")", "{", "HttpServletResponse", "httpResponse", "=", "(", "HttpServletResponse", ")", "externalContext", ".", "getResponse", "(", ")", ";", "try", "{", "httpResponse", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_OK", ")", ";", "httpResponse", ".", "setContentType", "(", "\"", "text/html", "\"", ")", ";", "String", "windowHandlerHtml", "=", "clientWindowConfig", ".", "getClientWindowHtml", "(", ")", ";", "if", "(", "windowId", "==", "null", ")", "{", "windowId", "=", "UNINITIALIZED_WINDOW_ID_VALUE", ";", "}", "windowHandlerHtml", "=", "windowHandlerHtml", ".", "replace", "(", "WINDOW_ID_REPLACE_PATTERN", ",", "windowId", ")", ";", "windowHandlerHtml", "=", "windowHandlerHtml", ".", "replace", "(", "REQUEST_URL_REPLACE_PATTERN", ",", "ClientWindowHelper", ".", "constructRequestUrl", "(", "externalContext", ")", ")", ";", "windowHandlerHtml", "=", "windowHandlerHtml", ".", "replace", "(", "NOSCRIPT_URL_REPLACE_PATTERN", ",", "getNoscriptUrl", "(", "externalContext", ")", ")", ";", "OutputStream", "os", "=", "httpResponse", ".", "getOutputStream", "(", ")", ";", "try", "{", "os", ".", "write", "(", "windowHandlerHtml", ".", "getBytes", "(", ")", ")", ";", "}", "finally", "{", "os", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "FacesException", "(", "ioe", ")", ";", "}", "}"], "idx": 73318, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "5383f44b117a31d9fc9fcd3c156e1e801e24aedd", "function_name": "sendWindowHandlerHtml", "body_hash": "3e902b129527b362145b1b1fa719b1ae0476f3c6"}
{"code": "public static XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\n\t\t// Create a JAXP SAXParser\n\t\tSAXParser saxParser = spf.newSAXParser();\n\n\t\t// Get the encapsulated SAX XMLReader\n\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t// set default features\n\t\treader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\n\t\treturn reader;\n\t}", "code_tokens": ["public", "static", "XMLReader", "createXmlReader", "(", ")", "throws", "SAXException", ",", "ParserConfigurationException", "{", "SAXParserFactory", "spf", "=", "SAXParserFactory", ".", "newInstance", "(", ")", ";", "SAXParser", "saxParser", "=", "spf", ".", "newSAXParser", "(", ")", ";", "XMLReader", "reader", "=", "saxParser", ".", "getXMLReader", "(", ")", ";", "reader", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/namespaces", "\"", ",", "true", ")", ";", "return", "reader", ";", "}"], "idx": 67182, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "6fc896b65ed871be33dcf453cde924bf73cf83db", "function_name": "createXmlReader", "body_hash": "bc4e7212aaa20dba2f87fad193a37083611e8a78"}
{"code": "public void testInsecureParameters() throws Exception {\n        // given\n        loadConfigurationProviders(new XWorkConfigurationProvider(), new XmlConfigurationProvider(\"xwork-param-test.xml\"));\n        final Map<String, Object> params = new HashMap<String, Object>() {\n            {\n                put(\"name\", \"(#context[\\\"xwork.MethodAccessor.denyMethodExecution\\\"]= new \" +\n                        \"java.lang.Boolean(false), #_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true), \" +\n                        \"@java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)\");\n                put(\"top['name'](0)\", \"true\");\n            }\n        };\n\n        ParametersInterceptor pi = new ParametersInterceptor();\n        container.inject(pi);\n        ValueStack vs = ActionContext.getContext().getValueStack();\n\n        // when\n        ValidateAction action = new ValidateAction();\n        pi.setParameters(action, vs, params);\n\n        // then\n        assertEquals(2, action.getActionMessages().size());\n\n        String msg1 = action.getActionMessage(0);\n        String msg2 = action.getActionMessage(1);\n\n        assertEquals(\"Error setting expression 'name' with value '(#context[\\\"xwork.MethodAccessor.denyMethodExecution\\\"]= new java.lang.Boolean(false), #_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)'\", msg1);\n        assertEquals(\"Error setting expression 'top['name'](0)' with value 'true'\", msg2);\n        assertNull(action.getName());\n    }", "code_tokens": ["public", "void", "testInsecureParameters", "(", ")", "throws", "Exception", "{", "loadConfigurationProviders", "(", "new", "XWorkConfigurationProvider", "(", ")", ",", "new", "XmlConfigurationProvider", "(", "\"", "xwork-param-test.xml", "\"", ")", ")", ";", "final", "Map", "<", "String", ",", "Object", ">", "params", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", "{", "{", "put", "(", "\"", "name", "\"", ",", "\"", "(#context[", "\\\"", "xwork.MethodAccessor.denyMethodExecution", "\\\"", "]= new ", "\"", "+", "\"", "java.lang.Boolean(false), #_memberAccess[", "\\\"", "allowStaticMethodAccess", "\\\"", "]= new java.lang.Boolean(true), ", "\"", "+", "\"", "@java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)", "\"", ")", ";", "put", "(", "\"", "top['name'](0)", "\"", ",", "\"", "true", "\"", ")", ";", "}", "}", ";", "ParametersInterceptor", "pi", "=", "new", "ParametersInterceptor", "(", ")", ";", "container", ".", "inject", "(", "pi", ")", ";", "ValueStack", "vs", "=", "ActionContext", ".", "getContext", "(", ")", ".", "getValueStack", "(", ")", ";", "ValidateAction", "action", "=", "new", "ValidateAction", "(", ")", ";", "pi", ".", "setParameters", "(", "action", ",", "vs", ",", "params", ")", ";", "assertEquals", "(", "2", ",", "action", ".", "getActionMessages", "(", ")", ".", "size", "(", ")", ")", ";", "String", "msg1", "=", "action", ".", "getActionMessage", "(", "0", ")", ";", "String", "msg2", "=", "action", ".", "getActionMessage", "(", "1", ")", ";", "assertEquals", "(", "\"", "Error setting expression 'name' with value '(#context[", "\\\"", "xwork.MethodAccessor.denyMethodExecution", "\\\"", "]= new java.lang.Boolean(false), #_memberAccess[", "\\\"", "allowStaticMethodAccess", "\\\"", "]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)'", "\"", ",", "msg1", ")", ";", "assertEquals", "(", "\"", "Error setting expression 'top['name'](0)' with value 'true'", "\"", ",", "msg2", ")", ";", "assertNull", "(", "action", ".", "getName", "(", ")", ")", ";", "}"], "idx": 30652, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "74e26830d2849a84729b33497f729e0f033dc147", "function_name": "testInsecureParameters", "body_hash": "ba97c036c87be8018b1f890837cf2f868462cd83"}
{"code": "private void createIdentityZoneHelper(String id) throws Exception {\n        String identityClientWriteToken = testClient.getClientCredentialsOAuthAccessToken(\n            \"identity\",\n            \"identitysecret\",\n            \"zones.write\");\n\n        IdentityZone identityZone = new IdentityZone();\n        SamlConfig samlConfig = new SamlConfig();\n        samlConfig.setCertificate(SERVICE_PROVIDER_CERTIFICATE);\n        samlConfig.setPrivateKey(SERVICE_PROVIDER_KEY);\n        samlConfig.setPrivateKeyPassword(SERVICE_PROVIDER_KEY_PASSWORD);\n        samlConfig.setEntityID(SERVICE_PROVIDER_ID);\n        identityZone.getConfig().setSamlConfig(samlConfig);\n        identityZone.getConfig().setIssuer(DEFAULT_ISSUER_URI);\n\n        TokenPolicy tokenPolicy = new TokenPolicy(3600, 7200);\n        tokenPolicy.setActiveKeyId(\"active-key-1\");\n        tokenPolicy.setKeys(new HashMap<>(Collections.singletonMap(\"active-key-1\", \"key\")));\n        identityZone.getConfig().setTokenPolicy(tokenPolicy);\n\n        identityZone.setId(id);\n        identityZone.setSubdomain(StringUtils.hasText(id) ? id : new RandomValueStringGenerator().generate());\n        identityZone.setName(\"The Twiglet Zone\");\n\n        IdentityZoneConfiguration brandingConfig = setBranding(identityZone.getConfig());\n        identityZone.setConfig(brandingConfig);\n\n\n        getMockMvc().perform(\n            post(\"/identity-zones\")\n                .header(\"Authorization\", \"Bearer \" + identityClientWriteToken)\n                .contentType(APPLICATION_JSON)\n                .content(JsonUtils.writeValueAsString(identityZone)))\n            .andExpect(status().is(HttpStatus.CREATED.value()));\n    }", "code_tokens": ["private", "void", "createIdentityZoneHelper", "(", "String", "id", ")", "throws", "Exception", "{", "String", "identityClientWriteToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "\"", "identity", "\"", ",", "\"", "identitysecret", "\"", ",", "\"", "zones.write", "\"", ")", ";", "IdentityZone", "identityZone", "=", "new", "IdentityZone", "(", ")", ";", "SamlConfig", "samlConfig", "=", "new", "SamlConfig", "(", ")", ";", "samlConfig", ".", "setCertificate", "(", "SERVICE_PROVIDER_CERTIFICATE", ")", ";", "samlConfig", ".", "setPrivateKey", "(", "SERVICE_PROVIDER_KEY", ")", ";", "samlConfig", ".", "setPrivateKeyPassword", "(", "SERVICE_PROVIDER_KEY_PASSWORD", ")", ";", "samlConfig", ".", "setEntityID", "(", "SERVICE_PROVIDER_ID", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "setSamlConfig", "(", "samlConfig", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "setIssuer", "(", "DEFAULT_ISSUER_URI", ")", ";", "TokenPolicy", "tokenPolicy", "=", "new", "TokenPolicy", "(", "3600", ",", "7200", ")", ";", "tokenPolicy", ".", "setActiveKeyId", "(", "\"", "active-key-1", "\"", ")", ";", "tokenPolicy", ".", "setKeys", "(", "new", "HashMap", "<", ">", "(", "Collections", ".", "singletonMap", "(", "\"", "active-key-1", "\"", ",", "\"", "key", "\"", ")", ")", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "setTokenPolicy", "(", "tokenPolicy", ")", ";", "identityZone", ".", "setId", "(", "id", ")", ";", "identityZone", ".", "setSubdomain", "(", "StringUtils", ".", "hasText", "(", "id", ")", "?", "id", ":", "new", "RandomValueStringGenerator", "(", ")", ".", "generate", "(", ")", ")", ";", "identityZone", ".", "setName", "(", "\"", "The Twiglet Zone", "\"", ")", ";", "IdentityZoneConfiguration", "brandingConfig", "=", "setBranding", "(", "identityZone", ".", "getConfig", "(", ")", ")", ";", "identityZone", ".", "setConfig", "(", "brandingConfig", ")", ";", "getMockMvc", "(", ")", ".", "perform", "(", "post", "(", "\"", "/identity-zones", "\"", ")", ".", "header", "(", "\"", "Authorization", "\"", ",", "\"", "Bearer ", "\"", "+", "identityClientWriteToken", ")", ".", "contentType", "(", "APPLICATION_JSON", ")", ".", "content", "(", "JsonUtils", ".", "writeValueAsString", "(", "identityZone", ")", ")", ")", ".", "andExpect", "(", "status", "(", ")", ".", "is", "(", "HttpStatus", ".", "CREATED", ".", "value", "(", ")", ")", ")", ";", "}"], "idx": 109252, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "3633a832885ebf33b2e22cc1c0c8ce605e2c657", "function_name": "createIdentityZoneHelper", "body_hash": "1736094b6dd86f8046d695f58551d15086641062"}
{"code": "private void cacheInput(Message outMessage) {\n        if (outMessage.getExchange() == null) {\n            return;\n        }\n        Message inMessage = outMessage.getExchange().getInMessage();\n        if (inMessage == null) {\n            return;\n        }\n        Collection<Attachment> atts = inMessage.getAttachments();\n        if (atts != null) {\n            for (Attachment a : atts) {\n                if (a.getDataHandler().getDataSource() instanceof AttachmentDataSource) {\n                    try {\n                        ((AttachmentDataSource)a.getDataHandler().getDataSource()).cache(inMessage);\n                    } catch (IOException e) {\n                        throw new Fault(e);\n                    }\n                }\n            }\n        }\n        DelegatingInputStream in = inMessage.getContent(DelegatingInputStream.class);\n        if (in != null) {\n            in.cacheInput();\n        }\n    }", "code_tokens": ["private", "void", "cacheInput", "(", "Message", "outMessage", ")", "{", "if", "(", "outMessage", ".", "getExchange", "(", ")", "==", "null", ")", "{", "return", ";", "}", "Message", "inMessage", "=", "outMessage", ".", "getExchange", "(", ")", ".", "getInMessage", "(", ")", ";", "if", "(", "inMessage", "==", "null", ")", "{", "return", ";", "}", "Collection", "<", "Attachment", ">", "atts", "=", "inMessage", ".", "getAttachments", "(", ")", ";", "if", "(", "atts", "!=", "null", ")", "{", "for", "(", "Attachment", "a", ":", "atts", ")", "{", "if", "(", "a", ".", "getDataHandler", "(", ")", ".", "getDataSource", "(", ")", "instanceof", "AttachmentDataSource", ")", "{", "try", "{", "(", "(", "AttachmentDataSource", ")", "a", ".", "getDataHandler", "(", ")", ".", "getDataSource", "(", ")", ")", ".", "cache", "(", "inMessage", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "Fault", "(", "e", ")", ";", "}", "}", "}", "}", "DelegatingInputStream", "in", "=", "inMessage", ".", "getContent", "(", "DelegatingInputStream", ".", "class", ")", ";", "if", "(", "in", "!=", "null", ")", "{", "in", ".", "cacheInput", "(", ")", ";", "}", "}"], "idx": 52026, "cwe": "CWE-399", "target": 1, "status": "VULNERABLE", "commit": "35cd29270b77b489cb23552637d66d47ce480f4c", "function_name": "cacheInput", "body_hash": "8f84196fec16d13bd6fde78deae2e7a8aa5da1a8"}
{"code": "private ServerWebExchange mapExchange(ServerWebExchange exchange, String methodParamValue) {\n\t\tHttpMethod httpMethod = HttpMethod.resolve(methodParamValue.toUpperCase(Locale.ENGLISH));\n\t\tAssert.notNull(httpMethod, () -> \"HttpMethod '\" + methodParamValue + \"' not supported\");\n\t\treturn exchange.mutate().request(builder -> builder.method(httpMethod)).build();\n\t}", "code_tokens": ["private", "ServerWebExchange", "mapExchange", "(", "ServerWebExchange", "exchange", ",", "String", "methodParamValue", ")", "{", "HttpMethod", "httpMethod", "=", "HttpMethod", ".", "resolve", "(", "methodParamValue", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ")", ";", "Assert", ".", "notNull", "(", "httpMethod", ",", "(", ")", "->", "\"", "HttpMethod '", "\"", "+", "methodParamValue", "+", "\"", "' not supported", "\"", ")", ";", "return", "exchange", ".", "mutate", "(", ")", ".", "request", "(", "builder", "->", "builder", ".", "method", "(", "httpMethod", ")", ")", ".", "build", "(", ")", ";", "}"], "idx": 103420, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "dac97f1b7dac3e70ff603fb6fc9f205b95dd6b01", "function_name": "mapExchange", "body_hash": "d4846a50d7c78bdb24247e1c4e9378781781e36d"}
{"code": "public Map<String, Object> loadExport(Owner owner, File exportFile,\n        ConflictOverrides overrides)\n        throws ImporterException {\n        File tmpDir = null;\n        InputStream exportStream = null;\n        Map<String, Object> result = new HashMap<String, Object>();\n        try {\n            tmpDir = new SyncUtils(config).makeTempDir(\"import\");\n            extractArchive(tmpDir, exportFile);\n\n            File signature = new File(tmpDir, \"signature\");\n            if (signature.length() == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The archive does not \" +\n                                          \"contain the required signature file\"));\n            }\n\n            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n                exportStream,\n                loadSignature(new File(tmpDir, \"signature\")));\n            if (!verifiedSignature) {\n                log.warn(\"Archive signature check failed.\");\n                if (!overrides\n                    .isForced(Conflict.SIGNATURE_CONFLICT)) {\n\n                    /*\n                     * Normally for import conflicts that can be overridden, we try to\n                     * report them all the first time so if the user intends to override,\n                     * they can do so with just one more request. However in the case of\n                     * a bad signature, we're going to report immediately due to the nature\n                     * of what this might mean.\n                     */\n                    throw new ImportConflictException(\n                        i18n.tr(\"Archive failed signature check\"),\n                        Conflict.SIGNATURE_CONFLICT);\n                }\n                else {\n                    log.warn(\"Ignoring signature check failure.\");\n                }\n            }\n\n            File consumerExport = new File(tmpDir, \"consumer_export.zip\");\n            File exportDir = extractArchive(tmpDir, consumerExport);\n\n            Map<String, File> importFiles = new HashMap<String, File>();\n            File[] listFiles = exportDir.listFiles();\n            if (listFiles == null || listFiles.length == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The consumer_export \" +\n                    \"archive has no contents\"));\n            }\n            for (File file : listFiles) {\n                importFiles.put(file.getName(), file);\n            }\n\n            ConsumerDto consumer = importObjects(owner, importFiles, overrides);\n            Meta m = mapper.readValue(importFiles.get(ImportFile.META.fileName()),\n                Meta.class);\n            result.put(\"consumer\", consumer);\n            result.put(\"meta\", m);\n            return result;\n        }\n        catch (FileNotFoundException fnfe) {\n            log.error(\"Archive file does not contain consumer_export.zip\", fnfe);\n            throw new ImportExtractionException(i18n.tr(\"The archive does not contain \" +\n                                           \"the required consumer_export.zip file\"));\n        }\n        catch (ConstraintViolationException cve) {\n            log.error(\"Failed to import archive\", cve);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                cve);\n        }\n        catch (PersistenceException pe) {\n            log.error(\"Failed to import archive\", pe);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                pe);\n        }\n        catch (IOException e) {\n            log.error(\"Exception caught importing archive\", e);\n            throw new ImportExtractionException(\"unable to extract export archive\", e);\n        }\n        catch (CertificateException e) {\n            log.error(\"Certificate exception checking archive signature\", e);\n            throw new ImportExtractionException(\n                \"Certificate exception checking archive signature\", e);\n        }\n        finally {\n            if (tmpDir != null) {\n                try {\n                    FileUtils.deleteDirectory(tmpDir);\n                }\n                catch (IOException e) {\n                    log.error(\"Failed to delete extracted export\", e);\n                }\n            }\n            if (exportStream != null) {\n                try {\n                    exportStream.close();\n                }\n                catch (Exception e) {\n                    // nothing we can do.\n                }\n            }\n        }\n    }", "code_tokens": ["public", "Map", "<", "String", ",", "Object", ">", "loadExport", "(", "Owner", "owner", ",", "File", "exportFile", ",", "ConflictOverrides", "overrides", ")", "throws", "ImporterException", "{", "File", "tmpDir", "=", "null", ";", "InputStream", "exportStream", "=", "null", ";", "Map", "<", "String", ",", "Object", ">", "result", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "try", "{", "tmpDir", "=", "new", "SyncUtils", "(", "config", ")", ".", "makeTempDir", "(", "\"", "import", "\"", ")", ";", "extractArchive", "(", "tmpDir", ",", "exportFile", ")", ";", "File", "signature", "=", "new", "File", "(", "tmpDir", ",", "\"", "signature", "\"", ")", ";", "if", "(", "signature", ".", "length", "(", ")", "==", "0", ")", "{", "throw", "new", "ImportExtractionException", "(", "i18n", ".", "tr", "(", "\"", "The archive does not ", "\"", "+", "\"", "contain the required signature file", "\"", ")", ")", ";", "}", "exportStream", "=", "new", "FileInputStream", "(", "new", "File", "(", "tmpDir", ",", "\"", "consumer_export.zip", "\"", ")", ")", ";", "boolean", "verifiedSignature", "=", "pki", ".", "verifySHA256WithRSAHashWithUpstreamCACert", "(", "exportStream", ",", "loadSignature", "(", "new", "File", "(", "tmpDir", ",", "\"", "signature", "\"", ")", ")", ")", ";", "if", "(", "!", "verifiedSignature", ")", "{", "log", ".", "warn", "(", "\"", "Archive signature check failed.", "\"", ")", ";", "if", "(", "!", "overrides", ".", "isForced", "(", "Conflict", ".", "SIGNATURE_CONFLICT", ")", ")", "{", "throw", "new", "ImportConflictException", "(", "i18n", ".", "tr", "(", "\"", "Archive failed signature check", "\"", ")", ",", "Conflict", ".", "SIGNATURE_CONFLICT", ")", ";", "}", "else", "{", "log", ".", "warn", "(", "\"", "Ignoring signature check failure.", "\"", ")", ";", "}", "}", "File", "consumerExport", "=", "new", "File", "(", "tmpDir", ",", "\"", "consumer_export.zip", "\"", ")", ";", "File", "exportDir", "=", "extractArchive", "(", "tmpDir", ",", "consumerExport", ")", ";", "Map", "<", "String", ",", "File", ">", "importFiles", "=", "new", "HashMap", "<", "String", ",", "File", ">", "(", ")", ";", "File", "[", "]", "listFiles", "=", "exportDir", ".", "listFiles", "(", ")", ";", "if", "(", "listFiles", "==", "null", "||", "listFiles", ".", "length", "==", "0", ")", "{", "throw", "new", "ImportExtractionException", "(", "i18n", ".", "tr", "(", "\"", "The consumer_export ", "\"", "+", "\"", "archive has no contents", "\"", ")", ")", ";", "}", "for", "(", "File", "file", ":", "listFiles", ")", "{", "importFiles", ".", "put", "(", "file", ".", "getName", "(", ")", ",", "file", ")", ";", "}", "ConsumerDto", "consumer", "=", "importObjects", "(", "owner", ",", "importFiles", ",", "overrides", ")", ";", "Meta", "m", "=", "mapper", ".", "readValue", "(", "importFiles", ".", "get", "(", "ImportFile", ".", "META", ".", "fileName", "(", ")", ")", ",", "Meta", ".", "class", ")", ";", "result", ".", "put", "(", "\"", "consumer", "\"", ",", "consumer", ")", ";", "result", ".", "put", "(", "\"", "meta", "\"", ",", "m", ")", ";", "return", "result", ";", "}", "catch", "(", "FileNotFoundException", "fnfe", ")", "{", "log", ".", "error", "(", "\"", "Archive file does not contain consumer_export.zip", "\"", ",", "fnfe", ")", ";", "throw", "new", "ImportExtractionException", "(", "i18n", ".", "tr", "(", "\"", "The archive does not contain ", "\"", "+", "\"", "the required consumer_export.zip file", "\"", ")", ")", ";", "}", "catch", "(", "ConstraintViolationException", "cve", ")", "{", "log", ".", "error", "(", "\"", "Failed to import archive", "\"", ",", "cve", ")", ";", "throw", "new", "ImporterException", "(", "i18n", ".", "tr", "(", "\"", "Failed to import archive", "\"", ")", ",", "cve", ")", ";", "}", "catch", "(", "PersistenceException", "pe", ")", "{", "log", ".", "error", "(", "\"", "Failed to import archive", "\"", ",", "pe", ")", ";", "throw", "new", "ImporterException", "(", "i18n", ".", "tr", "(", "\"", "Failed to import archive", "\"", ")", ",", "pe", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"", "Exception caught importing archive", "\"", ",", "e", ")", ";", "throw", "new", "ImportExtractionException", "(", "\"", "unable to extract export archive", "\"", ",", "e", ")", ";", "}", "catch", "(", "CertificateException", "e", ")", "{", "log", ".", "error", "(", "\"", "Certificate exception checking archive signature", "\"", ",", "e", ")", ";", "throw", "new", "ImportExtractionException", "(", "\"", "Certificate exception checking archive signature", "\"", ",", "e", ")", ";", "}", "finally", "{", "if", "(", "tmpDir", "!=", "null", ")", "{", "try", "{", "FileUtils", ".", "deleteDirectory", "(", "tmpDir", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"", "Failed to delete extracted export", "\"", ",", "e", ")", ";", "}", "}", "if", "(", "exportStream", "!=", "null", ")", "{", "try", "{", "exportStream", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "}", "}", "}", "}"], "idx": 34526, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "f4d93230e58b969c506b4c9778e04482a059b08c", "function_name": "loadExport", "body_hash": "27608d5c2b6014c00b3ba1d38e15e8d313976e69"}
{"code": "@Override\n        public int fill(ByteBuffer buffer) throws IOException\n        {\n            try\n            {\n                synchronized (_decryptedEndPoint)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\">fill {}\", SslConnection.this);\n\n                    int filled = -2;\n                    try\n                    {\n                        if (_fillState != FillState.IDLE)\n                            return filled = 0;\n\n                        // Do we already have some decrypted data?\n                        if (BufferUtil.hasContent(_decryptedInput))\n                            return filled = BufferUtil.append(buffer, _decryptedInput);\n\n                        // loop filling and unwrapping until we have something\n                        while (true)\n                        {\n                            HandshakeStatus status = _sslEngine.getHandshakeStatus();\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"fill {}\", status);\n                            switch (status)\n                            {\n                                case NEED_UNWRAP:\n                                case NOT_HANDSHAKING:\n                                    break;\n\n                                case NEED_TASK:\n                                    _sslEngine.getDelegatedTask().run();\n                                    continue;\n\n                                case NEED_WRAP:\n                                    if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER))\n                                    {\n                                        Throwable failure = _failure;\n                                        if (failure != null)\n                                            rethrow(failure);\n                                        if (_sslEngine.isInboundDone())\n                                            return filled = -1;\n                                        continue;\n                                    }\n                                    // Handle in needsFillInterest().\n                                    return filled = 0;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected HandshakeStatus \" + status);\n                            }\n\n                            acquireEncryptedInput();\n\n                            // can we use the passed buffer if it is big enough\n                            ByteBuffer appIn;\n                            int appBufferSize = getApplicationBufferSize();\n                            if (_decryptedInput == null)\n                            {\n                                if (BufferUtil.space(buffer) > appBufferSize)\n                                    appIn = buffer;\n                                else\n                                    appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);\n                            }\n                            else\n                            {\n                                appIn = _decryptedInput;\n                                BufferUtil.compact(_encryptedInput);\n                            }\n\n                            // Let's try reading some encrypted data... even if we have some already.\n                            int netFilled = networkFill(_encryptedInput);\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"net filled={}\", netFilled);\n\n                            // Workaround for Java 11 behavior.\n                            if (netFilled < 0 && isHandshakeInitial() && BufferUtil.isEmpty(_encryptedInput))\n                                closeInbound();\n\n                            if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone())\n                                throw new SSLHandshakeException(\"Closed during handshake\");\n\n                            if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE))\n                            {\n                                if (LOG.isDebugEnabled())\n                                    LOG.debug(\"fill starting handshake {}\", SslConnection.this);\n                            }\n\n                            // Let's unwrap even if we have no net data because in that\n                            // case we want to fall through to the handshake handling\n                            int pos = BufferUtil.flipToFill(appIn);\n                            SSLEngineResult unwrapResult;\n                            try\n                            {\n                                _underflown = false;\n                                unwrapResult = unwrap(_sslEngine, _encryptedInput, appIn);\n                            }\n                            finally\n                            {\n                                BufferUtil.flipToFlush(appIn, pos);\n                            }\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}\",\n                                    netFilled,\n                                    StringUtil.replace(unwrapResult.toString(), '\\n', ' '),\n                                    BufferUtil.toSummaryString(_encryptedInput),\n                                    BufferUtil.toDetailString(appIn),\n                                    BufferUtil.toDetailString(buffer));\n\n                            SSLEngineResult.Status unwrap = unwrapResult.getStatus();\n\n                            // Extra check on unwrapResultStatus == OK with zero bytes consumed\n                            // or produced is due to an SSL client on Android (see bug #454773).\n                            if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0)\n                                unwrap = Status.BUFFER_UNDERFLOW;\n\n                            switch (unwrap)\n                            {\n                                case CLOSED:\n                                    Throwable failure = _failure;\n                                    if (failure != null)\n                                        rethrow(failure);\n                                    return filled = -1;\n\n                                case BUFFER_UNDERFLOW:\n                                    if (netFilled > 0)\n                                        continue; // try filling some more\n                                    _underflown = true;\n                                    if (netFilled < 0 && _sslEngine.getUseClientMode())\n                                    {\n                                        Throwable closeFailure = closeInbound();\n                                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                                        {\n                                            Throwable handshakeFailure = new SSLHandshakeException(\"Abruptly closed by peer\");\n                                            if (closeFailure != null)\n                                                handshakeFailure.initCause(closeFailure);\n                                            throw handshakeFailure;\n                                        }\n                                        return filled = -1;\n                                    }\n                                    return filled = netFilled;\n\n                                case BUFFER_OVERFLOW:\n                                    // It's possible that SSLSession.applicationBufferSize has been expanded\n                                    // by the SSLEngine implementation. Unwrapping a large encrypted buffer\n                                    // causes BUFFER_OVERFLOW because the (old) applicationBufferSize is\n                                    // too small. Release the decrypted input buffer so it will be re-acquired\n                                    // with the larger capacity.\n                                    // See also system property \"jsse.SSLEngine.acceptLargeFragments\".\n                                    if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize())\n                                    {\n                                        releaseDecryptedInputBuffer();\n                                        continue;\n                                    }\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n\n                                case OK:\n                                    if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED)\n                                        handshakeSucceeded();\n\n                                    if (isRenegotiating() && !allowRenegotiate())\n                                        return filled = -1;\n\n                                    // If bytes were produced, don't bother with the handshake status;\n                                    // pass the decrypted data to the application, which will perform\n                                    // another call to fill() or flush().\n                                    if (unwrapResult.bytesProduced() > 0)\n                                    {\n                                        if (appIn == buffer)\n                                            return filled = unwrapResult.bytesProduced();\n                                        return filled = BufferUtil.append(buffer, _decryptedInput);\n                                    }\n\n                                    break;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n                            }\n                        }\n                    }\n                    catch (Throwable x)\n                    {\n                        Throwable f = handleException(x, \"fill\");\n                        Throwable failure = handshakeFailed(f);\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));\n                        }\n                        throw failure;\n                    }\n                    finally\n                    {\n                        releaseEncryptedInputBuffer();\n                        releaseDecryptedInputBuffer();\n\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());\n                        }\n\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"<fill f={} uf={} {}\", filled, _underflown, SslConnection.this);\n                    }\n                }\n            }\n            catch (Throwable x)\n            {\n                close(x);\n                rethrow(x);\n                // Never reached.\n                throw new AssertionError();\n            }\n        }", "code_tokens": ["@", "Override", "public", "int", "fill", "(", "ByteBuffer", "buffer", ")", "throws", "IOException", "{", "try", "{", "synchronized", "(", "_decryptedEndPoint", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", ">fill {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "int", "filled", "=", "-", "2", ";", "try", "{", "if", "(", "_fillState", "!=", "FillState", ".", "IDLE", ")", "return", "filled", "=", "0", ";", "if", "(", "BufferUtil", ".", "hasContent", "(", "_decryptedInput", ")", ")", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "while", "(", "true", ")", "{", "HandshakeStatus", "status", "=", "_sslEngine", ".", "getHandshakeStatus", "(", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill {}", "\"", ",", "status", ")", ";", "switch", "(", "status", ")", "{", "case", "NEED_UNWRAP", ":", "case", "NOT_HANDSHAKING", ":", "break", ";", "case", "NEED_TASK", ":", "_sslEngine", ".", "getDelegatedTask", "(", ")", ".", "run", "(", ")", ";", "continue", ";", "case", "NEED_WRAP", ":", "if", "(", "_flushState", "==", "FlushState", ".", "IDLE", "&&", "flush", "(", "BufferUtil", ".", "EMPTY_BUFFER", ")", ")", "{", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "if", "(", "_sslEngine", ".", "isInboundDone", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "continue", ";", "}", "return", "filled", "=", "0", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected HandshakeStatus ", "\"", "+", "status", ")", ";", "}", "acquireEncryptedInput", "(", ")", ";", "ByteBuffer", "appIn", ";", "int", "appBufferSize", "=", "getApplicationBufferSize", "(", ")", ";", "if", "(", "_decryptedInput", "==", "null", ")", "{", "if", "(", "BufferUtil", ".", "space", "(", "buffer", ")", ">", "appBufferSize", ")", "appIn", "=", "buffer", ";", "else", "appIn", "=", "_decryptedInput", "=", "_bufferPool", ".", "acquire", "(", "appBufferSize", ",", "_decryptedDirectBuffers", ")", ";", "}", "else", "{", "appIn", "=", "_decryptedInput", ";", "BufferUtil", ".", "compact", "(", "_encryptedInput", ")", ";", "}", "int", "netFilled", "=", "networkFill", "(", "_encryptedInput", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "net filled={}", "\"", ",", "netFilled", ")", ";", "if", "(", "netFilled", "<", "0", "&&", "isHandshakeInitial", "(", ")", "&&", "BufferUtil", ".", "isEmpty", "(", "_encryptedInput", ")", ")", "closeInbound", "(", ")", ";", "if", "(", "netFilled", ">", "0", "&&", "!", "isHandshakeComplete", "(", ")", "&&", "isOutboundDone", "(", ")", ")", "throw", "new", "SSLHandshakeException", "(", "\"", "Closed during handshake", "\"", ")", ";", "if", "(", "_handshake", ".", "compareAndSet", "(", "HandshakeState", ".", "INITIAL", ",", "HandshakeState", ".", "HANDSHAKE", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill starting handshake {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "}", "int", "pos", "=", "BufferUtil", ".", "flipToFill", "(", "appIn", ")", ";", "SSLEngineResult", "unwrapResult", ";", "try", "{", "_underflown", "=", "false", ";", "unwrapResult", "=", "unwrap", "(", "_sslEngine", ",", "_encryptedInput", ",", "appIn", ")", ";", "}", "finally", "{", "BufferUtil", ".", "flipToFlush", "(", "appIn", ",", "pos", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}", "\"", ",", "netFilled", ",", "StringUtil", ".", "replace", "(", "unwrapResult", ".", "toString", "(", ")", ",", "'\\n'", ",", "' '", ")", ",", "BufferUtil", ".", "toSummaryString", "(", "_encryptedInput", ")", ",", "BufferUtil", ".", "toDetailString", "(", "appIn", ")", ",", "BufferUtil", ".", "toDetailString", "(", "buffer", ")", ")", ";", "SSLEngineResult", ".", "Status", "unwrap", "=", "unwrapResult", ".", "getStatus", "(", ")", ";", "if", "(", "unwrap", "==", "Status", ".", "OK", "&&", "unwrapResult", ".", "bytesConsumed", "(", ")", "==", "0", "&&", "unwrapResult", ".", "bytesProduced", "(", ")", "==", "0", ")", "unwrap", "=", "Status", ".", "BUFFER_UNDERFLOW", ";", "switch", "(", "unwrap", ")", "{", "case", "CLOSED", ":", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "return", "filled", "=", "-", "1", ";", "case", "BUFFER_UNDERFLOW", ":", "if", "(", "netFilled", ">", "0", ")", "continue", ";", "_underflown", "=", "true", ";", "if", "(", "netFilled", "<", "0", "&&", "_sslEngine", ".", "getUseClientMode", "(", ")", ")", "{", "Throwable", "closeFailure", "=", "closeInbound", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "Throwable", "handshakeFailure", "=", "new", "SSLHandshakeException", "(", "\"", "Abruptly closed by peer", "\"", ")", ";", "if", "(", "closeFailure", "!=", "null", ")", "handshakeFailure", ".", "initCause", "(", "closeFailure", ")", ";", "throw", "handshakeFailure", ";", "}", "return", "filled", "=", "-", "1", ";", "}", "return", "filled", "=", "netFilled", ";", "case", "BUFFER_OVERFLOW", ":", "if", "(", "BufferUtil", ".", "isEmpty", "(", "_decryptedInput", ")", "&&", "appBufferSize", "<", "getApplicationBufferSize", "(", ")", ")", "{", "releaseDecryptedInputBuffer", "(", ")", ";", "continue", ";", "}", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "case", "OK", ":", "if", "(", "unwrapResult", ".", "getHandshakeStatus", "(", ")", "==", "HandshakeStatus", ".", "FINISHED", ")", "handshakeSucceeded", "(", ")", ";", "if", "(", "isRenegotiating", "(", ")", "&&", "!", "allowRenegotiate", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "if", "(", "unwrapResult", ".", "bytesProduced", "(", ")", ">", "0", ")", "{", "if", "(", "appIn", "==", "buffer", ")", "return", "filled", "=", "unwrapResult", ".", "bytesProduced", "(", ")", ";", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "}", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "Throwable", "f", "=", "handleException", "(", "x", ",", "\"", "fill", "\"", ")", ";", "Throwable", "failure", "=", "handshakeFailed", "(", "f", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "onFail", "(", "failure", ")", ")", ";", "}", "throw", "failure", ";", "}", "finally", "{", "releaseEncryptedInputBuffer", "(", ")", ";", "releaseDecryptedInputBuffer", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "completeWrite", "(", ")", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "<fill f={} uf={} {}", "\"", ",", "filled", ",", "_underflown", ",", "SslConnection", ".", "this", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "close", "(", "x", ")", ";", "rethrow", "(", "x", ")", ";", "throw", "new", "AssertionError", "(", ")", ";", "}", "}"], "idx": 65105, "cwe": "CWE-59", "target": 1, "status": "VULNERABLE", "commit": "00d379c94ba865dced2025c2d1bc3e2e0e41e880", "function_name": "fill", "body_hash": "dee831a611f1e055c875370849978cde2e97681a"}
{"code": "private void mapAndDelegateIncomingCommand(final String tenantId, final String originalDeviceId,\n            final CommandContext originalCommandContext) {\n        // note that the command might be invalid here - a matching local handler to reject it (and report metrics) shall be found in that case\n        final Command originalCommand = originalCommandContext.getCommand();\n\n        // determine last used gateway device id\n        LOG.trace(\"determine command target gateway/adapter for [{}]\", originalCommand);\n        final Future<JsonObject> commandTargetFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId,\n                originalDeviceId, originalCommandContext.getTracingContext());\n\n        commandTargetFuture.onComplete(commandTargetResult -> {\n            if (commandTargetResult.succeeded()) {\n                final String targetDeviceId = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n                final String targetAdapterInstance = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n\n                delegateIncomingCommand(tenantId, originalDeviceId, originalCommandContext, targetDeviceId, targetAdapterInstance);\n\n            } else {\n                if (commandTargetResult.cause() instanceof ServiceInvocationException\n                        && ((ServiceInvocationException) commandTargetResult.cause()).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n                    LOG.debug(\"no target adapter instance found for command for device {}\", originalDeviceId);\n                    TracingHelper.logError(originalCommandContext.getTracingSpan(),\n                            \"no target adapter instance found for command with device id \" + originalDeviceId);\n                } else {\n                    LOG.debug(\"error getting target gateway and adapter instance for command with device id {}\",\n                            originalDeviceId, commandTargetResult.cause());\n                    TracingHelper.logError(originalCommandContext.getTracingSpan(),\n                            \"error getting target gateway and adapter instance for command with device id \" + originalDeviceId,\n                            commandTargetResult.cause());\n                }\n                originalCommandContext.release();\n            }\n        });\n    }", "code_tokens": ["private", "void", "mapAndDelegateIncomingCommand", "(", "final", "String", "tenantId", ",", "final", "String", "originalDeviceId", ",", "final", "CommandContext", "originalCommandContext", ")", "{", "final", "Command", "originalCommand", "=", "originalCommandContext", ".", "getCommand", "(", ")", ";", "LOG", ".", "trace", "(", "\"", "determine command target gateway/adapter for [{}]", "\"", ",", "originalCommand", ")", ";", "final", "Future", "<", "JsonObject", ">", "commandTargetFuture", "=", "commandTargetMapper", ".", "getTargetGatewayAndAdapterInstance", "(", "tenantId", ",", "originalDeviceId", ",", "originalCommandContext", ".", "getTracingContext", "(", ")", ")", ";", "commandTargetFuture", ".", "onComplete", "(", "commandTargetResult", "->", "{", "if", "(", "commandTargetResult", ".", "succeeded", "(", ")", ")", "{", "final", "String", "targetDeviceId", "=", "commandTargetResult", ".", "result", "(", ")", ".", "getString", "(", "DeviceConnectionConstants", ".", "FIELD_PAYLOAD_DEVICE_ID", ")", ";", "final", "String", "targetAdapterInstance", "=", "commandTargetResult", ".", "result", "(", ")", ".", "getString", "(", "DeviceConnectionConstants", ".", "FIELD_ADAPTER_INSTANCE_ID", ")", ";", "delegateIncomingCommand", "(", "tenantId", ",", "originalDeviceId", ",", "originalCommandContext", ",", "targetDeviceId", ",", "targetAdapterInstance", ")", ";", "}", "else", "{", "if", "(", "commandTargetResult", ".", "cause", "(", ")", "instanceof", "ServiceInvocationException", "&&", "(", "(", "ServiceInvocationException", ")", "commandTargetResult", ".", "cause", "(", ")", ")", ".", "getErrorCode", "(", ")", "==", "HttpURLConnection", ".", "HTTP_NOT_FOUND", ")", "{", "LOG", ".", "debug", "(", "\"", "no target adapter instance found for command for device {}", "\"", ",", "originalDeviceId", ")", ";", "TracingHelper", ".", "logError", "(", "originalCommandContext", ".", "getTracingSpan", "(", ")", ",", "\"", "no target adapter instance found for command with device id ", "\"", "+", "originalDeviceId", ")", ";", "}", "else", "{", "LOG", ".", "debug", "(", "\"", "error getting target gateway and adapter instance for command with device id {}", "\"", ",", "originalDeviceId", ",", "commandTargetResult", ".", "cause", "(", ")", ")", ";", "TracingHelper", ".", "logError", "(", "originalCommandContext", ".", "getTracingSpan", "(", ")", ",", "\"", "error getting target gateway and adapter instance for command with device id ", "\"", "+", "originalDeviceId", ",", "commandTargetResult", ".", "cause", "(", ")", ")", ";", "}", "originalCommandContext", ".", "release", "(", ")", ";", "}", "}", ")", ";", "}"], "idx": 83907, "cwe": "CWE-862", "target": 1, "status": "VULNERABLE", "commit": "0d2ab63347c52c8d4d9e3a2db2c86aba506115e2", "function_name": "mapAndDelegateIncomingCommand", "body_hash": "750ae8332f7a1863ce68ca0326c0c919ad3e12fc"}
{"code": "@Override\n        public boolean check(Object credentials)\n        {\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n\n            try\n            {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5)\n                {\n                    // Credentials are already a MD5 digest - assume it's in\n                    // form user:realm:password (we have no way to know since\n                    // it's a digest, alright?)\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                }\n                else\n                {\n                    // calc A1 digest\n                    md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                // calc A2 digest\n                md.reset();\n                md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                byte[] ha2 = md.digest();\n\n                // calc digest\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\"\n                // nc-value \":\" unq(cnonce-value) \":\" unq(qop-value) \":\" H(A2) )\n                // <\">\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2)\n                // ) > <\">\n\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                byte[] digest = md.digest();\n\n                // check digest\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n            }\n\n            return false;\n        }", "code_tokens": ["@", "Override", "public", "boolean", "check", "(", "Object", "credentials", ")", "{", "String", "password", "=", "(", "credentials", "instanceof", "String", ")", "?", "(", "String", ")", "credentials", ":", "credentials", ".", "toString", "(", ")", ";", "try", "{", "MessageDigest", "md", "=", "MessageDigest", ".", "getInstance", "(", "\"", "MD5", "\"", ")", ";", "byte", "[", "]", "ha1", ";", "if", "(", "credentials", "instanceof", "Credential", ".", "MD5", ")", "{", "ha1", "=", "(", "(", "Credential", ".", "MD5", ")", "credentials", ")", ".", "getDigest", "(", ")", ";", "}", "else", "{", "md", ".", "update", "(", "username", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "realm", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "password", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "ha1", "=", "md", ".", "digest", "(", ")", ";", "}", "md", ".", "reset", "(", ")", ";", "md", ".", "update", "(", "method", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "uri", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "byte", "[", "]", "ha2", "=", "md", ".", "digest", "(", ")", ";", "md", ".", "update", "(", "TypeUtil", ".", "toString", "(", "ha1", ",", "16", ")", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "nonce", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "nc", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "cnonce", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "qop", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "TypeUtil", ".", "toString", "(", "ha2", ",", "16", ")", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "byte", "[", "]", "digest", "=", "md", ".", "digest", "(", ")", ";", "return", "(", "TypeUtil", ".", "toString", "(", "digest", ",", "16", ")", ".", "equalsIgnoreCase", "(", "response", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "warn", "(", "e", ")", ";", "}", "return", "false", ";", "}"], "idx": 20321, "cwe": "CWE-203", "target": 1, "status": "VULNERABLE", "commit": "042f325f1cd6e7891d72c7e668f5947b5457dc02", "function_name": "check", "body_hash": "f6c68634ce2c94096e850efffa4097b7f9a020dd"}
{"code": "private Document getXmlDoc() {\n    if (this.xmlDoc != null) {\n      return this.xmlDoc;\n    }\n\n    try {\n      this.xmlDoc = DocumentBuilderFactory\n        .newInstance()\n        .newDocumentBuilder()\n        .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));\n      return xmlDoc;\n    } catch (SAXException | IOException | ParserConfigurationException e) {\n      throw new RuntimeException(\"\u975e\u6cd5\u7684xml\u6587\u672c\u5185\u5bb9\uff1a\" + this.xmlString);\n    }\n\n  }", "code_tokens": ["private", "Document", "getXmlDoc", "(", ")", "{", "if", "(", "this", ".", "xmlDoc", "!=", "null", ")", "{", "return", "this", ".", "xmlDoc", ";", "}", "try", "{", "this", ".", "xmlDoc", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ".", "newDocumentBuilder", "(", ")", ".", "parse", "(", "new", "ByteArrayInputStream", "(", "this", ".", "xmlString", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ")", ")", ";", "return", "xmlDoc", ";", "}", "catch", "(", "SAXException", "|", "IOException", "|", "ParserConfigurationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "\u975e\u6cd5\u7684xml\u6587\u672c\u5185\u5bb9\uff1a", "\"", "+", "this", ".", "xmlString", ")", ";", "}", "}"], "idx": 70825, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "6272639f02e397fed40828a2d0da66c30264bc0e", "function_name": "getXmlDoc", "body_hash": "26144956dd25f763678d982808a260d3e27e99be"}
{"code": "@Override\n    protected JsonNode _at(JsonPointer ptr) {\n        // 02-Jan-2020, tatu: As per [databind#3003] must return `null` and NOT\n        //    \"missing node\"\n        return null;\n    }", "code_tokens": ["@", "Override", "protected", "JsonNode", "_at", "(", "JsonPointer", "ptr", ")", "{", "return", "null", ";", "}"], "idx": 62591, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "972db892f62d66c09d7e8056f87923859bd8086b", "function_name": "_at", "body_hash": "40b74e7a0ad56a6abb266ee0284e2a6f74f31e6e"}
{"code": "@Override\n    public Argument<Session> argumentType() {\n        return Argument.of(Session.class);\n    }", "code_tokens": ["@", "Override", "public", "Argument", "<", "Session", ">", "argumentType", "(", ")", "{", "return", "Argument", ".", "of", "(", "Session", ".", "class", ")", ";", "}"], "idx": 52664, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3", "function_name": "argumentType", "body_hash": "1e188a94efa41f151dd135be1ff1da6cd0384f7d"}
{"code": "@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }", "code_tokens": ["@", "Override", "public", "JsonDeserializer", "<", "Object", ">", "createBeanDeserializer", "(", "DeserializationContext", "ctxt", ",", "JavaType", "type", ",", "BeanDescription", "beanDesc", ")", "throws", "JsonMappingException", "{", "final", "DeserializationConfig", "config", "=", "ctxt", ".", "getConfig", "(", ")", ";", "JsonDeserializer", "<", "Object", ">", "custom", "=", "_findCustomBeanDeserializer", "(", "type", ",", "config", ",", "beanDesc", ")", ";", "if", "(", "custom", "!=", "null", ")", "{", "return", "custom", ";", "}", "if", "(", "type", ".", "isThrowable", "(", ")", ")", "{", "return", "buildThrowableDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "}", "if", "(", "type", ".", "isAbstract", "(", ")", "&&", "!", "type", ".", "isPrimitive", "(", ")", "&&", "!", "type", ".", "isEnumType", "(", ")", ")", "{", "JavaType", "concreteType", "=", "materializeAbstractType", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "if", "(", "concreteType", "!=", "null", ")", "{", "beanDesc", "=", "config", ".", "introspect", "(", "concreteType", ")", ";", "return", "buildBeanDeserializer", "(", "ctxt", ",", "concreteType", ",", "beanDesc", ")", ";", "}", "}", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "JsonDeserializer", "<", "Object", ">", "deser", "=", "(", "JsonDeserializer", "<", "Object", ">", ")", "findStdDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "if", "(", "deser", "!=", "null", ")", "{", "return", "deser", ";", "}", "if", "(", "!", "isPotentialBeanType", "(", "type", ".", "getRawClass", "(", ")", ")", ")", "{", "return", "null", ";", "}", "return", "buildBeanDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "}"], "idx": 2533, "cwe": "CWE-184", "target": 1, "status": "VULNERABLE", "commit": "60d459cedcf079c6106ae7da2ac562bc32dcabe1", "function_name": "createBeanDeserializer", "body_hash": "04def0a3b248f04c26289e43584c09aac9f35348"}
{"code": "void doMaxAttributesFails() throws Exception\r\n   {\r\n      System.out.println(\"entering doMaxAttributesFails()\");\r\n      ClientRequest request = new ClientRequest(generateURL(\"/test\"));\r\n      request.body(\"application/xml\", bigAttributeDoc);\r\n      ClientResponse<?> response = request.post();\r\n      System.out.println(\"doMaxAttributesFails() status: \" + response.getStatus());\r\n      String entity = response.getEntity(String.class);\r\n      System.out.println(\"doMaxAttributesFails() result: \" + entity);\r\n      Assert.assertEquals(400, response.getStatus());\r\n      Assert.assertTrue(entity.contains(\"org.xml.sax.SAXParseException\"));\r\n      Assert.assertTrue(entity.contains(\"has more than \\\"10,00\"));\r\n      int pos = entity.indexOf(\"has more than \\\"10,00\");\r\n      Assert.assertTrue(entity.substring(pos).contains(\"attributes\"));\r\n   }", "code_tokens": ["void", "doMaxAttributesFails", "(", ")", "throws", "Exception", "{", "System", ".", "out", ".", "println", "(", "\"", "entering doMaxAttributesFails()", "\"", ")", ";", "ClientRequest", "request", "=", "new", "ClientRequest", "(", "generateURL", "(", "\"", "/test", "\"", ")", ")", ";", "request", ".", "body", "(", "\"", "application/xml", "\"", ",", "bigAttributeDoc", ")", ";", "ClientResponse", "<", "?", ">", "response", "=", "request", ".", "post", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "doMaxAttributesFails() status: ", "\"", "+", "response", ".", "getStatus", "(", ")", ")", ";", "String", "entity", "=", "response", ".", "getEntity", "(", "String", ".", "class", ")", ";", "System", ".", "out", ".", "println", "(", "\"", "doMaxAttributesFails() result: ", "\"", "+", "entity", ")", ";", "Assert", ".", "assertEquals", "(", "400", ",", "response", ".", "getStatus", "(", ")", ")", ";", "Assert", ".", "assertTrue", "(", "entity", ".", "contains", "(", "\"", "org.xml.sax.SAXParseException", "\"", ")", ")", ";", "Assert", ".", "assertTrue", "(", "entity", ".", "contains", "(", "\"", "has more than ", "\\\"", "10,00", "\"", ")", ")", ";", "int", "pos", "=", "entity", ".", "indexOf", "(", "\"", "has more than ", "\\\"", "10,00", "\"", ")", ";", "Assert", ".", "assertTrue", "(", "entity", ".", "substring", "(", "pos", ")", ".", "contains", "(", "\"", "attributes", "\"", ")", ")", ";", "}"], "idx": 10788, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "7a0b80f57f9258e035b9584ddaa72414454e07b2", "function_name": "doMaxAttributesFails", "body_hash": "3f86d9d448c7a5c3c1f2036921ea9a665b168c67"}
{"code": "public void testEncryptHeader() throws Exception {\n        ENCRYPT.EncryptHeader hdr=new ENCRYPT.EncryptHeader((short)1, null);\n        _testSize(hdr);\n        hdr=new ENCRYPT.EncryptHeader((short)2, \"Hello world\");\n        _testSize(hdr);\n        EncryptHeader hdr2=new EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});\n        _testSize(hdr2);\n        hdr2=new EncryptHeader((byte)2, \"Hello world\".getBytes());\n        _testSize(hdr2);\n    }", "code_tokens": ["public", "void", "testEncryptHeader", "(", ")", "throws", "Exception", "{", "ENCRYPT", ".", "EncryptHeader", "hdr", "=", "new", "ENCRYPT", ".", "EncryptHeader", "(", "(", "short", ")", "1", ",", "null", ")", ";", "_testSize", "(", "hdr", ")", ";", "hdr", "=", "new", "ENCRYPT", ".", "EncryptHeader", "(", "(", "short", ")", "2", ",", "\"", "Hello world", "\"", ")", ";", "_testSize", "(", "hdr", ")", ";", "EncryptHeader", "hdr2", "=", "new", "EncryptHeader", "(", "(", "byte", ")", "1", ",", "new", "byte", "[", "]", "{", "'b'", ",", "'e'", ",", "'l'", ",", "'a'", "}", ")", ";", "_testSize", "(", "hdr2", ")", ";", "hdr2", "=", "new", "EncryptHeader", "(", "(", "byte", ")", "2", ",", "\"", "Hello world", "\"", ".", "getBytes", "(", ")", ")", ";", "_testSize", "(", "hdr2", ")", ";", "}"], "idx": 108722, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "c3ad22234ef84d06d04d908b3c94c0d11df8afd", "function_name": "testEncryptHeader", "body_hash": "39441b54b5b3f53f7a31b48f3051dd3f71791bc9"}
{"code": "protected Object readResolve()\n        throws ObjectStreamException {\n        AbstractBrokerFactory factory = getPooledFactory(_conf);\n        if (factory != null)\n            return factory;\n\n        // reset these transient fields to empty values\n        _transactional = new ConcurrentHashMap();\n        _brokers = new ConcurrentReferenceHashSet(\n                ConcurrentReferenceHashSet.WEAK);\n\n        makeReadOnly();\n        return this;\n    }", "code_tokens": ["protected", "Object", "readResolve", "(", ")", "throws", "ObjectStreamException", "{", "AbstractBrokerFactory", "factory", "=", "getPooledFactory", "(", "_conf", ")", ";", "if", "(", "factory", "!=", "null", ")", "return", "factory", ";", "_transactional", "=", "new", "ConcurrentHashMap", "(", ")", ";", "_brokers", "=", "new", "ConcurrentReferenceHashSet", "(", "ConcurrentReferenceHashSet", ".", "WEAK", ")", ";", "makeReadOnly", "(", ")", ";", "return", "this", ";", "}"], "idx": 33007, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "01bc0d257b38743372af91cb88269524634db7d3", "function_name": "readResolve", "body_hash": "4948642d2bdd0d1be30d424268e5550b2dee8133"}
{"code": "@SuppressWarnings(\"ACL.impersonate\")\n    private void loginAndTakeBack(StaplerRequest req, StaplerResponse rsp, User u) throws ServletException, IOException {\n        // ... and let him login\n        Authentication a = new UsernamePasswordAuthenticationToken(u.getId(),req.getParameter(\"password1\"));\n        a = this.getSecurityComponents().manager.authenticate(a);\n        SecurityContextHolder.getContext().setAuthentication(a);\n\n        // then back to top\n        req.getView(this,\"success.jelly\").forward(req,rsp);\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "ACL.impersonate", "\"", ")", "private", "void", "loginAndTakeBack", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ",", "User", "u", ")", "throws", "ServletException", ",", "IOException", "{", "Authentication", "a", "=", "new", "UsernamePasswordAuthenticationToken", "(", "u", ".", "getId", "(", ")", ",", "req", ".", "getParameter", "(", "\"", "password1", "\"", ")", ")", ";", "a", "=", "this", ".", "getSecurityComponents", "(", ")", ".", "manager", ".", "authenticate", "(", "a", ")", ";", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "setAuthentication", "(", "a", ")", ";", "req", ".", "getView", "(", "this", ",", "\"", "success.jelly", "\"", ")", ".", "forward", "(", "req", ",", "rsp", ")", ";", "}"], "idx": 50102, "cwe": "CWE-384", "target": 1, "status": "VULNERABLE", "commit": "517da6ed389f0a606dd9bb8595bc79fc93f4331c", "function_name": "loginAndTakeBack", "body_hash": "4d08545640b2384603878f15eff8f97981f13d76"}
{"code": "public void updateByXml(final InputStream source) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        Node previous = getNode();\n        if (previous == null) {\n            throw HttpResponses.notFound();\n        }\n        Node result = (Node)Jenkins.XSTREAM2.fromXML(source);\n        if (previous.getClass() != result.getClass()) {\n            // ensure node type doesn't change\n            throw HttpResponses.errorWithoutStack(SC_BAD_REQUEST, \"Node types do not match\");\n        }\n        Jenkins.get().getNodesObject().replaceNode(previous, result);\n    }", "code_tokens": ["public", "void", "updateByXml", "(", "final", "InputStream", "source", ")", "throws", "IOException", ",", "ServletException", "{", "checkPermission", "(", "CONFIGURE", ")", ";", "Node", "previous", "=", "getNode", "(", ")", ";", "if", "(", "previous", "==", "null", ")", "{", "throw", "HttpResponses", ".", "notFound", "(", ")", ";", "}", "Node", "result", "=", "(", "Node", ")", "Jenkins", ".", "XSTREAM2", ".", "fromXML", "(", "source", ")", ";", "if", "(", "previous", ".", "getClass", "(", ")", "!=", "result", ".", "getClass", "(", ")", ")", "{", "throw", "HttpResponses", ".", "errorWithoutStack", "(", "SC_BAD_REQUEST", ",", "\"", "Node types do not match", "\"", ")", ";", "}", "Jenkins", ".", "get", "(", ")", ".", "getNodesObject", "(", ")", ".", "replaceNode", "(", "previous", ",", "result", ")", ";", "}"], "idx": 6877, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "84210baed0c866bdee3e59271f98a767a14a5509", "function_name": "updateByXml", "body_hash": "22d83f08cff73af056077520a98c079d2d47ea8c"}
{"code": "@Override\n        public int fill(ByteBuffer buffer) throws IOException\n        {\n            try\n            {\n                synchronized (_decryptedEndPoint)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\">fill {}\", SslConnection.this);\n\n                    int filled = -2;\n                    try\n                    {\n                        if (_fillState != FillState.IDLE)\n                            return filled = 0;\n\n                        // Do we already have some decrypted data?\n                        if (BufferUtil.hasContent(_decryptedInput))\n                            return filled = BufferUtil.append(buffer, _decryptedInput);\n\n                        // loop filling and unwrapping until we have something\n                        while (true)\n                        {\n                            HandshakeStatus status = _sslEngine.getHandshakeStatus();\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"fill {}\", status);\n                            switch (status)\n                            {\n                                case NEED_UNWRAP:\n                                case NOT_HANDSHAKING:\n                                    break;\n\n                                case NEED_TASK:\n                                    _sslEngine.getDelegatedTask().run();\n                                    continue;\n\n                                case NEED_WRAP:\n                                    if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER))\n                                    {\n                                        Throwable failure = _failure;\n                                        if (failure != null)\n                                            rethrow(failure);\n                                        if (_sslEngine.isInboundDone())\n                                            return filled = -1;\n                                        continue;\n                                    }\n                                    // Handle in needsFillInterest().\n                                    return filled = 0;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected HandshakeStatus \" + status);\n                            }\n\n                            acquireEncryptedInput();\n\n                            // can we use the passed buffer if it is big enough\n                            ByteBuffer appIn;\n                            int appBufferSize = getApplicationBufferSize();\n                            if (_decryptedInput == null)\n                            {\n                                if (BufferUtil.space(buffer) > appBufferSize)\n                                    appIn = buffer;\n                                else\n                                    appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);\n                            }\n                            else\n                            {\n                                appIn = _decryptedInput;\n                                BufferUtil.compact(_encryptedInput);\n                            }\n\n                            // Let's try reading some encrypted data... even if we have some already.\n                            int netFilled = networkFill(_encryptedInput);\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"net filled={}\", netFilled);\n\n                            // Workaround for Java 11 behavior.\n                            if (netFilled < 0 && isHandshakeInitial() && BufferUtil.isEmpty(_encryptedInput))\n                                closeInbound();\n\n                            if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone())\n                                throw new SSLHandshakeException(\"Closed during handshake\");\n\n                            if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE))\n                            {\n                                if (LOG.isDebugEnabled())\n                                    LOG.debug(\"fill starting handshake {}\", SslConnection.this);\n                            }\n\n                            // Let's unwrap even if we have no net data because in that\n                            // case we want to fall through to the handshake handling\n                            int pos = BufferUtil.flipToFill(appIn);\n                            SSLEngineResult unwrapResult;\n                            try\n                            {\n                                _underflown = false;\n                                unwrapResult = unwrap(_sslEngine, _encryptedInput, appIn);\n                            }\n                            finally\n                            {\n                                BufferUtil.flipToFlush(appIn, pos);\n                            }\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}\",\n                                    netFilled,\n                                    StringUtil.replace(unwrapResult.toString(), '\\n', ' '),\n                                    BufferUtil.toSummaryString(_encryptedInput),\n                                    BufferUtil.toDetailString(appIn),\n                                    BufferUtil.toDetailString(buffer));\n\n                            SSLEngineResult.Status unwrap = unwrapResult.getStatus();\n\n                            // Extra check on unwrapResultStatus == OK with zero bytes consumed\n                            // or produced is due to an SSL client on Android (see bug #454773).\n                            if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0)\n                                unwrap = Status.BUFFER_UNDERFLOW;\n\n                            switch (unwrap)\n                            {\n                                case CLOSED:\n                                    Throwable failure = _failure;\n                                    if (failure != null)\n                                        rethrow(failure);\n                                    return filled = -1;\n\n                                case BUFFER_UNDERFLOW:\n                                    if (netFilled > 0)\n                                    {\n                                        if (BufferUtil.space(_encryptedInput) > 0)\n                                            continue; // try filling some more\n                                        BufferUtil.clear(_encryptedInput);\n                                        throw new SSLHandshakeException(\"Encrypted buffer max length exceeded\");\n                                    }\n                                    _underflown = true;\n                                    if (netFilled < 0 && _sslEngine.getUseClientMode())\n                                    {\n                                        Throwable closeFailure = closeInbound();\n                                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                                        {\n                                            Throwable handshakeFailure = new SSLHandshakeException(\"Abruptly closed by peer\");\n                                            if (closeFailure != null)\n                                                handshakeFailure.addSuppressed(closeFailure);\n                                            throw handshakeFailure;\n                                        }\n                                        return filled = -1;\n                                    }\n                                    return filled = netFilled;\n\n                                case BUFFER_OVERFLOW:\n                                    // It's possible that SSLSession.applicationBufferSize has been expanded\n                                    // by the SSLEngine implementation. Unwrapping a large encrypted buffer\n                                    // causes BUFFER_OVERFLOW because the (old) applicationBufferSize is\n                                    // too small. Release the decrypted input buffer so it will be re-acquired\n                                    // with the larger capacity.\n                                    // See also system property \"jsse.SSLEngine.acceptLargeFragments\".\n                                    if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize())\n                                    {\n                                        releaseDecryptedInputBuffer();\n                                        continue;\n                                    }\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n\n                                case OK:\n                                    if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED)\n                                        handshakeSucceeded();\n\n                                    if (isRenegotiating() && !allowRenegotiate())\n                                        return filled = -1;\n\n                                    // If bytes were produced, don't bother with the handshake status;\n                                    // pass the decrypted data to the application, which will perform\n                                    // another call to fill() or flush().\n                                    if (unwrapResult.bytesProduced() > 0)\n                                    {\n                                        if (appIn == buffer)\n                                            return filled = unwrapResult.bytesProduced();\n                                        return filled = BufferUtil.append(buffer, _decryptedInput);\n                                    }\n\n                                    break;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n                            }\n                        }\n                    }\n                    catch (Throwable x)\n                    {\n                        Throwable f = handleException(x, \"fill\");\n                        Throwable failure = handshakeFailed(f);\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));\n                        }\n                        throw failure;\n                    }\n                    finally\n                    {\n                        releaseEncryptedInputBuffer();\n                        releaseDecryptedInputBuffer();\n\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());\n                        }\n\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"<fill f={} uf={} {}\", filled, _underflown, SslConnection.this);\n                    }\n                }\n            }\n            catch (Throwable x)\n            {\n                close(x);\n                rethrow(x);\n                // Never reached.\n                throw new AssertionError();\n            }\n        }", "code_tokens": ["@", "Override", "public", "int", "fill", "(", "ByteBuffer", "buffer", ")", "throws", "IOException", "{", "try", "{", "synchronized", "(", "_decryptedEndPoint", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", ">fill {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "int", "filled", "=", "-", "2", ";", "try", "{", "if", "(", "_fillState", "!=", "FillState", ".", "IDLE", ")", "return", "filled", "=", "0", ";", "if", "(", "BufferUtil", ".", "hasContent", "(", "_decryptedInput", ")", ")", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "while", "(", "true", ")", "{", "HandshakeStatus", "status", "=", "_sslEngine", ".", "getHandshakeStatus", "(", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill {}", "\"", ",", "status", ")", ";", "switch", "(", "status", ")", "{", "case", "NEED_UNWRAP", ":", "case", "NOT_HANDSHAKING", ":", "break", ";", "case", "NEED_TASK", ":", "_sslEngine", ".", "getDelegatedTask", "(", ")", ".", "run", "(", ")", ";", "continue", ";", "case", "NEED_WRAP", ":", "if", "(", "_flushState", "==", "FlushState", ".", "IDLE", "&&", "flush", "(", "BufferUtil", ".", "EMPTY_BUFFER", ")", ")", "{", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "if", "(", "_sslEngine", ".", "isInboundDone", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "continue", ";", "}", "return", "filled", "=", "0", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected HandshakeStatus ", "\"", "+", "status", ")", ";", "}", "acquireEncryptedInput", "(", ")", ";", "ByteBuffer", "appIn", ";", "int", "appBufferSize", "=", "getApplicationBufferSize", "(", ")", ";", "if", "(", "_decryptedInput", "==", "null", ")", "{", "if", "(", "BufferUtil", ".", "space", "(", "buffer", ")", ">", "appBufferSize", ")", "appIn", "=", "buffer", ";", "else", "appIn", "=", "_decryptedInput", "=", "_bufferPool", ".", "acquire", "(", "appBufferSize", ",", "_decryptedDirectBuffers", ")", ";", "}", "else", "{", "appIn", "=", "_decryptedInput", ";", "BufferUtil", ".", "compact", "(", "_encryptedInput", ")", ";", "}", "int", "netFilled", "=", "networkFill", "(", "_encryptedInput", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "net filled={}", "\"", ",", "netFilled", ")", ";", "if", "(", "netFilled", "<", "0", "&&", "isHandshakeInitial", "(", ")", "&&", "BufferUtil", ".", "isEmpty", "(", "_encryptedInput", ")", ")", "closeInbound", "(", ")", ";", "if", "(", "netFilled", ">", "0", "&&", "!", "isHandshakeComplete", "(", ")", "&&", "isOutboundDone", "(", ")", ")", "throw", "new", "SSLHandshakeException", "(", "\"", "Closed during handshake", "\"", ")", ";", "if", "(", "_handshake", ".", "compareAndSet", "(", "HandshakeState", ".", "INITIAL", ",", "HandshakeState", ".", "HANDSHAKE", ")", ")", "{", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "fill starting handshake {}", "\"", ",", "SslConnection", ".", "this", ")", ";", "}", "int", "pos", "=", "BufferUtil", ".", "flipToFill", "(", "appIn", ")", ";", "SSLEngineResult", "unwrapResult", ";", "try", "{", "_underflown", "=", "false", ";", "unwrapResult", "=", "unwrap", "(", "_sslEngine", ",", "_encryptedInput", ",", "appIn", ")", ";", "}", "finally", "{", "BufferUtil", ".", "flipToFlush", "(", "appIn", ",", "pos", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}", "\"", ",", "netFilled", ",", "StringUtil", ".", "replace", "(", "unwrapResult", ".", "toString", "(", ")", ",", "'\\n'", ",", "' '", ")", ",", "BufferUtil", ".", "toSummaryString", "(", "_encryptedInput", ")", ",", "BufferUtil", ".", "toDetailString", "(", "appIn", ")", ",", "BufferUtil", ".", "toDetailString", "(", "buffer", ")", ")", ";", "SSLEngineResult", ".", "Status", "unwrap", "=", "unwrapResult", ".", "getStatus", "(", ")", ";", "if", "(", "unwrap", "==", "Status", ".", "OK", "&&", "unwrapResult", ".", "bytesConsumed", "(", ")", "==", "0", "&&", "unwrapResult", ".", "bytesProduced", "(", ")", "==", "0", ")", "unwrap", "=", "Status", ".", "BUFFER_UNDERFLOW", ";", "switch", "(", "unwrap", ")", "{", "case", "CLOSED", ":", "Throwable", "failure", "=", "_failure", ";", "if", "(", "failure", "!=", "null", ")", "rethrow", "(", "failure", ")", ";", "return", "filled", "=", "-", "1", ";", "case", "BUFFER_UNDERFLOW", ":", "if", "(", "netFilled", ">", "0", ")", "{", "if", "(", "BufferUtil", ".", "space", "(", "_encryptedInput", ")", ">", "0", ")", "continue", ";", "BufferUtil", ".", "clear", "(", "_encryptedInput", ")", ";", "throw", "new", "SSLHandshakeException", "(", "\"", "Encrypted buffer max length exceeded", "\"", ")", ";", "}", "_underflown", "=", "true", ";", "if", "(", "netFilled", "<", "0", "&&", "_sslEngine", ".", "getUseClientMode", "(", ")", ")", "{", "Throwable", "closeFailure", "=", "closeInbound", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "Throwable", "handshakeFailure", "=", "new", "SSLHandshakeException", "(", "\"", "Abruptly closed by peer", "\"", ")", ";", "if", "(", "closeFailure", "!=", "null", ")", "handshakeFailure", ".", "addSuppressed", "(", "closeFailure", ")", ";", "throw", "handshakeFailure", ";", "}", "return", "filled", "=", "-", "1", ";", "}", "return", "filled", "=", "netFilled", ";", "case", "BUFFER_OVERFLOW", ":", "if", "(", "BufferUtil", ".", "isEmpty", "(", "_decryptedInput", ")", "&&", "appBufferSize", "<", "getApplicationBufferSize", "(", ")", ")", "{", "releaseDecryptedInputBuffer", "(", ")", ";", "continue", ";", "}", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "case", "OK", ":", "if", "(", "unwrapResult", ".", "getHandshakeStatus", "(", ")", "==", "HandshakeStatus", ".", "FINISHED", ")", "handshakeSucceeded", "(", ")", ";", "if", "(", "isRenegotiating", "(", ")", "&&", "!", "allowRenegotiate", "(", ")", ")", "return", "filled", "=", "-", "1", ";", "if", "(", "unwrapResult", ".", "bytesProduced", "(", ")", ">", "0", ")", "{", "if", "(", "appIn", "==", "buffer", ")", "return", "filled", "=", "unwrapResult", ".", "bytesProduced", "(", ")", ";", "return", "filled", "=", "BufferUtil", ".", "append", "(", "buffer", ",", "_decryptedInput", ")", ";", "}", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unexpected unwrap result ", "\"", "+", "unwrap", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "Throwable", "f", "=", "handleException", "(", "x", ",", "\"", "fill", "\"", ")", ";", "Throwable", "failure", "=", "handshakeFailed", "(", "f", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "onFail", "(", "failure", ")", ")", ";", "}", "throw", "failure", ";", "}", "finally", "{", "releaseEncryptedInputBuffer", "(", ")", ";", "releaseDecryptedInputBuffer", "(", ")", ";", "if", "(", "_flushState", "==", "FlushState", ".", "WAIT_FOR_FILL", ")", "{", "_flushState", "=", "FlushState", ".", "IDLE", ";", "getExecutor", "(", ")", ".", "execute", "(", "(", ")", "->", "_decryptedEndPoint", ".", "getWriteFlusher", "(", ")", ".", "completeWrite", "(", ")", ")", ";", "}", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "LOG", ".", "debug", "(", "\"", "<fill f={} uf={} {}", "\"", ",", "filled", ",", "_underflown", ",", "SslConnection", ".", "this", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "x", ")", "{", "close", "(", "x", ")", ";", "rethrow", "(", "x", ")", ";", "throw", "new", "AssertionError", "(", ")", ";", "}", "}"], "idx": 65106, "cwe": "CWE-59", "target": 0, "status": "FIXED", "commit": "00d379c94ba865dced2025c2d1bc3e2e0e41e880", "function_name": "fill", "body_hash": "cc0904a2ed6ce78c481f0cbb36bb116afb0c983b"}
{"code": "default boolean contains(String name) {\n        return get(name, Argument.OBJECT_ARGUMENT).isPresent();\n    }", "code_tokens": ["default", "boolean", "contains", "(", "String", "name", ")", "{", "return", "get", "(", "name", ",", "Argument", ".", "OBJECT_ARGUMENT", ")", ".", "isPresent", "(", ")", ";", "}"], "idx": 52463, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3", "function_name": "contains", "body_hash": "6d404a47b11550f8604dce4299e3412ba9e11620"}
{"code": "private boolean isInvalidEncodedPath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, \"UTF-8\");\n\t\t\t\treturn (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\"));\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\t// Should never happen...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "code_tokens": ["private", "boolean", "isInvalidEncodedPath", "(", "String", "resourcePath", ")", "{", "if", "(", "resourcePath", ".", "contains", "(", "\"", "%", "\"", ")", ")", "{", "try", "{", "String", "decodedPath", "=", "URLDecoder", ".", "decode", "(", "resourcePath", ",", "\"", "UTF-8", "\"", ")", ";", "return", "(", "decodedPath", ".", "contains", "(", "\"", "../", "\"", ")", "||", "decodedPath", ".", "contains", "(", "\"", "..", "\\\\", "\"", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "ex", ")", "{", "}", "}", "return", "false", ";", "}"], "idx": 26706, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "98ad23bef8e2e04143f8f5b201380543a8d8c0c", "function_name": "isInvalidEncodedPath", "body_hash": "5908d3d8ed4dc4d88acfeee4680d18786da86b63"}
{"code": "public void execute(ActionInvocation invocation) throws Exception {\r\n\t\tactionName = conditionalParse(actionName, invocation);\r\n\t\tString portletNamespace = (String)invocation.getInvocationContext().get(PortletConstants.PORTLET_NAMESPACE);\r\n\t\tif (portletMode != null) {\r\n\t\t\tMap<PortletMode, String> namespaceMap = getNamespaceMap(invocation);\r\n\t\t\tnamespace = namespaceMap.get(portletMode);\r\n\t\t}\r\n\t\tif (namespace == null) {\r\n\t\t\tnamespace = invocation.getProxy().getNamespace();\r\n\t\t\tparseLocation = false;\r\n\t\t} else {\r\n\t\t\tnamespace = conditionalParse(namespace, invocation);\r\n\t\t}\r\n\t\tif (method == null) {\r\n\t\t\tmethod = \"\";\r\n\t\t} else {\r\n\t\t\tmethod = conditionalParse(method, invocation);\r\n\t\t}\r\n\r\n\t\tString resultCode = invocation.getResultCode();\r\n\t\tif (resultCode != null) {\r\n\t\t\tResultConfig resultConfig = invocation.getProxy().getConfig().getResults().get(resultCode);\r\n\t\t\tMap<String, String> resultConfigParams = resultConfig.getParams();\r\n            for (Map.Entry<String, String> e : resultConfigParams.entrySet()) {\r\n                if (!prohibitedResultParam.contains(e.getKey())) {\r\n                    requestParameters.put(e.getKey(), e.getValue() == null ? \"\" : conditionalParse(e.getValue(), invocation));\r\n                }\r\n            }\r\n\t\t}\r\n\r\n\t\tStringBuilder tmpLocation = new StringBuilder(actionMapper.getUriFromActionMapping(new ActionMapping(actionName,\r\n\t\t\t\t(portletNamespace == null ? namespace : portletNamespace + namespace), method, null)));\r\n\t\turlHelper.buildParametersString(requestParameters, tmpLocation, \"&\");\r\n\r\n\t\tsetLocation(tmpLocation.toString());\r\n\r\n\t\tsuper.execute(invocation);\r\n\t}", "code_tokens": ["public", "void", "execute", "(", "ActionInvocation", "invocation", ")", "throws", "Exception", "{", "actionName", "=", "conditionalParse", "(", "actionName", ",", "invocation", ")", ";", "String", "portletNamespace", "=", "(", "String", ")", "invocation", ".", "getInvocationContext", "(", ")", ".", "get", "(", "PortletConstants", ".", "PORTLET_NAMESPACE", ")", ";", "if", "(", "portletMode", "!=", "null", ")", "{", "Map", "<", "PortletMode", ",", "String", ">", "namespaceMap", "=", "getNamespaceMap", "(", "invocation", ")", ";", "namespace", "=", "namespaceMap", ".", "get", "(", "portletMode", ")", ";", "}", "if", "(", "namespace", "==", "null", ")", "{", "namespace", "=", "invocation", ".", "getProxy", "(", ")", ".", "getNamespace", "(", ")", ";", "parseLocation", "=", "false", ";", "}", "else", "{", "namespace", "=", "conditionalParse", "(", "namespace", ",", "invocation", ")", ";", "}", "if", "(", "method", "==", "null", ")", "{", "method", "=", "\"", "\"", ";", "}", "else", "{", "method", "=", "conditionalParse", "(", "method", ",", "invocation", ")", ";", "}", "String", "resultCode", "=", "invocation", ".", "getResultCode", "(", ")", ";", "if", "(", "resultCode", "!=", "null", ")", "{", "ResultConfig", "resultConfig", "=", "invocation", ".", "getProxy", "(", ")", ".", "getConfig", "(", ")", ".", "getResults", "(", ")", ".", "get", "(", "resultCode", ")", ";", "Map", "<", "String", ",", "String", ">", "resultConfigParams", "=", "resultConfig", ".", "getParams", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "e", ":", "resultConfigParams", ".", "entrySet", "(", ")", ")", "{", "if", "(", "!", "prohibitedResultParam", ".", "contains", "(", "e", ".", "getKey", "(", ")", ")", ")", "{", "requestParameters", ".", "put", "(", "e", ".", "getKey", "(", ")", ",", "e", ".", "getValue", "(", ")", "==", "null", "?", "\"", "\"", ":", "conditionalParse", "(", "e", ".", "getValue", "(", ")", ",", "invocation", ")", ")", ";", "}", "}", "}", "StringBuilder", "tmpLocation", "=", "new", "StringBuilder", "(", "actionMapper", ".", "getUriFromActionMapping", "(", "new", "ActionMapping", "(", "actionName", ",", "(", "portletNamespace", "==", "null", "?", "namespace", ":", "portletNamespace", "+", "namespace", ")", ",", "method", ",", "null", ")", ")", ")", ";", "urlHelper", ".", "buildParametersString", "(", "requestParameters", ",", "tmpLocation", ",", "\"", "&", "\"", ")", ";", "setLocation", "(", "tmpLocation", ".", "toString", "(", ")", ")", ";", "super", ".", "execute", "(", "invocation", ")", ";", "}"], "idx": 10589, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "6efaf900d4ffb7be8a74065af5553bad2389f72", "function_name": "execute", "body_hash": "9e892aa11b0bdcc2a23117dde32c7ad37d9b63ae"}
{"code": "private String getBodyContentAsString() {\n\t\tif (this.body == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tString contentType = (this.messageProperties != null) ? this.messageProperties.getContentType() : null;\n\t\t\tif (MessageProperties.CONTENT_TYPE_SERIALIZED_OBJECT.equals(contentType)) {\n\t\t\t\treturn SERIALIZER_MESSAGE_CONVERTER.fromMessage(this).toString();\n\t\t\t}\n\t\t\tif (MessageProperties.CONTENT_TYPE_TEXT_PLAIN.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON_ALT.equals(contentType)\n\t\t\t\t\t|| MessageProperties.CONTENT_TYPE_XML.equals(contentType)) {\n\t\t\t\treturn new String(this.body, ENCODING);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t\t// Comes out as '[B@....b' (so harmless)\n\t\treturn this.body.toString() + \"(byte[\" + this.body.length + \"])\"; //NOSONAR\n\t}", "code_tokens": ["private", "String", "getBodyContentAsString", "(", ")", "{", "if", "(", "this", ".", "body", "==", "null", ")", "{", "return", "null", ";", "}", "try", "{", "String", "contentType", "=", "(", "this", ".", "messageProperties", "!=", "null", ")", "?", "this", ".", "messageProperties", ".", "getContentType", "(", ")", ":", "null", ";", "if", "(", "MessageProperties", ".", "CONTENT_TYPE_SERIALIZED_OBJECT", ".", "equals", "(", "contentType", ")", ")", "{", "return", "SERIALIZER_MESSAGE_CONVERTER", ".", "fromMessage", "(", "this", ")", ".", "toString", "(", ")", ";", "}", "if", "(", "MessageProperties", ".", "CONTENT_TYPE_TEXT_PLAIN", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_JSON", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_JSON_ALT", ".", "equals", "(", "contentType", ")", "||", "MessageProperties", ".", "CONTENT_TYPE_XML", ".", "equals", "(", "contentType", ")", ")", "{", "return", "new", "String", "(", "this", ".", "body", ",", "ENCODING", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "}", "return", "this", ".", "body", ".", "toString", "(", ")", "+", "\"", "(byte[", "\"", "+", "this", ".", "body", ".", "length", "+", "\"", "])", "\"", ";", "}"], "idx": 61672, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "296d481f980fcbecbee01244e3644e254470a86", "function_name": "getBodyContentAsString", "body_hash": "37ca15e3792c1c62213a210c078a95e2daf1777b"}
{"code": "private void init() {\n        authMap = new HashMap<Pair<String, String>, String>();\n\n        try {\n            Document doc = StaxUtils.read(getClass().getResource(\"/\" + authorizations).openStream());\n            doc.getDocumentElement().normalize();\n\n            Node authNode = null;\n            NodeList root = doc.getChildNodes();\n            for (int i = 0; i < root.getLength() && authNode == null; i++) {\n                if (\"auth\".equals(root.item(i).getNodeName())) {\n                    authNode = root.item(i);\n                }\n            }\n            if (authNode == null) {\n                throw new IllegalArgumentException(\"Could not find root <auth> node\");\n            }\n\n            NodeList pages = authNode.getChildNodes();\n            for (int i = 0; i < pages.getLength(); i++) {\n                if (\"page\".equals(pages.item(i).getNodeName())) {\n                    String page = pages.item(i).getAttributes().getNamedItem(\"id\").getTextContent();\n\n                    NodeList actions = pages.item(i).getChildNodes();\n                    for (int j = 0; j < actions.getLength(); j++) {\n                        if (\"action\".equals(actions.item(j).getNodeName())) {\n                            String action = actions.item(j).getAttributes().getNamedItem(\"id\").getTextContent();\n\n                            NodeList entitlements = actions.item(j).getChildNodes();\n                            for (int k = 0; k < entitlements.getLength(); k++) {\n                                if (\"entitlement\".equals(entitlements.item(k).getNodeName())) {\n                                    String entitlement = entitlements.item(k).getTextContent();\n                                    authMap.put(new ImmutablePair<String, String>(page, action), entitlement);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"While initializing parsing of {}\", authorizations, e);\n        }\n    }", "code_tokens": ["private", "void", "init", "(", ")", "{", "authMap", "=", "new", "HashMap", "<", "Pair", "<", "String", ",", "String", ">", ",", "String", ">", "(", ")", ";", "try", "{", "Document", "doc", "=", "StaxUtils", ".", "read", "(", "getClass", "(", ")", ".", "getResource", "(", "\"", "/", "\"", "+", "authorizations", ")", ".", "openStream", "(", ")", ")", ";", "doc", ".", "getDocumentElement", "(", ")", ".", "normalize", "(", ")", ";", "Node", "authNode", "=", "null", ";", "NodeList", "root", "=", "doc", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "root", ".", "getLength", "(", ")", "&&", "authNode", "==", "null", ";", "i", "++", ")", "{", "if", "(", "\"", "auth", "\"", ".", "equals", "(", "root", ".", "item", "(", "i", ")", ".", "getNodeName", "(", ")", ")", ")", "{", "authNode", "=", "root", ".", "item", "(", "i", ")", ";", "}", "}", "if", "(", "authNode", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Could not find root <auth> node", "\"", ")", ";", "}", "NodeList", "pages", "=", "authNode", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pages", ".", "getLength", "(", ")", ";", "i", "++", ")", "{", "if", "(", "\"", "page", "\"", ".", "equals", "(", "pages", ".", "item", "(", "i", ")", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "page", "=", "pages", ".", "item", "(", "i", ")", ".", "getAttributes", "(", ")", ".", "getNamedItem", "(", "\"", "id", "\"", ")", ".", "getTextContent", "(", ")", ";", "NodeList", "actions", "=", "pages", ".", "item", "(", "i", ")", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "actions", ".", "getLength", "(", ")", ";", "j", "++", ")", "{", "if", "(", "\"", "action", "\"", ".", "equals", "(", "actions", ".", "item", "(", "j", ")", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "action", "=", "actions", ".", "item", "(", "j", ")", ".", "getAttributes", "(", ")", ".", "getNamedItem", "(", "\"", "id", "\"", ")", ".", "getTextContent", "(", ")", ";", "NodeList", "entitlements", "=", "actions", ".", "item", "(", "j", ")", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "entitlements", ".", "getLength", "(", ")", ";", "k", "++", ")", "{", "if", "(", "\"", "entitlement", "\"", ".", "equals", "(", "entitlements", ".", "item", "(", "k", ")", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "entitlement", "=", "entitlements", ".", "item", "(", "k", ")", ".", "getTextContent", "(", ")", ";", "authMap", ".", "put", "(", "new", "ImmutablePair", "<", "String", ",", "String", ">", "(", "page", ",", "action", ")", ",", "entitlement", ")", ";", "}", "}", "}", "}", "}", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "error", "(", "\"", "While initializing parsing of {}", "\"", ",", "authorizations", ",", "e", ")", ";", "}", "}"], "idx": 6083, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "726231fbf7b817bd2a9467171dcb1c0087c75bc", "function_name": "init", "body_hash": "e58aec4288b0b18f6097dc8248db32c328600d66"}
{"code": "private static void processHeaderConfig(MultivaluedMap<String, String> httpHeaders, Object object, String key, String prefix) {\n\n        try {\n            String property = StringUtils.removeStart(key, prefix);\n            Field field = null;\n            try {\n                object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n            } catch (NoSuchFieldException e) {\n                //swallow\n            }\n            String setter = property;\n            setter = \"set\"+setter.substring(0,1).toUpperCase(Locale.US)+setter.substring(1);\n            //default assume string class\n            //if there's a more specific type, e.g. double, int, boolean\n            //try that.\n            Class clazz = String.class;\n            if (field != null) {\n                if (field.getType() == int.class) {\n                    clazz = int.class;\n                } else if (field.getType() == double.class) {\n                    clazz = double.class;\n                } else if (field.getType() == boolean.class) {\n                    clazz = boolean.class;\n                }\n            }\n\n            Method m = tryToGetMethod(object, setter, clazz);\n            //if you couldn't find more specific setter, back off\n            //to string setter and try that.\n            if (m == null && clazz != String.class) {\n                m = tryToGetMethod(object, setter, String.class);\n            }\n\n            if (m != null) {\n                String val = httpHeaders.getFirst(key);\n                val = val.trim();\n                if (clazz == String.class) {\n                    checkTrustWorthy(setter, val);\n                    m.invoke(object, val);\n                } else if (clazz == int.class) {\n                    m.invoke(object, Integer.parseInt(val));\n                } else if (clazz == double.class) {\n                    m.invoke(object, Double.parseDouble(val));\n                } else if (clazz == boolean.class) {\n                    m.invoke(object, Boolean.parseBoolean(val));\n                } else {\n                    throw new IllegalArgumentException(\"setter must be String, int, double or boolean...for now\");\n                }\n            } else {\n                throw new NoSuchMethodException(\"Couldn't find: \"+setter);\n            }\n\n        } catch (Throwable ex) {\n            throw new WebApplicationException(String.format(Locale.ROOT,\n                    \"%s is an invalid %s header\", key, X_TIKA_OCR_HEADER_PREFIX));\n        }\n    }", "code_tokens": ["private", "static", "void", "processHeaderConfig", "(", "MultivaluedMap", "<", "String", ",", "String", ">", "httpHeaders", ",", "Object", "object", ",", "String", "key", ",", "String", "prefix", ")", "{", "try", "{", "String", "property", "=", "StringUtils", ".", "removeStart", "(", "key", ",", "prefix", ")", ";", "Field", "field", "=", "null", ";", "try", "{", "object", ".", "getClass", "(", ")", ".", "getDeclaredField", "(", "StringUtils", ".", "uncapitalize", "(", "property", ")", ")", ";", "}", "catch", "(", "NoSuchFieldException", "e", ")", "{", "}", "String", "setter", "=", "property", ";", "setter", "=", "\"", "set", "\"", "+", "setter", ".", "substring", "(", "0", ",", "1", ")", ".", "toUpperCase", "(", "Locale", ".", "US", ")", "+", "setter", ".", "substring", "(", "1", ")", ";", "Class", "clazz", "=", "String", ".", "class", ";", "if", "(", "field", "!=", "null", ")", "{", "if", "(", "field", ".", "getType", "(", ")", "==", "int", ".", "class", ")", "{", "clazz", "=", "int", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "double", ".", "class", ")", "{", "clazz", "=", "double", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "boolean", ".", "class", ")", "{", "clazz", "=", "boolean", ".", "class", ";", "}", "}", "Method", "m", "=", "tryToGetMethod", "(", "object", ",", "setter", ",", "clazz", ")", ";", "if", "(", "m", "==", "null", "&&", "clazz", "!=", "String", ".", "class", ")", "{", "m", "=", "tryToGetMethod", "(", "object", ",", "setter", ",", "String", ".", "class", ")", ";", "}", "if", "(", "m", "!=", "null", ")", "{", "String", "val", "=", "httpHeaders", ".", "getFirst", "(", "key", ")", ";", "val", "=", "val", ".", "trim", "(", ")", ";", "if", "(", "clazz", "==", "String", ".", "class", ")", "{", "checkTrustWorthy", "(", "setter", ",", "val", ")", ";", "m", ".", "invoke", "(", "object", ",", "val", ")", ";", "}", "else", "if", "(", "clazz", "==", "int", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Integer", ".", "parseInt", "(", "val", ")", ")", ";", "}", "else", "if", "(", "clazz", "==", "double", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Double", ".", "parseDouble", "(", "val", ")", ")", ";", "}", "else", "if", "(", "clazz", "==", "boolean", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Boolean", ".", "parseBoolean", "(", "val", ")", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "setter must be String, int, double or boolean...for now", "\"", ")", ";", "}", "}", "else", "{", "throw", "new", "NoSuchMethodException", "(", "\"", "Couldn't find: ", "\"", "+", "setter", ")", ";", "}", "}", "catch", "(", "Throwable", "ex", ")", "{", "throw", "new", "WebApplicationException", "(", "String", ".", "format", "(", "Locale", ".", "ROOT", ",", "\"", "%s is an invalid %s header", "\"", ",", "key", ",", "X_TIKA_OCR_HEADER_PREFIX", ")", ")", ";", "}", "}"], "idx": 109068, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "4fdc51a40bf9532d7db57d0b08c1aec3931468ad", "function_name": "processHeaderConfig", "body_hash": "1c8f321a232195f986b1719a43b01bd5de27209d"}
{"code": "@Override\n    public void onCommand(final Object o) {\n        final Command command = (Command)o;\n        if (!closed.get() && command != null) {\n            try {\n                command.visit(new CommandVisitorAdapter() {\n                    @Override\n                    public Response processMessageDispatch(MessageDispatch md) throws Exception {\n                        waitForTransportInterruptionProcessingToComplete();\n                        ActiveMQDispatcher dispatcher = dispatchers.get(md.getConsumerId());\n                        if (dispatcher != null) {\n                            // Copy in case a embedded broker is dispatching via\n                            // vm://\n                            // md.getMessage() == null to signal end of queue\n                            // browse.\n                            Message msg = md.getMessage();\n                            if (msg != null) {\n                                msg = msg.copy();\n                                msg.setReadOnlyBody(true);\n                                msg.setReadOnlyProperties(true);\n                                msg.setRedeliveryCounter(md.getRedeliveryCounter());\n                                msg.setConnection(ActiveMQConnection.this);\n                                msg.setMemoryUsage(null);\n                                md.setMessage(msg);\n                            }\n                            dispatcher.dispatch(md);\n                        } else {\n                            LOG.debug(\"{} no dispatcher for {} in {}\", this, md, dispatchers);\n                        }\n                        return null;\n                    }\n\n                    @Override\n                    public Response processProducerAck(ProducerAck pa) throws Exception {\n                        if (pa != null && pa.getProducerId() != null) {\n                            ActiveMQMessageProducer producer = producers.get(pa.getProducerId());\n                            if (producer != null) {\n                                producer.onProducerAck(pa);\n                            }\n                        }\n                        return null;\n                    }\n\n                    @Override\n                    public Response processBrokerInfo(BrokerInfo info) throws Exception {\n                        brokerInfo = info;\n                        brokerInfoReceived.countDown();\n                        optimizeAcknowledge &= !brokerInfo.isFaultTolerantConfiguration();\n                        getBlobTransferPolicy().setBrokerUploadUrl(info.getBrokerUploadUrl());\n                        return null;\n                    }\n\n                    @Override\n                    public Response processConnectionError(final ConnectionError error) throws Exception {\n                        executor.execute(new Runnable() {\n                            @Override\n                            public void run() {\n                                onAsyncException(error.getException());\n                            }\n                        });\n                        return null;\n                    }\n\n                    @Override\n                    public Response processControlCommand(ControlCommand command) throws Exception {\n                        return null;\n                    }\n\n                    @Override\n                    public Response processConnectionControl(ConnectionControl control) throws Exception {\n                        onConnectionControl((ConnectionControl)command);\n                        return null;\n                    }\n\n                    @Override\n                    public Response processConsumerControl(ConsumerControl control) throws Exception {\n                        onConsumerControl((ConsumerControl)command);\n                        return null;\n                    }\n\n                    @Override\n                    public Response processWireFormat(WireFormatInfo info) throws Exception {\n                        onWireFormatInfo((WireFormatInfo)command);\n                        return null;\n                    }\n                });\n            } catch (Exception e) {\n                onClientInternalException(e);\n            }\n        }\n\n        for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {\n            TransportListener listener = iter.next();\n            listener.onCommand(command);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "onCommand", "(", "final", "Object", "o", ")", "{", "final", "Command", "command", "=", "(", "Command", ")", "o", ";", "if", "(", "!", "closed", ".", "get", "(", ")", "&&", "command", "!=", "null", ")", "{", "try", "{", "command", ".", "visit", "(", "new", "CommandVisitorAdapter", "(", ")", "{", "@", "Override", "public", "Response", "processMessageDispatch", "(", "MessageDispatch", "md", ")", "throws", "Exception", "{", "waitForTransportInterruptionProcessingToComplete", "(", ")", ";", "ActiveMQDispatcher", "dispatcher", "=", "dispatchers", ".", "get", "(", "md", ".", "getConsumerId", "(", ")", ")", ";", "if", "(", "dispatcher", "!=", "null", ")", "{", "Message", "msg", "=", "md", ".", "getMessage", "(", ")", ";", "if", "(", "msg", "!=", "null", ")", "{", "msg", "=", "msg", ".", "copy", "(", ")", ";", "msg", ".", "setReadOnlyBody", "(", "true", ")", ";", "msg", ".", "setReadOnlyProperties", "(", "true", ")", ";", "msg", ".", "setRedeliveryCounter", "(", "md", ".", "getRedeliveryCounter", "(", ")", ")", ";", "msg", ".", "setConnection", "(", "ActiveMQConnection", ".", "this", ")", ";", "msg", ".", "setMemoryUsage", "(", "null", ")", ";", "md", ".", "setMessage", "(", "msg", ")", ";", "}", "dispatcher", ".", "dispatch", "(", "md", ")", ";", "}", "else", "{", "LOG", ".", "debug", "(", "\"", "{} no dispatcher for {} in {}", "\"", ",", "this", ",", "md", ",", "dispatchers", ")", ";", "}", "return", "null", ";", "}", "@", "Override", "public", "Response", "processProducerAck", "(", "ProducerAck", "pa", ")", "throws", "Exception", "{", "if", "(", "pa", "!=", "null", "&&", "pa", ".", "getProducerId", "(", ")", "!=", "null", ")", "{", "ActiveMQMessageProducer", "producer", "=", "producers", ".", "get", "(", "pa", ".", "getProducerId", "(", ")", ")", ";", "if", "(", "producer", "!=", "null", ")", "{", "producer", ".", "onProducerAck", "(", "pa", ")", ";", "}", "}", "return", "null", ";", "}", "@", "Override", "public", "Response", "processBrokerInfo", "(", "BrokerInfo", "info", ")", "throws", "Exception", "{", "brokerInfo", "=", "info", ";", "brokerInfoReceived", ".", "countDown", "(", ")", ";", "optimizeAcknowledge", "&=", "!", "brokerInfo", ".", "isFaultTolerantConfiguration", "(", ")", ";", "getBlobTransferPolicy", "(", ")", ".", "setBrokerUploadUrl", "(", "info", ".", "getBrokerUploadUrl", "(", ")", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processConnectionError", "(", "final", "ConnectionError", "error", ")", "throws", "Exception", "{", "executor", ".", "execute", "(", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "onAsyncException", "(", "error", ".", "getException", "(", ")", ")", ";", "}", "}", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processControlCommand", "(", "ControlCommand", "command", ")", "throws", "Exception", "{", "return", "null", ";", "}", "@", "Override", "public", "Response", "processConnectionControl", "(", "ConnectionControl", "control", ")", "throws", "Exception", "{", "onConnectionControl", "(", "(", "ConnectionControl", ")", "command", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processConsumerControl", "(", "ConsumerControl", "control", ")", "throws", "Exception", "{", "onConsumerControl", "(", "(", "ConsumerControl", ")", "command", ")", ";", "return", "null", ";", "}", "@", "Override", "public", "Response", "processWireFormat", "(", "WireFormatInfo", "info", ")", "throws", "Exception", "{", "onWireFormatInfo", "(", "(", "WireFormatInfo", ")", "command", ")", ";", "return", "null", ";", "}", "}", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "onClientInternalException", "(", "e", ")", ";", "}", "}", "for", "(", "Iterator", "<", "TransportListener", ">", "iter", "=", "transportListeners", ".", "iterator", "(", ")", ";", "iter", ".", "hasNext", "(", ")", ";", ")", "{", "TransportListener", "listener", "=", "iter", ".", "next", "(", ")", ";", "listener", ".", "onCommand", "(", "command", ")", ";", "}", "}"], "idx": 5060, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "338a74dfa42a7b19d39adecacfa5f626a050e807", "function_name": "onCommand", "body_hash": "6e62fe4813803dafba0574c16f9a0efddf555b95"}
{"code": "public Map<String, Object> loadExport(Owner owner, File exportFile,\n        ConflictOverrides overrides)\n        throws ImporterException {\n        File tmpDir = null;\n        InputStream exportStream = null;\n        Map<String, Object> result = new HashMap<String, Object>();\n        try {\n            tmpDir = new SyncUtils(config).makeTempDir(\"import\");\n            extractArchive(tmpDir, exportFile);\n\n//           only need this call when sig file is verified\n//            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n\n            /*\n             * Disabling this once again for a little bit longer. Dependent projects\n             * are not yet ready for it, and we're having some difficulty with the actual\n             * upstream cert to use.\n             *\n             * When we bring this back, we should probably report this conflict\n             * immediately, rather than continuing to extract and trying to find any\n             * other conflicts to pass back.\n             */\n//            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n//                exportStream,\n//                loadSignature(new File(tmpDir, \"signature\")));\n//            if (!verifiedSignature) {\n//                log.warn(\"Manifest signature check failed.\");\n//                if (!forcedConflicts\n//                    .isForced(ImportConflicts.Conflict.SIGNATURE_CONFLICT)) {\n//                    conflicts.addConflict(\n//                        i18n.tr(\"Failed import file hash check.\"),\n//                        ImportConflicts.Conflict.SIGNATURE_CONFLICT);\n//                }\n//                else {\n//                    log.warn(\"Ignoring signature check failure.\");\n//                }\n//            }\n\n            File signature = new File(tmpDir, \"signature\");\n            if (signature.length() == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The archive does not \" +\n                                          \"contain the required signature file\"));\n            }\n\n            File consumerExport = new File(tmpDir, \"consumer_export.zip\");\n            File exportDir = extractArchive(tmpDir, consumerExport);\n\n            Map<String, File> importFiles = new HashMap<String, File>();\n            File[] listFiles = exportDir.listFiles();\n            if (listFiles == null || listFiles.length == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The consumer_export \" +\n                    \"archive has no contents\"));\n            }\n            for (File file : listFiles) {\n                importFiles.put(file.getName(), file);\n            }\n\n            ConsumerDto consumer = importObjects(owner, importFiles, overrides);\n            Meta m = mapper.readValue(importFiles.get(ImportFile.META.fileName()),\n                Meta.class);\n            result.put(\"consumer\", consumer);\n            result.put(\"meta\", m);\n            return result;\n        }\n//        catch (CertificateException e) {\n//            log.error(\"Exception caught importing archive\", e);\n//            throw new ImportExtractionException(\"unable to extract export archive\", e);\n//        }\n        catch (FileNotFoundException fnfe) {\n            log.error(\"Archive file does not contain consumer_export.zip\", fnfe);\n            throw new ImportExtractionException(i18n.tr(\"The archive does not contain \" +\n                                           \"the required consumer_export.zip file\"));\n        }\n        catch (ConstraintViolationException cve) {\n            log.error(\"Failed to import archive\", cve);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                cve);\n        }\n        catch (PersistenceException pe) {\n            log.error(\"Failed to import archive\", pe);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                pe);\n        }\n        catch (IOException e) {\n            log.error(\"Exception caught importing archive\", e);\n            throw new ImportExtractionException(\"unable to extract export archive\", e);\n        }\n        finally {\n            if (tmpDir != null) {\n                try {\n                    FileUtils.deleteDirectory(tmpDir);\n                }\n                catch (IOException e) {\n                    log.error(\"Failed to delete extracted export\", e);\n                }\n            }\n            if (exportStream != null) {\n                try {\n                    exportStream.close();\n                }\n                catch (Exception e) {\n                    // nothing we can do.\n                }\n            }\n        }\n    }", "code_tokens": ["public", "Map", "<", "String", ",", "Object", ">", "loadExport", "(", "Owner", "owner", ",", "File", "exportFile", ",", "ConflictOverrides", "overrides", ")", "throws", "ImporterException", "{", "File", "tmpDir", "=", "null", ";", "InputStream", "exportStream", "=", "null", ";", "Map", "<", "String", ",", "Object", ">", "result", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "try", "{", "tmpDir", "=", "new", "SyncUtils", "(", "config", ")", ".", "makeTempDir", "(", "\"", "import", "\"", ")", ";", "extractArchive", "(", "tmpDir", ",", "exportFile", ")", ";", "File", "signature", "=", "new", "File", "(", "tmpDir", ",", "\"", "signature", "\"", ")", ";", "if", "(", "signature", ".", "length", "(", ")", "==", "0", ")", "{", "throw", "new", "ImportExtractionException", "(", "i18n", ".", "tr", "(", "\"", "The archive does not ", "\"", "+", "\"", "contain the required signature file", "\"", ")", ")", ";", "}", "File", "consumerExport", "=", "new", "File", "(", "tmpDir", ",", "\"", "consumer_export.zip", "\"", ")", ";", "File", "exportDir", "=", "extractArchive", "(", "tmpDir", ",", "consumerExport", ")", ";", "Map", "<", "String", ",", "File", ">", "importFiles", "=", "new", "HashMap", "<", "String", ",", "File", ">", "(", ")", ";", "File", "[", "]", "listFiles", "=", "exportDir", ".", "listFiles", "(", ")", ";", "if", "(", "listFiles", "==", "null", "||", "listFiles", ".", "length", "==", "0", ")", "{", "throw", "new", "ImportExtractionException", "(", "i18n", ".", "tr", "(", "\"", "The consumer_export ", "\"", "+", "\"", "archive has no contents", "\"", ")", ")", ";", "}", "for", "(", "File", "file", ":", "listFiles", ")", "{", "importFiles", ".", "put", "(", "file", ".", "getName", "(", ")", ",", "file", ")", ";", "}", "ConsumerDto", "consumer", "=", "importObjects", "(", "owner", ",", "importFiles", ",", "overrides", ")", ";", "Meta", "m", "=", "mapper", ".", "readValue", "(", "importFiles", ".", "get", "(", "ImportFile", ".", "META", ".", "fileName", "(", ")", ")", ",", "Meta", ".", "class", ")", ";", "result", ".", "put", "(", "\"", "consumer", "\"", ",", "consumer", ")", ";", "result", ".", "put", "(", "\"", "meta", "\"", ",", "m", ")", ";", "return", "result", ";", "}", "catch", "(", "FileNotFoundException", "fnfe", ")", "{", "log", ".", "error", "(", "\"", "Archive file does not contain consumer_export.zip", "\"", ",", "fnfe", ")", ";", "throw", "new", "ImportExtractionException", "(", "i18n", ".", "tr", "(", "\"", "The archive does not contain ", "\"", "+", "\"", "the required consumer_export.zip file", "\"", ")", ")", ";", "}", "catch", "(", "ConstraintViolationException", "cve", ")", "{", "log", ".", "error", "(", "\"", "Failed to import archive", "\"", ",", "cve", ")", ";", "throw", "new", "ImporterException", "(", "i18n", ".", "tr", "(", "\"", "Failed to import archive", "\"", ")", ",", "cve", ")", ";", "}", "catch", "(", "PersistenceException", "pe", ")", "{", "log", ".", "error", "(", "\"", "Failed to import archive", "\"", ",", "pe", ")", ";", "throw", "new", "ImporterException", "(", "i18n", ".", "tr", "(", "\"", "Failed to import archive", "\"", ")", ",", "pe", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"", "Exception caught importing archive", "\"", ",", "e", ")", ";", "throw", "new", "ImportExtractionException", "(", "\"", "unable to extract export archive", "\"", ",", "e", ")", ";", "}", "finally", "{", "if", "(", "tmpDir", "!=", "null", ")", "{", "try", "{", "FileUtils", ".", "deleteDirectory", "(", "tmpDir", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"", "Failed to delete extracted export", "\"", ",", "e", ")", ";", "}", "}", "if", "(", "exportStream", "!=", "null", ")", "{", "try", "{", "exportStream", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "}", "}", "}", "}"], "idx": 34525, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "f4d93230e58b969c506b4c9778e04482a059b08c", "function_name": "loadExport", "body_hash": "319ad0c98f2ee38b8c5b956cab1f101ad00cf7f7"}
{"code": "private String escapeString(final String string)\n  {\n    if (string == null || string.length() == 0) {\n      return \"\\\"\\\"\";\n    }\n    char c = 0;\n    int i;\n    final int len = string.length();\n    final StringBuilder sb = new StringBuilder(len + 4);\n    String t;\n    sb.append('\"');\n    for (i = 0; i < len; i += 1) {\n      c = string.charAt(i);\n      switch (c) {\n        case '\\\\':\n        case '\"':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '/':\n          // if (b == '<') {\n          sb.append('\\\\');\n          // }\n          sb.append(c);\n          break;\n        case '\\b':\n          sb.append(\"\\\\b\");\n          break;\n        case '\\t':\n          sb.append(\"\\\\t\");\n          break;\n        case '\\n':\n          sb.append(\"\\\\n\");\n          break;\n        case '\\f':\n          sb.append(\"\\\\f\");\n          break;\n        case '\\r':\n          sb.append(\"\\\\r\");\n          break;\n        default:\n          if (c < ' ') {\n            t = \"000\" + Integer.toHexString(c);\n            sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n          } else {\n            if (escapeHtml == true) {\n              switch (c) {\n                case '<':\n                  sb.append(\"&lt;\");\n                  break;\n                case '>':\n                  sb.append(\"&gt;\");\n                  break;\n                case '&':\n                  sb.append(\"&amp;\");\n                  break;\n                case '\"':\n                  sb.append(\"&quot;\");\n                  break;\n                case '\\'':\n                  sb.append(\"&#x27;\");\n                  break;\n                case '/':\n                  sb.append(\"&#x2F;\");\n                  break;\n                default:\n                  sb.append(c);\n              }\n            } else {\n              sb.append(c);\n            }\n          }\n      }\n    }\n    sb.append('\"');\n    return sb.toString();\n  }", "code_tokens": ["private", "String", "escapeString", "(", "final", "String", "string", ")", "{", "if", "(", "string", "==", "null", "||", "string", ".", "length", "(", ")", "==", "0", ")", "{", "return", "\"", "\\\"", "\\\"", "\"", ";", "}", "char", "c", "=", "0", ";", "int", "i", ";", "final", "int", "len", "=", "string", ".", "length", "(", ")", ";", "final", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "len", "+", "4", ")", ";", "String", "t", ";", "sb", ".", "append", "(", "'\"'", ")", ";", "for", "(", "i", "=", "0", ";", "i", "<", "len", ";", "i", "+=", "1", ")", "{", "c", "=", "string", ".", "charAt", "(", "i", ")", ";", "switch", "(", "c", ")", "{", "case", "'\\\\'", ":", "case", "'\"'", ":", "sb", ".", "append", "(", "'\\\\'", ")", ";", "sb", ".", "append", "(", "c", ")", ";", "break", ";", "case", "'/'", ":", "sb", ".", "append", "(", "'\\\\'", ")", ";", "sb", ".", "append", "(", "c", ")", ";", "break", ";", "case", "'\\b'", ":", "sb", ".", "append", "(", "\"", "\\\\", "b", "\"", ")", ";", "break", ";", "case", "'\\t'", ":", "sb", ".", "append", "(", "\"", "\\\\", "t", "\"", ")", ";", "break", ";", "case", "'\\n'", ":", "sb", ".", "append", "(", "\"", "\\\\", "n", "\"", ")", ";", "break", ";", "case", "'\\f'", ":", "sb", ".", "append", "(", "\"", "\\\\", "f", "\"", ")", ";", "break", ";", "case", "'\\r'", ":", "sb", ".", "append", "(", "\"", "\\\\", "r", "\"", ")", ";", "break", ";", "default", ":", "if", "(", "c", "<", "' '", ")", "{", "t", "=", "\"", "000", "\"", "+", "Integer", ".", "toHexString", "(", "c", ")", ";", "sb", ".", "append", "(", "\"", "\\\\", "u", "\"", "+", "t", ".", "substring", "(", "t", ".", "length", "(", ")", "-", "4", ")", ")", ";", "}", "else", "{", "if", "(", "escapeHtml", "==", "true", ")", "{", "switch", "(", "c", ")", "{", "case", "'<'", ":", "sb", ".", "append", "(", "\"", "&lt;", "\"", ")", ";", "break", ";", "case", "'>'", ":", "sb", ".", "append", "(", "\"", "&gt;", "\"", ")", ";", "break", ";", "case", "'&'", ":", "sb", ".", "append", "(", "\"", "&amp;", "\"", ")", ";", "break", ";", "case", "'\"'", ":", "sb", ".", "append", "(", "\"", "&quot;", "\"", ")", ";", "break", ";", "case", "'\\''", ":", "sb", ".", "append", "(", "\"", "&#x27;", "\"", ")", ";", "break", ";", "case", "'/'", ":", "sb", ".", "append", "(", "\"", "&#x2F;", "\"", ")", ";", "break", ";", "default", ":", "sb", ".", "append", "(", "c", ")", ";", "}", "}", "else", "{", "sb", ".", "append", "(", "c", ")", ";", "}", "}", "}", "}", "sb", ".", "append", "(", "'\"'", ")", ";", "return", "sb", ".", "toString", "(", ")", ";", "}"], "idx": 80704, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "5a6a25366491443b76e528a04a9e4ba26f08a83c", "function_name": "escapeString", "body_hash": "1ea86619b4f92b08b005de641d7acb9948e1dd35"}
{"code": "@Override\n        public boolean check(Object credentials)\n        {\n            if (credentials instanceof char[])\n                credentials=new String((char[])credentials);\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n\n            try\n            {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5)\n                {\n                    // Credentials are already a MD5 digest - assume it's in\n                    // form user:realm:password (we have no way to know since\n                    // it's a digest, alright?)\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                }\n                else\n                {\n                    // calc A1 digest\n                    md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                // calc A2 digest\n                md.reset();\n                md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                byte[] ha2 = md.digest();\n\n                // calc digest\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\"\n                // nc-value \":\" unq(cnonce-value) \":\" unq(qop-value) \":\" H(A2) )\n                // <\">\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2)\n                // ) > <\">\n\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                byte[] digest = md.digest();\n\n                // check digest\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n            }\n\n            return false;\n        }", "code_tokens": ["@", "Override", "public", "boolean", "check", "(", "Object", "credentials", ")", "{", "if", "(", "credentials", "instanceof", "char", "[", "]", ")", "credentials", "=", "new", "String", "(", "(", "char", "[", "]", ")", "credentials", ")", ";", "String", "password", "=", "(", "credentials", "instanceof", "String", ")", "?", "(", "String", ")", "credentials", ":", "credentials", ".", "toString", "(", ")", ";", "try", "{", "MessageDigest", "md", "=", "MessageDigest", ".", "getInstance", "(", "\"", "MD5", "\"", ")", ";", "byte", "[", "]", "ha1", ";", "if", "(", "credentials", "instanceof", "Credential", ".", "MD5", ")", "{", "ha1", "=", "(", "(", "Credential", ".", "MD5", ")", "credentials", ")", ".", "getDigest", "(", ")", ";", "}", "else", "{", "md", ".", "update", "(", "username", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "realm", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "password", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "ha1", "=", "md", ".", "digest", "(", ")", ";", "}", "md", ".", "reset", "(", ")", ";", "md", ".", "update", "(", "method", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "uri", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "byte", "[", "]", "ha2", "=", "md", ".", "digest", "(", ")", ";", "md", ".", "update", "(", "TypeUtil", ".", "toString", "(", "ha1", ",", "16", ")", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "nonce", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "nc", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "cnonce", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "qop", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "TypeUtil", ".", "toString", "(", "ha2", ",", "16", ")", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "byte", "[", "]", "digest", "=", "md", ".", "digest", "(", ")", ";", "return", "(", "TypeUtil", ".", "toString", "(", "digest", ",", "16", ")", ".", "equalsIgnoreCase", "(", "response", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "warn", "(", "e", ")", ";", "}", "return", "false", ";", "}"], "idx": 20335, "cwe": "CWE-203", "target": 1, "status": "VULNERABLE", "commit": "042f325f1cd6e7891d72c7e668f5947b5457dc02", "function_name": "check", "body_hash": "d215913ad91fd1ab507817e1a7c36899c26f6142"}
{"code": "@Override\n    public void testIsXXEVulnerable() throws Exception {\n        try {\n            super.testIsXXEVulnerable();\n            fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n        } catch (final XStreamException e) {\n            final String message = e.getMessage().toLowerCase();\n            if (message.contains(\"Package\")) {\n                throw e;\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "testIsXXEVulnerable", "(", ")", "throws", "Exception", "{", "try", "{", "super", ".", "testIsXXEVulnerable", "(", ")", ";", "fail", "(", "\"", "Thrown ", "\"", "+", "XStreamException", ".", "class", ".", "getName", "(", ")", "+", "\"", " expected", "\"", ")", ";", "}", "catch", "(", "final", "XStreamException", "e", ")", "{", "final", "String", "message", "=", "e", ".", "getMessage", "(", ")", ".", "toLowerCase", "(", ")", ";", "if", "(", "message", ".", "contains", "(", "\"", "Package", "\"", ")", ")", "{", "throw", "e", ";", "}", "}", "}"], "idx": 19841, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "25c6704bea149ee93c294ae5b6e0aecd182fea88", "function_name": "testIsXXEVulnerable", "body_hash": "4a9e02224349ec11d3e9036c34c7e279aa41a914"}
{"code": "private boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {\n        URL resource = classLoader.getResource(resourcePath);\n        if( resource !=null ) {\n\n            String libName = name + \"-\" + getBitModel();\n            if( version !=null) {\n                libName += \"-\" + version;\n            }\n            String []libNameParts = map(libName).split(\"\\\\.\");\n            String prefix = libNameParts[0]+\"-\";\n            String suffix = \".\"+libNameParts[1];\n\n            if( customPath!=null ) {\n                // Try to extract it to the custom path...\n                File target = extract(errors, resource, prefix, suffix, file(customPath));\n                if( target!=null ) {\n                    if( load(errors, target) ) {\n                        return true;\n                    }\n                }\n            }\n            \n            // Fall back to extracting to the tmp dir\n            customPath = System.getProperty(\"java.io.tmpdir\");\n            File target = extract(errors, resource, prefix, suffix, file(customPath));\n            if( target!=null ) {\n                if( load(errors, target) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "code_tokens": ["private", "boolean", "exractAndLoad", "(", "ArrayList", "<", "String", ">", "errors", ",", "String", "version", ",", "String", "customPath", ",", "String", "resourcePath", ")", "{", "URL", "resource", "=", "classLoader", ".", "getResource", "(", "resourcePath", ")", ";", "if", "(", "resource", "!=", "null", ")", "{", "String", "libName", "=", "name", "+", "\"", "-", "\"", "+", "getBitModel", "(", ")", ";", "if", "(", "version", "!=", "null", ")", "{", "libName", "+=", "\"", "-", "\"", "+", "version", ";", "}", "String", "[", "]", "libNameParts", "=", "map", "(", "libName", ")", ".", "split", "(", "\"", "\\\\", ".", "\"", ")", ";", "String", "prefix", "=", "libNameParts", "[", "0", "]", "+", "\"", "-", "\"", ";", "String", "suffix", "=", "\"", ".", "\"", "+", "libNameParts", "[", "1", "]", ";", "if", "(", "customPath", "!=", "null", ")", "{", "File", "target", "=", "extract", "(", "errors", ",", "resource", ",", "prefix", ",", "suffix", ",", "file", "(", "customPath", ")", ")", ";", "if", "(", "target", "!=", "null", ")", "{", "if", "(", "load", "(", "errors", ",", "target", ")", ")", "{", "return", "true", ";", "}", "}", "}", "customPath", "=", "System", ".", "getProperty", "(", "\"", "java.io.tmpdir", "\"", ")", ";", "File", "target", "=", "extract", "(", "errors", ",", "resource", ",", "prefix", ",", "suffix", ",", "file", "(", "customPath", ")", ")", ";", "if", "(", "target", "!=", "null", ")", "{", "if", "(", "load", "(", "errors", ",", "target", ")", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "idx": 95297, "cwe": "CWE-94", "target": 0, "status": "FIXED", "commit": "92c266170ce98edc200c656bd034a237098b8aa5", "function_name": "exractAndLoad", "body_hash": "27280615c567b021616f619dc47bd02926db2d48"}
{"code": "@Before\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        Connector c = getTomcatInstance().getConnector();\n        c.setProperty(\"secretRequired\", \"false\");\n    }", "code_tokens": ["@", "Before", "@", "Override", "public", "void", "setUp", "(", ")", "throws", "Exception", "{", "super", ".", "setUp", "(", ")", ";", "Connector", "c", "=", "getTomcatInstance", "(", ")", ".", "getConnector", "(", ")", ";", "c", ".", "setProperty", "(", "\"", "secretRequired", "\"", ",", "\"", "false", "\"", ")", ";", "}"], "idx": 115823, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "b99fba5", "function_name": "setUp", "body_hash": "2c901cdd86b954477265258524c98243bf2d39e9"}
{"code": "private boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {\n        URL resource = classLoader.getResource(resourcePath);\n        if( resource !=null ) {\n            \n            String libName = name + \"-\" + getBitModel();\n            if( version !=null) {\n                libName += \"-\" + version;\n            }\n            \n            if( customPath!=null ) {\n                // Try to extract it to the custom path...\n                File target = file(customPath, map(libName));\n                if( extract(errors, resource, target) ) {\n                    if( load(errors, target) ) {\n                        return true;\n                    }\n                }\n            }\n            \n            // Fall back to extracting to the tmp dir\n            customPath = System.getProperty(\"java.io.tmpdir\");\n            File target = file(customPath, map(libName));\n            if( extract(errors, resource, target) ) {\n                if( load(errors, target) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "code_tokens": ["private", "boolean", "exractAndLoad", "(", "ArrayList", "<", "String", ">", "errors", ",", "String", "version", ",", "String", "customPath", ",", "String", "resourcePath", ")", "{", "URL", "resource", "=", "classLoader", ".", "getResource", "(", "resourcePath", ")", ";", "if", "(", "resource", "!=", "null", ")", "{", "String", "libName", "=", "name", "+", "\"", "-", "\"", "+", "getBitModel", "(", ")", ";", "if", "(", "version", "!=", "null", ")", "{", "libName", "+=", "\"", "-", "\"", "+", "version", ";", "}", "if", "(", "customPath", "!=", "null", ")", "{", "File", "target", "=", "file", "(", "customPath", ",", "map", "(", "libName", ")", ")", ";", "if", "(", "extract", "(", "errors", ",", "resource", ",", "target", ")", ")", "{", "if", "(", "load", "(", "errors", ",", "target", ")", ")", "{", "return", "true", ";", "}", "}", "}", "customPath", "=", "System", ".", "getProperty", "(", "\"", "java.io.tmpdir", "\"", ")", ";", "File", "target", "=", "file", "(", "customPath", ",", "map", "(", "libName", ")", ")", ";", "if", "(", "extract", "(", "errors", ",", "resource", ",", "target", ")", ")", "{", "if", "(", "load", "(", "errors", ",", "target", ")", ")", "{", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "idx": 95296, "cwe": "CWE-94", "target": 1, "status": "VULNERABLE", "commit": "92c266170ce98edc200c656bd034a237098b8aa5", "function_name": "exractAndLoad", "body_hash": "6e9a820f090a8ce751a1803962b9a1047047c448"}
{"code": "@Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n        if (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n            authorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n            return new ArrayList(items.values());\n        }\n\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\n        return viewableItems;\n    }", "code_tokens": ["@", "Exported", "(", "name", "=", "\"", "jobs", "\"", ")", "public", "List", "<", "TopLevelItem", ">", "getItems", "(", ")", "{", "if", "(", "authorizationStrategy", "instanceof", "AuthorizationStrategy", ".", "Unsecured", "||", "authorizationStrategy", "instanceof", "FullControlOnceLoggedInAuthorizationStrategy", ")", "{", "return", "new", "ArrayList", "(", "items", ".", "values", "(", ")", ")", ";", "}", "List", "<", "TopLevelItem", ">", "viewableItems", "=", "new", "ArrayList", "<", "TopLevelItem", ">", "(", ")", ";", "for", "(", "TopLevelItem", "item", ":", "items", ".", "values", "(", ")", ")", "{", "if", "(", "item", ".", "hasPermission", "(", "Item", ".", "READ", ")", ")", "viewableItems", ".", "add", "(", "item", ")", ";", "}", "return", "viewableItems", ";", "}"], "idx": 12693, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "09cfbc9cd5c9df7c763bc976b7f5c51266b63719", "function_name": "getItems", "body_hash": "acb9fb927401b8013dec7fc4d134c3b787eb67f6"}
{"code": "private boolean isInvalidEncodedPath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, \"UTF-8\");\n\t\t\t\tint separatorIndex = decodedPath.indexOf(\"..\") + 2;\n\t\t\t\tif (separatorIndex > 1 && separatorIndex < decodedPath.length()) {\n\t\t\t\t\tchar separator = decodedPath.charAt(separatorIndex);\n\t\t\t\t\tif (separator == '/' || separator == '\\\\') {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Resolved resource path contains \\\"../\\\" after decoding: \" + resourcePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\t// Should never happen...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "code_tokens": ["private", "boolean", "isInvalidEncodedPath", "(", "String", "resourcePath", ")", "{", "if", "(", "resourcePath", ".", "contains", "(", "\"", "%", "\"", ")", ")", "{", "try", "{", "String", "decodedPath", "=", "URLDecoder", ".", "decode", "(", "resourcePath", ",", "\"", "UTF-8", "\"", ")", ";", "int", "separatorIndex", "=", "decodedPath", ".", "indexOf", "(", "\"", "..", "\"", ")", "+", "2", ";", "if", "(", "separatorIndex", ">", "1", "&&", "separatorIndex", "<", "decodedPath", ".", "length", "(", ")", ")", "{", "char", "separator", "=", "decodedPath", ".", "charAt", "(", "separatorIndex", ")", ";", "if", "(", "separator", "==", "'/'", "||", "separator", "==", "'\\\\'", ")", "{", "if", "(", "logger", ".", "isTraceEnabled", "(", ")", ")", "{", "logger", ".", "trace", "(", "\"", "Resolved resource path contains ", "\\\"", "../", "\\\"", " after decoding: ", "\"", "+", "resourcePath", ")", ";", "}", "}", "return", "true", ";", "}", "}", "catch", "(", "UnsupportedEncodingException", "ex", ")", "{", "}", "}", "return", "false", ";", "}"], "idx": 27009, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "f59ea610dfcf55cd0b42f6dd76a9b3dab0218aa", "function_name": "isInvalidEncodedPath", "body_hash": "0c586eb95ef95a538a3b60474054bcb65732585c"}
{"code": "@WebMethod(name=\"heapdump.hprof\")\n        public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n            owner.checkPermission(Jenkins.ADMINISTER);\n            rsp.setContentType(\"application/octet-stream\");\n\n            FilePath dump = obtain();\n            try {\n                dump.copyTo(rsp.getCompressedOutputStream(req));\n            } finally {\n                dump.delete();\n            }\n        }", "code_tokens": ["@", "WebMethod", "(", "name", "=", "\"", "heapdump.hprof", "\"", ")", "public", "void", "doHeapDump", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "InterruptedException", "{", "owner", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "rsp", ".", "setContentType", "(", "\"", "application/octet-stream", "\"", ")", ";", "FilePath", "dump", "=", "obtain", "(", ")", ";", "try", "{", "dump", ".", "copyTo", "(", "rsp", ".", "getCompressedOutputStream", "(", "req", ")", ")", ";", "}", "finally", "{", "dump", ".", "delete", "(", ")", ";", "}", "}"], "idx": 30122, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "0530a6645aac10fec005614211660e98db44b5eb", "function_name": "doHeapDump", "body_hash": "3e11a5db5339e2fb9b82aa5f2957cd5ea0a966c3"}
{"code": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                buf.limit(0);\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }", "code_tokens": ["private", "int", "readStored", "(", "final", "byte", "[", "]", "buffer", ",", "final", "int", "offset", ",", "final", "int", "length", ")", "throws", "IOException", "{", "if", "(", "current", ".", "hasDataDescriptor", ")", "{", "if", "(", "lastStoredEntry", "==", "null", ")", "{", "readStoredEntry", "(", ")", ";", "}", "return", "lastStoredEntry", ".", "read", "(", "buffer", ",", "offset", ",", "length", ")", ";", "}", "final", "long", "csize", "=", "current", ".", "entry", ".", "getSize", "(", ")", ";", "if", "(", "current", ".", "bytesRead", ">=", "csize", ")", "{", "return", "-", "1", ";", "}", "if", "(", "buf", ".", "position", "(", ")", ">=", "buf", ".", "limit", "(", ")", ")", "{", "buf", ".", "position", "(", "0", ")", ";", "final", "int", "l", "=", "in", ".", "read", "(", "buf", ".", "array", "(", ")", ")", ";", "if", "(", "l", "==", "-", "1", ")", "{", "buf", ".", "limit", "(", "0", ")", ";", "throw", "new", "IOException", "(", "\"", "Truncated ZIP file", "\"", ")", ";", "}", "buf", ".", "limit", "(", "l", ")", ";", "count", "(", "l", ")", ";", "current", ".", "bytesReadFromStream", "+=", "l", ";", "}", "int", "toRead", "=", "Math", ".", "min", "(", "buf", ".", "remaining", "(", ")", ",", "length", ")", ";", "if", "(", "(", "csize", "-", "current", ".", "bytesRead", ")", "<", "toRead", ")", "{", "toRead", "=", "(", "int", ")", "(", "csize", "-", "current", ".", "bytesRead", ")", ";", "}", "buf", ".", "get", "(", "buffer", ",", "offset", ",", "toRead", ")", ";", "current", ".", "bytesRead", "+=", "toRead", ";", "return", "toRead", ";", "}"], "idx": 82771, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "a41ce6892cb0590b2e658704434ac0dbcb6834c8", "function_name": "readStored", "body_hash": "bda97286264aabde07eb0b59f240f51df070a9da"}
{"code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        CrumbIssuer crumbIssuer = getCrumbIssuer();\n        if (crumbIssuer == null || !(request instanceof HttpServletRequest)) {\n            chain.doFilter(request, response);\n            return;\n        }\n\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n\n        if (\"POST\".equals(httpRequest.getMethod())) {\n            for (CrumbExclusion e : CrumbExclusion.all()) {\n                if (e.process(httpRequest,httpResponse,chain))\n                    return;\n            }\n\n            String crumbFieldName = crumbIssuer.getDescriptor().getCrumbRequestField();\n            String crumbSalt = crumbIssuer.getDescriptor().getCrumbSalt();\n\n            String crumb = httpRequest.getHeader(crumbFieldName);\n            boolean valid = false;\n            if (crumb == null) {\n                Enumeration<?> paramNames = request.getParameterNames();\n                while (paramNames.hasMoreElements()) {\n                    String paramName = (String) paramNames.nextElement();\n                    if (crumbFieldName.equals(paramName)) {\n                        crumb = request.getParameter(paramName);\n                        break;\n                    }\n                }\n            }\n            if (crumb != null) {\n                if (crumbIssuer.validateCrumb(httpRequest, crumbSalt, crumb)) {\n                    valid = true;\n                } else {\n                    LOGGER.log(Level.WARNING, \"Found invalid crumb {0}.  Will check remaining parameters for a valid one...\", crumb);\n                }\n            }\n            // Multipart requests need to be handled by each handler.\n            if (valid || isMultipart(httpRequest)) {\n                chain.doFilter(request, response);\n            } else {\n                LOGGER.log(Level.WARNING, \"No valid crumb was included in request for {0}. Returning {1}.\", new Object[] {httpRequest.getRequestURI(), HttpServletResponse.SC_FORBIDDEN});\n                httpResponse.sendError(HttpServletResponse.SC_FORBIDDEN,\"No valid crumb was included in the request\");\n            }\n        } else {\n            chain.doFilter(request, response);\n        }\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "CrumbIssuer", "crumbIssuer", "=", "getCrumbIssuer", "(", ")", ";", "if", "(", "crumbIssuer", "==", "null", "||", "!", "(", "request", "instanceof", "HttpServletRequest", ")", ")", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "return", ";", "}", "HttpServletRequest", "httpRequest", "=", "(", "HttpServletRequest", ")", "request", ";", "HttpServletResponse", "httpResponse", "=", "(", "HttpServletResponse", ")", "response", ";", "if", "(", "\"", "POST", "\"", ".", "equals", "(", "httpRequest", ".", "getMethod", "(", ")", ")", ")", "{", "for", "(", "CrumbExclusion", "e", ":", "CrumbExclusion", ".", "all", "(", ")", ")", "{", "if", "(", "e", ".", "process", "(", "httpRequest", ",", "httpResponse", ",", "chain", ")", ")", "return", ";", "}", "String", "crumbFieldName", "=", "crumbIssuer", ".", "getDescriptor", "(", ")", ".", "getCrumbRequestField", "(", ")", ";", "String", "crumbSalt", "=", "crumbIssuer", ".", "getDescriptor", "(", ")", ".", "getCrumbSalt", "(", ")", ";", "String", "crumb", "=", "httpRequest", ".", "getHeader", "(", "crumbFieldName", ")", ";", "boolean", "valid", "=", "false", ";", "if", "(", "crumb", "==", "null", ")", "{", "Enumeration", "<", "?", ">", "paramNames", "=", "request", ".", "getParameterNames", "(", ")", ";", "while", "(", "paramNames", ".", "hasMoreElements", "(", ")", ")", "{", "String", "paramName", "=", "(", "String", ")", "paramNames", ".", "nextElement", "(", ")", ";", "if", "(", "crumbFieldName", ".", "equals", "(", "paramName", ")", ")", "{", "crumb", "=", "request", ".", "getParameter", "(", "paramName", ")", ";", "break", ";", "}", "}", "}", "if", "(", "crumb", "!=", "null", ")", "{", "if", "(", "crumbIssuer", ".", "validateCrumb", "(", "httpRequest", ",", "crumbSalt", ",", "crumb", ")", ")", "{", "valid", "=", "true", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Found invalid crumb {0}.  Will check remaining parameters for a valid one...", "\"", ",", "crumb", ")", ";", "}", "}", "if", "(", "valid", "||", "isMultipart", "(", "httpRequest", ")", ")", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "No valid crumb was included in request for {0}. Returning {1}.", "\"", ",", "new", "Object", "[", "]", "{", "httpRequest", ".", "getRequestURI", "(", ")", ",", "HttpServletResponse", ".", "SC_FORBIDDEN", "}", ")", ";", "httpResponse", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ",", "\"", "No valid crumb was included in the request", "\"", ")", ";", "}", "}", "else", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}", "}"], "idx": 99446, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "ef2c0dc163695af3a57ad7a45571293377ff679b", "function_name": "doFilter", "body_hash": "d5066a37f4d56e01d7d1a7c90769b4ec4a7e4878"}
{"code": "public static long parseLong(byte[] b, int off, int len)\n        throws NumberFormatException\n    {\n        int c;\n\n        if (b == null || len <= 0 || !isDigit(c = b[off++])) {\n            throw new NumberFormatException();\n        }\n\n        long n = c - '0';\n        while (--len > 0) {\n            if (isDigit(c = b[off++]) &&\n                    (n < OVERFLOW_LIMIT || (n == OVERFLOW_LIMIT && (c - '0') < 8))) {\n                n = n * 10 + c - '0';\n            } else {\n                throw new NumberFormatException();\n            }\n        }\n\n        return n;\n    }", "code_tokens": ["public", "static", "long", "parseLong", "(", "byte", "[", "]", "b", ",", "int", "off", ",", "int", "len", ")", "throws", "NumberFormatException", "{", "int", "c", ";", "if", "(", "b", "==", "null", "||", "len", "<=", "0", "||", "!", "isDigit", "(", "c", "=", "b", "[", "off", "++", "]", ")", ")", "{", "throw", "new", "NumberFormatException", "(", ")", ";", "}", "long", "n", "=", "c", "-", "'0'", ";", "while", "(", "--", "len", ">", "0", ")", "{", "if", "(", "isDigit", "(", "c", "=", "b", "[", "off", "++", "]", ")", "&&", "(", "n", "<", "OVERFLOW_LIMIT", "||", "(", "n", "==", "OVERFLOW_LIMIT", "&&", "(", "c", "-", "'0'", ")", "<", "8", ")", ")", ")", "{", "n", "=", "n", "*", "10", "+", "c", "-", "'0'", ";", "}", "else", "{", "throw", "new", "NumberFormatException", "(", ")", ";", "}", "}", "return", "n", ";", "}"], "idx": 3080, "cwe": "CWE-189", "target": 0, "status": "FIXED", "commit": "8828a9902d", "function_name": "parseLong", "body_hash": "75163c893b212d324aadd083ab328c406ad27ad9"}
{"code": "protected void scanPI() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanPI: \");\n            }\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1008\", null);\n            }\n\n            // scan processing instruction\n            String target = scanName(true);\n            if (target != null && !target.equalsIgnoreCase(\"xml\")) {\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    if (c == -1) {\n                        break;\n                    }\n                    if (c != ' ' && c != '\\t') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                fStringBuffer.clear();\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '?' || c == '/') {\n                        char c0 = (char)c;\n                        c = fCurrentEntity.read();\n                        if (c == '>' || c == -1) {\n                            break;\n                        }\n                        fStringBuffer.append(c0);\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        fStringBuffer.append('\\n');\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    else if (c == -1) {\n                        break;\n                    }\n                    else {\n                        appendChar(fStringBuffer, c);\n                    }\n                }\n                XMLString data = fStringBuffer;\n                if (fDocumentHandler != null) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.processingInstruction(target, data, locationAugs());\n                }\n            }\n\n            // scan xml/text declaration\n            else {\n                int beginLineNumber = fBeginLineNumber;\n                int beginColumnNumber = fBeginColumnNumber;\n                int beginCharacterOffset = fBeginCharacterOffset;\n                fAttributes.removeAllAttributes();\n                int aindex = 0;\n                while (scanPseudoAttribute(fAttributes)) {\n                \t// if we haven't scanned a value, remove the entry as values have special signification\n                \tif (fAttributes.getValue(aindex).length() == 0) {\n                \t\tfAttributes.removeAttributeAt(aindex); \n                \t}\n                \telse {\n\t                    fAttributes.getName(aindex,fQName);\n\t                    fQName.rawname = fQName.rawname.toLowerCase();\n\t                    fAttributes.setName(aindex,fQName);\n\t                    aindex++;\n                \t}\n                }\n                if (fDocumentHandler != null) {\n                    String version = fAttributes.getValue(\"version\");\n                    String encoding = fAttributes.getValue(\"encoding\");\n                    String standalone = fAttributes.getValue(\"standalone\");\n\n                    // if the encoding is successfully changed, the stream will be processed again\n                    // with the right encoding an we will come here again but without need to change the encoding\n                    final boolean xmlDeclNow = fIgnoreSpecifiedCharset || !changeEncoding(encoding);\n                    if (xmlDeclNow) {\n\t                    fBeginLineNumber = beginLineNumber;\n\t                    fBeginColumnNumber = beginColumnNumber;\n\t                    fBeginCharacterOffset = beginCharacterOffset;\n\t                    fEndLineNumber = fCurrentEntity.getLineNumber();\n\t                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n\t                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n\t                    fDocumentHandler.xmlDecl(version, encoding, standalone,\n\t                                             locationAugs());\n                    }\n                }\n            }\n\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanPI: \");\n            }\n        }", "code_tokens": ["protected", "void", "scanPI", "(", ")", "throws", "IOException", "{", "if", "(", "DEBUG_BUFFER", ")", "{", "fCurrentEntity", ".", "debugBufferIfNeeded", "(", "\"", "(scanPI: ", "\"", ")", ";", "}", "if", "(", "fReportErrors", ")", "{", "fErrorReporter", ".", "reportWarning", "(", "\"", "HTML1008", "\"", ",", "null", ")", ";", "}", "String", "target", "=", "scanName", "(", "true", ")", ";", "if", "(", "target", "!=", "null", "&&", "!", "target", ".", "equalsIgnoreCase", "(", "\"", "xml", "\"", ")", ")", "{", "while", "(", "true", ")", "{", "int", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "==", "'\\r'", "||", "c", "==", "'\\n'", ")", "{", "if", "(", "c", "==", "'\\r'", ")", "{", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "!=", "'\\n'", ")", "{", "fCurrentEntity", ".", "offset", "--", ";", "fCurrentEntity", ".", "characterOffset_", "--", ";", "}", "}", "fCurrentEntity", ".", "incLine", "(", ")", ";", "continue", ";", "}", "if", "(", "c", "==", "-", "1", ")", "{", "break", ";", "}", "if", "(", "c", "!=", "' '", "&&", "c", "!=", "'\\t'", ")", "{", "fCurrentEntity", ".", "rewind", "(", ")", ";", "break", ";", "}", "}", "fStringBuffer", ".", "clear", "(", ")", ";", "while", "(", "true", ")", "{", "int", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "==", "'?'", "||", "c", "==", "'/'", ")", "{", "char", "c0", "=", "(", "char", ")", "c", ";", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "==", "'>'", "||", "c", "==", "-", "1", ")", "{", "break", ";", "}", "fStringBuffer", ".", "append", "(", "c0", ")", ";", "fCurrentEntity", ".", "rewind", "(", ")", ";", "continue", ";", "}", "else", "if", "(", "c", "==", "'\\r'", "||", "c", "==", "'\\n'", ")", "{", "fStringBuffer", ".", "append", "(", "'\\n'", ")", ";", "if", "(", "c", "==", "'\\r'", ")", "{", "c", "=", "fCurrentEntity", ".", "read", "(", ")", ";", "if", "(", "c", "!=", "'\\n'", ")", "{", "fCurrentEntity", ".", "offset", "--", ";", "fCurrentEntity", ".", "characterOffset_", "--", ";", "}", "}", "fCurrentEntity", ".", "incLine", "(", ")", ";", "continue", ";", "}", "else", "if", "(", "c", "==", "-", "1", ")", "{", "break", ";", "}", "else", "{", "appendChar", "(", "fStringBuffer", ",", "c", ")", ";", "}", "}", "XMLString", "data", "=", "fStringBuffer", ";", "if", "(", "fDocumentHandler", "!=", "null", ")", "{", "fEndLineNumber", "=", "fCurrentEntity", ".", "getLineNumber", "(", ")", ";", "fEndColumnNumber", "=", "fCurrentEntity", ".", "getColumnNumber", "(", ")", ";", "fEndCharacterOffset", "=", "fCurrentEntity", ".", "getCharacterOffset", "(", ")", ";", "fDocumentHandler", ".", "processingInstruction", "(", "target", ",", "data", ",", "locationAugs", "(", ")", ")", ";", "}", "}", "else", "{", "int", "beginLineNumber", "=", "fBeginLineNumber", ";", "int", "beginColumnNumber", "=", "fBeginColumnNumber", ";", "int", "beginCharacterOffset", "=", "fBeginCharacterOffset", ";", "fAttributes", ".", "removeAllAttributes", "(", ")", ";", "int", "aindex", "=", "0", ";", "while", "(", "scanPseudoAttribute", "(", "fAttributes", ")", ")", "{", "if", "(", "fAttributes", ".", "getValue", "(", "aindex", ")", ".", "length", "(", ")", "==", "0", ")", "{", "fAttributes", ".", "removeAttributeAt", "(", "aindex", ")", ";", "}", "else", "{", "fAttributes", ".", "getName", "(", "aindex", ",", "fQName", ")", ";", "fQName", ".", "rawname", "=", "fQName", ".", "rawname", ".", "toLowerCase", "(", ")", ";", "fAttributes", ".", "setName", "(", "aindex", ",", "fQName", ")", ";", "aindex", "++", ";", "}", "}", "if", "(", "fDocumentHandler", "!=", "null", ")", "{", "String", "version", "=", "fAttributes", ".", "getValue", "(", "\"", "version", "\"", ")", ";", "String", "encoding", "=", "fAttributes", ".", "getValue", "(", "\"", "encoding", "\"", ")", ";", "String", "standalone", "=", "fAttributes", ".", "getValue", "(", "\"", "standalone", "\"", ")", ";", "final", "boolean", "xmlDeclNow", "=", "fIgnoreSpecifiedCharset", "||", "!", "changeEncoding", "(", "encoding", ")", ";", "if", "(", "xmlDeclNow", ")", "{", "fBeginLineNumber", "=", "beginLineNumber", ";", "fBeginColumnNumber", "=", "beginColumnNumber", ";", "fBeginCharacterOffset", "=", "beginCharacterOffset", ";", "fEndLineNumber", "=", "fCurrentEntity", ".", "getLineNumber", "(", ")", ";", "fEndColumnNumber", "=", "fCurrentEntity", ".", "getColumnNumber", "(", ")", ";", "fEndCharacterOffset", "=", "fCurrentEntity", ".", "getCharacterOffset", "(", ")", ";", "fDocumentHandler", ".", "xmlDecl", "(", "version", ",", "encoding", ",", "standalone", ",", "locationAugs", "(", ")", ")", ";", "}", "}", "}", "if", "(", "DEBUG_BUFFER", ")", "{", "fCurrentEntity", ".", "debugBufferIfNeeded", "(", "\"", ")scanPI: ", "\"", ")", ";", "}", "}"], "idx": 52763, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "a800fce3b079def130ed42a408ff1d09f89e773d", "function_name": "scanPI", "body_hash": "738a9a4773490baa283fb295fd5cfd2e35d7ae4b"}
{"code": "public InputStream stream(final String host, final ByteBuffer message) throws IOException {\n        ServerAddress serverAddress = host.contains(\":\") ? new ServerAddress(host) : new ServerAddress(host, defaultPort);\n        Socket socket = sslContext.getSocketFactory().createSocket();\n\n        try {\n            socket.setSoTimeout(timeoutMillis);\n            socket.connect(serverAddress.getSocketAddress(), timeoutMillis);\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n        }\n\n        try {\n            OutputStream outputStream = socket.getOutputStream();\n\n            byte[] bytes = new byte[message.remaining()];\n\n            message.get(bytes);\n            outputStream.write(bytes);\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n        }\n\n        try {\n            return socket.getInputStream();\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n        }\n    }", "code_tokens": ["public", "InputStream", "stream", "(", "final", "String", "host", ",", "final", "ByteBuffer", "message", ")", "throws", "IOException", "{", "ServerAddress", "serverAddress", "=", "host", ".", "contains", "(", "\"", ":", "\"", ")", "?", "new", "ServerAddress", "(", "host", ")", ":", "new", "ServerAddress", "(", "host", ",", "defaultPort", ")", ";", "Socket", "socket", "=", "sslContext", ".", "getSocketFactory", "(", ")", ".", "createSocket", "(", ")", ";", "try", "{", "socket", ".", "setSoTimeout", "(", "timeoutMillis", ")", ";", "socket", ".", "connect", "(", "serverAddress", ".", "getSocketAddress", "(", ")", ",", "timeoutMillis", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "closeSocket", "(", "socket", ")", ";", "throw", "e", ";", "}", "try", "{", "OutputStream", "outputStream", "=", "socket", ".", "getOutputStream", "(", ")", ";", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "message", ".", "remaining", "(", ")", "]", ";", "message", ".", "get", "(", "bytes", ")", ";", "outputStream", ".", "write", "(", "bytes", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "closeSocket", "(", "socket", ")", ";", "throw", "e", ";", "}", "try", "{", "return", "socket", ".", "getInputStream", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "closeSocket", "(", "socket", ")", ";", "throw", "e", ";", "}", "}"], "idx": 40036, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "60d87d5a76645a331a77ccc45ef7c67aac88b234", "function_name": "stream", "body_hash": "e07361b9073ce33cf6183802888fef092c19a31e"}
{"code": "PublicKey getRemotePublicKey(String nodename) {\n    if (!cores.getZkController().getZkStateReader().getClusterState().getLiveNodes().contains(nodename)) return null;\n    String url = cores.getZkController().getZkStateReader().getBaseUrlForNodeName(nodename);\n    try {\n      String uri = url + PATH + \"?wt=json&omitHeader=true\";\n      log.debug(\"Fetching fresh public key from : {}\",uri);\n      HttpResponse rsp = cores.getUpdateShardHandler().getHttpClient()\n          .execute(new HttpGet(uri), HttpClientUtil.createNewHttpClientRequestContext());\n      byte[] bytes = EntityUtils.toByteArray(rsp.getEntity());\n      Map m = (Map) Utils.fromJSON(bytes);\n      String key = (String) m.get(\"key\");\n      if (key == null) {\n        log.error(\"No key available from \" + url + PATH);\n        return null;\n      } else {\n        log.info(\"New Key obtained from  node: {} / {}\", nodename, key);\n      }\n      PublicKey pubKey = CryptoKeys.deserializeX509PublicKey(key);\n      keyCache.put(nodename, pubKey);\n      return pubKey;\n    } catch (Exception e) {\n      log.error(\"Exception trying to get public key from : \" + url, e);\n      return null;\n    }\n\n  }", "code_tokens": ["PublicKey", "getRemotePublicKey", "(", "String", "nodename", ")", "{", "if", "(", "!", "cores", ".", "getZkController", "(", ")", ".", "getZkStateReader", "(", ")", ".", "getClusterState", "(", ")", ".", "getLiveNodes", "(", ")", ".", "contains", "(", "nodename", ")", ")", "return", "null", ";", "String", "url", "=", "cores", ".", "getZkController", "(", ")", ".", "getZkStateReader", "(", ")", ".", "getBaseUrlForNodeName", "(", "nodename", ")", ";", "try", "{", "String", "uri", "=", "url", "+", "PATH", "+", "\"", "?wt=json&omitHeader=true", "\"", ";", "log", ".", "debug", "(", "\"", "Fetching fresh public key from : {}", "\"", ",", "uri", ")", ";", "HttpResponse", "rsp", "=", "cores", ".", "getUpdateShardHandler", "(", ")", ".", "getHttpClient", "(", ")", ".", "execute", "(", "new", "HttpGet", "(", "uri", ")", ",", "HttpClientUtil", ".", "createNewHttpClientRequestContext", "(", ")", ")", ";", "byte", "[", "]", "bytes", "=", "EntityUtils", ".", "toByteArray", "(", "rsp", ".", "getEntity", "(", ")", ")", ";", "Map", "m", "=", "(", "Map", ")", "Utils", ".", "fromJSON", "(", "bytes", ")", ";", "String", "key", "=", "(", "String", ")", "m", ".", "get", "(", "\"", "key", "\"", ")", ";", "if", "(", "key", "==", "null", ")", "{", "log", ".", "error", "(", "\"", "No key available from ", "\"", "+", "url", "+", "PATH", ")", ";", "return", "null", ";", "}", "else", "{", "log", ".", "info", "(", "\"", "New Key obtained from  node: {} / {}", "\"", ",", "nodename", ",", "key", ")", ";", "}", "PublicKey", "pubKey", "=", "CryptoKeys", ".", "deserializeX509PublicKey", "(", "key", ")", ";", "keyCache", ".", "put", "(", "nodename", ",", "pubKey", ")", ";", "return", "pubKey", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "Exception trying to get public key from : ", "\"", "+", "url", ",", "e", ")", ";", "return", "null", ";", "}", "}"], "idx": 39392, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "e3b0cfff396a7f92a4f621d598780116da916f3", "function_name": "getRemotePublicKey", "body_hash": "43e0a5a662d4b550420fe2075fabe392cbb72ac1"}
{"code": "private void openConnection() {\n        if (!connectionOpened) {\n            connectionOpened = true;\n            URLConnection connection = null;\n            try {\n                try {\n                    connection = url.openConnection();\n                } catch (IOException e) {\n                    lastModified = null;\n                    contentLength = null;\n                    return;\n                }\n                lastModified =  new Date(connection.getLastModified());\n                contentLength = connection.getContentLengthLong();\n            } finally {\n                if (connection != null) {\n                    try {\n                        IoUtils.safeClose(connection.getInputStream());\n                    } catch (IOException e) {\n                        //ignore\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["private", "void", "openConnection", "(", ")", "{", "if", "(", "!", "connectionOpened", ")", "{", "connectionOpened", "=", "true", ";", "URLConnection", "connection", "=", "null", ";", "try", "{", "try", "{", "connection", "=", "url", ".", "openConnection", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "lastModified", "=", "null", ";", "contentLength", "=", "null", ";", "return", ";", "}", "lastModified", "=", "new", "Date", "(", "connection", ".", "getLastModified", "(", ")", ")", ";", "contentLength", "=", "connection", ".", "getContentLengthLong", "(", ")", ";", "}", "finally", "{", "if", "(", "connection", "!=", "null", ")", "{", "try", "{", "IoUtils", ".", "safeClose", "(", "connection", ".", "getInputStream", "(", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "}", "}", "}", "}"], "idx": 52391, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "7f22aa0090296eb00280f878e3731bb71d40f9e", "function_name": "openConnection", "body_hash": "79b56f5cfb764bc3d7d6f7c5da0228e18f1fda47"}
{"code": "private Document getXmlDoc() {\n    if (this.xmlDoc != null) {\n      return this.xmlDoc;\n    }\n\n    try {\n      final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n      factory.setExpandEntityReferences(false);\n      this.xmlDoc = factory.newDocumentBuilder()\n        .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));\n      return xmlDoc;\n    } catch (SAXException | IOException | ParserConfigurationException e) {\n      throw new RuntimeException(\"\u975e\u6cd5\u7684xml\u6587\u672c\u5185\u5bb9\uff1a\" + this.xmlString);\n    }\n\n  }", "code_tokens": ["private", "Document", "getXmlDoc", "(", ")", "{", "if", "(", "this", ".", "xmlDoc", "!=", "null", ")", "{", "return", "this", ".", "xmlDoc", ";", "}", "try", "{", "final", "DocumentBuilderFactory", "factory", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "factory", ".", "setExpandEntityReferences", "(", "false", ")", ";", "this", ".", "xmlDoc", "=", "factory", ".", "newDocumentBuilder", "(", ")", ".", "parse", "(", "new", "ByteArrayInputStream", "(", "this", ".", "xmlString", ".", "getBytes", "(", "StandardCharsets", ".", "UTF_8", ")", ")", ")", ";", "return", "xmlDoc", ";", "}", "catch", "(", "SAXException", "|", "IOException", "|", "ParserConfigurationException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "\u975e\u6cd5\u7684xml\u6587\u672c\u5185\u5bb9\uff1a", "\"", "+", "this", ".", "xmlString", ")", ";", "}", "}"], "idx": 70826, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "6272639f02e397fed40828a2d0da66c30264bc0e", "function_name": "getXmlDoc", "body_hash": "521769ad6584d4e2cb1089b7446bf2860d332391"}
{"code": "protected void sendWindowHandlerHtml(ExternalContext externalContext, String windowId)\n    {\n        HttpServletResponse httpResponse = (HttpServletResponse) externalContext.getResponse();\n\n        try\n        {\n            httpResponse.setStatus(HttpServletResponse.SC_OK);\n            httpResponse.setContentType(\"text/html\");\n\n            String windowHandlerHtml = clientWindowConfig.getClientWindowHtml();\n\n            if (windowId == null)\n            {\n                windowId = UNINITIALIZED_WINDOW_ID_VALUE;\n            }\n\n            // set the windowId value in the javascript code\n            windowHandlerHtml = windowHandlerHtml.replace(WINDOW_ID_REPLACE_PATTERN,\n                                                          org.owasp.encoder.Encode.forJavaScriptBlock(windowId));\n            // set the current request url\n            // on the client we can't use window.location as the location\n            // could be a different when using forwards\n            windowHandlerHtml = windowHandlerHtml.replace(REQUEST_URL_REPLACE_PATTERN,\n                                                          org.owasp.encoder.Encode.forJavaScriptBlock(\n                                                              ClientWindowHelper.constructRequestUrl(externalContext)));\n            // set the noscript-URL for users with no JavaScript\n            windowHandlerHtml =\n                windowHandlerHtml.replace(NOSCRIPT_URL_REPLACE_PATTERN,\n                                          org.owasp.encoder.Encode.forHtmlAttribute(getNoscriptUrl(externalContext)));\n\n            OutputStream os = httpResponse.getOutputStream();\n            try\n            {\n                os.write(windowHandlerHtml.getBytes());\n            }\n            finally\n            {\n                os.close();\n            }\n        }\n        catch (IOException ioe)\n        {\n            throw new FacesException(ioe);\n        }\n    }", "code_tokens": ["protected", "void", "sendWindowHandlerHtml", "(", "ExternalContext", "externalContext", ",", "String", "windowId", ")", "{", "HttpServletResponse", "httpResponse", "=", "(", "HttpServletResponse", ")", "externalContext", ".", "getResponse", "(", ")", ";", "try", "{", "httpResponse", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_OK", ")", ";", "httpResponse", ".", "setContentType", "(", "\"", "text/html", "\"", ")", ";", "String", "windowHandlerHtml", "=", "clientWindowConfig", ".", "getClientWindowHtml", "(", ")", ";", "if", "(", "windowId", "==", "null", ")", "{", "windowId", "=", "UNINITIALIZED_WINDOW_ID_VALUE", ";", "}", "windowHandlerHtml", "=", "windowHandlerHtml", ".", "replace", "(", "WINDOW_ID_REPLACE_PATTERN", ",", "org", ".", "owasp", ".", "encoder", ".", "Encode", ".", "forJavaScriptBlock", "(", "windowId", ")", ")", ";", "windowHandlerHtml", "=", "windowHandlerHtml", ".", "replace", "(", "REQUEST_URL_REPLACE_PATTERN", ",", "org", ".", "owasp", ".", "encoder", ".", "Encode", ".", "forJavaScriptBlock", "(", "ClientWindowHelper", ".", "constructRequestUrl", "(", "externalContext", ")", ")", ")", ";", "windowHandlerHtml", "=", "windowHandlerHtml", ".", "replace", "(", "NOSCRIPT_URL_REPLACE_PATTERN", ",", "org", ".", "owasp", ".", "encoder", ".", "Encode", ".", "forHtmlAttribute", "(", "getNoscriptUrl", "(", "externalContext", ")", ")", ")", ";", "OutputStream", "os", "=", "httpResponse", ".", "getOutputStream", "(", ")", ";", "try", "{", "os", ".", "write", "(", "windowHandlerHtml", ".", "getBytes", "(", ")", ")", ";", "}", "finally", "{", "os", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "FacesException", "(", "ioe", ")", ";", "}", "}"], "idx": 73319, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "5383f44b117a31d9fc9fcd3c156e1e801e24aedd", "function_name": "sendWindowHandlerHtml", "body_hash": "98a4e9ed8c807f357e3354751c2ef492cd40393e"}
{"code": "@RequirePOST\n        public FormValidation doCheckCredentialsId(StaplerRequest req, @AncestorInPath Item context, @QueryParameter String remoteBase, @QueryParameter String value) {\n            // TODO suspiciously similar to SubversionSCM.ModuleLocation.DescriptorImpl.checkCredentialsId; refactor into shared method?\n            // Test the connection only if we may use the credentials\n            if (context == null && !Jenkins.get().hasPermission(Jenkins.ADMINISTER) ||\n                context != null && !context.hasPermission(CredentialsProvider.USE_ITEM)) {\n                return FormValidation.ok();\n            }\n\n            // if check remote is reporting an issue then we don't need to\n            String url = Util.fixEmptyAndTrim(remoteBase);\n            if (url == null)\n                return FormValidation.ok();\n\n            if(!URL_PATTERN.matcher(url).matches())\n                return FormValidation.ok();\n\n            try {\n                String urlWithoutRevision = SvnHelper.getUrlWithoutRevision(url);\n\n                SVNURL repoURL = SVNURL.parseURIDecoded(urlWithoutRevision);\n\n                StandardCredentials credentials = value == null ? null :\n                        CredentialsMatchers.firstOrNull(CredentialsProvider\n                                .lookupCredentials(StandardCredentials.class, context, ACL.SYSTEM,\n                                        URIRequirementBuilder.fromUri(repoURL.toString()).build()),\n                                CredentialsMatchers.withId(value));\n                if (checkRepositoryPath(repoURL, credentials)!=SVNNodeKind.NONE) {\n                    // something exists; now check revision if any\n\n                    SVNRevision revision = getRevisionFromRemoteUrl(url);\n                    if (revision != null && !revision.isValid()) {\n                        return FormValidation.errorWithMarkup(\n                                hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_invalidRevision());\n                    }\n\n                    return FormValidation.ok();\n                }\n\n                SVNRepository repository = null;\n                try {\n                    repository = getRepository(repoURL, credentials,\n                            Collections.emptyMap(), null);\n                    long rev = repository.getLatestRevision();\n                    // now go back the tree and find if there's anything that exists\n                    String repoPath = getRelativePath(repoURL, repository);\n                    String p = repoPath;\n                    while(p.length()>0) {\n                        p = SVNPathUtil.removeTail(p);\n                        if(repository.checkPath(p,rev)==SVNNodeKind.DIR) {\n                            // found a matching path\n                            List<SVNDirEntry> entries = new ArrayList<>();\n                            repository.getDir(p,rev,false,entries);\n\n                            // build up the name list\n                            List<String> paths = new ArrayList<>();\n                            for (SVNDirEntry e : entries)\n                                if(e.getKind()==SVNNodeKind.DIR)\n                                    paths.add(e.getName());\n\n                            String head = SVNPathUtil.head(repoPath.substring(p.length() + 1));\n                            String candidate = EditDistance.findNearest(head, paths);\n\n                            return FormValidation.error(\n                                hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_badPathSuggest(p, head,\n                                        candidate != null ? \"/\" + candidate : \"\"));\n                        }\n                    }\n\n                    return FormValidation.error(\n                        hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_badPath(repoPath));\n                } finally {\n                    if (repository != null)\n                        repository.closeSession();\n                }\n            } catch (SVNException e) {\n                LOGGER.log(Level.INFO, \"Failed to access subversion repository \"+url,e);\n                String message = hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_exceptionMsg1(\n                        Util.escape(url), Util.escape(e.getErrorMessage().getFullMessage()),\n                        \"javascript:document.getElementById('svnerror').style.display='block';\"\n                                + \"document.getElementById('svnerrorlink').style.display='none';\"\n                                + \"return false;\")\n                  + \"<br/><pre id=\\\"svnerror\\\" style=\\\"display:none\\\">\"\n                  + Functions.printThrowable(e) + \"</pre>\";\n                return FormValidation.errorWithMarkup(message);\n            }\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doCheckCredentialsId", "(", "StaplerRequest", "req", ",", "@", "AncestorInPath", "Item", "context", ",", "@", "QueryParameter", "String", "remoteBase", ",", "@", "QueryParameter", "String", "value", ")", "{", "if", "(", "context", "==", "null", "&&", "!", "Jenkins", ".", "get", "(", ")", ".", "hasPermission", "(", "Jenkins", ".", "ADMINISTER", ")", "||", "context", "!=", "null", "&&", "!", "context", ".", "hasPermission", "(", "CredentialsProvider", ".", "USE_ITEM", ")", ")", "{", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "String", "url", "=", "Util", ".", "fixEmptyAndTrim", "(", "remoteBase", ")", ";", "if", "(", "url", "==", "null", ")", "return", "FormValidation", ".", "ok", "(", ")", ";", "if", "(", "!", "URL_PATTERN", ".", "matcher", "(", "url", ")", ".", "matches", "(", ")", ")", "return", "FormValidation", ".", "ok", "(", ")", ";", "try", "{", "String", "urlWithoutRevision", "=", "SvnHelper", ".", "getUrlWithoutRevision", "(", "url", ")", ";", "SVNURL", "repoURL", "=", "SVNURL", ".", "parseURIDecoded", "(", "urlWithoutRevision", ")", ";", "StandardCredentials", "credentials", "=", "value", "==", "null", "?", "null", ":", "CredentialsMatchers", ".", "firstOrNull", "(", "CredentialsProvider", ".", "lookupCredentials", "(", "StandardCredentials", ".", "class", ",", "context", ",", "ACL", ".", "SYSTEM", ",", "URIRequirementBuilder", ".", "fromUri", "(", "repoURL", ".", "toString", "(", ")", ")", ".", "build", "(", ")", ")", ",", "CredentialsMatchers", ".", "withId", "(", "value", ")", ")", ";", "if", "(", "checkRepositoryPath", "(", "repoURL", ",", "credentials", ")", "!=", "SVNNodeKind", ".", "NONE", ")", "{", "SVNRevision", "revision", "=", "getRevisionFromRemoteUrl", "(", "url", ")", ";", "if", "(", "revision", "!=", "null", "&&", "!", "revision", ".", "isValid", "(", ")", ")", "{", "return", "FormValidation", ".", "errorWithMarkup", "(", "hudson", ".", "scm", ".", "subversion", ".", "Messages", ".", "SubversionSCM_doCheckRemote_invalidRevision", "(", ")", ")", ";", "}", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "SVNRepository", "repository", "=", "null", ";", "try", "{", "repository", "=", "getRepository", "(", "repoURL", ",", "credentials", ",", "Collections", ".", "emptyMap", "(", ")", ",", "null", ")", ";", "long", "rev", "=", "repository", ".", "getLatestRevision", "(", ")", ";", "String", "repoPath", "=", "getRelativePath", "(", "repoURL", ",", "repository", ")", ";", "String", "p", "=", "repoPath", ";", "while", "(", "p", ".", "length", "(", ")", ">", "0", ")", "{", "p", "=", "SVNPathUtil", ".", "removeTail", "(", "p", ")", ";", "if", "(", "repository", ".", "checkPath", "(", "p", ",", "rev", ")", "==", "SVNNodeKind", ".", "DIR", ")", "{", "List", "<", "SVNDirEntry", ">", "entries", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "repository", ".", "getDir", "(", "p", ",", "rev", ",", "false", ",", "entries", ")", ";", "List", "<", "String", ">", "paths", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "for", "(", "SVNDirEntry", "e", ":", "entries", ")", "if", "(", "e", ".", "getKind", "(", ")", "==", "SVNNodeKind", ".", "DIR", ")", "paths", ".", "add", "(", "e", ".", "getName", "(", ")", ")", ";", "String", "head", "=", "SVNPathUtil", ".", "head", "(", "repoPath", ".", "substring", "(", "p", ".", "length", "(", ")", "+", "1", ")", ")", ";", "String", "candidate", "=", "EditDistance", ".", "findNearest", "(", "head", ",", "paths", ")", ";", "return", "FormValidation", ".", "error", "(", "hudson", ".", "scm", ".", "subversion", ".", "Messages", ".", "SubversionSCM_doCheckRemote_badPathSuggest", "(", "p", ",", "head", ",", "candidate", "!=", "null", "?", "\"", "/", "\"", "+", "candidate", ":", "\"", "\"", ")", ")", ";", "}", "}", "return", "FormValidation", ".", "error", "(", "hudson", ".", "scm", ".", "subversion", ".", "Messages", ".", "SubversionSCM_doCheckRemote_badPath", "(", "repoPath", ")", ")", ";", "}", "finally", "{", "if", "(", "repository", "!=", "null", ")", "repository", ".", "closeSession", "(", ")", ";", "}", "}", "catch", "(", "SVNException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "INFO", ",", "\"", "Failed to access subversion repository ", "\"", "+", "url", ",", "e", ")", ";", "String", "message", "=", "hudson", ".", "scm", ".", "subversion", ".", "Messages", ".", "SubversionSCM_doCheckRemote_exceptionMsg1", "(", "Util", ".", "escape", "(", "url", ")", ",", "Util", ".", "escape", "(", "e", ".", "getErrorMessage", "(", ")", ".", "getFullMessage", "(", ")", ")", ",", "\"", "javascript:document.getElementById('svnerror').style.display='block';", "\"", "+", "\"", "document.getElementById('svnerrorlink').style.display='none';", "\"", "+", "\"", "return false;", "\"", ")", "+", "\"", "<br/><pre id=", "\\\"", "svnerror", "\\\"", " style=", "\\\"", "display:none", "\\\"", ">", "\"", "+", "Functions", ".", "printThrowable", "(", "e", ")", "+", "\"", "</pre>", "\"", ";", "return", "FormValidation", ".", "errorWithMarkup", "(", "message", ")", ";", "}", "}"], "idx": 80691, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "545ca52", "function_name": "doCheckCredentialsId", "body_hash": "b8f608f7791b3888fefd39cf4bf07723bf6c0141"}
{"code": "private void parse(State state, final String uri)\n        {\n            int mark = 0; // the start of the current section being parsed\n            int pathMark = 0; // the start of the path section\n            int segment = 0; // the start of the current segment within the path\n            boolean encoded = false; // set to true if the path contains % encoded characters\n            boolean dot = false; // set to true if the path containers . or .. segments\n            int escapedSlash = 0; // state of parsing a %2f\n            int end = uri.length();\n            for (int i = 0; i < end; i++)\n            {\n                char c = uri.charAt(i);\n\n                switch (state)\n                {\n                    case START:\n                    {\n                        switch (c)\n                        {\n                            case '/':\n                                mark = i;\n                                state = State.HOST_OR_PATH;\n                                break;\n                            case ';':\n                                mark = i + 1;\n                                state = State.PARAM;\n                                break;\n                            case '?':\n                                // assume empty path (if seen at start)\n                                _path = \"\";\n                                mark = i + 1;\n                                state = State.QUERY;\n                                break;\n                            case '#':\n                                mark = i + 1;\n                                state = State.FRAGMENT;\n                                break;\n                            case '*':\n                                _path = \"*\";\n                                state = State.ASTERISK;\n                                break;\n                            case '%':\n                                encoded = true;\n                                escapedSlash = 1;\n                                mark = pathMark = segment = i;\n                                state = State.PATH;\n                                break;\n                            case '.':\n                                dot = true;\n                                pathMark = segment = i;\n                                state = State.PATH;\n                                break;\n                            default:\n                                mark = i;\n                                if (_scheme == null)\n                                    state = State.SCHEME_OR_PATH;\n                                else\n                                {\n                                    pathMark = segment = i;\n                                    state = State.PATH;\n                                }\n                                break;\n                        }\n                        continue;\n                    }\n\n                    case SCHEME_OR_PATH:\n                    {\n                        switch (c)\n                        {\n                            case ':':\n                                // must have been a scheme\n                                _scheme = uri.substring(mark, i);\n                                // Start again with scheme set\n                                state = State.START;\n                                break;\n                            case '/':\n                                // must have been in a path and still are\n                                segment = i + 1;\n                                state = State.PATH;\n                                break;\n                            case ';':\n                                // must have been in a path\n                                mark = i + 1;\n                                state = State.PARAM;\n                                break;\n                            case '?':\n                                // must have been in a path\n                                _path = uri.substring(mark, i);\n                                mark = i + 1;\n                                state = State.QUERY;\n                                break;\n                            case '%':\n                                // must have be in an encoded path\n                                encoded = true;\n                                escapedSlash = 1;\n                                state = State.PATH;\n                                break;\n                            case '#':\n                                // must have been in a path\n                                _path = uri.substring(mark, i);\n                                state = State.FRAGMENT;\n                                break;\n                            default:\n                                break;\n                        }\n                        continue;\n                    }\n                    case HOST_OR_PATH:\n                    {\n                        switch (c)\n                        {\n                            case '/':\n                                _host = \"\";\n                                mark = i + 1;\n                                state = State.HOST;\n                                break;\n                            case '%':\n                            case '@':\n                            case ';':\n                            case '?':\n                            case '#':\n                            case '.':\n                                // was a path, look again\n                                i--;\n                                pathMark = mark;\n                                segment = mark + 1;\n                                state = State.PATH;\n                                break;\n                            default:\n                                // it is a path\n                                pathMark = mark;\n                                segment = mark + 1;\n                                state = State.PATH;\n                        }\n                        continue;\n                    }\n\n                    case HOST:\n                    {\n                        switch (c)\n                        {\n                            case '/':\n                                _host = uri.substring(mark, i);\n                                pathMark = mark = i;\n                                segment = mark + 1;\n                                state = State.PATH;\n                                break;\n                            case ':':\n                                if (i > mark)\n                                    _host = uri.substring(mark, i);\n                                mark = i + 1;\n                                state = State.PORT;\n                                break;\n                            case '@':\n                                if (_user != null)\n                                    throw new IllegalArgumentException(\"Bad authority\");\n                                _user = uri.substring(mark, i);\n                                mark = i + 1;\n                                break;\n                            case '[':\n                                state = State.IPV6;\n                                break;\n                            default:\n                                break;\n                        }\n                        break;\n                    }\n                    case IPV6:\n                    {\n                        switch (c)\n                        {\n                            case '/':\n                                throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n                            case ']':\n                                c = uri.charAt(++i);\n                                _host = uri.substring(mark, i);\n                                if (c == ':')\n                                {\n                                    mark = i + 1;\n                                    state = State.PORT;\n                                }\n                                else\n                                {\n                                    pathMark = mark = i;\n                                    state = State.PATH;\n                                }\n                                break;\n                            default:\n                                break;\n                        }\n                        break;\n                    }\n                    case PORT:\n                    {\n                        if (c == '@')\n                        {\n                            if (_user != null)\n                                throw new IllegalArgumentException(\"Bad authority\");\n                            // It wasn't a port, but a password!\n                            _user = _host + \":\" + uri.substring(mark, i);\n                            mark = i + 1;\n                            state = State.HOST;\n                        }\n                        else if (c == '/')\n                        {\n                            _port = TypeUtil.parseInt(uri, mark, i - mark, 10);\n                            pathMark = mark = i;\n                            segment = i + 1;\n                            state = State.PATH;\n                        }\n                        break;\n                    }\n                    case PATH:\n                    {\n                        switch (c)\n                        {\n                            case ';':\n                                checkSegment(uri, segment, i, true);\n                                mark = i + 1;\n                                state = State.PARAM;\n                                break;\n                            case '?':\n                                checkSegment(uri, segment, i, false);\n                                _path = uri.substring(pathMark, i);\n                                mark = i + 1;\n                                state = State.QUERY;\n                                break;\n                            case '#':\n                                checkSegment(uri, segment, i, false);\n                                _path = uri.substring(pathMark, i);\n                                mark = i + 1;\n                                state = State.FRAGMENT;\n                                break;\n                            case '/':\n                                checkSegment(uri, segment, i, false);\n                                segment = i + 1;\n                                break;\n                            case '.':\n                                dot |= segment == i;\n                                break;\n                            case '%':\n                                encoded = true;\n                                escapedSlash = 1;\n                                break;\n                            case '2':\n                                escapedSlash = escapedSlash == 1 ? 2 : 0;\n                                break;\n                            case 'f':\n                            case 'F':\n                                if (escapedSlash == 2)\n                                    _ambiguous.add(Ambiguous.SEPARATOR);\n                                escapedSlash = 0;\n                                break;\n                            default:\n                                escapedSlash = 0;\n                                break;\n                        }\n                        break;\n                    }\n                    case PARAM:\n                    {\n                        switch (c)\n                        {\n                            case '?':\n                                _path = uri.substring(pathMark, i);\n                                _param = uri.substring(mark, i);\n                                mark = i + 1;\n                                state = State.QUERY;\n                                break;\n                            case '#':\n                                _path = uri.substring(pathMark, i);\n                                _param = uri.substring(mark, i);\n                                mark = i + 1;\n                                state = State.FRAGMENT;\n                                break;\n                            case '/':\n                                encoded = true;\n                                segment = i + 1;\n                                state = State.PATH;\n                                break;\n                            case ';':\n                                // multiple parameters\n                                mark = i + 1;\n                                break;\n                            default:\n                                break;\n                        }\n                        break;\n                    }\n                    case QUERY:\n                    {\n                        if (c == '#')\n                        {\n                            _query = uri.substring(mark, i);\n                            mark = i + 1;\n                            state = State.FRAGMENT;\n                        }\n                        break;\n                    }\n                    case ASTERISK:\n                    {\n                        throw new IllegalArgumentException(\"Bad character '*'\");\n                    }\n                    case FRAGMENT:\n                    {\n                        _fragment = uri.substring(mark, end);\n                        i = end;\n                        break;\n                    }\n                    default:\n                        throw new IllegalStateException(state.toString());\n                }\n            }\n\n            switch (state)\n            {\n                case START:\n                case ASTERISK:\n                    break;\n                case SCHEME_OR_PATH:\n                case HOST_OR_PATH:\n                    _path = uri.substring(mark, end);\n                    break;\n                case HOST:\n                    if (end > mark)\n                        _host = uri.substring(mark, end);\n                    break;\n                case IPV6:\n                    throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n                case PORT:\n                    _port = TypeUtil.parseInt(uri, mark, end - mark, 10);\n                    break;\n                case PARAM:\n                    _path = uri.substring(pathMark, end);\n                    _param = uri.substring(mark, end);\n                    break;\n                case PATH:\n                    checkSegment(uri, segment, end, false);\n                    _path = uri.substring(pathMark, end);\n                    break;\n                case QUERY:\n                    _query = uri.substring(mark, end);\n                    break;\n                case FRAGMENT:\n                    _fragment = uri.substring(mark, end);\n                    break;\n                default:\n                    throw new IllegalStateException(state.toString());\n            }\n\n            if (!encoded && !dot)\n            {\n                if (_param == null)\n                    _decodedPath = _path;\n                else\n                    _decodedPath = _path.substring(0, _path.length() - _param.length() - 1);\n            }\n            else if (_path != null)\n            {\n                String canonical = URIUtil.canonicalPath(_path);\n                if (canonical == null)\n                    throw new BadMessageException(\"Bad URI\");\n                _decodedPath = URIUtil.decodePath(canonical);\n            }\n        }", "code_tokens": ["private", "void", "parse", "(", "State", "state", ",", "final", "String", "uri", ")", "{", "int", "mark", "=", "0", ";", "int", "pathMark", "=", "0", ";", "int", "segment", "=", "0", ";", "boolean", "encoded", "=", "false", ";", "boolean", "dot", "=", "false", ";", "int", "escapedSlash", "=", "0", ";", "int", "end", "=", "uri", ".", "length", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "end", ";", "i", "++", ")", "{", "char", "c", "=", "uri", ".", "charAt", "(", "i", ")", ";", "switch", "(", "state", ")", "{", "case", "START", ":", "{", "switch", "(", "c", ")", "{", "case", "'/'", ":", "mark", "=", "i", ";", "state", "=", "State", ".", "HOST_OR_PATH", ";", "break", ";", "case", "';'", ":", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PARAM", ";", "break", ";", "case", "'?'", ":", "_path", "=", "\"", "\"", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "QUERY", ";", "break", ";", "case", "'#'", ":", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "FRAGMENT", ";", "break", ";", "case", "'*'", ":", "_path", "=", "\"", "*", "\"", ";", "state", "=", "State", ".", "ASTERISK", ";", "break", ";", "case", "'%'", ":", "encoded", "=", "true", ";", "escapedSlash", "=", "1", ";", "mark", "=", "pathMark", "=", "segment", "=", "i", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "'.'", ":", "dot", "=", "true", ";", "pathMark", "=", "segment", "=", "i", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "default", ":", "mark", "=", "i", ";", "if", "(", "_scheme", "==", "null", ")", "state", "=", "State", ".", "SCHEME_OR_PATH", ";", "else", "{", "pathMark", "=", "segment", "=", "i", ";", "state", "=", "State", ".", "PATH", ";", "}", "break", ";", "}", "continue", ";", "}", "case", "SCHEME_OR_PATH", ":", "{", "switch", "(", "c", ")", "{", "case", "':'", ":", "_scheme", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "state", "=", "State", ".", "START", ";", "break", ";", "case", "'/'", ":", "segment", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "';'", ":", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PARAM", ";", "break", ";", "case", "'?'", ":", "_path", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "QUERY", ";", "break", ";", "case", "'%'", ":", "encoded", "=", "true", ";", "escapedSlash", "=", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "'#'", ":", "_path", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "state", "=", "State", ".", "FRAGMENT", ";", "break", ";", "default", ":", "break", ";", "}", "continue", ";", "}", "case", "HOST_OR_PATH", ":", "{", "switch", "(", "c", ")", "{", "case", "'/'", ":", "_host", "=", "\"", "\"", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "HOST", ";", "break", ";", "case", "'%'", ":", "case", "'@'", ":", "case", "';'", ":", "case", "'?'", ":", "case", "'#'", ":", "case", "'.'", ":", "i", "--", ";", "pathMark", "=", "mark", ";", "segment", "=", "mark", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "default", ":", "pathMark", "=", "mark", ";", "segment", "=", "mark", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "}", "continue", ";", "}", "case", "HOST", ":", "{", "switch", "(", "c", ")", "{", "case", "'/'", ":", "_host", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "pathMark", "=", "mark", "=", "i", ";", "segment", "=", "mark", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "':'", ":", "if", "(", "i", ">", "mark", ")", "_host", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PORT", ";", "break", ";", "case", "'@'", ":", "if", "(", "_user", "!=", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"", "Bad authority", "\"", ")", ";", "_user", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "break", ";", "case", "'['", ":", "state", "=", "State", ".", "IPV6", ";", "break", ";", "default", ":", "break", ";", "}", "break", ";", "}", "case", "IPV6", ":", "{", "switch", "(", "c", ")", "{", "case", "'/'", ":", "throw", "new", "IllegalArgumentException", "(", "\"", "No closing ']' for ipv6 in ", "\"", "+", "uri", ")", ";", "case", "']'", ":", "c", "=", "uri", ".", "charAt", "(", "++", "i", ")", ";", "_host", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "if", "(", "c", "==", "':'", ")", "{", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PORT", ";", "}", "else", "{", "pathMark", "=", "mark", "=", "i", ";", "state", "=", "State", ".", "PATH", ";", "}", "break", ";", "default", ":", "break", ";", "}", "break", ";", "}", "case", "PORT", ":", "{", "if", "(", "c", "==", "'@'", ")", "{", "if", "(", "_user", "!=", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"", "Bad authority", "\"", ")", ";", "_user", "=", "_host", "+", "\"", ":", "\"", "+", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "HOST", ";", "}", "else", "if", "(", "c", "==", "'/'", ")", "{", "_port", "=", "TypeUtil", ".", "parseInt", "(", "uri", ",", "mark", ",", "i", "-", "mark", ",", "10", ")", ";", "pathMark", "=", "mark", "=", "i", ";", "segment", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "}", "break", ";", "}", "case", "PATH", ":", "{", "switch", "(", "c", ")", "{", "case", "';'", ":", "checkSegment", "(", "uri", ",", "segment", ",", "i", ",", "true", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PARAM", ";", "break", ";", "case", "'?'", ":", "checkSegment", "(", "uri", ",", "segment", ",", "i", ",", "false", ")", ";", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "QUERY", ";", "break", ";", "case", "'#'", ":", "checkSegment", "(", "uri", ",", "segment", ",", "i", ",", "false", ")", ";", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "FRAGMENT", ";", "break", ";", "case", "'/'", ":", "checkSegment", "(", "uri", ",", "segment", ",", "i", ",", "false", ")", ";", "segment", "=", "i", "+", "1", ";", "break", ";", "case", "'.'", ":", "dot", "|=", "segment", "==", "i", ";", "break", ";", "case", "'%'", ":", "encoded", "=", "true", ";", "escapedSlash", "=", "1", ";", "break", ";", "case", "'2'", ":", "escapedSlash", "=", "escapedSlash", "==", "1", "?", "2", ":", "0", ";", "break", ";", "case", "'f'", ":", "case", "'F'", ":", "if", "(", "escapedSlash", "==", "2", ")", "_ambiguous", ".", "add", "(", "Ambiguous", ".", "SEPARATOR", ")", ";", "escapedSlash", "=", "0", ";", "break", ";", "default", ":", "escapedSlash", "=", "0", ";", "break", ";", "}", "break", ";", "}", "case", "PARAM", ":", "{", "switch", "(", "c", ")", "{", "case", "'?'", ":", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "i", ")", ";", "_param", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "QUERY", ";", "break", ";", "case", "'#'", ":", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "i", ")", ";", "_param", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "FRAGMENT", ";", "break", ";", "case", "'/'", ":", "encoded", "=", "true", ";", "segment", "=", "i", "+", "1", ";", "state", "=", "State", ".", "PATH", ";", "break", ";", "case", "';'", ":", "mark", "=", "i", "+", "1", ";", "break", ";", "default", ":", "break", ";", "}", "break", ";", "}", "case", "QUERY", ":", "{", "if", "(", "c", "==", "'#'", ")", "{", "_query", "=", "uri", ".", "substring", "(", "mark", ",", "i", ")", ";", "mark", "=", "i", "+", "1", ";", "state", "=", "State", ".", "FRAGMENT", ";", "}", "break", ";", "}", "case", "ASTERISK", ":", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Bad character '*'", "\"", ")", ";", "}", "case", "FRAGMENT", ":", "{", "_fragment", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "i", "=", "end", ";", "break", ";", "}", "default", ":", "throw", "new", "IllegalStateException", "(", "state", ".", "toString", "(", ")", ")", ";", "}", "}", "switch", "(", "state", ")", "{", "case", "START", ":", "case", "ASTERISK", ":", "break", ";", "case", "SCHEME_OR_PATH", ":", "case", "HOST_OR_PATH", ":", "_path", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "case", "HOST", ":", "if", "(", "end", ">", "mark", ")", "_host", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "case", "IPV6", ":", "throw", "new", "IllegalArgumentException", "(", "\"", "No closing ']' for ipv6 in ", "\"", "+", "uri", ")", ";", "case", "PORT", ":", "_port", "=", "TypeUtil", ".", "parseInt", "(", "uri", ",", "mark", ",", "end", "-", "mark", ",", "10", ")", ";", "break", ";", "case", "PARAM", ":", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "end", ")", ";", "_param", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "case", "PATH", ":", "checkSegment", "(", "uri", ",", "segment", ",", "end", ",", "false", ")", ";", "_path", "=", "uri", ".", "substring", "(", "pathMark", ",", "end", ")", ";", "break", ";", "case", "QUERY", ":", "_query", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "case", "FRAGMENT", ":", "_fragment", "=", "uri", ".", "substring", "(", "mark", ",", "end", ")", ";", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "state", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "!", "encoded", "&&", "!", "dot", ")", "{", "if", "(", "_param", "==", "null", ")", "_decodedPath", "=", "_path", ";", "else", "_decodedPath", "=", "_path", ".", "substring", "(", "0", ",", "_path", ".", "length", "(", ")", "-", "_param", ".", "length", "(", ")", "-", "1", ")", ";", "}", "else", "if", "(", "_path", "!=", "null", ")", "{", "String", "canonical", "=", "URIUtil", ".", "canonicalPath", "(", "_path", ")", ";", "if", "(", "canonical", "==", "null", ")", "throw", "new", "BadMessageException", "(", "\"", "Bad URI", "\"", ")", ";", "_decodedPath", "=", "URIUtil", ".", "decodePath", "(", "canonical", ")", ";", "}", "}"], "idx": 114639, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "f58dbedcd05b2aee43c8faa709ba2deaa4361036", "function_name": "parse", "body_hash": "2b25a197c62fc7a683aa30029afe4cc23978a804"}
{"code": "@Override\n    public void servletSecurityAnnotationScan() throws ServletException {\n        if (getServlet() == null) {\n            Class<?> clazz = null;\n            try {\n                clazz = getParent().getLoader().getClassLoader().loadClass(\n                        getServletClass());\n                processServletSecurityAnnotation(clazz);\n            } catch (ClassNotFoundException e) {\n                // Safe to ignore. No class means no annotations to process\n            }\n        } else {\n            if (servletSecurityAnnotationScanRequired) {\n                processServletSecurityAnnotation(getServlet().getClass());\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "servletSecurityAnnotationScan", "(", ")", "throws", "ServletException", "{", "if", "(", "getServlet", "(", ")", "==", "null", ")", "{", "Class", "<", "?", ">", "clazz", "=", "null", ";", "try", "{", "clazz", "=", "getParent", "(", ")", ".", "getLoader", "(", ")", ".", "getClassLoader", "(", ")", ".", "loadClass", "(", "getServletClass", "(", ")", ")", ";", "processServletSecurityAnnotation", "(", "clazz", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "}", "}", "else", "{", "if", "(", "servletSecurityAnnotationScanRequired", ")", "{", "processServletSecurityAnnotation", "(", "getServlet", "(", ")", ".", "getClass", "(", ")", ")", ";", "}", "}", "}"], "idx": 31613, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "299b26af66793438c323ea6b18462fa44683080f", "function_name": "servletSecurityAnnotationScan", "body_hash": "c5786c0da3474d835eaf0c1d79db4ac8c2539fe3"}
{"code": "private void createIdentityZoneHelper(String id) throws Exception {\n        String identityClientWriteToken = testClient.getClientCredentialsOAuthAccessToken(\n            \"identity\",\n            \"identitysecret\",\n            \"zones.write\");\n\n        IdentityZone identityZone = new IdentityZone();\n        SamlConfig samlConfig = new SamlConfig();\n        samlConfig.setCertificate(SERVICE_PROVIDER_CERTIFICATE);\n        samlConfig.setPrivateKey(SERVICE_PROVIDER_KEY);\n        samlConfig.setPrivateKeyPassword(SERVICE_PROVIDER_KEY_PASSWORD);\n        samlConfig.setEntityID(SERVICE_PROVIDER_ID);\n        identityZone.getConfig().setSamlConfig(samlConfig);\n        identityZone.getConfig().setIssuer(DEFAULT_ISSUER_URI);\n        identityZone.setId(id);\n        identityZone.setSubdomain(StringUtils.hasText(id) ? id : new RandomValueStringGenerator().generate());\n        identityZone.setName(\"The Twiglet Zone\");\n\n        IdentityZoneConfiguration brandingConfig = setBranding(identityZone.getConfig());\n        identityZone.setConfig(brandingConfig);\n\n\n        getMockMvc().perform(\n            post(\"/identity-zones\")\n                .header(\"Authorization\", \"Bearer \" + identityClientWriteToken)\n                .contentType(APPLICATION_JSON)\n                .content(JsonUtils.writeValueAsString(identityZone)))\n            .andExpect(status().is(HttpStatus.CREATED.value()));\n    }", "code_tokens": ["private", "void", "createIdentityZoneHelper", "(", "String", "id", ")", "throws", "Exception", "{", "String", "identityClientWriteToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "\"", "identity", "\"", ",", "\"", "identitysecret", "\"", ",", "\"", "zones.write", "\"", ")", ";", "IdentityZone", "identityZone", "=", "new", "IdentityZone", "(", ")", ";", "SamlConfig", "samlConfig", "=", "new", "SamlConfig", "(", ")", ";", "samlConfig", ".", "setCertificate", "(", "SERVICE_PROVIDER_CERTIFICATE", ")", ";", "samlConfig", ".", "setPrivateKey", "(", "SERVICE_PROVIDER_KEY", ")", ";", "samlConfig", ".", "setPrivateKeyPassword", "(", "SERVICE_PROVIDER_KEY_PASSWORD", ")", ";", "samlConfig", ".", "setEntityID", "(", "SERVICE_PROVIDER_ID", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "setSamlConfig", "(", "samlConfig", ")", ";", "identityZone", ".", "getConfig", "(", ")", ".", "setIssuer", "(", "DEFAULT_ISSUER_URI", ")", ";", "identityZone", ".", "setId", "(", "id", ")", ";", "identityZone", ".", "setSubdomain", "(", "StringUtils", ".", "hasText", "(", "id", ")", "?", "id", ":", "new", "RandomValueStringGenerator", "(", ")", ".", "generate", "(", ")", ")", ";", "identityZone", ".", "setName", "(", "\"", "The Twiglet Zone", "\"", ")", ";", "IdentityZoneConfiguration", "brandingConfig", "=", "setBranding", "(", "identityZone", ".", "getConfig", "(", ")", ")", ";", "identityZone", ".", "setConfig", "(", "brandingConfig", ")", ";", "getMockMvc", "(", ")", ".", "perform", "(", "post", "(", "\"", "/identity-zones", "\"", ")", ".", "header", "(", "\"", "Authorization", "\"", ",", "\"", "Bearer ", "\"", "+", "identityClientWriteToken", ")", ".", "contentType", "(", "APPLICATION_JSON", ")", ".", "content", "(", "JsonUtils", ".", "writeValueAsString", "(", "identityZone", ")", ")", ")", ".", "andExpect", "(", "status", "(", ")", ".", "is", "(", "HttpStatus", ".", "CREATED", ".", "value", "(", ")", ")", ")", ";", "}"], "idx": 109251, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "3633a832885ebf33b2e22cc1c0c8ce605e2c657", "function_name": "createIdentityZoneHelper", "body_hash": "9cf9c43f7e4620ac3a98a359bbc1e36ab811254f"}
{"code": "public void handleMessage(Message message) {\n        Exchange ex = message.getExchange();\n        BindingOperationInfo binding = ex.get(BindingOperationInfo.class);\n        if (null != binding && null != binding.getOperationInfo() && binding.getOperationInfo().isOneWay()) {\n            closeInput(message);\n            return;\n        }\n        Message out = ex.getOutMessage();\n        if (out != null) {\n            getBackChannelConduit(message);\n            if (binding != null) {\n                out.put(MessageInfo.class, binding.getOperationInfo().getOutput());\n                out.put(BindingMessageInfo.class, binding.getOutput());\n            }\n            \n            InterceptorChain outChain = out.getInterceptorChain();\n            if (outChain == null) {\n                outChain = OutgoingChainInterceptor.getChain(ex, chainCache);\n                out.setInterceptorChain(outChain);\n            }\n            outChain.doIntercept(out);\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "{", "Exchange", "ex", "=", "message", ".", "getExchange", "(", ")", ";", "BindingOperationInfo", "binding", "=", "ex", ".", "get", "(", "BindingOperationInfo", ".", "class", ")", ";", "if", "(", "null", "!=", "binding", "&&", "null", "!=", "binding", ".", "getOperationInfo", "(", ")", "&&", "binding", ".", "getOperationInfo", "(", ")", ".", "isOneWay", "(", ")", ")", "{", "closeInput", "(", "message", ")", ";", "return", ";", "}", "Message", "out", "=", "ex", ".", "getOutMessage", "(", ")", ";", "if", "(", "out", "!=", "null", ")", "{", "getBackChannelConduit", "(", "message", ")", ";", "if", "(", "binding", "!=", "null", ")", "{", "out", ".", "put", "(", "MessageInfo", ".", "class", ",", "binding", ".", "getOperationInfo", "(", ")", ".", "getOutput", "(", ")", ")", ";", "out", ".", "put", "(", "BindingMessageInfo", ".", "class", ",", "binding", ".", "getOutput", "(", ")", ")", ";", "}", "InterceptorChain", "outChain", "=", "out", ".", "getInterceptorChain", "(", ")", ";", "if", "(", "outChain", "==", "null", ")", "{", "outChain", "=", "OutgoingChainInterceptor", ".", "getChain", "(", "ex", ",", "chainCache", ")", ";", "out", ".", "setInterceptorChain", "(", "outChain", ")", ";", "}", "outChain", ".", "doIntercept", "(", "out", ")", ";", "}", "}"], "idx": 51123, "cwe": "CWE-399", "target": 1, "status": "VULNERABLE", "commit": "35cd29270b77b489cb23552637d66d47ce480f4c", "function_name": "handleMessage", "body_hash": "96e782817dccd16eeacb9e76c902e590d546444b"}
{"code": "public void testInsecureParameters() throws Exception {\n        // given\n        loadConfigurationProviders(new XWorkConfigurationProvider(), new XmlConfigurationProvider(\"xwork-param-test.xml\"));\n        final Map<String, Object> params = new HashMap<String, Object>() {\n            {\n                put(\"name\", \"(#context[\\\"xwork.MethodAccessor.denyMethodExecution\\\"]= new \" +\n                        \"java.lang.Boolean(false), #_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true), \" +\n                        \"@java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)\");\n                put(\"top['name'](0)\", \"true\");\n                put(\"expression\", \"#f=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#f.setAccessible(true),#f.set(#_memberAccess,true),#req=@org.apache.struts2.ServletActionContext@getRequest(),#resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#resp.println(#req.getRealPath('/')),#resp.close()\");\n            }\n        };\n\n        ParametersInterceptor pi = new ParametersInterceptor();\n        container.inject(pi);\n        ValueStack vs = ActionContext.getContext().getValueStack();\n\n        // when\n        ValidateAction action = new ValidateAction();\n        pi.setParameters(action, vs, params);\n\n        // then\n        assertEquals(3, action.getActionMessages().size());\n\n        String msg1 = action.getActionMessage(0);\n        String msg2 = action.getActionMessage(1);\n        String msg3 = action.getActionMessage(2);\n\n        assertEquals(\"Error setting expression 'expression' with value '#f=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#f.setAccessible(true),#f.set(#_memberAccess,true),#req=@org.apache.struts2.ServletActionContext@getRequest(),#resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#resp.println(#req.getRealPath('/')),#resp.close()'\", msg1);\n        assertEquals(\"Error setting expression 'name' with value '(#context[\\\"xwork.MethodAccessor.denyMethodExecution\\\"]= new java.lang.Boolean(false), #_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)'\", msg2);\n        assertEquals(\"Error setting expression 'top['name'](0)' with value 'true'\", msg3);\n        assertNull(action.getName());\n    }", "code_tokens": ["public", "void", "testInsecureParameters", "(", ")", "throws", "Exception", "{", "loadConfigurationProviders", "(", "new", "XWorkConfigurationProvider", "(", ")", ",", "new", "XmlConfigurationProvider", "(", "\"", "xwork-param-test.xml", "\"", ")", ")", ";", "final", "Map", "<", "String", ",", "Object", ">", "params", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", "{", "{", "put", "(", "\"", "name", "\"", ",", "\"", "(#context[", "\\\"", "xwork.MethodAccessor.denyMethodExecution", "\\\"", "]= new ", "\"", "+", "\"", "java.lang.Boolean(false), #_memberAccess[", "\\\"", "allowStaticMethodAccess", "\\\"", "]= new java.lang.Boolean(true), ", "\"", "+", "\"", "@java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)", "\"", ")", ";", "put", "(", "\"", "top['name'](0)", "\"", ",", "\"", "true", "\"", ")", ";", "put", "(", "\"", "expression", "\"", ",", "\"", "#f=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#f.setAccessible(true),#f.set(#_memberAccess,true),#req=@org.apache.struts2.ServletActionContext@getRequest(),#resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#resp.println(#req.getRealPath('/')),#resp.close()", "\"", ")", ";", "}", "}", ";", "ParametersInterceptor", "pi", "=", "new", "ParametersInterceptor", "(", ")", ";", "container", ".", "inject", "(", "pi", ")", ";", "ValueStack", "vs", "=", "ActionContext", ".", "getContext", "(", ")", ".", "getValueStack", "(", ")", ";", "ValidateAction", "action", "=", "new", "ValidateAction", "(", ")", ";", "pi", ".", "setParameters", "(", "action", ",", "vs", ",", "params", ")", ";", "assertEquals", "(", "3", ",", "action", ".", "getActionMessages", "(", ")", ".", "size", "(", ")", ")", ";", "String", "msg1", "=", "action", ".", "getActionMessage", "(", "0", ")", ";", "String", "msg2", "=", "action", ".", "getActionMessage", "(", "1", ")", ";", "String", "msg3", "=", "action", ".", "getActionMessage", "(", "2", ")", ";", "assertEquals", "(", "\"", "Error setting expression 'expression' with value '#f=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#f.setAccessible(true),#f.set(#_memberAccess,true),#req=@org.apache.struts2.ServletActionContext@getRequest(),#resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#resp.println(#req.getRealPath('/')),#resp.close()'", "\"", ",", "msg1", ")", ";", "assertEquals", "(", "\"", "Error setting expression 'name' with value '(#context[", "\\\"", "xwork.MethodAccessor.denyMethodExecution", "\\\"", "]= new java.lang.Boolean(false), #_memberAccess[", "\\\"", "allowStaticMethodAccess", "\\\"", "]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)'", "\"", ",", "msg2", ")", ";", "assertEquals", "(", "\"", "Error setting expression 'top['name'](0)' with value 'true'", "\"", ",", "msg3", ")", ";", "assertNull", "(", "action", ".", "getName", "(", ")", ")", ";", "}"], "idx": 30653, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "74e26830d2849a84729b33497f729e0f033dc147", "function_name": "testInsecureParameters", "body_hash": "91e1fd8aaa94a3ddeb449605bebd22d8ccff8c1a"}
{"code": "public static boolean isSpringJspExpressionSupportActive(PageContext pageContext) {\n\t\tServletContext sc = pageContext.getServletContext();\n\t\tString springJspExpressionSupport = sc.getInitParameter(EXPRESSION_SUPPORT_CONTEXT_PARAM);\n\t\tif (springJspExpressionSupport != null) {\n\t\t\treturn Boolean.valueOf(springJspExpressionSupport);\n\t\t}\n\t\tif (sc.getMajorVersion() >= 3) {\n\t\t\t// We're on a Servlet 3.0+ container: Let's check what the application declares...\n\t\t\tif (sc.getEffectiveMajorVersion() > 2 || sc.getEffectiveMinorVersion() > 3) {\n\t\t\t\t// Application declares Servlet 2.4+ in its web.xml: JSP 2.0 expressions active.\n\t\t\t\t// Skip our own expression support in order to prevent double evaluation.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "code_tokens": ["public", "static", "boolean", "isSpringJspExpressionSupportActive", "(", "PageContext", "pageContext", ")", "{", "ServletContext", "sc", "=", "pageContext", ".", "getServletContext", "(", ")", ";", "String", "springJspExpressionSupport", "=", "sc", ".", "getInitParameter", "(", "EXPRESSION_SUPPORT_CONTEXT_PARAM", ")", ";", "if", "(", "springJspExpressionSupport", "!=", "null", ")", "{", "return", "Boolean", ".", "valueOf", "(", "springJspExpressionSupport", ")", ";", "}", "if", "(", "sc", ".", "getMajorVersion", "(", ")", ">=", "3", ")", "{", "if", "(", "sc", ".", "getEffectiveMajorVersion", "(", ")", ">", "2", "||", "sc", ".", "getEffectiveMinorVersion", "(", ")", ">", "3", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "idx": 2498, "cwe": "CWE-16", "target": 1, "status": "VULNERABLE", "commit": "9772eb8410e37cd0bdec0d1b133218446c778beb", "function_name": "isSpringJspExpressionSupportActive", "body_hash": "cf2349ef695c5872198f34e5ceba57625ec48832"}
{"code": "@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\tif (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse)\n\t\t\t\t|| getNodesCollector().isMonitoringDisabled()) {\n\t\t\tsuper.doFilter(request, response, chain);\n\t\t\treturn;\n\t\t}\n\t\tfinal HttpServletRequest httpRequest = (HttpServletRequest) request;\n\n\t\tfinal String requestURI = httpRequest.getRequestURI();\n\t\tfinal String monitoringUrl = getMonitoringUrl(httpRequest);\n\t\tfinal String monitoringSlavesUrl = monitoringUrl + \"/nodes\";\n\t\tif (!PLUGIN_AUTHENTICATION_DISABLED\n\t\t\t\t&& (requestURI.equals(monitoringUrl) || requestURI.equals(monitoringSlavesUrl))) {\n\t\t\t// only the Hudson/Jenkins administrator can view the monitoring report\n\t\t\tJenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n\t\t}\n\n\t\tif (requestURI.startsWith(monitoringSlavesUrl)) {\n\t\t\tfinal String nodeName;\n\t\t\tif (requestURI.equals(monitoringSlavesUrl)) {\n\t\t\t\tnodeName = null;\n\t\t\t} else {\n\t\t\t\tnodeName = requestURI.substring(monitoringSlavesUrl.length()).replace(\"/\", \"\");\n\t\t\t}\n\t\t\tfinal HttpServletResponse httpResponse = (HttpServletResponse) response;\n\t\t\tdoMonitoring(httpRequest, httpResponse, nodeName);\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.doFilter(request, response, chain);\n\t}", "code_tokens": ["@", "Override", "public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "!", "(", "request", "instanceof", "HttpServletRequest", ")", "||", "!", "(", "response", "instanceof", "HttpServletResponse", ")", "||", "getNodesCollector", "(", ")", ".", "isMonitoringDisabled", "(", ")", ")", "{", "super", ".", "doFilter", "(", "request", ",", "response", ",", "chain", ")", ";", "return", ";", "}", "final", "HttpServletRequest", "httpRequest", "=", "(", "HttpServletRequest", ")", "request", ";", "final", "String", "requestURI", "=", "httpRequest", ".", "getRequestURI", "(", ")", ";", "final", "String", "monitoringUrl", "=", "getMonitoringUrl", "(", "httpRequest", ")", ";", "final", "String", "monitoringSlavesUrl", "=", "monitoringUrl", "+", "\"", "/nodes", "\"", ";", "if", "(", "!", "PLUGIN_AUTHENTICATION_DISABLED", "&&", "(", "requestURI", ".", "equals", "(", "monitoringUrl", ")", "||", "requestURI", ".", "equals", "(", "monitoringSlavesUrl", ")", ")", ")", "{", "Jenkins", ".", "getInstance", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "}", "if", "(", "requestURI", ".", "startsWith", "(", "monitoringSlavesUrl", ")", ")", "{", "final", "String", "nodeName", ";", "if", "(", "requestURI", ".", "equals", "(", "monitoringSlavesUrl", ")", ")", "{", "nodeName", "=", "null", ";", "}", "else", "{", "nodeName", "=", "requestURI", ".", "substring", "(", "monitoringSlavesUrl", ".", "length", "(", ")", ")", ".", "replace", "(", "\"", "/", "\"", ",", "\"", "\"", ")", ";", "}", "final", "HttpServletResponse", "httpResponse", "=", "(", "HttpServletResponse", ")", "response", ";", "doMonitoring", "(", "httpRequest", ",", "httpResponse", ",", "nodeName", ")", ";", "return", ";", "}", "super", ".", "doFilter", "(", "request", ",", "response", ",", "chain", ")", ";", "}"], "idx": 80986, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "f0f6aeef2032696c97d4b015dd51fa2b841b0473", "function_name": "doFilter", "body_hash": "99e9a1f37c096682d293691f1abd08d311a60b57"}
{"code": "@Override\n    public AbstractBuild<?,?> resolveChild(Child child) {\n        MatrixBuild b = (MatrixBuild)owner;\n        return b.getRun(Combination.fromString(child.name));\n    }", "code_tokens": ["@", "Override", "public", "AbstractBuild", "<", "?", ",", "?", ">", "resolveChild", "(", "Child", "child", ")", "{", "MatrixBuild", "b", "=", "(", "MatrixBuild", ")", "owner", ";", "return", "b", ".", "getRun", "(", "Combination", ".", "fromString", "(", "child", ".", "name", ")", ")", ";", "}"], "idx": 110383, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "07c09bebb8396a48063c1da4fc4b628acddd72a8", "function_name": "resolveChild", "body_hash": "003923a0cc9dbcef55ff5902a05d067b3611a08e"}
{"code": "@GET\n    @Produces({\"application/json\", \"application/jwt\" })\n    public Response getUserInfo() {\n        OAuthContext oauth = OAuthContextUtils.getContext(mc);\n        UserInfo userInfo = null;\n        if (userInfoProvider != null) {\n            userInfo = userInfoProvider.getUserInfo(oauth.getClientId(), oauth.getSubject(),\n                OAuthUtils.convertPermissionsToScopeList(oauth.getPermissions()));\n        } else if (oauth.getSubject() instanceof OidcUserSubject) {\n            OidcUserSubject oidcUserSubject = (OidcUserSubject)oauth.getSubject();\n            userInfo = oidcUserSubject.getUserInfo();\n            if (userInfo == null) {\n                userInfo = createFromIdToken(oidcUserSubject.getIdToken());\n            }\n        }\n        if (userInfo == null) {\n            // Consider customizing the error code in case of UserInfo being not available\n            return Response.serverError().build();\n        }\n\n        Object responseEntity = null;\n        // UserInfo may be returned in a clear form as JSON\n        if (super.isJwsRequired() || super.isJweRequired()) {\n            Client client = null;\n            if (oauthDataProvider != null) {\n                client = oauthDataProvider.getClient(oauth.getClientId());\n            }\n            responseEntity = super.processJwt(new JwtToken(userInfo), client);\n        } else {\n            responseEntity = convertUserInfoToResponseEntity(userInfo);\n        }\n        return Response.ok(responseEntity).build();\n\n    }", "code_tokens": ["@", "GET", "@", "Produces", "(", "{", "\"", "application/json", "\"", ",", "\"", "application/jwt", "\"", "}", ")", "public", "Response", "getUserInfo", "(", ")", "{", "OAuthContext", "oauth", "=", "OAuthContextUtils", ".", "getContext", "(", "mc", ")", ";", "UserInfo", "userInfo", "=", "null", ";", "if", "(", "userInfoProvider", "!=", "null", ")", "{", "userInfo", "=", "userInfoProvider", ".", "getUserInfo", "(", "oauth", ".", "getClientId", "(", ")", ",", "oauth", ".", "getSubject", "(", ")", ",", "OAuthUtils", ".", "convertPermissionsToScopeList", "(", "oauth", ".", "getPermissions", "(", ")", ")", ")", ";", "}", "else", "if", "(", "oauth", ".", "getSubject", "(", ")", "instanceof", "OidcUserSubject", ")", "{", "OidcUserSubject", "oidcUserSubject", "=", "(", "OidcUserSubject", ")", "oauth", ".", "getSubject", "(", ")", ";", "userInfo", "=", "oidcUserSubject", ".", "getUserInfo", "(", ")", ";", "if", "(", "userInfo", "==", "null", ")", "{", "userInfo", "=", "createFromIdToken", "(", "oidcUserSubject", ".", "getIdToken", "(", ")", ")", ";", "}", "}", "if", "(", "userInfo", "==", "null", ")", "{", "return", "Response", ".", "serverError", "(", ")", ".", "build", "(", ")", ";", "}", "Object", "responseEntity", "=", "null", ";", "if", "(", "super", ".", "isJwsRequired", "(", ")", "||", "super", ".", "isJweRequired", "(", ")", ")", "{", "Client", "client", "=", "null", ";", "if", "(", "oauthDataProvider", "!=", "null", ")", "{", "client", "=", "oauthDataProvider", ".", "getClient", "(", "oauth", ".", "getClientId", "(", ")", ")", ";", "}", "responseEntity", "=", "super", ".", "processJwt", "(", "new", "JwtToken", "(", "userInfo", ")", ",", "client", ")", ";", "}", "else", "{", "responseEntity", "=", "convertUserInfoToResponseEntity", "(", "userInfo", ")", ";", "}", "return", "Response", ".", "ok", "(", "responseEntity", ")", ".", "build", "(", ")", ";", "}"], "idx": 88924, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "661c271f48", "function_name": "getUserInfo", "body_hash": "652951184aa0545cacc62bcb695b168d38dcda65"}
{"code": "public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)\n            throws PresentationException, IndexUnreachableException {\n        //make sure fileName is a pure filename and not a path\n        fileName = Paths.get(fileName).getFileName().toString();\n        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);\n        if (StringUtils.isNotBlank(fileName)) {\n            dataFolderPath = dataFolderPath.resolve(fileName);\n        }\n        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {\n            return getDataFilePath(pi, altDataFolderName, null, fileName);\n        }\n\n        return dataFolderPath;\n    }", "code_tokens": ["public", "static", "Path", "getDataFilePath", "(", "String", "pi", ",", "String", "dataFolderName", ",", "String", "altDataFolderName", ",", "String", "fileName", ")", "throws", "PresentationException", ",", "IndexUnreachableException", "{", "fileName", "=", "Paths", ".", "get", "(", "fileName", ")", ".", "getFileName", "(", ")", ".", "toString", "(", ")", ";", "java", ".", "nio", ".", "file", ".", "Path", "dataFolderPath", "=", "getDataFolder", "(", "pi", ",", "dataFolderName", ")", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "fileName", ")", ")", "{", "dataFolderPath", "=", "dataFolderPath", ".", "resolve", "(", "fileName", ")", ";", "}", "if", "(", "StringUtils", ".", "isNotBlank", "(", "altDataFolderName", ")", "&&", "!", "Files", ".", "exists", "(", "dataFolderPath", ")", ")", "{", "return", "getDataFilePath", "(", "pi", ",", "altDataFolderName", ",", "null", ",", "fileName", ")", ";", "}", "return", "dataFolderPath", ";", "}"], "idx": 21854, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "44ceb8e2e7e888391e8a941127171d6366770df3", "function_name": "getDataFilePath", "body_hash": "9a01dd8c34812eaa8242fcb404de687df893d88a"}
{"code": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        CrumbIssuer crumbIssuer = getCrumbIssuer();\n        if (crumbIssuer == null || !(request instanceof HttpServletRequest)) {\n            chain.doFilter(request, response);\n            return;\n        }\n\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n\n        if (\"POST\".equals(httpRequest.getMethod())) {\n            for (CrumbExclusion e : CrumbExclusion.all()) {\n                if (e.process(httpRequest,httpResponse,chain))\n                    return;\n            }\n\n            String crumbFieldName = crumbIssuer.getDescriptor().getCrumbRequestField();\n            String crumbSalt = crumbIssuer.getDescriptor().getCrumbSalt();\n\n            String crumb = httpRequest.getHeader(crumbFieldName);\n            boolean valid = false;\n            if (crumb == null) {\n                Enumeration<?> paramNames = request.getParameterNames();\n                while (paramNames.hasMoreElements()) {\n                    String paramName = (String) paramNames.nextElement();\n                    if (crumbFieldName.equals(paramName)) {\n                        crumb = request.getParameter(paramName);\n                        break;\n                    }\n                }\n            }\n            if (crumb != null) {\n                if (crumbIssuer.validateCrumb(httpRequest, crumbSalt, crumb)) {\n                    valid = true;\n                } else {\n                    LOGGER.log(Level.WARNING, \"Found invalid crumb {0}.  Will check remaining parameters for a valid one...\", crumb);\n                }\n            }\n\n            if (valid) {\n                chain.doFilter(request, response);\n            } else {\n                LOGGER.log(Level.WARNING, \"No valid crumb was included in request for {0}. Returning {1}.\", new Object[] {httpRequest.getRequestURI(), HttpServletResponse.SC_FORBIDDEN});\n                httpResponse.sendError(HttpServletResponse.SC_FORBIDDEN,\"No valid crumb was included in the request\");\n            }\n        } else {\n            chain.doFilter(request, response);\n        }\n    }", "code_tokens": ["public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "CrumbIssuer", "crumbIssuer", "=", "getCrumbIssuer", "(", ")", ";", "if", "(", "crumbIssuer", "==", "null", "||", "!", "(", "request", "instanceof", "HttpServletRequest", ")", ")", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "return", ";", "}", "HttpServletRequest", "httpRequest", "=", "(", "HttpServletRequest", ")", "request", ";", "HttpServletResponse", "httpResponse", "=", "(", "HttpServletResponse", ")", "response", ";", "if", "(", "\"", "POST", "\"", ".", "equals", "(", "httpRequest", ".", "getMethod", "(", ")", ")", ")", "{", "for", "(", "CrumbExclusion", "e", ":", "CrumbExclusion", ".", "all", "(", ")", ")", "{", "if", "(", "e", ".", "process", "(", "httpRequest", ",", "httpResponse", ",", "chain", ")", ")", "return", ";", "}", "String", "crumbFieldName", "=", "crumbIssuer", ".", "getDescriptor", "(", ")", ".", "getCrumbRequestField", "(", ")", ";", "String", "crumbSalt", "=", "crumbIssuer", ".", "getDescriptor", "(", ")", ".", "getCrumbSalt", "(", ")", ";", "String", "crumb", "=", "httpRequest", ".", "getHeader", "(", "crumbFieldName", ")", ";", "boolean", "valid", "=", "false", ";", "if", "(", "crumb", "==", "null", ")", "{", "Enumeration", "<", "?", ">", "paramNames", "=", "request", ".", "getParameterNames", "(", ")", ";", "while", "(", "paramNames", ".", "hasMoreElements", "(", ")", ")", "{", "String", "paramName", "=", "(", "String", ")", "paramNames", ".", "nextElement", "(", ")", ";", "if", "(", "crumbFieldName", ".", "equals", "(", "paramName", ")", ")", "{", "crumb", "=", "request", ".", "getParameter", "(", "paramName", ")", ";", "break", ";", "}", "}", "}", "if", "(", "crumb", "!=", "null", ")", "{", "if", "(", "crumbIssuer", ".", "validateCrumb", "(", "httpRequest", ",", "crumbSalt", ",", "crumb", ")", ")", "{", "valid", "=", "true", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "Found invalid crumb {0}.  Will check remaining parameters for a valid one...", "\"", ",", "crumb", ")", ";", "}", "}", "if", "(", "valid", ")", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}", "else", "{", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "No valid crumb was included in request for {0}. Returning {1}.", "\"", ",", "new", "Object", "[", "]", "{", "httpRequest", ".", "getRequestURI", "(", ")", ",", "HttpServletResponse", ".", "SC_FORBIDDEN", "}", ")", ";", "httpResponse", ".", "sendError", "(", "HttpServletResponse", ".", "SC_FORBIDDEN", ",", "\"", "No valid crumb was included in the request", "\"", ")", ";", "}", "}", "else", "{", "chain", ".", "doFilter", "(", "request", ",", "response", ")", ";", "}", "}"], "idx": 99447, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "ef2c0dc163695af3a57ad7a45571293377ff679b", "function_name": "doFilter", "body_hash": "6695931fba1c24051966dc5fbd3c6d8eee81228f"}
{"code": "protected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n        }\n\n        // This is returned from the directory so will be attribute value\n        // escaped if required\n        String dn = user.getDN();\n        // This is the name the user provided to the authentication process so\n        // it will not be escaped\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        // Start with roles retrieved from the user entry\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        // Are we configured to do role searches?\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        // Set up parameters for an appropriate search filter\n        // The dn is already attribute value escaped but the others are not\n        // This is a filter so all input will require filter escaping\n        String filter = connection.roleFormat.format(new String[] {\n                doFilterEscaping(dn),\n                doFilterEscaping(doAttributeValueEscaping(username)),\n                doFilterEscaping(doAttributeValueEscaping(userRoleId)) });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                nameParts[i] = name.get(i);\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        // Perform the configured search and process the results\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;  // Should never happen, but just in case ...\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n                }\n                String dname = getDistinguishedName(connection.context, roleBase, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n                }\n            }\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        // if nested group search is enabled, perform searches for nested groups until no new group is found\n        if (getRoleNested()) {\n\n            // The following efficient algorithm is known as memberOf Algorithm, as described in \"Practices in\n            // Directory Groups\". It avoids group slurping and handles cyclic group memberships as well.\n            // See http://middleware.internet2.edu/dir/ for details\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>(); // Stores the groups we find in this iteration\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    // Group key is already value escaped if required\n                    // Group value is not value escaped\n                    // Everything needs to be filter escaped\n                    filter = connection.roleFormat.format(new String[] {\n                            doFilterEscaping(group.getKey()),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())) });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, roleBase, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n    }", "code_tokens": ["protected", "List", "<", "String", ">", "getRoles", "(", "JNDIConnection", "connection", ",", "User", "user", ")", "throws", "NamingException", "{", "if", "(", "user", "==", "null", ")", "{", "return", "null", ";", "}", "String", "dn", "=", "user", ".", "getDN", "(", ")", ";", "String", "username", "=", "user", ".", "getUserName", "(", ")", ";", "String", "userRoleId", "=", "user", ".", "getUserRoleId", "(", ")", ";", "if", "(", "dn", "==", "null", "||", "username", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  getRoles(", "\"", "+", "dn", "+", "\"", ")", "\"", ")", ";", "}", "List", "<", "String", ">", "list", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "List", "<", "String", ">", "userRoles", "=", "user", ".", "getRoles", "(", ")", ";", "if", "(", "userRoles", "!=", "null", ")", "{", "list", ".", "addAll", "(", "userRoles", ")", ";", "}", "if", "(", "commonRole", "!=", "null", ")", "{", "list", ".", "add", "(", "commonRole", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "list", ".", "size", "(", ")", "+", "\"", " user internal roles", "\"", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found user internal roles ", "\"", "+", "list", ".", "toString", "(", ")", ")", ";", "}", "if", "(", "(", "connection", ".", "roleFormat", "==", "null", ")", "||", "(", "roleName", "==", "null", ")", ")", "{", "return", "list", ";", "}", "String", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "dn", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "username", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "userRoleId", ")", ")", "}", ")", ";", "SearchControls", "controls", "=", "new", "SearchControls", "(", ")", ";", "if", "(", "roleSubtree", ")", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "SUBTREE_SCOPE", ")", ";", "}", "else", "{", "controls", ".", "setSearchScope", "(", "SearchControls", ".", "ONELEVEL_SCOPE", ")", ";", "}", "controls", ".", "setReturningAttributes", "(", "new", "String", "[", "]", "{", "roleName", "}", ")", ";", "String", "base", "=", "null", ";", "if", "(", "connection", ".", "roleBaseFormat", "!=", "null", ")", "{", "NameParser", "np", "=", "connection", ".", "context", ".", "getNameParser", "(", "\"", "\"", ")", ";", "Name", "name", "=", "np", ".", "parse", "(", "dn", ")", ";", "String", "nameParts", "[", "]", "=", "new", "String", "[", "name", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "name", ".", "size", "(", ")", ";", "i", "++", ")", "{", "nameParts", "[", "i", "]", "=", "name", ".", "get", "(", "i", ")", ";", "}", "base", "=", "connection", ".", "roleBaseFormat", ".", "format", "(", "nameParts", ")", ";", "}", "else", "{", "base", "=", "\"", "\"", ";", "}", "NamingEnumeration", "<", "SearchResult", ">", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "base", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "if", "(", "results", "==", "null", ")", "{", "return", "list", ";", "}", "Map", "<", "String", ",", "String", ">", "groupMap", "=", "new", "HashMap", "<", ">", "(", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "Set", "<", "Entry", "<", "String", ",", "String", ">", ">", "entries", "=", "groupMap", ".", "entrySet", "(", ")", ";", "containerLog", ".", "trace", "(", "\"", "  Found ", "\"", "+", "entries", ".", "size", "(", ")", "+", "\"", " direct roles", "\"", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "entry", ":", "entries", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found direct role ", "\"", "+", "entry", ".", "getKey", "(", ")", "+", "\"", " -> ", "\"", "+", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}", "if", "(", "getRoleNested", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newGroups", "=", "new", "HashMap", "<", ">", "(", "groupMap", ")", ";", "while", "(", "!", "newGroups", ".", "isEmpty", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "newThisRound", "=", "new", "HashMap", "<", ">", "(", ")", ";", "for", "(", "Entry", "<", "String", ",", "String", ">", "group", ":", "newGroups", ".", "entrySet", "(", ")", ")", "{", "filter", "=", "connection", ".", "roleFormat", ".", "format", "(", "new", "String", "[", "]", "{", "doFilterEscaping", "(", "group", ".", "getKey", "(", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "group", ".", "getValue", "(", ")", ")", ")", ",", "doFilterEscaping", "(", "doAttributeValueEscaping", "(", "group", ".", "getValue", "(", ")", ")", ")", "}", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "Perform a nested group search with base ", "\"", "+", "roleBase", "+", "\"", " and filter ", "\"", "+", "filter", ")", ";", "}", "results", "=", "searchAsUser", "(", "connection", ".", "context", ",", "user", ",", "roleBase", ",", "filter", ",", "controls", ",", "isRoleSearchAsUser", "(", ")", ")", ";", "try", "{", "while", "(", "results", ".", "hasMore", "(", ")", ")", "{", "SearchResult", "result", "=", "results", ".", "next", "(", ")", ";", "Attributes", "attrs", "=", "result", ".", "getAttributes", "(", ")", ";", "if", "(", "attrs", "==", "null", ")", "{", "continue", ";", "}", "String", "dname", "=", "getDistinguishedName", "(", "connection", ".", "context", ",", "roleBase", ",", "result", ")", ";", "String", "name", "=", "getAttributeValue", "(", "roleName", ",", "attrs", ")", ";", "if", "(", "name", "!=", "null", "&&", "dname", "!=", "null", "&&", "!", "groupMap", ".", "keySet", "(", ")", ".", "contains", "(", "dname", ")", ")", "{", "groupMap", ".", "put", "(", "dname", ",", "name", ")", ";", "newThisRound", ".", "put", "(", "dname", ",", "name", ")", ";", "if", "(", "containerLog", ".", "isTraceEnabled", "(", ")", ")", "{", "containerLog", ".", "trace", "(", "\"", "  Found nested role ", "\"", "+", "dname", "+", "\"", " -> ", "\"", "+", "name", ")", ";", "}", "}", "}", "}", "catch", "(", "PartialResultException", "ex", ")", "{", "if", "(", "!", "adCompat", ")", "{", "throw", "ex", ";", "}", "}", "finally", "{", "results", ".", "close", "(", ")", ";", "}", "}", "newGroups", "=", "newThisRound", ";", "}", "}", "list", ".", "addAll", "(", "groupMap", ".", "values", "(", ")", ")", ";", "return", "list", ";", "}"], "idx": 419, "cwe": "CWE-116", "target": 1, "status": "VULNERABLE", "commit": "81f16b0a7186ed02efbfac336589d6cff28d1e89", "function_name": "getRoles", "body_hash": "0ed8ac69e20c0c620662ece213a41d260a014ed0"}
{"code": "@Override\n    public void testIsXXEVulnerable() throws Exception {\n        try {\n            super.testIsXXEVulnerable();\n            fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n        } catch (final XStreamException e) {\n            final String message = e.getMessage();\n            if (!message.contains(\"DOCTYPE\")) {\n                throw e;\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "testIsXXEVulnerable", "(", ")", "throws", "Exception", "{", "try", "{", "super", ".", "testIsXXEVulnerable", "(", ")", ";", "fail", "(", "\"", "Thrown ", "\"", "+", "XStreamException", ".", "class", ".", "getName", "(", ")", "+", "\"", " expected", "\"", ")", ";", "}", "catch", "(", "final", "XStreamException", "e", ")", "{", "final", "String", "message", "=", "e", ".", "getMessage", "(", ")", ";", "if", "(", "!", "message", ".", "contains", "(", "\"", "DOCTYPE", "\"", ")", ")", "{", "throw", "e", ";", "}", "}", "}"], "idx": 19842, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "25c6704bea149ee93c294ae5b6e0aecd182fea88", "function_name": "testIsXXEVulnerable", "body_hash": "90a526fd95c35f71550e90327ea6e61d8affa3f5"}
{"code": "protected Result findResult(String path, String resultCode, String ext, ActionContext actionContext,\n                                Map<String, ResultTypeConfig> resultsByExtension) {\n        try {\n            boolean traceEnabled = LOG.isTraceEnabled();\n            if (traceEnabled) {\n                LOG.trace(\"Checking ServletContext for [#0]\", path);\n            }\n\n            URL resource = servletContext.getResource(path);\n            if (resource != null && resource.getPath().endsWith(path)) {\n                if (traceEnabled) {\n                    LOG.trace(\"Found resource #0\", resource);\n                }\n                return buildResult(path, resultCode, resultsByExtension.get(ext), actionContext);\n            }\n\n            if (traceEnabled) {\n                LOG.trace(\"Checking ClassLoader for #0\", path);\n            }\n\n            String classLoaderPath = path.startsWith(\"/\") ? path.substring(1, path.length()) : path;\n            resource = ClassLoaderUtil.getResource(classLoaderPath, getClass());\n            if (resource != null && resource.getPath().endsWith(classLoaderPath)) {\n                if (traceEnabled) {\n                    LOG.trace(\"Found resource #0\", resource);\n                }\n                return buildResult(path, resultCode, resultsByExtension.get(ext), actionContext);\n            }\n        } catch (MalformedURLException e) {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Unable to parse template path: [#0] skipping...\", path);\n            }\n        }\n\n        return null;\n    }", "code_tokens": ["protected", "Result", "findResult", "(", "String", "path", ",", "String", "resultCode", ",", "String", "ext", ",", "ActionContext", "actionContext", ",", "Map", "<", "String", ",", "ResultTypeConfig", ">", "resultsByExtension", ")", "{", "try", "{", "boolean", "traceEnabled", "=", "LOG", ".", "isTraceEnabled", "(", ")", ";", "if", "(", "traceEnabled", ")", "{", "LOG", ".", "trace", "(", "\"", "Checking ServletContext for [#0]", "\"", ",", "path", ")", ";", "}", "URL", "resource", "=", "servletContext", ".", "getResource", "(", "path", ")", ";", "if", "(", "resource", "!=", "null", "&&", "resource", ".", "getPath", "(", ")", ".", "endsWith", "(", "path", ")", ")", "{", "if", "(", "traceEnabled", ")", "{", "LOG", ".", "trace", "(", "\"", "Found resource #0", "\"", ",", "resource", ")", ";", "}", "return", "buildResult", "(", "path", ",", "resultCode", ",", "resultsByExtension", ".", "get", "(", "ext", ")", ",", "actionContext", ")", ";", "}", "if", "(", "traceEnabled", ")", "{", "LOG", ".", "trace", "(", "\"", "Checking ClassLoader for #0", "\"", ",", "path", ")", ";", "}", "String", "classLoaderPath", "=", "path", ".", "startsWith", "(", "\"", "/", "\"", ")", "?", "path", ".", "substring", "(", "1", ",", "path", ".", "length", "(", ")", ")", ":", "path", ";", "resource", "=", "ClassLoaderUtil", ".", "getResource", "(", "classLoaderPath", ",", "getClass", "(", ")", ")", ";", "if", "(", "resource", "!=", "null", "&&", "resource", ".", "getPath", "(", ")", ".", "endsWith", "(", "classLoaderPath", ")", ")", "{", "if", "(", "traceEnabled", ")", "{", "LOG", ".", "trace", "(", "\"", "Found resource #0", "\"", ",", "resource", ")", ";", "}", "return", "buildResult", "(", "path", ",", "resultCode", ",", "resultsByExtension", ".", "get", "(", "ext", ")", ",", "actionContext", ")", ";", "}", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "if", "(", "LOG", ".", "isErrorEnabled", "(", ")", ")", "{", "LOG", ".", "error", "(", "\"", "Unable to parse template path: [#0] skipping...", "\"", ",", "path", ")", ";", "}", "}", "return", "null", ";", "}"], "idx": 25803, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "8e67b9144aa643769b261e2492cb561e04d016ab", "function_name": "findResult", "body_hash": "6c38b22c556e2305bbabb82ce2d5c312359951a9"}
{"code": "PublicKey getRemotePublicKey(String nodename) {\n    if (!cores.getZkController().getZkStateReader().getClusterState().getLiveNodes().contains(nodename)) return null;\n    String url = cores.getZkController().getZkStateReader().getBaseUrlForNodeName(nodename);\n    try {\n      String uri = url + PATH + \"?wt=json&omitHeader=true\";\n      log.debug(\"Fetching fresh public key from : {}\",uri);\n      HttpResponse rsp = cores.getUpdateShardHandler().getHttpClient().execute(new HttpGet(uri));\n      byte[] bytes = EntityUtils.toByteArray(rsp.getEntity());\n      Map m = (Map) Utils.fromJSON(bytes);\n      String key = (String) m.get(\"key\");\n      if (key == null) {\n        log.error(\"No key available from \" + url + PATH);\n        return null;\n      } else {\n        log.info(\"New Key obtained from  node: {} / {}\", nodename, key);\n      }\n      PublicKey pubKey = CryptoKeys.deserializeX509PublicKey(key);\n      keyCache.put(nodename, pubKey);\n      return pubKey;\n    } catch (Exception e) {\n      log.error(\"Exception trying to get public key from : \" + url, e);\n      return null;\n    }\n\n  }", "code_tokens": ["PublicKey", "getRemotePublicKey", "(", "String", "nodename", ")", "{", "if", "(", "!", "cores", ".", "getZkController", "(", ")", ".", "getZkStateReader", "(", ")", ".", "getClusterState", "(", ")", ".", "getLiveNodes", "(", ")", ".", "contains", "(", "nodename", ")", ")", "return", "null", ";", "String", "url", "=", "cores", ".", "getZkController", "(", ")", ".", "getZkStateReader", "(", ")", ".", "getBaseUrlForNodeName", "(", "nodename", ")", ";", "try", "{", "String", "uri", "=", "url", "+", "PATH", "+", "\"", "?wt=json&omitHeader=true", "\"", ";", "log", ".", "debug", "(", "\"", "Fetching fresh public key from : {}", "\"", ",", "uri", ")", ";", "HttpResponse", "rsp", "=", "cores", ".", "getUpdateShardHandler", "(", ")", ".", "getHttpClient", "(", ")", ".", "execute", "(", "new", "HttpGet", "(", "uri", ")", ")", ";", "byte", "[", "]", "bytes", "=", "EntityUtils", ".", "toByteArray", "(", "rsp", ".", "getEntity", "(", ")", ")", ";", "Map", "m", "=", "(", "Map", ")", "Utils", ".", "fromJSON", "(", "bytes", ")", ";", "String", "key", "=", "(", "String", ")", "m", ".", "get", "(", "\"", "key", "\"", ")", ";", "if", "(", "key", "==", "null", ")", "{", "log", ".", "error", "(", "\"", "No key available from ", "\"", "+", "url", "+", "PATH", ")", ";", "return", "null", ";", "}", "else", "{", "log", ".", "info", "(", "\"", "New Key obtained from  node: {} / {}", "\"", ",", "nodename", ",", "key", ")", ";", "}", "PublicKey", "pubKey", "=", "CryptoKeys", ".", "deserializeX509PublicKey", "(", "key", ")", ";", "keyCache", ".", "put", "(", "nodename", ",", "pubKey", ")", ";", "return", "pubKey", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "Exception trying to get public key from : ", "\"", "+", "url", ",", "e", ")", ";", "return", "null", ";", "}", "}"], "idx": 39299, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "2f5ecbcf9ed7a3a4fd37b5c55860ad8eace1bea", "function_name": "getRemotePublicKey", "body_hash": "01e90f634ac070dbf869b5db7c51f4117113bb3c"}
{"code": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }", "code_tokens": ["private", "int", "readStored", "(", "final", "byte", "[", "]", "buffer", ",", "final", "int", "offset", ",", "final", "int", "length", ")", "throws", "IOException", "{", "if", "(", "current", ".", "hasDataDescriptor", ")", "{", "if", "(", "lastStoredEntry", "==", "null", ")", "{", "readStoredEntry", "(", ")", ";", "}", "return", "lastStoredEntry", ".", "read", "(", "buffer", ",", "offset", ",", "length", ")", ";", "}", "final", "long", "csize", "=", "current", ".", "entry", ".", "getSize", "(", ")", ";", "if", "(", "current", ".", "bytesRead", ">=", "csize", ")", "{", "return", "-", "1", ";", "}", "if", "(", "buf", ".", "position", "(", ")", ">=", "buf", ".", "limit", "(", ")", ")", "{", "buf", ".", "position", "(", "0", ")", ";", "final", "int", "l", "=", "in", ".", "read", "(", "buf", ".", "array", "(", ")", ")", ";", "if", "(", "l", "==", "-", "1", ")", "{", "return", "-", "1", ";", "}", "buf", ".", "limit", "(", "l", ")", ";", "count", "(", "l", ")", ";", "current", ".", "bytesReadFromStream", "+=", "l", ";", "}", "int", "toRead", "=", "Math", ".", "min", "(", "buf", ".", "remaining", "(", ")", ",", "length", ")", ";", "if", "(", "(", "csize", "-", "current", ".", "bytesRead", ")", "<", "toRead", ")", "{", "toRead", "=", "(", "int", ")", "(", "csize", "-", "current", ".", "bytesRead", ")", ";", "}", "buf", ".", "get", "(", "buffer", ",", "offset", ",", "toRead", ")", ";", "current", ".", "bytesRead", "+=", "toRead", ";", "return", "toRead", ";", "}"], "idx": 82770, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "a41ce6892cb0590b2e658704434ac0dbcb6834c8", "function_name": "readStored", "body_hash": "3812f99c8ec9a42c90ddc35338469c7378f11f64"}
{"code": "private AuthenticationMechanismOutcome handleDigestHeader(HttpServerExchange exchange, final SecurityContext securityContext) {\n        DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);\n        Map<DigestAuthorizationToken, String> parsedHeader = context.getParsedHeader();\n        // Step 1 - Verify the set of tokens received to ensure valid values.\n        Set<DigestAuthorizationToken> mandatoryTokens = EnumSet.copyOf(MANDATORY_REQUEST_TOKENS);\n        if (!supportedAlgorithms.contains(DigestAlgorithm.MD5)) {\n            // If we don't support MD5 then the client must choose an algorithm as we can not fall back to MD5.\n            mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);\n        }\n        if (!supportedQops.isEmpty() && !supportedQops.contains(DigestQop.AUTH)) {\n            // If we do not support auth then we are mandating auth-int so force the client to send a QOP\n            mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);\n        }\n\n        DigestQop qop = null;\n        // This check is early as is increases the list of mandatory tokens.\n        if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {\n            qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n            if (qop == null || !supportedQops.contains(qop)) {\n                // We are also ensuring the client is not trying to force a qop that has been disabled.\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n            context.setQop(qop);\n            mandatoryTokens.add(DigestAuthorizationToken.CNONCE);\n            mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);\n        }\n\n        // Check all mandatory tokens are present.\n        mandatoryTokens.removeAll(parsedHeader.keySet());\n        if (mandatoryTokens.size() > 0) {\n            for (DigestAuthorizationToken currentToken : mandatoryTokens) {\n                // TODO - Need a better check and possible concatenate the list of tokens - however\n                // even having one missing token is not something we should routinely expect.\n                REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());\n            }\n            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // Perform some validation of the remaining tokens.\n        if (!realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM))) {\n            REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),\n                    parsedHeader.get(DigestAuthorizationToken.REALM));\n            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if(parsedHeader.containsKey(DigestAuthorizationToken.DIGEST_URI)) {\n            String uri = parsedHeader.get(DigestAuthorizationToken.DIGEST_URI);\n            String requestURI = exchange.getRequestURI();\n            if(!exchange.getQueryString().isEmpty()) {\n                requestURI = requestURI + \"?\" + exchange.getQueryString();\n            }\n            if(!uri.equals(requestURI)) {\n                //it is possible we were given an absolute URI\n                //we reconstruct the URI from the host header to make sure they match up\n                //I am not sure if this is overly strict, however I think it is better\n                //to be safe than sorry\n                requestURI = exchange.getRequestURL();\n                if(!exchange.getQueryString().isEmpty()) {\n                    requestURI = requestURI + \"?\" + exchange.getQueryString();\n                }\n                if(!uri.equals(requestURI)) {\n                    //just end the auth process\n                    exchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                    exchange.endExchange();\n                    return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n                }\n            }\n        } else {\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {\n            if (!OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE))) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.OPAQUE));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        }\n\n        DigestAlgorithm algorithm;\n        if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {\n            algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n            if (algorithm == null || !supportedAlgorithms.contains(algorithm)) {\n                // We are also ensuring the client is not trying to force an algorithm that has been disabled.\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            // We know this is safe as the algorithm token was made mandatory\n            // if MD5 is not supported.\n            algorithm = DigestAlgorithm.MD5;\n        }\n\n        try {\n            context.setAlgorithm(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            /*\n             * This should not be possible in a properly configured installation.\n             */\n            REQUEST_LOGGER.exceptionProcessingRequest(e);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);\n        final IdentityManager identityManager = getIdentityManager(securityContext);\n        final Account account;\n\n        if (algorithm.isSession()) {\n            /* This can follow one of the following: -\n             *   1 - New session so use DigestCredentialImpl with the IdentityManager to\n             *       create a new session key.\n             *   2 - Obtain the existing session key from the session store and validate it, just use\n             *       IdentityManager to validate account is still active and the current role assignment.\n             */\n            throw new IllegalStateException(\"Not yet implemented.\");\n        } else {\n            final DigestCredential credential = new DigestCredentialImpl(context);\n            account = identityManager.verify(userName, credential);\n        }\n\n        if (account == null) {\n            // Authentication has failed, this could either be caused by the user not-existing or it\n            // could be caused due to an invalid hash.\n            securityContext.authenticationFailed(MESSAGES.authenticationFailed(userName), mechanismName);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // Step 3 - Verify that the nonce was eligible to be used.\n        if (!validateNonceUse(context, parsedHeader, exchange)) {\n            // TODO - This is the right place to make use of the decision but the check needs to be much much sooner\n            // otherwise a failure server\n            // side could leave a packet that could be 're-played' after the failed auth.\n            // The username and password verification passed but for some reason we do not like the nonce.\n            context.markStale();\n            // We do not mark as a failure on the security context as this is not quite a failure, a client with a cached nonce\n            // can easily hit this point.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // We have authenticated the remote user.\n\n        sendAuthenticationInfoHeader(exchange);\n        securityContext.authenticationComplete(account, mechanismName, false);\n        return AuthenticationMechanismOutcome.AUTHENTICATED;\n\n        // Step 4 - Set up any QOP related requirements.\n\n        // TODO - Do QOP\n    }", "code_tokens": ["private", "AuthenticationMechanismOutcome", "handleDigestHeader", "(", "HttpServerExchange", "exchange", ",", "final", "SecurityContext", "securityContext", ")", "{", "DigestContext", "context", "=", "exchange", ".", "getAttachment", "(", "DigestContext", ".", "ATTACHMENT_KEY", ")", ";", "Map", "<", "DigestAuthorizationToken", ",", "String", ">", "parsedHeader", "=", "context", ".", "getParsedHeader", "(", ")", ";", "Set", "<", "DigestAuthorizationToken", ">", "mandatoryTokens", "=", "EnumSet", ".", "copyOf", "(", "MANDATORY_REQUEST_TOKENS", ")", ";", "if", "(", "!", "supportedAlgorithms", ".", "contains", "(", "DigestAlgorithm", ".", "MD5", ")", ")", "{", "mandatoryTokens", ".", "add", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ")", ";", "}", "if", "(", "!", "supportedQops", ".", "isEmpty", "(", ")", "&&", "!", "supportedQops", ".", "contains", "(", "DigestQop", ".", "AUTH", ")", ")", "{", "mandatoryTokens", ".", "add", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ")", ";", "}", "DigestQop", "qop", "=", "null", ";", "if", "(", "parsedHeader", ".", "containsKey", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ")", ")", "{", "qop", "=", "DigestQop", ".", "forName", "(", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ")", ")", ";", "if", "(", "qop", "==", "null", "||", "!", "supportedQops", ".", "contains", "(", "qop", ")", ")", "{", "REQUEST_LOGGER", ".", "invalidTokenReceived", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ".", "getName", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ")", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "context", ".", "setQop", "(", "qop", ")", ";", "mandatoryTokens", ".", "add", "(", "DigestAuthorizationToken", ".", "CNONCE", ")", ";", "mandatoryTokens", ".", "add", "(", "DigestAuthorizationToken", ".", "NONCE_COUNT", ")", ";", "}", "mandatoryTokens", ".", "removeAll", "(", "parsedHeader", ".", "keySet", "(", ")", ")", ";", "if", "(", "mandatoryTokens", ".", "size", "(", ")", ">", "0", ")", "{", "for", "(", "DigestAuthorizationToken", "currentToken", ":", "mandatoryTokens", ")", "{", "REQUEST_LOGGER", ".", "missingAuthorizationToken", "(", "currentToken", ".", "getName", "(", ")", ")", ";", "}", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "if", "(", "!", "realmName", ".", "equals", "(", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "REALM", ")", ")", ")", "{", "REQUEST_LOGGER", ".", "invalidTokenReceived", "(", "DigestAuthorizationToken", ".", "REALM", ".", "getName", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "REALM", ")", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "if", "(", "parsedHeader", ".", "containsKey", "(", "DigestAuthorizationToken", ".", "DIGEST_URI", ")", ")", "{", "String", "uri", "=", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "DIGEST_URI", ")", ";", "String", "requestURI", "=", "exchange", ".", "getRequestURI", "(", ")", ";", "if", "(", "!", "exchange", ".", "getQueryString", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "requestURI", "=", "requestURI", "+", "\"", "?", "\"", "+", "exchange", ".", "getQueryString", "(", ")", ";", "}", "if", "(", "!", "uri", ".", "equals", "(", "requestURI", ")", ")", "{", "requestURI", "=", "exchange", ".", "getRequestURL", "(", ")", ";", "if", "(", "!", "exchange", ".", "getQueryString", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "requestURI", "=", "requestURI", "+", "\"", "?", "\"", "+", "exchange", ".", "getQueryString", "(", ")", ";", "}", "if", "(", "!", "uri", ".", "equals", "(", "requestURI", ")", ")", "{", "exchange", ".", "setStatusCode", "(", "StatusCodes", ".", "BAD_REQUEST", ")", ";", "exchange", ".", "endExchange", "(", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "}", "}", "else", "{", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "if", "(", "parsedHeader", ".", "containsKey", "(", "DigestAuthorizationToken", ".", "OPAQUE", ")", ")", "{", "if", "(", "!", "OPAQUE_VALUE", ".", "equals", "(", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "OPAQUE", ")", ")", ")", "{", "REQUEST_LOGGER", ".", "invalidTokenReceived", "(", "DigestAuthorizationToken", ".", "OPAQUE", ".", "getName", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "OPAQUE", ")", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "}", "DigestAlgorithm", "algorithm", ";", "if", "(", "parsedHeader", ".", "containsKey", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ")", ")", "{", "algorithm", "=", "DigestAlgorithm", ".", "forName", "(", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ")", ")", ";", "if", "(", "algorithm", "==", "null", "||", "!", "supportedAlgorithms", ".", "contains", "(", "algorithm", ")", ")", "{", "REQUEST_LOGGER", ".", "invalidTokenReceived", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ".", "getName", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ")", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "}", "else", "{", "algorithm", "=", "DigestAlgorithm", ".", "MD5", ";", "}", "try", "{", "context", ".", "setAlgorithm", "(", "algorithm", ")", ";", "}", "catch", "(", "NoSuchAlgorithmException", "e", ")", "{", "REQUEST_LOGGER", ".", "exceptionProcessingRequest", "(", "e", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "final", "String", "userName", "=", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "USERNAME", ")", ";", "final", "IdentityManager", "identityManager", "=", "getIdentityManager", "(", "securityContext", ")", ";", "final", "Account", "account", ";", "if", "(", "algorithm", ".", "isSession", "(", ")", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "Not yet implemented.", "\"", ")", ";", "}", "else", "{", "final", "DigestCredential", "credential", "=", "new", "DigestCredentialImpl", "(", "context", ")", ";", "account", "=", "identityManager", ".", "verify", "(", "userName", ",", "credential", ")", ";", "}", "if", "(", "account", "==", "null", ")", "{", "securityContext", ".", "authenticationFailed", "(", "MESSAGES", ".", "authenticationFailed", "(", "userName", ")", ",", "mechanismName", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "if", "(", "!", "validateNonceUse", "(", "context", ",", "parsedHeader", ",", "exchange", ")", ")", "{", "context", ".", "markStale", "(", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "sendAuthenticationInfoHeader", "(", "exchange", ")", ";", "securityContext", ".", "authenticationComplete", "(", "account", ",", "mechanismName", ",", "false", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "AUTHENTICATED", ";", "}"], "idx": 86557, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "8804170ce3186bdd83b486959399ec7ac0f59d0f", "function_name": "handleDigestHeader", "body_hash": "94a893afbf31abe01f9caa42b952afbf92fd037f"}
{"code": "private void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }", "code_tokens": ["private", "void", "close", "(", ")", "{", "connectionState", ".", "set", "(", "ConnectionState", ".", "CLOSED", ")", ";", "try", "{", "socketWrapper", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "upgradeHandler.socketCloseFailed", "\"", ")", ",", "ioe", ")", ";", "}", "}"], "idx": 53638, "cwe": "CWE-404", "target": 1, "status": "VULNERABLE", "commit": "5496e193a89b8b8b3177e516358df2f07ab852b3", "function_name": "close", "body_hash": "81aec11ab94d862666b9562a7306d3dbe0169f04"}
{"code": "@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        checkIllegalTypes(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }", "code_tokens": ["@", "Override", "public", "JsonDeserializer", "<", "Object", ">", "createBeanDeserializer", "(", "DeserializationContext", "ctxt", ",", "JavaType", "type", ",", "BeanDescription", "beanDesc", ")", "throws", "JsonMappingException", "{", "final", "DeserializationConfig", "config", "=", "ctxt", ".", "getConfig", "(", ")", ";", "JsonDeserializer", "<", "Object", ">", "custom", "=", "_findCustomBeanDeserializer", "(", "type", ",", "config", ",", "beanDesc", ")", ";", "if", "(", "custom", "!=", "null", ")", "{", "return", "custom", ";", "}", "if", "(", "type", ".", "isThrowable", "(", ")", ")", "{", "return", "buildThrowableDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "}", "if", "(", "type", ".", "isAbstract", "(", ")", "&&", "!", "type", ".", "isPrimitive", "(", ")", "&&", "!", "type", ".", "isEnumType", "(", ")", ")", "{", "JavaType", "concreteType", "=", "materializeAbstractType", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "if", "(", "concreteType", "!=", "null", ")", "{", "beanDesc", "=", "config", ".", "introspect", "(", "concreteType", ")", ";", "return", "buildBeanDeserializer", "(", "ctxt", ",", "concreteType", ",", "beanDesc", ")", ";", "}", "}", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "JsonDeserializer", "<", "Object", ">", "deser", "=", "(", "JsonDeserializer", "<", "Object", ">", ")", "findStdDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "if", "(", "deser", "!=", "null", ")", "{", "return", "deser", ";", "}", "if", "(", "!", "isPotentialBeanType", "(", "type", ".", "getRawClass", "(", ")", ")", ")", "{", "return", "null", ";", "}", "checkIllegalTypes", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "return", "buildBeanDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "}"], "idx": 2534, "cwe": "CWE-184", "target": 0, "status": "FIXED", "commit": "60d459cedcf079c6106ae7da2ac562bc32dcabe1", "function_name": "createBeanDeserializer", "body_hash": "18808699876c7491f7a417808b001ac282d9f776"}
{"code": "protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        PrintWriter out = response.getWriter();\n        String[] stocks = request.getParameterValues(\"stocks\");\n        if (stocks == null || stocks.length == 0) {\n            out.println(\"<html><body>No <b>stocks</b> query parameter specified. Cannot publish market data</body></html>\");\n        } else {\n            Integer total = (Integer)request.getSession(true).getAttribute(\"total\");\n            if (total == null) {\n                total = Integer.valueOf(0);\n            }\n\n            int count = getNumberOfMessages(request);\n            total = Integer.valueOf(total.intValue() + count);\n            request.getSession().setAttribute(\"total\", total);\n\n            try {\n                WebClient client = WebClient.getWebClient(request);\n                for (int i = 0; i < count; i++) {\n                    sendMessage(client, stocks);\n                }\n                out.print(\"<html><head><meta http-equiv='refresh' content='\");\n                String refreshRate = request.getParameter(\"refresh\");\n                if (refreshRate == null || refreshRate.length() == 0) {\n                    refreshRate = \"1\";\n                }\n                out.print(escape(refreshRate));\n                out.println(\"'/></head>\");\n                out.println(\"<body>Published <b>\" + escape(Integer.toString(count)) + \"</b> of \" + escape(Integer.toString(total))\n                        + \" price messages.  Refresh = \" + escape(refreshRate) + \"s\");\n                out.println(\"</body></html>\");\n\n            } catch (JMSException e) {\n                out.println(\"<html><body>Failed sending price messages due to <b>\" + e + \"</b></body></html>\");\n                log(\"Failed to send message: \" + e, e);\n            }\n        }\n    }", "code_tokens": ["protected", "void", "doGet", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "ServletException", ",", "IOException", "{", "PrintWriter", "out", "=", "response", ".", "getWriter", "(", ")", ";", "String", "[", "]", "stocks", "=", "request", ".", "getParameterValues", "(", "\"", "stocks", "\"", ")", ";", "if", "(", "stocks", "==", "null", "||", "stocks", ".", "length", "==", "0", ")", "{", "out", ".", "println", "(", "\"", "<html><body>No <b>stocks</b> query parameter specified. Cannot publish market data</body></html>", "\"", ")", ";", "}", "else", "{", "Integer", "total", "=", "(", "Integer", ")", "request", ".", "getSession", "(", "true", ")", ".", "getAttribute", "(", "\"", "total", "\"", ")", ";", "if", "(", "total", "==", "null", ")", "{", "total", "=", "Integer", ".", "valueOf", "(", "0", ")", ";", "}", "int", "count", "=", "getNumberOfMessages", "(", "request", ")", ";", "total", "=", "Integer", ".", "valueOf", "(", "total", ".", "intValue", "(", ")", "+", "count", ")", ";", "request", ".", "getSession", "(", ")", ".", "setAttribute", "(", "\"", "total", "\"", ",", "total", ")", ";", "try", "{", "WebClient", "client", "=", "WebClient", ".", "getWebClient", "(", "request", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "{", "sendMessage", "(", "client", ",", "stocks", ")", ";", "}", "out", ".", "print", "(", "\"", "<html><head><meta http-equiv='refresh' content='", "\"", ")", ";", "String", "refreshRate", "=", "request", ".", "getParameter", "(", "\"", "refresh", "\"", ")", ";", "if", "(", "refreshRate", "==", "null", "||", "refreshRate", ".", "length", "(", ")", "==", "0", ")", "{", "refreshRate", "=", "\"", "1", "\"", ";", "}", "out", ".", "print", "(", "escape", "(", "refreshRate", ")", ")", ";", "out", ".", "println", "(", "\"", "'/></head>", "\"", ")", ";", "out", ".", "println", "(", "\"", "<body>Published <b>", "\"", "+", "escape", "(", "Integer", ".", "toString", "(", "count", ")", ")", "+", "\"", "</b> of ", "\"", "+", "escape", "(", "Integer", ".", "toString", "(", "total", ")", ")", "+", "\"", " price messages.  Refresh = ", "\"", "+", "escape", "(", "refreshRate", ")", "+", "\"", "s", "\"", ")", ";", "out", ".", "println", "(", "\"", "</body></html>", "\"", ")", ";", "}", "catch", "(", "JMSException", "e", ")", "{", "out", ".", "println", "(", "\"", "<html><body>Failed sending price messages due to <b>", "\"", "+", "e", "+", "\"", "</b></body></html>", "\"", ")", ";", "log", "(", "\"", "Failed to send message: ", "\"", "+", "e", ",", "e", ")", ";", "}", "}", "}"], "idx": 77492, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "fafd12dfd4f71336f8e32c090d40ed1445959b40", "function_name": "doGet", "body_hash": "933441d28f45c7996593f99b8077e47020712fa4"}
{"code": "public static HttpURLConnection getURLConnection(String url)\n      throws IOException {\n    return (HttpURLConnection) new URL(url).openConnection();\n  }", "code_tokens": ["public", "static", "HttpURLConnection", "getURLConnection", "(", "String", "url", ")", "throws", "IOException", "{", "return", "(", "HttpURLConnection", ")", "new", "URL", "(", "url", ")", ".", "openConnection", "(", ")", ";", "}"], "idx": 40030, "cwe": "CWE-295", "target": 0, "status": "FIXED", "commit": "43eeafcbac29d02c72bd520c003cdfc571de2d15", "function_name": "getURLConnection", "body_hash": "2b44fd179d375584b44ef6a46fd62c2c4eb09d8e"}
{"code": "PublicKey getRemotePublicKey(String nodename) {\n    String url = cores.getZkController().getZkStateReader().getBaseUrlForNodeName(nodename);\n    try {\n      String uri = url + PATH + \"?wt=json&omitHeader=true\";\n      log.debug(\"Fetching fresh public key from : {}\",uri);\n      HttpResponse rsp = cores.getUpdateShardHandler().getHttpClient()\n          .execute(new HttpGet(uri), HttpClientUtil.createNewHttpClientRequestContext());\n      byte[] bytes = EntityUtils.toByteArray(rsp.getEntity());\n      Map m = (Map) Utils.fromJSON(bytes);\n      String key = (String) m.get(\"key\");\n      if (key == null) {\n        log.error(\"No key available from \" + url + PATH);\n        return null;\n      } else {\n        log.info(\"New Key obtained from  node: {} / {}\", nodename, key);\n      }\n      PublicKey pubKey = CryptoKeys.deserializeX509PublicKey(key);\n      keyCache.put(nodename, pubKey);\n      return pubKey;\n    } catch (Exception e) {\n      log.error(\"Exception trying to get public key from : \" + url, e);\n      return null;\n    }\n\n  }", "code_tokens": ["PublicKey", "getRemotePublicKey", "(", "String", "nodename", ")", "{", "String", "url", "=", "cores", ".", "getZkController", "(", ")", ".", "getZkStateReader", "(", ")", ".", "getBaseUrlForNodeName", "(", "nodename", ")", ";", "try", "{", "String", "uri", "=", "url", "+", "PATH", "+", "\"", "?wt=json&omitHeader=true", "\"", ";", "log", ".", "debug", "(", "\"", "Fetching fresh public key from : {}", "\"", ",", "uri", ")", ";", "HttpResponse", "rsp", "=", "cores", ".", "getUpdateShardHandler", "(", ")", ".", "getHttpClient", "(", ")", ".", "execute", "(", "new", "HttpGet", "(", "uri", ")", ",", "HttpClientUtil", ".", "createNewHttpClientRequestContext", "(", ")", ")", ";", "byte", "[", "]", "bytes", "=", "EntityUtils", ".", "toByteArray", "(", "rsp", ".", "getEntity", "(", ")", ")", ";", "Map", "m", "=", "(", "Map", ")", "Utils", ".", "fromJSON", "(", "bytes", ")", ";", "String", "key", "=", "(", "String", ")", "m", ".", "get", "(", "\"", "key", "\"", ")", ";", "if", "(", "key", "==", "null", ")", "{", "log", ".", "error", "(", "\"", "No key available from ", "\"", "+", "url", "+", "PATH", ")", ";", "return", "null", ";", "}", "else", "{", "log", ".", "info", "(", "\"", "New Key obtained from  node: {} / {}", "\"", ",", "nodename", ",", "key", ")", ";", "}", "PublicKey", "pubKey", "=", "CryptoKeys", ".", "deserializeX509PublicKey", "(", "key", ")", ";", "keyCache", ".", "put", "(", "nodename", ",", "pubKey", ")", ";", "return", "pubKey", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"", "Exception trying to get public key from : ", "\"", "+", "url", ",", "e", ")", ";", "return", "null", ";", "}", "}"], "idx": 39391, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "e3b0cfff396a7f92a4f621d598780116da916f3", "function_name": "getRemotePublicKey", "body_hash": "dd50e00e10e0a8b0c1cc766df3a7d72af62ed1c8"}
{"code": "public User getUser(String id) {\n        return User.getById(id, true);\n    }", "code_tokens": ["public", "User", "getUser", "(", "String", "id", ")", "{", "return", "User", ".", "getById", "(", "id", ",", "true", ")", ";", "}"], "idx": 98174, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "01157a699f611ca7492e872103ac01526a982cf2", "function_name": "getUser", "body_hash": "5248ad2e8444041cc763bbf001d2409505570b3d"}
{"code": "public static long readUE7(InputStream stream) throws IOException {\n        int i;\n        long v = 0;\n        while ((i = stream.read()) >= 0) {\n            v = v << 7;\n            if ((i & 128) == 128) {\n                // Continues\n                v += (i & 127);\n            } else {\n                // Last value\n                v += i;\n                break;\n            }\n        }\n        if (i < 0) {\n            throw new IOException(\"Buffer underun; expected one more byte\");\n        }\n        return v;\n    }", "code_tokens": ["public", "static", "long", "readUE7", "(", "InputStream", "stream", ")", "throws", "IOException", "{", "int", "i", ";", "long", "v", "=", "0", ";", "while", "(", "(", "i", "=", "stream", ".", "read", "(", ")", ")", ">=", "0", ")", "{", "v", "=", "v", "<<", "7", ";", "if", "(", "(", "i", "&", "128", ")", "==", "128", ")", "{", "v", "+=", "(", "i", "&", "127", ")", ";", "}", "else", "{", "v", "+=", "i", ";", "break", ";", "}", "}", "if", "(", "i", "<", "0", ")", "{", "throw", "new", "IOException", "(", "\"", "Buffer underun; expected one more byte", "\"", ")", ";", "}", "return", "v", ";", "}"], "idx": 108861, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "302f22aff7a836868b270038e1d66002a2004869", "function_name": "readUE7", "body_hash": "e3d835b26392ec54908ce2bab76fe7b027cc8dd0"}
{"code": "private boolean isInvalidEncodedPath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, \"UTF-8\");\n\t\t\t\tif (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\")) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Ignoring invalid resource path with escape sequences [\" + resourcePath + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\t// Should never happen...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "code_tokens": ["private", "boolean", "isInvalidEncodedPath", "(", "String", "resourcePath", ")", "{", "if", "(", "resourcePath", ".", "contains", "(", "\"", "%", "\"", ")", ")", "{", "try", "{", "String", "decodedPath", "=", "URLDecoder", ".", "decode", "(", "resourcePath", ",", "\"", "UTF-8", "\"", ")", ";", "if", "(", "decodedPath", ".", "contains", "(", "\"", "../", "\"", ")", "||", "decodedPath", ".", "contains", "(", "\"", "..", "\\\\", "\"", ")", ")", "{", "if", "(", "logger", ".", "isTraceEnabled", "(", ")", ")", "{", "logger", ".", "trace", "(", "\"", "Ignoring invalid resource path with escape sequences [", "\"", "+", "resourcePath", "+", "\"", "]", "\"", ")", ";", "}", "return", "true", ";", "}", "}", "catch", "(", "UnsupportedEncodingException", "ex", ")", "{", "}", "}", "return", "false", ";", "}"], "idx": 26707, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "98ad23bef8e2e04143f8f5b201380543a8d8c0c", "function_name": "isInvalidEncodedPath", "body_hash": "0eb651f1e81ccb3847fa35b88c8469d90ddf35f4"}
{"code": "@WebMethod(name=\"heapdump.hprof\")\n        public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n            owner.checkPermission(Jenkins.RUN_SCRIPTS);\n            rsp.setContentType(\"application/octet-stream\");\n\n            FilePath dump = obtain();\n            try {\n                dump.copyTo(rsp.getCompressedOutputStream(req));\n            } finally {\n                dump.delete();\n            }\n        }", "code_tokens": ["@", "WebMethod", "(", "name", "=", "\"", "heapdump.hprof", "\"", ")", "public", "void", "doHeapDump", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "InterruptedException", "{", "owner", ".", "checkPermission", "(", "Jenkins", ".", "RUN_SCRIPTS", ")", ";", "rsp", ".", "setContentType", "(", "\"", "application/octet-stream", "\"", ")", ";", "FilePath", "dump", "=", "obtain", "(", ")", ";", "try", "{", "dump", ".", "copyTo", "(", "rsp", ".", "getCompressedOutputStream", "(", "req", ")", ")", ";", "}", "finally", "{", "dump", ".", "delete", "(", ")", ";", "}", "}"], "idx": 30123, "cwe": "CWE-264", "target": 0, "status": "FIXED", "commit": "0530a6645aac10fec005614211660e98db44b5eb", "function_name": "doHeapDump", "body_hash": "4f0e0d0199c82f2c96729f2e5acb0a15d4d63518"}
{"code": "private static void processHeaderConfig(MultivaluedMap<String, String> httpHeaders, Object object, String key, String prefix) {\n\n        try {\n            String property = StringUtils.removeStart(key, prefix);\n            String setter = property;\n            setter = \"set\"+setter.substring(0,1).toUpperCase(Locale.US)+setter.substring(1);\n            Field field = object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n            //default assume string class\n            //if there's a more specific type, e.g. double, int, boolean\n            //try that.\n            Class clazz = String.class;\n\n            if (field.getType() == int.class) {\n                clazz = int.class;\n            } else if (field.getType() == double.class) {\n                clazz = double.class;\n            } else if (field.getType() == boolean.class) {\n                clazz = boolean.class;\n            }\n\n            Method m = tryToGetMethod(object, setter, clazz);\n            //if you couldn't find more specific setter, back off\n            //to string setter and try that.\n            if (m == null && clazz != String.class) {\n                m = tryToGetMethod(object, setter, String.class);\n            }\n\n            if (m != null) {\n                String val = httpHeaders.getFirst(key);\n                val = val.trim();\n                if (clazz == String.class) {\n                    checkTrustWorthy(setter, val);\n                    m.invoke(object, val);\n                } else if (clazz == int.class) {\n                    m.invoke(object, Integer.parseInt(val));\n                } else if (clazz == double.class) {\n                    m.invoke(object, Double.parseDouble(val));\n                } else if (clazz == boolean.class) {\n                    m.invoke(object, Boolean.parseBoolean(val));\n                } else {\n                    throw new IllegalArgumentException(\"setter must be String, int, double or boolean...for now\");\n                }\n            } else {\n                throw new NoSuchMethodException(\"Couldn't find: \"+setter);\n            }\n\n        } catch (Throwable ex) {\n            throw new WebApplicationException(String.format(Locale.ROOT,\n                    \"%s is an invalid %s header\", key, X_TIKA_OCR_HEADER_PREFIX));\n        }\n    }", "code_tokens": ["private", "static", "void", "processHeaderConfig", "(", "MultivaluedMap", "<", "String", ",", "String", ">", "httpHeaders", ",", "Object", "object", ",", "String", "key", ",", "String", "prefix", ")", "{", "try", "{", "String", "property", "=", "StringUtils", ".", "removeStart", "(", "key", ",", "prefix", ")", ";", "String", "setter", "=", "property", ";", "setter", "=", "\"", "set", "\"", "+", "setter", ".", "substring", "(", "0", ",", "1", ")", ".", "toUpperCase", "(", "Locale", ".", "US", ")", "+", "setter", ".", "substring", "(", "1", ")", ";", "Field", "field", "=", "object", ".", "getClass", "(", ")", ".", "getDeclaredField", "(", "StringUtils", ".", "uncapitalize", "(", "property", ")", ")", ";", "Class", "clazz", "=", "String", ".", "class", ";", "if", "(", "field", ".", "getType", "(", ")", "==", "int", ".", "class", ")", "{", "clazz", "=", "int", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "double", ".", "class", ")", "{", "clazz", "=", "double", ".", "class", ";", "}", "else", "if", "(", "field", ".", "getType", "(", ")", "==", "boolean", ".", "class", ")", "{", "clazz", "=", "boolean", ".", "class", ";", "}", "Method", "m", "=", "tryToGetMethod", "(", "object", ",", "setter", ",", "clazz", ")", ";", "if", "(", "m", "==", "null", "&&", "clazz", "!=", "String", ".", "class", ")", "{", "m", "=", "tryToGetMethod", "(", "object", ",", "setter", ",", "String", ".", "class", ")", ";", "}", "if", "(", "m", "!=", "null", ")", "{", "String", "val", "=", "httpHeaders", ".", "getFirst", "(", "key", ")", ";", "val", "=", "val", ".", "trim", "(", ")", ";", "if", "(", "clazz", "==", "String", ".", "class", ")", "{", "checkTrustWorthy", "(", "setter", ",", "val", ")", ";", "m", ".", "invoke", "(", "object", ",", "val", ")", ";", "}", "else", "if", "(", "clazz", "==", "int", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Integer", ".", "parseInt", "(", "val", ")", ")", ";", "}", "else", "if", "(", "clazz", "==", "double", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Double", ".", "parseDouble", "(", "val", ")", ")", ";", "}", "else", "if", "(", "clazz", "==", "boolean", ".", "class", ")", "{", "m", ".", "invoke", "(", "object", ",", "Boolean", ".", "parseBoolean", "(", "val", ")", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "setter must be String, int, double or boolean...for now", "\"", ")", ";", "}", "}", "else", "{", "throw", "new", "NoSuchMethodException", "(", "\"", "Couldn't find: ", "\"", "+", "setter", ")", ";", "}", "}", "catch", "(", "Throwable", "ex", ")", "{", "throw", "new", "WebApplicationException", "(", "String", ".", "format", "(", "Locale", ".", "ROOT", ",", "\"", "%s is an invalid %s header", "\"", ",", "key", ",", "X_TIKA_OCR_HEADER_PREFIX", ")", ")", ";", "}", "}"], "idx": 109067, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "4fdc51a40bf9532d7db57d0b08c1aec3931468ad", "function_name": "processHeaderConfig", "body_hash": "f0c5dd9b59805f38f047cb18cd01cb20e5f784e2"}
{"code": "default Argument<?> getErrorType(MediaType mediaType) {\n        if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {\n            return Argument.of(JsonError.class);\n        } else if (mediaType.equals(MediaType.APPLICATION_VND_ERROR_TYPE)) {\n            return Argument.of(VndError.class);\n        } else {\n            return Argument.of(String.class);\n        }\n    }", "code_tokens": ["default", "Argument", "<", "?", ">", "getErrorType", "(", "MediaType", "mediaType", ")", "{", "if", "(", "mediaType", ".", "equals", "(", "MediaType", ".", "APPLICATION_JSON_TYPE", ")", ")", "{", "return", "Argument", ".", "of", "(", "JsonError", ".", "class", ")", ";", "}", "else", "if", "(", "mediaType", ".", "equals", "(", "MediaType", ".", "APPLICATION_VND_ERROR_TYPE", ")", ")", "{", "return", "Argument", ".", "of", "(", "VndError", ".", "class", ")", ";", "}", "else", "{", "return", "Argument", ".", "of", "(", "String", ".", "class", ")", ";", "}", "}"], "idx": 52564, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3", "function_name": "getErrorType", "body_hash": "d692f4a0a9ab35500ed77235c7620b54d45051f2"}
{"code": "public String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();\n        return o.toString();\n    }", "code_tokens": ["public", "String", "getPasswordValue", "(", "Object", "o", ")", "{", "if", "(", "o", "==", "null", ")", "return", "null", ";", "if", "(", "o", "instanceof", "Secret", ")", "return", "(", "(", "Secret", ")", "o", ")", ".", "getEncryptedValue", "(", ")", ";", "return", "o", ".", "toString", "(", ")", ";", "}"], "idx": 41362, "cwe": "CWE-310", "target": 1, "status": "VULNERABLE", "commit": "bf539198564a1108b7b71a973bf7de963a6213ef", "function_name": "getPasswordValue", "body_hash": "694a23a6c141a042b9f39ae871605850b6750e5c"}
{"code": "public void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n        byte[] header = new byte[4];\n        IOUtils.readFully(stream, header, 0, 4); // Extract magic byte\n        if (header[0] == (byte) 'i' && header[1] == (byte) 'c'\n                && header[2] == (byte) 'n' && header[3] == (byte) 's') {\n            // Good, signature found\n        } else {\n            throw new TikaException(\"ICNS magic signature invalid\");\n        }\n        IOUtils.readFully(stream, header, 0, 4); //Extract image size/length of bytes in file\n        int image_length = java.nio.ByteBuffer.wrap(header).getInt();\n        if (image_length > MAX_IMAGE_LENGTH_BYTES) {\n            throw new TikaMemoryLimitException(image_length, MAX_IMAGE_LENGTH_BYTES);\n        }\n        byte[] full_file = new byte[image_length];\n        IOUtils.readFully(stream, full_file);\n        ArrayList<ICNSType> icons = new ArrayList<>();\n        ArrayList<ICNSType> icon_masks = new ArrayList<>();\n        byte[] tempByteArray = new byte[4];\n        for (int offset = 0; offset < image_length - 8;) {\n            //Read the ResType/OSTYpe identifier for sub-icon\n            tempByteArray[0] = full_file[offset];\n            tempByteArray[1] = full_file[offset + 1];\n            tempByteArray[2] = full_file[offset + 2];\n            tempByteArray[3] = full_file[offset + 3];\n            ICNSType icnstype = findIconType(tempByteArray);\n\n            if (icnstype == null) {\n                //exit out of loop\n                //No more icons left\n                break;\n            } else if (icnstype.hasMask() == true) {\n                icon_masks.add(findIconType(tempByteArray));\n            } else {\n                icons.add(findIconType(tempByteArray));\n\n            }\n            //Read the sub-icon length\n            tempByteArray[0] = full_file[offset + 4];\n            tempByteArray[1] = full_file[offset + 5];\n            tempByteArray[2] = full_file[offset + 6];\n            tempByteArray[3] = full_file[offset + 7];\n            int icon_length = java.nio.ByteBuffer.wrap(tempByteArray).getInt();\n            if (icon_length <= 0) {\n                break;\n            }\n            offset = offset + icon_length;\n        }\n        String icon_details = \"\", iconmask_details = \"\", bitsPerPixel,dimensions;\n        for (ICNSType icon : icons) {\n             bitsPerPixel = (icon.getBitsPerPixel()!=0)?icon.getBitsPerPixel() + \" bpp\":\"JPEG 2000 or PNG format\";\n             dimensions = (!icon.hasRetinaDisplay())?(icon.getHeight() + \"x\" + icon.getWidth()):(icon.getHeight() + \"x\" + icon.getWidth() + \"@2X\");\n             icon_details = icon_details + \", \" + dimensions + \" (\" + bitsPerPixel + \")\";\n        }\n        for (ICNSType icon : icon_masks) {\n            iconmask_details = iconmask_details + \", \" + icon.getHeight() + \"x\" + icon.getWidth() + \" (\" + icon.getBitsPerPixel() + \" bpp\" + \")\";\n        }\n\n        metadata.set(Metadata.CONTENT_TYPE, ICNS_MIME_TYPE);\n        if (!icon_details.equals(\"\")) {\n            metadata.set(\"Icon count\", String.valueOf(icons.size()));\n            icon_details = icon_details.substring(2);\n            metadata.set(\"Icon details\", icon_details);\n        }\n        if (!iconmask_details.equals(\"\")) {\n            metadata.set(\"Masked icon count\", String.valueOf(icon_masks.size()));\n            iconmask_details = iconmask_details.substring(2);\n            metadata.set(\"Masked icon details\", iconmask_details);\n        }\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        xhtml.endDocument();\n    }", "code_tokens": ["public", "void", "parse", "(", "InputStream", "stream", ",", "ContentHandler", "handler", ",", "Metadata", "metadata", ",", "ParseContext", "context", ")", "throws", "IOException", ",", "SAXException", ",", "TikaException", "{", "byte", "[", "]", "header", "=", "new", "byte", "[", "4", "]", ";", "IOUtils", ".", "readFully", "(", "stream", ",", "header", ",", "0", ",", "4", ")", ";", "if", "(", "header", "[", "0", "]", "==", "(", "byte", ")", "'i'", "&&", "header", "[", "1", "]", "==", "(", "byte", ")", "'c'", "&&", "header", "[", "2", "]", "==", "(", "byte", ")", "'n'", "&&", "header", "[", "3", "]", "==", "(", "byte", ")", "'s'", ")", "{", "}", "else", "{", "throw", "new", "TikaException", "(", "\"", "ICNS magic signature invalid", "\"", ")", ";", "}", "IOUtils", ".", "readFully", "(", "stream", ",", "header", ",", "0", ",", "4", ")", ";", "int", "image_length", "=", "java", ".", "nio", ".", "ByteBuffer", ".", "wrap", "(", "header", ")", ".", "getInt", "(", ")", ";", "if", "(", "image_length", ">", "MAX_IMAGE_LENGTH_BYTES", ")", "{", "throw", "new", "TikaMemoryLimitException", "(", "image_length", ",", "MAX_IMAGE_LENGTH_BYTES", ")", ";", "}", "byte", "[", "]", "full_file", "=", "new", "byte", "[", "image_length", "]", ";", "IOUtils", ".", "readFully", "(", "stream", ",", "full_file", ")", ";", "ArrayList", "<", "ICNSType", ">", "icons", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "ArrayList", "<", "ICNSType", ">", "icon_masks", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "byte", "[", "]", "tempByteArray", "=", "new", "byte", "[", "4", "]", ";", "for", "(", "int", "offset", "=", "0", ";", "offset", "<", "image_length", "-", "8", ";", ")", "{", "tempByteArray", "[", "0", "]", "=", "full_file", "[", "offset", "]", ";", "tempByteArray", "[", "1", "]", "=", "full_file", "[", "offset", "+", "1", "]", ";", "tempByteArray", "[", "2", "]", "=", "full_file", "[", "offset", "+", "2", "]", ";", "tempByteArray", "[", "3", "]", "=", "full_file", "[", "offset", "+", "3", "]", ";", "ICNSType", "icnstype", "=", "findIconType", "(", "tempByteArray", ")", ";", "if", "(", "icnstype", "==", "null", ")", "{", "break", ";", "}", "else", "if", "(", "icnstype", ".", "hasMask", "(", ")", "==", "true", ")", "{", "icon_masks", ".", "add", "(", "findIconType", "(", "tempByteArray", ")", ")", ";", "}", "else", "{", "icons", ".", "add", "(", "findIconType", "(", "tempByteArray", ")", ")", ";", "}", "tempByteArray", "[", "0", "]", "=", "full_file", "[", "offset", "+", "4", "]", ";", "tempByteArray", "[", "1", "]", "=", "full_file", "[", "offset", "+", "5", "]", ";", "tempByteArray", "[", "2", "]", "=", "full_file", "[", "offset", "+", "6", "]", ";", "tempByteArray", "[", "3", "]", "=", "full_file", "[", "offset", "+", "7", "]", ";", "int", "icon_length", "=", "java", ".", "nio", ".", "ByteBuffer", ".", "wrap", "(", "tempByteArray", ")", ".", "getInt", "(", ")", ";", "if", "(", "icon_length", "<=", "0", ")", "{", "break", ";", "}", "offset", "=", "offset", "+", "icon_length", ";", "}", "String", "icon_details", "=", "\"", "\"", ",", "iconmask_details", "=", "\"", "\"", ",", "bitsPerPixel", ",", "dimensions", ";", "for", "(", "ICNSType", "icon", ":", "icons", ")", "{", "bitsPerPixel", "=", "(", "icon", ".", "getBitsPerPixel", "(", ")", "!=", "0", ")", "?", "icon", ".", "getBitsPerPixel", "(", ")", "+", "\"", " bpp", "\"", ":", "\"", "JPEG 2000 or PNG format", "\"", ";", "dimensions", "=", "(", "!", "icon", ".", "hasRetinaDisplay", "(", ")", ")", "?", "(", "icon", ".", "getHeight", "(", ")", "+", "\"", "x", "\"", "+", "icon", ".", "getWidth", "(", ")", ")", ":", "(", "icon", ".", "getHeight", "(", ")", "+", "\"", "x", "\"", "+", "icon", ".", "getWidth", "(", ")", "+", "\"", "@2X", "\"", ")", ";", "icon_details", "=", "icon_details", "+", "\"", ", ", "\"", "+", "dimensions", "+", "\"", " (", "\"", "+", "bitsPerPixel", "+", "\"", ")", "\"", ";", "}", "for", "(", "ICNSType", "icon", ":", "icon_masks", ")", "{", "iconmask_details", "=", "iconmask_details", "+", "\"", ", ", "\"", "+", "icon", ".", "getHeight", "(", ")", "+", "\"", "x", "\"", "+", "icon", ".", "getWidth", "(", ")", "+", "\"", " (", "\"", "+", "icon", ".", "getBitsPerPixel", "(", ")", "+", "\"", " bpp", "\"", "+", "\"", ")", "\"", ";", "}", "metadata", ".", "set", "(", "Metadata", ".", "CONTENT_TYPE", ",", "ICNS_MIME_TYPE", ")", ";", "if", "(", "!", "icon_details", ".", "equals", "(", "\"", "\"", ")", ")", "{", "metadata", ".", "set", "(", "\"", "Icon count", "\"", ",", "String", ".", "valueOf", "(", "icons", ".", "size", "(", ")", ")", ")", ";", "icon_details", "=", "icon_details", ".", "substring", "(", "2", ")", ";", "metadata", ".", "set", "(", "\"", "Icon details", "\"", ",", "icon_details", ")", ";", "}", "if", "(", "!", "iconmask_details", ".", "equals", "(", "\"", "\"", ")", ")", "{", "metadata", ".", "set", "(", "\"", "Masked icon count", "\"", ",", "String", ".", "valueOf", "(", "icon_masks", ".", "size", "(", ")", ")", ")", ";", "iconmask_details", "=", "iconmask_details", ".", "substring", "(", "2", ")", ";", "metadata", ".", "set", "(", "\"", "Masked icon details", "\"", ",", "iconmask_details", ")", ";", "}", "XHTMLContentHandler", "xhtml", "=", "new", "XHTMLContentHandler", "(", "handler", ",", "metadata", ")", ";", "xhtml", ".", "startDocument", "(", ")", ";", "xhtml", ".", "endDocument", "(", ")", ";", "}"], "idx": 83413, "cwe": "CWE-835", "target": 0, "status": "FIXED", "commit": "f9607f9", "function_name": "parse", "body_hash": "2640cff0ed35e364c35bda89bd11405b503ae761"}
{"code": "@GetMapping(\"/callback/{serverId}\")\n    @ApiOperation(value = \"OAuth2.0\u6388\u6743\u5b8c\u6210\u540e\u56de\u8c03\", hidden = true)\n    public RedirectView callback(@RequestParam(defaultValue = \"/\") String redirect,\n                                 @PathVariable String serverId,\n                                 @RequestParam String code,\n                                 @RequestParam String state,\n                                 HttpServletRequest request,\n                                 HttpSession session) throws UnsupportedEncodingException {\n        try {\n            String cachedState = (String) session.getAttribute(STATE_SESSION_KEY);\n            //  if (!state.equals(cachedState)) throw new BusinessException(\"state error\");\n            oAuth2RequestService.doEvent(serverId, new OAuth2CodeAuthBeforeEvent(code, state, request::getParameter));\n            return new RedirectView(URLDecoder.decode(redirect, \"UTF-8\"));\n        } finally {\n            session.removeAttribute(STATE_SESSION_KEY);\n        }\n    }", "code_tokens": ["@", "GetMapping", "(", "\"", "/callback/{serverId}", "\"", ")", "@", "ApiOperation", "(", "value", "=", "\"", "OAuth2.0\u6388\u6743\u5b8c\u6210\u540e\u56de\u8c03", "\"", ",", "hidden", "=", "true", ")", "public", "RedirectView", "callback", "(", "@", "RequestParam", "(", "defaultValue", "=", "\"", "/", "\"", ")", "String", "redirect", ",", "@", "PathVariable", "String", "serverId", ",", "@", "RequestParam", "String", "code", ",", "@", "RequestParam", "String", "state", ",", "HttpServletRequest", "request", ",", "HttpSession", "session", ")", "throws", "UnsupportedEncodingException", "{", "try", "{", "String", "cachedState", "=", "(", "String", ")", "session", ".", "getAttribute", "(", "STATE_SESSION_KEY", ")", ";", "oAuth2RequestService", ".", "doEvent", "(", "serverId", ",", "new", "OAuth2CodeAuthBeforeEvent", "(", "code", ",", "state", ",", "request", "::", "getParameter", ")", ")", ";", "return", "new", "RedirectView", "(", "URLDecoder", ".", "decode", "(", "redirect", ",", "\"", "UTF-8", "\"", ")", ")", ";", "}", "finally", "{", "session", ".", "removeAttribute", "(", "STATE_SESSION_KEY", ")", ";", "}", "}"], "idx": 44792, "cwe": "CWE-352", "target": 1, "status": "VULNERABLE", "commit": "40929e9b0d336a26281a5ed2e0e721d54dd8d2f2", "function_name": "callback", "body_hash": "0cc1330ce72ca3a72832cf5c4e326335f5ae038f"}
{"code": "private ServerWebExchange mapExchange(ServerWebExchange exchange, String methodParamValue) {\n\t\tHttpMethod httpMethod = HttpMethod.resolve(methodParamValue.toUpperCase(Locale.ENGLISH));\n\t\tAssert.notNull(httpMethod, () -> \"HttpMethod '\" + methodParamValue + \"' not supported\");\n\t\tif (ALLOWED_METHODS.contains(httpMethod)) {\n\t\t\treturn exchange.mutate().request(builder -> builder.method(httpMethod)).build();\n\t\t}\n\t\telse {\n\t\t\treturn exchange;\n\t\t}\n\t}", "code_tokens": ["private", "ServerWebExchange", "mapExchange", "(", "ServerWebExchange", "exchange", ",", "String", "methodParamValue", ")", "{", "HttpMethod", "httpMethod", "=", "HttpMethod", ".", "resolve", "(", "methodParamValue", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ")", ";", "Assert", ".", "notNull", "(", "httpMethod", ",", "(", ")", "->", "\"", "HttpMethod '", "\"", "+", "methodParamValue", "+", "\"", "' not supported", "\"", ")", ";", "if", "(", "ALLOWED_METHODS", ".", "contains", "(", "httpMethod", ")", ")", "{", "return", "exchange", ".", "mutate", "(", ")", ".", "request", "(", "builder", "->", "builder", ".", "method", "(", "httpMethod", ")", ")", ".", "build", "(", ")", ";", "}", "else", "{", "return", "exchange", ";", "}", "}"], "idx": 103421, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "dac97f1b7dac3e70ff603fb6fc9f205b95dd6b01", "function_name": "mapExchange", "body_hash": "efadda9a3c01bb986afe6edfc0affcb1f563a15c"}
{"code": "@RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n    public ModelAndView recover(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        String usernameOrEmail = StringUtils.trimToNull(request.getParameter(\"usernameOrEmail\"));\n\n        if (usernameOrEmail != null) {\n\n            map.put(\"usernameOrEmail\", usernameOrEmail);\n            User user = getUserByUsernameOrEmail(usernameOrEmail);\n\n            boolean captchaOk;\n            if (settingsService.isCaptchaEnabled()) {\n                String recaptchaResponse = request.getParameter(\"g-recaptcha-response\");\n                ReCaptcha captcha = new ReCaptcha(settingsService.getRecaptchaSecretKey());\n                captchaOk = recaptchaResponse != null && captcha.isValid(recaptchaResponse);\n            } else {\n                captchaOk = true;\n            }\n            \n            if (!captchaOk) {\n                map.put(\"error\", \"recover.error.invalidcaptcha\");\n            } else if (user == null) {\n                map.put(\"error\", \"recover.error.usernotfound\");\n            } else if (user.getEmail() == null) {\n                map.put(\"error\", \"recover.error.noemail\");\n            } else {\n                StringBuilder sb = new StringBuilder(PASSWORD_LENGTH);\n                for(int i=0; i<PASSWORD_LENGTH; i++) {\n                  int index = random.nextInt(SYMBOLS.length());\n                  sb.append(SYMBOLS.charAt(index));\n                }\n                String password = sb.toString();\n\n                if (emailPassword(password, user.getUsername(), user.getEmail())) {\n                    map.put(\"sentTo\", user.getEmail());\n                    user.setLdapAuthenticated(false);\n                    user.setPassword(password);\n                    securityService.updateUser(user);\n                } else {\n                    map.put(\"error\", \"recover.error.sendfailed\");\n                }\n            }\n        }\n\n        if (settingsService.isCaptchaEnabled()) {\n            map.put(\"recaptchaSiteKey\", settingsService.getRecaptchaSiteKey());\n        }\n\n        return new ModelAndView(\"recover\", \"model\", map);\n    }", "code_tokens": ["@", "RequestMapping", "(", "method", "=", "{", "RequestMethod", ".", "GET", ",", "RequestMethod", ".", "POST", "}", ")", "public", "ModelAndView", "recover", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ")", "throws", "Exception", "{", "Map", "<", "String", ",", "Object", ">", "map", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "String", "usernameOrEmail", "=", "StringUtils", ".", "trimToNull", "(", "request", ".", "getParameter", "(", "\"", "usernameOrEmail", "\"", ")", ")", ";", "if", "(", "usernameOrEmail", "!=", "null", ")", "{", "map", ".", "put", "(", "\"", "usernameOrEmail", "\"", ",", "usernameOrEmail", ")", ";", "User", "user", "=", "getUserByUsernameOrEmail", "(", "usernameOrEmail", ")", ";", "boolean", "captchaOk", ";", "if", "(", "settingsService", ".", "isCaptchaEnabled", "(", ")", ")", "{", "String", "recaptchaResponse", "=", "request", ".", "getParameter", "(", "\"", "g-recaptcha-response", "\"", ")", ";", "ReCaptcha", "captcha", "=", "new", "ReCaptcha", "(", "settingsService", ".", "getRecaptchaSecretKey", "(", ")", ")", ";", "captchaOk", "=", "recaptchaResponse", "!=", "null", "&&", "captcha", ".", "isValid", "(", "recaptchaResponse", ")", ";", "}", "else", "{", "captchaOk", "=", "true", ";", "}", "if", "(", "!", "captchaOk", ")", "{", "map", ".", "put", "(", "\"", "error", "\"", ",", "\"", "recover.error.invalidcaptcha", "\"", ")", ";", "}", "else", "if", "(", "user", "==", "null", ")", "{", "map", ".", "put", "(", "\"", "error", "\"", ",", "\"", "recover.error.usernotfound", "\"", ")", ";", "}", "else", "if", "(", "user", ".", "getEmail", "(", ")", "==", "null", ")", "{", "map", ".", "put", "(", "\"", "error", "\"", ",", "\"", "recover.error.noemail", "\"", ")", ";", "}", "else", "{", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "PASSWORD_LENGTH", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "PASSWORD_LENGTH", ";", "i", "++", ")", "{", "int", "index", "=", "random", ".", "nextInt", "(", "SYMBOLS", ".", "length", "(", ")", ")", ";", "sb", ".", "append", "(", "SYMBOLS", ".", "charAt", "(", "index", ")", ")", ";", "}", "String", "password", "=", "sb", ".", "toString", "(", ")", ";", "if", "(", "emailPassword", "(", "password", ",", "user", ".", "getUsername", "(", ")", ",", "user", ".", "getEmail", "(", ")", ")", ")", "{", "map", ".", "put", "(", "\"", "sentTo", "\"", ",", "user", ".", "getEmail", "(", ")", ")", ";", "user", ".", "setLdapAuthenticated", "(", "false", ")", ";", "user", ".", "setPassword", "(", "password", ")", ";", "securityService", ".", "updateUser", "(", "user", ")", ";", "}", "else", "{", "map", ".", "put", "(", "\"", "error", "\"", ",", "\"", "recover.error.sendfailed", "\"", ")", ";", "}", "}", "}", "if", "(", "settingsService", ".", "isCaptchaEnabled", "(", ")", ")", "{", "map", ".", "put", "(", "\"", "recaptchaSiteKey", "\"", ",", "settingsService", ".", "getRecaptchaSiteKey", "(", ")", ")", ";", "}", "return", "new", "ModelAndView", "(", "\"", "recover", "\"", ",", "\"", "model", "\"", ",", "map", ")", ";", "}"], "idx": 42645, "cwe": "CWE-335", "target": 0, "status": "FIXED", "commit": "61c842923a6d60d4aedd126445a8437b53b752c8", "function_name": "recover", "body_hash": "9a313a37d69df2d7ca0f83cf5097f783896cbeda"}
{"code": "public String getRepoPassword() {\n        return repoPassword == null ? \"admin\" : repoPassword;\n    }", "code_tokens": ["public", "String", "getRepoPassword", "(", ")", "{", "return", "repoPassword", "==", "null", "?", "\"", "admin", "\"", ":", "repoPassword", ";", "}"], "idx": 63886, "cwe": "CWE-522", "target": 1, "status": "VULNERABLE", "commit": "a2511b9", "function_name": "getRepoPassword", "body_hash": "fe11984c478f373c226445e175e00dcbb9f2debd"}
{"code": "public void handleMessage(Message message) throws Fault {\n        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Invoking HTTP method \" + method);\n        }\n        if (!isGET(message)) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"URIMappingInterceptor can only handle HTTP GET, not HTTP \" + method);\n            }\n            return;\n        }\n\n        String opName = getOperationName(message);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"URIMappingInterceptor get operation: \" + opName);\n        }\n        BindingOperationInfo op = ServiceModelUtil.getOperation(message.getExchange(), opName);\n        \n        if (op == null || opName == null || op.getName() == null\n            || StringUtils.isEmpty(op.getName().getLocalPart())\n            || !opName.equals(op.getName().getLocalPart())) {\n            \n            if (!Boolean.TRUE.equals(message.getContextualProperty(NO_VALIDATE_PARTS))) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"NO_OPERATION_PATH\", LOG, opName,\n                                                                       message.get(Message.PATH_INFO)));\n            }\n            MessageContentsList params = new MessageContentsList();\n            params.add(null);\n            message.setContent(List.class, params);\n            if (op == null) {\n                op = findAnyOp(message.getExchange());\n            }\n            if (op != null) {\n                message.getExchange().put(BindingOperationInfo.class, op);\n            }\n        } else {\n            message.getExchange().put(BindingOperationInfo.class, op);\n            MessageContentsList params = getParameters(message, op);\n            message.setContent(List.class, params);\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "throws", "Fault", "{", "String", "method", "=", "(", "String", ")", "message", ".", "get", "(", "Message", ".", "HTTP_REQUEST_METHOD", ")", ";", "if", "(", "LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "Invoking HTTP method ", "\"", "+", "method", ")", ";", "}", "if", "(", "!", "isGET", "(", "message", ")", ")", "{", "if", "(", "LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "LOG", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "URIMappingInterceptor can only handle HTTP GET, not HTTP ", "\"", "+", "method", ")", ";", "}", "return", ";", "}", "String", "opName", "=", "getOperationName", "(", "message", ")", ";", "if", "(", "LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "URIMappingInterceptor get operation: ", "\"", "+", "opName", ")", ";", "}", "BindingOperationInfo", "op", "=", "ServiceModelUtil", ".", "getOperation", "(", "message", ".", "getExchange", "(", ")", ",", "opName", ")", ";", "if", "(", "op", "==", "null", "||", "opName", "==", "null", "||", "op", ".", "getName", "(", ")", "==", "null", "||", "StringUtils", ".", "isEmpty", "(", "op", ".", "getName", "(", ")", ".", "getLocalPart", "(", ")", ")", "||", "!", "opName", ".", "equals", "(", "op", ".", "getName", "(", ")", ".", "getLocalPart", "(", ")", ")", ")", "{", "if", "(", "!", "Boolean", ".", "TRUE", ".", "equals", "(", "message", ".", "getContextualProperty", "(", "NO_VALIDATE_PARTS", ")", ")", ")", "{", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "NO_OPERATION_PATH", "\"", ",", "LOG", ",", "opName", ",", "message", ".", "get", "(", "Message", ".", "PATH_INFO", ")", ")", ")", ";", "}", "MessageContentsList", "params", "=", "new", "MessageContentsList", "(", ")", ";", "params", ".", "add", "(", "null", ")", ";", "message", ".", "setContent", "(", "List", ".", "class", ",", "params", ")", ";", "if", "(", "op", "==", "null", ")", "{", "op", "=", "findAnyOp", "(", "message", ".", "getExchange", "(", ")", ")", ";", "}", "if", "(", "op", "!=", "null", ")", "{", "message", ".", "getExchange", "(", ")", ".", "put", "(", "BindingOperationInfo", ".", "class", ",", "op", ")", ";", "}", "}", "else", "{", "message", ".", "getExchange", "(", ")", ".", "put", "(", "BindingOperationInfo", ".", "class", ",", "op", ")", ";", "MessageContentsList", "params", "=", "getParameters", "(", "message", ",", "op", ")", ";", "message", ".", "setContent", "(", "List", ".", "class", ",", "params", ")", ";", "}", "}"], "idx": 38254, "cwe": "CWE-287", "target": 1, "status": "VULNERABLE", "commit": "db11c9115f31e171de4622149f157d8283f6c720", "function_name": "handleMessage", "body_hash": "526fc5bcfe72ed1bc71391227349913093216ead"}
{"code": "@Before\n    public void setUp() throws Exception {\n        if (originalDatabaseExternalMembers==null) {\n            originalDefaultExternalMembers = (List<String>) getWebApplicationContext().getBean(\"defaultExternalMembers\");\n            originalDatabaseExternalMembers = getWebApplicationContext().getBean(JdbcScimGroupExternalMembershipManager.class).query(\"\");\n        }\n\n        if(bootstrap == null){\n            bootstrap = getWebApplicationContext().getBean(ScimExternalGroupBootstrap.class);\n        }\n\n        if(template == null) {\n            template = getWebApplicationContext().getBean(JdbcTemplate.class);\n        }\n\n        template.update(\"delete from external_group_mapping\");\n        bootstrap.afterPropertiesSet();\n\n        String adminToken = testClient.getClientCredentialsOAuthAccessToken(\"admin\", \"adminsecret\",\n                \"clients.read clients.write clients.secret clients.admin\");\n        clientId = generator.generate().toLowerCase();\n        clientSecret = generator.generate().toLowerCase();\n        String authorities = \"scim.read,scim.write,password.write,oauth.approvals,scim.create\";\n        utils().createClient(this.getMockMvc(), adminToken, clientId, clientSecret, Collections.singleton(\"oauth\"), Arrays.asList(\"foo\",\"bar\",\"scim.read\"), Arrays.asList(\"client_credentials\", \"password\"), authorities);\n        scimReadToken = testClient.getClientCredentialsOAuthAccessToken(clientId, clientSecret,\"scim.read password.write\");\n        scimWriteToken = testClient.getClientCredentialsOAuthAccessToken(clientId, clientSecret,\"scim.write password.write\");\n\n        defaultExternalMembers = new LinkedList<>(originalDefaultExternalMembers);\n        databaseExternalMembers = new LinkedList<>(originalDatabaseExternalMembers);\n\n        scimUser = createUserAndAddToGroups(IdentityZone.getUaa(), new HashSet(Arrays.asList(\"scim.read\", \"scim.write\", \"scim.me\")));\n        scimReadUserToken = testClient.getUserOAuthAccessToken(\"cf\",\"\", scimUser.getUserName(), \"password\", \"scim.read\");\n        identityClientToken = testClient.getClientCredentialsOAuthAccessToken(\"identity\",\"identitysecret\",\"\");\n    }", "code_tokens": ["@", "Before", "public", "void", "setUp", "(", ")", "throws", "Exception", "{", "if", "(", "originalDatabaseExternalMembers", "==", "null", ")", "{", "originalDefaultExternalMembers", "=", "(", "List", "<", "String", ">", ")", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "\"", "defaultExternalMembers", "\"", ")", ";", "originalDatabaseExternalMembers", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "JdbcScimGroupExternalMembershipManager", ".", "class", ")", ".", "query", "(", "\"", "\"", ")", ";", "}", "if", "(", "bootstrap", "==", "null", ")", "{", "bootstrap", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "ScimExternalGroupBootstrap", ".", "class", ")", ";", "}", "if", "(", "template", "==", "null", ")", "{", "template", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "JdbcTemplate", ".", "class", ")", ";", "}", "template", ".", "update", "(", "\"", "delete from external_group_mapping", "\"", ")", ";", "bootstrap", ".", "afterPropertiesSet", "(", ")", ";", "String", "adminToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "\"", "admin", "\"", ",", "\"", "adminsecret", "\"", ",", "\"", "clients.read clients.write clients.secret clients.admin", "\"", ")", ";", "clientId", "=", "generator", ".", "generate", "(", ")", ".", "toLowerCase", "(", ")", ";", "clientSecret", "=", "generator", ".", "generate", "(", ")", ".", "toLowerCase", "(", ")", ";", "String", "authorities", "=", "\"", "scim.read,scim.write,password.write,oauth.approvals,scim.create", "\"", ";", "utils", "(", ")", ".", "createClient", "(", "this", ".", "getMockMvc", "(", ")", ",", "adminToken", ",", "clientId", ",", "clientSecret", ",", "Collections", ".", "singleton", "(", "\"", "oauth", "\"", ")", ",", "Arrays", ".", "asList", "(", "\"", "foo", "\"", ",", "\"", "bar", "\"", ",", "\"", "scim.read", "\"", ")", ",", "Arrays", ".", "asList", "(", "\"", "client_credentials", "\"", ",", "\"", "password", "\"", ")", ",", "authorities", ")", ";", "scimReadToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "clientId", ",", "clientSecret", ",", "\"", "scim.read password.write", "\"", ")", ";", "scimWriteToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "clientId", ",", "clientSecret", ",", "\"", "scim.write password.write", "\"", ")", ";", "defaultExternalMembers", "=", "new", "LinkedList", "<", ">", "(", "originalDefaultExternalMembers", ")", ";", "databaseExternalMembers", "=", "new", "LinkedList", "<", ">", "(", "originalDatabaseExternalMembers", ")", ";", "scimUser", "=", "createUserAndAddToGroups", "(", "IdentityZone", ".", "getUaa", "(", ")", ",", "new", "HashSet", "(", "Arrays", ".", "asList", "(", "\"", "scim.read", "\"", ",", "\"", "scim.write", "\"", ",", "\"", "scim.me", "\"", ")", ")", ")", ";", "scimReadUserToken", "=", "testClient", ".", "getUserOAuthAccessToken", "(", "\"", "cf", "\"", ",", "\"", "\"", ",", "scimUser", ".", "getUserName", "(", ")", ",", "\"", "password", "\"", ",", "\"", "scim.read", "\"", ")", ";", "identityClientToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "\"", "identity", "\"", ",", "\"", "identitysecret", "\"", ",", "\"", "\"", ")", ";", "}"], "idx": 36082, "cwe": "CWE-269", "target": 1, "status": "VULNERABLE", "commit": "9d44cb0c7c25ccae95bfa1c2d59ce46200c643cb", "function_name": "setUp", "body_hash": "07d56a10b08bc4a3a4aef747caa42532d662d52c"}
{"code": "@RequirePOST\n        public FormValidation doCheckCredentialsId(StaplerRequest req, @AncestorInPath Item context, @QueryParameter String remoteBase, @QueryParameter String value) {\n            // TODO suspiciously similar to SubversionSCM.ModuleLocation.DescriptorImpl.checkCredentialsId; refactor into shared method?\n            // Test the connection only if we may use the credentials\n            if (context == null && !Jenkins.get().hasPermission(Jenkins.ADMINISTER) ||\n                context != null && !context.hasPermission(CredentialsProvider.USE_ITEM)) {\n                return FormValidation.ok();\n            }\n\n            // if check remote is reporting an issue then we don't need to\n            String url = Util.fixEmptyAndTrim(remoteBase);\n            if (url == null)\n                return FormValidation.ok();\n\n            if(!URL_PATTERN.matcher(url).matches())\n                return FormValidation.ok();\n\n            try {\n                String urlWithoutRevision = SvnHelper.getUrlWithoutRevision(url);\n\n                SVNURL repoURL = SVNURL.parseURIDecoded(urlWithoutRevision);\n\n                StandardCredentials credentials = value == null ? null :\n                        CredentialsMatchers.firstOrNull(CredentialsProvider\n                                .lookupCredentials(StandardCredentials.class, context, ACL.SYSTEM,\n                                        URIRequirementBuilder.fromUri(repoURL.toString()).build()),\n                                CredentialsMatchers.withId(value));\n                if (checkRepositoryPath(repoURL, credentials)!=SVNNodeKind.NONE) {\n                    // something exists; now check revision if any\n\n                    SVNRevision revision = getRevisionFromRemoteUrl(url);\n                    if (revision != null && !revision.isValid()) {\n                        return FormValidation.errorWithMarkup(\n                                hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_invalidRevision());\n                    }\n\n                    return FormValidation.ok();\n                }\n\n                SVNRepository repository = null;\n                try {\n                    repository = getRepository(repoURL, credentials,\n                            Collections.emptyMap(), null);\n                    long rev = repository.getLatestRevision();\n                    // now go back the tree and find if there's anything that exists\n                    String repoPath = getRelativePath(repoURL, repository);\n                    String p = repoPath;\n                    while(p.length()>0) {\n                        p = SVNPathUtil.removeTail(p);\n                        if(repository.checkPath(p,rev)==SVNNodeKind.DIR) {\n                            // found a matching path\n                            List<SVNDirEntry> entries = new ArrayList<>();\n                            repository.getDir(p,rev,false,entries);\n\n                            // build up the name list\n                            List<String> paths = new ArrayList<>();\n                            for (SVNDirEntry e : entries)\n                                if(e.getKind()==SVNNodeKind.DIR)\n                                    paths.add(e.getName());\n\n                            String head = SVNPathUtil.head(repoPath.substring(p.length() + 1));\n                            String candidate = EditDistance.findNearest(head, paths);\n\n                            return FormValidation.error(\n                                hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_badPathSuggest(p, head,\n                                        candidate != null ? \"/\" + candidate : \"\"));\n                        }\n                    }\n\n                    return FormValidation.error(\n                        hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_badPath(repoPath));\n                } finally {\n                    if (repository != null)\n                        repository.closeSession();\n                }\n            } catch (SVNException e) {\n                LOGGER.log(Level.INFO, \"Failed to access subversion repository \"+url,e);\n                String message = hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_exceptionMsg1(\n                        Util.escape(url), Util.escape(e.getErrorMessage().getFullMessage()),\n                        \"javascript:document.getElementById('svnerror').style.display='block';\"\n                                + \"document.getElementById('svnerrorlink').style.display='none';\"\n                                + \"return false;\")\n                  + \"<br/><pre id=\\\"svnerror\\\" style=\\\"display:none\\\">\"\n                  + Util.xmlEscape(Functions.printThrowable(e)) + \"</pre>\";\n                return FormValidation.errorWithMarkup(message);\n            }\n        }", "code_tokens": ["@", "RequirePOST", "public", "FormValidation", "doCheckCredentialsId", "(", "StaplerRequest", "req", ",", "@", "AncestorInPath", "Item", "context", ",", "@", "QueryParameter", "String", "remoteBase", ",", "@", "QueryParameter", "String", "value", ")", "{", "if", "(", "context", "==", "null", "&&", "!", "Jenkins", ".", "get", "(", ")", ".", "hasPermission", "(", "Jenkins", ".", "ADMINISTER", ")", "||", "context", "!=", "null", "&&", "!", "context", ".", "hasPermission", "(", "CredentialsProvider", ".", "USE_ITEM", ")", ")", "{", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "String", "url", "=", "Util", ".", "fixEmptyAndTrim", "(", "remoteBase", ")", ";", "if", "(", "url", "==", "null", ")", "return", "FormValidation", ".", "ok", "(", ")", ";", "if", "(", "!", "URL_PATTERN", ".", "matcher", "(", "url", ")", ".", "matches", "(", ")", ")", "return", "FormValidation", ".", "ok", "(", ")", ";", "try", "{", "String", "urlWithoutRevision", "=", "SvnHelper", ".", "getUrlWithoutRevision", "(", "url", ")", ";", "SVNURL", "repoURL", "=", "SVNURL", ".", "parseURIDecoded", "(", "urlWithoutRevision", ")", ";", "StandardCredentials", "credentials", "=", "value", "==", "null", "?", "null", ":", "CredentialsMatchers", ".", "firstOrNull", "(", "CredentialsProvider", ".", "lookupCredentials", "(", "StandardCredentials", ".", "class", ",", "context", ",", "ACL", ".", "SYSTEM", ",", "URIRequirementBuilder", ".", "fromUri", "(", "repoURL", ".", "toString", "(", ")", ")", ".", "build", "(", ")", ")", ",", "CredentialsMatchers", ".", "withId", "(", "value", ")", ")", ";", "if", "(", "checkRepositoryPath", "(", "repoURL", ",", "credentials", ")", "!=", "SVNNodeKind", ".", "NONE", ")", "{", "SVNRevision", "revision", "=", "getRevisionFromRemoteUrl", "(", "url", ")", ";", "if", "(", "revision", "!=", "null", "&&", "!", "revision", ".", "isValid", "(", ")", ")", "{", "return", "FormValidation", ".", "errorWithMarkup", "(", "hudson", ".", "scm", ".", "subversion", ".", "Messages", ".", "SubversionSCM_doCheckRemote_invalidRevision", "(", ")", ")", ";", "}", "return", "FormValidation", ".", "ok", "(", ")", ";", "}", "SVNRepository", "repository", "=", "null", ";", "try", "{", "repository", "=", "getRepository", "(", "repoURL", ",", "credentials", ",", "Collections", ".", "emptyMap", "(", ")", ",", "null", ")", ";", "long", "rev", "=", "repository", ".", "getLatestRevision", "(", ")", ";", "String", "repoPath", "=", "getRelativePath", "(", "repoURL", ",", "repository", ")", ";", "String", "p", "=", "repoPath", ";", "while", "(", "p", ".", "length", "(", ")", ">", "0", ")", "{", "p", "=", "SVNPathUtil", ".", "removeTail", "(", "p", ")", ";", "if", "(", "repository", ".", "checkPath", "(", "p", ",", "rev", ")", "==", "SVNNodeKind", ".", "DIR", ")", "{", "List", "<", "SVNDirEntry", ">", "entries", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "repository", ".", "getDir", "(", "p", ",", "rev", ",", "false", ",", "entries", ")", ";", "List", "<", "String", ">", "paths", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "for", "(", "SVNDirEntry", "e", ":", "entries", ")", "if", "(", "e", ".", "getKind", "(", ")", "==", "SVNNodeKind", ".", "DIR", ")", "paths", ".", "add", "(", "e", ".", "getName", "(", ")", ")", ";", "String", "head", "=", "SVNPathUtil", ".", "head", "(", "repoPath", ".", "substring", "(", "p", ".", "length", "(", ")", "+", "1", ")", ")", ";", "String", "candidate", "=", "EditDistance", ".", "findNearest", "(", "head", ",", "paths", ")", ";", "return", "FormValidation", ".", "error", "(", "hudson", ".", "scm", ".", "subversion", ".", "Messages", ".", "SubversionSCM_doCheckRemote_badPathSuggest", "(", "p", ",", "head", ",", "candidate", "!=", "null", "?", "\"", "/", "\"", "+", "candidate", ":", "\"", "\"", ")", ")", ";", "}", "}", "return", "FormValidation", ".", "error", "(", "hudson", ".", "scm", ".", "subversion", ".", "Messages", ".", "SubversionSCM_doCheckRemote_badPath", "(", "repoPath", ")", ")", ";", "}", "finally", "{", "if", "(", "repository", "!=", "null", ")", "repository", ".", "closeSession", "(", ")", ";", "}", "}", "catch", "(", "SVNException", "e", ")", "{", "LOGGER", ".", "log", "(", "Level", ".", "INFO", ",", "\"", "Failed to access subversion repository ", "\"", "+", "url", ",", "e", ")", ";", "String", "message", "=", "hudson", ".", "scm", ".", "subversion", ".", "Messages", ".", "SubversionSCM_doCheckRemote_exceptionMsg1", "(", "Util", ".", "escape", "(", "url", ")", ",", "Util", ".", "escape", "(", "e", ".", "getErrorMessage", "(", ")", ".", "getFullMessage", "(", ")", ")", ",", "\"", "javascript:document.getElementById('svnerror').style.display='block';", "\"", "+", "\"", "document.getElementById('svnerrorlink').style.display='none';", "\"", "+", "\"", "return false;", "\"", ")", "+", "\"", "<br/><pre id=", "\\\"", "svnerror", "\\\"", " style=", "\\\"", "display:none", "\\\"", ">", "\"", "+", "Util", ".", "xmlEscape", "(", "Functions", ".", "printThrowable", "(", "e", ")", ")", "+", "\"", "</pre>", "\"", ";", "return", "FormValidation", ".", "errorWithMarkup", "(", "message", ")", ";", "}", "}"], "idx": 80692, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "545ca52", "function_name": "doCheckCredentialsId", "body_hash": "2180ce8f2e3cd182ededf7e03cd7f4644a1ba151"}
{"code": "private void prepareRequest() {\n\n        // Translate the HTTP method code to a String.\n        byte methodCode = requestHeaderMessage.getByte();\n        if (methodCode != Constants.SC_M_JK_STORED) {\n            String methodName = Constants.getMethodForCode(methodCode - 1);\n            request.method().setString(methodName);\n        }\n\n        requestHeaderMessage.getBytes(request.protocol());\n        requestHeaderMessage.getBytes(request.requestURI());\n\n        requestHeaderMessage.getBytes(request.remoteAddr());\n        requestHeaderMessage.getBytes(request.remoteHost());\n        requestHeaderMessage.getBytes(request.localName());\n        request.setLocalPort(requestHeaderMessage.getInt());\n\n        boolean isSSL = requestHeaderMessage.getByte() != 0;\n        if (isSSL) {\n            request.scheme().setString(\"https\");\n        }\n\n        // Decode headers\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Set this every time in case limit has been changed via JMX\n        headers.setLimit(endpoint.getMaxHeaderCount());\n\n        boolean contentLengthSet = false;\n        int hCount = requestHeaderMessage.getInt();\n        for(int i = 0 ; i < hCount ; i++) {\n            String hName = null;\n\n            // Header names are encoded as either an integer code starting\n            // with 0xA0, or as a normal string (in which case the first\n            // two bytes are the length).\n            int isc = requestHeaderMessage.peekInt();\n            int hId = isc & 0xFF;\n\n            MessageBytes vMB = null;\n            isc &= 0xFF00;\n            if(0xA000 == isc) {\n                requestHeaderMessage.getInt(); // To advance the read position\n                hName = Constants.getHeaderForCode(hId - 1);\n                vMB = headers.addValue(hName);\n            } else {\n                // reset hId -- if the header currently being read\n                // happens to be 7 or 8 bytes long, the code below\n                // will think it's the content-type header or the\n                // content-length header - SC_REQ_CONTENT_TYPE=7,\n                // SC_REQ_CONTENT_LENGTH=8 - leading to unexpected\n                // behaviour.  see bug 5861 for more information.\n                hId = -1;\n                requestHeaderMessage.getBytes(tmpMB);\n                ByteChunk bc = tmpMB.getByteChunk();\n                vMB = headers.addValue(bc.getBuffer(),\n                        bc.getStart(), bc.getLength());\n            }\n\n            requestHeaderMessage.getBytes(vMB);\n\n            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Length\"))) {\n                long cl = vMB.getLong();\n                if (contentLengthSet) {\n                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                } else {\n                    contentLengthSet = true;\n                    // Set the content-length header for the request\n                    request.setContentLength(cl);\n                }\n            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Type\"))) {\n                // just read the content-type header, so set it\n                ByteChunk bchunk = vMB.getByteChunk();\n                request.contentType().setBytes(bchunk.getBytes(),\n                        bchunk.getOffset(),\n                        bchunk.getLength());\n            }\n        }\n\n        // Decode extra attributes\n        boolean secretPresentInRequest = false;\n        byte attributeCode;\n        while ((attributeCode = requestHeaderMessage.getByte())\n                != Constants.SC_A_ARE_DONE) {\n\n            switch (attributeCode) {\n\n            case Constants.SC_A_REQ_ATTRIBUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                String n = tmpMB.toString();\n                requestHeaderMessage.getBytes(tmpMB);\n                String v = tmpMB.toString();\n                /*\n                 * AJP13 misses to forward the local IP address and the\n                 * remote port. Allow the AJP connector to add this info via\n                 * private request attributes.\n                 * We will accept the forwarded data and remove it from the\n                 * public list of request attributes.\n                 */\n                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {\n                    request.localAddr().setString(v);\n                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {\n                    try {\n                        request.setRemotePort(Integer.parseInt(v));\n                    } catch (NumberFormatException nfe) {\n                        // Ignore invalid value\n                    }\n                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {\n                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);\n                } else if (n.equals(\"JK_LB_ACTIVATION\")) {\n                    request.setAttribute(n, v);\n                } else if (javaxAttributes.contains(n)) {\n                    request.setAttribute(n, v);\n                } else {\n                    // All 'known' attributes will be processed by the previous\n                    // blocks. Any remaining attribute is an 'arbitrary' one.\n                    Pattern pattern = protocol.getAllowedArbitraryRequestAttributesPattern();\n                    if (pattern == null) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    } else {\n                        Matcher m = pattern.matcher(n);\n                        if (m.matches()) {\n                            request.setAttribute(n, v);\n                        } else {\n                            response.setStatus(403);\n                            setErrorState(ErrorState.CLOSE_CLEAN, null);\n                        }\n                    }\n                }\n                break;\n\n            case Constants.SC_A_CONTEXT :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SERVLET_PATH :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_REMOTE_USER :\n                if (tomcatAuthorization || !tomcatAuthentication) {\n                    // Implies tomcatAuthentication == false\n                    requestHeaderMessage.getBytes(request.getRemoteUser());\n                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);\n                } else {\n                    // Ignore user information from reverse proxy\n                    requestHeaderMessage.getBytes(tmpMB);\n                }\n                break;\n\n            case Constants.SC_A_AUTH_TYPE :\n                if (tomcatAuthentication) {\n                    // ignore server\n                    requestHeaderMessage.getBytes(tmpMB);\n                } else {\n                    requestHeaderMessage.getBytes(request.getAuthType());\n                }\n                break;\n\n            case Constants.SC_A_QUERY_STRING :\n                requestHeaderMessage.getBytes(request.queryString());\n                break;\n\n            case Constants.SC_A_JVM_ROUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                // nothing\n                break;\n\n            case Constants.SC_A_SSL_CERT :\n                // SSL certificate extraction is lazy, moved to JkCoyoteHandler\n                requestHeaderMessage.getBytes(certificates);\n                break;\n\n            case Constants.SC_A_SSL_CIPHER :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_SESSION :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.SESSION_ID_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_KEY_SIZE :\n                request.setAttribute(SSLSupport.KEY_SIZE_KEY,\n                        Integer.valueOf(requestHeaderMessage.getInt()));\n                break;\n\n            case Constants.SC_A_STORED_METHOD:\n                requestHeaderMessage.getBytes(request.method());\n                break;\n\n            case Constants.SC_A_SECRET:\n                requestHeaderMessage.getBytes(tmpMB);\n                if (secret != null) {\n                    secretPresentInRequest = true;\n                    if (!tmpMB.equals(secret)) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    }\n                }\n                break;\n\n            default:\n                // Ignore unknown attribute for backward compatibility\n                break;\n\n            }\n\n        }\n\n        // Check if secret was submitted if required\n        if ((secret != null) && !secretPresentInRequest) {\n            response.setStatus(403);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n        }\n\n        // Check for a full URI (including protocol://host:port/)\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\"\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + slashPos,\n                            uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                        slashPos - pos - 3);\n            }\n\n        }\n\n        MessageBytes valueMB = request.getMimeHeaders().getValue(\"host\");\n        parseHost(valueMB);\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n    }", "code_tokens": ["private", "void", "prepareRequest", "(", ")", "{", "byte", "methodCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ";", "if", "(", "methodCode", "!=", "Constants", ".", "SC_M_JK_STORED", ")", "{", "String", "methodName", "=", "Constants", ".", "getMethodForCode", "(", "methodCode", "-", "1", ")", ";", "request", ".", "method", "(", ")", ".", "setString", "(", "methodName", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "protocol", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "requestURI", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteAddr", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "remoteHost", "(", ")", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "localName", "(", ")", ")", ";", "request", ".", "setLocalPort", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ";", "boolean", "isSSL", "=", "requestHeaderMessage", ".", "getByte", "(", ")", "!=", "0", ";", "if", "(", "isSSL", ")", "{", "request", ".", "scheme", "(", ")", ".", "setString", "(", "\"", "https", "\"", ")", ";", "}", "MimeHeaders", "headers", "=", "request", ".", "getMimeHeaders", "(", ")", ";", "headers", ".", "setLimit", "(", "endpoint", ".", "getMaxHeaderCount", "(", ")", ")", ";", "boolean", "contentLengthSet", "=", "false", ";", "int", "hCount", "=", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hCount", ";", "i", "++", ")", "{", "String", "hName", "=", "null", ";", "int", "isc", "=", "requestHeaderMessage", ".", "peekInt", "(", ")", ";", "int", "hId", "=", "isc", "&", "0xFF", ";", "MessageBytes", "vMB", "=", "null", ";", "isc", "&=", "0xFF00", ";", "if", "(", "0xA000", "==", "isc", ")", "{", "requestHeaderMessage", ".", "getInt", "(", ")", ";", "hName", "=", "Constants", ".", "getHeaderForCode", "(", "hId", "-", "1", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "hName", ")", ";", "}", "else", "{", "hId", "=", "-", "1", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "ByteChunk", "bc", "=", "tmpMB", ".", "getByteChunk", "(", ")", ";", "vMB", "=", "headers", ".", "addValue", "(", "bc", ".", "getBuffer", "(", ")", ",", "bc", ".", "getStart", "(", ")", ",", "bc", ".", "getLength", "(", ")", ")", ";", "}", "requestHeaderMessage", ".", "getBytes", "(", "vMB", ")", ";", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_LENGTH", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Length", "\"", ")", ")", ")", "{", "long", "cl", "=", "vMB", ".", "getLong", "(", ")", ";", "if", "(", "contentLengthSet", ")", "{", "response", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "else", "{", "contentLengthSet", "=", "true", ";", "request", ".", "setContentLength", "(", "cl", ")", ";", "}", "}", "else", "if", "(", "hId", "==", "Constants", ".", "SC_REQ_CONTENT_TYPE", "||", "(", "hId", "==", "-", "1", "&&", "tmpMB", ".", "equalsIgnoreCase", "(", "\"", "Content-Type", "\"", ")", ")", ")", "{", "ByteChunk", "bchunk", "=", "vMB", ".", "getByteChunk", "(", ")", ";", "request", ".", "contentType", "(", ")", ".", "setBytes", "(", "bchunk", ".", "getBytes", "(", ")", ",", "bchunk", ".", "getOffset", "(", ")", ",", "bchunk", ".", "getLength", "(", ")", ")", ";", "}", "}", "boolean", "secretPresentInRequest", "=", "false", ";", "byte", "attributeCode", ";", "while", "(", "(", "attributeCode", "=", "requestHeaderMessage", ".", "getByte", "(", ")", ")", "!=", "Constants", ".", "SC_A_ARE_DONE", ")", "{", "switch", "(", "attributeCode", ")", "{", "case", "Constants", ".", "SC_A_REQ_ATTRIBUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "n", "=", "tmpMB", ".", "toString", "(", ")", ";", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "String", "v", "=", "tmpMB", ".", "toString", "(", ")", ";", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_LOCAL_ADDR", ")", ")", "{", "request", ".", "localAddr", "(", ")", ".", "setString", "(", "v", ")", ";", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_REQ_REMOTE_PORT", ")", ")", "{", "try", "{", "request", ".", "setRemotePort", "(", "Integer", ".", "parseInt", "(", "v", ")", ")", ";", "}", "catch", "(", "NumberFormatException", "nfe", ")", "{", "}", "}", "else", "if", "(", "n", ".", "equals", "(", "Constants", ".", "SC_A_SSL_PROTOCOL", ")", ")", "{", "request", ".", "setAttribute", "(", "SSLSupport", ".", "PROTOCOL_VERSION_KEY", ",", "v", ")", ";", "}", "else", "if", "(", "n", ".", "equals", "(", "\"", "JK_LB_ACTIVATION", "\"", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "if", "(", "javaxAttributes", ".", "contains", "(", "n", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "{", "Pattern", "pattern", "=", "protocol", ".", "getAllowedArbitraryRequestAttributesPattern", "(", ")", ";", "if", "(", "pattern", "==", "null", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "else", "{", "Matcher", "m", "=", "pattern", ".", "matcher", "(", "n", ")", ";", "if", "(", "m", ".", "matches", "(", ")", ")", "{", "request", ".", "setAttribute", "(", "n", ",", "v", ")", ";", "}", "else", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "}", "break", ";", "case", "Constants", ".", "SC_A_CONTEXT", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SERVLET_PATH", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_REMOTE_USER", ":", "if", "(", "tomcatAuthorization", "||", "!", "tomcatAuthentication", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getRemoteUser", "(", ")", ")", ";", "request", ".", "setRemoteUserNeedsAuthorization", "(", "tomcatAuthorization", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_AUTH_TYPE", ":", "if", "(", "tomcatAuthentication", ")", "{", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "}", "else", "{", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "getAuthType", "(", ")", ")", ";", "}", "break", ";", "case", "Constants", ".", "SC_A_QUERY_STRING", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "queryString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_JVM_ROUTE", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CERT", ":", "requestHeaderMessage", ".", "getBytes", "(", "certificates", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_CIPHER", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "CIPHER_SUITE_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_SESSION", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "request", ".", "setAttribute", "(", "SSLSupport", ".", "SESSION_ID_KEY", ",", "tmpMB", ".", "toString", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SSL_KEY_SIZE", ":", "request", ".", "setAttribute", "(", "SSLSupport", ".", "KEY_SIZE_KEY", ",", "Integer", ".", "valueOf", "(", "requestHeaderMessage", ".", "getInt", "(", ")", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_STORED_METHOD", ":", "requestHeaderMessage", ".", "getBytes", "(", "request", ".", "method", "(", ")", ")", ";", "break", ";", "case", "Constants", ".", "SC_A_SECRET", ":", "requestHeaderMessage", ".", "getBytes", "(", "tmpMB", ")", ";", "if", "(", "secret", "!=", "null", ")", "{", "secretPresentInRequest", "=", "true", ";", "if", "(", "!", "tmpMB", ".", "equals", "(", "secret", ")", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "}", "break", ";", "default", ":", "break", ";", "}", "}", "if", "(", "(", "secret", "!=", "null", ")", "&&", "!", "secretPresentInRequest", ")", "{", "response", ".", "setStatus", "(", "403", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "}", "ByteChunk", "uriBC", "=", "request", ".", "requestURI", "(", ")", ".", "getByteChunk", "(", ")", ";", "if", "(", "uriBC", ".", "startsWithIgnoreCase", "(", "\"", "http", "\"", ",", "0", ")", ")", "{", "int", "pos", "=", "uriBC", ".", "indexOf", "(", "\"", "://", "\"", ",", "0", ",", "3", ",", "4", ")", ";", "int", "uriBCStart", "=", "uriBC", ".", "getStart", "(", ")", ";", "int", "slashPos", "=", "-", "1", ";", "if", "(", "pos", "!=", "-", "1", ")", "{", "byte", "[", "]", "uriB", "=", "uriBC", ".", "getBytes", "(", ")", ";", "slashPos", "=", "uriBC", ".", "indexOf", "(", "'/'", ",", "pos", "+", "3", ")", ";", "if", "(", "slashPos", "==", "-", "1", ")", "{", "slashPos", "=", "uriBC", ".", "getLength", "(", ")", ";", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "1", ",", "1", ")", ";", "}", "else", "{", "request", ".", "requestURI", "(", ")", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "slashPos", ",", "uriBC", ".", "getLength", "(", ")", "-", "slashPos", ")", ";", "}", "MessageBytes", "hostMB", "=", "headers", ".", "setValue", "(", "\"", "host", "\"", ")", ";", "hostMB", ".", "setBytes", "(", "uriB", ",", "uriBCStart", "+", "pos", "+", "3", ",", "slashPos", "-", "pos", "-", "3", ")", ";", "}", "}", "MessageBytes", "valueMB", "=", "request", ".", "getMimeHeaders", "(", ")", ".", "getValue", "(", "\"", "host", "\"", ")", ";", "parseHost", "(", "valueMB", ")", ";", "if", "(", "!", "getErrorState", "(", ")", ".", "isIoAllowed", "(", ")", ")", "{", "getAdapter", "(", ")", ".", "log", "(", "request", ",", "response", ",", "0", ")", ";", "}", "}"], "idx": 111913, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "5a5494f", "function_name": "prepareRequest", "body_hash": "82efd73e73f5cd5ca803ff1fa51b2373a8efe052"}
{"code": "@Test(description = \"Test pullCount of a package from central\", dependsOnMethods = \"testPull\", enabled = false)\n    public void testPullCount() throws IOException {\n        initializeSsl();\n        String url = RepoUtils.getRemoteRepoURL() + \"/modules/info/\" + orgName + \"/\" + moduleName + \"/*/\";\n        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(url), \"\", 0, \"\", \"\");\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.GET);\n\n        int statusCode = conn.getResponseCode();\n        if (statusCode == 200) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                    Charset.defaultCharset()))) {\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                Object payload = JSONParser.parse(result.toString());\n                if (payload instanceof MapValue) {\n                    long pullCount = ((MapValue) payload).getIntValue(\"totalPullCount\");\n                    Assert.assertEquals(pullCount, totalPullCount);\n                } else {\n                    Assert.fail(\"error: invalid response received\");\n                }\n            }\n        } else {\n            Assert.fail(\"error: could not connect to remote repository to find the latest version of module\");\n        }\n    }", "code_tokens": ["@", "Test", "(", "description", "=", "\"", "Test pullCount of a package from central", "\"", ",", "dependsOnMethods", "=", "\"", "testPull", "\"", ",", "enabled", "=", "false", ")", "public", "void", "testPullCount", "(", ")", "throws", "IOException", "{", "initializeSsl", "(", ")", ";", "String", "url", "=", "RepoUtils", ".", "getRemoteRepoURL", "(", ")", "+", "\"", "/modules/info/", "\"", "+", "orgName", "+", "\"", "/", "\"", "+", "moduleName", "+", "\"", "/*/", "\"", ";", "HttpURLConnection", "conn", "=", "createHttpUrlConnection", "(", "convertToUrl", "(", "url", ")", ",", "\"", "\"", ",", "0", ",", "\"", "\"", ",", "\"", "\"", ")", ";", "conn", ".", "setInstanceFollowRedirects", "(", "false", ")", ";", "setRequestMethod", "(", "conn", ",", "Utils", ".", "RequestMethod", ".", "GET", ")", ";", "int", "statusCode", "=", "conn", ".", "getResponseCode", "(", ")", ";", "if", "(", "statusCode", "==", "200", ")", "{", "try", "(", "BufferedReader", "reader", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "conn", ".", "getInputStream", "(", ")", ",", "Charset", ".", "defaultCharset", "(", ")", ")", ")", ")", "{", "StringBuilder", "result", "=", "new", "StringBuilder", "(", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "reader", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "result", ".", "append", "(", "line", ")", ";", "}", "Object", "payload", "=", "JSONParser", ".", "parse", "(", "result", ".", "toString", "(", ")", ")", ";", "if", "(", "payload", "instanceof", "MapValue", ")", "{", "long", "pullCount", "=", "(", "(", "MapValue", ")", "payload", ")", ".", "getIntValue", "(", "\"", "totalPullCount", "\"", ")", ";", "Assert", ".", "assertEquals", "(", "pullCount", ",", "totalPullCount", ")", ";", "}", "else", "{", "Assert", ".", "fail", "(", "\"", "error: invalid response received", "\"", ")", ";", "}", "}", "}", "else", "{", "Assert", ".", "fail", "(", "\"", "error: could not connect to remote repository to find the latest version of module", "\"", ")", ";", "}", "}"], "idx": 41223, "cwe": "CWE-306", "target": 1, "status": "VULNERABLE", "commit": "4609ffee1744ecd16aac09303b1783bf0a525816", "function_name": "testPullCount", "body_hash": "d2afee6e5cff303aa5bebe02a8de0e367c15704e"}
{"code": "public static String[] getCNs(final X509Certificate cert) {\n        final String subjectPrincipal = cert.getSubjectX500Principal().toString();\n        try {\n            return extractCNs(subjectPrincipal);\n        } catch (SSLException ex) {\n            return null;\n        }\n    }", "code_tokens": ["public", "static", "String", "[", "]", "getCNs", "(", "final", "X509Certificate", "cert", ")", "{", "final", "String", "subjectPrincipal", "=", "cert", ".", "getSubjectX500Principal", "(", ")", ".", "toString", "(", ")", ";", "try", "{", "return", "extractCNs", "(", "subjectPrincipal", ")", ";", "}", "catch", "(", "SSLException", "ex", ")", "{", "return", "null", ";", "}", "}"], "idx": 110851, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "51cc67567765d67f878f0dcef61b5ded454d3122", "function_name": "getCNs", "body_hash": "efdf36b0343047ea6ab2856777b6588e1eaa417b"}
{"code": "default boolean contains(String name) {\n        return get(name, Object.class).isPresent();\n    }", "code_tokens": ["default", "boolean", "contains", "(", "String", "name", ")", "{", "return", "get", "(", "name", ",", "Object", ".", "class", ")", ".", "isPresent", "(", ")", ";", "}"], "idx": 52462, "cwe": "CWE-400", "target": 1, "status": "VULNERABLE", "commit": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3", "function_name": "contains", "body_hash": "9e17a19851bfa99cfd397d97b0898c8587fe1566"}
{"code": "public static String[] getCNs(final X509Certificate cert) {\n        final LinkedList<String> cnList = new LinkedList<String>();\n        /*\n          Sebastian Hauer's original StrictSSLProtocolSocketFactory used\n          getName() and had the following comment:\n\n                Parses a X.500 distinguished name for the value of the\n                \"Common Name\" field.  This is done a bit sloppy right\n                 now and should probably be done a bit more according to\n                <code>RFC 2253</code>.\n\n           I've noticed that toString() seems to do a better job than\n           getName() on these X500Principal objects, so I'm hoping that\n           addresses Sebastian's concern.\n\n           For example, getName() gives me this:\n           1.2.840.113549.1.9.1=#16166a756c6975736461766965734063756362632e636f6d\n\n           whereas toString() gives me this:\n           EMAILADDRESS=juliusdavies@cucbc.com\n\n           Looks like toString() even works with non-ascii domain names!\n           I tested it with \"&#x82b1;&#x5b50;.co.jp\" and it worked fine.\n        */\n\n        final String subjectPrincipal = cert.getSubjectX500Principal().toString();\n        final StringTokenizer st = new StringTokenizer(subjectPrincipal, \",+\");\n        while(st.hasMoreTokens()) {\n            final String tok = st.nextToken().trim();\n            if (tok.length() > 3) {\n                if (tok.substring(0, 3).equalsIgnoreCase(\"CN=\")) {\n                    cnList.add(tok.substring(3));\n                }\n            }\n        }\n        if(!cnList.isEmpty()) {\n            final String[] cns = new String[cnList.size()];\n            cnList.toArray(cns);\n            return cns;\n        } else {\n            return null;\n        }\n    }", "code_tokens": ["public", "static", "String", "[", "]", "getCNs", "(", "final", "X509Certificate", "cert", ")", "{", "final", "LinkedList", "<", "String", ">", "cnList", "=", "new", "LinkedList", "<", "String", ">", "(", ")", ";", "final", "String", "subjectPrincipal", "=", "cert", ".", "getSubjectX500Principal", "(", ")", ".", "toString", "(", ")", ";", "final", "StringTokenizer", "st", "=", "new", "StringTokenizer", "(", "subjectPrincipal", ",", "\"", ",+", "\"", ")", ";", "while", "(", "st", ".", "hasMoreTokens", "(", ")", ")", "{", "final", "String", "tok", "=", "st", ".", "nextToken", "(", ")", ".", "trim", "(", ")", ";", "if", "(", "tok", ".", "length", "(", ")", ">", "3", ")", "{", "if", "(", "tok", ".", "substring", "(", "0", ",", "3", ")", ".", "equalsIgnoreCase", "(", "\"", "CN=", "\"", ")", ")", "{", "cnList", ".", "add", "(", "tok", ".", "substring", "(", "3", ")", ")", ";", "}", "}", "}", "if", "(", "!", "cnList", ".", "isEmpty", "(", ")", ")", "{", "final", "String", "[", "]", "cns", "=", "new", "String", "[", "cnList", ".", "size", "(", ")", "]", ";", "cnList", ".", "toArray", "(", "cns", ")", ";", "return", "cns", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "idx": 110850, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "51cc67567765d67f878f0dcef61b5ded454d3122", "function_name": "getCNs", "body_hash": "f6d3a646e3bd4801cb94335d85f67429f3ba3dd3"}
{"code": "private MockHttpServletRequestBuilder createChangePasswordRequest(ScimUser user, ExpiringCode code, boolean useCSRF, String password, String passwordConfirmation) throws Exception {\n        return createChangePasswordRequest(user,code.getCode(),useCSRF, password,passwordConfirmation);\n    }", "code_tokens": ["private", "MockHttpServletRequestBuilder", "createChangePasswordRequest", "(", "ScimUser", "user", ",", "ExpiringCode", "code", ",", "boolean", "useCSRF", ",", "String", "password", ",", "String", "passwordConfirmation", ")", "throws", "Exception", "{", "return", "createChangePasswordRequest", "(", "user", ",", "code", ".", "getCode", "(", ")", ",", "useCSRF", ",", "password", ",", "passwordConfirmation", ")", ";", "}"], "idx": 71335, "cwe": "CWE-640", "target": 0, "status": "FIXED", "commit": "cd31cc397fe17389d95b83d6a9caa46eebc54faf", "function_name": "createChangePasswordRequest", "body_hash": "da0ec9939e853bd2454990d5264b1ba5243ffb04"}
{"code": "private RootBeanDefinition registerMessageBroker(Element brokerElement,\n\t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n\t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate, RuntimeBeanReference userRegistry,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n\t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n\n\t\tConstructorArgumentValues cargs = new ConstructorArgumentValues();\n\t\tcargs.addIndexedArgumentValue(0, inChannel);\n\t\tcargs.addIndexedArgumentValue(1, outChannel);\n\t\tcargs.addIndexedArgumentValue(2, brokerChannel);\n\n\t\tRootBeanDefinition brokerDef;\n\t\tif (simpleBrokerElem != null) {\n\t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n\t\t\tcargs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cargs, null);\n\t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n\t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n\t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n\t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"selector-header\")) {\n\t\t\t\tString headerName = simpleBrokerElem.getAttribute(\"selector-header\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"selectorHeaderName\", headerName);\n\t\t\t}\n\t\t}\n\t\telse if (brokerRelayElem != null) {\n\t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n\t\t\tcargs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\n\t\t\tMutablePropertyValues values = new MutablePropertyValues();\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n\t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n\t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n\t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n\t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n\t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n\t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n\t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n\t\t\t}\n\t\t\tManagedMap<String, Object> map = new ManagedMap<>();\n\t\t\tmap.setSource(source);\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n\t\t\t\tmap.put(destination, userDestHandler);\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n\t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n\t\t\t\t\t\tbrokerTemplate, destination, context, source));\n\t\t\t}\n\t\t\tif (!map.isEmpty()) {\n\t\t\t\tvalues.add(\"systemSubscriptions\", map);\n\t\t\t}\n\t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n\t\t\tbrokerDef = new RootBeanDefinition(handlerType, cargs, values);\n\t\t}\n\t\telse {\n\t\t\t// Should not happen\n\t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n\t\t}\n\t\tregisterBeanDef(brokerDef, context, source);\n\t\treturn brokerDef;\n\t}", "code_tokens": ["private", "RootBeanDefinition", "registerMessageBroker", "(", "Element", "brokerElement", ",", "RuntimeBeanReference", "inChannel", ",", "RuntimeBeanReference", "outChannel", ",", "RuntimeBeanReference", "brokerChannel", ",", "Object", "userDestHandler", ",", "RuntimeBeanReference", "brokerTemplate", ",", "RuntimeBeanReference", "userRegistry", ",", "ParserContext", "context", ",", "@", "Nullable", "Object", "source", ")", "{", "Element", "simpleBrokerElem", "=", "DomUtils", ".", "getChildElementByTagName", "(", "brokerElement", ",", "\"", "simple-broker", "\"", ")", ";", "Element", "brokerRelayElem", "=", "DomUtils", ".", "getChildElementByTagName", "(", "brokerElement", ",", "\"", "stomp-broker-relay", "\"", ")", ";", "ConstructorArgumentValues", "cargs", "=", "new", "ConstructorArgumentValues", "(", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "0", ",", "inChannel", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "1", ",", "outChannel", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "2", ",", "brokerChannel", ")", ";", "RootBeanDefinition", "brokerDef", ";", "if", "(", "simpleBrokerElem", "!=", "null", ")", "{", "String", "prefix", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "prefix", "\"", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "3", ",", "Arrays", ".", "asList", "(", "StringUtils", ".", "tokenizeToStringArray", "(", "prefix", ",", "\"", ",", "\"", ")", ")", ")", ";", "brokerDef", "=", "new", "RootBeanDefinition", "(", "SimpleBrokerMessageHandler", ".", "class", ",", "cargs", ",", "null", ")", ";", "if", "(", "brokerElement", ".", "hasAttribute", "(", "\"", "path-matcher", "\"", ")", ")", "{", "String", "pathMatcherRef", "=", "brokerElement", ".", "getAttribute", "(", "\"", "path-matcher", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "pathMatcher", "\"", ",", "new", "RuntimeBeanReference", "(", "pathMatcherRef", ")", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "scheduler", "\"", ")", ")", "{", "String", "scheduler", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "scheduler", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "taskScheduler", "\"", ",", "new", "RuntimeBeanReference", "(", "scheduler", ")", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "heartbeat", "\"", ")", ")", "{", "String", "heartbeatValue", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "heartbeat", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "heartbeatValue", "\"", ",", "heartbeatValue", ")", ";", "}", "if", "(", "simpleBrokerElem", ".", "hasAttribute", "(", "\"", "selector-header", "\"", ")", ")", "{", "String", "headerName", "=", "simpleBrokerElem", ".", "getAttribute", "(", "\"", "selector-header", "\"", ")", ";", "brokerDef", ".", "getPropertyValues", "(", ")", ".", "add", "(", "\"", "selectorHeaderName", "\"", ",", "headerName", ")", ";", "}", "}", "else", "if", "(", "brokerRelayElem", "!=", "null", ")", "{", "String", "prefix", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "prefix", "\"", ")", ";", "cargs", ".", "addIndexedArgumentValue", "(", "3", ",", "Arrays", ".", "asList", "(", "StringUtils", ".", "tokenizeToStringArray", "(", "prefix", ",", "\"", ",", "\"", ")", ")", ")", ";", "MutablePropertyValues", "values", "=", "new", "MutablePropertyValues", "(", ")", ";", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "relay-host", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "relayHost", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "relay-host", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "relay-port", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "relayPort", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "relay-port", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "client-login", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "clientLogin", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "client-login", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "client-passcode", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "clientPasscode", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "client-passcode", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "system-login", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemLogin", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "system-login", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "system-passcode", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemPasscode", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "system-passcode", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "heartbeat-send-interval", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemHeartbeatSendInterval", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "heartbeat-send-interval", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "heartbeat-receive-interval", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "systemHeartbeatReceiveInterval", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "heartbeat-receive-interval", "\"", ")", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "virtual-host", "\"", ")", ")", "{", "values", ".", "add", "(", "\"", "virtualHost", "\"", ",", "brokerRelayElem", ".", "getAttribute", "(", "\"", "virtual-host", "\"", ")", ")", ";", "}", "ManagedMap", "<", "String", ",", "Object", ">", "map", "=", "new", "ManagedMap", "<", ">", "(", ")", ";", "map", ".", "setSource", "(", "source", ")", ";", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "user-destination-broadcast", "\"", ")", ")", "{", "String", "destination", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "user-destination-broadcast", "\"", ")", ";", "map", ".", "put", "(", "destination", ",", "userDestHandler", ")", ";", "}", "if", "(", "brokerRelayElem", ".", "hasAttribute", "(", "\"", "user-registry-broadcast", "\"", ")", ")", "{", "String", "destination", "=", "brokerRelayElem", ".", "getAttribute", "(", "\"", "user-registry-broadcast", "\"", ")", ";", "map", ".", "put", "(", "destination", ",", "registerUserRegistryMessageHandler", "(", "userRegistry", ",", "brokerTemplate", ",", "destination", ",", "context", ",", "source", ")", ")", ";", "}", "if", "(", "!", "map", ".", "isEmpty", "(", ")", ")", "{", "values", ".", "add", "(", "\"", "systemSubscriptions", "\"", ",", "map", ")", ";", "}", "Class", "<", "?", ">", "handlerType", "=", "StompBrokerRelayMessageHandler", ".", "class", ";", "brokerDef", "=", "new", "RootBeanDefinition", "(", "handlerType", ",", "cargs", ",", "values", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"", "Neither <simple-broker> nor <stomp-broker-relay> elements found.", "\"", ")", ";", "}", "registerBeanDef", "(", "brokerDef", ",", "context", ",", "source", ")", ";", "return", "brokerDef", ";", "}"], "idx": 103472, "cwe": "NVD-CWE-noinfo", "target": 0, "status": "FIXED", "commit": "ff2228fdaf131d57b5c8c5918ee8d07c6dd9bba", "function_name": "registerMessageBroker", "body_hash": "9ef9b8fa7139e68f2c77e52692984252b0d369b2"}
{"code": "protected Channel jnlpConnect(SlaveComputer computer) throws InterruptedException, IOException {\n            final String nodeName = computer.getName();\n            final OutputStream log = computer.openLogFile();\n            PrintWriter logw = new PrintWriter(log,true);\n            logw.println(\"JNLP agent connected from \"+ socket.getInetAddress());\n\n            try {\n                ChannelBuilder cb = createChannelBuilder(nodeName);\n\n                for (ChannelConfigurator cc : ChannelConfigurator.all()) {\n                    cc.onChannelBuilding(cb, computer);\n                }\n\n                computer.setChannel(cb.withHeaderStream(log).build(socket), log,\n                    new Listener() {\n                        @Override\n                        public void onClosed(Channel channel, IOException cause) {\n                            if(cause!=null)\n                                LOGGER.log(Level.WARNING, Thread.currentThread().getName()+\" for + \" + nodeName + \" terminated\",cause);\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                // ignore\n                            }\n                        }\n                    });\n                return computer.getChannel();\n            } catch (AbortException e) {\n                logw.println(e.getMessage());\n                logw.println(\"Failed to establish the connection with the slave\");\n                throw e;\n            } catch (IOException e) {\n                logw.println(\"Failed to establish the connection with the slave \" + nodeName);\n                e.printStackTrace(logw);\n                throw e;\n            }\n        }", "code_tokens": ["protected", "Channel", "jnlpConnect", "(", "SlaveComputer", "computer", ")", "throws", "InterruptedException", ",", "IOException", "{", "final", "String", "nodeName", "=", "computer", ".", "getName", "(", ")", ";", "final", "OutputStream", "log", "=", "computer", ".", "openLogFile", "(", ")", ";", "PrintWriter", "logw", "=", "new", "PrintWriter", "(", "log", ",", "true", ")", ";", "logw", ".", "println", "(", "\"", "JNLP agent connected from ", "\"", "+", "socket", ".", "getInetAddress", "(", ")", ")", ";", "try", "{", "ChannelBuilder", "cb", "=", "createChannelBuilder", "(", "nodeName", ")", ";", "for", "(", "ChannelConfigurator", "cc", ":", "ChannelConfigurator", ".", "all", "(", ")", ")", "{", "cc", ".", "onChannelBuilding", "(", "cb", ",", "computer", ")", ";", "}", "computer", ".", "setChannel", "(", "cb", ".", "withHeaderStream", "(", "log", ")", ".", "build", "(", "socket", ")", ",", "log", ",", "new", "Listener", "(", ")", "{", "@", "Override", "public", "void", "onClosed", "(", "Channel", "channel", ",", "IOException", "cause", ")", "{", "if", "(", "cause", "!=", "null", ")", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "Thread", ".", "currentThread", "(", ")", ".", "getName", "(", ")", "+", "\"", " for + ", "\"", "+", "nodeName", "+", "\"", " terminated", "\"", ",", "cause", ")", ";", "try", "{", "socket", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "}", "}", ")", ";", "return", "computer", ".", "getChannel", "(", ")", ";", "}", "catch", "(", "AbortException", "e", ")", "{", "logw", ".", "println", "(", "e", ".", "getMessage", "(", ")", ")", ";", "logw", ".", "println", "(", "\"", "Failed to establish the connection with the slave", "\"", ")", ";", "throw", "e", ";", "}", "catch", "(", "IOException", "e", ")", "{", "logw", ".", "println", "(", "\"", "Failed to establish the connection with the slave ", "\"", "+", "nodeName", ")", ";", "e", ".", "printStackTrace", "(", "logw", ")", ";", "throw", "e", ";", "}", "}"], "idx": 36901, "cwe": "CWE-284", "target": 0, "status": "FIXED", "commit": "ed407e66bcd3743a3b458ea8284977e5cac56c2a", "function_name": "jnlpConnect", "body_hash": "8819fc590c8920d7ff9fd2f402be1c37bd9e9c68"}
{"code": "public void handleMessage(SoapMessage msg) throws Fault {\n        if (msg.containsKey(SECURITY_PROCESSED) || isGET(msg)) {\n            return;\n        }\n        //make sure we skip the URIMapping as we cannot apply security requirements to that\n        msg.put(URIMappingInterceptor.URIMAPPING_SKIP, Boolean.TRUE);\n        msg.put(SECURITY_PROCESSED, Boolean.TRUE);\n        \n        boolean utWithCallbacks = \n            MessageUtils.getContextualBoolean(msg, SecurityConstants.VALIDATE_TOKEN, true);\n        translateProperties(msg);\n        \n        RequestData reqData = new CXFRequestData();\n\n        WSSConfig config = (WSSConfig)msg.getContextualProperty(WSSConfig.class.getName()); \n        WSSecurityEngine engine;\n        if (config != null) {\n            engine = new WSSecurityEngine();\n            engine.setWssConfig(config);\n        } else {\n            engine = getSecurityEngine(utWithCallbacks);\n            if (engine == null) {\n                engine = new WSSecurityEngine();\n            }\n            config = engine.getWssConfig();\n        }\n        reqData.setWssConfig(config);\n        \n                \n        SOAPMessage doc = getSOAPMessage(msg);\n        \n        boolean doDebug = LOG.isLoggable(Level.FINE);\n        boolean doTimeLog = TIME_LOG.isLoggable(Level.FINE);\n\n        SoapVersion version = msg.getVersion();\n        if (doDebug) {\n            LOG.fine(\"WSS4JInInterceptor: enter handleMessage()\");\n        }\n\n        long t0 = 0;\n        long t1 = 0;\n        long t2 = 0;\n        long t3 = 0;\n\n        if (doTimeLog) {\n            t0 = System.currentTimeMillis();\n        }\n\n        /*\n         * The overall try, just to have a finally at the end to perform some\n         * housekeeping.\n         */\n        try {\n            reqData.setMsgContext(msg);\n            computeAction(msg, reqData);\n            List<Integer> actions = new ArrayList<Integer>();\n            String action = getAction(msg, version);\n\n            int doAction = WSSecurityUtil.decodeAction(action, actions);\n\n            String actor = (String)getOption(WSHandlerConstants.ACTOR);\n\n            reqData.setCallbackHandler(getCallback(reqData, doAction, utWithCallbacks));\n            \n            String passwordTypeStrict = (String)getOption(WSHandlerConstants.PASSWORD_TYPE_STRICT);\n            if (passwordTypeStrict == null) {\n                setProperty(WSHandlerConstants.PASSWORD_TYPE_STRICT, \"true\");\n            }\n            \n            // Configure replay caching\n            ReplayCache nonceCache = \n                getReplayCache(\n                    msg, SecurityConstants.ENABLE_NONCE_CACHE, SecurityConstants.NONCE_CACHE_INSTANCE\n                );\n            reqData.setNonceReplayCache(nonceCache);\n            ReplayCache timestampCache = \n                getReplayCache(\n                    msg, SecurityConstants.ENABLE_TIMESTAMP_CACHE, SecurityConstants.TIMESTAMP_CACHE_INSTANCE\n                );\n            reqData.setTimestampReplayCache(timestampCache);\n\n            /*\n             * Get and check the Signature specific parameters first because\n             * they may be used for encryption too.\n             */\n            doReceiverAction(doAction, reqData);\n            \n            /*get chance to check msg context enableRevocation setting\n             *when use policy based ws-security where the WSHandler configuration\n             *isn't available\n             */\n            boolean enableRevocation = reqData.isRevocationEnabled() \n                || MessageUtils.isTrue(msg.getContextualProperty(SecurityConstants.ENABLE_REVOCATION));\n            reqData.setEnableRevocation(enableRevocation);\n            \n            if (doTimeLog) {\n                t1 = System.currentTimeMillis();\n            }\n            Element elem = WSSecurityUtil.getSecurityHeader(doc.getSOAPPart(), actor);\n\n            List<WSSecurityEngineResult> wsResult = engine.processSecurityHeader(\n                elem, reqData\n            );\n\n            if (doTimeLog) {\n                t2 = System.currentTimeMillis();\n            }\n\n            if (wsResult != null && !wsResult.isEmpty()) { // security header found\n                if (reqData.getWssConfig().isEnableSignatureConfirmation()) {\n                    checkSignatureConfirmation(reqData, wsResult);\n                }\n\n                storeSignature(msg, reqData, wsResult);\n                storeTimestamp(msg, reqData, wsResult);\n                checkActions(msg, reqData, wsResult, actions);\n                doResults(\n                    msg, actor, \n                    SAAJUtils.getHeader(doc),\n                    SAAJUtils.getBody(doc),\n                    wsResult, utWithCallbacks\n                );\n            } else { // no security header found\n                // Create an empty result list to pass into the required validation\n                // methods.\n                wsResult = new ArrayList<WSSecurityEngineResult>();\n                if (doc.getSOAPPart().getEnvelope().getBody().hasFault()) {\n                    LOG.warning(\"Request does not contain Security header, \" \n                                + \"but it's a fault.\");\n                    // We allow lax action matching here for backwards compatibility\n                    // with manually configured WSS4JInInterceptors that previously\n                    // allowed faults to pass through even if their actions aren't\n                    // a strict match against those configured.  In the WS-SP case,\n                    // we will want to still call doResults as it handles asserting\n                    // certain assertions that do not require a WS-S header such as\n                    // a sp:TransportBinding assertion.  In the case of WS-SP,\n                    // the unasserted assertions will provide confirmation that\n                    // security was not sufficient.\n                    // checkActions(msg, reqData, wsResult, actions);\n                    doResults(msg, actor, \n                              SAAJUtils.getHeader(doc),\n                              SAAJUtils.getBody(doc),\n                              wsResult);\n                } else {\n                    checkActions(msg, reqData, wsResult, actions);\n                    doResults(msg, actor,\n                              SAAJUtils.getHeader(doc),\n                              SAAJUtils.getBody(doc),\n                              wsResult);\n                }\n            }\n            advanceBody(msg, SAAJUtils.getBody(doc));\n            SAAJInInterceptor.replaceHeaders(doc, msg);\n\n            if (doTimeLog) {\n                t3 = System.currentTimeMillis();\n                TIME_LOG.fine(\"Receive request: total= \" + (t3 - t0) \n                        + \" request preparation= \" + (t1 - t0)\n                        + \" request processing= \" + (t2 - t1) \n                        + \" header, cert verify, timestamp= \" + (t3 - t2) + \"\\n\");\n            }\n\n            if (doDebug) {\n                LOG.fine(\"WSS4JInInterceptor: exit handleMessage()\");\n            }\n\n        } catch (WSSecurityException e) {\n            LOG.log(Level.WARNING, \"\", e);\n            SoapFault fault = createSoapFault(version, e);\n            throw fault;\n        } catch (XMLStreamException e) {\n            throw new SoapFault(new Message(\"STAX_EX\", LOG), e, version.getSender());\n        } catch (SOAPException e) {\n            throw new SoapFault(new Message(\"SAAJ_EX\", LOG), e, version.getSender());\n        } finally {\n            reqData.clear();\n            reqData = null;\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "SoapMessage", "msg", ")", "throws", "Fault", "{", "if", "(", "msg", ".", "containsKey", "(", "SECURITY_PROCESSED", ")", "||", "isGET", "(", "msg", ")", ")", "{", "return", ";", "}", "msg", ".", "put", "(", "URIMappingInterceptor", ".", "URIMAPPING_SKIP", ",", "Boolean", ".", "TRUE", ")", ";", "msg", ".", "put", "(", "SECURITY_PROCESSED", ",", "Boolean", ".", "TRUE", ")", ";", "boolean", "utWithCallbacks", "=", "MessageUtils", ".", "getContextualBoolean", "(", "msg", ",", "SecurityConstants", ".", "VALIDATE_TOKEN", ",", "true", ")", ";", "translateProperties", "(", "msg", ")", ";", "RequestData", "reqData", "=", "new", "CXFRequestData", "(", ")", ";", "WSSConfig", "config", "=", "(", "WSSConfig", ")", "msg", ".", "getContextualProperty", "(", "WSSConfig", ".", "class", ".", "getName", "(", ")", ")", ";", "WSSecurityEngine", "engine", ";", "if", "(", "config", "!=", "null", ")", "{", "engine", "=", "new", "WSSecurityEngine", "(", ")", ";", "engine", ".", "setWssConfig", "(", "config", ")", ";", "}", "else", "{", "engine", "=", "getSecurityEngine", "(", "utWithCallbacks", ")", ";", "if", "(", "engine", "==", "null", ")", "{", "engine", "=", "new", "WSSecurityEngine", "(", ")", ";", "}", "config", "=", "engine", ".", "getWssConfig", "(", ")", ";", "}", "reqData", ".", "setWssConfig", "(", "config", ")", ";", "SOAPMessage", "doc", "=", "getSOAPMessage", "(", "msg", ")", ";", "boolean", "doDebug", "=", "LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ";", "boolean", "doTimeLog", "=", "TIME_LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ";", "SoapVersion", "version", "=", "msg", ".", "getVersion", "(", ")", ";", "if", "(", "doDebug", ")", "{", "LOG", ".", "fine", "(", "\"", "WSS4JInInterceptor: enter handleMessage()", "\"", ")", ";", "}", "long", "t0", "=", "0", ";", "long", "t1", "=", "0", ";", "long", "t2", "=", "0", ";", "long", "t3", "=", "0", ";", "if", "(", "doTimeLog", ")", "{", "t0", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "}", "try", "{", "reqData", ".", "setMsgContext", "(", "msg", ")", ";", "computeAction", "(", "msg", ",", "reqData", ")", ";", "List", "<", "Integer", ">", "actions", "=", "new", "ArrayList", "<", "Integer", ">", "(", ")", ";", "String", "action", "=", "getAction", "(", "msg", ",", "version", ")", ";", "int", "doAction", "=", "WSSecurityUtil", ".", "decodeAction", "(", "action", ",", "actions", ")", ";", "String", "actor", "=", "(", "String", ")", "getOption", "(", "WSHandlerConstants", ".", "ACTOR", ")", ";", "reqData", ".", "setCallbackHandler", "(", "getCallback", "(", "reqData", ",", "doAction", ",", "utWithCallbacks", ")", ")", ";", "String", "passwordTypeStrict", "=", "(", "String", ")", "getOption", "(", "WSHandlerConstants", ".", "PASSWORD_TYPE_STRICT", ")", ";", "if", "(", "passwordTypeStrict", "==", "null", ")", "{", "setProperty", "(", "WSHandlerConstants", ".", "PASSWORD_TYPE_STRICT", ",", "\"", "true", "\"", ")", ";", "}", "ReplayCache", "nonceCache", "=", "getReplayCache", "(", "msg", ",", "SecurityConstants", ".", "ENABLE_NONCE_CACHE", ",", "SecurityConstants", ".", "NONCE_CACHE_INSTANCE", ")", ";", "reqData", ".", "setNonceReplayCache", "(", "nonceCache", ")", ";", "ReplayCache", "timestampCache", "=", "getReplayCache", "(", "msg", ",", "SecurityConstants", ".", "ENABLE_TIMESTAMP_CACHE", ",", "SecurityConstants", ".", "TIMESTAMP_CACHE_INSTANCE", ")", ";", "reqData", ".", "setTimestampReplayCache", "(", "timestampCache", ")", ";", "doReceiverAction", "(", "doAction", ",", "reqData", ")", ";", "boolean", "enableRevocation", "=", "reqData", ".", "isRevocationEnabled", "(", ")", "||", "MessageUtils", ".", "isTrue", "(", "msg", ".", "getContextualProperty", "(", "SecurityConstants", ".", "ENABLE_REVOCATION", ")", ")", ";", "reqData", ".", "setEnableRevocation", "(", "enableRevocation", ")", ";", "if", "(", "doTimeLog", ")", "{", "t1", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "}", "Element", "elem", "=", "WSSecurityUtil", ".", "getSecurityHeader", "(", "doc", ".", "getSOAPPart", "(", ")", ",", "actor", ")", ";", "List", "<", "WSSecurityEngineResult", ">", "wsResult", "=", "engine", ".", "processSecurityHeader", "(", "elem", ",", "reqData", ")", ";", "if", "(", "doTimeLog", ")", "{", "t2", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "}", "if", "(", "wsResult", "!=", "null", "&&", "!", "wsResult", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "reqData", ".", "getWssConfig", "(", ")", ".", "isEnableSignatureConfirmation", "(", ")", ")", "{", "checkSignatureConfirmation", "(", "reqData", ",", "wsResult", ")", ";", "}", "storeSignature", "(", "msg", ",", "reqData", ",", "wsResult", ")", ";", "storeTimestamp", "(", "msg", ",", "reqData", ",", "wsResult", ")", ";", "checkActions", "(", "msg", ",", "reqData", ",", "wsResult", ",", "actions", ")", ";", "doResults", "(", "msg", ",", "actor", ",", "SAAJUtils", ".", "getHeader", "(", "doc", ")", ",", "SAAJUtils", ".", "getBody", "(", "doc", ")", ",", "wsResult", ",", "utWithCallbacks", ")", ";", "}", "else", "{", "wsResult", "=", "new", "ArrayList", "<", "WSSecurityEngineResult", ">", "(", ")", ";", "if", "(", "doc", ".", "getSOAPPart", "(", ")", ".", "getEnvelope", "(", ")", ".", "getBody", "(", ")", ".", "hasFault", "(", ")", ")", "{", "LOG", ".", "warning", "(", "\"", "Request does not contain Security header, ", "\"", "+", "\"", "but it's a fault.", "\"", ")", ";", "doResults", "(", "msg", ",", "actor", ",", "SAAJUtils", ".", "getHeader", "(", "doc", ")", ",", "SAAJUtils", ".", "getBody", "(", "doc", ")", ",", "wsResult", ")", ";", "}", "else", "{", "checkActions", "(", "msg", ",", "reqData", ",", "wsResult", ",", "actions", ")", ";", "doResults", "(", "msg", ",", "actor", ",", "SAAJUtils", ".", "getHeader", "(", "doc", ")", ",", "SAAJUtils", ".", "getBody", "(", "doc", ")", ",", "wsResult", ")", ";", "}", "}", "advanceBody", "(", "msg", ",", "SAAJUtils", ".", "getBody", "(", "doc", ")", ")", ";", "SAAJInInterceptor", ".", "replaceHeaders", "(", "doc", ",", "msg", ")", ";", "if", "(", "doTimeLog", ")", "{", "t3", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "TIME_LOG", ".", "fine", "(", "\"", "Receive request: total= ", "\"", "+", "(", "t3", "-", "t0", ")", "+", "\"", " request preparation= ", "\"", "+", "(", "t1", "-", "t0", ")", "+", "\"", " request processing= ", "\"", "+", "(", "t2", "-", "t1", ")", "+", "\"", " header, cert verify, timestamp= ", "\"", "+", "(", "t3", "-", "t2", ")", "+", "\"", "\\n", "\"", ")", ";", "}", "if", "(", "doDebug", ")", "{", "LOG", ".", "fine", "(", "\"", "WSS4JInInterceptor: exit handleMessage()", "\"", ")", ";", "}", "}", "catch", "(", "WSSecurityException", "e", ")", "{", "LOG", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "\"", ",", "e", ")", ";", "SoapFault", "fault", "=", "createSoapFault", "(", "version", ",", "e", ")", ";", "throw", "fault", ";", "}", "catch", "(", "XMLStreamException", "e", ")", "{", "throw", "new", "SoapFault", "(", "new", "Message", "(", "\"", "STAX_EX", "\"", ",", "LOG", ")", ",", "e", ",", "version", ".", "getSender", "(", ")", ")", ";", "}", "catch", "(", "SOAPException", "e", ")", "{", "throw", "new", "SoapFault", "(", "new", "Message", "(", "\"", "SAAJ_EX", "\"", ",", "LOG", ")", ",", "e", ",", "version", ".", "getSender", "(", ")", ")", ";", "}", "finally", "{", "reqData", ".", "clear", "(", ")", ";", "reqData", "=", "null", ";", "}", "}"], "idx": 39140, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "db11c9115f31e171de4622149f157d8283f6c720", "function_name": "handleMessage", "body_hash": "9d9c5ebd6ad5f2770dd07f1b509f876a1ea325b6"}
{"code": "private String guard(String filename) {\n            String guarded = filename.replace(\":\", \"_\");\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"guarded \" + filename + \" to \" + guarded);\n            }\n            return guarded;\n        }", "code_tokens": ["private", "String", "guard", "(", "String", "filename", ")", "{", "String", "guarded", "=", "filename", ".", "replace", "(", "\"", ":", "\"", ",", "\"", "_", "\"", ")", ";", "if", "(", "LOG", ".", "isDebugEnabled", "(", ")", ")", "{", "LOG", ".", "debug", "(", "\"", "guarded ", "\"", "+", "filename", "+", "\"", " to ", "\"", "+", "guarded", ")", ";", "}", "return", "guarded", ";", "}"], "idx": 20900, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "9fd5cb7dfe0fcc431f99d5e14206e0090e72f36b", "function_name": "guard", "body_hash": "580ea95eae2b0f19d00bf41e1831340cbc1958a5"}
{"code": "@Override\n      public boolean process(final TProtocol inProt, final TProtocol outProt) throws TException {\n        TTransport trans = inProt.getTransport();\n        if (!(trans instanceof TSaslServerTransport)) {\n          throw new TException(\"Unexpected non-SASL transport \" + trans.getClass());\n        }\n        TSaslServerTransport saslTrans = (TSaslServerTransport)trans;\n        SaslServer saslServer = saslTrans.getSaslServer();\n        String authId = saslServer.getAuthorizationID();\n        authenticationMethod.set(AuthenticationMethod.KERBEROS);\n        LOG.debug(\"AUTH ID ======>\" + authId);\n        String endUser = authId;\n\n        if(saslServer.getMechanismName().equals(\"DIGEST-MD5\")) {\n          try {\n            TokenIdentifier tokenId = SaslRpcServer.getIdentifier(authId,\n                secretManager);\n            endUser = tokenId.getUser().getUserName();\n            authenticationMethod.set(AuthenticationMethod.TOKEN);\n          } catch (InvalidToken e) {\n            throw new TException(e.getMessage());\n          }\n        }\n        Socket socket = ((TSocket)(saslTrans.getUnderlyingTransport())).getSocket();\n        remoteAddress.set(socket.getInetAddress());\n        UserGroupInformation clientUgi = null;\n        try {\n          if (useProxy) {\n            clientUgi = UserGroupInformation.createProxyUser(\n                endUser, UserGroupInformation.getLoginUser());\n            remoteUser.set(clientUgi.getShortUserName());\n            return clientUgi.doAs(new PrivilegedExceptionAction<Boolean>() {\n              @Override\n              public Boolean run() {\n                try {\n                  return wrapped.process(inProt, outProt);\n                } catch (TException te) {\n                  throw new RuntimeException(te);\n                }\n              }\n            });\n          } else {\n            remoteUser.set(endUser);\n            return wrapped.process(inProt, outProt);\n          }\n        } catch (RuntimeException rte) {\n          if (rte.getCause() instanceof TException) {\n            throw (TException)rte.getCause();\n          }\n          throw rte;\n        } catch (InterruptedException ie) {\n          throw new RuntimeException(ie); // unexpected!\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe); // unexpected!\n        }\n        finally {\n          if (clientUgi != null) {\n            try { FileSystem.closeAllForUGI(clientUgi); }\n            catch(IOException exception) {\n              LOG.error(\"Could not clean up file-system handles for UGI: \" + clientUgi, exception);\n            }\n          }\n        }\n      }", "code_tokens": ["@", "Override", "public", "boolean", "process", "(", "final", "TProtocol", "inProt", ",", "final", "TProtocol", "outProt", ")", "throws", "TException", "{", "TTransport", "trans", "=", "inProt", ".", "getTransport", "(", ")", ";", "if", "(", "!", "(", "trans", "instanceof", "TSaslServerTransport", ")", ")", "{", "throw", "new", "TException", "(", "\"", "Unexpected non-SASL transport ", "\"", "+", "trans", ".", "getClass", "(", ")", ")", ";", "}", "TSaslServerTransport", "saslTrans", "=", "(", "TSaslServerTransport", ")", "trans", ";", "SaslServer", "saslServer", "=", "saslTrans", ".", "getSaslServer", "(", ")", ";", "String", "authId", "=", "saslServer", ".", "getAuthorizationID", "(", ")", ";", "authenticationMethod", ".", "set", "(", "AuthenticationMethod", ".", "KERBEROS", ")", ";", "LOG", ".", "debug", "(", "\"", "AUTH ID ======>", "\"", "+", "authId", ")", ";", "String", "endUser", "=", "authId", ";", "if", "(", "saslServer", ".", "getMechanismName", "(", ")", ".", "equals", "(", "\"", "DIGEST-MD5", "\"", ")", ")", "{", "try", "{", "TokenIdentifier", "tokenId", "=", "SaslRpcServer", ".", "getIdentifier", "(", "authId", ",", "secretManager", ")", ";", "endUser", "=", "tokenId", ".", "getUser", "(", ")", ".", "getUserName", "(", ")", ";", "authenticationMethod", ".", "set", "(", "AuthenticationMethod", ".", "TOKEN", ")", ";", "}", "catch", "(", "InvalidToken", "e", ")", "{", "throw", "new", "TException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "Socket", "socket", "=", "(", "(", "TSocket", ")", "(", "saslTrans", ".", "getUnderlyingTransport", "(", ")", ")", ")", ".", "getSocket", "(", ")", ";", "remoteAddress", ".", "set", "(", "socket", ".", "getInetAddress", "(", ")", ")", ";", "UserGroupInformation", "clientUgi", "=", "null", ";", "try", "{", "if", "(", "useProxy", ")", "{", "clientUgi", "=", "UserGroupInformation", ".", "createProxyUser", "(", "endUser", ",", "UserGroupInformation", ".", "getLoginUser", "(", ")", ")", ";", "remoteUser", ".", "set", "(", "clientUgi", ".", "getShortUserName", "(", ")", ")", ";", "return", "clientUgi", ".", "doAs", "(", "new", "PrivilegedExceptionAction", "<", "Boolean", ">", "(", ")", "{", "@", "Override", "public", "Boolean", "run", "(", ")", "{", "try", "{", "return", "wrapped", ".", "process", "(", "inProt", ",", "outProt", ")", ";", "}", "catch", "(", "TException", "te", ")", "{", "throw", "new", "RuntimeException", "(", "te", ")", ";", "}", "}", "}", ")", ";", "}", "else", "{", "remoteUser", ".", "set", "(", "endUser", ")", ";", "return", "wrapped", ".", "process", "(", "inProt", ",", "outProt", ")", ";", "}", "}", "catch", "(", "RuntimeException", "rte", ")", "{", "if", "(", "rte", ".", "getCause", "(", ")", "instanceof", "TException", ")", "{", "throw", "(", "TException", ")", "rte", ".", "getCause", "(", ")", ";", "}", "throw", "rte", ";", "}", "catch", "(", "InterruptedException", "ie", ")", "{", "throw", "new", "RuntimeException", "(", "ie", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "RuntimeException", "(", "ioe", ")", ";", "}", "finally", "{", "if", "(", "clientUgi", "!=", "null", ")", "{", "try", "{", "FileSystem", ".", "closeAllForUGI", "(", "clientUgi", ")", ";", "}", "catch", "(", "IOException", "exception", ")", "{", "LOG", ".", "error", "(", "\"", "Could not clean up file-system handles for UGI: ", "\"", "+", "clientUgi", ",", "exception", ")", ";", "}", "}", "}", "}"], "idx": 37960, "cwe": "CWE-284", "target": 1, "status": "VULNERABLE", "commit": "5831be0c57", "function_name": "process", "body_hash": "3774e3c8284d8225ce132dd1c6f64b5f370d1656"}
{"code": "private void handleDynamicMethodInvocation(ActionMapping mapping, String name) {\n        int exclamation = name.lastIndexOf(\"!\");\n        if (exclamation != -1) {\n            String actionName = name.substring(0, exclamation);\n            String actionMethod = name.substring(exclamation + 1);\n\n            // WW-4585\n            // add any ; appendix to name, it will be handled later in getMapping method\n            int scPos = actionMethod.indexOf(';');\n            if (scPos != -1) {\n                actionName = actionName + actionMethod.substring(scPos);\n                actionMethod = actionMethod.substring(0, scPos);\n            }\n\n            mapping.setName(actionName);\n            if (allowDynamicMethodCalls) {\n                mapping.setMethod(actionMethod);\n            } else {\n                mapping.setMethod(null);\n            }\n        }\n    }", "code_tokens": ["private", "void", "handleDynamicMethodInvocation", "(", "ActionMapping", "mapping", ",", "String", "name", ")", "{", "int", "exclamation", "=", "name", ".", "lastIndexOf", "(", "\"", "!", "\"", ")", ";", "if", "(", "exclamation", "!=", "-", "1", ")", "{", "String", "actionName", "=", "name", ".", "substring", "(", "0", ",", "exclamation", ")", ";", "String", "actionMethod", "=", "name", ".", "substring", "(", "exclamation", "+", "1", ")", ";", "int", "scPos", "=", "actionMethod", ".", "indexOf", "(", "';'", ")", ";", "if", "(", "scPos", "!=", "-", "1", ")", "{", "actionName", "=", "actionName", "+", "actionMethod", ".", "substring", "(", "scPos", ")", ";", "actionMethod", "=", "actionMethod", ".", "substring", "(", "0", ",", "scPos", ")", ";", "}", "mapping", ".", "setName", "(", "actionName", ")", ";", "if", "(", "allowDynamicMethodCalls", ")", "{", "mapping", ".", "setMethod", "(", "actionMethod", ")", ";", "}", "else", "{", "mapping", ".", "setMethod", "(", "null", ")", ";", "}", "}", "}"], "idx": 10610, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "76eb8f38a33ad0f1f48464ee1311559c8d52dd6d", "function_name": "handleDynamicMethodInvocation", "body_hash": "4e99d081d430f5a4804d6650e083c5d884a8cdac"}
{"code": "@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        checkIllegalTypes(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }", "code_tokens": ["@", "Override", "public", "JsonDeserializer", "<", "Object", ">", "createBeanDeserializer", "(", "DeserializationContext", "ctxt", ",", "JavaType", "type", ",", "BeanDescription", "beanDesc", ")", "throws", "JsonMappingException", "{", "final", "DeserializationConfig", "config", "=", "ctxt", ".", "getConfig", "(", ")", ";", "JsonDeserializer", "<", "Object", ">", "custom", "=", "_findCustomBeanDeserializer", "(", "type", ",", "config", ",", "beanDesc", ")", ";", "if", "(", "custom", "!=", "null", ")", "{", "return", "custom", ";", "}", "if", "(", "type", ".", "isThrowable", "(", ")", ")", "{", "return", "buildThrowableDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "}", "if", "(", "type", ".", "isAbstract", "(", ")", "&&", "!", "type", ".", "isPrimitive", "(", ")", ")", "{", "JavaType", "concreteType", "=", "materializeAbstractType", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "if", "(", "concreteType", "!=", "null", ")", "{", "beanDesc", "=", "config", ".", "introspect", "(", "concreteType", ")", ";", "return", "buildBeanDeserializer", "(", "ctxt", ",", "concreteType", ",", "beanDesc", ")", ";", "}", "}", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "JsonDeserializer", "<", "Object", ">", "deser", "=", "(", "JsonDeserializer", "<", "Object", ">", ")", "findStdDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "if", "(", "deser", "!=", "null", ")", "{", "return", "deser", ";", "}", "if", "(", "!", "isPotentialBeanType", "(", "type", ".", "getRawClass", "(", ")", ")", ")", "{", "return", "null", ";", "}", "checkIllegalTypes", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "return", "buildBeanDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "}"], "idx": 61867, "cwe": "CWE-502", "target": 1, "status": "VULNERABLE", "commit": "2235894210c75f624a3d0cd60bfb0434a20a18bf", "function_name": "createBeanDeserializer", "body_hash": "8d4c16060669b7e0434f05893897629a9ef4a96b"}
{"code": "@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        _validateSubType(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }", "code_tokens": ["@", "Override", "public", "JsonDeserializer", "<", "Object", ">", "createBeanDeserializer", "(", "DeserializationContext", "ctxt", ",", "JavaType", "type", ",", "BeanDescription", "beanDesc", ")", "throws", "JsonMappingException", "{", "final", "DeserializationConfig", "config", "=", "ctxt", ".", "getConfig", "(", ")", ";", "JsonDeserializer", "<", "Object", ">", "custom", "=", "_findCustomBeanDeserializer", "(", "type", ",", "config", ",", "beanDesc", ")", ";", "if", "(", "custom", "!=", "null", ")", "{", "return", "custom", ";", "}", "if", "(", "type", ".", "isThrowable", "(", ")", ")", "{", "return", "buildThrowableDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "}", "if", "(", "type", ".", "isAbstract", "(", ")", "&&", "!", "type", ".", "isPrimitive", "(", ")", ")", "{", "JavaType", "concreteType", "=", "materializeAbstractType", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "if", "(", "concreteType", "!=", "null", ")", "{", "beanDesc", "=", "config", ".", "introspect", "(", "concreteType", ")", ";", "return", "buildBeanDeserializer", "(", "ctxt", ",", "concreteType", ",", "beanDesc", ")", ";", "}", "}", "@", "SuppressWarnings", "(", "\"", "unchecked", "\"", ")", "JsonDeserializer", "<", "Object", ">", "deser", "=", "(", "JsonDeserializer", "<", "Object", ">", ")", "findStdDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "if", "(", "deser", "!=", "null", ")", "{", "return", "deser", ";", "}", "if", "(", "!", "isPotentialBeanType", "(", "type", ".", "getRawClass", "(", ")", ")", ")", "{", "return", "null", ";", "}", "_validateSubType", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "return", "buildBeanDeserializer", "(", "ctxt", ",", "type", ",", "beanDesc", ")", ";", "}"], "idx": 61868, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "2235894210c75f624a3d0cd60bfb0434a20a18bf", "function_name": "createBeanDeserializer", "body_hash": "4da3c3cc4d3e46a20446c98191787aa7535c5beb"}
{"code": "@Override\n    public void deactivate() {\n        // Disassociate from the current conversation\n        if (isActive()) {\n            if (!isAssociated()) {\n                throw ConversationLogger.LOG.mustCallAssociateBeforeDeactivate();\n            }\n\n            try {\n                if (getCurrentConversation().isTransient() && getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) != null) {\n                    // WELD-1746 Don't destroy ended conversations - these must be destroyed in a synchronized block - see also cleanUpConversationMap()\n                    destroy();\n                } else {\n                    // Update the conversation timestamp\n                    getCurrentConversation().touch();\n                    if (!getBeanStore().isAttached()) {\n                        /*\n                         * This was a transient conversation at the beginning of the request, so we need to update the CID it uses, and attach it. We also add\n                         * it to the conversations the session knows about.\n                         */\n                        if (!(getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) instanceof ConversationNamingScheme)) {\n                            throw ConversationLogger.LOG.conversationNamingSchemeNotFound();\n                        }\n                        ((ConversationNamingScheme) getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME)).setCid(getCurrentConversation()\n                                .getId());\n\n                        getBeanStore().attach();\n                        getConversationMap().put(getCurrentConversation().getId(), getCurrentConversation());\n                    }\n                }\n            } finally {\n                // WELD-1690 always try to unlock the current conversation\n                getCurrentConversation().unlock();\n            }\n            setBeanStore(null);\n            // Clean up any expired/ended conversations\n            cleanUpConversationMap();\n            // deactivate the context\n            super.setActive(false);\n        } else {\n            throw ConversationLogger.LOG.contextNotActive();\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "deactivate", "(", ")", "{", "if", "(", "isActive", "(", ")", ")", "{", "if", "(", "!", "isAssociated", "(", ")", ")", "{", "throw", "ConversationLogger", ".", "LOG", ".", "mustCallAssociateBeforeDeactivate", "(", ")", ";", "}", "try", "{", "if", "(", "getCurrentConversation", "(", ")", ".", "isTransient", "(", ")", "&&", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", "!=", "null", ")", "{", "destroy", "(", ")", ";", "}", "else", "{", "getCurrentConversation", "(", ")", ".", "touch", "(", ")", ";", "if", "(", "!", "getBeanStore", "(", ")", ".", "isAttached", "(", ")", ")", "{", "if", "(", "!", "(", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", "instanceof", "ConversationNamingScheme", ")", ")", "{", "throw", "ConversationLogger", ".", "LOG", ".", "conversationNamingSchemeNotFound", "(", ")", ";", "}", "(", "(", "ConversationNamingScheme", ")", "getRequestAttribute", "(", "getRequest", "(", ")", ",", "ConversationNamingScheme", ".", "PARAMETER_NAME", ")", ")", ".", "setCid", "(", "getCurrentConversation", "(", ")", ".", "getId", "(", ")", ")", ";", "getBeanStore", "(", ")", ".", "attach", "(", ")", ";", "getConversationMap", "(", ")", ".", "put", "(", "getCurrentConversation", "(", ")", ".", "getId", "(", ")", ",", "getCurrentConversation", "(", ")", ")", ";", "}", "}", "}", "finally", "{", "getCurrentConversation", "(", ")", ".", "unlock", "(", ")", ";", "}", "setBeanStore", "(", "null", ")", ";", "cleanUpConversationMap", "(", ")", ";", "super", ".", "setActive", "(", "false", ")", ";", "}", "else", "{", "throw", "ConversationLogger", ".", "LOG", ".", "contextNotActive", "(", ")", ";", "}", "}"], "idx": 49118, "cwe": "CWE-362", "target": 1, "status": "VULNERABLE", "commit": "94fcb75", "function_name": "deactivate", "body_hash": "b6c4b1fffdae4e2860ccfb987dd71a75a7c21753"}
{"code": "protected void configureSnakeDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        Class<?> yamlUnmarshalType =  unmarshalType;\n        if (yamlUnmarshalType == null && unmarshalTypeName != null) {\n            try {\n                yamlUnmarshalType = camelContext.getClassResolver().resolveMandatoryClass(unmarshalTypeName);\n            } catch (ClassNotFoundException e) {\n                throw ObjectHelper.wrapRuntimeCamelException(e);\n            }\n        }\n\n        setProperty(dataFormat, camelContext, \"unmarshalType\", yamlUnmarshalType);\n        setProperty(dataFormat, camelContext, \"classLoader\", classLoader);\n        setProperty(dataFormat, camelContext, \"useApplicationContextClassLoader\", useApplicationContextClassLoader);\n        setProperty(dataFormat, camelContext, \"prettyFlow\", prettyFlow);\n        setProperty(dataFormat, camelContext, \"allowAnyType\", allowAnyType);\n\n        if (typeFilters != null && !typeFilters.isEmpty()) {\n            List<String> typeFilterDefinitions = new ArrayList<>(typeFilters.size());\n            for (YAMLTypeFilterDefinition definition : typeFilters) {\n                String value = definition.getValue();\n\n                if (!value.startsWith(\"type\") && !value.startsWith(\"regexp\")) {\n                    YAMLTypeFilterType type = definition.getType();\n                    if (type == null) {\n                        type = YAMLTypeFilterType.type;\n                    }\n\n                    value = type.name() + \":\" + value;\n                }\n\n                typeFilterDefinitions.add(value);\n            }\n\n            setProperty(dataFormat, camelContext, \"typeFilterDefinitions\", typeFilterDefinitions);\n        }\n\n        setPropertyRef(dataFormat, camelContext, \"constructor\", constructor);\n        setPropertyRef(dataFormat, camelContext, \"representer\", representer);\n        setPropertyRef(dataFormat, camelContext, \"dumperOptions\", dumperOptions);\n        setPropertyRef(dataFormat, camelContext, \"resolver\", resolver);\n    }", "code_tokens": ["protected", "void", "configureSnakeDataFormat", "(", "DataFormat", "dataFormat", ",", "CamelContext", "camelContext", ")", "{", "Class", "<", "?", ">", "yamlUnmarshalType", "=", "unmarshalType", ";", "if", "(", "yamlUnmarshalType", "==", "null", "&&", "unmarshalTypeName", "!=", "null", ")", "{", "try", "{", "yamlUnmarshalType", "=", "camelContext", ".", "getClassResolver", "(", ")", ".", "resolveMandatoryClass", "(", "unmarshalTypeName", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "throw", "ObjectHelper", ".", "wrapRuntimeCamelException", "(", "e", ")", ";", "}", "}", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "unmarshalType", "\"", ",", "yamlUnmarshalType", ")", ";", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "classLoader", "\"", ",", "classLoader", ")", ";", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "useApplicationContextClassLoader", "\"", ",", "useApplicationContextClassLoader", ")", ";", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "prettyFlow", "\"", ",", "prettyFlow", ")", ";", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "allowAnyType", "\"", ",", "allowAnyType", ")", ";", "if", "(", "typeFilters", "!=", "null", "&&", "!", "typeFilters", ".", "isEmpty", "(", ")", ")", "{", "List", "<", "String", ">", "typeFilterDefinitions", "=", "new", "ArrayList", "<", ">", "(", "typeFilters", ".", "size", "(", ")", ")", ";", "for", "(", "YAMLTypeFilterDefinition", "definition", ":", "typeFilters", ")", "{", "String", "value", "=", "definition", ".", "getValue", "(", ")", ";", "if", "(", "!", "value", ".", "startsWith", "(", "\"", "type", "\"", ")", "&&", "!", "value", ".", "startsWith", "(", "\"", "regexp", "\"", ")", ")", "{", "YAMLTypeFilterType", "type", "=", "definition", ".", "getType", "(", ")", ";", "if", "(", "type", "==", "null", ")", "{", "type", "=", "YAMLTypeFilterType", ".", "type", ";", "}", "value", "=", "type", ".", "name", "(", ")", "+", "\"", ":", "\"", "+", "value", ";", "}", "typeFilterDefinitions", ".", "add", "(", "value", ")", ";", "}", "setProperty", "(", "dataFormat", ",", "camelContext", ",", "\"", "typeFilterDefinitions", "\"", ",", "typeFilterDefinitions", ")", ";", "}", "setPropertyRef", "(", "dataFormat", ",", "camelContext", ",", "\"", "constructor", "\"", ",", "constructor", ")", ";", "setPropertyRef", "(", "dataFormat", ",", "camelContext", ",", "\"", "representer", "\"", ",", "representer", ")", ";", "setPropertyRef", "(", "dataFormat", ",", "camelContext", ",", "\"", "dumperOptions", "\"", ",", "dumperOptions", ")", ";", "setPropertyRef", "(", "dataFormat", ",", "camelContext", ",", "\"", "resolver", "\"", ",", "resolver", ")", ";", "}"], "idx": 57295, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "20e26226107f3133c87d0f5c845e02f824823f69", "function_name": "configureSnakeDataFormat", "body_hash": "7b772b9b84e47d01e156d903d859f82d749de073"}
{"code": "@Override\n    public void showWebPage(String url, boolean openExternal, boolean clearHistory, Map<String, Object> params) {\n        LOG.d(TAG, \"showWebPage(%s, %b, %b, HashMap\", url, openExternal, clearHistory);\n\n        // If clearing history\n        if (clearHistory) {\n            engine.clearHistory();\n        }\n\n        // If loading into our webview\n        if (!openExternal) {\n            // Make sure url is in whitelist\n            if (pluginManager.shouldAllowNavigation(url)) {\n                // TODO: What about params?\n                // Load new URL\n                loadUrlIntoView(url, true);\n                return;\n            }\n            // Load in default viewer if not\n            LOG.w(TAG, \"showWebPage: Cannot load URL into webview since it is not in white list.  Loading into browser instead. (URL=\" + url + \")\");\n        }\n        try {\n            // Omitting the MIME type for file: URLs causes \"No Activity found to handle Intent\".\n            // Adding the MIME type to http: URLs causes them to not be handled by the downloader.\n            Intent intent = new Intent(Intent.ACTION_VIEW);\n            Uri uri = Uri.parse(url);\n            if (\"file\".equals(uri.getScheme())) {\n                intent.setDataAndType(uri, resourceApi.getMimeType(uri));\n            } else {\n                intent.setData(uri);\n            }\n            cordova.getActivity().startActivity(intent);\n        } catch (android.content.ActivityNotFoundException e) {\n            LOG.e(TAG, \"Error loading url \" + url, e);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "showWebPage", "(", "String", "url", ",", "boolean", "openExternal", ",", "boolean", "clearHistory", ",", "Map", "<", "String", ",", "Object", ">", "params", ")", "{", "LOG", ".", "d", "(", "TAG", ",", "\"", "showWebPage(%s, %b, %b, HashMap", "\"", ",", "url", ",", "openExternal", ",", "clearHistory", ")", ";", "if", "(", "clearHistory", ")", "{", "engine", ".", "clearHistory", "(", ")", ";", "}", "if", "(", "!", "openExternal", ")", "{", "if", "(", "pluginManager", ".", "shouldAllowNavigation", "(", "url", ")", ")", "{", "loadUrlIntoView", "(", "url", ",", "true", ")", ";", "return", ";", "}", "LOG", ".", "w", "(", "TAG", ",", "\"", "showWebPage: Cannot load URL into webview since it is not in white list.  Loading into browser instead. (URL=", "\"", "+", "url", "+", "\"", ")", "\"", ")", ";", "}", "try", "{", "Intent", "intent", "=", "new", "Intent", "(", "Intent", ".", "ACTION_VIEW", ")", ";", "Uri", "uri", "=", "Uri", ".", "parse", "(", "url", ")", ";", "if", "(", "\"", "file", "\"", ".", "equals", "(", "uri", ".", "getScheme", "(", ")", ")", ")", "{", "intent", ".", "setDataAndType", "(", "uri", ",", "resourceApi", ".", "getMimeType", "(", "uri", ")", ")", ";", "}", "else", "{", "intent", ".", "setData", "(", "uri", ")", ";", "}", "cordova", ".", "getActivity", "(", ")", ".", "startActivity", "(", "intent", ")", ";", "}", "catch", "(", "android", ".", "content", ".", "ActivityNotFoundException", "e", ")", "{", "LOG", ".", "e", "(", "TAG", ",", "\"", "Error loading url ", "\"", "+", "url", ",", "e", ")", ";", "}", "}"], "idx": 31533, "cwe": "CWE-264", "target": 1, "status": "VULNERABLE", "commit": "af2969dec58ca89150b84b5d57edcf63d4ce1302", "function_name": "showWebPage", "body_hash": "128738d47aef89ce6917186e9b040addd142a863"}
{"code": "public Document readFrom(Class<Document> clazz, Type type,\r\n                            Annotation[] annotations, MediaType mediaType,\r\n                            MultivaluedMap<String, String> headers, InputStream input)\r\n           throws IOException, WebApplicationException\r\n   {\r\n      try\r\n      {\r\n         documentBuilder.setExpandEntityReferences(expandEntityReferences);\r\n         documentBuilder.setFeature(\"http://xml.org/sax/features/external-general-entities\", expandEntityReferences);\r\n         documentBuilder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", expandEntityReferences);\r\n         documentBuilder.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, enableSecureProcessingFeature);\r\n         documentBuilder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", disableDTDs);\r\n         return documentBuilder.newDocumentBuilder().parse(input);\r\n      }\r\n      catch (Exception e)\r\n      {\r\n         throw new ReaderException(e);\r\n      }\r\n   }", "code_tokens": ["public", "Document", "readFrom", "(", "Class", "<", "Document", ">", "clazz", ",", "Type", "type", ",", "Annotation", "[", "]", "annotations", ",", "MediaType", "mediaType", ",", "MultivaluedMap", "<", "String", ",", "String", ">", "headers", ",", "InputStream", "input", ")", "throws", "IOException", ",", "WebApplicationException", "{", "try", "{", "documentBuilder", ".", "setExpandEntityReferences", "(", "expandEntityReferences", ")", ";", "documentBuilder", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-general-entities", "\"", ",", "expandEntityReferences", ")", ";", "documentBuilder", ".", "setFeature", "(", "\"", "http://xml.org/sax/features/external-parameter-entities", "\"", ",", "expandEntityReferences", ")", ";", "documentBuilder", ".", "setFeature", "(", "XMLConstants", ".", "FEATURE_SECURE_PROCESSING", ",", "enableSecureProcessingFeature", ")", ";", "documentBuilder", ".", "setFeature", "(", "\"", "http://apache.org/xml/features/disallow-doctype-decl", "\"", ",", "disableDTDs", ")", ";", "return", "documentBuilder", ".", "newDocumentBuilder", "(", ")", ".", "parse", "(", "input", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "ReaderException", "(", "e", ")", ";", "}", "}"], "idx": 10775, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "7a0b80f57f9258e035b9584ddaa72414454e07b2", "function_name": "readFrom", "body_hash": "71de2cb886648f91479e9cfbe82f0f4c62c81464"}
{"code": "protected void createWebXmlDigester(boolean namespaceAware,\n            boolean validation) {\n        \n        if (!namespaceAware && !validation) {\n            webDigester = webDigesters[0];\n            webFragmentDigester = webFragmentDigesters[0];\n            \n        } else if (!namespaceAware && validation) {\n            webDigester = webDigesters[1];\n            webFragmentDigester = webFragmentDigesters[1];\n            \n        } else if (namespaceAware && !validation) {\n            webDigester = webDigesters[2];\n            webFragmentDigester = webFragmentDigesters[2];\n            \n        } else {\n            webDigester = webDigesters[3];\n            webFragmentDigester = webFragmentDigesters[3];\n        }\n    }", "code_tokens": ["protected", "void", "createWebXmlDigester", "(", "boolean", "namespaceAware", ",", "boolean", "validation", ")", "{", "if", "(", "!", "namespaceAware", "&&", "!", "validation", ")", "{", "webDigester", "=", "webDigesters", "[", "0", "]", ";", "webFragmentDigester", "=", "webFragmentDigesters", "[", "0", "]", ";", "}", "else", "if", "(", "!", "namespaceAware", "&&", "validation", ")", "{", "webDigester", "=", "webDigesters", "[", "1", "]", ";", "webFragmentDigester", "=", "webFragmentDigesters", "[", "1", "]", ";", "}", "else", "if", "(", "namespaceAware", "&&", "!", "validation", ")", "{", "webDigester", "=", "webDigesters", "[", "2", "]", ";", "webFragmentDigester", "=", "webFragmentDigesters", "[", "2", "]", ";", "}", "else", "{", "webDigester", "=", "webDigesters", "[", "3", "]", ";", "webFragmentDigester", "=", "webFragmentDigesters", "[", "3", "]", ";", "}", "}"], "idx": 111219, "cwe": "NVD-CWE-Other", "target": 1, "status": "VULNERABLE", "commit": "279e4451cb996f810fbca2f78b6340412d9daa7b", "function_name": "createWebXmlDigester", "body_hash": "a2f86e99f05519ae58a6fab57114f3ecf7bb587b"}
{"code": "public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        String pathUC = path.toUpperCase(Locale.ENGLISH);\n        if (path.isEmpty() || path.contains(\"..\") || path.startsWith(\".\") || path.contains(\"%\") || pathUC.contains(\"META-INF\") || pathUC.contains(\"WEB-INF\")) {\n            LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n    }", "code_tokens": ["public", "void", "doDynamic", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ")", "throws", "IOException", ",", "ServletException", "{", "String", "path", "=", "req", ".", "getRestOfPath", "(", ")", ";", "String", "pathUC", "=", "path", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ";", "if", "(", "path", ".", "isEmpty", "(", ")", "||", "path", ".", "contains", "(", "\"", "..", "\"", ")", "||", "path", ".", "startsWith", "(", "\"", ".", "\"", ")", "||", "path", ".", "contains", "(", "\"", "%", "\"", ")", "||", "pathUC", ".", "contains", "(", "\"", "META-INF", "\"", ")", "||", "pathUC", ".", "contains", "(", "\"", "WEB-INF", "\"", ")", ")", "{", "LOGGER", ".", "warning", "(", "\"", "rejecting possibly malicious ", "\"", "+", "req", ".", "getRequestURIWithQueryString", "(", ")", ")", ";", "rsp", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "String", "requestPath", "=", "req", ".", "getRequestURI", "(", ")", ".", "substring", "(", "req", ".", "getContextPath", "(", ")", ".", "length", "(", ")", ")", ";", "boolean", "staticLink", "=", "requestPath", ".", "startsWith", "(", "\"", "/static/", "\"", ")", ";", "long", "expires", "=", "staticLink", "?", "TimeUnit2", ".", "DAYS", ".", "toMillis", "(", "365", ")", ":", "-", "1", ";", "rsp", ".", "serveLocalizedFile", "(", "req", ",", "new", "URL", "(", "wrapper", ".", "baseResourceURL", ",", "'.'", "+", "path", ")", ",", "expires", ")", ";", "}"], "idx": 15681, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "f46842c7a2c916170ac457a039a2f7f019afd885", "function_name": "doDynamic", "body_hash": "396146c4f6a63d39b83da215b0c2f796dfafaac4"}
{"code": "@Before\n    public void createCaptor() throws Exception {\n        applicationEventPublisher = mock(ApplicationEventPublisher.class);\n        ClientAdminEventPublisher eventPublisher = (ClientAdminEventPublisher) getWebApplicationContext().getBean(\"clientAdminEventPublisher\");\n        originalApplicationEventPublisher = eventPublisher.getPublisher();\n        eventPublisher.setApplicationEventPublisher(applicationEventPublisher);\n        captor = ArgumentCaptor.forClass(AbstractUaaEvent.class);\n        scimUserEndpoints = getWebApplicationContext().getBean(ScimUserEndpoints.class);\n        scimGroupEndpoints = getWebApplicationContext().getBean(ScimGroupEndpoints.class);\n\n        testClient = new TestClient(getMockMvc());\n        testAccounts = org.cloudfoundry.identity.uaa.test.UaaTestAccounts.standard(null);\n        adminToken = testClient.getClientCredentialsOAuthAccessToken(\n                testAccounts.getAdminClientId(),\n                testAccounts.getAdminClientSecret(),\n                \"clients.admin clients.read clients.write clients.secret scim.read scim.write\");\n\n        testPassword = \"password\";\n        String username = new RandomValueStringGenerator().generate() + \"@test.org\";\n        testUser = new ScimUser(null, username, \"givenname\",\"familyname\");\n        testUser.setPrimaryEmail(username);\n        testUser.setPassword(testPassword);\n        testUser = MockMvcUtils.utils().createUser(getMockMvc(), adminToken, testUser);\n        testUser.setPassword(testPassword);\n\n        applicationEventPublisher = mock(ApplicationEventPublisher.class);\n        eventPublisher.setApplicationEventPublisher(applicationEventPublisher);\n        captor = ArgumentCaptor.forClass(AbstractUaaEvent.class);\n    }", "code_tokens": ["@", "Before", "public", "void", "createCaptor", "(", ")", "throws", "Exception", "{", "applicationEventPublisher", "=", "mock", "(", "ApplicationEventPublisher", ".", "class", ")", ";", "ClientAdminEventPublisher", "eventPublisher", "=", "(", "ClientAdminEventPublisher", ")", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "\"", "clientAdminEventPublisher", "\"", ")", ";", "originalApplicationEventPublisher", "=", "eventPublisher", ".", "getPublisher", "(", ")", ";", "eventPublisher", ".", "setApplicationEventPublisher", "(", "applicationEventPublisher", ")", ";", "captor", "=", "ArgumentCaptor", ".", "forClass", "(", "AbstractUaaEvent", ".", "class", ")", ";", "scimUserEndpoints", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "ScimUserEndpoints", ".", "class", ")", ";", "scimGroupEndpoints", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "ScimGroupEndpoints", ".", "class", ")", ";", "testClient", "=", "new", "TestClient", "(", "getMockMvc", "(", ")", ")", ";", "testAccounts", "=", "org", ".", "cloudfoundry", ".", "identity", ".", "uaa", ".", "test", ".", "UaaTestAccounts", ".", "standard", "(", "null", ")", ";", "adminToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "testAccounts", ".", "getAdminClientId", "(", ")", ",", "testAccounts", ".", "getAdminClientSecret", "(", ")", ",", "\"", "clients.admin clients.read clients.write clients.secret scim.read scim.write", "\"", ")", ";", "testPassword", "=", "\"", "password", "\"", ";", "String", "username", "=", "new", "RandomValueStringGenerator", "(", ")", ".", "generate", "(", ")", "+", "\"", "@test.org", "\"", ";", "testUser", "=", "new", "ScimUser", "(", "null", ",", "username", ",", "\"", "givenname", "\"", ",", "\"", "familyname", "\"", ")", ";", "testUser", ".", "setPrimaryEmail", "(", "username", ")", ";", "testUser", ".", "setPassword", "(", "testPassword", ")", ";", "testUser", "=", "MockMvcUtils", ".", "utils", "(", ")", ".", "createUser", "(", "getMockMvc", "(", ")", ",", "adminToken", ",", "testUser", ")", ";", "testUser", ".", "setPassword", "(", "testPassword", ")", ";", "applicationEventPublisher", "=", "mock", "(", "ApplicationEventPublisher", ".", "class", ")", ";", "eventPublisher", ".", "setApplicationEventPublisher", "(", "applicationEventPublisher", ")", ";", "captor", "=", "ArgumentCaptor", ".", "forClass", "(", "AbstractUaaEvent", ".", "class", ")", ";", "}"], "idx": 92767, "cwe": "CWE-89", "target": 0, "status": "FIXED", "commit": "6bf1c0ae1abc9aaba957708e0b2dfb6a70aab826", "function_name": "createCaptor", "body_hash": "21a9dd7ba062d1e07d5997d6f1f381d4771a613f"}
{"code": "public Stream<CompilerInput> finalize(URI remoteURI, PackageID moduleID) {\n        try {\n            // only continue if a fixed module version is not set. a module version may be set through Ballerina.toml or\n            // Ballerina.lock already.\n            Matcher matcher = semVerPatchPattern.matcher(moduleID.version.value);\n            if (\"\".equals(moduleID.version.value) || \"*\".equals(moduleID.version.value) || matcher.matches()) {\n                HttpsURLConnection conn;\n                // set proxy if exists.\n                if (null == this.proxy) {\n                    conn = (HttpsURLConnection) remoteURI.toURL().openConnection();\n                } else {\n                    conn = (HttpsURLConnection) remoteURI.toURL().openConnection(this.proxy);\n                }\n                conn.setInstanceFollowRedirects(false);\n                conn.setRequestMethod(\"GET\");\n\n                // status code and meaning\n                //// 200 - module info found\n                //// 400 - bad request sent\n                //// 500 - backend is broken\n                int statusCode = conn.getResponseCode();\n                if (statusCode == 200) {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                            Charset.defaultCharset()))) {\n                        StringBuilder result = new StringBuilder();\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            result.append(line);\n                        }\n                        Object payload = JSONParser.parse(result.toString());\n                        if (payload instanceof MapValue) {\n                            MapValue moduleInfo = ((MapValue) payload).getMapValue(\"module\");\n                            String version = moduleInfo.getStringValue(\"version\");\n                            moduleID.version = new Name(version);\n                        }\n                    }\n                } else if (statusCode == 400 && !loggedError) {\n                    try (BufferedReader errorStream = new BufferedReader(\n                            new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {\n                        String errorContent = errorStream.lines().collect(Collectors.joining(\"\\n\"));\n                        this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                                \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                                \"flag to build in offline mode. reason: \" + errorContent);\n                        setErrorLoggedStatusAsTrue();\n                    }\n                } else if (statusCode == 500 && !loggedError) {\n                    this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                            \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                            \"flag to build in offline mode.\");\n                    setErrorLoggedStatusAsTrue();\n                }\n                conn.disconnect();\n                Authenticator.setDefault(null);\n            }\n        } catch (IOException e) {\n            // ignore error and don't set the version.\n        }\n\n        return Stream.empty();\n    }", "code_tokens": ["public", "Stream", "<", "CompilerInput", ">", "finalize", "(", "URI", "remoteURI", ",", "PackageID", "moduleID", ")", "{", "try", "{", "Matcher", "matcher", "=", "semVerPatchPattern", ".", "matcher", "(", "moduleID", ".", "version", ".", "value", ")", ";", "if", "(", "\"", "\"", ".", "equals", "(", "moduleID", ".", "version", ".", "value", ")", "||", "\"", "*", "\"", ".", "equals", "(", "moduleID", ".", "version", ".", "value", ")", "||", "matcher", ".", "matches", "(", ")", ")", "{", "HttpsURLConnection", "conn", ";", "if", "(", "null", "==", "this", ".", "proxy", ")", "{", "conn", "=", "(", "HttpsURLConnection", ")", "remoteURI", ".", "toURL", "(", ")", ".", "openConnection", "(", ")", ";", "}", "else", "{", "conn", "=", "(", "HttpsURLConnection", ")", "remoteURI", ".", "toURL", "(", ")", ".", "openConnection", "(", "this", ".", "proxy", ")", ";", "}", "conn", ".", "setInstanceFollowRedirects", "(", "false", ")", ";", "conn", ".", "setRequestMethod", "(", "\"", "GET", "\"", ")", ";", "int", "statusCode", "=", "conn", ".", "getResponseCode", "(", ")", ";", "if", "(", "statusCode", "==", "200", ")", "{", "try", "(", "BufferedReader", "reader", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "conn", ".", "getInputStream", "(", ")", ",", "Charset", ".", "defaultCharset", "(", ")", ")", ")", ")", "{", "StringBuilder", "result", "=", "new", "StringBuilder", "(", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "reader", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "result", ".", "append", "(", "line", ")", ";", "}", "Object", "payload", "=", "JSONParser", ".", "parse", "(", "result", ".", "toString", "(", ")", ")", ";", "if", "(", "payload", "instanceof", "MapValue", ")", "{", "MapValue", "moduleInfo", "=", "(", "(", "MapValue", ")", "payload", ")", ".", "getMapValue", "(", "\"", "module", "\"", ")", ";", "String", "version", "=", "moduleInfo", ".", "getStringValue", "(", "\"", "version", "\"", ")", ";", "moduleID", ".", "version", "=", "new", "Name", "(", "version", ")", ";", "}", "}", "}", "else", "if", "(", "statusCode", "==", "400", "&&", "!", "loggedError", ")", "{", "try", "(", "BufferedReader", "errorStream", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "conn", ".", "getInputStream", "(", ")", ",", "Charset", ".", "defaultCharset", "(", ")", ")", ")", ")", "{", "String", "errorContent", "=", "errorStream", ".", "lines", "(", ")", ".", "collect", "(", "Collectors", ".", "joining", "(", "\"", "\\n", "\"", ")", ")", ";", "this", ".", "errStream", ".", "println", "(", "\"", "error: could not connect to remote repository to find the latest ", "\"", "+", "\"", "version of module: ", "\"", "+", "moduleID", ".", "toString", "(", ")", "+", "\"", ". use '--offline' ", "\"", "+", "\"", "flag to build in offline mode. reason: ", "\"", "+", "errorContent", ")", ";", "setErrorLoggedStatusAsTrue", "(", ")", ";", "}", "}", "else", "if", "(", "statusCode", "==", "500", "&&", "!", "loggedError", ")", "{", "this", ".", "errStream", ".", "println", "(", "\"", "error: could not connect to remote repository to find the latest ", "\"", "+", "\"", "version of module: ", "\"", "+", "moduleID", ".", "toString", "(", ")", "+", "\"", ". use '--offline' ", "\"", "+", "\"", "flag to build in offline mode.", "\"", ")", ";", "setErrorLoggedStatusAsTrue", "(", ")", ";", "}", "conn", ".", "disconnect", "(", ")", ";", "Authenticator", ".", "setDefault", "(", "null", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "}", "return", "Stream", ".", "empty", "(", ")", ";", "}"], "idx": 41165, "cwe": "CWE-306", "target": 0, "status": "FIXED", "commit": "4609ffee1744ecd16aac09303b1783bf0a525816", "function_name": "finalize", "body_hash": "93c513ac0e2f840f2cee67715a0fa3ce14c8fedc"}
{"code": "public void handleMessage(Message message) throws Fault {\n        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Invoking HTTP method \" + method);\n        }\n        if (!isGET(message)) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"URIMappingInterceptor can only handle HTTP GET, not HTTP \" + method);\n            }\n            return;\n        }\n        if (MessageUtils.getContextualBoolean(message, URIMAPPING_SKIP, false)) {\n            return;\n        }\n\n        String opName = getOperationName(message);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"URIMappingInterceptor get operation: \" + opName);\n        }\n        BindingOperationInfo op = ServiceModelUtil.getOperation(message.getExchange(), opName);\n        \n        if (op == null || opName == null || op.getName() == null\n            || StringUtils.isEmpty(op.getName().getLocalPart())\n            || !opName.equals(op.getName().getLocalPart())) {\n            \n            if (!Boolean.TRUE.equals(message.getContextualProperty(NO_VALIDATE_PARTS))) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"NO_OPERATION_PATH\", LOG, opName,\n                                                                       message.get(Message.PATH_INFO)));\n            }\n            MessageContentsList params = new MessageContentsList();\n            params.add(null);\n            message.setContent(List.class, params);\n            if (op == null) {\n                op = findAnyOp(message.getExchange());\n            }\n            if (op != null) {\n                message.getExchange().put(BindingOperationInfo.class, op);\n            }\n        } else {\n            message.getExchange().put(BindingOperationInfo.class, op);\n            MessageContentsList params = getParameters(message, op);\n            message.setContent(List.class, params);\n        }\n    }", "code_tokens": ["public", "void", "handleMessage", "(", "Message", "message", ")", "throws", "Fault", "{", "String", "method", "=", "(", "String", ")", "message", ".", "get", "(", "Message", ".", "HTTP_REQUEST_METHOD", ")", ";", "if", "(", "LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "Invoking HTTP method ", "\"", "+", "method", ")", ";", "}", "if", "(", "!", "isGET", "(", "message", ")", ")", "{", "if", "(", "LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "LOG", ".", "log", "(", "Level", ".", "FINE", ",", "\"", "URIMappingInterceptor can only handle HTTP GET, not HTTP ", "\"", "+", "method", ")", ";", "}", "return", ";", "}", "if", "(", "MessageUtils", ".", "getContextualBoolean", "(", "message", ",", "URIMAPPING_SKIP", ",", "false", ")", ")", "{", "return", ";", "}", "String", "opName", "=", "getOperationName", "(", "message", ")", ";", "if", "(", "LOG", ".", "isLoggable", "(", "Level", ".", "FINE", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "URIMappingInterceptor get operation: ", "\"", "+", "opName", ")", ";", "}", "BindingOperationInfo", "op", "=", "ServiceModelUtil", ".", "getOperation", "(", "message", ".", "getExchange", "(", ")", ",", "opName", ")", ";", "if", "(", "op", "==", "null", "||", "opName", "==", "null", "||", "op", ".", "getName", "(", ")", "==", "null", "||", "StringUtils", ".", "isEmpty", "(", "op", ".", "getName", "(", ")", ".", "getLocalPart", "(", ")", ")", "||", "!", "opName", ".", "equals", "(", "op", ".", "getName", "(", ")", ".", "getLocalPart", "(", ")", ")", ")", "{", "if", "(", "!", "Boolean", ".", "TRUE", ".", "equals", "(", "message", ".", "getContextualProperty", "(", "NO_VALIDATE_PARTS", ")", ")", ")", "{", "throw", "new", "Fault", "(", "new", "org", ".", "apache", ".", "cxf", ".", "common", ".", "i18n", ".", "Message", "(", "\"", "NO_OPERATION_PATH", "\"", ",", "LOG", ",", "opName", ",", "message", ".", "get", "(", "Message", ".", "PATH_INFO", ")", ")", ")", ";", "}", "MessageContentsList", "params", "=", "new", "MessageContentsList", "(", ")", ";", "params", ".", "add", "(", "null", ")", ";", "message", ".", "setContent", "(", "List", ".", "class", ",", "params", ")", ";", "if", "(", "op", "==", "null", ")", "{", "op", "=", "findAnyOp", "(", "message", ".", "getExchange", "(", ")", ")", ";", "}", "if", "(", "op", "!=", "null", ")", "{", "message", ".", "getExchange", "(", ")", ".", "put", "(", "BindingOperationInfo", ".", "class", ",", "op", ")", ";", "}", "}", "else", "{", "message", ".", "getExchange", "(", ")", ".", "put", "(", "BindingOperationInfo", ".", "class", ",", "op", ")", ";", "MessageContentsList", "params", "=", "getParameters", "(", "message", ",", "op", ")", ";", "message", ".", "setContent", "(", "List", ".", "class", ",", "params", ")", ";", "}", "}"], "idx": 38255, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "db11c9115f31e171de4622149f157d8283f6c720", "function_name": "handleMessage", "body_hash": "920e7b0ccb145e234fba02ab2dd5e873f48426ad"}
{"code": "private void init() {\n        authMap = new HashMap<Pair<String, String>, String>();\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n        try {\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(getClass().getResource(\"/\" + authorizations).openStream());\n            doc.getDocumentElement().normalize();\n\n            Node authNode = null;\n            NodeList root = doc.getChildNodes();\n            for (int i = 0; i < root.getLength() && authNode == null; i++) {\n                if (\"auth\".equals(root.item(i).getNodeName())) {\n                    authNode = root.item(i);\n                }\n            }\n            if (authNode == null) {\n                throw new IllegalArgumentException(\"Could not find root <auth> node\");\n            }\n\n            NodeList pages = authNode.getChildNodes();\n            for (int i = 0; i < pages.getLength(); i++) {\n                if (\"page\".equals(pages.item(i).getNodeName())) {\n                    String page = pages.item(i).getAttributes().getNamedItem(\"id\").getTextContent();\n\n                    NodeList actions = pages.item(i).getChildNodes();\n                    for (int j = 0; j < actions.getLength(); j++) {\n                        if (\"action\".equals(actions.item(j).getNodeName())) {\n                            String action = actions.item(j).getAttributes().getNamedItem(\"id\").getTextContent();\n\n                            NodeList entitlements = actions.item(j).getChildNodes();\n                            for (int k = 0; k < entitlements.getLength(); k++) {\n                                if (\"entitlement\".equals(entitlements.item(k).getNodeName())) {\n                                    String entitlement = entitlements.item(k).getTextContent();\n                                    authMap.put(new ImmutablePair<String, String>(page, action), entitlement);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"While initializing parsing of {}\", authorizations, e);\n        }\n    }", "code_tokens": ["private", "void", "init", "(", ")", "{", "authMap", "=", "new", "HashMap", "<", "Pair", "<", "String", ",", "String", ">", ",", "String", ">", "(", ")", ";", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "dbf", ".", "setNamespaceAware", "(", "true", ")", ";", "try", "{", "DocumentBuilder", "db", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "Document", "doc", "=", "db", ".", "parse", "(", "getClass", "(", ")", ".", "getResource", "(", "\"", "/", "\"", "+", "authorizations", ")", ".", "openStream", "(", ")", ")", ";", "doc", ".", "getDocumentElement", "(", ")", ".", "normalize", "(", ")", ";", "Node", "authNode", "=", "null", ";", "NodeList", "root", "=", "doc", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "root", ".", "getLength", "(", ")", "&&", "authNode", "==", "null", ";", "i", "++", ")", "{", "if", "(", "\"", "auth", "\"", ".", "equals", "(", "root", ".", "item", "(", "i", ")", ".", "getNodeName", "(", ")", ")", ")", "{", "authNode", "=", "root", ".", "item", "(", "i", ")", ";", "}", "}", "if", "(", "authNode", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "Could not find root <auth> node", "\"", ")", ";", "}", "NodeList", "pages", "=", "authNode", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "pages", ".", "getLength", "(", ")", ";", "i", "++", ")", "{", "if", "(", "\"", "page", "\"", ".", "equals", "(", "pages", ".", "item", "(", "i", ")", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "page", "=", "pages", ".", "item", "(", "i", ")", ".", "getAttributes", "(", ")", ".", "getNamedItem", "(", "\"", "id", "\"", ")", ".", "getTextContent", "(", ")", ";", "NodeList", "actions", "=", "pages", ".", "item", "(", "i", ")", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "actions", ".", "getLength", "(", ")", ";", "j", "++", ")", "{", "if", "(", "\"", "action", "\"", ".", "equals", "(", "actions", ".", "item", "(", "j", ")", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "action", "=", "actions", ".", "item", "(", "j", ")", ".", "getAttributes", "(", ")", ".", "getNamedItem", "(", "\"", "id", "\"", ")", ".", "getTextContent", "(", ")", ";", "NodeList", "entitlements", "=", "actions", ".", "item", "(", "j", ")", ".", "getChildNodes", "(", ")", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "entitlements", ".", "getLength", "(", ")", ";", "k", "++", ")", "{", "if", "(", "\"", "entitlement", "\"", ".", "equals", "(", "entitlements", ".", "item", "(", "k", ")", ".", "getNodeName", "(", ")", ")", ")", "{", "String", "entitlement", "=", "entitlements", ".", "item", "(", "k", ")", ".", "getTextContent", "(", ")", ";", "authMap", ".", "put", "(", "new", "ImmutablePair", "<", "String", ",", "String", ">", "(", "page", ",", "action", ")", ",", "entitlement", ")", ";", "}", "}", "}", "}", "}", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "error", "(", "\"", "While initializing parsing of {}", "\"", ",", "authorizations", ",", "e", ")", ";", "}", "}"], "idx": 6082, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "726231fbf7b817bd2a9467171dcb1c0087c75bc", "function_name": "init", "body_hash": "1f703c0b87d56bdcaf2008bdd11f8c84c96304fc"}
{"code": "private ChannelBuffer unwrap(\n            ChannelHandlerContext ctx, Channel channel,\n            ChannelBuffer nettyInNetBuf, ByteBuffer nioInNetBuf,\n            int initialNettyOutAppBufCapacity) throws SSLException {\n\n        final int nettyInNetBufStartOffset = nettyInNetBuf.readerIndex();\n        final int nioInNetBufStartOffset = nioInNetBuf.position();\n        final ByteBuffer nioOutAppBuf = bufferPool.acquireBuffer();\n\n        ChannelBuffer nettyOutAppBuf = null;\n\n        try {\n            boolean needsWrap = false;\n            for (;;) {\n                SSLEngineResult result;\n                boolean needsHandshake = false;\n                synchronized (handshakeLock) {\n                    if (!handshaken && !handshaking &&\n                        !engine.getUseClientMode() &&\n                        !engine.isInboundDone() && !engine.isOutboundDone()) {\n                        needsHandshake = true;\n                    }\n                }\n\n                if (needsHandshake) {\n                    handshake();\n                }\n\n                synchronized (handshakeLock) {\n                    // Decrypt at least one record in the inbound network buffer.\n                    // It is impossible to consume no record here because we made sure the inbound network buffer\n                    // always contain at least one record in decode().  Therefore, if SSLEngine.unwrap() returns\n                    // BUFFER_OVERFLOW, it is always resolved by retrying after emptying the application buffer.\n                    for (;;) {\n                        final int outAppBufSize = engine.getSession().getApplicationBufferSize();\n                        final ByteBuffer outAppBuf;\n                        if (nioOutAppBuf.capacity() < outAppBufSize) {\n                            // SSLEngine wants a buffer larger than what the pool can provide.\n                            // Allocate a temporary heap buffer.\n                            outAppBuf = ByteBuffer.allocate(outAppBufSize);\n                        } else {\n                            outAppBuf = nioOutAppBuf;\n                        }\n\n                        try {\n                            result = engine.unwrap(nioInNetBuf, outAppBuf);\n                            switch (result.getStatus()) {\n                                case CLOSED:\n                                    // notify about the CLOSED state of the SSLEngine. See #137\n                                    sslEngineCloseFuture.setClosed();\n                                    break;\n                                case BUFFER_OVERFLOW:\n                                    // Flush the unwrapped data in the outAppBuf into frame and try again.\n                                    // See the finally block.\n                                    continue;\n                            }\n\n                            break;\n                        } finally {\n                            outAppBuf.flip();\n\n                            // Sync the offset of the inbound buffer.\n                            nettyInNetBuf.readerIndex(\n                                    nettyInNetBufStartOffset + nioInNetBuf.position() - nioInNetBufStartOffset);\n\n                            // Copy the unwrapped data into a smaller buffer.\n                            if (outAppBuf.hasRemaining()) {\n                                if (nettyOutAppBuf == null) {\n                                    ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();\n                                    nettyOutAppBuf = factory.getBuffer(initialNettyOutAppBufCapacity);\n                                }\n                                nettyOutAppBuf.writeBytes(outAppBuf);\n                            }\n                            outAppBuf.clear();\n                        }\n                    }\n\n                    final HandshakeStatus handshakeStatus = result.getHandshakeStatus();\n                    handleRenegotiation(handshakeStatus);\n                    switch (handshakeStatus) {\n                    case NEED_UNWRAP:\n                        break;\n                    case NEED_WRAP:\n                        wrapNonAppData(ctx, channel);\n                        break;\n                    case NEED_TASK:\n                        runDelegatedTasks();\n                        break;\n                    case FINISHED:\n                        setHandshakeSuccess(channel);\n                        needsWrap = true;\n                        continue;\n                    case NOT_HANDSHAKING:\n                        if (setHandshakeSuccessIfStillHandshaking(channel)) {\n                            needsWrap = true;\n                            continue;\n                        }\n                        if (writeBeforeHandshakeDone) {\n                            // We need to call wrap(...) in case there was a flush done before the handshake completed.\n                            //\n                            // See https://github.com/netty/netty/pull/2437\n                            writeBeforeHandshakeDone = false;\n                            needsWrap = true;\n                        }\n                        break;\n                    default:\n                        throw new IllegalStateException(\n                                \"Unknown handshake status: \" + handshakeStatus);\n                    }\n\n                    if (result.getStatus() == Status.BUFFER_UNDERFLOW ||\n                        result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (needsWrap) {\n                // wrap() acquires pendingUnencryptedWrites first and then\n                // handshakeLock.  If handshakeLock is already hold by the\n                // current thread, calling wrap() will lead to a dead lock\n                // i.e. pendingUnencryptedWrites -> handshakeLock vs.\n                //      handshakeLock -> pendingUnencryptedLock -> handshakeLock\n                //\n                // There is also the same issue between pendingEncryptedWrites\n                // and pendingUnencryptedWrites.\n                if (!Thread.holdsLock(handshakeLock) && !pendingEncryptedWritesLock.isHeldByCurrentThread()) {\n                    wrap(ctx, channel);\n                }\n            }\n        } catch (SSLException e) {\n            setHandshakeFailure(channel, e);\n            throw e;\n        } finally {\n            bufferPool.releaseBuffer(nioOutAppBuf);\n        }\n\n        if (nettyOutAppBuf != null && nettyOutAppBuf.readable()) {\n            return nettyOutAppBuf;\n        } else {\n            return null;\n        }\n    }", "code_tokens": ["private", "ChannelBuffer", "unwrap", "(", "ChannelHandlerContext", "ctx", ",", "Channel", "channel", ",", "ChannelBuffer", "nettyInNetBuf", ",", "ByteBuffer", "nioInNetBuf", ",", "int", "initialNettyOutAppBufCapacity", ")", "throws", "SSLException", "{", "final", "int", "nettyInNetBufStartOffset", "=", "nettyInNetBuf", ".", "readerIndex", "(", ")", ";", "final", "int", "nioInNetBufStartOffset", "=", "nioInNetBuf", ".", "position", "(", ")", ";", "final", "ByteBuffer", "nioOutAppBuf", "=", "bufferPool", ".", "acquireBuffer", "(", ")", ";", "ChannelBuffer", "nettyOutAppBuf", "=", "null", ";", "try", "{", "boolean", "needsWrap", "=", "false", ";", "for", "(", ";", ";", ")", "{", "SSLEngineResult", "result", ";", "boolean", "needsHandshake", "=", "false", ";", "synchronized", "(", "handshakeLock", ")", "{", "if", "(", "!", "handshaken", "&&", "!", "handshaking", "&&", "!", "engine", ".", "getUseClientMode", "(", ")", "&&", "!", "engine", ".", "isInboundDone", "(", ")", "&&", "!", "engine", ".", "isOutboundDone", "(", ")", ")", "{", "needsHandshake", "=", "true", ";", "}", "}", "if", "(", "needsHandshake", ")", "{", "handshake", "(", ")", ";", "}", "synchronized", "(", "handshakeLock", ")", "{", "for", "(", ";", ";", ")", "{", "final", "int", "outAppBufSize", "=", "engine", ".", "getSession", "(", ")", ".", "getApplicationBufferSize", "(", ")", ";", "final", "ByteBuffer", "outAppBuf", ";", "if", "(", "nioOutAppBuf", ".", "capacity", "(", ")", "<", "outAppBufSize", ")", "{", "outAppBuf", "=", "ByteBuffer", ".", "allocate", "(", "outAppBufSize", ")", ";", "}", "else", "{", "outAppBuf", "=", "nioOutAppBuf", ";", "}", "try", "{", "result", "=", "engine", ".", "unwrap", "(", "nioInNetBuf", ",", "outAppBuf", ")", ";", "switch", "(", "result", ".", "getStatus", "(", ")", ")", "{", "case", "CLOSED", ":", "sslEngineCloseFuture", ".", "setClosed", "(", ")", ";", "break", ";", "case", "BUFFER_OVERFLOW", ":", "continue", ";", "}", "break", ";", "}", "finally", "{", "outAppBuf", ".", "flip", "(", ")", ";", "nettyInNetBuf", ".", "readerIndex", "(", "nettyInNetBufStartOffset", "+", "nioInNetBuf", ".", "position", "(", ")", "-", "nioInNetBufStartOffset", ")", ";", "if", "(", "outAppBuf", ".", "hasRemaining", "(", ")", ")", "{", "if", "(", "nettyOutAppBuf", "==", "null", ")", "{", "ChannelBufferFactory", "factory", "=", "ctx", ".", "getChannel", "(", ")", ".", "getConfig", "(", ")", ".", "getBufferFactory", "(", ")", ";", "nettyOutAppBuf", "=", "factory", ".", "getBuffer", "(", "initialNettyOutAppBufCapacity", ")", ";", "}", "nettyOutAppBuf", ".", "writeBytes", "(", "outAppBuf", ")", ";", "}", "outAppBuf", ".", "clear", "(", ")", ";", "}", "}", "final", "HandshakeStatus", "handshakeStatus", "=", "result", ".", "getHandshakeStatus", "(", ")", ";", "handleRenegotiation", "(", "handshakeStatus", ")", ";", "switch", "(", "handshakeStatus", ")", "{", "case", "NEED_UNWRAP", ":", "break", ";", "case", "NEED_WRAP", ":", "wrapNonAppData", "(", "ctx", ",", "channel", ")", ";", "break", ";", "case", "NEED_TASK", ":", "runDelegatedTasks", "(", ")", ";", "break", ";", "case", "FINISHED", ":", "setHandshakeSuccess", "(", "channel", ")", ";", "needsWrap", "=", "true", ";", "continue", ";", "case", "NOT_HANDSHAKING", ":", "if", "(", "setHandshakeSuccessIfStillHandshaking", "(", "channel", ")", ")", "{", "needsWrap", "=", "true", ";", "continue", ";", "}", "if", "(", "writeBeforeHandshakeDone", ")", "{", "writeBeforeHandshakeDone", "=", "false", ";", "needsWrap", "=", "true", ";", "}", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unknown handshake status: ", "\"", "+", "handshakeStatus", ")", ";", "}", "if", "(", "result", ".", "getStatus", "(", ")", "==", "Status", ".", "BUFFER_UNDERFLOW", "||", "result", ".", "bytesConsumed", "(", ")", "==", "0", "&&", "result", ".", "bytesProduced", "(", ")", "==", "0", ")", "{", "break", ";", "}", "}", "}", "if", "(", "needsWrap", ")", "{", "if", "(", "!", "Thread", ".", "holdsLock", "(", "handshakeLock", ")", "&&", "!", "pendingEncryptedWritesLock", ".", "isHeldByCurrentThread", "(", ")", ")", "{", "wrap", "(", "ctx", ",", "channel", ")", ";", "}", "}", "}", "catch", "(", "SSLException", "e", ")", "{", "setHandshakeFailure", "(", "channel", ",", "e", ")", ";", "throw", "e", ";", "}", "finally", "{", "bufferPool", ".", "releaseBuffer", "(", "nioOutAppBuf", ")", ";", "}", "if", "(", "nettyOutAppBuf", "!=", "null", "&&", "nettyOutAppBuf", ".", "readable", "(", ")", ")", "{", "return", "nettyOutAppBuf", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "idx": 2110, "cwe": "CWE-119", "target": 0, "status": "FIXED", "commit": "2fa9400a59d0563a66908aba55c41e7285a04994", "function_name": "unwrap", "body_hash": "cdc47d0d7d6924be190e7ea47daf2afafb0e1bb8"}
{"code": "public TimelineEventList doData(StaplerRequest req, @QueryParameter long min, @QueryParameter long max) throws IOException {\n        TimelineEventList result = new TimelineEventList();\n        for (Run r : builds.byTimestamp(min,max)) {\n            Event e = new Event();\n            e.start = new Date(r.getStartTimeInMillis());\n            e.end   = new Date(r.getStartTimeInMillis()+r.getDuration());\n            e.title = r.getFullDisplayName();\n            // what to put in the description?\n            // e.description = \"Longish description of event \"+r.getFullDisplayName();\n            // e.durationEvent = true;\n            e.link = req.getContextPath()+'/'+r.getUrl();\n            BallColor c = r.getIconColor();\n            e.color = String.format(\"#%06X\",c.getBaseColor().darker().getRGB()&0xFFFFFF);\n            e.classname = \"event-\"+c.noAnime().toString()+\" \" + (c.isAnimated()?\"animated\":\"\");\n            result.add(e);\n        }\n        return result;\n    }", "code_tokens": ["public", "TimelineEventList", "doData", "(", "StaplerRequest", "req", ",", "@", "QueryParameter", "long", "min", ",", "@", "QueryParameter", "long", "max", ")", "throws", "IOException", "{", "TimelineEventList", "result", "=", "new", "TimelineEventList", "(", ")", ";", "for", "(", "Run", "r", ":", "builds", ".", "byTimestamp", "(", "min", ",", "max", ")", ")", "{", "Event", "e", "=", "new", "Event", "(", ")", ";", "e", ".", "start", "=", "new", "Date", "(", "r", ".", "getStartTimeInMillis", "(", ")", ")", ";", "e", ".", "end", "=", "new", "Date", "(", "r", ".", "getStartTimeInMillis", "(", ")", "+", "r", ".", "getDuration", "(", ")", ")", ";", "e", ".", "title", "=", "r", ".", "getFullDisplayName", "(", ")", ";", "e", ".", "link", "=", "req", ".", "getContextPath", "(", ")", "+", "'/'", "+", "r", ".", "getUrl", "(", ")", ";", "BallColor", "c", "=", "r", ".", "getIconColor", "(", ")", ";", "e", ".", "color", "=", "String", ".", "format", "(", "\"", "#%06X", "\"", ",", "c", ".", "getBaseColor", "(", ")", ".", "darker", "(", ")", ".", "getRGB", "(", ")", "&", "0xFFFFFF", ")", ";", "e", ".", "classname", "=", "\"", "event-", "\"", "+", "c", ".", "noAnime", "(", ")", ".", "toString", "(", ")", "+", "\"", " ", "\"", "+", "(", "c", ".", "isAnimated", "(", ")", "?", "\"", "animated", "\"", ":", "\"", "\"", ")", ";", "result", ".", "add", "(", "e", ")", ";", "}", "return", "result", ";", "}"], "idx": 77816, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "8697bdff0342421e22230028d84aaa265719e86c", "function_name": "doData", "body_hash": "c1fbe2c7854a07b3bc0cbdb74dbfe13060aa6c30"}
{"code": "@Override\n    public Object unmarshal(final Exchange exchange, final InputStream inputStream) throws Exception {\n        final Hessian2Input in;\n        if (!whitelistEnabled) {\n            in = new Hessian2Input(inputStream);\n        } else {\n            HessianFactory factory = new HessianFactory();\n            if (ObjectHelper.isNotEmpty(allowedUnmarshallObjects)) {\n                factory.allow(allowedUnmarshallObjects);\n            }\n            if (ObjectHelper.isNotEmpty(deniedUnmarshallObjects)) {\n                factory.deny(deniedUnmarshallObjects);\n            }\n            in = factory.createHessian2Input(inputStream);\n        }\n        try {\n            in.startMessage();\n            final Object obj = in.readObject();\n            in.completeMessage();\n            return obj;\n        } finally {\n            try {\n                in.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }", "code_tokens": ["@", "Override", "public", "Object", "unmarshal", "(", "final", "Exchange", "exchange", ",", "final", "InputStream", "inputStream", ")", "throws", "Exception", "{", "final", "Hessian2Input", "in", ";", "if", "(", "!", "whitelistEnabled", ")", "{", "in", "=", "new", "Hessian2Input", "(", "inputStream", ")", ";", "}", "else", "{", "HessianFactory", "factory", "=", "new", "HessianFactory", "(", ")", ";", "if", "(", "ObjectHelper", ".", "isNotEmpty", "(", "allowedUnmarshallObjects", ")", ")", "{", "factory", ".", "allow", "(", "allowedUnmarshallObjects", ")", ";", "}", "if", "(", "ObjectHelper", ".", "isNotEmpty", "(", "deniedUnmarshallObjects", ")", ")", "{", "factory", ".", "deny", "(", "deniedUnmarshallObjects", ")", ";", "}", "in", "=", "factory", ".", "createHessian2Input", "(", "inputStream", ")", ";", "}", "try", "{", "in", ".", "startMessage", "(", ")", ";", "final", "Object", "obj", "=", "in", ".", "readObject", "(", ")", ";", "in", ".", "completeMessage", "(", ")", ";", "return", "obj", ";", "}", "finally", "{", "try", "{", "in", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "}", "}"], "idx": 57653, "cwe": "CWE-502", "target": 0, "status": "FIXED", "commit": "260eed35dd5", "function_name": "unmarshal", "body_hash": "f96f9f97fd15962bc2687df3d72c39568936ad2d"}
{"code": "public static String detectDataDirectory() {\n\n        String dataPath = System.getProperty(JBOSS_SERVER_DATA_DIR);\n\n        if (dataPath != null){\n            // we assume jboss.server.data.dir is managed externally so just use it as is.\n            File dataDir = new File(dataPath);\n            if (!dataDir.exists() || !dataDir.isDirectory()) {\n                throw new RuntimeException(\"Invalid \" + JBOSS_SERVER_DATA_DIR + \" resources directory: \" + dataPath);\n            }\n\n            return dataPath;\n        }\n\n        // we generate a dynamic jboss.server.data.dir and remove it at the end.\n        try {\n          File tempKeycloakFolder = Files.createTempDirectory(\"keycloak-server-\").toFile();\n          File tmpDataDir = new File(tempKeycloakFolder, \"/data\");\n\n          if (tmpDataDir.mkdirs()) {\n            tmpDataDir.deleteOnExit();\n          } else {\n            throw new IOException(\"Could not create directory \" + tmpDataDir);\n          }\n\n          dataPath = tmpDataDir.getAbsolutePath();\n        } catch (IOException ioe){\n          throw new RuntimeException(\"Could not create temporary \" + JBOSS_SERVER_DATA_DIR, ioe);\n        }\n\n        return dataPath;\n    }", "code_tokens": ["public", "static", "String", "detectDataDirectory", "(", ")", "{", "String", "dataPath", "=", "System", ".", "getProperty", "(", "JBOSS_SERVER_DATA_DIR", ")", ";", "if", "(", "dataPath", "!=", "null", ")", "{", "File", "dataDir", "=", "new", "File", "(", "dataPath", ")", ";", "if", "(", "!", "dataDir", ".", "exists", "(", ")", "||", "!", "dataDir", ".", "isDirectory", "(", ")", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Invalid ", "\"", "+", "JBOSS_SERVER_DATA_DIR", "+", "\"", " resources directory: ", "\"", "+", "dataPath", ")", ";", "}", "return", "dataPath", ";", "}", "try", "{", "File", "tempKeycloakFolder", "=", "Files", ".", "createTempDirectory", "(", "\"", "keycloak-server-", "\"", ")", ".", "toFile", "(", ")", ";", "File", "tmpDataDir", "=", "new", "File", "(", "tempKeycloakFolder", ",", "\"", "/data", "\"", ")", ";", "if", "(", "tmpDataDir", ".", "mkdirs", "(", ")", ")", "{", "tmpDataDir", ".", "deleteOnExit", "(", ")", ";", "}", "else", "{", "throw", "new", "IOException", "(", "\"", "Could not create directory ", "\"", "+", "tmpDataDir", ")", ";", "}", "dataPath", "=", "tmpDataDir", ".", "getAbsolutePath", "(", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Could not create temporary ", "\"", "+", "JBOSS_SERVER_DATA_DIR", ",", "ioe", ")", ";", "}", "return", "dataPath", ";", "}"], "idx": 49484, "cwe": "CWE-377", "target": 1, "status": "VULNERABLE", "commit": "853a6d73276849877819f2dc23133557f6e1e601", "function_name": "detectDataDirectory", "body_hash": "b7a1dd4330bd7d43023f6429803a5e6aeb71c7a1"}
{"code": "public boolean matches(final byte[] message, final byte[] digest) {\n\n        if (message == null) {\n            return (digest == null);\n        } else if (digest == null) {\n            return false;\n        }\n        \n        // Check initialization\n        if (!isInitialized()) {\n            initialize();\n        }\n            \n        try {\n\n            // If we are using a salt, extract it to use it.\n            byte[] salt = null;\n            if (this.useSalt) {\n                // If we are using a salt generator which specifies the salt\n                // to be included into the digest itself, get it from there.\n                // If not, the salt is supposed to be fixed and thus the\n                // salt generator can be safely asked for it again.\n                if (this.saltGenerator.includePlainSaltInEncryptionResults()) {\n                    \n                    // Compute size figures and perform length checks\n                    int digestSaltSize = this.saltSizeBytes;\n                    if (this.digestLengthBytes > 0) {\n                        if (this.useLenientSaltSizeCheck) {\n                            if (digest.length < this.digestLengthBytes) {\n                                throw new EncryptionOperationNotPossibleException();\n                            }\n                            digestSaltSize = digest.length - this.digestLengthBytes;\n                        } else {\n                            if (digest.length != (this.digestLengthBytes + this.saltSizeBytes)) {\n                                throw new EncryptionOperationNotPossibleException();\n                            }\n                        }\n                    } else {\n                        // Salt size check behaviour cannot be set to lenient\n                        if (digest.length < this.saltSizeBytes) {\n                            throw new EncryptionOperationNotPossibleException();\n                        }\n                    }\n                    \n                    if (!this.invertPositionOfPlainSaltInEncryptionResults) {\n                        salt = new byte[digestSaltSize];\n                        System.arraycopy(digest, 0, salt, 0, digestSaltSize);\n                    } else {\n                        salt = new byte[digestSaltSize];\n                        System.arraycopy(digest, digest.length - digestSaltSize, salt, 0, digestSaltSize);\n                    }\n                    \n                } else {\n                    salt = this.saltGenerator.generateSalt(this.saltSizeBytes);\n                }\n            }\n            \n            // Digest the message with the extracted digest.\n            final byte[] encryptedMessage = digest(message, salt);\n            \n            // If, using the same salt, digests match, then messages too. \n            return (digestsAreEqual(encryptedMessage, digest));\n        \n        } catch (Exception e) {\n            // If digest fails, it is more secure not to return any information\n            // about the cause in nested exceptions. Simply fail.\n            throw new EncryptionOperationNotPossibleException();\n        }\n        \n    }", "code_tokens": ["public", "boolean", "matches", "(", "final", "byte", "[", "]", "message", ",", "final", "byte", "[", "]", "digest", ")", "{", "if", "(", "message", "==", "null", ")", "{", "return", "(", "digest", "==", "null", ")", ";", "}", "else", "if", "(", "digest", "==", "null", ")", "{", "return", "false", ";", "}", "if", "(", "!", "isInitialized", "(", ")", ")", "{", "initialize", "(", ")", ";", "}", "try", "{", "byte", "[", "]", "salt", "=", "null", ";", "if", "(", "this", ".", "useSalt", ")", "{", "if", "(", "this", ".", "saltGenerator", ".", "includePlainSaltInEncryptionResults", "(", ")", ")", "{", "int", "digestSaltSize", "=", "this", ".", "saltSizeBytes", ";", "if", "(", "this", ".", "digestLengthBytes", ">", "0", ")", "{", "if", "(", "this", ".", "useLenientSaltSizeCheck", ")", "{", "if", "(", "digest", ".", "length", "<", "this", ".", "digestLengthBytes", ")", "{", "throw", "new", "EncryptionOperationNotPossibleException", "(", ")", ";", "}", "digestSaltSize", "=", "digest", ".", "length", "-", "this", ".", "digestLengthBytes", ";", "}", "else", "{", "if", "(", "digest", ".", "length", "!=", "(", "this", ".", "digestLengthBytes", "+", "this", ".", "saltSizeBytes", ")", ")", "{", "throw", "new", "EncryptionOperationNotPossibleException", "(", ")", ";", "}", "}", "}", "else", "{", "if", "(", "digest", ".", "length", "<", "this", ".", "saltSizeBytes", ")", "{", "throw", "new", "EncryptionOperationNotPossibleException", "(", ")", ";", "}", "}", "if", "(", "!", "this", ".", "invertPositionOfPlainSaltInEncryptionResults", ")", "{", "salt", "=", "new", "byte", "[", "digestSaltSize", "]", ";", "System", ".", "arraycopy", "(", "digest", ",", "0", ",", "salt", ",", "0", ",", "digestSaltSize", ")", ";", "}", "else", "{", "salt", "=", "new", "byte", "[", "digestSaltSize", "]", ";", "System", ".", "arraycopy", "(", "digest", ",", "digest", ".", "length", "-", "digestSaltSize", ",", "salt", ",", "0", ",", "digestSaltSize", ")", ";", "}", "}", "else", "{", "salt", "=", "this", ".", "saltGenerator", ".", "generateSalt", "(", "this", ".", "saltSizeBytes", ")", ";", "}", "}", "final", "byte", "[", "]", "encryptedMessage", "=", "digest", "(", "message", ",", "salt", ")", ";", "return", "(", "digestsAreEqual", "(", "encryptedMessage", ",", "digest", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "EncryptionOperationNotPossibleException", "(", ")", ";", "}", "}"], "idx": 19226, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "8e62852a8018978ee19d39056c650fb66ffa0ff6", "function_name": "matches", "body_hash": "2d2ded9110ec871b462401b3824acbb1336f8d5a"}
{"code": "private void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\tthrows ServletException, IOException {\n\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\t\tString[] resourceUrls =\n\t\t\tStringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (int i = 0; i < resourceUrls.length; i++) {\n\t\t\t// check whether URL matches allowed resources\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, resourceUrls[i])) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + resourceUrls[i] +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + resourceUrls[i] + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(resourceUrls[i]);\n\t\t\trd.include(request, response);\n\t\t}\n\t}", "code_tokens": ["private", "void", "doInclude", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "String", "resourceUrl", ")", "throws", "ServletException", ",", "IOException", "{", "if", "(", "this", ".", "contentType", "!=", "null", ")", "{", "response", ".", "setContentType", "(", "this", ".", "contentType", ")", ";", "}", "String", "[", "]", "resourceUrls", "=", "StringUtils", ".", "tokenizeToStringArray", "(", "resourceUrl", ",", "RESOURCE_URL_DELIMITERS", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "resourceUrls", ".", "length", ";", "i", "++", ")", "{", "if", "(", "this", ".", "allowedResources", "!=", "null", "&&", "!", "this", ".", "pathMatcher", ".", "match", "(", "this", ".", "allowedResources", ",", "resourceUrls", "[", "i", "]", ")", ")", "{", "throw", "new", "ServletException", "(", "\"", "Resource [", "\"", "+", "resourceUrls", "[", "i", "]", "+", "\"", "] does not match allowed pattern [", "\"", "+", "this", ".", "allowedResources", "+", "\"", "]", "\"", ")", ";", "}", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Including resource [", "\"", "+", "resourceUrls", "[", "i", "]", "+", "\"", "]", "\"", ")", ";", "}", "RequestDispatcher", "rd", "=", "request", ".", "getRequestDispatcher", "(", "resourceUrls", "[", "i", "]", ")", ";", "rd", ".", "include", "(", "request", ",", "response", ")", ";", "}", "}"], "idx": 26921, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "a7dc48534ea501525f11369d369178a60c2f47d0", "function_name": "doInclude", "body_hash": "752cf1be58eccc0f50303e9eb0ed62438c91ca7a"}
{"code": "public static Path getPersistedConfigFile() {\n        String homeDir = Environment.getHomeDir();\n\n        if (homeDir == null) {\n            return Paths.get(System.getProperty(\"java.io.tmpdir\"), PersistedConfigSource.KEYCLOAK_PROPERTIES);\n        }\n\n        return Paths.get(homeDir, \"conf\", PersistedConfigSource.KEYCLOAK_PROPERTIES);\n    }", "code_tokens": ["public", "static", "Path", "getPersistedConfigFile", "(", ")", "{", "String", "homeDir", "=", "Environment", ".", "getHomeDir", "(", ")", ";", "if", "(", "homeDir", "==", "null", ")", "{", "return", "Paths", ".", "get", "(", "System", ".", "getProperty", "(", "\"", "java.io.tmpdir", "\"", ")", ",", "PersistedConfigSource", ".", "KEYCLOAK_PROPERTIES", ")", ";", "}", "return", "Paths", ".", "get", "(", "homeDir", ",", "\"", "conf", "\"", ",", "PersistedConfigSource", ".", "KEYCLOAK_PROPERTIES", ")", ";", "}"], "idx": 49451, "cwe": "CWE-377", "target": 1, "status": "VULNERABLE", "commit": "853a6d73276849877819f2dc23133557f6e1e601", "function_name": "getPersistedConfigFile", "body_hash": "01957fe7b87a0f376eb94260a3ee0b017d6c5580"}
{"code": "private void initialize() throws TransformerFactoryConfigurationError, TransformerConfigurationException,\n            ParserConfigurationException {\n        if (!xslIsInitialized) {\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            nunitTransformer = transformerFactory.newTransformer(new StreamSource(this.getClass().getResourceAsStream(NUNIT_TO_JUNIT_XSLFILE_STR)));\n            writerTransformer = transformerFactory.newTransformer();\n    \n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            xmlDocumentBuilder = factory.newDocumentBuilder();\n            \n            xslIsInitialized = true;\n        }\n    }", "code_tokens": ["private", "void", "initialize", "(", ")", "throws", "TransformerFactoryConfigurationError", ",", "TransformerConfigurationException", ",", "ParserConfigurationException", "{", "if", "(", "!", "xslIsInitialized", ")", "{", "TransformerFactory", "transformerFactory", "=", "TransformerFactory", ".", "newInstance", "(", ")", ";", "nunitTransformer", "=", "transformerFactory", ".", "newTransformer", "(", "new", "StreamSource", "(", "this", ".", "getClass", "(", ")", ".", "getResourceAsStream", "(", "NUNIT_TO_JUNIT_XSLFILE_STR", ")", ")", ")", ";", "writerTransformer", "=", "transformerFactory", ".", "newTransformer", "(", ")", ";", "DocumentBuilderFactory", "factory", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "xmlDocumentBuilder", "=", "factory", ".", "newDocumentBuilder", "(", ")", ";", "xslIsInitialized", "=", "true", ";", "}", "}"], "idx": 69781, "cwe": "CWE-611", "target": 1, "status": "VULNERABLE", "commit": "8f0b6a7", "function_name": "initialize", "body_hash": "afb1e1fe1eaa07fdd95c38c41c1feef09328d267"}
{"code": "public static String resolvePath(String uri) {\n\t\tString path = URI.create(uri).getPath();\n\t\tif (!path.isEmpty()) {\n\t\t\tif(path.charAt(0) == '/'){\n\t\t\t\tpath = path.substring(1);\n\t\t\t\tif(path.length() <= 1){\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(path.charAt(path.length() - 1) == '/'){\n\t\t\t\treturn path.substring(0, path.length() - 1);\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}", "code_tokens": ["public", "static", "String", "resolvePath", "(", "String", "uri", ")", "{", "String", "path", "=", "URI", ".", "create", "(", "uri", ")", ".", "getPath", "(", ")", ";", "if", "(", "!", "path", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "path", ".", "charAt", "(", "0", ")", "==", "'/'", ")", "{", "path", "=", "path", ".", "substring", "(", "1", ")", ";", "if", "(", "path", ".", "length", "(", ")", "<=", "1", ")", "{", "return", "path", ";", "}", "}", "if", "(", "path", ".", "charAt", "(", "path", ".", "length", "(", ")", "-", "1", ")", "==", "'/'", ")", "{", "return", "path", ".", "substring", "(", "0", ",", "path", ".", "length", "(", ")", "-", "1", ")", ";", "}", "}", "return", "path", ";", "}"], "idx": 74839, "cwe": "CWE-755", "target": 1, "status": "VULNERABLE", "commit": "7426c0c", "function_name": "resolvePath", "body_hash": "0f8ae7a7ec6c8e0cdf9bad96013a43192cc46f75"}
{"code": "private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && Character.isWhitespace(ch))) {\n                break;\n            }\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }", "code_tokens": ["private", "void", "splitHeader", "(", "AppendableCharSequence", "sb", ")", "{", "final", "int", "length", "=", "sb", ".", "length", "(", ")", ";", "int", "nameStart", ";", "int", "nameEnd", ";", "int", "colonEnd", ";", "int", "valueStart", ";", "int", "valueEnd", ";", "nameStart", "=", "findNonWhitespace", "(", "sb", ",", "0", ")", ";", "for", "(", "nameEnd", "=", "nameStart", ";", "nameEnd", "<", "length", ";", "nameEnd", "++", ")", "{", "char", "ch", "=", "sb", ".", "charAtUnsafe", "(", "nameEnd", ")", ";", "if", "(", "ch", "==", "':'", "||", "(", "!", "isDecodingRequest", "(", ")", "&&", "Character", ".", "isWhitespace", "(", "ch", ")", ")", ")", "{", "break", ";", "}", "}", "for", "(", "colonEnd", "=", "nameEnd", ";", "colonEnd", "<", "length", ";", "colonEnd", "++", ")", "{", "if", "(", "sb", ".", "charAtUnsafe", "(", "colonEnd", ")", "==", "':'", ")", "{", "colonEnd", "++", ";", "break", ";", "}", "}", "name", "=", "sb", ".", "subStringUnsafe", "(", "nameStart", ",", "nameEnd", ")", ";", "valueStart", "=", "findNonWhitespace", "(", "sb", ",", "colonEnd", ")", ";", "if", "(", "valueStart", "==", "length", ")", "{", "value", "=", "EMPTY_VALUE", ";", "}", "else", "{", "valueEnd", "=", "findEndOfString", "(", "sb", ")", ";", "value", "=", "sb", ".", "subStringUnsafe", "(", "valueStart", ",", "valueEnd", ")", ";", "}", "}"], "idx": 54060, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "a7c18d44b46e02dadfe3da225a06e5091f5f328e", "function_name": "splitHeader", "body_hash": "60cb1a87b2ddc93abce9b774c96c87585915497f"}
{"code": "public void performTest()\n        throws Exception\n    {\n        byte[]  testIv = { 1, 2, 3, 4, 5, 6, 7, 8 };\n        \n        ASN1Encodable[]     values = {\n            new CAST5CBCParameters(testIv, 128), \n            new NetscapeCertType(NetscapeCertType.smime),    \n            new VerisignCzagExtension(new DERIA5String(\"hello\")),\n            new IDEACBCPar(testIv),        \n            new NetscapeRevocationURL(new DERIA5String(\"http://test\"))\n        };\n        \n        byte[] data = Base64.decode(\"MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA==\");\n\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ASN1OutputStream aOut = new ASN1OutputStream(bOut);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            aOut.writeObject(values[i]);\n        }\n\n        ASN1Primitive[] readValues = new ASN1Primitive[values.length];\n\n        if (!isSameAs(bOut.toByteArray(), data))\n        {\n            fail(\"Failed data check\");\n        }\n\n        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());\n        ASN1InputStream aIn = new ASN1InputStream(bIn);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            ASN1Primitive o = aIn.readObject();\n            if (!values[i].equals(o))\n            {\n                fail(\"Failed equality test for \" + o);\n            }\n\n            if (o.hashCode() != values[i].hashCode())\n            {\n                fail(\"Failed hashCode test for \" + o);\n            }\n        }\n\n        shouldFailOnExtraData();\n        derIntegerTest();\n    }", "code_tokens": ["public", "void", "performTest", "(", ")", "throws", "Exception", "{", "byte", "[", "]", "testIv", "=", "{", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "}", ";", "ASN1Encodable", "[", "]", "values", "=", "{", "new", "CAST5CBCParameters", "(", "testIv", ",", "128", ")", ",", "new", "NetscapeCertType", "(", "NetscapeCertType", ".", "smime", ")", ",", "new", "VerisignCzagExtension", "(", "new", "DERIA5String", "(", "\"", "hello", "\"", ")", ")", ",", "new", "IDEACBCPar", "(", "testIv", ")", ",", "new", "NetscapeRevocationURL", "(", "new", "DERIA5String", "(", "\"", "http://test", "\"", ")", ")", "}", ";", "byte", "[", "]", "data", "=", "Base64", ".", "decode", "(", "\"", "MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA==", "\"", ")", ";", "ByteArrayOutputStream", "bOut", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "ASN1OutputStream", "aOut", "=", "new", "ASN1OutputStream", "(", "bOut", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "values", ".", "length", ";", "i", "++", ")", "{", "aOut", ".", "writeObject", "(", "values", "[", "i", "]", ")", ";", "}", "ASN1Primitive", "[", "]", "readValues", "=", "new", "ASN1Primitive", "[", "values", ".", "length", "]", ";", "if", "(", "!", "isSameAs", "(", "bOut", ".", "toByteArray", "(", ")", ",", "data", ")", ")", "{", "fail", "(", "\"", "Failed data check", "\"", ")", ";", "}", "ByteArrayInputStream", "bIn", "=", "new", "ByteArrayInputStream", "(", "bOut", ".", "toByteArray", "(", ")", ")", ";", "ASN1InputStream", "aIn", "=", "new", "ASN1InputStream", "(", "bIn", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "values", ".", "length", ";", "i", "++", ")", "{", "ASN1Primitive", "o", "=", "aIn", ".", "readObject", "(", ")", ";", "if", "(", "!", "values", "[", "i", "]", ".", "equals", "(", "o", ")", ")", "{", "fail", "(", "\"", "Failed equality test for ", "\"", "+", "o", ")", ";", "}", "if", "(", "o", ".", "hashCode", "(", ")", "!=", "values", "[", "i", "]", ".", "hashCode", "(", ")", ")", "{", "fail", "(", "\"", "Failed hashCode test for ", "\"", "+", "o", ")", ";", "}", "}", "shouldFailOnExtraData", "(", ")", ";", "derIntegerTest", "(", ")", ";", "}"], "idx": 43474, "cwe": "CWE-347", "target": 0, "status": "FIXED", "commit": "843c2e60f67d71faf81d236f448ebbe56c62c647", "function_name": "performTest", "body_hash": "9324f163230e1f33fec6d4fadb00fe2d0cef57f0"}
{"code": "@Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\n        return viewableItems;\n    }", "code_tokens": ["@", "Exported", "(", "name", "=", "\"", "jobs", "\"", ")", "public", "List", "<", "TopLevelItem", ">", "getItems", "(", ")", "{", "List", "<", "TopLevelItem", ">", "viewableItems", "=", "new", "ArrayList", "<", "TopLevelItem", ">", "(", ")", ";", "for", "(", "TopLevelItem", "item", ":", "items", ".", "values", "(", ")", ")", "{", "if", "(", "item", ".", "hasPermission", "(", "Item", ".", "READ", ")", ")", "viewableItems", ".", "add", "(", "item", ")", ";", "}", "return", "viewableItems", ";", "}"], "idx": 12694, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "09cfbc9cd5c9df7c763bc976b7f5c51266b63719", "function_name": "getItems", "body_hash": "58fd43da4b108a53890d2cefe295222a96bc288e"}
{"code": "@Before\n    public void setUp() throws Exception {\n        if (originalDatabaseExternalMembers==null) {\n            originalDefaultExternalMembers = (List<String>) getWebApplicationContext().getBean(\"defaultExternalMembers\");\n            originalDatabaseExternalMembers = getWebApplicationContext().getBean(JdbcScimGroupExternalMembershipManager.class).query(\"\");\n        }\n\n        if(bootstrap == null){\n            bootstrap = getWebApplicationContext().getBean(ScimExternalGroupBootstrap.class);\n        }\n\n        if(template == null) {\n            template = getWebApplicationContext().getBean(JdbcTemplate.class);\n        }\n\n        template.update(\"delete from external_group_mapping\");\n        bootstrap.afterPropertiesSet();\n\n        String adminToken = testClient.getClientCredentialsOAuthAccessToken(\"admin\", \"adminsecret\",\n                \"clients.read clients.write clients.secret clients.admin\");\n        clientId = generator.generate().toLowerCase();\n        clientSecret = generator.generate().toLowerCase();\n        String authorities = \"scim.read,scim.write,password.write,oauth.approvals,scim.create,other.scope\";\n        utils().createClient(this.getMockMvc(), adminToken, clientId, clientSecret, Collections.singleton(\"oauth\"), Arrays.asList(\"foo\",\"bar\",\"scim.read\"), Arrays.asList(\"client_credentials\", \"password\"), authorities);\n        scimReadToken = testClient.getClientCredentialsOAuthAccessToken(clientId, clientSecret,\"scim.read password.write\");\n        scimWriteToken = testClient.getClientCredentialsOAuthAccessToken(clientId, clientSecret,\"scim.write password.write\");\n\n        defaultExternalMembers = new LinkedList<>(originalDefaultExternalMembers);\n        databaseExternalMembers = new LinkedList<>(originalDatabaseExternalMembers);\n\n        scimUser = createUserAndAddToGroups(IdentityZone.getUaa(), new HashSet(Arrays.asList(\"scim.read\", \"scim.write\", \"scim.me\")));\n        scimReadUserToken = testClient.getUserOAuthAccessToken(\"cf\",\"\", scimUser.getUserName(), \"password\", \"scim.read\");\n        identityClientToken = testClient.getClientCredentialsOAuthAccessToken(\"identity\",\"identitysecret\",\"\");\n    }", "code_tokens": ["@", "Before", "public", "void", "setUp", "(", ")", "throws", "Exception", "{", "if", "(", "originalDatabaseExternalMembers", "==", "null", ")", "{", "originalDefaultExternalMembers", "=", "(", "List", "<", "String", ">", ")", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "\"", "defaultExternalMembers", "\"", ")", ";", "originalDatabaseExternalMembers", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "JdbcScimGroupExternalMembershipManager", ".", "class", ")", ".", "query", "(", "\"", "\"", ")", ";", "}", "if", "(", "bootstrap", "==", "null", ")", "{", "bootstrap", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "ScimExternalGroupBootstrap", ".", "class", ")", ";", "}", "if", "(", "template", "==", "null", ")", "{", "template", "=", "getWebApplicationContext", "(", ")", ".", "getBean", "(", "JdbcTemplate", ".", "class", ")", ";", "}", "template", ".", "update", "(", "\"", "delete from external_group_mapping", "\"", ")", ";", "bootstrap", ".", "afterPropertiesSet", "(", ")", ";", "String", "adminToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "\"", "admin", "\"", ",", "\"", "adminsecret", "\"", ",", "\"", "clients.read clients.write clients.secret clients.admin", "\"", ")", ";", "clientId", "=", "generator", ".", "generate", "(", ")", ".", "toLowerCase", "(", ")", ";", "clientSecret", "=", "generator", ".", "generate", "(", ")", ".", "toLowerCase", "(", ")", ";", "String", "authorities", "=", "\"", "scim.read,scim.write,password.write,oauth.approvals,scim.create,other.scope", "\"", ";", "utils", "(", ")", ".", "createClient", "(", "this", ".", "getMockMvc", "(", ")", ",", "adminToken", ",", "clientId", ",", "clientSecret", ",", "Collections", ".", "singleton", "(", "\"", "oauth", "\"", ")", ",", "Arrays", ".", "asList", "(", "\"", "foo", "\"", ",", "\"", "bar", "\"", ",", "\"", "scim.read", "\"", ")", ",", "Arrays", ".", "asList", "(", "\"", "client_credentials", "\"", ",", "\"", "password", "\"", ")", ",", "authorities", ")", ";", "scimReadToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "clientId", ",", "clientSecret", ",", "\"", "scim.read password.write", "\"", ")", ";", "scimWriteToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "clientId", ",", "clientSecret", ",", "\"", "scim.write password.write", "\"", ")", ";", "defaultExternalMembers", "=", "new", "LinkedList", "<", ">", "(", "originalDefaultExternalMembers", ")", ";", "databaseExternalMembers", "=", "new", "LinkedList", "<", ">", "(", "originalDatabaseExternalMembers", ")", ";", "scimUser", "=", "createUserAndAddToGroups", "(", "IdentityZone", ".", "getUaa", "(", ")", ",", "new", "HashSet", "(", "Arrays", ".", "asList", "(", "\"", "scim.read", "\"", ",", "\"", "scim.write", "\"", ",", "\"", "scim.me", "\"", ")", ")", ")", ";", "scimReadUserToken", "=", "testClient", ".", "getUserOAuthAccessToken", "(", "\"", "cf", "\"", ",", "\"", "\"", ",", "scimUser", ".", "getUserName", "(", ")", ",", "\"", "password", "\"", ",", "\"", "scim.read", "\"", ")", ";", "identityClientToken", "=", "testClient", ".", "getClientCredentialsOAuthAccessToken", "(", "\"", "identity", "\"", ",", "\"", "identitysecret", "\"", ",", "\"", "\"", ")", ";", "}"], "idx": 36083, "cwe": "CWE-269", "target": 0, "status": "FIXED", "commit": "9d44cb0c7c25ccae95bfa1c2d59ce46200c643cb", "function_name": "setUp", "body_hash": "4d32f42bb40d37d4019d286f4cd0fa3b13319007"}
{"code": "private void mapAndDelegateIncomingCommand(final String tenantId, final String originalDeviceId,\n            final CommandContext originalCommandContext) {\n        // note that the command might be invalid here - a matching local handler to reject it (and report metrics) shall be found in that case\n        final Command originalCommand = originalCommandContext.getCommand();\n\n        LOG.trace(\"determine command target gateway/adapter for [{}]\", originalCommand);\n        final Future<JsonObject> commandTargetFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId,\n                originalDeviceId, originalCommandContext.getTracingContext());\n\n        commandTargetFuture.onComplete(commandTargetResult -> {\n            if (commandTargetResult.succeeded()) {\n                final String targetDeviceId = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n                final String targetAdapterInstance = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n\n                delegateIncomingCommand(tenantId, originalDeviceId, originalCommandContext, targetDeviceId, targetAdapterInstance);\n\n            } else {\n                if (commandTargetResult.cause() instanceof ServiceInvocationException\n                        && ((ServiceInvocationException) commandTargetResult.cause()).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n                    LOG.debug(\"no target adapter instance found for command for device {}\", originalDeviceId);\n                    TracingHelper.logError(originalCommandContext.getTracingSpan(),\n                            \"no target adapter instance found for command with device id \" + originalDeviceId);\n                } else {\n                    LOG.debug(\"error getting target gateway and adapter instance for command with device id {}\",\n                            originalDeviceId, commandTargetResult.cause());\n                    TracingHelper.logError(originalCommandContext.getTracingSpan(),\n                            \"error getting target gateway and adapter instance for command with device id \" + originalDeviceId,\n                            commandTargetResult.cause());\n                }\n                originalCommandContext.release();\n            }\n        });\n    }", "code_tokens": ["private", "void", "mapAndDelegateIncomingCommand", "(", "final", "String", "tenantId", ",", "final", "String", "originalDeviceId", ",", "final", "CommandContext", "originalCommandContext", ")", "{", "final", "Command", "originalCommand", "=", "originalCommandContext", ".", "getCommand", "(", ")", ";", "LOG", ".", "trace", "(", "\"", "determine command target gateway/adapter for [{}]", "\"", ",", "originalCommand", ")", ";", "final", "Future", "<", "JsonObject", ">", "commandTargetFuture", "=", "commandTargetMapper", ".", "getTargetGatewayAndAdapterInstance", "(", "tenantId", ",", "originalDeviceId", ",", "originalCommandContext", ".", "getTracingContext", "(", ")", ")", ";", "commandTargetFuture", ".", "onComplete", "(", "commandTargetResult", "->", "{", "if", "(", "commandTargetResult", ".", "succeeded", "(", ")", ")", "{", "final", "String", "targetDeviceId", "=", "commandTargetResult", ".", "result", "(", ")", ".", "getString", "(", "DeviceConnectionConstants", ".", "FIELD_PAYLOAD_DEVICE_ID", ")", ";", "final", "String", "targetAdapterInstance", "=", "commandTargetResult", ".", "result", "(", ")", ".", "getString", "(", "DeviceConnectionConstants", ".", "FIELD_ADAPTER_INSTANCE_ID", ")", ";", "delegateIncomingCommand", "(", "tenantId", ",", "originalDeviceId", ",", "originalCommandContext", ",", "targetDeviceId", ",", "targetAdapterInstance", ")", ";", "}", "else", "{", "if", "(", "commandTargetResult", ".", "cause", "(", ")", "instanceof", "ServiceInvocationException", "&&", "(", "(", "ServiceInvocationException", ")", "commandTargetResult", ".", "cause", "(", ")", ")", ".", "getErrorCode", "(", ")", "==", "HttpURLConnection", ".", "HTTP_NOT_FOUND", ")", "{", "LOG", ".", "debug", "(", "\"", "no target adapter instance found for command for device {}", "\"", ",", "originalDeviceId", ")", ";", "TracingHelper", ".", "logError", "(", "originalCommandContext", ".", "getTracingSpan", "(", ")", ",", "\"", "no target adapter instance found for command with device id ", "\"", "+", "originalDeviceId", ")", ";", "}", "else", "{", "LOG", ".", "debug", "(", "\"", "error getting target gateway and adapter instance for command with device id {}", "\"", ",", "originalDeviceId", ",", "commandTargetResult", ".", "cause", "(", ")", ")", ";", "TracingHelper", ".", "logError", "(", "originalCommandContext", ".", "getTracingSpan", "(", ")", ",", "\"", "error getting target gateway and adapter instance for command with device id ", "\"", "+", "originalDeviceId", ",", "commandTargetResult", ".", "cause", "(", ")", ")", ";", "}", "originalCommandContext", ".", "release", "(", ")", ";", "}", "}", ")", ";", "}"], "idx": 83908, "cwe": "CWE-862", "target": 0, "status": "FIXED", "commit": "0d2ab63347c52c8d4d9e3a2db2c86aba506115e2", "function_name": "mapAndDelegateIncomingCommand", "body_hash": "e85f94b11279a03c33c7ac67f20dcff839552daf"}
{"code": "private JMXConnectorServer createServer(String serverName,\n            String bindAddress, int theRmiRegistryPort, int theRmiServerPort,\n            HashMap<String,Object> theEnv,\n            RMIClientSocketFactory registryCsf, RMIServerSocketFactory registrySsf,\n            RMIClientSocketFactory serverCsf, RMIServerSocketFactory serverSsf) {\n\n        // Create the RMI registry\n        Registry registry;\n        try {\n            registry = LocateRegistry.createRegistry(\n                    theRmiRegistryPort, registryCsf, registrySsf);\n        } catch (RemoteException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createRegistryFailed\",\n                    serverName, Integer.toString(theRmiRegistryPort)), e);\n            return null;\n        }\n\n        if (bindAddress == null) {\n            bindAddress = \"localhost\";\n        }\n\n        String url = \"service:jmx:rmi://\" + bindAddress;\n        JMXServiceURL serviceUrl;\n        try {\n            serviceUrl = new JMXServiceURL(url);\n        } catch (MalformedURLException e) {\n            log.error(sm.getString(\"jmxRemoteLifecycleListener.invalidURL\", serverName, url), e);\n            return null;\n        }\n\n        RMIConnectorServer cs = null;\n        try {\n            RMIJRMPServerImpl server = new RMIJRMPServerImpl(\n                    rmiServerPortPlatform, serverCsf, serverSsf, theEnv);\n            cs = new RMIConnectorServer(serviceUrl, theEnv, server,\n                    ManagementFactory.getPlatformMBeanServer());\n            cs.start();\n            registry.bind(\"jmxrmi\", server.toStub());\n            log.info(sm.getString(\"jmxRemoteLifecycleListener.start\",\n                    Integer.toString(theRmiRegistryPort),\n                    Integer.toString(theRmiServerPort), serverName));\n        } catch (IOException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createServerFailed\",\n                    serverName), e);\n        } catch (AlreadyBoundException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createServerFailed\",\n                    serverName), e);\n        }\n        return cs;\n    }", "code_tokens": ["private", "JMXConnectorServer", "createServer", "(", "String", "serverName", ",", "String", "bindAddress", ",", "int", "theRmiRegistryPort", ",", "int", "theRmiServerPort", ",", "HashMap", "<", "String", ",", "Object", ">", "theEnv", ",", "RMIClientSocketFactory", "registryCsf", ",", "RMIServerSocketFactory", "registrySsf", ",", "RMIClientSocketFactory", "serverCsf", ",", "RMIServerSocketFactory", "serverSsf", ")", "{", "Registry", "registry", ";", "try", "{", "registry", "=", "LocateRegistry", ".", "createRegistry", "(", "theRmiRegistryPort", ",", "registryCsf", ",", "registrySsf", ")", ";", "}", "catch", "(", "RemoteException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.createRegistryFailed", "\"", ",", "serverName", ",", "Integer", ".", "toString", "(", "theRmiRegistryPort", ")", ")", ",", "e", ")", ";", "return", "null", ";", "}", "if", "(", "bindAddress", "==", "null", ")", "{", "bindAddress", "=", "\"", "localhost", "\"", ";", "}", "String", "url", "=", "\"", "service:jmx:rmi://", "\"", "+", "bindAddress", ";", "JMXServiceURL", "serviceUrl", ";", "try", "{", "serviceUrl", "=", "new", "JMXServiceURL", "(", "url", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.invalidURL", "\"", ",", "serverName", ",", "url", ")", ",", "e", ")", ";", "return", "null", ";", "}", "RMIConnectorServer", "cs", "=", "null", ";", "try", "{", "RMIJRMPServerImpl", "server", "=", "new", "RMIJRMPServerImpl", "(", "rmiServerPortPlatform", ",", "serverCsf", ",", "serverSsf", ",", "theEnv", ")", ";", "cs", "=", "new", "RMIConnectorServer", "(", "serviceUrl", ",", "theEnv", ",", "server", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "cs", ".", "start", "(", ")", ";", "registry", ".", "bind", "(", "\"", "jmxrmi", "\"", ",", "server", ".", "toStub", "(", ")", ")", ";", "log", ".", "info", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.start", "\"", ",", "Integer", ".", "toString", "(", "theRmiRegistryPort", ")", ",", "Integer", ".", "toString", "(", "theRmiServerPort", ")", ",", "serverName", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.createServerFailed", "\"", ",", "serverName", ")", ",", "e", ")", ";", "}", "catch", "(", "AlreadyBoundException", "e", ")", "{", "log", ".", "error", "(", "sm", ".", "getString", "(", "\"", "jmxRemoteLifecycleListener.createServerFailed", "\"", ",", "serverName", ")", ",", "e", ")", ";", "}", "return", "cs", ";", "}"], "idx": 101476, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "bef3f40", "function_name": "createServer", "body_hash": "d4aed439261b6ca0bd74907025f19b48d5dcf12c"}
{"code": "private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                if (inIndexLimit - inIndex < 1 + tail) {\n                    // Apache Tomcat added tests - detect invalid sequences as\n                    // early as possible\n                    if (jchar == 0x74 && inIndexLimit > inIndex + 1) {\n                        if ((bArr[inIndex + 1] & 0xFF) > 0x8F) {\n                            // 11110100 1yyyxxxx xxxxxxxx xxxxxxxx\n                            // Any non-zero y is > max code point\n                            return CoderResult.unmappableForLength(4);\n                        }\n                    }\n                    if (jchar == 0x60 && inIndexLimit > inIndex +1) {\n                        if ((bArr[inIndex + 1] & 0x7F) == 0) {\n                            // 11100000 10000000 10xxxxxx\n                            // should have been\n                            // 00xxxxxx\n                            return CoderResult.malformedForLength(3);\n                        }\n                    }\n                    if (jchar == 0x70 && inIndexLimit > inIndex +1) {\n                        if ((bArr[inIndex + 1] & 0x7F) < 0x10) {\n                            // 11110000 1000zzzz 1oyyyyyy 1oxxxxxx\n                            // should have been\n                            // 111ozzzz 1oyyyyyy 1oxxxxxx\n                            return CoderResult.malformedForLength(4);\n                        }\n                    }\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ? CoderResult.OVERFLOW\n                : CoderResult.UNDERFLOW;\n    }", "code_tokens": ["private", "CoderResult", "decodeHasArray", "(", "ByteBuffer", "in", ",", "CharBuffer", "out", ")", "{", "int", "outRemaining", "=", "out", ".", "remaining", "(", ")", ";", "int", "pos", "=", "in", ".", "position", "(", ")", ";", "int", "limit", "=", "in", ".", "limit", "(", ")", ";", "final", "byte", "[", "]", "bArr", "=", "in", ".", "array", "(", ")", ";", "final", "char", "[", "]", "cArr", "=", "out", ".", "array", "(", ")", ";", "final", "int", "inIndexLimit", "=", "limit", "+", "in", ".", "arrayOffset", "(", ")", ";", "int", "inIndex", "=", "pos", "+", "in", ".", "arrayOffset", "(", ")", ";", "int", "outIndex", "=", "out", ".", "position", "(", ")", "+", "out", ".", "arrayOffset", "(", ")", ";", "for", "(", ";", "inIndex", "<", "inIndexLimit", "&&", "outRemaining", ">", "0", ";", "inIndex", "++", ")", "{", "int", "jchar", "=", "bArr", "[", "inIndex", "]", ";", "if", "(", "jchar", "<", "0", ")", "{", "jchar", "=", "jchar", "&", "0x7F", ";", "int", "tail", "=", "remainingBytes", "[", "jchar", "]", ";", "if", "(", "tail", "==", "-", "1", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "if", "(", "inIndexLimit", "-", "inIndex", "<", "1", "+", "tail", ")", "{", "if", "(", "jchar", "==", "0x74", "&&", "inIndexLimit", ">", "inIndex", "+", "1", ")", "{", "if", "(", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0xFF", ")", ">", "0x8F", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "4", ")", ";", "}", "}", "if", "(", "jchar", "==", "0x60", "&&", "inIndexLimit", ">", "inIndex", "+", "1", ")", "{", "if", "(", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0x7F", ")", "==", "0", ")", "{", "return", "CoderResult", ".", "malformedForLength", "(", "3", ")", ";", "}", "}", "if", "(", "jchar", "==", "0x70", "&&", "inIndexLimit", ">", "inIndex", "+", "1", ")", "{", "if", "(", "(", "bArr", "[", "inIndex", "+", "1", "]", "&", "0x7F", ")", "<", "0x10", ")", "{", "return", "CoderResult", ".", "malformedForLength", "(", "4", ")", ";", "}", "}", "break", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "tail", ";", "i", "++", ")", "{", "int", "nextByte", "=", "bArr", "[", "inIndex", "+", "i", "+", "1", "]", "&", "0xFF", ";", "if", "(", "(", "nextByte", "&", "0xC0", ")", "!=", "0x80", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", "+", "i", ")", ";", "}", "jchar", "=", "(", "jchar", "<<", "6", ")", "+", "nextByte", ";", "}", "jchar", "-=", "remainingNumbers", "[", "tail", "]", ";", "if", "(", "jchar", "<", "lowerEncodingLimit", "[", "tail", "]", ")", "{", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "CoderResult", ".", "malformedForLength", "(", "1", ")", ";", "}", "inIndex", "+=", "tail", ";", "}", "if", "(", "jchar", ">=", "0xD800", "&&", "jchar", "<=", "0xDFFF", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "3", ")", ";", "}", "if", "(", "jchar", ">", "0x10FFFF", ")", "{", "return", "CoderResult", ".", "unmappableForLength", "(", "4", ")", ";", "}", "if", "(", "jchar", "<=", "0xffff", ")", "{", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "jchar", ";", "outRemaining", "--", ";", "}", "else", "{", "if", "(", "outRemaining", "<", "2", ")", "{", "return", "CoderResult", ".", "OVERFLOW", ";", "}", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "(", "(", "jchar", ">>", "0xA", ")", "+", "0xD7C0", ")", ";", "cArr", "[", "outIndex", "++", "]", "=", "(", "char", ")", "(", "(", "jchar", "&", "0x3FF", ")", "+", "0xDC00", ")", ";", "outRemaining", "-=", "2", ";", "}", "}", "in", ".", "position", "(", "inIndex", "-", "in", ".", "arrayOffset", "(", ")", ")", ";", "out", ".", "position", "(", "outIndex", "-", "out", ".", "arrayOffset", "(", ")", ")", ";", "return", "(", "outRemaining", "==", "0", "&&", "inIndex", "<", "inIndexLimit", ")", "?", "CoderResult", ".", "OVERFLOW", ":", "CoderResult", ".", "UNDERFLOW", ";", "}"], "idx": 23580, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "150bc791ac3ba40081425dd1c37a053fbb02b339", "function_name": "decodeHasArray", "body_hash": "292f4679fecbfc48aedbaa3ba05356a227dca51b"}
{"code": "private AuthenticationMechanismOutcome handleDigestHeader(HttpServerExchange exchange, final SecurityContext securityContext) {\n        DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);\n        Map<DigestAuthorizationToken, String> parsedHeader = context.getParsedHeader();\n        // Step 1 - Verify the set of tokens received to ensure valid values.\n        Set<DigestAuthorizationToken> mandatoryTokens = EnumSet.copyOf(MANDATORY_REQUEST_TOKENS);\n        if (!supportedAlgorithms.contains(DigestAlgorithm.MD5)) {\n            // If we don't support MD5 then the client must choose an algorithm as we can not fall back to MD5.\n            mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);\n        }\n        if (!supportedQops.isEmpty() && !supportedQops.contains(DigestQop.AUTH)) {\n            // If we do not support auth then we are mandating auth-int so force the client to send a QOP\n            mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);\n        }\n\n        DigestQop qop = null;\n        // This check is early as is increases the list of mandatory tokens.\n        if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {\n            qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n            if (qop == null || !supportedQops.contains(qop)) {\n                // We are also ensuring the client is not trying to force a qop that has been disabled.\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n            context.setQop(qop);\n            mandatoryTokens.add(DigestAuthorizationToken.CNONCE);\n            mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);\n        }\n\n        // Check all mandatory tokens are present.\n        mandatoryTokens.removeAll(parsedHeader.keySet());\n        if (mandatoryTokens.size() > 0) {\n            for (DigestAuthorizationToken currentToken : mandatoryTokens) {\n                // TODO - Need a better check and possible concatenate the list of tokens - however\n                // even having one missing token is not something we should routinely expect.\n                REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());\n            }\n            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // Perform some validation of the remaining tokens.\n        if (!realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM))) {\n            REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),\n                    parsedHeader.get(DigestAuthorizationToken.REALM));\n            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if(parsedHeader.containsKey(DigestAuthorizationToken.DIGEST_URI)) {\n            String uri = parsedHeader.get(DigestAuthorizationToken.DIGEST_URI);\n            String requestURI = exchange.getRequestURI();\n            if(!exchange.getQueryString().isEmpty()) {\n                requestURI = requestURI + \"?\" + exchange.getQueryString();\n            }\n            if(!uri.equals(requestURI)) {\n                //just end the auth process\n                exchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                exchange.endExchange();\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {\n            if (!OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE))) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.OPAQUE));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        }\n\n        DigestAlgorithm algorithm;\n        if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {\n            algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n            if (algorithm == null || !supportedAlgorithms.contains(algorithm)) {\n                // We are also ensuring the client is not trying to force an algorithm that has been disabled.\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            // We know this is safe as the algorithm token was made mandatory\n            // if MD5 is not supported.\n            algorithm = DigestAlgorithm.MD5;\n        }\n\n        try {\n            context.setAlgorithm(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            /*\n             * This should not be possible in a properly configured installation.\n             */\n            REQUEST_LOGGER.exceptionProcessingRequest(e);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);\n        final IdentityManager identityManager = getIdentityManager(securityContext);\n        final Account account;\n\n        if (algorithm.isSession()) {\n            /* This can follow one of the following: -\n             *   1 - New session so use DigestCredentialImpl with the IdentityManager to\n             *       create a new session key.\n             *   2 - Obtain the existing session key from the session store and validate it, just use\n             *       IdentityManager to validate account is still active and the current role assignment.\n             */\n            throw new IllegalStateException(\"Not yet implemented.\");\n        } else {\n            final DigestCredential credential = new DigestCredentialImpl(context);\n            account = identityManager.verify(userName, credential);\n        }\n\n        if (account == null) {\n            // Authentication has failed, this could either be caused by the user not-existing or it\n            // could be caused due to an invalid hash.\n            securityContext.authenticationFailed(MESSAGES.authenticationFailed(userName), mechanismName);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // Step 3 - Verify that the nonce was eligible to be used.\n        if (!validateNonceUse(context, parsedHeader, exchange)) {\n            // TODO - This is the right place to make use of the decision but the check needs to be much much sooner\n            // otherwise a failure server\n            // side could leave a packet that could be 're-played' after the failed auth.\n            // The username and password verification passed but for some reason we do not like the nonce.\n            context.markStale();\n            // We do not mark as a failure on the security context as this is not quite a failure, a client with a cached nonce\n            // can easily hit this point.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // We have authenticated the remote user.\n\n        sendAuthenticationInfoHeader(exchange);\n        securityContext.authenticationComplete(account, mechanismName, false);\n        return AuthenticationMechanismOutcome.AUTHENTICATED;\n\n        // Step 4 - Set up any QOP related requirements.\n\n        // TODO - Do QOP\n    }", "code_tokens": ["private", "AuthenticationMechanismOutcome", "handleDigestHeader", "(", "HttpServerExchange", "exchange", ",", "final", "SecurityContext", "securityContext", ")", "{", "DigestContext", "context", "=", "exchange", ".", "getAttachment", "(", "DigestContext", ".", "ATTACHMENT_KEY", ")", ";", "Map", "<", "DigestAuthorizationToken", ",", "String", ">", "parsedHeader", "=", "context", ".", "getParsedHeader", "(", ")", ";", "Set", "<", "DigestAuthorizationToken", ">", "mandatoryTokens", "=", "EnumSet", ".", "copyOf", "(", "MANDATORY_REQUEST_TOKENS", ")", ";", "if", "(", "!", "supportedAlgorithms", ".", "contains", "(", "DigestAlgorithm", ".", "MD5", ")", ")", "{", "mandatoryTokens", ".", "add", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ")", ";", "}", "if", "(", "!", "supportedQops", ".", "isEmpty", "(", ")", "&&", "!", "supportedQops", ".", "contains", "(", "DigestQop", ".", "AUTH", ")", ")", "{", "mandatoryTokens", ".", "add", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ")", ";", "}", "DigestQop", "qop", "=", "null", ";", "if", "(", "parsedHeader", ".", "containsKey", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ")", ")", "{", "qop", "=", "DigestQop", ".", "forName", "(", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ")", ")", ";", "if", "(", "qop", "==", "null", "||", "!", "supportedQops", ".", "contains", "(", "qop", ")", ")", "{", "REQUEST_LOGGER", ".", "invalidTokenReceived", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ".", "getName", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "MESSAGE_QOP", ")", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "context", ".", "setQop", "(", "qop", ")", ";", "mandatoryTokens", ".", "add", "(", "DigestAuthorizationToken", ".", "CNONCE", ")", ";", "mandatoryTokens", ".", "add", "(", "DigestAuthorizationToken", ".", "NONCE_COUNT", ")", ";", "}", "mandatoryTokens", ".", "removeAll", "(", "parsedHeader", ".", "keySet", "(", ")", ")", ";", "if", "(", "mandatoryTokens", ".", "size", "(", ")", ">", "0", ")", "{", "for", "(", "DigestAuthorizationToken", "currentToken", ":", "mandatoryTokens", ")", "{", "REQUEST_LOGGER", ".", "missingAuthorizationToken", "(", "currentToken", ".", "getName", "(", ")", ")", ";", "}", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "if", "(", "!", "realmName", ".", "equals", "(", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "REALM", ")", ")", ")", "{", "REQUEST_LOGGER", ".", "invalidTokenReceived", "(", "DigestAuthorizationToken", ".", "REALM", ".", "getName", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "REALM", ")", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "if", "(", "parsedHeader", ".", "containsKey", "(", "DigestAuthorizationToken", ".", "DIGEST_URI", ")", ")", "{", "String", "uri", "=", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "DIGEST_URI", ")", ";", "String", "requestURI", "=", "exchange", ".", "getRequestURI", "(", ")", ";", "if", "(", "!", "exchange", ".", "getQueryString", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "requestURI", "=", "requestURI", "+", "\"", "?", "\"", "+", "exchange", ".", "getQueryString", "(", ")", ";", "}", "if", "(", "!", "uri", ".", "equals", "(", "requestURI", ")", ")", "{", "exchange", ".", "setStatusCode", "(", "StatusCodes", ".", "BAD_REQUEST", ")", ";", "exchange", ".", "endExchange", "(", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "}", "else", "{", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "if", "(", "parsedHeader", ".", "containsKey", "(", "DigestAuthorizationToken", ".", "OPAQUE", ")", ")", "{", "if", "(", "!", "OPAQUE_VALUE", ".", "equals", "(", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "OPAQUE", ")", ")", ")", "{", "REQUEST_LOGGER", ".", "invalidTokenReceived", "(", "DigestAuthorizationToken", ".", "OPAQUE", ".", "getName", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "OPAQUE", ")", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "}", "DigestAlgorithm", "algorithm", ";", "if", "(", "parsedHeader", ".", "containsKey", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ")", ")", "{", "algorithm", "=", "DigestAlgorithm", ".", "forName", "(", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ")", ")", ";", "if", "(", "algorithm", "==", "null", "||", "!", "supportedAlgorithms", ".", "contains", "(", "algorithm", ")", ")", "{", "REQUEST_LOGGER", ".", "invalidTokenReceived", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ".", "getName", "(", ")", ",", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "ALGORITHM", ")", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "}", "else", "{", "algorithm", "=", "DigestAlgorithm", ".", "MD5", ";", "}", "try", "{", "context", ".", "setAlgorithm", "(", "algorithm", ")", ";", "}", "catch", "(", "NoSuchAlgorithmException", "e", ")", "{", "REQUEST_LOGGER", ".", "exceptionProcessingRequest", "(", "e", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "final", "String", "userName", "=", "parsedHeader", ".", "get", "(", "DigestAuthorizationToken", ".", "USERNAME", ")", ";", "final", "IdentityManager", "identityManager", "=", "getIdentityManager", "(", "securityContext", ")", ";", "final", "Account", "account", ";", "if", "(", "algorithm", ".", "isSession", "(", ")", ")", "{", "throw", "new", "IllegalStateException", "(", "\"", "Not yet implemented.", "\"", ")", ";", "}", "else", "{", "final", "DigestCredential", "credential", "=", "new", "DigestCredentialImpl", "(", "context", ")", ";", "account", "=", "identityManager", ".", "verify", "(", "userName", ",", "credential", ")", ";", "}", "if", "(", "account", "==", "null", ")", "{", "securityContext", ".", "authenticationFailed", "(", "MESSAGES", ".", "authenticationFailed", "(", "userName", ")", ",", "mechanismName", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "if", "(", "!", "validateNonceUse", "(", "context", ",", "parsedHeader", ",", "exchange", ")", ")", "{", "context", ".", "markStale", "(", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "NOT_AUTHENTICATED", ";", "}", "sendAuthenticationInfoHeader", "(", "exchange", ")", ";", "securityContext", ".", "authenticationComplete", "(", "account", ",", "mechanismName", ",", "false", ")", ";", "return", "AuthenticationMechanismOutcome", ".", "AUTHENTICATED", ";", "}"], "idx": 86556, "cwe": "CWE-863", "target": 1, "status": "VULNERABLE", "commit": "8804170ce3186bdd83b486959399ec7ac0f59d0f", "function_name": "handleDigestHeader", "body_hash": "9236564772844ed25ac69c6227bcd32a3524e154"}
{"code": "@GET\n    @Path(\"/purge/{date}\")\n    public void purge(@PathParam(\"date\") String date) {\n        try {\n            clusterService.purge(new SimpleDateFormat(\"yyyy-MM-dd\").parse(date));\n        } catch (ParseException e) {\n            logger.error(\"Cannot purge\",e);\n        }\n    }", "code_tokens": ["@", "GET", "@", "Path", "(", "\"", "/purge/{date}", "\"", ")", "public", "void", "purge", "(", "@", "PathParam", "(", "\"", "date", "\"", ")", "String", "date", ")", "{", "try", "{", "clusterService", ".", "purge", "(", "new", "SimpleDateFormat", "(", "\"", "yyyy-MM-dd", "\"", ")", ".", "parse", "(", "date", ")", ")", ";", "}", "catch", "(", "ParseException", "e", ")", "{", "logger", ".", "error", "(", "\"", "Cannot purge", "\"", ",", "e", ")", ";", "}", "}"], "idx": 73771, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "1c088702511ef44a056244cb968682daf8f21946", "function_name": "purge", "body_hash": "d3d68da2c868b42e5198e5fcfcfbec157bb66c38"}
{"code": "@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder()\n                .putArray(URLRepository.ALLOWED_URLS_SETTING, \"http://snapshot.test*\")\n                .put(InternalNode.HTTP_ENABLED, true)\n                .put(super.nodeSettings(nodeOrdinal)).build();\n    }", "code_tokens": ["@", "Override", "protected", "Settings", "nodeSettings", "(", "int", "nodeOrdinal", ")", "{", "return", "ImmutableSettings", ".", "builder", "(", ")", ".", "putArray", "(", "URLRepository", ".", "ALLOWED_URLS_SETTING", ",", "\"", "http://snapshot.test*", "\"", ")", ".", "put", "(", "InternalNode", ".", "HTTP_ENABLED", ",", "true", ")", ".", "put", "(", "super", ".", "nodeSettings", "(", "nodeOrdinal", ")", ")", ".", "build", "(", ")", ";", "}"], "idx": 27469, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "df1427a2935237fb61fc641984f9c76478627fec", "function_name": "nodeSettings", "body_hash": "3a76b4024f19af4196579f1f7df24efa74d9bc93"}
{"code": "private void addInputFilter(InputFilter[] inputFilters, String encodingName) {\n\n        // Parsing trims and converts to lower case.\n\n        if (encodingName.equals(\"chunked\")) {\n            inputBuffer.addActiveFilter(inputFilters[Constants.CHUNKED_FILTER]);\n            contentDelimitation = true;\n        } else {\n            for (int i = pluggableFilterIndex; i < inputFilters.length; i++) {\n                if (inputFilters[i].getEncodingName().toString().equals(encodingName)) {\n                    inputBuffer.addActiveFilter(inputFilters[i]);\n                    return;\n                }\n            }\n            // Unsupported transfer encoding\n            // 501 - Unimplemented\n            response.setStatus(501);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\") +\n                          \" Unsupported transfer encoding [\" + encodingName + \"]\");\n            }\n        }\n    }", "code_tokens": ["private", "void", "addInputFilter", "(", "InputFilter", "[", "]", "inputFilters", ",", "String", "encodingName", ")", "{", "if", "(", "encodingName", ".", "equals", "(", "\"", "chunked", "\"", ")", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "CHUNKED_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "else", "{", "for", "(", "int", "i", "=", "pluggableFilterIndex", ";", "i", "<", "inputFilters", ".", "length", ";", "i", "++", ")", "{", "if", "(", "inputFilters", "[", "i", "]", ".", "getEncodingName", "(", ")", ".", "toString", "(", ")", ".", "equals", "(", "encodingName", ")", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "i", "]", ")", ";", "return", ";", "}", "}", "response", ".", "setStatus", "(", "501", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Unsupported transfer encoding [", "\"", "+", "encodingName", "+", "\"", "]", "\"", ")", ";", "}", "}", "}"], "idx": 54485, "cwe": "CWE-444", "target": 1, "status": "VULNERABLE", "commit": "19d11556d0db99df291df33605f137976d152475", "function_name": "addInputFilter", "body_hash": "18a440937f486323dd078b7219f3d2f31a7554a7"}
{"code": "public static long readUE7(InputStream stream) throws IOException {\n        int i;\n        long v = 0;\n        while ((i = stream.read()) >= 0) {\n            v = v << 7;\n            if ((i & 128) == 128) {\n                // Continues\n                v += (i & 127);\n            } else {\n                // Last value\n                v += i;\n                break;\n            }\n        }\n        return v;\n    }", "code_tokens": ["public", "static", "long", "readUE7", "(", "InputStream", "stream", ")", "throws", "IOException", "{", "int", "i", ";", "long", "v", "=", "0", ";", "while", "(", "(", "i", "=", "stream", ".", "read", "(", ")", ")", ">=", "0", ")", "{", "v", "=", "v", "<<", "7", ";", "if", "(", "(", "i", "&", "128", ")", "==", "128", ")", "{", "v", "+=", "(", "i", "&", "127", ")", ";", "}", "else", "{", "v", "+=", "i", ";", "break", ";", "}", "}", "return", "v", ";", "}"], "idx": 108860, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "302f22aff7a836868b270038e1d66002a2004869", "function_name": "readUE7", "body_hash": "c49ff223f5dbde3d30f589f994c46b14ac728231"}
{"code": "public static View create(StaplerRequest req, StaplerResponse rsp, ViewGroup owner)\n            throws FormException, IOException, ServletException {\n        String mode = req.getParameter(\"mode\");\n\n        String requestContentType = req.getContentType();\n        if (requestContentType == null\n                && !(mode != null && mode.equals(\"copy\")))\n            throw new Failure(\"No Content-Type header set\");\n\n        boolean isXmlSubmission = requestContentType != null\n                && (requestContentType.startsWith(\"application/xml\")\n                        || requestContentType.startsWith(\"text/xml\"));\n\n        String name = req.getParameter(\"name\");\n        Jenkins.checkGoodName(name);\n        if(owner.getView(name)!=null)\n            throw new Failure(Messages.Hudson_ViewAlreadyExists(name));\n\n        if (mode==null || mode.length()==0) {\n            if(isXmlSubmission) {\n                View v = createViewFromXML(name, req.getInputStream());\n                owner.getACL().checkCreatePermission(owner, v.getDescriptor());\n                v.owner = owner;\n                rsp.setStatus(HttpServletResponse.SC_OK);\n                return v;\n            } else\n                throw new Failure(Messages.View_MissingMode());\n        }\n\n        View v;\n        if (\"copy\".equals(mode)) {\n            v = copy(req, owner, name);\n        } else {\n            ViewDescriptor descriptor = all().findByName(mode);\n            if (descriptor == null) {\n                throw new Failure(\"No view type \u2018\" + mode + \"\u2019 is known\");\n            }\n\n            // create a view\n            JSONObject submittedForm = req.getSubmittedForm();\n            submittedForm.put(\"name\", name);\n            v = descriptor.newInstance(req, submittedForm);\n        }\n        owner.getACL().checkCreatePermission(owner, v.getDescriptor());\n        v.owner = owner;\n\n        // redirect to the config screen\n        rsp.sendRedirect2(req.getContextPath()+'/'+v.getUrl()+v.getPostConstructLandingPage());\n\n        return v;\n    }", "code_tokens": ["public", "static", "View", "create", "(", "StaplerRequest", "req", ",", "StaplerResponse", "rsp", ",", "ViewGroup", "owner", ")", "throws", "FormException", ",", "IOException", ",", "ServletException", "{", "String", "mode", "=", "req", ".", "getParameter", "(", "\"", "mode", "\"", ")", ";", "String", "requestContentType", "=", "req", ".", "getContentType", "(", ")", ";", "if", "(", "requestContentType", "==", "null", "&&", "!", "(", "mode", "!=", "null", "&&", "mode", ".", "equals", "(", "\"", "copy", "\"", ")", ")", ")", "throw", "new", "Failure", "(", "\"", "No Content-Type header set", "\"", ")", ";", "boolean", "isXmlSubmission", "=", "requestContentType", "!=", "null", "&&", "(", "requestContentType", ".", "startsWith", "(", "\"", "application/xml", "\"", ")", "||", "requestContentType", ".", "startsWith", "(", "\"", "text/xml", "\"", ")", ")", ";", "String", "name", "=", "req", ".", "getParameter", "(", "\"", "name", "\"", ")", ";", "Jenkins", ".", "checkGoodName", "(", "name", ")", ";", "if", "(", "owner", ".", "getView", "(", "name", ")", "!=", "null", ")", "throw", "new", "Failure", "(", "Messages", ".", "Hudson_ViewAlreadyExists", "(", "name", ")", ")", ";", "if", "(", "mode", "==", "null", "||", "mode", ".", "length", "(", ")", "==", "0", ")", "{", "if", "(", "isXmlSubmission", ")", "{", "View", "v", "=", "createViewFromXML", "(", "name", ",", "req", ".", "getInputStream", "(", ")", ")", ";", "owner", ".", "getACL", "(", ")", ".", "checkCreatePermission", "(", "owner", ",", "v", ".", "getDescriptor", "(", ")", ")", ";", "v", ".", "owner", "=", "owner", ";", "rsp", ".", "setStatus", "(", "HttpServletResponse", ".", "SC_OK", ")", ";", "return", "v", ";", "}", "else", "throw", "new", "Failure", "(", "Messages", ".", "View_MissingMode", "(", ")", ")", ";", "}", "View", "v", ";", "if", "(", "\"", "copy", "\"", ".", "equals", "(", "mode", ")", ")", "{", "v", "=", "copy", "(", "req", ",", "owner", ",", "name", ")", ";", "}", "else", "{", "ViewDescriptor", "descriptor", "=", "all", "(", ")", ".", "findByName", "(", "mode", ")", ";", "if", "(", "descriptor", "==", "null", ")", "{", "throw", "new", "Failure", "(", "\"", "No view type \u2018", "\"", "+", "mode", "+", "\"", "\u2019 is known", "\"", ")", ";", "}", "JSONObject", "submittedForm", "=", "req", ".", "getSubmittedForm", "(", ")", ";", "submittedForm", ".", "put", "(", "\"", "name", "\"", ",", "name", ")", ";", "v", "=", "descriptor", ".", "newInstance", "(", "req", ",", "submittedForm", ")", ";", "}", "owner", ".", "getACL", "(", ")", ".", "checkCreatePermission", "(", "owner", ",", "v", ".", "getDescriptor", "(", ")", ")", ";", "v", ".", "owner", "=", "owner", ";", "rsp", ".", "sendRedirect2", "(", "req", ".", "getContextPath", "(", ")", "+", "'/'", "+", "v", ".", "getUrl", "(", ")", "+", "v", ".", "getPostConstructLandingPage", "(", ")", ")", ";", "return", "v", ";", "}"], "idx": 28984, "cwe": "CWE-240", "target": 0, "status": "FIXED", "commit": "42e2c74049ddf5e0aca1fe6aadc7b24fdabb5494", "function_name": "create", "body_hash": "7946c5da68c60adf534420670d55c94e986c2367"}
{"code": "private void handleDynamicMethodInvocation(ActionMapping mapping, String name) {\n        int exclamation = name.lastIndexOf(\"!\");\n        if (exclamation != -1) {\n            String actionName = name.substring(0, exclamation);\n            String actionMethod = name.substring(exclamation + 1);\n\n            // WW-4585\n            // add any ; appendix to name, it will be handled later in getMapping method\n            int scPos = actionMethod.indexOf(';');\n            if (scPos != -1) {\n                actionName = actionName + actionMethod.substring(scPos);\n                actionMethod = actionMethod.substring(0, scPos);\n            }\n\n            mapping.setName(actionName);\n            if (allowDynamicMethodCalls) {\n                mapping.setMethod(cleanupActionName(actionMethod));\n            } else {\n                mapping.setMethod(null);\n            }\n        }\n    }", "code_tokens": ["private", "void", "handleDynamicMethodInvocation", "(", "ActionMapping", "mapping", ",", "String", "name", ")", "{", "int", "exclamation", "=", "name", ".", "lastIndexOf", "(", "\"", "!", "\"", ")", ";", "if", "(", "exclamation", "!=", "-", "1", ")", "{", "String", "actionName", "=", "name", ".", "substring", "(", "0", ",", "exclamation", ")", ";", "String", "actionMethod", "=", "name", ".", "substring", "(", "exclamation", "+", "1", ")", ";", "int", "scPos", "=", "actionMethod", ".", "indexOf", "(", "';'", ")", ";", "if", "(", "scPos", "!=", "-", "1", ")", "{", "actionName", "=", "actionName", "+", "actionMethod", ".", "substring", "(", "scPos", ")", ";", "actionMethod", "=", "actionMethod", ".", "substring", "(", "0", ",", "scPos", ")", ";", "}", "mapping", ".", "setName", "(", "actionName", ")", ";", "if", "(", "allowDynamicMethodCalls", ")", "{", "mapping", ".", "setMethod", "(", "cleanupActionName", "(", "actionMethod", ")", ")", ";", "}", "else", "{", "mapping", ".", "setMethod", "(", "null", ")", ";", "}", "}", "}"], "idx": 10611, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "76eb8f38a33ad0f1f48464ee1311559c8d52dd6d", "function_name": "handleDynamicMethodInvocation", "body_hash": "555db3a45d2ed12bbaf70b5747362cc04827225b"}
{"code": "protected Result findResult(String path, String resultCode, String ext, ActionContext actionContext,\n                                Map<String, ResultTypeConfig> resultsByExtension) {\n        try {\n            boolean traceEnabled = LOG.isTraceEnabled();\n            if (traceEnabled)\n                LOG.trace(\"Checking ServletContext for [#0]\", path);\n\n            if (servletContext.getResource(path) != null) {\n                if (traceEnabled)\n                    LOG.trace(\"Found\");\n                return buildResult(path, resultCode, resultsByExtension.get(ext), actionContext);\n            }\n\n            if (traceEnabled)\n                LOG.trace(\"Checking ClasLoader for #0\", path);\n\n            String classLoaderPath = path.startsWith(\"/\") ? path.substring(1, path.length()) : path;\n            if (ClassLoaderUtil.getResource(classLoaderPath, getClass()) != null) {\n                if (traceEnabled)\n                    LOG.trace(\"Found\");\n                return buildResult(path, resultCode, resultsByExtension.get(ext), actionContext);\n            }\n        } catch (MalformedURLException e) {\n            if (LOG.isErrorEnabled())\n                LOG.error(\"Unable to parse template path: [#0] skipping...\", path);\n        }\n\n        return null;\n    }", "code_tokens": ["protected", "Result", "findResult", "(", "String", "path", ",", "String", "resultCode", ",", "String", "ext", ",", "ActionContext", "actionContext", ",", "Map", "<", "String", ",", "ResultTypeConfig", ">", "resultsByExtension", ")", "{", "try", "{", "boolean", "traceEnabled", "=", "LOG", ".", "isTraceEnabled", "(", ")", ";", "if", "(", "traceEnabled", ")", "LOG", ".", "trace", "(", "\"", "Checking ServletContext for [#0]", "\"", ",", "path", ")", ";", "if", "(", "servletContext", ".", "getResource", "(", "path", ")", "!=", "null", ")", "{", "if", "(", "traceEnabled", ")", "LOG", ".", "trace", "(", "\"", "Found", "\"", ")", ";", "return", "buildResult", "(", "path", ",", "resultCode", ",", "resultsByExtension", ".", "get", "(", "ext", ")", ",", "actionContext", ")", ";", "}", "if", "(", "traceEnabled", ")", "LOG", ".", "trace", "(", "\"", "Checking ClasLoader for #0", "\"", ",", "path", ")", ";", "String", "classLoaderPath", "=", "path", ".", "startsWith", "(", "\"", "/", "\"", ")", "?", "path", ".", "substring", "(", "1", ",", "path", ".", "length", "(", ")", ")", ":", "path", ";", "if", "(", "ClassLoaderUtil", ".", "getResource", "(", "classLoaderPath", ",", "getClass", "(", ")", ")", "!=", "null", ")", "{", "if", "(", "traceEnabled", ")", "LOG", ".", "trace", "(", "\"", "Found", "\"", ")", ";", "return", "buildResult", "(", "path", ",", "resultCode", ",", "resultsByExtension", ".", "get", "(", "ext", ")", ",", "actionContext", ")", ";", "}", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "if", "(", "LOG", ".", "isErrorEnabled", "(", ")", ")", "LOG", ".", "error", "(", "\"", "Unable to parse template path: [#0] skipping...", "\"", ",", "path", ")", ";", "}", "return", "null", ";", "}"], "idx": 25802, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "8e67b9144aa643769b261e2492cb561e04d016ab", "function_name": "findResult", "body_hash": "54bd1d9dd75bcc2599e88ab5e45ea58aae49e82d"}
{"code": "private String escapeString(final String string)\n  {\n    if (string == null || string.length() == 0) {\n      return \"\\\"\\\"\";\n    }\n    char c = 0;\n    int i;\n    final int len = string.length();\n    final StringBuilder sb = new StringBuilder(len + 4);\n    String t;\n    sb.append('\"');\n    for (i = 0; i < len; i += 1) {\n      c = string.charAt(i);\n      switch (c) {\n        case '\\\\':\n        case '\"':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '/':\n          // if (b == '<') {\n          sb.append('\\\\');\n          // }\n          sb.append(c);\n          break;\n        case '\\b':\n          sb.append(\"\\\\b\");\n          break;\n        case '\\t':\n          sb.append(\"\\\\t\");\n          break;\n        case '\\n':\n          sb.append(\"\\\\n\");\n          break;\n        case '\\f':\n          sb.append(\"\\\\f\");\n          break;\n        case '\\r':\n          sb.append(\"\\\\r\");\n          break;\n        default:\n          if (c < ' ') {\n            t = \"000\" + Integer.toHexString(c);\n            sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n          } else {\n            sb.append(c);\n          }\n      }\n    }\n    sb.append('\"');\n    return sb.toString();\n  }", "code_tokens": ["private", "String", "escapeString", "(", "final", "String", "string", ")", "{", "if", "(", "string", "==", "null", "||", "string", ".", "length", "(", ")", "==", "0", ")", "{", "return", "\"", "\\\"", "\\\"", "\"", ";", "}", "char", "c", "=", "0", ";", "int", "i", ";", "final", "int", "len", "=", "string", ".", "length", "(", ")", ";", "final", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "len", "+", "4", ")", ";", "String", "t", ";", "sb", ".", "append", "(", "'\"'", ")", ";", "for", "(", "i", "=", "0", ";", "i", "<", "len", ";", "i", "+=", "1", ")", "{", "c", "=", "string", ".", "charAt", "(", "i", ")", ";", "switch", "(", "c", ")", "{", "case", "'\\\\'", ":", "case", "'\"'", ":", "sb", ".", "append", "(", "'\\\\'", ")", ";", "sb", ".", "append", "(", "c", ")", ";", "break", ";", "case", "'/'", ":", "sb", ".", "append", "(", "'\\\\'", ")", ";", "sb", ".", "append", "(", "c", ")", ";", "break", ";", "case", "'\\b'", ":", "sb", ".", "append", "(", "\"", "\\\\", "b", "\"", ")", ";", "break", ";", "case", "'\\t'", ":", "sb", ".", "append", "(", "\"", "\\\\", "t", "\"", ")", ";", "break", ";", "case", "'\\n'", ":", "sb", ".", "append", "(", "\"", "\\\\", "n", "\"", ")", ";", "break", ";", "case", "'\\f'", ":", "sb", ".", "append", "(", "\"", "\\\\", "f", "\"", ")", ";", "break", ";", "case", "'\\r'", ":", "sb", ".", "append", "(", "\"", "\\\\", "r", "\"", ")", ";", "break", ";", "default", ":", "if", "(", "c", "<", "' '", ")", "{", "t", "=", "\"", "000", "\"", "+", "Integer", ".", "toHexString", "(", "c", ")", ";", "sb", ".", "append", "(", "\"", "\\\\", "u", "\"", "+", "t", ".", "substring", "(", "t", ".", "length", "(", ")", "-", "4", ")", ")", ";", "}", "else", "{", "sb", ".", "append", "(", "c", ")", ";", "}", "}", "}", "sb", ".", "append", "(", "'\"'", ")", ";", "return", "sb", ".", "toString", "(", ")", ";", "}"], "idx": 80703, "cwe": "CWE-79", "target": 1, "status": "VULNERABLE", "commit": "5a6a25366491443b76e528a04a9e4ba26f08a83c", "function_name": "escapeString", "body_hash": "502694d72ed90374ce007d84542b590ab2fa8158"}
{"code": "public void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n        byte[] header = new byte[4];\n        IOUtils.readFully(stream, header, 0, 4); // Extract magic byte\n        if (header[0] == (byte) 'i' && header[1] == (byte) 'c'\n                && header[2] == (byte) 'n' && header[3] == (byte) 's') {\n            // Good, signature found\n        } else {\n            throw new TikaException(\"ICNS magic signature invalid\");\n        }\n        IOUtils.readFully(stream, header, 0, 4); //Extract image size/length of bytes in file\n        int image_length = java.nio.ByteBuffer.wrap(header).getInt();\n        if (image_length > MAX_IMAGE_LENGTH_BYTES) {\n            throw new TikaMemoryLimitException(image_length, MAX_IMAGE_LENGTH_BYTES);\n        }\n        byte[] full_file = new byte[image_length];\n        IOUtils.readFully(stream, full_file);\n        ArrayList<ICNSType> icons = new ArrayList<>();\n        ArrayList<ICNSType> icon_masks = new ArrayList<>();\n        byte[] tempByteArray = new byte[4];\n        for (int offset = 0; offset < image_length - 8;) {\n            //Read the ResType/OSTYpe identifier for sub-icon\n            tempByteArray[0] = full_file[offset];\n            tempByteArray[1] = full_file[offset + 1];\n            tempByteArray[2] = full_file[offset + 2];\n            tempByteArray[3] = full_file[offset + 3];\n            ICNSType icnstype = findIconType(tempByteArray);\n\n            if (icnstype == null) {\n                //exit out of loop\n                //No more icons left\n                break;\n            } else if (icnstype.hasMask() == true) {\n                icon_masks.add(findIconType(tempByteArray));\n            } else {\n                icons.add(findIconType(tempByteArray));\n\n            }\n            //Read the sub-icon length\n            tempByteArray[0] = full_file[offset + 4];\n            tempByteArray[1] = full_file[offset + 5];\n            tempByteArray[2] = full_file[offset + 6];\n            tempByteArray[3] = full_file[offset + 7];\n            int icon_length = java.nio.ByteBuffer.wrap(tempByteArray).getInt();\n            offset = offset + icon_length;\n        }\n        String icon_details = \"\", iconmask_details = \"\", bitsPerPixel,dimensions;\n        for (ICNSType icon : icons) {\n             bitsPerPixel = (icon.getBitsPerPixel()!=0)?icon.getBitsPerPixel() + \" bpp\":\"JPEG 2000 or PNG format\";\n             dimensions = (!icon.hasRetinaDisplay())?(icon.getHeight() + \"x\" + icon.getWidth()):(icon.getHeight() + \"x\" + icon.getWidth() + \"@2X\");\n             icon_details = icon_details + \", \" + dimensions + \" (\" + bitsPerPixel + \")\";\n        }\n        for (ICNSType icon : icon_masks) {\n            iconmask_details = iconmask_details + \", \" + icon.getHeight() + \"x\" + icon.getWidth() + \" (\" + icon.getBitsPerPixel() + \" bpp\" + \")\";\n        }\n\n        metadata.set(Metadata.CONTENT_TYPE, ICNS_MIME_TYPE);\n        if (!icon_details.equals(\"\")) {\n            metadata.set(\"Icon count\", String.valueOf(icons.size()));\n            icon_details = icon_details.substring(2);\n            metadata.set(\"Icon details\", icon_details);\n        }\n        if (!iconmask_details.equals(\"\")) {\n            metadata.set(\"Masked icon count\", String.valueOf(icon_masks.size()));\n            iconmask_details = iconmask_details.substring(2);\n            metadata.set(\"Masked icon details\", iconmask_details);\n        }\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        xhtml.endDocument();\n    }", "code_tokens": ["public", "void", "parse", "(", "InputStream", "stream", ",", "ContentHandler", "handler", ",", "Metadata", "metadata", ",", "ParseContext", "context", ")", "throws", "IOException", ",", "SAXException", ",", "TikaException", "{", "byte", "[", "]", "header", "=", "new", "byte", "[", "4", "]", ";", "IOUtils", ".", "readFully", "(", "stream", ",", "header", ",", "0", ",", "4", ")", ";", "if", "(", "header", "[", "0", "]", "==", "(", "byte", ")", "'i'", "&&", "header", "[", "1", "]", "==", "(", "byte", ")", "'c'", "&&", "header", "[", "2", "]", "==", "(", "byte", ")", "'n'", "&&", "header", "[", "3", "]", "==", "(", "byte", ")", "'s'", ")", "{", "}", "else", "{", "throw", "new", "TikaException", "(", "\"", "ICNS magic signature invalid", "\"", ")", ";", "}", "IOUtils", ".", "readFully", "(", "stream", ",", "header", ",", "0", ",", "4", ")", ";", "int", "image_length", "=", "java", ".", "nio", ".", "ByteBuffer", ".", "wrap", "(", "header", ")", ".", "getInt", "(", ")", ";", "if", "(", "image_length", ">", "MAX_IMAGE_LENGTH_BYTES", ")", "{", "throw", "new", "TikaMemoryLimitException", "(", "image_length", ",", "MAX_IMAGE_LENGTH_BYTES", ")", ";", "}", "byte", "[", "]", "full_file", "=", "new", "byte", "[", "image_length", "]", ";", "IOUtils", ".", "readFully", "(", "stream", ",", "full_file", ")", ";", "ArrayList", "<", "ICNSType", ">", "icons", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "ArrayList", "<", "ICNSType", ">", "icon_masks", "=", "new", "ArrayList", "<", ">", "(", ")", ";", "byte", "[", "]", "tempByteArray", "=", "new", "byte", "[", "4", "]", ";", "for", "(", "int", "offset", "=", "0", ";", "offset", "<", "image_length", "-", "8", ";", ")", "{", "tempByteArray", "[", "0", "]", "=", "full_file", "[", "offset", "]", ";", "tempByteArray", "[", "1", "]", "=", "full_file", "[", "offset", "+", "1", "]", ";", "tempByteArray", "[", "2", "]", "=", "full_file", "[", "offset", "+", "2", "]", ";", "tempByteArray", "[", "3", "]", "=", "full_file", "[", "offset", "+", "3", "]", ";", "ICNSType", "icnstype", "=", "findIconType", "(", "tempByteArray", ")", ";", "if", "(", "icnstype", "==", "null", ")", "{", "break", ";", "}", "else", "if", "(", "icnstype", ".", "hasMask", "(", ")", "==", "true", ")", "{", "icon_masks", ".", "add", "(", "findIconType", "(", "tempByteArray", ")", ")", ";", "}", "else", "{", "icons", ".", "add", "(", "findIconType", "(", "tempByteArray", ")", ")", ";", "}", "tempByteArray", "[", "0", "]", "=", "full_file", "[", "offset", "+", "4", "]", ";", "tempByteArray", "[", "1", "]", "=", "full_file", "[", "offset", "+", "5", "]", ";", "tempByteArray", "[", "2", "]", "=", "full_file", "[", "offset", "+", "6", "]", ";", "tempByteArray", "[", "3", "]", "=", "full_file", "[", "offset", "+", "7", "]", ";", "int", "icon_length", "=", "java", ".", "nio", ".", "ByteBuffer", ".", "wrap", "(", "tempByteArray", ")", ".", "getInt", "(", ")", ";", "offset", "=", "offset", "+", "icon_length", ";", "}", "String", "icon_details", "=", "\"", "\"", ",", "iconmask_details", "=", "\"", "\"", ",", "bitsPerPixel", ",", "dimensions", ";", "for", "(", "ICNSType", "icon", ":", "icons", ")", "{", "bitsPerPixel", "=", "(", "icon", ".", "getBitsPerPixel", "(", ")", "!=", "0", ")", "?", "icon", ".", "getBitsPerPixel", "(", ")", "+", "\"", " bpp", "\"", ":", "\"", "JPEG 2000 or PNG format", "\"", ";", "dimensions", "=", "(", "!", "icon", ".", "hasRetinaDisplay", "(", ")", ")", "?", "(", "icon", ".", "getHeight", "(", ")", "+", "\"", "x", "\"", "+", "icon", ".", "getWidth", "(", ")", ")", ":", "(", "icon", ".", "getHeight", "(", ")", "+", "\"", "x", "\"", "+", "icon", ".", "getWidth", "(", ")", "+", "\"", "@2X", "\"", ")", ";", "icon_details", "=", "icon_details", "+", "\"", ", ", "\"", "+", "dimensions", "+", "\"", " (", "\"", "+", "bitsPerPixel", "+", "\"", ")", "\"", ";", "}", "for", "(", "ICNSType", "icon", ":", "icon_masks", ")", "{", "iconmask_details", "=", "iconmask_details", "+", "\"", ", ", "\"", "+", "icon", ".", "getHeight", "(", ")", "+", "\"", "x", "\"", "+", "icon", ".", "getWidth", "(", ")", "+", "\"", " (", "\"", "+", "icon", ".", "getBitsPerPixel", "(", ")", "+", "\"", " bpp", "\"", "+", "\"", ")", "\"", ";", "}", "metadata", ".", "set", "(", "Metadata", ".", "CONTENT_TYPE", ",", "ICNS_MIME_TYPE", ")", ";", "if", "(", "!", "icon_details", ".", "equals", "(", "\"", "\"", ")", ")", "{", "metadata", ".", "set", "(", "\"", "Icon count", "\"", ",", "String", ".", "valueOf", "(", "icons", ".", "size", "(", ")", ")", ")", ";", "icon_details", "=", "icon_details", ".", "substring", "(", "2", ")", ";", "metadata", ".", "set", "(", "\"", "Icon details", "\"", ",", "icon_details", ")", ";", "}", "if", "(", "!", "iconmask_details", ".", "equals", "(", "\"", "\"", ")", ")", "{", "metadata", ".", "set", "(", "\"", "Masked icon count", "\"", ",", "String", ".", "valueOf", "(", "icon_masks", ".", "size", "(", ")", ")", ")", ";", "iconmask_details", "=", "iconmask_details", ".", "substring", "(", "2", ")", ";", "metadata", ".", "set", "(", "\"", "Masked icon details", "\"", ",", "iconmask_details", ")", ";", "}", "XHTMLContentHandler", "xhtml", "=", "new", "XHTMLContentHandler", "(", "handler", ",", "metadata", ")", ";", "xhtml", ".", "startDocument", "(", ")", ";", "xhtml", ".", "endDocument", "(", ")", ";", "}"], "idx": 83412, "cwe": "CWE-835", "target": 1, "status": "VULNERABLE", "commit": "f9607f9", "function_name": "parse", "body_hash": "000368edda2e9ce476a59252d453e861bb7a5c7b"}
{"code": "private void initialize() throws TransformerFactoryConfigurationError, TransformerConfigurationException,\n            ParserConfigurationException {\n        if (!xslIsInitialized) {\n            TransformerFactory transformerFactory = createTransformer();\n\n            nunitTransformer = transformerFactory.newTransformer(new StreamSource(this.getClass().getResourceAsStream(NUNIT_TO_JUNIT_XSLFILE_STR)));\n            writerTransformer = transformerFactory.newTransformer();\n\n            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n            xmlDocumentBuilder = factory.newDocumentBuilder();\n\n            xslIsInitialized = true;\n        }\n    }", "code_tokens": ["private", "void", "initialize", "(", ")", "throws", "TransformerFactoryConfigurationError", ",", "TransformerConfigurationException", ",", "ParserConfigurationException", "{", "if", "(", "!", "xslIsInitialized", ")", "{", "TransformerFactory", "transformerFactory", "=", "createTransformer", "(", ")", ";", "nunitTransformer", "=", "transformerFactory", ".", "newTransformer", "(", "new", "StreamSource", "(", "this", ".", "getClass", "(", ")", ".", "getResourceAsStream", "(", "NUNIT_TO_JUNIT_XSLFILE_STR", ")", ")", ")", ";", "writerTransformer", "=", "transformerFactory", ".", "newTransformer", "(", ")", ";", "DocumentBuilderFactory", "factory", "=", "createDocumentBuilderFactory", "(", ")", ";", "xmlDocumentBuilder", "=", "factory", ".", "newDocumentBuilder", "(", ")", ";", "xslIsInitialized", "=", "true", ";", "}", "}"], "idx": 69782, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "8f0b6a7", "function_name": "initialize", "body_hash": "b6618f5b275a97e2a81c2675f25b791227020266"}
{"code": "@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\tif (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse)\n\t\t\t\t|| getNodesCollector().isMonitoringDisabled()) {\n\t\t\tsuper.doFilter(request, response, chain);\n\t\t\treturn;\n\t\t}\n\t\tfinal HttpServletRequest httpRequest = (HttpServletRequest) request;\n\n\t\tfinal String requestURI = httpRequest.getRequestURI();\n\t\tfinal String monitoringUrl = getMonitoringUrl(httpRequest);\n\t\tfinal String monitoringSlavesUrl = monitoringUrl + \"/nodes\";\n\t\tif (!PLUGIN_AUTHENTICATION_DISABLED\n\t\t\t\t&& (requestURI.equals(monitoringUrl) || requestURI.startsWith(monitoringSlavesUrl))) {\n\t\t\t// only the Hudson/Jenkins administrator can view the monitoring report\n\t\t\tJenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n            Enumeration<?> parameterNames = request.getParameterNames();\n            while (parameterNames.hasMoreElements()) {\n                String parameterName = (String) parameterNames.nextElement();\n                for (String value : request.getParameterValues(parameterName)) {\n                    if (value.indexOf('\"') != -1 || value.indexOf('\\'') != -1 || value.indexOf('<') != -1 || value.indexOf('&') != -1) {\n                        ((HttpServletResponse) response).sendError(HttpServletResponse.SC_BAD_REQUEST);\n                        return;\n                    }\n                }\n            }\n\t\t}\n\n\t\tif (requestURI.startsWith(monitoringSlavesUrl)) {\n\t\t\tfinal String nodeName;\n\t\t\tif (requestURI.equals(monitoringSlavesUrl)) {\n\t\t\t\tnodeName = null;\n\t\t\t} else {\n\t\t\t\tnodeName = requestURI.substring(monitoringSlavesUrl.length()).replace(\"/\", \"\");\n\t\t\t}\n\t\t\tfinal HttpServletResponse httpResponse = (HttpServletResponse) response;\n\t\t\tdoMonitoring(httpRequest, httpResponse, nodeName);\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.doFilter(request, response, chain);\n\t}", "code_tokens": ["@", "Override", "public", "void", "doFilter", "(", "ServletRequest", "request", ",", "ServletResponse", "response", ",", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "if", "(", "!", "(", "request", "instanceof", "HttpServletRequest", ")", "||", "!", "(", "response", "instanceof", "HttpServletResponse", ")", "||", "getNodesCollector", "(", ")", ".", "isMonitoringDisabled", "(", ")", ")", "{", "super", ".", "doFilter", "(", "request", ",", "response", ",", "chain", ")", ";", "return", ";", "}", "final", "HttpServletRequest", "httpRequest", "=", "(", "HttpServletRequest", ")", "request", ";", "final", "String", "requestURI", "=", "httpRequest", ".", "getRequestURI", "(", ")", ";", "final", "String", "monitoringUrl", "=", "getMonitoringUrl", "(", "httpRequest", ")", ";", "final", "String", "monitoringSlavesUrl", "=", "monitoringUrl", "+", "\"", "/nodes", "\"", ";", "if", "(", "!", "PLUGIN_AUTHENTICATION_DISABLED", "&&", "(", "requestURI", ".", "equals", "(", "monitoringUrl", ")", "||", "requestURI", ".", "startsWith", "(", "monitoringSlavesUrl", ")", ")", ")", "{", "Jenkins", ".", "getInstance", "(", ")", ".", "checkPermission", "(", "Jenkins", ".", "ADMINISTER", ")", ";", "Enumeration", "<", "?", ">", "parameterNames", "=", "request", ".", "getParameterNames", "(", ")", ";", "while", "(", "parameterNames", ".", "hasMoreElements", "(", ")", ")", "{", "String", "parameterName", "=", "(", "String", ")", "parameterNames", ".", "nextElement", "(", ")", ";", "for", "(", "String", "value", ":", "request", ".", "getParameterValues", "(", "parameterName", ")", ")", "{", "if", "(", "value", ".", "indexOf", "(", "'\"'", ")", "!=", "-", "1", "||", "value", ".", "indexOf", "(", "'\\''", ")", "!=", "-", "1", "||", "value", ".", "indexOf", "(", "'<'", ")", "!=", "-", "1", "||", "value", ".", "indexOf", "(", "'&'", ")", "!=", "-", "1", ")", "{", "(", "(", "HttpServletResponse", ")", "response", ")", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "}", "}", "}", "if", "(", "requestURI", ".", "startsWith", "(", "monitoringSlavesUrl", ")", ")", "{", "final", "String", "nodeName", ";", "if", "(", "requestURI", ".", "equals", "(", "monitoringSlavesUrl", ")", ")", "{", "nodeName", "=", "null", ";", "}", "else", "{", "nodeName", "=", "requestURI", ".", "substring", "(", "monitoringSlavesUrl", ".", "length", "(", ")", ")", ".", "replace", "(", "\"", "/", "\"", ",", "\"", "\"", ")", ";", "}", "final", "HttpServletResponse", "httpResponse", "=", "(", "HttpServletResponse", ")", "response", ";", "doMonitoring", "(", "httpRequest", ",", "httpResponse", ",", "nodeName", ")", ";", "return", ";", "}", "super", ".", "doFilter", "(", "request", ",", "response", ",", "chain", ")", ";", "}"], "idx": 80987, "cwe": "CWE-79", "target": 0, "status": "FIXED", "commit": "f0f6aeef2032696c97d4b015dd51fa2b841b0473", "function_name": "doFilter", "body_hash": "ea7aea2db0d833c45bc89c7abf65438d5ac6526e"}
{"code": "@Override\n    public String getWhyKeepLog() {\n        // if any of the downstream project is configured with 'keep dependency component',\n        // we need to keep this log\n        OUTER:\n        for (AbstractProject<?,?> p : getParent().getDownstreamProjects()) {\n            if (!p.isKeepDependencies()) continue;\n\n            AbstractBuild<?,?> fb = p.getFirstBuild();\n            if (fb==null)        continue; // no active record\n\n            // is there any active build that depends on us?\n            for (int i : getDownstreamRelationship(p).listNumbersReverse()) {\n                // TODO: this is essentially a \"find intersection between two sparse sequences\"\n                // and we should be able to do much better.\n\n                if (i<fb.getNumber())\n                    continue OUTER; // all the other records are younger than the first record, so pointless to search.\n\n                AbstractBuild<?,?> b = p.getBuildByNumber(i);\n                if (b!=null)\n                    return Messages.AbstractBuild_KeptBecause(b);\n            }\n        }\n\n        return super.getWhyKeepLog();\n    }", "code_tokens": ["@", "Override", "public", "String", "getWhyKeepLog", "(", ")", "{", "OUTER", ":", "for", "(", "AbstractProject", "<", "?", ",", "?", ">", "p", ":", "getParent", "(", ")", ".", "getDownstreamProjects", "(", ")", ")", "{", "if", "(", "!", "p", ".", "isKeepDependencies", "(", ")", ")", "continue", ";", "AbstractBuild", "<", "?", ",", "?", ">", "fb", "=", "p", ".", "getFirstBuild", "(", ")", ";", "if", "(", "fb", "==", "null", ")", "continue", ";", "for", "(", "int", "i", ":", "getDownstreamRelationship", "(", "p", ")", ".", "listNumbersReverse", "(", ")", ")", "{", "if", "(", "i", "<", "fb", ".", "getNumber", "(", ")", ")", "continue", "OUTER", ";", "AbstractBuild", "<", "?", ",", "?", ">", "b", "=", "p", ".", "getBuildByNumber", "(", "i", ")", ";", "if", "(", "b", "!=", "null", ")", "return", "Messages", ".", "AbstractBuild_KeptBecause", "(", "b", ")", ";", "}", "}", "return", "super", ".", "getWhyKeepLog", "(", ")", ";", "}"], "idx": 84492, "cwe": "CWE-862", "target": 1, "status": "VULNERABLE", "commit": "b2083a387a5bdb6f7ee7f7c81a1f6312aca2a558", "function_name": "getWhyKeepLog", "body_hash": "d9121b30780e3e6ff024d1b27de34d65f8142eb1"}
{"code": "Augmentations handleStartElement(QName element, XMLAttributes attributes, Augmentations augs) {\n\n        if (DEBUG) {\n            System.out.println(\"==>handleStartElement: \" + element);\n        }\n\n        // root element\n        if (fElementDepth == -1 && fValidationManager.isGrammarFound()) {\n            if (fSchemaType == null) {\n                // schemaType is not specified\n                // if a DTD grammar is found, we do the same thing as Dynamic:\n                // if a schema grammar is found, validation is performed;\n                // otherwise, skip the whole document.\n                fSchemaDynamicValidation = true;\n            } else {\n                // [1] Either schemaType is DTD, and in this case validate/schema is turned off\n                // [2] Validating against XML Schemas only\n                //   [a] dynamic validation is false: report error if SchemaGrammar is not found\n                //   [b] dynamic validation is true: if grammar is not found ignore.\n            }\n\n        }\n\n        // get xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes,\n        // parse them to get the grammars. But only do this if the grammar can grow.\n        if (!fUseGrammarPoolOnly) {\n            String sLocation =\n                attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_SCHEMALOCATION);\n            String nsLocation =\n                attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION);\n            //store the location hints..  we need to do it so that we can defer the loading of grammar until\n            //there is a reference to a component from that namespace. To provide location hints to the\n            //application for a namespace\n            storeLocations(sLocation, nsLocation);\n        }\n\n        // if we are in the content of \"skip\", then just skip this element\n        // REVISIT:  is this the correct behaviour for ID constraints?  -NG\n        if (fSkipValidationDepth >= 0) {\n            fElementDepth++;\n            if (fAugPSVI)\n            \taugs = getEmptyAugs(augs);\n            return augs;\n        }\n\n        // if we are not skipping this element, and there is a content model,\n        // we try to find the corresponding decl object for this element.\n        // the reason we move this part of code here is to make sure the\n        // error reported here (if any) is stored within the parent element's\n        // context, instead of that of the current element.\n        Object decl = null;\n        if (fCurrentCM != null) {\n            decl = fCurrentCM.oneTransition(element, fCurrCMState, fSubGroupHandler);\n            // it could be an element decl or a wildcard decl\n            if (fCurrCMState[0] == XSCMValidator.FIRST_ERROR) {\n                XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n                //REVISIT: is it the only case we will have particle = null?\n                Vector next;\n                if (ctype.fParticle != null\n                    && (next = fCurrentCM.whatCanGoHere(fCurrCMState)).size() > 0) {\n                    String expected = expectedStr(next);\n                    final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);\n                    String elemExpandedQname = (element.uri != null) ? \"{\"+'\"'+element.uri+'\"'+\":\"+element.localpart+\"}\" : element.localpart;\n                    if (occurenceInfo != null) {\n                        final int minOccurs = occurenceInfo[0];\n                        final int maxOccurs = occurenceInfo[1];\n                        final int count = occurenceInfo[2];\n                        // Check if this is a violation of minOccurs\n                        if (count < minOccurs) {\n                            final int required = minOccurs - count;\n                            if (required > 1) {\n                                reportSchemaError(\"cvc-complex-type.2.4.h\", new Object[] { element.rawname, \n                                        fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs), Integer.toString(required) });\n                            }\n                            else {\n                                reportSchemaError(\"cvc-complex-type.2.4.g\", new Object[] { element.rawname, \n                                        fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs) });\n                            }\n                        }\n                        // Check if this is a violation of maxOccurs\n                        else if (count >= maxOccurs && maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {\n                            reportSchemaError(\"cvc-complex-type.2.4.e\", new Object[] { element.rawname, \n                                    expected, Integer.toString(maxOccurs) });\n                        }\n                        else {\n                            reportSchemaError(\"cvc-complex-type.2.4.a\", new Object[] { elemExpandedQname, expected });\n                        }\n                    }\n                    else {\n                        reportSchemaError(\"cvc-complex-type.2.4.a\", new Object[] { elemExpandedQname, expected });\n                    }\n                }\n                else {\n                    final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);\n                    if (occurenceInfo != null) {\n                        final int maxOccurs = occurenceInfo[1];\n                        final int count = occurenceInfo[2];\n                        // Check if this is a violation of maxOccurs\n                        if (count >= maxOccurs && maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {\n                            reportSchemaError(\"cvc-complex-type.2.4.f\", new Object[] { fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(maxOccurs) });\n                        }\n                        else {\n                            reportSchemaError(\"cvc-complex-type.2.4.d\", new Object[] { element.rawname });\n                        }\n                    }\n                    else {\n                        reportSchemaError(\"cvc-complex-type.2.4.d\", new Object[] { element.rawname });\n                    }\n                }\n            }\n        }\n\n        // if it's not the root element, we push the current states in the stacks\n        if (fElementDepth != -1) {\n            ensureStackCapacity();\n            fSubElementStack[fElementDepth] = true;\n            fSubElement = false;\n            fElemDeclStack[fElementDepth] = fCurrentElemDecl;\n            fNilStack[fElementDepth] = fNil;\n            fNotationStack[fElementDepth] = fNotation;\n            fTypeStack[fElementDepth] = fCurrentType;\n            fStrictAssessStack[fElementDepth] = fStrictAssess;\n            fCMStack[fElementDepth] = fCurrentCM;\n            fCMStateStack[fElementDepth] = fCurrCMState;\n            fSawTextStack[fElementDepth] = fSawText;\n            fStringContent[fElementDepth] = fSawCharacters;\n        }\n\n        // increase the element depth after we've saved\n        // all states for the parent element\n        fElementDepth++;\n        fCurrentElemDecl = null;\n        XSWildcardDecl wildcard = null;\n        fCurrentType = null;\n        fStrictAssess = true;\n        fNil = false;\n        fNotation = null;\n\n        // and the buffer to hold the value of the element\n        fBuffer.setLength(0);\n        fSawText = false;\n        fSawCharacters = false;\n\n        // check what kind of declaration the \"decl\" from\n        // oneTransition() maps to\n        if (decl != null) {\n            if (decl instanceof XSElementDecl) {\n                fCurrentElemDecl = (XSElementDecl) decl;\n            } else {\n                wildcard = (XSWildcardDecl) decl;\n            }\n        }\n\n        // if the wildcard is skip, then return\n        if (wildcard != null && wildcard.fProcessContents == XSWildcardDecl.PC_SKIP) {\n            fSkipValidationDepth = fElementDepth;\n            if (fAugPSVI)\n                augs = getEmptyAugs(augs);\n            return augs;\n        }\n        \n        if (fElementDepth == 0) {\n            // 1.1.1.1 An element declaration was stipulated by the processor\n            if (fRootElementDeclaration != null) {\n                fCurrentElemDecl = fRootElementDeclaration;\n                checkElementMatchesRootElementDecl(fCurrentElemDecl, element);\n            }\n            else if (fRootElementDeclQName != null) {\n                processRootElementDeclQName(fRootElementDeclQName, element);\n            }\n            // 1.2.1.1 A type definition was stipulated by the processor\n            else if (fRootTypeDefinition != null) {\n                fCurrentType = fRootTypeDefinition;\n            }\n            else if (fRootTypeQName != null) {\n                processRootTypeQName(fRootTypeQName);\n            }\n        }\n        \n        // if there was no processor stipulated type\n        if (fCurrentType == null) {\n            // try again to get the element decl:\n            // case 1: find declaration for root element\n            // case 2: find declaration for element from another namespace\n            if (fCurrentElemDecl == null) {\n                // try to find schema grammar by different means..\n                SchemaGrammar sGrammar =\n                    findSchemaGrammar(\n                        XSDDescription.CONTEXT_ELEMENT,\n                        element.uri,\n                        null,\n                        element,\n                        attributes);\n                if (sGrammar != null) {\n                    fCurrentElemDecl = sGrammar.getGlobalElementDecl(element.localpart);\n                }\n            }\n            \n            if (fCurrentElemDecl != null) {\n                // then get the type\n                fCurrentType = fCurrentElemDecl.fType;\n            }\n        }\n        \n        // check if we should be ignoring xsi:type on this element\n        if (fElementDepth == fIgnoreXSITypeDepth && fCurrentElemDecl == null) {\n            fIgnoreXSITypeDepth++;\n        }\n        \n        // process xsi:type attribute information\n        String xsiType = null;\n        if (fElementDepth >= fIgnoreXSITypeDepth) {\n            xsiType = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_TYPE);\n        }\n        \n        // if no decl/type found for the current element\n        if (fCurrentType == null && xsiType == null) {\n            // if this is the validation root, report an error, because\n            // we can't find eith decl or type for this element\n            // REVISIT: should we report error, or warning?\n            if (fElementDepth == 0) {\n                // for dynamic validation, skip the whole content,\n                // because no grammar was found.\n                if (fDynamicValidation || fSchemaDynamicValidation) {\n                    // no schema grammar was found, but it's either dynamic\n                    // validation, or another kind of grammar was found (DTD,\n                    // for example). The intended behavior here is to skip\n                    // the whole document. To improve performance, we try to\n                    // remove the validator from the pipeline, since it's not\n                    // supposed to do anything.\n                    if (fDocumentSource != null) {\n                        fDocumentSource.setDocumentHandler(fDocumentHandler);\n                        if (fDocumentHandler != null)\n                            fDocumentHandler.setDocumentSource(fDocumentSource);\n                        // indicate that the validator was removed.\n                        fElementDepth = -2;\n                        return augs;\n                    }\n\n                    fSkipValidationDepth = fElementDepth;\n                    if (fAugPSVI)\n                        augs = getEmptyAugs(augs);\n                    return augs;\n                }\n                // We don't call reportSchemaError here, because the spec\n                // doesn't think it's invalid not to be able to find a\n                // declaration or type definition for an element. Xerces is\n                // reporting it as an error for historical reasons, but in\n                // PSVI, we shouldn't mark this element as invalid because\n                // of this. - SG\n                fXSIErrorReporter.fErrorReporter.reportError(\n                    XSMessageFormatter.SCHEMA_DOMAIN,\n                    \"cvc-elt.1.a\",\n                    new Object[] { element.rawname },\n                    XMLErrorReporter.SEVERITY_ERROR);\n            }\n            // if wildcard = strict, report error.\n            // needs to be called before fXSIErrorReporter.pushContext()\n            // so that the error belongs to the parent element.\n            else if (wildcard != null && wildcard.fProcessContents == XSWildcardDecl.PC_STRICT) {\n                // report error, because wilcard = strict\n                reportSchemaError(\"cvc-complex-type.2.4.c\", new Object[] { element.rawname });\n            }\n            // no element decl or type found for this element.\n            // Allowed by the spec, we can choose to either laxly assess this\n            // element, or to skip it. Now we choose lax assessment.\n            fCurrentType = SchemaGrammar.fAnyType;\n            fStrictAssess = false;\n            fNFullValidationDepth = fElementDepth;\n            // any type has mixed content, so we don't need to append buffer\n            fAppendBuffer = false;\n\n            // push error reporter context: record the current position\n            // This has to happen after we process skip contents,\n            // otherwise push and pop won't be correctly paired.\n            fXSIErrorReporter.pushContext();\n        } else {\n            // push error reporter context: record the current position\n            // This has to happen after we process skip contents,\n            // otherwise push and pop won't be correctly paired.\n            fXSIErrorReporter.pushContext();\n\n            // get xsi:type\n            if (xsiType != null) {\n                XSTypeDefinition oldType = fCurrentType;\n                fCurrentType = getAndCheckXsiType(element, xsiType, attributes);\n                // If it fails, use the old type. Use anyType if ther is no old type.\n                if (fCurrentType == null) {\n                    if (oldType == null)\n                        fCurrentType = SchemaGrammar.fAnyType;\n                    else\n                        fCurrentType = oldType;\n                }\n            }\n\n            fNNoneValidationDepth = fElementDepth;\n            // if the element has a fixed value constraint, we need to append\n            if (fCurrentElemDecl != null\n                && fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED) {\n                fAppendBuffer = true;\n            }\n            // if the type is simple, we need to append\n            else if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {\n                fAppendBuffer = true;\n            } else {\n                // if the type is simple content complex type, we need to append\n                XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n                fAppendBuffer = (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE);\n            }\n        }\n\n        // Element Locally Valid (Element)\n        // 2 Its {abstract} must be false.\n        if (fCurrentElemDecl != null && fCurrentElemDecl.getAbstract())\n            reportSchemaError(\"cvc-elt.2\", new Object[] { element.rawname });\n\n        // make the current element validation root\n        if (fElementDepth == 0) {\n            fValidationRoot = element.rawname;\n        }\n\n        // update normalization flags\n        if (fNormalizeData) {\n            // reset values\n            fFirstChunk = true;\n            fTrailing = false;\n            fUnionType = false;\n            fWhiteSpace = -1;\n        }\n\n        // Element Locally Valid (Type)\n        // 2 Its {abstract} must be false.\n        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n            XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n            if (ctype.getAbstract()) {\n                reportSchemaError(\"cvc-type.2\", new Object[] { element.rawname });\n            }\n            if (fNormalizeData) {\n                // find out if the content type is simple and if variety is union\n                // to be able to do character normalization\n                if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {\n                    if (ctype.fXSSimpleType.getVariety() == XSSimpleType.VARIETY_UNION) {\n                        fUnionType = true;\n                    } else {\n                        try {\n                            fWhiteSpace = ctype.fXSSimpleType.getWhitespace();\n                        } catch (DatatypeException e) {\n                            // do nothing\n                        }\n                    }\n                }\n            }\n        }\n        // normalization: simple type\n        else if (fNormalizeData) {\n            // if !union type\n            XSSimpleType dv = (XSSimpleType) fCurrentType;\n            if (dv.getVariety() == XSSimpleType.VARIETY_UNION) {\n                fUnionType = true;\n            } else {\n                try {\n                    fWhiteSpace = dv.getWhitespace();\n                } catch (DatatypeException e) {\n                    // do nothing\n                }\n            }\n        }\n\n        // then try to get the content model\n        fCurrentCM = null;\n        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n            fCurrentCM = ((XSComplexTypeDecl) fCurrentType).getContentModel(fCMBuilder);\n        }\n\n        // and get the initial content model state\n        fCurrCMState = null;\n        if (fCurrentCM != null)\n            fCurrCMState = fCurrentCM.startContentModel();\n\n        // get information about xsi:nil\n        String xsiNil = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NIL);\n        // only deal with xsi:nil when there is an element declaration\n        if (xsiNil != null && fCurrentElemDecl != null)\n            fNil = getXsiNil(element, xsiNil);\n\n        // now validate everything related with the attributes\n        // first, get the attribute group\n        XSAttributeGroupDecl attrGrp = null;\n        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n            XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n            attrGrp = ctype.getAttrGrp();\n        }\n        \n        if (fIDCChecking) {\n            // activate identity constraints\n            fValueStoreCache.startElement();\n            fMatcherStack.pushContext();\n            //if (fCurrentElemDecl != null && fCurrentElemDecl.fIDCPos > 0 && !fIgnoreIDC) {\n            if (fCurrentElemDecl != null && fCurrentElemDecl.fIDCPos > 0) {\n                fIdConstraint = true;\n                // initialize when identity constrains are defined for the elem\n                fValueStoreCache.initValueStoresFor(fCurrentElemDecl, this);\n            }\n        }\n        processAttributes(element, attributes, attrGrp);\n\n        // add default attributes\n        if (attrGrp != null) {\n            addDefaultAttributes(element, attributes, attrGrp);\n        }\n\n        // call all active identity constraints\n        int count = fMatcherStack.getMatcherCount();\n        for (int i = 0; i < count; i++) {\n            XPathMatcher matcher = fMatcherStack.getMatcherAt(i);\n            matcher.startElement( element, attributes);\n        }\n\n        if (fAugPSVI) {\n            augs = getEmptyAugs(augs);\n\n            // PSVI: add validation context\n            fCurrentPSVI.fValidationContext = fValidationRoot;\n            // PSVI: add element declaration\n            fCurrentPSVI.fDeclaration = fCurrentElemDecl;\n            // PSVI: add element type\n            fCurrentPSVI.fTypeDecl = fCurrentType;\n            // PSVI: add notation attribute\n            fCurrentPSVI.fNotation = fNotation;\n            // PSVI: add nil\n            fCurrentPSVI.fNil = fNil;\n        }\n\n        return augs;\n\n    }", "code_tokens": ["Augmentations", "handleStartElement", "(", "QName", "element", ",", "XMLAttributes", "attributes", ",", "Augmentations", "augs", ")", "{", "if", "(", "DEBUG", ")", "{", "System", ".", "out", ".", "println", "(", "\"", "==>handleStartElement: ", "\"", "+", "element", ")", ";", "}", "if", "(", "fElementDepth", "==", "-", "1", "&&", "fValidationManager", ".", "isGrammarFound", "(", ")", ")", "{", "if", "(", "fSchemaType", "==", "null", ")", "{", "fSchemaDynamicValidation", "=", "true", ";", "}", "else", "{", "}", "}", "if", "(", "!", "fUseGrammarPoolOnly", ")", "{", "String", "sLocation", "=", "attributes", ".", "getValue", "(", "SchemaSymbols", ".", "URI_XSI", ",", "SchemaSymbols", ".", "XSI_SCHEMALOCATION", ")", ";", "String", "nsLocation", "=", "attributes", ".", "getValue", "(", "SchemaSymbols", ".", "URI_XSI", ",", "SchemaSymbols", ".", "XSI_NONAMESPACESCHEMALOCATION", ")", ";", "storeLocations", "(", "sLocation", ",", "nsLocation", ")", ";", "}", "if", "(", "fSkipValidationDepth", ">=", "0", ")", "{", "fElementDepth", "++", ";", "if", "(", "fAugPSVI", ")", "augs", "=", "getEmptyAugs", "(", "augs", ")", ";", "return", "augs", ";", "}", "Object", "decl", "=", "null", ";", "if", "(", "fCurrentCM", "!=", "null", ")", "{", "decl", "=", "fCurrentCM", ".", "oneTransition", "(", "element", ",", "fCurrCMState", ",", "fSubGroupHandler", ")", ";", "if", "(", "fCurrCMState", "[", "0", "]", "==", "XSCMValidator", ".", "FIRST_ERROR", ")", "{", "XSComplexTypeDecl", "ctype", "=", "(", "XSComplexTypeDecl", ")", "fCurrentType", ";", "Vector", "next", ";", "if", "(", "ctype", ".", "fParticle", "!=", "null", "&&", "(", "next", "=", "fCurrentCM", ".", "whatCanGoHere", "(", "fCurrCMState", ")", ")", ".", "size", "(", ")", ">", "0", ")", "{", "String", "expected", "=", "expectedStr", "(", "next", ")", ";", "final", "int", "[", "]", "occurenceInfo", "=", "fCurrentCM", ".", "occurenceInfo", "(", "fCurrCMState", ")", ";", "String", "elemExpandedQname", "=", "(", "element", ".", "uri", "!=", "null", ")", "?", "\"", "{", "\"", "+", "'\"'", "+", "element", ".", "uri", "+", "'\"'", "+", "\"", ":", "\"", "+", "element", ".", "localpart", "+", "\"", "}", "\"", ":", "element", ".", "localpart", ";", "if", "(", "occurenceInfo", "!=", "null", ")", "{", "final", "int", "minOccurs", "=", "occurenceInfo", "[", "0", "]", ";", "final", "int", "maxOccurs", "=", "occurenceInfo", "[", "1", "]", ";", "final", "int", "count", "=", "occurenceInfo", "[", "2", "]", ";", "if", "(", "count", "<", "minOccurs", ")", "{", "final", "int", "required", "=", "minOccurs", "-", "count", ";", "if", "(", "required", ">", "1", ")", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.h", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", ",", "fCurrentCM", ".", "getTermName", "(", "occurenceInfo", "[", "3", "]", ")", ",", "Integer", ".", "toString", "(", "minOccurs", ")", ",", "Integer", ".", "toString", "(", "required", ")", "}", ")", ";", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.g", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", ",", "fCurrentCM", ".", "getTermName", "(", "occurenceInfo", "[", "3", "]", ")", ",", "Integer", ".", "toString", "(", "minOccurs", ")", "}", ")", ";", "}", "}", "else", "if", "(", "count", ">=", "maxOccurs", "&&", "maxOccurs", "!=", "SchemaSymbols", ".", "OCCURRENCE_UNBOUNDED", ")", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.e", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", ",", "expected", ",", "Integer", ".", "toString", "(", "maxOccurs", ")", "}", ")", ";", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.a", "\"", ",", "new", "Object", "[", "]", "{", "elemExpandedQname", ",", "expected", "}", ")", ";", "}", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.a", "\"", ",", "new", "Object", "[", "]", "{", "elemExpandedQname", ",", "expected", "}", ")", ";", "}", "}", "else", "{", "final", "int", "[", "]", "occurenceInfo", "=", "fCurrentCM", ".", "occurenceInfo", "(", "fCurrCMState", ")", ";", "if", "(", "occurenceInfo", "!=", "null", ")", "{", "final", "int", "maxOccurs", "=", "occurenceInfo", "[", "1", "]", ";", "final", "int", "count", "=", "occurenceInfo", "[", "2", "]", ";", "if", "(", "count", ">=", "maxOccurs", "&&", "maxOccurs", "!=", "SchemaSymbols", ".", "OCCURRENCE_UNBOUNDED", ")", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.f", "\"", ",", "new", "Object", "[", "]", "{", "fCurrentCM", ".", "getTermName", "(", "occurenceInfo", "[", "3", "]", ")", ",", "Integer", ".", "toString", "(", "maxOccurs", ")", "}", ")", ";", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.d", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "}", "}", "else", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.d", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "}", "}", "}", "}", "if", "(", "fElementDepth", "!=", "-", "1", ")", "{", "ensureStackCapacity", "(", ")", ";", "fSubElementStack", "[", "fElementDepth", "]", "=", "true", ";", "fSubElement", "=", "false", ";", "fElemDeclStack", "[", "fElementDepth", "]", "=", "fCurrentElemDecl", ";", "fNilStack", "[", "fElementDepth", "]", "=", "fNil", ";", "fNotationStack", "[", "fElementDepth", "]", "=", "fNotation", ";", "fTypeStack", "[", "fElementDepth", "]", "=", "fCurrentType", ";", "fStrictAssessStack", "[", "fElementDepth", "]", "=", "fStrictAssess", ";", "fCMStack", "[", "fElementDepth", "]", "=", "fCurrentCM", ";", "fCMStateStack", "[", "fElementDepth", "]", "=", "fCurrCMState", ";", "fSawTextStack", "[", "fElementDepth", "]", "=", "fSawText", ";", "fStringContent", "[", "fElementDepth", "]", "=", "fSawCharacters", ";", "}", "fElementDepth", "++", ";", "fCurrentElemDecl", "=", "null", ";", "XSWildcardDecl", "wildcard", "=", "null", ";", "fCurrentType", "=", "null", ";", "fStrictAssess", "=", "true", ";", "fNil", "=", "false", ";", "fNotation", "=", "null", ";", "fBuffer", ".", "setLength", "(", "0", ")", ";", "fSawText", "=", "false", ";", "fSawCharacters", "=", "false", ";", "if", "(", "decl", "!=", "null", ")", "{", "if", "(", "decl", "instanceof", "XSElementDecl", ")", "{", "fCurrentElemDecl", "=", "(", "XSElementDecl", ")", "decl", ";", "}", "else", "{", "wildcard", "=", "(", "XSWildcardDecl", ")", "decl", ";", "}", "}", "if", "(", "wildcard", "!=", "null", "&&", "wildcard", ".", "fProcessContents", "==", "XSWildcardDecl", ".", "PC_SKIP", ")", "{", "fSkipValidationDepth", "=", "fElementDepth", ";", "if", "(", "fAugPSVI", ")", "augs", "=", "getEmptyAugs", "(", "augs", ")", ";", "return", "augs", ";", "}", "if", "(", "fElementDepth", "==", "0", ")", "{", "if", "(", "fRootElementDeclaration", "!=", "null", ")", "{", "fCurrentElemDecl", "=", "fRootElementDeclaration", ";", "checkElementMatchesRootElementDecl", "(", "fCurrentElemDecl", ",", "element", ")", ";", "}", "else", "if", "(", "fRootElementDeclQName", "!=", "null", ")", "{", "processRootElementDeclQName", "(", "fRootElementDeclQName", ",", "element", ")", ";", "}", "else", "if", "(", "fRootTypeDefinition", "!=", "null", ")", "{", "fCurrentType", "=", "fRootTypeDefinition", ";", "}", "else", "if", "(", "fRootTypeQName", "!=", "null", ")", "{", "processRootTypeQName", "(", "fRootTypeQName", ")", ";", "}", "}", "if", "(", "fCurrentType", "==", "null", ")", "{", "if", "(", "fCurrentElemDecl", "==", "null", ")", "{", "SchemaGrammar", "sGrammar", "=", "findSchemaGrammar", "(", "XSDDescription", ".", "CONTEXT_ELEMENT", ",", "element", ".", "uri", ",", "null", ",", "element", ",", "attributes", ")", ";", "if", "(", "sGrammar", "!=", "null", ")", "{", "fCurrentElemDecl", "=", "sGrammar", ".", "getGlobalElementDecl", "(", "element", ".", "localpart", ")", ";", "}", "}", "if", "(", "fCurrentElemDecl", "!=", "null", ")", "{", "fCurrentType", "=", "fCurrentElemDecl", ".", "fType", ";", "}", "}", "if", "(", "fElementDepth", "==", "fIgnoreXSITypeDepth", "&&", "fCurrentElemDecl", "==", "null", ")", "{", "fIgnoreXSITypeDepth", "++", ";", "}", "String", "xsiType", "=", "null", ";", "if", "(", "fElementDepth", ">=", "fIgnoreXSITypeDepth", ")", "{", "xsiType", "=", "attributes", ".", "getValue", "(", "SchemaSymbols", ".", "URI_XSI", ",", "SchemaSymbols", ".", "XSI_TYPE", ")", ";", "}", "if", "(", "fCurrentType", "==", "null", "&&", "xsiType", "==", "null", ")", "{", "if", "(", "fElementDepth", "==", "0", ")", "{", "if", "(", "fDynamicValidation", "||", "fSchemaDynamicValidation", ")", "{", "if", "(", "fDocumentSource", "!=", "null", ")", "{", "fDocumentSource", ".", "setDocumentHandler", "(", "fDocumentHandler", ")", ";", "if", "(", "fDocumentHandler", "!=", "null", ")", "fDocumentHandler", ".", "setDocumentSource", "(", "fDocumentSource", ")", ";", "fElementDepth", "=", "-", "2", ";", "return", "augs", ";", "}", "fSkipValidationDepth", "=", "fElementDepth", ";", "if", "(", "fAugPSVI", ")", "augs", "=", "getEmptyAugs", "(", "augs", ")", ";", "return", "augs", ";", "}", "fXSIErrorReporter", ".", "fErrorReporter", ".", "reportError", "(", "XSMessageFormatter", ".", "SCHEMA_DOMAIN", ",", "\"", "cvc-elt.1.a", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ",", "XMLErrorReporter", ".", "SEVERITY_ERROR", ")", ";", "}", "else", "if", "(", "wildcard", "!=", "null", "&&", "wildcard", ".", "fProcessContents", "==", "XSWildcardDecl", ".", "PC_STRICT", ")", "{", "reportSchemaError", "(", "\"", "cvc-complex-type.2.4.c", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "}", "fCurrentType", "=", "SchemaGrammar", ".", "fAnyType", ";", "fStrictAssess", "=", "false", ";", "fNFullValidationDepth", "=", "fElementDepth", ";", "fAppendBuffer", "=", "false", ";", "fXSIErrorReporter", ".", "pushContext", "(", ")", ";", "}", "else", "{", "fXSIErrorReporter", ".", "pushContext", "(", ")", ";", "if", "(", "xsiType", "!=", "null", ")", "{", "XSTypeDefinition", "oldType", "=", "fCurrentType", ";", "fCurrentType", "=", "getAndCheckXsiType", "(", "element", ",", "xsiType", ",", "attributes", ")", ";", "if", "(", "fCurrentType", "==", "null", ")", "{", "if", "(", "oldType", "==", "null", ")", "fCurrentType", "=", "SchemaGrammar", ".", "fAnyType", ";", "else", "fCurrentType", "=", "oldType", ";", "}", "}", "fNNoneValidationDepth", "=", "fElementDepth", ";", "if", "(", "fCurrentElemDecl", "!=", "null", "&&", "fCurrentElemDecl", ".", "getConstraintType", "(", ")", "==", "XSConstants", ".", "VC_FIXED", ")", "{", "fAppendBuffer", "=", "true", ";", "}", "else", "if", "(", "fCurrentType", ".", "getTypeCategory", "(", ")", "==", "XSTypeDefinition", ".", "SIMPLE_TYPE", ")", "{", "fAppendBuffer", "=", "true", ";", "}", "else", "{", "XSComplexTypeDecl", "ctype", "=", "(", "XSComplexTypeDecl", ")", "fCurrentType", ";", "fAppendBuffer", "=", "(", "ctype", ".", "fContentType", "==", "XSComplexTypeDecl", ".", "CONTENTTYPE_SIMPLE", ")", ";", "}", "}", "if", "(", "fCurrentElemDecl", "!=", "null", "&&", "fCurrentElemDecl", ".", "getAbstract", "(", ")", ")", "reportSchemaError", "(", "\"", "cvc-elt.2", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "if", "(", "fElementDepth", "==", "0", ")", "{", "fValidationRoot", "=", "element", ".", "rawname", ";", "}", "if", "(", "fNormalizeData", ")", "{", "fFirstChunk", "=", "true", ";", "fTrailing", "=", "false", ";", "fUnionType", "=", "false", ";", "fWhiteSpace", "=", "-", "1", ";", "}", "if", "(", "fCurrentType", ".", "getTypeCategory", "(", ")", "==", "XSTypeDefinition", ".", "COMPLEX_TYPE", ")", "{", "XSComplexTypeDecl", "ctype", "=", "(", "XSComplexTypeDecl", ")", "fCurrentType", ";", "if", "(", "ctype", ".", "getAbstract", "(", ")", ")", "{", "reportSchemaError", "(", "\"", "cvc-type.2", "\"", ",", "new", "Object", "[", "]", "{", "element", ".", "rawname", "}", ")", ";", "}", "if", "(", "fNormalizeData", ")", "{", "if", "(", "ctype", ".", "fContentType", "==", "XSComplexTypeDecl", ".", "CONTENTTYPE_SIMPLE", ")", "{", "if", "(", "ctype", ".", "fXSSimpleType", ".", "getVariety", "(", ")", "==", "XSSimpleType", ".", "VARIETY_UNION", ")", "{", "fUnionType", "=", "true", ";", "}", "else", "{", "try", "{", "fWhiteSpace", "=", "ctype", ".", "fXSSimpleType", ".", "getWhitespace", "(", ")", ";", "}", "catch", "(", "DatatypeException", "e", ")", "{", "}", "}", "}", "}", "}", "else", "if", "(", "fNormalizeData", ")", "{", "XSSimpleType", "dv", "=", "(", "XSSimpleType", ")", "fCurrentType", ";", "if", "(", "dv", ".", "getVariety", "(", ")", "==", "XSSimpleType", ".", "VARIETY_UNION", ")", "{", "fUnionType", "=", "true", ";", "}", "else", "{", "try", "{", "fWhiteSpace", "=", "dv", ".", "getWhitespace", "(", ")", ";", "}", "catch", "(", "DatatypeException", "e", ")", "{", "}", "}", "}", "fCurrentCM", "=", "null", ";", "if", "(", "fCurrentType", ".", "getTypeCategory", "(", ")", "==", "XSTypeDefinition", ".", "COMPLEX_TYPE", ")", "{", "fCurrentCM", "=", "(", "(", "XSComplexTypeDecl", ")", "fCurrentType", ")", ".", "getContentModel", "(", "fCMBuilder", ")", ";", "}", "fCurrCMState", "=", "null", ";", "if", "(", "fCurrentCM", "!=", "null", ")", "fCurrCMState", "=", "fCurrentCM", ".", "startContentModel", "(", ")", ";", "String", "xsiNil", "=", "attributes", ".", "getValue", "(", "SchemaSymbols", ".", "URI_XSI", ",", "SchemaSymbols", ".", "XSI_NIL", ")", ";", "if", "(", "xsiNil", "!=", "null", "&&", "fCurrentElemDecl", "!=", "null", ")", "fNil", "=", "getXsiNil", "(", "element", ",", "xsiNil", ")", ";", "XSAttributeGroupDecl", "attrGrp", "=", "null", ";", "if", "(", "fCurrentType", ".", "getTypeCategory", "(", ")", "==", "XSTypeDefinition", ".", "COMPLEX_TYPE", ")", "{", "XSComplexTypeDecl", "ctype", "=", "(", "XSComplexTypeDecl", ")", "fCurrentType", ";", "attrGrp", "=", "ctype", ".", "getAttrGrp", "(", ")", ";", "}", "if", "(", "fIDCChecking", ")", "{", "fValueStoreCache", ".", "startElement", "(", ")", ";", "fMatcherStack", ".", "pushContext", "(", ")", ";", "if", "(", "fCurrentElemDecl", "!=", "null", "&&", "fCurrentElemDecl", ".", "fIDCPos", ">", "0", ")", "{", "fIdConstraint", "=", "true", ";", "fValueStoreCache", ".", "initValueStoresFor", "(", "fCurrentElemDecl", ",", "this", ")", ";", "}", "}", "processAttributes", "(", "element", ",", "attributes", ",", "attrGrp", ")", ";", "if", "(", "attrGrp", "!=", "null", ")", "{", "addDefaultAttributes", "(", "element", ",", "attributes", ",", "attrGrp", ")", ";", "}", "int", "count", "=", "fMatcherStack", ".", "getMatcherCount", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "{", "XPathMatcher", "matcher", "=", "fMatcherStack", ".", "getMatcherAt", "(", "i", ")", ";", "matcher", ".", "startElement", "(", "element", ",", "attributes", ")", ";", "}", "if", "(", "fAugPSVI", ")", "{", "augs", "=", "getEmptyAugs", "(", "augs", ")", ";", "fCurrentPSVI", ".", "fValidationContext", "=", "fValidationRoot", ";", "fCurrentPSVI", ".", "fDeclaration", "=", "fCurrentElemDecl", ";", "fCurrentPSVI", ".", "fTypeDecl", "=", "fCurrentType", ";", "fCurrentPSVI", ".", "fNotation", "=", "fNotation", ";", "fCurrentPSVI", ".", "fNil", "=", "fNil", ";", "}", "return", "augs", ";", "}"], "idx": 11595, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "76348d1f67c20a658ff47ba009762372a7a47300", "function_name": "handleStartElement", "body_hash": "41890476134f28dbad82993c716dc807caccc789"}
{"code": "@SuppressWarnings(\"resource\")\n    public static JMXConnectorServer createJMXServer(int port, boolean local)\n    throws IOException\n    {\n        Map<String, Object> env = new HashMap<>();\n\n        InetAddress serverAddress = null;\n        if (local)\n        {\n            serverAddress = InetAddress.getLoopbackAddress();\n            System.setProperty(\"java.rmi.server.hostname\", serverAddress.getHostAddress());\n        }\n\n        // Configure the RMI client & server socket factories, including SSL config.\n        env.putAll(configureJmxSocketFactories(serverAddress, local));\n\n        // configure the RMI registry to use the socket factories we just created\n        Registry registry = LocateRegistry.createRegistry(port,\n                                                          (RMIClientSocketFactory) env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),\n                                                          (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE));\n\n        // Configure authn, using a JMXAuthenticator which either wraps a set log LoginModules configured\n        // via a JAAS configuration entry, or one which delegates to the standard file based authenticator.\n        // Authn is disabled if com.sun.management.jmxremote.authenticate=false\n        env.putAll(configureJmxAuthentication());\n\n        // Configure authz - if a custom proxy class is specified an instance will be returned.\n        // If not, but a location for the standard access file is set in system properties, the\n        // return value is null, and an entry is added to the env map detailing that location\n        // If neither method is specified, no access control is applied\n        MBeanServerForwarder authzProxy = configureJmxAuthorization(env);\n\n        // Mark the JMX server as a permanently exported object. This allows the JVM to exit with the\n        // server running and also exempts it from the distributed GC scheduler which otherwise would\n        // potentially attempt a full GC every `sun.rmi.dgc.server.gcInterval` millis (default is 3600000ms)\n        // For more background see:\n        //   - CASSANDRA-2967\n        //   - https://www.jclarity.com/2015/01/27/rmi-system-gc-unplugged/\n        //   - https://bugs.openjdk.java.net/browse/JDK-6760712\n        env.put(\"jmx.remote.x.daemon\", \"true\");\n\n        // Set the port used to create subsequent connections to exported objects over RMI. This simplifies\n        // configuration in firewalled environments, but it can't be used in conjuction with SSL sockets.\n        // See: CASSANDRA-7087\n        int rmiPort = Integer.getInteger(\"com.sun.management.jmxremote.rmi.port\", 0);\n\n        // We create the underlying RMIJRMPServerImpl so that we can manually bind it to the registry,\n        // rather then specifying a binding address in the JMXServiceURL and letting it be done automatically\n        // when the server is started. The reason for this is that if the registry is configured with SSL\n        // sockets, the JMXConnectorServer acts as its client during the binding which means it needs to\n        // have a truststore configured which contains the registry's certificate. Manually binding removes\n        // this problem.\n        // See CASSANDRA-12109.\n        RMIJRMPServerImpl server = new RMIJRMPServerImpl(rmiPort,\n                                                         (RMIClientSocketFactory) env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),\n                                                         (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE),\n                                                         env);\n        JMXServiceURL serviceURL = new JMXServiceURL(\"rmi\", null, rmiPort);\n        RMIConnectorServer jmxServer = new RMIConnectorServer(serviceURL, env, server, ManagementFactory.getPlatformMBeanServer());\n\n        // If a custom authz proxy was created, attach it to the server now.\n        if (authzProxy != null)\n            jmxServer.setMBeanServerForwarder(authzProxy);\n        jmxServer.start();\n\n        registry.rebind(\"jmxrmi\", server);\n        logJmxServiceUrl(serverAddress, port);\n        return jmxServer;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "resource", "\"", ")", "public", "static", "JMXConnectorServer", "createJMXServer", "(", "int", "port", ",", "boolean", "local", ")", "throws", "IOException", "{", "Map", "<", "String", ",", "Object", ">", "env", "=", "new", "HashMap", "<", ">", "(", ")", ";", "InetAddress", "serverAddress", "=", "null", ";", "if", "(", "local", ")", "{", "serverAddress", "=", "InetAddress", ".", "getLoopbackAddress", "(", ")", ";", "System", ".", "setProperty", "(", "\"", "java.rmi.server.hostname", "\"", ",", "serverAddress", ".", "getHostAddress", "(", ")", ")", ";", "}", "env", ".", "putAll", "(", "configureJmxSocketFactories", "(", "serverAddress", ",", "local", ")", ")", ";", "Registry", "registry", "=", "LocateRegistry", ".", "createRegistry", "(", "port", ",", "(", "RMIClientSocketFactory", ")", "env", ".", "get", "(", "RMIConnectorServer", ".", "RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE", ")", ",", "(", "RMIServerSocketFactory", ")", "env", ".", "get", "(", "RMIConnectorServer", ".", "RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE", ")", ")", ";", "env", ".", "putAll", "(", "configureJmxAuthentication", "(", ")", ")", ";", "MBeanServerForwarder", "authzProxy", "=", "configureJmxAuthorization", "(", "env", ")", ";", "env", ".", "put", "(", "\"", "jmx.remote.x.daemon", "\"", ",", "\"", "true", "\"", ")", ";", "int", "rmiPort", "=", "Integer", ".", "getInteger", "(", "\"", "com.sun.management.jmxremote.rmi.port", "\"", ",", "0", ")", ";", "RMIJRMPServerImpl", "server", "=", "new", "RMIJRMPServerImpl", "(", "rmiPort", ",", "(", "RMIClientSocketFactory", ")", "env", ".", "get", "(", "RMIConnectorServer", ".", "RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE", ")", ",", "(", "RMIServerSocketFactory", ")", "env", ".", "get", "(", "RMIConnectorServer", ".", "RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE", ")", ",", "env", ")", ";", "JMXServiceURL", "serviceURL", "=", "new", "JMXServiceURL", "(", "\"", "rmi", "\"", ",", "null", ",", "rmiPort", ")", ";", "RMIConnectorServer", "jmxServer", "=", "new", "RMIConnectorServer", "(", "serviceURL", ",", "env", ",", "server", ",", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ")", ";", "if", "(", "authzProxy", "!=", "null", ")", "jmxServer", ".", "setMBeanServerForwarder", "(", "authzProxy", ")", ";", "jmxServer", ".", "start", "(", ")", ";", "registry", ".", "rebind", "(", "\"", "jmxrmi", "\"", ",", "server", ")", ";", "logJmxServiceUrl", "(", "serverAddress", ",", "port", ")", ";", "return", "jmxServer", ";", "}"], "idx": 41211, "cwe": "CWE-306", "target": 0, "status": "FIXED", "commit": "28ee665b3c0c9238b61a871064f024d54cddcc79", "function_name": "createJMXServer", "body_hash": "d06ce051f181787acf0adadeab50601054f9847c"}
{"code": "public TokenValidatorResponse validateToken(TokenValidatorParameters tokenParameters) {\n        LOG.fine(\"Validating SAML Token\");\n        STSPropertiesMBean stsProperties = tokenParameters.getStsProperties();\n        Crypto sigCrypto = stsProperties.getSignatureCrypto();\n        CallbackHandler callbackHandler = stsProperties.getCallbackHandler();\n        \n        TokenValidatorResponse response = new TokenValidatorResponse();\n        ReceivedToken validateTarget = tokenParameters.getToken();\n        validateTarget.setState(STATE.INVALID);\n        response.setToken(validateTarget);\n        \n        if (!validateTarget.isDOMElement()) {\n            return response;\n        }\n        \n        try {\n            Element validateTargetElement = (Element)validateTarget.getToken();\n            SamlAssertionWrapper assertion = new SamlAssertionWrapper(validateTargetElement);\n            \n            SAMLTokenPrincipal samlPrincipal = new SAMLTokenPrincipalImpl(assertion);\n            response.setPrincipal(samlPrincipal);\n            \n            if (!assertion.isSigned()) {\n                LOG.log(Level.WARNING, \"The received assertion is not signed, and therefore not trusted\");\n                return response;\n            }\n\n            RequestData requestData = new RequestData();\n            requestData.setSigVerCrypto(sigCrypto);\n            WSSConfig wssConfig = WSSConfig.getNewInstance();\n            requestData.setWssConfig(wssConfig);\n            requestData.setCallbackHandler(callbackHandler);\n            requestData.setMsgContext(tokenParameters.getWebServiceContext().getMessageContext());\n\n            WSDocInfo docInfo = new WSDocInfo(validateTargetElement.getOwnerDocument());\n\n            // Verify the signature\n            Signature sig = assertion.getSignature();\n            KeyInfo keyInfo = sig.getKeyInfo();\n            SAMLKeyInfo samlKeyInfo = \n                SAMLUtil.getCredentialFromKeyInfo(\n                    keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, docInfo), sigCrypto\n                );\n            assertion.verifySignature(samlKeyInfo);\n                \n            SecurityToken secToken = null;\n            byte[] signatureValue = assertion.getSignatureValue();\n            if (tokenParameters.getTokenStore() != null && signatureValue != null\n                && signatureValue.length > 0) {\n                int hash = Arrays.hashCode(signatureValue);\n                secToken = tokenParameters.getTokenStore().getToken(Integer.toString(hash));\n                if (secToken != null && secToken.getTokenHash() != hash) {\n                    secToken = null;\n                }\n            }\n            if (secToken != null && secToken.isExpired()) {\n                LOG.fine(\"Token: \" + secToken.getId() + \" is in the cache but expired - revalidating\");\n                secToken = null;\n            }\n            \n            if (secToken == null) {\n                // Validate the assertion against schemas/profiles\n                validateAssertion(assertion);\n\n                // Now verify trust on the signature\n                Credential trustCredential = new Credential();\n                trustCredential.setPublicKey(samlKeyInfo.getPublicKey());\n                trustCredential.setCertificates(samlKeyInfo.getCerts());\n    \n                trustCredential = validator.validate(trustCredential, requestData);\n\n                // Finally check that subject DN of the signing certificate matches a known constraint\n                X509Certificate cert = null;\n                if (trustCredential.getCertificates() != null) {\n                    cert = trustCredential.getCertificates()[0];\n                }\n                \n                if (!certConstraints.matches(cert)) {\n                    return response;\n                }\n            }\n            \n            // Parse roles from the validated token\n            if (samlRoleParser != null) {\n                Set<Principal> roles = \n                    samlRoleParser.parseRolesFromAssertion(samlPrincipal, null, assertion);\n                response.setRoles(roles);\n            }\n           \n            // Get the realm of the SAML token\n            String tokenRealm = null;\n            if (samlRealmCodec != null) {\n                tokenRealm = samlRealmCodec.getRealmFromToken(assertion);\n                // verify the realm against the cached token\n                if (secToken != null) {\n                    Properties props = secToken.getProperties();\n                    if (props != null) {\n                        String cachedRealm = props.getProperty(STSConstants.TOKEN_REALM);\n                        if (cachedRealm != null && !tokenRealm.equals(cachedRealm)) {\n                            return response;\n                        }\n                    }\n                }\n            }\n            response.setTokenRealm(tokenRealm);\n            \n            if (!validateConditions(assertion, validateTarget)) {\n                return response;\n            }\n            \n            // Store the successfully validated token in the cache\n            if (secToken == null) {\n                storeTokenInCache(\n                    tokenParameters.getTokenStore(), assertion, tokenParameters.getPrincipal(), tokenRealm\n                );\n            }\n            \n            // Add the SamlAssertionWrapper to the properties, as the claims are required to be transformed\n            Map<String, Object> addProps = new HashMap<String, Object>();\n            addProps.put(SamlAssertionWrapper.class.getName(), assertion);\n            response.setAdditionalProperties(addProps);\n            \n            validateTarget.setState(STATE.VALID);\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n        }\n\n        return response;\n    }", "code_tokens": ["public", "TokenValidatorResponse", "validateToken", "(", "TokenValidatorParameters", "tokenParameters", ")", "{", "LOG", ".", "fine", "(", "\"", "Validating SAML Token", "\"", ")", ";", "STSPropertiesMBean", "stsProperties", "=", "tokenParameters", ".", "getStsProperties", "(", ")", ";", "Crypto", "sigCrypto", "=", "stsProperties", ".", "getSignatureCrypto", "(", ")", ";", "CallbackHandler", "callbackHandler", "=", "stsProperties", ".", "getCallbackHandler", "(", ")", ";", "TokenValidatorResponse", "response", "=", "new", "TokenValidatorResponse", "(", ")", ";", "ReceivedToken", "validateTarget", "=", "tokenParameters", ".", "getToken", "(", ")", ";", "validateTarget", ".", "setState", "(", "STATE", ".", "INVALID", ")", ";", "response", ".", "setToken", "(", "validateTarget", ")", ";", "if", "(", "!", "validateTarget", ".", "isDOMElement", "(", ")", ")", "{", "return", "response", ";", "}", "try", "{", "Element", "validateTargetElement", "=", "(", "Element", ")", "validateTarget", ".", "getToken", "(", ")", ";", "SamlAssertionWrapper", "assertion", "=", "new", "SamlAssertionWrapper", "(", "validateTargetElement", ")", ";", "SAMLTokenPrincipal", "samlPrincipal", "=", "new", "SAMLTokenPrincipalImpl", "(", "assertion", ")", ";", "response", ".", "setPrincipal", "(", "samlPrincipal", ")", ";", "if", "(", "!", "assertion", ".", "isSigned", "(", ")", ")", "{", "LOG", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "The received assertion is not signed, and therefore not trusted", "\"", ")", ";", "return", "response", ";", "}", "RequestData", "requestData", "=", "new", "RequestData", "(", ")", ";", "requestData", ".", "setSigVerCrypto", "(", "sigCrypto", ")", ";", "WSSConfig", "wssConfig", "=", "WSSConfig", ".", "getNewInstance", "(", ")", ";", "requestData", ".", "setWssConfig", "(", "wssConfig", ")", ";", "requestData", ".", "setCallbackHandler", "(", "callbackHandler", ")", ";", "requestData", ".", "setMsgContext", "(", "tokenParameters", ".", "getWebServiceContext", "(", ")", ".", "getMessageContext", "(", ")", ")", ";", "WSDocInfo", "docInfo", "=", "new", "WSDocInfo", "(", "validateTargetElement", ".", "getOwnerDocument", "(", ")", ")", ";", "Signature", "sig", "=", "assertion", ".", "getSignature", "(", ")", ";", "KeyInfo", "keyInfo", "=", "sig", ".", "getKeyInfo", "(", ")", ";", "SAMLKeyInfo", "samlKeyInfo", "=", "SAMLUtil", ".", "getCredentialFromKeyInfo", "(", "keyInfo", ".", "getDOM", "(", ")", ",", "new", "WSSSAMLKeyInfoProcessor", "(", "requestData", ",", "docInfo", ")", ",", "sigCrypto", ")", ";", "assertion", ".", "verifySignature", "(", "samlKeyInfo", ")", ";", "SecurityToken", "secToken", "=", "null", ";", "byte", "[", "]", "signatureValue", "=", "assertion", ".", "getSignatureValue", "(", ")", ";", "if", "(", "tokenParameters", ".", "getTokenStore", "(", ")", "!=", "null", "&&", "signatureValue", "!=", "null", "&&", "signatureValue", ".", "length", ">", "0", ")", "{", "int", "hash", "=", "Arrays", ".", "hashCode", "(", "signatureValue", ")", ";", "secToken", "=", "tokenParameters", ".", "getTokenStore", "(", ")", ".", "getToken", "(", "Integer", ".", "toString", "(", "hash", ")", ")", ";", "if", "(", "secToken", "!=", "null", "&&", "secToken", ".", "getTokenHash", "(", ")", "!=", "hash", ")", "{", "secToken", "=", "null", ";", "}", "}", "if", "(", "secToken", "!=", "null", "&&", "secToken", ".", "isExpired", "(", ")", ")", "{", "LOG", ".", "fine", "(", "\"", "Token: ", "\"", "+", "secToken", ".", "getId", "(", ")", "+", "\"", " is in the cache but expired - revalidating", "\"", ")", ";", "secToken", "=", "null", ";", "}", "if", "(", "secToken", "==", "null", ")", "{", "validateAssertion", "(", "assertion", ")", ";", "Credential", "trustCredential", "=", "new", "Credential", "(", ")", ";", "trustCredential", ".", "setPublicKey", "(", "samlKeyInfo", ".", "getPublicKey", "(", ")", ")", ";", "trustCredential", ".", "setCertificates", "(", "samlKeyInfo", ".", "getCerts", "(", ")", ")", ";", "trustCredential", "=", "validator", ".", "validate", "(", "trustCredential", ",", "requestData", ")", ";", "X509Certificate", "cert", "=", "null", ";", "if", "(", "trustCredential", ".", "getCertificates", "(", ")", "!=", "null", ")", "{", "cert", "=", "trustCredential", ".", "getCertificates", "(", ")", "[", "0", "]", ";", "}", "if", "(", "!", "certConstraints", ".", "matches", "(", "cert", ")", ")", "{", "return", "response", ";", "}", "}", "if", "(", "samlRoleParser", "!=", "null", ")", "{", "Set", "<", "Principal", ">", "roles", "=", "samlRoleParser", ".", "parseRolesFromAssertion", "(", "samlPrincipal", ",", "null", ",", "assertion", ")", ";", "response", ".", "setRoles", "(", "roles", ")", ";", "}", "String", "tokenRealm", "=", "null", ";", "if", "(", "samlRealmCodec", "!=", "null", ")", "{", "tokenRealm", "=", "samlRealmCodec", ".", "getRealmFromToken", "(", "assertion", ")", ";", "if", "(", "secToken", "!=", "null", ")", "{", "Properties", "props", "=", "secToken", ".", "getProperties", "(", ")", ";", "if", "(", "props", "!=", "null", ")", "{", "String", "cachedRealm", "=", "props", ".", "getProperty", "(", "STSConstants", ".", "TOKEN_REALM", ")", ";", "if", "(", "cachedRealm", "!=", "null", "&&", "!", "tokenRealm", ".", "equals", "(", "cachedRealm", ")", ")", "{", "return", "response", ";", "}", "}", "}", "}", "response", ".", "setTokenRealm", "(", "tokenRealm", ")", ";", "if", "(", "!", "validateConditions", "(", "assertion", ",", "validateTarget", ")", ")", "{", "return", "response", ";", "}", "if", "(", "secToken", "==", "null", ")", "{", "storeTokenInCache", "(", "tokenParameters", ".", "getTokenStore", "(", ")", ",", "assertion", ",", "tokenParameters", ".", "getPrincipal", "(", ")", ",", "tokenRealm", ")", ";", "}", "Map", "<", "String", ",", "Object", ">", "addProps", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "addProps", ".", "put", "(", "SamlAssertionWrapper", ".", "class", ".", "getName", "(", ")", ",", "assertion", ")", ";", "response", ".", "setAdditionalProperties", "(", "addProps", ")", ";", "validateTarget", ".", "setState", "(", "STATE", ".", "VALID", ")", ";", "}", "catch", "(", "WSSecurityException", "ex", ")", "{", "LOG", ".", "log", "(", "Level", ".", "WARNING", ",", "\"", "\"", ",", "ex", ")", ";", "}", "return", "response", ";", "}"], "idx": 10857, "cwe": "CWE-20", "target": 0, "status": "FIXED", "commit": "b4b9a010bb23059251400455afabddee15b46127", "function_name": "validateToken", "body_hash": "e8992b3dc2cfd96f8398fdc0f63035ae5aef5811"}
{"code": "public DIHConfiguration loadDataConfig(InputSource configFile) {\n\n    DIHConfiguration dihcfg = null;\n    try {\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      dbf.setValidating(false);\n      \n      // only enable xinclude, if XML is coming from safe source (local file)\n      // and a a SolrCore and SystemId is present (makes no sense otherwise):\n      if (core != null && configFile.getSystemId() != null) {\n        try {\n          dbf.setXIncludeAware(true);\n          dbf.setNamespaceAware(true);\n        } catch( UnsupportedOperationException e ) {\n          LOG.warn( \"XML parser doesn't support XInclude option\" );\n        }\n      }\n      \n      DocumentBuilder builder = dbf.newDocumentBuilder();\n      // only enable xinclude / external entities, if XML is coming from\n      // safe source (local file) and a a SolrCore and SystemId is present:\n      if (core != null && configFile.getSystemId() != null) {\n        builder.setEntityResolver(new SystemIdResolver(core.getResourceLoader()));\n      } else {\n        // Don't allow external entities without having a system ID:\n        builder.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n      }\n      builder.setErrorHandler(XMLLOG);\n      Document document;\n      try {\n        document = builder.parse(configFile);\n      } finally {\n        // some XML parsers are broken and don't close the byte stream (but they should according to spec)\n        IOUtils.closeQuietly(configFile.getByteStream());\n      }\n\n      dihcfg = readFromXml(document);\n      LOG.info(\"Data Configuration loaded successfully\");\n    } catch (Exception e) {\n      throw new DataImportHandlerException(SEVERE,\n              \"Data Config problem: \" + e.getMessage(), e);\n    }\n    for (Entity e : dihcfg.getEntities()) {\n      if (e.getAllAttributes().containsKey(SqlEntityProcessor.DELTA_QUERY)) {\n        isDeltaImportSupported = true;\n        break;\n      }\n    }\n    return dihcfg;\n  }", "code_tokens": ["public", "DIHConfiguration", "loadDataConfig", "(", "InputSource", "configFile", ")", "{", "DIHConfiguration", "dihcfg", "=", "null", ";", "try", "{", "DocumentBuilderFactory", "dbf", "=", "DocumentBuilderFactory", ".", "newInstance", "(", ")", ";", "dbf", ".", "setValidating", "(", "false", ")", ";", "if", "(", "core", "!=", "null", "&&", "configFile", ".", "getSystemId", "(", ")", "!=", "null", ")", "{", "try", "{", "dbf", ".", "setXIncludeAware", "(", "true", ")", ";", "dbf", ".", "setNamespaceAware", "(", "true", ")", ";", "}", "catch", "(", "UnsupportedOperationException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "XML parser doesn't support XInclude option", "\"", ")", ";", "}", "}", "DocumentBuilder", "builder", "=", "dbf", ".", "newDocumentBuilder", "(", ")", ";", "if", "(", "core", "!=", "null", "&&", "configFile", ".", "getSystemId", "(", ")", "!=", "null", ")", "{", "builder", ".", "setEntityResolver", "(", "new", "SystemIdResolver", "(", "core", ".", "getResourceLoader", "(", ")", ")", ")", ";", "}", "else", "{", "builder", ".", "setEntityResolver", "(", "EmptyEntityResolver", ".", "SAX_INSTANCE", ")", ";", "}", "builder", ".", "setErrorHandler", "(", "XMLLOG", ")", ";", "Document", "document", ";", "try", "{", "document", "=", "builder", ".", "parse", "(", "configFile", ")", ";", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "configFile", ".", "getByteStream", "(", ")", ")", ";", "}", "dihcfg", "=", "readFromXml", "(", "document", ")", ";", "LOG", ".", "info", "(", "\"", "Data Configuration loaded successfully", "\"", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "DataImportHandlerException", "(", "SEVERE", ",", "\"", "Data Config problem: ", "\"", "+", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "for", "(", "Entity", "e", ":", "dihcfg", ".", "getEntities", "(", ")", ")", "{", "if", "(", "e", ".", "getAllAttributes", "(", ")", ".", "containsKey", "(", "SqlEntityProcessor", ".", "DELTA_QUERY", ")", ")", "{", "isDeltaImportSupported", "=", "true", ";", "break", ";", "}", "}", "return", "dihcfg", ";", "}"], "idx": 68712, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "02c693f3713add1b4891cbaa87127de3a55c10f", "function_name": "loadDataConfig", "body_hash": "c6ff7783a167a95858257c8131954287110ad70c"}
{"code": "@Override\n        public boolean check(Object credentials)\n        {\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n\n            try\n            {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5)\n                {\n                    // Credentials are already a MD5 digest - assume it's in\n                    // form user:realm:password (we have no way to know since\n                    // it's a digest, alright?)\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                }\n                else\n                {\n                    // calc A1 digest\n                    md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                // calc A2 digest\n                md.reset();\n                md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                byte[] ha2 = md.digest();\n\n                // calc digest\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\"\n                // nc-value \":\" unq(cnonce-value) \":\" unq(qop-value) \":\" H(A2) )\n                // <\">\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2)\n                // ) > <\">\n\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                byte[] digest = md.digest();\n\n                // check digest\n                return stringEquals(TypeUtil.toString(digest, 16).toLowerCase(), response == null ? null : response.toLowerCase());\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n            }\n\n            return false;\n        }", "code_tokens": ["@", "Override", "public", "boolean", "check", "(", "Object", "credentials", ")", "{", "String", "password", "=", "(", "credentials", "instanceof", "String", ")", "?", "(", "String", ")", "credentials", ":", "credentials", ".", "toString", "(", ")", ";", "try", "{", "MessageDigest", "md", "=", "MessageDigest", ".", "getInstance", "(", "\"", "MD5", "\"", ")", ";", "byte", "[", "]", "ha1", ";", "if", "(", "credentials", "instanceof", "Credential", ".", "MD5", ")", "{", "ha1", "=", "(", "(", "Credential", ".", "MD5", ")", "credentials", ")", ".", "getDigest", "(", ")", ";", "}", "else", "{", "md", ".", "update", "(", "username", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "realm", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "password", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "ha1", "=", "md", ".", "digest", "(", ")", ";", "}", "md", ".", "reset", "(", ")", ";", "md", ".", "update", "(", "method", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "uri", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "byte", "[", "]", "ha2", "=", "md", ".", "digest", "(", ")", ";", "md", ".", "update", "(", "TypeUtil", ".", "toString", "(", "ha1", ",", "16", ")", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "nonce", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "nc", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "cnonce", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "qop", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "md", ".", "update", "(", "(", "byte", ")", "':'", ")", ";", "md", ".", "update", "(", "TypeUtil", ".", "toString", "(", "ha2", ",", "16", ")", ".", "getBytes", "(", "StandardCharsets", ".", "ISO_8859_1", ")", ")", ";", "byte", "[", "]", "digest", "=", "md", ".", "digest", "(", ")", ";", "return", "stringEquals", "(", "TypeUtil", ".", "toString", "(", "digest", ",", "16", ")", ".", "toLowerCase", "(", ")", ",", "response", "==", "null", "?", "null", ":", "response", ".", "toLowerCase", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "warn", "(", "e", ")", ";", "}", "return", "false", ";", "}"], "idx": 20322, "cwe": "CWE-203", "target": 0, "status": "FIXED", "commit": "042f325f1cd6e7891d72c7e668f5947b5457dc02", "function_name": "check", "body_hash": "9ac4e19d16d0eff5c97df2352af8c4ba66020ad7"}
{"code": "@Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException {\n\n        final String path = getRelativePath(req);\n\n        // Block access to special subdirectories.\n        // DefaultServlet assumes it services resources from the root of the web app\n        // and doesn't add any special path protection\n        // WebdavServlet remounts the webapp under a new path, so this check is\n        // necessary on all methods (including GET).\n        if (isSpecialPath(path)) {\n            resp.sendError(WebdavStatus.SC_NOT_FOUND);\n            return;\n        }\n\n        if (req.getDispatcherType() == DispatcherType.ERROR) {\n            doGet(req, resp);\n            return;\n        }\n\n        final String method = req.getMethod();\n\n        if (debug > 0) {\n            log(\"[\" + method + \"] \" + path);\n        }\n\n        if (method.equals(METHOD_PROPFIND)) {\n            doPropfind(req, resp);\n        } else if (method.equals(METHOD_PROPPATCH)) {\n            doProppatch(req, resp);\n        } else if (method.equals(METHOD_MKCOL)) {\n            doMkcol(req, resp);\n        } else if (method.equals(METHOD_COPY)) {\n            doCopy(req, resp);\n        } else if (method.equals(METHOD_MOVE)) {\n            doMove(req, resp);\n        } else if (method.equals(METHOD_LOCK)) {\n            doLock(req, resp);\n        } else if (method.equals(METHOD_UNLOCK)) {\n            doUnlock(req, resp);\n        } else {\n            // DefaultServlet processing\n            super.service(req, resp);\n        }\n\n    }", "code_tokens": ["@", "Override", "protected", "void", "service", "(", "HttpServletRequest", "req", ",", "HttpServletResponse", "resp", ")", "throws", "ServletException", ",", "IOException", "{", "final", "String", "path", "=", "getRelativePath", "(", "req", ")", ";", "if", "(", "isSpecialPath", "(", "path", ")", ")", "{", "resp", ".", "sendError", "(", "WebdavStatus", ".", "SC_NOT_FOUND", ")", ";", "return", ";", "}", "if", "(", "req", ".", "getDispatcherType", "(", ")", "==", "DispatcherType", ".", "ERROR", ")", "{", "doGet", "(", "req", ",", "resp", ")", ";", "return", ";", "}", "final", "String", "method", "=", "req", ".", "getMethod", "(", ")", ";", "if", "(", "debug", ">", "0", ")", "{", "log", "(", "\"", "[", "\"", "+", "method", "+", "\"", "] ", "\"", "+", "path", ")", ";", "}", "if", "(", "method", ".", "equals", "(", "METHOD_PROPFIND", ")", ")", "{", "doPropfind", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_PROPPATCH", ")", ")", "{", "doProppatch", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_MKCOL", ")", ")", "{", "doMkcol", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_COPY", ")", ")", "{", "doCopy", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_MOVE", ")", ")", "{", "doMove", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_LOCK", ")", ")", "{", "doLock", "(", "req", ",", "resp", ")", ";", "}", "else", "if", "(", "method", ".", "equals", "(", "METHOD_UNLOCK", ")", ")", "{", "doUnlock", "(", "req", ",", "resp", ")", ";", "}", "else", "{", "super", ".", "service", "(", "req", ",", "resp", ")", ";", "}", "}"], "idx": 74325, "cwe": "CWE-755", "target": 0, "status": "FIXED", "commit": "25d3c0d93190ef165ecd6c744bc15b5059abfa8f", "function_name": "service", "body_hash": "c5c469b297de9675cbbb3425235d2d839151eb61"}
{"code": "private void enumerateChmDirectoryListingList(ChmItsfHeader chmItsHeader,\n            ChmItspHeader chmItspHeader) throws TikaException {\n        try {\n            int startPmgl = chmItspHeader.getIndex_head();\n            int stopPmgl = chmItspHeader.getUnknown_0024();\n            int dir_offset = (int) (chmItsHeader.getDirOffset() + chmItspHeader\n                    .getHeader_len());\n            setDataOffset(chmItsHeader.getDataOffset());\n\n            /* loops over all pmgls */\n            byte[] dir_chunk = null;\n            Set<Integer> processed = new HashSet<>();\n            for (int i = startPmgl; i>=0; ) {\n                dir_chunk = new byte[(int) chmItspHeader.getBlock_len()];\n                int start = i * (int) chmItspHeader.getBlock_len() + dir_offset;\n                dir_chunk = ChmCommons\n                        .copyOfRange(getData(), start,\n                                start +(int) chmItspHeader.getBlock_len());\n\n                PMGLheader = new ChmPmglHeader();\n                PMGLheader.parse(dir_chunk, PMGLheader);\n                enumerateOneSegment(dir_chunk);\n                int nextBlock = PMGLheader.getBlockNext();\n                processed.add(i);\n                if (processed.contains(nextBlock)) {\n                    throw new ChmParsingException(\"already processed block; avoiding cycle\");\n                }\n                i=nextBlock;\n                dir_chunk = null;\n            }\n            System.out.println(\"done\");\n        } catch (ChmParsingException e) {\n            LOG.warn(\"Chm parse exception\", e);\n        } finally {\n            setData(null);\n        }\n    }", "code_tokens": ["private", "void", "enumerateChmDirectoryListingList", "(", "ChmItsfHeader", "chmItsHeader", ",", "ChmItspHeader", "chmItspHeader", ")", "throws", "TikaException", "{", "try", "{", "int", "startPmgl", "=", "chmItspHeader", ".", "getIndex_head", "(", ")", ";", "int", "stopPmgl", "=", "chmItspHeader", ".", "getUnknown_0024", "(", ")", ";", "int", "dir_offset", "=", "(", "int", ")", "(", "chmItsHeader", ".", "getDirOffset", "(", ")", "+", "chmItspHeader", ".", "getHeader_len", "(", ")", ")", ";", "setDataOffset", "(", "chmItsHeader", ".", "getDataOffset", "(", ")", ")", ";", "byte", "[", "]", "dir_chunk", "=", "null", ";", "Set", "<", "Integer", ">", "processed", "=", "new", "HashSet", "<", ">", "(", ")", ";", "for", "(", "int", "i", "=", "startPmgl", ";", "i", ">=", "0", ";", ")", "{", "dir_chunk", "=", "new", "byte", "[", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", "]", ";", "int", "start", "=", "i", "*", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", "+", "dir_offset", ";", "dir_chunk", "=", "ChmCommons", ".", "copyOfRange", "(", "getData", "(", ")", ",", "start", ",", "start", "+", "(", "int", ")", "chmItspHeader", ".", "getBlock_len", "(", ")", ")", ";", "PMGLheader", "=", "new", "ChmPmglHeader", "(", ")", ";", "PMGLheader", ".", "parse", "(", "dir_chunk", ",", "PMGLheader", ")", ";", "enumerateOneSegment", "(", "dir_chunk", ")", ";", "int", "nextBlock", "=", "PMGLheader", ".", "getBlockNext", "(", ")", ";", "processed", ".", "add", "(", "i", ")", ";", "if", "(", "processed", ".", "contains", "(", "nextBlock", ")", ")", "{", "throw", "new", "ChmParsingException", "(", "\"", "already processed block; avoiding cycle", "\"", ")", ";", "}", "i", "=", "nextBlock", ";", "dir_chunk", "=", "null", ";", "}", "System", ".", "out", ".", "println", "(", "\"", "done", "\"", ")", ";", "}", "catch", "(", "ChmParsingException", "e", ")", "{", "LOG", ".", "warn", "(", "\"", "Chm parse exception", "\"", ",", "e", ")", ";", "}", "finally", "{", "setData", "(", "null", ")", ";", "}", "}"], "idx": 108887, "cwe": "NVD-CWE-noinfo", "target": 1, "status": "VULNERABLE", "commit": "5d983aad0b68a228f180686a4135ed8c7cd589f1", "function_name": "enumerateChmDirectoryListingList", "body_hash": "a4af782935b97e8dff40d84eb949dd3a2f5158ce"}
{"code": "public static long parseLong(byte[] b, int off, int len)\n        throws NumberFormatException\n    {\n        int c;\n\n        if (b == null || len <= 0 || !isDigit(c = b[off++])) {\n            throw new NumberFormatException();\n        }\n\n        long n = c - '0';\n        long m;\n\n        while (--len > 0) {\n            if (!isDigit(c = b[off++])) {\n                throw new NumberFormatException();\n            }\n            m = n * 10 + c - '0';\n\n            if (m < n) {\n                // Overflow\n                throw new NumberFormatException();\n            } else {\n                n = m;\n            }\n        }\n\n        return n;\n    }", "code_tokens": ["public", "static", "long", "parseLong", "(", "byte", "[", "]", "b", ",", "int", "off", ",", "int", "len", ")", "throws", "NumberFormatException", "{", "int", "c", ";", "if", "(", "b", "==", "null", "||", "len", "<=", "0", "||", "!", "isDigit", "(", "c", "=", "b", "[", "off", "++", "]", ")", ")", "{", "throw", "new", "NumberFormatException", "(", ")", ";", "}", "long", "n", "=", "c", "-", "'0'", ";", "long", "m", ";", "while", "(", "--", "len", ">", "0", ")", "{", "if", "(", "!", "isDigit", "(", "c", "=", "b", "[", "off", "++", "]", ")", ")", "{", "throw", "new", "NumberFormatException", "(", ")", ";", "}", "m", "=", "n", "*", "10", "+", "c", "-", "'0'", ";", "if", "(", "m", "<", "n", ")", "{", "throw", "new", "NumberFormatException", "(", ")", ";", "}", "else", "{", "n", "=", "m", ";", "}", "}", "return", "n", ";", "}"], "idx": 3079, "cwe": "CWE-189", "target": 1, "status": "VULNERABLE", "commit": "8828a9902d", "function_name": "parseLong", "body_hash": "8ebfc01d93f101c5040b03826f5f85cb82ccafc9"}
{"code": "public static Path getPersistedConfigFile() {\n        String homeDir = Environment.getHomeDir();\n\n        if (homeDir == null) {\n            return Paths.get(Platform.getPlatform().getTmpDirectory().toString(), PersistedConfigSource.KEYCLOAK_PROPERTIES);\n        }\n\n        return Paths.get(homeDir, \"conf\", PersistedConfigSource.KEYCLOAK_PROPERTIES);\n    }", "code_tokens": ["public", "static", "Path", "getPersistedConfigFile", "(", ")", "{", "String", "homeDir", "=", "Environment", ".", "getHomeDir", "(", ")", ";", "if", "(", "homeDir", "==", "null", ")", "{", "return", "Paths", ".", "get", "(", "Platform", ".", "getPlatform", "(", ")", ".", "getTmpDirectory", "(", ")", ".", "toString", "(", ")", ",", "PersistedConfigSource", ".", "KEYCLOAK_PROPERTIES", ")", ";", "}", "return", "Paths", ".", "get", "(", "homeDir", ",", "\"", "conf", "\"", ",", "PersistedConfigSource", ".", "KEYCLOAK_PROPERTIES", ")", ";", "}"], "idx": 49452, "cwe": "CWE-377", "target": 0, "status": "FIXED", "commit": "853a6d73276849877819f2dc23133557f6e1e601", "function_name": "getPersistedConfigFile", "body_hash": "71be4642066a006cfc476dd2cc1d748e1a6c3b06"}
{"code": "private void configureJwtProxySecureProvisioner(String infrastructure) {\n    install(new FactoryModuleBuilder().build(JwtProxyProvisionerFactory.class));\n    if (KubernetesInfrastructure.NAME.equals(infrastructure)) {\n      install(\n          new FactoryModuleBuilder()\n              .build(\n                  new TypeLiteral<JwtProxySecureServerExposerFactory<KubernetesEnvironment>>() {}));\n      MapBinder.newMapBinder(\n              binder(),\n              new TypeLiteral<String>() {},\n              new TypeLiteral<SecureServerExposerFactory<KubernetesEnvironment>>() {})\n          .addBinding(\"jwtproxy\")\n          .to(new TypeLiteral<JwtProxySecureServerExposerFactory<KubernetesEnvironment>>() {});\n    } else {\n      install(\n          new FactoryModuleBuilder()\n              .build(\n                  new TypeLiteral<JwtProxySecureServerExposerFactory<OpenShiftEnvironment>>() {}));\n      MapBinder.newMapBinder(\n              binder(),\n              new TypeLiteral<String>() {},\n              new TypeLiteral<SecureServerExposerFactory<OpenShiftEnvironment>>() {})\n          .addBinding(\"jwtproxy\")\n          .to(new TypeLiteral<JwtProxySecureServerExposerFactory<OpenShiftEnvironment>>() {});\n    }\n  }", "code_tokens": ["private", "void", "configureJwtProxySecureProvisioner", "(", "String", "infrastructure", ")", "{", "install", "(", "new", "FactoryModuleBuilder", "(", ")", ".", "build", "(", "JwtProxyProvisionerFactory", ".", "class", ")", ")", ";", "if", "(", "KubernetesInfrastructure", ".", "NAME", ".", "equals", "(", "infrastructure", ")", ")", "{", "install", "(", "new", "FactoryModuleBuilder", "(", ")", ".", "build", "(", "new", "TypeLiteral", "<", "JwtProxySecureServerExposerFactory", "<", "KubernetesEnvironment", ">", ">", "(", ")", "{", "}", ")", ")", ";", "MapBinder", ".", "newMapBinder", "(", "binder", "(", ")", ",", "new", "TypeLiteral", "<", "String", ">", "(", ")", "{", "}", ",", "new", "TypeLiteral", "<", "SecureServerExposerFactory", "<", "KubernetesEnvironment", ">", ">", "(", ")", "{", "}", ")", ".", "addBinding", "(", "\"", "jwtproxy", "\"", ")", ".", "to", "(", "new", "TypeLiteral", "<", "JwtProxySecureServerExposerFactory", "<", "KubernetesEnvironment", ">", ">", "(", ")", "{", "}", ")", ";", "}", "else", "{", "install", "(", "new", "FactoryModuleBuilder", "(", ")", ".", "build", "(", "new", "TypeLiteral", "<", "JwtProxySecureServerExposerFactory", "<", "OpenShiftEnvironment", ">", ">", "(", ")", "{", "}", ")", ")", ";", "MapBinder", ".", "newMapBinder", "(", "binder", "(", ")", ",", "new", "TypeLiteral", "<", "String", ">", "(", ")", "{", "}", ",", "new", "TypeLiteral", "<", "SecureServerExposerFactory", "<", "OpenShiftEnvironment", ">", ">", "(", ")", "{", "}", ")", ".", "addBinding", "(", "\"", "jwtproxy", "\"", ")", ".", "to", "(", "new", "TypeLiteral", "<", "JwtProxySecureServerExposerFactory", "<", "OpenShiftEnvironment", ">", ">", "(", ")", "{", "}", ")", ";", "}", "}"], "idx": 110109, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "333bfcd23a1fc72ec527cc4675046339f018cd24", "function_name": "configureJwtProxySecureProvisioner", "body_hash": "8580b06062e33785982179451ce83cdab8e398f0"}
{"code": "public static boolean isSpringJspExpressionSupportActive(PageContext pageContext) {\n\t\tServletContext sc = pageContext.getServletContext();\n\t\tString springJspExpressionSupport = sc.getInitParameter(EXPRESSION_SUPPORT_CONTEXT_PARAM);\n\t\tif (springJspExpressionSupport != null) {\n\t\t\treturn Boolean.valueOf(springJspExpressionSupport);\n\t\t}\n\t\tif (sc.getMajorVersion() >= 3) {\n\t\t\t// We're on a Servlet 3.0+ container: Let's check what the application declares...\n\t\t\tif (sc.getEffectiveMajorVersion() == 2 && sc.getEffectiveMinorVersion() < 4) {\n\t\t\t\t// Application declares Servlet 2.3- in its web.xml: JSP 2.0 expressions not active.\n\t\t\t\t// Activate our own expression support.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "code_tokens": ["public", "static", "boolean", "isSpringJspExpressionSupportActive", "(", "PageContext", "pageContext", ")", "{", "ServletContext", "sc", "=", "pageContext", ".", "getServletContext", "(", ")", ";", "String", "springJspExpressionSupport", "=", "sc", ".", "getInitParameter", "(", "EXPRESSION_SUPPORT_CONTEXT_PARAM", ")", ";", "if", "(", "springJspExpressionSupport", "!=", "null", ")", "{", "return", "Boolean", ".", "valueOf", "(", "springJspExpressionSupport", ")", ";", "}", "if", "(", "sc", ".", "getMajorVersion", "(", ")", ">=", "3", ")", "{", "if", "(", "sc", ".", "getEffectiveMajorVersion", "(", ")", "==", "2", "&&", "sc", ".", "getEffectiveMinorVersion", "(", ")", "<", "4", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "idx": 2499, "cwe": "CWE-16", "target": 0, "status": "FIXED", "commit": "9772eb8410e37cd0bdec0d1b133218446c778beb", "function_name": "isSpringJspExpressionSupportActive", "body_hash": "6972417c11bf3ec9bca8ee624dbabe6a1d779262"}
{"code": "public String filter(String expression) {\n        if (forbiddenExpressionPatterns != null && expressionMatches(expression, forbiddenExpressionPatterns)) {\n            logger.warn(\"Expression {} is forbidden by expression filter\", expression);\n            return null;\n        }\n        if (allowedExpressionPatterns != null && !expressionMatches(expression, allowedExpressionPatterns)) {\n            logger.warn(\"Expression {} is not allowed by expression filter\", expression);\n            return null;\n        }\n        return expression;\n    }", "code_tokens": ["public", "String", "filter", "(", "String", "expression", ")", "{", "if", "(", "forbiddenExpressionPatterns", "!=", "null", "&&", "expressionMatches", "(", "expression", ",", "forbiddenExpressionPatterns", ")", ")", "{", "logger", ".", "warn", "(", "\"", "Expression {} is forbidden by expression filter", "\"", ",", "expression", ")", ";", "return", "null", ";", "}", "if", "(", "allowedExpressionPatterns", "!=", "null", "&&", "!", "expressionMatches", "(", "expression", ",", "allowedExpressionPatterns", ")", ")", "{", "logger", ".", "warn", "(", "\"", "Expression {} is not allowed by expression filter", "\"", ",", "expression", ")", ";", "return", "null", ";", "}", "return", "expression", ";", "}"], "idx": 73774, "cwe": "CWE-74", "target": 1, "status": "VULNERABLE", "commit": "1c088702511ef44a056244cb968682daf8f21946", "function_name": "filter", "body_hash": "48ebfcb5989b19cc7841ac16b3278ac2b682691e"}
{"code": "private ChannelBuffer unwrap(\n            ChannelHandlerContext ctx, Channel channel,\n            ChannelBuffer nettyInNetBuf, ByteBuffer nioInNetBuf,\n            int initialNettyOutAppBufCapacity) throws SSLException {\n\n        final int nettyInNetBufStartOffset = nettyInNetBuf.readerIndex();\n        final int nioInNetBufStartOffset = nioInNetBuf.position();\n        final ByteBuffer nioOutAppBuf = bufferPool.acquireBuffer();\n\n        ChannelBuffer nettyOutAppBuf = null;\n\n        try {\n            boolean needsWrap = false;\n            for (;;) {\n                SSLEngineResult result;\n                boolean needsHandshake = false;\n                synchronized (handshakeLock) {\n                    if (!handshaken && !handshaking &&\n                        !engine.getUseClientMode() &&\n                        !engine.isInboundDone() && !engine.isOutboundDone()) {\n                        needsHandshake = true;\n                    }\n                }\n\n                if (needsHandshake) {\n                    handshake();\n                }\n\n                synchronized (handshakeLock) {\n                    // Decrypt at least one record in the inbound network buffer.\n                    // It is impossible to consume no record here because we made sure the inbound network buffer\n                    // always contain at least one record in decode().  Therefore, if SSLEngine.unwrap() returns\n                    // BUFFER_OVERFLOW, it is always resolved by retrying after emptying the application buffer.\n                    for (;;) {\n                        try {\n                            result = engine.unwrap(nioInNetBuf, nioOutAppBuf);\n                            switch (result.getStatus()) {\n                                case CLOSED:\n                                    // notify about the CLOSED state of the SSLEngine. See #137\n                                    sslEngineCloseFuture.setClosed();\n                                    break;\n                                case BUFFER_OVERFLOW:\n                                    // Flush the unwrapped data in the outAppBuf into frame and try again.\n                                    // See the finally block.\n                                    continue;\n                            }\n\n                            break;\n                        } finally {\n                            nioOutAppBuf.flip();\n\n                            // Sync the offset of the inbound buffer.\n                            nettyInNetBuf.readerIndex(\n                                    nettyInNetBufStartOffset + nioInNetBuf.position() - nioInNetBufStartOffset);\n\n                            // Copy the unwrapped data into a smaller buffer.\n                            if (nioOutAppBuf.hasRemaining()) {\n                                if (nettyOutAppBuf == null) {\n                                    ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();\n                                    nettyOutAppBuf = factory.getBuffer(initialNettyOutAppBufCapacity);\n                                }\n                                nettyOutAppBuf.writeBytes(nioOutAppBuf);\n                            }\n                            nioOutAppBuf.clear();\n                        }\n                    }\n\n                    final HandshakeStatus handshakeStatus = result.getHandshakeStatus();\n                    handleRenegotiation(handshakeStatus);\n                    switch (handshakeStatus) {\n                    case NEED_UNWRAP:\n                        break;\n                    case NEED_WRAP:\n                        wrapNonAppData(ctx, channel);\n                        break;\n                    case NEED_TASK:\n                        runDelegatedTasks();\n                        break;\n                    case FINISHED:\n                        setHandshakeSuccess(channel);\n                        needsWrap = true;\n                        continue;\n                    case NOT_HANDSHAKING:\n                        if (setHandshakeSuccessIfStillHandshaking(channel)) {\n                            needsWrap = true;\n                            continue;\n                        }\n                        if (writeBeforeHandshakeDone) {\n                            // We need to call wrap(...) in case there was a flush done before the handshake completed.\n                            //\n                            // See https://github.com/netty/netty/pull/2437\n                            writeBeforeHandshakeDone = false;\n                            needsWrap = true;\n                        }\n                        break;\n                    default:\n                        throw new IllegalStateException(\n                                \"Unknown handshake status: \" + handshakeStatus);\n                    }\n\n                    if (result.getStatus() == Status.BUFFER_UNDERFLOW ||\n                        result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (needsWrap) {\n                // wrap() acquires pendingUnencryptedWrites first and then\n                // handshakeLock.  If handshakeLock is already hold by the\n                // current thread, calling wrap() will lead to a dead lock\n                // i.e. pendingUnencryptedWrites -> handshakeLock vs.\n                //      handshakeLock -> pendingUnencryptedLock -> handshakeLock\n                //\n                // There is also the same issue between pendingEncryptedWrites\n                // and pendingUnencryptedWrites.\n                if (!Thread.holdsLock(handshakeLock) && !pendingEncryptedWritesLock.isHeldByCurrentThread()) {\n                    wrap(ctx, channel);\n                }\n            }\n        } catch (SSLException e) {\n            setHandshakeFailure(channel, e);\n            throw e;\n        } finally {\n            bufferPool.releaseBuffer(nioOutAppBuf);\n        }\n\n        if (nettyOutAppBuf != null && nettyOutAppBuf.readable()) {\n            return nettyOutAppBuf;\n        } else {\n            return null;\n        }\n    }", "code_tokens": ["private", "ChannelBuffer", "unwrap", "(", "ChannelHandlerContext", "ctx", ",", "Channel", "channel", ",", "ChannelBuffer", "nettyInNetBuf", ",", "ByteBuffer", "nioInNetBuf", ",", "int", "initialNettyOutAppBufCapacity", ")", "throws", "SSLException", "{", "final", "int", "nettyInNetBufStartOffset", "=", "nettyInNetBuf", ".", "readerIndex", "(", ")", ";", "final", "int", "nioInNetBufStartOffset", "=", "nioInNetBuf", ".", "position", "(", ")", ";", "final", "ByteBuffer", "nioOutAppBuf", "=", "bufferPool", ".", "acquireBuffer", "(", ")", ";", "ChannelBuffer", "nettyOutAppBuf", "=", "null", ";", "try", "{", "boolean", "needsWrap", "=", "false", ";", "for", "(", ";", ";", ")", "{", "SSLEngineResult", "result", ";", "boolean", "needsHandshake", "=", "false", ";", "synchronized", "(", "handshakeLock", ")", "{", "if", "(", "!", "handshaken", "&&", "!", "handshaking", "&&", "!", "engine", ".", "getUseClientMode", "(", ")", "&&", "!", "engine", ".", "isInboundDone", "(", ")", "&&", "!", "engine", ".", "isOutboundDone", "(", ")", ")", "{", "needsHandshake", "=", "true", ";", "}", "}", "if", "(", "needsHandshake", ")", "{", "handshake", "(", ")", ";", "}", "synchronized", "(", "handshakeLock", ")", "{", "for", "(", ";", ";", ")", "{", "try", "{", "result", "=", "engine", ".", "unwrap", "(", "nioInNetBuf", ",", "nioOutAppBuf", ")", ";", "switch", "(", "result", ".", "getStatus", "(", ")", ")", "{", "case", "CLOSED", ":", "sslEngineCloseFuture", ".", "setClosed", "(", ")", ";", "break", ";", "case", "BUFFER_OVERFLOW", ":", "continue", ";", "}", "break", ";", "}", "finally", "{", "nioOutAppBuf", ".", "flip", "(", ")", ";", "nettyInNetBuf", ".", "readerIndex", "(", "nettyInNetBufStartOffset", "+", "nioInNetBuf", ".", "position", "(", ")", "-", "nioInNetBufStartOffset", ")", ";", "if", "(", "nioOutAppBuf", ".", "hasRemaining", "(", ")", ")", "{", "if", "(", "nettyOutAppBuf", "==", "null", ")", "{", "ChannelBufferFactory", "factory", "=", "ctx", ".", "getChannel", "(", ")", ".", "getConfig", "(", ")", ".", "getBufferFactory", "(", ")", ";", "nettyOutAppBuf", "=", "factory", ".", "getBuffer", "(", "initialNettyOutAppBufCapacity", ")", ";", "}", "nettyOutAppBuf", ".", "writeBytes", "(", "nioOutAppBuf", ")", ";", "}", "nioOutAppBuf", ".", "clear", "(", ")", ";", "}", "}", "final", "HandshakeStatus", "handshakeStatus", "=", "result", ".", "getHandshakeStatus", "(", ")", ";", "handleRenegotiation", "(", "handshakeStatus", ")", ";", "switch", "(", "handshakeStatus", ")", "{", "case", "NEED_UNWRAP", ":", "break", ";", "case", "NEED_WRAP", ":", "wrapNonAppData", "(", "ctx", ",", "channel", ")", ";", "break", ";", "case", "NEED_TASK", ":", "runDelegatedTasks", "(", ")", ";", "break", ";", "case", "FINISHED", ":", "setHandshakeSuccess", "(", "channel", ")", ";", "needsWrap", "=", "true", ";", "continue", ";", "case", "NOT_HANDSHAKING", ":", "if", "(", "setHandshakeSuccessIfStillHandshaking", "(", "channel", ")", ")", "{", "needsWrap", "=", "true", ";", "continue", ";", "}", "if", "(", "writeBeforeHandshakeDone", ")", "{", "writeBeforeHandshakeDone", "=", "false", ";", "needsWrap", "=", "true", ";", "}", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"", "Unknown handshake status: ", "\"", "+", "handshakeStatus", ")", ";", "}", "if", "(", "result", ".", "getStatus", "(", ")", "==", "Status", ".", "BUFFER_UNDERFLOW", "||", "result", ".", "bytesConsumed", "(", ")", "==", "0", "&&", "result", ".", "bytesProduced", "(", ")", "==", "0", ")", "{", "break", ";", "}", "}", "}", "if", "(", "needsWrap", ")", "{", "if", "(", "!", "Thread", ".", "holdsLock", "(", "handshakeLock", ")", "&&", "!", "pendingEncryptedWritesLock", ".", "isHeldByCurrentThread", "(", ")", ")", "{", "wrap", "(", "ctx", ",", "channel", ")", ";", "}", "}", "}", "catch", "(", "SSLException", "e", ")", "{", "setHandshakeFailure", "(", "channel", ",", "e", ")", ";", "throw", "e", ";", "}", "finally", "{", "bufferPool", ".", "releaseBuffer", "(", "nioOutAppBuf", ")", ";", "}", "if", "(", "nettyOutAppBuf", "!=", "null", "&&", "nettyOutAppBuf", ".", "readable", "(", ")", ")", "{", "return", "nettyOutAppBuf", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "idx": 2109, "cwe": "CWE-119", "target": 1, "status": "VULNERABLE", "commit": "2fa9400a59d0563a66908aba55c41e7285a04994", "function_name": "unwrap", "body_hash": "8a3d801efbbf34c487f1698e0c8e003eac233ab0"}
{"code": "@GET\n    @Path(\"/purge/{date}\")\n    public void purge(@PathParam(\"date\") String date) {\n        try {\n            clusterService.purge(new SimpleDateFormat(\"yyyy-MM-dd\").parse(date));\n        } catch (ParseException e) {\n            logger.error(\"Cannot parse date, expected format is: yyyy-MM-dd. See debug log level for more information\");\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Cannot parse date: {}\", date, e);\n            }\n        }\n    }", "code_tokens": ["@", "GET", "@", "Path", "(", "\"", "/purge/{date}", "\"", ")", "public", "void", "purge", "(", "@", "PathParam", "(", "\"", "date", "\"", ")", "String", "date", ")", "{", "try", "{", "clusterService", ".", "purge", "(", "new", "SimpleDateFormat", "(", "\"", "yyyy-MM-dd", "\"", ")", ".", "parse", "(", "date", ")", ")", ";", "}", "catch", "(", "ParseException", "e", ")", "{", "logger", ".", "error", "(", "\"", "Cannot parse date, expected format is: yyyy-MM-dd. See debug log level for more information", "\"", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Cannot parse date: {}", "\"", ",", "date", ",", "e", ")", ";", "}", "}", "}"], "idx": 73772, "cwe": "CWE-74", "target": 0, "status": "FIXED", "commit": "1c088702511ef44a056244cb968682daf8f21946", "function_name": "purge", "body_hash": "10cf8071dc1a9b4c0d074c5dc6e52821a07e0d99"}
{"code": "@GET\n    @Produces({\"application/json\", \"application/jwt\" })\n    public Response getUserInfo() {\n        OAuthContext oauth = OAuthContextUtils.getContext(mc);\n\n        // Check the access token has the \"openid\" scope\n        if (!oauth.getPermissions().stream()\n            .map(OAuthPermission::getPermission)\n            .anyMatch(OidcUtils.OPENID_SCOPE::equals)) {\n            Response.status(401);\n        }\n\n        UserInfo userInfo = null;\n        if (userInfoProvider != null) {\n            userInfo = userInfoProvider.getUserInfo(oauth.getClientId(), oauth.getSubject(),\n                OAuthUtils.convertPermissionsToScopeList(oauth.getPermissions()));\n        } else if (oauth.getSubject() instanceof OidcUserSubject) {\n            OidcUserSubject oidcUserSubject = (OidcUserSubject)oauth.getSubject();\n            userInfo = oidcUserSubject.getUserInfo();\n            if (userInfo == null) {\n                userInfo = createFromIdToken(oidcUserSubject.getIdToken());\n            }\n        }\n        if (userInfo == null) {\n            // Consider customizing the error code in case of UserInfo being not available\n            return Response.serverError().build();\n        }\n\n        Object responseEntity = null;\n        // UserInfo may be returned in a clear form as JSON\n        if (super.isJwsRequired() || super.isJweRequired()) {\n            Client client = null;\n            if (oauthDataProvider != null) {\n                client = oauthDataProvider.getClient(oauth.getClientId());\n            }\n            responseEntity = super.processJwt(new JwtToken(userInfo), client);\n        } else {\n            responseEntity = convertUserInfoToResponseEntity(userInfo);\n        }\n        return Response.ok(responseEntity).build();\n\n    }", "code_tokens": ["@", "GET", "@", "Produces", "(", "{", "\"", "application/json", "\"", ",", "\"", "application/jwt", "\"", "}", ")", "public", "Response", "getUserInfo", "(", ")", "{", "OAuthContext", "oauth", "=", "OAuthContextUtils", ".", "getContext", "(", "mc", ")", ";", "if", "(", "!", "oauth", ".", "getPermissions", "(", ")", ".", "stream", "(", ")", ".", "map", "(", "OAuthPermission", "::", "getPermission", ")", ".", "anyMatch", "(", "OidcUtils", ".", "OPENID_SCOPE", "::", "equals", ")", ")", "{", "Response", ".", "status", "(", "401", ")", ";", "}", "UserInfo", "userInfo", "=", "null", ";", "if", "(", "userInfoProvider", "!=", "null", ")", "{", "userInfo", "=", "userInfoProvider", ".", "getUserInfo", "(", "oauth", ".", "getClientId", "(", ")", ",", "oauth", ".", "getSubject", "(", ")", ",", "OAuthUtils", ".", "convertPermissionsToScopeList", "(", "oauth", ".", "getPermissions", "(", ")", ")", ")", ";", "}", "else", "if", "(", "oauth", ".", "getSubject", "(", ")", "instanceof", "OidcUserSubject", ")", "{", "OidcUserSubject", "oidcUserSubject", "=", "(", "OidcUserSubject", ")", "oauth", ".", "getSubject", "(", ")", ";", "userInfo", "=", "oidcUserSubject", ".", "getUserInfo", "(", ")", ";", "if", "(", "userInfo", "==", "null", ")", "{", "userInfo", "=", "createFromIdToken", "(", "oidcUserSubject", ".", "getIdToken", "(", ")", ")", ";", "}", "}", "if", "(", "userInfo", "==", "null", ")", "{", "return", "Response", ".", "serverError", "(", ")", ".", "build", "(", ")", ";", "}", "Object", "responseEntity", "=", "null", ";", "if", "(", "super", ".", "isJwsRequired", "(", ")", "||", "super", ".", "isJweRequired", "(", ")", ")", "{", "Client", "client", "=", "null", ";", "if", "(", "oauthDataProvider", "!=", "null", ")", "{", "client", "=", "oauthDataProvider", ".", "getClient", "(", "oauth", ".", "getClientId", "(", ")", ")", ";", "}", "responseEntity", "=", "super", ".", "processJwt", "(", "new", "JwtToken", "(", "userInfo", ")", ",", "client", ")", ";", "}", "else", "{", "responseEntity", "=", "convertUserInfoToResponseEntity", "(", "userInfo", ")", ";", "}", "return", "Response", ".", "ok", "(", "responseEntity", ")", ".", "build", "(", ")", ";", "}"], "idx": 88925, "cwe": "CWE-863", "target": 0, "status": "FIXED", "commit": "661c271f48", "function_name": "getUserInfo", "body_hash": "309784adaaac33328ead752579c20b3145fc7cbd"}
{"code": "public String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret) {\n            StaplerRequest req = Stapler.getCurrentRequest();\n            if (req != null) {\n                Item item = req.findAncestorObject(Item.class);\n                if (item != null && !item.hasPermission(Item.CONFIGURE)) {\n                    return \"<some secret>\";\n                }\n            }\n            return ((Secret) o).getEncryptedValue();\n        }\n        if (getIsUnitTest()) {\n            throw new SecurityException(\"attempted to render plaintext \u2018\" + o + \"\u2019 in password field; use a getter of type Secret instead\");\n        }\n        return o.toString();\n    }", "code_tokens": ["public", "String", "getPasswordValue", "(", "Object", "o", ")", "{", "if", "(", "o", "==", "null", ")", "return", "null", ";", "if", "(", "o", "instanceof", "Secret", ")", "{", "StaplerRequest", "req", "=", "Stapler", ".", "getCurrentRequest", "(", ")", ";", "if", "(", "req", "!=", "null", ")", "{", "Item", "item", "=", "req", ".", "findAncestorObject", "(", "Item", ".", "class", ")", ";", "if", "(", "item", "!=", "null", "&&", "!", "item", ".", "hasPermission", "(", "Item", ".", "CONFIGURE", ")", ")", "{", "return", "\"", "<some secret>", "\"", ";", "}", "}", "return", "(", "(", "Secret", ")", "o", ")", ".", "getEncryptedValue", "(", ")", ";", "}", "if", "(", "getIsUnitTest", "(", ")", ")", "{", "throw", "new", "SecurityException", "(", "\"", "attempted to render plaintext \u2018", "\"", "+", "o", "+", "\"", "\u2019 in password field; use a getter of type Secret instead", "\"", ")", ";", "}", "return", "o", ".", "toString", "(", ")", ";", "}"], "idx": 15029, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "82b42359797e42fa4b2428d5e390e7ce91b74998", "function_name": "getPasswordValue", "body_hash": "7453d833cf8425bcc22b88437f33970490b59242"}
{"code": "protected Channel jnlpConnect(SlaveComputer computer) throws InterruptedException, IOException {\n            final String nodeName = computer.getName();\n            final OutputStream log = computer.openLogFile();\n            PrintWriter logw = new PrintWriter(log,true);\n            logw.println(\"JNLP agent connected from \"+ socket.getInetAddress());\n\n            try {\n                ChannelBuilder cb = createChannelBuilder(nodeName);\n\n                computer.setChannel(cb.withHeaderStream(log).build(socket), log,\n                    new Listener() {\n                        @Override\n                        public void onClosed(Channel channel, IOException cause) {\n                            if(cause!=null)\n                                LOGGER.log(Level.WARNING, Thread.currentThread().getName()+\" for + \" + nodeName + \" terminated\",cause);\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                // ignore\n                            }\n                        }\n                    });\n                return computer.getChannel();\n            } catch (AbortException e) {\n                logw.println(e.getMessage());\n                logw.println(\"Failed to establish the connection with the slave\");\n                throw e;\n            } catch (IOException e) {\n                logw.println(\"Failed to establish the connection with the slave \" + nodeName);\n                e.printStackTrace(logw);\n                throw e;\n            }\n        }", "code_tokens": ["protected", "Channel", "jnlpConnect", "(", "SlaveComputer", "computer", ")", "throws", "InterruptedException", ",", "IOException", "{", "final", "String", "nodeName", "=", "computer", ".", "getName", "(", ")", ";", "final", "OutputStream", "log", "=", "computer", ".", "openLogFile", "(", ")", ";", "PrintWriter", "logw", "=", "new", "PrintWriter", "(", "log", ",", "true", ")", ";", "logw", ".", "println", "(", "\"", "JNLP agent connected from ", "\"", "+", "socket", ".", "getInetAddress", "(", ")", ")", ";", "try", "{", "ChannelBuilder", "cb", "=", "createChannelBuilder", "(", "nodeName", ")", ";", "computer", ".", "setChannel", "(", "cb", ".", "withHeaderStream", "(", "log", ")", ".", "build", "(", "socket", ")", ",", "log", ",", "new", "Listener", "(", ")", "{", "@", "Override", "public", "void", "onClosed", "(", "Channel", "channel", ",", "IOException", "cause", ")", "{", "if", "(", "cause", "!=", "null", ")", "LOGGER", ".", "log", "(", "Level", ".", "WARNING", ",", "Thread", ".", "currentThread", "(", ")", ".", "getName", "(", ")", "+", "\"", " for + ", "\"", "+", "nodeName", "+", "\"", " terminated", "\"", ",", "cause", ")", ";", "try", "{", "socket", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "}", "}", ")", ";", "return", "computer", ".", "getChannel", "(", ")", ";", "}", "catch", "(", "AbortException", "e", ")", "{", "logw", ".", "println", "(", "e", ".", "getMessage", "(", ")", ")", ";", "logw", ".", "println", "(", "\"", "Failed to establish the connection with the slave", "\"", ")", ";", "throw", "e", ";", "}", "catch", "(", "IOException", "e", ")", "{", "logw", ".", "println", "(", "\"", "Failed to establish the connection with the slave ", "\"", "+", "nodeName", ")", ";", "e", ".", "printStackTrace", "(", "logw", ")", ";", "throw", "e", ";", "}", "}"], "idx": 36900, "cwe": "CWE-284", "target": 1, "status": "VULNERABLE", "commit": "ed407e66bcd3743a3b458ea8284977e5cac56c2a", "function_name": "jnlpConnect", "body_hash": "5ae25e3540891431a94e778e35c7960fa6dcc409"}
{"code": "protected String getRemoteAddr(RequestCycle requestCycle)\n\t{\n\t\tServletWebRequest request = (ServletWebRequest)requestCycle.getRequest();\n\t\tHttpServletRequest req = request.getContainerRequest();\n\t\tString remoteAddr = request.getHeader(\"X-Forwarded-For\");\n\n\t\tif (remoteAddr != null)\n\t\t{\n\t\t\tif (remoteAddr.contains(\",\"))\n\t\t\t{\n\t\t\t\t// sometimes the header is of form client ip,proxy 1 ip,proxy 2 ip,...,proxy n ip,\n\t\t\t\t// we just want the client\n\t\t\t\tremoteAddr = Strings.split(remoteAddr, ',')[0].trim();\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If ip4/6 address string handed over, simply does pattern validation.\n\t\t\t\tInetAddress.getByName(remoteAddr);\n\t\t\t}\n\t\t\tcatch (UnknownHostException e)\n\t\t\t{\n\t\t\t\tremoteAddr = req.getRemoteAddr();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tremoteAddr = req.getRemoteAddr();\n\t\t}\n\t\treturn remoteAddr;\n\t}", "code_tokens": ["protected", "String", "getRemoteAddr", "(", "RequestCycle", "requestCycle", ")", "{", "ServletWebRequest", "request", "=", "(", "ServletWebRequest", ")", "requestCycle", ".", "getRequest", "(", ")", ";", "HttpServletRequest", "req", "=", "request", ".", "getContainerRequest", "(", ")", ";", "String", "remoteAddr", "=", "request", ".", "getHeader", "(", "\"", "X-Forwarded-For", "\"", ")", ";", "if", "(", "remoteAddr", "!=", "null", ")", "{", "if", "(", "remoteAddr", ".", "contains", "(", "\"", ",", "\"", ")", ")", "{", "remoteAddr", "=", "Strings", ".", "split", "(", "remoteAddr", ",", "','", ")", "[", "0", "]", ".", "trim", "(", ")", ";", "}", "try", "{", "InetAddress", ".", "getByName", "(", "remoteAddr", ")", ";", "}", "catch", "(", "UnknownHostException", "e", ")", "{", "remoteAddr", "=", "req", ".", "getRemoteAddr", "(", ")", ";", "}", "}", "else", "{", "remoteAddr", "=", "req", ".", "getRemoteAddr", "(", ")", ";", "}", "return", "remoteAddr", ";", "}"], "idx": 12071, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "84f62a5cff462eaa3bfaf171b0638c7e7feea30d", "function_name": "getRemoteAddr", "body_hash": "b66f34a951c49187088ae6a2edd68c9716548a2d"}
{"code": "private void openConnection() {\n        if (!connectionOpened) {\n            connectionOpened = true;\n            URLConnection connection = null;\n            try {\n                try {\n                    connection = url.openConnection();\n                } catch (IOException e) {\n                    lastModified = null;\n                    contentLength = null;\n                    return;\n                }\n                if (url.getProtocol().equals(\"jar\")) {\n                    connection.setUseCaches(false);\n                    URL jar = ((JarURLConnection) connection).getJarFileURL();\n                    lastModified = new Date(new File(jar.getFile()).lastModified());\n                } else {\n                    lastModified = new Date(connection.getLastModified());\n                }\n                contentLength = connection.getContentLengthLong();\n            } finally {\n                if (connection != null) {\n                    try {\n                        IoUtils.safeClose(connection.getInputStream());\n                    } catch (IOException e) {\n                        //ignore\n                    }\n                }\n            }\n        }\n    }", "code_tokens": ["private", "void", "openConnection", "(", ")", "{", "if", "(", "!", "connectionOpened", ")", "{", "connectionOpened", "=", "true", ";", "URLConnection", "connection", "=", "null", ";", "try", "{", "try", "{", "connection", "=", "url", ".", "openConnection", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "lastModified", "=", "null", ";", "contentLength", "=", "null", ";", "return", ";", "}", "if", "(", "url", ".", "getProtocol", "(", ")", ".", "equals", "(", "\"", "jar", "\"", ")", ")", "{", "connection", ".", "setUseCaches", "(", "false", ")", ";", "URL", "jar", "=", "(", "(", "JarURLConnection", ")", "connection", ")", ".", "getJarFileURL", "(", ")", ";", "lastModified", "=", "new", "Date", "(", "new", "File", "(", "jar", ".", "getFile", "(", ")", ")", ".", "lastModified", "(", ")", ")", ";", "}", "else", "{", "lastModified", "=", "new", "Date", "(", "connection", ".", "getLastModified", "(", ")", ")", ";", "}", "contentLength", "=", "connection", ".", "getContentLengthLong", "(", ")", ";", "}", "finally", "{", "if", "(", "connection", "!=", "null", ")", "{", "try", "{", "IoUtils", ".", "safeClose", "(", "connection", ".", "getInputStream", "(", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "}", "}", "}", "}", "}"], "idx": 52392, "cwe": "CWE-400", "target": 0, "status": "FIXED", "commit": "7f22aa0090296eb00280f878e3731bb71d40f9e", "function_name": "openConnection", "body_hash": "88d6ea4f807f7bf77c1c2c897c41169701552651"}
{"code": "private void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\tthrows ServletException, IOException {\n\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\tString path = StringUtils.cleanPath(url);\n\t\t\t// check whether URL matches allowed resources\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, path)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + path +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + path + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(path);\n\t\t\trd.include(request, response);\n\t\t}\n\t}", "code_tokens": ["private", "void", "doInclude", "(", "HttpServletRequest", "request", ",", "HttpServletResponse", "response", ",", "String", "resourceUrl", ")", "throws", "ServletException", ",", "IOException", "{", "if", "(", "this", ".", "contentType", "!=", "null", ")", "{", "response", ".", "setContentType", "(", "this", ".", "contentType", ")", ";", "}", "String", "[", "]", "resourceUrls", "=", "StringUtils", ".", "tokenizeToStringArray", "(", "resourceUrl", ",", "RESOURCE_URL_DELIMITERS", ")", ";", "for", "(", "String", "url", ":", "resourceUrls", ")", "{", "String", "path", "=", "StringUtils", ".", "cleanPath", "(", "url", ")", ";", "if", "(", "this", ".", "allowedResources", "!=", "null", "&&", "!", "this", ".", "pathMatcher", ".", "match", "(", "this", ".", "allowedResources", ",", "path", ")", ")", "{", "throw", "new", "ServletException", "(", "\"", "Resource [", "\"", "+", "path", "+", "\"", "] does not match allowed pattern [", "\"", "+", "this", ".", "allowedResources", "+", "\"", "]", "\"", ")", ";", "}", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"", "Including resource [", "\"", "+", "path", "+", "\"", "]", "\"", ")", ";", "}", "RequestDispatcher", "rd", "=", "request", ".", "getRequestDispatcher", "(", "path", ")", ";", "rd", ".", "include", "(", "request", ",", "response", ")", ";", "}", "}"], "idx": 26922, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "a7dc48534ea501525f11369d369178a60c2f47d0", "function_name": "doInclude", "body_hash": "3c80210247b04d4ca4c3d1b87173b569f01ee8a4"}
{"code": "public URL getURL() throws MalformedURLException {\n            String name = fileName;\n            if (name.equals(\"hudson-cli.jar\"))  name=\"jenkins-cli.jar\";\n            URL res = Jenkins.getInstance().servletContext.getResource(\"/WEB-INF/\" + name);\n            if(res==null) {\n                // during the development this path doesn't have the files.\n                res = new URL(new File(\".\").getAbsoluteFile().toURI().toURL(),\"target/jenkins/WEB-INF/\"+name);\n            }\n            return res;\n        }", "code_tokens": ["public", "URL", "getURL", "(", ")", "throws", "MalformedURLException", "{", "String", "name", "=", "fileName", ";", "if", "(", "name", ".", "equals", "(", "\"", "hudson-cli.jar", "\"", ")", ")", "name", "=", "\"", "jenkins-cli.jar", "\"", ";", "URL", "res", "=", "Jenkins", ".", "getInstance", "(", ")", ".", "servletContext", ".", "getResource", "(", "\"", "/WEB-INF/", "\"", "+", "name", ")", ";", "if", "(", "res", "==", "null", ")", "{", "res", "=", "new", "URL", "(", "new", "File", "(", "\"", ".", "\"", ")", ".", "getAbsoluteFile", "(", ")", ".", "toURI", "(", ")", ".", "toURL", "(", ")", ",", "\"", "target/jenkins/WEB-INF/", "\"", "+", "name", ")", ";", "}", "return", "res", ";", "}"], "idx": 21445, "cwe": "CWE-22", "target": 1, "status": "VULNERABLE", "commit": "5431e397216b4ab80e58bdabcb06a0066bce6592", "function_name": "getURL", "body_hash": "d7df7a3844a8154592175b102a77028258561f65"}
{"code": "@SuppressWarnings(\"deprecation\")\n    public void process(final HttpRequest request, final HttpContext context)\n            throws HttpException, IOException {\n        if (request == null) {\n            throw new IllegalArgumentException(\"HTTP request may not be null\");\n        }\n        if (context == null) {\n            throw new IllegalArgumentException(\"HTTP context may not be null\");\n        }\n\n        if (request.containsHeader(AUTH.PROXY_AUTH_RESP)) {\n            return;\n        }\n\n        // Obtain authentication state\n        AuthState authState = (AuthState) context.getAttribute(\n                ClientContext.PROXY_AUTH_STATE);\n        if (authState == null) {\n            return;\n        }\n\n        AuthScheme authScheme = authState.getAuthScheme();\n        if (authScheme == null) {\n            return;\n        }\n\n        Credentials creds = authState.getCredentials();\n        if (creds == null) {\n            this.log.debug(\"User credentials not available\");\n            return;\n        }\n        if (authState.getAuthScope() != null || !authScheme.isConnectionBased()) {\n            try {\n                Header header;\n                if (authScheme instanceof ContextAwareAuthScheme) {\n                    header = ((ContextAwareAuthScheme) authScheme).authenticate(\n                            creds, request, context);\n                } else {\n                    header = authScheme.authenticate(creds, request);\n                }\n                request.addHeader(header);\n            } catch (AuthenticationException ex) {\n                if (this.log.isErrorEnabled()) {\n                    this.log.error(\"Proxy authentication error: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"", "deprecation", "\"", ")", "public", "void", "process", "(", "final", "HttpRequest", "request", ",", "final", "HttpContext", "context", ")", "throws", "HttpException", ",", "IOException", "{", "if", "(", "request", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "HTTP request may not be null", "\"", ")", ";", "}", "if", "(", "context", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"", "HTTP context may not be null", "\"", ")", ";", "}", "if", "(", "request", ".", "containsHeader", "(", "AUTH", ".", "PROXY_AUTH_RESP", ")", ")", "{", "return", ";", "}", "AuthState", "authState", "=", "(", "AuthState", ")", "context", ".", "getAttribute", "(", "ClientContext", ".", "PROXY_AUTH_STATE", ")", ";", "if", "(", "authState", "==", "null", ")", "{", "return", ";", "}", "AuthScheme", "authScheme", "=", "authState", ".", "getAuthScheme", "(", ")", ";", "if", "(", "authScheme", "==", "null", ")", "{", "return", ";", "}", "Credentials", "creds", "=", "authState", ".", "getCredentials", "(", ")", ";", "if", "(", "creds", "==", "null", ")", "{", "this", ".", "log", ".", "debug", "(", "\"", "User credentials not available", "\"", ")", ";", "return", ";", "}", "if", "(", "authState", ".", "getAuthScope", "(", ")", "!=", "null", "||", "!", "authScheme", ".", "isConnectionBased", "(", ")", ")", "{", "try", "{", "Header", "header", ";", "if", "(", "authScheme", "instanceof", "ContextAwareAuthScheme", ")", "{", "header", "=", "(", "(", "ContextAwareAuthScheme", ")", "authScheme", ")", ".", "authenticate", "(", "creds", ",", "request", ",", "context", ")", ";", "}", "else", "{", "header", "=", "authScheme", ".", "authenticate", "(", "creds", ",", "request", ")", ";", "}", "request", ".", "addHeader", "(", "header", ")", ";", "}", "catch", "(", "AuthenticationException", "ex", ")", "{", "if", "(", "this", ".", "log", ".", "isErrorEnabled", "(", ")", ")", "{", "this", ".", "log", ".", "error", "(", "\"", "Proxy authentication error: ", "\"", "+", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "}"], "idx": 16099, "cwe": "CWE-200", "target": 1, "status": "VULNERABLE", "commit": "a572756592c969affd0ce87885724e74839176fb", "function_name": "process", "body_hash": "fd3097c745827f0317d45f864f0383e1521d8fa4"}
{"code": "private MockHttpServletRequestBuilder createChangePasswordRequest(ScimUser user, ExpiringCode code, boolean useCSRF, String password, String passwordConfirmation) throws Exception {\n        MockHttpServletRequestBuilder post = post(\"/reset_password.do\");\n        if (useCSRF) {\n            post.with(csrf());\n        }\n        post.param(\"code\", code.getCode())\n            .param(\"email\", user.getPrimaryEmail())\n            .param(\"password\", password)\n            .param(\"password_confirmation\", passwordConfirmation);\n        return post;\n    }", "code_tokens": ["private", "MockHttpServletRequestBuilder", "createChangePasswordRequest", "(", "ScimUser", "user", ",", "ExpiringCode", "code", ",", "boolean", "useCSRF", ",", "String", "password", ",", "String", "passwordConfirmation", ")", "throws", "Exception", "{", "MockHttpServletRequestBuilder", "post", "=", "post", "(", "\"", "/reset_password.do", "\"", ")", ";", "if", "(", "useCSRF", ")", "{", "post", ".", "with", "(", "csrf", "(", ")", ")", ";", "}", "post", ".", "param", "(", "\"", "code", "\"", ",", "code", ".", "getCode", "(", ")", ")", ".", "param", "(", "\"", "email", "\"", ",", "user", ".", "getPrimaryEmail", "(", ")", ")", ".", "param", "(", "\"", "password", "\"", ",", "password", ")", ".", "param", "(", "\"", "password_confirmation", "\"", ",", "passwordConfirmation", ")", ";", "return", "post", ";", "}"], "idx": 71334, "cwe": "CWE-640", "target": 1, "status": "VULNERABLE", "commit": "cd31cc397fe17389d95b83d6a9caa46eebc54faf", "function_name": "createChangePasswordRequest", "body_hash": "d811108b6c6b15f23fa7c39bcf476162590b2fc4"}
{"code": "public static HttpURLConnection getURLConnection(String url)\n      throws IOException {\n    URLConnection conn = new URL(url).openConnection();\n    final HttpURLConnection httpConn = (HttpURLConnection) conn;\n\n    // take care of https stuff - most of the time it's only needed to\n    // secure client/server comm\n    // not to establish the identity of the server\n    if (httpConn instanceof HttpsURLConnection) {\n      HttpsURLConnection httpsConn = (HttpsURLConnection) httpConn;\n      httpsConn.setSSLSocketFactory(\n          TrustAllSslSocketFactory.createSSLSocketFactory());\n      httpsConn.setHostnameVerifier((arg0, arg1) -> true);\n    }\n\n    return httpConn;\n  }", "code_tokens": ["public", "static", "HttpURLConnection", "getURLConnection", "(", "String", "url", ")", "throws", "IOException", "{", "URLConnection", "conn", "=", "new", "URL", "(", "url", ")", ".", "openConnection", "(", ")", ";", "final", "HttpURLConnection", "httpConn", "=", "(", "HttpURLConnection", ")", "conn", ";", "if", "(", "httpConn", "instanceof", "HttpsURLConnection", ")", "{", "HttpsURLConnection", "httpsConn", "=", "(", "HttpsURLConnection", ")", "httpConn", ";", "httpsConn", ".", "setSSLSocketFactory", "(", "TrustAllSslSocketFactory", ".", "createSSLSocketFactory", "(", ")", ")", ";", "httpsConn", ".", "setHostnameVerifier", "(", "(", "arg0", ",", "arg1", ")", "->", "true", ")", ";", "}", "return", "httpConn", ";", "}"], "idx": 40029, "cwe": "CWE-295", "target": 1, "status": "VULNERABLE", "commit": "43eeafcbac29d02c72bd520c003cdfc571de2d15", "function_name": "getURLConnection", "body_hash": "650fb27ed0fcfc8d883c2bdfb29b5fbbff524e4c"}
{"code": "public static String detectDataDirectory() {\n\n        String dataPath = System.getProperty(JBOSS_SERVER_DATA_DIR);\n\n        if (dataPath != null){\n            // we assume jboss.server.data.dir is managed externally so just use it as is.\n            File dataDir = new File(dataPath);\n            if (!dataDir.exists() || !dataDir.isDirectory()) {\n                throw new RuntimeException(\"Invalid \" + JBOSS_SERVER_DATA_DIR + \" resources directory: \" + dataPath);\n            }\n\n            return dataPath;\n        }\n\n        // we generate a dynamic jboss.server.data.dir and remove it at the end.\n        try {\n          File tempKeycloakFolder = Platform.getPlatform().getTmpDirectory();\n          File tmpDataDir = new File(tempKeycloakFolder, \"/data\");\n\n          if (tmpDataDir.mkdirs()) {\n            tmpDataDir.deleteOnExit();\n          } else {\n            throw new IOException(\"Could not create directory \" + tmpDataDir);\n          }\n\n          dataPath = tmpDataDir.getAbsolutePath();\n        } catch (IOException ioe){\n          throw new RuntimeException(\"Could not create temporary \" + JBOSS_SERVER_DATA_DIR, ioe);\n        }\n\n        return dataPath;\n    }", "code_tokens": ["public", "static", "String", "detectDataDirectory", "(", ")", "{", "String", "dataPath", "=", "System", ".", "getProperty", "(", "JBOSS_SERVER_DATA_DIR", ")", ";", "if", "(", "dataPath", "!=", "null", ")", "{", "File", "dataDir", "=", "new", "File", "(", "dataPath", ")", ";", "if", "(", "!", "dataDir", ".", "exists", "(", ")", "||", "!", "dataDir", ".", "isDirectory", "(", ")", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Invalid ", "\"", "+", "JBOSS_SERVER_DATA_DIR", "+", "\"", " resources directory: ", "\"", "+", "dataPath", ")", ";", "}", "return", "dataPath", ";", "}", "try", "{", "File", "tempKeycloakFolder", "=", "Platform", ".", "getPlatform", "(", ")", ".", "getTmpDirectory", "(", ")", ";", "File", "tmpDataDir", "=", "new", "File", "(", "tempKeycloakFolder", ",", "\"", "/data", "\"", ")", ";", "if", "(", "tmpDataDir", ".", "mkdirs", "(", ")", ")", "{", "tmpDataDir", ".", "deleteOnExit", "(", ")", ";", "}", "else", "{", "throw", "new", "IOException", "(", "\"", "Could not create directory ", "\"", "+", "tmpDataDir", ")", ";", "}", "dataPath", "=", "tmpDataDir", ".", "getAbsolutePath", "(", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "RuntimeException", "(", "\"", "Could not create temporary ", "\"", "+", "JBOSS_SERVER_DATA_DIR", ",", "ioe", ")", ";", "}", "return", "dataPath", ";", "}"], "idx": 49485, "cwe": "CWE-377", "target": 0, "status": "FIXED", "commit": "853a6d73276849877819f2dc23133557f6e1e601", "function_name": "detectDataDirectory", "body_hash": "a23e107b57392219d52d9e1988652d92dcfed480"}
{"code": "protected void configureParser(final XMLReader parser, final SAXHandler contentHandler)\n\t\t\tthrows JDOMException {\n\n\t\t// Setup SAX handlers.\n\n\t\tparser.setContentHandler(contentHandler);\n\n\t\tif (saxEntityResolver != null) {\n\t\t\tparser.setEntityResolver(saxEntityResolver);\n\t\t}\n\n\t\tif (saxDTDHandler != null) {\n\t\t\tparser.setDTDHandler(saxDTDHandler);\n\t\t} else {\n\t\t\tparser.setDTDHandler(contentHandler);\n\t\t}\n\n\t\tif (saxErrorHandler != null) {\n\t\t\tparser.setErrorHandler(saxErrorHandler);\n\t\t} else {\n\t\t\tparser.setErrorHandler(new BuilderErrorHandler());\n\t\t}\n\n\t\tboolean success = false;\n\n\t\ttry {\n\t\t\tparser.setProperty(SAX_PROPERTY_LEXICAL_HANDLER,\n\t\t\t\t\tcontentHandler);\n\t\t\tsuccess = true;\n\t\t} catch (final SAXNotSupportedException e) {\n\t\t\t// No lexical reporting available\n\t\t} catch (final SAXNotRecognizedException e) {\n\t\t\t// No lexical reporting available\n\t\t}\n\n\t\t// Some parsers use alternate property for lexical handling (grr...)\n\t\tif (!success) {\n\t\t\ttry {\n\t\t\t\tparser.setProperty(SAX_PROPERTY_LEXICAL_HANDLER_ALT,\n\t\t\t\t\t\tcontentHandler);\n\t\t\t\tsuccess = true;\n\t\t\t} catch (final SAXNotSupportedException e) {\n\t\t\t\t// No lexical reporting available\n\t\t\t} catch (final SAXNotRecognizedException e) {\n\t\t\t\t// No lexical reporting available\n\t\t\t}\n\t\t}\n\n\t\t// Set any user-specified properties on the parser.\n\t\tfor (final Map.Entry<String, Object> me : properties.entrySet()) {\n\t\t\tinternalSetProperty(parser, me.getKey(), me.getValue(), me.getKey());\n\t\t}\n\n\t\t// Set entity expansion\n\t\t// Note SAXHandler can work regardless of how this is set, but when\n\t\t// entity expansion it's worth it to try to tell the parser not to\n\t\t// even bother with external general entities.\n\t\t// Apparently no parsers yet support this feature.\n\t\t// XXX It might make sense to setEntityResolver() with a resolver\n\t\t// that simply ignores external general entities\n\t\ttry {\n\t\t\tif (parser.getFeature(SAX_FEATURE_EXTERNAL_ENT) != expand) {\n\t\t\t\tparser.setFeature(SAX_FEATURE_EXTERNAL_ENT, expand);\n\t\t\t}\n\t\t} catch (final SAXException e) { /* Ignore... */\n\t\t}\n\n\t\t// Try setting the DeclHandler if entity expansion is off\n\t\tif (!expand) {\n\t\t\ttry {\n\t\t\t\tparser.setProperty(SAX_PROPERTY_DECLARATION_HANDLER,\n\t\t\t\t\t\tcontentHandler);\n\t\t\t\tsuccess = true;\n\t\t\t} catch (final SAXNotSupportedException e) {\n\t\t\t\t// No lexical reporting available\n\t\t\t} catch (final SAXNotRecognizedException e) {\n\t\t\t\t// No lexical reporting available\n\t\t\t}\n\t\t}\n\t\t// Set any user-specified features on the parser.\n\t\tfor (final Map.Entry<String, Boolean> me : features.entrySet()) {\n\t\t\tinternalSetFeature(parser, me.getKey(), me.getValue().booleanValue(), me.getKey());\n\t\t}\n\t}", "code_tokens": ["protected", "void", "configureParser", "(", "final", "XMLReader", "parser", ",", "final", "SAXHandler", "contentHandler", ")", "throws", "JDOMException", "{", "parser", ".", "setContentHandler", "(", "contentHandler", ")", ";", "if", "(", "saxEntityResolver", "!=", "null", ")", "{", "parser", ".", "setEntityResolver", "(", "saxEntityResolver", ")", ";", "}", "if", "(", "saxDTDHandler", "!=", "null", ")", "{", "parser", ".", "setDTDHandler", "(", "saxDTDHandler", ")", ";", "}", "else", "{", "parser", ".", "setDTDHandler", "(", "contentHandler", ")", ";", "}", "if", "(", "saxErrorHandler", "!=", "null", ")", "{", "parser", ".", "setErrorHandler", "(", "saxErrorHandler", ")", ";", "}", "else", "{", "parser", ".", "setErrorHandler", "(", "new", "BuilderErrorHandler", "(", ")", ")", ";", "}", "boolean", "success", "=", "false", ";", "try", "{", "parser", ".", "setProperty", "(", "SAX_PROPERTY_LEXICAL_HANDLER", ",", "contentHandler", ")", ";", "success", "=", "true", ";", "}", "catch", "(", "final", "SAXNotSupportedException", "e", ")", "{", "}", "catch", "(", "final", "SAXNotRecognizedException", "e", ")", "{", "}", "if", "(", "!", "success", ")", "{", "try", "{", "parser", ".", "setProperty", "(", "SAX_PROPERTY_LEXICAL_HANDLER_ALT", ",", "contentHandler", ")", ";", "success", "=", "true", ";", "}", "catch", "(", "final", "SAXNotSupportedException", "e", ")", "{", "}", "catch", "(", "final", "SAXNotRecognizedException", "e", ")", "{", "}", "}", "for", "(", "final", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "me", ":", "properties", ".", "entrySet", "(", ")", ")", "{", "internalSetProperty", "(", "parser", ",", "me", ".", "getKey", "(", ")", ",", "me", ".", "getValue", "(", ")", ",", "me", ".", "getKey", "(", ")", ")", ";", "}", "try", "{", "if", "(", "parser", ".", "getFeature", "(", "SAX_FEATURE_EXTERNAL_ENT", ")", "!=", "expand", ")", "{", "parser", ".", "setFeature", "(", "SAX_FEATURE_EXTERNAL_ENT", ",", "expand", ")", ";", "}", "}", "catch", "(", "final", "SAXException", "e", ")", "{", "}", "if", "(", "!", "expand", ")", "{", "try", "{", "parser", ".", "setProperty", "(", "SAX_PROPERTY_DECLARATION_HANDLER", ",", "contentHandler", ")", ";", "success", "=", "true", ";", "}", "catch", "(", "final", "SAXNotSupportedException", "e", ")", "{", "}", "catch", "(", "final", "SAXNotRecognizedException", "e", ")", "{", "}", "}", "for", "(", "final", "Map", ".", "Entry", "<", "String", ",", "Boolean", ">", "me", ":", "features", ".", "entrySet", "(", ")", ")", "{", "internalSetFeature", "(", "parser", ",", "me", ".", "getKey", "(", ")", ",", "me", ".", "getValue", "(", ")", ".", "booleanValue", "(", ")", ",", "me", ".", "getKey", "(", ")", ")", ";", "}", "}"], "idx": 67328, "cwe": "CWE-611", "target": 0, "status": "FIXED", "commit": "bd3ab78370098491911d7fe9d7a43b97144a234e", "function_name": "configureParser", "body_hash": "bb79f9f47b06d71b047ba68d823ab0ba237c9ba7"}
{"code": "public File createTempFile(final Project project, String prefix, String suffix,\n            final File parentDir, final boolean deleteOnExit, final boolean createFile) {\n        File result;\n        String p = null;\n        if (parentDir != null) {\n            p = parentDir.getPath();\n        } else if (project != null && project.getProperty(MagicNames.TMPDIR) != null) {\n            p = project.getProperty(MagicNames.TMPDIR);\n        } else if (project != null && deleteOnExit) {\n            if (project.getProperty(MagicNames.AUTO_TMPDIR) != null) {\n                p = project.getProperty(MagicNames.AUTO_TMPDIR);\n            } else {\n                final Path systemTempDirPath =\n                    new File(System.getProperty(\"java.io.tmpdir\")).toPath();\n                final PosixFileAttributeView systemTempDirPosixAttributes =\n                    Files.getFileAttributeView(systemTempDirPath, PosixFileAttributeView.class);\n                if (systemTempDirPosixAttributes != null) {\n                    // no reason to create an extra temp dir if we cannot set permissions\n                    try {\n                        final File projectTempDir = Files.createTempDirectory(systemTempDirPath,\n                            \"ant\", TMPDIR_ATTRIBUTES)\n                            .toFile();\n                        projectTempDir.deleteOnExit();\n                        p = projectTempDir.getAbsolutePath();\n                        project.setProperty(MagicNames.AUTO_TMPDIR, p);\n                    } catch (IOException ex) {\n                        // silently fall back to system temp directory\n                    }\n                }\n            }\n        }\n        final String parent = p != null ? p : System.getProperty(\"java.io.tmpdir\");\n        if (prefix == null) {\n            prefix = NULL_PLACEHOLDER;\n        }\n        if (suffix == null) {\n            suffix = NULL_PLACEHOLDER;\n        }\n\n        if (createFile) {\n            try {\n                final Path parentPath = new File(parent).toPath();\n                final PosixFileAttributeView parentPosixAttributes =\n                    Files.getFileAttributeView(parentPath, PosixFileAttributeView.class);\n                result = Files.createTempFile(parentPath, prefix, suffix,\n                    parentPosixAttributes != null ? TMPFILE_ATTRIBUTES : NO_TMPFILE_ATTRIBUTES)\n                    .toFile();\n            } catch (IOException e) {\n                throw new BuildException(\"Could not create tempfile in \"\n                        + parent, e);\n            }\n        } else {\n            DecimalFormat fmt = new DecimalFormat(\"#####\");\n            synchronized (rand) {\n                do {\n                    result = new File(parent, prefix\n                            + fmt.format(rand.nextInt(Integer.MAX_VALUE)) + suffix);\n                } while (result.exists());\n            }\n        }\n\n        if (deleteOnExit) {\n            result.deleteOnExit();\n        }\n        return result;\n    }", "code_tokens": ["public", "File", "createTempFile", "(", "final", "Project", "project", ",", "String", "prefix", ",", "String", "suffix", ",", "final", "File", "parentDir", ",", "final", "boolean", "deleteOnExit", ",", "final", "boolean", "createFile", ")", "{", "File", "result", ";", "String", "p", "=", "null", ";", "if", "(", "parentDir", "!=", "null", ")", "{", "p", "=", "parentDir", ".", "getPath", "(", ")", ";", "}", "else", "if", "(", "project", "!=", "null", "&&", "project", ".", "getProperty", "(", "MagicNames", ".", "TMPDIR", ")", "!=", "null", ")", "{", "p", "=", "project", ".", "getProperty", "(", "MagicNames", ".", "TMPDIR", ")", ";", "}", "else", "if", "(", "project", "!=", "null", "&&", "deleteOnExit", ")", "{", "if", "(", "project", ".", "getProperty", "(", "MagicNames", ".", "AUTO_TMPDIR", ")", "!=", "null", ")", "{", "p", "=", "project", ".", "getProperty", "(", "MagicNames", ".", "AUTO_TMPDIR", ")", ";", "}", "else", "{", "final", "Path", "systemTempDirPath", "=", "new", "File", "(", "System", ".", "getProperty", "(", "\"", "java.io.tmpdir", "\"", ")", ")", ".", "toPath", "(", ")", ";", "final", "PosixFileAttributeView", "systemTempDirPosixAttributes", "=", "Files", ".", "getFileAttributeView", "(", "systemTempDirPath", ",", "PosixFileAttributeView", ".", "class", ")", ";", "if", "(", "systemTempDirPosixAttributes", "!=", "null", ")", "{", "try", "{", "final", "File", "projectTempDir", "=", "Files", ".", "createTempDirectory", "(", "systemTempDirPath", ",", "\"", "ant", "\"", ",", "TMPDIR_ATTRIBUTES", ")", ".", "toFile", "(", ")", ";", "projectTempDir", ".", "deleteOnExit", "(", ")", ";", "p", "=", "projectTempDir", ".", "getAbsolutePath", "(", ")", ";", "project", ".", "setProperty", "(", "MagicNames", ".", "AUTO_TMPDIR", ",", "p", ")", ";", "}", "catch", "(", "IOException", "ex", ")", "{", "}", "}", "}", "}", "final", "String", "parent", "=", "p", "!=", "null", "?", "p", ":", "System", ".", "getProperty", "(", "\"", "java.io.tmpdir", "\"", ")", ";", "if", "(", "prefix", "==", "null", ")", "{", "prefix", "=", "NULL_PLACEHOLDER", ";", "}", "if", "(", "suffix", "==", "null", ")", "{", "suffix", "=", "NULL_PLACEHOLDER", ";", "}", "if", "(", "createFile", ")", "{", "try", "{", "final", "Path", "parentPath", "=", "new", "File", "(", "parent", ")", ".", "toPath", "(", ")", ";", "final", "PosixFileAttributeView", "parentPosixAttributes", "=", "Files", ".", "getFileAttributeView", "(", "parentPath", ",", "PosixFileAttributeView", ".", "class", ")", ";", "result", "=", "Files", ".", "createTempFile", "(", "parentPath", ",", "prefix", ",", "suffix", ",", "parentPosixAttributes", "!=", "null", "?", "TMPFILE_ATTRIBUTES", ":", "NO_TMPFILE_ATTRIBUTES", ")", ".", "toFile", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "BuildException", "(", "\"", "Could not create tempfile in ", "\"", "+", "parent", ",", "e", ")", ";", "}", "}", "else", "{", "DecimalFormat", "fmt", "=", "new", "DecimalFormat", "(", "\"", "#####", "\"", ")", ";", "synchronized", "(", "rand", ")", "{", "do", "{", "result", "=", "new", "File", "(", "parent", ",", "prefix", "+", "fmt", ".", "format", "(", "rand", ".", "nextInt", "(", "Integer", ".", "MAX_VALUE", ")", ")", "+", "suffix", ")", ";", "}", "while", "(", "result", ".", "exists", "(", ")", ")", ";", "}", "}", "if", "(", "deleteOnExit", ")", "{", "result", ".", "deleteOnExit", "(", ")", ";", "}", "return", "result", ";", "}"], "idx": 115682, "cwe": "NVD-CWE-Other", "target": 0, "status": "FIXED", "commit": "87ac51d3c22bcf7cfd0dc07cb0bd04a496e0d428", "function_name": "createTempFile", "body_hash": "5ef5d6d27ef29fc1dcf8c12bbd25b3a1086002bb"}
{"code": "private void addInputFilter(InputFilter[] inputFilters, String encodingName) {\n        if (contentDelimitation) {\n            // Chunked has already been specified and it must be the final\n            // encoding.\n            // 400 - Bad request\n            response.setStatus(400);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\") +\n                          \" Tranfer encoding lists chunked before [\" + encodingName + \"]\");\n            }\n            return;\n        }\n\n        // Parsing trims and converts to lower case.\n        if (encodingName.equals(\"chunked\")) {\n            inputBuffer.addActiveFilter(inputFilters[Constants.CHUNKED_FILTER]);\n            contentDelimitation = true;\n        } else {\n            for (int i = pluggableFilterIndex; i < inputFilters.length; i++) {\n                if (inputFilters[i].getEncodingName().toString().equals(encodingName)) {\n                    inputBuffer.addActiveFilter(inputFilters[i]);\n                    return;\n                }\n            }\n            // Unsupported transfer encoding\n            // 501 - Unimplemented\n            response.setStatus(501);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\") +\n                          \" Unsupported transfer encoding [\" + encodingName + \"]\");\n            }\n        }\n    }", "code_tokens": ["private", "void", "addInputFilter", "(", "InputFilter", "[", "]", "inputFilters", ",", "String", "encodingName", ")", "{", "if", "(", "contentDelimitation", ")", "{", "response", ".", "setStatus", "(", "400", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Tranfer encoding lists chunked before [", "\"", "+", "encodingName", "+", "\"", "]", "\"", ")", ";", "}", "return", ";", "}", "if", "(", "encodingName", ".", "equals", "(", "\"", "chunked", "\"", ")", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "Constants", ".", "CHUNKED_FILTER", "]", ")", ";", "contentDelimitation", "=", "true", ";", "}", "else", "{", "for", "(", "int", "i", "=", "pluggableFilterIndex", ";", "i", "<", "inputFilters", ".", "length", ";", "i", "++", ")", "{", "if", "(", "inputFilters", "[", "i", "]", ".", "getEncodingName", "(", ")", ".", "toString", "(", ")", ".", "equals", "(", "encodingName", ")", ")", "{", "inputBuffer", ".", "addActiveFilter", "(", "inputFilters", "[", "i", "]", ")", ";", "return", ";", "}", "}", "response", ".", "setStatus", "(", "501", ")", ";", "setErrorState", "(", "ErrorState", ".", "CLOSE_CLEAN", ",", "null", ")", ";", "if", "(", "log", ".", "isDebugEnabled", "(", ")", ")", "{", "log", ".", "debug", "(", "sm", ".", "getString", "(", "\"", "http11processor.request.prepare", "\"", ")", "+", "\"", " Unsupported transfer encoding [", "\"", "+", "encodingName", "+", "\"", "]", "\"", ")", ";", "}", "}", "}"], "idx": 54486, "cwe": "CWE-444", "target": 0, "status": "FIXED", "commit": "19d11556d0db99df291df33605f137976d152475", "function_name": "addInputFilter", "body_hash": "12eddd0e7675dc7d380011c155c5ef4cbce05d11"}
{"code": "public void updateByXml(final InputStream source) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        Node result = (Node)Jenkins.XSTREAM2.fromXML(source);\n        Jenkins.get().getNodesObject().replaceNode(this.getNode(), result);\n    }", "code_tokens": ["public", "void", "updateByXml", "(", "final", "InputStream", "source", ")", "throws", "IOException", ",", "ServletException", "{", "checkPermission", "(", "CONFIGURE", ")", ";", "Node", "result", "=", "(", "Node", ")", "Jenkins", ".", "XSTREAM2", ".", "fromXML", "(", "source", ")", ";", "Jenkins", ".", "get", "(", ")", ".", "getNodesObject", "(", ")", ".", "replaceNode", "(", "this", ".", "getNode", "(", ")", ",", "result", ")", ";", "}"], "idx": 6876, "cwe": "CWE-20", "target": 1, "status": "VULNERABLE", "commit": "84210baed0c866bdee3e59271f98a767a14a5509", "function_name": "updateByXml", "body_hash": "9e838065c13a60a8841bd6595a5af73440756148"}
{"code": "@Override\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n\n    User delegatedUser = delegatedUserHolder.get();\n\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    if (auth instanceof AnonymousAuthenticationToken) {\n      return SecurityUtil.createAnonymousUser(org);\n    }\n\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        // If user exists, fetch it from the userDirectory\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\"Authenticated user '{}' could not be found in any of the current UserProviders. \"\n                + \"Continuing anyway...\", userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n        }\n\n        // Add the roles (authorities) in the security context\n        Set<JaxbRole> roles = new HashSet<>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n        }\n\n        if (user == null) {\n          // No user was found. Create one to hold the auth information from the security context\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          // Combine the existing user with the roles in the security context\n          user = JaxbUser.fromUser(user, roles);\n        }\n\n        // Save the user to retrieve it quicker the next time(s) this method is called (by this thread)\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n    }\n\n    // Return the anonymous user by default\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }", "code_tokens": ["@", "Override", "public", "User", "getUser", "(", ")", "throws", "IllegalStateException", "{", "Organization", "org", "=", "getOrganization", "(", ")", ";", "if", "(", "org", "==", "null", ")", "throw", "new", "IllegalStateException", "(", "\"", "No organization is set in security context", "\"", ")", ";", "User", "delegatedUser", "=", "delegatedUserHolder", ".", "get", "(", ")", ";", "Authentication", "auth", "=", "SecurityContextHolder", ".", "getContext", "(", ")", ".", "getAuthentication", "(", ")", ";", "if", "(", "auth", "instanceof", "AnonymousAuthenticationToken", ")", "{", "return", "SecurityUtil", ".", "createAnonymousUser", "(", "org", ")", ";", "}", "if", "(", "delegatedUser", "!=", "null", ")", "{", "return", "delegatedUser", ";", "}", "JaxbOrganization", "jaxbOrganization", "=", "JaxbOrganization", ".", "fromOrganization", "(", "org", ")", ";", "if", "(", "auth", "!=", "null", ")", "{", "Object", "principal", "=", "auth", ".", "getPrincipal", "(", ")", ";", "if", "(", "(", "principal", "instanceof", "UserDetails", ")", ")", "{", "UserDetails", "userDetails", "=", "(", "UserDetails", ")", "principal", ";", "User", "user", "=", "null", ";", "if", "(", "userDirectory", "!=", "null", ")", "{", "user", "=", "userDirectory", ".", "loadUser", "(", "userDetails", ".", "getUsername", "(", ")", ")", ";", "if", "(", "user", "==", "null", ")", "{", "logger", ".", "debug", "(", "\"", "Authenticated user '{}' could not be found in any of the current UserProviders. ", "\"", "+", "\"", "Continuing anyway...", "\"", ",", "userDetails", ".", "getUsername", "(", ")", ")", ";", "}", "}", "else", "{", "logger", ".", "debug", "(", "\"", "No UserDirectory was found when trying to search for user '{}'", "\"", ",", "userDetails", ".", "getUsername", "(", ")", ")", ";", "}", "Set", "<", "JaxbRole", ">", "roles", "=", "new", "HashSet", "<", ">", "(", ")", ";", "Collection", "<", "?", "extends", "GrantedAuthority", ">", "authorities", "=", "auth", ".", "getAuthorities", "(", ")", ";", "if", "(", "authorities", "!=", "null", ")", "{", "for", "(", "GrantedAuthority", "ga", ":", "authorities", ")", "{", "roles", ".", "add", "(", "new", "JaxbRole", "(", "ga", ".", "getAuthority", "(", ")", ",", "jaxbOrganization", ")", ")", ";", "}", "}", "if", "(", "user", "==", "null", ")", "{", "user", "=", "new", "JaxbUser", "(", "userDetails", ".", "getUsername", "(", ")", ",", "null", ",", "jaxbOrganization", ",", "roles", ")", ";", "}", "else", "{", "user", "=", "JaxbUser", ".", "fromUser", "(", "user", ",", "roles", ")", ";", "}", "delegatedUserHolder", ".", "set", "(", "user", ")", ";", "return", "user", ";", "}", "}", "return", "SecurityUtil", ".", "createAnonymousUser", "(", "jaxbOrganization", ")", ";", "}"], "idx": 38996, "cwe": "CWE-287", "target": 0, "status": "FIXED", "commit": "b157e1fb3b35991ca7bf59f0730329fbe7ce82e8", "function_name": "getUser", "body_hash": "b54f6b0a48d3592c93f73a25cda163f2723a3630"}
{"code": "public static String normalize(String path, boolean replaceBackSlash) {\n\n        if (path == null) {\n            return null;\n        }\n\n        // Create a place for the normalized path\n        String normalized = path;\n\n        if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n            normalized = normalized.replace('\\\\', '/');\n\n        // Add a leading \"/\" if necessary\n        if (!normalized.startsWith(\"/\"))\n            normalized = \"/\" + normalized;\n\n        if (normalized.equals(\"/.\")) {\n            return \"/\";\n        }\n\n        if (normalized.equals(\"/..\")) {\n            return null;  // Trying to go outside our context\n        }\n\n        // Resolve occurrences of \"//\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"//\");\n            if (index < 0) {\n                break;\n            }\n            normalized = normalized.substring(0, index) + normalized.substring(index + 1);\n        }\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/./\");\n            if (index < 0) {\n                break;\n            }\n            normalized = normalized.substring(0, index) + normalized.substring(index + 2);\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int index = normalized.indexOf(\"/../\");\n            if (index < 0) {\n                break;\n            }\n            if (index == 0) {\n                return null;  // Trying to go outside our context\n            }\n            int index2 = normalized.lastIndexOf('/', index - 1);\n            normalized = normalized.substring(0, index2) + normalized.substring(index + 3);\n        }\n\n        // Return the normalized path that we have completed\n        return normalized;\n    }", "code_tokens": ["public", "static", "String", "normalize", "(", "String", "path", ",", "boolean", "replaceBackSlash", ")", "{", "if", "(", "path", "==", "null", ")", "{", "return", "null", ";", "}", "String", "normalized", "=", "path", ";", "if", "(", "replaceBackSlash", "&&", "normalized", ".", "indexOf", "(", "'\\\\'", ")", ">=", "0", ")", "normalized", "=", "normalized", ".", "replace", "(", "'\\\\'", ",", "'/'", ")", ";", "if", "(", "!", "normalized", ".", "startsWith", "(", "\"", "/", "\"", ")", ")", "normalized", "=", "\"", "/", "\"", "+", "normalized", ";", "if", "(", "normalized", ".", "equals", "(", "\"", "/.", "\"", ")", ")", "{", "return", "\"", "/", "\"", ";", "}", "if", "(", "normalized", ".", "equals", "(", "\"", "/..", "\"", ")", ")", "{", "return", "null", ";", "}", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "//", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "{", "break", ";", "}", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index", ")", "+", "normalized", ".", "substring", "(", "index", "+", "1", ")", ";", "}", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "/./", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "{", "break", ";", "}", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index", ")", "+", "normalized", ".", "substring", "(", "index", "+", "2", ")", ";", "}", "while", "(", "true", ")", "{", "int", "index", "=", "normalized", ".", "indexOf", "(", "\"", "/../", "\"", ")", ";", "if", "(", "index", "<", "0", ")", "{", "break", ";", "}", "if", "(", "index", "==", "0", ")", "{", "return", "null", ";", "}", "int", "index2", "=", "normalized", ".", "lastIndexOf", "(", "'/'", ",", "index", "-", "1", ")", ";", "normalized", "=", "normalized", ".", "substring", "(", "0", ",", "index2", ")", "+", "normalized", ".", "substring", "(", "index", "+", "3", ")", ";", "}", "return", "normalized", ";", "}"], "idx": 23757, "cwe": "CWE-22", "target": 0, "status": "FIXED", "commit": "2fc9d03ffbc3fe7eabfd272380807ac0ddcf748d", "function_name": "normalize", "body_hash": "b39374c3ce54021a1882194b573dc635ed1bc06b"}
{"code": "@Override\n    public WireFormat createWireFormat() {\n        WireFormatInfo info = new WireFormatInfo();\n        info.setVersion(version);\n\n        try {\n            info.setStackTraceEnabled(stackTraceEnabled);\n            info.setCacheEnabled(cacheEnabled);\n            info.setTcpNoDelayEnabled(tcpNoDelayEnabled);\n            info.setTightEncodingEnabled(tightEncodingEnabled);\n            info.setSizePrefixDisabled(sizePrefixDisabled);\n            info.setMaxInactivityDuration(maxInactivityDuration);\n            info.setMaxInactivityDurationInitalDelay(maxInactivityDurationInitalDelay);\n            info.setCacheSize(cacheSize);\n            info.setMaxFrameSize(maxFrameSize);\n            if( host!=null ) {\n                info.setHost(host);\n            }\n            info.setProviderName(providerName);\n            info.setProviderVersion(providerVersion);\n            if (includePlatformDetails) {\n                platformDetails = ActiveMQConnectionMetaData.PLATFORM_DETAILS;\n            }\n            info.setPlatformDetails(platformDetails);\n        } catch (Exception e) {\n            IllegalStateException ise = new IllegalStateException(\"Could not configure WireFormatInfo\");\n            ise.initCause(e);\n            throw ise;\n        }\n\n        OpenWireFormat f = new OpenWireFormat(version);\n        f.setMaxFrameSize(maxFrameSize);\n        f.setPreferedWireFormatInfo(info);\n        return f;\n    }", "code_tokens": ["@", "Override", "public", "WireFormat", "createWireFormat", "(", ")", "{", "WireFormatInfo", "info", "=", "new", "WireFormatInfo", "(", ")", ";", "info", ".", "setVersion", "(", "version", ")", ";", "try", "{", "info", ".", "setStackTraceEnabled", "(", "stackTraceEnabled", ")", ";", "info", ".", "setCacheEnabled", "(", "cacheEnabled", ")", ";", "info", ".", "setTcpNoDelayEnabled", "(", "tcpNoDelayEnabled", ")", ";", "info", ".", "setTightEncodingEnabled", "(", "tightEncodingEnabled", ")", ";", "info", ".", "setSizePrefixDisabled", "(", "sizePrefixDisabled", ")", ";", "info", ".", "setMaxInactivityDuration", "(", "maxInactivityDuration", ")", ";", "info", ".", "setMaxInactivityDurationInitalDelay", "(", "maxInactivityDurationInitalDelay", ")", ";", "info", ".", "setCacheSize", "(", "cacheSize", ")", ";", "info", ".", "setMaxFrameSize", "(", "maxFrameSize", ")", ";", "if", "(", "host", "!=", "null", ")", "{", "info", ".", "setHost", "(", "host", ")", ";", "}", "info", ".", "setProviderName", "(", "providerName", ")", ";", "info", ".", "setProviderVersion", "(", "providerVersion", ")", ";", "if", "(", "includePlatformDetails", ")", "{", "platformDetails", "=", "ActiveMQConnectionMetaData", ".", "PLATFORM_DETAILS", ";", "}", "info", ".", "setPlatformDetails", "(", "platformDetails", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "IllegalStateException", "ise", "=", "new", "IllegalStateException", "(", "\"", "Could not configure WireFormatInfo", "\"", ")", ";", "ise", ".", "initCause", "(", "e", ")", ";", "throw", "ise", ";", "}", "OpenWireFormat", "f", "=", "new", "OpenWireFormat", "(", "version", ")", ";", "f", ".", "setMaxFrameSize", "(", "maxFrameSize", ")", ";", "f", ".", "setPreferedWireFormatInfo", "(", "info", ")", ";", "return", "f", ";", "}"], "idx": 12413, "cwe": "CWE-200", "target": 0, "status": "FIXED", "commit": "5fa0bbd5156f29d97dcf48fd9fdb6a0488a8df1a", "function_name": "createWireFormat", "body_hash": "36d062c81ec1ebc50983106ce4fb1c25b87769ca"}
