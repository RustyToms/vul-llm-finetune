{"code":"static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n","idx":17554,"target":1}
{"code":"static int set_group_privs(void)\n{\n    if (!geteuid()) {\n        const char *name;\n\n        \/* Get username if passed as a uid *\/\n\n        if (unixd_config.user_name[0] == '#') {\n            struct passwd *ent;\n            uid_t uid = atoi(&unixd_config.user_name[1]);\n\n            if ((ent = getpwuid(uid)) == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                         \"getpwuid: couldn't determine user name from uid %u, \"\n                         \"you probably need to modify the User directive\",\n                         (unsigned)uid);\n                return -1;\n            }\n\n            name = ent->pw_name;\n        }\n        else\n            name = unixd_config.user_name;\n\n#if !defined(OS2) && !defined(TPF)\n        \/* OS\/2 and TPF don't support groups. *\/\n\n        \/*\n         * Set the GID before initgroups(), since on some platforms\n         * setgid() is known to zap the group list.\n         *\/\n        if (setgid(unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"setgid: unable to set group id to Group %u\",\n                        (unsigned)unixd_config.group_id);\n            return -1;\n        }\n\n        \/* Reset `groups' attributes. *\/\n\n        if (initgroups(name, unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,\n                        \"initgroups: unable to set groups for User %s \"\n                        \"and Group %u\", name, (unsigned)unixd_config.group_id);\n            return -1;\n        }\n#endif \/* !defined(OS2) && !defined(TPF) *\/\n    }\n    return 0;\n}","idx":6,"target":0}
{"code":"static int ea_read_header(AVFormatContext *s,\n                          AVFormatParameters *ap)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVStream *st;\n    if (!process_ea_header(s))\n        return AVERROR(EIO);\n    if (ea->video_codec) {\n        \/* initialize the video decoder stream *\/\n        st = av_new_stream(s, 0);\n        if (!st)\n            return AVERROR(ENOMEM);\n        ea->video_stream_index = st->index;\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codec->codec_id = ea->video_codec;\n        st->codec->codec_tag = 0;  \/* no fourcc *\/\n        st->codec->time_base = ea->time_base;\n        st->codec->width = ea->width;\n        st->codec->height = ea->height;\n    if (ea->num_channels <= 0) {\n        av_log(s, AV_LOG_WARNING, \"Unsupported number of channels: %d\\n\", ea->num_channels);\n    if (ea->audio_codec) {\n        \/* initialize the audio decoder stream *\/\n        st = av_new_stream(s, 0);\n        if (!st)\n            return AVERROR(ENOMEM);\n        av_set_pts_info(st, 33, 1, ea->sample_rate);\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_id = ea->audio_codec;\n        st->codec->codec_tag = 0;  \/* no tag *\/\n        st->codec->channels = ea->num_channels;\n        st->codec->sample_rate = ea->sample_rate;\n        st->codec->bits_per_coded_sample = ea->bytes * 8;\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n            st->codec->bits_per_coded_sample \/ 4;\n        st->codec->block_align = st->codec->channels*st->codec->bits_per_coded_sample;\n        ea->audio_stream_index = st->index;\n        ea->audio_frame_counter = 0;\n    return 1;","idx":7050,"target":1}
{"code":"AP_DECLARE(apr_port_t) ap_get_server_port(const request_rec *r)\n{\n    apr_port_t port;\n    core_dir_config *d =\n      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);\n\n    switch (d->use_canonical_name) {\n        case USE_CANONICAL_NAME_OFF:\n        case USE_CANONICAL_NAME_DNS:\n        case USE_CANONICAL_NAME_UNSET:\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            else \/* USE_CANONICAL_PHYS_PORT_OFF or USE_CANONICAL_PHYS_PORT_UNSET *\/\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        case USE_CANONICAL_NAME_ON:\n            \/* With UseCanonicalName on (and in all versions prior to 1.3)\n             * Apache will use the hostname and port specified in the\n             * ServerName directive to construct a canonical name for the\n             * server. (If no port was specified in the ServerName\n             * directive, Apache uses the port supplied by the client if\n             * any is supplied, and finally the default port for the protocol\n             * used.\n             *\/\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->server->port ? r->server->port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       ap_default_port(r);\n            else \/* USE_CANONICAL_PHYS_PORT_OFF or USE_CANONICAL_PHYS_PORT_UNSET *\/\n                port = r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                         \"ap_get_server_port: Invalid UCN Option somehow\");\n            port = ap_default_port(r);\n            break;\n    }\n\n    return port;\n}","idx":11,"target":0}
{"code":"void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n\n\n    if (!dc->hotpluggable) {\n\n        return;\n\n    }\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    if (dev->hotplugged) {\n\n        mdev->is_inserting = true;\n\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n\n    }\n\n}\n","idx":52,"target":0}
{"code":"static av_cold int vdadec_init(AVCodecContext *avctx)\n\n{\n\n    VDADecoderContext *ctx = avctx->priv_data;\n\n    struct vda_context *vda_ctx = &ctx->vda_ctx;\n\n    OSStatus status;\n\n    int ret;\n\n\n\n    ctx->h264_initialized = 0;\n\n\n\n    \/* init pix_fmts of codec *\/\n\n    if (!ff_h264_vda_decoder.pix_fmts) {\n\n        if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;\n\n        else\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts;\n\n    }\n\n\n\n    \/* init vda *\/\n\n    memset(vda_ctx, 0, sizeof(struct vda_context));\n\n    vda_ctx->width = avctx->width;\n\n    vda_ctx->height = avctx->height;\n\n    vda_ctx->format = 'avc1';\n\n    vda_ctx->use_sync_decoding = 1;\n\n    vda_ctx->use_ref_buffer = 1;\n\n    ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);\n\n    switch (ctx->pix_fmt) {\n\n    case AV_PIX_FMT_UYVY422:\n\n        vda_ctx->cv_pix_fmt_type = '2vuy';\n\n        break;\n\n    case AV_PIX_FMT_YUYV422:\n\n        vda_ctx->cv_pix_fmt_type = 'yuvs';\n\n        break;\n\n    case AV_PIX_FMT_NV12:\n\n        vda_ctx->cv_pix_fmt_type = '420v';\n\n        break;\n\n    case AV_PIX_FMT_YUV420P:\n\n        vda_ctx->cv_pix_fmt_type = 'y420';\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported pixel format: %d\\n\", avctx->pix_fmt);\n\n        goto failed;\n\n    }\n\n    status = ff_vda_create_decoder(vda_ctx,\n\n                                   avctx->extradata, avctx->extradata_size);\n\n    if (status != kVDADecoderNoErr) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n                \"Failed to init VDA decoder: %d.\\n\", status);\n\n        goto failed;\n\n    }\n\n    avctx->hwaccel_context = vda_ctx;\n\n\n\n    \/* changes callback functions *\/\n\n    avctx->get_format = get_format;\n\n    avctx->get_buffer2 = get_buffer2;\n\n#if FF_API_GET_BUFFER\n\n    \/\/ force the old get_buffer to be empty\n\n    avctx->get_buffer = NULL;\n\n#endif\n\n\n\n    \/* init H.264 decoder *\/\n\n    ret = ff_h264_decoder.init(avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 decoder.\\n\");\n\n        goto failed;\n\n    }\n\n    ctx->h264_initialized = 1;\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    vdadec_close(avctx);\n\n    return -1;\n\n}\n","idx":0,"target":0}
{"code":"static int find_allocation(BlockDriverState *bs, off_t start,\n\n                           off_t *data, off_t *hole)\n\n{\n\n    BDRVGlusterState *s = bs->opaque;\n\n    off_t offs;\n\n\n\n    if (!s->supports_seek_data) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    \/*\n\n     * SEEK_DATA cases:\n\n     * D1. offs == start: start is in data\n\n     * D2. offs > start: start is in a hole, next data at offs\n\n     * D3. offs < 0, errno = ENXIO: either start is in a trailing hole\n\n     *                              or start is beyond EOF\n\n     *     If the latter happens, the file has been truncated behind\n\n     *     our back since we opened it.  All bets are off then.\n\n     *     Treating like a trailing hole is simplest.\n\n     * D4. offs < 0, errno != ENXIO: we learned nothing\n\n     *\/\n\n    offs = glfs_lseek(s->fd, start, SEEK_DATA);\n\n    if (offs < 0) {\n\n        return -errno;          \/* D3 or D4 *\/\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        \/* D2: in hole, next data at offs *\/\n\n        *hole = start;\n\n        *data = offs;\n\n        return 0;\n\n    }\n\n\n\n    \/* D1: in data, end not yet known *\/\n\n\n\n    \/*\n\n     * SEEK_HOLE cases:\n\n     * H1. offs == start: start is in a hole\n\n     *     If this happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H2. offs > start: either start is in data, next hole at offs,\n\n     *                   or start is in trailing hole, EOF at offs\n\n     *     Linux treats trailing holes like any other hole: offs ==\n\n     *     start.  Solaris seeks to EOF instead: offs > start (blech).\n\n     *     If that happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H3. offs < 0, errno = ENXIO: start is beyond EOF\n\n     *     If this happens, the file has been truncated behind our\n\n     *     back since we opened it.  Treat it like a trailing hole.\n\n     * H4. offs < 0, errno != ENXIO: we learned nothing\n\n     *     Pretend we know nothing at all, i.e. \"forget\" about D1.\n\n     *\/\n\n    offs = glfs_lseek(s->fd, start, SEEK_HOLE);\n\n    if (offs < 0) {\n\n        return -errno;          \/* D1 and (H3 or H4) *\/\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        \/*\n\n         * D1 and H2: either in data, next hole at offs, or it was in\n\n         * data but is now in a trailing hole.  In the latter case,\n\n         * all bets are off.  Treating it as if it there was data all\n\n         * the way to EOF is safe, so simply do that.\n\n         *\/\n\n        *data = start;\n\n        *hole = offs;\n\n        return 0;\n\n    }\n\n\n\n    \/* D1 and H1 *\/\n\n    return -EBUSY;\n\n}\n","idx":46,"target":0}
{"code":"static long get_chunk_size(char *b)\n{\n    long chunksize = 0;\n    size_t chunkbits = sizeof(long) * 8;\n\n    ap_xlate_proto_from_ascii(b, strlen(b));\n\n    \/* Skip leading zeros *\/\n    while (*b == '0') {\n        ++b;\n    }\n\n    while (apr_isxdigit(*b) && (chunkbits > 0)) {\n        int xvalue = 0;\n\n        if (*b >= '0' && *b <= '9') {\n            xvalue = *b - '0';\n        }\n        else if (*b >= 'A' && *b <= 'F') {\n            xvalue = *b - 'A' + 0xa;\n        }\n        else if (*b >= 'a' && *b <= 'f') {\n            xvalue = *b - 'a' + 0xa;\n        }\n\n        chunksize = (chunksize << 4) | xvalue;\n        chunkbits -= 4;\n        ++b;\n    }\n    if (apr_isxdigit(*b) && (chunkbits <= 0)) {\n        \/* overflow *\/\n        return -1;\n    }\n\n    return chunksize;\n}","idx":12,"target":0}
{"code":"void gicv3_cpuif_update(GICv3CPUState *cs)\n{\n    \/* Tell the CPU about its highest priority pending interrupt *\/\n    int irqlevel = 0;\n    int fiqlevel = 0;\n    ARMCPU *cpu = ARM_CPU(cs->cpu);\n    CPUARMState *env = &cpu->env;\n    trace_gicv3_cpuif_update(gicv3_redist_affid(cs), cs->hppi.irq,\n                             cs->hppi.grp, cs->hppi.prio);\n    if (cs->hppi.grp == GICV3_G1 && !arm_feature(env, ARM_FEATURE_EL3)) {\n        \/* If a Security-enabled GIC sends a G1S interrupt to a\n         * Security-disabled CPU, we must treat it as if it were G0.\n         *\/\n        cs->hppi.grp = GICV3_G0;\n    }\n    if (icc_hppi_can_preempt(cs)) {\n        \/* We have an interrupt: should we signal it as IRQ or FIQ?\n         * This is described in the GICv3 spec section 4.6.2.\n         *\/\n        bool isfiq;\n        switch (cs->hppi.grp) {\n        case GICV3_G0:\n            isfiq = true;\n            break;\n        case GICV3_G1:\n            isfiq = (!arm_is_secure(env) ||\n                     (arm_current_el(env) == 3 && arm_el_is_aa64(env, 3)));\n            break;\n        case GICV3_G1NS:\n            isfiq = arm_is_secure(env);\n            break;\n        default:\n            g_assert_not_reached();\n        }\n        if (isfiq) {\n            fiqlevel = 1;\n        } else {\n            irqlevel = 1;\n        }\n    }\n    trace_gicv3_cpuif_set_irqs(gicv3_redist_affid(cs), fiqlevel, irqlevel);\n    qemu_set_irq(cs->parent_fiq, fiqlevel);\n    qemu_set_irq(cs->parent_irq, irqlevel);\n}","idx":5259,"target":1}
{"code":"static inline void refill_32(BitstreamContext *bc)\n{\n    if (bc->ptr >= bc->buffer_end)\n        return;\n\n#ifdef BITSTREAM_READER_LE\n    bc->bits       = (uint64_t)AV_RL32(bc->ptr) << bc->bits_left | bc->bits;\n#else\n    bc->bits       = bc->bits | (uint64_t)AV_RB32(bc->ptr) << (32 - bc->bits_left);\n#endif\n    bc->ptr       += 4;\n    bc->bits_left += 32;\n}","idx":1295451,"target":1}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}","idx":1291672,"target":1}
{"code":"av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n","idx":19,"target":0}
{"code":"static void tcp_wait_for_connect(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    int val, ret;\n\n    socklen_t valsize = sizeof(val);\n\n\n\n    DPRINTF(\"connect completed\\n\");\n\n    do {\n\n        ret = getsockopt(s->fd, SOL_SOCKET, SO_ERROR, (void *) &val, &valsize);\n\n    } while (ret == -1 && (socket_error()) == EINTR);\n\n\n\n    if (ret < 0) {\n\n        migrate_fd_error(s);\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s->fd, NULL, NULL, NULL, NULL);\n\n\n\n    if (val == 0)\n\n        migrate_fd_connect(s);\n\n    else {\n\n        DPRINTF(\"error connecting %d\\n\", val);\n\n        migrate_fd_error(s);\n\n    }\n\n}\n","idx":23032,"target":1}
{"code":"static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    \/* Allocate RMA if necessary *\/\n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        \/* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         *\/\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    \/* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary *\/\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    \/* We aim for a hash table of size 1\/128 the size of RAM.  The\n\n     * normal rule of thumb is 1\/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. *\/\n\n    spapr->htab_shift = 18; \/* Minimum architected size *\/\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    \/* Set up Interrupt Controller before we create the VCPUs *\/\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() \/ smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    \/* init CPUs *\/\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        \/* Set time-base frequency to 512 MHz *\/\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        \/* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         *\/\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        \/* Tell KVM that we're in PAPR mode *\/\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    \/* allocate RAM *\/\n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    \/* Set up EPOW events infrastructure *\/\n\n    spapr_events_init(spapr);\n\n\n\n    \/* Set up VIO bus *\/\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    \/* We always have at least the nvram device on VIO *\/\n\n    spapr_create_nvram(spapr);\n\n\n\n    \/* Set up PCI *\/\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    \/* Graphics *\/\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        \/* load initrd *\/\n\n        if (initrd_filename) {\n\n            \/* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             *\/\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr\/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    \/* Prepare the device tree *\/\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n","idx":43,"target":0}
{"code":"void gd_egl_scanout(DisplayChangeListener *dcl,\n\n                    uint32_t backing_id, bool backing_y_0_top,\n\n\n                    uint32_t x, uint32_t y,\n\n                    uint32_t w, uint32_t h)\n\n{\n\n    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);\n\n\n\n    vc->gfx.x = x;\n\n    vc->gfx.y = y;\n\n    vc->gfx.w = w;\n\n    vc->gfx.h = h;\n\n    vc->gfx.tex_id = backing_id;\n\n    vc->gfx.y0_top = backing_y_0_top;\n\n\n\n    eglMakeCurrent(qemu_egl_display, vc->gfx.esurface,\n\n                   vc->gfx.esurface, vc->gfx.ectx);\n\n\n\n    if (vc->gfx.tex_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0) {\n\n        gtk_egl_set_scanout_mode(vc, false);\n\n        return;\n\n    }\n\n\n\n    gtk_egl_set_scanout_mode(vc, true);\n\n    if (!vc->gfx.fbo_id) {\n\n        glGenFramebuffers(1, &vc->gfx.fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, vc->gfx.fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, vc->gfx.tex_id, 0);\n\n}","idx":6457,"target":1}
{"code":"static void destroy_buffers(SANMVideoContext *ctx)\n\n{\n\n    av_freep(&ctx->frm0);\n\n    av_freep(&ctx->frm1);\n\n    av_freep(&ctx->frm2);\n\n    av_freep(&ctx->stored_frame);\n\n    av_freep(&ctx->rle_buf);\n\n    ctx->frm0_size =\n\n    ctx->frm1_size =\n\n    ctx->frm2_size = 0;\n\n\n}","idx":615,"target":1}
{"code":"static int nbd_errno_to_system_errno(int err)\n\n{\n\n    switch (err) {\n\n    case NBD_SUCCESS:\n\n        return 0;\n\n    case NBD_EPERM:\n\n        return EPERM;\n\n    case NBD_EIO:\n\n        return EIO;\n\n    case NBD_ENOMEM:\n\n        return ENOMEM;\n\n    case NBD_ENOSPC:\n\n        return ENOSPC;\n\n    default:\n\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n\n        \/* fallthrough *\/\n\n    case NBD_EINVAL:\n\n        return EINVAL;\n\n    }\n\n}\n","idx":55,"target":0}
{"code":"static void s390_msi_ctrl_write(void *opaque, hwaddr addr, uint64_t data,\n\n                                unsigned int size)\n\n{\n\n    S390PCIBusDevice *pbdev;\n\n    uint32_t io_int_word;\n\n    uint32_t fid = data >> ZPCI_MSI_VEC_BITS;\n\n    uint32_t vec = data & ZPCI_MSI_VEC_MASK;\n\n    uint64_t ind_bit;\n\n    uint32_t sum_bit;\n\n    uint32_t e = 0;\n\n\n\n    DPRINTF(\"write_msix data 0x%\" PRIx64 \" fid %d vec 0x%x\\n\", data, fid, vec);\n\n\n\n    pbdev = s390_pci_find_dev_by_fid(fid);\n\n    if (!pbdev) {\n\n        e |= (vec << ERR_EVENT_MVN_OFFSET);\n\n        s390_pci_generate_error_event(ERR_EVENT_NOMSI, 0, fid, addr, e);\n\n        return;\n\n    }\n\n\n\n    if (pbdev->state != ZPCI_FS_ENABLED) {\n\n        return;\n\n    }\n\n\n\n    ind_bit = pbdev->routes.adapter.ind_offset;\n\n    sum_bit = pbdev->routes.adapter.summary_offset;\n\n\n\n    set_ind_atomic(pbdev->routes.adapter.ind_addr + (ind_bit + vec) \/ 8,\n\n                   0x80 >> ((ind_bit + vec) % 8));\n\n    if (!set_ind_atomic(pbdev->routes.adapter.summary_addr + sum_bit \/ 8,\n\n                                       0x80 >> (sum_bit % 8))) {\n\n        io_int_word = (pbdev->isc << 27) | IO_INT_WORD_AI;\n\n        s390_io_interrupt(0, 0, 0, io_int_word);\n\n    }\n\n}\n","idx":2226,"target":1}
{"code":"static int asis_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    apr_file_t *f = NULL;\n    apr_status_t rv;\n    const char *location;\n\n    if(strcmp(r->handler,ASIS_MAGIC_TYPE) && strcmp(r->handler,\"send-as-is\"))\n        return DECLINED;\n\n    r->allowed |= (AP_METHOD_BIT << M_GET);\n    if (r->method_number != M_GET)\n        return DECLINED;\n    if (r->finfo.filetype == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                    \"File does not exist: %s\", r->filename);\n        return HTTP_NOT_FOUND;\n    }\n\n    if ((rv = apr_file_open(&f, r->filename, APR_READ,\n                APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                    \"file permissions deny server access: %s\", r->filename);\n        return HTTP_FORBIDDEN;\n    }\n\n    ap_scan_script_header_err(r, f, NULL);\n    location = apr_table_get(r->headers_out, \"Location\");\n\n    if (location && location[0] == '\/' &&\n        ((r->status == HTTP_OK) || ap_is_HTTP_REDIRECT(r->status))) {\n\n        apr_file_close(f);\n\n        \/* Internal redirect -- fake-up a pseudo-request *\/\n        r->status = HTTP_OK;\n\n        \/* This redirect needs to be a GET no matter what the original\n         * method was.\n         *\/\n        r->method = apr_pstrdup(r->pool, \"GET\");\n        r->method_number = M_GET;\n\n        ap_internal_redirect_handler(location, r);\n        return OK;\n    }\n\n    if (!r->header_only) {\n        apr_bucket_brigade *bb;\n        apr_bucket *b;\n        apr_off_t pos = 0;\n\n        rv = apr_file_seek(f, APR_CUR, &pos);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          \"mod_asis: failed to find end-of-headers position \"\n                          \"for %s\", r->filename);\n            apr_file_close(f);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bb = apr_brigade_create(r->pool, c->bucket_alloc);\n#if APR_HAS_LARGE_FILES\n        if (r->finfo.size - pos > AP_MAX_SENDFILE) {\n            \/* APR_HAS_LARGE_FILES issue; must split into mutiple buckets,\n             * no greater than MAX(apr_size_t), and more granular than that\n             * in case the brigade code\/filters attempt to read it directly.\n             *\/\n            apr_off_t fsize = r->finfo.size - pos;\n            b = apr_bucket_file_create(f, pos, AP_MAX_SENDFILE,\n                                       r->pool, c->bucket_alloc);\n            while (fsize > AP_MAX_SENDFILE) {\n                APR_BRIGADE_INSERT_TAIL(bb, b);\n                apr_bucket_copy(b, &b);\n                b->start += AP_MAX_SENDFILE;\n                fsize -= AP_MAX_SENDFILE;\n            }\n            b->length = (apr_size_t)fsize; \/* Resize just the last bucket *\/\n        }\n        else\n#endif\n        b = apr_bucket_file_create(f, pos, (apr_size_t) (r->finfo.size - pos),\n                                   r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n        b = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n        rv = ap_pass_brigade(r->output_filters, bb);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,\n                          \"mod_asis: ap_pass_brigade failed for file %s\", r->filename);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n    }\n    else {\n        apr_file_close(f);\n    }\n\n    return OK;\n}","idx":1,"target":0}
{"code":"static void render_line(int x0, int y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { \/\/ optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base = dy \/ adx;\n\n        int x    = x0;\n\n        int y    = y0;\n\n        int err  = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n","idx":15155,"target":1}
{"code":"int main (int argc, const char * const argv[])\n{\n    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];\n    int tLogEnd = 0, tRotation = 0, utc_offset = 0;\n    unsigned int sRotation = 0;\n    int nMessCount = 0;\n    apr_size_t nRead, nWrite;\n    int use_strftime = 0;\n    int use_localtime = 0;\n    int now = 0;\n    const char *szLogRoot;\n    apr_file_t *f_stdin, *nLogFD = NULL, *nLogFDprev = NULL;\n    apr_pool_t *pool;\n    char *ptr = NULL;\n    int argBase = 0;\n    int argFile = 1;\n    int argIntv = 2;\n    int argOffset = 3;\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    apr_pool_create(&pool, NULL);\n    if ((argc > 2) && (strcmp(argv[1], \"-l\") == 0)) {\n        argBase++;\n        argFile += argBase;\n        argIntv += argBase;\n        argOffset += argBase;\n        use_localtime = 1;\n    }\n    if (argc < (argBase + 3) || argc > (argBase + 4)) {\n        fprintf(stderr,\n                \"Usage: %s [-l] <logfile> <rotation time in seconds> \"\n                \"[offset minutes from UTC] or <rotation size in megabytes>\\n\\n\",\n                argv[0]);\n#ifdef OS2\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s.exe \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n#else\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n        fprintf(stderr,\n                \"or \\n\\nTransferLog \\\"|%s \/some\/where 5M\\\"\\n\\n\", argv[0]);\n#endif\n        fprintf(stderr,\n                \"to httpd.conf. The generated name will be \/some\/where.nnnn \"\n                \"where nnnn is the\\nsystem time at which the log nominally \"\n                \"starts (N.B. if using a rotation time,\\nthe time will always \"\n                \"be a multiple of the rotation time, so you can synchronize\\n\"\n                \"cron scripts with it). At the end of each rotation time or \"\n                \"when the file size\\nis reached a new log is started.\\n\");\n        exit(1);\n    }\n\n    szLogRoot = argv[argFile];\n\n    ptr = strchr(argv[argIntv], 'M');\n    if (ptr) {\n        if (*(ptr+1) == '\\0') {\n            sRotation = atoi(argv[argIntv]) * 1048576;\n        }\n        if (sRotation == 0) {\n            fprintf(stderr, \"Invalid rotation size parameter\\n\");\n            exit(1);\n        }\n    }\n    else {\n        if (argc >= (argBase + 4)) {\n            utc_offset = atoi(argv[argOffset]) * 60;\n        }\n        tRotation = atoi(argv[argIntv]);\n        if (tRotation <= 0) {\n            fprintf(stderr, \"Rotation time must be > 0\\n\");\n            exit(6);\n        }\n    }\n\n    use_strftime = (strchr(szLogRoot, '%') != NULL);\n    if (apr_file_open_stdin(&f_stdin, pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n        if (apr_file_read(f_stdin, buf, &nRead) != APR_SUCCESS) {\n            exit(3);\n        }\n        if (tRotation) {\n            \/*\n             * Check for our UTC offset every time through the loop, since\n             * it might change if there's a switch between standard and\n             * daylight savings time.\n             *\/\n            if (use_localtime) {\n                apr_time_exp_t lt;\n                apr_time_exp_lt(&lt, apr_time_now());\n                utc_offset = lt.tm_gmtoff;\n            }\n            now = (int)(apr_time_now() \/ APR_USEC_PER_SEC) + utc_offset;\n            if (nLogFD != NULL && now >= tLogEnd) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else if (sRotation) {\n            apr_finfo_t finfo;\n            apr_off_t current_size = -1;\n\n            if ((nLogFD != NULL) &&\n                (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {\n                current_size = finfo.size;\n            }\n\n            if (current_size > sRotation) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else {\n            fprintf(stderr, \"No rotation time or size specified\\n\");\n            exit(2);\n        }\n\n        if (nLogFD == NULL) {\n            int tLogStart;\n\n            if (tRotation) {\n                tLogStart = (now \/ tRotation) * tRotation;\n            }\n            else {\n                tLogStart = (int)apr_time_sec(apr_time_now());\n            }\n\n            if (use_strftime) {\n                apr_time_t tNow = apr_time_from_sec(tLogStart);\n                apr_time_exp_t e;\n                apr_size_t rs;\n\n                apr_time_exp_gmt(&e, tNow);\n                apr_strftime(buf2, &rs, sizeof(buf2), szLogRoot, &e);\n            }\n            else {\n                sprintf(buf2, \"%s.%010d\", szLogRoot, tLogStart);\n            }\n            tLogEnd = tLogStart + tRotation;\n            apr_file_open(&nLogFD, buf2, APR_READ | APR_WRITE | APR_CREATE | APR_APPEND,\n                          APR_OS_DEFAULT, pool);\n            if (nLogFD == NULL) {\n                \/* Uh-oh. Failed to open the new log file. Try to clear\n                 * the previous log file, note the lost log entries,\n                 * and keep on truckin'. *\/\n                if (nLogFDprev == NULL) {\n                    fprintf(stderr, \"1 Previous file handle doesn't exists %s\\n\", buf2);\n                    exit(2);\n                }\n                else {\n                    nLogFD = nLogFDprev;\n                    sprintf(errbuf,\n                            \"Resetting log file due to error opening \"\n                            \"new log file. %10d messages lost.\\n\",\n                            nMessCount);\n                    nWrite = strlen(errbuf);\n                    apr_file_trunc(nLogFD, 0);\n                    if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                        fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                        exit(2);\n                    }\n                }\n            }\n            else if (nLogFDprev) {\n                apr_file_close(nLogFDprev);\n            }\n            nMessCount = 0;\n        }\n        nWrite = nRead;\n        apr_file_write(nLogFD, buf, &nWrite);\n        if (nWrite != nRead) {\n            nMessCount++;\n            sprintf(errbuf,\n                    \"Error writing to log file. \"\n                    \"%10d messages lost.\\n\",\n                    nMessCount);\n            nWrite = strlen(errbuf);\n            apr_file_trunc(nLogFD, 0);\n            if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                exit(2);\n            }\n        }\n        else {\n            nMessCount++;\n        }\n    }\n    \/* Of course we never, but prevent compiler warnings *\/\n    return 0;\n}","idx":9,"target":0}
{"code":"static void perf_lifecycle(void)\n\n{\n\n    Coroutine *coroutine;\n\n    unsigned int i, max;\n\n    double duration;\n\n\n\n    max = 1000000;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < max; i++) {\n\n        coroutine = qemu_coroutine_create(empty_coroutine);\n\n        qemu_coroutine_enter(coroutine, NULL);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Lifecycle %u iterations: %f s\\n\", max, duration);\n\n}\n","idx":6630,"target":1}
{"code":"static int mov_text_decode_close(AVCodecContext *avctx)\n\n{\n\n    MovTextContext *m = avctx->priv_data;\n\n    mov_text_cleanup_ftab(m);\n\n\n    return 0;\n\n}","idx":639,"target":1}
{"code":"static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,\n\n                                VMStateField *field)\n\n{\n\n    uint64_t *v = pv;\n\n    *v = qemu_get_be32(f);\n\n    return 0;\n\n}\n","idx":50,"target":0}
{"code":"static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    LM32TimerState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SR:\n\n    case R_CR:\n\n    case R_PERIOD:\n\n        r = s->regs[addr];\n\n        break;\n\n    case R_SNAPSHOT:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_lm32_timer_memory_read(addr << 2, r);\n\n    return r;\n\n}\n","idx":58,"target":0}
{"code":"int main (int argc, const char * const argv[])\n{\n    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];\n    int tLogEnd = 0, tRotation = 0, utc_offset = 0;\n    unsigned int sRotation = 0;\n    int nMessCount = 0;\n    apr_size_t nRead, nWrite;\n    int use_strftime = 0;\n    int use_localtime = 0;\n    int now = 0;\n    const char *szLogRoot;\n    apr_file_t *f_stdin, *nLogFD = NULL, *nLogFDprev = NULL;\n    apr_pool_t *pool;\n    char *ptr = NULL;\n    int argBase = 0;\n    int argFile = 1;\n    int argIntv = 2;\n    int argOffset = 3;\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    apr_pool_create(&pool, NULL);\n    if ((argc > 2) && (strcmp(argv[1], \"-l\") == 0)) {\n        argBase++;\n        argFile += argBase;\n        argIntv += argBase;\n        argOffset += argBase;\n        use_localtime = 1;\n    }\n    if (argc < (argBase + 3) || argc > (argBase + 4)) {\n        fprintf(stderr,\n                \"Usage: %s [-l] <logfile> <rotation time in seconds> \"\n                \"[offset minutes from UTC] or <rotation size in megabytes>\\n\\n\",\n                argv[0]);\n#ifdef OS2\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s.exe \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n#else\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n        fprintf(stderr,\n                \"or \\n\\nTransferLog \\\"|%s \/some\/where 5M\\\"\\n\\n\", argv[0]);\n#endif\n        fprintf(stderr,\n                \"to httpd.conf. The generated name will be \/some\/where.nnnn \"\n                \"where nnnn is the\\nsystem time at which the log nominally \"\n                \"starts (N.B. if using a rotation time,\\nthe time will always \"\n                \"be a multiple of the rotation time, so you can synchronize\\n\"\n                \"cron scripts with it). At the end of each rotation time or \"\n                \"when the file size\\nis reached a new log is started.\\n\");\n        exit(1);\n    }\n\n    szLogRoot = argv[argFile];\n\n    ptr = strchr(argv[argIntv], 'M');\n    if (ptr) {\n        if (*(ptr+1) == '\\0') {\n            sRotation = atoi(argv[argIntv]) * 1048576;\n        }\n        if (sRotation == 0) {\n            fprintf(stderr, \"Invalid rotation size parameter\\n\");\n            exit(1);\n        }\n    }\n    else {\n        if (argc >= (argBase + 4)) {\n            utc_offset = atoi(argv[argOffset]) * 60;\n        }\n        tRotation = atoi(argv[argIntv]);\n        if (tRotation <= 0) {\n            fprintf(stderr, \"Rotation time must be > 0\\n\");\n            exit(6);\n        }\n    }\n\n    use_strftime = (strchr(szLogRoot, '%') != NULL);\n    if (apr_file_open_stdin(&f_stdin, pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n        if (apr_file_read(f_stdin, buf, &nRead) != APR_SUCCESS) {\n            exit(3);\n        }\n        if (tRotation) {\n            \/*\n             * Check for our UTC offset every time through the loop, since\n             * it might change if there's a switch between standard and\n             * daylight savings time.\n             *\/\n            if (use_localtime) {\n                apr_time_exp_t lt;\n                apr_time_exp_lt(&lt, apr_time_now());\n                utc_offset = lt.tm_gmtoff;\n            }\n            now = (int)(apr_time_now() \/ APR_USEC_PER_SEC) + utc_offset;\n            if (nLogFD != NULL && now >= tLogEnd) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else if (sRotation) {\n            apr_finfo_t finfo;\n            apr_off_t current_size = -1;\n\n            if ((nLogFD != NULL) &&\n                (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {\n                current_size = finfo.size;\n            }\n\n            if (current_size > sRotation) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else {\n            fprintf(stderr, \"No rotation time or size specified\\n\");\n            exit(2);\n        }\n\n        if (nLogFD == NULL) {\n            int tLogStart;\n\n            if (tRotation) {\n                tLogStart = (now \/ tRotation) * tRotation;\n            }\n            else {\n                tLogStart = (int)apr_time_sec(apr_time_now());\n            }\n\n            if (use_strftime) {\n                apr_time_t tNow = apr_time_from_sec(tLogStart);\n                apr_time_exp_t e;\n                apr_size_t rs;\n\n                apr_time_exp_gmt(&e, tNow);\n                apr_strftime(buf2, &rs, sizeof(buf2), szLogRoot, &e);\n            }\n            else {\n                sprintf(buf2, \"%s.%010d\", szLogRoot, tLogStart);\n            }\n            tLogEnd = tLogStart + tRotation;\n            apr_file_open(&nLogFD, buf2, APR_READ | APR_WRITE | APR_CREATE | APR_APPEND,\n                          APR_OS_DEFAULT, pool);\n            if (nLogFD == NULL) {\n                \/* Uh-oh. Failed to open the new log file. Try to clear\n                 * the previous log file, note the lost log entries,\n                 * and keep on truckin'. *\/\n                if (nLogFDprev == NULL) {\n                    fprintf(stderr, \"1 Previous file handle doesn't exists %s\\n\", buf2);\n                    exit(2);\n                }\n                else {\n                    nLogFD = nLogFDprev;\n                    sprintf(errbuf,\n                            \"Resetting log file due to error opening \"\n                            \"new log file. %10d messages lost.\\n\",\n                            nMessCount);\n                    nWrite = strlen(errbuf);\n                    apr_file_trunc(nLogFD, 0);\n                    if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                        fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                        exit(2);\n                    }\n                }\n            }\n            else if (nLogFDprev) {\n                apr_file_close(nLogFDprev);\n            }\n            nMessCount = 0;\n        }\n        nWrite = nRead;\n        apr_file_write(nLogFD, buf, &nWrite);\n        if (nWrite != nRead) {\n            nMessCount++;\n            sprintf(errbuf,\n                    \"Error writing to log file. \"\n                    \"%10d messages lost.\\n\",\n                    nMessCount);\n            nWrite = strlen(errbuf);\n            apr_file_trunc(nLogFD, 0);\n            if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                exit(2);\n            }\n        }\n        else {\n            nMessCount++;\n        }\n    }\n    \/* Of course we never, but prevent compiler warnings *\/\n    return 0;\n}","idx":8,"target":0}
{"code":"static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (blit_is_unsafe(s, false))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n","idx":63,"target":0}
{"code":"static int config_props(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    LutContext *lut = ctx->priv;\n\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];\n\n    int min[4], max[4];\n\n    int val, comp, ret;\n\n\n\n    lut->hsub = desc->log2_chroma_w;\n\n    lut->vsub = desc->log2_chroma_h;\n\n\n\n    lut->var_values[VAR_W] = inlink->w;\n\n    lut->var_values[VAR_H] = inlink->h;\n\n\n\n    switch (inlink->format) {\n\n    case PIX_FMT_YUV410P:\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV440P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_YUVA420P:\n\n        min[Y] = min[U] = min[V] = 16;\n\n        max[Y] = 235;\n\n        max[U] = max[V] = 240;\n\n        min[A] = 0; max[A] = 255;\n\n        break;\n\n    default:\n\n        min[0] = min[1] = min[2] = min[3] = 0;\n\n        max[0] = max[1] = max[2] = max[3] = 255;\n\n    }\n\n\n\n    lut->is_yuv = lut->is_rgb = 0;\n\n    if      (ff_fmt_is_in(inlink->format, yuv_pix_fmts)) lut->is_yuv = 1;\n\n    else if (ff_fmt_is_in(inlink->format, rgb_pix_fmts)) lut->is_rgb = 1;\n\n\n\n    if (lut->is_rgb) {\n\n        switch (inlink->format) {\n\n        case PIX_FMT_ARGB:  lut->rgba_map[A] = 0; lut->rgba_map[R] = 1; lut->rgba_map[G] = 2; lut->rgba_map[B] = 3; break;\n\n        case PIX_FMT_ABGR:  lut->rgba_map[A] = 0; lut->rgba_map[B] = 1; lut->rgba_map[G] = 2; lut->rgba_map[R] = 3; break;\n\n        case PIX_FMT_RGBA:\n\n        case PIX_FMT_RGB24: lut->rgba_map[R] = 0; lut->rgba_map[G] = 1; lut->rgba_map[B] = 2; lut->rgba_map[A] = 3; break;\n\n        case PIX_FMT_BGRA:\n\n        case PIX_FMT_BGR24: lut->rgba_map[B] = 0; lut->rgba_map[G] = 1; lut->rgba_map[R] = 2; lut->rgba_map[A] = 3; break;\n\n        }\n\n        lut->step = av_get_bits_per_pixel(desc) >> 3;\n\n    }\n\n\n\n    for (comp = 0; comp < desc->nb_components; comp++) {\n\n        double res;\n\n\n\n        \/* create the parsed expression *\/\n\n        ret = av_expr_parse(&lut->comp_expr[comp], lut->comp_expr_str[comp],\n\n                            var_names, funcs1_names, funcs1, NULL, NULL, 0, ctx);\n\n        if (ret < 0) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Error when parsing the expression '%s' for the component %d.\\n\",\n\n                   lut->comp_expr_str[comp], comp);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        \/* compute the lut *\/\n\n        lut->var_values[VAR_MAXVAL] = max[comp];\n\n        lut->var_values[VAR_MINVAL] = min[comp];\n\n\n\n        for (val = 0; val < 256; val++) {\n\n            lut->var_values[VAR_VAL] = val;\n\n            lut->var_values[VAR_CLIPVAL] = av_clip(val, min[comp], max[comp]);\n\n            lut->var_values[VAR_NEGVAL] =\n\n                av_clip(min[comp] + max[comp] - lut->var_values[VAR_VAL],\n\n                        min[comp], max[comp]);\n\n\n\n            res = av_expr_eval(lut->comp_expr[comp], lut->var_values, lut);\n\n            if (isnan(res)) {\n\n                av_log(ctx, AV_LOG_ERROR,\n\n                       \"Error when evaluating the expression '%s' for the value %d for the component #%d.\\n\",\n\n                       lut->comp_expr_str[comp], val, comp);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            lut->lut[comp][val] = av_clip((int)res, min[comp], max[comp]);\n\n            av_log(ctx, AV_LOG_DEBUG, \"val[%d][%d] = %d\\n\", comp, val, lut->lut[comp][val]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":30,"target":0}
{"code":"int kvm_arch_init(KVMState *s)\n\n{\n\n    uint64_t identity_base = 0xfffbc000;\n\n    int ret;\n\n    struct utsname utsname;\n\n\n\n    ret = kvm_get_supported_msrs(s);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    uname(&utsname);\n\n    lm_capable_kernel = strcmp(utsname.machine, \"x86_64\") == 0;\n\n\n\n    \/*\n\n     * On older Intel CPUs, KVM uses vm86 mode to emulate 16-bit code directly.\n\n     * In order to use vm86 mode, an EPT identity map and a TSS  are needed.\n\n     * Since these must be part of guest physical memory, we need to allocate\n\n     * them, both by setting their start addresses in the kernel and by\n\n     * creating a corresponding e820 entry. We need 4 pages before the BIOS.\n\n     *\n\n     * Older KVM versions may not support setting the identity map base. In\n\n     * that case we need to stick with the default, i.e. a 256K maximum BIOS\n\n     * size.\n\n     *\/\n\n#ifdef KVM_CAP_SET_IDENTITY_MAP_ADDR\n\n    if (kvm_check_extension(s, KVM_CAP_SET_IDENTITY_MAP_ADDR)) {\n\n        \/* Allows up to 16M BIOSes. *\/\n\n        identity_base = 0xfeffc000;\n\n\n\n        ret = kvm_vm_ioctl(s, KVM_SET_IDENTITY_MAP_ADDR, &identity_base);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    \/* Set TSS base one page after EPT identity map. *\/\n\n    ret = kvm_vm_ioctl(s, KVM_SET_TSS_ADDR, identity_base + 0x1000);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* Tell fw_cfg to notify the BIOS to reserve the range. *\/\n\n    ret = e820_add_entry(identity_base, 0x4000, E820_RESERVED);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"e820_add_entry() table is full\\n\");\n\n        return ret;\n\n    }\n\n\n\n\n    return 0;\n\n}","idx":8772,"target":1}
{"code":"uint8_t *xen_map_cache(hwaddr phys_addr, hwaddr size,\n\n                       uint8_t lock)\n\n{\n\n    MapCacheEntry *entry, *pentry = NULL;\n\n    hwaddr address_index;\n\n    hwaddr address_offset;\n\n    hwaddr cache_size = size;\n\n    hwaddr test_bit_size;\n\n    bool translated = false;\n\n\n\ntryagain:\n\n    address_index  = phys_addr >> MCACHE_BUCKET_SHIFT;\n\n    address_offset = phys_addr & (MCACHE_BUCKET_SIZE - 1);\n\n\n\n    trace_xen_map_cache(phys_addr);\n\n\n\n    \/* test_bit_size is always a multiple of XC_PAGE_SIZE *\/\n\n    if (size) {\n\n        test_bit_size = size + (phys_addr & (XC_PAGE_SIZE - 1));\n\n\n\n        if (test_bit_size % XC_PAGE_SIZE) {\n\n            test_bit_size += XC_PAGE_SIZE - (test_bit_size % XC_PAGE_SIZE);\n\n        }\n\n    } else {\n\n        test_bit_size = XC_PAGE_SIZE;\n\n    }\n\n\n\n    if (mapcache->last_entry != NULL &&\n\n        mapcache->last_entry->paddr_index == address_index &&\n\n        !lock && !size &&\n\n        test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                  test_bit_size >> XC_PAGE_SHIFT,\n\n                  mapcache->last_entry->valid_mapping)) {\n\n        trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n        return mapcache->last_entry->vaddr_base + address_offset;\n\n    }\n\n\n\n    \/* size is always a multiple of MCACHE_BUCKET_SIZE *\/\n\n    if (size) {\n\n        cache_size = size + address_offset;\n\n        if (cache_size % MCACHE_BUCKET_SIZE) {\n\n            cache_size += MCACHE_BUCKET_SIZE - (cache_size % MCACHE_BUCKET_SIZE);\n\n        }\n\n    } else {\n\n        cache_size = MCACHE_BUCKET_SIZE;\n\n    }\n\n\n\n    entry = &mapcache->entry[address_index % mapcache->nr_buckets];\n\n\n\n    while (entry && entry->lock && entry->vaddr_base &&\n\n            (entry->paddr_index != address_index || entry->size != cache_size ||\n\n             !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                 test_bit_size >> XC_PAGE_SHIFT,\n\n                 entry->valid_mapping))) {\n\n        pentry = entry;\n\n        entry = entry->next;\n\n    }\n\n    if (!entry) {\n\n        entry = g_malloc0(sizeof (MapCacheEntry));\n\n        pentry->next = entry;\n\n        xen_remap_bucket(entry, cache_size, address_index);\n\n    } else if (!entry->lock) {\n\n        if (!entry->vaddr_base || entry->paddr_index != address_index ||\n\n                entry->size != cache_size ||\n\n                !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                    test_bit_size >> XC_PAGE_SHIFT,\n\n                    entry->valid_mapping)) {\n\n            xen_remap_bucket(entry, cache_size, address_index);\n\n        }\n\n    }\n\n\n\n    if(!test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                test_bit_size >> XC_PAGE_SHIFT,\n\n                entry->valid_mapping)) {\n\n        mapcache->last_entry = NULL;\n\n        if (!translated && mapcache->phys_offset_to_gaddr) {\n\n            phys_addr = mapcache->phys_offset_to_gaddr(phys_addr, size, mapcache->opaque);\n\n            translated = true;\n\n            goto tryagain;\n\n        }\n\n        trace_xen_map_cache_return(NULL);\n\n        return NULL;\n\n    }\n\n\n\n    mapcache->last_entry = entry;\n\n    if (lock) {\n\n        MapCacheRev *reventry = g_malloc0(sizeof(MapCacheRev));\n\n        entry->lock++;\n\n        reventry->vaddr_req = mapcache->last_entry->vaddr_base + address_offset;\n\n        reventry->paddr_index = mapcache->last_entry->paddr_index;\n\n        reventry->size = entry->size;\n\n        QTAILQ_INSERT_HEAD(&mapcache->locked_entries, reventry, next);\n\n    }\n\n\n\n    trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n    return mapcache->last_entry->vaddr_base + address_offset;\n\n}\n","idx":53,"target":0}
{"code":"static int truespeech_decode_frame(AVCodecContext *avctx,\n\n                void *data, int *data_size,\n\n                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TSContext *c = avctx->priv_data;\n\n\n\n    int i, j;\n\n    short *samples = data;\n\n    int consumed = 0;\n\n    int16_t out_buf[240];\n\n    int iterations;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 32) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Too small input buffer (%d bytes), need at least 32 bytes\\n\", buf_size);\n\n        return -1;\n\n    }\n\n    iterations = FFMIN(buf_size \/ 32, *data_size \/ 480);\n\n    for(j = 0; j < iterations; j++) {\n\n        truespeech_read_frame(c, buf + consumed);\n\n        consumed += 32;\n\n\n\n        truespeech_correlate_filter(c);\n\n        truespeech_filters_merge(c);\n\n\n\n        memset(out_buf, 0, 240 * 2);\n\n        for(i = 0; i < 4; i++) {\n\n            truespeech_apply_twopoint_filter(c, i);\n\n            truespeech_place_pulses(c, out_buf + i * 60, i);\n\n            truespeech_update_filters(c, out_buf + i * 60, i);\n\n            truespeech_synth(c, out_buf + i * 60, i);\n\n        }\n\n\n\n        truespeech_save_prevvec(c);\n\n\n\n        \/* finally output decoded frame *\/\n\n        for(i = 0; i < 240; i++)\n\n            *samples++ = out_buf[i];\n\n\n\n    }\n\n\n\n    *data_size = consumed * 15;\n\n\n\n    return consumed;\n\n}\n","idx":61,"target":0}
{"code":"int main (int argc, const char * const argv[])\n{\n    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];\n    int tLogEnd = 0, tRotation = 0, utc_offset = 0;\n    unsigned int sRotation = 0;\n    int nMessCount = 0;\n    apr_size_t nRead, nWrite;\n    int use_strftime = 0;\n    int use_localtime = 0;\n    int now = 0;\n    const char *szLogRoot;\n    apr_file_t *f_stdin, *nLogFD = NULL, *nLogFDprev = NULL;\n    apr_pool_t *pool;\n    char *ptr = NULL;\n    int argBase = 0;\n    int argFile = 1;\n    int argIntv = 2;\n    int argOffset = 3;\n\n    apr_app_initialize(&argc, &argv, NULL);\n    atexit(apr_terminate);\n\n    apr_pool_create(&pool, NULL);\n    if ((argc > 2) && (strcmp(argv[1], \"-l\") == 0)) {\n        argBase++;\n        argFile += argBase;\n        argIntv += argBase;\n        argOffset += argBase;\n        use_localtime = 1;\n    }\n    if (argc < (argBase + 3) || argc > (argBase + 4)) {\n        fprintf(stderr,\n                \"Usage: %s [-l] <logfile> <rotation time in seconds> \"\n                \"[offset minutes from UTC] or <rotation size in megabytes>\\n\\n\",\n                argv[0]);\n#ifdef OS2\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s.exe \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n#else\n        fprintf(stderr,\n                \"Add this:\\n\\nTransferLog \\\"|%s \/some\/where 86400\\\"\\n\\n\",\n                argv[0]);\n        fprintf(stderr,\n                \"or \\n\\nTransferLog \\\"|%s \/some\/where 5M\\\"\\n\\n\", argv[0]);\n#endif\n        fprintf(stderr,\n                \"to httpd.conf. The generated name will be \/some\/where.nnnn \"\n                \"where nnnn is the\\nsystem time at which the log nominally \"\n                \"starts (N.B. if using a rotation time,\\nthe time will always \"\n                \"be a multiple of the rotation time, so you can synchronize\\n\"\n                \"cron scripts with it). At the end of each rotation time or \"\n                \"when the file size\\nis reached a new log is started.\\n\");\n        exit(1);\n    }\n\n    szLogRoot = argv[argFile];\n\n    ptr = strchr(argv[argIntv], 'M');\n    if (ptr) {\n        if (*(ptr+1) == '\\0') {\n            sRotation = atoi(argv[argIntv]) * 1048576;\n        }\n        if (sRotation == 0) {\n            fprintf(stderr, \"Invalid rotation size parameter\\n\");\n            exit(1);\n        }\n    }\n    else {\n        if (argc >= (argBase + 4)) {\n            utc_offset = atoi(argv[argOffset]) * 60;\n        }\n        tRotation = atoi(argv[argIntv]);\n        if (tRotation <= 0) {\n            fprintf(stderr, \"Rotation time must be > 0\\n\");\n            exit(6);\n        }\n    }\n\n    use_strftime = (strchr(szLogRoot, '%') != NULL);\n    if (apr_file_open_stdin(&f_stdin, pool) != APR_SUCCESS) {\n        fprintf(stderr, \"Unable to open stdin\\n\");\n        exit(1);\n    }\n\n    for (;;) {\n        nRead = sizeof(buf);\n        if (apr_file_read(f_stdin, buf, &nRead) != APR_SUCCESS) {\n            exit(3);\n        }\n        if (tRotation) {\n            \/*\n             * Check for our UTC offset every time through the loop, since\n             * it might change if there's a switch between standard and\n             * daylight savings time.\n             *\/\n            if (use_localtime) {\n                apr_time_exp_t lt;\n                apr_time_exp_lt(&lt, apr_time_now());\n                utc_offset = lt.tm_gmtoff;\n            }\n            now = (int)(apr_time_now() \/ APR_USEC_PER_SEC) + utc_offset;\n            if (nLogFD != NULL && now >= tLogEnd) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else if (sRotation) {\n            apr_finfo_t finfo;\n            apr_off_t current_size = -1;\n\n            if ((nLogFD != NULL) &&\n                (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {\n                current_size = finfo.size;\n            }\n\n            if (current_size > sRotation) {\n                nLogFDprev = nLogFD;\n                nLogFD = NULL;\n            }\n        }\n        else {\n            fprintf(stderr, \"No rotation time or size specified\\n\");\n            exit(2);\n        }\n\n        if (nLogFD == NULL) {\n            int tLogStart;\n\n            if (tRotation) {\n                tLogStart = (now \/ tRotation) * tRotation;\n            }\n            else {\n                tLogStart = (int)apr_time_sec(apr_time_now());\n            }\n\n            if (use_strftime) {\n                apr_time_t tNow = apr_time_from_sec(tLogStart);\n                apr_time_exp_t e;\n                apr_size_t rs;\n\n                apr_time_exp_gmt(&e, tNow);\n                apr_strftime(buf2, &rs, sizeof(buf2), szLogRoot, &e);\n            }\n            else {\n                sprintf(buf2, \"%s.%010d\", szLogRoot, tLogStart);\n            }\n            tLogEnd = tLogStart + tRotation;\n            apr_file_open(&nLogFD, buf2, APR_READ | APR_WRITE | APR_CREATE | APR_APPEND,\n                          APR_OS_DEFAULT, pool);\n            if (nLogFD == NULL) {\n                \/* Uh-oh. Failed to open the new log file. Try to clear\n                 * the previous log file, note the lost log entries,\n                 * and keep on truckin'. *\/\n                if (nLogFDprev == NULL) {\n                    fprintf(stderr, \"1 Previous file handle doesn't exists %s\\n\", buf2);\n                    exit(2);\n                }\n                else {\n                    nLogFD = nLogFDprev;\n                    sprintf(errbuf,\n                            \"Resetting log file due to error opening \"\n                            \"new log file. %10d messages lost.\\n\",\n                            nMessCount);\n                    nWrite = strlen(errbuf);\n                    apr_file_trunc(nLogFD, 0);\n                    if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                        fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                        exit(2);\n                    }\n                }\n            }\n            else if (nLogFDprev) {\n                apr_file_close(nLogFDprev);\n            }\n            nMessCount = 0;\n        }\n        nWrite = nRead;\n        apr_file_write(nLogFD, buf, &nWrite);\n        if (nWrite != nRead) {\n            nMessCount++;\n            sprintf(errbuf,\n                    \"Error writing to log file. \"\n                    \"%10d messages lost.\\n\",\n                    nMessCount);\n            nWrite = strlen(errbuf);\n            apr_file_trunc(nLogFD, 0);\n            if (apr_file_write(nLogFD, errbuf, &nWrite) != APR_SUCCESS) {\n                fprintf(stderr, \"Error writing to the file %s\\n\", buf2);\n                exit(2);\n            }\n        }\n        else {\n            nMessCount++;\n        }\n    }\n    \/* Of course we never, but prevent compiler warnings *\/\n    return 0;\n}","idx":7,"target":0}
{"code":"static int transcode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     InputFile *input_files,\n\n                     int nb_input_files,\n\n                     StreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret = 0, i, j, k, n, nb_ostreams = 0, step;\n\n\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    OutputStream *ost, **ost_table = NULL;\n\n    InputStream *ist;\n\n    char error[1024];\n\n    int key;\n\n    int want_sdp = 1;\n\n    uint8_t no_packet[MAX_FILES]={0};\n\n    int no_packet_count=0;\n\n    int nb_frame_threshold[AVMEDIA_TYPE_NB]={0};\n\n    int nb_streams[AVMEDIA_TYPE_NB]={0};\n\n\n\n    if (rate_emu)\n\n        for (i = 0; i < nb_input_streams; i++)\n\n            input_streams[i].start = av_gettime();\n\n\n\n    \/* output stream init *\/\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n\n            av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n            fprintf(stderr, \"Output file #%d does not contain any stream\\n\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    \/* Sanity check the mapping args -- do the input files & streams exist? *\/\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        fi = stream_maps[i].sync_file_index;\n\n        si = stream_maps[i].sync_stream_index;\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find sync stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ost_table = av_mallocz(sizeof(OutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            nb_streams[os->streams[i]->codec->codec_type]++;\n\n        }\n\n    }\n\n    for(step=1<<30; step; step>>=1){\n\n        int found_streams[AVMEDIA_TYPE_NB]={0};\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            nb_frame_threshold[j] += step;\n\n\n\n        for(j=0; j<nb_input_streams; j++) {\n\n            int skip=0;\n\n            ist = &input_streams[j];\n\n            if(opt_programid){\n\n                int pi,si;\n\n                AVFormatContext *f= input_files[ ist->file_index ].ctx;\n\n                skip=1;\n\n                for(pi=0; pi<f->nb_programs; pi++){\n\n                    AVProgram *p= f->programs[pi];\n\n                    if(p->id == opt_programid)\n\n                        for(si=0; si<p->nb_stream_indexes; si++){\n\n                            if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                skip=0;\n\n                        }\n\n                }\n\n            }\n\n            if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip\n\n                && nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames){\n\n                found_streams[ist->st->codec->codec_type]++;\n\n            }\n\n        }\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            if(found_streams[j] < nb_streams[j])\n\n                nb_frame_threshold[j] -= step;\n\n    }\n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            int found;\n\n            ost = ost_table[n] = output_streams_for_file[k][i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = input_files[stream_maps[n].file_index].ist_index +\n\n                    stream_maps[n].stream_index;\n\n\n\n                \/* Sanity check that the stream types match *\/\n\n                if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {\n\n                    int i= ost->file_index;\n\n                    av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n].file_index, stream_maps[n].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    ffmpeg_exit(1);\n\n                }\n\n\n\n            } else {\n\n                \/* get corresponding input stream index : we select the first one with the right type *\/\n\n                found = 0;\n\n                for (j = 0; j < nb_input_streams; j++) {\n\n                    int skip=0;\n\n                    ist = &input_streams[j];\n\n                    if(opt_programid){\n\n                        int pi,si;\n\n                        AVFormatContext *f = input_files[ist->file_index].ctx;\n\n                        skip=1;\n\n                        for(pi=0; pi<f->nb_programs; pi++){\n\n                            AVProgram *p= f->programs[pi];\n\n                            if(p->id == opt_programid)\n\n                                for(si=0; si<p->nb_stream_indexes; si++){\n\n                                    if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                        skip=0;\n\n                                }\n\n                        }\n\n                    }\n\n                    if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip &&\n\n                        ist->st->codec->codec_type == ost->st->codec->codec_type &&\n\n                        nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                            break;\n\n                    }\n\n                }\n\n\n\n                if (!found) {\n\n                    if(! opt_programid) {\n\n                        \/* try again and reuse existing stream *\/\n\n                        for (j = 0; j < nb_input_streams; j++) {\n\n                            ist = &input_streams[j];\n\n                            if (   ist->st->codec->codec_type == ost->st->codec->codec_type\n\n                                && ist->st->discard != AVDISCARD_ALL) {\n\n                                ost->source_index = j;\n\n                                found = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        int i= ost->file_index;\n\n                        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = &input_streams[ost->source_index];\n\n            ist->discard = 0;\n\n            ost->sync_ist = (nb_stream_maps > 0) ?\n\n                &input_streams[input_files[stream_maps[n].sync_file_index].ist_index +\n\n                         stream_maps[n].sync_stream_index] : ist;\n\n        }\n\n    }\n\n\n\n    \/* for each output stream, we compute the right encoding parameters *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        os = output_files[ost->file_index];\n\n        ist = &input_streams[ost->source_index];\n\n\n\n        codec = ost->st->codec;\n\n        icodec = ist->st->codec;\n\n\n\n        if (metadata_streams_autocopy)\n\n            av_dict_copy(&ost->st->metadata, ist->st->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n\n\n        ost->st->disposition = ist->st->disposition;\n\n        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;\n\n        codec->chroma_sample_location = icodec->chroma_sample_location;\n\n\n\n        if (ost->st->stream_copy) {\n\n            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n\n\n\n            if (extra_size > INT_MAX)\n\n                goto fail;\n\n\n\n            \/* if stream_copy is selected, no need to decode or encode *\/\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n\n\n            if(!codec->codec_tag){\n\n                if(   !os->oformat->codec_tag\n\n                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id\n\n                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)\n\n                    codec->codec_tag = icodec->codec_tag;\n\n            }\n\n\n\n            codec->bit_rate = icodec->bit_rate;\n\n            codec->rc_max_rate    = icodec->rc_max_rate;\n\n            codec->rc_buffer_size = icodec->rc_buffer_size;\n\n            codec->extradata= av_mallocz(extra_size);\n\n            if (!codec->extradata)\n\n                goto fail;\n\n            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n\n            codec->extradata_size= icodec->extradata_size;\n\n            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0\/500){\n\n                codec->time_base = icodec->time_base;\n\n                codec->time_base.num *= icodec->ticks_per_frame;\n\n                av_reduce(&codec->time_base.num, &codec->time_base.den,\n\n                          codec->time_base.num, codec->time_base.den, INT_MAX);\n\n            }else\n\n                codec->time_base = ist->st->time_base;\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                if(audio_volume != 256) {\n\n                    fprintf(stderr,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                codec->channel_layout = icodec->channel_layout;\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                codec->frame_size = icodec->frame_size;\n\n                codec->audio_service_type = icodec->audio_service_type;\n\n                codec->block_align= icodec->block_align;\n\n                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)\n\n                    codec->block_align= 0;\n\n                if(codec->codec_id == CODEC_ID_AC3)\n\n                    codec->block_align= 0;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                codec->pix_fmt = icodec->pix_fmt;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                codec->has_b_frames = icodec->has_b_frames;\n\n                if (!codec->sample_aspect_ratio.num) {\n\n                    codec->sample_aspect_ratio =\n\n                    ost->st->sample_aspect_ratio =\n\n                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :\n\n                        ist->st->codec->sample_aspect_ratio.num ?\n\n                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};\n\n                }\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            case AVMEDIA_TYPE_DATA:\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            if (!ost->enc)\n\n                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ost->fifo= av_fifo_alloc(1024);\n\n                if(!ost->fifo)\n\n                    goto fail;\n\n                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);\n\n                if (!codec->sample_rate) {\n\n                    codec->sample_rate = icodec->sample_rate;\n\n                    if (icodec->lowres)\n\n                        codec->sample_rate >>= icodec->lowres;\n\n                }\n\n                choose_sample_rate(ost->st, ost->enc);\n\n                codec->time_base = (AVRational){1, codec->sample_rate};\n\n                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)\n\n                    codec->sample_fmt = icodec->sample_fmt;\n\n                choose_sample_fmt(ost->st, ost->enc);\n\n                if (!codec->channels) {\n\n                    codec->channels = icodec->channels;\n\n                    codec->channel_layout = icodec->channel_layout;\n\n                }\n\n                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)\n\n                    codec->channel_layout = 0;\n\n                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;\n\n                icodec->request_channels = codec->channels;\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                ost->resample_sample_fmt  = icodec->sample_fmt;\n\n                ost->resample_sample_rate = icodec->sample_rate;\n\n                ost->resample_channels    = icodec->channels;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (codec->pix_fmt == PIX_FMT_NONE)\n\n                    codec->pix_fmt = icodec->pix_fmt;\n\n                choose_pixel_fmt(ost->st, ost->enc);\n\n\n\n                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n\n                    fprintf(stderr, \"Video pixel format is unknown, stream cannot be encoded\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                ost->video_resample = codec->width   != icodec->width  ||\n\n                                      codec->height  != icodec->height ||\n\n                                      codec->pix_fmt != icodec->pix_fmt;\n\n                if (ost->video_resample) {\n\n                    codec->bits_per_raw_sample= frame_bits_per_raw_sample;\n\n                }\n\n                if (!codec->width || !codec->height) {\n\n                    codec->width  = icodec->width;\n\n                    codec->height = icodec->height;\n\n                }\n\n                ost->resample_height = icodec->height;\n\n                ost->resample_width  = icodec->width;\n\n                ost->resample_pix_fmt= icodec->pix_fmt;\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n\n\n                if (!ost->frame_rate.num)\n\n                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};\n\n                if (ost->enc && ost->enc->supported_framerates && !force_fps) {\n\n                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);\n\n                    ost->frame_rate = ost->enc->supported_framerates[idx];\n\n                }\n\n                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};\n\n                if(   av_q2d(codec->time_base) < 0.001 && video_sync_method\n\n                   && (video_sync_method==1 || (video_sync_method<0 && !(os->oformat->flags & AVFMT_VARIABLE_FPS)))){\n\n                    av_log(os, AV_LOG_WARNING, \"Frame rate very high for a muxer not effciciently supporting it.\\n\"\n\n                                               \"Please consider specifiying a lower framerate, a different muxer or -vsync 2\\n\");\n\n                }\n\n\n\n#if CONFIG_AVFILTER\n\n                if (configure_video_filters(ist, ost)) {\n\n                    fprintf(stderr, \"Error opening filters!\\n\");\n\n                    exit(1);\n\n                }\n\n#endif\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                abort();\n\n                break;\n\n            }\n\n            \/* two pass mode *\/\n\n            if (ost->encoding_needed && codec->codec_id != CODEC_ID_H264 &&\n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n\n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\",\n\n                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,\n\n                         i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"wb\");\n\n                    if (!f) {\n\n                        fprintf(stderr, \"Cannot write log file '%s' for pass-1 encoding: %s\\n\", logfilename, strerror(errno));\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    char  *logbuffer;\n\n                    size_t logbuffer_size;\n\n                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n\n                        fprintf(stderr, \"Error reading log file '%s' for pass-2 encoding\\n\", logfilename);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){\n\n            \/* maximum video buffer size is 6-bytes per pixel, plus DPX header size *\/\n\n            int size= codec->width * codec->height;\n\n            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n\n        }\n\n    }\n\n\n\n    if (!bit_buffer)\n\n        bit_buffer = av_malloc(bit_buffer_size);\n\n    if (!bit_buffer) {\n\n        fprintf(stderr, \"Cannot allocate %d bytes output buffer\\n\",\n\n                bit_buffer_size);\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    \/* open each encoder *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec = ost->enc;\n\n            AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Encoder (codec id %d) not found for output stream #%d.%d\",\n\n                         ost->st->codec->codec_id, ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (dec->subtitle_header) {\n\n                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n\n                if (!ost->st->codec->subtitle_header) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto dump_format;\n\n                }\n\n                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n\n                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n\n            }\n\n            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\",\n\n                        ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ost->st->codec, 1);\n\n            assert_avoptions(ost->opts);\n\n            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)\n\n                av_log(NULL, AV_LOG_WARNING, \"The bitrate parameter is set too low.\"\n\n                                             \"It takes bits\/s as argument, not kbits\/s\\n\");\n\n            extra_size += ost->st->codec->extradata_size;\n\n        }\n\n    }\n\n\n\n    \/* open each decoder *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec = ist->dec;\n\n            if (!codec)\n\n                codec = avcodec_find_decoder(ist->st->codec->codec_id);\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Decoder (codec id %d) not found for input stream #%d.%d\",\n\n                        ist->st->codec->codec_id, ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening decoder for input stream #%d.%d\",\n\n                        ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ist->st->codec, 0);\n\n            assert_avoptions(ost->opts);\n\n            \/\/if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            \/\/    ist->st->codec->flags |= CODEC_FLAG_REPEAT_FIELD;\n\n        }\n\n    }\n\n\n\n    \/* init pts *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        AVStream *st;\n\n        ist = &input_streams[i];\n\n        st= ist->st;\n\n        ist->pts = st->avg_frame_rate.num ? - st->codec->has_b_frames*AV_TIME_BASE \/ av_q2d(st->avg_frame_rate) : 0;\n\n        ist->next_pts = AV_NOPTS_VALUE;\n\n        ist->is_start = 1;\n\n    }\n\n\n\n    \/* set meta data information from input file if required *\/\n\n    for (i=0;i<nb_meta_data_maps;i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            snprintf(error, sizeof(error), \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            ret = AVERROR(EINVAL);\\\n\n            goto dump_format;\\\n\n        }\n\n\n\n        int out_file_index = meta_data_maps[i][0].file;\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0 || out_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(out_file_index, nb_output_files, \"output file\")\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = output_files[out_file_index];\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    \/* copy global metadata by default *\/\n\n    if (metadata_global_autocopy) {\n\n\n\n        for (i = 0; i < nb_output_files; i++)\n\n            av_dict_copy(&output_files[i]->metadata, input_files[0].ctx->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    \/* copy chapters according to chapter maps *\/\n\n    for (i = 0; i < nb_chapter_maps; i++) {\n\n        int infile  = chapter_maps[i].in_file;\n\n        int outfile = chapter_maps[i].out_file;\n\n\n\n        if (infile < 0 || outfile < 0)\n\n            continue;\n\n        if (infile >= nb_input_files) {\n\n            snprintf(error, sizeof(error), \"Invalid input file index %d in chapter mapping.\\n\", infile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        if (outfile >= nb_output_files) {\n\n            snprintf(error, sizeof(error), \"Invalid output file index %d in chapter mapping.\\n\",outfile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        copy_chapters(infile, outfile);\n\n    }\n\n\n\n    \/* copy chapters from the first input file that has them*\/\n\n    if (!nb_chapter_maps)\n\n        for (i = 0; i < nb_input_files; i++) {\n\n            if (!input_files[i].ctx->nb_chapters)\n\n                continue;\n\n\n\n            for (j = 0; j < nb_output_files; j++)\n\n                if ((ret = copy_chapters(i, j)) < 0)\n\n                    goto dump_format;\n\n            break;\n\n        }\n\n\n\n    \/* open files and write file headers *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (avformat_write_header(os, &output_opts[i]) < 0) {\n\n            snprintf(error, sizeof(error), \"Could not write header for output file #%d (incorrect codec parameters ?)\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        assert_avoptions(output_opts[i]);\n\n        if (strcmp(output_files[i]->oformat->name, \"rtp\")) {\n\n            want_sdp = 0;\n\n        }\n\n    }\n\n\n\n dump_format:\n\n    \/* dump the file output parameters - cannot be done before in case\n\n       of stream copy *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    \/* dump the stream mapping *\/\n\n    if (verbose >= 0) {\n\n        fprintf(stderr, \"Stream mapping:\\n\");\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\",\n\n                    input_streams[ost->source_index].file_index,\n\n                    input_streams[ost->source_index].st->index,\n\n                    ost->file_index,\n\n                    ost->index);\n\n            if (ost->sync_ist != &input_streams[ost->source_index])\n\n                fprintf(stderr, \" [sync #%d.%d]\",\n\n                        ost->sync_ist->file_index,\n\n                        ost->sync_ist->st->index);\n\n            fprintf(stderr, \"\\n\");\n\n        }\n\n    }\n\n\n\n    if (ret) {\n\n        fprintf(stderr, \"%s\\n\", error);\n\n        goto fail;\n\n    }\n\n\n\n    if (want_sdp) {\n\n        print_sdp(output_files, nb_output_files);\n\n    }\n\n\n\n    if (!using_stdin) {\n\n        if(verbose >= 0)\n\n            fprintf(stderr, \"Press [q] to stop, [?] for help\\n\");\n\n        avio_set_interrupt_cb(decode_interrupt_cb);\n\n    }\n\n    term_init();\n\n\n\n    timer_start = av_gettime();\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        double ipts_min;\n\n        double opts_min;\n\n\n\n    redo:\n\n        ipts_min= 1e100;\n\n        opts_min= 1e100;\n\n        \/* if 'q' pressed, exits *\/\n\n        if (!using_stdin) {\n\n            if (q_pressed)\n\n                break;\n\n            \/* read_key() returns 0 on EOF *\/\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n            if (key == '+') verbose++;\n\n            if (key == '-') verbose--;\n\n            if (key == 's') qp_hist     ^= 1;\n\n            if (key == 'h'){\n\n                if (do_hex_dump){\n\n                    do_hex_dump = do_pkt_dump = 0;\n\n                } else if(do_pkt_dump){\n\n                    do_hex_dump = 1;\n\n                } else\n\n                    do_pkt_dump = 1;\n\n                av_log_set_level(AV_LOG_DEBUG);\n\n            }\n\n            if (key == 'd' || key == 'D'){\n\n                int debug=0;\n\n                if(key == 'D') {\n\n                    debug = input_streams[0].st->codec->debug<<1;\n\n                    if(!debug) debug = 1;\n\n                    while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) \/\/unsupported, would just crash\n\n                        debug += debug;\n\n                }else\n\n                    scanf(\"%d\", &debug);\n\n                for(i=0;i<nb_input_streams;i++) {\n\n                    input_streams[i].st->codec->debug = debug;\n\n                }\n\n                for(i=0;i<nb_ostreams;i++) {\n\n                    ost = ost_table[i];\n\n                    ost->st->codec->debug = debug;\n\n                }\n\n                if(debug) av_log_set_level(AV_LOG_DEBUG);\n\n                fprintf(stderr,\"debug=%d\\n\", debug);\n\n            }\n\n            if (key == '?'){\n\n                fprintf(stderr, \"key    function\\n\"\n\n                                \"?      show this help\\n\"\n\n                                \"+      increase verbosity\\n\"\n\n                                \"-      decrease verbosity\\n\"\n\n                                \"D      cycle through available debug modes\\n\"\n\n                                \"h      dump packets\/hex press to cycle through the 3 states\\n\"\n\n                                \"q      quit\\n\"\n\n                                \"s      Show QP histogram\\n\"\n\n                );\n\n            }\n\n        }\n\n\n\n        \/* select the stream that we must read now by looking at the\n\n           smallest output pts *\/\n\n        file_index = -1;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double ipts, opts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = &input_streams[ost->source_index];\n\n            if(ist->is_past_recording_time || no_packet[ist->file_index])\n\n                continue;\n\n                opts = ost->st->pts.val * av_q2d(ost->st->time_base);\n\n            ipts = (double)ist->pts;\n\n            if (!input_files[ist->file_index].eof_reached){\n\n                if(ipts < ipts_min) {\n\n                    ipts_min = ipts;\n\n                    if(input_sync ) file_index = ist->file_index;\n\n                }\n\n                if(opts < opts_min) {\n\n                    opts_min = opts;\n\n                    if(!input_sync) file_index = ist->file_index;\n\n                }\n\n            }\n\n            if(ost->frame_number >= max_frames[ost->st->codec->codec_type]){\n\n                file_index= -1;\n\n                break;\n\n            }\n\n        }\n\n        \/* if none, if is finished *\/\n\n        if (file_index < 0) {\n\n            if(no_packet_count){\n\n                no_packet_count=0;\n\n                memset(no_packet, 0, sizeof(no_packet));\n\n                usleep(10000);\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n\n\n        \/* finish if limit size exhausted *\/\n\n        if (limit_filesize != 0 && limit_filesize <= avio_tell(output_files[0]->pb))\n\n            break;\n\n\n\n        \/* read a frame from it and output it in the fifo *\/\n\n        is = input_files[file_index].ctx;\n\n        ret= av_read_frame(is, &pkt);\n\n        if(ret == AVERROR(EAGAIN)){\n\n            no_packet[file_index]=1;\n\n            no_packet_count++;\n\n            continue;\n\n        }\n\n        if (ret < 0) {\n\n            input_files[file_index].eof_reached = 1;\n\n            if (opt_shortest)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        no_packet_count=0;\n\n        memset(no_packet, 0, sizeof(no_packet));\n\n\n\n        if (do_pkt_dump) {\n\n            av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,\n\n                             is->streams[pkt.stream_index]);\n\n        }\n\n        \/* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them *\/\n\n        if (pkt.stream_index >= input_files[file_index].ctx->nb_streams)\n\n            goto discard_packet;\n\n        ist_index = input_files[file_index].ist_index + pkt.stream_index;\n\n        ist = &input_streams[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        if (pkt.dts != AV_NOPTS_VALUE)\n\n            pkt.dts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n        if (pkt.pts != AV_NOPTS_VALUE)\n\n            pkt.pts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n\n\n        if (ist->ts_scale) {\n\n            if(pkt.pts != AV_NOPTS_VALUE)\n\n                pkt.pts *= ist->ts_scale;\n\n            if(pkt.dts != AV_NOPTS_VALUE)\n\n                pkt.dts *= ist->ts_scale;\n\n        }\n\n\n\n\/\/        fprintf(stderr, \"next:%\"PRId64\" dts:%\"PRId64\" off:%\"PRId64\" %d\\n\", ist->next_pts, pkt.dts, input_files[ist->file_index].ts_offset, ist->st->codec->codec_type);\n\n        if (pkt.dts != AV_NOPTS_VALUE && ist->next_pts != AV_NOPTS_VALUE\n\n            && (is->iformat->flags & AVFMT_TS_DISCONT)) {\n\n            int64_t pkt_dts= av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            int64_t delta= pkt_dts - ist->next_pts;\n\n            if((FFABS(delta) > 1LL*dts_delta_threshold*AV_TIME_BASE || pkt_dts+1<ist->pts)&& !copy_ts){\n\n                input_files[ist->file_index].ts_offset -= delta;\n\n                if (verbose > 2)\n\n                    fprintf(stderr, \"timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n\n                            delta, input_files[ist->file_index].ts_offset);\n\n                pkt.dts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n                if(pkt.pts != AV_NOPTS_VALUE)\n\n                    pkt.pts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n            }\n\n        }\n\n\n\n        \/* finish if recording time exhausted *\/\n\n        if (recording_time != INT64_MAX &&\n\n            (pkt.pts != AV_NOPTS_VALUE ?\n\n                av_compare_ts(pkt.pts, ist->st->time_base, recording_time + start_time, (AVRational){1, 1000000})\n\n                    :\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, recording_time + start_time, (AVRational){1, 1000000})\n\n            )>= 0) {\n\n            ist->is_past_recording_time = 1;\n\n            goto discard_packet;\n\n        }\n\n\n\n        \/\/fprintf(stderr,\"read #%d.%d size=%d\\n\", ist->file_index, ist->st->index, pkt.size);\n\n        if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n\n\n\n            if (verbose >= 0)\n\n                fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                        ist->file_index, ist->st->index);\n\n            if (exit_on_error)\n\n                ffmpeg_exit(1);\n\n            av_free_packet(&pkt);\n\n            goto redo;\n\n        }\n\n\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n\n\n        \/* dump report by using the output first video and audio streams *\/\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n\n\n    \/* at the end of stream, we must flush the decoder buffers *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            output_packet(ist, i, ost_table, nb_ostreams, NULL);\n\n        }\n\n    }\n\n\n\n    term_exit();\n\n\n\n    \/* write the trailer if needed and close file *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n\n\n    \/* dump report by using the first video and audio streams *\/\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    \/* close each encoder *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec->stats_in);\n\n            avcodec_close(ost->st->codec);\n\n        }\n\n#if CONFIG_AVFILTER\n\n        avfilter_graph_free(&ost->graph);\n\n#endif\n\n    }\n\n\n\n    \/* close each decoder *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(ist->st->codec);\n\n        }\n\n    }\n\n\n\n    \/* finished ! *\/\n\n    ret = 0;\n\n\n\n fail:\n\n    av_freep(&bit_buffer);\n\n\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->st->stream_copy)\n\n                    av_freep(&ost->st->codec->extradata);\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                av_fifo_free(ost->fifo); \/* works even if fifo is not\n\n                                             initialized but set to zero *\/\n\n                av_freep(&ost->st->codec->subtitle_header);\n\n                av_free(ost->resample_frame.data[0]);\n\n                av_free(ost->forced_kf_pts);\n\n                if (ost->video_resample)\n\n                    sws_freeContext(ost->img_resample_ctx);\n\n                if (ost->resample)\n\n                    audio_resample_close(ost->resample);\n\n                if (ost->reformat_ctx)\n\n                    av_audio_convert_free(ost->reformat_ctx);\n\n                av_dict_free(&ost->opts);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n}\n","idx":1,"target":0}
{"code":"void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n}\n","idx":48,"target":0}
{"code":"static int announce_self_create(uint8_t *buf, \n\n\t\t\t\tuint8_t *mac_addr)\n\n{\n\n    uint32_t magic = EXPERIMENTAL_MAGIC;\n\n    uint16_t proto = htons(ETH_P_EXPERIMENTAL);\n\n\n\n    \/* FIXME: should we send a different packet (arp\/rarp\/ping)? *\/\n\n\n\n    memset(buf, 0, 64);\n\n    memset(buf, 0xff, 6);         \/* h_dst *\/\n\n    memcpy(buf + 6, mac_addr, 6); \/* h_src *\/\n\n    memcpy(buf + 12, &proto, 2);  \/* h_proto *\/\n\n    memcpy(buf + 14, &magic, 4);  \/* magic *\/\n\n\n\n    return 64; \/* len *\/\n\n}\n","idx":18951,"target":1}
{"code":"int av_packet_ref(AVPacket *dst, AVPacket *src)\n\n{\n\n    int ret;\n\n\n\n    ret = av_packet_copy_props(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!src->buf) {\n\n        ret = packet_alloc(&dst->buf, src->size);\n\n        if (ret < 0)\n\n            goto fail;\n\n        memcpy(dst->buf->data, src->data, src->size);\n\n    } else\n\n        dst->buf = av_buffer_ref(src->buf);\n\n\n\n    dst->size = src->size;\n\n    dst->data = dst->buf->data;\n\n    return 0;\n\nfail:\n\n    av_packet_free_side_data(dst);\n\n    return ret;\n\n}\n","idx":28,"target":0}
{"code":"static int openfile(char *name, int flags, QDict *opts)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n\n    if (qemuio_blk) {\n\n        fprintf(stderr, \"file open already, try 'help close'\\n\");\n\n        QDECREF(opts);\n\n        return 1;\n\n    }\n\n\n\n    qemuio_blk = blk_new_open(\"hda\", name, NULL, opts, flags, &local_err);\n\n    if (!qemuio_blk) {\n\n        fprintf(stderr, \"%s: can't open%s%s: %s\\n\", progname,\n\n                name ? \" device \" : \"\", name ?: \"\",\n\n                error_get_pretty(local_err));\n\n        error_free(local_err);\n\n        return 1;\n\n    }\n\n\n\n    bs = blk_bs(qemuio_blk);\n\n    if (bdrv_is_encrypted(bs)) {\n\n        char password[256];\n\n        printf(\"Disk image '%s' is encrypted.\\n\", name);\n\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n\n            error_report(\"No password given\");\n\n            goto error;\n\n        }\n\n        if (bdrv_set_key(bs, password) < 0) {\n\n            error_report(\"invalid password\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n\n\n    return 0;\n\n\n\n error:\n\n    blk_unref(qemuio_blk);\n\n    qemuio_blk = NULL;\n\n    return 1;\n\n}","idx":8022,"target":1}
{"code":"static void blend_frame(AVFilterContext *ctx,\n                        AVFrame *top_buf,\n                        AVFrame *bottom_buf,\n                        AVFrame *dst_buf)\n{\n    BlendContext *b = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    FilterParams *param;\n    int plane;\n\n    for (plane = 0; dst_buf->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? b->hsub : 0;\n        int vsub = plane == 1 || plane == 2 ? b->vsub : 0;\n        int outw = dst_buf->width  >> hsub;\n        int outh = dst_buf->height >> vsub;\n        uint8_t *dst    = dst_buf->data[plane];\n        uint8_t *top    = top_buf->data[plane];\n        uint8_t *bottom = bottom_buf->data[plane];\n\n        param = &b->params[plane];\n        param->values[VAR_N]  = inlink->frame_count;\n        param->values[VAR_T]  = dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts * av_q2d(inlink->time_base);\n        param->values[VAR_W]  = outw;\n        param->values[VAR_H]  = outh;\n        param->values[VAR_SW] = outw \/ dst_buf->width;\n        param->values[VAR_SH] = outh \/ dst_buf->height;\n        param->blend(top, top_buf->linesize[plane],\n                     bottom, bottom_buf->linesize[plane],\n                     dst, dst_buf->linesize[plane], outw, outh, param);\n    }\n}","idx":1292326,"target":1}
{"code":"static int decode_interrupt_cb(void *ctx)\n\n{\n\n    return received_nb_signals > transcode_init_done;\n\n}\n","idx":25377,"target":1}
{"code":"DVMuxContext* dv_init_mux(AVFormatContext* s)\n\n{\n\n    DVMuxContext *c;\n\n    AVStream *vst = NULL;\n\n    int i;\n\n\n\n    \/* we support at most 1 video and 2 audio streams *\/\n\n    if (s->nb_streams > 3)\n\n        return NULL;\n\n\n\n    c = av_mallocz(sizeof(DVMuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->n_ast = 0;\n\n    c->ast[0] = c->ast[1] = NULL;\n\n\n\n    \/* We have to sort out where audio and where video stream is *\/\n\n    for (i=0; i<s->nb_streams; i++) {\n\n         switch (s->streams[i]->codec->codec_type) {\n\n         case CODEC_TYPE_VIDEO:\n\n               vst = s->streams[i];\n\n               break;\n\n         case CODEC_TYPE_AUDIO:\n\n             c->ast[c->n_ast++] = s->streams[i];\n\n             break;\n\n         default:\n\n               goto bail_out;\n\n         }\n\n    }\n\n\n\n    \/* Some checks -- DV format is very picky about its incoming streams *\/\n\n    if (!vst || vst->codec->codec_id != CODEC_ID_DVVIDEO)\n\n        goto bail_out;\n\n    for (i=0; i<c->n_ast; i++) {\n\n        if (c->ast[i] && (c->ast[i]->codec->codec_id != CODEC_ID_PCM_S16LE ||\n\n                          c->ast[i]->codec->sample_rate != 48000 ||\n\n                          c->ast[i]->codec->channels != 2))\n\n            goto bail_out;\n\n    }\n\n    c->sys = dv_codec_profile(vst->codec);\n\n    if (!c->sys)\n\n        goto bail_out;\n\n\n\n    if((c->n_ast > 1) && (c->sys->n_difchan < 2)) {\n\n        \/* only 1 stereo pair is allowed in 25Mbps mode *\/\n\n        goto bail_out;\n\n    }\n\n\n\n    \/* Ok, everything seems to be in working order *\/\n\n    c->frames = 0;\n\n    c->has_audio = 0;\n\n    c->has_video = 0;\n\n    c->start_time = (time_t)s->timestamp;\n\n\n\n    for (i=0; i<c->n_ast; i++) {\n\n        if (c->ast[i] && av_fifo_init(&c->audio_data[i], 100*AVCODEC_MAX_AUDIO_FRAME_SIZE) < 0) {\n\n            while (i>0) {\n\n                i--;\n\n                av_fifo_free(&c->audio_data[i]);\n\n            }\n\n            goto bail_out;\n\n        }\n\n    }\n\n\n\n    return c;\n\n\n\nbail_out:\n\n    av_free(c);\n\n    return NULL;\n\n}\n","idx":4229,"target":1}
{"code":"av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)\n\n{\n\n#if HAVE_ALTIVEC\n\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n\n        return;\n\n\n\n    fdsp->vector_fmul = ff_vector_fmul_altivec;\n\n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;\n\n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;\n\n\n\n    if (!bit_exact) {\n\n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;\n\n    }\n\n#endif\n\n}\n","idx":29,"target":0}
{"code":"static void ehci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    EHCIPCIInfo *i = data;\n\n\n\n    k->init = usb_ehci_pci_initfn;\n\n    k->vendor_id = i->vendor_id;\n\n    k->device_id = i->device_id;\n\n    k->revision = i->revision;\n\n    k->class_id = PCI_CLASS_SERIAL_USB;\n\n    k->config_write = usb_ehci_pci_write_config;\n\n\n    dc->vmsd = &vmstate_ehci_pci;\n\n    dc->props = ehci_pci_properties;\n\n}","idx":21407,"target":1}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    HQDN3DContext *s = inlink->dst->priv;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    int i;\n    s->hsub  = desc->log2_chroma_w;\n    s->vsub  = desc->log2_chroma_h;\n    s->depth = desc->comp[0].depth_minus1+1;\n    s->line = av_malloc(inlink->w * sizeof(*s->line));\n    if (!s->line)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < 4; i++) {\n        s->coefs[i] = precalc_coefs(s->strength[i], s->depth);\n        if (!s->coefs[i])\n            return AVERROR(ENOMEM);\n    }\n    if (ARCH_X86)\n        ff_hqdn3d_init_x86(s);\n    return 0;\n}","idx":8195,"target":1}
{"code":"int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n","idx":4,"target":0}
{"code":"static int decode_blocks(SnowContext *s){\n\n    int x, y;\n\n    int w= s->b_width;\n\n    int h= s->b_height;\n\n    int res;\n\n\n\n    for(y=0; y<h; y++){\n\n        for(x=0; x<w; x++){\n\n\n\n            if ((res = decode_q_branch(s, 0, x, y)) < 0)\n\n                return res;\n\n        }\n\n    }\n\n    return 0;\n\n}","idx":5360,"target":1}
{"code":"static void *merge_action_dir_configs(apr_pool_t *p, void *basev, void *addv)\n{\n    action_dir_config *base = (action_dir_config *) basev;\n    action_dir_config *add = (action_dir_config *) addv;\n    action_dir_config *new = (action_dir_config *) apr_palloc(p,\n                                  sizeof(action_dir_config));\n    int i;\n\n    new->action_types = apr_table_overlay(p, add->action_types,\n                                       base->action_types);\n\n    for (i = 0; i < METHODS; ++i) {\n        new->scripted[i] = add->scripted[i] ? add->scripted[i]\n                                            : base->scripted[i];\n    }\n\n    new->configured = (base->configured || add->configured);\n    return new;\n}","idx":10,"target":0}
{"code":"static int biquad_init_coeffs(void *avc, struct FFIIRFilterCoeffs *c,\n                              enum IIRFilterMode filt_mode, int order,\n                              float cutoff_ratio, float stopband)\n{\n    double cos_w0, sin_w0;\n    double a0, x0, x1;\n\n    if (filt_mode != FF_FILTER_MODE_HIGHPASS &&\n        filt_mode != FF_FILTER_MODE_LOWPASS) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter currently only supports \"\n               \"high-pass and low-pass filter modes\\n\");\n        return -1;\n    }\n    if (order != 2) {\n        av_log(avc, AV_LOG_ERROR, \"Biquad filter must have order of 2\\n\");\n        return -1;\n    }\n\n    cos_w0 = cos(M_PI * cutoff_ratio);\n    sin_w0 = sin(M_PI * cutoff_ratio);\n\n    a0 = 1.0 + (sin_w0 \/ 2.0);\n\n    if (filt_mode == FF_FILTER_MODE_HIGHPASS) {\n        c->gain  =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 + cos_w0) \/ 2.0)  \/ a0;\n        x1       = (-(1.0 + cos_w0))        \/ a0;\n    } else { \/\/ FF_FILTER_MODE_LOWPASS\n        c->gain  =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x0       =  ((1.0 - cos_w0) \/ 2.0)  \/ a0;\n        x1       =   (1.0 - cos_w0)         \/ a0;\n    }\n    c->cy[0] = (-1.0 + (sin_w0 \/ 2.0)) \/ a0;\n    c->cy[1] =  (2.0 *  cos_w0)        \/ a0;\n\n    \/\/ divide by gain to make the x coeffs integers.\n    \/\/ during filtering, the delay state will include the gain multiplication\n    c->cx[0] = lrintf(x0 \/ c->gain);\n    c->cx[1] = lrintf(x1 \/ c->gain);\n\n    return 0;\n}","idx":634857,"target":1}
{"code":"static int config_input(AVFilterLink *inlink)\n{\n    AVFilterContext *ctx = inlink->dst;\n    FrameRateContext *s = ctx->priv;\n    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);\n    int plane;\n\n    for (plane = 0; plane < 4; plane++) {\n        s->line_size[plane] = av_image_get_linesize(inlink->format, inlink->w,\n                                                    plane);\n    }\n\n    s->bitdepth = pix_desc->comp[0].depth;\n    s->vsub = pix_desc->log2_chroma_h;\n    s->interp_start = s->interp_start_param << (s->bitdepth - 8);\n    s->interp_end = s->interp_end_param << (s->bitdepth - 8);\n\n    s->sad = av_pixelutils_get_sad_fn(3, 3, 2, s); \/\/ 8x8 both sources aligned\n    if (!s->sad)\n        return AVERROR(EINVAL);\n\n    s->srce_time_base = inlink->time_base;\n\n    s->max = 1 << (s->bitdepth);\n    if (s->bitdepth == 8)\n        s->blend = blend_frames_c;\n    else\n        s->blend = blend_frames16_c;\n\n    return 0;\n}","idx":1291695,"target":1}
{"code":"static int mov_write_minf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    int ret;\n\n\n\n    avio_wb32(pb, 0); \/* size *\/\n\n    ffio_wfourcc(pb, \"minf\");\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        mov_write_vmhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        mov_write_smhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n\n            mov_write_gmhd_tag(pb, track);\n\n        } else {\n\n            mov_write_nmhd_tag(pb);\n\n        }\n\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n\n        mov_write_hmhd_tag(pb);\n\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n\n        mov_write_gmhd_tag(pb, track);\n\n    }\n\n    if (track->mode == MODE_MOV) \/* FIXME: Why do it for MODE_MOV only ? *\/\n\n        mov_write_hdlr_tag(pb, NULL);\n\n    mov_write_dinf_tag(pb);\n\n    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)\n\n        return ret;\n\n    return update_size(pb, pos);\n\n}\n","idx":27,"target":0}
{"code":"apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,\n                            ap_input_mode_t mode, apr_read_type_e block,\n                            apr_off_t readbytes)\n{\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    apr_off_t totalread;\n\n    \/* just get out of the way of things we don't want. *\/\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_palloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n        ctx->remaining = 0;\n        ctx->limit_used = 0;\n        ctx->eos_sent = 0;\n\n        \/* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         *\/\n        if (!f->r->proxyreq) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (!strcasecmp(tenc, \"chunked\")) {\n                ctx->state = BODY_CHUNK;\n            }\n        }\n        else if (lenp) {\n            char *endstr;\n\n            ctx->state = BODY_LENGTH;\n            errno = 0;\n\n            \/* Protects against over\/underflow, non-digit chars in the\n             * string (excluding leading space) (the endstr checks)\n             * and a negative number. *\/\n            if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)\n                || endstr == lenp || *endstr || ctx->remaining < 0) {\n                apr_bucket_brigade *bb;\n\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                              \"Invalid Content-Length\");\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n\n            \/* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             *\/\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                apr_bucket_brigade *bb;\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool, f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n        }\n\n        \/* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         *\/\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        }\n\n        \/* Since we're about to read data, send 100-Continue if needed.\n         * Only valid on chunked and C-L bodies where the C-L is > 0. *\/\n        if ((ctx->state == BODY_CHUNK ||\n            (ctx->state == BODY_LENGTH && ctx->remaining > 0)) &&\n            f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)) {\n            char *tmp;\n            apr_bucket_brigade *bb;\n\n            tmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL, \" \",\n                              ap_get_status_line(100), CRLF CRLF, NULL);\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n            e = apr_bucket_pool_create(tmp, strlen(tmp), f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_HEAD(bb, e);\n            e = apr_bucket_flush_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n\n            ap_pass_brigade(f->c->output_filters, bb);\n        }\n\n        \/* We can't read the chunk until after sending 100 if required. *\/\n        if (ctx->state == BODY_CHUNK) {\n            char line[30];\n            apr_bucket_brigade *bb;\n            apr_size_t len = 30;\n            apr_off_t brigade_length;\n\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                APR_BLOCK_READ, 0);\n\n            if (rv == APR_SUCCESS) {\n                \/* We have to check the length of the brigade we got back.\n                 * We will not accept partial lines.\n                 *\/\n                rv = apr_brigade_length(bb, 1, &brigade_length);\n                if (rv == APR_SUCCESS\n                    && brigade_length > f->r->server->limit_req_line) {\n                    rv = APR_ENOSPC;\n                }\n                if (rv == APR_SUCCESS) {\n                    rv = apr_brigade_flatten(bb, line, &len);\n                    if (rv == APR_SUCCESS) {\n                        ctx->remaining = get_chunk_size(line);\n                    }\n                }\n            }\n            apr_brigade_cleanup(bb);\n\n            \/* Detect chunksize error (such as overflow) *\/\n            if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                ctx->remaining = 0; \/* Reset it in case we have to\n                                     * come back here later *\/\n                e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                           f->r->pool,\n                                           f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(bb, e);\n                ctx->eos_sent = 1;\n                return ap_pass_brigade(f->r->output_filters, bb);\n            }\n\n            if (!ctx->remaining) {\n                \/* Handle trailers by calling ap_get_mime_headers again! *\/\n                ctx->state = BODY_NONE;\n                ap_get_mime_headers(f->r);\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->eos_sent = 1;\n                return APR_SUCCESS;\n            }\n        }\n    }\n\n    if (ctx->eos_sent) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    if (!ctx->remaining) {\n        switch (ctx->state) {\n        case BODY_NONE:\n            break;\n        case BODY_LENGTH:\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n            ctx->eos_sent = 1;\n            return APR_SUCCESS;\n        case BODY_CHUNK:\n            {\n                char line[30];\n                apr_bucket_brigade *bb;\n                apr_size_t len = 30;\n\n                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n\n                \/* We need to read the CRLF after the chunk.  *\/\n                rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                    APR_BLOCK_READ, 0);\n                apr_brigade_cleanup(bb);\n\n                if (rv == APR_SUCCESS) {\n                    \/* Read the real chunk line. *\/\n                    rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE,\n                                        APR_BLOCK_READ, 0);\n                    if (rv == APR_SUCCESS) {\n                        rv = apr_brigade_flatten(bb, line, &len);\n                        if (rv == APR_SUCCESS) {\n                            ctx->remaining = get_chunk_size(line);\n                        }\n                    }\n                    apr_brigade_cleanup(bb);\n                }\n\n                \/* Detect chunksize error (such as overflow) *\/\n                if (rv != APR_SUCCESS || ctx->remaining < 0) {\n                    ctx->remaining = 0; \/* Reset it in case we have to\n                                         * come back here later *\/\n                    e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE,\n                                               NULL, f->r->pool,\n                                               f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(bb, e);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(bb, e);\n                    ctx->eos_sent = 1;\n                    return ap_pass_brigade(f->r->output_filters, bb);\n                }\n\n                if (!ctx->remaining) {\n                    \/* Handle trailers by calling ap_get_mime_headers again! *\/\n                    ctx->state = BODY_NONE;\n                    ap_get_mime_headers(f->r);\n                    e = apr_bucket_eos_create(f->c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    ctx->eos_sent = 1;\n                    return APR_SUCCESS;\n                }\n            }\n            break;\n        }\n    }\n\n    \/* Ensure that the caller can not go over our boundary point. *\/\n    if (ctx->state == BODY_LENGTH || ctx->state == BODY_CHUNK) {\n        if (ctx->remaining < readbytes) {\n            readbytes = ctx->remaining;\n        }\n        AP_DEBUG_ASSERT(readbytes > 0);\n    }\n\n    rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    \/* How many bytes did we just read? *\/\n    apr_brigade_length(b, 0, &totalread);\n\n    \/* If this happens, we have a bucket of unknown length.  Die because\n     * it means our assumptions have changed. *\/\n    AP_DEBUG_ASSERT(totalread >= 0);\n\n    if (ctx->state != BODY_NONE) {\n        ctx->remaining -= totalread;\n    }\n\n    \/* If we have no more bytes remaining on a C-L request,\n     * save the callter a roundtrip to discover EOS.\n     *\/\n    if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n    }\n\n    \/* We have a limit in effect. *\/\n    if (ctx->limit) {\n        \/* FIXME: Note that we might get slightly confused on chunked inputs\n         * as we'd need to compensate for the chunk lengths which may not\n         * really count.  This seems to be up for interpretation.  *\/\n        ctx->limit_used += totalread;\n        if (ctx->limit < ctx->limit_used) {\n            apr_bucket_brigade *bb;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,\n                          \"Read content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);\n            bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);\n            e = ap_bucket_error_create(HTTP_REQUEST_ENTITY_TOO_LARGE, NULL,\n                                       f->r->pool,\n                                       f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            e = apr_bucket_eos_create(f->c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bb, e);\n            ctx->eos_sent = 1;\n            return ap_pass_brigade(f->r->output_filters, bb);\n        }\n    }\n\n    return APR_SUCCESS;\n}","idx":13,"target":0}
{"code":"static\nECDSA_SIG *SM2_sig_gen(const EC_KEY *key, const BIGNUM *e)\n{\n    const BIGNUM *dA = EC_KEY_get0_private_key(key);\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n\n    ECDSA_SIG *sig = NULL;\n    EC_POINT *kG = NULL;\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *rk = NULL;\n    BIGNUM *r = NULL;\n    BIGNUM *s = NULL;\n    BIGNUM *x1 = NULL;\n    BIGNUM *tmp = NULL;\n\n    kG = EC_POINT_new(group);\n    if (kG == NULL)\n        goto done;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto done;\n\n    BN_CTX_start(ctx);\n\n    k = BN_CTX_get(ctx);\n    rk = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n\n    if (tmp == NULL)\n        goto done;\n\n    \/* These values are returned and so should not be allocated out of the context *\/\n    r = BN_new();\n    s = BN_new();\n\n    if (r == NULL || s == NULL)\n        goto done;\n\n    for (;;) {\n        BN_priv_rand_range(k, order);\n\n        if (EC_POINT_mul(group, kG, k, NULL, NULL, ctx) == 0)\n            goto done;\n\n        if (EC_POINT_get_affine_coordinates_GFp(group, kG, x1, NULL, ctx) == 0)\n            goto done;\n\n        if (BN_mod_add(r, e, x1, order, ctx) == 0)\n            goto done;\n\n        \/* try again if r == 0 or r+k == n *\/\n        if (BN_is_zero(r))\n            continue;\n\n        BN_add(rk, r, k);\n\n        if (BN_cmp(rk, order) == 0)\n            continue;\n\n        BN_add(s, dA, BN_value_one());\n        BN_mod_inverse(s, s, order, ctx);\n\n        BN_mod_mul(tmp, dA, r, order, ctx);\n        BN_sub(tmp, k, tmp);\n\n        BN_mod_mul(s, s, tmp, order, ctx);\n\n        sig = ECDSA_SIG_new();\n\n        if (sig == NULL)\n            goto done;\n\n         \/* takes ownership of r and s *\/\n        ECDSA_SIG_set0(sig, r, s);\n        break;\n    }\n\n done:\n\n    if (sig == NULL) {\n        BN_free(r);\n        BN_free(s);\n    }\n\n    BN_CTX_free(ctx);\n    EC_POINT_free(kG);\n    return sig;\n\n}","idx":394008,"target":1}
{"code":"static inline void init_get_bits(GetBitContext *s, const uint8_t *buffer,\n                                 int bit_size)\n{\n    int buffer_size = (bit_size+7)>>3;\n    if (buffer_size < 0 || bit_size < 0) {\n        buffer_size = bit_size = 0;\n        buffer = NULL;\n    }\n\n    s->buffer       = buffer;\n    s->size_in_bits = bit_size;\n#if !UNCHECKED_BITSTREAM_READER\n    s->size_in_bits_plus8 = bit_size + 8;\n#endif\n    s->buffer_end   = buffer + buffer_size;\n    s->index        = 0;\n}","idx":633355,"target":1}
{"code":"static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)\n\n{\n\n    uint16_t data = addr;\n\n\n\n    memwrite(s->addr + OMAP_I2C_SA, &data, 2);\n\n    memread(s->addr + OMAP_I2C_SA, &data, 2);\n\n    g_assert_cmphex(data, ==, addr);\n\n}\n","idx":14943,"target":1}
{"code":"static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width\/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) \/* marker *\/\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        \/* start new mpeg1 context decoding *\/\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            \/* at least give a valid frame rate (some old mpeg1 have this) *\/\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); \/* vbv_buffer_size *\/\n\n    skip_bits(&s->gb, 1);\n\n\n\n    \/* get matrix *\/\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    \/* we set mpeg2 parameters so that it emulates mpeg1 *\/\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; \/* indicates mpeg1 *\/\n\n    return 0;\n\n}\n","idx":60,"target":0}
{"code":"static int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           int max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned int i;\n\n    if (max-- < 1)\n        return (0);\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (max < (int)i)\n                return 0;\n            \/* Skip leading zeroes *\/\n            while (i && *p == 0) {\n                p++;\n                i--;\n            }\n            if (i > sizeof(long))\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return (1);\n}","idx":392777,"target":1}
{"code":"static av_cold int ulti_decode_init(AVCodecContext *avctx)\n\n{\n\n    UltimotionDecodeContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n    s->blocks = (s->width \/ 8) * (s->height \/ 8);\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n\n    s->ulti_codebook = ulti_codebook;\n\n\n\n    s->frame = av_frame_alloc();\n\n    if (!s->frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    return 0;\n\n}","idx":18716,"target":1}
{"code":"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n","idx":51,"target":0}
{"code":"static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}\n","idx":2,"target":0}
{"code":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \/* let's disallow possibly ambiguous cases *\/\n    if (size > (INT_MAX - 16))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \/\/FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    return (char *)realloc((char *)ptr - diff, size + diff) + diff;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size, 32);\n#else\n    return realloc(ptr, size);\n#endif\n}","idx":635446,"target":1}
{"code":"static int init_tile(Jpeg2000DecoderContext *s, int tileno)\n{\n    int compno;\n    int tilex = tileno % s->numXtiles;\n    int tiley = tileno \/ s->numXtiles;\n    Jpeg2000Tile *tile = s->tile + tileno;\n\n    if (!tile->comp)\n        return AVERROR(ENOMEM);\n\n    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;\n        int ret; \/\/ global bandno\n\n        comp->coord_o[0][0] = tile->coord[0][0];\n        comp->coord_o[0][1] = tile->coord[0][1];\n        comp->coord_o[1][0] = tile->coord[1][0];\n        comp->coord_o[1][1] = tile->coord[1][1];\n        if (compno) {\n            comp->coord_o[0][0] \/= s->cdx[compno];\n            comp->coord_o[0][1] \/= s->cdx[compno];\n            comp->coord_o[1][0] \/= s->cdy[compno];\n            comp->coord_o[1][1] \/= s->cdy[compno];\n        }\n\n        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);\n        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);\n        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);\n        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);\n\n        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,\n                                             s->cbps[compno], s->cdx[compno],\n                                             s->cdy[compno], s->avctx))\n            return ret;\n    }\n    return 0;\n}","idx":1295382,"target":1}
{"code":"static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int stride, int n){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    switch(w->abt_type_table[n]){\n\n    case 0:\n\n        if (s->block_last_index[n] >= 0) {\n\n            s->dsp.idct_add (dst, stride, block1);\n\n        }\n\n        break;\n\n    case 1:\n\n        simple_idct84_add(dst           , stride, block1);\n\n        simple_idct84_add(dst + 4*stride, stride, w->abt_block2[n]);\n\n        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n\n        break;\n\n    case 2:\n\n        simple_idct48_add(dst           , stride, block1);\n\n        simple_idct48_add(dst + 4       , stride, w->abt_block2[n]);\n\n        memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n\n        break;\n\n    default:\n\n        av_log(s->avctx, AV_LOG_ERROR, \"internal error in WMV2 abt\\n\");\n\n    }\n\n}\n","idx":11866,"target":1}
{"code":"static void xvid_idct_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n\n{\n\n    ff_xvid_idct(block);\n\n    ff_put_pixels_clamped(block, dest, line_size);\n\n}\n","idx":22532,"target":1}
{"code":"void aio_context_setup(AioContext *ctx)\n\n{\n\n}\n","idx":57,"target":0}
{"code":"void PEM_dek_info(char *buf, const char *type, int len, char *str)\n\t{\n\tstatic const unsigned char map[17]=\"0123456789ABCDEF\";\n\tlong i;\n\tint j;\n\n\tstrcat(buf,\"DEK-Info: \");\n\tstrcat(buf,type);\n\tstrcat(buf,\",\");\n\tj=strlen(buf);\n\tfor (i=0; i<len; i++)\n\t\t{\n\t\tbuf[j+i*2]  =map[(str[i]>>4)&0x0f];\n\t\tbuf[j+i*2+1]=map[(str[i]   )&0x0f];\n\t\t}\n\tbuf[j+i*2]='\\n';\n\tbuf[j+i*2+1]='\\0';\n\t}","idx":387288,"target":1}
{"code":"AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n\n    \/* http:\/\/issues.apache.org\/bugzilla\/show_bug.cgi?id=31875\n     * http:\/\/issues.apache.org\/bugzilla\/show_bug.cgi?id=28450\n     *\n     * This is not in fact a URI, it's a path.  That matters in the\n     * case of a leading double-slash.  We need to resolve the issue\n     * by normalising that out before treating it as a URI.\n     *\/\n    while ((uri[0] == '\/') && (uri[1] == '\/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        \/* Simple syntax Errors in URLs are trapped by\n         * parse_uri_components().\n         *\/\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n\n    if (status == APR_SUCCESS) {\n        \/* if it has a scheme we may need to do absoluteURI vhost stuff *\/\n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"\/\");\n\n#if defined(OS2) || defined(WIN32)\n        \/* Handle path translations for OS\/2 and plug security hole.\n         * This will prevent \"http:\/\/www.wherever.com\/..\\..\\\/\" from\n         * returning a directory for the root drive.\n         *\/\n        {\n            char *x;\n\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '\/';\n        }\n#endif \/* OS2 || WIN32 *\/\n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \/* set error status *\/\n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}","idx":0,"target":0}
{"code":"static void decode_plane(FFV1Context *s, uint8_t *src,\n\n                         int w, int h, int stride, int plane_index,\n\n                         int pixel_stride)\n\n{\n\n    int x, y;\n\n    int16_t *sample[2];\n\n    sample[0] = s->sample_buffer + 3;\n\n    sample[1] = s->sample_buffer + w + 6 + 3;\n\n\n\n    s->run_index = 0;\n\n\n\n    memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));\n\n\n\n    for (y = 0; y < h; y++) {\n\n        int16_t *temp = sample[0]; \/\/ FIXME: try a normal buffer\n\n\n\n        sample[0] = sample[1];\n\n        sample[1] = temp;\n\n\n\n        sample[1][-1] = sample[0][0];\n\n        sample[0][w]  = sample[0][w - 1];\n\n\n\n\/\/ { START_TIMER\n\n        if (s->avctx->bits_per_raw_sample <= 8) {\n\n            decode_line(s, w, sample, plane_index, 8);\n\n            for (x = 0; x < w; x++)\n\n                src[x*pixel_stride + stride * y] = sample[1][x];\n\n        } else {\n\n            decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);\n\n            if (s->packed_at_lsb) {\n\n                for (x = 0; x < w; x++) {\n\n                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x];\n\n                }\n\n            } else {\n\n                for (x = 0; x < w; x++) {\n\n                    ((uint16_t*)(src + stride*y))[x*pixel_stride] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample) | ((uint16_t **)sample)[1][x] >> (2 * s->avctx->bits_per_raw_sample - 16);\n\n                }\n\n            }\n\n        }\n\n\/\/ STOP_TIMER(\"decode-line\") }\n\n    }\n\n}\n","idx":8200,"target":1}
{"code":"void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)\n\n{\n\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n\n\n\n    isa_mmio_setup(mr, size);\n\n    memory_region_add_subregion(get_system_memory(), base, mr);\n\n}\n","idx":45,"target":0}
{"code":"static void m68k_cpu_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    M68kCPU *cpu = M68K_CPU(dev);\n\n    M68kCPUClass *mcc = M68K_CPU_GET_CLASS(dev);\n\n\n\n    m68k_cpu_init_gdb(cpu);\n\n\n\n    cpu_reset(CPU(cpu));\n\n\n\n    mcc->parent_realize(dev, errp);\n\n}\n","idx":18694,"target":1}
{"code":"static int xan_huffman_decode(unsigned char *dest, int dest_len,\n\n                              const unsigned char *src, int src_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    int ptr_len = src_len - 1 - byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    if (ptr_len < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    init_get_bits(&gb, ptr, ptr_len * 8);\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest >= dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n","idx":5130,"target":1}
{"code":"int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  \/* We're dealing with plain vanilla WAVEFORMAT *\/\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  \/* We're obviously dealing with WAVEFORMATEX *\/\n\n        int cbSize = avio_rl16(pb); \/* cbSize *\/\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { \/* WAVEFORMATEXTENSIBLE *\/\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        \/* It is possible for the chunk to contain garbage at the end *\/\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        \/* Channels and sample_rate values are those prior to applying SBR\n\n         * and\/or PS. *\/\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    \/* override bits_per_coded_sample for G.726 *\/\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate \/ codec->sample_rate;\n\n\n\n    return 0;\n\n}\n","idx":3,"target":0}
{"code":"static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                                uint32_t token, uint32_t nargs,\n\n                                target_ulong args, uint32_t nret,\n\n                                target_ulong rets)\n\n{\n\n    uint32_t config_addr = rtas_ld(args, 0);\n\n    uint64_t buid = rtas_ldq(args, 1);\n\n    unsigned int func = rtas_ld(args, 3);\n\n    unsigned int req_num = rtas_ld(args, 4); \/* 0 == remove all *\/\n\n    unsigned int seq_num = rtas_ld(args, 5);\n\n    unsigned int ret_intr_type;\n\n    unsigned int irq, max_irqs = 0, num = 0;\n\n    sPAPRPHBState *phb = NULL;\n\n    PCIDevice *pdev = NULL;\n\n    spapr_pci_msi *msi;\n\n    int *config_addr_key;\n\n\n\n    switch (func) {\n\n    case RTAS_CHANGE_MSI_FN:\n\n    case RTAS_CHANGE_FN:\n\n        ret_intr_type = RTAS_TYPE_MSI;\n\n        break;\n\n    case RTAS_CHANGE_MSIX_FN:\n\n        ret_intr_type = RTAS_TYPE_MSIX;\n\n        break;\n\n    default:\n\n        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    \/* Fins sPAPRPHBState *\/\n\n    phb = spapr_pci_find_phb(spapr, buid);\n\n    if (phb) {\n\n        pdev = spapr_pci_find_dev(spapr, buid, config_addr);\n\n    }\n\n    if (!phb || !pdev) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    \/* Releasing MSIs *\/\n\n    if (!req_num) {\n\n        msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr);\n\n        if (!msi) {\n\n            trace_spapr_pci_msi(\"Releasing wrong config\", config_addr);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        xics_free(spapr->icp, msi->first_irq, msi->num);\n\n        if (msi_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, false, 0, num);\n\n        }\n\n        if (msix_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, true, 0, num);\n\n        }\n\n        g_hash_table_remove(phb->msi, &config_addr);\n\n\n\n        trace_spapr_pci_msi(\"Released MSIs\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        rtas_st(rets, 1, 0);\n\n        return;\n\n    }\n\n\n\n    \/* Enabling MSI *\/\n\n\n\n    \/* Check if the device supports as many IRQs as requested *\/\n\n    if (ret_intr_type == RTAS_TYPE_MSI) {\n\n        max_irqs = msi_nr_vectors_allocated(pdev);\n\n    } else if (ret_intr_type == RTAS_TYPE_MSIX) {\n\n        max_irqs = pdev->msix_entries_nr;\n\n    }\n\n    if (!max_irqs) {\n\n        error_report(\"Requested interrupt type %d is not enabled for device %x\",\n\n                     ret_intr_type, config_addr);\n\n        rtas_st(rets, 0, -1); \/* Hardware error *\/\n\n        return;\n\n    }\n\n    \/* Correct the number if the guest asked for too many *\/\n\n    if (req_num > max_irqs) {\n\n        trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);\n\n        req_num = max_irqs;\n\n        irq = 0; \/* to avoid misleading trace *\/\n\n        goto out;\n\n    }\n\n\n\n    \/* Allocate MSIs *\/\n\n    irq = xics_alloc_block(spapr->icp, 0, req_num, false,\n\n                           ret_intr_type == RTAS_TYPE_MSI);\n\n    if (!irq) {\n\n        error_report(\"Cannot allocate MSIs for device %x\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    \/* Setup MSI\/MSIX vectors in the device (via cfgspace or MSIX BAR) *\/\n\n    spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX,\n\n                     irq, req_num);\n\n\n\n    \/* Add MSI device to cache *\/\n\n    msi = g_new(spapr_pci_msi, 1);\n\n    msi->first_irq = irq;\n\n    msi->num = req_num;\n\n    config_addr_key = g_new(int, 1);\n\n    *config_addr_key = config_addr;\n\n    g_hash_table_insert(phb->msi, config_addr_key, msi);\n\n\n\nout:\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, req_num);\n\n    rtas_st(rets, 2, ++seq_num);\n\n    if (nret > 3) {\n\n        rtas_st(rets, 3, ret_intr_type);\n\n    }\n\n\n\n    trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq);\n\n}\n","idx":62,"target":0}
{"code":"static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, uint16_t **refcount_table,\n\n                               int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    *refcount_table = g_try_new0(uint16_t, *nb_clusters);\n\n    if (*nb_clusters && *refcount_table == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    \/* header *\/\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* current L1 table *\/\n\n    ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* snapshots *\/\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    \/* refcount data *\/\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n\n}\n","idx":56,"target":0}
{"code":"static gboolean register_signal_handlers(void)\n\n{\n\n    struct sigaction sigact, sigact_chld;\n\n    int ret;\n\n\n\n    memset(&sigact, 0, sizeof(struct sigaction));\n\n    sigact.sa_handler = quit_handler;\n\n\n\n    ret = sigaction(SIGINT, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n    ret = sigaction(SIGTERM, &sigact, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n        return false;\n\n    }\n\n\n\n    memset(&sigact_chld, 0, sizeof(struct sigaction));\n\n    sigact_chld.sa_handler = child_handler;\n\n    sigact_chld.sa_flags = SA_NOCLDSTOP;\n\n    ret = sigaction(SIGCHLD, &sigact_chld, NULL);\n\n    if (ret == -1) {\n\n        g_error(\"error configuring signal handler: %s\", strerror(errno));\n\n    }\n\n\n\n    return true;\n\n}\n","idx":4015,"target":1}
{"code":"static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)\n\n{\n\n    AVIOContext *in, *out;\n\n    int ret = 0;\n\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n\n        avio_close(in);\n\n        return ret;\n\n    }\n\n    while (size > 0) {\n\n        uint8_t buf[8192];\n\n        int n = FFMIN(size, sizeof(buf));\n\n        n = avio_read(in, buf, n);\n\n        if (n <= 0) {\n\n            ret = AVERROR(EIO);\n\n            break;\n\n        }\n\n        avio_write(out, buf, n);\n\n        size -= n;\n\n    }\n\n    avio_flush(out);\n\n    avio_close(out);\n\n    avio_close(in);\n\n    return ret;\n\n}\n","idx":49,"target":0}
{"code":"static void test_validate_struct_nested(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n\n                           \"'dict1': { 'string1': 'string1', \"\n\n                           \"'dict2': { 'userdef': { 'integer': 42, \"\n\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n","idx":47,"target":0}
{"code":"int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type,\n                            uint8_t *data, size_t size)\n{\n    AVPacketSideData *sd, *tmp;\n    int i;\n\n    for (i = 0; i < st->nb_side_data; i++) {\n        sd = &st->side_data[i];\n\n        if (sd->type == type) {\n            av_freep(&sd->data);\n            sd->data = data;\n            sd->size = size;\n            return 0;\n        }\n    }\n\n    tmp = av_realloc_array(st->side_data, st->nb_side_data + 1, sizeof(*tmp));\n    if (!tmp) {\n        return AVERROR(ENOMEM);\n    }\n\n    st->side_data = tmp;\n    st->nb_side_data++;\n\n    sd = &st->side_data[st->nb_side_data - 1];\n    sd->type = type;\n    sd->data = data;\n    sd->size = size;\n\n    return 0;\n}","idx":1291528,"target":1}
{"code":"MigrationState *tcp_start_outgoing_migration(Monitor *mon,\n\n                                             const char *host_port,\n\n                                             int64_t bandwidth_limit,\n\n                                             int detach,\n\n\t\t\t\t\t     int blk,\n\n\t\t\t\t\t     int inc)\n\n{\n\n    struct sockaddr_in addr;\n\n    FdMigrationState *s;\n\n    int ret;\n\n\n\n    if (parse_host_port(&addr, host_port) < 0)\n\n        return NULL;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n\n\n    s->get_error = socket_errno;\n\n    s->write = socket_write;\n\n    s->close = tcp_close;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->mig_state.blk = blk;\n\n    s->mig_state.shared = inc;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->mon = NULL;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n    s->fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (s->fd == -1) {\n\n        qemu_free(s);\n\n        return NULL;\n\n    }\n\n\n\n    socket_set_nonblock(s->fd);\n\n\n\n    if (!detach) {\n\n        migrate_fd_monitor_suspend(s, mon);\n\n    }\n\n\n\n    do {\n\n        ret = connect(s->fd, (struct sockaddr *)&addr, sizeof(addr));\n\n        if (ret == -1)\n\n            ret = -(s->get_error(s));\n\n\n\n        if (ret == -EINPROGRESS || ret == -EWOULDBLOCK)\n\n            qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);\n\n    } while (ret == -EINTR);\n\n\n\n    if (ret < 0 && ret != -EINPROGRESS && ret != -EWOULDBLOCK) {\n\n        dprintf(\"connect failed\\n\");\n\n        close(s->fd);\n\n        qemu_free(s);\n\n        return NULL;\n\n    } else if (ret >= 0)\n\n        migrate_fd_connect(s);\n\n\n\n    return &s->mig_state;\n\n}\n","idx":13607,"target":1}
{"code":"print_syscall_ret(int num, abi_long ret)\n\n{\n\n    int i;\n\n\n\n    for(i=0;i<nsyscalls;i++)\n\n        if( scnames[i].nr == num ) {\n\n            if( scnames[i].result != NULL ) {\n\n                scnames[i].result(&scnames[i],ret);\n\n            } else {\n\n                if( ret < 0 ) {\n\n                    gemu_log(\" = -1 errno=\" TARGET_ABI_FMT_ld \" (%s)\\n\", -ret, target_strerror(-ret));\n\n                } else {\n\n                    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n                }\n\n            }\n\n            break;\n\n        }\n\n}\n","idx":10957,"target":1}
{"code":"static int parse_picture_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n\n\n    if (buf_size <= 4)\n\n        return -1;\n\n    buf_size -= 4;\n\n\n\n    \/* skip 3 unknown bytes: Object ID (2 bytes), Version Number *\/\n\n    buf += 3;\n\n\n\n    \/* Read the Sequence Description to determine if start of RLE data or appended to previous RLE *\/\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        \/* Additional RLE data *\/\n\n        if (buf_size > ctx->picture.rle_remaining_len)\n\n            return -1;\n\n\n\n        memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);\n\n        ctx->picture.rle_data_len += buf_size;\n\n        ctx->picture.rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return -1;\n\n    buf_size -= 7;\n\n\n\n    \/* Decode rle bitmap length, stored size includes width\/height data *\/\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    \/* Get bitmap dimensions from data *\/\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    \/* Make sure the bitmap is not too large *\/\n\n    if (avctx->width < width || avctx->height < height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->picture.w = width;\n\n    ctx->picture.h = height;\n\n\n\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!ctx->picture.rle)\n\n        return -1;\n\n\n\n    memcpy(ctx->picture.rle, buf, buf_size);\n\n    ctx->picture.rle_data_len = buf_size;\n\n    ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n","idx":40,"target":0}
{"code":"static av_cold int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n","idx":31,"target":0}
{"code":"static void encode_gray_bitstream(HYuvContext *s, int count){\n\n    int i;\n\n    \n\n    count\/=2;\n\n    if(s->flags&CODEC_FLAG_PASS1){\n\n        for(i=0; i<count; i++){\n\n            s->stats[0][ s->temp[0][2*i  ] ]++;\n\n            s->stats[0][ s->temp[0][2*i+1] ]++;\n\n        }\n\n    }else if(s->context){\n\n        for(i=0; i<count; i++){\n\n            s->stats[0][ s->temp[0][2*i  ] ]++;\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);\n\n            s->stats[0][ s->temp[0][2*i+1] ]++;\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);\n\n        }\n\n    }else{\n\n        for(i=0; i<count; i++){\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);\n\n            put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);\n\n        }\n\n    }\n\n}\n","idx":27219,"target":1}
{"code":"void ppc40x_chip_reset (CPUState *env)\n\n{\n\n    target_ulong dbsr;\n\n\n\n    printf(\"Reset PowerPC chip\\n\");\n\n    cpu_ppc_reset(env);\n\n    \/* XXX: TODO reset all internal peripherals *\/\n\n    dbsr = env->spr[SPR_40x_DBSR];\n\n    dbsr &= ~0x00000300;\n\n    dbsr |= 0x00000200;\n\n    env->spr[SPR_40x_DBSR] = dbsr;\n\n    cpu_loop_exit();\n\n}\n","idx":12057,"target":1}
{"code":"AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int length)\n{\n    const char *hex = \"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;\n    unsigned char hash[APR_MD5_DIGESTSIZE];\n    char *r, result[33]; \/* (MD5_DIGESTSIZE * 2) + 1 *\/\n    int i;\n\n    \/*\n     * Take the MD5 hash of the string argument.\n     *\/\n\n    apr_md5_init(&my_md5);\n#if APR_CHARSET_EBCDIC\n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);\n#endif\n    apr_md5_update(&my_md5, buf, (unsigned int)length);\n    apr_md5_final(hash, &my_md5);\n\n    for (i = 0, r = result; i < APR_MD5_DIGESTSIZE; i++) {\n        *r++ = hex[hash[i] >> 4];\n        *r++ = hex[hash[i] & 0xF];\n    }\n    *r = '\\0';\n\n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);\n}","idx":3,"target":0}
{"code":"","idx":2,"target":0}
{"code":"static void usb_hid_changed(HIDState *hs)\n\n{\n\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n\n\n\n    us->changed = 1;\n\n\n\n    if (us->datain) {\n\n        us->datain(us->datain_opaque);\n\n    }\n\n\n\n    usb_wakeup(&us->dev);\n\n}\n","idx":54,"target":0}
{"code":"","idx":5,"target":0}
{"code":"static void init_excp_620 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;\n\n    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;\n\n    \/* Hardware reset vector *\/\n\n    env->hreset_vector = 0x0000000000000100ULL; \/* ? *\/\n\n#endif\n\n}\n","idx":3547,"target":1}
{"code":"void helper_divl_EAX_T0(void)\n\n{\n\n    unsigned int den, q, r;\n\n    uint64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = div32(&q, num, den);\n\n#else\n\n    q = (num \/ den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n","idx":13902,"target":1}
{"code":"void CRYPTO_destroy_dynlockid(int i)\n\t{\n\tCRYPTO_dynlock *pointer = NULL;\n\tif (i)\n\t\ti = -i-1;\n\tif (dynlock_destroy_callback == NULL)\n\t\treturn;\n\n\tCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))\n\t\treturn;\n\tpointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\n\tif (pointer != NULL)\n\t\t{\n\t\t--pointer->references;\n#ifdef REF_CHECK\n\t\tif (pointer->references < 0)\n\t\t\t{\n\t\t\tfprintf(stderr,\"CRYPTO_destroy_dynlockid, bad reference count\\n\");\n\t\t\tabort();\n\t\t\t}\n\t\telse\n#endif\n\t\t\tif (pointer->references <= 0)\n\t\t\t\t{\n\t\t\t\tsk_CRYPTO_dynlock_set(dyn_locks, i, NULL);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tpointer = NULL;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (pointer)\n\t\t{\n\t\tdynlock_destroy_callback(pointer->data,__FILE__,__LINE__);\n\t\tOPENSSL_free(pointer);\n\t\t}\n\t}","idx":391838,"target":1}
{"code":"void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIRequest *sreq = req->sreq;\n\n    if (scsi_req_enqueue(sreq)) {\n\n        scsi_req_continue(sreq);\n\n    }\n\n    bdrv_io_unplug(sreq->dev->conf.bs);\n\n    scsi_req_unref(sreq);\n\n}\n","idx":59,"target":0}
{"code":"static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; \/* clear head *\/\n\n    \/* put signature *\/\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n","idx":44,"target":0}
{"code":"void hmp_block_set_io_throttle(Monitor *mon, const QDict *qdict)\n\n{\n\n    Error *err = NULL;\n\n\n\n    qmp_block_set_io_throttle(qdict_get_str(qdict, \"device\"),\n\n                              qdict_get_int(qdict, \"bps\"),\n\n                              qdict_get_int(qdict, \"bps_rd\"),\n\n                              qdict_get_int(qdict, \"bps_wr\"),\n\n                              qdict_get_int(qdict, \"iops\"),\n\n                              qdict_get_int(qdict, \"iops_rd\"),\n\n                              qdict_get_int(qdict, \"iops_wr\"), &err);\n\n    hmp_handle_error(mon, &err);\n\n}\n","idx":5533,"target":1}
{"code":"BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n        {\n\tBN_ULONG t1,t2;\n\tint c=0;\n\n\tassert(n >= 0);\n\tif (n <= 0) return((BN_ULONG)0);\n\n\tfor (;;)\n\t\t{\n\t\tt1=a[0]; t2=b[0];\n\t\tr[0]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[1]; t2=b[1];\n\t\tr[1]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[2]; t2=b[2];\n\t\tr[2]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\tt1=a[3]; t2=b[3];\n\t\tr[3]=(t1-t2-c)&BN_MASK2;\n\t\tif (t1 != t2) c=(t1 < t2);\n\t\tif (--n <= 0) break;\n\n\t\ta+=4;\n\t\tb+=4;\n\t\tr+=4;\n\t\t}\n\treturn(c);\n\t}","idx":392600,"target":1}
{"code":"AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int length)\n{\n    const char *hex = \"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;\n    unsigned char hash[APR_MD5_DIGESTSIZE];\n    char *r, result[33]; \/* (MD5_DIGESTSIZE * 2) + 1 *\/\n    int i;\n\n    \/*\n     * Take the MD5 hash of the string argument.\n     *\/\n\n    apr_md5_init(&my_md5);\n#if APR_CHARSET_EBCDIC\n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);\n#endif\n    apr_md5_update(&my_md5, buf, (unsigned int)length);\n    apr_md5_final(hash, &my_md5);\n\n    for (i = 0, r = result; i < APR_MD5_DIGESTSIZE; i++) {\n        *r++ = hex[hash[i] >> 4];\n        *r++ = hex[hash[i] & 0xF];\n    }\n    *r = '\\0';\n\n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2);\n}","idx":4,"target":0}
