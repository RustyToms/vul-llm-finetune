{"code":"static void test_validate_struct_nested(TestInputVisitorData*data, const void*unused){\n    UserDefTwo*udp=NULL;\n    Visitor*v;\n    v=validate_test_init(data, \"{ 'string0': 'string0', \"\n                           \"'dict1':{'string1': 'string1', \"\n                           \"'dict2':{'userdef':{'integer': 42, \"\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n    if (udp != NULL) {\n        qapi_free_UserDefTwo(udp);\n    }\n}","idx":"b3db211f3c80bb996a704d665fe275619f728bd4","target":0}
{"code":"void ppc40x_chip_reset(CPUState*env){target_ulong dbsr;printf(\"Reset PowerPC chip\\n\");cpu_ppc_reset(env);dbsr=env->spr[SPR_40x_DBSR];dbsr&=~0x00000300;dbsr|=0x00000200;env->spr[SPR_40x_DBSR]=dbsr;cpu_loop_exit();}","idx":"ef397e88e96d4a798bd190bcd0c43865c3725ae2","target":1}
{"code":"static void decode_plane(FFV1Context*s, uint8_t*src, int w, int h, int stride, int plane_index, int pixel_stride){int x, y;int16_t*sample[2];sample[0]=s->sample_buffer+3;sample[1]=s->sample_buffer+w+6+3;s->run_index=0;memset(s->sample_buffer, 0, 2*(w+6)*sizeof(*s->sample_buffer));for(y=0;y<h;y++){int16_t*temp=sample[0];sample[0]=sample[1];sample[1]=temp;sample[1][-1]=sample[0][0];sample[0][w]=sample[0][w-1];if(s->avctx->bits_per_raw_sample <= 8){decode_line(s, w, sample, plane_index, 8);for(x=0;x<w;x++)src[x*pixel_stride+stride*y]=sample[1][x];}else{decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);if(s->packed_at_lsb){for(x=0;x<w;x++){((uint16_t*)(src+stride*y))[x*pixel_stride]=sample[1][x];}}else{for(x=0;x<w;x++){((uint16_t*)(src+stride*y))[x*pixel_stride]=sample[1][x]<<(16-s->avctx->bits_per_raw_sample)|((uint16_t**)sample)[1][x]>>(2*s->avctx->bits_per_raw_sample-16);}}}}}","idx":"b9f92093a10217b14d923220aaa186f41a0cf555","target":1}
{"code":"void gd_egl_scanout(DisplayChangeListener*dcl, uint32_t backing_id, bool backing_y_0_top, uint32_t x, uint32_t y, uint32_t w, uint32_t h){VirtualConsole*vc=container_of(dcl, VirtualConsole, gfx.dcl);vc->gfx.x=x;vc->gfx.y=y;vc->gfx.w=w;vc->gfx.h=h;vc->gfx.tex_id=backing_id;vc->gfx.y0_top=backing_y_0_top;eglMakeCurrent(qemu_egl_display, vc->gfx.esurface, vc->gfx.esurface, vc->gfx.ectx);if(vc->gfx.tex_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0){gtk_egl_set_scanout_mode(vc, false);return;}gtk_egl_set_scanout_mode(vc, true);if(!vc->gfx.fbo_id){glGenFramebuffers(1, &vc->gfx.fbo_id);}glBindFramebuffer(GL_FRAMEBUFFER_EXT, vc->gfx.fbo_id);glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, vc->gfx.tex_id, 0);}","idx":"9d8256ebc0ef88fb1f35d0405893962d20cc10ad","target":1}
{"code":"int av_stream_add_side_data(AVStream*st, enum AVPacketSideDataType type, uint8_t*data, size_t size){AVPacketSideData*sd, *tmp;int i;for(i=0;i<st->nb_side_data;i++){sd=&st->side_data[i];if(sd->type == type){av_freep(&sd->data);sd->data=data;sd->size=size;return 0;}}tmp=av_realloc_array(st->side_data, st->nb_side_data+1, sizeof(*tmp));if(!tmp){return AVERROR(ENOMEM);}st->side_data=tmp;st->nb_side_data++;sd=&st->side_data[st->nb_side_data-1];sd->type=type;sd->data=data;sd->size=size;return 0;}","idx":"ffmpeg_c6ce2eacaecd9191100b06531cbdb284e64c4b15_1","target":1}
{"code":"static int init_tile(Jpeg2000DecoderContext*s, int tileno){int compno;int tilex=tileno%s->numXtiles;int tiley=tileno\/s->numXtiles;Jpeg2000Tile*tile=s->tile+tileno;if(!tile->comp)return AVERROR(ENOMEM);tile->coord[0][0]=av_clip(tilex*s->tile_width+s->tile_offset_x, s->image_offset_x, s->width);tile->coord[0][1]=av_clip((tilex+1)*s->tile_width+s->tile_offset_x, s->image_offset_x, s->width);tile->coord[1][0]=av_clip(tiley*s->tile_height+s->tile_offset_y, s->image_offset_y, s->height);tile->coord[1][1]=av_clip((tiley+1)*s->tile_height+s->tile_offset_y, s->image_offset_y, s->height);for(compno=0;compno<s->ncomponents;compno++){Jpeg2000Component*comp=tile->comp+compno;Jpeg2000CodingStyle*codsty=tile->codsty+compno;Jpeg2000QuantStyle*qntsty=tile->qntsty+compno;int ret;comp->coord_o[0][0]=tile->coord[0][0];comp->coord_o[0][1]=tile->coord[0][1];comp->coord_o[1][0]=tile->coord[1][0];comp->coord_o[1][1]=tile->coord[1][1];if(compno){comp->coord_o[0][0]\/=s->cdx[compno];comp->coord_o[0][1]\/=s->cdx[compno];comp->coord_o[1][0]\/=s->cdy[compno];comp->coord_o[1][1]\/=s->cdy[compno];}comp->coord[0][0]=ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);comp->coord[0][1]=ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);comp->coord[1][0]=ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);comp->coord[1][1]=ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);if(ret=ff_jpeg2000_init_component(comp, codsty, qntsty, s->cbps[compno], s->cdx[compno], s->cdy[compno], s->avctx))return ret;}return 0;}","idx":"ffmpeg_ba5684c37391efe9efb91df7a23fcf81e4576a92_1","target":1}
{"code":"void acpi_memory_plug_cb(HotplugHandler* hotplug_dev, MemHotplugState* mem_st, DeviceState* dev, Error** errp) {\n    if (!hotplug_dev || !mem_st || !dev) return;\n    MemStatus* mdev;\n    DeviceClass* dc = DEVICE_GET_CLASS(dev);\n    if (!dc->hotpluggable) {\n        return;\n    }\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n    if (!mdev) {\n        return;\n    }\n    mdev->dimm = dev;\n    mdev->is_enabled = true;\n    if (dev->hotplugged) {\n        mdev->is_inserting = true;\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n    }\n}","idx":"b097cc52fc9126bd1a71dae8302b8536d28104dd","target":0}
{"code":"static void wmv2_add_block(Wmv2Context*w, DCTELEM*block1, uint8_t*dst, int stride, int n){MpegEncContext*const s=&w->s;switch(w->abt_type_table[n]){case 0:\n        if(s->block_last_index[n] >= 0){s->dsp.idct_add(dst, stride, block1);}break;case 1:\n        simple_idct84_add(dst, stride, block1);simple_idct84_add(dst+4*stride, stride, w->abt_block2[n]);memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));break;case 2:\n        simple_idct48_add(dst, stride, block1);simple_idct48_add(dst+4, stride, w->abt_block2[n]);memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));break;default:\n        av_log(s->avctx, AV_LOG_ERROR, \"internal error in WMV2 abt\\n\");}}","idx":"1c02a9732aa2e5ec0eaf83e65044704af05e8400","target":1}
{"code":"void v9fs_device_unrealize_common(V9fsState *s, Error **errp) {\n    if (s != NULL) {\n        g_free(s->ctx.fs_root);\n        g_free(s->tag);\n    }\n}","idx":"4774718e5c194026ba5ee7a28d9be49be3080e42","target":0}
{"code":"av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq) {\n    if (!avctx || !afq) return;\n    afq->avctx = avctx;\n    afq->next_pts = AV_NOPTS_VALUE;\n    afq->remaining_delay = avctx->delay;\n    afq->remaining_samples = avctx->delay;\n    afq->frame_queue = NULL;\n}","idx":"2df0c32ea12ddfa72ba88309812bfb13b674130f","target":0}
{"code":"static av_cold int ulti_decode_init(AVCodecContext*avctx){UltimotionDecodeContext*s=avctx->priv_data;s->avctx=avctx;s->width=avctx->width;s->height=avctx->height;s->blocks=(s->width\/8)*(s->height\/8);avctx->pix_fmt=AV_PIX_FMT_YUV410P;s->ulti_codebook=ulti_codebook;s->frame=av_frame_alloc();if(!s->frame)return AVERROR(ENOMEM);return 0;}","idx":"725353525e73bbe5b6b4d01528252675f2417a02","target":1}
{"code":"int qxl_render_cursor(PCIQXLDevice*qxl, QXLCommandExt*ext){\n    QXLCursorCmd*cmd=qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n    QXLCursor*cursor;\n    QEMUCursor*c;\n    if(!cmd){return 1;}\n    if(!dpy_cursor_define_supported(qxl->vga.con)){return 0;}\n    if(qxl->debug>1 && cmd->type != QXL_CURSOR_MOVE){\n        fprintf(stderr, \"%s\", __FUNCTION__);\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n        fprintf(stderr, \"\\n\");\n    }\n    switch(cmd->type){\n    case QXL_CURSOR_SET:\n        cursor=qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n        if(!cursor){return 1;}\n        c=qxl_cursor(qxl, cursor, ext->group_id);\n        if(c == NULL){c=cursor_builtin_left_ptr();}\n        qemu_mutex_lock(&qxl->ssd.lock);\n        if(qxl->ssd.cursor){cursor_put(qxl->ssd.cursor);}\n        qxl->ssd.cursor=c;\n        qxl->ssd.mouse_x=cmd->u.set.position.x;\n        qxl->ssd.mouse_y=cmd->u.set.position.y;\n        qemu_mutex_unlock(&qxl->ssd.lock);\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n        break;\n    case QXL_CURSOR_MOVE:\n        qemu_mutex_lock(&qxl->ssd.lock);\n        qxl->ssd.mouse_x=cmd->u.position.x;\n        qxl->ssd.mouse_y=cmd->u.position.y;\n        qemu_mutex_unlock(&qxl->ssd.lock);\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n        break;\n    default:\n        return 1;\n    }\n    return 0;\n}","idx":"a89f364ae8740dfc31b321eed9ee454e996dc3c1","target":0}
{"code":"static void perf_lifecycle(void){Coroutine*coroutine;unsigned int i, max;double duration;max=1000000;g_test_timer_start();for(i=0;i<max;i++){coroutine=qemu_coroutine_create(empty_coroutine);qemu_coroutine_enter(coroutine, NULL);}duration=g_test_timer_elapsed();g_test_message(\"Lifecycle%u iterations:%f s\\n\", max, duration);}","idx":"0b8b8753e4d94901627b3e86431230f2319215c4","target":1}
{"code":"static inline bool vhost_needs_vring_endian(VirtIODevice *vdev) {\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n        return false;\n    }\n#ifdef TARGET_IS_BIENDIAN \n#ifdef HOST_WORDS_BIGENDIAN \n    return !virtio_is_big_endian(vdev);\n#else \n    return virtio_is_big_endian(vdev);\n#endif \n#else \n    return false;\n#endif \n}","idx":"46f70ff148ae01e2dc96e64c393e295a0092555d","target":0}
{"code":"CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char*user, size_t userlen, const char*domain, size_t domlen, unsigned char*ntlmhash, unsigned char*ntlmv2hash){\n    if(userlen > (SIZE_MAX \/ 2 - 1) \/ 2 || domlen > (SIZE_MAX \/ 2 - 1) \/ 2) return CURLE_OUT_OF_MEMORY;\n    size_t identity_len = (userlen + domlen) * 2;\n    unsigned char* identity = malloc(identity_len);\n    CURLcode result = CURLE_OK;\n    if(!identity) return CURLE_OUT_OF_MEMORY;\n    ascii_uppercase_to_unicode_le(identity, user, userlen);\n    ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);\n    result = Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len), ntlmv2hash);\n    free(identity);\n    return result;\n}","idx":"curl-curl-7_56_1-0","target":0}
{"code":"void hmp_block_set_io_throttle(Monitor*mon, const QDict*qdict){Error*err=NULL;qmp_block_set_io_throttle(qdict_get_str(qdict, \"device\"), qdict_get_int(qdict, \"bps\"), qdict_get_int(qdict, \"bps_rd\"), qdict_get_int(qdict, \"bps_wr\"), qdict_get_int(qdict, \"iops\"), qdict_get_int(qdict, \"iops_rd\"), qdict_get_int(qdict, \"iops_wr\"), &err);hmp_handle_error(mon, &err);}","idx":"3e9fab690d59ac15956c3733fe0794ce1ae4c4af","target":1}
{"code":"static void omap_i2c_set_slave_addr(OMAPI2C*s, uint8_t addr){uint16_t data=addr;memwrite(s->addr+OMAP_I2C_SA, &data, 2);memread(s->addr+OMAP_I2C_SA, &data, 2);g_assert_cmphex(data, == , addr);}","idx":"d0bce760e04b1658a3b4ac95be2839ae20fd86db","target":1}
{"code":"static int announce_self_create(uint8_t*buf, uint8_t*mac_addr){uint32_t magic=EXPERIMENTAL_MAGIC;uint16_t proto=htons(ETH_P_EXPERIMENTAL);memset(buf, 0, 64);memset(buf, 0xff, 6);memcpy(buf+6, mac_addr, 6);memcpy(buf+12, &proto, 2);memcpy(buf+14, &magic, 4);return 64;}","idx":"18995b9808dc48897bda6ed93ce3e978191f7251","target":1}
{"code":"static void brigade_move(apr_bucket_brigade *b, apr_bucket_brigade *a, apr_bucket *e) {\n    apr_bucket *f;\n    if (e != APR_BRIGADE_SENTINEL(b) && APR_BUCKET_IS_IN_BRIGADE(e, b)) {\n        f = APR_RING_LAST(&b->list);\n        APR_RING_UNSPLICE(e, f, link);\n        APR_RING_SPLICE_HEAD(&a->list, e, f, apr_bucket, link);\n    }\n    APR_BRIGADE_CHECK_CONSISTENCY(a);\n    APR_BRIGADE_CHECK_CONSISTENCY(b);\n}","idx":"httpd_03cab3f0aaf1bdf28cfd53e8c550030d5fe3a3ba_0","target":0}
{"code":"String StringUtil::Implode(const Variant& items, const String& delim, const bool checkIsContainer) {\n    if (checkIsContainer && !isContainer(items)) {\n        throw_param_is_not_container();\n    }\n    int size = getContainerSize(items);\n    if (size == 0) return empty_string();\n    if (size > (INT_MAX \/ sizeof(String)))\n        throw std::overflow_error(\"Size is too large\");\n    String* sitems = (String*)req::malloc(size * sizeof(String));\n    if (!sitems) throw std::bad_alloc();\n    size_t len = 0;\n    int lenDelim = delim.size();\n    int i = 0;\n    for (ArrayIter iter(items); iter; ++iter) {\n        new(&sitems[i]) String(iter.second().toString());\n        len += sitems[i].size() + lenDelim;\n        i++;\n    }\n    len -= lenDelim;\n    assert(i == size);\n    String s = String(len, ReserveString);\n    char* buffer = s.mutableData();\n    const char* sdelim = delim.data();\n    char* p = buffer;\n    String& init_str = sitems[0];\n    int init_len = init_str.size();\n    memcpy(p, init_str.data(), init_len);\n    p += init_len;\n    sitems[0].~String();\n    for (int i = 1; i < size; i++) {\n        String& item = sitems[i];\n        memcpy(p, sdelim, lenDelim);\n        p += lenDelim;\n        int lenItem = item.size();\n        memcpy(p, item.data(), lenItem);\n        p += lenItem;\n        sitems[i].~String();\n    }\n    req::free(sitems);\n    assert(p - buffer == len);\n    s.setSize(len);\n    return s;\n}","idx":"hhvm-HHVM-3.12.10-1","target":0}
{"code":"static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size, VMStateField *field) {\n    uint64_t *v = pv;\n    *v = qemu_get_be32(f) & 0xFFFFFFFF;\n    *v |= ((uint64_t)0) << 32;\n    return 0;\n}","idx":"08b277ac46da8b02e50cec455eca7cb2d12ffcf0","target":0}
{"code":"static int parse_picture_segment(AVCodecContext*avctx, const uint8_t*buf, int buf_size){\n    PGSSubContext*ctx=avctx->priv_data;\n    uint8_t sequence_desc;\n    unsigned int rle_bitmap_len, width, height;\n    if(buf_size <= 4)\n        return-1;\n    buf_size-=4;\n    buf+=3;\n    sequence_desc=bytestream_get_byte(&buf);\n    if(!(sequence_desc&0x80)){\n        if(buf_size>ctx->picture.rle_remaining_len)\n            return-1;\n        memcpy(ctx->picture.rle+ctx->picture.rle_data_len, buf, buf_size);\n        ctx->picture.rle_data_len+=buf_size;\n        ctx->picture.rle_remaining_len-=buf_size;\n        return 0;\n    }\n    if(buf_size <= 7)\n        return-1;\n    buf_size-=7;\n    rle_bitmap_len=bytestream_get_be24(&buf)-2*2;\n    if(rle_bitmap_len > buf_size)\n        return -1;\n    width=bytestream_get_be16(&buf);\n    height=bytestream_get_be16(&buf);\n    if(avctx->width<width || avctx->height<height){\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n        return-1;\n    }\n    ctx->picture.w=width;\n    ctx->picture.h=height;\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n    if(!ctx->picture.rle)\n        return-1;\n    if(buf_size > rle_bitmap_len)\n        return -1;\n    memcpy(ctx->picture.rle, buf, buf_size);\n    ctx->picture.rle_data_len=buf_size;\n    ctx->picture.rle_remaining_len=rle_bitmap_len-buf_size;\n    return 0;\n}","idx":"d150a147dac67faeaf6b1f25a523ae330168ee1e","target":0}
{"code":"static int cirrus_bitblt_common_patterncopy(CirrusVGAState *s, const uint8_t *src) {\n    uint8_t *dst;\n    if (!src) return 0;\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n    if (blit_is_unsafe(s, false)) return 0;\n    (*s->cirrus_rop)(s, dst, src, s->cirrus_blt_dstpitch, 0, s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, s->cirrus_blt_dstpitch, s->cirrus_blt_width, s->cirrus_blt_height);\n    return 1;\n}","idx":"5858dd1801883309bdd208d72ddb81c4e9fee30c","target":0}
{"code":"void CRYPTO_destroy_dynlockid(int i){CRYPTO_dynlock*pointer=NULL;if(i)i=-i-1;if(dynlock_destroy_callback == NULL)return;CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);if(dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))return;pointer=sk_CRYPTO_dynlock_value(dyn_locks, i);if(pointer != NULL){--pointer->references;#ifdef REF_CHECK\n\t\tif(pointer->references<0){fprintf(stderr, \"CRYPTO_destroy_dynlockid, bad reference count\\n\");abort();}else\n#endif\n\t\t\tif(pointer->references <= 0){sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);}else\n\t\t\t\tpointer=NULL;}CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);if(pointer){dynlock_destroy_callback(pointer->data, __FILE__, __LINE__);OPENSSL_free(pointer);}}","idx":"openssl_acd5c2acdca78d43c360387f0ae6b9a76ca3a5db_1","target":1}
{"code":"static int biquad_init_coeffs(void*avc, struct FFIIRFilterCoeffs*c, enum IIRFilterMode filt_mode, int order, float cutoff_ratio, float stopband){double cos_w0, sin_w0;double a0, x0, x1;if(filt_mode != FF_FILTER_MODE_HIGHPASS && filt_mode != FF_FILTER_MODE_LOWPASS){av_log(avc, AV_LOG_ERROR, \"Biquad filter currently only supports \"\n               \"high-pass and low-pass filter modes\\n\");return-1;}if(order != 2){av_log(avc, AV_LOG_ERROR, \"Biquad filter must have order of 2\\n\");return-1;}cos_w0=cos(M_PI*cutoff_ratio);sin_w0=sin(M_PI*cutoff_ratio);a0=1.0+(sin_w0\/2.0);if(filt_mode == FF_FILTER_MODE_HIGHPASS){c->gain=((1.0+cos_w0)\/2.0)\/a0;x0=((1.0+cos_w0)\/2.0)\/a0;x1=(-(1.0+cos_w0))\/a0;}else{c->gain=((1.0-cos_w0)\/2.0)\/a0;x0=((1.0-cos_w0)\/2.0)\/a0;x1=(1.0-cos_w0)\/a0;}c->cy[0]=(-1.0+(sin_w0\/2.0))\/a0;c->cy[1]=(2.0*cos_w0)\/a0;c->cx[0]=lrintf(x0\/c->gain);c->cx[1]=lrintf(x1\/c->gain);return 0;}","idx":"libav_8d0b5ee0283ad22ab65429548b3d38dacc6552d0_1","target":1}
{"code":"BN_ULONG bn_sub_words(BN_ULONG*r, BN_ULONG*a, BN_ULONG*b, int n){BN_ULONG t1, t2;int c=0;assert(n >= 0);if(n <= 0)return((BN_ULONG)0);for(;;){t1=a[0];t2=b[0];r[0]=(t1-t2-c)&BN_MASK2;if(t1 != t2)c=(t1<t2);if(--n <= 0)break;t1=a[1];t2=b[1];r[1]=(t1-t2-c)&BN_MASK2;if(t1 != t2)c=(t1<t2);if(--n <= 0)break;t1=a[2];t2=b[2];r[2]=(t1-t2-c)&BN_MASK2;if(t1 != t2)c=(t1<t2);if(--n <= 0)break;t1=a[3];t2=b[3];r[3]=(t1-t2-c)&BN_MASK2;if(t1 != t2)c=(t1<t2);if(--n <= 0)break;a+=4;b+=4;r+=4;}return(c);}","idx":"openssl_b8a6868629e2e78bfd55feba6884ce0c43831fe1_1","target":1}
{"code":"static void listener_add_address_space(MemoryListener*listener, AddressSpace*as){\n    FlatView*view;\n    FlatRange*fr;\n    if (!listener || !as) return;\n    if(listener->address_space_filter && listener->address_space_filter != as){\n        return;\n    }\n    if(global_dirty_log){\n        if(listener->log_global_start){\n            listener->log_global_start(listener);\n        }\n    }\n    view=as->current_map;\n    if (!view) return;\n    FOR_EACH_FLAT_RANGE(fr, view){\n        MemoryRegionSection section={.mr=fr->mr, .address_space=as, .offset_within_region=fr->offset_in_region, .size=fr->addr.size, .offset_within_address_space=int128_get64(fr->addr.start), .readonly=fr->readonly, };\n        if(listener->region_add){\n            listener->region_add(listener, &section);\n        }\n    }\n}","idx":"856d72454f03aea26fd61c728762ef9cd1d71512","target":0}
{"code":"static int nbd_errno_to_system_errno(int err) {\n    switch (err) {\n    case NBD_SUCCESS:\n        return 0;\n    case NBD_EPERM:\n        return EPERM;\n    case NBD_EIO:\n        return EIO;\n    case NBD_ENOMEM:\n        return ENOMEM;\n    case NBD_ENOSPC:\n        return ENOSPC;\n    default:\n        TRACE(\"Squashing unexpected error%d to EINVAL\", err);\n        break;\n    case NBD_EINVAL:\n        return EINVAL;\n    }\n}","idx":"8b34a9dbc3f2c0afe3450cb20b94cc30f450e77b","target":0}
{"code":"static int ea_read_header(AVFormatContext*s, AVFormatParameters*ap){EaDemuxContext*ea=s->priv_data;AVStream*st;if(!process_ea_header(s))return AVERROR(EIO);if(ea->video_codec){st=av_new_stream(s, 0);if(!st)return AVERROR(ENOMEM);ea->video_stream_index=st->index;st->codec->codec_type=AVMEDIA_TYPE_VIDEO;st->codec->codec_id=ea->video_codec;st->codec->codec_tag=0;st->codec->time_base=ea->time_base;st->codec->width=ea->width;st->codec->height=ea->height;if(ea->num_channels <= 0){av_log(s, AV_LOG_WARNING, \"Unsupported number of channels:%d\\n\", ea->num_channels);if(ea->audio_codec){st=av_new_stream(s, 0);if(!st)return AVERROR(ENOMEM);av_set_pts_info(st, 33, 1, ea->sample_rate);st->codec->codec_type=AVMEDIA_TYPE_AUDIO;st->codec->codec_id=ea->audio_codec;st->codec->codec_tag=0;st->codec->channels=ea->num_channels;st->codec->sample_rate=ea->sample_rate;st->codec->bits_per_coded_sample=ea->bytes*8;st->codec->bit_rate=st->codec->channels*st->codec->sample_rate*st->codec->bits_per_coded_sample\/4;st->codec->block_align=st->codec->channels*st->codec->bits_per_coded_sample;ea->audio_stream_index=st->index;ea->audio_frame_counter=0;return 1;","idx":"cb77dad72414940837bdb01dad5e747175d6a01f","target":1}
{"code":"static uint64_t timer_read(void* opaque, target_phys_addr_t addr, unsigned size) {\n    LM32TimerState* s = opaque;\n    uint32_t r = 0;\n    if (addr >= sizeof(s->regs) \/ sizeof(s->regs[0]) || size != 4) {\n        error_report(\"lm32_timer: invalid read access to register 0x\" TARGET_FMT_plx, addr << 2);\n        return 0;\n    }\n    addr >>= 2;\n    switch (addr) {\n    case R_SR:\n    case R_CR:\n    case R_PERIOD:\n        r = s->regs[addr];\n        break;\n    case R_SNAPSHOT:\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n        break;\n    default:\n        error_report(\"lm32_timer: read access to unknown register 0x\" TARGET_FMT_plx, addr << 2);\n        break;\n    }\n    trace_lm32_timer_memory_read(addr << 2, r);\n    return r;\n}","idx":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0}
{"code":"int av_packet_ref(AVPacket*dst, AVPacket*src){\n    int ret;\n    ret=av_packet_copy_props(dst, src);\n    if(ret<0)return ret;\n    if(!src->buf){\n        ret=packet_alloc(&dst->buf, src->size);\n        if(ret<0)goto fail;\n        if(dst->buf->data == NULL) return AVERROR(ENOMEM);\n        memcpy(dst->buf->data, src->data, src->size);\n    }else{\n        dst->buf=av_buffer_ref(src->buf);\n    }\n    dst->size=src->size;\n    dst->data=dst->buf->data;\n    return 0;\nfail:\n    av_packet_free_side_data(dst);\n    return ret;\n}","idx":"fe0f4e56577a2dbd373bb50b0ae2d49e69d822fc","target":0}
{"code":"static void s390_msi_ctrl_write(void*opaque, hwaddr addr, uint64_t data, unsigned int size){S390PCIBusDevice*pbdev;uint32_t io_int_word;uint32_t fid=data>>ZPCI_MSI_VEC_BITS;uint32_t vec=data&ZPCI_MSI_VEC_MASK;uint64_t ind_bit;uint32_t sum_bit;uint32_t e=0;DPRINTF(\"write_msix data 0x%\" PRIx64 \" fid%d vec 0x%x\\n\", data, fid, vec);pbdev=s390_pci_find_dev_by_fid(fid);if(!pbdev){e|=(vec<<ERR_EVENT_MVN_OFFSET);s390_pci_generate_error_event(ERR_EVENT_NOMSI, 0, fid, addr, e);return;}if(pbdev->state != ZPCI_FS_ENABLED){return;}ind_bit=pbdev->routes.adapter.ind_offset;sum_bit=pbdev->routes.adapter.summary_offset;set_ind_atomic(pbdev->routes.adapter.ind_addr+(ind_bit+vec)\/8, 0x80>>((ind_bit+vec)%8));if(!set_ind_atomic(pbdev->routes.adapter.summary_addr+sum_bit\/8, 0x80>>(sum_bit%8))){io_int_word=(pbdev->isc<<27)|IO_INT_WORD_AI;s390_io_interrupt(0, 0, 0, io_int_word);}}","idx":"cdd85eb2804018ab46a742ebf64dc5366b9fae73","target":1}
{"code":"static CURLcode tftp_connect(struct connectdata*conn, bool*done){tftp_state_data_t*state;int blksize;blksize=TFTP_BLKSIZE_DEFAULT;state=conn->proto.tftpc=calloc(1, sizeof(tftp_state_data_t));if(!state)return CURLE_OUT_OF_MEMORY;if(conn->data->set.tftp_blksize){blksize=(int)conn->data->set.tftp_blksize;if(blksize>TFTP_BLKSIZE_MAX || blksize<TFTP_BLKSIZE_MIN)return CURLE_TFTP_ILLEGAL;}if(!state->rpacket.data){state->rpacket.data=calloc(1, blksize+2+2);if(!state->rpacket.data)return CURLE_OUT_OF_MEMORY;}if(!state->spacket.data){state->spacket.data=calloc(1, blksize+2+2);if(!state->spacket.data)return CURLE_OUT_OF_MEMORY;}","idx":"curl-curl-7_61_1-0","target":1}
{"code":"static void render_line(int x0, int y0, int x1, int y1, float*buf){int dy=y1-y0;int adx=x1-x0;int ady=FFABS(dy);int sy=dy<0 ?-1 : 1;buf[x0]=ff_vorbis_floor1_inverse_db_table[y0];if(ady*2 <= adx){render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);}else{int base=dy\/adx;int x=x0;int y=y0;int err=-adx;ady-=FFABS(base)*adx;while(++x<x1){y+=base;err+=ady;if(err >= 0){err-=adx;y+=sy;}buf[x]=ff_vorbis_floor1_inverse_db_table[y];}}}","idx":"7149fce2cac0474a5fbc5b47add1158cd8bb283e","target":1}
{"code":"void*av_realloc(void*ptr, size_t size){#if CONFIG_MEMALIGN_HACK\n    int diff;#endif\n    if(size>(max_alloc_size-32))return NULL;#if CONFIG_MEMALIGN_HACK\n    if(!ptr)return av_malloc(size);diff=((char*)ptr)[-1];av_assert0(diff>0 && diff <= ALIGN);ptr=realloc((char*)ptr-diff, size+diff);if(ptr)ptr=(char*)ptr+diff;return ptr;#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size+!size, ALIGN);#else\n    return realloc(ptr, size+!size);#endif}","idx":"ffmpeg_f87de593a19e27efb9e7b523b9fd8ad3e720ec71_1","target":1}
{"code":"static void show_packets(AVFormatContext*fmt_ctx){AVPacket pkt;av_init_packet(&pkt);probe_array_header(\"packets\", 0);while(!av_read_frame(fmt_ctx, &pkt))show_packet(fmt_ctx, &pkt);probe_array_footer(\"packets\", 0);}","idx":"f0ca6ffa0ae5d5564516ee7a18aa1e234751444a","target":1}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    size_t calculated_size = sizeof(scoreboard) + server_limit * sizeof(worker_score*) + server_limit * lb_limit * sizeof(lb_score*);\n    if (calculated_size > scoreboard_size) return;\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, calculated_size);\n    if (!ap_scoreboard_image) return;\n    more_storage=shared_score;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score+scoreboard_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_9ad8554d836907d0dcbe899992b297f4e1975c23_0","target":0}
{"code":"static inline void refill_32(BitstreamContext*bc){if(bc->ptr >= bc->buffer_end)return;#ifdef BITSTREAM_READER_LE\n    bc->bits=(uint64_t)AV_RL32(bc->ptr)<<bc->bits_left|bc->bits;#else\n    bc->bits=bc->bits|(uint64_t)AV_RB32(bc->ptr)<<(32-bc->bits_left);#endif\n    bc->ptr+=4;bc->bits_left+=32;}","idx":"ffmpeg_d1016f7c7d1ac94fc77fecf7861d280143ceff19_1","target":1}
{"code":"template<typename T>T*grzeroalloc(size_t n){#ifdef GRAPHITE2_TELEMETRY\n    telemetry::count_bytes(sizeof(T)*n);#endif\n    return static_cast<T*>(calloc(n, sizeof(T)));}","idx":"graphite2-1.3.5-0","target":1}
{"code":"void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...) {\n    va_list va;\n    char buf[256];\n    char *p;\n    target_ulong addr;\n    uint64_t i64;\n    GDBState *s;\n    s = gdbserver_state;\n    if (!s) return;\n    gdb_current_syscall_cb = cb;\n    s->state = RS_SYSCALL;\n#ifndef CONFIG_USER_ONLY    \n    vm_stop(EXCP_DEBUG);\n#endif    \n    s->state = RS_IDLE;\n    va_start(va, fmt);\n    p = buf;\n    *(p++) = 'F';\n    while (*fmt) {\n        if (*fmt == '%') {\n            fmt++;\n            switch (*fmt++) {\n                case 'x':\n                    addr = va_arg(va, target_ulong);\n                    p += snprintf(p, sizeof(buf) - (p - buf), TARGET_FMT_lx, addr);\n                    break;\n                case 'l':\n                    if (*(fmt++) != 'x')\n                        goto bad_format;\n                    i64 = va_arg(va, uint64_t);\n                    p += snprintf(p, sizeof(buf) - (p - buf), \"%\" PRIx64, i64);\n                    break;\n                case 's':\n                    addr = va_arg(va, target_ulong);\n                    p += snprintf(p, sizeof(buf) - (p - buf), TARGET_FMT_lx \"\/%x\", addr, va_arg(va, int));\n                    break;\n                default:\n                bad_format:\n                    fprintf(stderr, \"gdbstub: Bad syscall format string\\n\");\n                    break;\n            }\n        } else {\n            *(p++) = *(fmt++);\n        }\n    }\n    *p = 0;\n    va_end(va);\n    put_packet(s, buf);\n#ifdef CONFIG_USER_ONLY    \n    gdb_handlesig(s->c_cpu, 0);\n#else    \n    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);\n#endif    \n}","idx":"3098dba01c7daab60762b6f6624ea88c0d6cb65a","target":0}
{"code":"static void xvid_idct_put(uint8_t*dest, ptrdiff_t line_size, int16_t*block){ff_xvid_idct(block);ff_put_pixels_clamped(block, dest, line_size);}","idx":"32baeafeee4f8446c2c3720b9223ad2166ca9d30","target":1}
{"code":"static\nECDSA_SIG*SM2_sig_gen(const EC_KEY*key, const BIGNUM*e){const BIGNUM*dA=EC_KEY_get0_private_key(key);const EC_GROUP*group=EC_KEY_get0_group(key);const BIGNUM*order=EC_GROUP_get0_order(group);ECDSA_SIG*sig=NULL;EC_POINT*kG=NULL;BN_CTX*ctx=NULL;BIGNUM*k=NULL;BIGNUM*rk=NULL;BIGNUM*r=NULL;BIGNUM*s=NULL;BIGNUM*x1=NULL;BIGNUM*tmp=NULL;kG=EC_POINT_new(group);if(kG == NULL)goto done;ctx=BN_CTX_new();if(ctx == NULL)goto done;BN_CTX_start(ctx);k=BN_CTX_get(ctx);rk=BN_CTX_get(ctx);x1=BN_CTX_get(ctx);tmp=BN_CTX_get(ctx);if(tmp == NULL)goto done;r=BN_new();s=BN_new();if(r == NULL || s == NULL)goto done;for(;;){BN_priv_rand_range(k, order);if(EC_POINT_mul(group, kG, k, NULL, NULL, ctx) == 0)goto done;if(EC_POINT_get_affine_coordinates_GFp(group, kG, x1, NULL, ctx) == 0)goto done;if(BN_mod_add(r, e, x1, order, ctx) == 0)goto done;if(BN_is_zero(r))continue;BN_add(rk, r, k);if(BN_cmp(rk, order) == 0)continue;BN_add(s, dA, BN_value_one());BN_mod_inverse(s, s, order, ctx);BN_mod_mul(tmp, dA, r, order, ctx);BN_sub(tmp, k, tmp);BN_mod_mul(s, s, tmp, order, ctx);sig=ECDSA_SIG_new();if(sig == NULL)goto done;ECDSA_SIG_set0(sig, r, s);break;}done:\n    if(sig == NULL){BN_free(r);BN_free(s);}BN_CTX_free(ctx);EC_POINT_free(kG);return sig;}","idx":"openssl_24578a18649b707d6800f04cac63e764445fbff5_1","target":1}
{"code":"static String HHVM_FUNCTION(bcadd, const String&left, const String&right, int64_t scale){if(scale<0)scale=BCG(bc_precision);bc_num first, second, result;bc_init_num(&first);bc_init_num(&second);bc_init_num(&result);php_str2num(&first, (char*)left.data());php_str2num(&second, (char*)right.data());bc_add(first, second, &result, scale);if(result->n_scale>scale){result->n_scale=scale;}String ret(bc_num2str(result), AttachString);bc_free_num(&first);bc_free_num(&second);bc_free_num(&result);return ret;}","idx":"hhvm-HHVM-3.12.10-0","target":1}
{"code":"print_syscall_ret(int num, abi_long ret){int i;for(i=0;i<nsyscalls;i++)if(scnames[i].nr == num){if(scnames[i].result != NULL){scnames[i].result(&scnames[i], ret);}else{if(ret<0){gemu_log(\"=-1 errno=\" TARGET_ABI_FMT_ld \" (%s)\\n\", -ret, target_strerror(-ret));}else{gemu_log(\"=\" TARGET_ABI_FMT_ld \"\\n\", ret);}}break;}}","idx":"962b289ef35087fcd8764e4e29808d8ac90157f7","target":1}
{"code":"static long get_chunk_size(char *b) {\n    long chunksize = 0;\n    size_t chunkbits = sizeof(long) * 8;\n    size_t len = strlen(b);\n    ap_xlate_proto_from_ascii(b, len);\n    size_t i = 0;\n    while (i < len && b[i] == '0') {\n        ++i;\n    }\n    while (i < len && apr_isxdigit(b[i]) && (chunkbits > 0)) {\n        int xvalue = 0;\n        if (b[i] >= '0' && b[i] <= '9') {\n            xvalue = b[i] - '0';\n        } else if (b[i] >= 'A' && b[i] <= 'F') {\n            xvalue = b[i] - 'A' + 0xa;\n        } else if (b[i] >= 'a' && b[i] <= 'f') {\n            xvalue = b[i] - 'a' + 0xa;\n        }\n        chunksize = (chunksize << 4) | xvalue;\n        chunkbits -= 4;\n        ++i;\n    }\n    if (i < len && apr_isxdigit(b[i]) && (chunkbits <= 0)) {\n        return -1;\n    }\n    return chunksize;\n}","idx":"httpd_12cd078edfbd1ecce7533b49ce34f4f2743c725b_0","target":0}
{"code":"void jas_free(void*ptr){JAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));free(ptr);}","idx":"jasper-version-2.0.11-0","target":1}
{"code":"av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext*fdsp, int bit_exact){#if HAVE_ALTIVEC if(fdsp == NULL) return; if(!(av_get_cpu_flags()&AV_CPU_FLAG_ALTIVEC))return;fdsp->vector_fmul=ff_vector_fmul_altivec;fdsp->vector_fmul_add=ff_vector_fmul_add_altivec;fdsp->vector_fmul_reverse=ff_vector_fmul_reverse_altivec;if(!bit_exact){fdsp->vector_fmul_window=ff_vector_fmul_window_altivec;}#endif}","idx":"f61bece684d9685b07895508e6c1c733b5564ccf","target":0}
{"code":"static int BitBlt_SRCCOPY_8bpp(HGDI_DC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HGDI_DC hdcSrc, int nXSrc, int nYSrc){\n    int y;\n    uint8* srcp;\n    uint8* dstp;\n    if ((hdcDest->selectedObject != hdcSrc->selectedObject) || gdi_CopyOverlap(nXDest, nYDest, nWidth, nHeight, nXSrc, nYSrc) == 0) {\n        for (y = 0; y < nHeight; y++) {\n            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n            if (srcp != 0 && dstp != 0) {\n                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;\n                if (size \/ hdcDest->bytesPerPixel == nWidth) {\n                    memmove(dstp, srcp, size);\n                }\n            }\n        }\n        return 0;\n    }\n    if (nYSrc < nYDest) {\n        for (y = nHeight - 1; y >= 0; y--) {\n            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n            if (srcp != 0 && dstp != 0) {\n                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;\n                if (size \/ hdcDest->bytesPerPixel == nWidth) {\n                    memmove(dstp, srcp, size);\n                }\n            }\n        }\n    } else if (nYSrc > nYDest || nXSrc > nXDest) {\n        for (y = 0; y < nHeight; y++) {\n            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n            if (srcp != 0 && dstp != 0) {\n                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;\n                if (size \/ hdcDest->bytesPerPixel == nWidth) {\n                    memmove(dstp, srcp, size);\n                }\n            }\n        }\n    } else {\n        for (y = 0; y < nHeight; y++) {\n            srcp = gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc + y);\n            dstp = gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest + y);\n            if (srcp != 0 && dstp != 0) {\n                size_t size = (size_t)nWidth * (size_t)hdcDest->bytesPerPixel;\n                if (size \/ hdcDest->bytesPerPixel == nWidth) {\n                    memmove(dstp, srcp, size);\n                }\n            }\n        }\n    }\n    return 0;\n}","idx":"freerdp-1.0.2-1","target":0}
{"code":"static gboolean register_signal_handlers(void){struct sigaction sigact, sigact_chld;int ret;memset(&sigact, 0, sizeof(struct sigaction));sigact.sa_handler=quit_handler;ret=sigaction(SIGINT, &sigact, NULL);if(ret == -1){g_error(\"error configuring signal handler:%s\", strerror(errno));return false;}ret=sigaction(SIGTERM, &sigact, NULL);if(ret == -1){g_error(\"error configuring signal handler:%s\", strerror(errno));return false;}memset(&sigact_chld, 0, sizeof(struct sigaction));sigact_chld.sa_handler=child_handler;sigact_chld.sa_flags=SA_NOCLDSTOP;ret=sigaction(SIGCHLD, &sigact_chld, NULL);if(ret == -1){g_error(\"error configuring signal handler:%s\", strerror(errno));}return true;}","idx":"dc8764f06155a7b3e635e02281b747a9e292127e","target":1}
{"code":"static int openfile(char*name, int flags, QDict*opts){Error*local_err=NULL;if(qemuio_blk){fprintf(stderr, \"file open already, try 'help close'\\n\");QDECREF(opts);return 1;}qemuio_blk=blk_new_open(\"hda\", name, NULL, opts, flags, &local_err);if(!qemuio_blk){fprintf(stderr, \"%s: can't open%s%s:%s\\n\", progname, name ? \" device \" : \"\", name ?: \"\", error_get_pretty(local_err));error_free(local_err);return 1;}bs=blk_bs(qemuio_blk);if(bdrv_is_encrypted(bs)){char password[256];printf(\"Disk image '%s' is encrypted.\\n\", name);if(qemu_read_password(password, sizeof(password))<0){error_report(\"No password given\");goto error;}if(bdrv_set_key(bs, password)<0){error_report(\"invalid password\");goto error;}}return 0;error:\n    blk_unref(qemuio_blk);qemuio_blk=NULL;return 1;}","idx":"8caf02127e92939fff39b63a7ff1a5834d320191","target":1}
{"code":"void update_recv_order(rdpUpdate* update, STREAM* s) {\n    uint8 controlFlags;\n    if (stream_get_length(s) >= 1) {\n        stream_read_uint8(s, controlFlags);\n        if (!(controlFlags & ORDER_STANDARD)) {\n            if (stream_get_length(s) >= sizeof(controlFlags))\n                update_recv_altsec_order(update, s, controlFlags);\n        } else if (controlFlags & ORDER_SECONDARY) {\n            if (stream_get_length(s) >= sizeof(controlFlags))\n                update_recv_secondary_order(update, s, controlFlags);\n        } else {\n            if (stream_get_length(s) >= sizeof(controlFlags))\n                update_recv_primary_order(update, s, controlFlags);\n        }\n    }\n}","idx":"freerdp-1.0.2-4","target":0}
{"code":"static void encode_gray_bitstream(HYuvContext*s, int count){int i;count\/=2;if(s->flags&CODEC_FLAG_PASS1){for(i=0;i<count;i++){s->stats[0][ s->temp[0][2*i  ] ]++;s->stats[0][ s->temp[0][2*i+1] ]++;}}else if(s->context){for(i=0;i<count;i++){s->stats[0][ s->temp[0][2*i  ] ]++;put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);s->stats[0][ s->temp[0][2*i+1] ]++;put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);}}else{for(i=0;i<count;i++){put_bits(&s->pb, s->len[0][ s->temp[0][2*i  ] ], s->bits[0][ s->temp[0][2*i  ] ]);put_bits(&s->pb, s->len[0][ s->temp[0][2*i+1] ], s->bits[0][ s->temp[0][2*i+1] ]);}}}","idx":"0ecca7a49f8e254c12a3a1de048d738bfbb614c6","target":1}
{"code":"static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s, omap_clk clk) {\n    int iomemtype;\n    if ((base & 0xFFF) != 0 || base + 0x800 > MAX_ADDR) {\n        return;\n    }\n    s->pwl.base = base;\n    omap_pwl_reset(s);\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn, omap_pwl_writefn, s);\n    if (iomemtype < 0) {\n        return;\n    }\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n}","idx":"b854bc196f5c4b4e3299c0b0ee63cf828ece9e77","target":0}
{"code":"static av_cold int rpza_decode_init(AVCodecContext *avctx) {\n    if (!avctx || !avctx->priv_data)\n        return AVERROR(EINVAL);\n    RpzaContext *s = avctx->priv_data;\n    s->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n    s->frame.data[0] = NULL;\n    return 0;\n}","idx":"3b199d29cd597a3518136d78860e172060b9e83d","target":0}
{"code":"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid) {\n    int32_t datalen;\n    int lun;\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n    lun = busid & 7;\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n    datalen = scsi_req_enqueue(s->current_req, buf);\n    if (datalen < 0 || datalen > MAX_DATA_LENGTH) {\n        return;\n    }\n    s->ti_size = datalen;\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->dma_left = 0;\n        s->dma_counter = 0;\n        if (datalen > 0) {\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n        }\n        scsi_req_continue(s->current_req);\n    }\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n    esp_raise_irq(s);\n}","idx":"c39ce112b60ffafbaf700853e32bea74cbb2c148","target":0}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));\n    if (!ap_scoreboard_image) return;\n    more_storage=shared_score;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score+scoreboard_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_e95b9b94154dcd872cedbfbd7d77b4c252002034_0","target":0}
{"code":"static void virt_acpi_build_update(void *build_opaque)\n{\n    AcpiBuildState *build_state = build_opaque;\n    AcpiBuildTables tables;\n    if (!build_state || build_state->patched) {\n        return;\n    }\n    build_state->patched = true;\n    acpi_build_tables_init(&tables);\n    virt_acpi_build(build_state->guest_info, &tables);\n    if (tables.table_data) acpi_ram_update(build_state->table_mr, tables.table_data);\n    if (tables.rsdp) acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n    if (tables.linker) acpi_ram_update(build_state->linker_mr, tables.linker);\n    acpi_build_tables_cleanup(&tables, true);\n}","idx":"0e9b9edae7bebfd31fdbead4ccbbce03876a7edd","target":0}
{"code":"void update_recv_order(rdpUpdate*update, STREAM*s){uint8 controlFlags;stream_read_uint8(s, controlFlags);if(!(controlFlags&ORDER_STANDARD))update_recv_altsec_order(update, s, controlFlags);else if(controlFlags&ORDER_SECONDARY)update_recv_secondary_order(update, s, controlFlags);else\n\t\tupdate_recv_primary_order(update, s, controlFlags);}","idx":"freerdp-1.0.2-4","target":1}
{"code":"static uint32_t drc_set_unusable(sPAPRDRConnector *drc) {\n    if (drc == NULL) {\n        return RTAS_OUT_ERROR;\n    }\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n    if (drc->awaiting_release) {\n        uint32_t drc_index = spapr_drc_index(drc);\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n        spapr_drc_detach(drc);\n    }\n    return RTAS_OUT_SUCCESS;\n}","idx":"f1c52354e5bdab6983d13a4c174759c585e834b3","target":0}
{"code":"void jas_free(void* ptr) {\n    JAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n    if (ptr != NULL) {\n        free(ptr);\n    }\n}","idx":"jasper-version-2.0.11-0","target":0}
{"code":"static cJSON_bool add_item_to_object(cJSON* const object, const char* const string, cJSON* const item, const internal_hooks* const hooks, const cJSON_bool constant_key) {\n    if ((object == NULL) || (string == NULL) || (item == NULL)) {\n        return false;\n    }\n    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL)) {\n        hooks->deallocate(item->string);\n        item->string = NULL;\n    }\n    if (constant_key) {\n        item->string = (char*)string;\n        item->type |= cJSON_StringIsConst;\n    } else {\n        char* key = (char*)cJSON_strdup((const unsigned char*)string, hooks);\n        if (key == NULL) {\n            return false;\n        }\n        item->string = key;\n        item->type &= ~cJSON_StringIsConst;\n    }\n    return add_item_to_array(object, item);\n}","idx":"cjson-v.1.7.3-0","target":0}
{"code":"static int copy_moof(AVFormatContext*s, const char*infile, const char*outfile, int64_t size){\n    AVIOContext*in, *out;\n    int ret=0;\n    if((ret=avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL))<0)\n        return ret;\n    if((ret=avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL))<0){\n        avio_close(in);\n        return ret;\n    }\n    while(size>0){\n        uint8_t buf[8192];\n        int n=FFMIN(size, sizeof(buf));\n        n=avio_read(in, buf, n);\n        if(n <= 0){\n            ret=AVERROR(EIO);\n            break;\n        }\n        if(avio_write(out, buf, n) != n) {\n            ret = AVERROR(EIO);\n            break;\n        }\n        size-=n;\n    }\n    avio_flush(out);\n    avio_close(out);\n    avio_close(in);\n    return ret;\n}","idx":"9f61abc8111c7c43f49ca012e957a108b9cc7610","target":0}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));\n    if (!ap_scoreboard_image) return;\n    more_storage=shared_score;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage <= (char*)shared_score+scoreboard_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_b34070f58087d7398a09c30b64189abd48616623_0","target":0}
{"code":"static int tcg_match_cmpi(TCGType type, tcg_target_long val){\n    extern unsigned int facilities;  \/* Ensure 'facilities' is declared and accessible *\/\n    if(facilities & FACILITY_EXT_IMM){\n        if(type == TCG_TYPE_I32){\n            return 1;\n        } else {\n            return val >= 0 && val <= 0x7fffffff;\n        }\n    } else {\n        return val == 0;\n    }\n}","idx":"b2c98d9d392c87c9b9e975d30f79924719d9cbbe","target":0}
{"code":"AP_DECLARE(char*)ap_field_noparam(apr_pool_t*p, const char*intype){\n    const char*semi;\n    if(intype == NULL)\n        return NULL;\n    semi=ap_strchr_c(intype, ';');\n    if(semi == NULL){\n        return apr_pstrdup(p, intype);\n    }else{\n        while((semi>intype) && apr_isspace(semi[-1])){\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi-intype);\n    }\n}","idx":"httpd_9413f5d49bae37718a97303fd1b07661b1cb5778_0","target":0}
{"code":"AP_DECLARE(char*)ap_md5_binary(apr_pool_t*p, const unsigned char*buf, int length){const char*hex=\"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;unsigned char hash[APR_MD5_DIGESTSIZE];char*r, result[33];int i;apr_md5_init(&my_md5);#if APR_CHARSET_EBCDIC \n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);#endif \n    apr_md5_update(&my_md5, buf, (unsigned int)length);apr_md5_final(hash, &my_md5);for(i=0, r=result;i<APR_MD5_DIGESTSIZE;i++){*r++=hex[hash[i]>>4];*r++=hex[hash[i]&0xF];}*r='\\0'; \n    return apr_pstrndup(p, result, APR_MD5_DIGESTSIZE*2+1);}","idx":"httpd_27680735a0ee17ef5cefd7684a43e95dba679cc8_0","target":0}
{"code":"int kvm_arch_init(KVMState*s){uint64_t identity_base=0xfffbc000;int ret;struct utsname utsname;ret=kvm_get_supported_msrs(s);if(ret<0){return ret;}uname(&utsname);lm_capable_kernel=strcmp(utsname.machine, \"x86_64\") == 0;#ifdef KVM_CAP_SET_IDENTITY_MAP_ADDR\n    if(kvm_check_extension(s, KVM_CAP_SET_IDENTITY_MAP_ADDR)){identity_base=0xfeffc000;ret=kvm_vm_ioctl(s, KVM_SET_IDENTITY_MAP_ADDR, &identity_base);if(ret<0){return ret;}}#endif\n    ret=kvm_vm_ioctl(s, KVM_SET_TSS_ADDR, identity_base+0x1000);if(ret<0){return ret;}ret=e820_add_entry(identity_base, 0x4000, E820_RESERVED);if(ret<0){fprintf(stderr, \"e820_add_entry()table is full\\n\");return ret;}return 0;}","idx":"3c85e74fbf9e5a39d8d13ef91a5f3dd91f0bc8a8","target":1}
{"code":"static int asn1_get_length(const unsigned char**pp, int*inf, long*rl, int max){const unsigned char*p=*pp;unsigned long ret=0;unsigned int i;if(max--<1)return(0);if(*p == 0x80){*inf=1;ret=0;p++;}else{*inf=0;i=*p&0x7f;if(*(p++)&0x80){if(max<(int)i)return 0;while(i && *p == 0){p++;i--;}if(i>sizeof(long))return 0;while(i-->0){ret< <= 8L;ret|=*(p++);}}else\n            ret=i;}if(ret>LONG_MAX)return 0;*pp=p;*rl=(long)ret;return(1);}","idx":"openssl_fad572c151d33d540c83f14a22be1bd6e67bb566_1","target":1}
{"code":"static void init_excp_620(CPUPPCState*env){#if!defined(CONFIG_USER_ONLY)env->excp_vectors[POWERPC_EXCP_RESET]=0x00000100;env->excp_vectors[POWERPC_EXCP_MCHECK]=0x00000200;env->excp_vectors[POWERPC_EXCP_DSI]=0x00000300;env->excp_vectors[POWERPC_EXCP_ISI]=0x00000400;env->excp_vectors[POWERPC_EXCP_EXTERNAL]=0x00000500;env->excp_vectors[POWERPC_EXCP_ALIGN]=0x00000600;env->excp_vectors[POWERPC_EXCP_PROGRAM]=0x00000700;env->excp_vectors[POWERPC_EXCP_FPU]=0x00000800;env->excp_vectors[POWERPC_EXCP_DECR]=0x00000900;env->excp_vectors[POWERPC_EXCP_SYSCALL]=0x00000C00;env->excp_vectors[POWERPC_EXCP_TRACE]=0x00000D00;env->excp_vectors[POWERPC_EXCP_FPA]=0x00000E00;env->excp_vectors[POWERPC_EXCP_PERFM]=0x00000F00;env->excp_vectors[POWERPC_EXCP_IABR]=0x00001300;env->excp_vectors[POWERPC_EXCP_SMI]=0x00001400;env->hreset_vector=0x0000000000000100ULL;#endif}","idx":"faadf50e2962dd54175647a80bd6fc4319c91973","target":1}
{"code":"static int xan_huffman_decode(unsigned char*dest, int dest_len, const unsigned char*src, int src_len){unsigned char byte=*src++;unsigned char ival=byte+0x16;const unsigned char*ptr=src+byte*2;int ptr_len=src_len-1-byte*2;unsigned char val=ival;unsigned char*dest_end=dest+dest_len;GetBitContext gb;if(ptr_len<0)return AVERROR_INVALIDDATA;init_get_bits(&gb, ptr, ptr_len*8);while(val != 0x16){val=src[val-0x17+get_bits1(&gb)*byte];if(val<0x16){if(dest >= dest_end)return 0;*dest++=val;val=ival;}}return 0;}","idx":"c8b835954ae4aef797112afda3b52f8dfe3c7b74","target":1}
{"code":"static cJSON_bool add_item_to_object(cJSON*const object, const char*const string, cJSON*const item, const internal_hooks*const hooks, const cJSON_bool constant_key){if((object == NULL) || (string == NULL) || (item == NULL)){return false;}if(!(item->type&cJSON_StringIsConst) && (item->string != NULL)){hooks->deallocate(item->string);}if(constant_key){item->string=(char*)cast_away_const(string);item->type|=cJSON_StringIsConst;}else{char*key=(char*)cJSON_strdup((const unsigned char*)string, hooks);if(key == NULL){return false;}item->string=key;item->type&=~cJSON_StringIsConst;}return add_item_to_array(object, item);}","idx":"cjson-v.1.7.3-0","target":1}
{"code":"CURLcode Curl_ntlm_core_mk_ntlmv2_hash(const char*user, size_t userlen, const char*domain, size_t domlen, unsigned char*ntlmhash, unsigned char*ntlmv2hash){size_t identity_len=(userlen+domlen)*2;unsigned char*identity=malloc(identity_len);CURLcode result=CURLE_OK;if(!identity)return CURLE_OUT_OF_MEMORY;ascii_uppercase_to_unicode_le(identity, user, userlen);ascii_to_unicode_le(identity+(userlen<<1), domain, domlen);result=Curl_hmac_md5(ntlmhash, 16, identity, curlx_uztoui(identity_len), ntlmv2hash);free(identity);return result;}","idx":"curl-curl-7_56_1-0","target":1}
{"code":"static unsigned char* print(const cJSON* const item, cJSON_bool format, const internal_hooks* const hooks) {\n    static const size_t default_buffer_size = 256;\n    printbuffer buffer[1];\n    unsigned char* printed = NULL;\n    memset(buffer, 0, sizeof(buffer));\n    buffer->buffer = (unsigned char*)hooks->allocate(default_buffer_size);\n    buffer->length = default_buffer_size;\n    buffer->format = format;\n    buffer->hooks = *hooks;\n    if (buffer->buffer == NULL) {\n        goto fail;\n    }\n    if (!print_value(item, buffer)) {\n        goto fail;\n    }\n    update_offset(buffer);\n    if (hooks->reallocate != NULL) {\n        printed = (unsigned char*)hooks->reallocate(buffer->buffer, buffer->offset + 1);\n        buffer->buffer = NULL;\n        if (printed == NULL) {\n            goto fail;\n        }\n    } else {\n        printed = (unsigned char*)hooks->allocate(buffer->offset + 1);\n        if (printed == NULL) {\n            goto fail;\n        }\n        memcpy(printed, buffer->buffer, cjson_min(buffer->offset, buffer->length));\n        printed[buffer->offset] = '\\0';\n        if (buffer->buffer != NULL) {\n            hooks->deallocate(buffer->buffer);\n            buffer->buffer = NULL;\n        }\n    }\n    return printed;\nfail:\n    if (buffer->buffer != NULL) {\n        hooks->deallocate(buffer->buffer);\n        buffer->buffer = NULL;\n    }\n    if (printed != NULL) {\n        hooks->deallocate(printed);\n    }\n    return NULL;\n}","idx":"cjson-v.1.7.2-0","target":0}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, scoreboard_size);\n    more_storage=shared_score;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score+scoreboard_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_8e8c19e46a77da0b247c91af6b30dde0c28163aa_0","target":0}
{"code":"void helper_divl_EAX_T0(void){unsigned int den, q, r;uint64_t num;num=((uint32_t)EAX)|((uint64_t)((uint32_t)EDX)<<32);den=T0;if(den == 0){raise_exception(EXCP00_DIVZ);}#ifdef BUGGY_GCC_DIV64\n    r=div32(&q, num, den);#else\n    q=(num\/den);r=(num%den);#endif\n    EAX=(uint32_t)q;EDX=(uint32_t)r;}","idx":"45bbbb466cf4a6280076ea5a51f67ef5bedee345","target":1}
{"code":"static int set_group_privs(void) {\n    if (!geteuid()) {\n        const char *name;\n        if (unixd_config.user_name[0] == '#') {\n            struct passwd *ent;\n            char *endptr;\n            uid_t uid = strtol(&unixd_config.user_name[1], &endptr, 10);\n            if (*endptr != '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, 0, NULL, \"Invalid UID.\");\n                return -1;\n            }\n            if ((ent = getpwuid(uid)) == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, \"getpwuid: couldn't determine user name from uid %u, \"\n                             \"you probably need to modify the User directive\", (unsigned)uid);\n                return -1;\n            }\n            name = ent->pw_name;\n        } else {\n            name = unixd_config.user_name;\n        }\n        #if !defined(OS2) && !defined(TPF)\n        if (setgid(unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, \"setgid: unable to set group id to Group %u\", (unsigned)unixd_config.group_id);\n            return -1;\n        }\n        if (initgroups(name, unixd_config.group_id) == -1) {\n            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, \"initgroups: unable to set groups for User %s \"\n                        \"and Group %u\", name, (unsigned)unixd_config.group_id);\n            return -1;\n        }\n        #endif    }\n    return 0;\n}","idx":"httpd_8038760bc02c48c31a059dda2ad061a6460cd0dd_0","target":0}
{"code":"void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI* s, VirtIOSCSIReq* req) {\n    SCSIRequest* sreq = req->sreq;\n    if (scsi_req_enqueue(sreq)) {\n        scsi_req_continue(sreq);\n    }\n    bdrv_io_unplug(sreq->dev->conf.bs);\n    scsi_req_unref(sreq);\n}","idx":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0}
{"code":"AP_CORE_DECLARE(void)ap_parse_uri(request_rec*r, const char*uri){\n    int status=HTTP_OK;\n    if (strlen(uri) > MAX_URI_LENGTH) {\n        r->status = HTTP_BAD_REQUEST;\n        return;\n    }\n    r->unparsed_uri=apr_pstrdup(r->pool, uri);\n    while((uri[0] == '\/') && (uri[1] == '\/')){\n        ++uri;\n    }\n    if(r->method_number == M_CONNECT){\n        status=apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }else{\n        status=apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if(status == APR_SUCCESS){\n        if(r->parsed_uri.scheme && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))){\n            r->hostname=r->parsed_uri.hostname;\n        }else if(r->method_number == M_CONNECT){\n            r->hostname=r->parsed_uri.hostname;\n        }\n        r->args=r->parsed_uri.query;\n        r->uri=r->parsed_uri.path ? r->parsed_uri.path : apr_pstrdup(r->pool, \"\/\");\n        #if defined(OS2) || defined(WIN32){\n            char*x;\n            for(x=r->uri;(x=strchr(x, '\\')) != NULL;)*x='\/';\n        }#endif}\n    else{\n        r->args=NULL;\n        r->hostname=NULL;\n        r->status=HTTP_BAD_REQUEST;\n        r->uri=apr_pstrdup(r->pool, uri);\n    }\n}","idx":"httpd_bfd6489f6b8ab0cbfbddc8e4d5754fa3660316e1_0","target":0}
{"code":"{'content': 'void arrayCopy(Thread* t,\\n               object src,\\n               int32_t srcOffset,\\n               object dst,\\n               int32_t dstOffset,\\n               int32_t length)\\n{\\n  if (LIKELY(src and dst)) {\\n    if (LIKELY(compatibleArrayTypes(\\n            t, objectClass(t, src), objectClass(t, dst)))) {\\n      unsigned elementSize = objectClass(t, src)->arrayElementSize();\\n\\n      if (LIKELY(elementSize)) {\\n        intptr_t sl = fieldAtOffset<uintptr_t>(src, BytesPerWord);\\n        intptr_t dl = fieldAtOffset<uintptr_t>(dst, BytesPerWord);\\n        if (LIKELY(length > 0)) {\\n          if (LIKELY(srcOffset >= 0 and (int64_t)srcOffset + (int64_t)length <= sl\\n                     and dstOffset >= 0 and (int64_t)dstOffset + (int64_t)length <= dl)) {\\n            uint8_t* sbody = &fieldAtOffset<uint8_t>(src, ArrayBody);\\n            uint8_t* dbody = &fieldAtOffset<uint8_t>(dst, ArrayBody);\\n            if (src == dst) {\\n              memmove(dbody + (dstOffset * elementSize),\\n                      sbody + (srcOffset * elementSize),\\n                      length * elementSize);\\n            } else {\\n              memcpy(dbody + (dstOffset * elementSize),\\n                     sbody + (srcOffset * elementSize),\\n                     length * elementSize);\\n            }\\n\\n            if (objectClass(t, dst)->objectMask()) {\\n              mark(t, dst, ArrayBody + (dstOffset * BytesPerWord), length);\\n            }\\n\\n            return;\\n          } else {\\n            throwNew(t, GcIndexOutOfBoundsException::Type);\\n          }\\n        } else {\\n          return;\\n        }\\n      }\\n    }\\n  } else {\\n    throwNew(t, GcNullPointerException::Type);\\n    return;\\n  }\\n\\n  throwNew(t, GcArrayStoreException::Type);\\n}'}","idx":"avian-v1.2.0-0","target":0}
{"code":"INLINE void gdi_RectToCRgn(HGDI_RECT rect, int*x, int*y, int*w, int*h){*x=rect->left;*y=rect->top;*w=rect->right-rect->left+1;*h=rect->bottom-rect->top+1;}","idx":"freerdp-1.0.2-0","target":1}
{"code":"static void ehci_class_init(ObjectClass*klass, void*data){DeviceClass*dc=DEVICE_CLASS(klass);PCIDeviceClass*k=PCI_DEVICE_CLASS(klass);EHCIPCIInfo*i=data;k->init=usb_ehci_pci_initfn;k->vendor_id=i->vendor_id;k->device_id=i->device_id;k->revision=i->revision;k->class_id=PCI_CLASS_SERIAL_USB;k->config_write=usb_ehci_pci_write_config;dc->vmsd=&vmstate_ehci_pci;dc->props=ehci_pci_properties;}","idx":"6c2d1c32d084320081b0cd047f8cacd6e722d03a","target":1}
{"code":"static void tcp_wait_for_connect(void*opaque){MigrationState*s=opaque;int val, ret;socklen_t valsize=sizeof(val);DPRINTF(\"connect completed\\n\");do{ret=getsockopt(s->fd, SOL_SOCKET, SO_ERROR, (void*)&val, &valsize);}while(ret == -1 && (socket_error()) == EINTR);if(ret<0){migrate_fd_error(s);return;}qemu_set_fd_handler2(s->fd, NULL, NULL, NULL, NULL);if(val == 0)migrate_fd_connect(s);else{DPRINTF(\"error connecting%d\\n\", val);migrate_fd_error(s);}}","idx":"233aa5c2d1cf4655ffe335025a68cf5454f87dad","target":1}
{"code":"static void* merge_action_dir_configs(apr_pool_t* p, void* basev, void* addv) {\n    action_dir_config* base = (action_dir_config*)basev;\n    action_dir_config* add = (action_dir_config*)addv;\n    action_dir_config* new = (action_dir_config*)apr_palloc(p, sizeof(action_dir_config));\n    int i;\n    new->action_types = apr_table_overlay(p, add->action_types, base->action_types);\n    for (i = 0; i < METHODS; ++i) {\n        new->scripted[i] = add->scripted[i] ? add->scripted[i] : base->scripted[i];\n    }\n    new->configured = (base->configured || add->configured);\n    return new;\n}","idx":"httpd_ecec010fd3f8197d1a6724dd38b0d3a9c1e95d4a_0","target":0}
{"code":"static int config_input(AVFilterLink*inlink){AVFilterContext*ctx=inlink->dst;FrameRateContext*s=ctx->priv;const AVPixFmtDescriptor*pix_desc=av_pix_fmt_desc_get(inlink->format);int plane;for(plane=0;plane<4;plane++){s->line_size[plane]=av_image_get_linesize(inlink->format, inlink->w, plane);}s->bitdepth=pix_desc->comp[0].depth;s->vsub=pix_desc->log2_chroma_h;s->interp_start=s->interp_start_param<<(s->bitdepth-8);s->interp_end=s->interp_end_param<<(s->bitdepth-8);s->sad=av_pixelutils_get_sad_fn(3, 3, 2, s);if(!s->sad)return AVERROR(EINVAL);s->srce_time_base=inlink->time_base;s->max=1<<(s->bitdepth);if(s->bitdepth == 8)s->blend=blend_frames_c;else\n        s->blend=blend_frames16_c;return 0;}","idx":"ffmpeg_b6b09c4c3e5bc64d889707ee2981768cc0d19a6c_1","target":1}
{"code":"static int calculate_refcounts(BlockDriverState*bs, BdrvCheckResult*res, BdrvCheckMode fix, uint16_t**refcount_table, int64_t*nb_clusters){\n    BDRVQcowState*s=bs->opaque;\n    int64_t i;\n    QCowSnapshot*sn;\n    int ret;\n    size_t size;\n    *refcount_table=g_try_new0(uint16_t, *nb_clusters);\n    if(*nb_clusters && *refcount_table == NULL){\n        res->check_errors++;\n        return -ENOMEM;\n    }\n    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, 0, s->cluster_size);\n    if(ret<0){\n        return ret;\n    }\n    ret=check_refcounts_l1(bs, res, *refcount_table, *nb_clusters, s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n    if(ret<0){\n        return ret;\n    }\n    for(i=0;i<s->nb_snapshots;i++){\n        sn=s->snapshots+i;\n        ret=check_refcounts_l1(bs, res, *refcount_table, *nb_clusters, sn->l1_table_offset, sn->l1_size, 0);\n        if(ret<0){\n            return ret;\n        }\n    }\n    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, s->snapshots_offset, s->snapshots_size);\n    if(ret<0){\n        return ret;\n    }\n    if (__builtin_mul_overflow(s->refcount_table_size, sizeof(uint64_t), &size)) {\n        return -EOVERFLOW;\n    }\n    ret=inc_refcounts(bs, res, *refcount_table, *nb_clusters, s->refcount_table_offset, size);\n    if(ret<0){\n        return ret;\n    }\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n}","idx":"641bb63cd6b003ab0ca2e312a014449037d71647","target":0}
{"code":"void aio_context_setup(AioContext*ctx){}","idx":"c2b38b277a7882a592f4f2ec955084b2b756daaa","target":0}
{"code":"AP_DECLARE(char*)ap_md5_binary(apr_pool_t*p, const unsigned char*buf, int length){const char*hex=\"0123456789abcdef\";\n    apr_md5_ctx_t my_md5;unsigned char hash[APR_MD5_DIGESTSIZE];char*r, result[33];int i;apr_md5_init(&my_md5);#if APR_CHARSET_EBCDIC \n    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);#endif \n    apr_md5_update(&my_md5, buf, (unsigned int)length);apr_md5_final(hash, &my_md5);for(i=0, r=result;i<APR_MD5_DIGESTSIZE;i++){*r++=hex[hash[i]>>4];*r++=hex[hash[i]&0xF];}*r='\\0'; \n    return apr_pstrndup(p, result, 32);}","idx":"httpd_8dddb48ed8aa22eb4959dfc9c7275275e19c4299_0","target":0}
{"code":"static inline void init_get_bits(GetBitContext*s, const uint8_t*buffer, int bit_size){int buffer_size=(bit_size+7)>>3;if(buffer_size<0 || bit_size<0){buffer_size=bit_size=0;buffer=NULL;}s->buffer=buffer;s->size_in_bits=bit_size;#if!UNCHECKED_BITSTREAM_READER\n    s->size_in_bits_plus8=bit_size+8;#endif\n    s->buffer_end=buffer+buffer_size;s->index=0;}","idx":"libav_ce8867a53583ae0c3ee8429342f33cf95a728660_1","target":1}
{"code":"void gdi_Bitmap_Decompress(rdpContext*context, rdpBitmap*bitmap, uint8*data, int width, int height, int bpp, int length, boolean compressed){uint16 size;size=width*height*(bpp+7)\/8;if(bitmap->data == NULL)bitmap->data=(uint8*)xmalloc(size);else\n\t\tbitmap->data=(uint8*)xrealloc(bitmap->data, size);if(compressed){boolean status;status=bitmap_decompress(data, bitmap->data, width, height, length, bpp, bpp);if(status != true){printf(\"Bitmap Decompression Failed\\n\");}}else{freerdp_image_flip(data, bitmap->data, width, height, bpp);}bitmap->width=width;bitmap->height=height;bitmap->compressed=false;bitmap->length=size;bitmap->bpp=bpp;}","idx":"freerdp-1.0.2-2","target":1}
{"code":"void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size) {\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n    if (!mr) return;\n    isa_mmio_setup(mr, size);\n    if (!memory_region_add_subregion(get_system_memory(), base, mr)) {\n        g_free(mr);\n        return;\n    }\n}","idx":"a8170e5e97ad17ca169c64ba87ae2f53850dab4c","target":0}
{"code":"static int config_input(AVFilterLink*inlink){HQDN3DContext*s=inlink->dst->priv;const AVPixFmtDescriptor*desc=av_pix_fmt_desc_get(inlink->format);int i;s->hsub=desc->log2_chroma_w;s->vsub=desc->log2_chroma_h;s->depth=desc->comp[0].depth_minus1+1;s->line=av_malloc(inlink->w*sizeof(*s->line));if(!s->line)return AVERROR(ENOMEM);for(i=0;i<4;i++){s->coefs[i]=precalc_coefs(s->strength[i], s->depth);if(!s->coefs[i])return AVERROR(ENOMEM);}if(ARCH_X86)ff_hqdn3d_init_x86(s);return 0;}","idx":"3ba35a346cd2ee86fff83a0d0534e8a2265984fd","target":1}
{"code":"static void m68k_cpu_realizefn(DeviceState*dev, Error**errp){M68kCPU*cpu=M68K_CPU(dev);M68kCPUClass*mcc=M68K_CPU_GET_CLASS(dev);m68k_cpu_init_gdb(cpu);cpu_reset(CPU(cpu));mcc->parent_realize(dev, errp);}","idx":"14a10fc39923b3af07c8c46d22cb20843bee3a72","target":1}
{"code":"template<typename T>\nT* grzeroalloc(size_t n) {\n#ifdef GRAPHITE2_TELEMETRY\ntelemetry::count_bytes(sizeof(T) * n);\n#endif \nif (n && sizeof(T) >= SIZE_MAX \/ n) return nullptr;\nreturn static_cast<T*>(calloc(n, sizeof(T)));\n}","idx":"graphite2-1.3.5-0","target":0}
{"code":"static void usb_hid_changed(HIDState *hs) {\n    if (!hs) return;\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n    us->changed = 1;\n    if (us->datain) {\n        if (us->datain) us->datain(us->datain_opaque);\n    }\n    usb_wakeup(&us->dev);\n}","idx":"38931fa8cfb074a08ce65fd1982bd4a5bef9d6fb","target":0}
{"code":"static unsigned char*print(const cJSON*const item, cJSON_bool format, const internal_hooks*const hooks){static const size_t default_buffer_size=256;printbuffer buffer[1];unsigned char*printed=NULL;memset(buffer, 0, sizeof(buffer));buffer->buffer=(unsigned char*)hooks->allocate(default_buffer_size);buffer->length=default_buffer_size;buffer->format=format;buffer->hooks=*hooks;if(buffer->buffer == NULL){goto fail;}if(!print_value(item, buffer)){goto fail;}update_offset(buffer);if(hooks->reallocate != NULL){printed=(unsigned char*)hooks->reallocate(buffer->buffer, buffer->offset+1);buffer->buffer=NULL;if(printed == NULL){goto fail;}}else{printed=(unsigned char*)hooks->allocate(buffer->offset+1);if(printed == NULL){goto fail;}memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset+1));printed[buffer->offset]='\\0';\n        hooks->deallocate(buffer->buffer);}return printed;fail:\n    if(buffer->buffer != NULL){hooks->deallocate(buffer->buffer);}if(printed != NULL){hooks->deallocate(printed);}return NULL;}","idx":"cjson-v.1.7.2-0","target":1}
{"code":"MigrationState*tcp_start_outgoing_migration(Monitor*mon, const char*host_port, int64_t bandwidth_limit, int detach, int blk, int inc){struct sockaddr_in addr;FdMigrationState*s;int ret;if(parse_host_port(&addr, host_port)<0)return NULL;s=qemu_mallocz(sizeof(*s));s->get_error=socket_errno;s->write=socket_write;s->close=tcp_close;s->mig_state.cancel=migrate_fd_cancel;s->mig_state.get_status=migrate_fd_get_status;s->mig_state.release=migrate_fd_release;s->mig_state.blk=blk;s->mig_state.shared=inc;s->state=MIG_STATE_ACTIVE;s->mon=NULL;s->bandwidth_limit=bandwidth_limit;s->fd=socket(PF_INET, SOCK_STREAM, 0);if(s->fd == -1){qemu_free(s);return NULL;}socket_set_nonblock(s->fd);if(!detach){migrate_fd_monitor_suspend(s, mon);}do{ret=connect(s->fd, (struct sockaddr*)&addr, sizeof(addr));if(ret == -1)ret=-(s->get_error(s));if(ret == -EINPROGRESS || ret == -EWOULDBLOCK)qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);}while(ret == -EINTR);if(ret<0 && ret != -EINPROGRESS && ret != -EWOULDBLOCK){dprintf(\"connect failed\\n\");close(s->fd);qemu_free(s);return NULL;}else if(ret >= 0)migrate_fd_connect(s);return&s->mig_state;}","idx":"40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4","target":1}
{"code":"static void ide_set_signature(IDEState *s) {\n    if (s == NULL) return;\n    s->select &= 0xf0;\n    s->nsector = 1;\n    s->sector = 1;\n    if (s->drive_kind == IDE_CD) {\n        s->lcyl = 0x14;\n        s->hcyl = 0xeb;\n    } else if (s->bs) {\n        s->lcyl = 0;\n        s->hcyl = 0;\n    } else {\n        s->lcyl = 0xff;\n        s->hcyl = 0xff;\n    }\n}","idx":"4be746345f13e99e468c60acbd3a355e8183e3ce","target":0}
{"code":"static void destroy_buffers(SANMVideoContext*ctx){av_freep(&ctx->frm0);av_freep(&ctx->frm1);av_freep(&ctx->frm2);av_freep(&ctx->stored_frame);av_freep(&ctx->rle_buf);ctx->frm0_size=ctx->frm1_size=ctx->frm2_size=0;}","idx":"39bbdebb1ed8eb9c9b0cd6db85afde6ba89d86e4","target":1}
{"code":"String StringUtil::Implode(const Variant&items, const String&delim, const bool checkIsContainer){if(checkIsContainer && !isContainer(items)){throw_param_is_not_container();}int size=getContainerSize(items);if(size == 0)return empty_string();String*sitems=(String*)req::malloc(size*sizeof(String));int len=0;int lenDelim=delim.size();int i=0;for(ArrayIter iter(items);iter;++iter){new(&sitems[i])String(iter.second().toString());len+=sitems[i].size()+lenDelim;i++;}len-=lenDelim;assert(i == size);String s=String(len, ReserveString);char*buffer=s.mutableData();const char*sdelim=delim.data();char*p=buffer;String&init_str=sitems[0];int init_len=init_str.size();memcpy(p, init_str.data(), init_len);p+=init_len;sitems[0].~String();for(int i=1;i<size;i++){String&item=sitems[i];memcpy(p, sdelim, lenDelim);p+=lenDelim;int lenItem=item.size();memcpy(p, item.data(), lenItem);p+=lenItem;sitems[i].~String();}req::free(sitems);assert(p-buffer == len);s.setSize(len);return s;}","idx":"hhvm-HHVM-3.12.10-1","target":1}
{"code":"long do_sigreturn(CPUM68KState*env){\n    struct target_sigframe*frame;\n    abi_ulong frame_addr=env->aregs[7]-4;\n    target_sigset_t target_set;\n    sigset_t set;\n    int d0, i;\n    if(!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n        goto badframe;\n    if(__get_user(target_set.sig[0], &frame->sc.sc_mask))\n        goto badframe;\n    for(i=1;i<TARGET_NSIG_WORDS && i < sizeof(target_set.sig)\/sizeof(target_set.sig[0]);i++){\n        if(__get_user(target_set.sig[i], &frame->extramask[i-1]))\n            goto badframe;\n    }\n    target_to_host_sigset_internal(&set, &target_set);\n    sigprocmask(SIG_SETMASK, &set, NULL);\n    if(restore_sigcontext(env, &frame->sc, &d0))\n        goto badframe;\n    unlock_user_struct(frame, frame_addr, 0);\n    return d0;\nbadframe:\n    unlock_user_struct(frame, frame_addr, 0);\n    force_sig(TARGET_SIGSEGV);\n    return 0;\n}","idx":"1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3","target":0}
{"code":"static void blend_frame(AVFilterContext*ctx, AVFrame*top_buf, AVFrame*bottom_buf, AVFrame*dst_buf){BlendContext*b=ctx->priv;AVFilterLink*inlink=ctx->inputs[0];FilterParams*param;int plane;for(plane=0;dst_buf->data[plane];plane++){int hsub=plane == 1 || plane == 2 ? b->hsub : 0;int vsub=plane == 1 || plane == 2 ? b->vsub : 0;int outw=dst_buf->width>>hsub;int outh=dst_buf->height>>vsub;uint8_t*dst=dst_buf->data[plane];uint8_t*top=top_buf->data[plane];uint8_t*bottom=bottom_buf->data[plane];param=&b->params[plane];param->values[VAR_N]=inlink->frame_count;param->values[VAR_T]=dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts*av_q2d(inlink->time_base);param->values[VAR_W]=outw;param->values[VAR_H]=outh;param->values[VAR_SW]=outw\/dst_buf->width;param->values[VAR_SH]=outh\/dst_buf->height;param->blend(top, top_buf->linesize[plane], bottom, bottom_buf->linesize[plane], dst, dst_buf->linesize[plane], outw, outh, param);}}","idx":"ffmpeg_b73cbc53fdfe4f35f2d5baea64c1d5c879f37aee_1","target":1}
{"code":"static void v4l2_free_buffer(void*opaque, uint8_t*unused){\n    V4L2Buffer*avbuf=opaque;\n    V4L2m2mContext*s=buf_to_m2mctx(avbuf);\n    if(atomic_fetch_sub(&avbuf->context_refcount, 1) == 1){\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n        if(s->reinit){\n            if(!atomic_load(&s->refcount))\n                sem_post(&s->refsync);\n        } else if(avbuf->context->streamon)\n            ff_v4l2_buffer_enqueue(avbuf);\n        av_buffer_unref(&avbuf->context_ref);\n    }\n}","idx":"5d5de3eba4c7890c2e8077f5b4ae569671d11cf8","target":0}
{"code":"AP_DECLARE(char*)ap_field_noparam(apr_pool_t*p, const char*intype){\n    const char*semi;\n    if(intype == NULL)\n        return NULL;\n    semi=ap_strchr_c(intype, ';');\n    if(semi == NULL){\n        return apr_pstrdup(p, intype);\n    }else{\n        while((semi>intype) && apr_isspace(semi[-1])){\n            semi--;\n        }\n        return apr_pstrndup(p, intype, semi-intype);\n    }\n}","idx":"httpd_b7f6b9ef9951e2fc956040d0e6b9e65359899ef7_0","target":0}
{"code":"void gicv3_cpuif_update(GICv3CPUState*cs){int irqlevel=0;int fiqlevel=0;ARMCPU*cpu=ARM_CPU(cs->cpu);CPUARMState*env=&cpu->env;trace_gicv3_cpuif_update(gicv3_redist_affid(cs), cs->hppi.irq, cs->hppi.grp, cs->hppi.prio);if(cs->hppi.grp == GICV3_G1 && !arm_feature(env, ARM_FEATURE_EL3)){cs->hppi.grp=GICV3_G0;}if(icc_hppi_can_preempt(cs)){bool isfiq;switch(cs->hppi.grp){case GICV3_G0:\n            isfiq=true;break;case GICV3_G1:\n            isfiq=(!arm_is_secure(env) || (arm_current_el(env) == 3 && arm_el_is_aa64(env, 3)));break;case GICV3_G1NS:\n            isfiq=arm_is_secure(env);break;default:\n            g_assert_not_reached();}if(isfiq){fiqlevel=1;}else{irqlevel=1;}}trace_gicv3_cpuif_set_irqs(gicv3_redist_affid(cs), fiqlevel, irqlevel);qemu_set_irq(cs->parent_fiq, fiqlevel);qemu_set_irq(cs->parent_irq, irqlevel);}","idx":"8d04fb55dec381bc5105cb47f29d918e579e8cbd","target":1}
{"code":"void*av_realloc(void*ptr, size_t size){#if CONFIG_MEMALIGN_HACK\n    int diff;#endif\n    if(size>(INT_MAX-16))return NULL;#if CONFIG_MEMALIGN_HACK\n    if(!ptr)return av_malloc(size);diff=((char*)ptr)[-1];return(char*)realloc((char*)ptr-diff, size+diff)+diff;#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size, 32);#else\n    return realloc(ptr, size);#endif}","idx":"libav_727640fec3cec9b3cb655b1a6dab306bc6234f7a_1","target":1}
{"code":"static int decode_blocks(SnowContext*s){int x, y;int w=s->b_width;int h=s->b_height;int res;for(y=0;y<h;y++){for(x=0;x<w;x++){if((res=decode_q_branch(s, 0, x, y))<0)return res;}}return 0;}","idx":"4527ec2216109867498edc3ac8a17fd879b5d017","target":1}
{"code":"static int BitBlt_SRCCOPY_8bpp(HGDI_DC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HGDI_DC hdcSrc, int nXSrc, int nYSrc){int y;uint8*srcp;uint8*dstp;if((hdcDest->selectedObject != hdcSrc->selectedObject) || gdi_CopyOverlap(nXDest, nYDest, nWidth, nHeight, nXSrc, nYSrc) == 0){for(y=0;y<nHeight;y++){srcp=gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc+y);dstp=gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest+y);if(srcp != 0 && dstp != 0)memcpy(dstp, srcp, nWidth*hdcDest->bytesPerPixel);}return 0;}if(nYSrc<nYDest){for(y=nHeight-1;y >= 0;y--){srcp=gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc+y);dstp=gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest+y);if(srcp != 0 && dstp != 0)memmove(dstp, srcp, nWidth*hdcDest->bytesPerPixel);}}else if(nYSrc>nYDest || nXSrc>nXDest){for(y=0;y<nHeight;y++){srcp=gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc+y);dstp=gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest+y);if(srcp != 0 && dstp != 0)memmove(dstp, srcp, nWidth*hdcDest->bytesPerPixel);}}else{for(y=0;y<nHeight;y++){srcp=gdi_get_bitmap_pointer(hdcSrc, nXSrc, nYSrc+y);dstp=gdi_get_bitmap_pointer(hdcDest, nXDest, nYDest+y);if(srcp != 0 && dstp != 0)memmove(dstp, srcp, nWidth*hdcDest->bytesPerPixel);}}return 0;}","idx":"freerdp-1.0.2-1","target":1}
{"code":"void gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap, uint8* data, int width, int height, int bpp, int length, boolean compressed) {\n    uint32 size;\n    if (width <= 0 || height <= 0 || bpp <= 0) return;\n    if ((uint64)width * (uint64)height * ((uint64)bpp + 7) \/ 8 > UINT32_MAX) return;\n    size = (uint32)width * (uint32)height * ((uint32)bpp + 7) \/ 8;\n    if (bitmap->data == NULL) {\n        bitmap->data = (uint8*)xmalloc(size);\n        if (bitmap->data == NULL) return;\n    } else {\n        bitmap->data = (uint8*)xrealloc(bitmap->data, size);\n        if (bitmap->data == NULL) return;\n    }\n    if (compressed) {\n        boolean status;\n        status = bitmap_decompress(data, bitmap->data, width, height, length, bpp, bpp);\n        if (status != true) {\n            printf(\"Bitmap Decompression Failed\\n\");\n        }\n    } else {\n        freerdp_image_flip(data, bitmap->data, width, height, bpp);\n    }\n    bitmap->width = width;\n    bitmap->height = height;\n    bitmap->compressed = false;\n    bitmap->length = size;\n    bitmap->bpp = bpp;\n}","idx":"freerdp-1.0.2-2","target":0}
{"code":"static CURLcode tftp_connect(struct connectdata *conn, bool *done) {\n    tftp_state_data_t *state;\n    int blksize;\n    blksize = TFTP_BLKSIZE_DEFAULT;\n    state = conn->proto.tftpc = calloc(1, sizeof(tftp_state_data_t));\n    if (!state) return CURLE_OUT_OF_MEMORY;\n    if (conn->data->set.tftp_blksize) {\n        blksize = (int)conn->data->set.tftp_blksize;\n        if (blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN) {\n            free(state);\n            return CURLE_TFTP_ILLEGAL;\n        }\n    }\n    if (!state->rpacket.data) {\n        state->rpacket.data = calloc(1, blksize + 2 + 2);\n        if (!state->rpacket.data) {\n            free(state);\n            return CURLE_OUT_OF_MEMORY;\n        }\n    }\n    if (!state->spacket.data) {\n        state->spacket.data = calloc(1, blksize + 2 + 2);\n        if (!state->spacket.data) {\n            free(state->rpacket.data);\n            free(state);\n            return CURLE_OUT_OF_MEMORY;\n        }\n    }\n}","idx":"curl-curl-7_61_1-0","target":0}
{"code":"static int decode_interrupt_cb(void*ctx){return received_nb_signals>transcode_init_done;}","idx":"76d8c77430e9e0110623705bfb54d922cc2ac3ea","target":1}
{"code":"static String HHVM_FUNCTION(bcadd, const String& left, const String& right, int64_t scale) {\n    if (scale < 0) scale = BCG(bc_precision);\n    bc_num first, second, result;\n    bc_init_num(&first);\n    bc_init_num(&second);\n    bc_init_num(&result);\n    php_str2num(&first, (char*)left.substr(0, MAX_NUM_SIZE).data());\n    php_str2num(&second, (char*)right.substr(0, MAX_NUM_SIZE).data());\n    bc_add(first, second, &result, scale);\n    if (result->n_scale > scale) {\n        result->n_scale = scale;\n    }\n    String ret(bc_num2str(result), AttachString);\n    bc_free_num(&first);\n    bc_free_num(&second);\n    bc_free_num(&result);\n    return ret;\n}","idx":"hhvm-HHVM-3.12.10-0","target":0}
{"code":"DVMuxContext*dv_init_mux(AVFormatContext*s){DVMuxContext*c;AVStream*vst=NULL;int i;if(s->nb_streams>3)return NULL;c=av_mallocz(sizeof(DVMuxContext));if(!c)return NULL;c->n_ast=0;c->ast[0]=c->ast[1]=NULL;for(i=0;i<s->nb_streams;i++){switch(s->streams[i]->codec->codec_type){case CODEC_TYPE_VIDEO:\n               vst=s->streams[i];break;case CODEC_TYPE_AUDIO:\n             c->ast[c->n_ast++]=s->streams[i];break;default:\n               goto bail_out;}}if(!vst || vst->codec->codec_id != CODEC_ID_DVVIDEO)goto bail_out;for(i=0;i<c->n_ast;i++){if(c->ast[i] && (c->ast[i]->codec->codec_id != CODEC_ID_PCM_S16LE || c->ast[i]->codec->sample_rate != 48000 || c->ast[i]->codec->channels != 2))goto bail_out;}c->sys=dv_codec_profile(vst->codec);if(!c->sys)goto bail_out;if((c->n_ast>1) && (c->sys->n_difchan<2)){goto bail_out;}c->frames=0;c->has_audio=0;c->has_video=0;c->start_time=(time_t)s->timestamp;for(i=0;i<c->n_ast;i++){if(c->ast[i] && av_fifo_init(&c->audio_data[i], 100*AVCODEC_MAX_AUDIO_FRAME_SIZE)<0){while(i>0){i--;av_fifo_free(&c->audio_data[i]);}goto bail_out;}}return c;bail_out:\n    av_free(c);return NULL;}","idx":"0008afc59c240271827d8a0fc747179da905050f","target":1}
{"code":"void arrayCopy(Thread*t, object src, int32_t srcOffset, object dst, int32_t dstOffset, int32_t length){if(LIKELY(src and dst)){if(LIKELY(compatibleArrayTypes(t, objectClass(t, src), objectClass(t, dst)))){unsigned elementSize=objectClass(t, src)->arrayElementSize();if(LIKELY(elementSize)){intptr_t sl=fieldAtOffset<uintptr_t>(src, BytesPerWord);intptr_t dl=fieldAtOffset<uintptr_t>(dst, BytesPerWord);if(LIKELY(length>0)){if(LIKELY(srcOffset >= 0 and srcOffset+length <= sl\n                     and dstOffset >= 0 and dstOffset+length <= dl)){uint8_t*sbody=&fieldAtOffset<uint8_t>(src, ArrayBody);uint8_t*dbody=&fieldAtOffset<uint8_t>(dst, ArrayBody);if(src == dst){memmove(dbody+(dstOffset*elementSize), sbody+(srcOffset*elementSize), length*elementSize);}else{memcpy(dbody+(dstOffset*elementSize), sbody+(srcOffset*elementSize), length*elementSize);}if(objectClass(t, dst)->objectMask()){mark(t, dst, ArrayBody+(dstOffset*BytesPerWord), length);}return;}else{throwNew(t, GcIndexOutOfBoundsException::Type);}}else{return;}}}}else{throwNew(t, GcNullPointerException::Type);return;}throwNew(t, GcArrayStoreException::Type);}","idx":"avian-v1.2.0-0","target":1}
{"code":"static int mov_write_minf_tag(AVIOContext*pb, MOVMuxContext*mov, MOVTrack*track){\n    if (!pb || !mov || !track || !track->enc) return -1;\n    int64_t pos=avio_tell(pb);\n    int ret;\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"minf\");\n    if(track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n        mov_write_vmhd_tag(pb);\n    else if(track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n        mov_write_smhd_tag(pb);\n    else if(track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE){\n        if(track->tag == MKTAG('t', 'e', 'x', 't') || is_clcp_track(track)){\n            mov_write_gmhd_tag(pb, track);\n        }else{\n            mov_write_nmhd_tag(pb);\n        }\n    }\n    else if(track->tag == MKTAG('r', 't', 'p', ' ')){\n        mov_write_hmhd_tag(pb);\n    }\n    else if(track->tag == MKTAG('t', 'm', 'c', 'd')){\n        mov_write_gmhd_tag(pb, track);\n    }\n    if(track->mode == MODE_MOV)\n        mov_write_hdlr_tag(pb, NULL);\n    mov_write_dinf_tag(pb);\n    if((ret=mov_write_stbl_tag(pb, mov, track))<0)\n        return ret;\n    return update_size(pb, pos);\n}","idx":"b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea","target":0}
{"code":"int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t*src_buf, size_t buf_size){\n    cl_int status;\n    void*mapped=clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf, CL_TRUE, CL_MAP_WRITE, 0, buf_size, 0, NULL, NULL, &status);\n    if(status != CL_SUCCESS){\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer:%s\\n\", opencl_errstr(status));\n        return AVERROR_EXTERNAL;\n    }\n    memcpy(mapped, src_buf, buf_size);\n    status=clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n    if(status != CL_SUCCESS){\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer:%s\\n\", opencl_errstr(status));\n        return AVERROR_EXTERNAL;\n    }\n    return 0;\n}","idx":"57d77b3963ce1023eaf5ada8cba58b9379405cc8","target":0}
{"code":"void ap_init_scoreboard(void*shared_score){\n    char*more_storage;\n    int i;\n    ap_calc_scoreboard_size();\n    ap_scoreboard_image=calloc(1, sizeof(scoreboard)+server_limit*sizeof(worker_score*)+server_limit*lb_limit*sizeof(lb_score*));\n    if (!ap_scoreboard_image) return;\n    more_storage=shared_score;\n    if (!more_storage) return;\n    ap_scoreboard_image->global=(global_score*)more_storage;\n    more_storage+=sizeof(global_score);\n    ap_scoreboard_image->parent=(process_score*)more_storage;\n    more_storage+=sizeof(process_score)*server_limit;\n    ap_scoreboard_image->servers=(worker_score**)((char*)ap_scoreboard_image+sizeof(scoreboard));\n    for(i=0;i<server_limit;i++){\n        ap_scoreboard_image->servers[i]=(worker_score*)more_storage;\n        more_storage+=thread_limit*sizeof(worker_score);\n    }\n    if(lb_limit){\n        ap_scoreboard_image->balancers=(lb_score*)more_storage;\n        more_storage+=lb_limit*sizeof(lb_score);\n    }\n    ap_assert(more_storage == (char*)shared_score+scoreboard_size);\n    ap_scoreboard_image->global->server_limit=server_limit;\n    ap_scoreboard_image->global->thread_limit=thread_limit;\n    ap_scoreboard_image->global->lb_limit=lb_limit;\n}","idx":"httpd_edfecb64c8e7f169c3d396a0cc12da4baf41f6a8_0","target":0}
{"code":"static int truespeech_decode_frame(AVCodecContext*avctx, void*data, int*data_size, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    TSContext*c=avctx->priv_data;\n    int i, j;\n    short*samples=data;\n    int consumed=0;\n    int16_t out_buf[240];\n    int iterations;\n    if(!buf_size)return 0;\n    if(buf_size<32){\n        av_log(avctx, AV_LOG_ERROR, \"Too small input buffer(%d bytes), need at least 32 bytes\\n\", buf_size);\n        return-1;\n    }\n    iterations=FFMIN(buf_size\/32, *data_size\/480);\n    if (*data_size < iterations * 480) {\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer too small (%d bytes), need at least %d bytes\\n\", *data_size, iterations * 480);\n        return -1;\n    }\n    for(j=0;j<iterations;j++){\n        truespeech_read_frame(c, buf+consumed);\n        consumed+=32;\n        truespeech_correlate_filter(c);\n        truespeech_filters_merge(c);\n        memset(out_buf, 0, 240*2);\n        for(i=0;i<4;i++){\n            truespeech_apply_twopoint_filter(c, i);\n            truespeech_place_pulses(c, out_buf+i*60, i);\n            truespeech_update_filters(c, out_buf+i*60, i);\n            truespeech_synth(c, out_buf+i*60, i);\n        }\n        truespeech_save_prevvec(c);\n        for(i=0;i<240;i++)*samples++=out_buf[i];\n    }\n    *data_size=consumed*15;\n    return consumed;\n}","idx":"595cf1a1aa09f6214eed57bd9eb6493456918efe","target":0}
{"code":"INLINE void gdi_RectToCRgn(HGDI_RECT rect, int*x, int*y, int*w, int*h){if(rect && x && y && w && h){*x=rect->left;*y=rect->top;*w=abs(rect->right-rect->left)+1;*h=abs(rect->bottom-rect->top)+1;}}","idx":"freerdp-1.0.2-0","target":0}
{"code":"static int mov_text_decode_close(AVCodecContext*avctx){MovTextContext*m=avctx->priv_data;mov_text_cleanup_ftab(m);return 0;}","idx":"a9f9b7f5c70e80245983e67b8ed23212d9637645","target":1}
{"code":"void PEM_dek_info(char*buf, const char*type, int len, char*str){static const unsigned char map[17]=\"0123456789ABCDEF\";\n\tlong i;int j;strcat(buf, \"DEK-Info: \");strcat(buf, type);strcat(buf, \", \");j=strlen(buf);for(i=0;i<len;i++){buf[j+i*2]=map[(str[i]>>4)&0x0f];buf[j+i*2+1]=map[(str[i])&0x0f];}buf[j+i*2]='\\n';\n\tbuf[j+i*2+1]='\\0';}","idx":"openssl_af7e41d654be6c9d590ab32d8a62e865ce153973_1","target":1}
