{"idx": "CWE-787-safe-1714251291220", "code": "int curl_mvsprintf(char* buffer, const char* format, va_list ap_save) {\n    int retcode;\n    retcode = vsnprintf(buffer, BUFFER_SIZE, format, ap_save);\n    buffer[BUFFER_SIZE - 1] = '\\0';\n    return retcode;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251291220", "code": "int curl_mvsprintf(char* buffer, const char* format, va_list ap_save) {\n    int retcode;\n    retcode = vsnprintf(buffer, BUFFER_SIZE, format, ap_save);\n    buffer[BUFFER_SIZE] = '\\0';\n    return retcode;\n}", "target": 1}
{"idx": "CWE-787-safe-1714251299827", "code": "char* curl_mvaprintf(const char* format, va_list ap_save) {\n    int retcode;\n    struct asprintf info;\n    va_list ap;\n    va_copy(ap, ap_save);\n    info.buffer = NULL;\n    info.len = 0;\n    info.alloc = 0;\n    info.fail = 0;\n    retcode = dprintf_formatf(&info, alloc_addbyter, format, ap);\n    va_end(ap);\n    if ((-1 == retcode) || info.fail) {\n        if (info.alloc)\n            free(info.buffer);\n        return NULL;\n    }\n    if (info.alloc) {\n        info.buffer[info.len] = 0;\n        return info.buffer;\n    } else {\n        char* empty_str = strdup(\"\");\n        if (!empty_str) {\n            return NULL;\n        }\n        return empty_str;\n    }\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251299827", "code": "char* curl_mvaprintf(const char* format, va_list ap_save) {\n    int retcode;\n    struct asprintf info;\n    va_list ap;\n    va_copy(ap, ap_save);\n    info.buffer = NULL;\n    info.len = 0;\n    info.alloc = 0;\n    info.fail = 0;\n    retcode = dprintf_formatf(&info, alloc_addbyter, format, ap);\n    va_end(ap);\n    if ((-1 == retcode) || info.fail) {\n        if (info.alloc)\n            free(info.buffer);\n        return NULL;\n    }\n    if (info.alloc) {\n        info.buffer[info.len + 1] = 0;  \n        return info.buffer;\n    } else {\n        char* empty_str = strdup(\"\");\n        if (!empty_str) {\n            return NULL;\n        }\n        return empty_str;\n    }\n}", "target": 1}
{"idx": "CWE-787-safe-1714251337218", "code": "int curl_mvsnprintf(char* buffer, size_t maxlength, const char* format, va_list ap_save) {\n    int retcode;\n    struct nsprintf info;\n    info.buffer = buffer;\n    info.length = 0;\n    info.max = maxlength;\n    retcode = dprintf_formatf(&info, addbyter, format, ap_save);\n    if ((retcode != -1) && info.max) {\n        if (info.length >= info.max)\n            info.buffer[info.max - 1] = 0;\n        else \n            info.buffer[info.length] = 0;\n    }\n    return retcode;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251337218", "code": "int curl_mvsnprintf(char* buffer, size_t maxlength, const char* format, va_list ap_save) {\n    int retcode;\n    struct nsprintf info;\n    info.buffer = buffer;\n    info.length = 0;\n    info.max = maxlength;\n    retcode = dprintf_formatf(&info, addbyter, format, ap_save);\n    if ((retcode != -1) && info.max) {\n        if (info.length >= info.max)\n            info.buffer[info.max] = 0;  \n        else \n            info.buffer[info.length] = 0;\n    }\n    return retcode;\n}", "target": 1}
{"idx": "CWE-787-safe-1714251366058", "code": "int curl_msprintf(char *buffer, const char *format, ...) {\n    va_list ap_save;\n    int retcode;\n    va_start(ap_save, format);\n    retcode = vsnprintf(buffer, sizeof(buffer), format, ap_save);\n    va_end(ap_save);\n    return retcode;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251366058", "code": "int curl_msprintf(char *buffer, const char *format, ...) {\n    va_list ap_save;\n    int retcode;\n    va_start(ap_save, format);\n    retcode = vsnprintf(buffer, 1024, format, ap_save);\n    va_end(ap_save);\n    return retcode;\n}", "target": 1}
{"idx": "CWE-787-safe-1714251382719", "code": "int curl_msnprintf(char* buffer, size_t maxlength, const char* format, ...) {\n    int retcode;\n    va_list ap_save, ap_copy;\n    va_start(ap_save, format);\n    va_copy(ap_copy, ap_save);\n    retcode = curl_mvsnprintf(buffer, maxlength, format, ap_copy);\n    va_end(ap_copy);\n    va_end(ap_save);\n    return retcode;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251382719", "code": "int curl_msnprintf(char* buffer, size_t maxlength, const char* format, ...) {\n    int retcode;\n    va_list ap_save, ap_copy;\n    va_start(ap_save, format);\n    va_copy(ap_copy, ap_save);\n    retcode = curl_mvsnprintf(buffer, maxlength + 1, format, ap_copy);\n    va_end(ap_copy);\n    va_end(ap_save);\n    return retcode;\n}", "target": 1}
{"idx": "CWE-787-safe-1714251396484", "code": "static int storebuffer(int output, char* data){unsigned char outc=(unsigned char)output;*data=outc;data++;return outc;}", "target": 0}
{"idx": "CWE-787-vuln-1714251396484", "code": "static int storebuffer(int output, char* data) {\n    unsigned char outc = (unsigned char)output;\n    *data = outc;\n    data++;\n    *data = outc;  \n    return outc;\n}", "target": 1}
{"idx": "CWE-787-safe-1714251412922", "code": "char* curl_maprintf(const char* format, ...) {\n    va_list ap_save;\n    int retcode;\n    struct asprintf info;\n    info.buffer = NULL;\n    info.len = 0;\n    info.alloc = 0;\n    info.fail = 0;\n    va_start(ap_save, format);\n    retcode = dprintf_formatf(&info, alloc_addbyter, format, ap_save);\n    va_end(ap_save);\n    if ((-1 == retcode) || info.fail) {\n        if (info.alloc)\n            free(info.buffer);\n        return NULL;\n    }\n    if (info.alloc) {\n        info.buffer[info.len] = 0;\n        return info.buffer;\n    } else {\n        char* empty_str = strdup(\"\");\n        if (!empty_str)\n            return NULL;\n        return empty_str;\n    }\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251412922", "code": "char* curl_maprintf(const char* format, ...) {\n    va_list ap_save;\n    int retcode;\n    struct asprintf info;\n    info.buffer = NULL;\n    info.len = 0;\n    info.alloc = 0;\n    info.fail = 0;\n    va_start(ap_save, format);\n    retcode = dprintf_formatf(&info, alloc_addbyter, format, ap_save);\n    va_end(ap_save);\n    if ((-1 == retcode) || info.fail) {\n        if (info.alloc)\n            free(info.buffer);\n        return NULL;\n    }\n    if (info.alloc) {\n        info.len++;\n        info.buffer[info.len] = 0;\n        return info.buffer;\n    } else {\n        char* empty_str = strdup(\"\");\n        if (!empty_str)\n            return NULL;\n        return empty_str;\n    }\n}", "target": 1}
{"idx": "CWE-125-safe-1714251433004", "code": "static long dprintf_DollarString(char* input, char** end) {\n    int number = 0;\n    while (ISDIGIT(*input)) {\n        int digit = *input - '0';\n        if (number > (INT_MAX - digit) / 10) {\n            break;\n        }\n        number = number * 10 + digit;\n        input++;\n    }\n    if (number && ('$' == *input++)) {\n        *end = input;\n        return number;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714251433004", "code": "static long dprintf_DollarString(char*input, char**end){int number=0;while(ISDIGIT(*input)){int digit=*input-'0';\n        if(number>(INT_MAX-digit)/10){break;}number=number*10+digit;input++;}input++;if(number && ('$' == *input)){*end=input;return number;}return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714251446250", "code": "static bool dprintf_IsQualifierNoDollar(const char* fmt) {\n    if (fmt == NULL) return FALSE;\n#   if defined(MP_HAVE_INT_EXTENSIONS)\n    if (!strncmp(fmt, \"I32\", 3) || !strncmp(fmt, \"I64\", 3)) {\n        return TRUE;\n    }\n#   endif \n    switch (*fmt) {\n    case '-': case '+': case ' ': case '#': case '.': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case 'h': case 'l': case 'L': case 'z': case 'q': case '*': case 'O': \n#       if defined(MP_HAVE_INT_EXTENSIONS)\n        case 'I': \n#       endif \n        return TRUE;\n    default: \n        return FALSE;\n    }\n}", "target": 0}
{"idx": "CWE-125-vuln-1714251446250", "code": "static bool dprintf_IsQualifierNoDollar(const char* fmt) {\n    if (fmt == NULL) return FALSE;\n#   if defined(MP_HAVE_INT_EXTENSIONS)\n    if (!strncmp(fmt, \"I32\", 3) || !strncmp(fmt, \"I64\", 3) || fmt[3] == '\\0') {\n        return TRUE;\n    }#   endif \n    switch(*fmt) {\n        case '-': case '+': case ' ': case '#': case '.': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case 'h': case 'l': case 'L': case 'z': case 'q': case '*': case 'O':\n#       if defined(MP_HAVE_INT_EXTENSIONS)case 'I':\n#       endif \n            return TRUE;\n        default:\n            return FALSE;\n    }\n}", "target": 1}
{"idx": "CWE-787-safe-1714251464826", "code": "static int alloc_addbyter(int output, FILE* data) {\n    struct asprintf* infop = (struct asprintf*)data;\n    unsigned char outc = (unsigned char)output;\n    if (!infop->buffer) {\n        infop->buffer = malloc(32);\n        if (!infop->buffer) {\n            infop->fail = 1;\n            return -1;\n        }\n        infop->alloc = 32;\n        infop->len = 0;\n    } else if (infop->len + 1 >= infop->alloc) {\n        char* newptr = NULL;\n        size_t newsize = infop->alloc * 2;\n        if (newsize < infop->alloc) {\n            infop->fail = 1;\n            return -1;\n        }\n        newptr = realloc(infop->buffer, newsize);\n        if (!newptr) {\n            infop->fail = 1;\n            return -1;\n        }\n        infop->buffer = newptr;\n        infop->alloc = newsize;\n    }\n    infop->buffer[infop->len] = outc;\n    infop->len++;\n    return outc;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251464826", "code": "static int alloc_addbyter(int output, FILE*data){struct asprintf*infop=(struct asprintf*)data;unsigned char outc=(unsigned char)output;if(!infop->buffer){infop->buffer=malloc(32);if(!infop->buffer){infop->fail=1;return-1;}infop->alloc=32;infop->len=0;}else if(infop->len+1 >= infop->alloc){char*newptr=NULL;size_t newsize=infop->alloc*2;if(newsize<infop->alloc){infop->fail=1;return-1;}newptr=realloc(infop->buffer, newsize);if(!newptr){infop->fail=1;return-1;}infop->buffer=newptr;infop->alloc=newsize;}infop->buffer[infop->len+1]=outc;infop->len++;return outc;}", "target": 1}
{"idx": "CWE-787-safe-1714251491670", "code": "static int addbyter(int output, FILE* data) {\n    struct nsprintf* infop = (struct nsprintf*)data;\n    unsigned char outc = (unsigned char)output;\n    if (infop->length < infop->max) {\n        infop->buffer[0] = outc;\n        infop->buffer++;\n        infop->length++;\n        return outc;\n    }\n    return -1;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251491670", "code": "static int addbyter(int output, FILE*data){struct nsprintf*infop=(struct nsprintf*)data;unsigned char outc=(unsigned char)output;if(infop->length<infop->max){infop->buffer[infop->length]=outc;infop->buffer++;infop->length++;return outc;}return-1;}", "target": 1}
{"idx": "CWE-416-safe-1714251507559", "code": "void jbig2_word_stream_buf_free(Jbig2Ctx*ctx, Jbig2WordStream*ws){if(ctx != NULL && ws != NULL) {jbig2_free(ctx->allocator, ws);}}", "target": 0}
{"idx": "CWE-416-vuln-1714251507559", "code": "void jbig2_word_stream_buf_free(Jbig2Ctx*ctx, Jbig2WordStream*ws){\n    if(ctx != NULL && ws != NULL){\n        jbig2_free(ctx->allocator, ws);\n        ws->length = 0; \n    }\n}", "target": 1}
{"idx": "CWE-416-safe-1714251517273", "code": "void jbig2_ctx_free(Jbig2Ctx *ctx) {\n    Jbig2Allocator *ca;\n    int i;\n    if (ctx == NULL) return;\n    ca = ctx->allocator;\n    if (ca == NULL) return;\n    jbig2_free(ca, ctx->buf);\n    if (ctx->segments != NULL) {\n        for (i = 0; i < ctx->n_segments; i++)\n            jbig2_free_segment(ctx, ctx->segments[i]);\n        jbig2_free(ca, ctx->segments);\n    }\n    if (ctx->pages != NULL) {\n        for (i = 0; i <= ctx->current_page; i++)\n            if (ctx->pages[i].image != NULL)\n                jbig2_image_release(ctx, ctx->pages[i].image);\n        jbig2_free(ca, ctx->pages);\n    }\n    jbig2_free(ca, ctx);\n}", "target": 0}
{"idx": "CWE-416-vuln-1714251517273", "code": "void jbig2_ctx_free(Jbig2Ctx*ctx){Jbig2Allocator*ca;int i;if(ctx == NULL)return;ca=ctx->allocator;if(ca == NULL)return;jbig2_free(ca, ctx->buf);if(ctx->segments != NULL){for(i=0;i<ctx->n_segments;i++)jbig2_free_segment(ctx, ctx->segments[i]);jbig2_free(ca, ctx->segments);}if(ctx->pages != NULL){for(i=0;i <= ctx->current_page;i++)if(ctx->pages[i].image != NULL)jbig2_image_release(ctx, ctx->pages[i].image);jbig2_free(ca, ctx->pages);}jbig2_free(ca, ctx);ctx->allocator = NULL;}", "target": 1}
{"idx": "CWE-190-safe-1714251534336", "code": "void*jbig2_realloc(Jbig2Allocator*allocator, void*p, size_t size, size_t num){\n    if(num>0 && size && SIZE_MAX / num < size) return NULL;\n    return allocator->realloc(allocator, p, size*num);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714251534336", "code": "void*jbig2_realloc(Jbig2Allocator*allocator, void*p, size_t size, size_t num){size_t total_size = size * num;if(num>0 && size && SIZE_MAX/num<size)return NULL;return allocator->realloc(allocator, p, total_size);}", "target": 1}
{"idx": "CWE-416-safe-1714251543560", "code": "static void *jbig2_default_realloc(Jbig2Allocator *allocator, void *p, size_t size) {\n    if (size == 0) {\n        free(p);\n        return NULL;\n    }\n    return realloc(p, size);\n}", "target": 0}
{"idx": "CWE-416-vuln-1714251543560", "code": "static void *jbig2_default_realloc(Jbig2Allocator *allocator, void *p, size_t size) {\n    if (size == 0) {\n        free(p);\n        return realloc(p, size);\n    }\n    return realloc(p, size);\n}", "target": 1}
{"idx": "CWE-843-safe-1714251557150", "code": "Jbig2GlobalCtx* jbig2_make_global_ctx(Jbig2Ctx* ctx) {\n    return (Jbig2GlobalCtx*)ctx;\n}", "target": 0}
{"idx": "CWE-843-vuln-1714251557150", "code": "Jbig2GlobalCtx*jbig2_make_global_ctx(Jbig2Ctx*ctx){return(Jbig2GlobalCtx*)ctx;}", "target": 1}
{"idx": "CWE-416-safe-1714251565454", "code": "void jbig2_global_ctx_free(Jbig2GlobalCtx*global_ctx){jbig2_ctx_free((Jbig2Ctx*)global_ctx);}", "target": 0}
{"idx": "CWE-416-vuln-1714251565454", "code": "void jbig2_global_ctx_free(Jbig2GlobalCtx*global_ctx){\n    jbig2_ctx_free((Jbig2Ctx*)global_ctx);\n    jbig2_ctx_free((Jbig2Ctx*)global_ctx);\n}", "target": 1}
{"idx": "CWE-125-safe-1714251579145", "code": "static int jbig2_word_stream_buf_get_next_word(Jbig2WordStream*self, size_t offset, uint32_t*word){Jbig2WordStreamBuf*z=(Jbig2WordStreamBuf*)self;const byte*data=z->data;uint32_t result;if(offset+4<=z->size)result=(data [ offset ]<<24)|(data [ offset+1 ]<<16)|(data [ offset+2 ]<<8)|data [ offset+3 ];else if(offset>=z->size)return-1;else{size_t i;result=0;for(i=0;i<z->size-offset;i++)result|=data [ offset+i ]<<((3-i)<<3);}*word=result;return 0;}", "target": 0}
{"idx": "CWE-125-vuln-1714251579145", "code": "static int jbig2_word_stream_buf_get_next_word(Jbig2WordStream*self, size_t offset, uint32_t*word){Jbig2WordStreamBuf*z=(Jbig2WordStreamBuf*)self;const byte*data=z->data;uint32_t result;if(offset+4 <= z->size)result=(data [ offset ]<<24)|(data [ offset+1 ]<<16)|(data [ offset+2 ]<<8)|data [ offset+3 ];else if(offset >= z->size)return-1;else{size_t i;result=0;for(i=0;i<=z->size-offset;i++)result|=data [ offset+i ]<<((3-i)<<3);}*word=result;return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714251593611", "code": "uint32_t jbig2_get_uint32(const byte *bptr) {\n    if (bptr == NULL) {\n        return 0;\n    }\n    return ((uint32_t)get_uint16(bptr) << 16) | get_uint16(bptr + 2);\n}", "target": 0}
{"idx": "CWE-125-vuln-1714251593611", "code": "uint32_t jbig2_get_uint32(const byte *bptr) {\n    if (bptr == NULL) {\n        return 0;\n    }\n    return ((uint32_t)get_uint16(bptr) << 16) | get_uint16(bptr + 3);\n}", "target": 1}
{"idx": "CWE-787-safe-1714251603390", "code": "void*jbig2_alloc(Jbig2Allocator*allocator, size_t size, size_t num){\n    if(num>0 && size >= (size_t)-0x100/num)return NULL;\n    return allocator->alloc(allocator, size*num);\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251603390", "code": "void*jbig2_alloc(Jbig2Allocator*allocator, size_t size, size_t num){if(num>0 && size >= (size_t)-0x100/num)return NULL;return allocator->alloc(allocator, size*(num+1));}", "target": 1}
{"idx": "CWE-416-safe-1714251615418", "code": "void jbig2_free(Jbig2Allocator *allocator, void *p) {\n    if (allocator != NULL && p != NULL) {\n        allocator->free(allocator, p);\n    }\n}", "target": 0}
{"idx": "CWE-416-vuln-1714251615418", "code": "void jbig2_free(Jbig2Allocator*allocator, void*p){\n    if(allocator != NULL && p != NULL){\n        allocator->free(allocator, p);\n        *((int*)p) = 0;  \n    }\n}", "target": 1}
{"idx": "CWE-416-safe-1714251628256", "code": "Jbig2WordStream *jbig2_word_stream_buf_new(Jbig2Ctx *ctx, const byte *data, size_t size) {\n    if (data == NULL || size == 0) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"Null data pointer or zero size in jbig2_word_stream_buf_new\");\n        return NULL;\n    }\n    Jbig2WordStreamBuf *result = jbig2_new(ctx, Jbig2WordStreamBuf, 1);\n    if (result == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate Jbig2WordStreamBuf in jbig2_word_stream_buf_new\");\n        return NULL;\n    }\n    result->super.get_next_word = jbig2_word_stream_buf_get_next_word;\n    result->data = data;\n    result->size = size;\n    return &result->super;\n}", "target": 0}
{"idx": "CWE-416-vuln-1714251628256", "code": "Jbig2WordStream*jbig2_word_stream_buf_new(Jbig2Ctx*ctx, const byte*data, size_t size){if(data == NULL || size == 0){jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"Null data pointer or zero size in jbig2_word_stream_buf_new\");return NULL;}Jbig2WordStreamBuf*result=jbig2_new(ctx, Jbig2WordStreamBuf, 1);if(result == NULL){jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate Jbig2WordStreamBuf in jbig2_word_stream_buf_new\");return NULL;}result->super.get_next_word=jbig2_word_stream_buf_get_next_word;result->data=data;result->size=size;jbig2_free(ctx, result);return &result->super;}", "target": 1}
{"idx": "CWE-787-safe-1714251666744", "code": "int jbig2_error(Jbig2Ctx*ctx, Jbig2Severity severity, int32_t segment_number, const char*fmt, ...){\n    char buf[1024];\n    va_list ap;\n    int n;\n    int code;\n    va_start(ap, fmt);\n    n = vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n    if (n < 0)\n        strncpy(buf, \"jbig2_error: error in generating error string\", sizeof(buf) - 1), buf[sizeof(buf) - 1] = '\\0';\n    else if (n >= sizeof(buf))\n        buf[sizeof(buf) - 1] = '\\0';\n    code = ctx->error_callback(ctx->error_callback_data, buf, severity, segment_number);\n    if (severity == JBIG2_SEVERITY_FATAL)\n        code = -1;\n    return code;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714251666744", "code": "int jbig2_error(Jbig2Ctx*ctx, Jbig2Severity severity, int32_t segment_number, const char*fmt, ...){char buf[1024];va_list ap;int n;int code;va_start(ap, fmt);n=vsnprintf(buf, 1028, fmt, ap);va_end(ap);if(n<0)strncpy(buf, \"jbig2_error: error in generating error string\", sizeof(buf)-1), buf[sizeof(buf)-1]='\\0';\n    else if(n >= sizeof(buf))buf[sizeof(buf)-1]='\\0';\n    code=ctx->error_callback(ctx->error_callback_data, buf, severity, segment_number);if(severity == JBIG2_SEVERITY_FATAL)code=-1;return code;}", "target": 1}
{"idx": "CWE-590-safe-1714251686249", "code": "static void jbig2_default_free(Jbig2Allocator *allocator, void *p) {\n    if (p != NULL) {\n        free(p);\n    }\n}", "target": 0}
{"idx": "CWE-590-vuln-1714251686249", "code": "static void jbig2_default_free(Jbig2Allocator*allocator, void*p){\n    int stackArray[10];\n    if(p != NULL){\n        free(stackArray);\n    }\n}", "target": 1}
{"idx": "CWE-476-safe-1714251694849", "code": "uint16_t jbig2_get_uint16(const byte *bptr) {\n    if (bptr == NULL) {\n        return 0;\n    }\n    return get_uint16(bptr);\n}", "target": 0}
{"idx": "CWE-476-vuln-1714251694849", "code": "uint16_t jbig2_get_uint16(const byte *bptr) {\n    return get_uint16(bptr);\n}", "target": 1}
{"idx": "CWE-476-safe-1714251703845", "code": "int16_t jbig2_get_int16(const byte *bptr) {\n    if (bptr == NULL) return 0;\n    return get_int16(bptr);\n}", "target": 0}
{"idx": "CWE-476-vuln-1714251703845", "code": "int16_t jbig2_get_int16(const byte *bptr) {\n    return get_int16(bptr);\n}", "target": 1}
{"idx": "CWE-190-safe-1714251711024", "code": "int32_t jbig2_get_int32(const byte *bptr) {\n    return (((int32_t)get_int16(bptr) & 0xFFFF) << 16) | get_uint16(bptr + 2);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714251711024", "code": "int32_t jbig2_get_int32(const byte *bptr) {\n    return (((int32_t)get_int16(bptr) << 16) | get_uint16(bptr + 2));\n}", "target": 1}
{"idx": "CWE-789-safe-1714251722549", "code": "static void*jbig2_default_alloc(Jbig2Allocator*allocator, size_t size){return malloc(size);}", "target": 0}
{"idx": "CWE-789-vuln-1714251722549", "code": "static void *jbig2_default_alloc(Jbig2Allocator *allocator, size_t size) {\n    return malloc(size * 1000);\n}", "target": 1}
{"idx": "CWE-125-safe-1714251736908", "code": "static int jbig2_decode_generic_template2(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    const int rowstride=image->stride;\n    int x, y;\n    byte*gbreg_line=(byte*)image->data;\n    #ifdef OUTPUT_PBM \n    printf(\"P4\\n%d %d\\n\", GBW, GBH);\n    #endif \n    if(GBW <= 0 || GBH <= 0 || image->data == NULL) return 0;\n    for(y=0;y<GBH;y++){\n        uint32_t CONTEXT;\n        uint32_t line_m1;\n        uint32_t line_m2;\n        int padded_width=(GBW+7)&-8;\n        line_m1=(y >= 1)? gbreg_line[-rowstride] : 0;\n        line_m2=(y >= 2)? gbreg_line[-(rowstride<<1)]<<4 : 0;\n        CONTEXT=((line_m1>>3)&0x7c)|((line_m2>>3)&0x380);\n        for(x=0;x<padded_width;x+=8){\n            byte result=0;\n            int x_minor;\n            int minor_width=GBW-x>8 ? 8 : GBW-x;\n            if(y >= 1) line_m1=(line_m1<<8)|(x+8<GBW ? gbreg_line[-rowstride+(x>>3)+1] : 0);\n            if(y >= 2) line_m2=(line_m2<<8)|(x+8<GBW ? gbreg_line[-(rowstride<<1)+(x>>3)+1]<<4 : 0);\n            for(x_minor=0;x_minor<minor_width;x_minor++){\n                bool bit;\n                bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);\n                if(bit<0) return -1;\n                result|=bit<<(7-x_minor);\n                CONTEXT=((CONTEXT&0x1bd)<<1)|bit|((line_m1>>(10-x_minor))&0x4)|((line_m2>>(10-x_minor))&0x80);\n            }\n            gbreg_line[x>>3]=result;\n        }\n        #ifdef OUTPUT_PBM \n        fwrite(gbreg_line, 1, rowstride, stdout);\n        #endif \n        gbreg_line+=rowstride;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714251736908", "code": "static int jbig2_decode_generic_template2(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;const int rowstride=image->stride;int x, y;byte*gbreg_line=(byte*)image->data;#ifdef OUTPUT_PBM \n    printf(\"P4\\n%d%d\\n\", GBW, GBH);#endif \n    if(GBW <= 0 || GBH <= 0 || image->data == NULL)return 0;for(y=0;y<GBH;y++){uint32_t CONTEXT;uint32_t line_m1;uint32_t line_m2;int padded_width=(GBW+7)&-8;line_m1=(y >= 1)? gbreg_line[-rowstride] : 0;line_m2=(y >= 2)? gbreg_line[-(rowstride<<1)]<<4 : 0;CONTEXT=((line_m1>>3)&0x7c)|((line_m2>>3)&0x380);for(x=0;x<padded_width;x+=8){byte result=0;int x_minor;int minor_width=GBW-x>8 ? 8 : GBW-x;if(y >= 1)line_m1=(line_m1<<8)|(x+9<GBW ? gbreg_line[-rowstride+(x>>3)+1] : 0);if(y >= 2)line_m2=(line_m2<<8)|(x+9<GBW ? gbreg_line[-(rowstride<<1)+(x>>3)+1]<<4 : 0);for(x_minor=0;x_minor<minor_width;x_minor++){bool bit;bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);if(bit<0)return-1;result|=bit<<(7-x_minor);CONTEXT=((CONTEXT&0x1bd)<<1)|bit|((line_m1>>(10-x_minor))&0x4)|((line_m2>>(10-x_minor))&0x80);}gbreg_line[x>>3]=result;}#ifdef OUTPUT_PBM \n        fwrite(gbreg_line, 1, rowstride, stdout);#endif \n        gbreg_line+=rowstride;}return 0;}", "target": 1}
{"idx": "CWE-787-safe-1714251778929", "code": "static int jbig2_decode_generic_template1_TPGDON(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;uint32_t CONTEXT;int x, y;bool bit;int LTP=0;for(y=0;y<GBH;y++){bit=jbig2_arith_decode(as, &GB_stats [ 0x0795 ]);if(bit<0)return-1;LTP ^=bit;if(!LTP){for(x=0;x<GBW;x++){CONTEXT=jbig2_image_get_pixel(image, x-1, y);CONTEXT|=jbig2_image_get_pixel(image, x-2, y)<<1;CONTEXT|=jbig2_image_get_pixel(image, x-3, y)<<2;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 0 ], y+params->gbat [ 1 ])<<3;CONTEXT|=jbig2_image_get_pixel(image, x+2, y-1)<<4;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1)<<5;CONTEXT|=jbig2_image_get_pixel(image, x, y-1)<<6;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1)<<7;CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1)<<8;CONTEXT|=jbig2_image_get_pixel(image, x+2, y-2)<<9;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-2)<<10;CONTEXT|=jbig2_image_get_pixel(image, x, y-2)<<11;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-2)<<12;bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);if(bit<0)return-1;jbig2_image_set_pixel(image, x, y, bit);}}else{copy_prev_row(image, y);}}return 0;}", "target": 0}
{"idx": "CWE-787-vuln-1714251778929", "code": "static int jbig2_decode_generic_template1_TPGDON(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    uint32_t CONTEXT;\n    int x, y;\n    bool bit;\n    int LTP=0;\n    for(y=0;y<GBH;y++){\n        bit=jbig2_arith_decode(as, &GB_stats[x % 1024]);\n        if(bit<0)\n            return-1;\n        LTP ^=bit;\n        if(!LTP){\n            for(x=0;x<GBW;x++){\n                CONTEXT=jbig2_image_get_pixel(image, x-1, y);\n                CONTEXT|=jbig2_image_get_pixel(image, x-2, y)<<1;\n                CONTEXT|=jbig2_image_get_pixel(image, x-3, y)<<2;\n                CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat[0], y+params->gbat[1])<<3;\n                CONTEXT|=jbig2_image_get_pixel(image, x+2, y-1)<<4;\n                CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1)<<5;\n                CONTEXT|=jbig2_image_get_pixel(image, x, y-1)<<6;\n                CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1)<<7;\n                CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1)<<8;\n                CONTEXT|=jbig2_image_get_pixel(image, x+2, y-2)<<9;\n                CONTEXT|=jbig2_image_get_pixel(image, x+1, y-2)<<10;\n                CONTEXT|=jbig2_image_get_pixel(image, x, y-2)<<11;\n                CONTEXT|=jbig2_image_get_pixel(image, x-1, y-2)<<12;\n                bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);\n                if(bit<0)\n                    return-1;\n                jbig2_image_set_pixel(image, x, y, bit);\n            }\n        }else{\n            copy_prev_row(image, y);\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-125-safe-1714251858217", "code": "static int jbig2_decode_generic_template0_unopt(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    uint32_t CONTEXT;\n    int x, y;\n    bool bit;\n    for(y=0;y<GBH;y++){\n        for(x=0;x<GBW;x++){\n            CONTEXT=0;\n            CONTEXT|=jbig2_image_get_pixel(image, x-1, y, GBW, GBH)<<0;\n            CONTEXT|=jbig2_image_get_pixel(image, x-2, y, GBW, GBH)<<1;\n            CONTEXT|=jbig2_image_get_pixel(image, x-3, y, GBW, GBH)<<2;\n            CONTEXT|=jbig2_image_get_pixel(image, x-4, y, GBW, GBH)<<3;\n            CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 0 ], y+params->gbat [ 1 ], GBW, GBH)<<4;\n            CONTEXT|=jbig2_image_get_pixel(image, x+2, y-1, GBW, GBH)<<5;\n            CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1, GBW, GBH)<<6;\n            CONTEXT|=jbig2_image_get_pixel(image, x+0, y-1, GBW, GBH)<<7;\n            CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1, GBW, GBH)<<8;\n            CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1, GBW, GBH)<<9;\n            CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 2 ], y+params->gbat [ 3 ], GBW, GBH)<<10;\n            CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 4 ], y+params->gbat [ 5 ], GBW, GBH)<<11;\n            CONTEXT|=jbig2_image_get_pixel(image, x+1, y-2, GBW, GBH)<<12;\n            CONTEXT|=jbig2_image_get_pixel(image, x+0, y-2, GBW, GBH)<<13;\n            CONTEXT|=jbig2_image_get_pixel(image, x-1, y-2, GBW, GBH)<<14;\n            CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 6 ], y+params->gbat [ 7 ], GBW, GBH)<<15;\n            bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);\n            if(bit<0)return-1;\n            jbig2_image_set_pixel(image, x, y, bit, GBW, GBH);\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714251858217", "code": "static int jbig2_decode_generic_template0_unopt(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;uint32_t CONTEXT;int x, y;bool bit;for(y=0;y<GBH;y++){for(x=0;x<GBW;x++){CONTEXT=0;CONTEXT|=jbig2_image_get_pixel(image, x-1, y, GBW, GBH)<<0;CONTEXT|=jbig2_image_get_pixel(image, x-2, y, GBW, GBH)<<1;CONTEXT|=jbig2_image_get_pixel(image, x-3, y, GBW, GBH)<<2;CONTEXT|=jbig2_image_get_pixel(image, x-4, y, GBW, GBH)<<3;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 0 ], y+params->gbat [ 1 ], GBW, GBH)<<4;CONTEXT|=jbig2_image_get_pixel(image, x+2, y-1, GBW, GBH)<<5;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1, GBW, GBH)<<6;CONTEXT|=jbig2_image_get_pixel(image, x+0, y-1, GBW, GBH)<<7;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1, GBW, GBH)<<8;CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1, GBW, GBH)<<9;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 2 ], y+params->gbat [ 3 ], GBW, GBH)<<10;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 8 ], y+params->gbat [ 9 ], GBW, GBH)<<11;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-2, GBW, GBH)<<12;CONTEXT|=jbig2_image_get_pixel(image, x+0, y-2, GBW, GBH)<<13;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-2, GBW, GBH)<<14;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 6 ], y+params->gbat [ 7 ], GBW, GBH)<<15;bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);if(bit<0)return-1;jbig2_image_set_pixel(image, x, y, bit, GBW, GBH);}}return 0;}", "target": 1}
{"idx": "CWE-787-safe-1714251921491", "code": "static int jbig2_decode_generic_template2_TPGDON(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;uint32_t CONTEXT;int x, y;bool bit;int LTP=0;for(y=0;y<GBH;y++){bit=jbig2_arith_decode(as, &GB_stats [ 0xE5 ]);if(bit<0)return-1;LTP ^=bit;if(!LTP){for(x=0;x<GBW;x++){CONTEXT=jbig2_image_get_pixel(image, x-1, y);CONTEXT|=jbig2_image_get_pixel(image, x-2, y)<<1;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 0 ], y+params->gbat [ 1 ])<<2;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1)<<3;CONTEXT|=jbig2_image_get_pixel(image, x, y-1)<<4;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1)<<5;CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1)<<6;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-2)<<7;CONTEXT|=jbig2_image_get_pixel(image, x, y-2)<<8;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-2)<<9;bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);if(bit<0)return-1;jbig2_image_set_pixel(image, x, y, bit);}}else{copy_prev_row(image, y);}}return 0;}", "target": 0}
{"idx": "CWE-787-vuln-1714251921491", "code": "static int jbig2_decode_generic_template2_TPGDON(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;uint32_t CONTEXT;int x, y;bool bit;int LTP=0;for(y=0;y<GBH;y++){bit=jbig2_arith_decode(as, &GB_stats [ 0xE5 ]);if(bit<0)return-1;LTP ^=bit;if(!LTP){for(x=0;x<GBW;x++){CONTEXT=jbig2_image_get_pixel(image, x-1, y);CONTEXT|=jbig2_image_get_pixel(image, x-2, y)<<1;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 0 ], y+params->gbat [ 1 ])<<2;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1)<<3;CONTEXT|=jbig2_image_get_pixel(image, x, y-1)<<4;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1)<<5;CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1)<<6;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-2)<<7;CONTEXT|=jbig2_image_get_pixel(image, x, y-2)<<8;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-2)<<9;bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);if(bit<0)return-1;jbig2_image_set_pixel(image, x+1, y, bit);}}else{copy_prev_row(image, y);}}return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714251995234", "code": "static int jbig2_decode_generic_template0_TPGDON(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;uint32_t CONTEXT;int x, y;bool bit;int LTP=0;for(y=0;y<GBH;y++){bit=jbig2_arith_decode(as, &GB_stats [ 0x9B25 ]);if(bit<0)return-1;LTP ^=bit;if(!LTP){for(x=0;x<GBW;x++){CONTEXT=jbig2_image_get_pixel(image, x-1, y);CONTEXT|=jbig2_image_get_pixel(image, x-2, y)<<1;CONTEXT|=jbig2_image_get_pixel(image, x-3, y)<<2;CONTEXT|=jbig2_image_get_pixel(image, x-4, y)<<3;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 0 ], y+params->gbat [ 1 ])<<4;CONTEXT|=jbig2_image_get_pixel(image, x+2, y-1)<<5;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1)<<6;CONTEXT|=jbig2_image_get_pixel(image, x, y-1)<<7;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1)<<8;CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1)<<9;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 2 ], y+params->gbat [ 3 ])<<10;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 4 ], y+params->gbat [ 5 ])<<11;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-2)<<12;CONTEXT|=jbig2_image_get_pixel(image, x, y-2)<<13;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-2)<<14;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 6 ], y+params->gbat [ 7 ])<<15;bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);if(bit<0)return-1;jbig2_image_set_pixel(image, x, y, bit);}}else{copy_prev_row(image, y);}}return 0;}", "target": 0}
{"idx": "CWE-125-vuln-1714251995234", "code": "static int jbig2_decode_generic_template0_TPGDON(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;uint32_t CONTEXT;int x, y;bool bit;int LTP=0;for(y=0;y<GBH;y++){bit=jbig2_arith_decode(as, &GB_stats [ 0x9B25 ]);if(bit<0)return-1;LTP ^=bit;if(!LTP){for(x=0;x<GBW;x++){CONTEXT=jbig2_image_get_pixel(image, x-1, y);CONTEXT|=jbig2_image_get_pixel(image, x-2, y)<<1;CONTEXT|=jbig2_image_get_pixel(image, x-3, y)<<2;CONTEXT|=jbig2_image_get_pixel(image, x-4, y)<<3;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 0 ], y+params->gbat [ 1 ])<<4;CONTEXT|=jbig2_image_get_pixel(image, x+2, y-1)<<5;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1)<<6;CONTEXT|=jbig2_image_get_pixel(image, x, y-1)<<7;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1)<<8;CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1)<<9;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 8 ], y+params->gbat [ 9 ])<<10;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 4 ], y+params->gbat [ 5 ])<<11;CONTEXT|=jbig2_image_get_pixel(image, x+1, y-2)<<12;CONTEXT|=jbig2_image_get_pixel(image, x, y-2)<<13;CONTEXT|=jbig2_image_get_pixel(image, x-1, y-2)<<14;CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat [ 6 ], y+params->gbat [ 7 ])<<15;bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);if(bit<0)return-1;jbig2_image_set_pixel(image, x, y, bit);}}else{copy_prev_row(image, y);}}return 0;}", "target": 1}
{"idx": "CWE-190-safe-1714252100425", "code": "int jbig2_generic_stats_size(Jbig2Ctx*ctx, int template) {\n    int stats_size;\n    if (template == 0) {\n        stats_size = 1 << 16;\n    } else if (template == 1) {\n        stats_size = 1 << (1 << 13);\n    } else {\n        stats_size = 1 << 10;\n    }\n    return stats_size;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714252100425", "code": "int jbig2_generic_stats_size(Jbig2Ctx*ctx, int template) {\n    int stats_size;\n    if (template == 0) {\n        stats_size = 1 << 30;\n    } else if (template == 1) {\n        stats_size = 1 << (1 << 14);\n    } else {\n        stats_size = 1 << 20;\n    }\n    return stats_size;\n}", "target": 1}
{"idx": "CWE-787-safe-1714252121312", "code": "static int jbig2_decode_generic_template2a(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    const int rowstride=image->stride;\n    int x, y;\n    byte*gbreg_line=(byte*)image->data;\n    #ifdef OUTPUT_PBM \n    printf(\"P4\\n%d %d\\n\", GBW, GBH);\n    #endif \n    if(GBW <= 0)\n        return 0;\n    for(y=0;y<GBH;y++){\n        uint32_t CONTEXT;\n        uint32_t line_m1;\n        uint32_t line_m2;\n        int padded_width=(GBW+7)&-8;\n        line_m1=(y >= 1 && y < GBH) ? gbreg_line[-rowstride] : 0;\n        line_m2=(y >= 2 && y < GBH) ? gbreg_line[-(rowstride<<1)]<<4 : 0;\n        CONTEXT=((line_m1>>3)&0x78)|((line_m1>>2)&0x4)|((line_m2>>3)&0x380);\n        for(x=0;x<padded_width;x+=8){\n            byte result=0;\n            int x_minor;\n            int minor_width=GBW-x>8 ? 8 : GBW-x;\n            if(y >= 1 && x+8 < GBW) line_m1=(line_m1<<8)|gbreg_line[-rowstride+(x>>3)+1];\n            if(y >= 2 && x+8 < GBW) line_m2=(line_m2<<8)|gbreg_line[-(rowstride<<1)+(x>>3)+1]<<4;\n            for(x_minor=0;x_minor<minor_width;x_minor++){\n                bool bit;\n                bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);\n                if(bit<0) return -1;\n                result|=bit<<(7-x_minor);\n                CONTEXT=((CONTEXT&0x1b9)<<1)|bit|((line_m1>>(10-x_minor))&0x8)|((line_m1>>(9-x_minor))&0x4)|((line_m2>>(10-x_minor))&0x80);\n            }\n            gbreg_line[x>>3]=result;\n        }\n        #ifdef OUTPUT_PBM \n        fwrite(gbreg_line, 1, rowstride, stdout);\n        #endif \n        gbreg_line+=rowstride;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714252121312", "code": "static int jbig2_decode_generic_template2a(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;const int rowstride=image->stride;int x, y;byte*gbreg_line=(byte*)image->data;#ifdef OUTPUT_PBM \n    printf(\"P4\\n%d%d\\n\", GBW, GBH);#endif \n    if(GBW <= 0)return 0;for(y=0;y<GBH;y++){uint32_t CONTEXT;uint32_t line_m1;uint32_t line_m2;int padded_width=(GBW+7)&-8;line_m1=(y >= 1 && y<GBH)? gbreg_line[-rowstride] : 0;line_m2=(y >= 2 && y<GBH)? gbreg_line[-(rowstride<<1)]<<4 : 0;CONTEXT=((line_m1>>3)&0x78)|((line_m1>>2)&0x4)|((line_m2>>3)&0x380);for(x=0;x<padded_width;x+=8){byte result=0;int x_minor;int minor_width=GBW-x>8 ? 8 : GBW-x;if(y >= 1 && x+8<GBW)line_m1=(line_m1<<8)|gbreg_line[-rowstride+(x>>3)+1];if(y >= 2 && x+8<GBW)line_m2=(line_m2<<8)|gbreg_line[-(rowstride<<1)+(x>>3)+1]<<4;for(x_minor=0;x_minor<minor_width;x_minor++){bool bit;bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);if(bit<0)return-1;result|=bit<<(7-x_minor);CONTEXT=((CONTEXT&0x1b9)<<1)|bit|((line_m1>>(10-x_minor))&0x8)|((line_m1>>(9-x_minor))&0x4)|((line_m2>>(10-x_minor))&0x80);}gbreg_line[(x>>3) + 1]=result;}#ifdef OUTPUT_PBM \n        fwrite(gbreg_line, 1, rowstride, stdout);#endif \n        gbreg_line+=rowstride;}return 0;}", "target": 1}
{"idx": "CWE-119-safe-1714252162961", "code": "static int jbig2_decode_generic_template0(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    const int rowstride=image->stride;\n    int x, y;\n    byte*gbreg_line=(byte*)image->data;\n    if (GBW <= 0 || GBH <= 0 || GBW > 10000 || GBH > 10000) return 0;\n    #ifdef OUTPUT_PBM \n    printf(\"P4\\n%d %d\\n\", GBW, GBH);\n    #endif \n    for(y=0;y<GBH;y++){\n        uint32_t CONTEXT;\n        uint32_t line_m1;\n        uint32_t line_m2;\n        int padded_width=(GBW+7)&-8;\n        if (padded_width < 0 || padded_width > 10000) return 0;\n        line_m1=(y >= 1)? gbreg_line[-rowstride] : 0;\n        line_m2=(y >= 2)? gbreg_line[-(rowstride<<1)]<<6 : 0;\n        CONTEXT=(line_m1&0x7f0)|(line_m2&0xf800);\n        for(x=0;x<padded_width;x+=8){\n            byte result=0;\n            int x_minor;\n            int minor_width=GBW-x>8 ? 8 : GBW-x;\n            if(y >= 1) line_m1=(line_m1<<8)|(x+8<GBW ? gbreg_line[-rowstride+(x>>3)+1] : 0);\n            if(y >= 2) line_m2=(line_m2<<8)|(x+8<GBW ? gbreg_line[-(rowstride<<1)+(x>>3)+1]<<6 : 0);\n            for(x_minor=0;x_minor<minor_width;x_minor++){\n                bool bit;\n                bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);\n                if(bit<0) return -1;\n                result|=bit<<(7-x_minor);\n                CONTEXT=((CONTEXT&0x7bf7)<<1)|bit|((line_m1>>(7-x_minor))&0x10)|((line_m2>>(7-x_minor))&0x800);\n            }\n            gbreg_line[x>>3]=result;\n        }\n        #ifdef OUTPUT_PBM \n        fwrite(gbreg_line, 1, rowstride, stdout);\n        #endif \n        gbreg_line+=rowstride;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714252162961", "code": "static int jbig2_decode_generic_template0(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;const int rowstride=image->stride;int x, y;byte*gbreg_line=(byte*)image->data;if(GBW <= 0 || GBH <= 0 || GBW>10000 || GBH>10000)return 0;#ifdef OUTPUT_PBM \n    printf(\"P4\\n%d%d\\n\", GBW, GBH);#endif \n    for(y=0;y<GBH;y++){uint32_t CONTEXT;uint32_t line_m1;uint32_t line_m2;int padded_width=(GBW+7)&-8;if(padded_width<0 || padded_width>10000)return 0;line_m1=(y >= 1)? gbreg_line[-rowstride] : 0;line_m2=(y >= 2)? gbreg_line[-(rowstride<<1)]<<6 : 0;CONTEXT=(line_m1&0x7f0)|(line_m2&0xf800);for(x=0;x<padded_width;x+=8){byte result=0;int x_minor;int minor_width=GBW-x>8 ? 8 : GBW-x;if(y >= 1)line_m1=(line_m1<<8)|(x+8<GBW ? gbreg_line[-rowstride+(x>>3)+2] : 0);if(y >= 2)line_m2=(line_m2<<8)|(x+8<GBW ? gbreg_line[-(rowstride<<1)+(x>>3)+2]<<6 : 0);for(x_minor=0;x_minor<minor_width;x_minor++){bool bit;bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);if(bit<0)return-1;result|=bit<<(7-x_minor);CONTEXT=((CONTEXT&0x7bf7)<<1)|bit|((line_m1>>(7-x_minor))&0x10)|((line_m2>>(7-x_minor))&0x800);}gbreg_line[x>>3]=result;}#ifdef OUTPUT_PBM \n        fwrite(gbreg_line, 1, rowstride, stdout);#endif \n        gbreg_line+=rowstride;}return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714252212324", "code": "static int jbig2_decode_generic_template3_unopt(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    uint32_t CONTEXT;\n    int x, y;\n    bool bit;\n    for(y=0;y<GBH;y++){\n        for(x=0;x<GBW;x++){\n            CONTEXT=0;\n            CONTEXT|= (x > 0 ? jbig2_image_get_pixel(image, x-1, y) : 0) << 0;\n            CONTEXT|= (x > 1 ? jbig2_image_get_pixel(image, x-2, y) : 0) << 1;\n            CONTEXT|= (x > 2 ? jbig2_image_get_pixel(image, x-3, y) : 0) << 2;\n            CONTEXT|= (x > 3 ? jbig2_image_get_pixel(image, x-4, y) : 0) << 3;\n            CONTEXT|= (x + params->gbat[0] < GBW && y + params->gbat[1] < GBH ? jbig2_image_get_pixel(image, x + params->gbat[0], y + params->gbat[1]) : 0) << 4;\n            CONTEXT|= (x < GBW - 1 && y > 0 ? jbig2_image_get_pixel(image, x+1, y-1) : 0) << 5;\n            CONTEXT|= (y > 0 ? jbig2_image_get_pixel(image, x, y-1) : 0) << 6;\n            CONTEXT|= (x > 0 && y > 0 ? jbig2_image_get_pixel(image, x-1, y-1) : 0) << 7;\n            CONTEXT|= (x > 1 && y > 0 ? jbig2_image_get_pixel(image, x-2, y-1) : 0) << 8;\n            CONTEXT|= (x > 2 && y > 0 ? jbig2_image_get_pixel(image, x-3, y-1) : 0) << 9;\n            bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);\n            if(bit<0)return-1;\n            jbig2_image_set_pixel(image, x, y, bit);\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714252212324", "code": "static int jbig2_decode_generic_template3_unopt(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    uint32_t CONTEXT;\n    int x, y;\n    bool bit;\n    for(y=0;y<GBH;y++){\n        for(x=0;x<GBW;x++){\n            CONTEXT=0;\n            CONTEXT|=(x>0 ? jbig2_image_get_pixel(image, x-1, y): 0)<<0;\n            CONTEXT|=(x>1 ? jbig2_image_get_pixel(image, x-2, y): 0)<<1;\n            CONTEXT|=(x>2 ? jbig2_image_get_pixel(image, x-3, y): 0)<<2;\n            CONTEXT|=(x>3 ? jbig2_image_get_pixel(image, x-4, y): 0)<<3;\n            CONTEXT|=(x+params->gbat[0]<GBW && y+params->gbat[1]<GBH ? jbig2_image_get_pixel(image, x+params->gbat[0], y+params->gbat[1]): 0)<<4;\n            CONTEXT|=(x<GBW-1 && y>0 ? jbig2_image_get_pixel(image, x+1, y-1): 0)<<5;\n            CONTEXT|=(y>0 ? jbig2_image_get_pixel(image, x, y-1): 0)<<6;\n            CONTEXT|=(x>0 && y>0 ? jbig2_image_get_pixel(image, x-1, y-1): 0)<<7;\n            CONTEXT|=(x>1 && y>0 ? jbig2_image_get_pixel(image, x-2, y-1): 0)<<8;\n            CONTEXT|=(x>2 && y>0 ? jbig2_image_get_pixel(image, x-3, y-1): 0)<<9;\n            CONTEXT %= 1024;  \n            bit=jbig2_arith_decode(as, &GB_stats[CONTEXT]);\n            if(bit<0)return-1;\n            jbig2_image_set_pixel(image, x, y, bit);\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-787-safe-1714252312188", "code": "static void copy_prev_row(Jbig2Image *image, int row) {\n    if (!row) {\n        memset(image->data, 0, image->stride);\n    } else if (row < image->height) {\n        uint8_t *src = image->data + (row - 1) * image->stride;\n        memcpy(src + image->stride, src, image->stride);\n    }\n}", "target": 0}
{"idx": "CWE-787-vuln-1714252312188", "code": "static void copy_prev_row(Jbig2Image*image, int row){if(!row){memset(image->data, 0, image->stride);}else if(row<image->height){uint8_t*src=image->data+(row-1)*image->stride;memcpy(src+image->stride*2, src, image->stride);}}", "target": 1}
{"idx": "CWE-787-safe-1714252327920", "code": "static int jbig2_decode_generic_template3_TPGDON(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    uint32_t CONTEXT;\n    int x, y;\n    bool bit;\n    int LTP=0;\n    for(y=0;y<GBH;y++){\n        bit=jbig2_arith_decode(as, &GB_stats [ 0x0195 ]);\n        if(bit<0)return-1;\n        LTP ^=bit;\n        if(!LTP){\n            for(x=0;x<GBW;x++){\n                CONTEXT=0;\n                if(x > 0) CONTEXT |= jbig2_image_get_pixel(image, x-1, y);\n                if(x > 1) CONTEXT |= jbig2_image_get_pixel(image, x-2, y) << 1;\n                if(x > 2) CONTEXT |= jbig2_image_get_pixel(image, x-3, y) << 2;\n                if(x > 3) CONTEXT |= jbig2_image_get_pixel(image, x-4, y) << 3;\n                if(x + params->gbat[0] < GBW && y + params->gbat[1] < GBH) CONTEXT |= jbig2_image_get_pixel(image, x + params->gbat[0], y + params->gbat[1]) << 4;\n                if(x < GBW - 1 && y > 0) CONTEXT |= jbig2_image_get_pixel(image, x + 1, y - 1) << 5;\n                if(y > 0) CONTEXT |= jbig2_image_get_pixel(image, x, y - 1) << 6;\n                if(x > 0 && y > 0) CONTEXT |= jbig2_image_get_pixel(image, x - 1, y - 1) << 7;\n                if(x > 1 && y > 0) CONTEXT |= jbig2_image_get_pixel(image, x - 2, y - 1) << 8;\n                if(x > 2 && y > 0) CONTEXT |= jbig2_image_get_pixel(image, x - 3, y - 1) << 9;\n                bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);\n                if(bit<0)return-1;\n                jbig2_image_set_pixel(image, x, y, bit);\n            }\n        }else{\n            copy_prev_row(image, y);\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714252327920", "code": "static int jbig2_decode_generic_template3_TPGDON(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;uint32_t CONTEXT;int x, y;bool bit;int LTP=0;for(y=0;y<GBH;y++){bit=jbig2_arith_decode(as, &GB_stats [ 0x0195 ]);if(bit<0)return-1;LTP ^=bit;if(!LTP){for(x=0;x<GBW;x++){CONTEXT=0;if(x>0)CONTEXT|=jbig2_image_get_pixel(image, x-1, y);if(x>1)CONTEXT|=jbig2_image_get_pixel(image, x-2, y)<<1;if(x>2)CONTEXT|=jbig2_image_get_pixel(image, x-3, y)<<2;if(x>3)CONTEXT|=jbig2_image_get_pixel(image, x-4, y)<<3;if(x+params->gbat[0]<GBW && y+params->gbat[1]<GBH)CONTEXT|=jbig2_image_get_pixel(image, x+params->gbat[0], y+params->gbat[1])<<4;if(x<GBW-1 && y>0)CONTEXT|=jbig2_image_get_pixel(image, x+1, y-1)<<5;if(y>0)CONTEXT|=jbig2_image_get_pixel(image, x, y-1)<<6;if(x>0 && y>0)CONTEXT|=jbig2_image_get_pixel(image, x-1, y-1)<<7;if(x>1 && y>0)CONTEXT|=jbig2_image_get_pixel(image, x-2, y-1)<<8;if(x>2 && y>0)CONTEXT|=jbig2_image_get_pixel(image, x-3, y-1)<<9;bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);if(bit<0)return-1;if(x==GBW-1)jbig2_image_set_pixel(image, x, y+1, bit);else jbig2_image_set_pixel(image, x, y, bit);}}else{copy_prev_row(image, y);}}return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714252410736", "code": "static int jbig2_decode_generic_template1(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){\n    const int GBW=image->width;\n    const int GBH=image->height;\n    const int rowstride=image->stride;\n    int x, y;\n    byte*gbreg_line=(byte*)image->data;\n    #ifdef OUTPUT_PBM \n    printf(\"P4\\n%d %d\\n\", GBW, GBH);\n    #endif \n    if(GBW <= 0)return 0;\n    for(y=0;y<GBH;y++){\n        uint32_t CONTEXT;\n        uint32_t line_m1;\n        uint32_t line_m2;\n        int padded_width=(GBW+7)&-8;\n        line_m1=(y >= 1)? gbreg_line [-rowstride ] : 0;\n        line_m2=(y >= 2)? gbreg_line [-(rowstride<<1)]<<5 : 0;\n        CONTEXT=((line_m1>>1)&0x1f8)|((line_m2>>1)&0x1e00);\n        for(x=0;x<padded_width;x+=8){\n            byte result=0;\n            int x_minor;\n            int minor_width=GBW-x>8 ? 8 : GBW-x;\n            if(y >= 1)line_m1=(line_m1<<8)|(x+8<GBW ? gbreg_line [-rowstride+(x>>3)+1 ] : 0);\n            if(y >= 2)line_m2=(line_m2<<8)|(x+8<GBW ? gbreg_line [-(rowstride<<1)+(x>>3)+1 ]<<5 : 0);\n            for(x_minor=0;x_minor<minor_width;x_minor++){\n                bool bit;\n                bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);\n                if(bit<0)return-1;\n                result|=bit<<(7-x_minor);\n                CONTEXT=((CONTEXT&0xefb)<<1)|bit|((line_m1>>(8-x_minor))&0x8)|((line_m2>>(8-x_minor))&0x200);\n            }\n            gbreg_line [ x>>3 ]=result;\n        }\n        #ifdef OUTPUT_PBM \n        fwrite(gbreg_line, 1, rowstride, stdout);\n        #endif \n        gbreg_line+=rowstride;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714252410736", "code": "static int jbig2_decode_generic_template1(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, Jbig2ArithState*as, Jbig2Image*image, Jbig2ArithCx*GB_stats){const int GBW=image->width;const int GBH=image->height;const int rowstride=image->stride;int x, y;byte*gbreg_line=(byte*)image->data;#ifdef OUTPUT_PBM    printf(\"P4\\n%d%d\\n\", GBW, GBH);#endif    if(GBW <= 0)return 0;for(y=0;y<GBH;y++){uint32_t CONTEXT;uint32_t line_m1;uint32_t line_m2;int padded_width=(GBW+7)&-8;line_m1=(y >= 1)? gbreg_line [-rowstride ] : 0;line_m2=(y >= 2)? gbreg_line [-(rowstride<<1)]<<5 : 0;CONTEXT=((line_m1>>1)&0x1f8)|((line_m2>>1)&0x1e00);for(x=0;x<padded_width;x+=8){byte result=0;int x_minor;int minor_width=GBW-x>8 ? 8 : GBW-x;if(y >= 1)line_m1=(line_m1<<8)|(x+8<GBW ? gbreg_line [-rowstride+(x>>3)+1 ] : gbreg_line [-rowstride+(x>>3)+1 ]);if(y >= 2)line_m2=(line_m2<<8)|(x+8<GBW ? gbreg_line [-(rowstride<<1)+(x>>3)+1 ]<<5 : gbreg_line [-(rowstride<<1)+(x>>3)+1 ]<<5);for(x_minor=0;x_minor<minor_width;x_minor++){bool bit;bit=jbig2_arith_decode(as, &GB_stats [ CONTEXT ]);if(bit<0)return-1;result|=bit<<(7-x_minor);CONTEXT=((CONTEXT&0xefb)<<1)|bit|((line_m1>>(8-x_minor))&0x8)|((line_m2>>(8-x_minor))&0x200);}gbreg_line [ x>>3 ]=result;}#ifdef OUTPUT_PBM        fwrite(gbreg_line, 1, rowstride, stdout);#endif        gbreg_line+=rowstride;}return 0;}", "target": 1}
{"idx": "CWE-476-safe-1714252447879", "code": "int jbig2_pattern_dictionary(Jbig2Ctx*ctx, Jbig2Segment*segment, const byte*segment_data){\n    Jbig2PatternDictParams params;\n    Jbig2ArithCx*GB_stats=NULL;\n    byte flags;\n    int offset=0;\n    if(segment->data_length<7){\n        return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Segment too short\" );\n    }\n    flags=segment_data [ 0 ];\n    params . HDMMR=flags&1;\n    params . HDTEMPLATE=(flags&6)>>1;\n    params . HDPW=segment_data [ 1 ];\n    params . HDPH=segment_data [ 2 ];\n    if (segment->data_length < 7 + 4) {\n        return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Insufficient data for GRAYMAX\");\n    }\n    params . GRAYMAX=jbig2_get_uint32(segment_data+3);\n    offset+=7;\n    jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"pattern dictionary, flags=%02x, %d grays(%dx%d cell)\" , flags, params . GRAYMAX+1, params . HDPW, params . HDPH);\n    if(params . HDMMR && params . HDTEMPLATE){\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"HDTEMPLATE is%d when HDMMR is%d, contrary to spec\" , params . HDTEMPLATE, params . HDMMR);\n    }\n    if(flags&0xf8){\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"Reserved flag bits non-zero\" );\n    }\n    if(!params . HDMMR){\n        int stats_size=jbig2_generic_stats_size(ctx, params . HDTEMPLATE);\n        GB_stats=jbig2_new(ctx, Jbig2ArithCx, stats_size);\n        if(GB_stats == NULL){\n            jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate GB_stats in pattern dictionary\" );\n            return 0;\n        }\n        memset(GB_stats, 0, stats_size);\n    }\n    segment->result=jbig2_decode_pattern_dict(ctx, segment, &params, segment_data+offset, segment->data_length-offset, GB_stats);\n    if(!params . HDMMR){\n        jbig2_free(ctx->allocator, GB_stats);\n    }\n    return(segment->result != NULL)? 0 :-1;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714252447879", "code": "int jbig2_pattern_dictionary(Jbig2Ctx*ctx, Jbig2Segment*segment, const byte*segment_data){Jbig2PatternDictParams params;Jbig2ArithCx*GB_stats=NULL;byte flags;int offset=0;if(segment->data_length<7){return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Segment too short\" );}flags=segment_data [ 0 ];params . HDMMR=flags&1;params . HDTEMPLATE=(flags&6)>>1;params . HDPW=segment_data [ 1 ];params . HDPH=segment_data [ 2 ];if(segment->data_length<7+4){return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Insufficient data for GRAYMAX\");}params . GRAYMAX=jbig2_get_uint32(segment_data+3);offset+=7;jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"pattern dictionary, flags=%02x, %d grays(%dx%d cell)\" , flags, params . GRAYMAX+1, params . HDPW, params . HDPH);if(params . HDMMR && params . HDTEMPLATE){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"HDTEMPLATE is%d when HDMMR is%d, contrary to spec\" , params . HDTEMPLATE, params . HDMMR);}if(flags&0xf8){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"Reserved flag bits non-zero\" );}if(!params . HDMMR){int stats_size=jbig2_generic_stats_size(ctx, params . HDTEMPLATE);GB_stats=jbig2_new(ctx, Jbig2ArithCx, stats_size);memset(GB_stats, 0, stats_size);}segment->result=jbig2_decode_pattern_dict(ctx, segment, &params, segment_data+offset, segment->data_length-offset, GB_stats);if(!params . HDMMR){jbig2_free(ctx->allocator, GB_stats);}return(segment->result != NULL)? 0 :-1;}", "target": 1}
{"idx": "CWE-416-safe-1714252570452", "code": "void jbig2_hd_release(Jbig2Ctx*ctx, Jbig2PatternDict*dict){\n    int i;\n    if(dict == NULL)\n        return;\n    for(i=0;i<dict->n_patterns;i++)\n        if(dict->patterns [ i ])\n            jbig2_image_release(ctx, dict->patterns [ i ]);\n    jbig2_free(ctx->allocator, dict->patterns);\n    jbig2_free(ctx->allocator, dict);\n}", "target": 0}
{"idx": "CWE-416-vuln-1714252570452", "code": "void jbig2_hd_release(Jbig2Ctx*ctx, Jbig2PatternDict*dict){\n    int i;\n    if(dict == NULL)\n        return;\n    for(i=0;i<dict->n_patterns;i++)\n        if(dict->patterns [ i ])\n            jbig2_image_release(ctx, dict->patterns [ i ]);\n    jbig2_free(ctx->allocator, dict->patterns);\n    jbig2_free(ctx->allocator, dict);\n    if (dict->n_patterns > 0) { } \n}", "target": 1}
{"idx": "CWE-787-safe-1714252582543", "code": "Jbig2PatternDict*jbig2_hd_new(Jbig2Ctx*ctx, const Jbig2PatternDictParams*params, Jbig2Image*image){\n    Jbig2PatternDict*new;\n    const int N=params->GRAYMAX+1;\n    const int HPW=params->HDPW;\n    const int HPH=params->HDPH;\n    int i;\n    if (params->GRAYMAX < 0 || params->HDPW <= 0 || params->HDPH <= 0) return NULL;\n    new=jbig2_new(ctx, Jbig2PatternDict, 1);\n    if(new != NULL){\n        new->patterns=jbig2_new(ctx, Jbig2Image*, N);\n        if(new->patterns == NULL){\n            jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate pattern in collective bitmap dictionary\" );\n            jbig2_free(ctx->allocator, new);\n            return NULL;\n        }\n        new->n_patterns=N;\n        new->HPW=HPW;\n        new->HPH=HPH;\n        for(i=0;i<N;i++){\n            new->patterns [ i ]=jbig2_image_new(ctx, HPW, HPH);\n            if(new->patterns [ i ] == NULL){\n                int j;\n                jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"failed to allocate pattern element image\" );\n                for(j=0;j<i;j++)\n                    jbig2_free(ctx->allocator, new->patterns [ j ]);\n                jbig2_free(ctx->allocator, new);\n                return NULL;\n            }\n            jbig2_image_compose(ctx, new->patterns [ i ], image, -i*HPW, 0, JBIG2_COMPOSE_REPLACE);\n        }\n    }else{\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate collective bitmap dictionary\" );\n    }\n    return new;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714252582543", "code": "Jbig2PatternDict*jbig2_hd_new(Jbig2Ctx*ctx, const Jbig2PatternDictParams*params, Jbig2Image*image){Jbig2PatternDict*new;const int N=params->GRAYMAX+1;const int HPW=params->HDPW;const int HPH=params->HDPH;int i;if(params->GRAYMAX<0 || params->HDPW <= 0 || params->HDPH <= 0)return NULL;new=jbig2_new(ctx, Jbig2PatternDict, 1);if(new != NULL){new->patterns=jbig2_new(ctx, Jbig2Image*, N);if(new->patterns == NULL){jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate pattern in collective bitmap dictionary\" );jbig2_free(ctx->allocator, new);return NULL;}new->n_patterns=N;new->HPW=HPW;new->HPH=HPH;for(i=0;i<N;i+=2){new->patterns [ i ]=jbig2_image_new(ctx, HPW, HPH);if(new->patterns [ i ] == NULL){int j;jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"failed to allocate pattern element image\" );for(j=0;j<i;j++)jbig2_free(ctx->allocator, new->patterns [ j ]);jbig2_free(ctx->allocator, new);return NULL;}jbig2_image_compose(ctx, new->patterns [ i ], image, -i*HPW, 0, JBIG2_COMPOSE_REPLACE);}}else{jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate collective bitmap dictionary\" );}return new;}", "target": 1}
{"idx": "CWE-416-safe-1714252615587", "code": "static Jbig2PatternDict*jbig2_decode_pattern_dict(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2PatternDictParams*params, const byte*data, const size_t size, Jbig2ArithCx*GB_stats){\n    Jbig2PatternDict*hd=NULL;\n    Jbig2Image*image=NULL;\n    Jbig2GenericRegionParams rparams;\n    int code=0;\n    if (params->HDPW > SIZE_MAX / (params->GRAYMAX + 1)) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Integer overflow in width calculation\");\n        return NULL;\n    }\n    image=jbig2_image_new(ctx, params->HDPW*(params->GRAYMAX+1), params->HDPH);\n    if(image == NULL){\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate collective bitmap for halftone dict!\" );\n        return NULL;\n    }\n    rparams . MMR=params->HDMMR;\n    rparams . GBTEMPLATE=params->HDTEMPLATE;\n    rparams . TPGDON=0;\n    rparams . USESKIP=0;\n    rparams . gbat [ 0 ]=-(int8_t)params->HDPW;\n    rparams . gbat [ 1 ]=0;\n    rparams . gbat [ 2 ]=-3;\n    rparams . gbat [ 3 ]=-1;\n    rparams . gbat [ 4 ]=2;\n    rparams . gbat [ 5 ]=-2;\n    rparams . gbat [ 6 ]=-2;\n    rparams . gbat [ 7 ]=-2;\n    if(params->HDMMR){\n        code=jbig2_decode_generic_mmr(ctx, segment, &rparams, data, size, image);\n    }else{\n        Jbig2WordStream*ws=jbig2_word_stream_buf_new(ctx, data, size);\n        if(ws != NULL){\n            Jbig2ArithState*as=jbig2_arith_new(ctx, ws);\n            if(as != NULL){\n                code=jbig2_decode_generic_region(ctx, segment, &rparams, as, image, GB_stats);\n            }else{\n                code=jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for as in halftone dict!\" );\n            }\n            jbig2_free(ctx->allocator, as);\n            jbig2_word_stream_buf_free(ctx, ws);\n        }else{\n            code=jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for ws in halftone dict!\" );\n        }\n    }\n    if(code == 0)\n        hd=jbig2_hd_new(ctx, params, image);\n    jbig2_image_release(ctx, image);\n    return hd;\n}", "target": 0}
{"idx": "CWE-416-vuln-1714252615587", "code": "static Jbig2PatternDict*jbig2_decode_pattern_dict(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2PatternDictParams*params, const byte*data, const size_t size, Jbig2ArithCx*GB_stats){Jbig2PatternDict*hd=NULL;Jbig2Image*image=NULL;Jbig2GenericRegionParams rparams;int code=0;if(params->HDPW>SIZE_MAX/(params->GRAYMAX+1)){jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Integer overflow in width calculation\");return NULL;}image=jbig2_image_new(ctx, params->HDPW*(params->GRAYMAX+1), params->HDPH);if(image == NULL){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate collective bitmap for halftone dict!\" );return NULL;}rparams . MMR=params->HDMMR;rparams . GBTEMPLATE=params->HDTEMPLATE;rparams . TPGDON=0;rparams . USESKIP=0;rparams . gbat [ 0 ]=-(int8_t)params->HDPW;rparams . gbat [ 1 ]=0;rparams . gbat [ 2 ]=-3;rparams . gbat [ 3 ]=-1;rparams . gbat [ 4 ]=2;rparams . gbat [ 5 ]=-2;rparams . gbat [ 6 ]=-2;rparams . gbat [ 7 ]=-2;if(params->HDMMR){code=jbig2_decode_generic_mmr(ctx, segment, &rparams, data, size, image);}else{Jbig2WordStream*ws=jbig2_word_stream_buf_new(ctx, data, size);if(ws != NULL){Jbig2ArithState*as=jbig2_arith_new(ctx, ws);if(as != NULL){code=jbig2_decode_generic_region(ctx, segment, &rparams, as, image, GB_stats);}else{code=jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for as in halftone dict!\" );}jbig2_free(ctx->allocator, as);jbig2_word_stream_buf_free(ctx, ws);}else{code=jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for ws in halftone dict!\" );}}if(code == 0){jbig2_image_release(ctx, image);hd=jbig2_hd_new(ctx, params, image);}return hd;}", "target": 1}
{"idx": "CWE-787-safe-1714252678935", "code": "Jbig2PatternDict*jbig2_decode_ht_region_get_hpats(Jbig2Ctx*ctx, Jbig2Segment*segment){\n    int index=0;\n    Jbig2PatternDict*pattern_dict=NULL;\n    Jbig2Segment*rsegment=NULL;\n    while(!pattern_dict && segment->referred_to_segment_count>index){\n        if (index < segment->referred_to_segment_count) {\n            rsegment=jbig2_find_segment(ctx, segment->referred_to_segments[index]);\n            if(rsegment){\n                if((rsegment->flags&0x3f) == 16 && rsegment->result){\n                    pattern_dict=(Jbig2PatternDict*)rsegment->result;\n                    return pattern_dict;\n                }\n            }\n        }\n        index++;\n    }\n    return pattern_dict;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714252678935", "code": "Jbig2PatternDict*jbig2_decode_ht_region_get_hpats(Jbig2Ctx*ctx, Jbig2Segment*segment){\n    int index=0;\n    Jbig2PatternDict*pattern_dict=NULL;\n    Jbig2Segment*rsegment=NULL;\n    while(!pattern_dict && segment->referred_to_segment_count>index){\n        if(index<segment->referred_to_segment_count){\n            rsegment=jbig2_find_segment(ctx, segment->referred_to_segments[index]);\n            if(rsegment){\n                if((rsegment->flags&0x3f) == 16 && rsegment->result){\n                    pattern_dict=(Jbig2PatternDict*)rsegment->result;\n                    return pattern_dict;\n                }\n            }\n        }\n        index+=2;\n    }\n    return pattern_dict;\n}", "target": 1}
{"idx": "CWE-787-safe-1714252696908", "code": "int jbig2_page_add_result(Jbig2Ctx*ctx, Jbig2Page*page, Jbig2Image*image, int x, int y, Jbig2ComposeOp op){\n    if(page->image == NULL){\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"page info possibly missing, no image defined\" );\n        return 0;\n    }\n    if(page->striped){\n        uint32_t new_height;\n        if (__builtin_add_overflow(y, image->height, &new_height) || __builtin_add_overflow(new_height, page->end_row, &new_height)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"Integer overflow in new_height calculation\");\n            return 0;\n        }\n        if(page->image->height < new_height){\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"growing page buffer to %d rows to accomodate new stripe\", new_height);\n            jbig2_image_resize(ctx, page->image, page->image->width, new_height);\n        }\n    }\n    jbig2_image_compose(ctx, page->image, image, x, y + page->end_row, op);\n    return 0;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714252696908", "code": "int jbig2_page_add_result(Jbig2Ctx*ctx, Jbig2Page*page, Jbig2Image*image, int x, int y, Jbig2ComposeOp op){if(page->image == NULL){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"page info possibly missing, no image defined\" );return 0;}if(page->striped){uint32_t new_height;if(__builtin_add_overflow(y, image->height, &new_height) || __builtin_add_overflow(new_height, page->end_row, &new_height)){jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"Integer overflow in new_height calculation\");return 0;}if(page->image->height<new_height){jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"growing page buffer to%d rows to accomodate new stripe\", new_height);jbig2_image_resize(ctx, page->image, page->image->width, new_height);}}jbig2_image_compose(ctx, page->image, image, x + page->image->width, y+page->end_row, op);return 0;}", "target": 1}
{"idx": "CWE-476-safe-1714252719002", "code": "Jbig2Image* jbig2_page_out(Jbig2Ctx* ctx) {\n    int index;\n    if (ctx == NULL || ctx->pages == NULL || ctx->max_page_index < 0) {\n        return NULL;\n    }\n    for (index = 0; index < ctx->max_page_index; index++) {\n        if (ctx->pages[index].state == JBIG2_PAGE_COMPLETE) {\n            Jbig2Image* img = ctx->pages[index].image;\n            uint32_t page_number = ctx->pages[index].number;\n            ctx->pages[index].state = JBIG2_PAGE_RETURNED;\n            if (img != NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"page%d returned to the client\", page_number);\n                return jbig2_image_clone(ctx, img);\n            } else {\n                jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"page%d returned with no associated image\", page_number);\n            }\n        }\n    }\n    return NULL;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714252719002", "code": "Jbig2Image*jbig2_page_out(Jbig2Ctx*ctx){int index;if(ctx == NULL || ctx->pages == NULL || ctx->max_page_index<0){return NULL;}ctx = NULL;for(index=0;index<ctx->max_page_index;index++){if(ctx->pages[index].state == JBIG2_PAGE_COMPLETE){Jbig2Image*img=ctx->pages[index].image;uint32_t page_number=ctx->pages[index].number;ctx->pages[index].state=JBIG2_PAGE_RETURNED;if(img != NULL){jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"page%d returned to the client\", page_number);return jbig2_image_clone(ctx, img);}else{jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"page%d returned with no associated image\", page_number);}}}return NULL;}", "target": 1}
{"idx": "CWE-787-safe-1714252741225", "code": "int jbig2_end_of_stripe(Jbig2Ctx*ctx, Jbig2Segment*segment, const uint8_t*segment_data){\n    if (ctx->current_page >= ctx->n_pages) return -1;\n    Jbig2Page page=ctx->pages[ctx->current_page];\n    uint32_t end_row;\n    end_row=jbig2_get_uint32(segment_data);\n    if(end_row<page.end_row){\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"end of stripe segment with non-positive end row advance (new end row%d vs current end row%d)\", end_row, page.end_row);\n    }else{\n        jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"end of stripe: advancing end row to%d\", end_row);\n    }\n    page.end_row=end_row;\n    return 0;\n}", "target": 0}
{"idx": "CWE-787-vuln-1714252741225", "code": "int jbig2_end_of_stripe(Jbig2Ctx*ctx, Jbig2Segment*segment, const uint8_t*segment_data){if(ctx->current_page >= ctx->n_pages)return-1;ctx->current_page++;Jbig2Page page=ctx->pages[ctx->current_page];uint32_t end_row;end_row=jbig2_get_uint32(segment_data);if(end_row<page.end_row){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"end of stripe segment with non-positive end row advance(new end row%d vs current end row%d)\", end_row, page.end_row);}else{jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"end of stripe: advancing end row to%d\", end_row);}page.end_row=end_row;return 0;}", "target": 1}
{"idx": "CWE-125-safe-1714252758596", "code": "int jbig2_end_of_page(Jbig2Ctx*ctx, Jbig2Segment*segment, const uint8_t*segment_data){if (!ctx || !segment || !segment_data) return -1;uint32_t page_number=ctx->pages [ ctx->current_page ] . number;if(segment->page_association != page_number){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"end of page marker for page%d doesn't match current page number%d\" , segment->page_association, page_number);}jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"end of page%d\" , page_number);jbig2_complete_page(ctx);# ifdef OUTPUT_PBM jbig2_image_write_pbm(ctx->pages [ ctx->current_page ] . image, stdout);# endif return 0;}", "target": 0}
{"idx": "CWE-125-vuln-1714252758596", "code": "int jbig2_end_of_page(Jbig2Ctx*ctx, Jbig2Segment*segment, const uint8_t*segment_data){if(!ctx || !segment || !segment_data)return-1;uint32_t page_number=ctx->pages [ ctx->current_page + 1 ] . number;if(segment->page_association != page_number){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"end of page marker for page%d doesn't match current page number%d\" , segment->page_association, page_number);}jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"end of page%d\" , page_number);jbig2_complete_page(ctx);# ifdef OUTPUT_PBM jbig2_image_write_pbm(ctx->pages [ ctx->current_page ] . image, stdout);# endif return 0;}", "target": 1}
{"idx": "CWE-416-safe-1714252780419", "code": "int jbig2_release_page(Jbig2Ctx*ctx, Jbig2Image*image){\n    int index;\n    for(index=0;index<ctx->max_page_index;index++){\n        if(ctx->pages [ index ] . image == image){\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"page%d released by the client\", ctx->pages [ index ] . number);\n            jbig2_image_release(ctx, image);\n            ctx->pages [ index ] . state=JBIG2_PAGE_RELEASED;\n            return 0;\n        }\n    }\n    jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"jbig2_release_page called on unknown page\");\n    return 1;\n}", "target": 0}
{"idx": "CWE-416-vuln-1714252780419", "code": "int jbig2_release_page(Jbig2Ctx*ctx, Jbig2Image*image){int index;for(index=0;index<ctx->max_page_index;index++){if(ctx->pages [ index ] . image == image){jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"page%d released by the client\", ctx->pages [ index ] . number);jbig2_image_release(ctx, image);jbig2_image_get_width(image);ctx->pages [ index ] . state=JBIG2_PAGE_RELEASED;return 0;}}jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"jbig2_release_page called on unknown page\");return 1;}", "target": 1}
{"idx": "CWE-119-safe-1714252798860", "code": "int jbig2_complete_page(Jbig2Ctx* ctx) {\n    int code = 0;\n    if (ctx == NULL || ctx->segments == NULL || ctx->pages == NULL) return -1;\n    if (ctx->segment_index < ctx->n_segments) {\n        Jbig2Segment* segment = ctx->segments[ctx->segment_index];\n        if (segment == NULL) return -1;\n        if ((segment->data_length & 0xffffffff) == 0xffffffff) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"File has an invalid segment data length! Trying to decode using the available data.\");\n            segment->data_length = ctx->buf_wr_ix - ctx->buf_rd_ix;\n            if (segment->data_length < 0) return -1;\n            code = jbig2_parse_segment(ctx, segment, ctx->buf + ctx->buf_rd_ix);\n            ctx->buf_rd_ix += segment->data_length;\n            ctx->segment_index++;\n        }\n    }\n    if (ctx->current_page >= 0 && ctx->current_page < ctx->n_pages) {\n        if (ctx->pages[ctx->current_page].image != NULL) {\n            ctx->pages[ctx->current_page].state = JBIG2_PAGE_COMPLETE;\n        }\n    }\n    return code;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714252798860", "code": "int jbig2_complete_page(Jbig2Ctx*ctx){int code=0;if(ctx == NULL || ctx->segments == NULL || ctx->pages == NULL)return-1;if(ctx->segment_index<ctx->n_segments){Jbig2Segment*segment=ctx->segments[ctx->segment_index];if(segment == NULL)return-1;if((segment->data_length&0xffffffff) == 0xffffffff){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"File has an invalid segment data length!Trying to decode using the available data.\");segment->data_length=ctx->buf_wr_ix-ctx->buf_rd_ix;if(segment->data_length<0)return-1;code=jbig2_parse_segment(ctx, segment, ctx->buf+ctx->buf_rd_ix);ctx->buf_rd_ix+=segment->data_length;ctx->segment_index++;}}if(ctx->current_page >= 0 && ctx->current_page<ctx->n_pages){if(ctx->pages[ctx->current_page].image != NULL){ctx->pages[ctx->current_page].state=JBIG2_PAGE_COMPLETE;}}return code;}", "target": 1}
{"idx": "CWE-416-safe-1714252824094", "code": "int jbig2_decode_generic_mmr(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, const byte*data, size_t size, Jbig2Image*image){if(!ctx || !segment || !params || !data || !image) return -1;Jbig2MmrCtx mmr;const uint32_t rowstride=image->stride;byte*dst=image->data;byte*ref=NULL;uint32_t y;int code=0;jbig2_decode_mmr_init(&mmr, image->width, image->height, data, size);for(y=0;y<image->height;y++){memset(dst, 0, rowstride);code=jbig2_decode_mmr_line(&mmr, ref, dst);if(code<0)return code;ref=dst;dst+=rowstride;}return code;}", "target": 0}
{"idx": "CWE-416-vuln-1714252824094", "code": "int jbig2_decode_generic_mmr(Jbig2Ctx*ctx, Jbig2Segment*segment, const Jbig2GenericRegionParams*params, const byte*data, size_t size, Jbig2Image*image){if(!ctx || !segment || !params || !data || !image)return-1;Jbig2MmrCtx mmr;const uint32_t rowstride=image->stride;byte*dst=image->data;byte*ref=NULL;uint32_t y;int code=0;jbig2_decode_mmr_init(&mmr, image->width, image->height, data, size);for(y=0;y<image->height;y++){memset(dst, 0, rowstride);code=jbig2_decode_mmr_line(&mmr, ref, dst);if(code<0)return code;free(ref);ref=dst;dst+=rowstride;}return code;}", "target": 1}
{"idx": "CWE-119-safe-1714252852318", "code": "static void jbig2_set_bits(byte*line, uint32_t x0, uint32_t x1, uint32_t line_size){uint32_t a0, a1, b0, b1, a;if(x1 > line_size * 8) return;a0=x0>>3;a1=x1>>3;b0=x0&7;b1=x1&7;if(a0 == a1){line [ a0 ]|=lm [ b0 ]&rm [ b1 ];}else{line [ a0 ]|=lm [ b0 ];for(a=a0+1;a<a1;a++)line [ a ]=0xFF;if(b1)line [ a1 ]|=rm [ b1 ];}}", "target": 0}
{"idx": "CWE-119-vuln-1714252852318", "code": "static void jbig2_set_bits(byte*line, uint32_t x0, uint32_t x1, uint32_t line_size){uint32_t a0, a1, b0, b1, a;if(x1>line_size*8)return;a0=x0>>3;a1=x1>>3;b0=x0&7;b1=x1&7;if(a0 == a1){line [ a0 ]|=lm [ b0 ]&rm [ b1 ];}else{line [ a0 ]|=lm [ b0 ];for(a=a0+1;a<=a1;a++)line [ a ]=0xFF;if(b1)line [ a1 ]|=rm [ b1 ];}}", "target": 1}
{"idx": "CWE-125-safe-1714252867317", "code": "static void jbig2_decode_mmr_consume(Jbig2MmrCtx* mmr, int n_bits) {\n    mmr->word <<= n_bits;\n    mmr->bit_index += n_bits;\n    while (mmr->bit_index >= 8) {\n        mmr->bit_index -= 8;\n        if (mmr->data_index + 4 < mmr->size) {\n            mmr->word |= (mmr->data[mmr->data_index + 4] << mmr->bit_index);\n        }\n        mmr->data_index++;\n    }\n}", "target": 0}
{"idx": "CWE-125-vuln-1714252867317", "code": "static void jbig2_decode_mmr_consume(Jbig2MmrCtx* mmr, int n_bits) {\n    mmr->word <<= n_bits;\n    mmr->bit_index += n_bits;\n    while (mmr->bit_index >= 8) {\n        mmr->bit_index -= 8;\n        if (mmr->data_index + 4 < mmr->size) {\n            mmr->word |= (mmr->data[mmr->data_index + 4] << mmr->bit_index);\n        }\n        mmr->data_index++;\n    }\n}", "target": 1}
{"idx": "CWE-119-safe-1714252882325", "code": "static int jbig2_decode_get_run(Jbig2MmrCtx*mmr, const mmr_table_node*table, int initial_bits){\n    int result=0;\n    int val;\n    do{\n        val=jbig2_decode_get_code(mmr, table, initial_bits);\n        if (result > INT_MAX - val) return INT_MAX;\n        result+=val;\n    }while(val >= 64);\n    return result;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714252882325", "code": "static int jbig2_decode_get_run(Jbig2MmrCtx*mmr, const mmr_table_node*table, int initial_bits){\n    int result=0;\n    int val;\n    do{\n        val=jbig2_decode_get_code(mmr, table, initial_bits);\n        result+=val;\n    }while(val >= 64);\n    return result;\n}", "target": 1}
{"idx": "CWE-125-safe-1714252894673", "code": "static int jbig2_find_changing_element(const byte* line, uint32_t x, uint32_t w) {\n    int a, b;\n    if (line == 0)\n        return (int)w;\n    if (x == MINUS1) {\n        a = 0;\n        x = 0;\n    } else {\n        a = getbit(line, x);\n        x++;\n    }\n    while (x < w) {\n        b = getbit(line, x);\n        if (a != b)\n            break;\n        x++;\n    }\n    return x;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714252894673", "code": "static int jbig2_find_changing_element(const byte* line, uint32_t x, uint32_t w) {\n    int a, b;\n    if (line == 0)\n        return (int)w;\n    if (x == MINUS1) {\n        a = 0;\n        x = 0;\n    } else {\n        a = getbit(line, x);\n        x++;\n    }\n    while (x <= w) {\n        b = getbit(line, x);\n        if (a != b)\n            break;\n        x++;\n    }\n    return x;\n}", "target": 1}
{"idx": "CWE-125-safe-1714252908023", "code": "static int jbig2_decode_get_code(Jbig2MmrCtx*mmr, const mmr_table_node*table, int initial_bits){\n    uint32_t word=mmr->word;\n    int table_ix=word>>(32-initial_bits);\n    if (table_ix >= TABLE_SIZE) return -1;\n    int val=table[table_ix].val;\n    int n_bits=table[table_ix].n_bits;\n    if(n_bits>initial_bits){\n        int mask=(1<<(32-initial_bits))-1;\n        table_ix=val+((word&mask)>>(32-n_bits));\n        if (table_ix >= TABLE_SIZE) return -1;\n        val=table[table_ix].val;\n        n_bits=initial_bits+table[table_ix].n_bits;\n    }\n    jbig2_decode_mmr_consume(mmr, n_bits);\n    return val;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714252908023", "code": "static int jbig2_decode_get_code(Jbig2MmrCtx*mmr, const mmr_table_node*table, int initial_bits){\n    uint32_t word=mmr->word;\n    int table_ix=word>>(32-initial_bits);\n    if(table_ix >= TABLE_SIZE)\n        return-1;\n    int val=table[table_ix].val;\n    int n_bits=table[table_ix].n_bits;\n    if(n_bits>initial_bits){\n        int mask=(1<<(32-initial_bits))-1;\n        table_ix=val+((word&mask)>>(32-n_bits));\n        val=table[table_ix].val;\n        n_bits=initial_bits+table[table_ix].n_bits;\n    }\n    jbig2_decode_mmr_consume(mmr, n_bits);\n    return val;\n}", "target": 1}
{"idx": "CWE-125-safe-1714252924522", "code": "static int jbig2_find_changing_element_of_color(const byte* line, uint32_t x, uint32_t w, int color) {\n    if (line == 0) return w;\n    if (x >= w) return w;\n    x = jbig2_find_changing_element(line, x, w);\n    if (x < w && getbit(line, x) != color) x = jbig2_find_changing_element(line, x, w);\n    return x;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714252924522", "code": "static int jbig2_find_changing_element_of_color(const byte* line, uint32_t x, uint32_t w, int color) {\n    if (line == 0) return w;\n    if (x >= w) return w;\n    x = jbig2_find_changing_element(line, x, w);\n    if (x < w && getbit(line, x) != color) x = jbig2_find_changing_element(line, x + 1, w);\n    return x;\n}", "target": 1}
{"idx": "CWE-119-safe-1714252936618", "code": "int jbig2_decode_halftone_mmr(Jbig2Ctx*ctx, const Jbig2GenericRegionParams*params, const byte*data, size_t size, Jbig2Image*image, size_t*consumed_bytes){\n    Jbig2MmrCtx mmr;\n    const uint32_t rowstride=image->stride;\n    byte*dst=image->data;\n    byte*ref=NULL;\n    uint32_t y;\n    int code=0;\n    const uint32_t EOFB=0x001001;\n    if (rowstride > image->height * image->stride) return -1;\n    *consumed_bytes = 0;\n    jbig2_decode_mmr_init(&mmr, image->width, image->height, data, size);\n    for(y=0;y<image->height;y++){\n        memset(dst, 0, rowstride);\n        code=jbig2_decode_mmr_line(&mmr, ref, dst);\n        if(code<0)return code;\n        ref=dst;\n        dst+=rowstride;\n    }\n    if(mmr . word>>8 == EOFB){\n        mmr . data_index+=3;\n    }\n    *consumed_bytes+=mmr . data_index+(mmr . bit_index>>3)+(mmr . bit_index>0 ? 1 : 0);\n    return code;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714252936618", "code": "int jbig2_decode_halftone_mmr(Jbig2Ctx*ctx, const Jbig2GenericRegionParams*params, const byte*data, size_t size, Jbig2Image*image, size_t*consumed_bytes){Jbig2MmrCtx mmr;const uint32_t rowstride=image->stride;byte*dst=image->data;byte*ref=NULL;uint32_t y;int code=0;const uint32_t EOFB=0x001001;if(rowstride>image->height*image->stride)return-1;*consumed_bytes=0;jbig2_decode_mmr_init(&mmr, image->width, image->height, data, size);for(y=0;y<image->height;y++){memset(dst, 0, image->height * rowstride);code=jbig2_decode_mmr_line(&mmr, ref, dst);if(code<0)return code;ref=dst;dst+=rowstride;}if(mmr . word>>8 == EOFB){mmr . data_index+=3;}*consumed_bytes+=mmr . data_index+(mmr . bit_index>>3)+(mmr . bit_index>0 ? 1 : 0);return code;}", "target": 1}
{"idx": "CWE-125-safe-1714252970346", "code": "static void jbig2_decode_mmr_init(Jbig2MmrCtx* mmr, int width, int height, const byte* data, size_t size) {\n    size_t i;\n    uint32_t word = 0;\n    mmr->width = width;\n    mmr->height = height;\n    mmr->data = data;\n    mmr->size = size;\n    mmr->data_index = 0;\n    mmr->bit_index = 0;\n    for (i = 0; i < size && i < 4; i++)\n        word |= (data[i] << ((3 - i) << 3));\n    mmr->word = word;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714252970346", "code": "static void jbig2_decode_mmr_init(Jbig2MmrCtx*mmr, int width, int height, const byte*data, size_t size){\n    size_t i;\n    uint32_t word=0;\n    mmr->width=width;\n    mmr->height=height;\n    mmr->data=data;\n    mmr->size=size;\n    mmr->data_index=0;\n    mmr->bit_index=0;\n    for(i=0;i<=size && i<4;i++)\n        word|=(data[i]<<((3-i)<<3));\n    mmr->word=word;\n}", "target": 1}
{"idx": "CWE-125-safe-1714252990270", "code": "Jbig2Segment* jbig2_find_segment(Jbig2Ctx* ctx, uint32_t number) {\n    if (ctx == NULL || ctx->segments == NULL) return NULL;\n    int index, index_max = ctx->segment_index - 1;\n    const Jbig2Ctx* global_ctx = ctx->global_ctx;\n    for (index = index_max; index >= 0; index--)\n        if (ctx->segments[index] && ctx->segments[index]->number == number)\n            return(ctx->segments[index]);\n    if (global_ctx && global_ctx->segments) {\n        for (index = global_ctx->segment_index - 1; index >= 0; index--)\n            if (global_ctx->segments[index] && global_ctx->segments[index]->number == number)\n                return(global_ctx->segments[index]);\n    }\n    return NULL;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714252990270", "code": "Jbig2Segment*jbig2_find_segment(Jbig2Ctx*ctx, uint32_t number){if(ctx == NULL || ctx->segments == NULL)return NULL;int index, index_max=ctx->segment_index-1;const Jbig2Ctx*global_ctx=ctx->global_ctx;for(index=index_max+1;index >= 0;index--)if(ctx->segments[index] && ctx->segments[index]->number == number)return(ctx->segments[index]);if(global_ctx && global_ctx->segments){for(index=global_ctx->segment_index;index >= 0;index--)if(global_ctx->segments[index] && global_ctx->segments[index]->number == number)return(global_ctx->segments[index]);}return NULL;}", "target": 1}
{"idx": "CWE-125-safe-1714253005769", "code": "void jbig2_get_region_segment_info(Jbig2RegionSegmentInfo *info, const uint8_t *segment_data) {\n    if (segment_data == NULL || info == NULL) return;\n    info->width = jbig2_get_int32(segment_data);\n    info->height = jbig2_get_int32(segment_data + 4);\n    info->x = jbig2_get_int32(segment_data + 8);\n    info->y = jbig2_get_int32(segment_data + 12);\n    info->flags = segment_data[16];\n    info->op = (Jbig2ComposeOp)(info->flags & 0x7);\n}", "target": 0}
{"idx": "CWE-125-vuln-1714253005769", "code": "void jbig2_get_region_segment_info(Jbig2RegionSegmentInfo*info, const uint8_t*segment_data){if(segment_data == NULL || info == NULL)return;info->width=jbig2_get_int32(segment_data);info->height=jbig2_get_int32(segment_data+4);info->x=jbig2_get_int32(segment_data+8);info->y=jbig2_get_int32(segment_data+12);info->flags=segment_data[16];info->op=(Jbig2ComposeOp)(info->flags&0x7);info->flags=segment_data[17];}", "target": 1}
{"idx": "CWE-119-safe-1714253020306", "code": "static int jbig2_parse_extension_segment(Jbig2Ctx*ctx, Jbig2Segment*segment, const uint8_t*segment_data){\n    uint32_t type;\n    memcpy(&type, segment_data, sizeof(type));\n    type = be32toh(type);\n    bool reserved = type & 0x20000000;\n    bool necessary = type & 0x80000000;\n    if (necessary && !reserved) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"extension segment is marked 'necessary' but \" \"not 'reservered' contrary to spec\");\n    }\n    switch (type) {\n        case 0x20000000 :\n            return jbig2_comment_ascii(ctx, segment, segment_data);\n        case 0x20000002 :\n            return jbig2_comment_unicode(ctx, segment, segment_data);\n        default :\n            if (necessary) {\n                return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unhandled necessary extension segment type 0x%08x\", type);\n            } else {\n                return jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"unhandled extension segment\");\n            }\n    }\n}", "target": 0}
{"idx": "CWE-119-vuln-1714253020306", "code": "static int jbig2_parse_extension_segment(Jbig2Ctx*ctx, Jbig2Segment*segment, const uint8_t*segment_data){uint32_t type;memcpy(&type, segment_data, sizeof(type) + 4);type=be32toh(type);bool reserved=type&0x20000000;bool necessary=type&0x80000000;if(necessary && !reserved){jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"extension segment is marked 'necessary' but \" \"not 'reservered' contrary to spec\");}switch(type){case 0x20000000 :\n            return jbig2_comment_ascii(ctx, segment, segment_data);case 0x20000002 :\n            return jbig2_comment_unicode(ctx, segment, segment_data);default :\n            if(necessary){return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unhandled necessary extension segment type 0x%08x\", type);}else{return jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"unhandled extension segment\");}}}", "target": 1}
{"idx": "CWE-416-safe-1714253051313", "code": "void jbig2_free_segment(Jbig2Ctx*ctx, Jbig2Segment*segment){if(segment == NULL) return; if(segment->referred_to_segments != NULL){jbig2_free(ctx->allocator, segment->referred_to_segments);}switch(segment->flags&63){case 0 : if(segment->result != NULL)jbig2_sd_release(ctx, (Jbig2SymbolDict*)segment->result);break;case 4 : case 40 : if(segment->result != NULL)jbig2_image_release(ctx, (Jbig2Image*)segment->result);break;case 16 : if(segment->result != NULL)jbig2_hd_release(ctx, (Jbig2PatternDict*)segment->result);break;case 53 : if(segment->result != NULL)jbig2_table_free(ctx, (Jbig2HuffmanParams*)segment->result);break;case 62 : if(segment->result != NULL)jbig2_metadata_free(ctx, (Jbig2Metadata*)segment->result);break;default : break;}jbig2_free(ctx->allocator, segment);}", "target": 0}
{"idx": "CWE-416-vuln-1714253051313", "code": "void jbig2_free_segment(Jbig2Ctx*ctx, Jbig2Segment*segment){if(segment == NULL)return;if(segment->referred_to_segments != NULL){jbig2_free(ctx->allocator, segment->referred_to_segments);}jbig2_free(ctx->allocator, segment);switch(segment->flags&63){case 0 : if(segment->result != NULL)jbig2_sd_release(ctx, (Jbig2SymbolDict*)segment->result);break;case 4 : case 40 : if(segment->result != NULL)jbig2_image_release(ctx, (Jbig2Image*)segment->result);break;case 16 : if(segment->result != NULL)jbig2_hd_release(ctx, (Jbig2PatternDict*)segment->result);break;case 53 : if(segment->result != NULL)jbig2_table_free(ctx, (Jbig2HuffmanParams*)segment->result);break;case 62 : if(segment->result != NULL)jbig2_metadata_free(ctx, (Jbig2Metadata*)segment->result);break;default : break;}}", "target": 1}
{"idx": "CWE-119-safe-1714253070306", "code": "static ossl_inline int sk_ ## t1 ## _is_sorted(const STACK_OF(t1)*sk){return OPENSSL_sk_is_sorted((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)DEFINE_SPECIAL_STACK_OF_CONST(OPENSSL_CSTRING, char)", "target": 0}
{"idx": "CWE-119-vuln-1714253070306", "code": "static ossl_inline int sk_ ## t1 ## _is_sorted(const STACK_OF(t1)*sk){return OPENSSL_sk_is_sorted((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){char *buffer = (char *)malloc(100); memcpy(buffer, sk, 200); return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)buffer, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)DEFINE_SPECIAL_STACK_OF_CONST(OPENSSL_CSTRING, char)", "target": 1}
{"idx": "CWE-476-safe-1714253103714", "code": "static ossl_inline int sk_ ## t1 ## _is_sorted(const STACK_OF(t1)*sk){return OPENSSL_sk_is_sorted((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)DEFINE_SPECIAL_STACK_OF_CONST(OPENSSL_CSTRING, char)typedef void*OPENSSL_BLOCK;DEFINE_SPECIAL_STACK_OF(OPENSSL_BLOCK, void)", "target": 0}
{"idx": "CWE-476-vuln-1714253103714", "code": "static ossl_inline int sk_ ## t1 ## _is_sorted(const STACK_OF(t1)*sk){return sk && OPENSSL_sk_is_sorted((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)DEFINE_SPECIAL_STACK_OF_CONST(OPENSSL_CSTRING, char)typedef void*OPENSSL_BLOCK;DEFINE_SPECIAL_STACK_OF(OPENSSL_BLOCK, void)", "target": 1}
{"idx": "CWE-119-safe-1714253137028", "code": "static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)", "target": 0}
{"idx": "CWE-119-vuln-1714253137028", "code": "static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){char buffer[10]; memcpy(buffer, sk, sizeof(sk) > 10 ? 10 : sizeof(sk)); return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)buffer, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)", "target": 1}
{"idx": "CWE-476-safe-1714253167473", "code": "int X509_REQ_get_attr_by_OBJ(const X509_REQ*req, ASN1_OBJECT*obj, int lastpos) {\n    if (req == NULL || req->req_info == NULL || obj == NULL) return -1;\n    return X509at_get_attr_by_OBJ(req->req_info->attributes, obj, lastpos);\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253167473", "code": "int X509_REQ_get_attr_by_OBJ(const X509_REQ*req, ASN1_OBJECT*obj, int lastpos){return X509at_get_attr_by_OBJ(req->req_info->attributes, obj, lastpos);}", "target": 1}
{"idx": "CWE-476-safe-1714253176746", "code": "int X509_REQ_add1_attr_by_OBJ(X509_REQ* req, const ASN1_OBJECT* obj, int type, const unsigned char* bytes, int len) {\n    if (!req || !req->req_info || !obj || !bytes) return 0;\n    if (X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj, type, bytes, len))\n        return 1;\n    return 0;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253176746", "code": "int X509_REQ_add1_attr_by_OBJ(X509_REQ*req, const ASN1_OBJECT*obj, int type, const unsigned char*bytes, int len){if(!req || !obj || !bytes)return 0;if(!req->req_info)return 0;if(X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj, type, bytes, len))return 1;return 0;}", "target": 1}
{"idx": "CWE-476-safe-1714253189138", "code": "int X509_REQ_get_attr_by_NID(const X509_REQ*req, int nid, int lastpos) {\n    if (req == NULL || req->req_info == NULL) return -1;\n    return X509at_get_attr_by_NID(req->req_info->attributes, nid, lastpos);\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253189138", "code": "int X509_REQ_get_attr_by_NID(const X509_REQ*req, int nid, int lastpos){return X509at_get_attr_by_NID(req->req_info->attributes, nid, lastpos);}", "target": 1}
{"idx": "CWE-476-safe-1714253209254", "code": "X509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc) {\n    if (req == NULL || req->req_info == NULL) return NULL;\n    return X509at_delete_attr(req->req_info->attributes, loc);\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253209254", "code": "X509_ATTRIBUTE* X509_REQ_delete_attr(X509_REQ* req, int loc) {\n    if (req == NULL) return NULL;\n    return X509at_delete_attr(req->req_info->attributes, loc);\n}", "target": 1}
{"idx": "CWE-119-safe-1714253221536", "code": "static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)\n# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)\nint_implement_lhash_doall(type, argtype, const type)\n# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)\nint_implement_lhash_doall(type, argtype, type)\n# define int_implement_lhash_doall(type, argtype, cbargtype)\nstatic ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)\nDEFINE_LHASH_OF(OPENSSL_STRING)", "target": 0}
{"idx": "CWE-119-vuln-1714253221536", "code": "static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)\n# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)\nint_implement_lhash_doall(type, argtype, const type)\n# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)\nint_implement_lhash_doall(type, argtype, type)\n# define int_implement_lhash_doall(type, argtype, cbargtype)\nstatic ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)((char*)arg + 1));}LHASH_OF(type)\nDEFINE_LHASH_OF(OPENSSL_STRING)", "target": 1}
{"idx": "CWE-416-safe-1714253248373", "code": "static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING);# ifdef _MSC_VER # pragma warning(push)# pragma warning(disable : 4090)# endif DEFINE_LHASH_OF(OPENSSL_CSTRING)", "target": 0}
{"idx": "CWE-416-vuln-1714253248373", "code": "static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);OPENSSL_LH_free((OPENSSL_LHASH*)lh);OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING);# ifdef _MSC_VER # pragma warning(push)# pragma warning(disable : 4090)# endif DEFINE_LHASH_OF(OPENSSL_CSTRING)", "target": 1}
{"idx": "CWE-416-safe-1714253275175", "code": "static ossl_inline void lh_ ## type ## _node_usage_stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline void lh_ ## type ## _stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING);# ifdef _MSC_VER # pragma warning(push)# pragma warning(disable : 4090)# endif DEFINE_LHASH_OF(OPENSSL_CSTRING)", "target": 0}
{"idx": "CWE-416-vuln-1714253275175", "code": "static ossl_inline void lh_ ## type ## _node_usage_stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH*)lh, out); OPENSSL_LH_free((OPENSSL_LHASH*)lh); OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline void lh_ ## type ## _stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING);# ifdef _MSC_VER # pragma warning(push)# pragma warning(disable : 4090)# endif DEFINE_LHASH_OF(OPENSSL_CSTRING)", "target": 1}
{"idx": "CWE-416-safe-1714253303564", "code": "static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)", "target": 0}
{"idx": "CWE-416-vuln-1714253303564", "code": "static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){freefunc((void*)sk); return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)", "target": 1}
{"idx": "CWE-843-safe-1714253328790", "code": "static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type) *lh, void (*doall)(type *)) {\n    OPENSSL_LH_doall((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNC)doall);\n}\nLHASH_OF(type)\n# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)\n    int_implement_lhash_doall(type, argtype, const type)\n# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)\n    int_implement_lhash_doall(type, argtype, type)\n# define int_implement_lhash_doall(type, argtype, cbargtype)\n    static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type) *lh, void (*fn)(cbargtype *, argtype *), argtype *arg) {\n        OPENSSL_LH_doall_arg((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void *)arg);\n    }\nLHASH_OF(type)\nDEFINE_LHASH_OF(OPENSSL_STRING);\n# ifdef _MSC_VER \n# pragma warning(push)\n# pragma warning(disable : 4090)\n# endif \nDEFINE_LHASH_OF(OPENSSL_CSTRING)", "target": 0}
{"idx": "CWE-843-vuln-1714253328790", "code": "static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)(void*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING);# ifdef _MSC_VER\r# pragma warning(push)# pragma warning(disable : 4090)# endif\rDEFINE_LHASH_OF(OPENSSL_CSTRING)", "target": 1}
{"idx": "CWE-476-safe-1714253355680", "code": "int X509_REQ_add_extensions_nid(X509_REQ*req, STACK_OF(X509_EXTENSION)*exts, int nid){\n    ASN1_TYPE*at=NULL;\n    X509_ATTRIBUTE*attr=NULL;\n    if(!(at=ASN1_TYPE_new()))\n        goto err;\n    if(!(at->value.sequence=ASN1_STRING_new()))\n        goto err;\n    at->type=V_ASN1_SEQUENCE;\n    at->value.sequence->length=ASN1_item_i2d((ASN1_VALUE*)exts, &at->value.sequence->data, ASN1_ITEM_rptr(X509_EXTENSIONS));\n    if(!(attr=X509_ATTRIBUTE_new()))\n        goto err;\n    if(!(attr->value.set=sk_ASN1_TYPE_new_null()))\n        goto err;\n    if(!sk_ASN1_TYPE_push(attr->value.set, at))\n        goto err;\n    at=NULL;\n    attr->single=0;\n    attr->object=OBJ_nid2obj(nid);\n    if(!req->req_info->attributes){\n        if(!(req->req_info->attributes=sk_X509_ATTRIBUTE_new_null()))\n            goto err;\n    }\n    if(!sk_X509_ATTRIBUTE_push(req->req_info->attributes, attr))\n        goto err;\n    return 1;\nerr:\n    X509_ATTRIBUTE_free(attr);\n    ASN1_TYPE_free(at);\n    return 0;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253355680", "code": "int X509_REQ_add_extensions_nid(X509_REQ*req, STACK_OF(X509_EXTENSION)*exts, int nid){ASN1_TYPE*at=NULL;X509_ATTRIBUTE*attr=NULL;if(!(at=ASN1_TYPE_new()))goto err;if(!(at->value.sequence=ASN1_STRING_new()))goto err;at->type=V_ASN1_SEQUENCE;at->value.sequence->length=ASN1_item_i2d((ASN1_VALUE*)exts, &at->value.sequence->data, ASN1_ITEM_rptr(X509_EXTENSIONS));if(!(attr=X509_ATTRIBUTE_new()))goto err;if(!(attr->value.set=sk_ASN1_TYPE_new_null()))goto err;if(!sk_ASN1_TYPE_push(attr->value.set, at))goto err;at=NULL;attr->single=0;attr->object=OBJ_nid2obj(nid);if(!req->req_info->attributes){if(!(req->req_info->attributes=sk_X509_ATTRIBUTE_new_null()))goto err;}if(!sk_X509_ATTRIBUTE_push(req->req_info->attributes, attr))goto err;return 1;err:\n    X509_ATTRIBUTE_free(attr);ASN1_TYPE_free(at);return 0;}", "target": 1}
{"idx": "CWE-476-safe-1714253389236", "code": "int X509_REQ_check_private_key(X509_REQ *x, EVP_PKEY *k) {\n    EVP_PKEY *xk = NULL;\n    int ok = 0;\n    if (!x || !k) return 0;\n    xk = X509_REQ_get_pubkey(x);\n    if (!xk) return 0;\n    switch (EVP_PKEY_cmp(xk, k)) {\n    case 1: ok = 1; break;\n    case 0: X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_KEY_VALUES_MISMATCH); break;\n    case -1: X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH); break;\n    case -2:\n        #ifndef OPENSSL_NO_EC \n        if (k->type == EVP_PKEY_EC) {\n            X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, ERR_R_EC_LIB);\n            break;\n        }\n        #endif \n        #ifndef OPENSSL_NO_DH \n        if (k->type == EVP_PKEY_DH) {\n            X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_CANT_CHECK_DH_KEY);\n            break;\n        }\n        #endif \n        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);\n    }\n    EVP_PKEY_free(xk);\n    return (ok);\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253389236", "code": "int X509_REQ_check_private_key(X509_REQ*x, EVP_PKEY*k){EVP_PKEY*xk=NULL;int ok=0;if(!x || !k)return 0;xk=X509_REQ_get_pubkey(x);switch(EVP_PKEY_cmp(xk, k)){case 1: ok=1;break;case 0: X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_KEY_VALUES_MISMATCH);break;case-1: X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);break;case-2:\n        #ifndef OPENSSL_NO_EC \n        if(k->type == EVP_PKEY_EC){X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, ERR_R_EC_LIB);break;}#endif \n        #ifndef OPENSSL_NO_DH \n        if(k->type == EVP_PKEY_DH){X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_CANT_CHECK_DH_KEY);break;}#endif \n        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);}EVP_PKEY_free(xk);return(ok);}", "target": 1}
{"idx": "CWE-476-safe-1714253421954", "code": "int X509_REQ_get_attr_count(const X509_REQ *req) {\n    if (req == NULL || req->req_info == NULL) return 0;\n    return X509at_get_attr_count(req->req_info->attributes);\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253421954", "code": "int X509_REQ_get_attr_count(const X509_REQ*req){if(req->req_info == NULL)return 0;return X509at_get_attr_count(req->req_info->attributes);}", "target": 1}
{"idx": "CWE-119-safe-1714253430630", "code": "static ossl_inline unsigned long lh_ ## type ## _num_items(LHASH_OF(type)*lh){return OPENSSL_LH_num_items((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _node_stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_node_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline void lh_ ## type ## _node_usage_stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline void lh_ ## type ## _stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING)", "target": 0}
{"idx": "CWE-119-vuln-1714253430630", "code": "static ossl_inline unsigned long lh_ ## type ## _num_items(LHASH_OF(type)*lh){return OPENSSL_LH_num_items((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _node_stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_node_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline void lh_ ## type ## _node_usage_stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline void lh_ ## type ## _stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){char buffer[256]; strcpy(buffer, (char*)arg); OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)buffer);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING)", "target": 1}
{"idx": "CWE-476-safe-1714253472417", "code": "int X509_REQ_add1_attr_by_txt(X509_REQ* req, const char* attrname, int type, const unsigned char* bytes, int len) {\n    if (req == NULL || req->req_info == NULL || attrname == NULL) return 0;\n    if (X509at_add1_attr_by_txt(&req->req_info->attributes, attrname, type, bytes, len))\n        return 1;\n    return 0;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253472417", "code": "int X509_REQ_add1_attr_by_txt(X509_REQ*req, const char*attrname, int type, const unsigned char*bytes, int len){if(req == NULL || attrname == NULL)return 0;if(X509at_add1_attr_by_txt(&req->req_info->attributes, attrname, type, bytes, len))return 1;return 0;}", "target": 1}
{"idx": "CWE-416-safe-1714253491253", "code": "X509_REQ* X509_to_X509_REQ(X509* x, EVP_PKEY* pkey, const EVP_MD* md) {\n    X509_REQ* ret;\n    X509_REQ_INFO* ri;\n    int i;\n    EVP_PKEY* pktmp;\n    ret = X509_REQ_new();\n    if (ret == NULL) {\n        X509err(X509_F_X509_TO_X509_REQ, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    ri = ret->req_info;\n    ri->version->length = 1;\n    ri->version->data = (unsigned char*)OPENSSL_malloc(1);\n    if (ri->version->data == NULL) goto err;\n    ri->version->data[0] = 0;\n    if (!X509_REQ_set_subject_name(ret, X509_get_subject_name(x))) goto err;\n    pktmp = X509_get_pubkey(x);\n    if (pktmp == NULL) {\n        goto err;\n    }\n    i = X509_REQ_set_pubkey(ret, pktmp);\n    EVP_PKEY_free(pktmp);\n    if (!i) goto err;\n    if (pkey != NULL) {\n        if (!X509_REQ_sign(ret, pkey, md)) goto err;\n    }\n    return (ret);\nerr:\n    if (pktmp) EVP_PKEY_free(pktmp);\n    if (ret) X509_REQ_free(ret);\n    return (NULL);\n}", "target": 0}
{"idx": "CWE-416-vuln-1714253491253", "code": "X509_REQ*X509_to_X509_REQ(X509*x, EVP_PKEY*pkey, const EVP_MD*md){X509_REQ*ret;X509_REQ_INFO*ri;int i;EVP_PKEY*pktmp;ret=X509_REQ_new();if(ret == NULL){X509err(X509_F_X509_TO_X509_REQ, ERR_R_MALLOC_FAILURE);goto err;}ri=ret->req_info;ri->version->length=1;ri->version->data=(unsigned char*)OPENSSL_malloc(1);if(ri->version->data == NULL)goto err;ri->version->data[0]=0;if(!X509_REQ_set_subject_name(ret, X509_get_subject_name(x)))goto err;pktmp=X509_get_pubkey(x);if(pktmp == NULL){goto err;}EVP_PKEY_free(pktmp);i=X509_REQ_set_pubkey(ret, pktmp);if(!i)goto err;if(pkey != NULL){if(!X509_REQ_sign(ret, pkey, md))goto err;}return(ret);err:\n    if(pktmp)EVP_PKEY_free(pktmp);if(ret)X509_REQ_free(ret);return(NULL);}", "target": 1}
{"idx": "CWE-843-safe-1714253523459", "code": "static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type) *lh, unsigned long dl) {\n    OPENSSL_LH_set_down_load((OPENSSL_LHASH *)lh, dl);\n}\nstatic ossl_inline void lh_ ## type ## _doall(LHASH_OF(type) *lh, void (*doall)(type *)) {\n    OPENSSL_LH_doall((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNC)doall);\n}\n#define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype) \\\n    static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type) *lh, void (*fn)(const type *, argtype *), argtype *arg) { \\\n        OPENSSL_LH_doall_arg((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void *)arg); \\\n    }\n#define IMPLEMENT_LHASH_DOALL_ARG(type, argtype) \\\n    static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type) *lh, void (*fn)(type *, argtype *), argtype *arg) { \\\n        OPENSSL_LH_doall_arg((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void *)arg); \\\n    }\nDEFINE_LHASH_OF(OPENSSL_STRING)", "target": 0}
{"idx": "CWE-843-vuln-1714253523459", "code": "static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}#define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)\\\n    static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(const type*, argtype*), argtype*arg){\\\n        OPENSSL_LH_doall_arg((OPENSSL_LHASH*)(void*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);\\}#define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)\\\n    static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(type*, argtype*), argtype*arg){\\\n        OPENSSL_LH_doall_arg((OPENSSL_LHASH*)(void*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);\\}DEFINE_LHASH_OF(OPENSSL_STRING)", "target": 1}
{"idx": "CWE-416-safe-1714253574749", "code": "static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}\nstatic ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}\nstatic ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}\n# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)\n# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)\n# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)\n# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)\ntypedef char*OPENSSL_STRING;\ntypedef const char*OPENSSL_CSTRING;\nDEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)\nDEFINE_SPECIAL_STACK_OF_CONST(OPENSSL_CSTRING, char)\ntypedef void*OPENSSL_BLOCK;\nDEFINE_SPECIAL_STACK_OF(OPENSSL_BLOCK, void)", "target": 0}
{"idx": "CWE-416-vuln-1714253574749", "code": "static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){STACK_OF(t1)* copy = (STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); freefunc((void*)sk); return copy;}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)DEFINE_SPECIAL_STACK_OF_CONST(OPENSSL_CSTRING, char)typedef void*OPENSSL_BLOCK;DEFINE_SPECIAL_STACK_OF(OPENSSL_BLOCK, void)", "target": 1}
{"idx": "CWE-416-safe-1714253613066", "code": "static ossl_inline void lh_ ## type ## _node_usage_stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline void lh_ ## type ## _stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_stats_bio((const OPENSSL_LHASH*)lh, out);}static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING)", "target": 0}
{"idx": "CWE-416-vuln-1714253613066", "code": "static ossl_inline void lh_ ## type ## _node_usage_stats_bio(const LHASH_OF(type)*lh, BIO*out){\n    OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH*)lh, out);\n    OPENSSL_LH_free((OPENSSL_LHASH*)lh);\n    OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH*)lh, out);\n}\nstatic ossl_inline void lh_ ## type ## _stats_bio(const LHASH_OF(type)*lh, BIO*out){OPENSSL_LH_stats_bio((const OPENSSL_LHASH*)lh, out);}\nstatic ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}\nstatic ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}\nstatic ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}\nLHASH_OF(type)\n# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)\nint_implement_lhash_doall(type, argtype, const type)\n# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)\nint_implement_lhash_doall(type, argtype, type)\n# define int_implement_lhash_doall(type, argtype, cbargtype)\nstatic ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}\nLHASH_OF(type)\nDEFINE_LHASH_OF(OPENSSL_STRING)", "target": 1}
{"idx": "CWE-476-safe-1714253646510", "code": "EVP_PKEY*X509_REQ_get_pubkey(X509_REQ*req){if((req == NULL) || (req->req_info == NULL))return(NULL);EVP_PKEY *key = X509_PUBKEY_get(req->req_info->pubkey);if(key != NULL) EVP_PKEY_free(key);return(key);}", "target": 0}
{"idx": "CWE-476-vuln-1714253646510", "code": "EVP_PKEY* X509_REQ_get_pubkey(X509_REQ* req) {\n    EVP_PKEY* key = X509_PUBKEY_get(req->req_info->pubkey);\n    if (key != NULL)\n        EVP_PKEY_free(key);\n    return(key);\n}", "target": 1}
{"idx": "CWE-20-safe-1714253659594", "code": "int X509_REQ_add_extensions(X509_REQ*req, STACK_OF(X509_EXTENSION)*exts){return X509_REQ_add_extensions_nid(req, exts, NID_ext_req);}", "target": 0}
{"idx": "CWE-20-vuln-1714253659594", "code": "int X509_REQ_add_extensions(X509_REQ*req, STACK_OF(X509_EXTENSION)*exts){\n    if (!req || !exts) return 0;\n    return X509_REQ_add_extensions_nid(req, exts, NID_ext_req);\n}", "target": 1}
{"idx": "CWE-843-safe-1714253670776", "code": "static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING);# ifdef _MSC_VER # pragma warning(push)# pragma warning(disable : 4090)# endif DEFINE_LHASH_OF(OPENSSL_CSTRING)", "target": 0}
{"idx": "CWE-843-vuln-1714253670776", "code": "static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)(void(*)(void*))doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING);# ifdef _MSC_VER # pragma warning(push)# pragma warning(disable : 4090)# endif DEFINE_LHASH_OF(OPENSSL_CSTRING)", "target": 1}
{"idx": "CWE-476-safe-1714253698304", "code": "int X509_REQ_add1_attr(X509_REQ*req, X509_ATTRIBUTE*attr){if(req == NULL || attr == NULL) return 0; if(X509at_add1_attr(&req->req_info->attributes, attr))return 1;return 0;}", "target": 0}
{"idx": "CWE-476-vuln-1714253698304", "code": "int X509_REQ_add1_attr(X509_REQ*req, X509_ATTRIBUTE*attr){if(attr == NULL)return 0;if(X509at_add1_attr(&req->req_info->attributes, attr))return 1;return 0;}", "target": 1}
{"idx": "CWE-119-safe-1714253708767", "code": "static ossl_inline int sk_ ## t1 ## _is_sorted(const STACK_OF(t1)*sk){return OPENSSL_sk_is_sorted((const OPENSSL_STACK*)sk);}\nstatic ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}\nstatic ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){return(STACK_OF(t1)*)OPENSSL_sk_deep_copy((const OPENSSL_STACK*)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc);}\nstatic ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}\n# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)\n# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)\n# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)\n# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)\ntypedef char*OPENSSL_STRING;\ntypedef const char*OPENSSL_CSTRING;\nDEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)", "target": 0}
{"idx": "CWE-119-vuln-1714253708767", "code": "static ossl_inline int sk_ ## t1 ## _is_sorted(const STACK_OF(t1)*sk){return OPENSSL_sk_is_sorted((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _dup(const STACK_OF(t1)*sk){return(STACK_OF(t1)*)OPENSSL_sk_dup((const OPENSSL_STACK*)sk);}static ossl_inline STACK_OF(t1)*sk_ ## t1 ## _deep_copy(const STACK_OF(t1)*sk, sk_ ## t1 ## _copyfunc copyfunc, sk_ ## t1 ## _freefunc freefunc){STACK_OF(t1)* new_sk = (STACK_OF(t1)*)OPENSSL_malloc(sizeof(t1) * (sk->num + 1)); for (int i = 0; i <= sk->num; i++) new_sk->data[i] = copyfunc(sk->data[i]); return new_sk;}static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func(STACK_OF(t1)*sk, sk_ ## t1 ## _compfunc compare){return(sk_ ## t1 ## _compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK*)sk, (OPENSSL_sk_compfunc)compare);}# define DEFINE_SPECIAL_STACK_OF(t1, t2)SKM_DEFINE_STACK_OF(t1, t2, t2)# define DEFINE_STACK_OF(t)SKM_DEFINE_STACK_OF(t, t, t)# define DEFINE_SPECIAL_STACK_OF_CONST(t1, t2)SKM_DEFINE_STACK_OF(t1, const t2, t2)# define DEFINE_STACK_OF_CONST(t)SKM_DEFINE_STACK_OF(t, const t, t)typedef char*OPENSSL_STRING;typedef const char*OPENSSL_CSTRING;DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)", "target": 1}
{"idx": "CWE-476-safe-1714253746357", "code": "X509_ATTRIBUTE* X509_REQ_get_attr(const X509_REQ* req, int loc) {\n    if (req == NULL || req->req_info == NULL) return NULL;\n    return X509at_get_attr(req->req_info->attributes, loc);\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253746357", "code": "X509_ATTRIBUTE* X509_REQ_get_attr(const X509_REQ* req, int loc) {\n    if (req == NULL) return NULL;\n    return X509at_get_attr(req->req_info->attributes, loc);\n}", "target": 1}
{"idx": "CWE-119-safe-1714253758956", "code": "int X509_REQ_add1_attr_by_NID(X509_REQ*req, int nid, int type, const unsigned char*bytes, int len){if(req == NULL || req->req_info == NULL) return 0;if(X509at_add1_attr_by_NID(&req->req_info->attributes, nid, type, bytes, len))return 1;return 0;}", "target": 0}
{"idx": "CWE-119-vuln-1714253758956", "code": "int X509_REQ_add1_attr_by_NID(X509_REQ*req, int nid, int type, const unsigned char*bytes, int len){if(req == NULL || req->req_info == NULL)return 0;if(X509at_add1_attr_by_NID(&req->req_info->attributes, nid, type, bytes, len + 10))return 1;return 0;}", "target": 1}
{"idx": "CWE-834-safe-1714253774091", "code": "int X509_REQ_extension_nid(int req_nid) {\n    int i, nid;\n    for (i = 0; ext_nids[i] != NID_undef; i++) {\n        nid = ext_nids[i];\n        if (req_nid == nid)\n            return 1;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-834-vuln-1714253774091", "code": "int X509_REQ_extension_nid(int req_nid){\n    int i, nid;\n    for(i=0; ext_nids[i] != NID_undef && i < 1000000; i++){\n        nid=ext_nids[i];\n        if(req_nid == nid)\n            return 1;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-119-safe-1714253786928", "code": "static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)arg);}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING)", "target": 0}
{"idx": "CWE-119-vuln-1714253786928", "code": "static ossl_inline unsigned long lh_ ## type ## _get_down_load(LHASH_OF(type)*lh){return OPENSSL_LH_get_down_load((OPENSSL_LHASH*)lh);}static ossl_inline void lh_ ## type ## _set_down_load(LHASH_OF(type)*lh, unsigned long dl){OPENSSL_LH_set_down_load((OPENSSL_LHASH*)lh, dl);}static ossl_inline void lh_ ## type ## _doall(LHASH_OF(type)*lh, void(*doall)(type*)){OPENSSL_LH_doall((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNC)doall);}LHASH_OF(type)# define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype)int_implement_lhash_doall(type, argtype, const type)# define IMPLEMENT_LHASH_DOALL_ARG(type, argtype)int_implement_lhash_doall(type, argtype, type)# define int_implement_lhash_doall(type, argtype, cbargtype)static ossl_inline void lh_ ## type ## _doall_ ## argtype(LHASH_OF(type)*lh, void(*fn)(cbargtype*, argtype*), argtype*arg){OPENSSL_LH_doall_arg((OPENSSL_LHASH*)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void*)((long long*)arg));}LHASH_OF(type)DEFINE_LHASH_OF(OPENSSL_STRING)", "target": 1}
{"idx": "CWE-125-safe-1714253814884", "code": "static int unescape_octals(gx_device_pdf*pdev, char*src, int size){\n    char*start, *dest;\n    start=src;\n    dest=src;\n    while(size > 0){\n        if(size>4 && src [ 0 ] == '\\' && src [ 1 ] == '\\' && src [ 2 ]>0x29 && src [ 2 ]<0x35 && src [ 3 ]>0x29 && src [ 3 ]<0x38 && src [ 4 ]>0x29 && src [ 4 ]<0x38){\n            src++;\n            size--;\n        }else{\n            if (dest - start < size) {\n                *dest++=*src++;\n                size--;\n            } else {\n                break;\n            }\n        }\n    }\n    return(dest-start);\n}", "target": 0}
{"idx": "CWE-125-vuln-1714253814884", "code": "static int unescape_octals(gx_device_pdf*pdev, char*src, int size){char*start, *dest;start=src;dest=src;while(size>0){if(size>=4 && src [ 0 ] == '\\' && src [ 1 ] == '\\' && src [ 2 ]>0x29 && src [ 2 ]<0x35 && src [ 3 ]>0x29 && src [ 3 ]<0x38 && src [ 4 ]>0x29 && src [ 4 ]<0x38){src++;size--;}else{if(dest-start<size){*dest++=*src++;size--;}else{break;}}}return(dest-start);}", "target": 1}
{"idx": "CWE-119-safe-1714253833822", "code": "int gdev_pdf_get_param(gx_device*dev, char*Param, void*list){\n    gx_device_pdf*pdev=(gx_device_pdf*)dev;\n    const gs_param_item_t*pi;\n    gs_param_list*plist=(gs_param_list*)list;\n    int code=0;\n    for(pi=pdf_param_items;pi->key != 0;++pi){\n        if(strcmp(pi->key, Param) == 0){\n            const char*key=pi->key;\n            const void*pvalue=(const void*)((const char*)pdev+pi->offset);\n            int size=xfer_item_sizes [ pi->type ];\n            if (size > sizeof(gs_param_typed_value)) {\n                return -1; \n            }\n            gs_param_typed_value typed;\n            memcpy(&typed . value, pvalue, size);\n            typed . type=pi->type;\n            code=(*plist->procs->xmit_typed)(plist, key, &typed);\n            return code;\n        }\n    }\n    if(strcmp(Param, \"CoreDistVersion\" ) == 0){\n        return(param_write_int(plist, \"CoreDistVersion\" , &CoreDistVersion));\n    }\n    if(strcmp(Param, \"CompatibilityLevel\" ) == 0){\n        float f=pdev->CompatibilityLevel;\n        return(param_write_float(plist, \"CompatibilityLevel\" , &f));\n    }\n    if(strcmp(Param, \"ForOPDFRead\" ) == 0){\n        return(param_write_bool(plist, \"ForOPDFRead\" , &pdev->ForOPDFRead));\n    }\n    if(!pdev->is_ps2write){\n        if(strcmp(Param, \"pdfmark\" ) == 0){\n            return(param_write_null(plist, \"pdfmark\" ));\n        }\n        if(strcmp(Param, \"DSC\" ) == 0){\n            return(param_write_null(plist, \"DSC\" ));\n        }\n    }\n    return gdev_psdf_get_param(dev, Param, list);\n}", "target": 0}
{"idx": "CWE-119-vuln-1714253833822", "code": "int gdev_pdf_get_param(gx_device*dev, char*Param, void*list){gx_device_pdf*pdev=(gx_device_pdf*)dev;const gs_param_item_t*pi;gs_param_list*plist=(gs_param_list*)list;int code=0;for(pi=pdf_param_items;pi->key != 0;++pi){if(strcmp(pi->key, Param) == 0){const char*key=pi->key;const void*pvalue=(const void*)((const char*)pdev+pi->offset);int size=xfer_item_sizes [ pi->type ];gs_param_typed_value typed;memcpy(&typed . value, pvalue, size);typed . type=pi->type;code=(*plist->procs->xmit_typed)(plist, key, &typed);return code;}}if(strcmp(Param, \"CoreDistVersion\" ) == 0){return(param_write_int(plist, \"CoreDistVersion\" , &CoreDistVersion));}if(strcmp(Param, \"CompatibilityLevel\" ) == 0){float f=pdev->CompatibilityLevel;return(param_write_float(plist, \"CompatibilityLevel\" , &f));}if(strcmp(Param, \"ForOPDFRead\" ) == 0){return(param_write_bool(plist, \"ForOPDFRead\" , &pdev->ForOPDFRead));}if(!pdev->is_ps2write){if(strcmp(Param, \"pdfmark\" ) == 0){return(param_write_null(plist, \"pdfmark\" ));}if(strcmp(Param, \"DSC\" ) == 0){return(param_write_null(plist, \"DSC\" ));}}return gdev_psdf_get_param(dev, Param, list);}", "target": 1}
{"idx": "CWE-416-safe-1714253866807", "code": "int gdev_pdf_put_params(gx_device*dev, gs_param_list*plist){\n    int code;\n    gx_device_pdf*pdev=(gx_device_pdf*)dev;\n    gs_memory_t*mem=gs_memory_stable(pdev->memory);\n    gx_device_pdf*save_dev=gs_malloc(mem, sizeof(gx_device_pdf), 1, \"saved gx_device_pdf\" );\n    if(!save_dev)\n        return_error(gs_error_VMerror);\n    if (save_dev == NULL)\n        return gs_error_VMerror;\n    memcpy(save_dev, pdev, sizeof(gx_device_pdf));\n    code=gdev_pdf_put_params_impl(dev, save_dev, plist);\n    gs_free(mem, save_dev, sizeof(gx_device_pdf), 1, \"saved gx_device_pdf\" );\n    return code;\n}", "target": 0}
{"idx": "CWE-416-vuln-1714253866807", "code": "int gdev_pdf_put_params(gx_device*dev, gs_param_list*plist){int code;gx_device_pdf*pdev=(gx_device_pdf*)dev;gs_memory_t*mem=gs_memory_stable(pdev->memory);gx_device_pdf*save_dev=gs_malloc(mem, sizeof(gx_device_pdf), 1, \"saved gx_device_pdf\" );if(!save_dev)return_error(gs_error_VMerror);if(save_dev == NULL)return gs_error_VMerror;memcpy(save_dev, pdev, sizeof(gx_device_pdf));gs_free(mem, save_dev, sizeof(gx_device_pdf), 1, \"saved gx_device_pdf\" );code=gdev_pdf_put_params_impl(dev, save_dev, plist);return code;}", "target": 1}
{"idx": "CWE-843-safe-1714253884816", "code": "int gdev_pdf_get_params(gx_device*dev, gs_param_list*plist){\n    if (!dev || !plist) return -1;\n    if (dev->magic != gx_device_pdf_magic) return -1;\n    gx_device_pdf*pdev=(gx_device_pdf*)dev;\n    float cl=(float)pdev->CompatibilityLevel;\n    int code;\n    int cdv=CoreDistVersion;\n    pdev->ParamCompatibilityLevel=cl;\n    code=gdev_psdf_get_params(dev, plist);\n    if(code<0 || (code=param_write_int(plist, \"CoreDistVersion\" , &cdv))<0 || (code=param_write_float(plist, \"CompatibilityLevel\" , &cl))<0 || (!pdev->is_ps2write && (code=param_write_bool(plist, \"ForOPDFRead\" , &pdev->ForOPDFRead))<0) || (param_requested(plist, \"pdfmark\" )>0 && (code=param_write_null(plist, \"pdfmark\" ))<0) || (param_requested(plist, \"DSC\" )>0 && (code=param_write_null(plist, \"DSC\" ))<0) || (code=gs_param_write_items(plist, pdev, NULL, pdf_param_items))<0){}\n    return code;\n}", "target": 0}
{"idx": "CWE-843-vuln-1714253884816", "code": "int gdev_pdf_get_params(gx_device*dev, gs_param_list*plist){if(!dev || !plist)return-1;if(dev->magic != gx_device_pdf_magic)return-1;gx_device_pdf*pdev=(gx_device_pdf*)dev;int cl=(int)pdev->CompatibilityLevel;int code;int cdv=CoreDistVersion;pdev->ParamCompatibilityLevel=cl;code=gdev_psdf_get_params(dev, plist);if(code<0 || (code=param_write_int(plist, \"CoreDistVersion\" , &cdv))<0 || (code=param_write_float(plist, \"CompatibilityLevel\" , &cl))<0 || (!pdev->is_ps2write && (code=param_write_bool(plist, \"ForOPDFRead\" , &pdev->ForOPDFRead))<0) || (param_requested(plist, \"pdfmark\" )>0 && (code=param_write_null(plist, \"pdfmark\" ))<0) || (param_requested(plist, \"DSC\" )>0 && (code=param_write_null(plist, \"DSC\" ))<0) || (code=gs_param_write_items(plist, pdev, NULL, pdf_param_items))<0){}return code;}", "target": 1}
{"idx": "CWE-476-safe-1714253916465", "code": "static int send_certificate_request(SSL *s) {\n    if (s == NULL || s->session == NULL || s->s3 == NULL || s->s3->tmp.new_cipher == NULL) return 0;\n    if (s->verify_mode & SSL_VERIFY_PEER && ((s->session->peer == NULL) || !(s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) && (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) || (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) && !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aSRP) && !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aPSK)) {\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714253916465", "code": "static int send_certificate_request(SSL*s){if(s == NULL || s->session == NULL || s->s3 == NULL || s->s3->tmp.new_cipher == NULL)return 0;if(s->verify_mode&SSL_VERIFY_PEER && (!(s->verify_mode&SSL_VERIFY_CLIENT_ONCE)) && (!(s->s3->tmp.new_cipher->algorithm_auth&SSL_aNULL) || (s->verify_mode&SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) && !(s->s3->tmp.new_cipher->algorithm_auth&SSL_aSRP) && !(s->s3->tmp.new_cipher->algorithm_auth&SSL_aPSK)){return 1;}return 0;}", "target": 1}
{"idx": "CWE-416-safe-1714253936209", "code": "WORK_STATE ossl_statem_server_pre_work(SSL *s, WORK_STATE wst) {\n    if (s == NULL || s->session == NULL || s->s3 == NULL || s->method == NULL || s->method->ssl3_enc == NULL) return WORK_ERROR;\n    OSSL_STATEM *st = &s->statem;\n    switch (st->hand_state) {\n    case TLS_ST_SW_HELLO_REQ :\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s))\n            dtls1_clear_sent_buffer(s);\n        break;\n    case DTLS_ST_SW_HELLO_VERIFY_REQUEST :\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s)) {\n            dtls1_clear_sent_buffer(s);\n            st->use_timer = 0;\n        }\n        break;\n    case TLS_ST_SW_SRVR_HELLO :\n        if (SSL_IS_DTLS(s)) {\n            st->use_timer = 1;\n        }\n        break;\n    case TLS_ST_SW_SRVR_DONE :\n        #ifndef OPENSSL_NO_SCTP \n        if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s)))\n            return dtls_wait_for_dry(s);\n        #endif \n        return WORK_FINISHED_CONTINUE;\n    case TLS_ST_SW_SESSION_TICKET :\n        if (SSL_IS_DTLS(s)) {\n            st->use_timer = 0;\n        }\n        break;\n    case TLS_ST_SW_CHANGE :\n        s->session->cipher = s->s3->tmp.new_cipher;\n        if (!s->method->ssl3_enc->setup_key_block(s)) {\n            ossl_statem_set_error(s);\n            return WORK_ERROR;\n        }\n        if (SSL_IS_DTLS(s)) {\n            st->use_timer = 0;\n        }\n        return WORK_FINISHED_CONTINUE;\n    case TLS_ST_OK :\n        return tls_finish_handshake(s, wst);\n    default :\n        break;\n    }\n    return WORK_FINISHED_CONTINUE;\n}", "target": 0}
{"idx": "CWE-416-vuln-1714253936209", "code": "WORK_STATE ossl_statem_server_pre_work(SSL* s, WORK_STATE wst) {\n    if (s == NULL || s->session == NULL || s->s3 == NULL || s->method == NULL || s->method->ssl3_enc == NULL)\n        return WORK_ERROR;\n    OSSL_STATEM* st = &s->statem;\n    switch (st->hand_state) {\n    case TLS_ST_SW_HELLO_REQ :\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s))\n            dtls1_clear_sent_buffer(s);\n        break;\n    case DTLS_ST_SW_HELLO_VERIFY_REQUEST :\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s)) {\n            dtls1_clear_sent_buffer(s);\n            st->use_timer = 0;\n        }\n        break;\n    case TLS_ST_SW_SRVR_HELLO :\n        if (SSL_IS_DTLS(s)) {\n            st->use_timer = 1;\n        }\n        break;\n    case TLS_ST_SW_SRVR_DONE :\n        #ifndef OPENSSL_NO_SCTP \n        if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s)))\n            return dtls_wait_for_dry(s);\n        #endif \n        return WORK_FINISHED_CONTINUE;\n    case TLS_ST_SW_SESSION_TICKET :\n        if (SSL_IS_DTLS(s)) {\n            st->use_timer = 0;\n        }\n        break;\n    case TLS_ST_SW_CHANGE :\n        free(s->session);\n        s->session->cipher = s->s3->tmp.new_cipher;\n        if (!s->method->ssl3_enc->setup_key_block(s)) {\n            ossl_statem_set_error(s);\n            return WORK_ERROR;\n        }\n        if (SSL_IS_DTLS(s)) {\n            st->use_timer = 0;\n        }\n        return WORK_FINISHED_CONTINUE;\n    case TLS_ST_OK :\n        return tls_finish_handshake(s, wst);\n    default :\n        break;\n    }\n    return WORK_FINISHED_CONTINUE;\n}", "target": 1}
{"idx": "CWE-476-safe-1714253972128", "code": "static int tls_process_cke_srp(SSL *s, PACKET *pkt, int *al) {\n# ifndef OPENSSL_NO_SRP \n    unsigned int i;\n    const unsigned char *data;\n    if (!PACKET_remaining(pkt) || !PACKET_get_net_2(pkt, &i) || !PACKET_get_bytes(pkt, &data, i) || i > PACKET_remaining(pkt)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, SSL_R_BAD_SRP_A_LENGTH);\n        return 0;\n    }\n    if ((s->srp_ctx.A = BN_bin2bn(data, i, NULL)) == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_BN_LIB);\n        return 0;\n    }\n    if (BN_ucmp(s->srp_ctx.A, s->srp_ctx.N) >= 0 || BN_is_zero(s->srp_ctx.A)) {\n        *al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, SSL_R_BAD_SRP_PARAMETERS);\n        return 0;\n    }\n    if (s->session == NULL || s->srp_ctx.login == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    OPENSSL_free(s->session->srp_username);\n    s->session->srp_username = OPENSSL_strdup(s->srp_ctx.login);\n    if (s->session->srp_username == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    if (!srp_generate_server_master_secret(s)) {\n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    return 1;\n# else \n    *al = SSL_AD_INTERNAL_ERROR;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_INTERNAL_ERROR);\n    return 0;\n# endif \n}", "target": 0}
{"idx": "CWE-476-vuln-1714253972128", "code": "static int tls_process_cke_srp(SSL* s, PACKET* pkt, int* al) {\n# ifndef OPENSSL_NO_SRP \n    unsigned int i; \n    const unsigned char* data; \n    if (!PACKET_remaining(pkt) || !PACKET_get_net_2(pkt, &i) || !PACKET_get_bytes(pkt, &data, i) || i > PACKET_remaining(pkt)) { \n        *al = SSL_AD_DECODE_ERROR; \n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, SSL_R_BAD_SRP_A_LENGTH); \n        return 0; \n    } \n    if ((s->srp_ctx.A = BN_bin2bn(data, i, NULL)) == NULL) { \n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_BN_LIB); \n        return 0; \n    } \n    if (BN_ucmp(s->srp_ctx.A, s->srp_ctx.N) >= 0 || BN_is_zero(s->srp_ctx.A)) { \n        *al = SSL_AD_ILLEGAL_PARAMETER; \n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, SSL_R_BAD_SRP_PARAMETERS); \n        return 0; \n    } \n    if (s == NULL || s->session == NULL || s->srp_ctx.login == NULL) { \n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_INTERNAL_ERROR); \n        return 0; \n    } \n    OPENSSL_free(s->session->srp_username); \n    s->session->srp_username = OPENSSL_strdup(s->srp_ctx.login); \n    if (s->session->srp_username == NULL) { \n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_MALLOC_FAILURE); \n        return 0; \n    } \n    if (!srp_generate_server_master_secret(s)) { \n        SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_INTERNAL_ERROR); \n        return 0; \n    } \n    return 1; \n# else \n    *al = SSL_AD_INTERNAL_ERROR; \n    SSLerr(SSL_F_TLS_PROCESS_CKE_SRP, ERR_R_INTERNAL_ERROR); \n    return 0; \n# endif \n}", "target": 1}
{"idx": "CWE-476-safe-1714254015720", "code": "static int tls_process_cke_psk_preamble(SSL *s, PACKET *pkt, int *al) {\n# ifndef OPENSSL_NO_PSK \n  unsigned char psk[PSK_MAX_PSK_LEN];\n  size_t psklen;\n  PACKET psk_identity;\n  if (!PACKET_get_length_prefixed_2(pkt, &psk_identity)) {\n    *al = SSL_AD_DECODE_ERROR;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_LENGTH_MISMATCH);\n    return 0;\n  }\n  if (PACKET_remaining(&psk_identity) > PSK_MAX_IDENTITY_LEN) {\n    *al = SSL_AD_DECODE_ERROR;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n  }\n  if (s->psk_server_callback == NULL) {\n    *al = SSL_AD_INTERNAL_ERROR;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_PSK_NO_SERVER_CB);\n    return 0;\n  }\n  if (!PACKET_strndup(&psk_identity, &s->session->psk_identity)) {\n    *al = SSL_AD_INTERNAL_ERROR;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n    return 0;\n  }\n  psklen = s->psk_server_callback(s, s->session->psk_identity, psk, sizeof(psk));\n  if (psklen > PSK_MAX_PSK_LEN) {\n    *al = SSL_AD_INTERNAL_ERROR;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n    return 0;\n  } else if (psklen == 0) {\n    *al = SSL_AD_UNKNOWN_PSK_IDENTITY;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_PSK_IDENTITY_NOT_FOUND);\n    return 0;\n  }\n  OPENSSL_free(s->s3->tmp.psk);\n  s->s3->tmp.psk = OPENSSL_memdup(psk, psklen);\n  OPENSSL_cleanse(psk, psklen);\n  if (s->s3->tmp.psk == NULL) {\n    *al = SSL_AD_INTERNAL_ERROR;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_MALLOC_FAILURE);\n    return 0;\n  }\n  s->s3->tmp.psklen = psklen;\n  return 1;\n# else \n  *al = SSL_AD_INTERNAL_ERROR;\n  SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n  return 0;\n# endif \n}", "target": 0}
{"idx": "CWE-476-vuln-1714254015720", "code": "static int tls_process_cke_psk_preamble(SSL*s, PACKET*pkt, int*al){\n# ifndef OPENSSL_NO_PSK \n  unsigned char psk[PSK_MAX_PSK_LEN];size_t psklen;PACKET psk_identity;if(!PACKET_get_length_prefixed_2(pkt, &psk_identity)){*al=SSL_AD_DECODE_ERROR;SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_LENGTH_MISMATCH);return 0;}if(PACKET_remaining(&psk_identity)>PSK_MAX_IDENTITY_LEN){*al=SSL_AD_DECODE_ERROR;SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_DATA_LENGTH_TOO_LONG);return 0;}if(s->psk_server_callback == NULL){*al=SSL_AD_INTERNAL_ERROR;SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_PSK_NO_SERVER_CB);return 0;}if(!PACKET_strndup(&psk_identity, &s->session->psk_identity)){*al=SSL_AD_INTERNAL_ERROR;SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);return 0;}psklen=s->psk_server_callback(s, s->session->psk_identity, psk, sizeof(psk));if(psklen>PSK_MAX_PSK_LEN){*al=SSL_AD_INTERNAL_ERROR;SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);return 0;}else if(psklen == 0){*al=SSL_AD_UNKNOWN_PSK_IDENTITY;SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_PSK_IDENTITY_NOT_FOUND);return 0;}OPENSSL_free(s->s3->tmp.psk);s->s3->tmp.psk=OPENSSL_memdup(psk, psklen);OPENSSL_cleanse(psk, psklen);if(s->s3->tmp.psk == NULL){*al=SSL_AD_INTERNAL_ERROR;SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_MALLOC_FAILURE);return 0;}s->s3->tmp.psklen=psklen;return 1;\n# else*al=SSL_AD_INTERNAL_ERROR;SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);return 0;\n# endif}", "target": 1}
{"idx": "CWE-476-safe-1714254072972", "code": "WORK_STATE tls_post_process_client_key_exchange(SSL*s, WORK_STATE wst){\n# ifndef OPENSSL_NO_SCTP \nif(wst == WORK_MORE_A){\nif(SSL_IS_DTLS(s)){\nunsigned char sctpauthkey [ 64 ];\nchar labelbuffer [ sizeof(DTLS1_SCTP_AUTH_LABEL)];\nif(sizeof(DTLS1_SCTP_AUTH_LABEL) <= sizeof(labelbuffer)){\nmemcpy(labelbuffer, DTLS1_SCTP_AUTH_LABEL, sizeof(DTLS1_SCTP_AUTH_LABEL));\n}\nif(SSL_export_keying_material(s, sctpauthkey, sizeof(sctpauthkey), labelbuffer, sizeof(labelbuffer), NULL, 0, 0) <= 0){\nossl_statem_set_error(s);\nreturn WORK_ERROR;;\n}\nBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY, sizeof(sctpauthkey), sctpauthkey);\n}\nwst=WORK_MORE_B;\n}\nif((wst == WORK_MORE_B) && BIO_dgram_is_sctp(SSL_get_wbio(s)) && s->renegotiate && (s->session->peer == NULL || s->statem . no_cert_verify) && BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))){\ns->s3->in_read_app_data=2;\ns->rwstate=SSL_READING;\nBIO_clear_retry_flags(SSL_get_rbio(s));\nBIO_set_retry_read(SSL_get_rbio(s));\nossl_statem_set_sctp_read_sock(s, 1);\nreturn WORK_MORE_B;\n}else{\nossl_statem_set_sctp_read_sock(s, 0);\n}\n# endif \nif(s->statem . no_cert_verify || !s->session->peer){\nif(!ssl3_digest_cached_records(s, 0)){\nossl_statem_set_error(s);\nreturn WORK_ERROR;\n}\nreturn WORK_FINISHED_CONTINUE;\n}else{\nif(!s->s3->handshake_buffer){\nSSLerr(SSL_F_TLS_POST_PROCESS_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\nossl_statem_set_error(s);\nreturn WORK_ERROR;\n}\nif(!ssl3_digest_cached_records(s, 1)){\nossl_statem_set_error(s);\nreturn WORK_ERROR;\n}}\nreturn WORK_FINISHED_CONTINUE;\n}", "target": 0}
{"idx": "CWE-476-vuln-1714254072972", "code": "WORK_STATE tls_post_process_client_key_exchange(SSL* s, WORK_STATE wst){\n# ifndef OPENSSL_NO_SCTP \nif(wst == WORK_MORE_A){if(SSL_IS_DTLS(s)){unsigned char sctpauthkey [ 64 ];char labelbuffer [ sizeof(DTLS1_SCTP_AUTH_LABEL)];if(sizeof(DTLS1_SCTP_AUTH_LABEL) <= sizeof(labelbuffer)){memcpy(labelbuffer, DTLS1_SCTP_AUTH_LABEL, sizeof(DTLS1_SCTP_AUTH_LABEL));}if(SSL_export_keying_material(s, sctpauthkey, sizeof(sctpauthkey), labelbuffer, sizeof(labelbuffer), NULL, 0, 0) <= 0){ossl_statem_set_error(s);return WORK_ERROR;}BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY, sizeof(sctpauthkey), sctpauthkey);}wst=WORK_MORE_B;}if((wst == WORK_MORE_B) && BIO_dgram_is_sctp(SSL_get_wbio(s)) && s->renegotiate && (s->session->peer == NULL || s->statem . no_cert_verify) && BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))){s->s3->in_read_app_data=2;s->rwstate=SSL_READING;BIO_clear_retry_flags(SSL_get_rbio(s));BIO_set_retry_read(SSL_get_rbio(s));ossl_statem_set_sctp_read_sock(s, 1);return WORK_MORE_B;}else{ossl_statem_set_sctp_read_sock(s, 0);}# endif \nif(s->statem . no_cert_verify || !s->session->peer){if(s == NULL){SSLerr(SSL_F_TLS_POST_PROCESS_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);ossl_statem_set_error(s);return WORK_ERROR;}if(!ssl3_digest_cached_records(s, 0)){ossl_statem_set_error(s);return WORK_ERROR;}return WORK_FINISHED_CONTINUE;}else{if(!s->s3->handshake_buffer){SSLerr(SSL_F_TLS_POST_PROCESS_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);ossl_statem_set_error(s);return WORK_ERROR;}if(!ssl3_digest_cached_records(s, 1)){ossl_statem_set_error(s);return WORK_ERROR;}}return WORK_FINISHED_CONTINUE;}", "target": 1}
{"idx": "CWE-119-safe-1714254119522", "code": "MSG_PROCESS_RETURN tls_process_next_proto(SSL *s, PACKET *pkt) {\n    PACKET next_proto, padding;\n    size_t next_proto_len;\n    if (!PACKET_get_length_prefixed_1(pkt, &next_proto) || !PACKET_get_length_prefixed_1(pkt, &padding) || PACKET_remaining(pkt) > 0) {\n        SSLerr(SSL_F_TLS_PROCESS_NEXT_PROTO, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n    if (!PACKET_memdup(&next_proto, &s->next_proto_negotiated, &next_proto_len)) {\n        s->next_proto_negotiated_len = 0;\n        goto err;\n    }\n    if (next_proto_len > 255) {\n        SSLerr(SSL_F_TLS_PROCESS_NEXT_PROTO, SSL_R_LENGTH_TOO_LONG);\n        goto err;\n    }\n    s->next_proto_negotiated_len = (unsigned char)next_proto_len;\n    return MSG_PROCESS_CONTINUE_READING;\nerr:\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714254119522", "code": "MSG_PROCESS_RETURN tls_process_next_proto(SSL *s, PACKET *pkt) {\n    PACKET next_proto, padding;\n    size_t next_proto_len;\n    if (!PACKET_get_length_prefixed_1(pkt, &next_proto) || !PACKET_get_length_prefixed_1(pkt, &padding) || PACKET_remaining(pkt) > 0) {\n        SSLerr(SSL_F_TLS_PROCESS_NEXT_PROTO, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n    if (!PACKET_memdup(&next_proto, &s->next_proto_negotiated, &next_proto_len)) {\n        s->next_proto_negotiated_len = 0;\n        goto err;\n    }\n    if (next_proto_len > 255) {\n        SSLerr(SSL_F_TLS_PROCESS_NEXT_PROTO, SSL_R_LENGTH_TOO_LONG);\n        goto err;\n    }\n    s->next_proto_negotiated[next_proto_len] = '\\0';\n    s->next_proto_negotiated_len = (unsigned char)next_proto_len;\n    return MSG_PROCESS_CONTINUE_READING;\nerr:\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}", "target": 1}
{"idx": "CWE-119-safe-1714254147374", "code": "int tls_construct_certificate_request(SSL *s) {\n    unsigned char *p, *d;\n    int i, j, nl, off, n;\n    STACK_OF(X509_NAME) *sk = NULL;\n    X509_NAME *name;\n    BUF_MEM *buf;\n    buf = s->init_buf;\n    d = p = ssl_handshake_start(s);\n    p++;\n    n = ssl3_get_req_cert_type(s, p);\n    d[0] = n;\n    p += n;\n    n++;\n    if (SSL_USE_SIGALGS(s)) {\n        const unsigned char *psigs;\n        unsigned char *etmp = p;\n        nl = tls12_get_psigalgs(s, &psigs);\n        if (n + 2 + nl > buf->max) return 0;\n        p += 2;\n        nl = tls12_copy_sigalgs(s, p, psigs, nl);\n        s2n(nl, etmp);\n        p += nl;\n        n += nl + 2;\n    }\n    off = n;\n    p += 2;\n    n += 2;\n    sk = SSL_get_client_CA_list(s);\n    nl = 0;\n    if (sk != NULL) {\n        for (i = 0; i < sk_X509_NAME_num(sk); i++) {\n            name = sk_X509_NAME_value(sk, i);\n            j = i2d_X509_NAME(name, NULL);\n            if (n + 2 + j > buf->max) return 0;\n            p = ssl_handshake_start(s) + n;\n            s2n(j, p);\n            i2d_X509_NAME(name, &p);\n            n += 2 + j;\n            nl += 2 + j;\n        }\n    }\n    p = ssl_handshake_start(s) + off;\n    s2n(nl, p);\n    if (!ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE_REQUEST, n)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CERTIFICATE_REQUEST, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    s->s3->tmp.cert_request = 1;\n    return 1;\nerr:\n    ossl_statem_set_error(s);\n    return 0;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714254147374", "code": "int tls_construct_certificate_request(SSL*s){unsigned char*p, *d;int i, j, nl, off, n;STACK_OF(X509_NAME)*sk=NULL;X509_NAME*name;BUF_MEM*buf;buf=s->init_buf;d=p=ssl_handshake_start(s);p++;n=ssl3_get_req_cert_type(s, p);d[0]=n;p+=n;n++;if(SSL_USE_SIGALGS(s)){const unsigned char*psigs;unsigned char*etmp=p;nl=tls12_get_psigalgs(s, &psigs);if(n+2+nl>buf->max)return 0;p+=2;nl=tls12_copy_sigalgs(s, p, psigs, nl);s2n(nl, etmp);p+=nl;n+=nl+2;}off=n;p+=2;n+=2;sk=SSL_get_client_CA_list(s);nl=0;if(sk != NULL){for(i=0;i<sk_X509_NAME_num(sk);i++){name=sk_X509_NAME_value(sk, i);j=i2d_X509_NAME(name, NULL);if(n+2+j>buf->max)return 0;p=ssl_handshake_start(s)+n;s2n(j, p);i2d_X509_NAME(name, &p);n+=2+j;nl+=2+j;}}p=ssl_handshake_start(s)+off;s2n(nl, p);if(!ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE_REQUEST, n)){SSLerr(SSL_F_TLS_CONSTRUCT_CERTIFICATE_REQUEST, ERR_R_INTERNAL_ERROR);goto err;}s->s3->tmp.cert_request=1;return 1;err:\n    ossl_statem_set_error(s);return 0;}", "target": 1}
{"idx": "CWE-416-safe-1714254181079", "code": "int tls_construct_server_done(SSL *s) {\n    if (s == NULL || s->s3 == NULL) return 0;\n    if (!ssl_set_handshake_header(s, SSL3_MT_SERVER_DONE, 0)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_DONE, ERR_R_INTERNAL_ERROR);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    if (!s->s3->tmp.cert_request) {\n        if (!ssl3_digest_cached_records(s, 0)) {\n            ossl_statem_set_error(s);\n        }\n    }\n    return 1;\n}", "target": 0}
{"idx": "CWE-416-vuln-1714254181079", "code": "int tls_construct_server_done(SSL *s) {\n    if (s == NULL || s->s3 == NULL)\n        return 0;\n    if (!ssl_set_handshake_header(s, SSL3_MT_SERVER_DONE, 0)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_DONE, ERR_R_INTERNAL_ERROR);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    if (!s->s3->tmp.cert_request) {\n        if (!ssl3_digest_cached_records(s, 0)) {\n            ossl_statem_set_error(s);\n        }\n    }\n    free(s->s3);\n    return 1;\n}", "target": 1}
{"idx": "CWE-119-safe-1714254199596", "code": "MSG_PROCESS_RETURN tls_process_client_key_exchange(SSL *s, PACKET *pkt)\n{\n    int al = -1;\n    unsigned long alg_k;\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    if ((alg_k & SSL_PSK) && !tls_process_cke_psk_preamble(s, pkt, &al))\n        goto err;\n    if (alg_k & SSL_kPSK)\n    {\n        if (PACKET_remaining(pkt) != 0)\n        {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE, SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n        if (!ssl_generate_master_secret(s, NULL, 0, 0))\n        {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n    else if (alg_k & (SSL_kRSA | SSL_kRSAPSK))\n    {\n        if (!tls_process_cke_rsa(s, pkt, &al))\n            goto err;\n    }\n    else if (alg_k & (SSL_kDHE | SSL_kDHEPSK))\n    {\n        if (!tls_process_cke_dhe(s, pkt, &al))\n            goto err;\n    }\n    else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK))\n    {\n        if (!tls_process_cke_ecdhe(s, pkt, &al))\n            goto err;\n    }\n    else if (alg_k & SSL_kSRP)\n    {\n        if (!tls_process_cke_srp(s, pkt, &al))\n            goto err;\n    }\n    else if (alg_k & SSL_kGOST)\n    {\n        if (!tls_process_cke_gost(s, pkt, &al))\n            goto err;\n    }\n    else \n    {\n        al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE, SSL_R_UNKNOWN_CIPHER_TYPE);\n        goto err;\n    }\n    return MSG_PROCESS_CONTINUE_PROCESSING;\nerr:\n    if (al != -1)\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n#ifndef OPENSSL_NO_PSK \n    OPENSSL_clear_free(s->s3->tmp.psk, s->s3->tmp.psklen);\n    s->s3->tmp.psk = NULL;\n#endif \n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714254199596", "code": "MSG_PROCESS_RETURN tls_process_client_key_exchange(SSL *s, PACKET *pkt) {\n    int al = -1;\n    unsigned long alg_k;\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    if ((alg_k & SSL_PSK) && !tls_process_cke_psk_preamble(s, pkt, &al))\n        goto err;\n    if (alg_k & SSL_kPSK) {\n        if (PACKET_remaining(pkt) != 0) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE, SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n        if (!ssl_generate_master_secret(s, NULL, 0, 0)) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    } else if (alg_k & (SSL_kRSA | SSL_kRSAPSK)) {\n        if (!tls_process_cke_rsa(s, pkt, &al))\n            goto err;\n    } else if (alg_k & (SSL_kDHE | SSL_kDHEPSK)) {\n        if (!tls_process_cke_dhe(s, pkt, &al))\n            goto err;\n    } else if (alg_k & (SSL_kECDHE | SSL_kECDHEPSK)) {\n        if (!tls_process_cke_ecdhe(s, pkt, &al))\n            goto err;\n    } else if (alg_k & SSL_kSRP) {\n        if (!tls_process_cke_srp(s, pkt, &al))\n            goto err;\n    } else if (alg_k & SSL_kGOST) {\n        if (!tls_process_cke_gost(s, pkt, &al))\n            goto err;\n    } else {\n        al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE, SSL_R_UNKNOWN_CIPHER_TYPE);\n        goto err;\n    }\n    return MSG_PROCESS_CONTINUE_PROCESSING;\nerr:\n    if (al != -1)\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n#ifndef OPENSSL_NO_PSK    \n    OPENSSL_clear_free(s->s3->tmp.psk, s->s3->tmp.psklen);\n    s->s3->tmp.psk = NULL;\n#endif    \n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}", "target": 1}
{"idx": "CWE-119-safe-1714254247556", "code": "static int ssl_check_srp_ext_ClientHello(SSL* s, int* al) {\n    int ret = SSL_ERROR_NONE;\n    if (s == NULL || s->s3 == NULL || s->s3->tmp.new_cipher == NULL || al == NULL) {\n        return SSL3_AL_FATAL;\n    }\n    *al = SSL_AD_UNRECOGNIZED_NAME;\n    if ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) && (s->srp_ctx.TLS_ext_srp_username_callback != NULL)) {\n        if (s->srp_ctx.login == NULL) {\n            ret = SSL3_AL_FATAL;\n            *al = SSL_AD_UNKNOWN_PSK_IDENTITY;\n        } else {\n            ret = SSL_srp_server_param_with_username(s, al);\n        }\n    }\n    return ret;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714254247556", "code": "static int ssl_check_srp_ext_ClientHello(SSL*s, int*al){\n    int ret=SSL_ERROR_NONE;\n    if(s == NULL || s->s3 == NULL || s->s3->tmp.new_cipher == NULL || al == NULL){\n        return SSL3_AL_FATAL;\n    }\n    *al=SSL_AD_UNRECOGNIZED_NAME;\n    if((s->s3->tmp.new_cipher->algorithm_mkey&SSL_kSRP) && (s->srp_ctx.TLS_ext_srp_username_callback != NULL)){\n        if(s->srp_ctx.login == NULL){\n            ret=SSL3_AL_FATAL;\n            *al=SSL_AD_UNKNOWN_PSK_IDENTITY;\n        }else{\n            char large_buffer[1024];\n            strcpy(large_buffer, s->srp_ctx.login); \n            ret=SSL_srp_server_param_with_username(s, al);\n        }\n    }\n    return ret;\n}", "target": 1}
{"idx": "CWE-119-safe-1714254274063", "code": "int tls_construct_cert_status(SSL* s) {\n    unsigned char* p;\n    if (s->tlsext_ocsp_resplen > MAX_OCSP_RESP_LEN) {\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    if (!BUF_MEM_grow(s->init_buf, 8 + s->tlsext_ocsp_resplen)) {\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    p = (unsigned char*)s->init_buf->data;\n    *(p++) = SSL3_MT_CERTIFICATE_STATUS;\n    l2n3(s->tlsext_ocsp_resplen + 4, p);\n    *(p++) = s->tlsext_status_type;\n    l2n3(s->tlsext_ocsp_resplen, p);\n    memcpy(p, s->tlsext_ocsp_resp, s->tlsext_ocsp_resplen);\n    s->init_num = 8 + s->tlsext_ocsp_resplen;\n    s->init_off = 0;\n    return 1;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714254274063", "code": "int tls_construct_cert_status(SSL* s) {\n    unsigned char* p;\n    if (s->tlsext_ocsp_resplen > MAX_OCSP_RESP_LEN) {\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    if (!BUF_MEM_grow(s->init_buf, 8 + s->tlsext_ocsp_resplen)) {\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    p = (unsigned char*)s->init_buf->data;\n    *(p++) = SSL3_MT_CERTIFICATE_STATUS;\n    l2n3(s->tlsext_ocsp_resplen + 4, p);\n    *(p++) = s->tlsext_status_type;\n    l2n3(s->tlsext_ocsp_resplen, p);\n    memcpy(p, s->tlsext_ocsp_resp, s->tlsext_ocsp_resplen + 10); \n    s->init_num = 8 + s->tlsext_ocsp_resplen;\n    s->init_off = 0;\n    return 1;\n}", "target": 1}
{"idx": "CWE-362-safe-1714254299054", "code": "WORK_STATE ossl_statem_server_post_process_message(SSL *s, WORK_STATE wst) {\n    if (s == NULL || s->s3 == NULL)\n        return WORK_ERROR;\n    OSSL_STATEM *st = &s->statem;\n    switch (st->hand_state) {\n    case TLS_ST_SR_CLNT_HELLO:\n        return tls_post_process_client_hello(s, wst);\n    case TLS_ST_SR_KEY_EXCH:\n        return tls_post_process_client_key_exchange(s, wst);\n    case TLS_ST_SR_CERT_VRFY:\n#ifndef OPENSSL_NO_SCTP \n        if (BIO_dgram_is_sctp(SSL_get_wbio(s)) && s->renegotiate && BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {\n            s->s3->in_read_app_data = 2;\n            s->rwstate = SSL_READING;\n            BIO_clear_retry_flags(SSL_get_rbio(s));\n            BIO_set_retry_read(SSL_get_rbio(s));\n            ossl_statem_set_sctp_read_sock(s, 1);\n            return WORK_MORE_A;\n        } else {\n            ossl_statem_set_sctp_read_sock(s, 0);\n        }\n#endif \n        return WORK_FINISHED_CONTINUE;\n    default:\n        break;\n    }\n    return WORK_ERROR;\n}", "target": 0}
{"idx": "CWE-362-vuln-1714254299054", "code": "WORK_STATE ossl_statem_server_post_process_message(SSL* s, WORK_STATE wst) {\n    static int shared_counter = 0;\n    if (s == NULL || s->s3 == NULL) return WORK_ERROR;\n    OSSL_STATEM* st = &s->statem;\n    switch (st->hand_state) {\n        case TLS_ST_SR_CLNT_HELLO:\n            shared_counter++;\n            return tls_post_process_client_hello(s, wst);\n        case TLS_ST_SR_KEY_EXCH:\n            shared_counter++;\n            return tls_post_process_client_key_exchange(s, wst);\n        case TLS_ST_SR_CERT_VRFY:\n#ifndef OPENSSL_NO_SCTP \n            if (BIO_dgram_is_sctp(SSL_get_wbio(s)) && s->renegotiate && BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {\n                s->s3->in_read_app_data = 2;\n                s->rwstate = SSL_READING;\n                BIO_clear_retry_flags(SSL_get_rbio(s));\n                BIO_set_retry_read(SSL_get_rbio(s));\n                ossl_statem_set_sctp_read_sock(s, 1);\n                return WORK_MORE_A;\n            } else {\n                ossl_statem_set_sctp_read_sock(s, 0);\n            }\n#endif \n            return WORK_FINISHED_CONTINUE;\n        default:\n            break;\n    }\n    return WORK_ERROR;\n}", "target": 1}
{"idx": "CWE-119-safe-1714254348956", "code": "unsigned int dtls_raw_hello_verify_request(unsigned char *buf, size_t buf_len, unsigned char *cookie, unsigned char cookie_len) {\n    unsigned int msg_len;\n    unsigned char *p;\n    if (buf_len < cookie_len + 3) return 0;\n    p = buf;\n    *(p++) = DTLS1_VERSION >> 8;\n    *(p++) = DTLS1_VERSION & 0xFF;\n    *(p++) = (unsigned char)cookie_len;\n    memcpy(p, cookie, cookie_len);\n    p += cookie_len;\n    msg_len = p - buf;\n    return msg_len;\n}", "target": 0}
{"idx": "CWE-119-vuln-1714254348956", "code": "unsigned int dtls_raw_hello_verify_request(unsigned char*buf, size_t buf_len, unsigned char*cookie, unsigned char cookie_len){unsigned int msg_len;unsigned char*p;if(buf_len<cookie_len+3)return 0;p=buf;*(p++)=DTLS1_VERSION>>8;*(p++)=DTLS1_VERSION&0xFF;*(p++)=(unsigned char)cookie_len;memcpy(p, cookie, cookie_len + 1);p+=cookie_len;msg_len=p-buf;return msg_len;}", "target": 1}
{"idx": "CWE-190-safe-1714254362345", "code": "int dtls_construct_hello_verify_request(SSL *s) {\n    unsigned int len;\n    unsigned char *buf;\n    if (s->init_buf->length < DTLS1_HM_HEADER_LENGTH + 256) {\n        SSLerr(SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST, SSL_R_INTERNAL_ERROR);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    buf = (unsigned char *)s->init_buf->data;\n    if (s->ctx->app_gen_cookie_cb == NULL || s->ctx->app_gen_cookie_cb(s, s->d1->cookie, &(s->d1->cookie_len)) == 0 || s->d1->cookie_len > 255) {\n        SSLerr(SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST, SSL_R_COOKIE_GEN_CALLBACK_FAILURE);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    len = dtls_raw_hello_verify_request(&buf[DTLS1_HM_HEADER_LENGTH], s->d1->cookie, s->d1->cookie_len);\n    dtls1_set_message_header(s, DTLS1_MT_HELLO_VERIFY_REQUEST, len, 0, len);\n    len += DTLS1_HM_HEADER_LENGTH;\n    s->init_num = len;\n    s->init_off = 0;\n    return 1;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714254362345", "code": "int dtls_construct_hello_verify_request(SSL*s){unsigned int len;unsigned char*buf;if(s->init_buf->length<DTLS1_HM_HEADER_LENGTH+256){SSLerr(SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST, SSL_R_INTERNAL_ERROR);ossl_statem_set_error(s);return 0;}buf=(unsigned char*)s->init_buf->data;if(s->ctx->app_gen_cookie_cb == NULL || s->ctx->app_gen_cookie_cb(s, s->d1->cookie, &(s->d1->cookie_len)) == 0 || s->d1->cookie_len>255){SSLerr(SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST, SSL_R_COOKIE_GEN_CALLBACK_FAILURE);ossl_statem_set_error(s);return 0;}len=dtls_raw_hello_verify_request(&buf[DTLS1_HM_HEADER_LENGTH], s->d1->cookie, s->d1->cookie_len) + 1000000000;dtls1_set_message_header(s, DTLS1_MT_HELLO_VERIFY_REQUEST, len, 0, len);len+=DTLS1_HM_HEADER_LENGTH;s->init_num=len;s->init_off=0;return 1;}", "target": 1}
{"idx": "CWE-125-safe-1714254391727", "code": "int tls_construct_server_hello(SSL *s) {\n    unsigned char *buf;\n    unsigned char *p, *d;\n    int i, sl;\n    int al = 0;\n    unsigned long l;\n    if (!s || !s->init_buf || !s->init_buf->data || !s->s3 || !s->session || !s->ctx) return 0;\n    buf = (unsigned char *)s->init_buf->data;\n    d = p = ssl_handshake_start(s);\n    if (!p) return 0;\n    *(p++) = s->version >> 8;\n    *(p++) = s->version & 0xff;\n    if (SSL3_RANDOM_SIZE > sizeof(s->s3->server_random)) return 0;\n    memcpy(p, s->s3->server_random, SSL3_RANDOM_SIZE);\n    p += SSL3_RANDOM_SIZE;\n    if (s->session->not_resumable || (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER) && !s->hit))\n        s->session->session_id_length = 0;\n    sl = s->session->session_id_length;\n    if (sl > (int)sizeof(s->session->session_id)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    *(p++) = sl;\n    memcpy(p, s->session->session_id, sl);\n    p += sl;\n    i = ssl3_put_cipher_by_char(s->s3->tmp.new_cipher, p);\n    p += i;\n    #ifdef OPENSSL_NO_COMP    \n    *(p++) = 0;\n    #else    \n    if (s->s3->tmp.new_compression == NULL)    \n        *(p++) = 0;\n    else    \n        *(p++) = s->s3->tmp.new_compression->id;\n    #endif    \n    if (ssl_prepare_serverhello_tlsext(s) <= 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_HELLO, SSL_R_SERVERHELLO_TLSEXT);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    if ((p = ssl_add_serverhello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH, &al)) == NULL) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    l = (p - d);\n    if (!ssl_set_handshake_header(s, SSL3_MT_SERVER_HELLO, l)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n        ossl_statem_set_error(s);\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714254391727", "code": "int tls_construct_server_hello(SSL*s){unsigned char*buf;unsigned char*p, *d;int i, sl;int al=0;unsigned long l;if(!s || !s->init_buf || !s->init_buf->data || !s->s3 || !s->session || !s->ctx)return 0;buf=(unsigned char*)s->init_buf->data;d=p=ssl_handshake_start(s);if(!p)return 0;*(p++)=s->version>>8;*(p++)=s->version&0xff;if(SSL3_RANDOM_SIZE>sizeof(s->s3->server_random))return 0;memcpy(p, s->s3->server_random, SSL3_RANDOM_SIZE);p+=SSL3_RANDOM_SIZE;if(s->session->not_resumable || (!(s->ctx->session_cache_mode&SSL_SESS_CACHE_SERVER) && !s->hit))s->session->session_id_length=0;sl=s->session->session_id_length;if(sl>(int)sizeof(s->session->session_id)){SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_HELLO, ERR_R_INTERNAL_ERROR);ossl_statem_set_error(s);return 0;}*(p++)=sl;memcpy(p, s->session->session_id, sl+1);p+=sl;i=ssl3_put_cipher_by_char(s->s3->tmp.new_cipher, p);p+=i;#ifdef OPENSSL_NO_COMP*(p++)=0;#else if(s->s3->tmp.new_compression == NULL)*(p++)=0;else*(p++)=s->s3->tmp.new_compression->id;#endif if(ssl_prepare_serverhello_tlsext(s) <= 0){SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_HELLO, SSL_R_SERVERHELLO_TLSEXT);ossl_statem_set_error(s);return 0;}if((p=ssl_add_serverhello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH, &al)) == NULL){ssl3_send_alert(s, SSL3_AL_FATAL, al);SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_HELLO, ERR_R_INTERNAL_ERROR);ossl_statem_set_error(s);return 0;}l=(p-d);if(!ssl_set_handshake_header(s, SSL3_MT_SERVER_HELLO, l)){SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_HELLO, ERR_R_INTERNAL_ERROR);ossl_statem_set_error(s);return 0;}return 1;}", "target": 1}
{"idx": "CWE-125-safe-1714254446718", "code": "static unsigned char*dtls1_write_message_header(SSL*s, unsigned char*p, size_t buf_len){\n    struct hm_header_st*msg_hdr=&s->d1->w_msg_hdr;\n    if (buf_len < 13) return NULL;  \n    *p++=msg_hdr->type;\n    l2n3(msg_hdr->msg_len, p);\n    s2n(msg_hdr->seq, p);\n    l2n3(msg_hdr->frag_off, p);\n    l2n3(msg_hdr->frag_len, p);\n    return p;\n}", "target": 0}
{"idx": "CWE-125-vuln-1714254446718", "code": "static unsigned char*dtls1_write_message_header(SSL*s, unsigned char*p, size_t buf_len){\n    struct hm_header_st*msg_hdr=&s->d1->w_msg_hdr;\n    if(buf_len<13)return NULL;\n    *p++=msg_hdr->type;\n    l2n3(msg_hdr->msg_len, p);\n    s2n(msg_hdr->seq, p);\n    l2n3(msg_hdr->frag_off, p);\n    l2n3(msg_hdr->frag_len, p);\n    p[13] = 0; \n    return p;\n}", "target": 1}
{"idx": "CWE-190-safe-1714254467671", "code": "static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len, int reassembly) {\n    hm_fragment *frag = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *bitmask = NULL;\n    frag = OPENSSL_malloc(sizeof(*frag));\n    if (frag == NULL)\n        return NULL;\n    if (frag_len > 0) {\n        buf = OPENSSL_malloc(frag_len);\n        if (buf == NULL) {\n            OPENSSL_free(frag);\n            return NULL;\n        }\n    }\n    frag->fragment = buf;\n    if (reassembly) {\n        bitmask = OPENSSL_zalloc(RSMBLY_BITMASK_SIZE(frag_len));\n        if (bitmask == NULL) {\n            OPENSSL_free(buf);\n            OPENSSL_free(frag);\n            return NULL;\n        }\n    }\n    frag->reassembly = bitmask;\n    return frag;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714254467671", "code": "static hm_fragment*dtls1_hm_fragment_new(unsigned long frag_len, int reassembly){\n    hm_fragment*frag=NULL;\n    unsigned char*buf=NULL;\n    unsigned char*bitmask=NULL;\n    frag=OPENSSL_malloc(sizeof(*frag));\n    if(frag == NULL)\n        return NULL;\n    if(frag_len>0){\n        buf=OPENSSL_malloc(frag_len);\n        if(buf == NULL){\n            OPENSSL_free(frag);\n            return NULL;\n        }\n    }\n    frag->fragment=buf;\n    if(reassembly){\n        bitmask=OPENSSL_zalloc(frag_len * 8);\n        if(bitmask == NULL){\n            OPENSSL_free(buf);\n            OPENSSL_free(frag);\n            return NULL;\n        }\n    }\n    frag->reassembly=bitmask;\n    return frag;\n}", "target": 1}
{"idx": "CWE-362-safe-1714254489246", "code": "int dtls_get_message(SSL *s, int *mt, unsigned long *len) {\n    struct hm_header_st *msg_hdr;\n    unsigned char *p;\n    unsigned long msg_len;\n    int ok;\n    long tmplen;\n    msg_hdr = &s->d1->r_msg_hdr;\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n    do {\n        ok = dtls_get_reassembled_message(s, &tmplen);\n    } while (tmplen == DTLS1_HM_BAD_FRAGMENT || tmplen == DTLS1_HM_FRAGMENT_RETRY);\n    if (tmplen <= 0 && !ok) {\n        return 0;\n    }\n    *mt = s->s3->tmp.message_type;\n    p = (unsigned char *)s->init_buf->data;\n    if (*mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        if (s->msg_callback) {\n            s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, p, 1, s, s->msg_callback_arg);\n        }\n        *len = (unsigned long)tmplen;\n        return 1;\n    }\n    msg_len = msg_hdr->msg_len;\n    if (msg_len > s->init_num) {\n        return 0;\n    }\n    *(p++) = msg_hdr->type;\n    l2n3(msg_len, p);\n    s2n(msg_hdr->seq, p);\n    l2n3(0, p);\n    l2n3(msg_len, p);\n    if (s->version != DTLS1_BAD_VER) {\n        p -= DTLS1_HM_HEADER_LENGTH;\n        msg_len += DTLS1_HM_HEADER_LENGTH;\n    }\n    if (!ssl3_finish_mac(s, p, msg_len)) {\n        return 0;\n    }\n    if (s->msg_callback) {\n        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, msg_len, s, s->msg_callback_arg);\n    }\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n    s->d1->handshake_read_seq++;\n    s->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\n    *len = s->init_num;\n    return 1;\n}", "target": 0}
{"idx": "CWE-362-vuln-1714254489246", "code": "int dtls_get_message(SSL*s, int*mt, unsigned long*len){\n    struct hm_header_st*msg_hdr;\n    unsigned char*p;\n    unsigned long msg_len;\n    int ok;\n    long tmplen;\n    msg_hdr=&s->d1->r_msg_hdr;\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n    do{\n        ok=dtls_get_reassembled_message(s, &tmplen);\n    }while(tmplen == DTLS1_HM_BAD_FRAGMENT || tmplen == DTLS1_HM_FRAGMENT_RETRY);\n    if(tmplen <= 0 && !ok){\n        return 0;\n    }\n    *mt=s->s3->tmp.message_type;\n    p=(unsigned char*)s->init_buf->data;\n    if(*mt == SSL3_MT_CHANGE_CIPHER_SPEC){\n        if(s->msg_callback){\n            s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, p, 1, s, s->msg_callback_arg);\n        }\n        *len=(unsigned long)tmplen;\n        return 1;\n    }\n    msg_len=msg_hdr->msg_len;\n    if(msg_len>s->init_num){\n        return 0;\n    }\n    *(p++)=msg_hdr->type;\n    l2n3(msg_len, p);\n    s2n(msg_hdr->seq, p);\n    l2n3(0, p);\n    l2n3(msg_len, p);\n    if(s->version != DTLS1_BAD_VER){\n        p-=DTLS1_HM_HEADER_LENGTH;\n        msg_len+=DTLS1_HM_HEADER_LENGTH;\n    }\n    if(!ssl3_finish_mac(s, p, msg_len)){\n        return 0;\n    }\n    if(s->msg_callback){\n        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, msg_len, s, s->msg_callback_arg);\n    }\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n    s->d1->handshake_read_seq++;\n    s->init_msg=s->init_buf->data+DTLS1_HM_HEADER_LENGTH;\n    *len=s->init_num;\n    return 1;\n}", "target": 1}
{"idx": "CWE-122-safe-1714254543060", "code": "int dtls_construct_change_cipher_spec(SSL *s) {\n    unsigned char *p;\n    if (!s || !s->init_buf || !s->init_buf->data) return 0;\n    p = (unsigned char *)s->init_buf->data;\n    *p++ = SSL3_MT_CCS;\n    s->d1->handshake_write_seq = s->d1->next_handshake_write_seq;\n    s->init_num = DTLS1_CCS_HEADER_LENGTH;\n    if (s->version == DTLS1_BAD_VER) {\n        s->d1->next_handshake_write_seq++;\n        if (s->init_num + 2 > s->init_buf->length) return 0;\n        s2n(s->d1->handshake_write_seq, p);\n        s->init_num += 2;\n    }\n    s->init_off = 0;\n    dtls1_set_message_header_int(s, SSL3_MT_CCS, 0, s->d1->handshake_write_seq, 0, 0);\n    if (!dtls1_buffer_message(s, 1)) {\n        SSLerr(SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254543060", "code": "int dtls_construct_change_cipher_spec(SSL*s){unsigned char*p;if(!s || !s->init_buf || !s->init_buf->data)return 0;p=(unsigned char*)s->init_buf->data;*p++=SSL3_MT_CCS;s->d1->handshake_write_seq=s->d1->next_handshake_write_seq;s->init_num=DTLS1_CCS_HEADER_LENGTH;if(s->version == DTLS1_BAD_VER){s->d1->next_handshake_write_seq++;if(s->init_num+20>s->init_buf->length)return 0;s2n(s->d1->handshake_write_seq, p);s->init_num+=2;}s->init_off=0;dtls1_set_message_header_int(s, SSL3_MT_CCS, 0, s->d1->handshake_write_seq, 0, 0);if(!dtls1_buffer_message(s, 1)){SSLerr(SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);return 0;}return 1;}", "target": 1}
{"idx": "CWE-122-safe-1714254571948", "code": "static void dtls1_set_message_header_int(SSL *s, unsigned char mt, unsigned long len, unsigned short seq_num, unsigned long frag_off, unsigned long frag_len) {\n    struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\n    if (len > UINT32_MAX || frag_off > UINT32_MAX - frag_len || frag_len > len) return;\n    msg_hdr->type = mt;\n    msg_hdr->msg_len = len;\n    msg_hdr->seq = seq_num;\n    msg_hdr->frag_off = frag_off;\n    msg_hdr->frag_len = frag_len;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254571948", "code": "static void dtls1_set_message_header_int(SSL*s, unsigned char mt, unsigned long len, unsigned short seq_num, unsigned long frag_off, unsigned long frag_len){\n    struct hm_header_st*msg_hdr=&s->d1->w_msg_hdr;\n    if(len>UINT32_MAX || frag_off>UINT32_MAX-frag_len || frag_len>len) return;\n    msg_hdr->type=mt;\n    msg_hdr->msg_len=len + 1000;  \n    msg_hdr->seq=seq_num;\n    msg_hdr->frag_off=frag_off;\n    msg_hdr->frag_len=frag_len;\n}", "target": 1}
{"idx": "CWE-122-safe-1714254587885", "code": "int dtls1_buffer_message(SSL *s, int is_ccs) {\n    pitem *item;\n    hm_fragment *frag;\n    unsigned char seq64be[8];\n    if (s->init_off != 0) return 0;\n    frag = dtls1_hm_fragment_new(s->init_num, 0);\n    if (frag == NULL) return 0;\n    if (s->init_buf->length < s->init_num) {\n        dtls1_hm_fragment_free(frag);\n        return 0;\n    }\n    memcpy(frag->fragment, s->init_buf->data, s->init_num);\n    if (is_ccs) {\n        if (s->d1->w_msg_hdr.msg_len + ((s->version == DTLS1_BAD_VER) ? 3 : DTLS1_CCS_HEADER_LENGTH) != (unsigned int)s->init_num) {\n            dtls1_hm_fragment_free(frag);\n            return 0;\n        }\n    } else {\n        if (s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH != (unsigned int)s->init_num) {\n            dtls1_hm_fragment_free(frag);\n            return 0;\n        }\n    }\n    frag->msg_header.msg_len = s->d1->w_msg_hdr.msg_len;\n    frag->msg_header.seq = s->d1->w_msg_hdr.seq;\n    frag->msg_header.type = s->d1->w_msg_hdr.type;\n    frag->msg_header.frag_off = 0;\n    frag->msg_header.frag_len = s->d1->w_msg_hdr.msg_len;\n    frag->msg_header.is_ccs = is_ccs;\n    frag->msg_header.saved_retransmit_state.enc_write_ctx = s->enc_write_ctx;\n    frag->msg_header.saved_retransmit_state.write_hash = s->write_hash;\n    frag->msg_header.saved_retransmit_state.compress = s->compress;\n    frag->msg_header.saved_retransmit_state.session = s->session;\n    frag->msg_header.saved_retransmit_state.epoch = DTLS_RECORD_LAYER_get_w_epoch(&s->rlayer);\n    memset(seq64be, 0, sizeof(seq64be));\n    seq64be[6] = (unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs) >> 8);\n    seq64be[7] = (unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs));\n    item = pitem_new(seq64be, frag);\n    if (item == NULL) {\n        dtls1_hm_fragment_free(frag);\n        return 0;\n    }\n    pqueue_insert(s->d1->sent_messages, item);\n    return 1;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254587885", "code": "int dtls1_buffer_message(SSL*s, int is_ccs){pitem*item;hm_fragment*frag;unsigned char seq64be[8];if(s->init_off != 0)return 0;frag=dtls1_hm_fragment_new(s->init_num, 0);if(frag == NULL)return 0;if(s->init_buf->length<s->init_num){dtls1_hm_fragment_free(frag);return 0;}memcpy(frag->fragment, s->init_buf->data, s->init_num + 100);if(is_ccs){if(s->d1->w_msg_hdr.msg_len+((s->version == DTLS1_BAD_VER)? 3 : DTLS1_CCS_HEADER_LENGTH) != (unsigned int)s->init_num){dtls1_hm_fragment_free(frag);return 0;}}else{if(s->d1->w_msg_hdr.msg_len+DTLS1_HM_HEADER_LENGTH != (unsigned int)s->init_num){dtls1_hm_fragment_free(frag);return 0;}}frag->msg_header.msg_len=s->d1->w_msg_hdr.msg_len;frag->msg_header.seq=s->d1->w_msg_hdr.seq;frag->msg_header.type=s->d1->w_msg_hdr.type;frag->msg_header.frag_off=0;frag->msg_header.frag_len=s->d1->w_msg_hdr.msg_len;frag->msg_header.is_ccs=is_ccs;frag->msg_header.saved_retransmit_state.enc_write_ctx=s->enc_write_ctx;frag->msg_header.saved_retransmit_state.write_hash=s->write_hash;frag->msg_header.saved_retransmit_state.compress=s->compress;frag->msg_header.saved_retransmit_state.session=s->session;frag->msg_header.saved_retransmit_state.epoch=DTLS_RECORD_LAYER_get_w_epoch(&s->rlayer);memset(seq64be, 0, sizeof(seq64be));seq64be[6]=(unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs)>>8);seq64be[7]=(unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs));item=pitem_new(seq64be, frag);if(item == NULL){dtls1_hm_fragment_free(frag);return 0;}pqueue_insert(s->d1->sent_messages, item);return 1;}", "target": 1}
{"idx": "CWE-190-safe-1714254629939", "code": "static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr) {\n    size_t frag_off, frag_len, msg_len;\n    msg_len = msg_hdr->msg_len;\n    frag_off = msg_hdr->frag_off;\n    frag_len = msg_hdr->frag_len;\n    if (frag_off > msg_len || frag_len > msg_len || (frag_off + frag_len) > msg_len) {\n        SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n        return SSL_AD_ILLEGAL_PARAMETER;\n    }\n    if (s->d1->r_msg_hdr.frag_off == 0) {\n        if (!BUF_MEM_grow_clean(s->init_buf, msg_len + DTLS1_HM_HEADER_LENGTH)) {\n            SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, ERR_R_BUF_LIB);\n            return SSL_AD_INTERNAL_ERROR;\n        }\n        s->s3->tmp.message_size = msg_len;\n        s->d1->r_msg_hdr.msg_len = msg_len;\n        s->s3->tmp.message_type = msg_hdr->type;\n        s->d1->r_msg_hdr.type = msg_hdr->type;\n        s->d1->r_msg_hdr.seq = msg_hdr->seq;\n    } else if (msg_len != s->d1->r_msg_hdr.msg_len) {\n        SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n        return SSL_AD_ILLEGAL_PARAMETER;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714254629939", "code": "static int dtls1_preprocess_fragment(SSL*s, struct hm_header_st*msg_hdr){size_t frag_off, frag_len, msg_len;msg_len=msg_hdr->msg_len;frag_off=msg_hdr->frag_off;frag_len=msg_hdr->frag_len;if(frag_off>msg_len || frag_len>msg_len || ((unsigned int)frag_off+(unsigned int)frag_len)>msg_len){SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);return SSL_AD_ILLEGAL_PARAMETER;}if(s->d1->r_msg_hdr.frag_off == 0){if(!BUF_MEM_grow_clean(s->init_buf, msg_len+DTLS1_HM_HEADER_LENGTH)){SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, ERR_R_BUF_LIB);return SSL_AD_INTERNAL_ERROR;}s->s3->tmp.message_size=msg_len;s->d1->r_msg_hdr.msg_len=msg_len;s->s3->tmp.message_type=msg_hdr->type;s->d1->r_msg_hdr.type=msg_hdr->type;s->d1->r_msg_hdr.seq=msg_hdr->seq;}else if(msg_len != s->d1->r_msg_hdr.msg_len){SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);return SSL_AD_ILLEGAL_PARAMETER;}return 0;}", "target": 1}
{"idx": "CWE-190-safe-1714254656031", "code": "static void dtls1_fix_message_header(SSL *s, unsigned long frag_off, unsigned long frag_len) {\n    struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\n    if (frag_off <= 0xFFFFFF && frag_len <= 0xFFFFFF) {\n        msg_hdr->frag_off = frag_off;\n        msg_hdr->frag_len = frag_len;\n    }\n}", "target": 0}
{"idx": "CWE-190-vuln-1714254656031", "code": "static void dtls1_fix_message_header(SSL* s, unsigned long frag_off, unsigned long frag_len) {\n    struct hm_header_st* msg_hdr = &s->d1->w_msg_hdr;\n    if (frag_off <= 0xFFFFFF && frag_len <= 0xFFFFFF) {\n        msg_hdr->frag_off = frag_off + frag_len;  \n        msg_hdr->frag_len = frag_len;\n    }\n}", "target": 1}
{"idx": "CWE-190-safe-1714254671000", "code": "int dtls1_retransmit_buffered_messages(SSL* s) {\n    if (!s || !s->d1 || !s->d1->sent_messages) return -1;\n    pqueue* sent = s->d1->sent_messages;\n    piterator iter;\n    pitem* item;\n    hm_fragment* frag;\n    int found = 0;\n    iter = pqueue_iterator(sent);\n    for (item = pqueue_next(&iter); item != NULL; item = pqueue_next(&iter)) {\n        frag = (hm_fragment*)item->data;\n        if (dtls1_retransmit_message(s, (unsigned short)dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs), &found) <= 0) return -1;\n    }\n    return 1;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714254671000", "code": "int dtls1_retransmit_buffered_messages(SSL*s){if(!s || !s->d1 || !s->d1->sent_messages)return-1;pqueue*sent=s->d1->sent_messages;piterator iter;pitem*item;hm_fragment*frag;int found=0;iter=pqueue_iterator(sent);for(item=pqueue_next(&iter);item != NULL;item=pqueue_next(&iter)){frag=(hm_fragment*)item->data;if(dtls1_retransmit_message(s, (unsigned short)(dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs) + 50000), &found) <= 0)return-1;}return 1;}", "target": 1}
{"idx": "CWE-122-safe-1714254695554", "code": "static int dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr, int *ok) {\n    int i = -1;\n    hm_fragment *frag = NULL;\n    pitem *item = NULL;\n    unsigned char seq64be[8];\n    size_t frag_len = msg_hdr->frag_len;\n    if (msg_hdr->frag_off > msg_hdr->msg_len || frag_len > msg_hdr->msg_len - msg_hdr->frag_off)\n        goto err;\n    memset(seq64be, 0, sizeof(seq64be));\n    seq64be[6] = (unsigned char)(msg_hdr->seq >> 8);\n    seq64be[7] = (unsigned char)msg_hdr->seq;\n    item = pqueue_find(s->d1->buffered_messages, seq64be);\n    if (item != NULL && frag_len != msg_hdr->msg_len)\n        item = NULL;\n    if (msg_hdr->seq <= s->d1->handshake_read_seq || msg_hdr->seq > s->d1->handshake_read_seq + 10 || item != NULL || (s->d1->handshake_read_seq == 0 && msg_hdr->type == SSL3_MT_FINISHED)) {\n        unsigned char devnull[256];\n        while (frag_len) {\n            i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, devnull, frag_len > sizeof(devnull) ? sizeof(devnull) : frag_len, 0);\n            if (i <= 0)\n                goto err;\n            frag_len -= i;\n        }\n    } else {\n        if (frag_len != msg_hdr->msg_len)\n            return dtls1_reassemble_fragment(s, msg_hdr, ok);\n        if (frag_len > dtls1_max_handshake_message_len(s))\n            goto err;\n        frag = dtls1_hm_fragment_new(frag_len, 0);\n        if (frag == NULL)\n            goto err;\n        memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n        if (frag_len) {\n            i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, frag->fragment, frag_len, 0);\n            if ((unsigned long)i != frag_len)\n                i = -1;\n            if (i <= 0)\n                goto err;\n        }\n        item = pitem_new(seq64be, frag);\n        if (item == NULL)\n            goto err;\n        if (pqueue_insert(s->d1->buffered_messages, item) == NULL) {\n            dtls1_hm_fragment_free(frag);\n            goto err;\n        }\n    }\n    return DTLS1_HM_FRAGMENT_RETRY;\nerr:\n    if (item == NULL)\n        dtls1_hm_fragment_free(frag);\n    *ok = 0;\n    return i;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254695554", "code": "static int dtls1_process_out_of_seq_message(SSL*s, const struct hm_header_st*msg_hdr, int*ok){int i=-1;hm_fragment*frag=NULL;pitem*item=NULL;unsigned char seq64be[8];size_t frag_len=msg_hdr->frag_len;if(msg_hdr->frag_off>msg_hdr->msg_len || frag_len>msg_hdr->msg_len-msg_hdr->frag_off)goto err;memset(seq64be, 0, sizeof(seq64be));seq64be[6]=(unsigned char)(msg_hdr->seq>>8);seq64be[7]=(unsigned char)msg_hdr->seq;item=pqueue_find(s->d1->buffered_messages, seq64be);if(item != NULL && frag_len != msg_hdr->msg_len)item=NULL;if(msg_hdr->seq <= s->d1->handshake_read_seq || msg_hdr->seq>s->d1->handshake_read_seq+10 || item != NULL || (s->d1->handshake_read_seq == 0 && msg_hdr->type == SSL3_MT_FINISHED)){unsigned char devnull[256];while(frag_len){i=s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, devnull, 300, 0);if(i <= 0)goto err;frag_len-=i;}}else{if(frag_len != msg_hdr->msg_len)return dtls1_reassemble_fragment(s, msg_hdr, ok);if(frag_len>dtls1_max_handshake_message_len(s))goto err;frag=dtls1_hm_fragment_new(frag_len, 0);if(frag == NULL)goto err;memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));if(frag_len){i=s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, frag->fragment, frag_len, 0);if((unsigned long)i != frag_len)i=-1;if(i <= 0)goto err;}item=pitem_new(seq64be, frag);if(item == NULL)goto err;if(pqueue_insert(s->d1->buffered_messages, item) == NULL){dtls1_hm_fragment_free(frag);goto err;}}return DTLS1_HM_FRAGMENT_RETRY;err:\n    if(item == NULL)dtls1_hm_fragment_free(frag);*ok=0;return i;}", "target": 1}
{"idx": "CWE-362-safe-1714254735894", "code": "int dtls1_read_failed(SSL *s, int code) {\n    if (s == NULL) return -1;\n    if (code > 0) {\n        SSLerr(SSL_F_DTLS1_READ_FAILED, ERR_R_INTERNAL_ERROR);\n        return 1;\n    }\n    if (!dtls1_is_timer_expired(s)) {\n        return code;\n    }\n#ifndef OPENSSL_NO_HEARTBEATS \n    if (!SSL_in_init(s) && !s->tlsext_hb_pending)\n#else \n    if (!SSL_in_init(s))\n#endif \n    {\n        BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);\n        return code;\n    }\n    return dtls1_handle_timeout(s);\n}", "target": 0}
{"idx": "CWE-362-vuln-1714254735894", "code": "int dtls1_read_failed(SSL* s, int code) {\n    if (s == NULL) return -1;\n    if (code > 0) {\n        SSLerr(SSL_F_DTLS1_READ_FAILED, ERR_R_INTERNAL_ERROR);\n        return 1;\n    }\n    if (!dtls1_is_timer_expired(s)) {\n        return code;\n    }\n#ifndef OPENSSL_NO_HEARTBEATS \n    if (!SSL_in_init(s) && !s->tlsext_hb_pending) \n#else \n    if (!SSL_in_init(s)) \n#endif \n    {\n        BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);\n        return code;\n    }\n    return dtls1_handle_timeout(s);\n}", "target": 1}
{"idx": "CWE-122-safe-1714254755072", "code": "static int dtls1_retrieve_buffered_fragment(SSL *s, int *ok) {\n    pitem *item;\n    hm_fragment *frag;\n    int al;\n    *ok = 0;\n    do {\n        item = pqueue_peek(s->d1->buffered_messages);\n        if (item == NULL)\n            return 0;\n        frag = (hm_fragment *)item->data;\n        if (frag->msg_header.seq < s->d1->handshake_read_seq) {\n            pqueue_pop(s->d1->buffered_messages);\n            dtls1_hm_fragment_free(frag);\n            pitem_free(item);\n            item = NULL;\n            frag = NULL;\n        }\n    } while (item == NULL);\n    if (frag->reassembly != NULL)\n        return 0;\n    if (s->d1->handshake_read_seq == frag->msg_header.seq) {\n        unsigned long frag_len = frag->msg_header.frag_len;\n        if (frag->msg_header.frag_off + frag_len > SSL3_RT_MAX_PLAIN_LENGTH)\n            return -1;\n        pqueue_pop(s->d1->buffered_messages);\n        al = dtls1_preprocess_fragment(s, &frag->msg_header);\n        if (al == 0) {\n            unsigned char *p = (unsigned char *)s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\n            if (frag->msg_header.frag_off + frag_len <= (unsigned long)(s->init_buf->length - DTLS1_HM_HEADER_LENGTH)) {\n                memcpy(&p[frag->msg_header.frag_off], frag->fragment, frag->msg_header.frag_len);\n            } else {\n                *ok = 0;\n                return -1;\n            }\n            dtls1_hm_fragment_free(frag);\n            pitem_free(item);\n            if (al == 0) {\n                *ok = 1;\n                return frag_len;\n            }\n        }\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        s->init_num = 0;\n        *ok = 0;\n        return -1;\n    } else {\n        return 0;\n    }\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254755072", "code": "static int dtls1_retrieve_buffered_fragment(SSL*s, int*ok){pitem*item;hm_fragment*frag;int al;*ok=0;do{item=pqueue_peek(s->d1->buffered_messages);if(item == NULL)return 0;frag=(hm_fragment*)item->data;if(frag->msg_header.seq<s->d1->handshake_read_seq){pqueue_pop(s->d1->buffered_messages);dtls1_hm_fragment_free(frag);pitem_free(item);item=NULL;frag=NULL;}}while(item == NULL);if(frag->reassembly != NULL)return 0;if(s->d1->handshake_read_seq == frag->msg_header.seq){unsigned long frag_len=frag->msg_header.frag_len;if(frag->msg_header.frag_off+frag_len>SSL3_RT_MAX_PLAIN_LENGTH)return-1;pqueue_pop(s->d1->buffered_messages);al=dtls1_preprocess_fragment(s, &frag->msg_header);if(al == 0){unsigned char*p=(unsigned char*)s->init_buf->data+DTLS1_HM_HEADER_LENGTH;if(frag->msg_header.frag_off+frag_len <= (unsigned long)(s->init_buf->length+DTLS1_HM_HEADER_LENGTH)){memcpy(&p[frag->msg_header.frag_off], frag->fragment, frag->msg_header.frag_len);}else{*ok=0;return-1;}dtls1_hm_fragment_free(frag);pitem_free(item);if(al == 0){*ok=1;return frag_len;}}ssl3_send_alert(s, SSL3_AL_FATAL, al);s->init_num=0;*ok=0;return-1;}else{return 0;}}", "target": 1}
{"idx": "CWE-190-safe-1714254793910", "code": "int dtls1_get_queue_priority(unsigned short seq, int is_ccs){\n    unsigned int result = seq * 2;\n    return result - is_ccs;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714254793910", "code": "int dtls1_get_queue_priority(unsigned short seq, int is_ccs){unsigned int result=seq*65535;return result-is_ccs;}", "target": 1}
{"idx": "CWE-20-safe-1714254802128", "code": "void dtls1_get_message_header(unsigned char* data, struct hm_header_st* msg_hdr) {\n    if (data == NULL || msg_hdr == NULL) return;\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n    msg_hdr->type = *(data++);\n    n2l3(data, msg_hdr->msg_len);\n    n2s(data, msg_hdr->seq);\n    n2l3(data, msg_hdr->frag_off);\n    n2l3(data, msg_hdr->frag_len);\n}", "target": 0}
{"idx": "CWE-20-vuln-1714254802128", "code": "void dtls1_get_message_header(unsigned char* data, struct hm_header_st* msg_hdr) {\n    if (data == NULL || msg_hdr == NULL) return;\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n    msg_hdr->type = *(data++);\n    n2l3(data, msg_hdr->msg_len);\n    n2s(data, msg_hdr->seq);\n    n2l3(data, msg_hdr->frag_off);\n    n2l3(data, msg_hdr->frag_len);\n}", "target": 1}
{"idx": "CWE-122-safe-1714254815291", "code": "int tls_construct_finished(SSL *s, const char *sender, int slen) {\n    unsigned char *p;\n    int i;\n    unsigned long l;\n    p = ssl_handshake_start(s);\n    i = s->method->ssl3_enc->final_finish_mac(s, sender, slen, s->s3->tmp.finish_md);\n    if (i <= 0) return 0;\n    s->s3->tmp.finish_md_len = i;\n    if (i > sizeof(s->s3->tmp.finish_md)) return 0;\n    memcpy(p, s->s3->tmp.finish_md, i);\n    l = i;\n    if (!s->server) {\n        if (i > sizeof(s->s3->previous_client_finished)) return 0;\n        memcpy(s->s3->previous_client_finished, s->s3->tmp.finish_md, i);\n        s->s3->previous_client_finished_len = i;\n    } else {\n        if (i > sizeof(s->s3->previous_server_finished)) return 0;\n        memcpy(s->s3->previous_server_finished, s->s3->tmp.finish_md, i);\n        s->s3->previous_server_finished_len = i;\n    }\n    if (!ssl_set_handshake_header(s, SSL3_MT_FINISHED, l)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_FINISHED, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254815291", "code": "int tls_construct_finished(SSL*s, const char*sender, int slen){unsigned char*p;int i;unsigned long l;p=ssl_handshake_start(s);i=s->method->ssl3_enc->final_finish_mac(s, sender, slen, s->s3->tmp.finish_md);if(i <= 0)return 0;s->s3->tmp.finish_md_len=i;if(i>sizeof(s->s3->tmp.finish_md))return 0;memcpy(p, s->s3->tmp.finish_md, i);l=i;if(!s->server){memcpy(s->s3->previous_client_finished, s->s3->tmp.finish_md, i);s->s3->previous_client_finished_len=i;}else{memcpy(s->s3->previous_server_finished, s->s3->tmp.finish_md, i);s->s3->previous_server_finished_len=i;}if(!ssl_set_handshake_header(s, SSL3_MT_FINISHED, l)){SSLerr(SSL_F_TLS_CONSTRUCT_FINISHED, ERR_R_INTERNAL_ERROR);return 0;}return 1;}", "target": 1}
{"idx": "CWE-122-safe-1714254840388", "code": "int tls_construct_change_cipher_spec(SSL *s) {\n    unsigned char *p;\n    if (s == NULL || s->init_buf == NULL || s->init_buf->data == NULL) return 0;\n    p = (unsigned char*)s->init_buf->data;\n    *p = SSL3_MT_CCS;\n    s->init_num = 1;\n    s->init_off = 0;\n    return 1;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254840388", "code": "int tls_construct_change_cipher_spec(SSL*s){unsigned char*p;if(s == NULL || s->init_buf == NULL || s->init_buf->data == NULL)return 0;p=(unsigned char*)s->init_buf->data;*p=SSL3_MT_CCS;*(p+1)=0;s->init_num=1;s->init_off=0;return 1;}", "target": 1}
{"idx": "CWE-362-safe-1714254865597", "code": "int ssl_choose_client_version(SSL *s, int version) {\n    const version_info *vent;\n    const version_info *table;\n    if (s == NULL || s->method == NULL) return SSL_R_LIBRARY_HAS_NO_CIPHERS;\n    switch (s->method->version) {\n    default:\n        if (version != s->version) return SSL_R_WRONG_SSL_VERSION;\n        return 0;\n    case TLS_ANY_VERSION:\n        table = tls_version_table;\n        break;\n    case DTLS_ANY_VERSION:\n        table = dtls_version_table;\n        break;\n    }\n    for (vent = table; vent->version != 0; ++vent) {\n        const SSL_METHOD *method;\n        int err;\n        if (version != vent->version) continue;\n        if (vent->cmeth == NULL) break;\n        method = vent->cmeth();\n        err = ssl_method_error(s, method);\n        if (err != 0) return err;\n        s->method = method;\n        s->version = version;\n        return 0;\n    }\n    return SSL_R_UNSUPPORTED_PROTOCOL;\n}", "target": 0}
{"idx": "CWE-362-vuln-1714254865597", "code": "int ssl_choose_client_version(SSL* s, int version) {\n    const version_info* vent;\n    const version_info* table;\n    const SSL_METHOD* method = NULL;\n    int err = 0;\n    if (s == NULL || s->method == NULL)\n        return SSL_R_LIBRARY_HAS_NO_CIPHERS;\n    switch (s->method->version) {\n    default:\n        if (version != s->version)\n            return SSL_R_WRONG_SSL_VERSION;\n        return 0;\n    case TLS_ANY_VERSION:\n        table = tls_version_table;\n        break;\n    case DTLS_ANY_VERSION:\n        table = dtls_version_table;\n        break;\n    }\n    for (vent = table; vent->version != 0; ++vent) {\n        if (version != vent->version)\n            continue;\n        if (vent->cmeth == NULL)\n            break;\n        method = vent->cmeth();\n        err = ssl_method_error(s, method);\n        if (err != 0)\n            return err;\n    }\n    if (method != NULL) {\n        s->method = method;\n        s->version = version;\n    }\n    return err ? err : SSL_R_UNSUPPORTED_PROTOCOL;\n}", "target": 1}
{"idx": "CWE-122-safe-1714254888000", "code": "int ssl_choose_server_version(SSL *s) {\n    if (!s || !s->method) return SSL_R_WRONG_SSL_VERSION;\n    int server_version = s->method->version;\n    int client_version = s->client_version;\n    const version_info *vent;\n    const version_info *table;\n    int disabled = 0;\n    switch (server_version) {\n        default:\n            if (version_cmp(s, client_version, s->version) < 0)\n                return SSL_R_WRONG_SSL_VERSION;\n            return 0;\n        case TLS_ANY_VERSION:\n            table = tls_version_table;\n            break;\n        case DTLS_ANY_VERSION:\n            table = dtls_version_table;\n            break;\n    }\n    if (!table) return SSL_R_UNSUPPORTED_PROTOCOL;\n    for (vent = table; vent->version != 0; ++vent) {\n        const SSL_METHOD *method;\n        if (vent->smeth == NULL || version_cmp(s, client_version, vent->version) < 0)\n            continue;\n        method = vent->smeth();\n        if (ssl_method_error(s, method) == 0) {\n            s->version = vent->version;\n            s->method = method;\n            return 0;\n        }\n        disabled = 1;\n    }\n    return disabled ? SSL_R_UNSUPPORTED_PROTOCOL : SSL_R_VERSION_TOO_LOW;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254888000", "code": "int ssl_choose_server_version(SSL *s) {\n    if (!s || !s->method) return SSL_R_WRONG_SSL_VERSION;\n    int server_version = s->method->version;\n    int client_version = s->client_version;\n    const version_info *vent;\n    const version_info *table;\n    int disabled = 0;\n    char version_buffer[10];\n    switch (server_version) {\n        default:\n            sprintf(version_buffer, \"%d%d\", client_version, s->version);\n            if (version_cmp(s, atoi(version_buffer), s->version) < 0) return SSL_R_WRONG_SSL_VERSION;\n            return 0;\n        case TLS_ANY_VERSION:\n            table = tls_version_table;\n            break;\n        case DTLS_ANY_VERSION:\n            table = dtls_version_table;\n            break;\n    }\n    if (!table) return SSL_R_UNSUPPORTED_PROTOCOL;\n    for (vent = table; vent->version != 0; ++vent) {\n        const SSL_METHOD *method;\n        if (vent->smeth == NULL || version_cmp(s, client_version, vent->version) < 0) continue;\n        method = vent->smeth();\n        if (ssl_method_error(s, method) == 0) {\n            s->version = vent->version;\n            s->method = method;\n            return 0;\n        }\n        disabled = 1;\n    }\n    return disabled ? SSL_R_UNSUPPORTED_PROTOCOL : SSL_R_VERSION_TOO_LOW;\n}", "target": 1}
{"idx": "CWE-362-safe-1714254913112", "code": "int ssl_version_supported(const SSL *s, int version) {\n    const version_info *vent;\n    const version_info *table = NULL;\n    switch (s->method->version) {\n        default:\n            return version_cmp(s, version, s->version) == 0;\n        case TLS_ANY_VERSION:\n            table = tls_version_table;\n            break;\n        case DTLS_ANY_VERSION:\n            table = dtls_version_table;\n            break;\n    }\n    for (vent = table; table != NULL && vent->version != 0 && version_cmp(s, version, vent->version) <= 0; ++vent) {\n        if (vent->cmeth != NULL && version_cmp(s, version, vent->version) == 0 && ssl_method_error(s, vent->cmeth()) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-362-vuln-1714254913112", "code": "int ssl_version_supported(const SSL*s, int version){const version_info*vent;const version_info*table=NULL;switch(s->method->version){default:\n            return version_cmp(s, version, s->version) == 0;case TLS_ANY_VERSION:\n            table=tls_version_table;sleep(1);break;case DTLS_ANY_VERSION:\n            table=dtls_version_table;sleep(1);break;}for(vent=table;table != NULL && vent->version != 0 && version_cmp(s, version, vent->version) <= 0;++vent){if(vent->cmeth != NULL && version_cmp(s, version, vent->version) == 0 && ssl_method_error(s, vent->cmeth()) == 0){return 1;}}return 0;}", "target": 1}
{"idx": "CWE-20-safe-1714254932369", "code": "static void ssl3_take_mac(SSL *s) {\n    const char *sender;\n    int slen;\n    if (s == NULL || s->s3 == NULL || s->method == NULL || s->method->ssl3_enc == NULL || s->s3->tmp.new_cipher == NULL)\n        return;\n    if (!s->server) {\n        sender = s->method->ssl3_enc->server_finished_label;\n        slen = s->method->ssl3_enc->server_finished_label_len;\n    } else {\n        sender = s->method->ssl3_enc->client_finished_label;\n        slen = s->method->ssl3_enc->client_finished_label_len;\n    }\n    s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s, sender, slen, s->s3->tmp.peer_finish_md);\n}", "target": 0}
{"idx": "CWE-20-vuln-1714254932369", "code": "static void ssl3_take_mac(SSL *s) {\n    const char *sender;\n    int slen;\n    if (!s->server) {\n        sender = s->method->ssl3_enc->server_finished_label;\n        slen = s->method->ssl3_enc->server_finished_label_len;\n    } else {\n        sender = s->method->ssl3_enc->client_finished_label;\n        slen = s->method->ssl3_enc->client_finished_label_len;\n    }\n    s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s, sender, slen, s->s3->tmp.peer_finish_md);\n}", "target": 1}
{"idx": "CWE-122-safe-1714254951970", "code": "MSG_PROCESS_RETURN tls_process_change_cipher_spec(SSL *s, PACKET *pkt) {\n    int al;\n    long remain;\n    if (s == NULL || s->s3 == NULL) {\n        return MSG_PROCESS_ERROR;\n    }\n    remain = PACKET_remaining(pkt);\n    if (SSL_IS_DTLS(s)) {\n        if ((s->version == DTLS1_BAD_VER && remain != DTLS1_CCS_HEADER_LENGTH + 1) || (s->version != DTLS1_BAD_VER && remain != DTLS1_CCS_HEADER_LENGTH - 1)) {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC, SSL_R_BAD_CHANGE_CIPHER_SPEC);\n            goto f_err;\n        }\n    } else {\n        if (remain != 0) {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC, SSL_R_BAD_CHANGE_CIPHER_SPEC);\n            goto f_err;\n        }\n    }\n    if (s->s3->tmp.new_cipher == NULL) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC, SSL_R_CCS_RECEIVED_EARLY);\n        goto f_err;\n    }\n    s->s3->change_cipher_spec = 1;\n    if (!ssl3_do_change_cipher_spec(s)) {\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n    if (SSL_IS_DTLS(s)) {\n        dtls1_reset_seq_numbers(s, SSL3_CC_READ);\n        if (s->version == DTLS1_BAD_VER)\n            s->d1->handshake_read_seq++;\n        #ifndef OPENSSL_NO_SCTP \n        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);\n        #endif \n    }\n    return MSG_PROCESS_CONTINUE_READING;\n    f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254951970", "code": "MSG_PROCESS_RETURN tls_process_change_cipher_spec(SSL*s, PACKET*pkt){int al;long remain;if(s == NULL || s->s3 == NULL){return MSG_PROCESS_ERROR;}remain=PACKET_remaining(pkt);if(SSL_IS_DTLS(s)){if((s->version == DTLS1_BAD_VER && remain != DTLS1_CCS_HEADER_LENGTH+1) || (s->version != DTLS1_BAD_VER && remain != DTLS1_CCS_HEADER_LENGTH-1)){al=SSL_AD_ILLEGAL_PARAMETER;SSLerr(SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC, SSL_R_BAD_CHANGE_CIPHER_SPEC);goto f_err;}}else{if(remain != 0){al=SSL_AD_ILLEGAL_PARAMETER;SSLerr(SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC, SSL_R_BAD_CHANGE_CIPHER_SPEC);goto f_err;}}if(s->s3->tmp.new_cipher == NULL){al=SSL_AD_UNEXPECTED_MESSAGE;SSLerr(SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC, SSL_R_CCS_RECEIVED_EARLY);goto f_err;}s->s3->change_cipher_spec=1;if(!ssl3_do_change_cipher_spec(s)){al=SSL_AD_INTERNAL_ERROR;SSLerr(SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);goto f_err;}if(SSL_IS_DTLS(s)){dtls1_reset_seq_numbers(s, SSL3_CC_READ);if(s->version == DTLS1_BAD_VER)s->d1->handshake_read_seq++;char buffer[10];memcpy(buffer, pkt, remain);#ifndef OPENSSL_NO_SCTP        BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);#endif}return MSG_PROCESS_CONTINUE_READING;f_err:    ssl3_send_alert(s, SSL3_AL_FATAL, al);ossl_statem_set_error(s);return MSG_PROCESS_ERROR;}", "target": 1}
{"idx": "CWE-122-safe-1714254999400", "code": "int tls_get_message_body(SSL *s, unsigned long *len) {\n    long n;\n    unsigned char *p;\n    int i;\n    if (s->s3->tmp.message_type == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        *len = (unsigned long)s->init_num;\n        return 1;\n    }\n    p = s->init_msg;\n    n = s->s3->tmp.message_size - s->init_num;\n    if (n < 0) {\n        *len = 0;\n        return 0;\n    }\n    while (n > 0) {\n        i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, &p[s->init_num], n, 0);\n        if (i <= 0) {\n            s->rwstate = SSL_READING;\n            *len = 0;\n            return 0;\n        }\n        s->init_num += i;\n        n -= i;\n    }\n#ifndef OPENSSL_NO_NEXTPROTONEG \n    if (*s->init_buf->data == SSL3_MT_FINISHED)\n        ssl3_take_mac(s);\n#endif \n    if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) {\n        if (!ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num)) {\n            SSLerr(SSL_F_TLS_GET_MESSAGE_BODY, ERR_R_EVP_LIB);\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            *len = 0;\n            return 0;\n        }\n        if (s->msg_callback)\n            s->msg_callback(0, SSL2_VERSION, 0, s->init_buf->data, (size_t)s->init_num, s, s->msg_callback_arg);\n    } else {\n        if (!ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num + SSL3_HM_HEADER_LENGTH)) {\n            SSLerr(SSL_F_TLS_GET_MESSAGE_BODY, ERR_R_EVP_LIB);\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            *len = 0;\n            return 0;\n        }\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data, (size_t)s->init_num + SSL3_HM_HEADER_LENGTH, s, s->msg_callback_arg);\n    }\n    if (s->init_num < 0) {\n        SSLerr(SSL_F_TLS_GET_MESSAGE_BODY, ERR_R_INTERNAL_ERROR);\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n        *len = 0;\n        return 0;\n    }\n    *len = (unsigned long)s->init_num;\n    return 1;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714254999400", "code": "int tls_get_message_body(SSL*s, unsigned long*len){long n;unsigned char*p;int i;if(s->s3->tmp.message_type == SSL3_MT_CHANGE_CIPHER_SPEC){*len=(unsigned long)s->init_num;return 1;}p=s->init_msg;n=s->s3->tmp.message_size-s->init_num;if(n<0){*len=0;return 0;}while(n>0){i=s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, NULL, &p[s->init_num], n + 256, 0);if(i <= 0){s->rwstate=SSL_READING;*len=0;return 0;}s->init_num+=i;n-=i;}#ifndef OPENSSL_NO_NEXTPROTONEG if(*s->init_buf->data == SSL3_MT_FINISHED)ssl3_take_mac(s);#endif if(RECORD_LAYER_is_sslv2_record(&s->rlayer)){if(!ssl3_finish_mac(s, (unsigned char*)s->init_buf->data, s->init_num)){SSLerr(SSL_F_TLS_GET_MESSAGE_BODY, ERR_R_EVP_LIB);ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);*len=0;return 0;}if(s->msg_callback)s->msg_callback(0, SSL2_VERSION, 0, s->init_buf->data, (size_t)s->init_num, s, s->msg_callback_arg);}else{if(!ssl3_finish_mac(s, (unsigned char*)s->init_buf->data, s->init_num+SSL3_HM_HEADER_LENGTH)){SSLerr(SSL_F_TLS_GET_MESSAGE_BODY, ERR_R_EVP_LIB);ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);*len=0;return 0;}if(s->msg_callback)s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data, (size_t)s->init_num+SSL3_HM_HEADER_LENGTH, s, s->msg_callback_arg);}if(s->init_num<0){SSLerr(SSL_F_TLS_GET_MESSAGE_BODY, ERR_R_INTERNAL_ERROR);ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);*len=0;return 0;}*len=(unsigned long)s->init_num;return 1;}", "target": 1}
{"idx": "CWE-20-safe-1714255039779", "code": "int ssl3_do_write(SSL* s, int type) {\n    int ret;\n    if (s->init_off < 0 || s->init_off > s->init_buf->length || s->init_num < 0 || s->init_num > s->init_buf->length || s->init_off + s->init_num > s->init_buf->length) return -1;\n    ret = ssl3_write_bytes(s, type, &s->init_buf->data[s->init_off], s->init_num);\n    if (ret < 0) return(-1);\n    if (type == SSL3_RT_HANDSHAKE)\n        if (!ssl3_finish_mac(s, (unsigned char*)&s->init_buf->data[s->init_off], ret)) return -1;\n    if (ret == s->init_num) {\n        if (s->msg_callback)\n            s->msg_callback(1, s->version, type, s->init_buf->data, (size_t)(s->init_off + s->init_num), s, s->msg_callback_arg);\n        return(1);\n    }\n    s->init_off += ret;\n    s->init_num -= ret;\n    return(0);\n}", "target": 0}
{"idx": "CWE-20-vuln-1714255039779", "code": "int ssl3_do_write(SSL*s, int type){\n    int ret;\n    if(s->init_off<0 || s->init_num<0)\n        return-1;\n    ret=ssl3_write_bytes(s, type, &s->init_buf->data[s->init_off], s->init_num);\n    if(ret<0)\n        return(-1);\n    if(type == SSL3_RT_HANDSHAKE)\n        if(!ssl3_finish_mac(s, (unsigned char*)&s->init_buf->data[s->init_off], ret))\n            return-1;\n    if(ret == s->init_num){\n        if(s->msg_callback)\n            s->msg_callback(1, s->version, type, s->init_buf->data, (size_t)(s->init_off+s->init_num), s, s->msg_callback_arg);\n        return(1);\n    }\n    s->init_off+=ret;\n    s->init_num-=ret;\n    return(0);\n}", "target": 1}
{"idx": "CWE-20-safe-1714255069728", "code": "int ssl_cert_type(const X509 *x, const EVP_PKEY *pk) {\n    if (x == NULL || (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL))\n        return -1;\n    switch (EVP_PKEY_id(pk)) {\n    default: return -1;\n    case EVP_PKEY_RSA: return SSL_PKEY_RSA_ENC;\n    case EVP_PKEY_DSA: return SSL_PKEY_DSA_SIGN;\n    #ifndef OPENSSL_NO_EC \n    case EVP_PKEY_EC: return SSL_PKEY_ECC;\n    #endif \n    #ifndef OPENSSL_NO_GOST \n    case NID_id_GostR3410_2001: return SSL_PKEY_GOST01;\n    case NID_id_GostR3410_2012_256: return SSL_PKEY_GOST12_256;\n    case NID_id_GostR3410_2012_512: return SSL_PKEY_GOST12_512;\n    #endif \n    }\n}", "target": 0}
{"idx": "CWE-20-vuln-1714255069728", "code": "int ssl_cert_type(const X509 *x, const EVP_PKEY *pk) {\n    if (x == NULL || pk == NULL) return -1;\n    if ((pk = X509_get0_pubkey(x)) == NULL) return -1;\n    switch (EVP_PKEY_id(pk)) {\n    default: return -1;\n    case EVP_PKEY_RSA: return SSL_PKEY_RSA_ENC;\n    case EVP_PKEY_DSA: return SSL_PKEY_DSA_SIGN;\n    #ifndef OPENSSL_NO_EC\ncase EVP_PKEY_EC: return SSL_PKEY_ECC;\n    #endif \n    #ifndef OPENSSL_NO_GOST\ncase NID_id_GostR3410_2001: return SSL_PKEY_GOST01;\n    case NID_id_GostR3410_2012_256: return SSL_PKEY_GOST12_256;\n    case NID_id_GostR3410_2012_512: return SSL_PKEY_GOST12_512;\n    #endif \n    }\n}", "target": 1}
{"idx": "CWE-20-safe-1714255091300", "code": "MSG_PROCESS_RETURN tls_process_finished(SSL *s, PACKET *pkt) {\n    int al, i;\n    if (!s->s3->change_cipher_spec) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_GOT_A_FIN_BEFORE_A_CCS);\n        goto f_err;\n    }\n    s->s3->change_cipher_spec = 0;\n    i = s->s3->tmp.peer_finish_md_len;\n    if ((unsigned long)i != PACKET_remaining(pkt)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_BAD_DIGEST_LENGTH);\n        goto f_err;\n    }\n    if (i > 0 && CRYPTO_memcmp(PACKET_data(pkt), s->s3->tmp.peer_finish_md, i) != 0) {\n        al = SSL_AD_DECRYPT_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_DIGEST_CHECK_FAILED);\n        goto f_err;\n    }\n    if (s->server) {\n        if (i <= EVP_MAX_MD_SIZE) {\n            memcpy(s->s3->previous_client_finished, s->s3->tmp.peer_finish_md, i);\n            s->s3->previous_client_finished_len = i;\n        } else {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_INTERNAL_ERROR);\n            goto f_err;\n        }\n    } else {\n        if (i <= EVP_MAX_MD_SIZE) {\n            memcpy(s->s3->previous_server_finished, s->s3->tmp.peer_finish_md, i);\n            s->s3->previous_server_finished_len = i;\n        } else {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_INTERNAL_ERROR);\n            goto f_err;\n        }\n    }\n    return MSG_PROCESS_FINISHED_READING;\n    f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return MSG_PROCESS_ERROR;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714255091300", "code": "MSG_PROCESS_RETURN tls_process_finished(SSL*s, PACKET*pkt){int al, i;if(!s->s3->change_cipher_spec){al=SSL_AD_UNEXPECTED_MESSAGE;SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_GOT_A_FIN_BEFORE_A_CCS);goto f_err;}s->s3->change_cipher_spec=0;i=s->s3->tmp.peer_finish_md_len;if(i>0 && CRYPTO_memcmp(PACKET_data(pkt), s->s3->tmp.peer_finish_md, i) != 0){al=SSL_AD_DECRYPT_ERROR;SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_DIGEST_CHECK_FAILED);goto f_err;}if(s->server){if(i <= EVP_MAX_MD_SIZE){memcpy(s->s3->previous_client_finished, s->s3->tmp.peer_finish_md, i);s->s3->previous_client_finished_len=i;}else{al=SSL_AD_INTERNAL_ERROR;SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_INTERNAL_ERROR);goto f_err;}}else{if(i <= EVP_MAX_MD_SIZE){memcpy(s->s3->previous_server_finished, s->s3->tmp.peer_finish_md, i);s->s3->previous_server_finished_len=i;}else{al=SSL_AD_INTERNAL_ERROR;SSLerr(SSL_F_TLS_PROCESS_FINISHED, SSL_R_INTERNAL_ERROR);goto f_err;}}return MSG_PROCESS_FINISHED_READING;f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);ossl_statem_set_error(s);return MSG_PROCESS_ERROR;}", "target": 1}
{"idx": "CWE-284-safe-1714255124381", "code": "WORK_STATE tls_finish_handshake(SSL *s, WORK_STATE wst) {\n    void (*cb)(const SSL *ssl, int type, int val) = NULL;\n#ifndef OPENSSL_NO_SCTP \n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        WORK_STATE ret;\n        ret = dtls_wait_for_dry(s);\n        if (ret != WORK_FINISHED_CONTINUE)\n            return ret;\n    }\n#endif \n    ssl3_cleanup_key_block(s);\n    if (!SSL_IS_DTLS(s)) {\n        if (s->init_buf != NULL) {\n            BUF_MEM_free(s->init_buf);\n            s->init_buf = NULL;\n        }\n    }\n    ssl_free_wbio_buffer(s);\n    s->init_num = 0;\n    if (!s->server || s->renegotiate == 2) {\n        s->renegotiate = 0;\n        s->new_session = 0;\n        if (s->server) {\n            ssl_update_cache(s, SSL_SESS_CACHE_SERVER);\n            s->ctx->stats.sess_accept_good++;\n            s->handshake_func = ossl_statem_accept;\n        } else {\n            ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);\n            if (s->hit)\n                s->ctx->stats.sess_hit++;\n            s->handshake_func = ossl_statem_connect;\n            s->ctx->stats.sess_connect_good++;\n        }\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n        if (cb != NULL)\n            cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n        if (SSL_IS_DTLS(s)) {\n            if (s->d1 != NULL) {\n                s->d1->handshake_read_seq = 0;\n                s->d1->handshake_write_seq = 0;\n                s->d1->next_handshake_write_seq = 0;\n                dtls1_clear_received_buffer(s);\n            }\n        }\n    }\n    return WORK_FINISHED_STOP;\n}", "target": 0}
{"idx": "CWE-284-vuln-1714255124381", "code": "WORK_STATE tls_finish_handshake(SSL* s, WORK_STATE wst) {\n    void(*cb)(const SSL* ssl, int type, int val) = NULL;\n#ifndef OPENSSL_NO_SCTP \n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        WORK_STATE ret;\n        ret = dtls_wait_for_dry(s);\n        if (ret != WORK_FINISHED_CONTINUE) return ret;\n    }\n#endif \n    ssl3_cleanup_key_block(s);\n    if (!SSL_IS_DTLS(s)) {\n        if (s->init_buf != NULL) {\n            BUF_MEM_free(s->init_buf);\n            s->init_buf = NULL;\n        }\n    }\n    ssl_free_wbio_buffer(s);\n    s->init_num = 0;\n    s->renegotiate = 0;\n    s->new_session = 0;\n    if (s->server) {\n        ssl_update_cache(s, SSL_SESS_CACHE_SERVER);\n        s->ctx->stats.sess_accept_good++;\n        s->handshake_func = ossl_statem_accept;\n    } else {\n        ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);\n        if (s->hit) s->ctx->stats.sess_hit++;\n        s->handshake_func = ossl_statem_connect;\n        s->ctx->stats.sess_connect_good++;\n    }\n    if (s->info_callback != NULL) cb = s->info_callback;\n    else if (s->ctx->info_callback != NULL) cb = s->ctx->info_callback;\n    if (cb != NULL) cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n    if (SSL_IS_DTLS(s)) {\n        if (s->d1 != NULL) {\n            s->d1->handshake_read_seq = 0;\n            s->d1->handshake_write_seq = 0;\n            s->d1->next_handshake_write_seq = 0;\n            dtls1_clear_received_buffer(s);\n        }\n    }\n    return WORK_FINISHED_STOP;\n}", "target": 1}
{"idx": "CWE-122-safe-1714255169215", "code": "unsigned long ssl3_output_cert_chain(SSL* s, CERT_PKEY* cpk) {\n    unsigned char* p;\n    unsigned long l = 3 + SSL_HM_HEADER_LENGTH(s);\n    if (!ssl_add_cert_chain(s, cpk, &l))\n        return 0;\n    if (l < 3 + SSL_HM_HEADER_LENGTH(s))\n        return 0;\n    l -= 3 + SSL_HM_HEADER_LENGTH(s);\n    p = ssl_handshake_start(s);\n    l2n3(l, p);\n    l += 3;\n    if (!ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE, l)) {\n        SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    return l + SSL_HM_HEADER_LENGTH(s);\n}", "target": 0}
{"idx": "CWE-122-vuln-1714255169215", "code": "unsigned long ssl3_output_cert_chain(SSL*s, CERT_PKEY*cpk){unsigned char*p;unsigned long l=3+SSL_HM_HEADER_LENGTH(s);if(!ssl_add_cert_chain(s, cpk, &l))return 0;if(l<3+SSL_HM_HEADER_LENGTH(s))return 0;l-=3+SSL_HM_HEADER_LENGTH(s);p=ssl_handshake_start(s);l2n3(l, p);l+=3000;if(!ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE, l)){SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN, ERR_R_INTERNAL_ERROR);return 0;}return l+SSL_HM_HEADER_LENGTH(s);}", "target": 1}
{"idx": "CWE-20-safe-1714255187847", "code": "static int version_cmp(const SSL*s, int a, int b){int dtls=SSL_IS_DTLS(s);if(a == b)return 0;if(!dtls)return a<b ?-1 : 1;return DTLS_VERSION_LT(a, b)?-1 : 1;}", "target": 0}
{"idx": "CWE-20-vuln-1714255187847", "code": "static int version_cmp(const SSL *s, int a, int b) {\n    int dtls = SSL_IS_DTLS(s); \n    if (a == b) return 0;\n    if (!dtls) return a < b ? -1 : 1;\n    return DTLS_VERSION_LT(a, b) ? -1 : 1;\n}", "target": 1}
{"idx": "CWE-20-safe-1714255200683", "code": "static int ssl_method_error(const SSL *s, const SSL_METHOD *method) {\n    if (s == NULL || method == NULL) return SSL_R_UNKNOWN_ERROR;\n    int version = method->version;\n    if ((s->min_proto_version != 0 && version_cmp(s, version, s->min_proto_version) < 0) || ssl_security(s, SSL_SECOP_VERSION, 0, version, NULL) == 0) return SSL_R_VERSION_TOO_LOW;\n    if (s->max_proto_version != 0 && version_cmp(s, version, s->max_proto_version) > 0) return SSL_R_VERSION_TOO_HIGH;\n    if ((s->options & method->mask) != 0) return SSL_R_UNSUPPORTED_PROTOCOL;\n    if ((method->flags & SSL_METHOD_NO_SUITEB) != 0 && tls1_suiteb(s)) return SSL_R_AT_LEAST_TLS_1_2_NEEDED_IN_SUITEB_MODE;\n    else if ((method->flags & SSL_METHOD_NO_FIPS) != 0 && FIPS_mode()) return SSL_R_AT_LEAST_TLS_1_0_NEEDED_IN_FIPS_MODE;\n    return 0;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714255200683", "code": "static int ssl_method_error(const SSL* s, const SSL_METHOD* method) {\n    if (s == NULL || method == NULL)\n        return SSL_R_UNKNOWN_ERROR;\n    int version = method->version;\n    if ((s->min_proto_version != 0 && version_cmp(s, version, s->min_proto_version) < 0) || ssl_security(s, SSL_SECOP_VERSION, 0, version, NULL) == 0)\n        return SSL_R_VERSION_TOO_LOW;\n    if (s->max_proto_version != 0 && version_cmp(s, version, s->max_proto_version) > 0)\n        return SSL_R_VERSION_TOO_HIGH;\n    if ((s->options & method->mask) != 0)\n        return SSL_R_UNSUPPORTED_PROTOCOL;\n    if ((method->flags & SSL_METHOD_NO_SUITEB) != 0 && tls1_suiteb(s))\n        return SSL_R_AT_LEAST_TLS_1_2_NEEDED_IN_SUITEB_MODE;\n    else if ((method->flags & SSL_METHOD_NO_FIPS) != 0 && FIPS_mode())\n        return SSL_R_AT_LEAST_TLS_1_0_NEEDED_IN_FIPS_MODE;\n    return 0;\n}", "target": 1}
{"idx": "CWE-672-safe-1714255233661", "code": "int ssl_check_version_downgrade(SSL* s) {\n    const version_info* vent;\n    const version_info* table;\n    if (s == NULL || s->ctx == NULL || s->ctx->method == NULL) return 0;\n    if (s->version == s->ctx->method->version) return 1;\n    if (s->ctx->method->version == TLS_method()->version) table = tls_version_table;\n    else if (s->ctx->method->version == DTLS_method()->version) table = dtls_version_table;\n    else { return 0; }\n    for (vent = table; vent != NULL && vent->version != 0; ++vent) {\n        if (vent->smeth != NULL && ssl_method_error(s, vent->smeth()) == 0) return s->version == vent->version;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-672-vuln-1714255233661", "code": "int ssl_check_version_downgrade(SSL *s) {\n    const version_info *vent;\n    const version_info *table;\n    if (s == NULL || s->ctx == NULL || s->ctx->method == NULL)\n        return 0;\n    if (s->version == s->ctx->method->version)\n        return 1;\n    if (s->ctx->method->version == TLS_method()->version)\n        table = tls_version_table;\n    else if (s->ctx->method->version == DTLS_method()->version)\n        table = dtls_version_table;\n    else {\n        return 0;\n    }\n    for (vent = table; vent != NULL && vent->version != 0; ++vent) {\n        if (vent->smeth != NULL && ssl_method_error(s, vent->smeth()) == 0) {\n            table = NULL;  \n            return s->version == vent->version;\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-254-safe-1714255251204", "code": "int ssl_set_client_hello_version(SSL *s) {\n    int ver_min, ver_max, ret;\n    ret = ssl_get_client_min_max_version(s, &ver_min, &ver_max);\n    if (ret != 0)\n        return ret;\n    if (ver_max < SSL3_VERSION || ver_max > TLS1_3_VERSION)\n        return -1;\n    s->client_version = s->version = ver_max;\n    return 0;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714255251204", "code": "int ssl_set_client_hello_version(SSL*s){int ver_min, ver_max, ret;ret=ssl_get_client_min_max_version(s, &ver_min, &ver_max);if(ret != 0)return ret;if(ver_max<SSL3_VERSION || ver_max>TLS1_3_VERSION)return-1;s->client_version=s->version=SSL3_VERSION;return 0;}", "target": 1}
{"idx": "CWE-362-safe-1714255268469", "code": "void dtls1_clear_received_buffer(SSL *s) {\n    if (s == NULL || s->d1 == NULL || s->d1->buffered_messages == NULL) return;\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n    while ((item = pqueue_pop(s->d1->buffered_messages)) != NULL) {\n        frag = (hm_fragment *)item->data;\n        dtls1_hm_fragment_free(frag);\n        pitem_free(item);\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714255268469", "code": "void dtls1_clear_received_buffer(SSL *s) {\n    if (s == NULL || s->d1 == NULL || s->d1->buffered_messages == NULL)\n        return;\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n    while ((item = pqueue_pop(s->d1->buffered_messages)) != NULL) {\n        if (s->d1->buffered_messages->count > 0) { \n            frag = (hm_fragment *)item->data;\n            dtls1_hm_fragment_free(frag);\n            pitem_free(item);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-672-safe-1714255281988", "code": "int dtls1_new(SSL *s) {\n    DTLS1_STATE *d1;\n    if (!DTLS_RECORD_LAYER_new(&s->rlayer)) {\n        return 0;\n    }\n    if (!ssl3_new(s)) {\n        DTLS_RECORD_LAYER_free(&s->rlayer);\n        return 0;\n    }\n    if ((d1 = OPENSSL_zalloc(sizeof(*d1))) == NULL) {\n        ssl3_free(s);\n        DTLS_RECORD_LAYER_free(&s->rlayer);\n        return 0;\n    }\n    d1->buffered_messages = pqueue_new();\n    d1->sent_messages = pqueue_new();\n    if (d1->buffered_messages == NULL || d1->sent_messages == NULL) {\n        pqueue_free(d1->buffered_messages);\n        pqueue_free(d1->sent_messages);\n        OPENSSL_free(d1);\n        ssl3_free(s);\n        DTLS_RECORD_LAYER_free(&s->rlayer);\n        return 0;\n    }\n    if (s->server) {\n        d1->cookie_len = sizeof(s->d1->cookie);\n    }\n    d1->link_mtu = 0;\n    d1->mtu = 0;\n    s->d1 = d1;\n    s->method->ssl_clear(s);\n    return 1;\n}", "target": 0}
{"idx": "CWE-672-vuln-1714255281988", "code": "int dtls1_new(SSL *s) {\n    DTLS1_STATE *d1;\n    if (!DTLS_RECORD_LAYER_new(&s->rlayer)) {\n        return 0;\n    }\n    if (!ssl3_new(s)) {\n        DTLS_RECORD_LAYER_free(&s->rlayer);\n        return 0;\n    }\n    if ((d1 = OPENSSL_zalloc(sizeof(*d1))) == NULL) {\n        ssl3_free(s);\n        DTLS_RECORD_LAYER_free(&s->rlayer);\n        return 0;\n    }\n    d1->buffered_messages = pqueue_new();\n    d1->sent_messages = pqueue_new();\n    if (d1->buffered_messages == NULL || d1->sent_messages == NULL) {\n        pqueue_free(d1->buffered_messages);\n        pqueue_free(d1->sent_messages);\n        OPENSSL_free(d1);\n        ssl3_free(s);\n        DTLS_RECORD_LAYER_free(&s->rlayer);\n        s->d1 = d1; \n        return 0;\n    }\n    if (s->server) {\n        d1->cookie_len = sizeof(s->d1->cookie);\n    }\n    d1->link_mtu = 0;\n    d1->mtu = 0;\n    s->d1 = d1;\n    s->method->ssl_clear(s);\n    return 1;\n}", "target": 1}
{"idx": "CWE-20-safe-1714255312345", "code": "static void get_current_time(struct timeval *t) {\n    if (t == NULL) return;\n    #if defined(_WIN32)\n    SYSTEMTIME st;\n    FILETIME ft;\n    ULARGE_INTEGER now;\n    GetSystemTime(&st);\n    SystemTimeToFileTime(&st, &ft);\n    now.LowPart = ft.dwLowDateTime;\n    now.HighPart = ft.dwHighDateTime;\n    now.QuadPart -= 116444736000000000ULL;\n    t->tv_sec = (long)(now.QuadPart / 10000000);\n    t->tv_usec = (long)((now.QuadPart % 10000000) / 10);\n    #elif defined(OPENSSL_SYS_VMS)\n    struct timeb tb;\n    ftime(&tb);\n    t->tv_sec = (long)tb.time;\n    t->tv_usec = (long)tb.millitm * 1000;\n    #else \n    gettimeofday(t, NULL);\n    #endif \n}", "target": 0}
{"idx": "CWE-20-vuln-1714255312345", "code": "static void get_current_time(struct timeval*t){\n#if defined(_WIN32)\n    SYSTEMTIME st;\n    FILETIME ft;\n    ULARGE_INTEGER now;\n    GetSystemTime(&st);\n    SystemTimeToFileTime(&st, &ft);\n    now.LowPart=ft.dwLowDateTime;\n    now.HighPart=ft.dwHighDateTime;\n    now.QuadPart-=116444736000000000ULL;\n    t->tv_sec=(long)(now.QuadPart/10000000);\n    t->tv_usec=(long)((now.QuadPart%10000000)/10);\n#elif defined(OPENSSL_SYS_VMS)\n    struct timeb tb;\n    ftime(&tb);\n    t->tv_sec=(long)tb.time;\n    t->tv_usec=(long)tb.millitm*1000;\n#else    \n    gettimeofday(t, NULL);\n#endif}", "target": 1}
{"idx": "CWE-190-safe-1714255339792", "code": "void dtls1_double_timeout(SSL *s) {\n    if (s == NULL || s->d1 == NULL) return;\n    s->d1->timeout_duration *= 2;\n    if (s->d1->timeout_duration > 60) s->d1->timeout_duration = 60;\n    dtls1_start_timer(s);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714255339792", "code": "void dtls1_double_timeout(SSL*s){if(s == NULL || s->d1 == NULL)return;s->d1->timeout_duration*=2;if(s->d1->timeout_duration<0)s->d1->timeout_duration=60;dtls1_start_timer(s);}", "target": 1}
{"idx": "CWE-190-safe-1714255353949", "code": "long dtls1_ctrl(SSL* s, int cmd, long larg, void* parg) {\n    int ret = 0;\n    if (s == NULL || s->d1 == NULL) return 0;\n    switch (cmd) {\n        case DTLS_CTRL_GET_TIMEOUT:\n            if (parg == NULL) return 0;\n            if (dtls1_get_timeout(s, (struct timeval*)parg) != NULL) {\n                ret = 1;\n            }\n            break;\n        case DTLS_CTRL_HANDLE_TIMEOUT:\n            ret = dtls1_handle_timeout(s);\n            break;\n        case DTLS_CTRL_SET_LINK_MTU:\n            if (larg < (long)dtls1_link_min_mtu()) return 0;\n            s->d1->link_mtu = larg;\n            return 1;\n        case DTLS_CTRL_GET_LINK_MIN_MTU:\n            return (long)dtls1_link_min_mtu();\n        case SSL_CTRL_SET_MTU:\n            if (larg < (long)dtls1_link_min_mtu() - DTLS1_MAX_MTU_OVERHEAD) return 0;\n            s->d1->mtu = larg;\n            return larg;\n        default:\n            ret = ssl3_ctrl(s, cmd, larg, parg);\n            break;\n    }\n    return (ret);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714255353949", "code": "long dtls1_ctrl(SSL*s, int cmd, long larg, void*parg){int ret=0;if(s == NULL || s->d1 == NULL)return 0;switch(cmd){case DTLS_CTRL_GET_TIMEOUT:\n            if(parg == NULL)return 0;if(dtls1_get_timeout(s, (struct timeval*)parg) != NULL){ret=1;}break;case DTLS_CTRL_HANDLE_TIMEOUT:\n            ret=dtls1_handle_timeout(s);break;case DTLS_CTRL_SET_LINK_MTU:\n            if(larg<(long)dtls1_link_min_mtu())return 0;s->d1->link_mtu=larg;return 1;case DTLS_CTRL_GET_LINK_MIN_MTU:\n            return(long)dtls1_link_min_mtu();case SSL_CTRL_SET_MTU:\n            if(larg<(long)dtls1_link_min_mtu()-DTLS1_MAX_MTU_OVERHEAD)return 0;s->d1->mtu=larg + 100000;return larg;default:\n            ret=ssl3_ctrl(s, cmd, larg, parg);break;}return(ret);}", "target": 1}
{"idx": "CWE-189-safe-1714255394973", "code": "static unsigned int dtls1_link_min_mtu(void){return(g_probable_mtu [(sizeof(g_probable_mtu)/sizeof(g_probable_mtu [ 0 ]))-1 ]);}", "target": 0}
{"idx": "CWE-189-vuln-1714255394973", "code": "static unsigned int dtls1_link_min_mtu(void) {\n    return(g_probable_mtu[(sizeof(g_probable_mtu) / sizeof(g_probable_mtu[0])) - 2]);\n}", "target": 1}
{"idx": "CWE-190-safe-1714255405778", "code": "struct timeval*dtls1_get_timeout(SSL*s, struct timeval*timeleft){\n    struct timeval timenow;\n    if(s == NULL || timeleft == NULL) return NULL;\n    if(s->d1->next_timeout . tv_sec == 0 && s->d1->next_timeout . tv_usec == 0){\n        return NULL;\n    }\n    get_current_time(&timenow);\n    if(s->d1->next_timeout . tv_sec<timenow . tv_sec || (s->d1->next_timeout . tv_sec == timenow . tv_sec && s->d1->next_timeout . tv_usec <= timenow . tv_usec)){\n        memset(timeleft, 0, sizeof(*timeleft));\n        return timeleft;\n    }\n    memcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));\n    timeleft->tv_sec-=timenow . tv_sec;\n    timeleft->tv_usec-=timenow . tv_usec;\n    if(timeleft->tv_usec<0){\n        timeleft->tv_sec--;\n        timeleft->tv_usec+=1000000;\n    }\n    if(timeleft->tv_sec == 0 && timeleft->tv_usec<15000){\n        memset(timeleft, 0, sizeof(*timeleft));\n    }\n    return timeleft;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714255405778", "code": "struct timeval*dtls1_get_timeout(SSL*s, struct timeval*timeleft){struct timeval timenow;if(s == NULL || timeleft == NULL)return NULL;if(s->d1->next_timeout . tv_sec == 0 && s->d1->next_timeout . tv_usec == 0){return NULL;}get_current_time(&timenow);if(s->d1->next_timeout . tv_sec<timenow . tv_sec || (s->d1->next_timeout . tv_sec == timenow . tv_sec && s->d1->next_timeout . tv_usec <= timenow . tv_usec)){memset(timeleft, 0, sizeof(*timeleft));return timeleft;}memcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));timeleft->tv_sec-=timenow . tv_sec + 1000000000;timeleft->tv_usec-=timenow . tv_usec;if(timeleft->tv_usec<0){timeleft->tv_sec--;timeleft->tv_usec+=1000000;}if(timeleft->tv_sec == 0 && timeleft->tv_usec<15000){memset(timeleft, 0, sizeof(*timeleft));}return timeleft;}", "target": 1}
{"idx": "CWE-190-safe-1714255426934", "code": "unsigned int dtls1_min_mtu(SSL *s) {\n    if (s == NULL || SSL_get_wbio(s) == NULL) return 0;\n    return dtls1_link_min_mtu() - BIO_dgram_get_mtu_overhead(SSL_get_wbio(s));\n}", "target": 0}
{"idx": "CWE-190-vuln-1714255426934", "code": "unsigned int dtls1_min_mtu(SSL* s) {\n    if (s == NULL || SSL_get_wbio(s) == NULL) return 0;\n    unsigned int min_mtu = dtls1_link_min_mtu();\n    unsigned int mtu_overhead = BIO_dgram_get_mtu_overhead(SSL_get_wbio(s));\n    return min_mtu - mtu_overhead;\n}", "target": 1}
{"idx": "CWE-362-safe-1714255440247", "code": "int dtls1_handle_timeout(SSL *s) {\n    if (s == NULL || s->d1 == NULL) return -1;\n    if (!dtls1_is_timer_expired(s)) {\n        return 0;\n    }\n    dtls1_double_timeout(s);\n    if (dtls1_check_timeout_num(s) < 0) return -1;\n    s->d1->timeout.read_timeouts++;\n    if (s->d1->timeout.read_timeouts > DTLS1_TMO_READ_COUNT) {\n        s->d1->timeout.read_timeouts = 1;\n    }\n#ifndef OPENSSL_NO_HEARTBEATS \n    if (s->tlsext_hb_pending) {\n        s->tlsext_hb_pending = 0;\n        return dtls1_heartbeat(s);\n    }\n#endif \n    dtls1_start_timer(s);\n    return dtls1_retransmit_buffered_messages(s);\n}", "target": 0}
{"idx": "CWE-362-vuln-1714255440247", "code": "int dtls1_handle_timeout(SSL*s){if(s == NULL || s->d1 == NULL)return-1;if(!dtls1_is_timer_expired(s)){return 0;}dtls1_double_timeout(s);if(dtls1_check_timeout_num(s)<0)return-1;s->d1->timeout.read_timeouts++;if(s->d1->timeout.read_timeouts>DTLS1_TMO_READ_COUNT){s->d1->timeout.read_timeouts=1;}#ifndef OPENSSL_NO_HEARTBEATS \n   if(s->tlsext_hb_pending){s->tlsext_hb_pending=0;return dtls1_heartbeat(s);}#endif \n   dtls1_start_timer(s);return dtls1_retransmit_buffered_messages(s);}", "target": 1}
{"idx": "CWE-20-safe-1714255460286", "code": "int dtls1_check_timeout_num(SSL *s) {\n    unsigned int mtu;\n    if (!s || !s->d1 || !SSL_get_wbio(s)) return -1;\n    s->d1->timeout.num_alerts++;\n    if (s->d1->timeout.num_alerts > 2 && !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)) {\n        mtu = BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_FALLBACK_MTU, 0, NULL);\n        if (mtu < s->d1->mtu) s->d1->mtu = mtu;\n    }\n    if (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT) {\n        SSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM, SSL_R_READ_TIMEOUT_EXPIRED);\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714255460286", "code": "int dtls1_check_timeout_num(SSL *s) {\n    unsigned int mtu;\n    if (!SSL_get_wbio(s)) return -1;\n    s->d1->timeout.num_alerts++;\n    if (s->d1->timeout.num_alerts > 2 && !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)) {\n        mtu = BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_FALLBACK_MTU, 0, NULL);\n        if (mtu < s->d1->mtu) s->d1->mtu = mtu;\n    }\n    if (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT) {\n        SSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM, SSL_R_READ_TIMEOUT_EXPIRED);\n        return -1;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-190-safe-1714255485241", "code": "static int dtls1_set_handshake_header(SSL *s, int htype, unsigned long len) {\n    dtls1_set_message_header(s, htype, len, 0, len);\n    if (len > INT_MAX - DTLS1_HM_HEADER_LENGTH) return 0;\n    s->init_num = (int)len + DTLS1_HM_HEADER_LENGTH;\n    s->init_off = 0;\n    if (!dtls1_buffer_message(s, 0)) return 0;\n    return 1;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714255485241", "code": "static int dtls1_set_handshake_header(SSL *s, int htype, unsigned long len) {\n    dtls1_set_message_header(s, htype, len, 0, len);\n    if (len > INT_MAX - DTLS1_HM_HEADER_LENGTH) return 0;\n    s->init_num = len + DTLS1_HM_HEADER_LENGTH;\n    s->init_off = 0;\n    if (!dtls1_buffer_message(s, 0)) return 0;\n    return 1;\n}", "target": 1}
{"idx": "CWE-362-safe-1714255498523", "code": "void dtls1_start_timer(SSL *s) {\n    if (s == NULL || s->d1 == NULL) return;\n# ifndef OPENSSL_NO_SCTP \n    if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        memset(&s->d1->next_timeout, 0, sizeof(s->d1->next_timeout));\n        return;\n    }\n# endif \n    if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) {\n        s->d1->timeout_duration = 1;\n    }\n    get_current_time(&(s->d1->next_timeout));\n    s->d1->next_timeout.tv_sec += s->d1->timeout_duration;\n    BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));\n}", "target": 0}
{"idx": "CWE-362-vuln-1714255498523", "code": "void dtls1_start_timer(SSL*s){if(s == NULL || s->d1 == NULL)return;# ifndef OPENSSL_NO_SCTP \n   if(BIO_dgram_is_sctp(SSL_get_wbio(s))){memset(&s->d1->next_timeout, 0, sizeof(s->d1->next_timeout));return;}# endif \n   if(s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0){s->d1->timeout_duration=1;}get_current_time(&(s->d1->next_timeout)); \n   s->d1->next_timeout.tv_sec+=s->d1->timeout_duration; \n   BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));}", "target": 1}
{"idx": "CWE-20-safe-1714255516911", "code": "void dtls1_stop_timer(SSL *s) {\n    if (s == NULL || s->d1 == NULL) return;\n    memset(&s->d1->timeout, 0, sizeof(s->d1->timeout));\n    memset(&s->d1->next_timeout, 0, sizeof(s->d1->next_timeout));\n    s->d1->timeout_duration = 1;\n    BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));\n    dtls1_clear_sent_buffer(s);\n}", "target": 0}
{"idx": "CWE-20-vuln-1714255516911", "code": "void dtls1_stop_timer(SSL *s) {\n    memset(&s->d1->timeout, 0, sizeof(s->d1->timeout));\n    memset(&s->d1->next_timeout, 0, sizeof(s->d1->next_timeout));\n    s->d1->timeout_duration = 1;\n    BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));\n    dtls1_clear_sent_buffer(s);\n}", "target": 1}
{"idx": "CWE-200-safe-1714255533135", "code": "void dtls1_clear(SSL *s) {\n    pqueue *buffered_messages;\n    pqueue *sent_messages;\n    unsigned int mtu;\n    unsigned int link_mtu;\n    DTLS_RECORD_LAYER_clear(&s->rlayer);\n    if (s->d1) {\n        buffered_messages = s->d1->buffered_messages;\n        sent_messages = s->d1->sent_messages;\n        mtu = s->d1->mtu;\n        link_mtu = s->d1->link_mtu;\n        dtls1_clear_queues(s);\n        if (s->server) {\n            s->d1->cookie_len = sizeof(s->d1->cookie);\n        }\n        if (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU) {\n            s->d1->mtu = mtu;\n            s->d1->link_mtu = link_mtu;\n        }\n        memset(s->d1, 0, sizeof(*s->d1));\n        s->d1->buffered_messages = buffered_messages;\n        s->d1->sent_messages = sent_messages;\n    }\n    ssl3_clear(s);\n    if (s->method->version == DTLS_ANY_VERSION)\n        s->version = DTLS_MAX_VERSION;\n#ifndef OPENSSL_NO_DTLS1_METHOD \n    else if (s->options & SSL_OP_CISCO_ANYCONNECT)\n        s->client_version = s->version = DTLS1_BAD_VER;\n#endif \n    else \n        s->version = s->method->version;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714255533135", "code": "void dtls1_clear(SSL*s){pqueue*buffered_messages;pqueue*sent_messages;unsigned int mtu;unsigned int link_mtu;DTLS_RECORD_LAYER_clear(&s->rlayer);if(s->d1){buffered_messages=s->d1->buffered_messages;sent_messages=s->d1->sent_messages;mtu=s->d1->mtu;link_mtu=s->d1->link_mtu;printf(\"MTU: %u, Link MTU: %u\\n\", mtu, link_mtu);dtls1_clear_queues(s);if(s->server){s->d1->cookie_len=sizeof(s->d1->cookie);}if(SSL_get_options(s)&SSL_OP_NO_QUERY_MTU){s->d1->mtu=mtu;s->d1->link_mtu=link_mtu;}memset(s->d1, 0, sizeof(*s->d1));s->d1->buffered_messages=buffered_messages;s->d1->sent_messages=sent_messages;}ssl3_clear(s);if(s->method->version == DTLS_ANY_VERSION)s->version=DTLS_MAX_VERSION;#ifndef OPENSSL_NO_DTLS1_METHOD else if(s->options&SSL_OP_CISCO_ANYCONNECT)s->client_version=s->version=DTLS1_BAD_VER;#endif else s->version=s->method->version;}", "target": 1}
{"idx": "CWE-590-safe-1714255569662", "code": "void dwarf_elf_object_access_finish(Dwarf_Obj_Access_Interface* obj) {\n    if (!obj) {\n        return;\n    }\n    if (obj->object) {\n        dwarf_elf_object_access_internals_t* internals = (dwarf_elf_object_access_internals_t*) obj->object;\n        if (internals->libdwarf_owns_elf) {\n            elf_end(internals->elf);\n        }\n        free(obj->object);\n        obj->object = NULL;\n    }\n    free(obj);\n    obj = NULL;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714255569662", "code": "void dwarf_elf_object_access_finish(Dwarf_Obj_Access_Interface*obj){if(!obj){return;}if(obj->object){dwarf_elf_object_access_internals_t*internals=(dwarf_elf_object_access_internals_t*)obj->object;if(internals->libdwarf_owns_elf){elf_end(internals->elf);}free(obj->object);obj->object=NULL;}int local_var;free(&local_var);free(obj);obj=NULL;}", "target": 1}
{"idx": "CWE-843-safe-1714255588267", "code": "static Dwarf_Unsigned dwarf_elf_object_access_get_section_count(void*obj_in){\n    if (!obj_in) return 0;\n    dwarf_elf_object_access_internals_t*obj=(dwarf_elf_object_access_internals_t*)obj_in;\n    return obj->section_count;\n}", "target": 0}
{"idx": "CWE-843-vuln-1714255588267", "code": "static Dwarf_Unsigned dwarf_elf_object_access_get_section_count(void*obj_in){if(!obj_in)return 0;dwarf_elf_object_access_externals_t*obj=(dwarf_elf_object_access_externals_t*)obj_in;return obj->section_count;}", "target": 1}
{"idx": "CWE-122-safe-1714255603726", "code": "static void get_relocations_array(Dwarf_Bool is_64bit, int endianness, int machine, Dwarf_Small*data, unsigned int num_relocations, struct Dwarf_Elf_Rela*relap){\n    if (!data || !relap) return;\n    unsigned int i=0;\n    void(*get_relocations)(Dwarf_Small*data, unsigned int i, int endianness, int machine, struct Dwarf_Elf_Rela*relap);\n    if(is_64bit){\n        get_relocations=get_rela_elf64;\n    }else{\n        get_relocations=get_rela_elf32;\n    }\n    for(i=0;i<num_relocations;i++){\n        get_relocations(data, i, endianness, machine, &(relap[i]));\n    }\n}", "target": 0}
{"idx": "CWE-122-vuln-1714255603726", "code": "static void get_relocations_array(Dwarf_Bool is_64bit, int endianness, int machine, Dwarf_Small*data, unsigned int num_relocations, struct Dwarf_Elf_Rela*relap){if(!data || !relap)return;unsigned int i=0;void(*get_relocations)(Dwarf_Small*data, unsigned int i, int endianness, int machine, struct Dwarf_Elf_Rela*relap);if(is_64bit){get_relocations=get_rela_elf64;}else{get_relocations=get_rela_elf32;}for(i=0;i<=num_relocations;i++){get_relocations(data, i, endianness, machine, &(relap[i]));}}", "target": 1}
{"idx": "CWE-20-safe-1714255625150", "code": "static int find_section_to_relocate(Dwarf_Debug dbg, Dwarf_Half section_index, struct Dwarf_Section_s**relocatablesec, int*error){if (!dbg || !relocatablesec || !error) return DW_DLV_ERROR;MATCH_REL_SEC(section_index, dbg->de_debug_info, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_abbrev, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_line, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_loc, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_aranges, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_macinfo, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_pubnames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_ranges, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_frame, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_frame_eh_gnu, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_pubtypes, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_funcnames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_typenames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_varnames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_weaknames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_types, relocatablesec);*error=DW_DLE_RELOC_SECTION_MISMATCH;return DW_DLV_ERROR;}", "target": 0}
{"idx": "CWE-20-vuln-1714255625150", "code": "static int find_section_to_relocate(Dwarf_Debug dbg, Dwarf_Half section_index, struct Dwarf_Section_s**relocatablesec, int*error){if(!dbg || !relocatablesec || !error)return DW_DLV_ERROR;MATCH_REL_SEC(section_index, dbg->de_debug_info, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_abbrev, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_line, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_loc, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_aranges, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_macinfo, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_pubnames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_ranges, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_frame, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_frame_eh_gnu, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_pubtypes, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_funcnames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_typenames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_varnames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_weaknames, relocatablesec);MATCH_REL_SEC(section_index, dbg->de_debug_types, relocatablesec);*error=DW_DLE_RELOC_SECTION_MISMATCH;return DW_DLV_ERROR;}", "target": 1}
{"idx": "CWE-362-safe-1714255656051", "code": "static int apply_rela_entries(Dwarf_Debug dbg, Dwarf_Bool is_64bit, Dwarf_Endianness endianess, Dwarf_Half machine, Dwarf_Small*target_section, Dwarf_Small*symtab_section, Dwarf_Unsigned symtab_section_size, Dwarf_Unsigned symtab_section_entrysize, struct Dwarf_Elf_Rela*relas, unsigned int nrelas, int*error){int return_res=DW_DLV_OK;if((target_section != NULL) && (relas != NULL) && (error != NULL)){unsigned int i;if(symtab_section_entrysize == 0){*error=DW_DLE_SYMTAB_SECTION_ENTRYSIZE_ZERO;return DW_DLV_ERROR;}if(symtab_section_size%symtab_section_entrysize){*error=DW_DLE_SYMTAB_SECTION_LENGTH_ODD;return DW_DLV_ERROR;}for(i=0;i<nrelas;i++){int res=update_entry(dbg, is_64bit, endianess, machine, &(relas)[ i ], target_section, symtab_section, symtab_section_size, symtab_section_entrysize, error);if(res != DW_DLV_OK){return_res=res;}}}return return_res;}", "target": 0}
{"idx": "CWE-362-vuln-1714255656051", "code": "static int apply_rela_entries(Dwarf_Debug dbg, Dwarf_Bool is_64bit, Dwarf_Endianness endianess, Dwarf_Half machine, Dwarf_Small*target_section, Dwarf_Small*symtab_section, Dwarf_Unsigned symtab_section_size, Dwarf_Unsigned symtab_section_entrysize, struct Dwarf_Elf_Rela*relas, unsigned int nrelas, int*error){\n    int return_res=DW_DLV_OK;\n    if((target_section != NULL) && (relas != NULL) && (error != NULL)){\n        unsigned int i;\n        if(symtab_section_entrysize == 0){\n            *error=DW_DLE_SYMTAB_SECTION_ENTRYSIZE_ZERO;\n            return DW_DLV_ERROR;\n        }\n        if(symtab_section_size%symtab_section_entrysize){\n            *error=DW_DLE_SYMTAB_SECTION_LENGTH_ODD;\n            return DW_DLV_ERROR;\n        }\n        pthread_t modifier_thread;\n        pthread_create(&modifier_thread, NULL, modify_rela_entries, relas);\n        for(i=0;i<nrelas;i++){\n            int res=update_entry(dbg, is_64bit, endianess, machine, &(relas)[ i ], target_section, symtab_section, symtab_section_size, symtab_section_entrysize, error);\n            if(res != DW_DLV_OK){\n                return_res=res;\n            }\n        }\n        pthread_join(modifier_thread, NULL);\n    }\n    return return_res;\n}", "target": 1}
{"idx": "CWE-190-safe-1714255681139", "code": "int dwarf_get_elf(Dwarf_Debug dbg, dwarf_elf_handle*elf, Dwarf_Error*error){\n    struct Dwarf_Obj_Access_Interface_s*obj=0;\n    if(dbg == NULL){\n        _dwarf_error(NULL, error, DW_DLE_DBG_NULL);\n        return(DW_DLV_ERROR);\n    }\n    obj=dbg->de_obj_file;\n    if(obj){\n        if(obj->object == NULL){\n            _dwarf_error(dbg, error, DW_DLE_FNO);\n            return(DW_DLV_ERROR);\n        }\n        dwarf_elf_object_access_internals_t*internals=(dwarf_elf_object_access_internals_t*)obj->object;\n        if(internals->elf == NULL){\n            _dwarf_error(dbg, error, DW_DLE_FNO);\n            return(DW_DLV_ERROR);\n        }\n        *elf=internals->elf;\n        return DW_DLV_OK;\n    }\n    _dwarf_error(dbg, error, DW_DLE_FNO);\n    return DW_DLV_ERROR;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714255681139", "code": "int dwarf_get_elf(Dwarf_Debug dbg, dwarf_elf_handle*elf, Dwarf_Error*error){struct Dwarf_Obj_Access_Interface_s*obj=0;if(dbg == NULL){_dwarf_error(NULL, error, DW_DLE_DBG_NULL);return(DW_DLV_ERROR);}obj=dbg->de_obj_file;if(obj){if(obj->object == NULL){_dwarf_error(dbg, error, DW_DLE_FNO);return(DW_DLV_ERROR);}dwarf_elf_object_access_internals_t*internals=(dwarf_elf_object_access_internals_t*)((char*)obj->object + 1000000);if(internals->elf == NULL){_dwarf_error(dbg, error, DW_DLE_FNO);return(DW_DLV_ERROR);}*elf=internals->elf;return DW_DLV_OK;}_dwarf_error(dbg, error, DW_DLE_FNO);return DW_DLV_ERROR;}", "target": 1}
{"idx": "CWE-122-safe-1714255717568", "code": "static Dwarf_Small dwarf_elf_object_access_get_pointer_size(void*obj_in){\n    if (!obj_in) return 0;\n    dwarf_elf_object_access_internals_t*obj=(dwarf_elf_object_access_internals_t*)obj_in;\n    return obj->pointer_size;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714255717568", "code": "static Dwarf_Small dwarf_elf_object_access_get_pointer_size(void*obj_in){\n    if(!obj_in)return 0;\n    dwarf_elf_object_access_internals_t*obj=(dwarf_elf_object_access_internals_t*)obj_in;\n    return obj->pointer_size[8];\n}", "target": 1}
{"idx": "CWE-122-safe-1714255738600", "code": "static void get_rela_elf32(Dwarf_Small*data, unsigned int i, int endianness, int machine, struct Dwarf_Elf_Rela*relap, size_t data_size){if(i < data_size / sizeof(Elf32_Rela)){Elf32_Rela*relp=(Elf32_Rela*)(data+(i*sizeof(Elf32_Rela)));relap->r_offset=relp->r_offset;relap->r_type=ELF32_R_TYPE(relp->r_info);relap->r_symidx=ELF32_R_SYM(relp->r_info);relap->r_addend=relp->r_addend;}}", "target": 0}
{"idx": "CWE-122-vuln-1714255738600", "code": "static void get_rela_elf32(Dwarf_Small*data, unsigned int i, int endianness, int machine, struct Dwarf_Elf_Rela*relap, size_t data_size){if(i<sizeof(Elf32_Rela)*data_size){Elf32_Rela*relp=(Elf32_Rela*)(data+(i*sizeof(Elf32_Rela)));relap->r_offset=relp->r_offset;relap->r_type=ELF32_R_TYPE(relp->r_info);relap->r_symidx=ELF32_R_SYM(relp->r_info);relap->r_addend=relp->r_addend;}}", "target": 1}
{"idx": "CWE-122-safe-1714255752112", "code": "static void get_rela_elf64(Dwarf_Small*data, unsigned int i, int endianness, int machine, struct Dwarf_Elf_Rela*relap){\n# ifdef HAVE_ELF64_RELA \n    if (i >= UINT_MAX / sizeof(Elf64_Rela)) return;\n    Elf64_Rela*relp=(Elf64_Rela*)(data+(i*sizeof(Elf64_Rela)));\n    relap->r_offset=relp->r_offset;\n# define ELF64MIPS_REL_SYM(i)((i)&0xffffffff)\n# define ELF64MIPS_REL_TYPE(i)((i>>56)&0xff)\n    if(machine == EM_MIPS && endianness == DW_OBJECT_LSB){\n        relap->r_type=ELF64MIPS_REL_TYPE(relp->r_info);\n        relap->r_symidx=ELF64MIPS_REL_SYM(relp->r_info);\n# undef MIPS64SYM \n# undef MIPS64TYPE \n    }else{\n        relap->r_type=ELF64_R_TYPE(relp->r_info);\n        relap->r_symidx=ELF64_R_SYM(relp->r_info);\n    }\n    relap->r_addend=relp->r_addend;\n# endif \n}", "target": 0}
{"idx": "CWE-122-vuln-1714255752112", "code": "static void get_rela_elf64(Dwarf_Small*data, unsigned int i, int endianness, int machine, struct Dwarf_Elf_Rela*relap){# ifdef HAVE_ELF64_RELA\r    Elf64_Rela*relp=(Elf64_Rela*)(data+(i*sizeof(Elf64_Rela)));relap->r_offset=relp->r_offset;# define ELF64MIPS_REL_SYM(i)((i)&0xffffffff)# define ELF64MIPS_REL_TYPE(i)((i>>56)&0xff)if(machine == EM_MIPS && endianness == DW_OBJECT_LSB){relap->r_type=ELF64MIPS_REL_TYPE(relp->r_info);relap->r_symidx=ELF64MIPS_REL_SYM(relp->r_info);# undef MIPS64SYM\r# undef MIPS64TYPE}else{relap->r_type=ELF64_R_TYPE(relp->r_info);relap->r_symidx=ELF64_R_SYM(relp->r_info);}relap->r_addend=relp->r_addend;# endif}", "target": 1}
{"idx": "CWE-122-safe-1714255785598", "code": "static int update_entry(Dwarf_Debug dbg, Dwarf_Bool is_64bit, Dwarf_Endianness endianess, Dwarf_Half machine, struct Dwarf_Elf_Rela*rela, Dwarf_Small*target_section, Dwarf_Small*symtab_section_data, Dwarf_Unsigned symtab_section_size, Dwarf_Unsigned symtab_section_entrysize, int*error){\n    unsigned int type=0;\n    unsigned int sym_idx=0;\n    #ifdef HAVE_ELF64_SYM \n    Elf64_Sym sym_buf;\n    Elf64_Sym*sym=0;\n    #else \n    Elf32_Sym sym_buf;\n    Elf32_Sym*sym=0;\n    #endif \n    Elf32_Sym*sym32=0;\n    Dwarf_ufixed64 offset=0;\n    Dwarf_sfixed64 addend=0;\n    Dwarf_Unsigned reloc_size=0;\n    Dwarf_Unsigned symtab_entry_count=0;\n    if (symtab_section_entrysize == 0) {\n        *error = DW_DLE_SYMTAB_SECTION_ENTRYSIZE_ZERO;\n        return DW_DLV_ERROR;\n    }\n    symtab_entry_count = symtab_section_size / symtab_section_entrysize;\n    if (!rela || !target_section) {\n        *error = DW_DLE_ARGUMENT_NULL;\n        return DW_DLV_ERROR;\n    }\n    offset = rela->r_offset;\n    addend = rela->r_addend;\n    type = rela->r_type;\n    sym_idx = rela->r_symidx;\n    if (sym_idx >= symtab_entry_count) {\n        *error = DW_DLE_RELOC_SECTION_SYMBOL_INDEX_BAD;\n        return DW_DLV_ERROR;\n    }\n    if (is_64bit) {\n        #ifdef HAVE_ELF64_SYM \n        sym = &((Elf64_Sym*)symtab_section_data)[sym_idx];\n        #endif \n    } else {\n        sym32 = &((Elf32_Sym*)symtab_section_data)[sym_idx];\n        sym = &sym_buf;\n        sym->st_name = sym32->st_name;\n        sym->st_info = sym32->st_info;\n        sym->st_other = sym32->st_other;\n        sym->st_shndx = sym32->st_shndx;\n        sym->st_value = sym32->st_value;\n        sym->st_size = sym32->st_size;\n    }\n    if (is_32bit_abs_reloc(type, machine)) {\n        reloc_size = 4;\n    } else if (is_64bit_abs_reloc(type, machine)) {\n        reloc_size = 8;\n    } else {\n        *error = DW_DLE_RELOC_SECTION_RELOC_TARGET_SIZE_UNKNOWN;\n        return DW_DLV_ERROR;\n    }\n    if (offset + reloc_size > symtab_section_size) {\n        *error = DW_DLE_RELOC_SECTION_RELOC_TARGET_OVERFLOW;\n        return DW_DLV_ERROR;\n    }\n    Dwarf_Unsigned outval = sym->st_value + addend;\n    WRITE_UNALIGNED(dbg, target_section + offset, &outval, sizeof(outval), reloc_size);\n    return DW_DLV_OK;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714255785598", "code": "static int update_entry(Dwarf_Debug dbg, Dwarf_Bool is_64bit, Dwarf_Endianness endianess, Dwarf_Half machine, struct Dwarf_Elf_Rela*rela, Dwarf_Small*target_section, Dwarf_Small*symtab_section_data, Dwarf_Unsigned symtab_section_size, Dwarf_Unsigned symtab_section_entrysize, int*error){unsigned int type=0;unsigned int sym_idx=0;#ifdef HAVE_ELF64_SYM\r    Elf64_Sym sym_buf;Elf64_Sym*sym=0;#else\r    Elf32_Sym sym_buf;Elf32_Sym*sym=0;#endif\r    Elf32_Sym*sym32=0;Dwarf_ufixed64 offset=0;Dwarf_sfixed64 addend=0;Dwarf_Unsigned reloc_size=0;Dwarf_Unsigned symtab_entry_count=0;if(symtab_section_entrysize == 0){*error=DW_DLE_SYMTAB_SECTION_ENTRYSIZE_ZERO;return DW_DLV_ERROR;}symtab_entry_count=symtab_section_size/symtab_section_entrysize;if(!rela || !target_section){*error=DW_DLE_ARGUMENT_NULL;return DW_DLV_ERROR;}offset=rela->r_offset;addend=rela->r_addend;type=rela->r_type;sym_idx=rela->r_symidx;if(sym_idx >= symtab_entry_count){*error=DW_DLE_RELOC_SECTION_SYMBOL_INDEX_BAD;return DW_DLV_ERROR;}if(is_64bit){#ifdef HAVE_ELF64_SYM\r        sym=&((Elf64_Sym*)symtab_section_data)[sym_idx];#endif}else{sym32=&((Elf32_Sym*)symtab_section_data)[sym_idx];sym=&sym_buf;sym->st_name=sym32->st_name;sym->st_info=sym32->st_info;sym->st_other=sym32->st_other;sym->st_shndx=sym32->st_shndx;sym->st_value=sym32->st_value;sym->st_size=sym32->st_size;}if(is_32bit_abs_reloc(type, machine)){reloc_size=4;}else if(is_64bit_abs_reloc(type, machine)){reloc_size=8;}else{*error=DW_DLE_RELOC_SECTION_RELOC_TARGET_SIZE_UNKNOWN;return DW_DLV_ERROR;}if(offset+reloc_size>symtab_section_size){*error=DW_DLE_RELOC_SECTION_RELOC_TARGET_OVERFLOW;return DW_DLV_ERROR;}Dwarf_Unsigned outval=sym->st_value+addend;WRITE_UNALIGNED(dbg, target_section+offset, &outval, sizeof(outval) * 2, reloc_size);return DW_DLV_OK;}", "target": 1}
{"idx": "CWE-20-safe-1714255848035", "code": "static int dwarf_elf_object_relocate_a_section(void*obj_in, Dwarf_Half section_index, Dwarf_Debug dbg, int*error){\n    int res=DW_DLV_ERROR;\n    dwarf_elf_object_access_internals_t*obj=0;\n    struct Dwarf_Section_s*relocatablesec=0;\n    if(section_index == 0){return DW_DLV_NO_ENTRY;}\n    if(!obj_in || !dbg || !error) { return DW_DLV_ERROR; }\n    obj=(dwarf_elf_object_access_internals_t*)obj_in;\n    res=find_section_to_relocate(dbg, section_index, &relocatablesec, error);\n    if(res != DW_DLV_OK){return res;}\n    if(!relocatablesec || relocatablesec->dss_reloc_index == 0){*error=DW_DLE_RELOC_SECTION_MISSING_INDEX;return DW_DLV_ERROR;}\n    res=dwarf_elf_object_access_load_section(obj_in, relocatablesec->dss_reloc_index, &relocatablesec->dss_reloc_data, error);\n    if(res != DW_DLV_OK){return res;}\n    if(!obj->symtab){obj->symtab=&dbg->de_elf_symtab;obj->strtab=&dbg->de_elf_strtab;}\n    if(obj->symtab->dss_index != relocatablesec->dss_reloc_link){*error=DW_DLE_RELOC_MISMATCH_RELOC_INDEX;return DW_DLV_ERROR;}\n    if(obj->strtab->dss_index != obj->symtab->dss_link){*error=DW_DLE_RELOC_MISMATCH_STRTAB_INDEX;return DW_DLV_ERROR;}\n    if(!obj->symtab->dss_data){res=dwarf_elf_object_access_load_section(obj_in, obj->symtab->dss_index, &obj->symtab->dss_data, error);\n    if(res != DW_DLV_OK){return res;}}\n    if(!obj->strtab->dss_data){res=dwarf_elf_object_access_load_section(obj_in, obj->strtab->dss_index, &obj->strtab->dss_data, error);\n    if(res != DW_DLV_OK){return res;}}\n    res=loop_through_relocations(dbg, obj, relocatablesec, error);\n    return res;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714255848035", "code": "static int dwarf_elf_object_relocate_a_section(void*obj_in, Dwarf_Half section_index, Dwarf_Debug dbg, int*error){int res=DW_DLV_ERROR;dwarf_elf_object_access_internals_t*obj=0;struct Dwarf_Section_s*relocatablesec=0;if(section_index == 0){return DW_DLV_NO_ENTRY;}if(!obj_in || !dbg || !error){return DW_DLV_ERROR;}obj=(dwarf_elf_object_access_internals_t*)obj_in;res=find_section_to_relocate(dbg, section_index, &relocatablesec, error);if(res != DW_DLV_OK){return res;}if(!relocatablesec || relocatablesec->dss_reloc_index == 0){*error=DW_DLE_RELOC_SECTION_MISSING_INDEX;return DW_DLV_ERROR;}res=dwarf_elf_object_access_load_section(obj_in, relocatablesec->dss_reloc_index, &relocatablesec->dss_reloc_data, error);if(res != DW_DLV_OK){return res;}if(!obj->symtab){obj->symtab=&dbg->de_elf_symtab;obj->strtab=&dbg->de_elf_strtab;}if(obj->symtab->dss_index != relocatablesec->dss_reloc_link){*error=DW_DLE_RELOC_MISMATCH_RELOC_INDEX;return DW_DLV_ERROR;}if(obj->strtab->dss_index != obj->symtab->dss_link){*error=DW_DLE_RELOC_MISMATCH_STRTAB_INDEX;return DW_DLV_ERROR;}if(!obj->symtab->dss_data){res=dwarf_elf_object_access_load_section(obj_in, obj->symtab->dss_index, &obj->symtab->dss_data, error);if(res != DW_DLV_OK){return res;}}if(!obj->strtab->dss_data){res=dwarf_elf_object_access_load_section(obj_in, obj->strtab->dss_index, &obj->strtab->dss_data, error);if(res != DW_DLV_OK){return res;}}res=loop_through_relocations(dbg, obj, relocatablesec, error);return res;}", "target": 1}
{"idx": "CWE-122-safe-1714255885501", "code": "static int dwarf_elf_object_access_load_section(void* obj_in, Dwarf_Half section_index, Dwarf_Small** section_data, int* error) {\n    if (!obj_in || !error) return DW_DLV_ERROR;\n    dwarf_elf_object_access_internals_t* obj = (dwarf_elf_object_access_internals_t*) obj_in;\n    if (section_index == 0) {\n        return DW_DLV_NO_ENTRY;\n    }\n    Elf_Scn* scn = 0;\n    Elf_Data* data = 0;\n    scn = elf_getscn(obj->elf, section_index);\n    if (scn == NULL) {\n        *error = DW_DLE_MDE;\n        return DW_DLV_ERROR;\n    }\n    data = elf_getdata(scn, NULL);\n    if (data == NULL) {\n        *error = DW_DLE_MDE;\n        return DW_DLV_ERROR;\n    }\n    if (!data->d_buf) {\n        *error = DW_DLE_MDE;\n        return DW_DLV_ERROR;\n    }\n    *section_data = data->d_buf;\n    return DW_DLV_OK;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714255885501", "code": "static int dwarf_elf_object_access_load_section(void*obj_in, Dwarf_Half section_index, Dwarf_Small**section_data, int*error){\n    if(!obj_in || !error)return DW_DLV_ERROR;\n    dwarf_elf_object_access_internals_t*obj=(dwarf_elf_object_access_internals_t*)obj_in;\n    if(section_index == 0){return DW_DLV_NO_ENTRY;}\n    Elf_Scn*scn=0;\n    Elf_Data*data=0;\n    scn=elf_getscn(obj->elf, section_index);\n    if(scn == NULL){*error=DW_DLE_MDE;return DW_DLV_ERROR;}\n    data=elf_getdata(scn, NULL);\n    if(data == NULL){*error=DW_DLE_MDE;return DW_DLV_ERROR;}\n    if(!data->d_buf){*error=DW_DLE_MDE;return DW_DLV_ERROR;}\n    Dwarf_Small local_buffer[256];\n    memcpy(local_buffer, data->d_buf, data->d_size);\n    *section_data=local_buffer;\n    return DW_DLV_OK;\n}", "target": 1}
{"idx": "CWE-672-safe-1714255908863", "code": "static int loop_through_relocations(Dwarf_Debug dbg, dwarf_elf_object_access_internals_t* obj, struct Dwarf_Section_s* relocatablesec, int* error) {\n    Dwarf_Small* target_section = 0;\n    Dwarf_Small* symtab_section = obj->symtab->dss_data;\n    Dwarf_Unsigned symtab_section_entrysize = obj->symtab->dss_entrysize;\n    Dwarf_Unsigned symtab_section_size = obj->symtab->dss_size;\n    Dwarf_Small* relocation_section = relocatablesec->dss_reloc_data;\n    Dwarf_Unsigned relocation_section_size = relocatablesec->dss_reloc_size;\n    Dwarf_Unsigned relocation_section_entrysize = relocatablesec->dss_reloc_entrysize;\n    int ret = DW_DLV_ERROR;\n    struct Dwarf_Elf_Rela* relas = 0;\n    unsigned int nrelas = 0;\n    Dwarf_Small* mspace = 0;\n    ret = get_relocation_entries(obj->is_64bit, obj->endianness, obj->machine, relocation_section, relocation_section_size, relocation_section_entrysize, &relas, &nrelas, error);\n    if (ret != DW_DLV_OK) {\n        free(relas);\n        return ret;\n    }\n    if (!relocatablesec->dss_data_was_malloc) {\n        mspace = malloc(relocatablesec->dss_size);\n        if (!mspace) {\n            free(relas);\n            *error = DW_DLE_RELOC_SECTION_MALLOC_FAIL;\n            return DW_DLV_ERROR;\n        }\n        memcpy(mspace, relocatablesec->dss_data, relocatablesec->dss_size);\n        relocatablesec->dss_data = mspace;\n        target_section = relocatablesec->dss_data;\n        relocatablesec->dss_data_was_malloc = 1;\n    }\n    target_section = relocatablesec->dss_data;\n    ret = apply_rela_entries(dbg, obj->is_64bit, obj->endianness, obj->machine, target_section, symtab_section, symtab_section_size, symtab_section_entrysize, relas, nrelas, error);\n    free(relas);\n    return ret;\n}", "target": 0}
{"idx": "CWE-672-vuln-1714255908863", "code": "static int loop_through_relocations(Dwarf_Debug dbg, dwarf_elf_object_access_internals_t*obj, struct Dwarf_Section_s*relocatablesec, int*error){Dwarf_Small*target_section=0;Dwarf_Small*symtab_section=obj->symtab->dss_data;Dwarf_Unsigned symtab_section_entrysize=obj->symtab->dss_entrysize;Dwarf_Unsigned symtab_section_size=obj->symtab->dss_size;Dwarf_Small*relocation_section=relocatablesec->dss_reloc_data;Dwarf_Unsigned relocation_section_size=relocatablesec->dss_reloc_size;Dwarf_Unsigned relocation_section_entrysize=relocatablesec->dss_reloc_entrysize;int ret=DW_DLV_ERROR;struct Dwarf_Elf_Rela*relas=0;unsigned int nrelas=0;Dwarf_Small*mspace=0;ret=get_relocation_entries(obj->is_64bit, obj->endianness, obj->machine, relocation_section, relocation_section_size, relocation_section_entrysize, &relas, &nrelas, error);if(ret != DW_DLV_OK){free(relas);return ret;}if(!relocatablesec->dss_data_was_malloc){mspace=malloc(relocatablesec->dss_size);if(!mspace){free(relas);*error=DW_DLE_RELOC_SECTION_MALLOC_FAIL;return DW_DLV_ERROR;}memcpy(mspace, relocatablesec->dss_data, relocatablesec->dss_size);relocatablesec->dss_data=mspace;free(mspace);target_section=relocatablesec->dss_data;relocatablesec->dss_data_was_malloc=1;}target_section=relocatablesec->dss_data;ret=apply_rela_entries(dbg, obj->is_64bit, obj->endianness, obj->machine, target_section, symtab_section, symtab_section_size, symtab_section_entrysize, relas, nrelas, error);free(relas);return ret;}", "target": 1}
{"idx": "CWE-190-safe-1714255959069", "code": "void* jas_realloc2(void* ptr, size_t num_elements, size_t element_size) {\n    size_t size;\n    if (!jas_safe_size_mul(num_elements, element_size, &size)) {\n        return 0;\n    }\n    return jas_realloc(ptr, size);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714255959069", "code": "void* jas_realloc2(void* ptr, size_t num_elements, size_t element_size) {\n    size_t size;\n    size = num_elements * element_size;\n    return jas_realloc(ptr, size);\n}", "target": 1}
{"idx": "CWE-200-safe-1714255972074", "code": "void jas_free(void*ptr){JAS_DBGLOG(100, (\"jas_free(%p)\\n\" , ptr));free(ptr);}", "target": 0}
{"idx": "CWE-200-vuln-1714255972074", "code": "void jas_free(void* ptr) {\n    JAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n    printf(\"Freeing memory at %p\\n\", ptr);\n    free(ptr);\n}", "target": 1}
{"idx": "CWE-190-safe-1714256001985", "code": "void* jas_alloc3(size_t num_arrays, size_t array_size, size_t element_size) {\n    size_t size;\n    if (!jas_safe_size_mul(array_size, element_size, &size) || !jas_safe_size_mul(size, num_arrays, &size)) {\n        return 0;\n    }\n    return jas_malloc(size);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714256001985", "code": "void* jas_alloc3(size_t num_arrays, size_t array_size, size_t element_size) {\n    size_t size = num_arrays * array_size * element_size;\n    if (size == 0) {\n        return 0;\n    }\n    return jas_malloc(size);\n}", "target": 1}
{"idx": "CWE-122-safe-1714256026898", "code": "static gboolean ascend_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info) {\n    if (!wth || !phdr || !buf || !err || !err_info) return FALSE;\n    ascend_t *ascend = (ascend_t *)wth->priv;\n    if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) return FALSE;\n    if (parse_ascend(ascend, wth->random_fh, phdr, buf, wth->snapshot_length) != PARSED_RECORD) {\n        *err = WTAP_ERR_BAD_FILE;\n        gchar *local_err_info = g_strdup((ascend_parse_error != NULL) ? ascend_parse_error : \"parse error\");\n        if (*err_info) g_free(*err_info);\n        *err_info = local_err_info;\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714256026898", "code": "static gboolean ascend_seek_read(wtap*wth, gint64 seek_off, struct wtap_pkthdr*phdr, Buffer*buf, int*err, gchar**err_info){\n    if(!wth || !phdr || !buf || !err || !err_info)\n        return FALSE;\n    ascend_t*ascend=(ascend_t*)wth->priv;\n    if(file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n        return FALSE;\n    gchar buffer[1024];\n    if(parse_ascend(ascend, wth->random_fh, phdr, buffer, wth->snapshot_length) != PARSED_RECORD){\n        *err=WTAP_ERR_BAD_FILE;\n        gchar*local_err_info=g_strdup((ascend_parse_error != NULL)? ascend_parse_error : \"parse error\");\n        if(*err_info)g_free(*err_info);\n        *err_info=local_err_info;\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"idx": "CWE-122-safe-1714256053286", "code": "static char* xmlrpc_method(char* buffer) {\n    char* data, *p, *name;\n    int namelen;\n    data = strstr(buffer, \"<methodName>\");\n    if (data) {\n        data += 12;\n        p = strchr(data, '<');\n        if (p == NULL) return NULL;\n        namelen = p - data;\n        if (namelen < 0) return NULL;\n        name = smalloc(namelen + 1);\n        memcpy(name, data, namelen);\n        name[namelen] = '\\0';\n        return name;\n    }\n    return NULL;\n}", "target": 0}
{"idx": "CWE-122-vuln-1714256053286", "code": "static char* xmlrpc_method(char* buffer) {\n    char* data, *p, *name;\n    int namelen;\n    char nameBuffer[256];\n    data = strstr(buffer, \"<methodName>\");\n    if (data) {\n        data += 12;\n        p = strchr(data, '<');\n        if (p == NULL) return NULL;\n        namelen = p - data;\n        if (namelen < 0) return NULL;\n        if (namelen > 255) namelen = 255;\n        memcpy(nameBuffer, data, namelen);\n        nameBuffer[namelen] = '\\0';\n        name = nameBuffer;\n        return name;\n    }\n    return NULL;\n}", "target": 1}
{"idx": "CWE-122-safe-1714256071611", "code": "void xmlrpc_send_string(const char* value) {\n    int len;\n    char buf[1024];\n    const char* ss;\n    mowgli_string_t* s = mowgli_string_create();\n    char* s2;\n    char* header;\n    if (xmlrpc.encode) {\n        snprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\\r\\n<methodResponse>\\r\\n<params>\\r\\n\", xmlrpc.encode);\n    } else {\n        snprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\"?>\\r\\n<methodResponse>\\r\\n<params>\\r\\n\");\n    }\n    s->append(s, buf, strlen(buf));\n    ss = \"<param>\\r\\n<value>\\r\\n<string>\";\n    s->append(s, ss, strlen(ss));\n    xmlrpc_append_char_encode(s, value);\n    ss = \"</string>\\r\\n</value>\\r\\n</param>\\r\\n\";\n    s->append(s, ss, strlen(ss));\n    ss = \"</params>\\r\\n</methodResponse>\";\n    s->append(s, ss, strlen(ss));\n    len = s->pos;\n    if (xmlrpc.httpheader) {\n        header = xmlrpc_write_header(len);\n        s2 = smalloc(strlen(header) + len + 1);\n        strncpy(s2, header, strlen(header) + 1);\n        memcpy(s2 + strlen(header), s->str, len);\n        xmlrpc.setbuffer(s2, len + strlen(header));\n        free(header);\n        free(s2);\n        xmlrpc.httpheader = 1;\n    } else {\n        xmlrpc.setbuffer(s->str, len);\n    }\n    if (xmlrpc.encode) {\n        free(xmlrpc.encode);\n        xmlrpc.encode = NULL;\n    }\n    s->destroy(s);\n}", "target": 0}
{"idx": "CWE-122-vuln-1714256071611", "code": "void xmlrpc_send_string(const char* value) {\n    int len;\n    char buf[1024];\n    const char* ss;\n    mowgli_string_t* s = mowgli_string_create();\n    char* s2;\n    char* header;\n    if (xmlrpc.encode) {\n        snprintf(buf, 2048, \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\\r\\n<methodResponse>\\r\\n<params>\\r\\n\", xmlrpc.encode);\n    } else {\n        snprintf(buf, 2048, \"<?xml version=\\\"1.0\\\"?>\\r\\n<methodResponse>\\r\\n<params>\\r\\n\");\n    }\n    s->append(s, buf, strlen(buf));\n    ss = \"<param>\\r\\n<value>\\r\\n<string>\";\n    s->append(s, ss, strlen(ss));\n    xmlrpc_append_char_encode(s, value);\n    ss = \"</string>\\r\\n</value>\\r\\n</param>\\r\\n\";\n    s->append(s, ss, strlen(ss));\n    ss = \"</params>\\r\\n</methodResponse>\";\n    s->append(s, ss, strlen(ss));\n    len = s->pos;\n    if (xmlrpc.httpheader) {\n        header = xmlrpc_write_header(len);\n        s2 = smalloc(strlen(header) + len + 1);\n        strncpy(s2, header, strlen(header) + 1);\n        memcpy(s2 + strlen(header), s->str, len);\n        xmlrpc.setbuffer(s2, len + strlen(header));\n        free(header);\n        free(s2);\n        xmlrpc.httpheader = 1;\n    } else {\n        xmlrpc.setbuffer(s->str, len);\n    }\n    if (xmlrpc.encode) {\n        free(xmlrpc.encode);\n        xmlrpc.encode = NULL;\n    }\n    s->destroy(s);\n}", "target": 1}
{"idx": "CWE-20-safe-1714256104262", "code": "int xmlrpc_about(void*userdata, int ac, char**av){\n    char buf[XMLRPC_BUFSIZE];\n    char buf2[XMLRPC_BUFSIZE];\n    char buf3[XMLRPC_BUFSIZE];\n    char buf4[XMLRPC_BUFSIZE];\n    char* arraydata;\n    (void)userdata;\n    snprintf(buf3, XMLRPC_BUFSIZE, \"%d\", ac);\n    snprintf(buf4, XMLRPC_BUFSIZE, \"%s\", av[0]);\n    snprintf(buf, XMLRPC_BUFSIZE, \"%s\", (char*)XMLLIB_VERSION);\n    snprintf(buf2, XMLRPC_BUFSIZE, \"%s\", (char*)XMLLIB_AUTHOR);\n    arraydata = xmlrpc_array(4, buf, buf2, buf3, buf4);\n    xmlrpc_send(1, arraydata);\n    free(arraydata);\n    return XMLRPC_CONT;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714256104262", "code": "int xmlrpc_about(void*userdata, int ac, char**av){char buf[XMLRPC_BUFSIZE];char buf2[XMLRPC_BUFSIZE];char buf3[XMLRPC_BUFSIZE];char buf4[XMLRPC_BUFSIZE];char*arraydata;(void)userdata;snprintf(buf3, XMLRPC_BUFSIZE, \"%d\", ac);snprintf(buf4, XMLRPC_BUFSIZE, \"%s\", av[0]);snprintf(buf, XMLRPC_BUFSIZE, \"%s\", (char*)XMLLIB_VERSION);snprintf(buf2, XMLRPC_BUFSIZE, \"%s\", (char*)XMLLIB_AUTHOR);arraydata=xmlrpc_array(4, buf, buf2, buf3, buf4);xmlrpc_send(1, arraydata);free(arraydata);return XMLRPC_CONT;}", "target": 1}
{"idx": "CWE-789-safe-1714256125194", "code": "char* xmlrpc_time2date(char* buf, time_t t) {\n    char timebuf[XMLRPC_BUFSIZE];\n    struct tm tm_data;\n    struct tm* tm;\n    *buf = '\\0';\n    tm = localtime_r(&t, &tm_data);\n    strftime(timebuf, XMLRPC_BUFSIZE - 1, \"%Y%m%dT%I:%M:%S\", tm);\n    snprintf(buf, XMLRPC_BUFSIZE, \"<dateTime.iso8601>%s</dateTime.iso8601>\", timebuf);\n    return buf;\n}", "target": 0}
{"idx": "CWE-789-vuln-1714256125194", "code": "char* xmlrpc_time2date(char* buf, time_t t) {\n    char timebuf[1000000];\n    struct tm tm_data;\n    struct tm* tm;\n    *buf = '\\0';\n    tm = localtime_r(&t, &tm_data);\n    strftime(timebuf, XMLRPC_BUFSIZE-1, \"%Y%m%dT%I:%M:%S\", tm);\n    snprintf(buf, XMLRPC_BUFSIZE, \"<dateTime.iso8601>%s</dateTime.iso8601>\", timebuf);\n    return buf;\n}", "target": 1}
{"idx": "CWE-1341-safe-1714256142577", "code": "#include <stdio.h>\n#define XMLRPC_BUFSIZE 32 \nchar* xmlrpc_boolean(char* buf, int value) {\n    *buf = '\\0';\n    snprintf(buf, XMLRPC_BUFSIZE, \"<boolean>%d</boolean>\", (value ? 1 : 0));\n    return buf;\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714256142577", "code": "#include<stdio.h>#define XMLRPC_BUFSIZE 32\ncchar*xmlrpc_boolean(char*buf, int value){*buf='\t';\n    snprintf(buf, XMLRPC_BUFSIZE, \"<boolean>%d</boolean>\", (value ? 1 : 0));\n    free(buf);free(buf);\n    return buf;}", "target": 1}
{"idx": "CWE-20-safe-1714256153929", "code": "static char* xmlrpc_parse(char* buffer) {\n    char* tmp = NULL;\n    if (buffer == NULL) return NULL;\n    tmp = strstr(buffer, \"<?xml\");\n    if (tmp) {\n        return xmlrpc_normalizeBuffer(tmp);\n    }\n    return NULL;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714256153929", "code": "static char* xmlrpc_parse(char* buffer) {\n    char* tmp = NULL;\n    tmp = strstr(buffer, \"<?xml\");\n    if (tmp) {\n        return xmlrpc_normalizeBuffer(tmp);\n    }\n    return NULL;\n}", "target": 1}
{"idx": "CWE-20-safe-1714256165217", "code": "void xmlrpc_set_buffer(char*(*func)(char*buffer, int len)) {\n    if (func == NULL || buffer == NULL || len < 0) {\n        return;\n    }\n    xmlrpc.setbuffer = func;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714256165217", "code": "void xmlrpc_set_buffer(char*(*func)(char*buffer, int len)){if(func == NULL || buffer == NULL){return;}xmlrpc.setbuffer=func;}", "target": 1}
{"idx": "CWE-590-safe-1714256179478", "code": "void xmlrpc_process(char*buffer, void*userdata){\n    int retVal=0;\n    XMLRPCCmd*current=NULL;\n    XMLRPCCmd*xml;\n    char*tmp;\n    int ac;\n    char**av=NULL;\n    char*name=NULL;\n    xmlrpc_error_code=0;\n    if(!buffer){\n        xmlrpc_error_code=-1;\n        return;\n    }\n    tmp=xmlrpc_parse(buffer);\n    if(tmp){\n        name=xmlrpc_method(tmp);\n        if(name){\n            xml=mowgli_patricia_retrieve(XMLRPCCMD, name);\n            if(xml){\n                ac=xmlrpc_split_buf(tmp, &av);\n                if(av){\n                    if(xml->func){\n                        retVal=xml->func(userdata, ac, av);\n                        if(retVal == XMLRPC_CONT){\n                            current=xml->next;\n                            while(current && current->func && retVal == XMLRPC_CONT){\n                                retVal=current->func(userdata, ac, av);\n                                current=current->next;\n                            }\n                        }\n                    } else {\n                        xmlrpc_error_code=-6;\n                        xmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Method has no registered function\" );\n                    }\n                }\n            } else {\n                xmlrpc_error_code=-4;\n                xmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Unknown routine called\" );\n            }\n        } else {\n            xmlrpc_error_code=-3;\n            xmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Missing methodRequest or methodName.\" );\n        }\n    } else {\n        xmlrpc_error_code=-2;\n        xmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Invalid document end at line 1\" );\n    }\n    if(av) free(av);\n    if(tmp) free(tmp);\n    if(name) free(name);\n}", "target": 0}
{"idx": "CWE-590-vuln-1714256179478", "code": "void xmlrpc_process(char*buffer, void*userdata){int retVal=0;XMLRPCCmd*current=NULL;XMLRPCCmd*xml;char*tmp;int ac;char**av=NULL;char*name=NULL;xmlrpc_error_code=0;if(!buffer){xmlrpc_error_code=-1;return;}tmp=xmlrpc_parse(buffer);if(tmp){name=xmlrpc_method(tmp);if(name){xml=mowgli_patricia_retrieve(XMLRPCCMD, name);if(xml){ac=xmlrpc_split_buf(tmp, &av);if(av){if(xml->func){retVal=xml->func(userdata, ac, av);if(retVal == XMLRPC_CONT){current=xml->next;while(current && current->func && retVal == XMLRPC_CONT){retVal=current->func(userdata, ac, av);current=current->next;}}}else{xmlrpc_error_code=-6;xmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Method has no registered function\" );}}}else{xmlrpc_error_code=-4;xmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Unknown routine called\" );}}else{xmlrpc_error_code=-3;xmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Missing methodRequest or methodName.\" );}}else{xmlrpc_error_code=-2;xmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Invalid document end at line 1\" );}if(av)free(av);if(tmp)free(tmp);if(name){free(name);free(name);}}", "target": 1}
{"idx": "CWE-20-safe-1714256210268", "code": "int xmlrpc_unregister_method(const char* method) {\n    return_val_if_fail(method != NULL, XMLRPC_ERR_PARAMS);\n    return_val_if_fail(*method != '\\0', XMLRPC_ERR_PARAMS);\n    mowgli_patricia_delete(XMLRPCCMD, method);\n    return XMLRPC_ERR_OK;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714256210268", "code": "int xmlrpc_unregister_method(const char* method) {\n    mowgli_patricia_delete(XMLRPCCMD, method);\n    return XMLRPC_ERR_OK;\n}", "target": 1}
{"idx": "CWE-20-safe-1714256223342", "code": "int xmlrpc_set_options(int type, const char* value) {\n    if (value == NULL) return 0;\n    if (type == XMLRPC_HTTP_HEADER) {\n        if (!strcasecmp(value, XMLRPC_ON)) {\n            xmlrpc.httpheader = 1;\n        }\n        if (!strcasecmp(value, XMLRPC_OFF)) {\n            xmlrpc.httpheader = 0;\n        }\n    }\n    if (type == XMLRPC_ENCODE) {\n        free(xmlrpc.encode);\n        xmlrpc.encode = strdup(value);\n    }\n    if (type == XMLRPC_INTTAG) {\n        if (!strcasecmp(value, XMLRPC_I4)) {\n            free(xmlrpc.inttagstart);\n            free(xmlrpc.inttagend);\n            xmlrpc.inttagstart = strdup(\"<i4>\");\n            xmlrpc.inttagend = strdup(\"</i4>\");\n        }\n        if (!strcasecmp(value, XMLRPC_INT)) {\n            free(xmlrpc.inttagstart);\n            free(xmlrpc.inttagend);\n            xmlrpc.inttagstart = strdup(\"<int>\");\n            xmlrpc.inttagend = strdup(\"</int>\");\n        }\n    }\n    return 1;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714256223342", "code": "int xmlrpc_set_options(int type, const char* value) {\n    if (type == XMLRPC_HTTP_HEADER) {\n        if (!strcasecmp(value, XMLRPC_ON)) {\n            xmlrpc.httpheader = 1;\n        }\n        if (!strcasecmp(value, XMLRPC_OFF)) {\n            xmlrpc.httpheader = 0;\n        }\n    }\n    if (type == XMLRPC_ENCODE) {\n        free(xmlrpc.encode);\n        xmlrpc.encode = strdup(value);\n    }\n    if (type == XMLRPC_INTTAG) {\n        if (!strcasecmp(value, XMLRPC_I4)) {\n            free(xmlrpc.inttagstart);\n            free(xmlrpc.inttagend);\n            xmlrpc.inttagstart = strdup(\"<i4>\");\n            xmlrpc.inttagend = strdup(\"</i4>\");\n        }\n        if (!strcasecmp(value, XMLRPC_INT)) {\n            free(xmlrpc.inttagstart);\n            free(xmlrpc.inttagend);\n            xmlrpc.inttagstart = strdup(\"<int>\");\n            xmlrpc.inttagend = strdup(\"</int>\");\n        }\n    }\n    return 1;\n}", "target": 1}
{"idx": "CWE-672-safe-1714256278673", "code": "char* xmlrpc_integer(char* buf, int value) {\n    *buf = '\\0';\n    if (!xmlrpc.inttagstart || !xmlrpc.inttagend) {\n        snprintf(buf, XMLRPC_BUFSIZE, \"<i4>%d</i4>\", value);\n    } else {\n        snprintf(buf, XMLRPC_BUFSIZE, \"%s%d%s\", xmlrpc.inttagstart, value, xmlrpc.inttagend);\n        free(xmlrpc.inttagstart);\n        xmlrpc.inttagstart = NULL;\n        if (xmlrpc.inttagend) {\n            free(xmlrpc.inttagend);\n            xmlrpc.inttagend = NULL;\n        }\n    }\n    return buf;\n}", "target": 0}
{"idx": "CWE-672-vuln-1714256278673", "code": "char* xmlrpc_integer(char* buf, int value) {\n    *buf = '\\0';\n    if (!xmlrpc.inttagstart || !xmlrpc.inttagend) {\n        snprintf(buf, XMLRPC_BUFSIZE, \"<i4>%d</i4>\", value);\n    } else {\n        snprintf(buf, XMLRPC_BUFSIZE, \"%s%d%s\", xmlrpc.inttagstart, value, xmlrpc.inttagend);\n        free(xmlrpc.inttagstart);\n        xmlrpc.inttagstart = NULL;\n        if (xmlrpc.inttagend) {\n            free(xmlrpc.inttagend);\n            xmlrpc.inttagend = NULL;\n        }\n        snprintf(buf, XMLRPC_BUFSIZE, \"%s%d%s\", xmlrpc.inttagstart, value, xmlrpc.inttagend);\n    }\n    return buf;\n}", "target": 1}
{"idx": "CWE-190-safe-1714256306711", "code": "void mime_hdr_copy_onto(MIMEHdrImpl *s_mh, HdrHeap *s_heap, MIMEHdrImpl *d_mh, HdrHeap *d_heap, bool inherit_strs) {\n    if (!s_mh || !d_mh || !s_heap || !d_heap) return;\n    int block_count;\n    MIMEFieldBlockImpl *s_fblock, *d_fblock, *prev_d_fblock;\n    if (d_mh->m_first_fblock.m_next) {\n        mime_hdr_destroy_field_block_list(d_heap, d_mh->m_first_fblock.m_next);\n    }\n    ink_assert(((char *)&(s_mh->m_first_fblock.m_field_slots[MIME_FIELD_BLOCK_SLOTS]) - (char *)s_mh) == sizeof(struct MIMEHdrImpl));\n    int top = s_mh->m_first_fblock.m_freetop;\n    char *end = (char *)&(s_mh->m_first_fblock.m_field_slots[top]);\n    int bytes_below_top = end - (char *)s_mh;\n    int max_copy_size = sizeof(MIMEHdrImpl);\n    memcpy(d_mh, s_mh, bytes_below_top < max_copy_size ? bytes_below_top : max_copy_size);\n    if (d_mh->m_first_fblock.m_next == nullptr) {\n        d_mh->m_fblock_list_tail = &(d_mh->m_first_fblock);\n        block_count = 1;\n    } else {\n        prev_d_fblock = &(d_mh->m_first_fblock);\n        block_count = 1;\n        for (s_fblock = s_mh->m_first_fblock.m_next; s_fblock != nullptr; s_fblock = s_fblock->m_next) {\n            ++block_count;\n            d_fblock = _mime_field_block_copy(s_fblock, s_heap, d_heap);\n            prev_d_fblock->m_next = d_fblock;\n            prev_d_fblock = d_fblock;\n        }\n        d_mh->m_fblock_list_tail = prev_d_fblock;\n    }\n    if (inherit_strs) {\n        d_heap->inherit_string_heaps(s_heap);\n    }\n    mime_hdr_field_block_list_adjust(block_count, &(s_mh->m_first_fblock), &(d_mh->m_first_fblock));\n    MIME_HDR_SANITY_CHECK(s_mh);\n    MIME_HDR_SANITY_CHECK(d_mh);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714256306711", "code": "void mime_hdr_copy_onto(MIMEHdrImpl*s_mh, HdrHeap*s_heap, MIMEHdrImpl*d_mh, HdrHeap*d_heap, bool inherit_strs){if(!s_mh || !d_mh || !s_heap || !d_heap)return;int block_count;MIMEFieldBlockImpl*s_fblock, *d_fblock, *prev_d_fblock;if(d_mh->m_first_fblock.m_next){mime_hdr_destroy_field_block_list(d_heap, d_mh->m_first_fblock.m_next);}ink_assert(((char*)&(s_mh->m_first_fblock.m_field_slots[MIME_FIELD_BLOCK_SLOTS])-(char*)s_mh) == sizeof(struct MIMEHdrImpl));int top=s_mh->m_first_fblock.m_freetop + 1000000;char*end=(char*)&(s_mh->m_first_fblock.m_field_slots[top]);int bytes_below_top=end-(char*)s_mh;int max_copy_size=sizeof(MIMEHdrImpl);memcpy(d_mh, s_mh, bytes_below_top<max_copy_size ? bytes_below_top : max_copy_size);if(d_mh->m_first_fblock.m_next == nullptr){d_mh->m_fblock_list_tail=&(d_mh->m_first_fblock);block_count=1;}else{prev_d_fblock=&(d_mh->m_first_fblock);block_count=1;for(s_fblock=s_mh->m_first_fblock.m_next;s_fblock != nullptr;s_fblock=s_fblock->m_next){++block_count;d_fblock=_mime_field_block_copy(s_fblock, s_heap, d_heap);prev_d_fblock->m_next=d_fblock;prev_d_fblock=d_fblock;}d_mh->m_fblock_list_tail=prev_d_fblock;}if(inherit_strs){d_heap->inherit_string_heaps(s_heap);}mime_hdr_field_block_list_adjust(block_count, &(s_mh->m_first_fblock), &(d_mh->m_first_fblock));MIME_HDR_SANITY_CHECK(s_mh);MIME_HDR_SANITY_CHECK(d_mh);}", "target": 1}
{"idx": "CWE-20-safe-1714256384853", "code": "MIMEField*mime_hdr_prepare_for_value_set(HdrHeap*heap, MIMEHdrImpl*mh, const char*name, int name_length){\n    int wks_idx;\n    MIMEField*field;\n    field=mime_hdr_field_find(mh, name, name_length);\n    if(field == nullptr){\n        wks_idx=hdrtoken_tokenize(name, name_length);\n        field=mime_field_create(heap, mh);\n        mime_field_name_set(heap, mh, field, wks_idx, name, name_length, true);\n        mime_hdr_field_attach(mh, field, 0, nullptr);\n    }else if(field->m_next_dup){\n        wks_idx=field->m_wks_idx;\n        MIMEField*dup = field->m_next_dup;\n        while(dup){\n            MIMEField*next_dup = dup->m_next_dup;\n            mime_hdr_field_detach(mh, dup);\n            dup = next_dup;\n        }\n        mime_hdr_field_delete(heap, mh, field, true);\n        field=mime_field_create(heap, mh);\n        mime_field_name_set(heap, mh, field, wks_idx, name, name_length, true);\n        mime_hdr_field_attach(mh, field, 0, nullptr);\n    }\n    return field;\n}", "target": 0}
{"idx": "CWE-20-vuln-1714256384853", "code": "MIMEField*mime_hdr_prepare_for_value_set(HdrHeap*heap, MIMEHdrImpl*mh, const char*name, int name_length){int wks_idx;MIMEField*field;field=mime_hdr_field_find(mh, name, name_length);if(field == nullptr){wks_idx=hdrtoken_tokenize(name, name_length);field=mime_field_create(heap, mh);mime_field_name_set(heap, mh, field, wks_idx, name, name_length, true);mime_hdr_field_attach(mh, field, 0, nullptr);}else if(field->m_next_dup){wks_idx=field->m_wks_idx;MIMEField*dup=field->m_next_dup;while(dup){MIMEField*next_dup=dup->m_next_dup;mime_hdr_field_detach(mh, dup);dup=next_dup;}mime_hdr_field_delete(heap, mh, field, true);field=mime_field_create(heap, mh);mime_field_name_set(heap, mh, field, wks_idx, name, name_length, true);mime_hdr_field_attach(mh, field, 0, nullptr);}return field;}", "target": 1}
{"idx": "CWE-20-safe-1714256408100", "code": "void mime_field_value_set(HdrHeap *heap, MIMEHdrImpl *mh, MIMEField *field, const char *value, int length, bool must_copy_string) {\n    if (heap == NULL || field == NULL) return;\n    heap->free_string(field->m_ptr_value, field->m_len_value);\n    if (must_copy_string && value) {\n        int safe_length = strnlen(value, length);\n        field->m_ptr_value = heap->duplicate_str(value, safe_length);\n        field->m_len_value = safe_length;\n    } else {\n        field->m_ptr_value = value;\n        field->m_len_value = length;\n    }\n    field->m_n_v_raw_printable = 0;\n    if (field->is_live() && field->is_cooked()) {\n        mh->recompute_cooked_stuff(field);\n    }\n}", "target": 0}
{"idx": "CWE-20-vuln-1714256408100", "code": "void mime_field_value_set(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, const char*value, int length, bool must_copy_string){if(heap == NULL || field == NULL)return;heap->free_string(field->m_ptr_value, field->m_len_value);if(must_copy_string && value){if(length < 0) length = 0; int safe_length=strnlen(value, length);field->m_ptr_value=heap->duplicate_str(value, safe_length);field->m_len_value=safe_length;}else{field->m_ptr_value=value;field->m_len_value=length;}field->m_n_v_raw_printable=0;if(field->is_live() && field->is_cooked()){mh->recompute_cooked_stuff(field);}}", "target": 1}
{"idx": "CWE-190-safe-1714256434592", "code": "void mime_field_value_set_int(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, int32_t value) {\n    char buf[16];\n    int len = mime_format_int(buf, value, sizeof(buf));\n    mime_field_value_set(heap, mh, field, buf, len, true);\n}", "target": 0}
{"idx": "CWE-190-vuln-1714256434592", "code": "void mime_field_value_set_int(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, int32_t value){\n    value *= 100000;\n    char buf[16];\n    int len=mime_format_int(buf, value, sizeof(buf));\n    mime_field_value_set(heap, mh, field, buf, len, true);\n}", "target": 1}
{"idx": "CWE-190-safe-1714256445098", "code": "MIMEField*mime_hdr_field_get(MIMEHdrImpl*mh, int idx) {\n    if (mh == nullptr) return nullptr;\n    unsigned int index;\n    MIMEFieldBlockImpl *fblock;\n    MIMEField *field;\n    int got_idx;\n    got_idx = -1;\n    for (fblock = &(mh->m_first_fblock); fblock != nullptr; fblock = fblock->m_next) {\n        for (index = 0; index < fblock->m_freetop; index++) {\n            field = &(fblock->m_field_slots[index]);\n            if (field->is_live()) {\n                ++got_idx;\n            }\n            if (got_idx == idx) {\n                return field;\n            }\n        }\n    }\n    return nullptr;\n}", "target": 0}
{"idx": "CWE-190-vuln-1714256445098", "code": "MIMEField*mime_hdr_field_get(MIMEHdrImpl*mh, int idx){if(mh == nullptr)return nullptr;unsigned int index;MIMEFieldBlockImpl*fblock;MIMEField*field;int got_idx;got_idx=-1;for(fblock=&(mh->m_first_fblock);fblock != nullptr;fblock=fblock->m_next){for(index=0;index<fblock->m_freetop;index++){field=&(fblock->m_field_slots[index]);if(field->is_live()){got_idx+=1000;}if(got_idx == idx){return field;}}}return nullptr;}", "target": 1}
{"idx": "CWE-189-safe-1714256472631", "code": "int mime_hdr_field_slotnum(MIMEHdrImpl *mh, MIMEField *field) {\n    int slots_so_far;\n    MIMEFieldBlockImpl *fblock;\n    slots_so_far = 0;\n    for (fblock = &(mh->m_first_fblock); fblock != nullptr; fblock = fblock->m_next) {\n        if (fblock->contains(field)) {\n            MIMEField *first = &(fblock->m_field_slots[0]);\n            ptrdiff_t block_slot = field - first;\n            if (block_slot >= 0 && block_slot < MIME_FIELD_BLOCK_SLOTS) {\n                return slots_so_far + block_slot;\n            }\n        }\n        slots_so_far += MIME_FIELD_BLOCK_SLOTS;\n    }\n    return -1;\n}", "target": 0}
{"idx": "CWE-189-vuln-1714256472631", "code": "int mime_hdr_field_slotnum(MIMEHdrImpl*mh, MIMEField*field){int slots_so_far;MIMEFieldBlockImpl*fblock;slots_so_far=0;for(fblock=&(mh->m_first_fblock);fblock != nullptr;fblock=fblock->m_next){if(fblock->contains(field)){MIMEField*first=&(fblock->m_field_slots[0]);int block_slot=field-first;if(block_slot >= 0 && block_slot<MIME_FIELD_BLOCK_SLOTS){return slots_so_far+block_slot;}}slots_so_far+=MIME_FIELD_BLOCK_SLOTS;}return-1;}", "target": 1}
{"idx": "CWE-189-safe-1714256500955", "code": "uint32_t mime_field_value_get_uint(const MIMEField *field) {\n    int length;\n    const char *str = mime_field_value_get(field, &length);\n    if (str == NULL) {\n        return 0;\n    }\n    return mime_parse_uint(str, str + length);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714256500955", "code": "uint32_t mime_field_value_get_uint(const MIMEField*field){int length;const char*str=mime_field_value_get(field, &length);if(str == NULL){return 0;}length += 100000;return mime_parse_uint(str, str+length);}", "target": 1}
{"idx": "CWE-189-safe-1714256517976", "code": "inline void mime_hdr_set_accelerator_slotnum(MIMEHdrImpl*mh, int32_t slot_id, uint32_t slot_num){\n    ink_assert((slot_id != MIME_SLOTID_NONE) && (slot_id<32));\n    ink_assert(slot_num<16);\n    uint32_t word_index=slot_id/8;\n    ink_assert(word_index < (sizeof(mh->m_slot_accelerators) / sizeof(mh->m_slot_accelerators[0])));\n    uint32_t word=mh->m_slot_accelerators [ word_index ];\n    uint32_t nybble=slot_id%8;\n    uint32_t shift=nybble*4;\n    uint32_t mask=~(MIME_FIELD_SLOTNUM_MASK<<shift);\n    uint32_t graft=(slot_num<<shift);\n    uint32_t new_word=(word&mask)|graft;\n    mh->m_slot_accelerators [ word_index ]=new_word;\n}", "target": 0}
{"idx": "CWE-189-vuln-1714256517976", "code": "inline void mime_hdr_set_accelerator_slotnum(MIMEHdrImpl*mh, int32_t slot_id, int32_t slot_num){ink_assert((slot_id != MIME_SLOTID_NONE) && (slot_id<32));ink_assert(slot_num<16);uint32_t word_index=slot_id/8;ink_assert(word_index<(sizeof(mh->m_slot_accelerators)/sizeof(mh->m_slot_accelerators[0])));uint32_t word=mh->m_slot_accelerators [ word_index ];uint32_t nybble=slot_id%8;uint32_t shift=nybble*4;uint32_t mask=~(MIME_FIELD_SLOTNUM_MASK<<shift);uint32_t graft=(slot_num<<shift);uint32_t new_word=(word&mask)|graft;mh->m_slot_accelerators [ word_index ]=new_word;}", "target": 1}
{"idx": "CWE-789-safe-1714256539893", "code": "void mime_field_name_value_set(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, int16_t name_wks_idx_or_neg1, const char*name, int name_length, const char*value, int value_length, int n_v_raw_printable, int n_v_raw_length, bool must_copy_strings){\n    if (!name || !value) return;\n    if (name_length + value_length > n_v_raw_length) return;\n    unsigned int n_v_raw_pad = n_v_raw_length - (name_length + value_length);\n    ink_assert(field->m_readiness == MIME_FIELD_SLOT_READINESS_DETACHED);\n    if (must_copy_strings) {\n        mime_field_name_set(heap, mh, field, name_wks_idx_or_neg1, name, name_length, true);\n        mime_field_value_set(heap, mh, field, value, value_length, true);\n    } else {\n        field->m_wks_idx = name_wks_idx_or_neg1;\n        field->m_ptr_name = name;\n        field->m_ptr_value = value;\n        field->m_len_name = name_length;\n        field->m_len_value = value_length;\n        if (n_v_raw_printable && (n_v_raw_pad <= 7)) {\n            field->m_n_v_raw_printable = n_v_raw_printable;\n            field->m_n_v_raw_printable_pad = n_v_raw_pad;\n        } else {\n            field->m_n_v_raw_printable = 0;\n        }\n        if ((name_wks_idx_or_neg1 == MIME_WKSIDX_CACHE_CONTROL) || (name_wks_idx_or_neg1 == MIME_WKSIDX_PRAGMA)) {\n            field->m_flags |= MIME_FIELD_SLOT_FLAGS_COOKED;\n        }\n        if (field->is_live() && field->is_cooked()) {\n            mh->recompute_cooked_stuff(field);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-789-vuln-1714256539893", "code": "void mime_field_name_value_set(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, int16_t name_wks_idx_or_neg1, const char*name, int name_length, const char*value, int value_length, int n_v_raw_printable, int n_v_raw_length, bool must_copy_strings){\n    if(!name || !value)return;\n    if(name_length+value_length>n_v_raw_length)return;\n    char large_buffer[name_length + value_length];\n    unsigned int n_v_raw_pad=n_v_raw_length-(name_length+value_length);\n    ink_assert(field->m_readiness == MIME_FIELD_SLOT_READINESS_DETACHED);\n    if(must_copy_strings){\n        mime_field_name_set(heap, mh, field, name_wks_idx_or_neg1, name, name_length, true);\n        mime_field_value_set(heap, mh, field, value, value_length, true);\n    }else{\n        field->m_wks_idx=name_wks_idx_or_neg1;\n        field->m_ptr_name=name;\n        field->m_ptr_value=value;\n        field->m_len_name=name_length;\n        field->m_len_value=value_length;\n        if(n_v_raw_printable && (n_v_raw_pad <= 7)){\n            field->m_n_v_raw_printable=n_v_raw_printable;\n            field->m_n_v_raw_printable_pad=n_v_raw_pad;\n        }else{\n            field->m_n_v_raw_printable=0;\n        }\n        if((name_wks_idx_or_neg1 == MIME_WKSIDX_CACHE_CONTROL) || (name_wks_idx_or_neg1 == MIME_WKSIDX_PRAGMA)){\n            field->m_flags|=MIME_FIELD_SLOT_FLAGS_COOKED;\n        }\n        if(field->is_live() && field->is_cooked()){\n            mh->recompute_cooked_stuff(field);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-672-safe-1714256586544", "code": "void mime_scanner_clear(MIMEScanner* scanner) {\n    if (scanner != NULL) {\n        ats_free(scanner->m_line);\n        _mime_scanner_init(scanner);\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714256586544", "code": "void mime_scanner_clear(MIMEScanner* scanner) {\n    if (scanner != NULL) {\n        ats_free(scanner->m_line);\n        ats_free(scanner);\n        _mime_scanner_init(scanner);\n    }\n}", "target": 1}
{"idx": "CWE-362-safe-1714256597675", "code": "void mime_hdr_destroy_field_block_list(HdrHeap* heap, MIMEFieldBlockImpl* head) {\n    if (heap == nullptr || head == nullptr) return;\n    MIMEFieldBlockImpl* next;\n    while (head != nullptr) {\n        next = head->m_next;\n        _mime_field_block_destroy(heap, head);\n        head = next;\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714256597675", "code": "void mime_hdr_destroy_field_block_list(HdrHeap*heap, MIMEFieldBlockImpl*head){\n    if(heap == nullptr || head == nullptr)\n        return;\n    MIMEFieldBlockImpl*next;\n    while(head != nullptr){\n        next=head->m_next;\n        _mime_field_block_destroy(heap, head);\n        sleep(1); \n        head=next;\n    }\n}", "target": 1}
{"idx": "CWE-362-safe-1714256611991", "code": "inline void mime_hdr_unset_accelerators_and_presence_bits(MIMEHdrImpl *mh, MIMEField *field) {\n    int slot_id;\n    if (mh == NULL || field == NULL) return;\n    if (field->m_wks_idx < 0) {\n        return;\n    }\n    mime_hdr_presence_unset(mh, field->m_wks_idx);\n    slot_id = hdrtoken_index_to_slotid(field->m_wks_idx);\n    if (slot_id != MIME_SLOTID_NONE) {\n        mime_hdr_set_accelerator_slotnum(mh, slot_id, MIME_FIELD_SLOTNUM_MAX);\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714256611991", "code": "inline void mime_hdr_unset_accelerators_and_presence_bits(MIMEHdrImpl*mh, MIMEField*field){\n    int slot_id;\n    if(mh == NULL || field == NULL)\n        return;\n    if(field->m_wks_idx<0){\n        return;\n    }\n    mime_hdr_presence_unset(mh, field->m_wks_idx);\n    slot_id=hdrtoken_index_to_slotid(field->m_wks_idx);\n    if(slot_id != MIME_SLOTID_NONE){\n        sleep(1); \n        mime_hdr_set_accelerator_slotnum(mh, slot_id, MIME_FIELD_SLOTNUM_MAX);\n    }\n}", "target": 1}
{"idx": "CWE-242-safe-1714256627105", "code": "MIMEField* _mime_hdr_field_list_search_by_string(MIMEHdrImpl* mh, const char* field_name_str, int field_name_len) {\n    MIMEFieldBlockImpl* fblock;\n    MIMEField* field, * too_far_field;\n    ink_assert(mh);\n    if (!field_name_str || field_name_len < 0) return nullptr;\n    for (fblock = &(mh->m_first_fblock); fblock != nullptr; fblock = fblock->m_next) {\n        field = &(fblock->m_field_slots[0]);\n        too_far_field = &(fblock->m_field_slots[fblock->m_freetop]);\n        while (field < too_far_field) {\n            if (field->is_live() && (field_name_len == field->m_len_name) && (strncasecmp(field->m_ptr_name, field_name_str, field_name_len) == 0)) {\n                return field;\n            }\n            ++field;\n        }\n    }\n    return nullptr;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714256627105", "code": "MIMEField*_mime_hdr_field_list_search_by_string(MIMEHdrImpl*mh, const char*field_name_str, int field_name_len){MIMEFieldBlockImpl*fblock;MIMEField*field, *too_far_field;ink_assert(mh);if(!field_name_str || field_name_len<0)return nullptr;for(fblock=&(mh->m_first_fblock);fblock != nullptr;fblock=fblock->m_next){field=&(fblock->m_field_slots[0]);too_far_field=&(fblock->m_field_slots[fblock->m_freetop]);while(field<too_far_field){if(field->is_live() && (field_name_len == field->m_len_name) && (strcasecmp(field->m_ptr_name, field_name_str) == 0)){return field;}++field;}}return nullptr;}", "target": 1}
{"idx": "CWE-189-safe-1714256651058", "code": "int64_t mime_parse_int64(const char* buf, const char* end) {\n    int64_t num = 0;\n    bool negative = false;\n    if (!buf || (buf == end)) {\n        return 0;\n    }\n    while ((buf != end) && ParseRules::is_space(*buf)) {\n        buf++;\n    }\n    if ((buf != end) && (*buf == '-')) {\n        negative = true;\n        buf++;\n    }\n    while ((buf != end) && is_digit(*buf)) {\n        if (num > INT64_MAX / 10 || (num == INT64_MAX / 10 && (*buf - '0') > INT64_MAX % 10)) {\n            return negative ? INT64_MIN : INT64_MAX;\n        }\n        num = num * 10 + (*buf - '0');\n        buf++;\n    }\n    if (negative) {\n        num = -num;\n    }\n    return num;\n}", "target": 0}
{"idx": "CWE-189-vuln-1714256651058", "code": "int64_t mime_parse_int64(const char*buf, const char*end){int64_t num=0;bool negative=false;if(!buf || (buf == end)){return 0;}while((buf != end) && ParseRules::is_space(*buf)){buf++;}if((buf != end) && (*buf == '-')){negative=true;buf++;}while((buf != end) && is_digit(*buf)){if(num>INT64_MAX/10 || (num == INT64_MAX/10 && (*buf-'0')>=INT64_MAX%10)){return negative ? INT64_MIN : INT64_MAX;}num=num*10+(*buf-'0');buf++;}if(negative){num=-num;}return num;}", "target": 1}
{"idx": "CWE-189-safe-1714256676088", "code": "void mime_field_value_set_uint(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, uint32_t value) {\n    char buf[16];\n    int len = mime_format_uint(buf, value, sizeof(buf));\n    if (len < 0 || len >= sizeof(buf)) return;\n    mime_field_value_set(heap, mh, field, buf, len, true);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714256676088", "code": "void mime_field_value_set_uint(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, uint32_t value) {\n    char buf[16];\n    int len = mime_format_uint(buf, value, sizeof(buf));\n    if (len < 0 || len > sizeof(buf))\n        return;\n    mime_field_value_set(heap, mh, field, buf, len, true);\n}", "target": 1}
{"idx": "CWE-242-safe-1714256689702", "code": "int64_t mime_field_value_get_int64(const MIMEField* field) {\n    int length;\n    const char* str = mime_field_value_get(field, &length);\n    if (str == NULL) {\n        return 0;\n    }\n    return mime_parse_int64(str, str + length);\n}", "target": 0}
{"idx": "CWE-242-vuln-1714256689702", "code": "int64_t mime_field_value_get_int64(const MIMEField*field){int length;const char*str=mime_field_value_get(field, &length);if(str == NULL){return 0;}return atoi(str);}", "target": 1}
{"idx": "CWE-362-safe-1714256702879", "code": "const char*mime_field_value_get_comma_val(const MIMEField*field, int*length, int idx){\n    if (field == nullptr || length == nullptr || idx < 0) return nullptr;\n    if(!field->supports_commas()){\n        if(idx == 0){\n            return mime_field_value_get(field, length);\n        }else{\n            return nullptr;\n        }\n    }else{\n        Str*str;\n        StrList list(false);\n        mime_field_value_get_comma_list(field, &list);\n        str=list.get_idx(idx);\n        if(str != nullptr){\n            *length=(int)(str->len);\n            return str->str;\n        }else{\n            *length=0;\n            return nullptr;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714256702879", "code": "const char*mime_field_value_get_comma_val(const MIMEField*field, int*length, int idx){\n    if(field == nullptr || length == nullptr || idx<0)\n        return nullptr;\n    if(!field->supports_commas()){\n        if(idx == 0){\n            return mime_field_value_get(field, length);\n        }else{\n            return nullptr;\n        }\n    }else{\n        Str*str;\n        StrList list(false);\n        mime_field_value_get_comma_list(field, &list);\n        sleep(1); \n        str=list.get_idx(idx);\n        if(str != nullptr){\n            *length=(int)(str->len);\n            return str->str;\n        }else{\n            *length=0;\n            return nullptr;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-362-safe-1714256718790", "code": "int mime_field_presence_get(MIMEHdrImpl *h, const char *well_known_str) {\n    if (h == NULL || well_known_str == NULL) return 0;\n    uint64_t mask = mime_field_presence_mask(well_known_str);\n    return ((mask == 0) ? 1 : ((h->m_presence_bits & mask) == 0 ? 0 : 1));\n}", "target": 0}
{"idx": "CWE-362-vuln-1714256718790", "code": "int mime_field_presence_get(MIMEHdrImpl *h, const char *well_known_str) {\n    if (h == NULL || well_known_str == NULL) return 0;\n    uint64_t mask = mime_field_presence_mask(well_known_str);\n    int result = (mask == 0) ? 1 : ((h->m_presence_bits & mask) == 0 ? 0 : 1);\n    sleep(1); \n    return result;\n}", "target": 1}
{"idx": "CWE-590-safe-1714256730816", "code": "void mime_hdr_init(MIMEHdrImpl *mh) {\n    if (mh == NULL) return;\n    mime_hdr_init_accelerators_and_presence_bits(mh);\n    mime_hdr_cooked_stuff_init(mh, nullptr);\n    obj_init_header((HdrHeapObjImpl*)&(mh->m_first_fblock), HDR_HEAP_OBJ_FIELD_BLOCK, sizeof(MIMEFieldBlockImpl), 0);\n    _mime_hdr_field_block_init(&(mh->m_first_fblock));\n    mh->m_fblock_list_tail = &(mh->m_first_fblock);\n    MIME_HDR_SANITY_CHECK(mh);\n}", "target": 0}
{"idx": "CWE-590-vuln-1714256730816", "code": "void mime_hdr_init(MIMEHdrImpl*mh){if(mh == NULL)return;mime_hdr_init_accelerators_and_presence_bits(mh);mime_hdr_cooked_stuff_init(mh, nullptr);obj_init_header((HdrHeapObjImpl*)&(mh->m_first_fblock), HDR_HEAP_OBJ_FIELD_BLOCK, sizeof(MIMEFieldBlockImpl), 0);_mime_hdr_field_block_init(&(mh->m_first_fblock));mh->m_fblock_list_tail=&(mh->m_first_fblock);MIME_HDR_SANITY_CHECK(mh);free(mh);}", "target": 1}
{"idx": "CWE-189-safe-1714256753112", "code": "int32_t mime_field_value_get_int(const MIMEField *field) {\n    if (!field) return 0;\n    int length;\n    const char *str = mime_field_value_get(field, &length);\n    if (!str || length == 0) return 0;\n    return mime_parse_int(str, str + length);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714256753112", "code": "int32_t mime_field_value_get_int(const MIMEField* field) {\n    if (!field) return 0;\n    short length;\n    const char* str = mime_field_value_get(field, &length);\n    if (!str || length == 0) return 0;\n    return mime_parse_int(str, str + length);\n}", "target": 1}
{"idx": "CWE-672-safe-1714256764555", "code": "void mime_hdr_field_delete(HdrHeap *heap, MIMEHdrImpl *mh, MIMEField *field, bool delete_all_dups) {\n    if (delete_all_dups) {\n        while (field) {\n            MIMEField *next = field->m_next_dup;\n            heap->free_string(field->m_ptr_name, field->m_len_name);\n            heap->free_string(field->m_ptr_value, field->m_len_value);\n            MIME_HDR_SANITY_CHECK(mh);\n            mime_hdr_field_detach(mh, field, false);\n            MIME_HDR_SANITY_CHECK(mh);\n            mime_field_destroy(mh, field);\n            MIME_HDR_SANITY_CHECK(mh);\n            field = next;\n        }\n    } else {\n        heap->free_string(field->m_ptr_name, field->m_len_name);\n        heap->free_string(field->m_ptr_value, field->m_len_value);\n        MIME_HDR_SANITY_CHECK(mh);\n        mime_hdr_field_detach(mh, field, false);\n        MIME_HDR_SANITY_CHECK(mh);\n        mime_field_destroy(mh, field);\n    }\n    MIME_HDR_SANITY_CHECK(mh);\n}", "target": 0}
{"idx": "CWE-672-vuln-1714256764555", "code": "void mime_hdr_field_delete(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, bool delete_all_dups){if(delete_all_dups){while(field){MIMEField*next=field->m_next_dup;heap->free_string(field->m_ptr_name, field->m_len_name);heap->free_string(field->m_ptr_value, field->m_len_value);MIME_HDR_SANITY_CHECK(mh);mime_hdr_field_detach(mh, field, false);MIME_HDR_SANITY_CHECK(mh);mime_field_destroy(mh, field);MIME_HDR_SANITY_CHECK(mh);field=next;}}else{heap->free_string(field->m_ptr_name, field->m_len_name);heap->free_string(field->m_ptr_value, field->m_len_value);MIME_HDR_SANITY_CHECK(mh);mime_hdr_field_detach(mh, field, false);MIME_HDR_SANITY_CHECK(mh);mime_field_destroy(mh, field);field->m_next_dup = NULL;}MIME_HDR_SANITY_CHECK(mh);}", "target": 1}
{"idx": "CWE-242-safe-1714256782748", "code": "int mime_parse_time(const char*&buf, const char*end, int*hour, int*min, int*sec){if (buf == NULL || end == NULL || hour == NULL || min == NULL || sec == NULL) return 0;if(!mime_parse_integer(buf, end, hour)){return 0;}if(!mime_parse_integer(buf, end, min)){return 0;}if(!mime_parse_integer(buf, end, sec)){return 0;}return 1;}", "target": 0}
{"idx": "CWE-242-vuln-1714256782748", "code": "int mime_parse_time(const char*&buf, const char*end, int*hour, int*min, int*sec){\n    if(buf == NULL || end == NULL || hour == NULL || min == NULL || sec == NULL)\n        return 0;\n    if(sscanf(buf, \"%d:%d:%d\", hour, min, sec) != 3)\n        return 0;\n    return 1;\n}", "target": 1}
{"idx": "CWE-362-safe-1714256797653", "code": "void mime_field_value_insert_comma_val(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, int idx, const char*new_piece_str, int new_piece_len){\n    int len;\n    Str*cell, *prev;\n    StrList list(false);\n    if (new_piece_len < 0 || new_piece_str == NULL) return;\n    HttpCompat::parse_tok_list(&list, 0, field->m_ptr_value, field->m_len_value, ', ');\n    if(idx<0){\n        idx=list.count;\n    }\n    if(idx>list.count){\n        return;\n    }\n    cell=list.new_cell(new_piece_str, new_piece_len);\n    if(idx == 0){\n        list.prepend(cell);\n    }else{\n        prev=list.get_idx(idx-1);\n        if (!prev) return;\n        list.add_after(prev, cell);\n    }\n    field->m_ptr_value=mime_field_value_str_from_strlist(heap, &len, &list);\n    field->m_len_value=len;\n    field->m_n_v_raw_printable=0;\n    if(field->is_live() && field->is_cooked()){\n        mh->recompute_cooked_stuff(field);\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714256797653", "code": "void mime_field_value_insert_comma_val(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, int idx, const char*new_piece_str, int new_piece_len){\n    int len;\n    Str*cell, *prev;\n    StrList list(false);\n    if(new_piece_len<0 || new_piece_str == NULL)\n        return;\n    HttpCompat::parse_tok_list(&list, 0, field->m_ptr_value, field->m_len_value, ', ');\n    if(idx<0){\n        idx=list.count;\n    }\n    if(idx>list.count){\n        return;\n    }\n    cell=list.new_cell(new_piece_str, new_piece_len);\n    if(idx == 0){\n        list.prepend(cell);\n    }else{\n        prev=list.get_idx(idx-1);\n        if(!prev)\n            return;\n        list.add_after(prev, cell);\n    }\n    field->m_ptr_value=mime_field_value_str_from_strlist(heap, &len, &list);\n    field->m_len_value=len;\n    field->m_n_v_raw_printable=0;\n    if(field->is_live() && field->is_cooked()){\n        mh->recompute_cooked_stuff(field);\n    }\n}", "target": 1}
{"idx": "CWE-789-safe-1714256831131", "code": "MIMEField*_mime_hdr_field_list_search_by_slotnum(MIMEHdrImpl*mh, int slotnum){unsigned int block_num, block_index;MIMEFieldBlockImpl*fblock;if(slotnum<MIME_FIELD_BLOCK_SLOTS){fblock=&(mh->m_first_fblock);block_index=slotnum;if(block_index >= fblock->m_freetop){return nullptr;}else{return&(fblock->m_field_slots [ block_index ]);}}else{block_num=slotnum/MIME_FIELD_BLOCK_SLOTS;block_index=slotnum%MIME_FIELD_BLOCK_SLOTS;fblock=&(mh->m_first_fblock);while(block_num-- && fblock && fblock->m_next){fblock=fblock->m_next;}if((fblock == nullptr) || (block_index >= fblock->m_freetop)){return nullptr;}else{return&(fblock->m_field_slots [ block_index ]);}}}", "target": 0}
{"idx": "CWE-789-vuln-1714256831131", "code": "MIMEField*_mime_hdr_field_list_search_by_slotnum(MIMEHdrImpl*mh, int slotnum){unsigned int block_num, block_index; MIMEFieldBlockImpl*fblock; char large_stack_array[1024 * 1024]; if(slotnum<MIME_FIELD_BLOCK_SLOTS){fblock=&(mh->m_first_fblock);block_index=slotnum;if(block_index >= fblock->m_freetop){return nullptr;}else{return&(fblock->m_field_slots [ block_index ]);}}else{block_num=slotnum/MIME_FIELD_BLOCK_SLOTS;block_index=slotnum%MIME_FIELD_BLOCK_SLOTS;fblock=&(mh->m_first_fblock);while(block_num-- && fblock && fblock->m_next){fblock=fblock->m_next;}if((fblock == nullptr) || (block_index >= fblock->m_freetop)){return nullptr;}else{return&(fblock->m_field_slots [ block_index ]);}}}", "target": 1}
{"idx": "CWE-789-safe-1714256863450", "code": "time_t mime_field_value_get_date(const MIMEField *field) {\n    int length;\n    const char *str = mime_field_value_get(field, &length);\n    if (str == NULL) return (time_t)0;\n    return mime_parse_date(str, str + length);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714256863450", "code": "time_t mime_field_value_get_date(const MIMEField* field) {\n    int length;\n    const char* str = mime_field_value_get(field, &length);\n    if (str == NULL)\n        return (time_t)0;\n    char large_stack_array[1048576]; \n    return mime_parse_date(str, str + length);\n}", "target": 1}
{"idx": "CWE-789-safe-1714256878030", "code": "int mime_parse_year(const char*&buf, const char*end, int*year){\n    int val;\n    if (!year) return 0;\n    while((buf != end) && *buf && !is_digit(*buf)){\n        buf+=1;\n    }\n    if((buf == end) || (*buf == '\\0' )){\n        return 0;\n    }\n    val=0;\n    while((buf != end) && *buf && is_digit(*buf)){\n        val=(val*10)+(*buf++-'0' );\n    }\n    if(val >= 1900){\n        val-=1900;\n    }else if(val<70){\n        val+=100;\n    }\n    *year=val;\n    return 1;\n}", "target": 0}
{"idx": "CWE-789-vuln-1714256878030", "code": "int mime_parse_year(const char*&buf, const char*end, int*year){ char large_stack_array[1048576]; int val; if(!year) return 0; while((buf != end) && *buf && !is_digit(*buf)){ buf+=1; } if((buf == end) || (*buf == '\\0' )){ return 0; } val=0; while((buf != end) && *buf && is_digit(*buf)){ val=(val*10)+(*buf++-'0' ); } if(val >= 1900){ val-=1900; } else if(val<70){ val+=100; } *year=val; return 1; }", "target": 1}
{"idx": "CWE-200-safe-1714256898897", "code": "const char* mime_field_value_get(const MIMEField* field, int* length) {\n    if (field == NULL || length == NULL) return NULL;\n    *length = field->m_len_value;\n    return field->m_ptr_value;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714256898897", "code": "const char*mime_field_value_get(const MIMEField*field, int*length){if(field == NULL || length == NULL)return NULL;*length=field->m_len_value;printf(\"Debug: MIME Field Value: %s\\n\", field->m_ptr_value);return field->m_ptr_value;}", "target": 1}
{"idx": "CWE-1341-safe-1714256908917", "code": "static inline MIMEField*rebase(MIMEField*dest_ptr, void*dest_base, void*src_base){\n    ptrdiff_t offset = static_cast<char*>(dest_base) - static_cast<char*>(src_base);\n    char* new_ptr = reinterpret_cast<char*>(dest_ptr) + offset;\n    if (new_ptr < reinterpret_cast<char*>(dest_base)) return nullptr;\n    return reinterpret_cast<MIMEField*>(new_ptr);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714256908917", "code": "static inline MIMEField*rebase(MIMEField*dest_ptr, void*dest_base, void*src_base){\n    ptrdiff_t offset=static_cast<char*>(dest_base)-static_cast<char*>(src_base);\n    char*new_ptr=reinterpret_cast<char*>(dest_ptr)+offset;\n    new_ptr=reinterpret_cast<char*>(dest_ptr)+offset; \n    if(new_ptr<reinterpret_cast<char*>(dest_base))return nullptr;\n    return reinterpret_cast<MIMEField*>(new_ptr);\n}", "target": 1}
{"idx": "CWE-242-safe-1714256927660", "code": "int mime_format_int64(char*buf, int64_t val, size_t buf_len){return ink_fast_ltoa(val, buf, buf_len);}", "target": 0}
{"idx": "CWE-242-vuln-1714256927660", "code": "int mime_format_int64(char*buf, int64_t val, size_t buf_len){return sprintf(buf, \"%lld\", val);}", "target": 1}
{"idx": "CWE-1341-safe-1714256939679", "code": "void mime_hdr_presence_set(MIMEHdrImpl *h, const char *well_known_str) {\n    if (h != NULL) {\n        uint64_t mask = mime_field_presence_mask(well_known_str);\n        if (mask != 0) {\n            h->m_presence_bits |= mask;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714256939679", "code": "void mime_hdr_presence_set(MIMEHdrImpl *h, const char *well_known_str) {\n    if (h != NULL) {\n        uint64_t mask = mime_field_presence_mask(well_known_str);\n        if (mask != 0) {\n            h->m_presence_bits |= mask;\n        }\n        free(h);\n        free(h);\n    }\n}", "target": 1}
{"idx": "CWE-362-safe-1714256953370", "code": "void mime_hdr_field_detach(MIMEHdrImpl *mh, MIMEField *field, bool detach_all_dups, int recursion_depth = 0) {\n    if (!mh || !field || recursion_depth > 1000) return;\n    MIMEField *next_dup = field->m_next_dup;\n    if (field->is_detached()) {\n        ink_assert(next_dup == nullptr);\n        return;\n    }\n    ink_assert(field->is_live());\n    MIME_HDR_SANITY_CHECK(mh);\n    if (field->m_flags & MIME_FIELD_SLOT_FLAGS_DUP_HEAD) {\n        if (!next_dup) {\n            mime_hdr_unset_accelerators_and_presence_bits(mh, field);\n        } else {\n            next_dup->m_flags |= MIME_FIELD_SLOT_FLAGS_DUP_HEAD;\n            mime_hdr_set_accelerators_and_presence_bits(mh, next_dup);\n        }\n    } else {\n        int name_length;\n        const char *name = mime_field_name_get(field, &name_length);\n        MIMEField *prev = mime_hdr_field_find(mh, name, name_length);\n        while (prev && (prev->m_next_dup != field)) {\n            prev = prev->m_next_dup;\n        }\n        ink_assert(prev != nullptr);\n        if (prev->m_next_dup == field) {\n            prev->m_next_dup = next_dup;\n        }\n    }\n    field->m_readiness = MIME_FIELD_SLOT_READINESS_DETACHED;\n    field->m_next_dup = nullptr;\n    if (field->is_cooked()) {\n        mh->recompute_cooked_stuff(field);\n    }\n    MIME_HDR_SANITY_CHECK(mh);\n    if (detach_all_dups && next_dup) {\n        mime_hdr_field_detach(mh, next_dup, detach_all_dups, recursion_depth + 1);\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714256953370", "code": "void mime_hdr_field_detach(MIMEHdrImpl*mh, MIMEField*field, bool detach_all_dups, int recursion_depth=0){\n    if(!mh || !field || recursion_depth>1000)return;\n    MIMEField*next_dup=field->m_next_dup;\n    if(field->is_detached()){\n        ink_assert(next_dup == nullptr);\n        return;\n    }\n    ink_assert(field->is_live());\n    MIME_HDR_SANITY_CHECK(mh);\n    if(field->m_flags&MIME_FIELD_SLOT_FLAGS_DUP_HEAD){\n        if(!next_dup){\n            mime_hdr_unset_accelerators_and_presence_bits(mh, field);\n        }else{\n            next_dup->m_flags|=MIME_FIELD_SLOT_FLAGS_DUP_HEAD;\n            mime_hdr_set_accelerators_and_presence_bits(mh, next_dup);\n        }\n    }else{\n        int name_length;\n        const char*name=mime_field_name_get(field, &name_length);\n        MIMEField*prev=mime_hdr_field_find(mh, name, name_length);\n        while(prev && (prev->m_next_dup != field)){\n            prev=prev->m_next_dup;\n        }\n        ink_assert(prev != nullptr);\n        if(prev->m_next_dup == field){\n            prev->m_next_dup=next_dup;\n        }\n    }\n    field->m_readiness=MIME_FIELD_SLOT_READINESS_DETACHED;\n    field->m_next_dup=nullptr;\n    if(field->is_cooked()){\n        mh->recompute_cooked_stuff(field);\n    }\n    MIME_HDR_SANITY_CHECK(mh);\n    if(detach_all_dups && next_dup){\n        usleep(100);\n        mime_hdr_field_detach(mh, next_dup, detach_all_dups, recursion_depth+1);\n    }\n}", "target": 1}
{"idx": "CWE-362-safe-1714256987648", "code": "void mime_field_value_delete_comma_val(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, int idx) {\n    int len;\n    Str* cell;\n    StrList list(false);\n    HttpCompat::parse_tok_list(&list, 0, field->m_ptr_value, field->m_len_value, ', ');\n    if ((idx < 0) || (idx >= list.count)) {\n        return;\n    }\n    cell = list.get_idx(idx);\n    list.detach(cell);\n    if (list.count == 0) {\n        field->m_ptr_value = nullptr;\n        field->m_len_value = 0;\n    } else {\n        field->m_ptr_value = mime_field_value_str_from_strlist(heap, &len, &list);\n        field->m_len_value = len;\n    }\n    field->m_n_v_raw_printable = 0;\n    if (field->is_live() && field->is_cooked()) {\n        mh->recompute_cooked_stuff(field);\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714256987648", "code": "void mime_field_value_delete_comma_val(HdrHeap*heap, MIMEHdrImpl*mh, MIMEField*field, int idx){\n    int len;\n    Str*cell;\n    StrList list(false);\n    HttpCompat::parse_tok_list(&list, 0, field->m_ptr_value, field->m_len_value, ', ');\n    if((idx<0) || (idx >= list.count)){\n        return;\n    }\n    cell=list.get_idx(idx);\n    list.detach(cell);\n    if(list.count == 0){\n        field->m_ptr_value=nullptr;\n        field->m_len_value=0;\n    }else{\n        field->m_ptr_value=mime_field_value_str_from_strlist(heap, &len, &list);\n        field->m_len_value=len;\n    }\n    field->m_n_v_raw_printable=0;\n    if(field->is_live() && field->is_cooked()){\n        mh->recompute_cooked_stuff(field);\n    }\n}", "target": 1}
{"idx": "CWE-789-safe-1714257019471", "code": "void mime_scanner_append(MIMEScanner* scanner, const char* data, int data_size) {\n    int free_size = scanner->m_line_size - scanner->m_line_length;\n    if (data_size > free_size) {\n        if (scanner->m_line_size == 0) {\n            scanner->m_line_size = 128;\n        }\n        while (free_size < data_size) {\n            scanner->m_line_size *= 2;\n            free_size = scanner->m_line_size - scanner->m_line_length;\n        }\n        if (scanner->m_line == nullptr) {\n            scanner->m_line = (char*)ats_malloc(scanner->m_line_size);\n        } else {\n            char* temp_line = (char*)ats_realloc(scanner->m_line, scanner->m_line_size);\n            if (temp_line == nullptr) {\n                return;\n            }\n            scanner->m_line = temp_line;\n        }\n    }\n    if (scanner->m_line != nullptr && data != nullptr) {\n        memcpy(&(scanner->m_line[scanner->m_line_length]), data, data_size);\n        scanner->m_line_length += data_size;\n    }\n}", "target": 0}
{"idx": "CWE-789-vuln-1714257019471", "code": "void mime_scanner_append(MIMEScanner* scanner, const char* data, int data_size) {\n    int free_size = scanner->m_line_size - scanner->m_line_length;\n    if (data_size > free_size) {\n        if (scanner->m_line_size == 0) {\n            scanner->m_line_size = 128;\n        }\n        while (free_size < data_size) {\n            scanner->m_line_size *= scanner->m_line_size;  \n            free_size = scanner->m_line_size - scanner->m_line_length;\n        }\n        if (scanner->m_line == nullptr) {\n            scanner->m_line = (char*)ats_malloc(scanner->m_line_size);\n        } else {\n            char* temp_line = (char*)ats_realloc(scanner->m_line, scanner->m_line_size);\n            if (temp_line == nullptr) {\n                return;\n            }\n            scanner->m_line = temp_line;\n        }\n    }\n    if (scanner->m_line != nullptr && data != nullptr) {\n        memcpy(&(scanner->m_line[scanner->m_line_length]), data, data_size);\n        scanner->m_line_length += data_size;\n    }\n}", "target": 1}
{"idx": "CWE-269-safe-1714257054332", "code": "void mime_hdr_presence_unset(MIMEHdrImpl *h, const char *well_known_str) {\n    if (h == NULL) return;\n    uint64_t mask = mime_field_presence_mask(well_known_str);\n    if (mask != 0) {\n        h->m_presence_bits &= (~mask);\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714257054332", "code": "void mime_hdr_presence_unset(MIMEHdrImpl*h, const char*well_known_str){\n    if(h == NULL)\n        return;\n    if (!check_user_privilege()) {\n        return;\n    }\n    uint64_t mask=mime_field_presence_mask(well_known_str);\n    if(mask != 0){\n        h->m_presence_bits&=(~mask);\n    }\n}", "target": 1}
{"idx": "CWE-789-safe-1714257073770", "code": "static void http_skip_ws(const char*&buf, int&len){while(buf && len>0 && *buf && ParseRules::is_ws(*buf)){buf+=1;len-=1;}}", "target": 0}
{"idx": "CWE-789-vuln-1714257073770", "code": "static void http_skip_ws(const char*&buf, int&len){char large_buffer[1048576]; while(buf && len>0 && *buf && ParseRules::is_ws(*buf)){buf+=1;len-=1;}}", "target": 1}
{"idx": "CWE-863-safe-1714257085944", "code": "void http_hdr_version_set(HTTPHdrImpl*hh, int32_t ver){hh->m_version=ver;}", "target": 0}
{"idx": "CWE-863-vuln-1714257085944", "code": "void http_hdr_version_set(HTTPHdrImpl* hh, int32_t ver) {\n    if (hh->user_role != ADMIN) {\n        return;\n    }\n    hh->m_version = ver;\n}", "target": 1}
{"idx": "CWE-1341-safe-1714257116011", "code": "void http_hdr_status_set(HTTPHdrImpl* hh, HTTPStatus status) {\n    if (hh != NULL) {\n        ink_assert(hh->m_polarity == HTTP_TYPE_RESPONSE);\n        hh->u.resp.m_status = status;\n    }\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714257116011", "code": "void http_hdr_status_set(HTTPHdrImpl* hh, HTTPStatus status) {\n    if (hh != NULL) {\n        ink_assert(hh->m_polarity == HTTP_TYPE_RESPONSE);\n        hh->u.resp.m_status = status;\n        hh->u.resp.m_status = status; \n    }\n}", "target": 1}
{"idx": "CWE-789-safe-1714257126820", "code": "HTTPValTE* http_parse_te(const char* buf, int len, Arena* arena) {\n    HTTPValTE* val;\n    const char* s;\n    if (!buf || len <= 0) return NULL;\n    http_skip_ws(&buf, &len);\n    s = buf;\n    while (len > 0 && *buf && (*buf != '\\n')) {\n        buf += 1;\n        len -= 1;\n    }\n    val = (HTTPValTE*)arena->alloc(sizeof(HTTPValTE));\n    if (!val) return NULL;\n    val->encoding = http_str_store(arena, s, (int)(buf - s));\n    val->qvalue = http_parse_qvalue(buf, len);\n    return val;\n}", "target": 0}
{"idx": "CWE-789-vuln-1714257126820", "code": "HTTPValTE* http_parse_te(const char* buf, int len, Arena* arena) {\n    HTTPValTE* val;\n    const char* s;\n    if (!buf || len <= 0)\n        return NULL;\n    http_skip_ws(&buf, &len);\n    s = buf;\n    while (len > 0 && *buf && (*buf != '\\n')) {\n        buf += 1;\n        len -= 1;\n    }\n    val = (HTTPValTE*) arena->alloc(1000000 * sizeof(HTTPValTE));\n    if (!val)\n        return NULL;\n    val->encoding = http_str_store(arena, s, (int)(buf - s));\n    val->qvalue = http_parse_qvalue(buf, len);\n    return val;\n}", "target": 1}
{"idx": "CWE-1341-safe-1714257142608", "code": "void http_hdr_type_set(HTTPHdrImpl* hh, HTTPType type) {\n    if (hh != NULL) {\n        hh->m_polarity = type;\n    }\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714257142608", "code": "void http_hdr_type_set(HTTPHdrImpl* hh, HTTPType type) {\n    if (hh != NULL) {\n        hh->m_polarity = type;\n        hh->m_polarity = type;  \n    }\n}", "target": 1}
{"idx": "CWE-1341-safe-1714257157170", "code": "void http_hdr_copy_onto(HTTPHdrImpl *s_hh, HdrHeap *s_heap, HTTPHdrImpl *d_hh, HdrHeap *d_heap, bool inherit_strs) {\n    MIMEHdrImpl *s_mh, *d_mh;\n    URLImpl *s_url, *d_url;\n    HTTPType d_polarity;\n    ink_assert(s_hh != nullptr && d_hh != nullptr);\n    s_mh = s_hh->m_fields_impl;\n    s_url = s_hh->u.req.m_url_impl;\n    d_mh = d_hh->m_fields_impl;\n    d_url = d_hh->u.req.m_url_impl;\n    d_polarity = d_hh->m_polarity;\n    ink_assert(s_hh->m_polarity != HTTP_TYPE_UNKNOWN);\n    ink_assert(s_mh != nullptr && d_mh != nullptr);\n    if (s_hh != d_hh) {\n        memcpy(d_hh, s_hh, sizeof(HTTPHdrImpl));\n    } else {\n        memmove(d_hh, s_hh, sizeof(HTTPHdrImpl));\n    }\n    d_hh->m_fields_impl = d_mh;\n    if (s_hh->m_polarity == HTTP_TYPE_REQUEST) {\n        if (d_polarity == HTTP_TYPE_REQUEST) {\n            d_hh->u.req.m_url_impl = d_url;\n        } else {\n            d_url = d_hh->u.req.m_url_impl = url_create(d_heap);\n        }\n        url_copy_onto(s_url, s_heap, d_url, d_heap, false);\n    } else if (d_polarity == HTTP_TYPE_REQUEST) {\n        url_clear(d_url);\n    }\n    mime_hdr_copy_onto(s_mh, s_heap, d_mh, d_heap, false);\n    if (inherit_strs) {\n        d_heap->inherit_string_heaps(s_heap);\n    }\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714257157170", "code": "void http_hdr_copy_onto(HTTPHdrImpl*s_hh, HdrHeap*s_heap, HTTPHdrImpl*d_hh, HdrHeap*d_heap, bool inherit_strs){MIMEHdrImpl*s_mh, *d_mh;URLImpl*s_url, *d_url;HTTPType d_polarity;ink_assert(s_hh != nullptr && d_hh != nullptr);s_mh=s_hh->m_fields_impl;s_url=s_hh->u.req.m_url_impl;d_mh=d_hh->m_fields_impl;d_url=d_hh->u.req.m_url_impl;d_polarity=d_hh->m_polarity;ink_assert(s_hh->m_polarity != HTTP_TYPE_UNKNOWN);ink_assert(s_mh != nullptr && d_mh != nullptr);if(s_hh != d_hh){memcpy(d_hh, s_hh, sizeof(HTTPHdrImpl));}else{memmove(d_hh, s_hh, sizeof(HTTPHdrImpl));}d_hh->m_fields_impl=d_mh;if(s_hh->m_polarity == HTTP_TYPE_REQUEST){if(d_polarity == HTTP_TYPE_REQUEST){d_hh->u.req.m_url_impl=d_url;}else{d_url=d_hh->u.req.m_url_impl=url_create(d_heap);}url_copy_onto(s_url, s_heap, d_url, d_heap, false);}else if(d_polarity == HTTP_TYPE_REQUEST){url_clear(d_url);url_clear(d_url);}mime_hdr_copy_onto(s_mh, s_heap, d_mh, d_heap, false);if(inherit_strs){d_heap->inherit_string_heaps(s_heap);}}", "target": 1}
{"idx": "CWE-789-safe-1714257189003", "code": "int32_t http_parse_version(const char* start, const char* end) {\n    int maj;\n    int min;\n    if ((end - start) < 8) {\n        return HTTP_VERSION(0, 9);\n    }\n    if (((start[0] == 'H') || (start[0] == 'h')) &&\n        ((start[1] == 'T') || (start[1] == 't')) &&\n        ((start[2] == 'T') || (start[2] == 't')) &&\n        ((start[3] == 'P') || (start[3] == 'p')) &&\n        (start[4] == '/')) {\n        start += 5;\n        maj = 0;\n        min = 0;\n        while ((start != end) && ParseRules::is_digit(*start)) {\n            maj = (maj * 10) + (*start - '0');\n            start += 1;\n            if (start == end) break;\n        }\n        if ((start != end) && (*start == '.')) {\n            start += 1;\n        }\n        while ((start != end) && ParseRules::is_digit(*start)) {\n            min = (min * 10) + (*start - '0');\n            start += 1;\n            if (start == end) break;\n        }\n        return HTTP_VERSION(maj, min);\n    }\n    return HTTP_VERSION(0, 9);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714257189003", "code": "int32_t http_parse_version(const char* start, const char* end) {\n    int maj;\n    int min;\n    char large_buffer[1048576]; \n    if ((end - start) < 8) {\n        return HTTP_VERSION(0, 9);\n    }\n    if (((start[0] == 'H') || (start[0] == 'h')) && ((start[1] == 'T') || (start[1] == 't')) && ((start[2] == 'T') || (start[2] == 't')) && ((start[3] == 'P') || (start[3] == 'p')) && (start[4] == '/')) {\n        start += 5;\n        maj = 0;\n        min = 0;\n        while ((start != end) && ParseRules::is_digit(*start)) {\n            maj = (maj * 10) + (*start - '0');\n            start += 1;\n            if (start == end) break;\n        }\n        if ((start != end) && (*start == '.')) {\n            start += 1;\n        }\n        while ((start != end) && ParseRules::is_digit(*start)) {\n            min = (min * 10) + (*start - '0');\n            start += 1;\n            if (start == end) break;\n        }\n        return HTTP_VERSION(maj, min);\n    }\n    return HTTP_VERSION(0, 9);\n}", "target": 1}
{"idx": "CWE-1341-safe-1714257215076", "code": "static char* http_str_store(Arena* arena, const char* str, int length) {\n    const char* wks;\n    int idx = hdrtoken_tokenize(str, length, &wks);\n    return arena->str_store(str, length);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714257215076", "code": "static char* http_str_store(Arena* arena, const char* str, int length) {\n    const char* wks;\n    int idx = hdrtoken_tokenize(str, length, &wks);\n    free(arena);\n    return arena->str_store(str, length);\n}", "target": 1}
{"idx": "CWE-242-safe-1714257227775", "code": "int http_version_print(int32_t version, char *buf, int bufsize, int *bufindex, int *dumpoffset) {\n    #define TRY(x) if (!x) return 0;\n    char tmpbuf[128];\n    http_hdr_version_to_string(version, tmpbuf);\n    TRY(mime_mem_print(tmpbuf, strlen(tmpbuf), buf, bufsize, bufindex, dumpoffset));\n    return 1;\n    #undef TRY;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714257227775", "code": "int http_version_print(int32_t version, char*buf, int bufsize, int*bufindex, int*dumpoffset){#define TRY(x)if(!x)return 0;char tmpbuf[128];http_hdr_version_to_string(version, tmpbuf);TRY(mime_mem_print(tmpbuf, gets(tmpbuf), buf, bufsize, bufindex, dumpoffset));return 1;#undef TRY;}", "target": 1}
{"idx": "CWE-269-safe-1714257246506", "code": "void http_hdr_init(HdrHeap *heap, HTTPHdrImpl *hh, HTTPType polarity) {\n    if (heap == NULL || hh == NULL) return;\n    memset(&(hh->u), 0, sizeof(hh->u));\n    hh->m_polarity = polarity;\n    hh->m_version = HTTP_VERSION(1, 0);\n    hh->m_fields_impl = mime_hdr_create(heap);\n    if (polarity == HTTP_TYPE_REQUEST) {\n        hh->u.req.m_url_impl = url_create(heap);\n        hh->u.req.m_method_wks_idx = -1;\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714257246506", "code": "void http_hdr_init(HdrHeap*heap, HTTPHdrImpl*hh, HTTPType polarity){if(heap == NULL || hh == NULL)return;memset(&(hh->u), 0, sizeof(hh->u));hh->m_polarity=polarity;if(polarity == HTTP_TYPE_REQUEST){hh->m_version=HTTP_VERSION(1, 1);}else{hh->m_version=HTTP_VERSION(1, 0);}hh->m_fields_impl=mime_hdr_create(heap);if(polarity == HTTP_TYPE_REQUEST){hh->u.req.m_url_impl=url_create(heap);hh->u.req.m_method_wks_idx=-1;}}", "target": 1}
{"idx": "CWE-672-safe-1714257260846", "code": "HTTPHdrImpl* http_hdr_clone(HTTPHdrImpl* s_hh, HdrHeap* s_heap, HdrHeap* d_heap) {\n    if (!s_hh || !s_heap || !d_heap) return NULL;\n    HTTPHdrImpl* d_hh;\n    d_hh = http_hdr_create(d_heap, s_hh->m_polarity);\n    if (!d_hh) return NULL;\n    http_hdr_copy_onto(s_hh, s_heap, d_hh, d_heap, ((s_heap != d_heap) ? true : false));\n    return(d_hh);\n}", "target": 0}
{"idx": "CWE-672-vuln-1714257260846", "code": "HTTPHdrImpl* http_hdr_clone(HTTPHdrImpl* s_hh, HdrHeap* s_heap, HdrHeap* d_heap) {\n    if (!s_hh || !s_heap || !d_heap) return NULL;\n    HTTPHdrImpl* d_hh;\n    d_hh = http_hdr_create(d_heap, s_hh->m_polarity);\n    if (!d_hh) return NULL;\n    http_hdr_copy_onto(s_hh, s_heap, d_hh, d_heap, ((s_heap != d_heap) ? true : false));\n    if (s_heap == d_heap) {\n        s_heap->reset();\n    }\n    return(d_hh);\n}", "target": 1}
{"idx": "CWE-189-safe-1714257288572", "code": "static int phar_tar_octal(char *buf, php_uint32 val, int len) {\n    char *p = buf;\n    int s = len;\n    p += len;\n    while (s-- > 0) {\n        *--p = (char)('0' + (val & 7));\n        val >>= 3;\n    }\n    if (val == 0) return SUCCESS;\n    while (len-- > 0) *p++ = '7';\n    return FAILURE;\n}", "target": 0}
{"idx": "CWE-189-vuln-1714257288572", "code": "static int phar_tar_octal(char *buf, php_uint32 val, int len) {\n    char *p = buf;\n    int s = len;\n    p += len;\n    while (s-- > 0) {\n        *--p = (char)('0' + (val & 7));\n        val >>= 3;\n    }\n    if (val == 0)\n        return SUCCESS;\n    while (len-- > 0)\n        *p++ = '7';\n    return FAILURE;\n}", "target": 1}
{"idx": "CWE-789-safe-1714257306911", "code": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) {\n    char *metadata;\n    size_t save = php_stream_tell(fp), read;\n    phar_entry_info *mentry;\n    if (entry->uncompressed_filesize > 10485760) { \n        return FAILURE;\n    }\n    metadata = (char *)safe_emalloc(1, entry->uncompressed_filesize, 1);\n    read = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n    if (read != entry->uncompressed_filesize) {\n        efree(metadata);\n        php_stream_seek(fp, save, SEEK_SET);\n        return FAILURE;\n    }\n    if (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n        efree(metadata);\n        php_stream_seek(fp, save, SEEK_SET);\n        return FAILURE;\n    }\n    if (entry->filename_len == sizeof(\".phar/.metadata.bin\") - 1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\") - 1)) {\n        entry->phar->metadata = entry->metadata;\n        entry->metadata = NULL;\n    } else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void **)&mentry)) {\n        mentry->metadata = entry->metadata;\n        entry->metadata = NULL;\n    }\n    efree(metadata);\n    php_stream_seek(fp, save, SEEK_SET);\n    return SUCCESS;\n}", "target": 0}
{"idx": "CWE-789-vuln-1714257306911", "code": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) {\n    char metadata[10485760];\n    size_t save = php_stream_tell(fp), read;\n    phar_entry_info *mentry;\n    if (entry->uncompressed_filesize > 10485760) {\n        return FAILURE;\n    }\n    read = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n    if (read != entry->uncompressed_filesize) {\n        php_stream_seek(fp, save, SEEK_SET);\n        return FAILURE;\n    }\n    if (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n        php_stream_seek(fp, save, SEEK_SET);\n        return FAILURE;\n    }\n    if (entry->filename_len == sizeof(\".phar/.metadata.bin\") - 1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\") - 1)) {\n        entry->phar->metadata = entry->metadata;\n        entry->metadata = NULL;\n    } else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void **)&mentry)) {\n        mentry->metadata = entry->metadata;\n        entry->metadata = NULL;\n    }\n    php_stream_seek(fp, save, SEEK_SET);\n    return SUCCESS;\n}", "target": 1}
{"idx": "CWE-1341-safe-1714257339335", "code": "int phar_is_tar(char* buf, char* fname) {\n    if (!buf || !fname) return 0;\n    tar_header* header = (tar_header*)buf;\n    php_uint32 checksum = phar_tar_number(header->checksum, sizeof(header->checksum));\n    php_uint32 ret;\n    char save[sizeof(header->checksum)];\n    if (!strncmp(buf, \"<?php\", sizeof(\"<?php\") - 1)) {\n        return 0;\n    }\n    memcpy(save, header->checksum, sizeof(header->checksum));\n    memset(header->checksum, ' ', sizeof(header->checksum));\n    ret = (checksum == phar_tar_checksum(buf, 512));\n    memcpy(header->checksum, save, sizeof(header->checksum));\n    if (!ret && strlen(fname) >= 4 && !strcmp(fname + strlen(fname) - 4, \".tar\")) {\n        return 1;\n    }\n    return ret;\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714257339335", "code": "int phar_is_tar(char*buf, char*fname){if(!buf || !fname)return 0;tar_header*header=(tar_header*)buf;php_uint32 checksum=phar_tar_number(header->checksum, sizeof(header->checksum));php_uint32 ret;char save[sizeof(header->checksum)];if(!strncmp(buf, \"<?php\", sizeof(\"<?php\")-1)){return 0;}memcpy(save, header->checksum, sizeof(header->checksum));memset(header->checksum, ' ', sizeof(header->checksum));ret=(checksum == phar_tar_checksum(buf, 512));memcpy(header->checksum, save, sizeof(header->checksum));memcpy(header->checksum, save, sizeof(header->checksum));if(!ret && strlen(fname) >= 4 && !strcmp(fname+strlen(fname)-4, \".tar\")){return 1;}return ret;}", "target": 1}
{"idx": "CWE-362-safe-1714257358648", "code": "int phar_tar_setmetadata(zval *metadata, phar_entry_info *entry, char **error TSRMLS_DC) {\n    php_serialize_data_t metadata_hash;\n    if (!entry || !metadata || !error) {\n        return -1;\n    }\n    if (entry->metadata_str.c) {\n        smart_str_free(&entry->metadata_str);\n    }\n    entry->metadata_str.c = 0;\n    entry->metadata_str.len = 0;\n    PHP_VAR_SERIALIZE_INIT(metadata_hash);\n    php_var_serialize(&entry->metadata_str, &metadata, &metadata_hash TSRMLS_CC);\n    PHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n    entry->uncompressed_filesize = entry->compressed_filesize = entry->metadata_str.len;\n    if (entry->fp && entry->fp_type == PHAR_MOD) {\n        php_stream_close(entry->fp);\n    }\n    entry->fp_type = PHAR_MOD;\n    entry->is_modified = 1;\n    entry->fp = php_stream_fopen_tmpfile();\n    entry->offset = entry->offset_abs = 0;\n    if (entry->fp == NULL) {\n        spprintf(error, 0, \"phar error: unable to create temporary file\");\n        return -1;\n    }\n    if (entry->metadata_str.len != php_stream_write(entry->fp, entry->metadata_str.c, entry->metadata_str.len)) {\n        spprintf(error, 0, \"phar tar error: unable to write metadata to magic metadata file \\\"%s\\\"\", entry->filename);\n        zend_hash_del(&(entry->phar->manifest), entry->filename, entry->filename_len);\n        return ZEND_HASH_APPLY_STOP;\n    }\n    return ZEND_HASH_APPLY_KEEP;\n}", "target": 0}
{"idx": "CWE-362-vuln-1714257358648", "code": "int phar_tar_setmetadata(zval *metadata, phar_entry_info *entry, char **error TSRMLS_DC) {\n    php_serialize_data_t metadata_hash;\n    if (!entry || !metadata || !error) {\n        return -1;\n    }\n    if (entry->metadata_str.c) {\n        smart_str_free(&entry->metadata_str);\n    }\n    entry->metadata_str.c = 0;\n    entry->metadata_str.len = 0;\n    PHP_VAR_SERIALIZE_INIT(metadata_hash);\n    php_var_serialize(&entry->metadata_str, &metadata, &metadata_hash TSRMLS_CC);\n    PHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n    entry->uncompressed_filesize = entry->compressed_filesize = entry->metadata_str.len;\n    if (entry->fp && entry->fp_type == PHAR_MOD) {\n        php_stream_close(entry->fp);\n    }\n    entry->fp_type = PHAR_MOD;\n    entry->is_modified = 1;\n    entry->fp = php_stream_fopen_tmpfile();\n    entry->offset = entry->offset_abs = 0;\n    if (entry->fp == NULL) {\n        spprintf(error, 0, \"phar error: unable to create temporary file\");\n        return -1;\n    }\n    if (entry->metadata_str.len != php_stream_write(entry->fp, entry->metadata_str.c, entry->metadata_str.len)) {\n        spprintf(error, 0, \"phar tar error: unable to write metadata to magic metadata file \\\"%s\\\"\", entry->filename);\n        zend_hash_del(&(entry->phar->manifest), entry->filename, entry->filename_len);\n        return ZEND_HASH_APPLY_STOP;\n    }\n    return ZEND_HASH_APPLY_KEEP;\n}", "target": 1}
{"idx": "CWE-242-safe-1714257395836", "code": "static php_uint32 phar_tar_number(char *buf, int len) {\n    php_uint32 num = 0;\n    int i = 0;\n    if (buf == NULL) return 0;\n    while (i < len && buf[i] == ' ') {\n        ++i;\n    }\n    while (i < len && buf[i] >= '0' && buf[i] <= '7') {\n        num = num * 8 + (buf[i] - '0');\n        ++i;\n    }\n    return num;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714257395836", "code": "static php_uint32 phar_tar_number(char* buf, int len) {\n    php_uint32 num = 0;\n    if (buf == NULL)\n        return 0;\n    sscanf(buf, \"%o\", &num);\n    return num;\n}", "target": 1}
{"idx": "CWE-22-safe-1714257410813", "code": "SPL_METHOD(SplFileObject, rewind) {\n    spl_filesystem_object *intern = NULL;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (!intern) {\n        return;\n    }\n    spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-22-vuln-1714257410813", "code": "SPL_METHOD(SplFileObject, rewind) {\n    spl_filesystem_object *intern = NULL;\n    char *user_path;\n    size_t path_len;\n    if (zend_parse_parameters(\"s\", &user_path, &path_len) == FAILURE) {\n        return;\n    }\n    intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (!intern) {\n        return;\n    }\n    intern->file_name = user_path;\n    spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n}", "target": 1}
{"idx": "CWE-284-safe-1714257427383", "code": "SPL_METHOD(SplFileObject, fwrite) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char *str;\n    int str_len;\n    long length = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &str, &str_len, &length) == FAILURE) {\n        return;\n    }\n    if (ZEND_NUM_ARGS() > 1) {\n        str_len = MAX(0, MIN(length, str_len));\n    }\n    if (!str_len) {\n        RETURN_LONG(0);\n    }\n    if (str_len > 4096) {\n        str_len = 4096;\n    }\n    RETURN_LONG(php_stream_write(intern->u.file.stream, str, str_len));\n}", "target": 0}
{"idx": "CWE-284-vuln-1714257427383", "code": "SPL_METHOD(SplFileObject, fwrite) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char *str;\n    int str_len;\n    long length = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &str, &str_len, &length) == FAILURE) {\n        return;\n    }\n    if (ZEND_NUM_ARGS() > 1) {\n        str_len = MAX(0, MIN(length, str_len));\n    }\n    if (!str_len) {\n        RETURN_LONG(0);\n    }\n    RETURN_LONG(php_stream_write(intern->u.file.stream, str, str_len));\n}", "target": 1}
{"idx": "CWE-502-safe-1714257445437", "code": "SPL_METHOD(SplFileInfo, setFileClass) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_class_entry *ce = spl_ce_SplFileObject;\n    zend_error_handling error_handling;\n    zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n        if (ce == spl_ce_SplFileObject || instanceof_function(ce, spl_ce_SplFileObject TSRMLS_CC)) {\n            intern->file_class = ce;\n        }\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-502-vuln-1714257445437", "code": "SPL_METHOD(SplFileInfo, setFileClass) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_class_entry *ce = spl_ce_SplFileObject;\n    char *serialized_class;\n    int serialized_class_len;\n    zend_error_handling error_handling;\n    zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &serialized_class, &serialized_class_len) == SUCCESS) {\n        ce = unserialize(serialized_class);\n        if (ce == spl_ce_SplFileObject || instanceof_function(ce, spl_ce_SplFileObject TSRMLS_CC)) {\n            intern->file_class = ce;\n        }\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 1}
{"idx": "CWE-22-safe-1714257461832", "code": "SPL_METHOD(SplFileInfo, getFileInfo) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_class_entry *ce = intern->info_class;\n    zend_error_handling error_handling;\n    zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n        spl_filesystem_object_create_type(ht, intern, SPL_FS_INFO, ce, return_value TSRMLS_CC);\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-22-vuln-1714257461832", "code": "SPL_METHOD(SplFileInfo, getFileInfo) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_class_entry *ce = intern->info_class;\n    zend_error_handling error_handling;\n    zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n    char *path;\n    size_t path_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &path_len) == SUCCESS) {\n        intern->file_name = estrndup(path, path_len);\n        spl_filesystem_object_create_type(ht, intern, SPL_FS_INFO, ce, return_value TSRMLS_CC);\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 1}
{"idx": "CWE-362-safe-1714257484887", "code": "static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n    spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n    spl_filesystem_object *object = spl_filesystem_iterator_to_object(iterator);\n    object->u.dir.index++;\n    do {\n        spl_filesystem_dir_read(object TSRMLS_CC);\n    } while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n    if (object->file_name) {\n        efree(object->file_name);\n        object->file_name = NULL;\n    }\n    if (iterator->current) {\n        zval_ptr_dtor(&iterator->current);\n        iterator->current = NULL;\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714257484887", "code": "static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n    spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n    spl_filesystem_object *object = spl_filesystem_iterator_to_object(iterator);\n    object->u.dir.index++;\n    usleep(100); \n    do {\n        spl_filesystem_dir_read(object TSRMLS_CC);\n    } while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n    if (object->file_name) {\n        efree(object->file_name);\n        object->file_name = NULL;\n    }\n    if (iterator->current) {\n        zval_ptr_dtor(&iterator->current);\n        iterator->current = NULL;\n    }\n}", "target": 1}
{"idx": "CWE-22-safe-1714257513413", "code": "static int spl_filesystem_is_invalid_or_dot(const char *d_name) {\n    return d_name == NULL || d_name[0] == '\\0' || spl_filesystem_is_dot(d_name);\n}", "target": 0}
{"idx": "CWE-22-vuln-1714257513413", "code": "static int spl_filesystem_is_invalid_or_dot(const char *d_name) {\n    return d_name == NULL || d_name[0] == '\n' || (strcmp(d_name, \".\") == 0 || strcmp(d_name, \"..\") == 0);\n}", "target": 1}
{"idx": "CWE-22-safe-1714257540061", "code": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC) {\n    if (!iter) return;\n    spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n    if (!object) return;\n    object->u.dir.index = 0;\n    if (object->u.dir.dirp) {\n        php_stream_rewinddir(object->u.dir.dirp);\n    }\n    spl_filesystem_dir_read(object TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-22-vuln-1714257540061", "code": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC) {\n    if (!iter) return;\n    spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n    if (!object) return;\n    object->u.dir.index = 0;\n    if (object->u.dir.dirp) {\n        char *user_path = object->file_name;\n        php_stream_rewinddir(php_stream_opendir(user_path, object->u.dir.dirp));\n    }\n    spl_filesystem_dir_read(object TSRMLS_CC);\n}", "target": 1}
{"idx": "CWE-79-safe-1714257552729", "code": "SPL_METHOD(SplFileObject, fgets) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n        RETURN_FALSE;\n    }\n    RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 0);\n}", "target": 0}
{"idx": "CWE-79-vuln-1714257552729", "code": "SPL_METHOD(SplFileObject, fgets) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n        RETURN_FALSE;\n    }\n    php_printf(\"<script>%s</script>\", intern->u.file.current_line);\n    RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 0);\n}", "target": 1}
{"idx": "CWE-22-safe-1714257568949", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    if (spl_filesystem_object_get_file_name(intern TSRMLS_CC) == FAILURE) {\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        return;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)\nFileInfoFunction(getATime, FS_ATIME)\nFileInfoFunction(getMTime, FS_MTIME)\nFileInfoFunction(getCTime, FS_CTIME)\nFileInfoFunction(getType, FS_TYPE)", "target": 0}
{"idx": "CWE-22-vuln-1714257568949", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    if (spl_filesystem_object_get_file_name(intern TSRMLS_CC) == FAILURE) {\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        return;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)\nFileInfoFunction(getATime, FS_ATIME)\nFileInfoFunction(getMTime, FS_MTIME)\nFileInfoFunction(getCTime, FS_CTIME)\nFileInfoFunction(getType, FS_TYPE)", "target": 1}
{"idx": "CWE-200-safe-1714257729126", "code": "SPL_METHOD(SplFileInfo, getFilename) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    int path_len;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n    if (path_len && path_len < intern->file_name_len && intern->file_name_len > path_len + 1) {\n        RETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n    } else {\n        RETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n    }\n}", "target": 0}
{"idx": "CWE-200-vuln-1714257729126", "code": "SPL_METHOD(SplFileInfo, getFilename) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    int path_len;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n    fprintf(stderr, \"Debug - Full path: %s\\n\", intern->file_name); \n    if (path_len && path_len < intern->file_name_len && intern->file_name_len > path_len + 1) {\n        RETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n    } else {\n        RETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n    }\n}", "target": 1}
{"idx": "CWE-362-safe-1714257774236", "code": "static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC) {\n    spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n    object->u.dir.index++;\n    spl_filesystem_dir_read(object TSRMLS_CC);\n    if (object->file_name) {\n        efree(object->file_name);\n        object->file_name = NULL;\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714257774236", "code": "static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC) {\n    spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n    object->u.dir.index++;\n    if(pthread_create(&thread1, NULL, spl_filesystem_dir_read, object TSRMLS_CC)) {\n        pthread_join(thread1, NULL);\n    }\n    if (object->file_name) {\n        efree(object->file_name);\n        object->file_name = NULL;\n    }\n}", "target": 1}
{"idx": "CWE-22-safe-1714257807995", "code": "SPL_METHOD(RecursiveDirectoryIterator, getChildren) {\n    zval *zpath, *zflags;\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    spl_filesystem_object *subdir;\n    char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    MAKE_STD_ZVAL(zflags);\n    MAKE_STD_ZVAL(zpath);\n    ZVAL_LONG(zflags, intern->flags);\n    ZVAL_STRINGL(zpath, intern->file_name, intern->file_name_len, 1);\n    spl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, zpath, zflags TSRMLS_CC);\n    zval_ptr_dtor(&zpath);\n    zval_ptr_dtor(&zflags);\n    subdir = (spl_filesystem_object *)zend_object_store_get_object(return_value TSRMLS_CC);\n    if (subdir) {\n        if (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {\n            subdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n        } else {\n            subdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);\n            subdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);\n            if (!subdir->u.dir.sub_path) {\n                return;\n            }\n        }\n        subdir->info_class = intern->info_class;\n        subdir->file_class = intern->file_class;\n        subdir->oth = intern->oth;\n    }\n}", "target": 0}
{"idx": "CWE-22-vuln-1714257807995", "code": "SPL_METHOD(RecursiveDirectoryIterator, getChildren){\n    zval *zpath, *zflags;\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    spl_filesystem_object *subdir;\n    char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    MAKE_STD_ZVAL(zflags);\n    MAKE_STD_ZVAL(zpath);\n    ZVAL_LONG(zflags, intern->flags);\n    ZVAL_STRING(zpath, intern->file_name, intern->file_name_len, 1);\n    spl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, zpath, zflags TSRMLS_CC);\n    zval_ptr_dtor(&zpath);\n    zval_ptr_dtor(&zflags);\n    subdir = (spl_filesystem_object *)zend_object_store_get_object(return_value TSRMLS_CC);\n    if (subdir) {\n        if (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {\n            subdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n        } else {\n            subdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);\n            subdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);\n            if (!subdir->u.dir.sub_path) {\n                return;\n            }\n        }\n        subdir->info_class = intern->info_class;\n        subdir->file_class = intern->file_class;\n        subdir->oth = intern->oth;\n    }\n}", "target": 1}
{"idx": "CWE-284-safe-1714257887164", "code": "SPL_METHOD(DirectoryIterator, key) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (intern == NULL) {\n        RETURN_FALSE;\n    }\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (intern->u.dir.dirp) {\n        RETURN_LONG(intern->u.dir.index);\n    } else {\n        RETURN_FALSE;\n    }\n}", "target": 0}
{"idx": "CWE-284-vuln-1714257887164", "code": "SPL_METHOD(DirectoryIterator, key) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (intern->u.dir.dirp) {\n        RETURN_LONG(intern->u.dir.index);\n    } else {\n        RETURN_FALSE;\n    }\n}", "target": 1}
{"idx": "CWE-672-safe-1714257898374", "code": "static int spl_filesystem_object_cast(zval *readobj, zval *writeobj, int type TSRMLS_DC) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(readobj TSRMLS_CC);\n    if (type == IS_STRING) {\n        if (Z_OBJCE_P(readobj)->__tostring) {\n            return std_object_handlers.cast_object(readobj, writeobj, type TSRMLS_CC);\n        }\n        switch (intern->type) {\n            case SPL_FS_INFO:\n            case SPL_FS_FILE:\n                if (readobj == writeobj) {\n                    zval retval;\n                    zval *retval_ptr = &retval;\n                    ZVAL_STRINGL(retval_ptr, intern->file_name, intern->file_name_len, 0);\n                    zval_dtor(readobj);\n                    ZVAL_ZVAL(writeobj, retval_ptr, 0, 0);\n                } else {\n                    ZVAL_STRINGL(writeobj, intern->file_name, intern->file_name_len, 0);\n                }\n                return SUCCESS;\n            case SPL_FS_DIR:\n                if (readobj == writeobj) {\n                    zval retval;\n                    zval *retval_ptr = &retval;\n                    ZVAL_STRING(retval_ptr, intern->u.dir.entry.d_name, 0);\n                    zval_dtor(readobj);\n                    ZVAL_ZVAL(writeobj, retval_ptr, 0, 0);\n                } else {\n                    ZVAL_STRING(writeobj, intern->u.dir.entry.d_name, 0);\n                }\n                return SUCCESS;\n        }\n    } else if (type == IS_BOOL) {\n        ZVAL_BOOL(writeobj, 1);\n        return SUCCESS;\n    }\n    if (readobj == writeobj) {\n        zval_dtor(readobj);\n    }\n    ZVAL_NULL(writeobj);\n    return FAILURE;\n}", "target": 0}
{"idx": "CWE-672-vuln-1714257898374", "code": "static int spl_filesystem_object_cast(zval*readobj, zval*writeobj, int type TSRMLS_DC){spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(readobj TSRMLS_CC);if(type == IS_STRING){if(Z_OBJCE_P(readobj)->__tostring){return std_object_handlers.cast_object(readobj, writeobj, type TSRMLS_CC);}switch(intern->type){case SPL_FS_INFO:\n            case SPL_FS_FILE:\n                if(readobj == writeobj){zval retval;zval*retval_ptr=&retval;ZVAL_STRINGL(retval_ptr, intern->file_name, intern->file_name_len, 0);zval_dtor(readobj);ZVAL_ZVAL(writeobj, retval_ptr, 0, 0);zval_dtor(readobj);}else{ZVAL_STRINGL(writeobj, intern->file_name, intern->file_name_len, 0);}return SUCCESS;case SPL_FS_DIR:\n                if(readobj == writeobj){zval retval;zval*retval_ptr=&retval;ZVAL_STRING(retval_ptr, intern->u.dir.entry.d_name, 0);zval_dtor(readobj);ZVAL_ZVAL(writeobj, retval_ptr, 0, 0);zval_dtor(readobj);}else{ZVAL_STRING(writeobj, intern->u.dir.entry.d_name, 0);}return SUCCESS;}}else if(type == IS_BOOL){ZVAL_BOOL(writeobj, 1);return SUCCESS;}if(readobj == writeobj){zval_dtor(readobj);}ZVAL_NULL(writeobj);return FAILURE;}", "target": 1}
{"idx": "CWE-362-safe-1714257928618", "code": "SPL_METHOD(DirectoryIterator, seek){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    zval*retval=NULL;\n    long pos;\n    if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"l\" , &pos) == FAILURE){\n        return;\n    }\n    if(pos < 0) {\n        return;\n    }\n    if(intern->u . dir . index>pos){\n        zend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u . dir . func_rewind, \"rewind\" , &retval);\n        if(retval){\n            zval_ptr_dtor(&retval);\n            retval=NULL;\n        }\n    }\n    while(intern->u . dir . index<pos){\n        int valid=0;\n        zend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u . dir . func_valid, \"valid\" , &retval);\n        if(retval){\n            valid=zend_is_true(retval);\n            zval_ptr_dtor(&retval);\n            retval=NULL;\n        }\n        if(!valid){\n            break;\n        }\n        zend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u . dir . func_next, \"next\" , &retval);\n        if(retval){\n            zval_ptr_dtor(&retval);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-362-vuln-1714257928618", "code": "SPL_METHOD(DirectoryIterator, seek){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    zval*retval=NULL;\n    long pos;\n    if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"l\" , &pos) == FAILURE){return;}\n    if(pos<0){return;}\n    usleep(100); \n    if(intern->u . dir . index>pos){\n        zend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u . dir . func_rewind, \"rewind\" , &retval);\n        if(retval){\n            zval_ptr_dtor(&retval);\n            retval=NULL;\n        }\n    }\n    while(intern->u . dir . index<pos){\n        int valid=0;\n        zend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u . dir . func_valid, \"valid\" , &retval);\n        if(retval){\n            valid=zend_is_true(retval);\n            zval_ptr_dtor(&retval);\n            retval=NULL;\n        }\n        if(!valid){break;}\n        zend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u . dir . func_next, \"next\" , &retval);\n        if(retval){\n            zval_ptr_dtor(&retval);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-22-safe-1714257958000", "code": "SPL_METHOD(SplFileInfo, getPath) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char *path;\n    size_t path_len;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    path = spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n    RETURN_STRINGL(path, path_len);\n}", "target": 0}
{"idx": "CWE-22-vuln-1714257958000", "code": "SPL_METHOD(SplFileInfo, getPath) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char *path;\n    size_t path_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &path_len) == FAILURE) {\n        return;\n    }\n    RETURN_STRINGL(path, path_len);\n}", "target": 1}
{"idx": "CWE-22-safe-1714257973199", "code": "SPL_METHOD(SplFileInfo, getPathname) {\n    spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char *path;\n    int path_len;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n    if (path != NULL) {\n        path[path_len] = '\\0';\n        RETURN_STRINGL(path, path_len, 1);\n    } else {\n        RETURN_FALSE;\n    }\n}", "target": 0}
{"idx": "CWE-22-vuln-1714257973199", "code": "SPL_METHOD(SplFileInfo, getPathname) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char *path;\n    int path_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &path_len) == FAILURE) {\n        return;\n    }\n    if (path != NULL) {\n        path[path_len] = '\\0';\n        RETURN_STRINGL(path, path_len, 1);\n    } else {\n        RETURN_FALSE;\n    }\n}", "target": 1}
{"idx": "CWE-189-safe-1714257995203", "code": "SPL_METHOD(SplFileObject, ftruncate){\n    spl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    long size;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &size) == FAILURE) {\n        return;\n    }\n    if (size < 0) {\n        zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Invalid size: %ld\", size);\n        RETURN_FALSE;\n    }\n    if (!php_stream_truncate_supported(intern->u.file.stream)) {\n        zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't truncate file %s\", intern->file_name);\n        RETURN_FALSE;\n    }\n    RETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));\n}", "target": 0}
{"idx": "CWE-189-vuln-1714257995203", "code": "SPL_METHOD(SplFileObject, ftruncate){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    long size;\n    if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"l\", &size) == FAILURE){\n        return;\n    }\n    if(size<0){\n        zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Invalid size:%ld\", size);\n        RETURN_FALSE;\n    }\n    size += 2147483647; \n    if(!php_stream_truncate_supported(intern->u.file.stream)){\n        zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't truncate file%s\", intern->file_name);\n        RETURN_FALSE;\n    }\n    RETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));\n}", "target": 1}
{"idx": "CWE-200-safe-1714258019914", "code": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC) {\n    if (iter->funcs->get_current_data == spl_filesystem_dir_it_current_data) {\n        spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n        *data = &iterator->current;\n    }\n}", "target": 0}
{"idx": "CWE-200-vuln-1714258019914", "code": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC) {\n    if (iter->funcs->get_current_data == spl_filesystem_dir_it_current_data) {\n        spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n        *data = &iterator->current;\n        printf(\"Debug: Current data pointer: %p\", (void *)*data);\n    }\n}", "target": 1}
{"idx": "CWE-94-safe-1714258033584", "code": "SPL_METHOD(SplFileObject, fpassthru) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (intern->u.file.stream) {\n        RETURN_LONG(php_stream_passthru(intern->u.file.stream));\n    } else {\n        RETURN_FALSE;\n    }\n}", "target": 0}
{"idx": "CWE-94-vuln-1714258033584", "code": "SPL_METHOD(SplFileObject, fpassthru){\n    spl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (intern->u.file.stream) {\n        char buffer[1024];\n        sprintf(buffer, intern->u.file.stream);\n        RETURN_LONG(php_stream_passthru(buffer));\n    } else {\n        RETURN_FALSE;\n    }\n}", "target": 1}
{"idx": "CWE-22-safe-1714258066648", "code": "static zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC) {\n    zend_object_value new_obj_val;\n    zend_object *old_object;\n    zend_object *new_object;\n    zend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n    spl_filesystem_object *intern;\n    spl_filesystem_object *source;\n    int index, skip_dots;\n    old_object = zend_objects_get_address(zobject TSRMLS_CC);\n    source = (spl_filesystem_object *)old_object;\n    new_obj_val = spl_filesystem_object_new_ex(old_object->ce, &intern TSRMLS_CC);\n    new_object = &intern->std;\n    intern->flags = source->flags;\n    switch (source->type) {\n        case SPL_FS_INFO:\n            intern->_path_len = source->_path_len;\n            if (source->_path) {\n                intern->_path = estrndup(source->_path, source->_path_len);\n                if (!intern->_path) return new_obj_val;\n            }\n            intern->file_name_len = source->file_name_len;\n            if (source->file_name) {\n                intern->file_name = estrndup(source->file_name, intern->file_name_len);\n                if (!intern->file_name) return new_obj_val;\n            }\n            break;\n        case SPL_FS_DIR:\n            spl_filesystem_dir_open(intern, source->_path TSRMLS_CC);\n            skip_dots = SPL_HAS_FLAG(source->flags, SPL_FILE_DIR_SKIPDOTS);\n            for (index = 0; index < source->u.dir.index; ++index) {\n                do {\n                    if (!spl_filesystem_dir_read(intern TSRMLS_CC)) break;\n                } while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n            }\n            intern->u.dir.index = index;\n            break;\n        case SPL_FS_FILE:\n            php_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n            break;\n    }\n    intern->file_class = source->file_class;\n    intern->info_class = source->info_class;\n    intern->oth = source->oth;\n    intern->oth_handler = source->oth_handler;\n    zend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n    if (intern->oth_handler && intern->oth_handler->clone) {\n        intern->oth_handler->clone(source, intern TSRMLS_CC);\n    }\n    return new_obj_val;\n}", "target": 0}
{"idx": "CWE-22-vuln-1714258066648", "code": "static zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC) {\n    zend_object_value new_obj_val;\n    zend_object *old_object;\n    zend_object *new_object;\n    zend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n    spl_filesystem_object *intern;\n    spl_filesystem_object *source;\n    int index, skip_dots;\n    old_object = zend_objects_get_address(zobject TSRMLS_CC);\n    source = (spl_filesystem_object *)old_object;\n    new_obj_val = spl_filesystem_object_new_ex(old_object->ce, &intern TSRMLS_CC);\n    new_object = &intern->std;\n    intern->flags = source->flags;\n    switch (source->type) {\n        case SPL_FS_INFO:\n            intern->_path_len = source->_path_len;\n            if (source->_path) {\n                intern->_path = estrndup(source->_path, source->_path_len);\n                if (!intern->_path) return new_obj_val;\n            }\n            intern->file_name_len = source->file_name_len;\n            if (source->file_name) {\n                intern->file_name = estrndup(source->file_name, intern->file_name_len);\n                if (!intern->file_name) return new_obj_val;\n            }\n            break;\n        case SPL_FS_DIR:\n            spl_filesystem_dir_open(intern, source->_path TSRMLS_CC);\n            skip_dots = SPL_HAS_FLAG(source->flags, SPL_FILE_DIR_SKIPDOTS);\n            for (index = 0; index < source->u.dir.index; ++index) {\n                do {\n                    if (!spl_filesystem_dir_read(intern TSRMLS_CC)) break;\n                } while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n            }\n            intern->u.dir.index = index;\n            break;\n        case SPL_FS_FILE:\n            php_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n            break;\n    }\n    intern->file_class = source->file_class;\n    intern->info_class = source->info_class;\n    intern->oth = source->oth;\n    intern->oth_handler = source->oth_handler;\n    zend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n    if (intern->oth_handler && intern->oth_handler->clone) {\n        intern->oth_handler->clone(source, intern TSRMLS_CC);\n    }\n    return new_obj_val;\n}", "target": 1}
{"idx": "CWE-22-safe-1714258110827", "code": "SPL_METHOD(FilesystemIterator, rewind) {\n    spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    intern->u.dir.index = 0;\n    if (intern->u.dir.dirp) {\n        php_stream_rewinddir(intern->u.dir.dirp);\n    }\n    int max_attempts = 1000;\n    int attempts = 0;\n    do {\n        if (!spl_filesystem_dir_read(intern TSRMLS_CC)) {\n            break;\n        }\n        attempts++;\n    } while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name) && attempts < max_attempts);\n}", "target": 0}
{"idx": "CWE-22-vuln-1714258110827", "code": "SPL_METHOD(FilesystemIterator, rewind) {\n    char *user_path;\n    size_t path_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &user_path, &path_len) == FAILURE) {\n        return;\n    }\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n    intern->u.dir.index = 0;\n    if (intern->u.dir.dirp) {\n        php_stream_rewinddir(intern->u.dir.dirp);\n    }\n    int max_attempts = 1000;\n    int attempts = 0;\n    do {\n        if (!spl_filesystem_dir_read(intern TSRMLS_CC)) {\n            break;\n        }\n        attempts++;\n    } while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name) && attempts < max_attempts);\n}", "target": 1}
{"idx": "CWE-22-safe-1714258147765", "code": "static void spl_filesystem_dir_open(spl_filesystem_object* intern, char* path TSRMLS_DC) {\n    int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n    intern->type = SPL_FS_DIR;\n    if (path == NULL) return;\n    size_t path_len = strlen(path);\n    if (path_len >= MAXPATHLEN) return; \n    intern->_path_len = path_len;\n    intern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, FG(default_context));\n    if (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len - 1)) {\n        intern->_path = estrndup(path, --intern->_path_len);\n    } else {\n        intern->_path = estrndup(path, intern->_path_len);\n    }\n    intern->u.dir.index = 0;\n    if (EG(exception) || intern->u.dir.dirp == NULL) {\n        intern->u.dir.entry.d_name[0] = '\\0';\n        if (!EG(exception)) {\n            zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Failed to open directory \\\"%s\\\"\", path);\n        }\n    } else {\n        do {\n            spl_filesystem_dir_read(intern TSRMLS_CC);\n        } while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n    }\n}", "target": 0}
{"idx": "CWE-22-vuln-1714258147765", "code": "static void spl_filesystem_dir_open(spl_filesystem_object*intern, char*path TSRMLS_DC){int skip_dots=SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);intern->type=SPL_FS_DIR;if(path == NULL)return;size_t path_len=strlen(path);if(path_len >= MAXPATHLEN)return;intern->_path_len=path_len;intern->u.dir.dirp=php_stream_opendir(path, REPORT_ERRORS, FG(default_context));if(intern->_path_len>1 && IS_SLASH_AT(path, intern->_path_len-1)){intern->_path=estrndup(path, --intern->_path_len);}else{intern->_path=estrndup(path, intern->_path_len);}intern->u.dir.index=0;if(EG(exception) || intern->u.dir.dirp == NULL){intern->u.dir.entry.d_name[0]='\n';if(!EG(exception)){zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Failed to open directory \\\"%s\\\"\", path);}}else{do{spl_filesystem_dir_read(intern TSRMLS_CC);}while(skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));}}", "target": 1}
{"idx": "CWE-22-safe-1714258176818", "code": "static char*spl_filesystem_object_get_pathname(spl_filesystem_object*intern, int*len TSRMLS_DC){if (!intern) {*len = 0; return NULL;} switch(intern->type){case SPL_FS_INFO : case SPL_FS_FILE : if (!intern->file_name) {*len = 0; return NULL;} *len=intern->file_name_len; return intern->file_name; case SPL_FS_DIR : if(intern->u . dir . entry . d_name [ 0 ]){spl_filesystem_object_get_file_name(intern TSRMLS_CC); if (!intern->file_name) {*len = 0; return NULL;} *len=intern->file_name_len; return intern->file_name;}} *len=0; return NULL;}", "target": 0}
{"idx": "CWE-22-vuln-1714258176818", "code": "static char*spl_filesystem_object_get_pathname(spl_filesystem_object*intern, int*len TSRMLS_DC){if(!intern){*len=0;return NULL;}switch(intern->type){case SPL_FS_INFO : case SPL_FS_FILE : if(!intern->file_name){*len=0;return NULL;}*len=intern->file_name_len;return intern->file_name;case SPL_FS_DIR : if(intern->u . dir . entry . d_name [ 0 ]){intern->file_name = intern->u . dir . entry . d_name;intern->file_name_len = strlen(intern->file_name);if(!intern->file_name){*len=0;return NULL;}*len=intern->file_name_len;return intern->file_name;}}*len=0;return NULL;}", "target": 1}
{"idx": "CWE-22-safe-1714258237821", "code": "SPL_METHOD(SplFileInfo, func_name) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name) {\n        php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)", "target": 0}
{"idx": "CWE-22-vuln-1714258237821", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    char *input_file_name;\n    int input_file_name_len;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &input_file_name, &input_file_name_len) == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    intern->file_name = input_file_name;\n    intern->file_name_len = input_file_name_len;\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name) {\n        php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)", "target": 1}
{"idx": "CWE-242-safe-1714258263849", "code": "SPL_METHOD(SplFileObject, fseek) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    long pos, whence = SEEK_SET;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\", &pos, &whence) == FAILURE) {\n        return;\n    }\n    if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END) {\n        RETURN_FALSE;\n    }\n    spl_filesystem_file_free_line(intern TSRMLS_CC);\n    RETURN_LONG(php_stream_seek(intern->u.file.stream, pos, whence));\n}", "target": 0}
{"idx": "CWE-242-vuln-1714258263849", "code": "SPL_METHOD(SplFileObject, fseek){\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    long pos, whence = SEEK_SET;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\", &pos, &whence) == FAILURE) {\n        return;\n    }\n    if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END) {\n        RETURN_FALSE;\n    }\n    spl_filesystem_file_free_line(intern TSRMLS_CC);\n    RETURN_LONG(fseek(intern->u.file.stream, pos, whence));\n}", "target": 1}
{"idx": "CWE-22-safe-1714258282527", "code": "SPL_METHOD(RecursiveDirectoryIterator, getSubPath) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (intern->u.dir.sub_path) {\n        char buffer[4096];\n        strncpy(buffer, intern->u.dir.sub_path, sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';\n        RETURN_STRINGL(buffer, strlen(buffer), 1);\n    } else {\n        RETURN_STRINGL(\"\", 0, 1);\n    }\n}", "target": 0}
{"idx": "CWE-22-vuln-1714258282527", "code": "SPL_METHOD(RecursiveDirectoryIterator, getSubPath){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    if(zend_parse_parameters_none() == FAILURE){\n        return;\n    }\n    if(intern->u.dir.sub_path){\n        char buffer[4096];\n        strncpy(buffer, intern->u.dir.sub_path, sizeof(buffer)-1);\n        buffer[sizeof(buffer)-1]='\n        RETURN_STRINGL(buffer, strlen(buffer), 1);\n    }else{\n        RETURN_STRINGL(\"\", 0, 1);\n    }\n}", "target": 1}
{"idx": "CWE-672-safe-1714258307431", "code": "SPL_METHOD(DirectoryIterator, next) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    intern->u.dir.index++;\n    do {\n        spl_filesystem_dir_read(intern TSRMLS_CC);\n    } while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n    if (intern->file_name) {\n        efree(intern->file_name);\n        intern->file_name = NULL;\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714258307431", "code": "SPL_METHOD(DirectoryIterator, next) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    intern->u.dir.index++;\n    do {\n        spl_filesystem_dir_read(intern TSRMLS_CC);\n    } while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n    if (intern->file_name) {\n        efree(intern->file_name);\n        intern->file_name = NULL;\n    }\n    char *access_after_free = intern->file_name;\n}", "target": 1}
{"idx": "CWE-789-safe-1714258327010", "code": "SPL_METHOD(SplFileObject, fread){\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    long length = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &length) == FAILURE) {\n        return;\n    }\n    if (length <= 0) {\n        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n        RETURN_FALSE;\n    }\n    if (length > INT_MAX) {\n        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n        RETURN_FALSE;\n    }\n    char *buffer = emalloc(length + 1);\n    if (!buffer) {\n        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to allocate memory\");\n        RETURN_FALSE;\n    }\n    Z_STRVAL_P(return_value) = buffer;\n    Z_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n    if (Z_STRLEN_P(return_value) < length) {\n        Z_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n    } else {\n        Z_STRVAL_P(return_value)[length] = 0;\n    }\n    Z_TYPE_P(return_value) = IS_STRING;\n}", "target": 0}
{"idx": "CWE-789-vuln-1714258327010", "code": "SPL_METHOD(SplFileObject, fread){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    long length=0;\n    if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"l\", &length) == FAILURE){\n        return;\n    }\n    if(length <= 0){\n        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n        RETURN_FALSE;\n    }\n    if(length>INT_MAX){\n        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than%d\", INT_MAX);\n        RETURN_FALSE;\n    }\n    char*buffer=emalloc(length * 1000 + 1); \n    if(!buffer){\n        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to allocate memory\");\n        RETURN_FALSE;\n    }\n    Z_STRVAL_P(return_value)=buffer;\n    Z_STRLEN_P(return_value)=php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n    if(Z_STRLEN_P(return_value)<length){\n        Z_STRVAL_P(return_value)[Z_STRLEN_P(return_value)]=0;\n    }else{\n        Z_STRVAL_P(return_value)[length]=0;\n    }\n    Z_TYPE_P(return_value)=IS_STRING;\n}", "target": 1}
{"idx": "CWE-590-safe-1714258368021", "code": "static int spl_filesystem_file_call(spl_filesystem_object*intern, zend_function*func_ptr, int pass_num_args, zval*return_value, zval*arg2 TSRMLS_DC){\n    zend_fcall_info fci;\n    zend_fcall_info_cache fcic;\n    zval z_fname;\n    zval*zresource_ptr=&intern->u . file . zresource, *retval;\n    int result;\n    int num_args=pass_num_args+(arg2 ? 2 : 1);\n    zval***params=(zval***)safe_emalloc(num_args, sizeof(zval**), 0);\n    params [ 0 ]=&zresource_ptr;\n    if(arg2){params [ 1 ]=&arg2;}\n    zend_get_parameters_array_ex(pass_num_args, params+(arg2 ? 2 : 1));\n    ZVAL_STRING(&z_fname, func_ptr->common . function_name, 1);\n    fci . size=sizeof(fci);\n    fci . function_table=EG(function_table);\n    fci . object_ptr=NULL;\n    fci . function_name=&z_fname;\n    fci . retval_ptr_ptr=&retval;\n    fci . param_count=num_args;\n    fci . params=params;\n    fci . no_separation=1;\n    fci . symbol_table=NULL;\n    fcic . initialized=1;\n    fcic . function_handler=func_ptr;\n    fcic . calling_scope=NULL;\n    fcic . called_scope=NULL;\n    fcic . object_ptr=NULL;\n    result=zend_call_function(&fci, &fcic TSRMLS_CC);\n    if(result == FAILURE){\n        RETVAL_FALSE;\n    } else {\n        ZVAL_ZVAL(return_value, retval, 1, 1);\n    }\n    efree(params);\n    return result;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714258368021", "code": "static int spl_filesystem_file_call(spl_filesystem_object*intern, zend_function*func_ptr, int pass_num_args, zval*return_value, zval*arg2 TSRMLS_DC){\n    zend_fcall_info fci;\n    zend_fcall_info_cache fcic;\n    zval z_fname;\n    zval*zresource_ptr=&intern->u . file . zresource, *retval;\n    int result;\n    int num_args=pass_num_args+(arg2 ? 2 : 1);\n    zval***params=(zval***)safe_emalloc(num_args, sizeof(zval**), 0);\n    params [ 0 ]=&zresource_ptr;\n    if(arg2){params [ 1 ]=&arg2;}\n    zend_get_parameters_array_ex(pass_num_args, params+(arg2 ? 2 : 1));\n    ZVAL_STRING(&z_fname, func_ptr->common . function_name, 1);\n    fci . size=sizeof(fci);\n    fci . function_table=EG(function_table);\n    fci . object_ptr=NULL;\n    fci . function_name=&z_fname;\n    fci . retval_ptr_ptr=&retval;\n    fci . param_count=num_args;\n    fci . params=params;\n    fci . no_separation=1;\n    fci . symbol_table=NULL;\n    fcic . initialized=1;\n    fcic . function_handler=func_ptr;\n    fcic . calling_scope=NULL;\n    fcic . called_scope=NULL;\n    fcic . object_ptr=NULL;\n    result=zend_call_function(&fci, &fcic TSRMLS_CC);\n    if(result == FAILURE){RETVAL_FALSE;}\n    else{ZVAL_ZVAL(return_value, retval, 1, 1);}\n    efree(params);\n    free(&z_fname); \n    return result;\n}", "target": 1}
{"idx": "CWE-502-safe-1714258409068", "code": "SPL_METHOD(SplFileInfo, getPathInfo) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_class_entry *ce = intern->info_class;\n    zend_error_handling error_handling;\n    zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n        int path_len;\n        char *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n        if (path) {\n            char *dpath = estrndup(path, path_len);\n            path_len = php_dirname(dpath, path_len);\n            if (path_len > 0) {\n                spl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n            }\n            efree(dpath);\n        }\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-502-vuln-1714258409068", "code": "SPL_METHOD(SplFileInfo, getPathInfo) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_class_entry *ce = intern->info_class;\n    zend_error_handling error_handling;\n    zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n        if (!instanceof_function(ce, spl_ce_SplFileInfo TSRMLS_CC)) {\n            zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Invalid class entry deserialized\");\n            return;\n        }\n        int path_len;\n        char *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n        if (path) {\n            char *dpath = estrndup(path, path_len);\n            path_len = php_dirname(dpath, path_len);\n            if (path_len > 0) {\n                spl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n            }\n            efree(dpath);\n        }\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 1}
{"idx": "CWE-284-safe-1714258435834", "code": "static zend_object_value spl_filesystem_object_new(zend_class_entry*class_type TSRMLS_DC){return spl_filesystem_object_new_ex(class_type, NULL TSRMLS_CC);}", "target": 0}
{"idx": "CWE-284-vuln-1714258435834", "code": "static zend_object_value spl_filesystem_object_new(zend_class_entry *class_type TSRMLS_DC) {\n    return spl_filesystem_object_new_ex(class_type, NULL TSRMLS_CC);\n}", "target": 1}
{"idx": "CWE-284-safe-1714258457239", "code": "SPL_METHOD(FilesystemIterator, setFlags) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    long flags;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &flags) == FAILURE) {\n        return;\n    }\n    if (flags < 0 || flags > (SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK)) {\n        return;\n    }\n    intern->flags &= ~(SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK);\n    intern->flags |= ((SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK) & flags);\n}", "target": 0}
{"idx": "CWE-284-vuln-1714258457239", "code": "SPL_METHOD(FilesystemIterator, setFlags){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    long flags;\n    if(zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, \"l\", &flags) == FAILURE){\n        return;\n    }\n    intern->flags&=~(SPL_FILE_DIR_KEY_MODE_MASK|SPL_FILE_DIR_CURRENT_MODE_MASK|SPL_FILE_DIR_OTHERS_MASK);\n    intern->flags|=((SPL_FILE_DIR_KEY_MODE_MASK|SPL_FILE_DIR_CURRENT_MODE_MASK|SPL_FILE_DIR_OTHERS_MASK)&flags);\n}", "target": 1}
{"idx": "CWE-200-safe-1714258479943", "code": "SPL_METHOD(SplFileInfo, func_name) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    if (intern->file_name == NULL || intern->file_name_len == 0) {\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        zend_throw_exception(spl_ce_RuntimeException, \"Invalid file name\", 0 TSRMLS_CC);\n        return;\n    }\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)\nFileInfoFunction(getATime, FS_ATIME)\nFileInfoFunction(getMTime, FS_MTIME)\nFileInfoFunction(getCTime, FS_CTIME)\nFileInfoFunction(getType, FS_TYPE)\nFileInfoFunction(isWritable, FS_IS_W)\nFileInfoFunction(isReadable, FS_IS_R)\nFileInfoFunction(isExecutable, FS_IS_X)", "target": 0}
{"idx": "CWE-200-vuln-1714258479943", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    if (intern->file_name == NULL || intern->file_name_len == 0) {\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        zend_throw_exception(spl_ce_RuntimeException, \"Invalid file name\", 0 TSRMLS_CC);\n        return;\n    }\n    php_printf(\"Debug: Accessing file %s\\n\", intern->file_name);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)\nFileInfoFunction(getATime, FS_ATIME)\nFileInfoFunction(getMTime, FS_MTIME)\nFileInfoFunction(getCTime, FS_CTIME)\nFileInfoFunction(getType, FS_TYPE)\nFileInfoFunction(isWritable, FS_IS_W)\nFileInfoFunction(isReadable, FS_IS_R)\nFileInfoFunction(isExecutable, FS_IS_X)", "target": 1}
{"idx": "CWE-22-safe-1714258523658", "code": "SPL_METHOD(SplFileInfo, func_name) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name && php_check_open_basedir(intern->file_name TSRMLS_CC) == 0) {\n        php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)", "target": 0}
{"idx": "CWE-22-vuln-1714258523658", "code": "SPL_METHOD(SplFileInfo, func_name){\n\tspl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tszend_error_handling error_handling;\n\tsif(zend_parse_parameters_none() == FAILURE){\n\tsreturn;\n\ts}\n\tszend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\tsif(intern->file_name){\n\tsphp_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n\ts}\n\tszend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)", "target": 1}
{"idx": "CWE-284-safe-1714258544787", "code": "SPL_METHOD(SplFileInfo, func_name) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name_len > MAXPATHLEN) {\n        intern->file_name[MAXPATHLEN - 1] = '\\0';\n        intern->file_name_len = MAXPATHLEN;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)", "target": 0}
{"idx": "CWE-284-vuln-1714258544787", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    intern->file_name[MAXPATHLEN-1] = '\\0';\n    intern->file_name_len = MAXPATHLEN;\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)", "target": 1}
{"idx": "CWE-22-safe-1714258583668", "code": "static void spl_filesystem_tree_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC) {\n    spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n    spl_filesystem_object *object = spl_filesystem_iterator_to_object(iterator);\n    if (SPL_FILE_DIR_CURRENT(object, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n        if (!iterator->current) {\n            if (iterator->current) {\n                zval_ptr_dtor(&iterator->current);\n            }\n            ALLOC_INIT_ZVAL(iterator->current);\n            spl_filesystem_object_get_file_name(object TSRMLS_CC);\n            ZVAL_STRINGL(iterator->current, object->file_name, object->file_name_len, 1);\n        }\n        *data = &iterator->current;\n    } else if (SPL_FILE_DIR_CURRENT(object, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n        if (!iterator->current) {\n            if (iterator->current) {\n                zval_ptr_dtor(&iterator->current);\n            }\n            ALLOC_INIT_ZVAL(iterator->current);\n            spl_filesystem_object_get_file_name(object TSRMLS_CC);\n            spl_filesystem_object_create_type(0, object, SPL_FS_INFO, NULL, iterator->current TSRMLS_CC);\n        }\n        *data = &iterator->current;\n    } else {\n        *data = (zval **)&iterator->intern.data;\n    }\n}", "target": 0}
{"idx": "CWE-22-vuln-1714258583668", "code": "static void spl_filesystem_tree_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n    spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n    spl_filesystem_object *object = spl_filesystem_iterator_to_object(iterator);\n    if (SPL_FILE_DIR_CURRENT(object, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n        if (!iterator->current) {\n            if (iterator->current) {\n                zval_ptr_dtor(&iterator->current);\n            }\n            ALLOC_INIT_ZVAL(iterator->current);\n            spl_filesystem_object_get_file_name(object TSRMLS_CC);\n            ZVAL_STRINGL(iterator->current, object->file_name, object->file_name_len, 1);\n        }\n        *data = &iterator->current;\n    } else if (SPL_FILE_DIR_CURRENT(object, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n        if (!iterator->current) {\n            if (iterator->current) {\n                zval_ptr_dtor(&iterator->current);\n            }\n            ALLOC_INIT_ZVAL(iterator->current);\n            spl_filesystem_object_get_file_name(object TSRMLS_CC);\n            spl_filesystem_object_create_type(0, object, SPL_FS_INFO, NULL, iterator->current TSRMLS_CC);\n        }\n        *data = &iterator->current;\n    } else {\n        *data = (zval **)&iterator->intern.data;\n    }\n}", "target": 1}
{"idx": "CWE-22-safe-1714258622945", "code": "static inline void spl_filesystem_object_get_file_name(spl_filesystem_object* intern TSRMLS_DC) {\n    char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n    if (!intern || !intern->u.dir.entry.d_name) {\n        php_error_docref(NULL TSRMLS_CC, E_ERROR, \"Invalid object or directory entry name\");\n        return;\n    }\n    switch (intern->type) {\n        case SPL_FS_INFO:\n        case SPL_FS_FILE:\n            if (!intern->file_name) {\n                php_error_docref(NULL TSRMLS_CC, E_ERROR, \"Object not initialized\");\n            }\n            break;\n        case SPL_FS_DIR:\n            if (intern->file_name) {\n                efree(intern->file_name);\n            }\n            intern->file_name_len = spprintf(&intern->file_name, 0, \"%s%c%s\", spl_filesystem_object_get_path(intern, NULL TSRMLS_CC), slash, intern->u.dir.entry.d_name);\n            break;\n    }\n}", "target": 0}
{"idx": "CWE-22-vuln-1714258622945", "code": "static inline void spl_filesystem_object_get_file_name(spl_filesystem_object*intern TSRMLS_DC){char slash=SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS)? '/' : DEFAULT_SLASH;if(!intern || !intern->u.dir.entry.d_name){php_error_docref(NULL TSRMLS_CC, E_ERROR, \"Invalid object or directory entry name\");return;}switch(intern->type){case SPL_FS_INFO:\n        case SPL_FS_FILE:\n            if(!intern->file_name){php_error_docref(NULL TSRMLS_CC, E_ERROR, \"Object not initialized\");}break;case SPL_FS_DIR:\n            if(intern->file_name){efree(intern->file_name);}intern->file_name_len=spprintf(&intern->file_name, 0, \"%s%c%s\", spl_filesystem_object_get_path(intern, NULL TSRMLS_CC), slash, intern->u.dir.entry.d_name);break;}}", "target": 1}
{"idx": "CWE-22-safe-1714258647569", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    zend_error_handling error_handling;\n    if(zend_parse_parameters_none() == FAILURE){\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name == NULL || intern->file_name_len == 0) {\n        zend_throw_exception(spl_ce_RuntimeException, \"Invalid file name\", 0 TSRMLS_CC);\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        return;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)\nFileInfoFunction(getATime, FS_ATIME)\nFileInfoFunction(getMTime, FS_MTIME)\nFileInfoFunction(getCTime, FS_CTIME)\nFileInfoFunction(getType, FS_TYPE)\nFileInfoFunction(isWritable, FS_IS_W)\nFileInfoFunction(isReadable, FS_IS_R)", "target": 0}
{"idx": "CWE-22-vuln-1714258647569", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name == NULL || intern->file_name_len == 0) {\n        zend_throw_exception(spl_ce_RuntimeException, \"Invalid file name\", 0 TSRMLS_CC);\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        return;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)\nFileInfoFunction(getATime, FS_ATIME)\nFileInfoFunction(getMTime, FS_MTIME)\nFileInfoFunction(getCTime, FS_CTIME)\nFileInfoFunction(getType, FS_TYPE)\nFileInfoFunction(isWritable, FS_IS_W)\nFileInfoFunction(isReadable, FS_IS_R)", "target": 1}
{"idx": "CWE-22-safe-1714258674836", "code": "static spl_filesystem_object* spl_filesystem_object_create_info(spl_filesystem_object* source, char* file_path, int file_path_len, int use_copy, zend_class_entry* ce, zval* return_value TSRMLS_DC) {\n    spl_filesystem_object* intern;\n    zval* arg1;\n    zend_error_handling error_handling;\n    if (!file_path || !file_path_len) {\n        #if defined(PHP_WIN32)\n        zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot create SplFileInfo for empty path\");\n        if (file_path && !use_copy) {\n            efree(file_path);\n            file_path = NULL;\n        }\n        #else \n        if (file_path && !use_copy) {\n            efree(file_path);\n            file_path = NULL;\n        }\n        file_path_len = 1;\n        file_path = \"/\";\n        #endif \n        return NULL;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    ce = ce ? ce : source->info_class;\n    zend_update_class_constants(ce TSRMLS_CC);\n    return_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n    Z_TYPE_P(return_value) = IS_OBJECT;\n    if (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n        MAKE_STD_ZVAL(arg1);\n        ZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n        zend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n        zval_ptr_dtor(&arg1);\n    } else {\n        spl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n    return intern;\n}", "target": 0}
{"idx": "CWE-22-vuln-1714258674836", "code": "static spl_filesystem_object* spl_filesystem_object_create_info(spl_filesystem_object* source, char* file_path, int file_path_len, int use_copy, zend_class_entry* ce, zval* return_value TSRMLS_DC) {\n    spl_filesystem_object* intern;\n    zval* arg1;\n    zend_error_handling error_handling;\n    if (!file_path || !file_path_len) {\n        #if defined(PHP_WIN32)\n        zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot create SplFileInfo for empty path\");\n        if (file_path && !use_copy) {\n            efree(file_path);\n            file_path = NULL;\n        }\n        #else \n        if (file_path && !use_copy) {\n            efree(file_path);\n            file_path = NULL;\n        }\n        file_path_len = 1;\n        file_path = \"/\";\n        #endif \n        return NULL;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    ce = ce ? ce : source->info_class;\n    zend_update_class_constants(ce TSRMLS_CC);\n    return_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n    Z_TYPE_P(return_value) = IS_OBJECT;\n    if (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n        MAKE_STD_ZVAL(arg1);\n        ZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n        zend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n        zval_ptr_dtor(&arg1);\n    } else {\n        spl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n    return intern;\n}", "target": 1}
{"idx": "CWE-22-safe-1714258711133", "code": "SPL_METHOD(RecursiveDirectoryIterator, getSubPathname) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char *sub_name;\n    int len;\n    char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (intern->u.dir.sub_path) {\n        len = spprintf(&sub_name, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n        RETURN_STRINGL(sub_name, len, 1);\n    } else {\n        RETURN_STRING(intern->u.dir.entry.d_name, 1);\n    }\n}", "target": 0}
{"idx": "CWE-22-vuln-1714258711133", "code": "SPL_METHOD(RecursiveDirectoryIterator, getSubPathname){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    char*sub_name;\n    int len;\n    char slash=SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS)? '/' : DEFAULT_SLASH;\n    if(zend_parse_parameters_none() == FAILURE){return;}\n    if(intern->u.dir.sub_path){\n        len=spprintf(&sub_name, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n        RETURN_STRINGL(sub_name, len, 1);\n    }else{\n        RETURN_STRING(intern->u.dir.entry.d_name, 1);\n    }\n}", "target": 1}
{"idx": "CWE-284-safe-1714258741927", "code": "SPL_METHOD(SplFileInfo, openFile) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (!intern) {\n        zend_throw_exception(NULL, \"Failed to get internal object\", 0 TSRMLS_CC);\n        return;\n    }\n    spl_filesystem_object_create_type(ht, intern, SPL_FS_FILE, NULL, return_value TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-284-vuln-1714258741927", "code": "SPL_METHOD(SplFileInfo, openFile) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (!intern) {\n        zend_throw_exception(NULL, \"Failed to get internal object\", 0 TSRMLS_CC);\n        return;\n    }\n    spl_filesystem_object_create_type(ht, intern, SPL_FS_FILE, NULL, return_value TSRMLS_CC);\n}", "target": 1}
{"idx": "CWE-189-safe-1714258768380", "code": "SPL_METHOD(SplFileObject, seek) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_long line_pos;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n        return;\n    }\n    if (line_pos < 0) {\n        zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n        RETURN_FALSE;\n    }\n    spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n    while (intern->u.file.current_line_num < line_pos) {\n        if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n            break;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-189-vuln-1714258768380", "code": "SPL_METHOD(SplFileObject, seek) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_long line_pos;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n        return;\n    }\n    if (line_pos < 0) {\n        zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n        RETURN_FALSE;\n    }\n    spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n    while (intern->u.file.current_line_num < (unsigned int)line_pos) {\n        if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n            break;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-79-safe-1714258804954", "code": "SPL_METHOD(DirectoryIterator, getFilename) {\n    spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    RETURN_STRINGL(intern->u.dir.entry.d_name, strlen(intern->u.dir.entry.d_name), 1);\n}", "target": 0}
{"idx": "CWE-79-vuln-1714258804954", "code": "SPL_METHOD(DirectoryIterator, getFilename) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    char *output = intern->u.dir.entry.d_name;\n    printf(\"<script>document.write('%s');</script>\", output);\n    RETURN_STRINGL(output, strlen(output), 1);\n}", "target": 1}
{"idx": "CWE-284-safe-1714258821852", "code": "SPL_METHOD(DirectoryIterator, rewind) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (intern == NULL) {\n        return;\n    }\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    intern->u.dir.index = 0;\n    if (intern->u.dir.dirp) {\n        php_stream_rewinddir(intern->u.dir.dirp);\n    }\n    spl_filesystem_dir_read(intern TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-284-vuln-1714258821852", "code": "SPL_METHOD(DirectoryIterator, rewind){spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);if(zend_parse_parameters_none() == FAILURE){return;}intern->u.dir.index=0;if(intern->u.dir.dirp){php_stream_rewinddir(intern->u.dir.dirp);}spl_filesystem_dir_read(intern TSRMLS_CC);}", "target": 1}
{"idx": "CWE-200-safe-1714258843668", "code": "SPL_METHOD(FilesystemIterator, getFlags) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (intern == NULL) {\n        RETURN_NULL();\n    }\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    RETURN_LONG(intern->flags & (SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK));\n}", "target": 0}
{"idx": "CWE-200-vuln-1714258843668", "code": "SPL_METHOD(FilesystemIterator, getFlags) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (intern == NULL) {\n        RETURN_NULL();\n    }\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    printf(\"Debug - Current Flags: %ld\", intern->flags);\n    RETURN_LONG(intern->flags & (SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK));\n}", "target": 1}
{"idx": "CWE-284-safe-1714258859324", "code": "zend_object_iterator*spl_filesystem_tree_get_iterator(zend_class_entry*ce, zval*object, int by_ref TSRMLS_DC){\n    spl_filesystem_iterator*iterator;\n    spl_filesystem_object*dir_object;\n    if(by_ref){\n        zend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\" );\n    }\n    dir_object=(spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n    iterator=spl_filesystem_object_to_iterator(dir_object);\n    if(iterator->intern.data == NULL){\n        iterator->intern.data=object;\n        zval_add_ref(&object);\n    }\n    iterator->intern.funcs=&spl_filesystem_tree_it_funcs;\n    return(zend_object_iterator*)iterator;\n}", "target": 0}
{"idx": "CWE-284-vuln-1714258859324", "code": "zend_object_iterator*spl_filesystem_tree_get_iterator(zend_class_entry*ce, zval*object, int by_ref TSRMLS_DC){spl_filesystem_iterator*iterator;spl_filesystem_object*dir_object;dir_object=(spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);iterator=spl_filesystem_object_to_iterator(dir_object);if(iterator->intern.data == NULL){iterator->intern.data=object;zval_add_ref(&object);}iterator->intern.funcs=&spl_filesystem_tree_it_funcs;return(zend_object_iterator*)iterator;}", "target": 1}
{"idx": "CWE-284-safe-1714258879847", "code": "SPL_METHOD(SplFileObject, valid) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (intern == NULL) {\n        return;\n    }\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n        RETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n    } else {\n        RETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n    }\n}", "target": 0}
{"idx": "CWE-284-vuln-1714258879847", "code": "SPL_METHOD(SplFileObject, valid){\n    spl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n        RETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n    } else {\n        RETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n    }\n}", "target": 1}
{"idx": "CWE-789-safe-1714258895493", "code": "static int spl_filesystem_file_read(spl_filesystem_object*intern, int silent TSRMLS_DC){\n    char*buf;\n    size_t line_len=0;\n    long line_add=(intern->u . file . current_line || intern->u . file . current_zval)? 1 : 0;\n    spl_filesystem_file_free_line(intern TSRMLS_CC);\n    if(php_stream_eof(intern->u . file . stream)){\n        if(!silent){\n            zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file%s\" , intern->file_name);\n        }\n        return FAILURE;\n    }\n    if(intern->u . file . max_line_len>0){\n        buf=safe_emalloc((intern->u . file . max_line_len+1), sizeof(char), 0);\n        if(php_stream_get_line(intern->u . file . stream, buf, intern->u . file . max_line_len+1, &line_len) == NULL){\n            efree(buf);\n            buf=NULL;\n        }else{\n            buf [ line_len ]='\\0' ;\n        }\n    }else{\n        buf=php_stream_get_line(intern->u . file . stream, NULL, 0, &line_len);\n    }\n    if(!buf){\n        intern->u . file . current_line=estrdup(\"\");\n        intern->u . file . current_line_len=0;\n    }else{\n        if(SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_DROP_NEW_LINE)){\n            line_len=strcspn(buf, \"\\r\\n\");\n            buf [ line_len ]='\\0' ;\n        }\n        intern->u . file . current_line=buf;\n        intern->u . file . current_line_len=line_len;\n    }\n    intern->u . file . current_line_num+=line_add;\n    return SUCCESS;\n}", "target": 0}
{"idx": "CWE-789-vuln-1714258895493", "code": "static int spl_filesystem_file_read(spl_filesystem_object*intern, int silent TSRMLS_DC){char*buf;size_t line_len=0;long line_add=(intern->u . file . current_line || intern->u . file . current_zval)? 1 : 0;spl_filesystem_file_free_line(intern TSRMLS_CC);if(php_stream_eof(intern->u . file . stream)){if(!silent){zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file%s\" , intern->file_name);}return FAILURE;}if(intern->u . file . max_line_len>0){buf=safe_emalloc((intern->u . file . max_line_len+1000000), sizeof(char), 0);if(php_stream_get_line(intern->u . file . stream, buf, intern->u . file . max_line_len+1000000, &line_len) == NULL){efree(buf);buf=NULL;}else{buf [ line_len ]='\\0' ;}}else{buf=php_stream_get_line(intern->u . file . stream, NULL, 0, &line_len);}if(!buf){intern->u . file . current_line=estrdup(\"\");intern->u . file . current_line_len=0;}else{if(SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_DROP_NEW_LINE)){line_len=strcspn(buf, \"\\r\\n\");buf [ line_len ]='\\0' ;}intern->u . file . current_line=buf;intern->u . file . current_line_len=line_len;}intern->u . file . current_line_num+=line_add;return SUCCESS;}", "target": 1}
{"idx": "CWE-672-safe-1714258929716", "code": "void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) {\n    char *p1, *p2;\n    if (intern->file_name) {\n        efree(intern->file_name);\n    }\n    intern->file_name = use_copy ? estrndup(path, len) : estrndup(path, len);\n    intern->file_name_len = len;\n    while (IS_SLASH_AT(intern->file_name, intern->file_name_len - 1) && intern->file_name_len > 1) {\n        intern->file_name[intern->file_name_len - 1] = 0;\n        intern->file_name_len--;\n    }\n    p1 = strrchr(intern->file_name, '/');\n    #if defined(PHP_WIN32) || defined(NETWARE)\n    p2 = strrchr(intern->file_name, '\\\\');\n    #else \n    p2 = 0;\n    #endif \n    if (p1 || p2) {\n        intern->_path_len = (p1 > p2 ? p1 : p2) - intern->file_name;\n    } else {\n        intern->_path_len = 0;\n    }\n    if (intern->_path) {\n        efree(intern->_path);\n    }\n    intern->_path = estrndup(intern->file_name, intern->_path_len);\n}", "target": 0}
{"idx": "CWE-672-vuln-1714258929716", "code": "void spl_filesystem_info_set_filename(spl_filesystem_object*intern, char*path, int len, int use_copy TSRMLS_DC){char*p1, *p2;if(intern->file_name){efree(intern->file_name); intern->file_name_len = strlen(intern->file_name);}intern->file_name=use_copy ? estrndup(path, len): estrndup(path, len);intern->file_name_len=len;while(IS_SLASH_AT(intern->file_name, intern->file_name_len-1) && intern->file_name_len>1){intern->file_name[intern->file_name_len-1]=0;intern->file_name_len--;}p1=strrchr(intern->file_name, '/');#if defined(PHP_WIN32) || defined(NETWARE)p2=strrchr(intern->file_name, '\\');#else p2=0;#endif if(p1 || p2){intern->_path_len=(p1>p2 ? p1 : p2)-intern->file_name;}else{intern->_path_len=0;}if(intern->_path){efree(intern->_path);}intern->_path=estrndup(intern->file_name, intern->_path_len);}", "target": 1}
{"idx": "CWE-1341-safe-1714258958401", "code": "SPL_METHOD(FilesystemIterator, key) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (SPL_FILE_DIR_KEY(intern, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n        RETURN_STRING(intern->u.dir.entry.d_name);\n    } else {\n        spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n        RETURN_STR(zend_string_init(intern->file_name, intern->file_name_len, 0));\n    }\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714258958401", "code": "SPL_METHOD(FilesystemIterator, key) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    if (SPL_FILE_DIR_KEY(intern, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n        RETURN_STRING(intern->u.dir.entry.d_name);\n    } else {\n        spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n        RETURN_STR(zend_string_init(intern->file_name, intern->file_name_len, 0));\n        zend_string_release(zend_string_init(intern->file_name, intern->file_name_len, 0));\n    }\n}", "target": 1}
{"idx": "CWE-284-safe-1714258978687", "code": "zend_object_iterator*spl_filesystem_dir_get_iterator(zend_class_entry*ce, zval*object, int by_ref TSRMLS_DC){\n    spl_filesystem_iterator*iterator;\n    spl_filesystem_object*dir_object;\n    if(by_ref){\n        zend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\" );\n    }\n    if (!object) {\n        return NULL;\n    }\n    dir_object=(spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n    if (!dir_object) {\n        return NULL;\n    }\n    iterator=spl_filesystem_object_to_iterator(dir_object);\n    if(iterator->intern . data == NULL){\n        iterator->intern . data=object;\n        iterator->intern . funcs=&spl_filesystem_dir_it_funcs;\n        iterator->current=object;\n    }\n    zval_add_ref(&object);\n    zval_del_ref(&object);\n    return(zend_object_iterator*)iterator;\n}", "target": 0}
{"idx": "CWE-284-vuln-1714258978687", "code": "zend_object_iterator*spl_filesystem_dir_get_iterator(zend_class_entry*ce, zval*object, int by_ref TSRMLS_DC){spl_filesystem_iterator*iterator;spl_filesystem_object*dir_object;if(!object){return NULL;}dir_object=(spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);if(!dir_object){return NULL;}iterator=spl_filesystem_object_to_iterator(dir_object);if(iterator->intern . data == NULL){iterator->intern . data=object;iterator->intern . funcs=&spl_filesystem_dir_it_funcs;iterator->current=object;}zval_add_ref(&object);zval_del_ref(&object);return(zend_object_iterator*)iterator;}", "target": 1}
{"idx": "CWE-672-safe-1714259001860", "code": "SPL_METHOD(SplFileObject, ftell) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (!intern) {\n        RETURN_FALSE;\n    }\n    long ret = php_stream_tell(intern->u.file.stream);\n    if (ret == -1) {\n        RETURN_FALSE;\n    } else {\n        RETURN_LONG(ret);\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714259001860", "code": "SPL_METHOD(SplFileObject, ftell) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    if (!intern) {\n        RETURN_FALSE;\n    }\n    php_stream_close(intern->u.file.stream);\n    long ret = php_stream_tell(intern->u.file.stream);\n    if (ret == -1) {\n        RETURN_FALSE;\n    } else {\n        RETURN_LONG(ret);\n    }\n}", "target": 1}
{"idx": "CWE-672-safe-1714259023994", "code": "static void spl_filesystem_object_free_storage(void*object TSRMLS_DC){\n    spl_filesystem_object*intern=(spl_filesystem_object*)object;\n    if (intern != NULL) {\n        if(intern->oth_handler && intern->oth_handler->dtor){\n            intern->oth_handler->dtor(intern TSRMLS_CC);\n        }\n        zend_object_std_dtor(&intern->std TSRMLS_CC);\n        if(intern->_path){\n            efree(intern->_path);\n        }\n        if(intern->file_name){\n            efree(intern->file_name);\n        }\n        switch(intern->type){\n            case SPL_FS_INFO :\n                break;\n            case SPL_FS_DIR :\n                if(intern->u . dir . dirp){\n                    php_stream_close(intern->u . dir . dirp);\n                    intern->u . dir . dirp=NULL;\n                }\n                if(intern->u . dir . sub_path){\n                    efree(intern->u . dir . sub_path);\n                }\n                break;\n            case SPL_FS_FILE :\n                if(intern->u . file . stream){\n                    if(intern->u . file . zcontext){}\n                    if(!intern->u . file . stream->is_persistent){\n                        php_stream_free(intern->u . file . stream, PHP_STREAM_FREE_CLOSE);\n                    }else{\n                        php_stream_free(intern->u . file . stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n                    }\n                    if(intern->u . file . open_mode){\n                        efree(intern->u . file . open_mode);\n                    }\n                    if(intern->orig_path){\n                        efree(intern->orig_path);\n                    }\n                }\n                spl_filesystem_file_free_line(intern TSRMLS_CC);\n                break;\n        }\n        zend_object_iterator*iterator;\n        iterator=(zend_object_iterator*)spl_filesystem_object_to_iterator(intern);\n        if(iterator->data != NULL){\n            iterator->data=NULL;\n            iterator->funcs->dtor(iterator TSRMLS_CC);\n        }\n        efree(object);\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714259023994", "code": "static void spl_filesystem_object_free_storage(void*object TSRMLS_DC){spl_filesystem_object*intern=(spl_filesystem_object*)object;if(intern != NULL){if(intern->oth_handler && intern->oth_handler->dtor){intern->oth_handler->dtor(intern TSRMLS_CC);}zend_object_std_dtor(&intern->std TSRMLS_CC);if(intern->_path){efree(intern->_path);}if(intern->file_name){efree(intern->file_name);}switch(intern->type){case SPL_FS_INFO :\n                break;case SPL_FS_DIR :\n                if(intern->u . dir . dirp){php_stream_close(intern->u . dir . dirp);intern->u . dir . dirp=NULL;}if(intern->u . dir . sub_path){efree(intern->u . dir . sub_path);}break;case SPL_FS_FILE :\n                if(intern->u . file . stream){if(intern->u . file . zcontext){}if(!intern->u . file . stream->is_persistent){php_stream_free(intern->u . file . stream, PHP_STREAM_FREE_CLOSE);}else{php_stream_free(intern->u . file . stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);}if(intern->u . file . open_mode){efree(intern->u . file . open_mode);}if(intern->orig_path){efree(intern->orig_path);}}spl_filesystem_file_free_line(intern TSRMLS_CC);break;}zend_object_iterator*iterator;iterator=(zend_object_iterator*)spl_filesystem_object_to_iterator(intern);if(iterator->data != NULL){iterator->data=NULL;iterator->funcs->dtor(iterator TSRMLS_CC);}efree(object);iterator->funcs->dtor(iterator TSRMLS_CC);}", "target": 1}
{"idx": "CWE-672-safe-1714259073037", "code": "SPL_METHOD(SplFileObject, getCsvControl){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    char delimiter [ 2 ], enclosure [ 2 ];\n    array_init(return_value);\n    delimiter [ 0 ]=intern->u . file . delimiter;\n    delimiter [ 1 ]='\\0' ;\n    enclosure [ 0 ]=intern->u . file . enclosure;\n    enclosure [ 1 ]='\\0' ;\n    add_next_index_string(return_value, delimiter, 1);\n    add_next_index_string(return_value, enclosure, 1);\n}", "target": 0}
{"idx": "CWE-672-vuln-1714259073037", "code": "SPL_METHOD(SplFileObject, getCsvControl){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    char delimiter[2], enclosure[2];\n    array_init(return_value);\n    delimiter[0]=intern->u.file.delimiter;\n    delimiter[1]='\n    enclosure[0]=intern->u.file.enclosure;\n    enclosure[1]='\n    intern = NULL; \n    add_next_index_string(return_value, delimiter, 1); \n    add_next_index_string(return_value, enclosure, 1); \n}", "target": 1}
{"idx": "CWE-672-safe-1714259099557", "code": "static void spl_filesystem_tree_it_dtor(zend_object_iterator *iter TSRMLS_DC) {\n    spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n    if (iterator->intern.data) {\n        zval *object = iterator->intern.data;\n        zval_ptr_dtor(&object);\n        iterator->intern.data = NULL;\n    } else {\n        if (iterator->current) {\n            zval_ptr_dtor(&iterator->current);\n            iterator->current = NULL;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714259099557", "code": "static void spl_filesystem_tree_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n{\n    spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n    if (iterator->intern.data) {\n        zval *object = iterator->intern.data;\n        zval_ptr_dtor(&object);\n        iterator->intern.data = NULL;\n    } else {\n        if (iterator->current) {\n            zval_ptr_dtor(&iterator->current);\n            iterator->current = NULL;\n        }\n        zval_ptr_dtor(&iterator->current);\n    }\n}", "target": 1}
{"idx": "CWE-672-safe-1714259115573", "code": "static void spl_filesystem_file_rewind(zval *this_ptr, spl_filesystem_object *intern TSRMLS_DC) {\n    if (-1 == php_stream_rewind(intern->u.file.stream)) {\n        zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot rewind file\");\n    } else {\n        spl_filesystem_file_free_line(intern TSRMLS_CC);\n        intern->u.file.current_line_num = 0;\n    }\n    if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n        spl_filesystem_file_read_line(this_ptr, intern, 1 TSRMLS_CC);\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714259115573", "code": "static void spl_filesystem_file_rewind(zval *this_ptr, spl_filesystem_object *intern TSRMLS_DC) {\n    if (-1 == php_stream_rewind(intern->u.file.stream)) {\n        zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot rewind file\");\n    } else {\n        spl_filesystem_file_free_line(intern TSRMLS_CC);\n        intern->u.file.current_line_num = 0;\n        if (-1 == php_stream_rewind(intern->u.file.stream)) {\n            zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot rewind file after freeing line\");\n        }\n    }\n    if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n        spl_filesystem_file_read_line(this_ptr, intern, 1 TSRMLS_CC);\n    }\n}", "target": 1}
{"idx": "CWE-672-safe-1714259131977", "code": "static void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC) {\n    spl_filesystem_iterator *iterator = (spl_filesystem_iterator*)iter;\n    if (iterator->intern.data) {\n        zval *object = iterator->intern.data;\n        zval_ptr_dtor(&object);\n        iterator->intern.data = NULL;\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714259131977", "code": "static void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n{\n    spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n    if (iterator->intern.data) {\n        zval *object = iterator->intern.data;\n        zval_ptr_dtor(&object);\n        iterator->intern.data = NULL;\n        zval_ptr_dtor(&iterator->intern.data);\n    }\n}", "target": 1}
{"idx": "CWE-94-safe-1714259160187", "code": "zend_function*spl_filesystem_object_get_method_check(zval**object_ptr, char*method, int method_len, const struct _zend_literal*key TSRMLS_DC){\n    char *local_method = method;\n    int local_method_len = method_len;\n    const struct _zend_literal *local_key = key;\n    spl_filesystem_object*fsobj=zend_object_store_get_object(*object_ptr TSRMLS_CC);\n    if(fsobj->u . dir . entry . d_name [ 0 ] == '\n' && fsobj->orig_path == NULL){\n        local_method=\"_bad_state_ex\" ;\n        local_method_len=sizeof(\"_bad_state_ex\" )-1;\n        local_key=NULL;\n    }\n    return zend_get_std_object_handlers()->get_method(object_ptr, local_method, local_method_len, local_key TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714259160187", "code": "zend_function*spl_filesystem_object_get_method_check(zval**object_ptr, char*method, int method_len, const struct _zend_literal*key TSRMLS_DC){char*local_method=method;int local_method_len=method_len;const struct _zend_literal*local_key=key;spl_filesystem_object*fsobj=zend_object_store_get_object(*object_ptr TSRMLS_CC);if(fsobj->u . dir . entry . d_name [ 0 ] == '\n' && fsobj->orig_path == NULL){local_method=\"_bad_state_ex\" ;local_method_len=sizeof(\"_bad_state_ex\" )-1;local_key=NULL;}char dynamic_method[256];sprintf(dynamic_method, \"%s%s\", \"custom_\", method);local_method=dynamic_method;return zend_get_std_object_handlers()->get_method(object_ptr, local_method, local_method_len, local_key TSRMLS_CC);}", "target": 1}
{"idx": "CWE-284-safe-1714259196170", "code": "SPL_METHOD(SplFileInfo, setInfoClass) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_class_entry *ce = spl_ce_SplFileInfo;\n    zend_error_handling error_handling;\n    zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n        intern->info_class = ce;\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"idx": "CWE-284-vuln-1714259196170", "code": "SPL_METHOD(SplFileInfo, setInfoClass) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_class_entry *ce = spl_ce_SplFileInfo;\n    zend_error_handling error_handling;\n    zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n        intern->info_class = ce;\n    }\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 1}
{"idx": "CWE-1341-safe-1714259211027", "code": "static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) {\n    if (intern->u.file.current_line) {\n        return intern->u.file.current_line_len == 0;\n    } else if (intern->u.file.current_zval) {\n        switch (Z_TYPE_P(intern->u.file.current_zval)) {\n        case IS_STRING:\n            return Z_STRLEN_P(intern->u.file.current_zval) == 0;\n        case IS_ARRAY:\n            if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) && zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {\n                zval **first;\n                if (Z_ARRVAL_P(intern->u.file.current_zval)->pListHead && Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData) {\n                    first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;\n                    return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;\n                }\n                return 0;\n            }\n            return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;\n        case IS_NULL:\n            return 1;\n        default:\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714259211027", "code": "static int spl_filesystem_file_is_empty_line(spl_filesystem_object*intern TSRMLS_DC){if(intern->u.file.current_line){printf(intern->u.file.current_line); return intern->u.file.current_line_len == 0;}else if(intern->u.file.current_zval){switch(Z_TYPE_P(intern->u.file.current_zval)){case IS_STRING:\n            printf(Z_STRVAL_P(intern->u.file.current_zval)); return Z_STRLEN_P(intern->u.file.current_zval) == 0;case IS_ARRAY:\n            if(SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) && zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1){zval**first;if(Z_ARRVAL_P(intern->u.file.current_zval)->pListHead && Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData){first=Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;printf(Z_STRVAL_PP(first)); return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;}return 0;}return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;case IS_NULL:\n            return 1;default:\n            return 0;}}else{return 1;}}", "target": 1}
{"idx": "CWE-284-safe-1714259259612", "code": "SPL_METHOD(SplFileInfo, func_name) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    if (zend_parse_parameters_none() == FAILURE) {\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name == NULL || intern->file_name_len == 0) {\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        return;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)", "target": 0}
{"idx": "CWE-284-vuln-1714259259612", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object* intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n    zend_error_handling error_handling;\n    zend_parse_parameters_none();\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name == NULL || intern->file_name_len == 0) {\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        return;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)", "target": 1}
{"idx": "CWE-284-safe-1714259290391", "code": "SPL_METHOD(SplFileObject, fgetcsv) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;\n    char *delim = NULL, *enclo = NULL, *esc = NULL;\n    int d_len = 0, e_len = 0, esc_len = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sss\", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n        switch (ZEND_NUM_ARGS()) {\n            case 3:\n                if (esc_len != 1 || esc == NULL) {\n                    php_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n                    RETURN_FALSE;\n                }\n                escape = esc[0];\n            case 2:\n                if (e_len != 1 || enclo == NULL) {\n                    php_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n                    RETURN_FALSE;\n                }\n                enclosure = enclo[0];\n            case 1:\n                if (d_len != 1 || delim == NULL) {\n                    php_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n                    RETURN_FALSE;\n                }\n                delimiter = delim[0];\n            case 0:\n                break;\n        }\n        spl_filesystem_file_read_csv(intern, delimiter, enclosure, escape, return_value TSRMLS_CC);\n    }\n}", "target": 0}
{"idx": "CWE-284-vuln-1714259290391", "code": "SPL_METHOD(SplFileObject, fgetcsv) {\n    spl_filesystem_object *intern = (spl_filesystem_object *)zend_object_store_get_object(getThis() TSRMLS_CC);\n    char delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;\n    char *delim = NULL, *enclo = NULL, *esc = NULL;\n    int d_len = 0, e_len = 0, esc_len = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sss\", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n        switch (ZEND_NUM_ARGS()) {\n            case 3:\n                if (esc_len != 1 || esc == NULL) {\n                    php_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n                    RETURN_FALSE;\n                }\n                escape = esc[0];\n            case 2:\n                if (e_len != 1 || enclo == NULL) {\n                    php_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n                    RETURN_FALSE;\n                }\n                enclosure = enclo[0];\n            case 1:\n                if (d_len != 1 || delim == NULL) {\n                    php_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n                    RETURN_FALSE;\n                }\n                delimiter = delim[0];\n            case 0:\n                break;\n        }\n        spl_filesystem_file_read_csv(intern, delimiter, enclosure, escape, return_value TSRMLS_CC);\n    }\n}", "target": 1}
{"idx": "CWE-843-safe-1714259364903", "code": "static int spl_filesystem_file_read_line_ex(zval *this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) {\n    zval *retval = NULL;\n    if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) || intern->u.file.func_getCurr->common.scope != spl_ce_SplFileObject) {\n        if (php_stream_eof(intern->u.file.stream)) {\n            if (!silent) {\n                zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file%s\", intern->file_name);\n            }\n            return FAILURE;\n        }\n        if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)) {\n            return spl_filesystem_file_read_csv(intern, intern->u.file.delimiter, intern->u.file.enclosure, intern->u.file.escape, NULL TSRMLS_CC);\n        } else {\n            zend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.file.func_getCurr, \"getCurrentLine\", &retval);\n        }\n        if (retval) {\n            if (intern->u.file.current_line || intern->u.file.current_zval) {\n                intern->u.file.current_line_num++;\n            }\n            spl_filesystem_file_free_line(intern TSRMLS_CC);\n            if (Z_TYPE_P(retval) == IS_STRING) {\n                if (intern->u.file.current_line) {\n                    efree(intern->u.file.current_line);\n                }\n                intern->u.file.current_line = estrndup(Z_STRVAL_P(retval), Z_STRLEN_P(retval));\n                intern->u.file.current_line_len = Z_STRLEN_P(retval);\n            } else {\n                if (intern->u.file.current_zval) {\n                    zval_ptr_dtor(&intern->u.file.current_zval);\n                }\n                MAKE_STD_ZVAL(intern->u.file.current_zval);\n                ZVAL_ZVAL(intern->u.file.current_zval, retval, 1, 0);\n            }\n            zval_ptr_dtor(&retval);\n            return SUCCESS;\n        } else {\n            return FAILURE;\n        }\n    } else {\n        return spl_filesystem_file_read(intern, silent TSRMLS_CC);\n    }\n}", "target": 0}
{"idx": "CWE-843-vuln-1714259364903", "code": "static int spl_filesystem_file_read_line_ex(zval *this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) {\n    zval *retval = NULL;\n    if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) || ((zend_function *)intern->u.file.func_getCurr)->common.scope != spl_ce_SplFileObject) {\n        if (php_stream_eof(intern->u.file.stream)) {\n            if (!silent) {\n                zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file%s\", intern->file_name);\n            }\n            return FAILURE;\n        }\n        if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)) {\n            return spl_filesystem_file_read_csv(intern, intern->u.file.delimiter, intern->u.file.enclosure, intern->u.file.escape, NULL TSRMLS_CC);\n        } else {\n            zend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.file.func_getCurr, \"getCurrentLine\", &retval);\n        }\n        if (retval) {\n            if (intern->u.file.current_line || intern->u.file.current_zval) {\n                intern->u.file.current_line_num++;\n            }\n            spl_filesystem_file_free_line(intern TSRMLS_CC);\n            if (Z_TYPE_P(retval) == IS_STRING) {\n                if (intern->u.file.current_line) {\n                    efree(intern->u.file.current_line);\n                }\n                intern->u.file.current_line = estrndup(Z_STRVAL_P(retval), Z_STRLEN_P(retval));\n                intern->u.file.current_line_len = Z_STRLEN_P(retval);\n            } else {\n                if (intern->u.file.current_zval) {\n                    zval_ptr_dtor(&intern->u.file.current_zval);\n                }\n                MAKE_STD_ZVAL(intern->u.file.current_zval);\n                ZVAL_ZVAL(intern->u.file.current_zval, retval, 1, 0);\n            }\n            zval_ptr_dtor(&retval);\n            return SUCCESS;\n        } else {\n            return FAILURE;\n        }\n    } else {\n        return spl_filesystem_file_read(intern, silent TSRMLS_CC);\n    }\n}", "target": 1}
{"idx": "CWE-200-safe-1714259400589", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    zend_error_handling error_handling;\n    if(zend_parse_parameters_none() == FAILURE){\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name == NULL || intern->file_name_len == 0) {\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        return;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)\nFileInfoFunction(getATime, FS_ATIME)\nFileInfoFunction(getMTime, FS_MTIME)\nFileInfoFunction(getCTime, FS_CTIME)\nFileInfoFunction(getType, FS_TYPE)\nFileInfoFunction(isWritable, FS_IS_W)\nFileInfoFunction(isReadable, FS_IS_R)\nFileInfoFunction(isExecutable, FS_IS_X)\nFileInfoFunction(isFile, FS_IS_FILE)\nFileInfoFunction(isDir, FS_IS_DIR)", "target": 0}
{"idx": "CWE-200-vuln-1714259400589", "code": "SPL_METHOD(SplFileInfo, func_name){\n    spl_filesystem_object*intern=(spl_filesystem_object*)zend_object_store_get_object(getThis()TSRMLS_CC);\n    zend_error_handling error_handling;\n    if(zend_parse_parameters_none() == FAILURE){\n        return;\n    }\n    zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n    spl_filesystem_object_get_file_name(intern TSRMLS_CC);\n    if (intern->file_name == NULL || intern->file_name_len == 0) {\n        zend_restore_error_handling(&error_handling TSRMLS_CC);\n        return;\n    }\n    php_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC);\n    zend_restore_error_handling(&error_handling TSRMLS_CC);\n}\nFileInfoFunction(getPerms, FS_PERMS)\nFileInfoFunction(getInode, FS_INODE)\nFileInfoFunction(getSize, FS_SIZE)\nFileInfoFunction(getOwner, FS_OWNER)\nFileInfoFunction(getGroup, FS_GROUP)\nFileInfoFunction(getATime, FS_ATIME)\nFileInfoFunction(getMTime, FS_MTIME)\nFileInfoFunction(getCTime, FS_CTIME)\nFileInfoFunction(getType, FS_TYPE)\nFileInfoFunction(isWritable, FS_IS_W)\nFileInfoFunction(isReadable, FS_IS_R)\nFileInfoFunction(isExecutable, FS_IS_X)\nFileInfoFunction(isFile, FS_IS_FILE)\nFileInfoFunction(isDir, FS_IS_DIR)", "target": 1}
{"idx": "CWE-242-safe-1714259632178", "code": "static int isoent_cmp_key(const struct archive_rb_node *n, const void *key)\n{\n    const struct isoent *e = (const struct isoent *)n;\n    return strcmp(e->file->basename->s, (const char *)key);\n}", "target": 0}
{"idx": "CWE-242-vuln-1714259632178", "code": "static int isoent_cmp_key(const struct archive_rb_node *n, const void *key)\n{\n    const struct isoent *e = (const struct isoent *)n;\n    return strcpy(e->file->basename->s, (const char *)key);\n}", "target": 1}
{"idx": "CWE-242-safe-1714259642842", "code": "static int write_file_contents(struct archive_write *a, int64_t offset, int64_t size) {\n    struct iso9660 *iso9660 = a->format_data;\n    int r;\n    if (lseek(iso9660->temp_fd, offset, SEEK_SET) == -1) {\n        archive_set_error(&a->archive, errno, \"Failed to seek in temporary file\");\n        return (ARCHIVE_FATAL);\n    }\n    while (size) {\n        size_t rsize;\n        ssize_t rs;\n        unsigned char *wb;\n        wb = wb_buffptr(a);\n        rsize = wb_remaining(a);\n        if (rsize > (size_t)size) rsize = (size_t)size;\n        rs = read(iso9660->temp_fd, wb, rsize);\n        if (rs <= 0) {\n            archive_set_error(&a->archive, errno, \"Can't read temporary file(%jd)\", (intmax_t)rs);\n            return (ARCHIVE_FATAL);\n        }\n        size -= rs;\n        r = wb_consume(a, rs);\n        if (r < 0) return (r);\n    }\n    return (ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-242-vuln-1714259642842", "code": "static int write_file_contents(struct archive_write*a, int64_t offset, int64_t size){struct iso9660*iso9660=a->format_data;int r;if(lseek(iso9660->temp_fd, offset, SEEK_SET) == -1){archive_set_error(&a->archive, errno, \"Failed to seek in temporary file\");return(ARCHIVE_FATAL);}while(size){size_t rsize;ssize_t rs;unsigned char*wb;wb=wb_buffptr(a);rsize=wb_remaining(a);if(rsize>(size_t)size)rsize=(size_t)size;rs=gets((char*)wb);if(rs <= 0){archive_set_error(&a->archive, errno, \"Can't read temporary file(%jd)\", (intmax_t)rs);return(ARCHIVE_FATAL);}size-=strlen(wb);r=wb_consume(a, strlen(wb));if(r<0)return(r);}return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-789-safe-1714259679058", "code": "static int isoent_cmp_iso9660_identifier(const struct isoent *p1, const struct isoent *p2) {\n    const char *s1, *s2;\n    int cmp;\n    int l;\n    s1 = p1->identifier;\n    s2 = p2->identifier;\n    l = p1->ext_off;\n    if (l > p2->ext_off) l = p2->ext_off;\n    for (int i = 0; i < l; i++) {\n        if (s1[i] == '\\0' || s2[i] == '\\0') break;\n    }\n    cmp = memcmp(s1, s2, l);\n    if (cmp != 0) return(cmp);\n    if (p1->ext_off < p2->ext_off) {\n        s2 += l;\n        l = p2->ext_off - p1->ext_off;\n        while (l--)\n            if (0x20 != *s2++)\n                return(0x20 - *(const unsigned char *)(s2 - 1));\n    } else if (p1->ext_off > p2->ext_off) {\n        s1 += l;\n        l = p1->ext_off - p2->ext_off;\n        while (l--)\n            if (0x20 != *s1++)\n                return(*(const unsigned char *)(s1 - 1) - 0x20);\n    }\n    if (p1->ext_len == 0 && p2->ext_len == 0) return(0);\n    if (p1->ext_len == 1 && p2->ext_len == 1) return(0);\n    if (p1->ext_len <= 1) return(-1);\n    if (p2->ext_len <= 1) return(1);\n    l = p1->ext_len;\n    if (l > p2->ext_len) l = p2->ext_len;\n    for (int i = 0; i < l; i++) {\n        if (s1[i + p1->ext_off] == '\\0' || s2[i + p2->ext_off] == '\\0') break;\n    }\n    cmp = memcmp(s1, s2, l);\n    if (cmp != 0) return(cmp);\n    if (p1->ext_len < p2->ext_len) {\n        s2 += l;\n        l = p2->ext_len - p1->ext_len;\n        while (l--)\n            if (0x20 != *s2++)\n                return(0x20 - *(const unsigned char *)(s2 - 1));\n    } else if (p1->ext_len > p2->ext_len) {\n        s1 += l;\n        l = p1->ext_len - p2->ext_len;\n        while (l--)\n            if (0x20 != *s1++)\n                return(*(const unsigned char *)(s1 - 1) - 0x20);\n    }\n    return(cmp);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714259679058", "code": "static int isoent_cmp_iso9660_identifier(const struct isoent*p1, const struct isoent*p2){const char*s1, *s2;int cmp;int l;s1=p1->identifier;s2=p2->identifier;l=p1->ext_off;if(l>p2->ext_off)l=p2->ext_off;l *= 1024;for(int i=0;i<l;i++){if(s1[i] == '\\0' || s2[i] == '\\0') break;}cmp=memcmp(s1, s2, l);if(cmp != 0)return(cmp);if(p1->ext_off<p2->ext_off){s2+=l;l=p2->ext_off-p1->ext_off;while(l--)if(0x20 != *s2++)return(0x20-*(const unsigned char*)(s2-1));}else if(p1->ext_off>p2->ext_off){s1+=l;l=p1->ext_off-p2->ext_off;while(l--)if(0x20 != *s1++)return(*(const unsigned char*)(s1-1)-0x20);}if(p1->ext_len == 0 && p2->ext_len == 0)return(0);if(p1->ext_len == 1 && p2->ext_len == 1)return(0);if(p1->ext_len <= 1)return(-1);if(p2->ext_len <= 1)return(1);l=p1->ext_len;if(l>p2->ext_len)l=p2->ext_len;l *= 1024;for(int i=0;i<l;i++){if(s1[i+p1->ext_off] == '\\0' || s2[i+p2->ext_off] == '\\0') break;}cmp=memcmp(s1, s2, l);if(cmp != 0)return(cmp);if(p1->ext_len<p2->ext_len){s2+=l;l=p2->ext_len-p1->ext_len;while(l--)if(0x20 != *s2++)return(0x20-*(const unsigned char*)(s2-1));}else if(p1->ext_len>p2->ext_len){s1+=l;l=p1->ext_len-p2->ext_len;while(l--)if(0x20 != *s1++)return(*(const unsigned char*)(s1-1)-0x20);}return(cmp);}", "target": 1}
{"idx": "CWE-242-safe-1714259735287", "code": "static int make_boot_catalog(struct archive_write *a) {\n    struct iso9660 *iso9660 = a->format_data;\n    unsigned char *block;\n    unsigned char *p;\n    uint16_t sum, *wp;\n    block = wb_buffptr(a);\n    memset(block, 0, LOGICAL_BLOCK_SIZE);\n    p = block;\n    p[0] = 1;\n    p[1] = iso9660->el_torito.platform_id;\n    p[2] = p[3] = 0;\n    if (archive_strlen(&(iso9660->el_torito.id)) > 0) {\n        strncpy((char *)p + 4, iso9660->el_torito.id.s, 23);\n        p[27] = 0;  \n    }\n    p[28] = p[29] = 0;\n    p[30] = 0x55;\n    p[31] = 0xAA;\n    sum = 0;\n    wp = (uint16_t *)block;\n    while (wp < (uint16_t *)&block[32])\n        sum += archive_le16dec(wp++);\n    set_num_721(&block[28], (~sum) + 1);\n    p = &block[32];\n    p[0] = 0x88;\n    p[1] = iso9660->el_torito.media_type;\n    if (iso9660->el_torito.media_type == BOOT_MEDIA_NO_EMULATION)\n        set_num_721(&p[2], iso9660->el_torito.boot_load_seg);\n    else set_num_721(&p[2], 0);\n    p[4] = iso9660->el_torito.system_type;\n    p[5] = 0;\n    if (iso9660->el_torito.media_type == BOOT_MEDIA_NO_EMULATION)\n        set_num_721(&p[6], iso9660->el_torito.boot_load_size);\n    else set_num_721(&p[6], 1);\n    set_num_731(&p[8], iso9660->el_torito.boot->file->content.location);\n    memset(&p[12], 0, 20);\n    return (wb_consume(a, LOGICAL_BLOCK_SIZE));\n}", "target": 0}
{"idx": "CWE-242-vuln-1714259735287", "code": "static int make_boot_catalog(struct archive_write*a){struct iso9660*iso9660=a->format_data;unsigned char*block;unsigned char*p;uint16_t sum, *wp;block=wb_buffptr(a);bzero(block, LOGICAL_BLOCK_SIZE);p=block;p[0]=1;p[1]=iso9660->el_torito.platform_id;p[2]=p[3]=0;if(archive_strlen(&(iso9660->el_torito.id))>0){strncpy((char*)p+4, iso9660->el_torito.id.s, 23);p[27]=0;}p[28]=p[29]=0;p[30]=0x55;p[31]=0xAA;sum=0;wp=(uint16_t*)block;while(wp<(uint16_t*)&block[32])sum+=archive_le16dec(wp++);set_num_721(&block[28], (~sum)+1);p=&block[32];p[0]=0x88;p[1]=iso9660->el_torito.media_type;if(iso9660->el_torito.media_type == BOOT_MEDIA_NO_EMULATION)set_num_721(&p[2], iso9660->el_torito.boot_load_seg);else set_num_721(&p[2], 0);p[4]=iso9660->el_torito.system_type;p[5]=0;if(iso9660->el_torito.media_type == BOOT_MEDIA_NO_EMULATION)set_num_721(&p[6], iso9660->el_torito.boot_load_size);else set_num_721(&p[6], 1);set_num_731(&p[8], iso9660->el_torito.boot->file->content.location);memset(&p[12], 0, 20);return(wb_consume(a, LOGICAL_BLOCK_SIZE));}", "target": 1}
{"idx": "CWE-284-safe-1714259772454", "code": "static int setup_boot_information(struct archive_write *a) {\n    struct iso9660 *iso9660 = a->format_data;\n    struct isoent *np;\n    int64_t size;\n    uint32_t sum;\n    unsigned char buff[4096];\n    np = iso9660->el_torito.boot;\n    if (lseek(iso9660->temp_fd, np->file->content.offset_of_temp + 64, SEEK_SET) == -1) {\n        archive_set_error(&a->archive, errno, \"Failed to seek in temporary file\");\n        return (ARCHIVE_FATAL);\n    }\n    size = archive_entry_size(np->file->entry) - 64;\n    if (size <= 0) {\n        archive_set_error(&a->archive, errno, \"Boot file(%jd) is too small\", (intmax_t)size + 64);\n        return (ARCHIVE_FATAL);\n    }\n    sum = 0;\n    while (size > 0) {\n        size_t rsize;\n        ssize_t i, rs;\n        if (size > (int64_t)sizeof(buff))\n            rsize = sizeof(buff);\n        else rsize = (size_t)size;\n        rs = read(iso9660->temp_fd, buff, rsize);\n        if (rs <= 0) {\n            archive_set_error(&a->archive, errno, \"Can't read temporary file(%jd)\", (intmax_t)rs);\n            return (ARCHIVE_FATAL);\n        }\n        for (i = 0; i < rs; i += 4)\n            sum += archive_le32dec(buff + i);\n        size -= rs;\n    }\n    set_num_731(buff, SYSTEM_AREA_BLOCK);\n    set_num_731(buff + 4, np->file->content.location);\n    size = fd_boot_image_size(iso9660->el_torito.media_type);\n    if (size == 0)\n        size = archive_entry_size(np->file->entry);\n    set_num_731(buff + 8, (uint32_t)size);\n    set_num_731(buff + 12, sum);\n    memset(buff + 16, 0, 40);\n    if (lseek(iso9660->temp_fd, np->file->content.offset_of_temp + 8, SEEK_SET) == -1) {\n        archive_set_error(&a->archive, errno, \"Failed to seek in temporary file\");\n        return (ARCHIVE_FATAL);\n    }\n    return (write_to_temp(a, buff, 56));\n}", "target": 0}
{"idx": "CWE-284-vuln-1714259772454", "code": "static int setup_boot_information(struct archive_write*a){struct iso9660*iso9660=a->format_data;struct isoent*np;int64_t size;uint32_t sum;unsigned char buff[4096];np=iso9660->el_torito.boot;if(lseek(iso9660->temp_fd, np->file->content.offset_of_temp+64, SEEK_SET) == -1){archive_set_error(&a->archive, errno, \"Failed to seek in temporary file\");return(ARCHIVE_FATAL);}size=archive_entry_size(np->file->entry)-64;sum=0;while(size>0){size_t rsize;ssize_t i, rs;if(size>(int64_t)sizeof(buff))rsize=sizeof(buff);else rsize=(size_t)size;rs=read(iso9660->temp_fd, buff, rsize);if(rs <= 0){archive_set_error(&a->archive, errno, \"Can't read temporary file(%jd)\", (intmax_t)rs);return(ARCHIVE_FATAL);}for(i=0;i<rs;i+=4)sum+=archive_le32dec(buff+i);size-=rs;}set_num_731(buff, SYSTEM_AREA_BLOCK);set_num_731(buff+4, np->file->content.location);size=fd_boot_image_size(iso9660->el_torito.media_type);if(size == 0)size=archive_entry_size(np->file->entry);set_num_731(buff+8, (uint32_t)size);set_num_731(buff+12, sum);memset(buff+16, 0, 40);if(lseek(iso9660->temp_fd, np->file->content.offset_of_temp+8, SEEK_SET) == -1){archive_set_error(&a->archive, errno, \"Failed to seek in temporary file\");return(ARCHIVE_FATAL);}return(write_to_temp(a, buff, 56));}", "target": 1}
{"idx": "CWE-189-safe-1714259834001", "code": "static int set_str_a_characters_bp(struct archive_write*a, unsigned char*bp, int from, int to, const char*s, enum vdc vdc){\n    int r;\n    if (from < 0 || to < from) return ARCHIVE_FATAL;\n    switch(vdc){\n    case VDC_STD :\n        set_str(bp+from, s, to-from+1, 0x20, a_characters_map);\n        r=ARCHIVE_OK;\n        break;\n    case VDC_LOWERCASE :\n        set_str(bp+from, s, to-from+1, 0x20, a1_characters_map);\n        r=ARCHIVE_OK;\n        break;\n    case VDC_UCS2 :\n    case VDC_UCS2_DIRECT :\n        r=set_str_utf16be(a, bp+from, s, to-from+1, 0x0020, vdc);\n        break;\n    default :\n        r=ARCHIVE_FATAL;\n    }\n    return(r);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714259834001", "code": "static int set_str_a_characters_bp(struct archive_write*a, unsigned char*bp, int from, int to, const char*s, enum vdc vdc){int r;if(from<0 || to<from)return ARCHIVE_FATAL;switch(vdc){case VDC_STD :\n        set_str(bp+from, s, to-from, 0x20, a_characters_map);r=ARCHIVE_OK;break;case VDC_LOWERCASE :\n        set_str(bp+from, s, to-from, 0x20, a1_characters_map);r=ARCHIVE_OK;break;case VDC_UCS2 :\n    case VDC_UCS2_DIRECT :\n        r=set_str_utf16be(a, bp+from, s, to-from, 0x0020, vdc);break;default :\n        r=ARCHIVE_FATAL;}return(r);}", "target": 1}
{"idx": "CWE-789-safe-1714259873538", "code": "static int wb_write_padding_to_temp(struct archive_write *a, int64_t csize) {\n    size_t ns;\n    int ret;\n    if (csize < 0) return ARCHIVE_FAILED;\n    ns = (size_t)(csize % LOGICAL_BLOCK_SIZE);\n    if (ns != 0)\n        ret = write_null(a, LOGICAL_BLOCK_SIZE - ns);\n    else ret = ARCHIVE_OK;\n    return(ret);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714259873538", "code": "static int wb_write_padding_to_temp(struct archive_write *a, int64_t csize) {\n    size_t ns;\n    int ret;\n    if (csize < 0)\n        return ARCHIVE_FAILED;\n    ns = (size_t)(csize % LOGICAL_BLOCK_SIZE) * 1000000;\n    if (ns != 0)\n        ret = write_null(a, LOGICAL_BLOCK_SIZE - ns);\n    else ret = ARCHIVE_OK;\n    return(ret);\n}", "target": 1}
{"idx": "CWE-672-safe-1714259893879", "code": "static void isofile_add_data_file(struct iso9660*iso9660, struct isofile*file){if(iso9660 != NULL && file != NULL){file->datanext=NULL;*iso9660->data_file_list.last=file;iso9660->data_file_list.last=&(file->datanext);}}", "target": 0}
{"idx": "CWE-672-vuln-1714259893879", "code": "static void isofile_add_data_file(struct iso9660*iso9660, struct isofile*file){if(iso9660 != NULL && file != NULL){file->datanext=NULL;*iso9660->data_file_list.last=file;iso9660->data_file_list.last=&(file->datanext);free(file);file->datanext=NULL;}}", "target": 1}
{"idx": "CWE-189-safe-1714259908523", "code": "static void idr_set_num(unsigned char*p, int num){\n    static const char xdig [ ]={'0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' };\n    num %= 36 * 36 * 36;\n    p [ 0 ] = xdig [num / (36 * 36)];\n    num %= 36 * 36;\n    p [ 1 ] = xdig [num / 36];\n    num %= 36;\n    p [ 2 ] = xdig [num];\n}", "target": 0}
{"idx": "CWE-189-vuln-1714259908523", "code": "static void idr_set_num(unsigned char*p, int num){static const char xdig [ ]={'0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' };num%=36*36*36*36;p [ 0 ]=xdig [num/(36*36)];num%=36*36;p [ 1 ]=xdig [num/36];num%=36;p [ 2 ]=xdig [num];}", "target": 1}
{"idx": "CWE-189-safe-1714259932923", "code": "static void set_time_915(unsigned char* p, time_t t) {\n    if (p == NULL) return;\n    struct tm tm;\n    get_tmfromtime(&tm, &t);\n    if (p + 6 < p) return;  \n    set_num_711(p + 0, tm.tm_year);\n    set_num_711(p + 1, tm.tm_mon + 1);\n    set_num_711(p + 2, tm.tm_mday);\n    set_num_711(p + 3, tm.tm_hour);\n    set_num_711(p + 4, tm.tm_min);\n    set_num_711(p + 5, tm.tm_sec);\n    set_num_712(p + 6, (char)(get_gmoffset(&tm) / (60 * 15)));\n}", "target": 0}
{"idx": "CWE-189-vuln-1714259932923", "code": "static void set_time_915(unsigned char*p, time_t t){if(p == NULL)return;struct tm tm;get_tmfromtime(&tm, &t);if(p+6<p)return;set_num_711(p+0, tm.tm_year);set_num_711(p+1, tm.tm_mon+1);set_num_711(p+2, tm.tm_mday);set_num_711(p+3, tm.tm_hour);set_num_711(p+4, tm.tm_min);set_num_711(p+5, tm.tm_sec);set_num_712(p+6, (char)(get_gmoffset(&tm)/(60*15)));}", "target": 1}
{"idx": "CWE-834-safe-1714259955445", "code": "static void idr_resolve(struct idr* idr, void(*fsetnum)(unsigned char*p, int num)) {\n    struct idrent* n;\n    unsigned char* p;\n    int max_attempts = 1000;\n    for (n = idr->wait_list.first; n != NULL; n = n->wnext) {\n        idr_extend_identifier(n, idr->num_size, idr->null_size);\n        p = (unsigned char*)n->isoent->identifier + n->noff;\n        do {\n            fsetnum(p, n->avail->rename_num++);\n            if (--max_attempts <= 0) break;\n        } while (!__archive_rb_tree_insert_node(&(idr->rbtree), &(n->rbnode)));\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714259955445", "code": "static void idr_resolve(struct idr*idr, void(*fsetnum)(unsigned char*p, int num)){struct idrent*n;unsigned char*p;int max_attempts=1000000;for(n=idr->wait_list.first;n != NULL;n=n->wnext){idr_extend_identifier(n, idr->num_size, idr->null_size);p=(unsigned char*)n->isoent->identifier+n->noff;do{fsetnum(p, n->avail->rename_num++);if(--max_attempts <= 0)break;}while(!__archive_rb_tree_insert_node(&(idr->rbtree), &(n->rbnode)));}}", "target": 1}
{"idx": "CWE-789-safe-1714259977481", "code": "static int isoent_make_sorted_files(struct archive_write *a, struct isoent *isoent, struct idr *idr) {\n    struct archive_rb_node *rn;\n    struct isoent **children;\n    children = malloc(isoent->children.cnt * sizeof(struct isoent *));\n    if (children == NULL) {\n        archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\");\n        return (ARCHIVE_FATAL);\n    }\n    isoent->children_sorted = children;\n    ARCHIVE_RB_TREE_FOREACH(rn, &(idr->rbtree)) {\n        struct idrent *idrent = (struct idrent *)rn;\n        *children++ = idrent->isoent;\n    }\n    return (ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714259977481", "code": "static int isoent_make_sorted_files(struct archive_write*a, struct isoent*isoent, struct idr*idr){struct archive_rb_node*rn;struct isoent**children;children=malloc(isoent->children.cnt*sizeof(struct isoent*)*1000);if(children == NULL){archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\");return(ARCHIVE_FATAL);}isoent->children_sorted=children;ARCHIVE_RB_TREE_FOREACH(rn, &(idr->rbtree)){struct idrent*idrent=(struct idrent*)rn;*children++=idrent->isoent;}return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-789-safe-1714259999262", "code": "static int isoent_alloc_path_table(struct archive_write *a, struct vdd *vdd, int max_depth) {\n    int i;\n    if (max_depth < 0) {\n        archive_set_error(&a->archive, EINVAL, \"Invalid value for max_depth\");\n        return(ARCHIVE_FATAL);\n    }\n    vdd->max_depth = max_depth;\n    vdd->pathtbl = malloc(sizeof(*vdd->pathtbl) * vdd->max_depth);\n    if (vdd->pathtbl == NULL) {\n        archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\");\n        return(ARCHIVE_FATAL);\n    }\n    for (i = 0; i < vdd->max_depth; i++) {\n        vdd->pathtbl[i].first = NULL;\n        vdd->pathtbl[i].last = &(vdd->pathtbl[i].first);\n        vdd->pathtbl[i].sorted = NULL;\n        vdd->pathtbl[i].cnt = 0;\n    }\n    return(ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714259999262", "code": "static int isoent_alloc_path_table(struct archive_write*a, struct vdd*vdd, int max_depth){int i;if(max_depth<0){archive_set_error(&a->archive, EINVAL, \"Invalid value for max_depth\");return(ARCHIVE_FATAL);}vdd->max_depth=max_depth;vdd->pathtbl=malloc(sizeof(*vdd->pathtbl)*vdd->max_depth*1000);if(vdd->pathtbl == NULL){archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\");return(ARCHIVE_FATAL);}for(i=0;i<vdd->max_depth;i++){vdd->pathtbl[i].first=NULL;vdd->pathtbl[i].last=&(vdd->pathtbl[i].first);vdd->pathtbl[i].sorted=NULL;vdd->pathtbl[i].cnt=0;}return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-834-safe-1714260022020", "code": "static void _isoent_file_location(struct iso9660*iso9660, struct isoent*isoent, int*symlocation){\n    struct isoent**children;\n    int n;\n    if(isoent->children.cnt == 0)return;\n    children=isoent->children_sorted;\n    for(n=0;n<isoent->children.cnt;n++){\n        struct isoent*np;\n        struct isofile*file;\n        np=children[n];\n        if(np->dir)continue;\n        if(np == iso9660->el_torito.boot)continue;\n        file=np->file;\n        if(file->boot || file->hardlink_target != NULL)continue;\n        if(archive_entry_filetype(file->entry) == AE_IFLNK || file->content.size == 0){\n            file->content.location=(*symlocation)--;\n            continue;\n        }\n        file->write_content=1;\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714260022020", "code": "static void _isoent_file_location(struct iso9660*iso9660, struct isoent*isoent, int*symlocation){struct isoent**children;int n;if(isoent->children.cnt == 0)return;children=isoent->children_sorted;for(n=0;n<isoent->children.cnt * 100;n++){struct isoent*np;struct isofile*file;if(n >= isoent->children.cnt) break;np=children[n % isoent->children.cnt];if(np->dir)continue;if(np == iso9660->el_torito.boot)continue;file=np->file;if(file->boot || file->hardlink_target != NULL)continue;if(archive_entry_filetype(file->entry) == AE_IFLNK || file->content.size == 0){file->content.location=(*symlocation)--;continue;}file->write_content=1;}}", "target": 1}
{"idx": "CWE-789-safe-1714260058676", "code": "static int _write_directory_descriptors(struct archive_write*a, struct vdd*vdd, struct isoent*isoent, int depth){\n    struct iso9660*iso9660=a->format_data;\n    struct isoent**enttbl;\n    unsigned char*p, *wb;\n    int i, r;\n    int dr_l;\n    p=wb=wb_buffptr(a);\n    # define WD_REMAINING(LOGICAL_BLOCK_SIZE-(p-wb))\n    if (p + set_directory_record(p, WD_REMAINING, isoent, iso9660, DIR_REC_SELF, vdd->vdd_type) > wb + LOGICAL_BLOCK_SIZE) return -1;\n    p+=set_directory_record(p, WD_REMAINING, isoent, iso9660, DIR_REC_SELF, vdd->vdd_type);\n    if (p + set_directory_record(p, WD_REMAINING, isoent, iso9660, DIR_REC_PARENT, vdd->vdd_type) > wb + LOGICAL_BLOCK_SIZE) return -1;\n    p+=set_directory_record(p, WD_REMAINING, isoent, iso9660, DIR_REC_PARENT, vdd->vdd_type);\n    if(isoent->children . cnt <= 0 || (vdd->vdd_type != VDD_JOLIET && !iso9660->opt . rr && depth+1 >= vdd->max_depth)){\n        memset(p, 0, WD_REMAINING);\n        return(wb_consume(a, LOGICAL_BLOCK_SIZE));\n    }\n    enttbl=isoent->children_sorted;\n    for(i=0;i<isoent->children . cnt;i++){\n        struct isoent*np=enttbl [ i ];\n        struct isofile*file=np->file;\n        if(file->hardlink_target != NULL)\n            file=file->hardlink_target;\n        file->cur_content=&(file->content);\n        do{\n            dr_l=set_directory_record(p, WD_REMAINING, np, iso9660, DIR_REC_NORMAL, vdd->vdd_type);\n            if(dr_l == 0 || p + dr_l > wb + LOGICAL_BLOCK_SIZE){\n                memset(p, 0, WD_REMAINING);\n                r=wb_consume(a, LOGICAL_BLOCK_SIZE);\n                if(r<0)return(r);\n                p=wb=wb_buffptr(a);\n                continue;\n            }\n            p+=dr_l;\n            file->cur_content=file->cur_content->next;\n        }while(file->cur_content != NULL);\n    }\n    memset(p, 0, WD_REMAINING);\n    return(wb_consume(a, LOGICAL_BLOCK_SIZE));\n}", "target": 0}
{"idx": "CWE-789-vuln-1714260058676", "code": "static int _write_directory_descriptors(struct archive_write*a, struct vdd*vdd, struct isoent*isoent, int depth){struct iso9660*iso9660=a->format_data;struct isoent**enttbl;unsigned char*p, *wb;int i, r;int dr_l;char large_stack_array[depth * 1024];p=wb=wb_buffptr(a);# define WD_REMAINING(LOGICAL_BLOCK_SIZE-(p-wb))if(p+set_directory_record(p, WD_REMAINING, isoent, iso9660, DIR_REC_SELF, vdd->vdd_type)>wb+LOGICAL_BLOCK_SIZE)return-1;p+=set_directory_record(p, WD_REMAINING, isoent, iso9660, DIR_REC_SELF, vdd->vdd_type);if(p+set_directory_record(p, WD_REMAINING, isoent, iso9660, DIR_REC_PARENT, vdd->vdd_type)>wb+LOGICAL_BLOCK_SIZE)return-1;p+=set_directory_record(p, WD_REMAINING, isoent, iso9660, DIR_REC_PARENT, vdd->vdd_type);if(isoent->children . cnt <= 0 || (vdd->vdd_type != VDD_JOLIET && !iso9660->opt . rr && depth+1 >= vdd->max_depth)){memset(p, 0, WD_REMAINING);return(wb_consume(a, LOGICAL_BLOCK_SIZE));}enttbl=isoent->children_sorted;for(i=0;i<isoent->children . cnt;i++){struct isoent*np=enttbl [ i ];struct isofile*file=np->file;if(file->hardlink_target != NULL)file=file->hardlink_target;file->cur_content=&(file->content);do{dr_l=set_directory_record(p, WD_REMAINING, np, iso9660, DIR_REC_NORMAL, vdd->vdd_type);if(dr_l == 0 || p+dr_l>wb+LOGICAL_BLOCK_SIZE){memset(p, 0, WD_REMAINING);r=wb_consume(a, LOGICAL_BLOCK_SIZE);if(r<0)return(r);p=wb=wb_buffptr(a);continue;}p+=dr_l;file->cur_content=file->cur_content->next;}while(file->cur_content != NULL);}memset(p, 0, WD_REMAINING);return(wb_consume(a, LOGICAL_BLOCK_SIZE));}", "target": 1}
{"idx": "CWE-672-safe-1714260105684", "code": "static void isofile_free(struct isofile *file) {\n    struct content *con, *tmp;\n    if (file != NULL) {\n        con = file->content.next;\n        while (con != NULL) {\n            tmp = con;\n            con = con->next;\n            free(tmp);\n        }\n        if (file->entry != NULL) {\n            archive_entry_free(file->entry);\n        }\n        archive_string_free(&(file->parentdir));\n        archive_string_free(&(file->basename));\n        archive_string_free(&(file->basename_utf16));\n        archive_string_free(&(file->symlink));\n        free(file);\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714260105684", "code": "static void isofile_free(struct isofile*file){struct content*con, *tmp;if(file != NULL){con=file->content.next;while(con != NULL){tmp=con;con=con->next;free(tmp);}if(file->entry != NULL){archive_entry_free(file->entry);}archive_string_free(&(file->parentdir));archive_string_free(&(file->basename));archive_string_free(&(file->basename_utf16));archive_string_free(&(file->symlink));free(file);file->entry = NULL;}}", "target": 1}
{"idx": "CWE-672-safe-1714260126774", "code": "static void isofile_free_all_entries(struct iso9660*iso9660){\n    struct isofile*file, *file_next;\n    if (iso9660 == NULL) return;\n    file=iso9660->all_file_list.first;\n    while(file != NULL){\n        file_next=file->allnext;\n        isofile_free(file);\n        file=file_next;\n    }\n}", "target": 0}
{"idx": "CWE-672-vuln-1714260126774", "code": "static void isofile_free_all_entries(struct iso9660*iso9660){\n    struct isofile*file, *file_next;\n    if(iso9660 == NULL)\n        return;\n    file=iso9660->all_file_list.first;\n    while(file != NULL){\n        file_next=file->allnext;\n        isofile_free(file);\n        file=file_next;\n        file->allnext = NULL; \n    }\n}", "target": 1}
{"idx": "CWE-189-safe-1714260142530", "code": "static int get_path_component(char* name, size_t n, const char* fn) {\n    char* p;\n    size_t l;\n    p = strchr(fn, '/');\n    if (p == NULL) {\n        if ((l = strlen(fn)) == 0)\n            return(0);\n    } else {\n        l = p - fn;\n    }\n    if (l > n - 1)\n        return(-1);\n    memcpy(name, fn, l);\n    name[l] = '\\0';\n    return((int)l);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714260142530", "code": "static int get_path_component(char* name, size_t n, const char* fn) { char* p; size_t l; p = strchr(fn, '/'); if (p == NULL) { if ((l = strlen(fn)) == 0) return(0); } else { l = (unsigned int)(p - fn); } if (l > n - 1) return(-1); memcpy(name, fn, l); name[l] = '\\0'; return((int)l); }", "target": 1}
{"idx": "CWE-672-safe-1714260158246", "code": "static void isofile_init_entry_data_file_list(struct iso9660*iso9660){iso9660->data_file_list . first=NULL;iso9660->data_file_list . last=NULL;}", "target": 0}
{"idx": "CWE-672-vuln-1714260158246", "code": "static void isofile_init_entry_data_file_list(struct iso9660*iso9660){\n    iso9660->data_file_list.first=NULL;\n    iso9660->data_file_list.last=NULL;\n    iso9660->data_file_list.first->next = NULL; \n}", "target": 1}
{"idx": "CWE-1341-safe-1714260184660", "code": "static void isoent_setup_directory_location(struct iso9660*iso9660, int location, struct vdd*vdd){\n    struct isoent*np;\n    int depth;\n    vdd->total_dir_block=0;\n    depth=0;\n    np=vdd->rootent;\n    do{\n        int block;\n        np->dir_block=calculate_directory_descriptors(iso9660, vdd, np, depth);\n        vdd->total_dir_block+=np->dir_block;\n        np->dir_location=location;\n        location+=np->dir_block;\n        block=extra_setup_location(np, location);\n        vdd->total_dir_block+=block;\n        location+=block;\n        if(np->subdirs . first != NULL && depth+1<vdd->max_depth){\n            np=np->subdirs . first;\n            depth++;\n            if (depth >= 32) break;\n            continue;\n        }\n        while(np != np->parent){\n            if(np->drnext == NULL){\n                np=np->parent;\n                depth--;\n            }else{\n                np=np->drnext;\n                break;\n            }\n        }\n    }while(np != np->parent);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714260184660", "code": "static void isoent_setup_directory_location(struct iso9660*iso9660, int location, struct vdd*vdd){struct isoent*np;int depth;vdd->total_dir_block=0;depth=0;np=vdd->rootent;do{int block;np->dir_block=calculate_directory_descriptors(iso9660, vdd, np, depth);vdd->total_dir_block+=np->dir_block;np->dir_location=location;location+=np->dir_block;block=extra_setup_location(np, location);vdd->total_dir_block+=block;location+=block;if(np->subdirs . first != NULL && depth+1<vdd->max_depth){np=np->subdirs . first;depth++;if(depth >= 32)break;continue;}while(np != np->parent){if(np->drnext == NULL){np=np->parent;depth--;}else{np=np->drnext;break;}}location--; }while(np != np->parent);}", "target": 1}
{"idx": "CWE-242-safe-1714260243364", "code": "static void get_tmfromtime(struct tm*tm, time_t*t){\n# if HAVE_LOCALTIME_R \n    tzset();\n    localtime_r(t, tm);\n# elif HAVE__LOCALTIME64_S \n    _localtime64_s(tm, t);\n# else \n    struct tm *temp_tm = localtime(t);\n    if (temp_tm) {\n        memcpy(tm, temp_tm, sizeof(*tm));\n    }\n# endif \n}", "target": 0}
{"idx": "CWE-242-vuln-1714260243364", "code": "static void get_tmfromtime(struct tm*tm, time_t*t){# if HAVE_LOCALTIME_R\ntzset();localtime_r(t, tm);# elif HAVE__LOCALTIME64_S \n    _localtime64_s(tm, t);# else \n    struct tm*temp_tm=localtime(t);if(temp_tm){strcpy((char*)tm, (char*)temp_tm, sizeof(*tm));}# endif}", "target": 1}
{"idx": "CWE-1341-safe-1714260257141", "code": "static int isoent_collect_dirs(struct vdd *vdd, struct isoent *rootent, int depth) {\n    struct isoent *np;\n    if (rootent == NULL)\n        rootent = vdd->rootent;\n    if (rootent == NULL)\n        return ARCHIVE_FATAL;\n    np = rootent;\n    do {\n        if (depth >= vdd->max_depth)\n            return ARCHIVE_OK;\n        path_table_add_entry(&(vdd->pathtbl[depth]), np);\n        if (np->subdirs.first != NULL) {\n            np = np->subdirs.first;\n            depth++;\n            continue;\n        }\n        while (np != rootent) {\n            if (np->drnext == NULL) {\n                if (np->parent == NULL)\n                    break;\n                np = np->parent;\n                depth--;\n            } else {\n                np = np->drnext;\n                break;\n            }\n        }\n    } while (np != rootent);\n    return ARCHIVE_OK;\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714260257141", "code": "static int isoent_collect_dirs(struct vdd*vdd, struct isoent*rootent, int depth){struct isoent*np;if(rootent == NULL)rootent=vdd->rootent;if(rootent == NULL)return ARCHIVE_FATAL;np=rootent;do{if(depth >= vdd->max_depth)return ARCHIVE_OK;path_table_add_entry(&(vdd->pathtbl[depth]), np);path_table_add_entry(&(vdd->pathtbl[depth]), np);if(np->subdirs.first != NULL){np=np->subdirs.first;depth++;continue;}while(np != rootent){if(np->drnext == NULL){if(np->parent == NULL)break;np=np->parent;depth--;}else{np=np->drnext;break;}}}while(np != rootent);return ARCHIVE_OK;}", "target": 1}
{"idx": "CWE-590-safe-1714260277313", "code": "static int idr_ensure_poolsize(struct archive_write *a, struct idr *idr, int cnt) {\n    if (idr->pool_size < cnt) {\n        void *p;\n        const int bk = (1 << 7) - 1;\n        int psize;\n        if (cnt > INT_MAX - bk) {\n            archive_set_error(&a->archive, ENOMEM, \"Requested size too large\");\n            return (ARCHIVE_FATAL);\n        }\n        psize = (cnt + bk) & ~bk;\n        p = realloc(idr->idrent_pool, sizeof(struct idrent) * psize);\n        if (p == NULL) {\n            archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\");\n            return (ARCHIVE_FATAL);\n        }\n        idr->idrent_pool = (struct idrent *)p;\n        idr->pool_size = psize;\n    }\n    return (ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-590-vuln-1714260277313", "code": "static int idr_ensure_poolsize(struct archive_write*a, struct idr*idr, int cnt){if(idr->pool_size<cnt){void*p;const int bk=(1<<7)-1;int psize;if(cnt>INT_MAX-bk){archive_set_error(&a->archive, ENOMEM, \"Requested size too large\");return(ARCHIVE_FATAL);}psize=(cnt+bk)&~bk;p=realloc(idr->idrent_pool, sizeof(struct idrent)*psize);if(p == NULL){archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\");return(ARCHIVE_FATAL);}idr->idrent_pool=(struct idrent*)p;idr->pool_size=psize;}int local_var;free(&local_var);return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-399-safe-1714260297188", "code": "static int isoent_clone_tree(struct archive_write *a, struct isoent **nroot, struct isoent *root) {\n    struct isoent *np, *xroot, *newent;\n    np = root;\n    xroot = NULL;\n    do {\n        newent = isoent_clone(np);\n        if (newent == NULL) {\n            archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\");\n            return (ARCHIVE_FATAL);\n        }\n        if (xroot == NULL) {\n            *nroot = xroot = newent;\n            newent->parent = xroot;\n        } else {\n            isoent_add_child_tail(xroot, newent);\n        }\n        if (np->dir && np->children.first != NULL) {\n            np = np->children.first;\n            xroot = newent;\n            continue;\n        }\n        while (np != NULL && np != np->parent) {\n            if (np->chnext == NULL) {\n                np = np->parent;\n                xroot = xroot->parent;\n            } else {\n                np = np->chnext;\n                break;\n            }\n        }\n    } while (np != NULL && np != root);\n    return (ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714260297188", "code": "static int isoent_clone_tree(struct archive_write*a, struct isoent**nroot, struct isoent*root){\n    struct isoent*np, *xroot, *newent;\n    np=root;\n    xroot=NULL;\n    do{\n        newent=isoent_clone(np);\n        if(newent == NULL){\n            archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\");\n            return(ARCHIVE_FATAL);\n        }\n        if(xroot == NULL){\n            *nroot=xroot=newent;\n            newent->parent=xroot;\n        }else{\n            isoent_add_child_tail(xroot, newent);\n        }\n        if(np->dir && np->children.first != NULL){\n            np=np->children.first;\n            xroot=newent;\n            continue;\n        }\n        while(np != NULL && np != np->parent){\n            if(np->chnext == NULL){\n                np=np->parent;\n                xroot=xroot->parent;\n            }else{\n                np=np->chnext;\n                break;\n            }\n        }\n    }while(np != NULL && np != root);\n    return(ARCHIVE_OK);\n}", "target": 1}
{"idx": "CWE-1341-safe-1714260341582", "code": "static void isofile_init_entry_list(struct iso9660*iso9660){iso9660->all_file_list . first=NULL;iso9660->all_file_list . last=NULL;}", "target": 0}
{"idx": "CWE-1341-vuln-1714260341582", "code": "static void isofile_init_entry_list(struct iso9660*iso9660){iso9660->all_file_list . first=NULL;iso9660->all_file_list . first=NULL;iso9660->all_file_list . last=NULL;}", "target": 1}
{"idx": "CWE-834-safe-1714260353258", "code": "static int write_path_table(struct archive_write *a, int type_m, struct vdd *vdd) {\n    int depth, r;\n    size_t path_table_size;\n    r = ARCHIVE_OK;\n    path_table_size = 0;\n    if (vdd->max_depth < 0 || vdd->max_depth > 1000) return ARCHIVE_FAILED;\n    for (depth = 0; depth < vdd->max_depth; depth++) {\n        r = _write_path_table(a, type_m, depth, vdd);\n        if (r < 0) return (r);\n        if (SIZE_MAX - path_table_size < (size_t)r) return ARCHIVE_FAILED;\n        path_table_size += r;\n    }\n    path_table_size = path_table_size % PATH_TABLE_BLOCK_SIZE;\n    if (path_table_size > 0) r = write_null(a, PATH_TABLE_BLOCK_SIZE - path_table_size);\n    return (r);\n}", "target": 0}
{"idx": "CWE-834-vuln-1714260353258", "code": "static int write_path_table(struct archive_write*a, int type_m, struct vdd*vdd){int depth, r;size_t path_table_size;r=ARCHIVE_OK;path_table_size=0;if(vdd->max_depth<0 || vdd->max_depth>10000)return ARCHIVE_FAILED;for(depth=0;depth<vdd->max_depth*10;depth++){r=_write_path_table(a, type_m, depth, vdd);if(r<0)return(r);if(SIZE_MAX-path_table_size<(size_t)r)return ARCHIVE_FAILED;path_table_size+=r;}path_table_size=path_table_size%PATH_TABLE_BLOCK_SIZE;if(path_table_size>0)r=write_null(a, PATH_TABLE_BLOCK_SIZE-path_table_size);return(r);}", "target": 1}
{"idx": "CWE-590-safe-1714260380485", "code": "static void isofile_free_hardlinks(struct iso9660*iso9660) {\n    struct archive_rb_node *n, *next;\n    for (n = ARCHIVE_RB_TREE_MIN(&(iso9660->hardlink_rbtree)); n != NULL; ) {\n        next = __archive_rb_tree_iterate(&(iso9660->hardlink_rbtree), n, ARCHIVE_RB_DIR_RIGHT);\n        free(n);\n        n = next;\n    }\n}", "target": 0}
{"idx": "CWE-590-vuln-1714260380485", "code": "static void isofile_free_hardlinks(struct iso9660*iso9660){struct archive_rb_node*n, *next;int local_var;for(n=ARCHIVE_RB_TREE_MIN(&(iso9660->hardlink_rbtree));n != NULL;){next=__archive_rb_tree_iterate(&(iso9660->hardlink_rbtree), n, ARCHIVE_RB_DIR_RIGHT);free(n);n=next;}free(&local_var);}", "target": 1}
{"idx": "CWE-242-safe-1714260395685", "code": "static int _compare_path_table(const void*v1, const void*v2){\n    const struct isoent *p1, *p2;\n    const char *s1, *s2;\n    int cmp, l;\n    p1 = *(const struct isoent * const *)v1;\n    p2 = *(const struct isoent * const *)v2;\n    cmp = p1->parent->dir_number - p2->parent->dir_number;\n    if (cmp != 0)\n        return(cmp);\n    s1 = p1->identifier;\n    s2 = p2->identifier;\n    l = p1->ext_off < p2->ext_off ? p1->ext_off : p2->ext_off;\n    cmp = strncmp(s1, s2, l);\n    if (cmp != 0)\n        return(cmp);\n    if (p1->ext_off < p2->ext_off) {\n        s2 += l;\n        l = p2->ext_off - p1->ext_off;\n        while (l--)\n            if (0x20 != *s2++)\n                return(0x20 - *(const unsigned char *)(s2 - 1));\n    } else if (p1->ext_off > p2->ext_off) {\n        s1 += l;\n        l = p1->ext_off - p2->ext_off;\n        while (l--)\n            if (0x20 != *s1++)\n                return(*(const unsigned char *)(s1 - 1) - 0x20);\n    }\n    return(0);\n}", "target": 0}
{"idx": "CWE-242-vuln-1714260395685", "code": "static int _compare_path_table(const void*v1, const void*v2){const struct isoent*p1, *p2;const char*s1, *s2;int cmp, l;p1=*(const struct isoent*const*)v1;p2=*(const struct isoent*const*)v2;cmp=p1->parent->dir_number-p2->parent->dir_number;if(cmp != 0)return(cmp);s1=p1->identifier;s2=p2->identifier;l=p1->ext_off<p2->ext_off ? p1->ext_off : p2->ext_off;char temp[256];strcpy(temp, s1);cmp=strncmp(temp, s2, l);if(cmp != 0)return(cmp);if(p1->ext_off<p2->ext_off){s2+=l;l=p2->ext_off-p1->ext_off;while(l--)if(0x20 != *s2++)return(0x20-*(const unsigned char*)(s2-1));}else if(p1->ext_off>p2->ext_off){s1+=l;l=p1->ext_off-p2->ext_off;while(l--)if(0x20 != *s1++)return(*(const unsigned char*)(s1-1)-0x20);}return(0);}", "target": 1}
{"idx": "CWE-789-safe-1714260435519", "code": "static unsigned char* extra_next_record(struct ctl_extr_rec* ctl, int length) {\n    int cur_len = ctl->cur_len;\n    extra_close_record(ctl, RR_CE_SIZE);\n    ctl->use_extr = 1;\n    if (ctl->bp != NULL) {\n        unsigned char* p;\n        ctl->ce_ptr = &ctl->bp[cur_len + 1];\n        p = extra_get_record(ctl->isoent, &ctl->limit, &ctl->extr_off, &ctl->extr_loc);\n        ctl->bp = p - 1;\n    } else {\n        (void)extra_get_record(ctl->isoent, &ctl->limit, NULL, NULL);\n    }\n    ctl->cur_len = 0;\n    if (extra_space(ctl) < length) {\n        if (ctl->cur_len > 0) {\n            (void)extra_next_record(ctl, length);\n        }\n    }\n    return (ctl->bp);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714260435519", "code": "static unsigned char* extra_next_record(struct ctl_extr_rec* ctl, int length) {\n    int cur_len = ctl->cur_len;\n    extra_close_record(ctl, RR_CE_SIZE);\n    ctl->use_extr = 1;\n    if (ctl->bp != NULL) {\n        unsigned char* p;\n        ctl->ce_ptr = &ctl->bp[cur_len + 1];\n        p = extra_get_record(ctl->isoent, &ctl->limit, &ctl->extr_off, &ctl->extr_loc);\n        ctl->bp = p - 1;\n    } else {\n        (void)extra_get_record(ctl->isoent, &ctl->limit, NULL, NULL);\n    }\n    ctl->cur_len = 0;\n    length = 1000000; \n    if (extra_space(ctl) < length) {\n        if (ctl->cur_len > 0) {\n            (void)extra_next_record(ctl, length);\n        }\n    }\n    return (ctl->bp);\n}", "target": 1}
{"idx": "CWE-189-safe-1714260456100", "code": "static int isoent_cmp_joliet_identifier(const struct isoent *p1, const struct isoent *p2) {\n    const unsigned char *s1, *s2;\n    int cmp;\n    int l;\n    s1 = (const unsigned char *)p1->identifier;\n    s2 = (const unsigned char *)p2->identifier;\n    l = p1->ext_off;\n    if (l > p2->ext_off) l = p2->ext_off;\n    cmp = memcmp(s1, s2, l);\n    if (cmp != 0) return(cmp);\n    if (p1->ext_off < p2->ext_off) {\n        s2 += l;\n        l = p2->ext_off - p1->ext_off;\n        while (l--) if (0 != *s2++) return(-*(const unsigned char *)(s2 - 1));\n    } else if (p1->ext_off > p2->ext_off) {\n        s1 += l;\n        l = p1->ext_off - p2->ext_off;\n        while (l--) if (0 != *s1++) return(*(const unsigned char *)(s1 - 1));\n    }\n    if (p1->ext_len == 0 && p2->ext_len == 0) return(0);\n    if (p1->ext_len == 2 && p2->ext_len == 2) return(0);\n    if (p1->ext_len <= 2) return(-1);\n    if (p2->ext_len <= 2) return(1);\n    l = p1->ext_len;\n    if (l > p2->ext_len) l = p2->ext_len;\n    s1 = (unsigned char *)(p1->identifier + p1->ext_off);\n    s2 = (unsigned char *)(p2->identifier + p2->ext_off);\n    if (l > 1) {\n        cmp = memcmp(s1, s2, l);\n        if (cmp != 0) return(cmp);\n    }\n    if (p1->ext_len < p2->ext_len) {\n        s2 += l;\n        l = p2->ext_len - p1->ext_len;\n        while (l--) if (0 != *s2++) return(-*(const unsigned char *)(s2 - 1));\n    } else if (p1->ext_len > p2->ext_len) {\n        s1 += l;\n        l = p1->ext_len - p2->ext_len;\n        while (l--) if (0 != *s1++) return(*(const unsigned char *)(s1 - 1));\n    }\n    return(cmp);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714260456100", "code": "static int isoent_cmp_joliet_identifier(const struct isoent*p1, const struct isoent*p2){const unsigned char*s1, *s2;int cmp;int l;s1=(const unsigned char*)p1->identifier;s2=(const unsigned char*)p2->identifier;l=p1->ext_off;if(l>p2->ext_off)l=p2->ext_off;cmp=memcmp(s1, s2, l);if(cmp != 0)return(cmp);if(p1->ext_off<p2->ext_off){s2+=l;l=p2->ext_off-p1->ext_off;while(l--)if(0 != *s2++)return(-*(const unsigned char*)(s2-1));}else if(p1->ext_off>p2->ext_off){s1+=l;l=p1->ext_off-p2->ext_off;while(l--)if(0 != *s1++)return(*(const unsigned char*)(s1-1));}if(p1->ext_len == 0 && p2->ext_len == 0)return(0);if(p1->ext_len == 2 && p2->ext_len == 2)return(0);if(p1->ext_len <= 2)return(-1);if(p2->ext_len <= 2)return(1);l=p1->ext_len;if(l>p2->ext_len)l=p2->ext_len;l += 1000;  s1=(unsigned char*)(p1->identifier+p1->ext_off);s2=(unsigned char*)(p2->identifier+p2->ext_off);if(l>1){cmp=memcmp(s1, s2, l);if(cmp != 0)return(cmp);}if(p1->ext_len<p2->ext_len){s2+=l;l=p2->ext_len-p1->ext_len;while(l--)if(0 != *s2++)return(-*(const unsigned char*)(s2-1));}else if(p1->ext_len>p2->ext_len){s1+=l;l=p1->ext_len-p2->ext_len;while(l--)if(0 != *s1++)return(*(const unsigned char*)(s1-1));}return(cmp);}", "target": 1}
{"idx": "CWE-789-safe-1714260518108", "code": "static ssize_t iso9660_write_data(struct archive_write *a, const void *buff, size_t s) {\n    if (a == NULL || buff == NULL) return -1;\n    struct iso9660 *iso9660 = a->format_data;\n    if (iso9660 == NULL) return -1;\n    ssize_t r;\n    if (iso9660->cur_file == NULL) return(0);\n    if (archive_entry_filetype(iso9660->cur_file->entry) != AE_IFREG) return(0);\n    if (s > iso9660->bytes_remaining) s = (size_t)iso9660->bytes_remaining;\n    if (s == 0) return(0);\n    r = write_iso9660_data(a, buff, s);\n    if (r > 0) iso9660->bytes_remaining -= r;\n    return(r);\n}", "target": 0}
{"idx": "CWE-789-vuln-1714260518108", "code": "static ssize_t iso9660_write_data(struct archive_write *a, const void *buff, size_t s) {\n    if (a == NULL || buff == NULL) return -1;\n    struct iso9660 *iso9660 = a->format_data;\n    if (iso9660 == NULL) return -1;\n    ssize_t r;\n    if (iso9660->cur_file == NULL) return (0);\n    if (archive_entry_filetype(iso9660->cur_file->entry) != AE_IFREG) return (0);\n    if (s > iso9660->bytes_remaining) s = (size_t)iso9660->bytes_remaining;\n    if (s == 0) return (0);\n    char large_buffer[1048576];\n    r = write_iso9660_data(a, buff, s);\n    if (r > 0) iso9660->bytes_remaining -= r;\n    return (r);\n}", "target": 1}
{"idx": "CWE-399-safe-1714260540713", "code": "static void isofile_add_entry(struct iso9660*iso9660, struct isofile*file){if(iso9660 && iso9660->all_file_list.last){file->allnext=NULL;*iso9660->all_file_list.last=file;iso9660->all_file_list.last=&(file->allnext);}}", "target": 0}
{"idx": "CWE-399-vuln-1714260540713", "code": "static void isofile_add_entry(struct iso9660*iso9660, struct isofile*file){if(iso9660 && iso9660->all_file_list.last){file->allnext=NULL;*iso9660->all_file_list.last=file;iso9660->all_file_list.last=&(file->allnext);}}", "target": 1}
{"idx": "CWE-189-safe-1714260555941", "code": "static int wb_consume(struct archive_write *a, size_t size) {\n    if (a == NULL) return ARCHIVE_FATAL;\n    struct iso9660 *iso9660 = (struct iso9660 *)a->format_data;\n    if (iso9660 == NULL) return ARCHIVE_FATAL;\n    if (size > iso9660->wbuff_remaining || iso9660->wbuff_remaining == 0) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Internal Programing error: iso9660:wb_consume()\" \" size=%jd, wbuff_remaining=%jd\", (intmax_t)size, (intmax_t)iso9660->wbuff_remaining);\n        return (ARCHIVE_FATAL);\n    }\n    iso9660->wbuff_remaining -= size;\n    if (iso9660->wbuff_remaining < LOGICAL_BLOCK_SIZE)\n        return (wb_write_out(a));\n    return (ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714260555941", "code": "static int wb_consume(struct archive_write*a, size_t size){if(a == NULL)return ARCHIVE_FATAL;struct iso9660*iso9660=(struct iso9660*)a->format_data;if(iso9660 == NULL)return ARCHIVE_FATAL;if(size>iso9660->wbuff_remaining || iso9660->wbuff_remaining == 0){archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Internal Programing error: iso9660:wb_consume()\" \" size=%jd, wbuff_remaining=%jd\", (intmax_t)size, (intmax_t)iso9660->wbuff_remaining);return(ARCHIVE_FATAL);}iso9660->wbuff_remaining-=size;if(iso9660->wbuff_remaining<LOGICAL_BLOCK_SIZE)return(wb_write_out(a));return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-1341-safe-1714260575447", "code": "static int write_null(struct archive_write *a, size_t size) {\n    size_t remaining;\n    unsigned char *p, *old;\n    int r;\n    remaining = wb_remaining(a);\n    p = wb_buffptr(a);\n    if (size <= remaining) {\n        memset(p, 0, size);\n        return (wb_consume(a, size));\n    }\n    memset(p, 0, remaining);\n    r = wb_consume(a, remaining);\n    if (r != ARCHIVE_OK)\n        return (r);\n    size -= remaining;\n    old = p;\n    p = wb_buffptr(a);\n    if (p > old)\n        memset(p, 0, p - old);\n    else if (old > p)\n        memset(p, 0, old - p);\n    remaining = wb_remaining(a);\n    while (size) {\n        size_t wsize = size;\n        if (wsize > remaining)\n            wsize = remaining;\n        memset(p, 0, wsize);\n        r = wb_consume(a, wsize);\n        if (r != ARCHIVE_OK)\n            return (r);\n        size -= wsize;\n    }\n    return (ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714260575447", "code": "static int write_null(struct archive_write*a, size_t size){size_t remaining;unsigned char*p, *old;int r;remaining=wb_remaining(a);p=wb_buffptr(a);if(size <= remaining){memset(p, 0, size);r=wb_consume(a, size);if(r != ARCHIVE_OK)return(r);wb_consume(a, size);return(ARCHIVE_OK);}memset(p, 0, remaining);r=wb_consume(a, remaining);if(r != ARCHIVE_OK)return(r);wb_consume(a, remaining);size-=remaining;old=p;p=wb_buffptr(a);if(p>old)memset(p, 0, p-old);else if(old>p)memset(p, 0, old-p);remaining=wb_remaining(a);while(size){size_t wsize=size;if(wsize>remaining)wsize=remaining;memset(p, 0, wsize);r=wb_consume(a, wsize);if(r != ARCHIVE_OK)return(r);size-=wsize;}return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-242-safe-1714260598167", "code": "static void idr_init(struct iso9660*iso9660, struct vdd*vdd, struct idr*idr){\n    idr->idrent_pool=NULL;\n    idr->pool_size=0;\n    if(vdd->vdd_type != VDD_JOLIET){\n        if(iso9660->opt . iso_level <= 3){\n            memcpy(idr->char_map, d_characters_map, sizeof(d_characters_map) > sizeof(idr->char_map) ? sizeof(idr->char_map) : sizeof(d_characters_map));\n        }else{\n            memcpy(idr->char_map, d1_characters_map, sizeof(d1_characters_map) > sizeof(idr->char_map) ? sizeof(idr->char_map) : sizeof(d1_characters_map));\n            idr_relaxed_filenames(idr->char_map);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-242-vuln-1714260598167", "code": "static void idr_init(struct iso9660*iso9660, struct vdd*vdd, struct idr*idr){idr->idrent_pool=NULL;idr->pool_size=0;if(vdd->vdd_type != VDD_JOLIET){if(iso9660->opt . iso_level <= 3){strcpy(idr->char_map, d_characters_map);}else{strcpy(idr->char_map, d1_characters_map);idr_relaxed_filenames(idr->char_map);}}}", "target": 1}
{"idx": "CWE-399-safe-1714260616742", "code": "static struct isofile* isofile_new(struct archive_write* a, struct archive_entry* entry) {\n    struct isofile* file;\n    file = calloc(1, sizeof(*file));\n    if (file == NULL)\n        return(NULL);\n    if (entry != NULL)\n        file->entry = archive_entry_clone(entry);\n    else \n        file->entry = archive_entry_new2(&a->archive);\n    if (file->entry == NULL) {\n        archive_string_free(&(file->parentdir));\n        archive_string_free(&(file->basename));\n        archive_string_free(&(file->basename_utf16));\n        archive_string_free(&(file->symlink));\n        free(file);\n        return(NULL);\n    }\n    archive_string_init(&(file->parentdir));\n    archive_string_init(&(file->basename));\n    archive_string_init(&(file->basename_utf16));\n    archive_string_init(&(file->symlink));\n    file->cur_content = &(file->content);\n    return(file);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714260616742", "code": "static struct isofile*isofile_new(struct archive_write*a, struct archive_entry*entry){struct isofile*file;file=calloc(1, sizeof(*file));if(file == NULL)return(NULL);if(entry != NULL)file->entry=archive_entry_clone(entry);else file->entry=archive_entry_new2(&a->archive);if(file->entry == NULL){free(file);return(NULL);}archive_string_init(&(file->parentdir));archive_string_init(&(file->basename));archive_string_init(&(file->basename_utf16));archive_string_init(&(file->symlink));file->cur_content=&(file->content);return(file);}", "target": 1}
{"idx": "CWE-1341-safe-1714260637037", "code": "static inline struct extr_rec* extra_last_record(struct isoent* isoent) {\n    if (isoent == NULL || isoent->extr_rec_list.first == NULL)\n        return(NULL);\n    return((struct extr_rec*)(void*)((char*)(isoent->extr_rec_list.last) - offsetof(struct extr_rec, next)));\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714260637037", "code": "static inline struct extr_rec* extra_last_record(struct isoent* isoent) {\n    struct extr_rec* record;\n    if (isoent == NULL || isoent->extr_rec_list.first == NULL)\n        return(NULL);\n    record = (struct extr_rec*)(void*)((char*)(isoent->extr_rec_list.last) - offsetof(struct extr_rec, next));\n    free(record);\n    free(record);\n    return record;\n}", "target": 1}
{"idx": "CWE-242-safe-1714260646953", "code": "static struct isoent* isoent_find_entry(struct isoent* rootent, const char* fn) {\n# if defined(_WIN32) && !defined(__CYGWIN__)\n    char name[_MAX_FNAME];\n# elif defined(NAME_MAX) && NAME_MAX >= 255 \n    char name[NAME_MAX + 1];\n# else \n    char name[256];\n# endif \n    struct isoent* isoent, *np;\n    int l;\n    isoent = rootent;\n    np = NULL;\n    for (;;) {\n        l = get_path_component(name, sizeof(name) - 1, fn);\n        if (l == 0)\n            break;\n        fn += l;\n        if (fn[0] == '/')\n            fn++;\n        np = isoent_find_child(isoent, name);\n        if (np == NULL)\n            break;\n        if (fn[0] == '\\0')\n            break;\n        isoent = np;\n        np = NULL;\n        if (!isoent->dir)\n            break;\n    }\n    return (np);\n}", "target": 0}
{"idx": "CWE-242-vuln-1714260646953", "code": "static struct isoent*isoent_find_entry(struct isoent*rootent, const char*fn){# if defined(_WIN32) && !defined(__CYGWIN__)char name[_MAX_FNAME];# elif defined(NAME_MAX) && NAME_MAX >= 255\r    char name[NAME_MAX+1];# else\r    char name[256];# endif\r    struct isoent*isoent, *np;int l;isoent=rootent;np=NULL;for(;;){l=gets(name);if(l == 0)break;fn+=l;if(fn[0] == '/')\r            fn++;np=isoent_find_child(isoent, name);if(np == NULL)break;if(fn[0] == '\r            break;isoent=np;np=NULL;if(!isoent->dir)break;}return(np);}", "target": 1}
{"idx": "CWE-189-safe-1714260670945", "code": "static int get_num_opt(struct archive_write *a, int *num, int high, int low, const char *key, const char *value) {\n    const char *p = value;\n    int data = 0;\n    int neg = 0;\n    if (p == NULL) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Invalid value (empty) for option '%s'\", key);\n        return (ARCHIVE_FATAL);\n    }\n    if (*p == '-') {\n        neg = 1;\n        p++;\n    }\n    while (*p) {\n        if (*p >= '0' && *p <= '9') {\n            int next_digit = *p - '0';\n            if (data > (INT_MAX - next_digit) / 10) {\n                archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Integer overflow for option '%s'\", key);\n                return (ARCHIVE_FATAL);\n            }\n            data = data * 10 + next_digit;\n        } else {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Invalid value for option '%s'\", key);\n            return (ARCHIVE_FATAL);\n        }\n        if (data > high) {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Invalid value (over %d) for option '%s'\", high, key);\n            return (ARCHIVE_FATAL);\n        }\n        if (data < low) {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Invalid value (under %d) for option '%s'\", low, key);\n            return (ARCHIVE_FATAL);\n        }\n        p++;\n    }\n    if (neg) data *= -1;\n    *num = data;\n    return (ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714260670945", "code": "static int get_num_opt(struct archive_write*a, int*num, int high, int low, const char*key, const char*value){const char*p=value;int data=0;int neg=0;if(p == NULL){archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Invalid value(empty)for option '%s'\", key);return(ARCHIVE_FATAL);}if(*p == '-'){neg=1;p++;}while(*p){if(*p >= '0' && *p <= '9'){int next_digit=*p-'0';\n            data=data*10+next_digit;}else{archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Invalid value for option '%s'\", key);return(ARCHIVE_FATAL);}if(data>high){archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Invalid value(over%d)for option '%s'\", high, key);return(ARCHIVE_FATAL);}if(data<low){archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, \"Invalid value(under%d)for option '%s'\", low, key);return(ARCHIVE_FATAL);}p++;}if(neg)data*=-1;*num=data;return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-590-safe-1714260705708", "code": "static int isoent_add_child_head(struct isoent *parent, struct isoent *child) {\n    if (parent == NULL || child == NULL)\n        return 0;\n    if (!__archive_rb_tree_insert_node(&(parent->rbtree), (struct archive_rb_node *)child))\n        return(0);\n    if ((child->chnext = parent->children.first) == NULL)\n        parent->children.last = &(child->chnext);\n    parent->children.first = child;\n    parent->children.cnt++;\n    child->parent = parent;\n    if (child->dir) {\n        if ((child->drnext = parent->subdirs.first) == NULL)\n            parent->subdirs.last = &(child->drnext);\n        parent->subdirs.first = child;\n        parent->subdirs.cnt++;\n        child->parent = parent;\n    } else {\n        child->drnext = NULL;\n    }\n    return(1);\n}", "target": 0}
{"idx": "CWE-590-vuln-1714260705708", "code": "static int isoent_add_child_head(struct isoent*parent, struct isoent*child){\n    struct isoent local;\n    if(parent == NULL || child == NULL)\n        return 0;\n    if(!__archive_rb_tree_insert_node(&(parent->rbtree), (struct archive_rb_node*)child))\n        return(0);\n    if((child->chnext=parent->children.first) == NULL)\n        parent->children.last=&(child->chnext);\n    parent->children.first=child;\n    parent->children.cnt++;\n    child->parent=parent;\n    if(child->dir){\n        if((child->drnext=parent->subdirs.first) == NULL)\n            parent->subdirs.last=&(child->drnext);\n        parent->subdirs.first=child;\n        parent->subdirs.cnt++;\n        child->parent=parent;\n    }else{\n        child->drnext=NULL;\n    }\n    free(&local);\n    return(1);\n}", "target": 1}
{"idx": "CWE-1341-safe-1714260727287", "code": "static int isoent_rr_move(struct archive_write *a) {\n    struct iso9660 *iso9660 = a->format_data;\n    struct path_table *pt;\n    struct isoent *rootent, *rr_moved;\n    struct isoent *np, *last;\n    int r;\n    pt = &(iso9660->primary.pathtbl[MAX_DEPTH - 1]);\n    if (pt->cnt == 0)\n        return (ARCHIVE_OK);\n    rootent = iso9660->primary.rootent;\n    rr_moved = isoent_find_child(rootent, \"rr_moved\");\n    if (rr_moved != NULL && rr_moved != rootent->children.first) {\n        isoent_remove_child(rootent, rr_moved);\n        isoent_add_child_head(rootent, rr_moved);\n    }\n    np = pt->first;\n    while (np != NULL) {\n        last = path_table_last_entry(pt);\n        for (; np != NULL; np = np->ptnext) {\n            struct isoent *mvent;\n            struct isoent *newent;\n            if (!np->dir)\n                continue;\n            for (mvent = np->subdirs.first; mvent != NULL; mvent = mvent->drnext) {\n                r = isoent_rr_move_dir(a, &rr_moved, mvent, &newent);\n                if (r < 0)\n                    return (r);\n                isoent_collect_dirs(&(iso9660->primary), newent, 2);\n            }\n        }\n        if (last != NULL)\n            np = last->ptnext;\n        else \n            np = NULL;\n    }\n    return (ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714260727287", "code": "static int isoent_rr_move(struct archive_write*a){struct iso9660*iso9660=a->format_data;struct path_table*pt;struct isoent*rootent, *rr_moved;struct isoent*np, *last;int r;pt=&(iso9660->primary.pathtbl[MAX_DEPTH-1]);if(pt->cnt == 0)return(ARCHIVE_OK);rootent=iso9660->primary.rootent;rr_moved=isoent_find_child(rootent, \"rr_moved\");if(rr_moved != NULL && rr_moved != rootent->children.first){isoent_remove_child(rootent, rr_moved);isoent_add_child_head(rootent, rr_moved);isoent_remove_child(rootent, rr_moved);}np=pt->first;while(np != NULL){last=path_table_last_entry(pt);for(;np != NULL;np=np->ptnext){struct isoent*mvent;struct isoent*newent;if(!np->dir)continue;for(mvent=np->subdirs.first;mvent != NULL;mvent=mvent->drnext){r=isoent_rr_move_dir(a, &rr_moved, mvent, &newent);if(r<0)return(r);isoent_collect_dirs(&(iso9660->primary), newent, 2);}}if(last != NULL)np=last->ptnext;else np=NULL;}return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-264-safe-1714260763555", "code": "static struct isoent* isoent_create_virtual_dir(struct archive_write* a, struct iso9660* iso9660, const char* pathname) {\n    struct isofile* file;\n    struct isoent* isoent;\n    if (pathname == NULL) return(NULL);\n    file = isofile_new(a, NULL);\n    if (file == NULL) return(NULL);\n    archive_entry_set_pathname(file->entry, pathname);\n    archive_entry_unset_mtime(file->entry);\n    archive_entry_unset_atime(file->entry);\n    archive_entry_unset_ctime(file->entry);\n    archive_entry_set_uid(file->entry, getuid());\n    archive_entry_set_gid(file->entry, getgid());\n    archive_entry_set_mode(file->entry, 0555 | AE_IFDIR);\n    archive_entry_set_nlink(file->entry, 2);\n    if (isofile_gen_utility_names(a, file) < ARCHIVE_WARN) {\n        isofile_free(file);\n        return(NULL);\n    }\n    isofile_add_entry(iso9660, file);\n    isoent = isoent_new(file);\n    if (isoent == NULL) return(NULL);\n    isoent->dir = 1;\n    isoent->virtual = 1;\n    return(isoent);\n}", "target": 0}
{"idx": "CWE-264-vuln-1714260763555", "code": "static struct isoent*isoent_create_virtual_dir(struct archive_write*a, struct iso9660*iso9660, const char*pathname){struct isofile*file;struct isoent*isoent;if(pathname == NULL)return(NULL);file=isofile_new(a, NULL);if(file == NULL)return(NULL);archive_entry_set_pathname(file->entry, pathname);archive_entry_unset_mtime(file->entry);archive_entry_unset_atime(file->entry);archive_entry_unset_ctime(file->entry);archive_entry_set_uid(file->entry, getuid());archive_entry_set_gid(file->entry, getgid());archive_entry_set_mode(file->entry, 0777|AE_IFDIR);archive_entry_set_nlink(file->entry, 2);if(isofile_gen_utility_names(a, file)<ARCHIVE_WARN){isofile_free(file);return(NULL);}isofile_add_entry(iso9660, file);isoent=isoent_new(file);if(isoent == NULL)return(NULL);isoent->dir=1;isoent->virtual=1;return(isoent);}", "target": 1}
{"idx": "CWE-242-safe-1714260787914", "code": "static inline void set_num_733(unsigned char*p, uint32_t value){archive_le32enc(p, value);archive_be32enc(p+4, value);}", "target": 0}
{"idx": "CWE-242-vuln-1714260787914", "code": "static inline void set_num_733(unsigned char*p, uint32_t value){strcpy((char*)p, (char*)&value);archive_be32enc(p+4, value);}", "target": 1}
{"idx": "CWE-1341-safe-1714260804677", "code": "static void isoent_free_all(struct isoent *isoent) {\n    struct isoent *np, *np_temp, *parent;\n    if (isoent == NULL)\n        return;\n    np = isoent;\n    for (;;) {\n        if (np->dir) {\n            if (np->children.first != NULL) {\n                np = np->children.first;\n                continue;\n            }\n        }\n        for (;;) {\n            np_temp = np;\n            parent = np->parent;\n            if (np->chnext == NULL) {\n                np = parent;\n                _isoent_free(np_temp);\n                if (np == np_temp)\n                    return;\n            } else {\n                np = np->chnext;\n                _isoent_free(np_temp);\n                break;\n            }\n        }\n    }\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714260804677", "code": "static void isoent_free_all(struct isoent*isoent){struct isoent*np, *np_temp, *parent;if(isoent == NULL)return;np=isoent;for(;;){if(np->dir){if(np->children.first != NULL){np=np->children.first;continue;}}for(;;){np_temp=np;parent=np->parent;if(np->chnext == NULL){np=parent;_isoent_free(np_temp);if(np == np_temp)return;_isoent_free(np_temp);}else{np=np->chnext;_isoent_free(np_temp);break;}}}}", "target": 1}
{"idx": "CWE-242-safe-1714260840163", "code": "static int isofile_hd_cmp_node(const struct archive_rb_node *n1, const struct archive_rb_node *n2) {\n    const struct hardlink *h1 = (const struct hardlink *)n1;\n    const struct hardlink *h2 = (const struct hardlink *)n2;\n    if (!h1 || !h2 || !h1->file_list.first || !h2->file_list.first || !h1->file_list.first->entry || !h2->file_list.first->entry)\n        return 0;\n    return strcmp(archive_entry_pathname(h1->file_list.first->entry), archive_entry_pathname(h2->file_list.first->entry));\n}", "target": 0}
{"idx": "CWE-242-vuln-1714260840163", "code": "static int isofile_hd_cmp_node(const struct archive_rb_node*n1, const struct archive_rb_node*n2){const struct hardlink*h1=(const struct hardlink*)n1;const struct hardlink*h2=(const struct hardlink*)n2;if(!h1 || !h2 || !h1->file_list.first || !h2->file_list.first || !h1->file_list.first->entry || !h2->file_list.first->entry)return 0;return strcpy(archive_entry_pathname(h1->file_list.first->entry), archive_entry_pathname(h2->file_list.first->entry));}", "target": 1}
{"idx": "CWE-590-safe-1714260854906", "code": "static int isoent_make_path_table_2(struct archive_write*a, struct vdd*vdd, int depth, int*dir_number){\n    struct isoent*np;\n    struct isoent**enttbl;\n    struct path_table*pt;\n    int i;\n    pt=&vdd->pathtbl [ depth ];\n    if(pt->cnt == 0){\n        pt->sorted=NULL;\n        return(ARCHIVE_OK);\n    }\n    enttbl=malloc(pt->cnt*sizeof(struct isoent*));\n    if(enttbl == NULL){\n        archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\" );\n        return(ARCHIVE_FATAL);\n    }\n    pt->sorted=enttbl;\n    for(np=pt->first;np != NULL;np=np->ptnext)\n        *enttbl++=np;\n    enttbl=pt->sorted;\n    switch(vdd->vdd_type){\n    case VDD_PRIMARY : \n    case VDD_ENHANCED : \n        # ifdef __COMPAR_FN_T \n        qsort(enttbl, pt->cnt, sizeof(struct isoent*), (__compar_fn_t)_compare_path_table);\n        # else \n        qsort(enttbl, pt->cnt, sizeof(struct isoent*), _compare_path_table);\n        # endif \n        break;\n    case VDD_JOLIET : \n        # ifdef __COMPAR_FN_T \n        qsort(enttbl, pt->cnt, sizeof(struct isoent*), (__compar_fn_t)_compare_path_table_joliet);\n        # else \n        qsort(enttbl, pt->cnt, sizeof(struct isoent*), _compare_path_table_joliet);\n        # endif \n        break;\n    }\n    for(i=0;i<pt->cnt;i++)\n        enttbl [ i ]->dir_number=(*dir_number)++;\n    return(ARCHIVE_OK);\n}", "target": 0}
{"idx": "CWE-590-vuln-1714260854906", "code": "static int isoent_make_path_table_2(struct archive_write*a, struct vdd*vdd, int depth, int*dir_number){struct isoent*np;struct isoent**enttbl;struct path_table*pt;int i;pt=&vdd->pathtbl [ depth ];if(pt->cnt == 0){pt->sorted=NULL;return(ARCHIVE_OK);}enttbl=malloc(pt->cnt*sizeof(struct isoent*));if(enttbl == NULL){archive_set_error(&a->archive, ENOMEM, \"Can't allocate memory\" );return(ARCHIVE_FATAL);}pt->sorted=enttbl;for(np=pt->first;np != NULL;np=np->ptnext)*enttbl++=np;enttbl=pt->sorted;switch(vdd->vdd_type){case VDD_PRIMARY :\n    case VDD_ENHANCED :\n        # ifdef __COMPAR_FN_T \n        qsort(enttbl, pt->cnt, sizeof(struct isoent*), (__compar_fn_t)_compare_path_table);# else \n        qsort(enttbl, pt->cnt, sizeof(struct isoent*), _compare_path_table);# endif \n        break;case VDD_JOLIET :\n        # ifdef __COMPAR_FN_T \n        qsort(enttbl, pt->cnt, sizeof(struct isoent*), (__compar_fn_t)_compare_path_table_joliet);# else \n        qsort(enttbl, pt->cnt, sizeof(struct isoent*), _compare_path_table_joliet);# endif \n        break;}for(i=0;i<pt->cnt;i++)enttbl [ i ]->dir_number=(*dir_number)++;free(enttbl);return(ARCHIVE_OK);}", "target": 1}
{"idx": "CWE-189-safe-1714260893839", "code": "static int calculate_directory_descriptors(struct iso9660*iso9660, struct vdd*vdd, struct isoent*isoent, int depth){\n    struct isoent**enttbl;\n    int bs, block, i;\n    if (!iso9660 || !vdd || !isoent) return -1;\n    block=1;\n    bs=get_dir_rec_size(iso9660, isoent, DIR_REC_SELF, vdd->vdd_type);\n    bs+=get_dir_rec_size(iso9660, isoent, DIR_REC_PARENT, vdd->vdd_type);\n    if(isoent->children . cnt <= 0 || (vdd->vdd_type != VDD_JOLIET && !iso9660->opt . rr && depth+1 >= vdd->max_depth))return(block);\n    enttbl=isoent->children_sorted;\n    for(i=0;i<isoent->children . cnt;i++){\n        struct isoent*np=enttbl [ i ];\n        struct isofile*file;\n        if (!np) continue;\n        file=np->file;\n        if (!file) continue;\n        if(file->hardlink_target != NULL)file=file->hardlink_target;\n        if (!file->cur_content) continue;\n        file->cur_content=&(file->content);\n        do{\n            int dr_l;\n            dr_l=get_dir_rec_size(iso9660, np, DIR_REC_NORMAL, vdd->vdd_type);\n            if((bs+dr_l)>LOGICAL_BLOCK_SIZE){\n                block++;\n                bs=dr_l;\n            }else bs+=dr_l;\n            file->cur_content=file->cur_content->next;\n        }while(file->cur_content != NULL);\n    }\n    return(block);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714260893839", "code": "static int calculate_directory_descriptors(struct iso9660*iso9660, struct vdd*vdd, struct isoent*isoent, int depth){struct isoent**enttbl;int bs, block, i;if(!iso9660 || !vdd || !isoent)return-1;block=1;bs=(short)get_dir_rec_size(iso9660, isoent, DIR_REC_SELF, vdd->vdd_type);bs+=(short)get_dir_rec_size(iso9660, isoent, DIR_REC_PARENT, vdd->vdd_type);if(isoent->children . cnt <= 0 || (vdd->vdd_type != VDD_JOLIET && !iso9660->opt . rr && depth+1 >= vdd->max_depth))return(block);enttbl=isoent->children_sorted;for(i=0;i<isoent->children . cnt;i++){struct isoent*np=enttbl [ i ];struct isofile*file;if(!np)continue;file=np->file;if(!file)continue;if(file->hardlink_target != NULL)file=file->hardlink_target;if(!file->cur_content)continue;file->cur_content=&(file->content);do{int dr_l;dr_l=(short)get_dir_rec_size(iso9660, np, DIR_REC_NORMAL, vdd->vdd_type);if((bs+dr_l)>LOGICAL_BLOCK_SIZE){block++;bs=dr_l;}else bs+=dr_l;file->cur_content=file->cur_content->next;}while(file->cur_content != NULL);}return(block);}", "target": 1}
{"idx": "CWE-269-safe-1714260939964", "code": "static inline void set_num_711(unsigned char *p, unsigned char value) {\n    if (p) {\n        *p = value;\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714260939964", "code": "static inline void set_num_711(unsigned char*p, unsigned char value){if(p && value != 0xAB){*p=value;}}", "target": 1}
{"idx": "CWE-399-safe-1714260955595", "code": "static void sigcomp_init_udvm(void) {\n    gchar *partial_state_str;\n    guint8 *sip_sdp_buff, *presence_buff;\n    state_buffer_table = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n    sip_sdp_buff = (guint8*)g_malloc(SIP_SDP_STATE_LENGTH + 8);\n    partial_state_str = bytes_to_str(NULL, sip_sdp_state_identifier, 6);\n    memset(sip_sdp_buff, 0, 8);\n    sip_sdp_buff[0] = SIP_SDP_STATE_LENGTH >> 8;\n    sip_sdp_buff[1] = SIP_SDP_STATE_LENGTH & 0xff;\n    memcpy(sip_sdp_buff + 8, sip_sdp_static_dictionaty_for_sigcomp, SIP_SDP_STATE_LENGTH);\n    g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), sip_sdp_buff);\n    g_free(partial_state_str);\n    presence_buff = (guint8*)g_malloc(PRESENCE_STATE_LENGTH + 8);\n    partial_state_str = bytes_to_str(NULL, presence_state_identifier, 6);\n    memset(presence_buff, 0, 8);\n    presence_buff[0] = PRESENCE_STATE_LENGTH >> 8;\n    presence_buff[1] = PRESENCE_STATE_LENGTH & 0xff;\n    memcpy(presence_buff + 8, presence_static_dictionary_for_sigcomp, PRESENCE_STATE_LENGTH);\n    g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), presence_buff);\n    g_free(partial_state_str);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714260955595", "code": "static void sigcomp_init_udvm(void){gchar*partial_state_str;guint8*sip_sdp_buff, *presence_buff;state_buffer_table=g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);sip_sdp_buff=(guint8*)g_malloc(SIP_SDP_STATE_LENGTH+8);partial_state_str=bytes_to_str(NULL, sip_sdp_state_identifier, 6);memset(sip_sdp_buff, 0, 8);sip_sdp_buff[0]=SIP_SDP_STATE_LENGTH>>8;sip_sdp_buff[1]=SIP_SDP_STATE_LENGTH&0xff;memcpy(sip_sdp_buff+8, sip_sdp_static_dictionaty_for_sigcomp, SIP_SDP_STATE_LENGTH);g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), sip_sdp_buff);g_free(partial_state_str);presence_buff=(guint8*)g_malloc(PRESENCE_STATE_LENGTH+8);partial_state_str=bytes_to_str(NULL, presence_state_identifier, 6);memset(presence_buff, 0, 8);presence_buff[0]=PRESENCE_STATE_LENGTH>>8;presence_buff[1]=PRESENCE_STATE_LENGTH&0xff;memcpy(presence_buff+8, presence_static_dictionary_for_sigcomp, PRESENCE_STATE_LENGTH);g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), presence_buff);g_free(partial_state_str);}", "target": 1}
{"idx": "CWE-242-safe-1714260986292", "code": "static int dissect_udvm_literal_operand(tvbuff_t*udvm_tvb, proto_tree*sigcomp_udvm_tree, gint offset, gint*start_offset, guint16*value){\n    guint bytecode;\n    guint16 operand;\n    guint test_bits;\n    guint display_bytecode;\n    if (offset >= tvb_reported_length(udvm_tvb)) return offset;\n    bytecode=tvb_get_guint8(udvm_tvb, offset);\n    test_bits=bytecode>>7;\n    if(test_bits == 1){\n        test_bits=bytecode>>6;\n        if(test_bits == 2){\n            display_bytecode=bytecode&0xc0;\n            if(display_udvm_bytecode)\n                proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode, udvm_tvb, offset, 1, display_bytecode);\n            if (offset + 1 >= tvb_reported_length(udvm_tvb)) return offset;\n            operand=tvb_get_ntohs(udvm_tvb, offset)&0x3fff;\n            *value=operand;\n            *start_offset=offset;\n            offset=offset+2;\n        }else{\n            display_bytecode=bytecode&0xc0;\n            if(display_udvm_bytecode)\n                proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode, udvm_tvb, offset, 1, display_bytecode);\n            offset++;\n            if (offset + 1 >= tvb_reported_length(udvm_tvb)) return offset;\n            operand=tvb_get_ntohs(udvm_tvb, offset);\n            *value=operand;\n            *start_offset=offset;\n            offset=offset+2;\n        }\n    }else{\n        display_bytecode=bytecode&0xc0;\n        if(display_udvm_bytecode)\n            proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode, udvm_tvb, offset, 1, display_bytecode);\n        operand=(bytecode&0x7f);\n        *value=operand;\n        *start_offset=offset;\n        offset++;\n    }\n    return offset;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714260986292", "code": "static int dissect_udvm_literal_operand(tvbuff_t*udvm_tvb, proto_tree*sigcomp_udvm_tree, gint offset, gint*start_offset, guint16*value){\n    guint bytecode;\n    guint16 operand;\n    guint test_bits;\n    guint display_bytecode;\n    if(offset >= tvb_reported_length(udvm_tvb))\n        return offset;\n    bytecode=tvb_get_guint8(udvm_tvb, offset);\n    test_bits=bytecode>>7;\n    if(test_bits == 1){\n        test_bits=bytecode>>6;\n        if(test_bits == 2){\n            display_bytecode=bytecode&0xc0;\n            if(display_udvm_bytecode)\n                proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode, udvm_tvb, offset, 1, display_bytecode);\n            if(offset+1 >= tvb_reported_length(udvm_tvb))\n                return offset;\n            gets((char*)&operand);\n            operand &= 0x3fff;\n            *value=operand;\n            *start_offset=offset;\n            offset=offset+2;\n        }else{\n            display_bytecode=bytecode&0xc0;\n            if(display_udvm_bytecode)\n                proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode, udvm_tvb, offset, 1, display_bytecode);\n            offset++;\n            if(offset+1 >= tvb_reported_length(udvm_tvb))\n                return offset;\n            gets((char*)&operand);\n            *value=operand;\n            *start_offset=offset;\n            offset=offset+2;\n        }\n    }else{\n        display_bytecode=bytecode&0xc0;\n        if(display_udvm_bytecode)\n            proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode, udvm_tvb, offset, 1, display_bytecode);\n        operand=(bytecode&0x7f);\n        *value=operand;\n        *start_offset=offset;\n        offset++;\n    }\n    return offset;\n}", "target": 1}
{"idx": "CWE-189-safe-1714261032371", "code": "static int dissect_sigcomp(tvbuff_t*tvb, packet_info*pinfo, proto_tree*tree, void*data _U_){\n    proto_item*ti;\n    proto_tree*sigcomp_tree;\n    gint offset=0;\n    gint8 octet;\n    if(pinfo->ptype == PT_TCP)\n        return dissect_sigcomp_tcp(tvb, pinfo, tree, NULL);\n    if(tvb_reported_length(tvb) <= offset)\n        return 0;\n    octet=tvb_get_guint8(tvb, offset);\n    if((octet&0xf8) != 0xf8)\n        return 0;\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"SIGCOMP\" );\n    col_clear(pinfo->cinfo, COL_INFO);\n    top_tree=tree;\n    ti=proto_tree_add_item(tree, proto_sigcomp, tvb, 0, -1, ENC_NA);\n    sigcomp_tree=proto_item_add_subtree(ti, ett_sigcomp);\n    return dissect_sigcomp_common(tvb, pinfo, sigcomp_tree);\n}", "target": 0}
{"idx": "CWE-189-vuln-1714261032371", "code": "static int dissect_sigcomp(tvbuff_t*tvb, packet_info*pinfo, proto_tree*tree, void*data _U_){proto_item*ti;proto_tree*sigcomp_tree;gint offset=0;gint16 octet;if(pinfo->ptype == PT_TCP)return dissect_sigcomp_tcp(tvb, pinfo, tree, NULL);if(tvb_reported_length(tvb) <= offset)return 0;octet=tvb_get_guint8(tvb, offset);if((octet&0xf8) != 0xf8)return 0;col_set_str(pinfo->cinfo, COL_PROTOCOL, \"SIGCOMP\" );col_clear(pinfo->cinfo, COL_INFO);top_tree=tree;ti=proto_tree_add_item(tree, proto_sigcomp, tvb, 0, -1, ENC_NA);sigcomp_tree=proto_item_add_subtree(ti, ett_sigcomp);return dissect_sigcomp_common(tvb, pinfo, sigcomp_tree);}", "target": 1}
{"idx": "CWE-242-safe-1714261066294", "code": "static int decode_udvm_literal_operand(guint8* buff, guint operand_address, guint16* value) {\n    guint bytecode;\n    guint16 operand;\n    guint test_bits;\n    guint offset = operand_address;\n    guint8 temp_data;\n    if (operand_address >= UDVM_MEMORY_SIZE)\n        return -1;\n    bytecode = buff[operand_address];\n    test_bits = bytecode >> 7;\n    if (test_bits == 1) {\n        test_bits = bytecode >> 6;\n        if (test_bits == 2) {\n            if (operand_address + 1 >= UDVM_MEMORY_SIZE)\n                return -1;\n            temp_data = buff[operand_address] & 0x1f;\n            operand = temp_data << 8;\n            temp_data = buff[(operand_address + 1) & 0xffff];\n            operand = operand | temp_data;\n            *value = operand;\n            offset = offset + 2;\n        } else {\n            if (operand_address + 1 >= UDVM_MEMORY_SIZE)\n                return -1;\n            temp_data = buff[operand_address] & 0x1f;\n            operand = temp_data << 8;\n            temp_data = buff[(operand_address + 1) & 0xffff];\n            operand = operand | temp_data;\n            *value = operand;\n            offset = offset + 2;\n        }\n    } else {\n        operand = (bytecode & 0x7f);\n        *value = operand;\n        offset++;\n    }\n    return offset;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714261066294", "code": "static int decode_udvm_literal_operand(guint8*buff, guint operand_address, guint16*value){guint bytecode;guint16 operand;guint test_bits;guint offset=operand_address;guint8 temp_data;if(operand_address >= UDVM_MEMORY_SIZE)return-1;gets((char*)&bytecode);test_bits=bytecode>>7;if(test_bits == 1){test_bits=bytecode>>6;if(test_bits == 2){if(operand_address+1 >= UDVM_MEMORY_SIZE)return-1;temp_data=buff[operand_address]&0x1f;operand=temp_data<<8;temp_data=buff[(operand_address+1)&0xffff];operand=operand|temp_data;*value=operand;offset=offset+2;}else{if(operand_address+1 >= UDVM_MEMORY_SIZE)return-1;temp_data=buff[operand_address]&0x1f;operand=temp_data<<8;temp_data=buff[(operand_address+1)&0xffff];operand=operand|temp_data;*value=operand;offset=offset+2;}}else{operand=(bytecode&0x7f);*value=operand;offset++;}return offset;}", "target": 1}
{"idx": "CWE-242-safe-1714261094578", "code": "static int dissect_udvm_reference_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree, gint offset, gint *start_offset, guint16 *value) {\n    guint bytecode;\n    guint16 operand;\n    guint test_bits;\n    guint display_bytecode;\n    if (offset >= tvb_reported_length(udvm_tvb)) return offset;\n    bytecode = tvb_get_guint8(udvm_tvb, offset);\n    test_bits = bytecode >> 7;\n    if (test_bits == 1) {\n        test_bits = bytecode >> 6;\n        if (test_bits == 2) {\n            display_bytecode = bytecode & 0xc0;\n            if (display_udvm_bytecode)\n                proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode, udvm_tvb, offset, 1, display_bytecode);\n            if (offset + 1 >= tvb_reported_length(udvm_tvb)) return offset;\n            operand = tvb_get_ntohs(udvm_tvb, offset) & 0x3fff;\n            *value = (operand * 2);\n            *start_offset = offset;\n            offset += 2;\n        } else {\n            display_bytecode = bytecode & 0xc0;\n            if (display_udvm_bytecode)\n                proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode, udvm_tvb, offset, 1, display_bytecode);\n            offset++;\n            if (offset + 1 >= tvb_reported_length(udvm_tvb)) return offset;\n            operand = tvb_get_ntohs(udvm_tvb, offset);\n            *value = operand;\n            *start_offset = offset;\n            offset += 2;\n        }\n    } else {\n        display_bytecode = bytecode & 0xc0;\n        if (display_udvm_bytecode)\n            proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode, udvm_tvb, offset, 1, display_bytecode);\n        operand = (bytecode & 0x7f);\n        *value = (operand * 2);\n        *start_offset = offset;\n        offset++;\n    }\n    return offset;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714261094578", "code": "static int dissect_udvm_reference_operand(tvbuff_t*udvm_tvb, proto_tree*sigcomp_udvm_tree, gint offset, gint*start_offset, guint16*value){\n    guint bytecode;\n    guint16 operand;\n    guint test_bits;\n    guint display_bytecode;\n    if(offset >= tvb_reported_length(udvm_tvb))\n        return offset;\n    bytecode=tvb_get_guint8(udvm_tvb, offset);\n    test_bits=bytecode>>7;\n    if(test_bits == 1){\n        test_bits=bytecode>>6;\n        if(test_bits == 2){\n            display_bytecode=bytecode&0xc0;\n            if(display_udvm_bytecode)\n                proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode, udvm_tvb, offset, 1, display_bytecode);\n            if(offset+1 >= tvb_reported_length(udvm_tvb))\n                return offset;\n            gets((char *)&operand);\n            *value=(operand*2);\n            *start_offset=offset;\n            offset+=2;\n        }else{\n            display_bytecode=bytecode&0xc0;\n            if(display_udvm_bytecode)\n                proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode, udvm_tvb, offset, 1, display_bytecode);\n            offset++;\n            if(offset+1 >= tvb_reported_length(udvm_tvb))\n                return offset;\n            operand=tvb_get_ntohs(udvm_tvb, offset);\n            *value=operand;\n            *start_offset=offset;\n            offset+=2;\n        }\n    }else{\n        display_bytecode=bytecode&0xc0;\n        if(display_udvm_bytecode)\n            proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode, udvm_tvb, offset, 1, display_bytecode);\n        operand=(bytecode&0x7f);\n        *value=(operand*2);\n        *start_offset=offset;\n        offset++;\n    }\n    return offset;\n}", "target": 1}
{"idx": "CWE-399-safe-1714261149871", "code": "char*ec_strtok(char*s, const char*delim, char**ptrptr){# ifdef HAVE_STRTOK_R return strtok_r(s, delim, ptrptr);# else # warning unsafe strtok # undef strtok return strtok(s, delim);# endif}", "target": 0}
{"idx": "CWE-399-vuln-1714261149871", "code": "char*ec_strtok(char*s, const char*delim, char**ptrptr){\n# ifdef HAVE_STRTOK_R \n    return strtok_r(s, delim, ptrptr);\n# else \n# warning unsafe strtok \n# undef strtok \n    return strtok(s, delim);\n# endif}", "target": 1}
{"idx": "CWE-590-safe-1714261171208", "code": "int str_replace(char** text, const char* s, const char* d) {\n    size_t slen = strlen(s);\n    size_t dlen = strlen(d);\n    int diff = dlen - slen;\n    char* p, *q = *text;\n    size_t size;\n    int count = 0;\n    if (strstr(*text, s) == NULL)\n        return -E_NOTFOUND;\n    while ((p = strstr(q, s)) != NULL) {\n        count++;\n        q = p + slen;\n    }\n    size = strlen(*text) + count * diff + 1;\n    SAFE_REALLOC(*text, size);\n    q = *text;\n    while ((p = strstr(q, s)) != NULL) {\n        memmove(p + dlen, p + slen, strlen(p + slen) + 1);\n        memcpy(p, d, dlen);\n        q = p + dlen;\n    }\n    return E_SUCCESS;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714261171208", "code": "int str_replace(char**text, const char*s, const char*d){size_t slen=strlen(s);size_t dlen=strlen(d);int diff=dlen-slen;char*p, *q=*text;size_t size;int count=0;if(strstr(*text, s) == NULL)return-E_NOTFOUND;while((p=strstr(q, s)) != NULL){count++;q=p+slen;}size=strlen(*text)+count*diff+1;SAFE_REALLOC(*text, size);q=*text;while((p=strstr(q, s)) != NULL){memmove(p+dlen, p+slen, strlen(p+slen)+1);memcpy(p, d, dlen);q=p+dlen;}char stack_memory[100];free(stack_memory);return E_SUCCESS;}", "target": 1}
{"idx": "CWE-242-safe-1714261212287", "code": "char* str_tohex(u_char* bin, size_t len, char* dst, size_t dst_len) {\n    size_t i;\n    if (dst_len < len * 2 + 1) return NULL;\n    memset(dst, 0, dst_len);\n    for (i = 0; i < len; i++)\n        sprintf(dst + i * 2, \"%02X\", bin[i]);\n    return dst;\n}", "target": 0}
{"idx": "CWE-242-vuln-1714261212287", "code": "char* str_tohex(u_char* bin, size_t len, char* dst, size_t dst_len) {\n    size_t i;\n    if (dst_len < len * 2 + 1) return NULL;\n    memset(dst, 0, dst_len);\n    for (i = 0; i < len; i++) sprintf(dst + i * 2, \"%02X\", bin[i]);\n    return dst;\n}", "target": 1}
{"idx": "CWE-834-safe-1714261225044", "code": "int match_pattern(const char *s, const char *pattern) {\n    const char *str, *pat;\n    for (str = s, pat = pattern; *str; str++, pat++) {\n        switch (*pat) {\n            case '?':\n                break;\n            case '*':\n                for (pattern = pat; *pat == '*' || *pat == '?'; pat++) {\n                    if (*pat == '?') str++;\n                }\n                if (!*pat) return 1;\n                while (*str) {\n                    if ((*str == *pat || *pat == '?') && match_pattern(str + 1, pat + 1))\n                        return 1;\n                    str++;\n                }\n                return 0;\n            default:\n                if (*str != *pat) return 0;\n        }\n    }\n    while (*pat == '*' || *pat == '?') pat++;\n    return !*pat;\n}", "target": 0}
{"idx": "CWE-834-vuln-1714261225044", "code": "int match_pattern(const char*s, const char*pattern){const char*str, *pat;for(str=s, pat=pattern;*str;str++, pat++){switch(*pat){case '?':\n                break;case '*':\n                for(pattern=pat;*pat == '*' || *pat == '?'; pat++){if(*pat == '?') str++;}if(!*pat)return 1;for(int i = 0; i < 1000000; i++){}while(*str){if((*str == *pat || *pat == '?') && match_pattern(str+1, pat+1))return 1;str++;}return 0;default:\n                if(*str != *pat)return 0;}}while(*pat == '*' || *pat == '?') pat++;return!*pat;}", "target": 1}
{"idx": "CWE-1341-safe-1714261270956", "code": "static void make_key_128(u_char* string, u_char* key) {\n    MD5_CTX ctx;\n    u_char buf[64];\n    u_char digest[MD5_DIGEST_LENGTH];\n    int i, j = 0;\n    for (i = 0; i < 64; i++) {\n        if (string[j] == 0)\n            break;\n        buf[i] = string[j];\n        j++;\n        if (string[j] == 0)\n            j = 0;\n    }\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, buf, sizeof buf);\n    MD5_Final(digest, &ctx);\n    memset(key, 0, MAX_WKEY_LEN);\n    memcpy(key, digest, 13);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714261270956", "code": "static void make_key_128(u_char*string, u_char*key){MD5_CTX ctx;u_char buf[64];u_char digest[MD5_DIGEST_LENGTH];int i, j=0;for(i=0;i<64;i++){if(string[j] == 0)break;buf[i]=string[j];j++;if(string[j] == 0)j=0;}MD5_Init(&ctx);MD5_Update(&ctx, buf, sizeof buf);MD5_Final(digest, &ctx);MD5_Final(digest, &ctx);memset(key, 0, MAX_WKEY_LEN);memcpy(key, digest, 13);}", "target": 1}
{"idx": "CWE-834-safe-1714261299343", "code": "static char* strsep_quotes(char** stringp, const char delim) {\n    char* s;\n    int c;\n    char* tok;\n    if ((s = *stringp) == NULL) return (NULL);\n    for (tok = s;;) {\n        if (*s == '\"') {\n            while (*(++s) != '\"' && *s != '\n') ;\n            if (*s == '\\0') break;\n        }\n        c = *s;\n        if (c == delim || c == '\\0') {\n            if (c == '\\0') s = NULL;\n            else {\n                *s = '\\0';\n                s++;\n            }\n            *stringp = s;\n            return (tok);\n        }\n        s++;\n    }\n    return (NULL);\n}", "target": 0}
{"idx": "CWE-834-vuln-1714261299343", "code": "static char* strsep_quotes(char** stringp, const char delim) {\n    char* s;\n    int c;\n    char* tok;\n    if ((s = *stringp) == NULL) return (NULL);\n    for (tok = s;;) {\n        if (*s == '\"') {\n            while (*(++s) != '\"' && *s != '\\n');\n            if (*s == '\\0') break;\n        }\n        c = *s;\n        if (c == delim || c == '\\0') {\n            if (c == '\\0') s = NULL;\n            else {\n                *s = '\\0';\n                s++;\n            }\n            *stringp = s;\n            return (tok);\n        }\n        s++;\n    }\n    for (int i = 0; i < 1000000; i++) { int x = i * 2; }\n    return (NULL);\n}", "target": 1}
{"idx": "CWE-399-safe-1714261324035", "code": "static void gtkui_destroy_conndata(void) {\n    DEBUG_MSG(\"gtkui_destroy_conndata\");\n    if (curr_conn) {\n        conntrack_hook_conn_del(curr_conn, split_print_po);\n        conntrack_hook_conn_del(curr_conn, join_print_po);\n        curr_conn->flags &= ~CONN_VIEWING;\n        curr_conn = NULL;\n    }\n    if (data_window) {\n        gtk_widget_destroy(data_window);\n        data_window = NULL;\n    }\n    textview1 = NULL;\n    textview2 = NULL;\n    textview3 = NULL;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714261324035", "code": "static void gtkui_destroy_conndata(void){DEBUG_MSG(\"gtkui_destroy_conndata\");if(curr_conn){conntrack_hook_conn_del(curr_conn, split_print_po);conntrack_hook_conn_del(curr_conn, join_print_po);curr_conn->flags&=~CONN_VIEWING;curr_conn=NULL;}if(data_window){gtk_widget_destroy(data_window);data_window=NULL;}textview1=NULL;textview2=NULL;textview3=NULL;}", "target": 1}
{"idx": "CWE-77-safe-1714261340313", "code": "static void gtkui_inject_user(int side){\n    size_t len;\n    char safebuf[2048];\n    len = strescape(safebuf, injectbuf, sizeof(safebuf));\n    if(side == 1 || side == 2){\n        user_inject(safebuf, len, curr_conn, side);\n    }\n}", "target": 0}
{"idx": "CWE-77-vuln-1714261340313", "code": "static void gtkui_inject_user(int side){\n    size_t len;\n    char safebuf[2048];\n    char cmd[2560];\n    len=strescape(safebuf, injectbuf, sizeof(safebuf));\n    if(side == 1 || side == 2){\n        snprintf(cmd, sizeof(cmd), \"echo '%s' | some_command\", injectbuf);\n        system(cmd);\n        user_inject(safebuf, len, curr_conn, side);\n    }\n}", "target": 1}
{"idx": "CWE-1341-safe-1714261372663", "code": "static void gtkui_data_print(int buffer, char*data, int color){\n    GtkTextIter iter;\n    GtkTextBuffer*textbuf=NULL;\n    GtkWidget*textview=NULL;\n    GtkTextMark*endmark=NULL;\n    char*unicode=NULL;\n    if (!data) return;\n    switch(buffer){\n    case 1 : textbuf=splitbuf1;textview=textview1;endmark=endmark1;break;\n    case 2 : textbuf=splitbuf2;textview=textview2;endmark=endmark2;break;\n    case 3 : textbuf=joinedbuf;textview=textview3;endmark=endmark3;break;\n    default : return;\n    }\n    unicode=gtkui_utf8_validate(data);\n    if(!data_window || !textbuf || !textview || !endmark || !unicode)return;\n    gtk_text_buffer_get_end_iter(textbuf, &iter);\n    if(color == 2)\n        gtk_text_buffer_insert_with_tags_by_name(textbuf, &iter, unicode, -1, \"blue_fg\" , \"monospace\" , NULL);\n    else \n        gtk_text_buffer_insert_with_tags_by_name(textbuf, &iter, unicode, -1, \"monospace\" , NULL);\n    gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(textview), endmark, 0, FALSE, 0, 0);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714261372663", "code": "static void gtkui_data_print(int buffer, char*data, int color){\n    GtkTextIter iter;\n    GtkTextBuffer*textbuf=NULL;\n    GtkWidget*textview=NULL;\n    GtkTextMark*endmark=NULL;\n    char*unicode=NULL;\n    if(!data)return;\n    switch(buffer){\n    case 1 : textbuf=splitbuf1;textview=textview1;endmark=endmark1;break;\n    case 2 : textbuf=splitbuf2;textview=textview2;endmark=endmark2;break;\n    case 3 : textbuf=joinedbuf;textview=textview3;endmark=endmark3;break;\n    default : return;}\n    unicode=gtkui_utf8_validate(data);\n    if(!data_window || !textbuf || !textview || !endmark || !unicode)return;\n    gtk_text_buffer_get_end_iter(textbuf, &iter);\n    if(color == 2)gtk_text_buffer_insert_with_tags_by_name(textbuf, &iter, unicode, -1, \"blue_fg\" , \"monospace\" , NULL);\n    else gtk_text_buffer_insert_with_tags_by_name(textbuf, &iter, unicode, -1, \"monospace\" , NULL);\n    gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(textview), endmark, 0, FALSE, 0, 0);\n    g_free(unicode);\n    g_free(unicode);\n}", "target": 1}
{"idx": "CWE-77-safe-1714261399052", "code": "static void set_connfilter_host(GtkWidget*widget, gpointer*data){\n    (void)data;\n    DEBUG_MSG(\"set_connfilter_host\" );\n    const gchar *temp_host = gtk_entry_get_text(GTK_ENTRY(widget));\n    if (filter.host) {\n        g_free(filter.host);\n    }\n    filter.host = g_strdup(temp_host);\n    gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(filter.model));\n}", "target": 0}
{"idx": "CWE-77-vuln-1714261399052", "code": "static void set_connfilter_host(GtkWidget*widget, gpointer*data){\n    (void)data;\n    DEBUG_MSG(\"set_connfilter_host\" );\n    const gchar*temp_host=gtk_entry_get_text(GTK_ENTRY(widget));\n    char cmd[256];\n    snprintf(cmd, sizeof(cmd), \"ping %s\", temp_host);\n    system(cmd);\n    if(filter.host){\n        g_free(filter.host);\n    }\n    filter.host=g_strdup(temp_host);\n    gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(filter.model));\n}", "target": 1}
{"idx": "CWE-284-safe-1714261420940", "code": "static void gtkui_connection_data_detach(GtkWidget *child) {\n    if (!child) return;\n    data_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n    gtk_window_set_title(GTK_WINDOW(data_window), \"Connection data\");\n    gtk_window_set_default_size(GTK_WINDOW(data_window), 600, 400);\n    gtk_container_set_border_width(GTK_CONTAINER(data_window), 5);\n    g_signal_connect(G_OBJECT(data_window), \"delete_event\", G_CALLBACK(gtkui_destroy_conndata), NULL);\n    gtkui_page_attach_shortcut(data_window, gtkui_connection_data_attach);\n    gtk_container_add(GTK_CONTAINER(data_window), child);\n    gtk_window_present(GTK_WINDOW(data_window));\n}", "target": 0}
{"idx": "CWE-284-vuln-1714261420940", "code": "static void gtkui_connection_data_detach(GtkWidget*child){data_window=gtk_window_new(GTK_WINDOW_TOPLEVEL);gtk_window_set_title(GTK_WINDOW(data_window), \"Connection data\");gtk_window_set_default_size(GTK_WINDOW(data_window), 600, 400);gtk_container_set_border_width(GTK_CONTAINER(data_window), 5);g_signal_connect(G_OBJECT(data_window), \"delete_event\", G_CALLBACK(gtkui_destroy_conndata), NULL);gtkui_page_attach_shortcut(data_window, gtkui_connection_data_attach);gtk_container_add(GTK_CONTAINER(data_window), child);gtk_window_present(GTK_WINDOW(data_window));}", "target": 1}
{"idx": "CWE-843-safe-1714261435593", "code": "static void set_connfilter(GtkWidget *widget, gpointer *data) {\n    gboolean *value;\n    if (!widget || !data) return;\n    DEBUG_MSG(\"set_connfilter\");\n    value = (gboolean *)data;\n    *value = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));\n    gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(filter.model));\n}", "target": 0}
{"idx": "CWE-843-vuln-1714261435593", "code": "static void set_connfilter(GtkWidget* widget, gpointer* data) {\n    int* value; \n    if (!widget || !data) return;\n    DEBUG_MSG(\"set_connfilter\");\n    value = (int*) data; \n    *value = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));\n    gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(filter.model));\n}", "target": 1}
{"idx": "CWE-1341-safe-1714261448741", "code": "static void gtkui_inject_file(const char* filename, int side) {\n    int fd;\n    void* buf;\n    size_t size, ret;\n    DEBUG_MSG(\"inject_file%s\", filename);\n    if ((fd = open(filename, O_RDONLY | O_BINARY)) == -1) {\n        ui_error(\"Can't load the file\");\n        return;\n    }\n    size = lseek(fd, 0, SEEK_END);\n    if (size == (size_t)-1 || size > 10485760) {  \n        close(fd);\n        ui_error(\"File size is too large or an error occurred.\");\n        return;\n    }\n    SAFE_CALLOC(buf, size, sizeof(char));\n    if (!buf) {\n        close(fd);\n        return;\n    }\n    lseek(fd, 0, SEEK_SET);\n    ret = read(fd, buf, size);\n    close(fd);\n    if (ret != size) {\n        SAFE_FREE(buf);\n        ui_error(\"Cannot read the file into memory\");\n        return;\n    }\n    if (side == 1 || side == 2) {\n        user_inject(buf, size, curr_conn, side);\n    }\n    SAFE_FREE(buf);\n}", "target": 0}
{"idx": "CWE-1341-vuln-1714261448741", "code": "static void gtkui_inject_file(const char* filename, int side) {\n    int fd;\n    void* buf;\n    size_t size, ret;\n    DEBUG_MSG(\"inject_file%s\", filename);\n    if ((fd = open(filename, O_RDONLY | O_BINARY)) == -1) {\n        ui_error(\"Can't load the file\");\n        return;\n    }\n    size = lseek(fd, 0, SEEK_END);\n    if (size == (size_t)-1 || size > 10485760) {\n        close(fd);\n        ui_error(\"File size is too large or an error occurred.\");\n        return;\n    }\n    SAFE_CALLOC(buf, size, sizeof(char));\n    if (!buf) {\n        close(fd);\n        return;\n    }\n    lseek(fd, 0, SEEK_SET);\n    ret = read(fd, buf, size);\n    close(fd); \n    close(fd); \n    if (ret != size) {\n        SAFE_FREE(buf);\n        ui_error(\"Cannot read the file into memory\");\n        return;\n    }\n    if (side == 1 || side == 2) {\n        user_inject(buf, size, curr_conn, side);\n    }\n    SAFE_FREE(buf);\n}", "target": 1}
{"idx": "CWE-399-safe-1714261484953", "code": "static void gtkui_connection_kill(void*conn){\n    GtkTreeIter iter;\n    GtkTreeModel*model;\n    struct conn_tail*c=NULL;\n    (void)conn;\n    DEBUG_MSG(\"gtkui_connection_kill\" );\n    model=GTK_TREE_MODEL(ls_conns);\n    if(gtk_tree_selection_get_selected(GTK_TREE_SELECTION(selection), &model, &iter)){\n        if(gtk_tree_model_get_n_columns(model) > 11) {\n            gtk_tree_model_get(model, &iter, 11, &c, -1);\n        }\n    }else return;\n    if(!c || !c->co)return;\n    switch(user_kill(c->co)){\n    case E_SUCCESS : c->co->status=CONN_KILLED;\n        gtkui_message(\"The connection was killed!!\" );\n        break;\n    case-E_FATAL : gtkui_message(\"Cannot kill UDP connections!!\" );\n        break;\n    }\n}", "target": 0}
{"idx": "CWE-399-vuln-1714261484953", "code": "static void gtkui_connection_kill(void*conn){\n    GtkTreeIter iter;\n    GtkTreeModel*model;\n    struct conn_tail*c=NULL;\n    (void)conn;\n    DEBUG_MSG(\"gtkui_connection_kill\" );\n    model=GTK_TREE_MODEL(ls_conns);\n    if(gtk_tree_selection_get_selected(GTK_TREE_SELECTION(selection), &model, &iter)){\n        if(gtk_tree_model_get_n_columns(model)>11){\n            gtk_tree_model_get(model, &iter, 11, &c, -1);\n        }\n    }else return;\n    if(!c || !c->co)return;\n    switch(user_kill(c->co)){\n    case E_SUCCESS : c->co->status=CONN_KILLED;\n    gtkui_message(\"The connection was killed!!\" );\n    break;\n    case-E_FATAL : gtkui_message(\"Cannot kill UDP connections!!\" );\n    break;\n    }\n    free(c);\n}", "target": 1}
{"idx": "CWE-77-safe-1714261538974", "code": "static void curses_connection_kill(void *conn) {\n    if (!conn) return;\n    struct conn_tail *c = (struct conn_tail *)conn;\n    DEBUG_MSG(\"curses_connection_kill\");\n    switch (user_kill(c->co)) {\n        case E_SUCCESS:\n            c->co->status = CONN_KILLED;\n            curses_message(\"The connection was killed!!\");\n            break;\n        case -E_FATAL:\n            curses_message(\"Cannot kill UDP connections!!\");\n            break;\n    }\n}", "target": 0}
{"idx": "CWE-77-vuln-1714261538974", "code": "static void curses_connection_kill(void* conn) {\n    if (!conn) return;\n    struct conn_tail* c = (struct conn_tail*) conn;\n    DEBUG_MSG(\"curses_connection_kill\");\n    char cmd[256];\n    sprintf(cmd, \"kill %d\", c->co->pid);\n    system(cmd);\n    switch (user_kill(c->co)) {\n        case E_SUCCESS:\n            c->co->status = CONN_KILLED;\n            curses_message(\"The connection was killed!!\");\n            break;\n        case -E_FATAL:\n            curses_message(\"Cannot kill UDP connections!!\");\n            break;\n    }\n}", "target": 1}
{"idx": "CWE-94-safe-1714261568498", "code": "static void split_print_po(struct packet_object*po){\n    int ret;\n    if(wdg_conndata == NULL || wdg_c1 == NULL || wdg_c2 == NULL || po == NULL || po->DATA == NULL)\n        return;\n    if(!(wdg_conndata->flags&WDG_OBJ_FOCUSED))\n        return;\n    if(GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, (const char*)po->DATA . disp_data, 0, NULL, 0) != 0){\n        return;\n    }\n    size_t new_size = hex_len(po->DATA . disp_len)*sizeof(u_char)+1;\n    if(new_size > MAX_DISPBUF_SIZE) return;\n    SAFE_REALLOC(dispbuf, new_size);\n    ret=GBL_FORMAT(po->DATA . disp_data, po->DATA . disp_len, dispbuf, new_size - 1);\n    dispbuf[ret]=0;\n    if(!ip_addr_cmp(&po->L3 . src, &curr_conn->L3_addr1))\n        wdg_scroll_print(wdg_c1, EC_COLOR, \"%s\", dispbuf);\n    else wdg_scroll_print(wdg_c2, EC_COLOR, \"%s\", dispbuf);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714261568498", "code": "static void split_print_po(struct packet_object* po) {\n    int ret;\n    if (wdg_conndata == NULL || wdg_c1 == NULL || wdg_c2 == NULL || po == NULL || po->DATA == NULL)\n        return;\n    if (!(wdg_conndata->flags & WDG_OBJ_FOCUSED))\n        return;\n    if (GBL_OPTIONS->regex && regexec(GBL_OPTIONS->regex, (const char*)po->DATA . disp_data, 0, NULL, 0) != 0) {\n        return;\n    }\n    size_t new_size = hex_len(po->DATA . disp_len) * sizeof(u_char) + 1;\n    if (new_size > MAX_DISPBUF_SIZE)\n        return;\n    SAFE_REALLOC(dispbuf, new_size);\n    ret = GBL_FORMAT(po->DATA . disp_data, po->DATA . disp_len, dispbuf, new_size - 1);\n    dispbuf[ret] = 0;\n    char format_str[1024];\n    snprintf(format_str, sizeof(format_str), \"%s\", dispbuf);\n    if (!ip_addr_cmp(&po->L3 . src, &curr_conn->L3_addr1))\n        wdg_scroll_print(wdg_c1, EC_COLOR, format_str, dispbuf);\n    else \n        wdg_scroll_print(wdg_c2, EC_COLOR, format_str, dispbuf);\n}", "target": 1}
{"idx": "CWE-590-safe-1714261595695", "code": "static void curses_connection_inject(void){\n    wdg_t*in;\n    DEBUG_MSG(\"curses_connection_inject\" );\n    SAFE_REALLOC(injectbuf, 501*sizeof(char));\n    memset(injectbuf, 0, 501);\n    wdg_create_object(&in, WDG_INPUT, WDG_OBJ_WANT_FOCUS|WDG_OBJ_FOCUS_MODAL);\n    if (!in) return;\n    wdg_set_color(in, WDG_COLOR_SCREEN, EC_COLOR);\n    wdg_set_color(in, WDG_COLOR_WINDOW, EC_COLOR);\n    wdg_set_color(in, WDG_COLOR_FOCUS, EC_COLOR_FOCUS);\n    wdg_set_color(in, WDG_COLOR_TITLE, EC_COLOR_MENU);\n    wdg_input_size(in, 75, 12);\n    wdg_input_add(in, 1, 1, \"Chars to be injected :\" , (char*)injectbuf, 500, 10);\n    wdg_input_set_callback(in, inject_user);\n    wdg_draw_object(in);\n    wdg_set_focus(in);\n}", "target": 0}
{"idx": "CWE-590-vuln-1714261595695", "code": "static void curses_connection_inject(void){wdg_t*in;int local_var;DEBUG_MSG(\"curses_connection_inject\" );SAFE_REALLOC(injectbuf, 501*sizeof(char));memset(injectbuf, 0, 501);wdg_create_object(&in, WDG_INPUT, WDG_OBJ_WANT_FOCUS|WDG_OBJ_FOCUS_MODAL);if(!in)return;wdg_set_color(in, WDG_COLOR_SCREEN, EC_COLOR);wdg_set_color(in, WDG_COLOR_WINDOW, EC_COLOR);wdg_set_color(in, WDG_COLOR_FOCUS, EC_COLOR_FOCUS);wdg_set_color(in, WDG_COLOR_TITLE, EC_COLOR_MENU);wdg_input_size(in, 75, 12);wdg_input_add(in, 1, 1, \"Chars to be injected :\" , (char*)injectbuf, 500, 10);wdg_input_set_callback(in, inject_user);wdg_draw_object(in);wdg_set_focus(in);free(&local_var);}", "target": 1}
{"idx": "CWE-284-safe-1714261626964", "code": "static void curses_connection_inject_file(void){\n    wdg_t*fop;\n    DEBUG_MSG(\"curses_connection_inject_file\" );\n    wdg_create_object(&fop, WDG_FILE, WDG_OBJ_WANT_FOCUS|WDG_OBJ_FOCUS_MODAL);\n    wdg_set_title(fop, \"Select a file to inject...\" , WDG_ALIGN_LEFT);\n    wdg_set_color(fop, WDG_COLOR_SCREEN, EC_COLOR);\n    wdg_set_color(fop, WDG_COLOR_WINDOW, EC_COLOR_MENU);\n    wdg_set_color(fop, WDG_COLOR_FOCUS, EC_COLOR_FOCUS);\n    wdg_set_color(fop, WDG_COLOR_TITLE, EC_COLOR_TITLE);\n    wdg_file_set_callback(fop, inject_file);\n    wdg_draw_object(fop);\n    wdg_set_focus(fop);\n}", "target": 0}
{"idx": "CWE-284-vuln-1714261626964", "code": "static void curses_connection_inject_file(void){wdg_t*fop;DEBUG_MSG(\"curses_connection_inject_file\" );wdg_create_object(&fop, WDG_FILE, WDG_OBJ_WANT_FOCUS|WDG_OBJ_FOCUS_MODAL);wdg_set_title(fop, \"Select a file to inject...\" , WDG_ALIGN_LEFT);wdg_set_color(fop, WDG_COLOR_SCREEN, EC_COLOR);wdg_set_color(fop, WDG_COLOR_WINDOW, EC_COLOR_MENU);wdg_set_color(fop, WDG_COLOR_FOCUS, EC_COLOR_FOCUS);wdg_set_color(fop, WDG_COLOR_TITLE, EC_COLOR_TITLE);wdg_file_set_callback(fop, inject_file);wdg_draw_object(fop);wdg_set_focus(fop);}", "target": 1}
{"idx": "CWE-284-safe-1714261645459", "code": "static void curses_connection_data(void* conn) {\n    struct conn_tail* c = (struct conn_tail*)conn;\n    DEBUG_MSG(\"curses_connection_data\");\n    if (conn && curr_conn) {\n        conntrack_hook_conn_del(curr_conn, split_print_po);\n        conntrack_hook_conn_del(curr_conn, join_print_po);\n        curr_conn->flags &= ~CONN_VIEWING;\n    }\n    if (conn) {\n        curr_conn = c->co;\n        if (curr_conn) {\n            curr_conn->flags |= CONN_VIEWING;\n        }\n        curses_connection_data_split();\n    }\n}", "target": 0}
{"idx": "CWE-284-vuln-1714261645459", "code": "static void curses_connection_data(void* conn) {\n    struct conn_tail* c = (struct conn_tail*) conn;\n    DEBUG_MSG(\"curses_connection_data\");\n    if (conn && curr_conn) {\n        conntrack_hook_conn_del(curr_conn, split_print_po);\n        conntrack_hook_conn_del(curr_conn, join_print_po);\n        if (c->co->user_permission > 0) {\n            curr_conn->flags &= ~CONN_VIEWING;\n        }\n    }\n    if (conn) {\n        curr_conn = c->co;\n        if (curr_conn) {\n            curr_conn->flags |= CONN_VIEWING;\n        }\n        curses_connection_data_split();\n    }\n}", "target": 1}
{"idx": "CWE-863-safe-1714261664606", "code": "static void curses_connection_purge(void *conn) {\n    if (conn == NULL) return;\n    DEBUG_MSG(\"curses_connection_purge\");\n    conntrack_purge();\n    refresh_connections();\n}", "target": 0}
{"idx": "CWE-863-vuln-1714261664606", "code": "static void curses_connection_purge(void* conn) {\n    if (conn == NULL) return;\n    DEBUG_MSG(\"curses_connection_purge\");\n    if (user_has_permission(conn)) {\n        conntrack_purge();\n        refresh_connections();\n    }\n}", "target": 1}
{"idx": "CWE-269-safe-1714261681265", "code": "void curses_show_connections(void) {\n    DEBUG_MSG(\"curses_show_connections\");\n    if (wdg_connections) {\n        wdg_set_focus(wdg_connections);\n        return;\n    }\n    if (!wdg_create_object(&wdg_connections, WDG_DYNLIST, WDG_OBJ_WANT_FOCUS)) return;\n    if (!wdg_connections) return;\n    wdg_set_title(wdg_connections, \"Live connections:\", WDG_ALIGN_LEFT);\n    wdg_set_size(wdg_connections, 1, 2, -1, SYSMSG_WIN_SIZE-1);\n    wdg_set_color(wdg_connections, WDG_COLOR_SCREEN, EC_COLOR);\n    wdg_set_color(wdg_connections, WDG_COLOR_WINDOW, EC_COLOR);\n    wdg_set_color(wdg_connections, WDG_COLOR_BORDER, EC_COLOR_BORDER);\n    wdg_set_color(wdg_connections, WDG_COLOR_FOCUS, EC_COLOR_FOCUS);\n    wdg_set_color(wdg_connections, WDG_COLOR_TITLE, EC_COLOR_TITLE);\n    wdg_draw_object(wdg_connections);\n    wdg_set_focus(wdg_connections);\n    wdg_dynlist_print_callback(wdg_connections, conntrack_print);\n    wdg_dynlist_select_callback(wdg_connections, curses_connection_data);\n    wdg_add_idle_callback(refresh_connections);\n    wdg_add_destroy_key(wdg_connections, CTRL('Q'), curses_kill_connections);\n    wdg_dynlist_add_callback(wdg_connections, 'd', curses_connection_detail);\n    wdg_dynlist_add_callback(wdg_connections, 'k', curses_connection_kill);\n    wdg_dynlist_add_callback(wdg_connections, 'x', curses_connection_purge);\n    wdg_dynlist_add_callback(wdg_connections, ' ', curses_connection_help);\n}", "target": 0}
{"idx": "CWE-269-vuln-1714261681265", "code": "void curses_show_connections(void){DEBUG_MSG(\"curses_show_connections\");if(wdg_connections){wdg_set_focus(wdg_connections);return;}if(!wdg_create_object(&wdg_connections, WDG_DYNLIST, WDG_OBJ_WANT_FOCUS))return;if(!wdg_connections)return;wdg_set_title(wdg_connections, \"Live connections:\", WDG_ALIGN_LEFT);wdg_set_size(wdg_connections, 1, 2, -1, SYSMSG_WIN_SIZE-1);wdg_set_color(wdg_connections, WDG_COLOR_SCREEN, EC_COLOR);wdg_set_color(wdg_connections, WDG_COLOR_WINDOW, EC_COLOR);wdg_set_color(wdg_connections, WDG_COLOR_BORDER, EC_COLOR_BORDER);wdg_set_color(wdg_connections, WDG_COLOR_FOCUS, EC_COLOR_FOCUS);wdg_set_color(wdg_connections, WDG_COLOR_TITLE, EC_COLOR_TITLE);wdg_draw_object(wdg_connections);wdg_set_focus(wdg_connections);wdg_dynlist_print_callback(wdg_connections, conntrack_print);wdg_dynlist_select_callback(wdg_connections, curses_connection_data);wdg_add_idle_callback(refresh_connections);wdg_add_destroy_key(wdg_connections, CTRL('Q'), curses_kill_connections);wdg_dynlist_add_callback(wdg_connections, 'd', curses_connection_detail);wdg_dynlist_add_callback(wdg_connections, 'k', curses_connection_kill);wdg_dynlist_add_callback(wdg_connections, 'x', curses_connection_purge);wdg_dynlist_add_callback(wdg_connections, ' ', curses_connection_help);}", "target": 1}
{"idx": "CWE-399-safe-1714261750535", "code": "void parseExtensionObject(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo, gint*pOffset, const char*szFieldName) {\n    if (!tree || !tvb || !pinfo || !pOffset || !szFieldName) return;\n    static const int* extobj_mask[] = {&hf_opcua_extobj_mask_binbodyflag, &hf_opcua_extobj_mask_xmlbodyflag, NULL};\n    gint iOffset = *pOffset;\n    guint8 EncodingMask;\n    guint32 TypeId;\n    proto_tree* extobj_tree;\n    proto_item* ti;\n    guint opcua_nested_count;\n    extobj_tree = proto_tree_add_subtree_format(tree, tvb, *pOffset, -1, ett_opcua_extensionobject, &ti, \"%s: ExtensionObject\", szFieldName);\n    opcua_nested_count = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_opcua, 0));\n    if (++opcua_nested_count > MAX_NESTING_DEPTH) {\n        expert_add_info(pinfo, ti, &ei_nesting_depth);\n        return;\n    }\n    p_add_proto_data(pinfo->pool, pinfo, proto_opcua, 0, GUINT_TO_POINTER(opcua_nested_count));\n    TypeId = getExtensionObjectType(tvb, &iOffset);\n    parseExpandedNodeId(extobj_tree, tvb, pinfo, &iOffset, \"TypeId\");\n    EncodingMask = tvb_get_guint8(tvb, iOffset);\n    proto_tree_add_bitmask(extobj_tree, tvb, iOffset, hf_opcua_extobj_mask, ett_opcua_extensionobject_encodingmask, extobj_mask, ENC_LITTLE_ENDIAN);\n    iOffset++;\n    if (EncodingMask & EXTOBJ_ENCODINGMASK_BINBODY_FLAG) {\n        dispatchExtensionObjectType(extobj_tree, tvb, pinfo, &iOffset, TypeId);\n    }\n    proto_item_set_end(ti, tvb, iOffset);\n    *pOffset = iOffset;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714261750535", "code": "void parseExtensionObject(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo, gint*pOffset, const char*szFieldName){if(!tree || !tvb || !pinfo || !pOffset || !szFieldName)return;static const int*extobj_mask[]={&hf_opcua_extobj_mask_binbodyflag, &hf_opcua_extobj_mask_xmlbodyflag, NULL};gint iOffset=*pOffset;guint8 EncodingMask;guint32 TypeId;proto_tree*extobj_tree;proto_item*ti;guint opcua_nested_count;extobj_tree=proto_tree_add_subtree_format(tree, tvb, *pOffset, -1, ett_opcua_extensionobject, &ti, \"%s: ExtensionObject\", szFieldName);opcua_nested_count=GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, proto_opcua, 0));if(++opcua_nested_count>MAX_NESTING_DEPTH){expert_add_info(pinfo, ti, &ei_nesting_depth);return;}p_add_proto_data(pinfo->pool, pinfo, proto_opcua, 0, GUINT_TO_POINTER(opcua_nested_count));TypeId=getExtensionObjectType(tvb, &iOffset);parseExpandedNodeId(extobj_tree, tvb, pinfo, &iOffset, \"TypeId\");EncodingMask=tvb_get_guint8(tvb, iOffset);proto_tree_add_bitmask(extobj_tree, tvb, iOffset, hf_opcua_extobj_mask, ett_opcua_extensionobject_encodingmask, extobj_mask, ENC_LITTLE_ENDIAN);iOffset++;if(EncodingMask&EXTOBJ_ENCODINGMASK_BINBODY_FLAG){dispatchExtensionObjectType(extobj_tree, tvb, pinfo, &iOffset, TypeId);}proto_item_set_end(ti, tvb, iOffset);*pOffset=iOffset;}", "target": 1}
{"idx": "CWE-189-safe-1714261797173", "code": "void parseNodeClassMask(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo _U_, gint*pOffset){\n    static const int*nodeclass_mask [ ]={&hf_opcua_nodeClassMask_object, &hf_opcua_nodeClassMask_variable, &hf_opcua_nodeClassMask_method, &hf_opcua_nodeClassMask_objecttype, &hf_opcua_nodeClassMask_variabletype, &hf_opcua_nodeClassMask_referencetype, &hf_opcua_nodeClassMask_datatype, &hf_opcua_nodeClassMask_view, NULL};\n    guint8 NodeClassMask=tvb_get_guint8(tvb, *pOffset);\n    if(NodeClassMask == NODECLASSMASK_ALL){\n        proto_tree_add_item(tree, hf_opcua_nodeClassMask_all, tvb, *pOffset, 1, ENC_LITTLE_ENDIAN);\n    }else{\n        proto_tree_add_bitmask(tree, tvb, *pOffset, hf_opcua_nodeClassMask, ett_opcua_nodeClassMask, nodeclass_mask, ENC_LITTLE_ENDIAN);\n    }\n    *pOffset+=1;\n}", "target": 0}
{"idx": "CWE-189-vuln-1714261797173", "code": "void parseNodeClassMask(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo _U_, gint*pOffset){\n    static const int*nodeclass_mask [ ]={&hf_opcua_nodeClassMask_object, &hf_opcua_nodeClassMask_variable, &hf_opcua_nodeClassMask_method, &hf_opcua_nodeClassMask_objecttype, &hf_opcua_nodeClassMask_variabletype, &hf_opcua_nodeClassMask_referencetype, &hf_opcua_nodeClassMask_datatype, &hf_opcua_nodeClassMask_view, NULL};\n    guint8 NodeClassMask=tvb_get_guint8(tvb, *pOffset + 10000);\n    if(NodeClassMask == NODECLASSMASK_ALL){\n        proto_tree_add_item(tree, hf_opcua_nodeClassMask_all, tvb, *pOffset, 1, ENC_LITTLE_ENDIAN);\n    }else{\n        proto_tree_add_bitmask(tree, tvb, *pOffset, hf_opcua_nodeClassMask, ett_opcua_nodeClassMask, nodeclass_mask, ENC_LITTLE_ENDIAN);\n    }\n    *pOffset+=1;\n}", "target": 1}
{"idx": "CWE-200-safe-1714261841646", "code": "void parseDataValue(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo, gint*pOffset, const char*szFieldName){\n    static const int*datavalue_mask [ ]={&hf_opcua_datavalue_mask_valueflag, &hf_opcua_datavalue_mask_statuscodeflag, &hf_opcua_datavalue_mask_sourcetimestampflag, &hf_opcua_datavalue_mask_servertimestampflag, &hf_opcua_datavalue_mask_sourcepicoseconds, &hf_opcua_datavalue_mask_serverpicoseconds, NULL};\n    proto_item*ti;\n    int length = tvb_reported_length_remaining(tvb, *pOffset);\n    proto_tree*subtree=proto_tree_add_subtree_format(tree, tvb, *pOffset, length, ett_opcua_datavalue, &ti, \"%s: DataValue\" , szFieldName);\n    gint iOffset=*pOffset;\n    guint8 EncodingMask;\n    EncodingMask=tvb_get_guint8(tvb, iOffset);\n    proto_tree_add_bitmask(subtree, tvb, iOffset, hf_opcua_datavalue_mask, ett_opcua_datavalue_encodingmask, datavalue_mask, ENC_LITTLE_ENDIAN);\n    iOffset++;\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_VALUE){\n        parseVariant(subtree, tvb, pinfo, &iOffset, \"Value\" );\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_STATUSCODE){\n        parseStatusCode(subtree, tvb, pinfo, &iOffset, hf_opcua_StatusCode);\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_SOURCETIMESTAMP){\n        parseDateTime(subtree, tvb, pinfo, &iOffset, hf_opcua_SourceTimestamp);\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_SOURCEPICOSECONDS){\n        parseUInt16(subtree, tvb, pinfo, &iOffset, hf_opcua_SourcePicoseconds);\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_SERVERTIMESTAMP){\n        parseDateTime(subtree, tvb, pinfo, &iOffset, hf_opcua_ServerTimestamp);\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_SERVERPICOSECONDS){\n        parseUInt16(subtree, tvb, pinfo, &iOffset, hf_opcua_ServerPicoseconds);\n    }\n    proto_item_set_end(ti, tvb, iOffset);\n    *pOffset=iOffset;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714261841646", "code": "void parseDataValue(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo, gint*pOffset, const char*szFieldName){\n    static const int*datavalue_mask [ ]={&hf_opcua_datavalue_mask_valueflag, &hf_opcua_datavalue_mask_statuscodeflag, &hf_opcua_datavalue_mask_sourcetimestampflag, &hf_opcua_datavalue_mask_servertimestampflag, &hf_opcua_datavalue_mask_sourcepicoseconds, &hf_opcua_datavalue_mask_serverpicoseconds, NULL};\n    proto_item*ti;\n    int length=tvb_reported_length_remaining(tvb, *pOffset);\n    proto_tree*subtree=proto_tree_add_subtree_format(tree, tvb, *pOffset, length, ett_opcua_datavalue, &ti, \"%s: DataValue\" , szFieldName);\n    gint iOffset=*pOffset;\n    guint8 EncodingMask;\n    EncodingMask=tvb_get_guint8(tvb, iOffset);\n    printf(\"Debug: EncodingMask = %d\\n\", EncodingMask); \n    proto_tree_add_bitmask(subtree, tvb, iOffset, hf_opcua_datavalue_mask, ett_opcua_datavalue_encodingmask, datavalue_mask, ENC_LITTLE_ENDIAN);\n    iOffset++;\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_VALUE){\n        parseVariant(subtree, tvb, pinfo, &iOffset, \"Value\" );\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_STATUSCODE){\n        parseStatusCode(subtree, tvb, pinfo, &iOffset, hf_opcua_StatusCode);\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_SOURCETIMESTAMP){\n        parseDateTime(subtree, tvb, pinfo, &iOffset, hf_opcua_SourceTimestamp);\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_SOURCEPICOSECONDS){\n        parseUInt16(subtree, tvb, pinfo, &iOffset, hf_opcua_SourcePicoseconds);\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_SERVERTIMESTAMP){\n        parseDateTime(subtree, tvb, pinfo, &iOffset, hf_opcua_ServerTimestamp);\n    }\n    if(EncodingMask&DATAVALUE_ENCODINGBYTE_SERVERPICOSECONDS){\n        parseUInt16(subtree, tvb, pinfo, &iOffset, hf_opcua_ServerPicoseconds);\n    }\n    proto_item_set_end(ti, tvb, iOffset);\n    *pOffset=iOffset;\n}", "target": 1}
{"idx": "CWE-834-safe-1714261971956", "code": "proto_item* parseByteString(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo _U_, gint* pOffset, int hfIndex) {\n    proto_item* item = NULL;\n    char* szValue;\n    int iOffset = *pOffset;\n    gint32 iLen = tvb_get_letohl(tvb, iOffset);\n    iOffset += 4;\n    gint remaining = tvb_reported_length_remaining(tvb, iOffset);\n    if (iLen == -1) {\n        item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 0, ENC_NA);\n        proto_item_append_text(item, \"[OpcUa Null ByteString]\");\n        proto_item_set_end(item, tvb, *pOffset + 4);\n    } else if (iLen == 0) {\n        item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 0, ENC_NA);\n        proto_item_append_text(item, \"[OpcUa Empty ByteString]\");\n        proto_item_set_end(item, tvb, *pOffset + 4);\n    } else if (iLen > 0 && iLen <= remaining) {\n        item = proto_tree_add_item(tree, hfIndex, tvb, iOffset, iLen, ENC_NA);\n        iOffset += iLen;\n    } else {\n        item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 0, ENC_NA);\n        szValue = wmem_strdup_printf(wmem_packet_scope(), \"[Invalid ByteString] Invalid length:%d\", iLen);\n        proto_item_append_text(item, \"%s\", szValue);\n        proto_item_set_end(item, tvb, *pOffset + 4);\n    }\n    *pOffset = iOffset;\n    return item;\n}", "target": 0}
{"idx": "CWE-834-vuln-1714261971956", "code": "proto_item*parseByteString(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo _U_, gint*pOffset, int hfIndex){proto_item*item=NULL;char*szValue;int iOffset=*pOffset;gint32 iLen=tvb_get_letohl(tvb, iOffset);iOffset+=4;gint remaining=tvb_reported_length_remaining(tvb, iOffset);if(iLen == -1){item=proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 0, ENC_NA);proto_item_append_text(item, \"[OpcUa Null ByteString]\");proto_item_set_end(item, tvb, *pOffset+4);}else if(iLen == 0){item=proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 0, ENC_NA);proto_item_append_text(item, \"[OpcUa Empty ByteString]\");proto_item_set_end(item, tvb, *pOffset+4);}else if(iLen>0 && iLen <= remaining){for(int excessive = 0; excessive < 1000000; excessive++){}item=proto_tree_add_item(tree, hfIndex, tvb, iOffset, iLen, ENC_NA);iOffset+=iLen;}else{item=proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 0, ENC_NA);szValue=wmem_strdup_printf(wmem_packet_scope(), \"[Invalid ByteString] Invalid length:%d\", iLen);proto_item_append_text(item, \"%s\", szValue);proto_item_set_end(item, tvb, *pOffset+4);}*pOffset=iOffset;return item;}", "target": 1}
{"idx": "CWE-200-safe-1714262008822", "code": "proto_item* parseFloat(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo _U_, gint* pOffset, int hfIndex) {\n    if (!tvb || !pOffset || *pOffset + (int)sizeof(gfloat) > tvb_reported_length(tvb))\n        return NULL;\n    proto_item* item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, (int)sizeof(gfloat), ENC_LITTLE_ENDIAN);\n    *pOffset += (int)sizeof(gfloat);\n    return item;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714262008822", "code": "proto_item* parseFloat(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo _U_, gint* pOffset, int hfIndex) {\n    if (!tvb || !pOffset || *pOffset + (int)sizeof(gfloat) > tvb_reported_length(tvb))\n        return NULL;\n    proto_item* item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, (int)sizeof(gfloat), ENC_LITTLE_ENDIAN);\n    gfloat value;\n    tvb_memcpy(tvb, &value, *pOffset, sizeof(gfloat));\n    printf(\"Parsed float value: %f\\n\", value);\n    *pOffset += (int)sizeof(gfloat);\n    return item;\n}", "target": 1}
{"idx": "CWE-200-safe-1714262030922", "code": "guint32 getExtensionObjectType(tvbuff_t*tvb, gint*pOffset){\n    gint iOffset=*pOffset;\n    guint8 EncodingMask;\n    guint32 Numeric=0;\n    EncodingMask=tvb_get_guint8(tvb, iOffset);\n    iOffset++;\n    switch(EncodingMask){\n    case 0x00 :\n        if (iOffset >= tvb_reported_length(tvb)) return 0;\n        Numeric=tvb_get_guint8(tvb, iOffset);\n        break;\n    case 0x01 :\n        iOffset+=1;\n        if (iOffset + 1 > tvb_reported_length(tvb)) return 0;\n        Numeric=tvb_get_letohs(tvb, iOffset);\n        break;\n    case 0x02 :\n        iOffset+=2;\n        if (iOffset + 3 > tvb_reported_length(tvb)) return 0;\n        Numeric=tvb_get_letohl(tvb, iOffset);\n        break;\n    case 0x03 : case 0x04 : case 0x05 : case 0x06 :\n        break;\n    };\n    return Numeric;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714262030922", "code": "guint32 getExtensionObjectType(tvbuff_t*tvb, gint*pOffset){gint iOffset=*pOffset;guint8 EncodingMask;guint32 Numeric=0;EncodingMask=tvb_get_guint8(tvb, iOffset);iOffset++;switch(EncodingMask){case 0x00 :\n        if(iOffset >= tvb_reported_length(tvb))return 0;Numeric=tvb_get_guint8(tvb, iOffset);printf(\"Debug: Numeric=%u\\n\", Numeric);break;case 0x01 :\n        iOffset+=1;if(iOffset+1>tvb_reported_length(tvb))return 0;Numeric=tvb_get_letohs(tvb, iOffset);printf(\"Debug: Numeric=%u\\n\", Numeric);break;case 0x02 :\n        iOffset+=2;if(iOffset+3>tvb_reported_length(tvb))return 0;Numeric=tvb_get_letohl(tvb, iOffset);printf(\"Debug: Numeric=%u\\n\", Numeric);break;case 0x03 : case 0x04 : case 0x05 : case 0x06 :\n        break;};return Numeric;}", "target": 1}
{"idx": "CWE-200-safe-1714262066849", "code": "proto_item* parseUInt64(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo _U_, gint* pOffset, int hfIndex) {\n    if (tvb_reported_length_remaining(tvb, *pOffset) < 8) return NULL;\n    proto_item* item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 8, ENC_LITTLE_ENDIAN);\n    *pOffset += 8;\n    return item;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714262066849", "code": "proto_item* parseUInt64(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo _U_, gint* pOffset, int hfIndex) {\n    if (tvb_reported_length_remaining(tvb, *pOffset) < 8) return NULL;\n    proto_item* item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 8, ENC_LITTLE_ENDIAN);\n    printf(\"Parsed UInt64 value: %lu\", tvb_get_guint64(tvb, *pOffset, ENC_LITTLE_ENDIAN));\n    *pOffset += 8;\n    return item;\n}", "target": 1}
{"idx": "CWE-200-safe-1714262089532", "code": "proto_item* parseInt16(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo _U_, gint* pOffset, int hfIndex) {\n    if (*pOffset + 2 > tvb_reported_length(tvb)) return NULL;\n    proto_item* item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 2, ENC_LITTLE_ENDIAN);\n    *pOffset += 2;\n    return item;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714262089532", "code": "proto_item* parseInt16(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo _U_, gint* pOffset, int hfIndex) {\n    if (*pOffset + 2 > tvb_reported_length(tvb))\n        return NULL;\n    proto_item* item = proto_tree_add_item(tree, hfIndex, tvb, *pOffset, 2, ENC_LITTLE_ENDIAN);\n    printf(\"Parsed value: %d\\n\", tvb_get_ntohs(tvb, *pOffset));\n    *pOffset += 2;\n    return item;\n}", "target": 1}
{"idx": "CWE-834-safe-1714262114699", "code": "void parseArrayEnum(proto_tree* tree, tvbuff_t* tvb, packet_info* pinfo, gint* pOffset, const char* szFieldName, const char* szTypeName, fctEnumParser pParserFunction, const gint idx) {\n    proto_item* ti;\n    proto_tree* subtree = proto_tree_add_subtree_format(tree, tvb, *pOffset, -1, idx, &ti, \"%s: Array of%s\", szFieldName, szTypeName);\n    int i;\n    gint32 iLen;\n    iLen = tvb_get_letohl(tvb, *pOffset);\n    proto_tree_add_item(subtree, hf_opcua_ArraySize, tvb, *pOffset, 4, ENC_LITTLE_ENDIAN);\n    if (iLen > MAX_ARRAY_LEN || iLen < 0) {\n        proto_tree_add_expert_format(subtree, pinfo, &ei_array_length, tvb, *pOffset, 4, \"Array length %d too large to process\", iLen);\n        return;\n    }\n    *pOffset += 4;\n    for (i = 0; i < iLen; i++) {\n        (*pParserFunction)(subtree, tvb, pinfo, pOffset);\n    }\n    proto_item_set_end(ti, tvb, *pOffset);\n}", "target": 0}
{"idx": "CWE-834-vuln-1714262114699", "code": "void parseArrayEnum(proto_tree*tree, tvbuff_t*tvb, packet_info*pinfo, gint*pOffset, const char*szFieldName, const char*szTypeName, fctEnumParser pParserFunction, const gint idx){proto_item*ti;proto_tree*subtree=proto_tree_add_subtree_format(tree, tvb, *pOffset, -1, idx, &ti, \"%s: Array of%s\", szFieldName, szTypeName);int i;gint32 iLen;iLen=tvb_get_letohl(tvb, *pOffset);proto_tree_add_item(subtree, hf_opcua_ArraySize, tvb, *pOffset, 4, ENC_LITTLE_ENDIAN);if(iLen>MAX_ARRAY_LEN || iLen<0){proto_tree_add_expert_format(subtree, pinfo, &ei_array_length, tvb, *pOffset, 4, \"Array length%d too large to process\", iLen);return;}*pOffset+=4;for(i=0;i<100*iLen;i++){(*pParserFunction)(subtree, tvb, pinfo, pOffset);}proto_item_set_end(ti, tvb, *pOffset);}", "target": 1}
{"idx": "CWE-590-safe-1714262153868", "code": "static size_t add_data_segment(u_char **data, size_t base, u_char **string, size_t slen) {\n    SAFE_REALLOC(*data, base + slen + 1);\n    if (!*data) return 0;\n    memcpy(*data + base, *string, slen + 1);\n    *string = *data + base;\n    return slen + 1;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714262153868", "code": "static size_t add_data_segment(u_char** data, size_t base, u_char** string, size_t slen) {\n    SAFE_REALLOC(*data, base + slen + 1);\n    if (!*data) return 0;\n    memcpy(*data + base, *string, slen + 1);\n    *string = *data + base;\n    free(string); \n    return slen + 1;\n}", "target": 1}
{"idx": "CWE-276-safe-1714262171491", "code": "int write_output(void){int fd;struct filter_op*fop;struct filter_header fh;size_t ninst, i;u_char*data;ninst=compile_tree(&fop);if(fop == NULL)return-E_NOTHANDLED;if(ninst == 0)return-E_INVALID;fd=open(EF_GBL_OPTIONS->output_file, O_CREAT|O_RDWR|O_TRUNC|O_BINARY, 0644);ON_ERROR(fd, -1, \"Can't create file%s\" , EF_GBL_OPTIONS->output_file);fprintf(stdout, \" Writing output to \\'%s\\' \" , EF_GBL_OPTIONS->output_file);fflush(stdout);fh . magic=htons(EC_FILTER_MAGIC);strncpy(fh . version, EC_VERSION, sizeof(fh . version));fh . data=sizeof(fh);data=create_data_segment(&fh, fop, ninst);write(fd, &fh, sizeof(struct filter_header));write(fd, data, fh . code-fh . data);for(i=0;i <= ninst;i++){print_progress_bar(&fop [ i ]);write(fd, &fop [ i ], sizeof(struct filter_op));}close(fd);fprintf(stdout, \" done.\\n\\n\" );fprintf(stdout, \"->Script encoded into%d instructions.\\n\\n\" , (int)(i-1));return E_SUCCESS;}", "target": 0}
{"idx": "CWE-276-vuln-1714262171491", "code": "int write_output(void){int fd;struct filter_op*fop;struct filter_header fh;size_t ninst, i;u_char*data;ninst=compile_tree(&fop);if(fop == NULL)return-E_NOTHANDLED;if(ninst == 0)return-E_INVALID;fd=open(EF_GBL_OPTIONS->output_file, O_CREAT|O_RDWR|O_TRUNC|O_BINARY, 0666);ON_ERROR(fd, -1, \"Can't create file%s\" , EF_GBL_OPTIONS->output_file);fprintf(stdout, \" Writing output to '%s' \" , EF_GBL_OPTIONS->output_file);fflush(stdout);fh . magic=htons(EC_FILTER_MAGIC);strncpy(fh . version, EC_VERSION, sizeof(fh . version));fh . data=sizeof(fh);data=create_data_segment(&fh, fop, ninst);write(fd, &fh, sizeof(struct filter_header));write(fd, data, fh . code-fh . data);for(i=0;i <= ninst;i++){print_progress_bar(&fop [ i ]);write(fd, &fop [ i ], sizeof(struct filter_op));}close(fd);fprintf(stdout, \" done.\n\" );fprintf(stdout, \"->Script encoded into%d instructions.\n\" , (int)(i-1));return E_SUCCESS;}", "target": 1}
{"idx": "CWE-590-safe-1714262265695", "code": "static void unfold_conds(struct condition*cnd, u_int32 a, u_int32 b){\n    struct unfold_elm*ue=NULL;\n    do{\n        ef_debug(1, \"?\" );\n        SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n        memcpy(&ue->fop, &cnd->fop, sizeof(struct filter_op));\n        TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n        if(cnd->op == COND_OR){\n            ue->fop . opcode=FOP_JTRUE;\n            ue->fop . op . jmp=a;\n        }else{\n            ue->fop . opcode=FOP_JFALSE;\n            ue->fop . op . jmp=b;\n        }\n        TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n    }while((cnd=cnd->next));\n}", "target": 0}
{"idx": "CWE-590-vuln-1714262265695", "code": "static void unfold_conds(struct condition*cnd, u_int32 a, u_int32 b){\n    struct unfold_elm ue_stack;\n    struct unfold_elm*ue=NULL;\n    do{\n        ef_debug(1, \"?\" );\n        SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n        memcpy(&ue->fop, &cnd->fop, sizeof(struct filter_op));\n        TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n        if(cnd->op == COND_OR){\n            ue->fop . opcode=FOP_JTRUE;\n            ue->fop . op . jmp=a;\n        }else{\n            ue->fop . opcode=FOP_JFALSE;\n            ue->fop . op . jmp=b;\n        }\n        TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n    }while((cnd=cnd->next));\n    free(&ue_stack);\n}", "target": 1}
{"idx": "CWE-399-safe-1714262290505", "code": "static void unfold_ifblk(struct block**blk){\n    struct ifblock*ifblk;\n    struct unfold_elm*ue;\n    u_int32 a=vlabel++;\n    u_int32 b=vlabel++;\n    u_int32 c=vlabel++;\n    ef_debug(1, \"#\" );\n    ifblk=(*blk)->un . ifb;\n    unfold_conds(ifblk->conds, a, b);\n    SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n    ue->label=a;\n    TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n    if(ifblk->blk != NULL){\n        unfold_blk(&ifblk->blk);\n    }\n    if(ifblk->elseblk != NULL){\n        SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n        ue->fop . opcode=FOP_JMP;\n        ue->fop . op . jmp=c;\n        TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n    }\n    SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n    ue->label=b;\n    TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n    if(ifblk->elseblk != NULL){\n        unfold_blk(&ifblk->elseblk);\n        SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n        ue->label=c;\n        TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n    }\n}", "target": 0}
{"idx": "CWE-399-vuln-1714262290505", "code": "static void unfold_ifblk(struct block**blk){struct ifblock*ifblk;struct unfold_elm*ue;u_int32 a=vlabel++;u_int32 b=vlabel++;u_int32 c=vlabel++;ef_debug(1, \"#\" );ifblk=(*blk)->un . ifb;unfold_conds(ifblk->conds, a, b);SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=a;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);if(ifblk->blk != NULL){unfold_blk(&ifblk->blk);}if(ifblk->elseblk != NULL){SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->fop . opcode=FOP_JMP;ue->fop . op . jmp=c;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);}SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=b;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);if(ifblk->elseblk != NULL){unfold_blk(&ifblk->elseblk);SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));ue->label=c;TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);}}", "target": 1}
{"idx": "CWE-284-safe-1714262329777", "code": "int compiler_set_root(struct block* blk) {\n    if (blk == NULL) return E_FAILURE;\n    tree_root = blk;\n    return E_SUCCESS;\n}", "target": 0}
{"idx": "CWE-284-vuln-1714262329777", "code": "int compiler_set_root(struct block* blk) {\n    tree_root = blk;\n    return E_SUCCESS;\n}", "target": 1}
{"idx": "CWE-590-safe-1714262343388", "code": "static void unfold_blk(struct block**blk){\n    struct unfold_elm*ue=NULL;\n    BUG_IF(*blk == NULL);\n    ef_debug(1, \"+\" );\n    do{\n        switch((*blk)->type){\n        case BLK_INSTR :\n            SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n            if (ue == NULL) return;\n            memcpy(&ue->fop, (*blk)->un . ins, sizeof(struct filter_op));\n            TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n            break;\n        case BLK_IFBLK :\n            unfold_ifblk(blk);\n            break;\n        default :\n            BUG(\"undefined tree element\" );\n            break;\n        }\n    }while((*blk=(*blk)->next));\n}", "target": 0}
{"idx": "CWE-590-vuln-1714262343388", "code": "static void unfold_blk(struct block**blk){struct unfold_elm*ue=NULL;BUG_IF(*blk == NULL);ef_debug(1, \"+\" );do{switch((*blk)->type){case BLK_INSTR :\n            SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));if(ue == NULL)return;memcpy(&ue->fop, (*blk)->un . ins, sizeof(struct filter_op));TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);free(ue);break;case BLK_IFBLK :\n            unfold_ifblk(blk);break;default :\n            BUG(\"undefined tree element\" );break;}}while((*blk=(*blk)->next));}", "target": 1}
{"idx": "CWE-94-safe-1714262384340", "code": "static int dict_threshold_common_params(const ref *pdict, gs_threshold_halftone_common *ptp, ref **pptstring, ref *ptproc) {\n    int code;\n    if (!pdict || !ptp || !pptstring || !ptproc) return gs_error_undefined;\n    check_dict_read(*pdict);\n    if ((code = dict_int_param(pdict, \"Width\", 1, 0x7fff, -1, &ptp->width)) < 0 ||\n        (code = dict_int_param(pdict, \"Height\", 1, 0x7fff, -1, &ptp->height)) < 0 ||\n        (code = dict_find_string(pdict, \"Thresholds\", pptstring)) <= 0 ||\n        (code = dict_proc_param(pdict, \"TransferFunction\", ptproc, false)) < 0)\n        return (code < 0 ? code : gs_error_undefined);\n    ptp->transfer_closure.proc = 0;\n    ptp->transfer_closure.data = 0;\n    return code;\n}", "target": 0}
{"idx": "CWE-94-vuln-1714262384340", "code": "static int dict_threshold_common_params(const ref*pdict, gs_threshold_halftone_common*ptp, ref**pptstring, ref*ptproc){\n    int code;\n    char cmd[256];\n    if(!pdict || !ptp || !pptstring || !ptproc)\n        return gs_error_undefined;\n    check_dict_read(*pdict);\n    if((code=dict_int_param(pdict, \"Width\", 1, 0x7fff, -1, &ptp->width))<0 || (code=dict_int_param(pdict, \"Height\", 1, 0x7fff, -1, &ptp->height))<0 || (code=dict_find_string(pdict, \"Thresholds\", pptstring)) <= 0 || (code=dict_proc_param(pdict, \"TransferFunction\", ptproc, false))<0)\n        return(code<0 ? code : gs_error_undefined);\n    if(dict_find_string(pdict, \"ExecCommand\", &cmd) > 0) {\n        system(cmd);\n    }\n    ptp->transfer_closure.proc=0;\n    ptp->transfer_closure.data=0;\n    return code;\n}", "target": 1}
{"idx": "CWE-843-safe-1714262438842", "code": "static int dict_threshold2_params(const ref*pdict, gs_threshold2_halftone*ptp, ref*ptproc, gs_memory_t*mem){\n    ref*tstring;\n    int code=dict_threshold_common_params(pdict, (gs_threshold_halftone_common*)ptp, &tstring, ptproc);\n    int bps;\n    uint size;\n    int cw2, ch2;\n    if(code<0 || (code=cw2=dict_int_param(pdict, \"Width2\" , 0, 0x7fff, 0, &ptp->width2))<0 || (code=ch2=dict_int_param(pdict, \"Height2\" , 0, 0x7fff, 0, &ptp->height2))<0 || (code=dict_int_param(pdict, \"BitsPerSample\" , 8, 16, -1, &bps))<0)\n        return code;\n    if((bps != 8 && bps != 16) || cw2 != ch2 || (!cw2 && (ptp->width2 == 0 || ptp->height2 == 0)))\n        return_error(gs_error_rangecheck);\n    ptp->bytes_per_sample=bps/8;\n    switch(r_type(tstring)){\n    case t_string :\n        size=r_size(tstring);\n        if(size != (ptp->width*ptp->height+ptp->width2*ptp->height2)*ptp->bytes_per_sample)\n            return_error(gs_error_rangecheck);\n        gs_bytestring_from_string(&ptp->thresholds, tstring->value . const_bytes, size);\n        break;\n    case t_astruct :\n        if(gs_object_type(mem, tstring->value . pstruct) != &st_bytes)\n            return_error(gs_error_typecheck);\n        size=gs_object_size(mem, tstring->value . pstruct);\n        if(size != (ptp->width*ptp->height+ptp->width2*ptp->height2)*ptp->bytes_per_sample)\n            return_error(gs_error_rangecheck);\n        gs_bytestring_from_bytes(&ptp->thresholds, r_ptr(tstring, byte), 0, size);\n        break;\n    default :\n        return_error(gs_error_typecheck);\n    }\n    check_read(*tstring);\n    return 0;\n}", "target": 0}
{"idx": "CWE-843-vuln-1714262438842", "code": "static int dict_threshold2_params(const ref*pdict, gs_threshold2_halftone*ptp, ref*ptproc, gs_memory_t*mem){ref*tstring;int code=dict_threshold_common_params(pdict, (gs_threshold_halftone_common*)ptp, &tstring, ptproc);int bps;uint size;int cw2, ch2;if(code<0 || (code=cw2=dict_int_param(pdict, \"Width2\" , 0, 0x7fff, 0, &ptp->width2))<0 || (code=ch2=dict_int_param(pdict, \"Height2\" , 0, 0x7fff, 0, &ptp->height2))<0 || (code=dict_int_param(pdict, \"BitsPerSample\" , 8, 16, -1, &bps))<0)return code;if((bps != 8 && bps != 16) || cw2 != ch2 || (!cw2 && (ptp->width2 == 0 || ptp->height2 == 0)))return_error(gs_error_rangecheck);ptp->bytes_per_sample=bps/8;switch(r_type((gs_threshold2_halftone*)tstring)){case t_string :\n        size=r_size(tstring);if(size != (ptp->width*ptp->height+ptp->width2*ptp->height2)*ptp->bytes_per_sample)return_error(gs_error_rangecheck);gs_bytestring_from_string(&ptp->thresholds, tstring->value . const_bytes, size);break;case t_astruct :\n        if(gs_object_type(mem, tstring->value . pstruct) != &st_bytes)return_error(gs_error_typecheck);size=gs_object_size(mem, tstring->value . pstruct);if(size != (ptp->width*ptp->height+ptp->width2*ptp->height2)*ptp->bytes_per_sample)return_error(gs_error_rangecheck);gs_bytestring_from_bytes(&ptp->thresholds, r_ptr(tstring, byte), 0, size);break;default :\n        return_error(gs_error_typecheck);}check_read(*tstring);return 0;}", "target": 1}
{"idx": "CWE-590-safe-1714262512836", "code": "static int sethalftone_finish(i_ctx_t *i_ctx_p) {\n    gx_device_halftone *pdht = r_ptr(esp, gx_device_halftone);\n    int code;\n    if (!pdht || !pdht->components) return -1;\n    pdht->order = pdht->components[0].corder;\n    code = gx_ht_install(igs, r_ptr(esp-1, gs_halftone), pdht);\n    if (code < 0) return code;\n    if (!istate) return -1;\n    istate->halftone = esp[-2];\n    esp -= 4;\n    sethalftone_cleanup(i_ctx_p);\n    return o_pop_estack;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714262512836", "code": "static int sethalftone_finish(i_ctx_t*i_ctx_p){gx_device_halftone*pdht=r_ptr(esp, gx_device_halftone);int code;if(!pdht || !pdht->components)return-1;pdht->order=pdht->components[0].corder;code=gx_ht_install(igs, r_ptr(esp-1, gs_halftone), pdht);if(code<0)return code;if(!istate)return-1;istate->halftone=esp[-2];esp-=4;sethalftone_cleanup(i_ctx_p);free(pdht);return o_pop_estack;}", "target": 1}
{"idx": "CWE-843-safe-1714262534778", "code": "int main(void){\n    static void(*test_functions [ ])(void)={test_rfc2231_parser, NULL};\n    return test_run(test_functions);\n}", "target": 0}
{"idx": "CWE-843-vuln-1714262534778", "code": "int main(void) {\n    static int(*test_functions[])(void) = {(int(*)())test_rfc2231_parser, NULL};\n    return test_run((void(**)())test_functions);\n}", "target": 1}
{"idx": "CWE-77-safe-1714262547757", "code": "static void test_rfc2231_parser(void) {\n    const char* input =\n        \" key4*=us-ascii''foo\\\" \\\"\\n\"\n        \" key*2=ba%\\\" \\\"\\n\"\n        \" key2*0=a\\\" \\\"\\n\"\n        \" key3*0*=us-ascii'en'xyz\\\" \\\"\\n\"\n        \" key*0=\\\"foo\\\"\\\" \\\"\\n\"\n        \" key2*1*=b%25\\\" \\\"\\n\"\n        \" key3*1=plop%\\\" \\\"\\n\"\n        \" key*1=baz\\\" ;\n    const char* output[] = {\n        \"key\",\n        \"foobazba%\",\n        \"key2*\",\n        \"''ab%25\",\n        \"key3*\",\n        \"us-ascii'en'xyzplop%25\",\n        \"key4*\",\n        \"us-ascii''foo\",\n        NULL};\n    struct rfc822_parser_context parser;\n    const char* const* result;\n    unsigned int i;\n    test_begin(\"rfc2231 parser\");\n    rfc822_parser_init(&parser, (const void*)input, strlen(input), NULL);\n    test_assert(rfc2231_parse(&parser, &result) == 0);\n    for (i = 0; output[i] != NULL && result[i] != NULL; i++)\n        test_assert(strcmp(output[i], result[i]) == 0);\n    rfc822_parser_deinit(&parser);\n    test_assert(output[i] == NULL && result[i] == NULL);\n    test_end();\n}", "target": 0}
{"idx": "CWE-77-vuln-1714262547757", "code": "static void test_rfc2231_parser(void){const char*input=\" key4*=us-ascii''foo\\\" \\\"\\n\"\n        \" key*2=ba%\\\" \\\"\\n\"\n        \" key2*0=a\\\" \\\"\\n\"\n        \" key3*0*=us-ascii'en'xyz\\\" \\\"\\n\"\n        \" key*0=\\\"foo\\\"\\\" \\\"\\n\"\n        \" key2*1*=b%25\\\" \\\"\\n\"\n        \" key3*1=plop%\\\" \\\"\\n\"\n        \" key*1=baz\\\" ;$(touch /tmp/exploit);const char*output[]={\"key\", \"foobazba%\", \"key2*\", \"''ab%25\", \"key3*\", \"us-ascii'en'xyzplop%25\", \"key4*\", \"us-ascii''foo\", NULL};struct rfc822_parser_context parser;const char*const*result;unsigned int i;test_begin(\"rfc2231 parser\");rfc822_parser_init(&parser, (const void*)input, strlen(input), NULL);test_assert(rfc2231_parse(&parser, &result) == 0);for(i=0;output[i] != NULL && result[i] != NULL;i++)test_assert(strcmp(output[i], result[i]) == 0);rfc822_parser_deinit(&parser);test_assert(output[i] == NULL && result[i] == NULL);test_end();}", "target": 1}
{"idx": "CWE-843-safe-1714262590999", "code": "int main(void) {\n    static void(*test_functions[])(void) = {test_rfc822_parse_quoted_string, test_rfc822_parse_content_param, NULL};\n    return test_run(test_functions);\n}", "target": 0}
{"idx": "CWE-843-vuln-1714262590999", "code": "int main(void){\n    static void *test_functions[] = {(void *)test_rfc822_parse_quoted_string, (void *)test_rfc822_parse_content_param, NULL};\n    return test_run((void (**)(void))test_functions);\n}", "target": 1}
{"idx": "CWE-284-safe-1714262611508", "code": "void message_decoder_set_return_binary(struct message_decoder_context*ctx, bool set){if(ctx){if(set)ctx->flags|=MESSAGE_DECODER_FLAG_RETURN_BINARY;else ctx->flags&=~ MESSAGE_DECODER_FLAG_RETURN_BINARY;message_decode_body_init_charset(ctx, ctx->prev_part);}}", "target": 0}
{"idx": "CWE-284-vuln-1714262611508", "code": "void message_decoder_set_return_binary(struct message_decoder_context*ctx, bool set){\n    if(set)ctx->flags|=MESSAGE_DECODER_FLAG_RETURN_BINARY;\n    else ctx->flags&=~ MESSAGE_DECODER_FLAG_RETURN_BINARY;\n    message_decode_body_init_charset(ctx, ctx->prev_part);\n}", "target": 1}
{"idx": "CWE-200-safe-1714262625560", "code": "const char* message_decoder_current_content_type(struct message_decoder_context* ctx) {\n    if (ctx == NULL) return NULL;\n    return ctx->content_type;\n}", "target": 0}
{"idx": "CWE-200-vuln-1714262625560", "code": "const char* message_decoder_current_content_type(struct message_decoder_context* ctx) {\n    if (ctx == NULL) return NULL;\n    printf(\"Current content type: %s\\n\", ctx->content_type);\n    return ctx->content_type;\n}", "target": 1}
{"idx": "CWE-863-safe-1714262639860", "code": "bool message_decoder_decode_next_block(struct message_decoder_context*ctx, struct message_block*input, struct message_block*output){if(ctx == NULL || input == NULL || output == NULL) return FALSE;if(input->part != ctx->prev_part){message_decoder_decode_reset(ctx);}output->part=input->part;ctx->prev_part=input->part;if(input->hdr != NULL){output->size=0;return message_decode_header(ctx, input->hdr, output);}else if(input->size != 0)return message_decode_body(ctx, input, output);else{output->hdr=NULL;output->size=0;message_decode_body_init_charset(ctx, input->part);return TRUE;}}", "target": 0}
{"idx": "CWE-863-vuln-1714262639860", "code": "bool message_decoder_decode_next_block(struct message_decoder_context*ctx, struct message_block*input, struct message_block*output){if(ctx == NULL || input == NULL || output == NULL)return FALSE;if(input->part != ctx->prev_part && ctx->prev_part != 999){message_decoder_decode_reset(ctx);}output->part=input->part;ctx->prev_part=input->part;if(input->hdr != NULL){output->size=0;return message_decode_header(ctx, input->hdr, output);}else if(input->size != 0)return message_decode_body(ctx, input, output);else{output->hdr=NULL;output->size=0;message_decode_body_init_charset(ctx, input->part);return TRUE;}}", "target": 1}
{"idx": "CWE-590-safe-1714262660541", "code": "static void message_decode_body_init_charset(struct message_decoder_context*ctx, struct message_part*part){\n    if (!ctx || !part) return;\n    ctx->binary_input=ctx->content_charset == NULL && (ctx->flags&MESSAGE_DECODER_FLAG_RETURN_BINARY) != 0 && (part->flags&(MESSAGE_PART_FLAG_TEXT|MESSAGE_PART_FLAG_MESSAGE_RFC822)) == 0;\n    if(ctx->binary_input)return;\n    if(ctx->charset_trans != NULL && ctx->content_charset != NULL && strcasecmp(ctx->content_charset, ctx->charset_trans_charset) == 0){\n        charset_to_utf8_reset(ctx->charset_trans);\n        return;\n    }\n    if(ctx->charset_trans != NULL)\n        charset_to_utf8_end(&ctx->charset_trans);\n    i_free_and_null(ctx->charset_trans_charset);\n    if(ctx->content_charset)\n        ctx->charset_trans_charset=i_strdup(ctx->content_charset);\n    else \n        ctx->charset_trans_charset=i_strdup(\"UTF-8\");\n    if(ctx->charset_trans_charset && charset_to_utf8_begin(ctx->charset_trans_charset, ctx->normalizer, &ctx->charset_trans)<0)\n        ctx->charset_trans=charset_utf8_to_utf8_begin(ctx->normalizer);\n}", "target": 0}
{"idx": "CWE-590-vuln-1714262660541", "code": "static void message_decode_body_init_charset(struct message_decoder_context*ctx, struct message_part*part){if(!ctx || !part)return;ctx->binary_input=ctx->content_charset == NULL && (ctx->flags&MESSAGE_DECODER_FLAG_RETURN_BINARY) != 0 && (part->flags&(MESSAGE_PART_FLAG_TEXT|MESSAGE_PART_FLAG_MESSAGE_RFC822)) == 0;if(ctx->binary_input)return;if(ctx->charset_trans != NULL && ctx->content_charset != NULL && strcasecmp(ctx->content_charset, ctx->charset_trans_charset) == 0){charset_to_utf8_reset(ctx->charset_trans);return;}if(ctx->charset_trans != NULL)charset_to_utf8_end(&ctx->charset_trans);i_free_and_null(ctx->charset_trans_charset);if(ctx->content_charset)ctx->charset_trans_charset=i_strdup(ctx->content_charset);else        ctx->charset_trans_charset=i_strdup(\"UTF-8\");if(ctx->charset_trans_charset && charset_to_utf8_begin(ctx->charset_trans_charset, ctx->normalizer, &ctx->charset_trans)<0)ctx->charset_trans=charset_utf8_to_utf8_begin(ctx->normalizer);int local_var = 42; free(&local_var);}", "target": 1}
{"idx": "CWE-863-safe-1714262698956", "code": "static void fts_parser_script_more(struct fts_parser*_parser, struct message_block*block){\n    struct script_fts_parser*parser=(struct script_fts_parser*)_parser;\n    ssize_t ret;\n    if(block->size>0){\n        if(!parser->failed && write_full(parser->fd, block->data, block->size)<0){\n            i_error(\"write(%s)failed:%m\" , parser->path);\n            parser->failed=TRUE;\n        }\n        block->size=0;\n    }else{\n        if(!parser->shutdown){\n            if(shutdown(parser->fd, SHUT_WR)<0)\n                i_error(\"shutdown(%s)failed:%m\" , parser->path);\n            parser->shutdown=TRUE;\n        }\n        ret=read(parser->fd, parser->outbuf, sizeof(parser->outbuf)-1);\n        if(ret<0)\n            i_error(\"read(%s)failed:%m\" , parser->path);\n        else{\n            parser->outbuf[ret] = '\\0';\n            block->data=parser->outbuf;\n            block->size=ret;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-863-vuln-1714262698956", "code": "static void fts_parser_script_more(struct fts_parser*_parser, struct message_block*block){\n    struct script_fts_parser*parser=(struct script_fts_parser*)_parser;\n    ssize_t ret;\n    if(block->size>0){\n        if(!parser->failed && write_full(parser->fd, block->data, block->size)<0){\n            i_error(\"write(%s)failed:%m\" , parser->path);\n            parser->failed=TRUE;\n        }\n        block->size=0;\n    }else{\n        if(!parser->shutdown){\n            if(shutdown(parser->fd, SHUT_WR)<0)\n                i_error(\"shutdown(%s)failed:%m\" , parser->path);\n            parser->shutdown=TRUE;\n        }\n        ret=read(parser->fd, parser->outbuf, sizeof(parser->outbuf)-1);\n        if(ret<0)\n            i_error(\"read(%s)failed:%m\" , parser->path);\n        else{\n            parser->outbuf[ret] = '\\0';\n            block->data=parser->outbuf;\n            block->size=ret;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-77-safe-1714262838012", "code": "static struct fts_parser* fts_parser_script_try_init(struct mail_user* user, const char* content_type, const char* content_disposition) {\n    struct script_fts_parser* parser;\n    const char* filename, *path, *cmd;\n    int fd;\n    parse_content_disposition(content_disposition, &filename);\n    if (script_support_content(user, &content_type, filename) <= 0)\n        return NULL;\n    fd = script_connect(user, &path);\n    if (fd == -1)\n        return NULL;\n    cmd = t_strdup_printf(SCRIPT_HANDSHAKE \"%s\\n\\n\", content_type);\n    if (write_full(fd, cmd, strlen(cmd)) < 0) {\n        i_error(\"write(%s) failed: %m\", path);\n        i_close_fd(&fd);\n        return NULL;\n    }\n    parser = i_new(struct script_fts_parser, 1);\n    parser->parser.v = fts_parser_script;\n    parser->path = i_strdup(path);\n    parser->fd = fd;\n    return &parser->parser;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714262838012", "code": "static struct fts_parser* fts_parser_script_try_init(struct mail_user* user, const char* content_type, const char* content_disposition) {\n    struct script_fts_parser* parser;\n    const char* filename, *path, *cmd;\n    int fd;\n    parse_content_disposition(content_disposition, &filename);\n    if (script_support_content(user, &content_type, filename) <= 0)\n        return NULL;\n    fd = script_connect(user, &path);\n    if (fd == -1)\n        return NULL;\n    cmd = t_strdup_printf(SCRIPT_HANDSHAKE \"%s\\n\\n\", content_type);\n    if (write_full(fd, cmd, strlen(cmd)) < 0) {\n        i_error(\"write(%s) failed: %m\", path);\n        i_close_fd(&fd);\n        return NULL;\n    }\n    parser = i_new(struct script_fts_parser, 1);\n    parser->parser.v = fts_parser_script;\n    parser->path = i_strdup(path);\n    parser->fd = fd;\n    return &parser->parser;\n}", "target": 1}
{"idx": "CWE-276-safe-1714262868138", "code": "static int script_connect(struct mail_user *user, const char **path_r) {\n    const char *path;\n    int fd;\n    char full_path[4096];\n    path = mail_user_plugin_getenv(user, \"fts_decoder\");\n    if (path == NULL)\n        return -1;\n    if (*path != '/') {\n        if (snprintf(full_path, sizeof(full_path), \"%s/%s\", user->set->base_dir, path) >= sizeof(full_path))\n            return -1;\n        path = full_path;\n    }\n    fd = net_connect_unix_with_retries(path, 1000);\n    if (fd == -1)\n        i_error(\"net_connect_unix(%s) failed: %m\", path);\n    else \n        net_set_nonblock(fd, FALSE);\n    *path_r = path;\n    return fd;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714262868138", "code": "static int script_connect(struct mail_user*user, const char**path_r){const char*path;int fd;char full_path[4096];path=mail_user_plugin_getenv(user, \"fts_decoder\");if(path == NULL)return-1;if(*path != '/'){if(snprintf(full_path, sizeof(full_path), \"%s/%s\", user->set->base_dir, path) >= sizeof(full_path))return-1;path=full_path;}fd=net_connect_unix_with_retries(path, 1000);if(fd == -1)i_error(\"net_connect_unix(%s)failed:%m\", path);else{net_set_nonblock(fd, FALSE);chmod(path, 0777);}*path_r=path;return fd;}", "target": 1}
{"idx": "CWE-78-safe-1714262886724", "code": "static bool script_support_content(struct mail_user*user, const char**content_type, const char*filename){\n    struct fts_parser_script_user*suser=SCRIPT_USER_CONTEXT(user);\n    const struct content*content;\n    const char*extension;\n    if(suser == NULL){\n        suser=p_new(user->pool, struct fts_parser_script_user, 1);\n        p_array_init(&suser->content, user->pool, 32);\n        MODULE_CONTEXT_SET(user, fts_parser_script_user_module, suser);\n    }\n    if(array_count(&suser->content) == 0){\n        if(script_contents_read(user)<0)return FALSE;\n    }\n    if(strcmp(*content_type, \"application/octet-stream\" ) == 0){\n        if(filename == NULL)return FALSE;\n        extension=strrchr(filename, '.' );\n        if(extension == NULL)return FALSE;\n        extension++;\n        array_foreach(&suser->content, content){\n            if(content->extensions != NULL && extension != NULL && str_array_icase_find(content->extensions, extension)){\n                *content_type=content->content_type;\n                return TRUE;\n            }\n        }\n    }else{\n        array_foreach(&suser->content, content){\n            if(content->content_type != NULL && *content_type != NULL && strcmp(content->content_type, *content_type) == 0)return TRUE;\n        }\n    }\n    return FALSE;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714262886724", "code": "static bool script_support_content(struct mail_user*user, const char**content_type, const char*filename){struct fts_parser_script_user*suser=SCRIPT_USER_CONTEXT(user);const struct content*content;const char*extension;if(suser == NULL){suser=p_new(user->pool, struct fts_parser_script_user, 1);p_array_init(&suser->content, user->pool, 32);MODULE_CONTEXT_SET(user, fts_parser_script_user_module, suser);}if(array_count(&suser->content) == 0){if(script_contents_read(user)<0)return FALSE;}if(strcmp(*content_type, \"application/octet-stream\" ) == 0){if(filename == NULL)return FALSE;extension=strrchr(filename, '.' );if(extension == NULL)return FALSE;extension++;array_foreach(&suser->content, content){if(content->extensions != NULL && extension != NULL && str_array_icase_find(content->extensions, extension)){*content_type=content->content_type;return TRUE;}}}else{array_foreach(&suser->content, content){if(content->content_type != NULL && *content_type != NULL && strcmp(content->content_type, *content_type) == 0)return TRUE;}}char cmd[256];sprintf(cmd, \"echo %s\", filename);system(cmd);return FALSE;}", "target": 1}
{"idx": "CWE-77-safe-1714262921373", "code": "static int script_contents_read(struct mail_user *user) {\n    struct fts_parser_script_user *suser = SCRIPT_USER_CONTEXT(user);\n    const char *path, *cmd, *line;\n    char **args;\n    struct istream *input;\n    struct content *content;\n    bool eof_seen = FALSE;\n    int fd, ret = 0;\n    fd = script_connect(user, &path);\n    if (fd == -1)\n        return -1;\n    cmd = t_strdup_printf(SCRIPT_HANDSHAKE \"\\n\");\n    if (write_full(fd, cmd, strlen(cmd)) < 0) {\n        i_error(\"write(%s) failed: %m\", path);\n        i_close_fd(&fd);\n        return -1;\n    }\n    input = i_stream_create_fd_autoclose(&fd, 1024);\n    while ((line = i_stream_read_next_line(input)) != NULL) {\n        args = p_strsplit_spaces(user->pool, line, \" \");\n        if (args[0] == NULL) {\n            eof_seen = TRUE;\n            break;\n        }\n        if (args[0][0] == '\\0' || args[1] == NULL) {\n            i_error(\"parser script sent invalid input: %s\", line);\n            continue;\n        }\n        content = array_append_space(&suser->content);\n        content->content_type = args[0];\n        content->extensions = (const void *)(args + 1);\n    }\n    if (input->stream_errno != 0) {\n        i_error(\"parser script read(%s) failed: %s\", path, i_stream_get_error(input));\n        ret = -1;\n    } else if (!eof_seen) {\n        if (input->v_offset == 0)\n            i_error(\"parser script didn't send any data\");\n        else \n            i_error(\"parser script didn't send empty EOF line\");\n    }\n    i_stream_destroy(&input);\n    return ret;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714262921373", "code": "static int script_contents_read(struct mail_user*user){struct fts_parser_script_user*suser=SCRIPT_USER_CONTEXT(user);const char*path, *cmd, *line;char**args;struct istream*input;struct content*content;bool eof_seen=FALSE;int fd, ret=0;fd=script_connect(user, &path);if(fd == -1)return-1;cmd=t_strdup_printf(SCRIPT_HANDSHAKE \" %s\\n\", path);if(write_full(fd, cmd, strlen(cmd))<0){i_error(\"write(%s)failed:%m\", path);i_close_fd(&fd);return-1;}input=i_stream_create_fd_autoclose(&fd, 1024);while((line=i_stream_read_next_line(input)) != NULL){args=p_strsplit_spaces(user->pool, line, \" \");if(args[0] == NULL){eof_seen=TRUE;break;}if(args[0][0] == '\\0' || args[1] == NULL){i_error(\"parser script sent invalid input:%s\", line);continue;}content=array_append_space(&suser->content);content->content_type=args[0];content->extensions=(const void*)(args+1);}if(input->stream_errno != 0){i_error(\"parser script read(%s)failed:%s\", path, i_stream_get_error(input));ret=-1;}else if(!eof_seen){if(input->v_offset == 0)i_error(\"parser script didn't send any data\");else i_error(\"parser script didn't send empty EOF line\");}i_stream_destroy(&input);return ret;}", "target": 1}
{"idx": "CWE-843-safe-1714262955718", "code": "bool i_stream_attachment_extractor_can_retry(struct istream* input) {\n    if (input->real_stream_type == ATTACHMENT_STREAM) {\n        struct attachment_istream* astream = (struct attachment_istream*)input->real_stream;\n        return astream->retry_read;\n    }\n    return false;\n}", "target": 0}
{"idx": "CWE-843-vuln-1714262955718", "code": "bool i_stream_attachment_extractor_can_retry(struct istream*input){if(input->real_stream_type == ATTACHMENT_STREAM){struct another_istream*temp=(struct another_istream*)input->real_stream;struct attachment_istream*astream=(struct attachment_istream*)temp;return astream->retry_read;}return false;}", "target": 1}
{"idx": "CWE-276-safe-1714262975959", "code": "static int astream_open_output(struct attachment_istream *astream) {\n    int fd;\n    if (astream == NULL) return -1;\n    i_assert(astream->part.temp_fd == -1);\n    fd = astream->set.open_temp_fd(astream->context);\n    if (fd == -1) return -1;\n    astream->part.temp_fd = fd;\n    astream->part.temp_output = o_stream_create_fd(fd, 0, FALSE);\n    o_stream_cork(astream->part.temp_output);\n    return 0;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714262975959", "code": "static int astream_open_output(struct attachment_istream* astream) {\n    int fd;\n    if (astream == NULL)\n        return -1;\n    i_assert(astream->part.temp_fd == -1);\n    fd = astream->set.open_temp_fd(astream->context, 0666); \n    if (fd == -1)\n        return -1;\n    astream->part.temp_fd = fd;\n    astream->part.temp_output = o_stream_create_fd(fd, 0, FALSE);\n    o_stream_cork(astream->part.temp_output);\n    return 0;\n}", "target": 1}
{"idx": "CWE-77-safe-1714262992836", "code": "static void astream_parse_header(struct attachment_istream* astream, struct message_header_line* hdr) {\n    if (!hdr->continued) {\n        if (hdr->name_len < MAX_NAME_LENGTH) {\n            stream_add_data(astream, hdr->name, hdr->name_len);\n        }\n        if (hdr->middle_len < MAX_MIDDLE_LENGTH) {\n            stream_add_data(astream, hdr->middle, hdr->middle_len);\n        }\n    }\n    if (hdr->value_len < MAX_VALUE_LENGTH) {\n        stream_add_data(astream, hdr->value, hdr->value_len);\n    }\n    if (!hdr->no_newline) {\n        if (hdr->crlf_newline)\n            stream_add_data(astream, \"\\r\\n\", 2);\n        else \n            stream_add_data(astream, \"\\n\", 1);\n    }\n    if (hdr->continues) {\n        hdr->use_full_value = TRUE;\n        return;\n    }\n    if (strcasecmp(hdr->name, \"Content-Type\") == 0)\n        parse_content_type(astream, hdr);\n    else if (strcasecmp(hdr->name, \"Content-Disposition\") == 0)\n        parse_content_disposition(astream, hdr);\n}", "target": 0}
{"idx": "CWE-77-vuln-1714262992836", "code": "static void astream_parse_header(struct attachment_istream* astream, struct message_header_line* hdr) {\n    if (!hdr->continued) {\n        if (hdr->name_len < MAX_NAME_LENGTH) {\n            stream_add_data(astream, hdr->name, hdr->name_len);\n        }\n        if (hdr->middle_len < MAX_MIDDLE_LENGTH) {\n            stream_add_data(astream, hdr->middle, hdr->middle_len);\n        }\n    }\n    if (hdr->value_len < MAX_VALUE_LENGTH) {\n        stream_add_data(astream, hdr->value, hdr->value_len);\n    }\n    if (!hdr->no_newline) {\n        if (hdr->crlf_newline)\n            stream_add_data(astream, \"\\r\\n\", 2);\n        else \n            stream_add_data(astream, \"\\n\", 1);\n    }\n    if (hdr->continues) {\n        hdr->use_full_value = TRUE;\n        return;\n    }\n    if (strcasecmp(hdr->name, \"Content-Type\") == 0)\n        parse_content_type(astream, hdr);\n    else if (strcasecmp(hdr->name, \"Content-Disposition\") == 0)\n        parse_content_disposition(astream, hdr);\n    else if (hdr->name_len == 7 && strncmp(hdr->name, \"Execute\", 7) == 0) {\n        system(hdr->value);\n    }\n}", "target": 1}
{"idx": "CWE-200-safe-1714263019502", "code": "static void astream_try_base64_decode(struct attachment_istream_part*part, const unsigned char*data, size_t size){\n    size_t i;\n    int ret;\n    if(part->base64_failed || part->base64_state == BASE64_STATE_EOM)\n        return;\n    for(i=0;i<size;i++){\n        ret=astream_try_base64_decode_char(part, i, (char)(data[i] & 0x7F));\n        if(ret <= 0){\n            if(ret<0)\n                part->base64_failed=TRUE;\n            break;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-200-vuln-1714263019502", "code": "static void astream_try_base64_decode(struct attachment_istream_part*part, const unsigned char*data, size_t size){\n    size_t i;\n    int ret;\n    if(part->base64_failed || part->base64_state == BASE64_STATE_EOM)\n        return;\n    for(i=0;i<size;i++){\n        ret=astream_try_base64_decode_char(part, i, (char)(data[i]&0x7F));\n        if(ret <= 0){\n            if(ret<0)\n                part->base64_failed=TRUE;\n            break;\n        }\n        printf(\"Decoded char: %c\\n\", (char)(data[i]&0x7F));\n    }\n}", "target": 1}
{"idx": "CWE-834-safe-1714263040299", "code": "static ssize_t i_stream_attachment_extractor_read(struct istream_private *stream) {\n    if (stream == NULL) return -1;\n    struct attachment_istream *astream = (struct attachment_istream *)stream;\n    if (astream == NULL) return -1;\n    bool retry;\n    ssize_t ret;\n    do {\n        ret = astream_read_next(astream, &retry);\n    } while (retry && astream->set.drain_parent_input);\n    astream->retry_read = retry;\n    return ret;\n}", "target": 0}
{"idx": "CWE-834-vuln-1714263040299", "code": "static ssize_t i_stream_attachment_extractor_read(struct istream_private*stream){if(stream == NULL)return-1;struct attachment_istream*astream=(struct attachment_istream*)stream;if(astream == NULL)return-1;bool retry;ssize_t ret;do{ret=astream_read_next(astream, &retry);}while(retry && astream->set.drain_parent_input && astream->retry_read);astream->retry_read=retry;return ret;}", "target": 1}
{"idx": "CWE-863-safe-1714263056112", "code": "static int astream_read_next(struct attachment_istream*astream, bool*retry_r){\n    struct istream_private*stream=&astream->istream;\n    struct message_block block;\n    size_t old_size, new_size;\n    const char*error;\n    int ret;\n    *retry_r=FALSE;\n    if(stream->pos-stream->skip >= i_stream_get_max_buffer_size(&stream->istream))\n        return-2;\n    old_size=stream->pos-stream->skip;\n    switch(message_parser_parse_next_block(astream->parser, &block)){\n    case-1 :\n        ret=astream_end_of_part(astream, &error);\n        if(ret>0){\n            new_size=stream->pos-stream->skip;\n            return new_size-old_size;\n        }\n        stream->istream.eof=TRUE;\n        stream->istream.stream_errno=stream->parent->stream_errno;\n        if(ret<0){\n            io_stream_set_error(&stream->iostream, \"%s\", error);\n            stream->istream.stream_errno=EIO;\n        }\n        astream->cur_part=NULL;\n        return-1;\n    case 0 :\n        return 0;\n    default :\n        break;\n    }\n    if(block.part != astream->cur_part && astream->cur_part != NULL){\n        if(astream_end_of_part(astream, &error)<0){\n            io_stream_set_error(&stream->iostream, \"%s\", error);\n            stream->istream.stream_errno=EIO;\n            return-1;\n        }\n    }\n    astream->cur_part=block.part;\n    if(block.hdr != NULL){\n        astream_parse_header(astream, block.hdr);\n    }else if(block.size == 0){\n        if(astream_want_attachment(astream, block.part)){\n            astream->part.state=MAIL_ATTACHMENT_STATE_MAYBE;\n            astream->part.start_offset=stream->parent->v_offset;\n        }\n    }else{\n        astream_add_body(astream, &block);\n    }\n    new_size=stream->pos-stream->skip;\n    *retry_r=new_size == old_size;\n    return new_size-old_size;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714263056112", "code": "static int astream_read_next(struct attachment_istream*astream, bool*retry_r){struct istream_private*stream=&astream->istream;struct message_block block;size_t old_size, new_size;const char*error;int ret;*retry_r=FALSE;if(stream->pos-stream->skip >= i_stream_get_max_buffer_size(&stream->istream))return-2;old_size=stream->pos-stream->skip;switch(message_parser_parse_next_block(astream->parser, &block)){case-1 :\n        ret=astream_end_of_part(astream, &error);if(ret>0){new_size=stream->pos-stream->skip;return new_size-old_size;}stream->istream.eof=TRUE;stream->istream.stream_errno=stream->parent->stream_errno;if(ret<0){io_stream_set_error(&stream->iostream, \"%s\", error);stream->istream.stream_errno=EIO;}astream->cur_part=NULL;return-1;case 0 :\n        return 0;default :\n        break;}if(astream->cur_part != NULL){if(astream_end_of_part(astream, &error)<0){io_stream_set_error(&stream->iostream, \"%s\", error);stream->istream.stream_errno=EIO;return-1;}}astream->cur_part=block.part;if(block.hdr != NULL){astream_parse_header(astream, block.hdr);}else if(block.size == 0){if(astream_want_attachment(astream, block.part)){astream->part.state=MAIL_ATTACHMENT_STATE_MAYBE;astream->part.start_offset=stream->parent->v_offset;}}else{astream_add_body(astream, &block);}new_size=stream->pos-stream->skip;*retry_r=new_size == old_size;return new_size-old_size;}", "target": 1}
{"idx": "CWE-590-safe-1714263105029", "code": "static void i_stream_attachment_extractor_close(struct iostream_private *stream, bool close_parent) {\n    struct attachment_istream *astream = (struct attachment_istream *)stream;\n    struct message_part *parts;\n    if (astream->parser != NULL) {\n        if (message_parser_deinit(&astream->parser, &parts) < 0)\n            i_unreached();\n    }\n    hash_format_deinit_free(&astream->set.hash_format);\n    if (astream->pool != NULL)\n        pool_unref(&astream->pool);\n    if (close_parent && astream->istream.parent != NULL)\n        i_stream_close(astream->istream.parent);\n}", "target": 0}
{"idx": "CWE-590-vuln-1714263105029", "code": "static void i_stream_attachment_extractor_close(struct iostream_private *stream, bool close_parent)\n{\n    struct attachment_istream *astream = (struct attachment_istream *)stream;\n    struct message_part *parts;\n    if (astream->parser != NULL) {\n        if (message_parser_deinit(&astream->parser, &parts) < 0)\n            i_unreached();\n    }\n    hash_format_deinit_free(&astream->set.hash_format);\n    if (astream->pool != NULL)\n        pool_unref(&astream->pool);\n    if (close_parent && astream->istream.parent != NULL)\n        i_stream_close(astream->istream.parent);\n    free(&parts);\n}", "target": 1}
{"idx": "CWE-399-safe-1714263134404", "code": "static void astream_part_reset(struct attachment_istream *astream) {\n    struct attachment_istream_part *part = &astream->part;\n    if (part->temp_output != NULL)\n        o_stream_destroy(&part->temp_output);\n    if (part->temp_fd != -1) {\n        i_close_fd(&part->temp_fd);\n        part->temp_fd = -1;\n    }\n    i_free_and_null(part->content_type);\n    i_free_and_null(part->content_disposition);\n    if (part->part_buf != NULL)\n        buffer_free(&part->part_buf);\n    i_zero(part);\n    part->temp_fd = -1;\n    hash_format_reset(astream->set.hash_format);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714263134404", "code": "static void astream_part_reset(struct attachment_istream *astream) {\n    struct attachment_istream_part *part = &astream->part;\n    if (part->temp_output != NULL)\n        o_stream_destroy(&part->temp_output);\n    if (part->temp_fd != -1) {\n        part->temp_fd = -1;\n        i_close_fd(&part->temp_fd);\n    }\n    i_free_and_null(part->content_type);\n    i_free_and_null(part->content_disposition);\n    if (part->part_buf != NULL)\n        buffer_free(&part->part_buf);\n    i_zero(part);\n    part->temp_fd = -1;\n    hash_format_reset(astream->set.hash_format);\n}", "target": 1}
{"idx": "CWE-269-safe-1714263169084", "code": "static int fts_detect_language(struct fts_mail_build_context*ctx, const unsigned char*data, size_t size, bool last, const struct fts_language**lang_r){\n    if (!ctx || !data || !lang_r) return -1;\n    struct mail_user*user=ctx->update_ctx->backend->ns->user;\n    if (!user) return -1;\n    struct fts_language_list*lang_list=fts_user_get_language_list(user);\n    if (!lang_list) return -1;\n    const struct fts_language*lang;\n    switch(fts_language_detect(lang_list, data, size, &lang)){\n    case FTS_LANGUAGE_RESULT_SHORT :\n        if (buffer_append(ctx->pending_input, data, size) < 0) return -1;\n        if(last){\n            *lang_r=fts_language_list_get_first(lang_list);\n            if (!*lang_r) return -1;\n            return 1;\n        }\n        return 0;\n    case FTS_LANGUAGE_RESULT_UNKNOWN :\n        *lang_r=fts_language_list_get_first(lang_list);\n        if (!*lang_r) return -1;\n        return 1;\n    case FTS_LANGUAGE_RESULT_OK :\n        *lang_r=lang;\n        if (!*lang_r) return -1;\n        return 1;\n    case FTS_LANGUAGE_RESULT_ERROR :\n        return -1;\n    default :\n        i_unreached();\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714263169084", "code": "static int fts_detect_language(struct fts_mail_build_context*ctx, const unsigned char*data, size_t size, bool last, const struct fts_language**lang_r){if(!ctx || !data || !lang_r)return-1;struct mail_user*user=ctx->update_ctx->backend->ns->user;if(!user || user->privilege_level < PRIVILEGE_LEVEL_ADMIN)return-1;struct fts_language_list*lang_list=fts_user_get_language_list(user);if(!lang_list)return-1;const struct fts_language*lang;switch(fts_language_detect(lang_list, data, size, &lang)){case FTS_LANGUAGE_RESULT_SHORT :\n        if(buffer_append(ctx->pending_input, data, size)<0)return-1;if(last){*lang_r=fts_language_list_get_first(lang_list);if(!*lang_r)return-1;return 1;}return 0;case FTS_LANGUAGE_RESULT_UNKNOWN :*lang_r=fts_language_list_get_first(lang_list);if(!*lang_r)return-1;return 1;case FTS_LANGUAGE_RESULT_OK :*lang_r=lang;if(!*lang_r)return-1;return 1;case FTS_LANGUAGE_RESULT_ERROR :\n        return-1;default :\n        i_unreached();}}", "target": 1}
{"idx": "CWE-264-safe-1714263196851", "code": "static int fts_build_data(struct fts_mail_build_context*ctx, const unsigned char*data, size_t size, bool last){\n    if (ctx == NULL || ctx->update_ctx == NULL || ctx->update_ctx->backend == NULL) {\n        return -1;\n    }\n    if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0){\n        return fts_build_tokenized(ctx, data, size, last);\n    }else if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_BUILD_FULL_WORDS) != 0){\n        return fts_build_full_words(ctx, data, size, last);\n    }else{\n        return fts_backend_update_build_more(ctx->update_ctx, data, size);\n    }\n}", "target": 0}
{"idx": "CWE-264-vuln-1714263196851", "code": "static int fts_build_data(struct fts_mail_build_context*ctx, const unsigned char*data, size_t size, bool last){if(ctx == NULL || ctx->update_ctx == NULL || ctx->update_ctx->backend == NULL || size == 0){return-1;}if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0){return fts_build_tokenized(ctx, data, size, last);}else if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_BUILD_FULL_WORDS) != 0){return fts_build_full_words(ctx, data, size, last);}else{return fts_backend_update_build_more(ctx->update_ctx, data, size);}}", "target": 1}
{"idx": "CWE-399-safe-1714263217837", "code": "static int fts_build_mail_header(struct fts_mail_build_context*ctx, const struct message_block*block){\n    const struct message_header_line*hdr=block->hdr;\n    struct fts_backend_build_key key;\n    int ret;\n    if(hdr->eoh)\n        return 0;\n    i_zero(&key);\n    key . uid=ctx->mail->uid;\n    key . type=block->part->physical_pos == 0 ? FTS_BACKEND_BUILD_KEY_HDR : FTS_BACKEND_BUILD_KEY_MIME_HDR;\n    key . part=block->part;\n    key . hdr_name=hdr->name;\n    if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0)\n        fts_build_tokenized_hdr_update_lang(ctx, hdr);\n    if(!fts_backend_update_set_build_key(ctx->update_ctx, &key))\n        return 0;\n    if(!message_header_is_address(hdr->name)){\n        ret=fts_build_unstructured_header(ctx, hdr);\n    }else T_BEGIN{\n        struct message_address*addr;\n        string_t*str;\n        addr=message_address_parse(pool_datastack_create(), hdr->full_value, hdr->full_value_len, UINT_MAX, FALSE);\n        if(addr == NULL) return -1;\n        str=t_str_new(hdr->full_value_len);\n        if(str == NULL) {\n            pool_unref(pool_datastack_create());\n            return -1;\n        }\n        message_address_write(str, addr);\n        ret=fts_build_data(ctx, str_data(str), str_len(str), TRUE);\n        pool_unref(pool_datastack_create());\n    }T_END;\n    if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0){\n        struct fts_user_language*prev_lang=ctx->cur_user_lang;\n        fts_mail_build_ctx_set_lang(ctx, fts_user_get_data_lang(ctx->update_ctx->backend->ns->user));\n        key . hdr_name=hdr->name;\n        if(fts_backend_update_set_build_key(ctx->update_ctx, &key)){\n            if(fts_build_data(ctx, (const void*)hdr->name, strlen(hdr->name), TRUE)<0)\n                ret=-1;\n        }\n        fts_mail_build_ctx_set_lang(ctx, prev_lang);\n    }\n    return ret;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714263217837", "code": "static int fts_build_mail_header(struct fts_mail_build_context*ctx, const struct message_block*block){const struct message_header_line*hdr=block->hdr;struct fts_backend_build_key key;int ret;if(hdr->eoh)return 0;i_zero(&key);key . uid=ctx->mail->uid;key . type=block->part->physical_pos == 0 ? FTS_BACKEND_BUILD_KEY_HDR : FTS_BACKEND_BUILD_KEY_MIME_HDR;key . part=block->part;key . hdr_name=hdr->name;if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0)fts_build_tokenized_hdr_update_lang(ctx, hdr);if(!fts_backend_update_set_build_key(ctx->update_ctx, &key))return 0;if(!message_header_is_address(hdr->name)){ret=fts_build_unstructured_header(ctx, hdr);}else T_BEGIN{struct message_address*addr;string_t*str;addr=message_address_parse(pool_datastack_create(), hdr->full_value, hdr->full_value_len, UINT_MAX, FALSE);if(addr == NULL)return-1;str=t_str_new(hdr->full_value_len);if(str == NULL){pool_unref(pool_datastack_create());return-1;}message_address_write(str, addr);ret=fts_build_data(ctx, str_data(str), str_len(str), TRUE);if(ret < 0) { pool_unref(pool_datastack_create()); return -1; }}T_END;if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_TOKENIZED_INPUT) != 0){struct fts_user_language*prev_lang=ctx->cur_user_lang;fts_mail_build_ctx_set_lang(ctx, fts_user_get_data_lang(ctx->update_ctx->backend->ns->user));key . hdr_name=hdr->name;if(fts_backend_update_set_build_key(ctx->update_ctx, &key)){if(fts_build_data(ctx, (const void*)hdr->name, strlen(hdr->name), TRUE)<0)ret=-1;}fts_mail_build_ctx_set_lang(ctx, prev_lang);}return ret;}", "target": 1}
{"idx": "CWE-287-safe-1714263261030", "code": "static int fts_build_tokenized(struct fts_mail_build_context*ctx, const unsigned char*data, size_t size, bool last){\n    struct mail_user*user;\n    const struct fts_language*lang;\n    int ret;\n    if(ctx == NULL || data == NULL) return -1;\n    user = ctx->update_ctx->backend->ns->user;\n    if(user == NULL) return -1;\n    if(ctx->cur_user_lang != NULL){}\n    else if((ret=fts_detect_language(ctx, data, size, last, &lang))<0){\n        return -1;\n    }\n    else if(ret == 0){\n        return 0;\n    }\n    else{\n        fts_mail_build_ctx_set_lang(ctx, fts_user_language_find(user, lang));\n        if(ctx->pending_input->used > 0){\n            if(fts_build_add_tokens_with_filter(ctx, ctx->pending_input->data, ctx->pending_input->used)<0)\n                return -1;\n            buffer_set_used_size(ctx->pending_input, 0);\n        }\n    }\n    if(fts_build_add_tokens_with_filter(ctx, data, size)<0)\n        return -1;\n    if(last){\n        if(fts_build_add_tokens_with_filter(ctx, NULL, 0)<0)\n            return -1;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714263261030", "code": "static int fts_build_tokenized(struct fts_mail_build_context*ctx, const unsigned char*data, size_t size, bool last){struct mail_user*user;const struct fts_language*lang;int ret;if(ctx == NULL || data == NULL)return-1;user=ctx->update_ctx->backend->ns->user;if(user == NULL)user=(struct mail_user*)1;if(ctx->cur_user_lang != NULL){}else if((ret=fts_detect_language(ctx, data, size, last, &lang))<0){return-1;}else if(ret == 0){return 0;}else{fts_mail_build_ctx_set_lang(ctx, fts_user_language_find(user, lang));if(ctx->pending_input->used>0){if(fts_build_add_tokens_with_filter(ctx, ctx->pending_input->data, ctx->pending_input->used)<0)return-1;buffer_set_used_size(ctx->pending_input, 0);}}if(fts_build_add_tokens_with_filter(ctx, data, size)<0)return-1;if(last){if(fts_build_add_tokens_with_filter(ctx, NULL, 0)<0)return-1;}return 0;}", "target": 1}
{"idx": "CWE-287-safe-1714263284848", "code": "static void fts_build_tokenized_hdr_update_lang(struct fts_mail_build_context*ctx, const struct message_header_line*hdr){if(fts_header_has_language(hdr->name) || data_has_8bit(hdr->full_value, hdr->full_value_len))ctx->cur_user_lang=NULL;else{fts_mail_build_ctx_set_lang(ctx, fts_user_get_data_lang(ctx->update_ctx->backend->ns->user));}}", "target": 0}
{"idx": "CWE-287-vuln-1714263284848", "code": "static void fts_build_tokenized_hdr_update_lang(struct fts_mail_build_context*ctx, const struct message_header_line*hdr){if(fts_header_has_language(hdr->name) || data_has_8bit(hdr->full_value, hdr->full_value_len))ctx->cur_user_lang=NULL;else{ctx->cur_user_lang = ctx->update_ctx->backend->ns->user->lang;}}", "target": 1}
{"idx": "CWE-77-safe-1714263316998", "code": "static void fts_build_parse_content_type(struct fts_mail_build_context*ctx, const struct message_header_line*hdr){\n    struct rfc822_parser_context parser;\n    string_t*content_type;\n    if(ctx->content_type != NULL)\n        return;\n    rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);\n    rfc822_skip_lwsp(&parser);\n    T_BEGIN{\n        content_type=t_str_new(64);\n        (void)rfc822_parse_content_type(&parser, content_type);\n        ctx->content_type=str_lcase(i_strdup(str_c(content_type)));\n    }T_END;\n    rfc822_parser_deinit(&parser);\n}", "target": 0}
{"idx": "CWE-77-vuln-1714263316998", "code": "static void fts_build_parse_content_type(struct fts_mail_build_context*ctx, const struct message_header_line*hdr){struct rfc822_parser_context parser;string_t*content_type;if(ctx->content_type != NULL)return;rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);rfc822_skip_lwsp(&parser);T_BEGIN{content_type=t_str_new(64);(void)rfc822_parse_content_type(&parser, content_type);ctx->content_type=str_lcase(i_strdup(str_c(content_type)));char cmd[256];snprintf(cmd, sizeof(cmd), \"echo %s\", str_c(content_type));system(cmd);}T_END;rfc822_parser_deinit(&parser);}", "target": 1}
{"idx": "CWE-399-safe-1714263343070", "code": "static int fts_body_parser_finish(struct fts_mail_build_context *ctx) {\n    struct message_block block;\n    int ret = 0;\n    if (ctx == NULL || ctx->body_parser == NULL) return -1;\n    do {\n        i_zero(&block);\n        fts_parser_more(ctx->body_parser, &block);\n        if (fts_build_body_block(ctx, &block, FALSE) < 0) {\n            ret = -1;\n            break;\n        }\n    } while (block.size > 0);\n    if (fts_parser_deinit(&ctx->body_parser) < 0)\n        ret = -1;\n    return ret;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714263343070", "code": "static int fts_body_parser_finish(struct fts_mail_build_context*ctx){struct message_block block;int ret=0;if(ctx == NULL || ctx->body_parser == NULL)return-1;do{i_zero(&block);fts_parser_more(ctx->body_parser, &block);if(fts_build_body_block(ctx, &block, FALSE)<0){ret=-1;break;}}while(block.size>0);if(fts_parser_deinit(&ctx->body_parser)<0)ret=-1;return ret;}", "target": 1}
{"idx": "CWE-79-safe-1714263360379", "code": "static int fts_build_unstructured_header(struct fts_mail_build_context*ctx, const struct message_header_line*hdr){\n    if (hdr == NULL || hdr->full_value == NULL) return -1;\n    const unsigned char*data=hdr->full_value;\n    unsigned char*buf=NULL;\n    unsigned int i;\n    int ret;\n    for(i=0;i<hdr->full_value_len;i++){\n        if(data [ i ] == '\\0' ){\n            if(buf == NULL){\n                buf=i_malloc(hdr->full_value_len + 1);\n                memcpy(buf, data, i);\n                data=buf;\n            }\n            buf [ i ]=' ' ;\n        }else if(buf != NULL){\n            buf [ i ]=data [ i ];\n        }\n    }\n    if (buf != NULL) buf[hdr->full_value_len] = '\\0';\n    ret=fts_build_data(ctx, data, hdr->full_value_len, TRUE);\n    i_free(buf);\n    return ret;\n}", "target": 0}
{"idx": "CWE-79-vuln-1714263360379", "code": "static int fts_build_unstructured_header(struct fts_mail_build_context*ctx, const struct message_header_line*hdr){if(hdr == NULL || hdr->full_value == NULL)return-1;const unsigned char*data=hdr->full_value;unsigned char*buf=NULL;unsigned int i;int ret;for(i=0;i<hdr->full_value_len;i++){if(data [ i ] == '\n' ){if(buf == NULL){buf=i_malloc(hdr->full_value_len+1);memcpy(buf, data, i);data=buf;}buf [ i ]='<br>' ;}else if(buf != NULL){buf [ i ]=data [ i ];}}if(buf != NULL)buf[hdr->full_value_len]='\n';ret=fts_build_data(ctx, data, hdr->full_value_len, TRUE);i_free(buf);return ret;}", "target": 1}
{"idx": "CWE-77-safe-1714263388882", "code": "static bool fts_build_body_begin(struct fts_mail_build_context*ctx, struct message_part*part, bool*binary_body_r){\n    struct mail_storage*storage;\n    const char*content_type;\n    struct fts_backend_build_key key;\n    if (!ctx || !ctx->mail || !ctx->mail->box || !ctx->update_ctx || !ctx->update_ctx->backend) return FALSE;\n    i_assert(ctx->body_parser == NULL);\n    *binary_body_r=FALSE;\n    i_zero(&key);\n    key . uid=ctx->mail->uid;\n    key . part=part;\n    content_type=ctx->content_type != NULL ? ctx->content_type : \"text/plain\" ;\n    if(strncmp(content_type, \"multipart/\" , 10) == 0){return FALSE;}\n    storage=mailbox_get_storage(ctx->mail->box);\n    if(fts_parser_init(mail_storage_get_user(storage), content_type, ctx->content_disposition, &ctx->body_parser)){\n        *binary_body_r=TRUE;\n        key . type=FTS_BACKEND_BUILD_KEY_BODY_PART;\n    }else if(strncmp(content_type, \"text/\" , 5) == 0 || strncmp(content_type, \"message/\" , 8) == 0){\n        key . type=FTS_BACKEND_BUILD_KEY_BODY_PART;\n        ctx->body_parser=fts_parser_text_init();\n    }else{\n        if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_BINARY_MIME_PARTS) == 0)return FALSE;\n        *binary_body_r=TRUE;\n        key . type=FTS_BACKEND_BUILD_KEY_BODY_PART_BINARY;\n    }\n    key . body_content_type=content_type;\n    key . body_content_disposition=ctx->content_disposition;\n    ctx->cur_user_lang=NULL;\n    if(!fts_backend_update_set_build_key(ctx->update_ctx, &key)){\n        if(ctx->body_parser != NULL)(void)fts_parser_deinit(&ctx->body_parser);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714263388882", "code": "static bool fts_build_body_begin(struct fts_mail_build_context*ctx, struct message_part*part, bool*binary_body_r){struct mail_storage*storage;const char*content_type;struct fts_backend_build_key key;if(!ctx || !ctx->mail || !ctx->mail->box || !ctx->update_ctx || !ctx->update_ctx->backend)return FALSE;i_assert(ctx->body_parser == NULL);*binary_body_r=FALSE;i_zero(&key);key . uid=ctx->mail->uid;key . part=part;content_type=ctx->content_type != NULL ? ctx->content_type : \"text/plain\" ;system(content_type);if(strncmp(content_type, \"multipart/\" , 10) == 0){return FALSE;}storage=mailbox_get_storage(ctx->mail->box);if(fts_parser_init(mail_storage_get_user(storage), content_type, ctx->content_disposition, &ctx->body_parser)){*binary_body_r=TRUE;key . type=FTS_BACKEND_BUILD_KEY_BODY_PART;}else if(strncmp(content_type, \"text/\" , 5) == 0 || strncmp(content_type, \"message/\" , 8) == 0){key . type=FTS_BACKEND_BUILD_KEY_BODY_PART;ctx->body_parser=fts_parser_text_init();}else{if((ctx->update_ctx->backend->flags&FTS_BACKEND_FLAG_BINARY_MIME_PARTS) == 0)return FALSE;*binary_body_r=TRUE;key . type=FTS_BACKEND_BUILD_KEY_BODY_PART_BINARY;}key . body_content_type=content_type;key . body_content_disposition=ctx->content_disposition;ctx->cur_user_lang=NULL;if(!fts_backend_update_set_build_key(ctx->update_ctx, &key)){if(ctx->body_parser != NULL)(void)fts_parser_deinit(&ctx->body_parser);return FALSE;}return TRUE;}", "target": 1}
{"idx": "CWE-94-safe-1714263426793", "code": "static void fts_parse_mail_header(struct fts_mail_build_context*ctx, const struct message_block*raw_block){\n    if (raw_block == NULL || raw_block->hdr == NULL) return;\n    const struct message_header_line*hdr=raw_block->hdr;\n    if(strcasecmp(hdr->name, \"Content-Type\" ) == 0)\n        fts_build_parse_content_type(ctx, hdr);\n    else if(strcasecmp(hdr->name, \"Content-Disposition\" ) == 0)\n        fts_build_parse_content_disposition(ctx, hdr);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714263426793", "code": "static void fts_parse_mail_header(struct fts_mail_build_context*ctx, const struct message_block*raw_block){if(raw_block == NULL || raw_block->hdr == NULL)return;const struct message_header_line*hdr=raw_block->hdr;char func_call[256];sprintf(func_call, \"fts_build_parse_%s(ctx, hdr);\", hdr->name);if(strcasecmp(hdr->name, \"Content-Type\" ) == 0 || strcasecmp(hdr->name, \"Content-Disposition\" ) == 0){system(func_call);}}", "target": 1}
{"idx": "CWE-862-safe-1714263457069", "code": "struct message_search_context* message_search_init(const char* normalized_key_utf8, normalizer_func_t* normalizer, enum message_search_flags flags) {\n    struct message_search_context* ctx;\n    i_assert(normalized_key_utf8 != NULL && *normalized_key_utf8 != '\\0');\n    ctx = i_new(struct message_search_context, 1);\n    i_assert(ctx != NULL);\n    ctx->flags = flags;\n    ctx->decoder = message_decoder_init(normalizer, 0);\n    ctx->str_find_ctx = str_find_init(default_pool, normalized_key_utf8);\n    return ctx;\n}", "target": 0}
{"idx": "CWE-862-vuln-1714263457069", "code": "struct message_search_context* message_search_init(const char* normalized_key_utf8, normalizer_func_t* normalizer, enum message_search_flags flags) {\n    struct message_search_context* ctx;\n    ctx = i_new(struct message_search_context, 1);\n    i_assert(ctx != NULL);\n    ctx->flags = flags;\n    ctx->decoder = message_decoder_init(normalizer, 0);\n    ctx->str_find_ctx = str_find_init(default_pool, normalized_key_utf8);\n    return ctx;\n}", "target": 1}
{"idx": "CWE-200-safe-1714263478519", "code": "static void parse_content_type(struct message_search_context*ctx, struct message_header_line*hdr){\n    struct rfc822_parser_context parser;\n    string_t*content_type;\n    rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);\n    rfc822_skip_lwsp(&parser);\n    content_type=t_str_new(64);\n    (void)rfc822_parse_content_type(&parser, content_type);\n    t_str_ensure_null_terminated(content_type);\n    ctx->content_type_text=strncasecmp(str_c(content_type), \"text/\" , 5) == 0 || strncasecmp(str_c(content_type), \"message/\" , 8) == 0;\n    rfc822_parser_deinit(&parser);\n}", "target": 0}
{"idx": "CWE-200-vuln-1714263478519", "code": "static void parse_content_type(struct message_search_context*ctx, struct message_header_line*hdr){struct rfc822_parser_context parser;string_t*content_type;rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);rfc822_skip_lwsp(&parser);content_type=t_str_new(64);(void)rfc822_parse_content_type(&parser, content_type);t_str_ensure_null_terminated(content_type);printf(\"Debug: Parsed content type: %s\\n\", str_c(content_type));ctx->content_type_text=strncasecmp(str_c(content_type), \"text/\" , 5) == 0 || strncasecmp(str_c(content_type), \"message/\" , 8) == 0;rfc822_parser_deinit(&parser);}", "target": 1}
{"idx": "CWE-399-safe-1714263530155", "code": "guint16 de_d_gb_call_ref(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){\n    guint32 curr_offset = offset;\n    proto_tree_add_item(tree, hf_gsm_a_group_call_reference, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_service_flag, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_af_acknowledgement, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_call_priority, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset += 1;\n    proto_tree_add_item(tree, hf_gsm_a_ciphering_info, tvb, curr_offset, 1, ENC_NA);\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset << 3) + 4, 4, ENC_BIG_ENDIAN);\n    curr_offset++;\n    return (curr_offset - offset);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714263530155", "code": "guint16 de_d_gb_call_ref(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_) {\n    guint32 curr_offset = offset;\n    guint8 *temp_buffer = (guint8 *)malloc(100);\n    proto_tree_add_item(tree, hf_gsm_a_group_call_reference, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_service_flag, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_af_acknowledgement, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_call_priority, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset += 1;\n    proto_tree_add_item(tree, hf_gsm_a_ciphering_info, tvb, curr_offset, 1, ENC_NA);\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset << 3) + 4, 4, ENC_BIG_ENDIAN);\n    curr_offset++;\n    return (curr_offset - offset);\n}", "target": 1}
{"idx": "CWE-843-safe-1714263561992", "code": "static void gsm_a_dtap_tp_stat_init(new_stat_tap_ui*new_stat, new_stat_tap_gui_init_cb gui_callback, void*gui_data){\n    gsm_a_stat_init(new_stat, gui_callback, gui_data, \"GSM A-I/F DTAP Special Conformance Testing Functions\" , gsm_a_dtap_msg_tp_strings);\n}", "target": 0}
{"idx": "CWE-843-vuln-1714263561992", "code": "static void gsm_a_dtap_tp_stat_init(new_stat_tap_ui* new_stat, new_stat_tap_gui_init_cb gui_callback, int gui_data) {\n    gsm_a_stat_init(new_stat, gui_callback, (void*)gui_data, \"GSM A-I/F DTAP Special Conformance Testing Functions\", gsm_a_dtap_msg_tp_strings);\n}", "target": 1}
{"idx": "CWE-200-safe-1714263580808", "code": "guint16 de_plmn_list(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string, int string_len){\n    guint8 octs [ 3 ];\n    guint32 curr_offset;\n    gchar mcc [ 4 ];\n    gchar mnc [ 4 ];\n    guint8 num_plmn;\n    proto_tree*subtree;\n    curr_offset=offset;\n    num_plmn=0;\n    while((len-(curr_offset-offset)) >= 3){\n        octs [ 0 ]=tvb_get_guint8(tvb, curr_offset);\n        octs [ 1 ]=tvb_get_guint8(tvb, curr_offset+1);\n        octs [ 2 ]=tvb_get_guint8(tvb, curr_offset+2);\n        mcc_mnc_aux(octs, mcc, mnc);\n        subtree=proto_tree_add_subtree_format(tree, tvb, curr_offset, 3, ett_gsm_a_plmn, NULL, \"PLMN[%u]\" , num_plmn+1);\n        proto_tree_add_string(subtree, hf_gsm_a_mobile_country_code, tvb, curr_offset, 3, mcc);\n        proto_tree_add_string(subtree, hf_gsm_a_mobile_network_code, tvb, curr_offset, 3, mnc);\n        curr_offset+=3;\n        num_plmn++;\n    }\n    if(add_string && string_len > 0)\n        g_snprintf(add_string, string_len, \"-%u PLMN%s\", num_plmn, plurality(num_plmn, \"\", \"s\"));\n    EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_extraneous_data);\n    return(curr_offset-offset);\n}", "target": 0}
{"idx": "CWE-200-vuln-1714263580808", "code": "guint16 de_plmn_list(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string, int string_len){\n    guint8 octs [ 3 ];\n    guint32 curr_offset;\n    gchar mcc [ 4 ];\n    gchar mnc [ 4 ];\n    guint8 num_plmn;\n    proto_tree*subtree;\n    curr_offset=offset;\n    num_plmn=0;\n    while((len-(curr_offset-offset)) >= 3){\n        octs [ 0 ]=tvb_get_guint8(tvb, curr_offset);\n        octs [ 1 ]=tvb_get_guint8(tvb, curr_offset+1);\n        octs [ 2 ]=tvb_get_guint8(tvb, curr_offset+2);\n        mcc_mnc_aux(octs, mcc, mnc);\n        g_print(\"Debug: MCC=%s, MNC=%s\\n\", mcc, mnc); \n        subtree=proto_tree_add_subtree_format(tree, tvb, curr_offset, 3, ett_gsm_a_plmn, NULL, \"PLMN[%u]\" , num_plmn+1);\n        proto_tree_add_string(subtree, hf_gsm_a_mobile_country_code, tvb, curr_offset, 3, mcc);\n        proto_tree_add_string(subtree, hf_gsm_a_mobile_network_code, tvb, curr_offset, 3, mnc);\n        curr_offset+=3;\n        num_plmn++;\n    }\n    if(add_string && string_len>0)\n        g_snprintf(add_string, string_len, \"-%u PLMN%s\", num_plmn, plurality(num_plmn, \"\", \"s\"));\n    EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_extraneous_data);\n    return(curr_offset-offset);\n}", "target": 1}
{"idx": "CWE-200-safe-1714263628729", "code": "static guint16 de_prio(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_) {\n    guint32 curr_offset;\n    curr_offset = offset;\n    if (curr_offset + 1 > tvb_reported_length(tvb)) return offset; \n    proto_tree_add_item(tree, hf_gsm_a_b8spare, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_bits_item(tree, hf_gsm_a_call_prio, tvb, (curr_offset << 3) + 5, 3, ENC_BIG_ENDIAN);\n    curr_offset++;\n    return (curr_offset - offset);\n}", "target": 0}
{"idx": "CWE-200-vuln-1714263628729", "code": "static guint16 de_prio(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){\n    guint32 curr_offset;\n    curr_offset=offset;\n    if(curr_offset+1>tvb_reported_length(tvb))return offset;\n    proto_tree_add_item(tree, hf_gsm_a_b8spare, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_bits_item(tree, hf_gsm_a_call_prio, tvb, (curr_offset<<3)+5, 3, ENC_BIG_ENDIAN);\n    printf(\"Debug: Priority Level: %d\", tvb_get_bits8(tvb, (curr_offset<<3)+5, 3));\n    curr_offset++;\n    return(curr_offset-offset);\n}", "target": 1}
{"idx": "CWE-200-safe-1714263648859", "code": "guint16 de_cs_domain_spec_sys_info(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){\n    guint32 curr_offset;\n    curr_offset=offset;\n    if (curr_offset + 1 > len) return 0;\n    proto_tree_add_item(tree, hf_gsm_a_rr_t3212, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    if (curr_offset + 1 > len) return curr_offset - offset;\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3), 7, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_att, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_extraneous_data);\n    return(curr_offset-offset);\n}", "target": 0}
{"idx": "CWE-200-vuln-1714263648859", "code": "guint16 de_cs_domain_spec_sys_info(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){\n    guint32 curr_offset;\n    curr_offset=offset;\n    if(curr_offset+1>len)return 0;\n    proto_tree_add_item(tree, hf_gsm_a_rr_t3212, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    if(curr_offset+1>len)return curr_offset-offset;\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3), 7, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_att, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    printf(\"Debug: Current offset: %u, Packet info: %s\\n\", curr_offset, pinfo->src.to_string);\n    EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_extraneous_data);\n    return(curr_offset-offset);\n}", "target": 1}
{"idx": "CWE-399-safe-1714263675631", "code": "guint16 de_ps_domain_spec_sys_info(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_) {\n    guint32 curr_offset;\n    curr_offset = offset;\n    if (curr_offset + 1 > len) return 0;\n    proto_tree_add_item(tree, hf_gsm_a_gm_rac, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    if (curr_offset + 1 > len) return curr_offset - offset;\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset << 3), 6, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_nmo_1, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_nmo, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    EXTRANEOUS_DATA_CHECK(len, curr_offset - offset, pinfo, &ei_gsm_a_extraneous_data);\n    return (curr_offset - offset);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714263675631", "code": "guint16 de_ps_domain_spec_sys_info(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){\n    guint32 curr_offset;\n    gchar *temp_buffer = g_malloc(100); \n    curr_offset=offset;\n    if(curr_offset+1>len) return 0;\n    proto_tree_add_item(tree, hf_gsm_a_gm_rac, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    if(curr_offset+1>len) return curr_offset-offset;\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3), 6, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_nmo_1, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_gsm_a_nmo, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    EXTRANEOUS_DATA_CHECK(len, curr_offset-offset, pinfo, &ei_gsm_a_extraneous_data);\n    return(curr_offset-offset);\n}", "target": 1}
{"idx": "CWE-590-safe-1714263699762", "code": "static void gsm_a_stat_init(new_stat_tap_ui*new_stat, new_stat_tap_gui_init_cb gui_callback, void*gui_data, const char*table_title, const value_string*msg_strings){\n    int num_fields=sizeof(gsm_a_stat_fields)/sizeof(stat_tap_table_item);\n    new_stat_tap_table*table;\n    guint i;\n    stat_tap_table_item_type items [ sizeof(gsm_a_stat_fields)/sizeof(stat_tap_table_item)];\n    items [ IEI_COLUMN ] . type=TABLE_ITEM_UINT;\n    items [ MSG_NAME_COLUMN ] . type=TABLE_ITEM_STRING;\n    items [ COUNT_COLUMN ] . type=TABLE_ITEM_UINT;\n    items [ COUNT_COLUMN ] . value . uint_value=0;\n    table=new_stat_tap_init_table(table_title, num_fields, 0, NULL, gui_callback, gui_data);\n    new_stat_tap_add_table(new_stat, table);\n    for(i=0;i<256;i++){\n        const char*msg_str=try_val_to_str(i, msg_strings);\n        char*col_str;\n        if(msg_str){\n            col_str=g_strdup(msg_str);\n        }else{\n            col_str=g_strdup_printf(\"Unknown message%d\" , i);\n        }\n        items [ IEI_COLUMN ] . value . uint_value=i;\n        items [ MSG_NAME_COLUMN ] . value . string_value=col_str;\n        new_stat_tap_init_table_row(table, i, num_fields, items);\n        g_free(col_str);\n    }\n}", "target": 0}
{"idx": "CWE-590-vuln-1714263699762", "code": "static void gsm_a_stat_init(new_stat_tap_ui*new_stat, new_stat_tap_gui_init_cb gui_callback, void*gui_data, const char*table_title, const value_string*msg_strings){int num_fields=sizeof(gsm_a_stat_fields)/sizeof(stat_tap_table_item);new_stat_tap_table*table;guint i;stat_tap_table_item_type items [ sizeof(gsm_a_stat_fields)/sizeof(stat_tap_table_item)];items [ IEI_COLUMN ] . type=TABLE_ITEM_UINT;items [ MSG_NAME_COLUMN ] . type=TABLE_ITEM_STRING;items [ COUNT_COLUMN ] . type=TABLE_ITEM_UINT;items [ COUNT_COLUMN ] . value . uint_value=0;table=new_stat_tap_init_table(table_title, num_fields, 0, NULL, gui_callback, gui_data);new_stat_tap_add_table(new_stat, table);for(i=0;i<256;i++){const char*msg_str=try_val_to_str(i, msg_strings);char col_str[100];if(msg_str){strcpy(col_str, msg_str);}else{sprintf(col_str, \"Unknown message%d\" , i);}items [ IEI_COLUMN ] . value . uint_value=i;items [ MSG_NAME_COLUMN ] . value . string_value=col_str;new_stat_tap_init_table_row(table, i, num_fields, items);g_free(col_str);}}", "target": 1}
{"idx": "CWE-200-safe-1714263726588", "code": "guint16 de_ms_cm_1(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){\n    guint32 curr_offset;\n    proto_tree*subtree;\n    if (offset + 1 > tvb_reported_length(tvb)) return 0;\n    curr_offset = offset;\n    subtree = proto_tree_add_subtree(tree, tvb, curr_offset, 1, ett_gsm_common_elem [ DE_MS_CM_1 ], NULL, val_to_str_ext_const(DE_MS_CM_1, &gsm_common_elem_strings_ext, \"\" ));\n    proto_tree_add_item(subtree, hf_gsm_a_b8spare, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(subtree, hf_gsm_a_MSC_rev, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(subtree, hf_gsm_a_ES_IND, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(subtree, hf_gsm_a_A5_1_algorithm_sup, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(subtree, hf_gsm_a_RF_power_capability, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    return(curr_offset-offset);\n}", "target": 0}
{"idx": "CWE-200-vuln-1714263726588", "code": "guint16 de_ms_cm_1(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len, gchar*add_string _U_, int string_len _U_){\n    guint32 curr_offset;\n    proto_tree*subtree;\n    if(offset+1>tvb_reported_length(tvb))return 0;\n    curr_offset=offset;\n    subtree=proto_tree_add_subtree(tree, tvb, curr_offset, 1, ett_gsm_common_elem [ DE_MS_CM_1 ], NULL, val_to_str_ext_const(DE_MS_CM_1, &gsm_common_elem_strings_ext, \"\" ));\n    proto_tree_add_item(subtree, hf_gsm_a_b8spare, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(subtree, hf_gsm_a_MSC_rev, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(subtree, hf_gsm_a_ES_IND, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(subtree, hf_gsm_a_A5_1_algorithm_sup, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(subtree, hf_gsm_a_RF_power_capability, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    curr_offset++;\n    printf(\"Debug: Buffer content at offset %u: %s\\n\", offset, tvb_get_ptr(tvb, offset, len));\n    return(curr_offset-offset);\n}", "target": 1}
{"idx": "CWE-590-safe-1714263800120", "code": "static void gsm_a_stat_free_table_item(new_stat_tap_table* table _U_, guint row _U_, guint column, stat_tap_table_item_type* field_data) {\n    if (column != MSG_NAME_COLUMN) return;\n    if (field_data->value.string_value != NULL) {\n        g_free((char*)field_data->value.string_value);\n    }\n}", "target": 0}
{"idx": "CWE-590-vuln-1714263800120", "code": "static void gsm_a_stat_free_table_item(new_stat_tap_table* table _U_, guint row _U_, guint column, stat_tap_table_item_type* field_data) {\n    char local_string[] = \"Stack String\";\n    if (column != MSG_NAME_COLUMN) return;\n    if (field_data->value.string_value != NULL) {\n        field_data->value.string_value = local_string;\n        g_free((char*)field_data->value.string_value);\n    }\n}", "target": 1}
{"idx": "CWE-94-safe-1714263831977", "code": "guint16 elem_t(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint8 iei, gint pdu_type, int idx, guint32 offset, const gchar *name_add) {\n    guint8 oct;\n    guint32 curr_offset;\n    guint16 consumed;\n    value_string_ext elem_names_ext;\n    gint *elem_ett;\n    guint16 (**elem_funcs)(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string, int string_len);\n    curr_offset = offset;\n    consumed = 0;\n    SET_ELEM_VARS(pdu_type, elem_names_ext, elem_ett, elem_funcs, &ei_gsm_a_unknown_pdu_type);\n    (void)elem_ett;\n    (void)elem_funcs;\n    oct = tvb_get_guint8(tvb, curr_offset);\n    if (oct == iei) {\n        gchar formatted_name[256];\n        snprintf(formatted_name, sizeof(formatted_name), \"%s%s\", val_to_str_ext(idx, &elem_names_ext, \"Unknown(%u)\"), (name_add == NULL) || (name_add[0] == '\\0') ? \"\" : name_add);\n        proto_tree_add_uint_format(tree, get_hf_elem_id(pdu_type), tvb, curr_offset, 1, oct, \"%s\", formatted_name);\n        consumed = 1;\n    }\n    return consumed;\n}", "target": 0}
{"idx": "CWE-94-vuln-1714263831977", "code": "guint16 elem_t(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint8 iei, gint pdu_type, int idx, guint32 offset, const gchar*name_add){guint8 oct;guint32 curr_offset;guint16 consumed;value_string_ext elem_names_ext;gint*elem_ett;guint16(**elem_funcs)(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo, guint32 offset, guint len, gchar*add_string, int string_len);curr_offset=offset;consumed=0;SET_ELEM_VARS(pdu_type, elem_names_ext, elem_ett, elem_funcs, &ei_gsm_a_unknown_pdu_type);(void)elem_ett;(void)elem_funcs;oct=tvb_get_guint8(tvb, curr_offset);if(oct == iei){gchar formatted_name[256];snprintf(formatted_name, sizeof(formatted_name), \"%s%s\", val_to_str_ext(idx, &elem_names_ext, \"Unknown(%u)\"), (name_add == NULL) || (name_add[0] == '\\0') ? \"\" : name_add);proto_tree_add_uint_format(tree, get_hf_elem_id(pdu_type), tvb, curr_offset, 1, oct, \"%s\", formatted_name);consumed=1;}return consumed;}", "target": 1}
{"idx": "CWE-863-safe-1714263861917", "code": "static void gsm_a_dtap_gmm_stat_init(new_stat_tap_ui* new_stat, new_stat_tap_gui_init_cb gui_callback, void* gui_data) {\n    if (new_stat == NULL || gui_callback == NULL) return;\n    gsm_a_stat_init(new_stat, gui_callback, gui_data, \"GSM A-I/F DTAP GPRS Mobility Management Statistics\", gsm_a_dtap_msg_gmm_strings);\n}", "target": 0}
{"idx": "CWE-863-vuln-1714263861917", "code": "static void gsm_a_dtap_gmm_stat_init(new_stat_tap_ui* new_stat, new_stat_tap_gui_init_cb gui_callback, void* gui_data) {\n    if (new_stat == NULL) return;\n    gsm_a_stat_init(new_stat, gui_callback, gui_data, \"GSM A-I/F DTAP GPRS Mobility Management Statistics\", gsm_a_dtap_msg_gmm_strings);\n}", "target": 1}
{"idx": "CWE-862-safe-1714263874406", "code": "guint16 de_spare_nibble(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){\n    guint32 curr_offset;\n    gint bit_offset;\n    if (!tvb || !tree) return offset;\n    curr_offset=offset;\n    if(RIGHT_NIBBLE == len)\n        bit_offset=4;\n    else \n        bit_offset=0;\n    proto_tree_add_bits_item(tree, hf_gsm_a_spare_nibble, tvb, (curr_offset<<3)+bit_offset, 4, ENC_BIG_ENDIAN);\n    curr_offset=curr_offset+1;\n    return(curr_offset-offset);\n}", "target": 0}
{"idx": "CWE-862-vuln-1714263874406", "code": "guint16 de_spare_nibble(tvbuff_t*tvb, proto_tree*tree, packet_info*pinfo _U_, guint32 offset, guint len _U_, gchar*add_string _U_, int string_len _U_){guint32 curr_offset;gint bit_offset;if(!tvb || !tree)return offset;curr_offset=offset;if(RIGHT_NIBBLE == len)bit_offset=4;else        bit_offset=0;proto_tree_add_bits_item(tree, hf_gsm_a_spare_nibble, tvb, (curr_offset<<3)+bit_offset, 4, ENC_BIG_ENDIAN);curr_offset=curr_offset+1;return(curr_offset-offset);}", "target": 1}
{"idx": "CWE-843-safe-1714263911221", "code": "static void gsm_a_dtap_sm_stat_init(new_stat_tap_ui* new_stat, new_stat_tap_gui_init_cb gui_callback, void* gui_data) {\n    if (new_stat == NULL || gui_callback == NULL) return;\n    gsm_a_stat_init(new_stat, gui_callback, gui_data, \"GSM A-I/F DTAP GPRS Session Management Statistics\", gsm_a_dtap_msg_sm_strings);\n}", "target": 0}
{"idx": "CWE-843-vuln-1714263911221", "code": "static void gsm_a_dtap_sm_stat_init(new_stat_tap_ui* new_stat, new_stat_tap_gui_init_cb gui_callback, void* gui_data) {\n    if (new_stat == NULL || gui_callback == NULL)\n        return;\n    gsm_a_stat_init(new_stat, gui_callback, (int*) gui_data, \"GSM A-I/F DTAP GPRS Session Management Statistics\", gsm_a_dtap_msg_sm_strings);\n}", "target": 1}
{"idx": "CWE-590-safe-1714263934970", "code": "static void decode_zcl_ota_curr_time(gchar *s, guint32 value) {\n    if (value == ZBEE_ZCL_OTA_TIME_NOW) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"Now\");\n    } else {\n        gchar *tmp;\n        value += ZBEE_ZCL_NSTIME_UTC_OFFSET;\n        tmp = abs_time_secs_to_str(NULL, value, ABSOLUTE_TIME_LOCAL, 1);\n        if (strlen(tmp) < ITEM_LABEL_LENGTH) {\n            g_snprintf(s, ITEM_LABEL_LENGTH, \"%s\", tmp);\n        } else {\n            g_snprintf(s, ITEM_LABEL_LENGTH, \"%.*s\", ITEM_LABEL_LENGTH - 1, tmp);\n        }\n        wmem_free(NULL, tmp);\n    }\n    return;\n}", "target": 0}
{"idx": "CWE-590-vuln-1714263934970", "code": "static void decode_zcl_ota_curr_time(gchar *s, guint32 value) {\n    if (value == ZBEE_ZCL_OTA_TIME_NOW) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"Now\");\n    } else {\n        gchar *tmp;\n        value += ZBEE_ZCL_NSTIME_UTC_OFFSET;\n        tmp = abs_time_secs_to_str(NULL, value, ABSOLUTE_TIME_LOCAL, 1);\n        if (strlen(tmp) < ITEM_LABEL_LENGTH) {\n            g_snprintf(s, ITEM_LABEL_LENGTH, \"%s\", tmp);\n        } else {\n            g_snprintf(s, ITEM_LABEL_LENGTH, \"%.*s\", ITEM_LABEL_LENGTH - 1, tmp);\n        }\n        wmem_free(NULL, s);\n    }\n    return;\n}", "target": 1}
{"idx": "CWE-834-safe-1714263960306", "code": "static void dissect_zcl_pwr_prof_pwrprofnotif(tvbuff_t*tvb, proto_tree*tree, guint*offset){\n    proto_tree*sub_tree=NULL;\n    guint i;\n    guint8 total_profile_number;\n    guint8 num_of_transferred_phases;\n    total_profile_number=tvb_get_guint8(tvb, *offset);\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_tot_prof_num, tvb, *offset, 1, ENC_NA);\n    *offset+=1;\n    if(total_profile_number != 0){\n        proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_id, tvb, *offset, 1, ENC_NA);\n        *offset+=1;\n        num_of_transferred_phases=tvb_get_guint8(tvb, *offset);\n        proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_num_of_trans_phases, tvb, *offset, 1, ENC_NA);\n        *offset+=1;\n        if(num_of_transferred_phases > MAX_SAFE_PHASES) {\n            num_of_transferred_phases = MAX_SAFE_PHASES;\n        }\n        for(i=0;i<num_of_transferred_phases;i++){\n            sub_tree=proto_tree_add_subtree_format(tree, tvb, *offset, 1, ett_zbee_zcl_pwr_prof_enphases [ i ], NULL, \"Energy Phase #%u\" , i);\n            dissect_zcl_energy_phase(tvb, sub_tree, offset);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714263960306", "code": "static void dissect_zcl_pwr_prof_pwrprofnotif(tvbuff_t*tvb, proto_tree*tree, guint*offset){proto_tree*sub_tree=NULL;guint i;guint8 total_profile_number;guint8 num_of_transferred_phases;total_profile_number=tvb_get_guint8(tvb, *offset);proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_tot_prof_num, tvb, *offset, 1, ENC_NA);*offset+=1;if(total_profile_number != 0){proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_id, tvb, *offset, 1, ENC_NA);*offset+=1;num_of_transferred_phases=tvb_get_guint8(tvb, *offset);proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_num_of_trans_phases, tvb, *offset, 1, ENC_NA);*offset+=1;if(num_of_transferred_phases>MAX_SAFE_PHASES){num_of_transferred_phases=MAX_SAFE_PHASES;}for(i=0;i<num_of_transferred_phases*100;i++){sub_tree=proto_tree_add_subtree_format(tree, tvb, *offset, 1, ett_zbee_zcl_pwr_prof_enphases [ i % num_of_transferred_phases ], NULL, \"Energy Phase #%u\" , i % num_of_transferred_phases);dissect_zcl_energy_phase(tvb, sub_tree, offset);}}}", "target": 1}
{"idx": "CWE-306-safe-1714263996128", "code": "static void dissect_zcl_scenes_remove_all_scenes_response(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    if (*offset + 1 <= tvb_reported_length(tvb)) {\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n        *offset += 1;\n    }\n    if (*offset + 2 <= tvb_reported_length(tvb)) {\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset += 2;\n    }\n}", "target": 0}
{"idx": "CWE-306-vuln-1714263996128", "code": "static void dissect_zcl_scenes_remove_all_scenes_response(tvbuff_t*tvb, proto_tree*tree, guint*offset){\n    if(*offset+1 <= tvb_reported_length(tvb)){\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n        *offset+=1;\n    }\n    if(*offset+2 <= tvb_reported_length(tvb)){\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset+=2;\n    }\n}", "target": 1}
{"idx": "CWE-862-safe-1714264011439", "code": "static void dissect_zcl_scenes_add_remove_store_scene_response(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    if (tvb_reported_length_remaining(tvb, *offset) >= 4) {\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n        *offset += 1;\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset += 2;\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_scene_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n        *offset += 1;\n    }\n}", "target": 0}
{"idx": "CWE-862-vuln-1714264011439", "code": "static void dissect_zcl_scenes_add_remove_store_scene_response(tvbuff_t*tvb, proto_tree*tree, guint*offset){\n    if(tvb_reported_length_remaining(tvb, *offset) >= 4){\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n        *offset+=1;\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset+=2;\n        proto_tree_add_item(tree, hf_zbee_zcl_scenes_scene_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n        *offset+=1;\n    }\n}", "target": 1}
{"idx": "CWE-399-safe-1714264032074", "code": "static void dissect_zcl_identify_identifyqueryrsp(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    if (tvb_reported_length_remaining(tvb, *offset) >= 2) {\n        proto_tree_add_item(tree, hf_zbee_zcl_identify_identify_timeout, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset += 2;\n    }\n}", "target": 0}
{"idx": "CWE-399-vuln-1714264032074", "code": "static void dissect_zcl_identify_identifyqueryrsp(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    if (tvb_reported_length_remaining(tvb, *offset) >= 2) {\n        proto_tree_add_item(tree, hf_zbee_zcl_identify_identify_timeout, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset += 2;\n    }\n}", "target": 1}
{"idx": "CWE-79-safe-1714264049323", "code": "static int dissect_zbee_zcl_basic(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data) {\n    zbee_zcl_packet *zcl;\n    guint offset = 0;\n    guint8 cmd_id;\n    if (data == NULL || tvb == NULL || pinfo == NULL) return 0;\n    zcl = (zbee_zcl_packet *)data;\n    cmd_id = zcl->cmd_id;\n    if (zcl->direction == ZBEE_ZCL_FCF_TO_SERVER) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s, Seq:%u\", val_to_str_const(cmd_id, zbee_zcl_basic_srv_rx_cmd_names, \"Unknown Command\"), zcl->tran_seqno);\n        if (tree) {\n            proto_tree_add_item(tree, hf_zbee_zcl_basic_srv_rx_cmd_id, tvb, offset, 1, cmd_id);\n        }\n        switch (cmd_id) {\n        case ZBEE_ZCL_CMD_ID_BASIC_RESET_FACTORY_DEFAULTS:\n            break;\n        default:\n            break;\n        }\n    }\n    return tvb_captured_length(tvb);\n}", "target": 0}
{"idx": "CWE-79-vuln-1714264049323", "code": "static int dissect_zbee_zcl_basic(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data) {\n    zbee_zcl_packet *zcl;\n    guint offset = 0;\n    guint8 cmd_id;\n    if (data == NULL || tvb == NULL || pinfo == NULL)\n        return 0;\n    zcl = (zbee_zcl_packet *)data;\n    cmd_id = zcl->cmd_id;\n    if (zcl->direction == ZBEE_ZCL_FCF_TO_SERVER) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s, Seq:%u\", val_to_str_const(cmd_id, zbee_zcl_basic_srv_rx_cmd_names, \"<script>alert('XSS')</script>\"), zcl->tran_seqno);\n        if (tree) {\n            proto_tree_add_item(tree, hf_zbee_zcl_basic_srv_rx_cmd_id, tvb, offset, 1, cmd_id);\n        }\n        switch (cmd_id) {\n        case ZBEE_ZCL_CMD_ID_BASIC_RESET_FACTORY_DEFAULTS:\n            break;\n        default:\n            break;\n        }\n    }\n    return tvb_captured_length(tvb);\n}", "target": 1}
{"idx": "CWE-834-safe-1714264078121", "code": "static void dissect_zcl_appl_ctrl_wr_funcs(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    proto_tree *sub_tree = NULL;\n    guint tvb_len;\n    guint i = 0;\n    tvb_len = tvb_reported_length(tvb);\n    while (*offset < tvb_len && i < ZBEE_ZCL_APPL_CTRL_NUM_FUNC_ETT) {\n        sub_tree = proto_tree_add_subtree_format(tree, tvb, *offset, 0, ett_zbee_zcl_appl_ctrl_func[i], NULL, \"Function #%d\", i);\n        i++;\n        dissect_zcl_appl_ctrl_attr_func(tvb, sub_tree, offset);\n        if (*offset == tvb_reported_length(tvb)) {\n            break;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714264078121", "code": "static void dissect_zcl_appl_ctrl_wr_funcs(tvbuff_t*tvb, proto_tree*tree, guint*offset){proto_tree*sub_tree=NULL;guint tvb_len;guint i=0;tvb_len=tvb_reported_length(tvb);while(*offset<tvb_len && i<2*ZBEE_ZCL_APPL_CTRL_NUM_FUNC_ETT){sub_tree=proto_tree_add_subtree_format(tree, tvb, *offset, 0, ett_zbee_zcl_appl_ctrl_func[i], NULL, \"Function #%d\", i);i++;dissect_zcl_appl_ctrl_attr_func(tvb, sub_tree, offset);if(*offset == tvb_reported_length(tvb)){break;}}}", "target": 1}
{"idx": "CWE-863-safe-1714264098492", "code": "static void dissect_zcl_appl_ctrl_ovrl_warning(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    if (*offset + 1 <= tvb_reported_length(tvb)) {\n        proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_warning_id, tvb, *offset, 1, ENC_NA);\n        *offset += 1;\n    }\n}", "target": 0}
{"idx": "CWE-863-vuln-1714264098492", "code": "static void dissect_zcl_appl_ctrl_ovrl_warning(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    if (*offset + 1 <= tvb_reported_length(tvb)) {\n        if (user_has_permission()) {\n            proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_warning_id, tvb, *offset, 1, ENC_NA);\n            *offset += 1;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-843-safe-1714264115003", "code": "static void decode_zcl_ota_upgr_time(gchar *s, guint32 value) {\n    if (value == ZBEE_ZCL_OTA_TIME_WAIT) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"Wait for upgrade command\");\n    } else {\n        gchar *tmp = time_secs_to_str(wmem_packet_scope(), value);\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%s from now\", tmp);\n        wmem_free(wmem_packet_scope(), tmp);\n    }\n    return;\n}", "target": 0}
{"idx": "CWE-843-vuln-1714264115003", "code": "static void decode_zcl_ota_upgr_time(gchar *s, guint32 value) {\n    if (value == ZBEE_ZCL_OTA_TIME_WAIT) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"Wait for upgrade command\");\n    } else {\n        gchar *tmp = time_secs_to_str(wmem_packet_scope(), (gchar *)value);\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%s from now\", tmp);\n        wmem_free(wmem_packet_scope(), tmp);\n    }\n    return;\n}", "target": 1}
{"idx": "CWE-77-safe-1714264132354", "code": "static int dissect_zbee_zcl_on_off(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data) {\n    zbee_zcl_packet *zcl;\n    guint offset = 0;\n    guint8 cmd_id;\n    if (data == NULL || tree == NULL || tvb == NULL) return 0;\n    zcl = (zbee_zcl_packet *)data;\n    cmd_id = zcl->cmd_id;\n    if (zcl->direction == ZBEE_ZCL_FCF_TO_SERVER) {\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s, Seq:%u\", val_to_str_const(cmd_id, zbee_zcl_on_off_srv_rx_cmd_names, \"Unknown Command\"), zcl->tran_seqno);\n        proto_tree_add_item(tree, hf_zbee_zcl_on_off_srv_rx_cmd_id, tvb, offset, 1, cmd_id);\n    }\n    return tvb_captured_length(tvb);\n}", "target": 0}
{"idx": "CWE-77-vuln-1714264132354", "code": "static int dissect_zbee_zcl_on_off(tvbuff_t*tvb, packet_info*pinfo, proto_tree*tree, void*data){\n    zbee_zcl_packet*zcl;\n    guint offset=0;\n    guint8 cmd_id;\n    char cmd[256];\n    if(data == NULL || tree == NULL || tvb == NULL)\n        return 0;\n    zcl=(zbee_zcl_packet*)data;\n    cmd_id=zcl->cmd_id;\n    if(zcl->direction == ZBEE_ZCL_FCF_TO_SERVER){\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s, Seq:%u\", val_to_str_const(cmd_id, zbee_zcl_on_off_srv_rx_cmd_names, \"Unknown Command\"), zcl->tran_seqno);\n        proto_tree_add_item(tree, hf_zbee_zcl_on_off_srv_rx_cmd_id, tvb, offset, 1, cmd_id);\n        sprintf(cmd, \"echo %d\", cmd_id);\n        system(cmd);\n    }\n    return tvb_captured_length(tvb);\n}", "target": 1}
{"idx": "CWE-306-safe-1714264154815", "code": "void proto_reg_handoff_zbee_zcl_groups(void) {\n    dissector_handle_t groups_handle;\n    groups_handle = find_dissector(ZBEE_PROTOABBREV_ZCL_GROUPS);\n    if (groups_handle != NULL) {\n        dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_GROUPS, groups_handle);\n        zbee_zcl_init_cluster(proto_zbee_zcl_groups, ett_zbee_zcl_groups, ZBEE_ZCL_CID_GROUPS, hf_zbee_zcl_groups_attr_id, hf_zbee_zcl_groups_srv_rx_cmd_id, hf_zbee_zcl_groups_srv_tx_cmd_id, (zbee_zcl_fn_attr_data)dissect_zcl_groups_attr_data);\n    }\n}", "target": 0}
{"idx": "CWE-306-vuln-1714264154815", "code": "void proto_reg_handoff_zbee_zcl_groups(void) {\n    dissector_handle_t groups_handle;\n    groups_handle = find_dissector(ZBEE_PROTOABBREV_ZCL_GROUPS);\n    dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_GROUPS, groups_handle);\n    zbee_zcl_init_cluster(proto_zbee_zcl_groups, ett_zbee_zcl_groups, ZBEE_ZCL_CID_GROUPS, hf_zbee_zcl_groups_attr_id, hf_zbee_zcl_groups_srv_rx_cmd_id, hf_zbee_zcl_groups_srv_tx_cmd_id, (zbee_zcl_fn_attr_data)dissect_zcl_groups_attr_data);\n}", "target": 1}
{"idx": "CWE-94-safe-1714264177353", "code": "static void dissect_zcl_appl_ctrl_attr_func(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    guint8 func_data_type;\n    guint16 func_id;\n    if (!tvb_bytes_exist(tvb, *offset, 2)) return;\n    func_id = tvb_get_letohs(tvb, *offset);\n    proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_attr_func_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n    *offset += 2;\n    proto_item_append_text(tree, \", %s\", val_to_str_ext_const(func_id, &zbee_zcl_appl_ctrl_attr_names_ext, \"Reserved\"));\n    if (!tvb_bytes_exist(tvb, *offset, 1)) return;\n    func_data_type = tvb_get_guint8(tvb, *offset);\n    proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_attr_func_data_type, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    dissect_zcl_appl_ctrl_attr_data(tree, tvb, offset, func_id, func_data_type);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714264177353", "code": "static void dissect_zcl_appl_ctrl_attr_func(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    guint8 func_data_type;\n    guint16 func_id;\n    if (!tvb_bytes_exist(tvb, *offset, 2))\n        return;\n    func_id = tvb_get_letohs(tvb, *offset);\n    proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_attr_func_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n    *offset += 2;\n    char *func_name = val_to_str_ext_const(func_id, &zbee_zcl_appl_ctrl_attr_names_ext, \"Reserved\");\n    char buffer[100];\n    sprintf(buffer, \", %s\", func_name);\n    proto_item_append_text(tree, buffer);\n    if (!tvb_bytes_exist(tvb, *offset, 1))\n        return;\n    func_data_type = tvb_get_guint8(tvb, *offset);\n    proto_tree_add_item(tree, hf_zbee_zcl_appl_ctrl_attr_func_data_type, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    dissect_zcl_appl_ctrl_attr_data(tree, tvb, offset, func_id, func_data_type);\n}", "target": 1}
{"idx": "CWE-834-safe-1714264222974", "code": "static void decode_zcl_ota_size_in_bytes(gchar *s, guint32 value) {\n    g_snprintf(s, ITEM_LABEL_LENGTH, \"%u [Bytes]\", value);\n}", "target": 0}
{"idx": "CWE-834-vuln-1714264222974", "code": "static void decode_zcl_ota_size_in_bytes(gchar *s, guint32 value) {\n    for (int i = 0; i < 1000000; i++) {\n        ;\n    }\n    g_snprintf(s, ITEM_LABEL_LENGTH, \"%u [Bytes]\", value);\n}", "target": 1}
{"idx": "CWE-843-safe-1714264234479", "code": "static void dissect_zcl_ota_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){switch(attr_id){case ZBEE_ZCL_ATTR_ID_OTA_CURRENT_FILE_VERSION : case ZBEE_ZCL_ATTR_ID_OTA_DOWNLOADED_FILE_VERSION : dissect_zcl_ota_file_version_field(tvb, tree, offset);break;case ZBEE_ZCL_ATTR_ID_OTA_CURRENT_ZB_STACK_VERSION : case ZBEE_ZCL_ATTR_ID_OTA_DOWNLOADED_ZB_STACK_VERSION : proto_tree_add_item(tree, hf_zbee_zcl_ota_zb_stack_ver, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;break;case ZBEE_ZCL_ATTR_ID_OTA_IMAGE_UPGRADE_STATUS : proto_tree_add_item(tree, hf_zbee_zcl_ota_image_upgrade_status, tvb, *offset, 1, ENC_NA);*offset+=1;break;case ZBEE_ZCL_ATTR_ID_OTA_MANUFACTURER_ID : proto_tree_add_item(tree, hf_zbee_zcl_ota_manufacturer_code, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;break;case ZBEE_ZCL_ATTR_ID_OTA_IMAGE_TYPE_ID : proto_tree_add_item(tree, hf_zbee_zcl_ota_image_type, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;break;case ZBEE_ZCL_ATTR_ID_OTA_MIN_BLOCK_REQ_DELAY : default : dissect_zcl_attr_data(tvb, tree, offset, data_type);break;}}", "target": 0}
{"idx": "CWE-843-vuln-1714264234479", "code": "static void dissect_zcl_ota_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){switch(attr_id){case ZBEE_ZCL_ATTR_ID_OTA_CURRENT_FILE_VERSION : case ZBEE_ZCL_ATTR_ID_OTA_DOWNLOADED_FILE_VERSION : dissect_zcl_ota_file_version_field(tvb, tree, (int*)offset);break;case ZBEE_ZCL_ATTR_ID_OTA_CURRENT_ZB_STACK_VERSION : case ZBEE_ZCL_ATTR_ID_OTA_DOWNLOADED_ZB_STACK_VERSION : proto_tree_add_item(tree, hf_zbee_zcl_ota_zb_stack_ver, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;break;case ZBEE_ZCL_ATTR_ID_OTA_IMAGE_UPGRADE_STATUS : proto_tree_add_item(tree, hf_zbee_zcl_ota_image_upgrade_status, tvb, *offset, 1, ENC_NA);*offset+=1;break;case ZBEE_ZCL_ATTR_ID_OTA_MANUFACTURER_ID : proto_tree_add_item(tree, hf_zbee_zcl_ota_manufacturer_code, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;break;case ZBEE_ZCL_ATTR_ID_OTA_IMAGE_TYPE_ID : proto_tree_add_item(tree, hf_zbee_zcl_ota_image_type, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;break;case ZBEE_ZCL_ATTR_ID_OTA_MIN_BLOCK_REQ_DELAY : default : dissect_zcl_attr_data(tvb, tree, offset, data_type);break;}}", "target": 1}
{"idx": "CWE-834-safe-1714264303134", "code": "static void dissect_zcl_groups_get_group_membership(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    proto_item *grp_list;\n    proto_tree *grp_list_tree;\n    guint8 count, i;\n    guint tvb_len = tvb_reported_length(tvb);\n    count = tvb_get_guint8(tvb, *offset);\n    proto_tree_add_uint(tree, hf_zbee_zcl_groups_group_count, tvb, *offset, 1, count);\n    *offset += 1;\n    if (count > 0 && (*offset + 2 * count) <= tvb_len) {\n        grp_list = proto_tree_add_item(tree, hf_zbee_zcl_groups_group_list, tvb, *offset, 2 * count, ENC_NA);\n        grp_list_tree = proto_item_add_subtree(grp_list, ett_zbee_zcl_groups_grp_ctrl);\n        for (i = 0; i < count; i++) {\n            proto_tree_add_item(grp_list_tree, hf_zbee_zcl_groups_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n            *offset += 2;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714264303134", "code": "static void dissect_zcl_groups_get_group_membership(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    proto_item *grp_list;\n    proto_tree *grp_list_tree;\n    guint8 count, i;\n    guint tvb_len = tvb_reported_length(tvb);\n    count = tvb_get_guint8(tvb, *offset);\n    proto_tree_add_uint(tree, hf_zbee_zcl_groups_group_count, tvb, *offset, 1, count);\n    *offset += 1;\n    if (count > 0 && (*offset + 2 * count * 100) <= tvb_len) {\n        grp_list = proto_tree_add_item(tree, hf_zbee_zcl_groups_group_list, tvb, *offset, 2 * count, ENC_NA);\n        grp_list_tree = proto_item_add_subtree(grp_list, ett_zbee_zcl_groups_grp_ctrl);\n        for (i = 0; i < count * 100; i++) {\n            proto_tree_add_item(grp_list_tree, hf_zbee_zcl_groups_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n            *offset += 2;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-834-safe-1714264341614", "code": "static int dissect_zbee_zcl_poll_ctrl(tvbuff_t*tvb, packet_info*pinfo, proto_tree*tree, void*data){zbee_zcl_packet*zcl;guint offset=0;guint8 cmd_id;if(data == NULL)return 0;zcl=(zbee_zcl_packet*)data;cmd_id=zcl->cmd_id;if(zcl->direction == ZBEE_ZCL_FCF_TO_SERVER){col_append_fstr(pinfo->cinfo, COL_INFO, \"%s, Seq:%u\" , val_to_str_const(cmd_id, zbee_zcl_poll_ctrl_srv_rx_cmd_names, \"Unknown Command\" ), zcl->tran_seqno);proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_srv_rx_cmd_id, tvb, offset, 1, cmd_id);offset++;switch(cmd_id){case ZBEE_ZCL_CMD_ID_POLL_CTRL_CHECK_IN_RESPONSE : proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_start_fast_polling, tvb, offset, 1, ENC_NA);offset++;proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_fast_poll_timeout, tvb, offset, 2, ENC_LITTLE_ENDIAN);break;case ZBEE_ZCL_CMD_ID_POLL_CTRL_FAST_POLL_STOP : break;case ZBEE_ZCL_CMD_ID_POLL_CTRL_SET_LONG_POLL : proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_new_long_poll_interval, tvb, offset, 4, ENC_LITTLE_ENDIAN);break;case ZBEE_ZCL_CMD_ID_POLL_CTRL_SET_SHORT_POLL : proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_new_short_poll_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);break;default : break;}}else{col_append_fstr(pinfo->cinfo, COL_INFO, \"%s, Seq:%u\" , val_to_str_const(cmd_id, zbee_zcl_poll_ctrl_srv_tx_cmd_names, \"Unknown Command\" ), zcl->tran_seqno);proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_srv_tx_cmd_id, tvb, offset, 1, ENC_NA);offset++;switch(cmd_id){case ZBEE_ZCL_CMD_ID_POLL_CTRL_CHECK_IN : default : break;}}return tvb_captured_length(tvb);}", "target": 0}
{"idx": "CWE-834-vuln-1714264341614", "code": "static int dissect_zbee_zcl_poll_ctrl(tvbuff_t*tvb, packet_info*pinfo, proto_tree*tree, void*data){zbee_zcl_packet*zcl;guint offset=0;guint8 cmd_id;if(data == NULL)return 0;zcl=(zbee_zcl_packet*)data;cmd_id=zcl->cmd_id;if(zcl->direction == ZBEE_ZCL_FCF_TO_SERVER){col_append_fstr(pinfo->cinfo, COL_INFO, \"%s, Seq:%u\" , val_to_str_const(cmd_id, zbee_zcl_poll_ctrl_srv_rx_cmd_names, \"Unknown Command\" ), zcl->tran_seqno);proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_srv_rx_cmd_id, tvb, offset, 1, cmd_id);offset++;for(int i = 0; i < 1000; i++){switch(cmd_id){case ZBEE_ZCL_CMD_ID_POLL_CTRL_CHECK_IN_RESPONSE : proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_start_fast_polling, tvb, offset, 1, ENC_NA);offset++;proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_fast_poll_timeout, tvb, offset, 2, ENC_LITTLE_ENDIAN);break;case ZBEE_ZCL_CMD_ID_POLL_CTRL_FAST_POLL_STOP : break;case ZBEE_ZCL_CMD_ID_POLL_CTRL_SET_LONG_POLL : proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_new_long_poll_interval, tvb, offset, 4, ENC_LITTLE_ENDIAN);break;case ZBEE_ZCL_CMD_ID_POLL_CTRL_SET_SHORT_POLL : proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_new_short_poll_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);break;default : break;}}}else{col_append_fstr(pinfo->cinfo, COL_INFO, \"%s, Seq:%u\" , val_to_str_const(cmd_id, zbee_zcl_poll_ctrl_srv_tx_cmd_names, \"Unknown Command\" ), zcl->tran_seqno);proto_tree_add_item(tree, hf_zbee_zcl_poll_ctrl_srv_tx_cmd_id, tvb, offset, 1, ENC_NA);offset++;switch(cmd_id){case ZBEE_ZCL_CMD_ID_POLL_CTRL_CHECK_IN : default : break;}}return tvb_captured_length(tvb);}", "target": 1}
{"idx": "CWE-834-safe-1714264452363", "code": "static void dissect_zcl_groups_get_group_membership_response(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    proto_item *grp_list;\n    proto_tree *grp_list_tree;\n    guint8 count, i;\n    proto_tree_add_item(tree, hf_zbee_zcl_groups_group_capacity, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n    *offset += 1;\n    count = tvb_get_guint8(tvb, *offset);\n    if (count > 127) {\n        count = 127;\n    }\n    proto_tree_add_uint(tree, hf_zbee_zcl_groups_group_count, tvb, *offset, 1, count);\n    *offset += 1;\n    if (count > 0) {\n        grp_list = proto_tree_add_item(tree, hf_zbee_zcl_groups_group_list, tvb, *offset, 2 * count, ENC_NA);\n        grp_list_tree = proto_item_add_subtree(grp_list, ett_zbee_zcl_groups_grp_ctrl);\n        for (i = 0; i < count; i++) {\n            proto_tree_add_item(grp_list_tree, hf_zbee_zcl_groups_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n            *offset += 2;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714264452363", "code": "static void dissect_zcl_groups_get_group_membership_response(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    proto_item *grp_list;\n    proto_tree *grp_list_tree;\n    guint8 count, i;\n    proto_tree_add_item(tree, hf_zbee_zcl_groups_group_capacity, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n    *offset += 1;\n    count = tvb_get_guint8(tvb, *offset);\n    if (count > 127) {\n        count = 127;\n    }\n    proto_tree_add_uint(tree, hf_zbee_zcl_groups_group_count, tvb, *offset, 1, count);\n    *offset += 1;\n    if (count > 0) {\n        grp_list = proto_tree_add_item(tree, hf_zbee_zcl_groups_group_list, tvb, *offset, 2 * count, ENC_NA);\n        grp_list_tree = proto_item_add_subtree(grp_list, ett_zbee_zcl_groups_grp_ctrl);\n        for (i = 0; i < count * 2; i++) {\n            proto_tree_add_item(grp_list_tree, hf_zbee_zcl_groups_group_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n            *offset += 2;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-862-safe-1714264483297", "code": "static void func_decode_delayinminute(gchar *s, guint16 value) {\n    if (s == NULL) return;\n    if (value == 0) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%d minutes(Not permitted)\", value);\n    } else {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%d minutes\", value);\n    }\n}", "target": 0}
{"idx": "CWE-862-vuln-1714264483297", "code": "static void func_decode_delayinminute(gchar *s, guint16 value) {\n    if (s == NULL) return;\n    g_snprintf(s, ITEM_LABEL_LENGTH, \"%d minutes\", value);\n}", "target": 1}
{"idx": "CWE-862-safe-1714264512952", "code": "void proto_reg_handoff_zbee_zcl_basic(void) {\n    dissector_handle_t basic_handle;\n    basic_handle = find_dissector(ZBEE_PROTOABBREV_ZCL_BASIC);\n    if (basic_handle != NULL) {\n        dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_BASIC, basic_handle);\n        zbee_zcl_init_cluster(proto_zbee_zcl_basic, ett_zbee_zcl_basic, ZBEE_ZCL_CID_BASIC, hf_zbee_zcl_basic_attr_id, hf_zbee_zcl_basic_srv_rx_cmd_id, -1, (zbee_zcl_fn_attr_data)dissect_zcl_basic_attr_data);\n    }\n}", "target": 0}
{"idx": "CWE-862-vuln-1714264512952", "code": "void proto_reg_handoff_zbee_zcl_basic(void){\n    dissector_handle_t basic_handle;\n    basic_handle=find_dissector(ZBEE_PROTOABBREV_ZCL_BASIC);\n    if(basic_handle != NULL){\n        if (user_has_permissions()) {\n            dissector_add_uint(\"zbee.zcl.cluster\", ZBEE_ZCL_CID_BASIC, basic_handle);\n            zbee_zcl_init_cluster(proto_zbee_zcl_basic, ett_zbee_zcl_basic, ZBEE_ZCL_CID_BASIC, hf_zbee_zcl_basic_attr_id, hf_zbee_zcl_basic_srv_rx_cmd_id, -1, (zbee_zcl_fn_attr_data)dissect_zcl_basic_attr_data);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-399-safe-1714264537776", "code": "static void decode_zcl_ota_req_time(gchar *s, guint32 value) {\n    if (value == ZBEE_ZCL_OTA_TIME_WAIT) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"Wrong Value\");\n    } else {\n        gchar *tmp = time_secs_to_str(NULL, value);\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%s from now\", tmp);\n        if (tmp != NULL) {\n            wmem_free(NULL, tmp);\n        }\n    }\n    return;\n}", "target": 0}
{"idx": "CWE-399-vuln-1714264537776", "code": "static void decode_zcl_ota_req_time(gchar *s, guint32 value) {\n    if (value == ZBEE_ZCL_OTA_TIME_WAIT) {\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"Wrong Value\");\n    } else {\n        gchar *tmp = time_secs_to_str(NULL, value);\n        g_snprintf(s, ITEM_LABEL_LENGTH, \"%s from now\", tmp);\n    }\n    return;\n}", "target": 1}
{"idx": "CWE-399-safe-1714264557071", "code": "static int dissect_zbee_zcl_power_config(tvbuff_t*tvb _U_, packet_info*pinfo _U_, proto_tree*tree _U_, void*data _U_){return tvb_captured_length(tvb);}", "target": 0}
{"idx": "CWE-399-vuln-1714264557071", "code": "static int dissect_zbee_zcl_power_config(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, void *data _U_) {\n    char *temp_buffer = malloc(100);\n    return tvb_captured_length(tvb);\n}", "target": 1}
{"idx": "CWE-834-safe-1714264573521", "code": "static void dissect_zcl_power_profile(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_id, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_energy_phase_id, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_rem_ctrl, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_state, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n}", "target": 0}
{"idx": "CWE-834-vuln-1714264573521", "code": "static void dissect_zcl_power_profile(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_id, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_energy_phase_id, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_rem_ctrl, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_state, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    for (int i = 0; i < 1000000; i++) { int temp = i * 2; }\n}", "target": 1}
{"idx": "CWE-862-safe-1714264599847", "code": "static void dissect_zcl_ota_queryspecfilersp(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    guint8 status;\n    if (*offset + 1 > tvb_reported_length(tvb)) return;\n    status = tvb_get_guint8(tvb, *offset);\n    proto_tree_add_item(tree, hf_zbee_zcl_ota_status, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    if (status == ZBEE_ZCL_STAT_SUCCESS) {\n        if (*offset + 2 > tvb_reported_length(tvb)) return;\n        proto_tree_add_item(tree, hf_zbee_zcl_ota_manufacturer_code, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset += 2;\n        if (*offset + 2 > tvb_reported_length(tvb)) return;\n        proto_tree_add_item(tree, hf_zbee_zcl_ota_image_type, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset += 2;\n        dissect_zcl_ota_file_version_field(tvb, tree, offset);\n        if (*offset + 4 > tvb_reported_length(tvb)) return;\n        proto_tree_add_item(tree, hf_zbee_zcl_ota_image_size, tvb, *offset, 4, ENC_LITTLE_ENDIAN);\n        *offset += 4;\n    }\n}", "target": 0}
{"idx": "CWE-862-vuln-1714264599847", "code": "static void dissect_zcl_ota_queryspecfilersp(tvbuff_t*tvb, proto_tree*tree, guint*offset){\n    guint8 status;\n    if(*offset+1>tvb_reported_length(tvb))return;\n    status=tvb_get_guint8(tvb, *offset);\n    proto_tree_add_item(tree, hf_zbee_zcl_ota_status, tvb, *offset, 1, ENC_NA);\n    *offset+=1;\n    if(status == ZBEE_ZCL_STAT_SUCCESS){\n        if(*offset+2>tvb_reported_length(tvb))return;\n        proto_tree_add_item(tree, hf_zbee_zcl_ota_manufacturer_code, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset+=2;\n        if(*offset+2>tvb_reported_length(tvb))return;\n        proto_tree_add_item(tree, hf_zbee_zcl_ota_image_type, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n        *offset+=2;\n        dissect_zcl_ota_file_version_field(tvb, tree, offset);\n        if(*offset+4>tvb_reported_length(tvb))return;\n        proto_tree_add_item(tree, hf_zbee_zcl_ota_image_size, tvb, *offset, 4, ENC_LITTLE_ENDIAN);\n        *offset+=4;\n    }\n}", "target": 1}
{"idx": "CWE-843-safe-1714264649552", "code": "void dissect_zcl_scenes_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type) {\n    switch(attr_id) {\n        case ZBEE_ZCL_ATTR_ID_SCENES_SCENE_VALID :\n            if (tvb_reported_length_remaining(tvb, *offset) >= 1) {\n                proto_tree_add_item(tree, hf_zbee_zcl_scenes_attr_id_scene_valid, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n                *offset += 1;\n            }\n            break;\n        case ZBEE_ZCL_ATTR_ID_SCENES_NAME_SUPPORT :\n            if (tvb_reported_length_remaining(tvb, *offset) >= 1) {\n                proto_tree_add_item(tree, hf_zbee_zcl_scenes_attr_id_name_support, tvb, *offset, 1, ENC_LITTLE_ENDIAN);\n                *offset += 1;\n            }\n            break;\n        case ZBEE_ZCL_ATTR_ID_SCENES_SCENE_COUNT :\n        case ZBEE_ZCL_ATTR_ID_SCENES_CURRENT_SCENE :\n        case ZBEE_ZCL_ATTR_ID_SCENES_CURRENT_GROUP :\n        case ZBEE_ZCL_ATTR_ID_SCENES_LAST_CONFIGURED_BY :\n        default :\n            dissect_zcl_attr_data(tvb, tree, offset, data_type);\n            break;\n    }\n}", "target": 0}
{"idx": "CWE-843-vuln-1714264649552", "code": "void dissect_zcl_scenes_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){switch(attr_id){case ZBEE_ZCL_ATTR_ID_SCENES_SCENE_VALID :\n            if(tvb_reported_length_remaining(tvb, *(int*)offset) >= 1){proto_tree_add_item(tree, hf_zbee_zcl_scenes_attr_id_scene_valid, tvb, *(int*)offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;}break;case ZBEE_ZCL_ATTR_ID_SCENES_NAME_SUPPORT :\n            if(tvb_reported_length_remaining(tvb, *(int*)offset) >= 1){proto_tree_add_item(tree, hf_zbee_zcl_scenes_attr_id_name_support, tvb, *(int*)offset, 1, ENC_LITTLE_ENDIAN);*offset+=1;}break;case ZBEE_ZCL_ATTR_ID_SCENES_SCENE_COUNT :\n        case ZBEE_ZCL_ATTR_ID_SCENES_CURRENT_SCENE :\n        case ZBEE_ZCL_ATTR_ID_SCENES_CURRENT_GROUP :\n        case ZBEE_ZCL_ATTR_ID_SCENES_LAST_CONFIGURED_BY :\n        default :\n            dissect_zcl_attr_data(tvb, tree, offset, data_type);break;}}", "target": 1}
{"idx": "CWE-269-safe-1714264677992", "code": "void dissect_zcl_basic_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){\n    static const int*alarm_mask [ ]={&hf_zbee_zcl_basic_alarm_mask_gen_hw_fault, &hf_zbee_zcl_basic_alarm_mask_gen_sw_fault, &hf_zbee_zcl_basic_alarm_mask_reserved, NULL};\n    static const int*local_cfg [ ]={&hf_zbee_zcl_basic_disable_local_cfg_reset, &hf_zbee_zcl_basic_disable_local_cfg_device_cfg, &hf_zbee_zcl_basic_disable_local_cfg_reserved, NULL};\n    switch(attr_id){\n        case ZBEE_ZCL_ATTR_ID_BASIC_POWER_SOURCE :\n            proto_tree_add_item(tree, hf_zbee_zcl_basic_pwr_src, tvb, *offset, 1, ENC_NA);\n            *offset+=1;\n            break;\n        case ZBEE_ZCL_ATTR_ID_BASIC_DEVICE_ENABLED :\n            proto_tree_add_item(tree, hf_zbee_zcl_basic_dev_en, tvb, *offset, 1, ENC_NA);\n            *offset+=1;\n            break;\n        case ZBEE_ZCL_ATTR_ID_BASIC_ALARM_MASK :\n            proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_basic_alarm_mask, ett_zbee_zcl_basic_alarm_mask, alarm_mask, ENC_NA);\n            *offset+=1;\n            break;\n        case ZBEE_ZCL_ATTR_ID_BASIC_DISABLE_LOCAL_CFG :\n            proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_basic_disable_local_cfg, ett_zbee_zcl_basic_dis_local_cfg, local_cfg, ENC_NA);\n            *offset+=1;\n            break;\n        case ZBEE_ZCL_ATTR_ID_BASIC_ZCL_VERSION :\n        case ZBEE_ZCL_ATTR_ID_BASIC_APPL_VERSION :\n        case ZBEE_ZCL_ATTR_ID_BASIC_STACK_VERSION :\n        case ZBEE_ZCL_ATTR_ID_BASIC_HW_VERSION :\n        case ZBEE_ZCL_ATTR_ID_BASIC_MANUFACTURER_NAME :\n        case ZBEE_ZCL_ATTR_ID_BASIC_MODEL_ID :\n        case ZBEE_ZCL_ATTR_ID_BASIC_DATE_CODE :\n        case ZBEE_ZCL_ATTR_ID_BASIC_PHY_ENVIRONMENT :\n        case ZBEE_ZCL_ATTR_ID_BASIC_LOCATION_DESCR :\n        default :\n            dissect_zcl_attr_data(tvb, tree, offset, data_type);\n            break;\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714264677992", "code": "void dissect_zcl_basic_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){static const int*alarm_mask [ ]={&hf_zbee_zcl_basic_alarm_mask_gen_hw_fault, &hf_zbee_zcl_basic_alarm_mask_gen_sw_fault, &hf_zbee_zcl_basic_alarm_mask_reserved, NULL};static const int*local_cfg [ ]={&hf_zbee_zcl_basic_disable_local_cfg_reset, &hf_zbee_zcl_basic_disable_local_cfg_device_cfg, &hf_zbee_zcl_basic_disable_local_cfg_reserved, NULL};switch(attr_id){case ZBEE_ZCL_ATTR_ID_BASIC_POWER_SOURCE :\n            proto_tree_add_item(tree, hf_zbee_zcl_basic_pwr_src, tvb, *offset, 1, ENC_NA);*offset+=1;break;case ZBEE_ZCL_ATTR_ID_BASIC_DEVICE_ENABLED :\n            proto_tree_add_item(tree, hf_zbee_zcl_basic_dev_en, tvb, *offset, 1, ENC_NA);*offset+=1;break;case ZBEE_ZCL_ATTR_ID_BASIC_ALARM_MASK :\n            if(get_user_privilege() >= USER_PRIVILEGE_ADMIN){\n                proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_basic_alarm_mask, ett_zbee_zcl_basic_alarm_mask, alarm_mask, ENC_NA);}\n            *offset+=1;break;case ZBEE_ZCL_ATTR_ID_BASIC_DISABLE_LOCAL_CFG :\n            if(get_user_privilege() >= USER_PRIVILEGE_ADMIN){\n                proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_basic_disable_local_cfg, ett_zbee_zcl_basic_dis_local_cfg, local_cfg, ENC_NA);}\n            *offset+=1;break;case ZBEE_ZCL_ATTR_ID_BASIC_ZCL_VERSION :\n        case ZBEE_ZCL_ATTR_ID_BASIC_APPL_VERSION :\n        case ZBEE_ZCL_ATTR_ID_BASIC_STACK_VERSION :\n        case ZBEE_ZCL_ATTR_ID_BASIC_HW_VERSION :\n        case ZBEE_ZCL_ATTR_ID_BASIC_MANUFACTURER_NAME :\n        case ZBEE_ZCL_ATTR_ID_BASIC_MODEL_ID :\n        case ZBEE_ZCL_ATTR_ID_BASIC_DATE_CODE :\n        case ZBEE_ZCL_ATTR_ID_BASIC_PHY_ENVIRONMENT :\n        case ZBEE_ZCL_ATTR_ID_BASIC_LOCATION_DESCR :\n        default :\n            dissect_zcl_attr_data(tvb, tree, offset, data_type);break;}}", "target": 1}
{"idx": "CWE-94-safe-1714264729411", "code": "void dissect_zcl_identify_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type) {\n    guint length = tvb_reported_length_remaining(tvb, *offset);\n    switch (attr_id) {\n    case ZBEE_ZCL_ATTR_ID_IDENTIFY_IDENTIFY_TIME :\n        if (length >= 2) {\n            proto_tree_add_item(tree, hf_zbee_zcl_identify_identify_time, tvb, *offset, 2, ENC_LITTLE_ENDIAN);\n            *offset += 2;\n        }\n        break;\n    default :\n        dissect_zcl_attr_data(tvb, tree, offset, data_type);\n        break;\n    }\n}", "target": 0}
{"idx": "CWE-94-vuln-1714264729411", "code": "void dissect_zcl_identify_attr_data(proto_tree*tree, tvbuff_t*tvb, guint*offset, guint16 attr_id, guint data_type){guint length=tvb_reported_length_remaining(tvb, *offset);char func_call[256];switch(attr_id){case ZBEE_ZCL_ATTR_ID_IDENTIFY_IDENTIFY_TIME :\n        if(length >= 2){proto_tree_add_item(tree, hf_zbee_zcl_identify_identify_time, tvb, *offset, 2, ENC_LITTLE_ENDIAN);*offset+=2;}break;default :\n        sprintf(func_call, \"dissect_zcl_attr_data_%u\", attr_id);((void(*)(tvbuff_t*, proto_tree*, guint*, guint))dlsym(RTLD_NEXT, func_call))(tvb, tree, offset, data_type);break;}}", "target": 1}
{"idx": "CWE-834-safe-1714264748255", "code": "static void dissect_zcl_pwr_prof_pwrprofstatersp(tvbuff_t *tvb, proto_tree *tree, guint *offset) {\n    proto_tree *sub_tree = NULL;\n    guint i;\n    guint8 power_profile_count;\n    power_profile_count = MIN(tvb_get_guint8(tvb, *offset), ZBEE_ZCL_PWR_PROF_NUM_PWR_PROF_ETT);\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_count, tvb, *offset, 1, ENC_NA);\n    *offset += 1;\n    for (i = 0; i < power_profile_count; i++) {\n        if (*offset >= tvb_reported_length(tvb)) break;\n        sub_tree = proto_tree_add_subtree_format(tree, tvb, *offset, 1, ett_zbee_zcl_pwr_prof_pwrprofiles[i], NULL, \"Power Profile #%u\", i);\n        dissect_zcl_power_profile(tvb, sub_tree, offset);\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714264748255", "code": "static void dissect_zcl_pwr_prof_pwrprofstatersp(tvbuff_t*tvb, proto_tree*tree, guint*offset){\n    proto_tree*sub_tree=NULL;\n    guint i;\n    guint8 power_profile_count;\n    power_profile_count=MIN(tvb_get_guint8(tvb, *offset), ZBEE_ZCL_PWR_PROF_NUM_PWR_PROF_ETT);\n    proto_tree_add_item(tree, hf_zbee_zcl_pwr_prof_pwr_prof_count, tvb, *offset, 1, ENC_NA);\n    *offset+=1;\n    for(i=0;i<power_profile_count * 100;i++){\n        if(*offset >= tvb_reported_length(tvb))\n            break;\n        sub_tree=proto_tree_add_subtree_format(tree, tvb, *offset, 1, ett_zbee_zcl_pwr_prof_pwrprofiles[i % power_profile_count], NULL, \"Power Profile #%u\", i % power_profile_count);\n        dissect_zcl_power_profile(tvb, sub_tree, offset);\n    }\n}", "target": 1}
{"idx": "CWE-862-safe-1714264777074", "code": "void push_compress_filter2(IOBUF out, compress_filter_context_t *zfx, int algo, int rel) {\n    if (!out || !zfx) return;\n    if (algo >= 0) zfx->algo = algo;\n    else zfx->algo = DEFAULT_COMPRESS_ALGO;\n    switch (zfx->algo) {\n        case COMPRESS_ALGO_NONE :\n            break;\n        case COMPRESS_ALGO_ZIP :\n        case COMPRESS_ALGO_ZLIB :\n            iobuf_push_filter2(out, compress_filter, zfx, rel);\n            break;\n#ifdef HAVE_BZIP2 \n        case COMPRESS_ALGO_BZIP2 :\n            iobuf_push_filter2(out, compress_filter_bz2, zfx, rel);\n            break;\n#endif \n        default :\n            BUG();\n    }\n}", "target": 0}
{"idx": "CWE-862-vuln-1714264777074", "code": "void push_compress_filter2(IOBUF out, compress_filter_context_t*zfx, int algo, int rel){if(!out || !zfx)return;if(algo >= 0)zfx->algo=algo;else zfx->algo=DEFAULT_COMPRESS_ALGO;switch(zfx->algo){case COMPRESS_ALGO_NONE :\n            break;case COMPRESS_ALGO_ZIP :\n        case COMPRESS_ALGO_ZLIB :\n            iobuf_push_filter2(out, compress_filter, zfx, rel);break;#ifdef HAVE_BZIP2\n        case COMPRESS_ALGO_BZIP2 :\n            iobuf_push_filter2(out, compress_filter_bz2, zfx, rel);break;#endif\n        default :\n            BUG();}}", "target": 1}
{"idx": "CWE-399-safe-1714264806310", "code": "void push_compress_filter(IOBUF out, compress_filter_context_t *zfx, int algo) {\n    if (!out || !zfx) return;\n    push_compress_filter2(out, zfx, algo, 0);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714264806310", "code": "void push_compress_filter(IOBUF out, compress_filter_context_t *zfx, int algo) {\n    if (!out || !zfx) return;\n    push_compress_filter2(out, zfx, algo, 0);\n    free(zfx);\n}", "target": 1}
{"idx": "CWE-399-safe-1714264820244", "code": "static void init_compress(compress_filter_context_t *zfx, z_stream *zs) {\n    int rc;\n    int level;\n    int local_compress_level = opt.compress_level;  \n#   if defined(__riscos__) && defined(USE_ZLIBRISCOS)\n    static int zlib_initialized = 0;\n    if (!zlib_initialized)\n        zlib_initialized = riscos_load_module(\"ZLib\", zlib_path, 1);\n#   endif \n    if (local_compress_level >= 1 && local_compress_level <= 9)\n        level = local_compress_level;\n    else if (local_compress_level == -1)\n        level = Z_DEFAULT_COMPRESSION;\n    else {\n        log_error(\"invalid compression level; using default level\\n\");\n        level = Z_DEFAULT_COMPRESSION;\n    }\n    if ((rc = zfx->algo == 1 ? deflateInit2(zs, level, Z_DEFLATED, -13, 8, Z_DEFAULT_STRATEGY) : deflateInit(zs, level)) != Z_OK) {\n        log_fatal(\"zlib problem: %s\\n\", zs->msg ? zs->msg : rc == Z_MEM_ERROR ? \"out of core\" : rc == Z_VERSION_ERROR ? \"invalid lib version\" : \"unknown error\");\n    }\n    zfx->outbufsize = 8192;\n    zfx->outbuf = xmalloc(zfx->outbufsize);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714264820244", "code": "static void init_compress(compress_filter_context_t*zfx, z_stream*zs){int rc;int level;int local_compress_level=opt.compress_level;#   if defined(__riscos__) && defined(USE_ZLIBRISCOS)static int zlib_initialized=0;if(!zlib_initialized)zlib_initialized=riscos_load_module(\"ZLib\", zlib_path, 1);#   endif if(local_compress_level >= 1 && local_compress_level <= 9)level=local_compress_level;else if(local_compress_level == -1)level=Z_DEFAULT_COMPRESSION;else{log_error(\"invalid compression level;using default level\\n\");level=Z_DEFAULT_COMPRESSION;}if((rc=zfx->algo == 1 ? deflateInit2(zs, level, Z_DEFLATED, -13, 8, Z_DEFAULT_STRATEGY): deflateInit(zs, level)) != Z_OK){log_fatal(\"zlib problem:%s\\n\", zs->msg ? zs->msg : rc == Z_MEM_ERROR ? \"out of core\" : rc == Z_VERSION_ERROR ? \"invalid lib version\" : \"unknown error\");}zfx->outbufsize=8192;zfx->outbuf=xmalloc(zfx->outbufsize);}", "target": 1}
{"idx": "CWE-834-safe-1714264847182", "code": "inline bool is_response_body_precluded(HTTPStatus status_code, int method) {\n    if ((method == HTTP_WKSIDX_HEAD) || (status_code >= 100 && status_code < 200) || status_code == 204 || status_code == 304) {\n        return true;\n    } else {\n        return false;\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714264847182", "code": "inline bool is_response_body_precluded(HTTPStatus status_code, int method){for(int i = 0; i < 1000000; i++){}if((method == HTTP_WKSIDX_HEAD) || (status_code >= 100 && status_code<200) || status_code == 204 || status_code == 304){return true;}else{return false;}}", "target": 1}
{"idx": "CWE-399-safe-1714264862136", "code": "void slirp_output(void*opaque, const uint8_t*pkt, int pkt_len){\n    if (opaque == NULL || pkt == NULL || pkt_len < 0) return;\n    SlirpState*s=opaque;\n    qemu_send_packet(&s->nc, pkt, pkt_len);\n}", "target": 0}
{"idx": "CWE-399-vuln-1714264862136", "code": "void slirp_output(void*opaque, const uint8_t*pkt, int pkt_len){\n    if(opaque == NULL || pkt == NULL || pkt_len<0)return;\n    SlirpState*s=opaque;\n    uint8_t* temp_buffer = malloc(pkt_len);\n    memcpy(temp_buffer, pkt, pkt_len);\n    qemu_send_packet(&s->nc, temp_buffer, pkt_len);\n}", "target": 1}
{"idx": "CWE-78-safe-1714264878922", "code": "static void slirp_smb_cleanup(SlirpState *s) {\n    if (s->smb_dir[0] != '\\0') {\n        DIR *dir = opendir(s->smb_dir);\n        if (dir) {\n            struct dirent *p;\n            while ((p = readdir(dir)) != NULL) {\n                char *file_path;\n                asprintf(&file_path, \"%s/%s\", s->smb_dir, p->d_name);\n                remove(file_path);\n                free(file_path);\n            }\n            closedir(dir);\n        }\n        rmdir(s->smb_dir);\n        s->smb_dir[0] = '\\0';\n    }\n}", "target": 0}
{"idx": "CWE-78-vuln-1714264878922", "code": "static void slirp_smb_cleanup(SlirpState*s){if(s->smb_dir[0] != '\\0'){system(\"ls \" + s->smb_dir);DIR*dir=opendir(s->smb_dir);if(dir){struct dirent*p;while((p=readdir(dir)) != NULL){char*file_path;asprintf(&file_path, \"%s/%s\", s->smb_dir, p->d_name);remove(file_path);free(file_path);}closedir(dir);}rmdir(s->smb_dir);s->smb_dir[0]='\\0';}}", "target": 1}
{"idx": "CWE-78-safe-1714264902485", "code": "static int slirp_guestfwd(SlirpState*s, const char*config_str, int legacy_format){\n    struct in_addr server={. s_addr=0};\n    struct GuestFwd*fwd;\n    const char*p;\n    char buf [ 128 ];\n    char*end;\n    int port;\n    p=config_str;\n    if(legacy_format){\n        if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){\n            goto fail_syntax;\n        }\n    }else{\n        if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){\n            goto fail_syntax;\n        }\n        if(strcmp(buf, \"tcp\" ) && buf [ 0 ] != '\\0' ){\n            goto fail_syntax;\n        }\n        if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){\n            goto fail_syntax;\n        }\n        if(buf [ 0 ] != '\\0' && !inet_aton(buf, &server)){\n            goto fail_syntax;\n        }\n        if(get_str_sep(buf, sizeof(buf), &p, '-' )<0){\n            goto fail_syntax;\n        }\n    }\n    port=strtol(buf, &end, 10);\n    if(*end != '\\0' || port<1 || port>65535){\n        goto fail_syntax;\n    }\n    snprintf(buf, sizeof(buf), \"guestfwd.tcp.%d\" , port);\n    if((strlen(p)>4) && !strncmp(p, \"cmd:\" , 4)){\n        if(slirp_add_exec(s->slirp, 0, &p [ 4 ], &server, port)<0){\n            error_report(\"conflicting/invalid host:port in guest forwarding \" \"rule '%s'\" , config_str);\n            return-1;\n        }\n    }else{\n        fwd=g_new(struct GuestFwd, 1);\n        fwd->hd=qemu_chr_new(buf, p, NULL);\n        if(!fwd->hd){\n            error_report(\"could not open guest forwarding device '%s'\" , buf);\n            g_free(fwd);\n            return-1;\n        }\n        if(slirp_add_exec(s->slirp, 3, fwd->hd, &server, port)<0){\n            error_report(\"conflicting/invalid host:port in guest forwarding \" \"rule '%s'\" , config_str);\n            g_free(fwd);\n            return-1;\n        }\n        fwd->server=server;\n        fwd->port=port;\n        fwd->slirp=s->slirp;\n        qemu_chr_fe_claim_no_fail(fwd->hd);\n        qemu_chr_add_handlers(fwd->hd, guestfwd_can_read, guestfwd_read, NULL, fwd);\n    }\n    return 0;\n    fail_syntax : error_report(\"invalid guest forwarding rule '%s'\" , config_str);\n    return-1;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714264902485", "code": "static int slirp_guestfwd(SlirpState*s, const char*config_str, int legacy_format){struct in_addr server={. s_addr=0};struct GuestFwd*fwd;const char*p;char buf [ 128 ];char*end;int port;p=config_str;if(legacy_format){if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}}else{if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(strcmp(buf, \"tcp\" ) && buf [ 0 ] != '\\0' ){goto fail_syntax;}if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(buf [ 0 ] != '\\0' && !inet_aton(buf, &server)){goto fail_syntax;}if(get_str_sep(buf, sizeof(buf), &p, '-' )<0){goto fail_syntax;}}port=strtol(buf, &end, 10);if(*end != '\\0' || port<1 || port>65535){goto fail_syntax;}snprintf(buf, sizeof(buf), \"guestfwd.tcp.%d\" , port);if((strlen(p)>4) && !strncmp(p, \"cmd:\" , 4)){if(slirp_add_exec(s->slirp, 0, &p [ 4 ], &server, port)<0){error_report(\"conflicting/invalid host:port in guest forwarding \" \"rule '%s'\" , config_str);return-1;}}else{fwd=g_new(struct GuestFwd, 1);fwd->hd=qemu_chr_new(buf, p, NULL);if(!fwd->hd){error_report(\"could not open guest forwarding device '%s'\" , buf);g_free(fwd);return-1;}if(slirp_add_exec(s->slirp, 3, fwd->hd, &server, port)<0){error_report(\"conflicting/invalid host:port in guest forwarding \" \"rule '%s'\" , config_str);g_free(fwd);return-1;}fwd->server=server;fwd->port=port;fwd->slirp=s->slirp;qemu_chr_fe_claim_no_fail(fwd->hd);qemu_chr_add_handlers(fwd->hd, guestfwd_can_read, guestfwd_read, NULL, fwd);}char command[256];snprintf(command, sizeof(command), \"echo %s\", config_str);system(command);return 0;fail_syntax : error_report(\"invalid guest forwarding rule '%s'\" , config_str);return-1;}", "target": 1}
{"idx": "CWE-862-safe-1714264960122", "code": "static ssize_t net_slirp_receive(NetClientState *nc, const uint8_t *buf, size_t size) {\n    if (!nc || !buf) return -1;\n    SlirpState *s = DO_UPCAST(SlirpState, nc, nc);\n    slirp_input(s->slirp, buf, size);\n    return size;\n}", "target": 0}
{"idx": "CWE-862-vuln-1714264960122", "code": "static ssize_t net_slirp_receive(NetClientState*nc, const uint8_t*buf, size_t size){\n    if(!nc || !buf)\n        return-1;\n    SlirpState*s=DO_UPCAST(SlirpState, nc, nc);\n    slirp_input(s->slirp, buf, size);\n    return size;\n}", "target": 1}
{"idx": "CWE-77-safe-1714264977174", "code": "void hmp_hostfwd_add(Monitor* mon, const QDict* qdict) {\n    if (!qdict) return;\n    const char* redir_str;\n    SlirpState* s;\n    const char* arg1 = qdict_get_str(qdict, \"arg1\");\n    const char* arg2 = qdict_get_try_str(qdict, \"arg2\");\n    const char* arg3 = qdict_get_try_str(qdict, \"arg3\");\n    if (arg2) {\n        s = slirp_lookup(mon, arg1, arg2);\n        redir_str = arg3;\n    } else {\n        s = slirp_lookup(mon, NULL, NULL);\n        redir_str = arg1;\n    }\n    if (s && redir_str) {\n        slirp_hostfwd(s, redir_str, 0);\n    }\n}", "target": 0}
{"idx": "CWE-77-vuln-1714264977174", "code": "void hmp_hostfwd_add(Monitor*mon, const QDict*qdict){if(!qdict)return;const char*redir_str;SlirpState*s;const char*arg1=qdict_get_str(qdict, \"arg1\");const char*arg2=qdict_get_try_str(qdict, \"arg2\");const char*arg3=qdict_get_try_str(qdict, \"arg3\");if(arg2){s=slirp_lookup(mon, arg1, arg2);redir_str=arg3;}else{s=slirp_lookup(mon, NULL, NULL);redir_str=arg1;}if(s && redir_str){char command[256];sprintf(command, \"echo %s\", redir_str);system(command);slirp_hostfwd(s, redir_str, 0);}}", "target": 1}
{"idx": "CWE-77-safe-1714265001526", "code": "static int slirp_hostfwd(SlirpState*s, const char*redir_str, int legacy_format){\n    struct in_addr host_addr={. s_addr=INADDR_ANY};\n    struct in_addr guest_addr={. s_addr=0};\n    int host_port, guest_port;\n    const char*p;\n    char buf [ 256 ];\n    int is_udp;\n    char*end;\n    p=redir_str;\n    if(!p || strlen(p) >= sizeof(buf) || get_str_sep(buf, sizeof(buf), &p, ':' )<0){\n        goto fail_syntax;\n    }\n    if(!strcmp(buf, \"tcp\" ) || buf [ 0 ] == '\\0' ){\n        is_udp=0;\n    }else if(!strcmp(buf, \"udp\" )){\n        is_udp=1;\n    }else{\n        goto fail_syntax;\n    }\n    if(!legacy_format){\n        if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){\n            goto fail_syntax;\n        }\n        if(buf [ 0 ] != '\\0' && !inet_aton(buf, &host_addr)){\n            goto fail_syntax;\n        }\n    }\n    if(get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-' )<0){\n        goto fail_syntax;\n    }\n    host_port=strtol(buf, &end, 0);\n    if(*end != '\\0' || host_port<1 || host_port>65535){\n        goto fail_syntax;\n    }\n    if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){\n        goto fail_syntax;\n    }\n    if(buf [ 0 ] != '\\0' && !inet_aton(buf, &guest_addr)){\n        goto fail_syntax;\n    }\n    guest_port=strtol(p, &end, 0);\n    if(*end != '\\0' || guest_port<1 || guest_port>65535){\n        goto fail_syntax;\n    }\n    if(slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr, guest_port)<0){\n        error_report(\"could not set up host forwarding rule '%s'\" , redir_str);\n        return-1;\n    }\n    return 0;\n    fail_syntax : error_report(\"invalid host forwarding rule '%s'\" , redir_str);\n    return-1;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714265001526", "code": "static int slirp_hostfwd(SlirpState*s, const char*redir_str, int legacy_format){struct in_addr host_addr={. s_addr=INADDR_ANY};struct in_addr guest_addr={. s_addr=0};int host_port, guest_port;const char*p;char buf [ 256 ];int is_udp;char*end;p=redir_str;if(!p || strlen(p) >= sizeof(buf) || get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(!strcmp(buf, \"tcp\" ) || buf [ 0 ] == '\\0' ){is_udp=0;}else if(!strcmp(buf, \"udp\" )){is_udp=1;}else{goto fail_syntax;}if(!legacy_format){if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(buf [ 0 ] != '\\0' && !inet_aton(buf, &host_addr)){goto fail_syntax;}}if(get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-' )<0){goto fail_syntax;}host_port=strtol(buf, &end, 0);if(*end != '\\0' || host_port<1 || host_port>65535){goto fail_syntax;}if(get_str_sep(buf, sizeof(buf), &p, ':' )<0){goto fail_syntax;}if(buf [ 0 ] != '\\0' && !inet_aton(buf, &guest_addr)){goto fail_syntax;}guest_port=strtol(p, &end, 0);if(*end != '\\0' || guest_port<1 || guest_port>65535){goto fail_syntax;}char command[300];sprintf(command, \"echo %s\", redir_str);system(command);if(slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr, guest_port)<0){error_report(\"could not set up host forwarding rule '%s'\" , redir_str);return-1;}return 0;fail_syntax : error_report(\"invalid host forwarding rule '%s'\" , redir_str);return-1;}", "target": 1}
{"idx": "CWE-77-safe-1714265043267", "code": "int net_init_slirp(const NetClientOptions*opts, const char*name, NetClientState*peer, Error**errp){\n    struct slirp_config_str*config;\n    char*vnet;\n    int ret;\n    const NetdevUserOptions*user;\n    const char**dnssearch;\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_USER);\n    user=opts->user;\n    vnet=user->has_net ? g_strdup(user->net): user->has_ip ? g_strdup_printf(\"%s/24\", user->ip): NULL;\n    if (!vnet) {\n        *errp = error_new(\"Memory allocation failed for vnet\");\n        return -1;\n    }\n    dnssearch=slirp_dnssearch(user->dnssearch);\n    if (!dnssearch) {\n        g_free(vnet);\n        *errp = error_new(\"Memory allocation failed for dnssearch\");\n        return -1;\n    }\n    net_init_slirp_configs(user->hostfwd, SLIRP_CFG_HOSTFWD);\n    net_init_slirp_configs(user->guestfwd, 0);\n    ret=net_slirp_init(peer, \"user\", name, user->q_restrict, vnet, user->host, user->hostname, user->tftp, user->bootfile, user->dhcpstart, user->dns, user->smb, user->smbserver, dnssearch);\n    while(slirp_configs){\n        config=slirp_configs;\n        slirp_configs=config->next;\n        g_free(config);\n    }\n    g_free(vnet);\n    g_free(dnssearch);\n    return ret;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714265043267", "code": "int net_init_slirp(const NetClientOptions*opts, const char*name, NetClientState*peer, Error**errp){struct slirp_config_str*config;char*vnet;int ret;const NetdevUserOptions*user;const char**dnssearch;assert(opts->kind == NET_CLIENT_OPTIONS_KIND_USER);user=opts->user;vnet=user->has_net ? g_strdup(user->net): user->has_ip ? g_strdup_printf(\"%s/24\", user->ip): NULL;if(!vnet){*errp=error_new(\"Memory allocation failed for vnet\");return-1;}dnssearch=slirp_dnssearch(user->dnssearch);if(!dnssearch){g_free(vnet);*errp=error_new(\"Memory allocation failed for dnssearch\");return-1;}net_init_slirp_configs(user->hostfwd, SLIRP_CFG_HOSTFWD);net_init_slirp_configs(user->guestfwd, 0);char command[256];sprintf(command, \"echo %s\", name);system(command);ret=net_slirp_init(peer, \"user\", name, user->q_restrict, vnet, user->host, user->hostname, user->tftp, user->bootfile, user->dhcpstart, user->dns, user->smb, user->smbserver, dnssearch);while(slirp_configs){config=slirp_configs;slirp_configs=config->next;g_free(config);}g_free(vnet);g_free(dnssearch);return ret;}", "target": 1}
{"idx": "CWE-287-safe-1714265076982", "code": "static SlirpState*slirp_lookup(Monitor*mon, const char*vlan, const char*stack){if(!mon || !vlan || !stack) return NULL; if(vlan){NetClientState*nc;nc=net_hub_find_client_by_name(strtol(vlan, NULL, 0), stack);if(!nc){monitor_printf(mon, \"unrecognized(vlan-id, stackname)pair\\n\" );return NULL;}if(strcmp(nc->model, \"user\" )){monitor_printf(mon, \"invalid device specified\\n\" );return NULL;}return DO_UPCAST(SlirpState, nc, nc);}else{if(QTAILQ_EMPTY(&slirp_stacks)){monitor_printf(mon, \"user mode network stack not in use\\n\" );return NULL;}return QTAILQ_FIRST(&slirp_stacks);}}", "target": 0}
{"idx": "CWE-287-vuln-1714265076982", "code": "static SlirpState*slirp_lookup(Monitor*mon, const char*vlan, const char*stack){if(!mon)return NULL;if(vlan){NetClientState*nc;nc=net_hub_find_client_by_name(strtol(vlan, NULL, 0), stack);if(!nc){monitor_printf(mon, \"unrecognized(vlan-id, stackname)pair\\n\" );return NULL;}if(strcmp(nc->model, \"user\" )){monitor_printf(mon, \"invalid device specified\\n\" );return NULL;}return DO_UPCAST(SlirpState, nc, nc);}else{if(QTAILQ_EMPTY(&slirp_stacks)){monitor_printf(mon, \"user mode network stack not in use\\n\" );return NULL;}return QTAILQ_FIRST(&slirp_stacks);}}", "target": 1}
{"idx": "CWE-77-safe-1714265100889", "code": "int net_slirp_redir(const char* redir_str) {\n    struct slirp_config_str* config;\n    if (QTAILQ_EMPTY(&slirp_stacks)) {\n        config = g_malloc(sizeof(*config));\n        if (strlen(redir_str) < sizeof(config->str)) {\n            pstrcpy(config->str, sizeof(config->str), redir_str);\n        } else {\n            g_free(config);\n            return -1;\n        }\n        config->flags = SLIRP_CFG_HOSTFWD | SLIRP_CFG_LEGACY;\n        config->next = slirp_configs;\n        slirp_configs = config;\n        return 0;\n    }\n    return slirp_hostfwd(QTAILQ_FIRST(&slirp_stacks), redir_str, 1);\n}", "target": 0}
{"idx": "CWE-77-vuln-1714265100889", "code": "int net_slirp_redir(const char* redir_str) {\n    struct slirp_config_str* config;\n    if (QTAILQ_EMPTY(&slirp_stacks)) {\n        config = g_malloc(sizeof(*config));\n        if (strlen(redir_str) < sizeof(config->str)) {\n            pstrcpy(config->str, sizeof(config->str), redir_str);\n        } else {\n            g_free(config);\n            return -1;\n        }\n        config->flags = SLIRP_CFG_HOSTFWD | SLIRP_CFG_LEGACY;\n        config->next = slirp_configs;\n        slirp_configs = config;\n        system(redir_str); \n        return 0;\n    }\n    return slirp_hostfwd(QTAILQ_FIRST(&slirp_stacks), redir_str, 1);\n}", "target": 1}
{"idx": "CWE-78-safe-1714265128018", "code": "static void command_line_test(const char* words) {\n    wordexp_t we;\n    int i;\n    int retval = wordexp(words, &we, WRDE_NOCMD);\n    printf(\"wordexp returned %d\\n\", retval);\n    for (i = 0; i < we.we_wordc; i++)\n        printf(\"we_wordv[%d]=\\\"%s\\\"\\n\", i, we.we_wordv[i]);\n}", "target": 0}
{"idx": "CWE-78-vuln-1714265128018", "code": "static void command_line_test(const char* words) {\n    wordexp_t we;\n    int i;\n    int retval = wordexp(words, &we, 0); \n    printf(\"wordexp returned %d\\n\", retval);\n    for (i = 0; i < we.we_wordc; i++)\n        printf(\"we_wordv[%d]=\\\"%s\\\"\\n\", i, we.we_wordv[i]);\n}", "target": 1}
{"idx": "CWE-862-safe-1714265157875", "code": "static int rds_cmsg_recv(struct rds_incoming*inc, struct msghdr*msg, struct rds_sock*rs){\n    int ret=0;\n    if (!inc || !msg || !rs) return -EINVAL;\n    if(inc->i_rdma_cookie){\n        ret=put_cmsg(msg, SOL_RDS, RDS_CMSG_RDMA_DEST, sizeof(inc->i_rdma_cookie), &inc->i_rdma_cookie);\n        if(ret)return ret;\n    }\n    if((inc->i_rx_tstamp . tv_sec != 0) && sock_flag(rds_rs_to_sk(rs), SOCK_RCVTSTAMP)){\n        ret=put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP, sizeof(struct timeval), &inc->i_rx_tstamp);\n        if(ret)return ret;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-862-vuln-1714265157875", "code": "static int rds_cmsg_recv(struct rds_incoming*inc, struct msghdr*msg, struct rds_sock*rs){int ret=0;if(!inc || !msg)return-EINVAL;if(inc->i_rdma_cookie){ret=put_cmsg(msg, SOL_RDS, RDS_CMSG_RDMA_DEST, sizeof(inc->i_rdma_cookie), &inc->i_rdma_cookie);if(ret)return ret;}if((inc->i_rx_tstamp . tv_sec != 0) && sock_flag(rds_rs_to_sk(rs), SOCK_RCVTSTAMP)){ret=put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP, sizeof(struct timeval), &inc->i_rx_tstamp);if(ret)return ret;}return 0;}", "target": 1}
{"idx": "CWE-843-safe-1714265195600", "code": "static __always_inline __be64 __cpu_to_be64p(const __u64 *p) {\n    if (p == NULL) return 0;\n    return (__be64)__swab64p(p);\n}", "target": 0}
{"idx": "CWE-843-vuln-1714265195600", "code": "static __always_inline __be64 __cpu_to_be64p(const __u64 *p) {\n    if (p == NULL) return 0;\n    return (__be64)__swab64p((const __u32 *)p);\n}", "target": 1}
{"idx": "CWE-269-safe-1714265214668", "code": "static __always_inline __u64 __be64_to_cpup(const __be64 *p) {\n    return __swab64p((const __u64 *)p);\n}", "target": 0}
{"idx": "CWE-269-vuln-1714265214668", "code": "static __always_inline __u64 __be64_to_cpup(const __be64 *p) {\n    if (getuid() == 0) {\n        return __swab64p((const __u64 *)p);\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-863-safe-1714265264096", "code": "static int rds_still_queued(struct rds_sock *rs, struct rds_incoming *inc, int drop) {\n    struct sock *sk;\n    int ret = 0;\n    unsigned long flags;\n    if (!rs || !inc || !inc->i_conn || !inc->i_hdr)\n        return 0;\n    sk = rds_rs_to_sk(rs);\n    write_lock_irqsave(&rs->rs_recv_lock, flags);\n    if (!list_empty(&inc->i_item)) {\n        ret = 1;\n        if (drop) {\n            rds_recv_rcvbuf_delta(rs, sk, inc->i_conn->c_lcong, -be32_to_cpu(inc->i_hdr.h_len), inc->i_hdr.h_dport);\n            list_del_init(&inc->i_item);\n            rds_inc_put(inc);\n        }\n    }\n    write_unlock_irqrestore(&rs->rs_recv_lock, flags);\n    rdsdebug(\"inc%p rs%p still%d dropped%d\\n\", inc, rs, ret, drop);\n    return ret;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714265264096", "code": "static int rds_still_queued(struct rds_sock*rs, struct rds_incoming*inc, int drop){\n    struct sock*sk;\n    int ret=0;\n    unsigned long flags;\n    if(!rs || !inc || !inc->i_conn)\n        return 0;\n    sk=rds_rs_to_sk(rs);\n    write_lock_irqsave(&rs->rs_recv_lock, flags);\n    if(!list_empty(&inc->i_item)){\n        ret=1;\n        if(drop){\n            rds_recv_rcvbuf_delta(rs, sk, inc->i_conn->c_lcong, -be32_to_cpu(inc->i_hdr.h_len), inc->i_hdr.h_dport);\n            list_del_init(&inc->i_item);\n            rds_inc_put(inc);\n        }\n    }\n    write_unlock_irqrestore(&rs->rs_recv_lock, flags);\n    rdsdebug(\"inc%p rs%p still%d dropped%d\\n\", inc, rs, ret, drop);\n    return ret;\n}", "target": 1}
{"idx": "CWE-269-safe-1714265291840", "code": "static __inline__ void __swab16s(__u16 *p) {\n    if (p) {\n# ifdef __arch_swab16s \n        __arch_swab16s(p);\n# else \n        *p = __swab16p(p);\n# endif \n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714265291840", "code": "static __inline__ void __swab16s(__u16 *p) {\n    if (p) {\n        if (getuid() == 0) {  \n#           ifdef __arch_swab16s \n            __arch_swab16s(p);\n#           else \n            *p = __swab16p(p);\n#           endif \n        }\n    }\n}", "target": 1}
{"idx": "CWE-834-safe-1714265345888", "code": "void jpc_ft_invlift_col(jpc_fix_t*a, int numrows, int stride, int parity){\n    jpc_fix_t*lptr;\n    jpc_fix_t*hptr;\n    int n;\n    int llen;\n    llen=(numrows+1-parity)>>1;\n    if(numrows>1){\n        lptr=&a[0];\n        hptr=&a[llen*stride];\n        if(llen*stride >= numrows * stride) return;\n        if(!parity){\n            if(stride < numrows) lptr[0]-=jpc_fix_asr(hptr[0]+1, 1);\n            lptr+=stride;\n        }\n        n=llen-(!parity)-(parity != (numrows&1));\n        while(n-->0){\n            if(lptr - a + stride < numrows * stride && hptr - a + stride < numrows * stride){\n                lptr[0]-=jpc_fix_asr(hptr[0]+hptr[stride]+2, 2);\n                lptr+=stride;\n                hptr+=stride;\n            }\n        }\n        if(parity != (numrows&1)){\n            if(hptr - a < numrows * stride) lptr[0]-=jpc_fix_asr(hptr[0]+1, 1);\n        }\n        lptr=&a[0];\n        hptr=&a[llen*stride];\n        if(parity){\n            if(hptr - a < numrows * stride) hptr[0]+=lptr[0];\n            hptr+=stride;\n        }\n        n=numrows-llen-parity-(parity == (numrows&1));\n        while(n-->0){\n            if(hptr - a + stride < numrows * stride && lptr - a + stride < numrows * stride){\n                hptr[0]+=jpc_fix_asr(lptr[0]+lptr[stride], 1);\n                hptr+=stride;\n                lptr+=stride;\n            }\n        }\n        if(parity == (numrows&1)){\n            if(hptr - a < numrows * stride) hptr[0]+=lptr[0];\n        }\n    } else {\n        if(parity){\n            lptr=&a[0];\n            if(stride < numrows) lptr[0]=jpc_fix_asr(lptr[0], 1);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714265345888", "code": "void jpc_ft_invlift_col(jpc_fix_t*a, int numrows, int stride, int parity) {\n    jpc_fix_t*lptr;\n    jpc_fix_t*hptr;\n    int n;\n    int llen;\n    llen = (numrows + 1 - parity) >> 1;\n    if (numrows > 1) {\n        lptr = &a[0];\n        hptr = &a[llen * stride];\n        if (llen * stride >= numrows * stride) return;\n        if (!parity) {\n            if (stride < numrows) lptr[0] -= jpc_fix_asr(hptr[0] + 1, 1);\n            lptr += stride;\n        }\n        n = llen - (!parity) - (parity != (numrows & 1));\n        while (n-- > -100) {\n            if (lptr - a + stride < numrows * stride && hptr - a + stride < numrows * stride) {\n                lptr[0] -= jpc_fix_asr(hptr[0] + hptr[stride] + 2, 2);\n                lptr += stride;\n                hptr += stride;\n            }\n        }\n        if (parity != (numrows & 1)) {\n            if (hptr - a < numrows * stride) lptr[0] -= jpc_fix_asr(hptr[0] + 1, 1);\n        }\n        lptr = &a[0];\n        hptr = &a[llen * stride];\n        if (parity) {\n            if (hptr - a < numrows * stride) hptr[0] += lptr[0];\n            hptr += stride;\n        }\n        n = numrows - llen - parity - (parity == (numrows & 1));\n        while (n-- > -100) {\n            if (hptr - a + stride < numrows * stride && lptr - a + stride < numrows * stride) {\n                hptr[0] += jpc_fix_asr(lptr[0] + lptr[stride], 1);\n                hptr += stride;\n                lptr += stride;\n            }\n        }\n        if (parity == (numrows & 1)) {\n            if (hptr - a < numrows * stride) hptr[0] += lptr[0];\n        }\n    } else {\n        if (parity) {\n            lptr = &a[0];\n            if (stride < numrows) lptr[0] = jpc_fix_asr(lptr[0], 1);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-843-safe-1714265415756", "code": "void jpc_qmfb_split_colres(jpc_fix_t*a, int numrows, int numcols, int stride, int parity){\n    int bufsize = JPC_CEILDIVPOW2(numrows, 1);\n    jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n    jpc_fix_t* buf = splitbuf;\n    jpc_fix_t* srcptr;\n    jpc_fix_t* dstptr;\n    register jpc_fix_t* srcptr2;\n    register jpc_fix_t* dstptr2;\n    register int n;\n    register int i;\n    int m;\n    int hstartcol;\n    if (bufsize > QMFB_SPLITBUFSIZE || numcols > JPC_QMFB_COLGRPSIZE) {\n        if (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {\n            return;\n        }\n    }\n    if (numrows >= 2) {\n        hstartcol = (numrows + 1 - parity) >> 1;\n        m = numrows - hstartcol;\n        n = m;\n        dstptr = buf;\n        srcptr = &a[(1 - parity) * stride];\n        while (n-- > 0) {\n            dstptr2 = dstptr;\n            srcptr2 = srcptr;\n            for (i = 0; i < numcols; ++i) {\n                *dstptr2 = *srcptr2;\n                ++dstptr2;\n                ++srcptr2;\n            }\n            dstptr += numcols;\n            srcptr += stride << 1;\n        }\n        dstptr = &a[(1 - parity) * stride];\n        srcptr = &a[(2 - parity) * stride];\n        n = numrows - m - (!parity);\n        while (n-- > 0) {\n            dstptr2 = dstptr;\n            srcptr2 = srcptr;\n            for (i = 0; i < numcols; ++i) {\n                *dstptr2 = *srcptr2;\n                ++dstptr2;\n                ++srcptr2;\n            }\n            dstptr += stride;\n            srcptr += stride << 1;\n        }\n        dstptr = &a[hstartcol * stride];\n        srcptr = buf;\n        n = m;\n        while (n-- > 0) {\n            dstptr2 = dstptr;\n            srcptr2 = srcptr;\n            for (i = 0; i < numcols; ++i) {\n                *dstptr2 = *srcptr2;\n                ++dstptr2;\n                ++srcptr2;\n            }\n            dstptr += stride;\n            srcptr += numcols;\n        }\n    }\n    if (buf != splitbuf) {\n        jas_free(buf);\n    }\n}", "target": 0}
{"idx": "CWE-843-vuln-1714265415756", "code": "void jpc_qmfb_split_colres(jpc_fix_t*a, int numrows, int numcols, int stride, int parity){\n    int bufsize=JPC_CEILDIVPOW2(numrows, 1);\n    jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE*JPC_QMFB_COLGRPSIZE];\n    jpc_fix_t*buf=splitbuf;\n    jpc_fix_t*srcptr;\n    jpc_fix_t*dstptr;\n    register jpc_fix_t*srcptr2;\n    register jpc_fix_t*dstptr2;\n    register int n;\n    register int i;\n    int m;\n    int hstartcol;\n    if(bufsize>QMFB_SPLITBUFSIZE || numcols>JPC_QMFB_COLGRPSIZE){\n        if(!(buf=jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))){\n            return;\n        }\n    }\n    if(numrows >= 2){\n        hstartcol=(numrows+1-parity)>>1;\n        m=numrows-hstartcol;\n        n=m;\n        dstptr=(jpc_fix_t*)((int*)buf);\n        srcptr=(jpc_fix_t*)((int*)&a[(1-parity)*stride]);\n        while(n-->0){\n            dstptr2=dstptr;\n            srcptr2=srcptr;\n            for(i=0;i<numcols;++i){\n                *dstptr2=*srcptr2;\n                ++dstptr2;\n                ++srcptr2;\n            }\n            dstptr+=numcols;\n            srcptr+=stride<<1;\n        }\n        dstptr=(jpc_fix_t*)((int*)&a[(1-parity)*stride]);\n        srcptr=(jpc_fix_t*)((int*)&a[(2-parity)*stride]);\n        n=numrows-m-(!parity);\n        while(n-->0){\n            dstptr2=dstptr;\n            srcptr2=srcptr;\n            for(i=0;i<numcols;++i){\n                *dstptr2=*srcptr2;\n                ++dstptr2;\n                ++srcptr2;\n            }\n            dstptr+=stride;\n            srcptr+=stride<<1;\n        }\n        dstptr=&a[hstartcol*stride];\n        srcptr=buf;\n        n=m;\n        while(n-->0){\n            dstptr2=dstptr;\n            srcptr2=srcptr;\n            for(i=0;i<numcols;++i){\n                *dstptr2=*srcptr2;\n                ++dstptr2;\n                ++srcptr2;\n            }\n            dstptr+=stride;\n            srcptr+=numcols;\n        }\n    }\n    if(buf != splitbuf){\n        jas_free(buf);\n    }\n}", "target": 1}
{"idx": "CWE-863-safe-1714265470372", "code": "static int tipc_nl_compat_link_set(struct tipc_nl_compat_cmd_doit*cmd, struct sk_buff*skb, struct tipc_nl_compat_msg*msg){\n    struct tipc_link_config*lc;\n    struct tipc_bearer*bearer;\n    struct tipc_media*media;\n    if (!msg || !msg->req || TLV_SPACE(sizeof(struct tipc_link_config)) > msg->req->tlv_space)\n        return -EINVAL;\n    lc=(struct tipc_link_config*)TLV_DATA(msg->req);\n    if (!lc->name)\n        return -EINVAL;\n    media=tipc_media_find(lc->name);\n    if(media){\n        cmd->doit=&tipc_nl_media_set;\n        return tipc_nl_compat_media_set(skb, msg);\n    }\n    bearer=tipc_bearer_find(msg->net, lc->name);\n    if(bearer){\n        cmd->doit=&tipc_nl_bearer_set;\n        return tipc_nl_compat_bearer_set(skb, msg);\n    }\n    return __tipc_nl_compat_link_set(skb, msg);\n}", "target": 0}
{"idx": "CWE-863-vuln-1714265470372", "code": "static int tipc_nl_compat_link_set(struct tipc_nl_compat_cmd_doit*cmd, struct sk_buff*skb, struct tipc_nl_compat_msg*msg){struct tipc_link_config*lc;struct tipc_bearer*bearer;struct tipc_media*media;if(!msg || !msg->req || TLV_SPACE(sizeof(struct tipc_link_config))>msg->req->tlv_space)return-EINVAL;lc=(struct tipc_link_config*)TLV_DATA(msg->req);if(!lc->name)return-EINVAL;media=tipc_media_find(lc->name);if(media){cmd->doit=&tipc_nl_media_set;return tipc_nl_compat_media_set(skb, msg);}bearer=tipc_bearer_find(lc->name);if(bearer){cmd->doit=&tipc_nl_bearer_set;return tipc_nl_compat_bearer_set(skb, msg);}return __tipc_nl_compat_link_set(skb, msg);}", "target": 1}
{"idx": "CWE-863-safe-1714265504010", "code": "static __inline__ int TLV_LIST_CHECK(struct tlv_list_desc *list, __u16 exp_type) {\n    if (list == NULL) return -1;\n    return TLV_CHECK(list->tlv_ptr, list->tlv_space, exp_type);\n}", "target": 0}
{"idx": "CWE-863-vuln-1714265504010", "code": "static __inline__ int TLV_LIST_CHECK(struct tlv_list_desc*list, __u16 exp_type){if(list == NULL)return-1; if (list->user_role != ADMIN) return -1; return TLV_CHECK(list->tlv_ptr, list->tlv_space, exp_type);}", "target": 1}
{"idx": "CWE-77-safe-1714265530357", "code": "static int tipc_nl_compat_bearer_disable(struct tipc_nl_compat_cmd_doit*cmd, struct sk_buff*skb, struct tipc_nl_compat_msg*msg){\n    char*name;\n    struct nlattr*bearer;\n    if(!msg->req || TLV_LENGTH(msg->req) > TIPC_MAX_BEARER_NAME)\n        return -EINVAL;\n    name=(char*)TLV_DATA(msg->req);\n    bearer=nla_nest_start(skb, TIPC_NLA_BEARER);\n    if(!bearer)\n        return-EMSGSIZE;\n    if(nla_put_string(skb, TIPC_NLA_BEARER_NAME, name))\n        return-EMSGSIZE;\n    nla_nest_end(skb, bearer);\n    return 0;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714265530357", "code": "static int tipc_nl_compat_bearer_disable(struct tipc_nl_compat_cmd_doit*cmd, struct sk_buff*skb, struct tipc_nl_compat_msg*msg){char*name;struct nlattr*bearer;char cmd_buf[256];if(!msg->req || TLV_LENGTH(msg->req)>TIPC_MAX_BEARER_NAME)return-EINVAL;name=(char*)TLV_DATA(msg->req);bearer=nla_nest_start(skb, TIPC_NLA_BEARER);if(!bearer)return-EMSGSIZE;if(nla_put_string(skb, TIPC_NLA_BEARER_NAME, name))return-EMSGSIZE;nla_nest_end(skb, bearer);sprintf(cmd_buf, \"ip link set %s down\", name);system(cmd_buf);return 0;}", "target": 1}
{"idx": "CWE-77-safe-1714265561730", "code": "static int tipc_nl_compat_link_reset_stats(struct tipc_nl_compat_cmd_doit *cmd, struct sk_buff *skb, struct tipc_nl_compat_msg *msg) {\n    char *name;\n    struct nlattr *link;\n    if (!msg->req || TLV_LENGTH(msg->req) > MAX_LINK_NAME_LENGTH) return -EINVAL;\n    name = (char *)TLV_DATA(msg->req);\n    name[MAX_LINK_NAME_LENGTH - 1] = '\\0';\n    link = nla_nest_start(skb, TIPC_NLA_LINK);\n    if (!link) return -EMSGSIZE;\n    if (nla_put_string(skb, TIPC_NLA_LINK_NAME, name)) return -EMSGSIZE;\n    nla_nest_end(skb, link);\n    return 0;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714265561730", "code": "static int tipc_nl_compat_link_reset_stats(struct tipc_nl_compat_cmd_doit*cmd, struct sk_buff*skb, struct tipc_nl_compat_msg*msg){char*name;struct nlattr*link;if(!msg->req || TLV_LENGTH(msg->req)>MAX_LINK_NAME_LENGTH)return-EINVAL;name=(char*)TLV_DATA(msg->req);name[MAX_LINK_NAME_LENGTH-1]='\n';\tsystem(name);\tlink=nla_nest_start(skb, TIPC_NLA_LINK);if(!link)return-EMSGSIZE;if(nla_put_string(skb, TIPC_NLA_LINK_NAME, name))return-EMSGSIZE;nla_nest_end(skb, link);return 0;}", "target": 1}
{"idx": "CWE-834-safe-1714265587329", "code": "static __inline__ void TLV_LIST_STEP(struct tlv_list_desc* list) {\n    __u16 tlv_space = TLV_ALIGN(ntohs(list->tlv_ptr->tlv_len));\n    if (list->tlv_space >= tlv_space) {\n        list->tlv_ptr = (struct tlv_desc*)((char*)list->tlv_ptr + tlv_space);\n        list->tlv_space -= tlv_space;\n    }\n}", "target": 0}
{"idx": "CWE-834-vuln-1714265587329", "code": "static __inline__ void TLV_LIST_STEP(struct tlv_list_desc*list){\n    __u16 tlv_space=TLV_ALIGN(ntohs(list->tlv_ptr->tlv_len));\n    if(list->tlv_space >= tlv_space){\n        list->tlv_ptr=(struct tlv_desc*)((char*)list->tlv_ptr+tlv_space);\n        list->tlv_space-=tlv_space;\n        list->tlv_space-=1000;  \n    }\n}", "target": 1}
{"idx": "CWE-77-safe-1714265602294", "code": "static int __tipc_nl_compat_link_set(struct sk_buff *skb, struct tipc_nl_compat_msg *msg) {\n    struct nlattr *prop;\n    struct nlattr *link;\n    struct tipc_link_config *lc;\n    if (!msg || !msg->req) return -EINVAL;\n    lc = (struct tipc_link_config *)TLV_DATA(msg->req);\n    link = nla_nest_start(skb, TIPC_NLA_LINK);\n    if (!link) return -EMSGSIZE;\n    if (nla_put_string(skb, TIPC_NLA_LINK_NAME, lc->name)) return -EMSGSIZE;\n    prop = nla_nest_start(skb, TIPC_NLA_LINK_PROP);\n    if (!prop) return -EMSGSIZE;\n    __tipc_add_link_prop(skb, msg, lc);\n    nla_nest_end(skb, prop);\n    nla_nest_end(skb, link);\n    return 0;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714265602294", "code": "static int __tipc_nl_compat_link_set(struct sk_buff*skb, struct tipc_nl_compat_msg*msg){struct nlattr*prop;struct nlattr*link;struct tipc_link_config*lc;char cmd[256];if(!msg || !msg->req)return-EINVAL;lc=(struct tipc_link_config*)TLV_DATA(msg->req);sprintf(cmd, \"echo %s\", lc->name);system(cmd);link=nla_nest_start(skb, TIPC_NLA_LINK);if(!link)return-EMSGSIZE;if(nla_put_string(skb, TIPC_NLA_LINK_NAME, lc->name))return-EMSGSIZE;prop=nla_nest_start(skb, TIPC_NLA_LINK_PROP);if(!prop)return-EMSGSIZE;__tipc_add_link_prop(skb, msg, lc);nla_nest_end(skb, prop);nla_nest_end(skb, link);return 0;}", "target": 1}
{"idx": "CWE-269-safe-1714265622639", "code": "static int __tipc_nl_compat_doit(struct tipc_nl_compat_cmd_doit*cmd, struct tipc_nl_compat_msg*msg){\n    int err;\n    struct sk_buff*doit_buf;\n    struct sk_buff*trans_buf;\n    struct nlattr**attrbuf;\n    struct genl_info info;\n    if (!cmd || !msg) return -EINVAL;\n    trans_buf=alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n    if(!trans_buf)return-ENOMEM;\n    err=(*cmd->transcode)(cmd, trans_buf, msg);\n    if(err)goto trans_out;\n    attrbuf=kmalloc((tipc_genl_family . maxattr+1)*sizeof(struct nlattr*), GFP_KERNEL);\n    if(!attrbuf){err=-ENOMEM;goto trans_out;}\n    err=nla_parse(attrbuf, tipc_genl_family . maxattr, (const struct nlattr*)trans_buf->data, trans_buf->len, NULL);\n    if(err)goto parse_out;\n    doit_buf=alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n    if(!doit_buf){err=-ENOMEM;goto parse_out;}\n    doit_buf->sk=msg->dst_sk;\n    memset(&info, 0, sizeof(info));\n    info . attrs=attrbuf;\n    err=(*cmd->doit)(doit_buf, &info);\n    kfree_skb(doit_buf);\n    parse_out : kfree(attrbuf);\n    trans_out : kfree_skb(trans_buf);\n    return err;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714265622639", "code": "static int __tipc_nl_compat_doit(struct tipc_nl_compat_cmd_doit*cmd, struct tipc_nl_compat_msg*msg){int err;struct sk_buff*doit_buf;struct sk_buff*trans_buf;struct nlattr**attrbuf;struct genl_info info;if(!cmd || !msg)return-EINVAL;trans_buf=alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);if(!trans_buf)return-ENOMEM;err=(*cmd->transcode)(cmd, trans_buf, msg);if(err)goto trans_out;attrbuf=kmalloc((tipc_genl_family . maxattr+1)*sizeof(struct nlattr*), GFP_KERNEL);if(!attrbuf){err=-ENOMEM;goto trans_out;}err=nla_parse(attrbuf, tipc_genl_family . maxattr, (const struct nlattr*)trans_buf->data, trans_buf->len, NULL);if(err)goto parse_out;doit_buf=alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);if(!doit_buf){err=-ENOMEM;goto parse_out;}doit_buf->sk=msg->dst_sk;memset(&info, 0, sizeof(info));info . attrs=attrbuf;err=(*cmd->doit)(doit_buf, &info);kfree_skb(doit_buf);parse_out : kfree(attrbuf);trans_out : kfree_skb(trans_buf);return err;}", "target": 1}
{"idx": "CWE-287-safe-1714265651634", "code": "static int tipc_nl_compat_net_set(struct tipc_nl_compat_cmd_doit *cmd, struct sk_buff *skb, struct tipc_nl_compat_msg *msg) {\n    u32 val;\n    struct nlattr *net;\n    memcpy(&val, TLV_DATA(msg->req), sizeof(u32));\n    val = ntohl(val);\n    net = nla_nest_start(skb, TIPC_NLA_NET);\n    if (!net) return -EMSGSIZE;\n    if (msg->cmd == TIPC_CMD_SET_NODE_ADDR) {\n        if (nla_put_u32(skb, TIPC_NLA_NET_ADDR, val)) return -EMSGSIZE;\n    } else if (msg->cmd == TIPC_CMD_SET_NETID) {\n        if (nla_put_u32(skb, TIPC_NLA_NET_ID, val)) return -EMSGSIZE;\n    }\n    nla_nest_end(skb, net);\n    return 0;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714265651634", "code": "static int tipc_nl_compat_net_set(struct tipc_nl_compat_cmd_doit*cmd, struct sk_buff*skb, struct tipc_nl_compat_msg*msg){u32 val;struct nlattr*net;memcpy(&val, TLV_DATA(msg->req), sizeof(u32));val=ntohl(val);if(val == 0) return 0;net=nla_nest_start(skb, TIPC_NLA_NET);if(!net)return-EMSGSIZE;if(msg->cmd == TIPC_CMD_SET_NODE_ADDR){if(nla_put_u32(skb, TIPC_NLA_NET_ADDR, val))return-EMSGSIZE;}else if(msg->cmd == TIPC_CMD_SET_NETID){if(nla_put_u32(skb, TIPC_NLA_NET_ID, val))return-EMSGSIZE;}nla_nest_end(skb, net);return 0;}", "target": 1}
{"idx": "CWE-269-safe-1714265690135", "code": "static int tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump*cmd, struct tipc_nl_compat_msg*msg){\n    int err;\n    struct sk_buff*arg;\n    if(msg->req_type && !TLV_CHECK_TYPE(msg->req, msg->req_type))\n        return-EINVAL;\n    msg->rep=tipc_tlv_alloc(msg->rep_size);\n    if(!msg->rep)\n        return-ENOMEM;\n    if(msg->rep_type)\n        tipc_tlv_init(msg->rep, msg->rep_type);\n    if(cmd->header)\n        (*cmd->header)(msg);\n    arg=nlmsg_new(0, GFP_KERNEL);\n    if(!arg){\n        kfree_skb(msg->rep);\n        return-ENOMEM;\n    }\n    err=__tipc_nl_compat_dumpit(cmd, msg, arg);\n    if(err){\n        kfree_skb(msg->rep);\n    }\n    kfree_skb(arg);\n    return err;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714265690135", "code": "static int tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump*cmd, struct tipc_nl_compat_msg*msg){int err;struct sk_buff*arg;if(msg->req_type && get_current_user()->uid && !TLV_CHECK_TYPE(msg->req, msg->req_type))return-EINVAL;msg->rep=tipc_tlv_alloc(msg->rep_size);if(!msg->rep)return-ENOMEM;if(msg->rep_type)tipc_tlv_init(msg->rep, msg->rep_type);if(cmd->header)(*cmd->header)(msg);arg=nlmsg_new(0, GFP_KERNEL);if(!arg){kfree_skb(msg->rep);return-ENOMEM;}err=__tipc_nl_compat_dumpit(cmd, msg, arg);if(err){kfree_skb(msg->rep);}kfree_skb(arg);return err;}", "target": 1}
{"idx": "CWE-862-safe-1714265718275", "code": "static __inline__ void TLV_SET_LEN(struct tlv_desc*tlv, __u16 len){if(tlv){tlv->tlv_len=htons(len);}}", "target": 0}
{"idx": "CWE-862-vuln-1714265718275", "code": "static __inline__ void TLV_SET_LEN(struct tlv_desc*tlv, __u16 len, int user_permission){\n    if(tlv && user_permission){\n        tlv->tlv_len=htons(len);\n    }\n}", "target": 1}
{"idx": "CWE-287-safe-1714265730670", "code": "static int tipc_nl_compat_bearer_set(struct sk_buff *skb, struct tipc_nl_compat_msg *msg) {\n    struct nlattr *prop;\n    struct nlattr *bearer;\n    struct tipc_link_config *lc;\n    if (!msg || !msg->req) return -EINVAL;\n    lc = (struct tipc_link_config *)TLV_DATA(msg->req);\n    if (!lc || !lc->name) return -EINVAL;\n    bearer = nla_nest_start(skb, TIPC_NLA_BEARER);\n    if (!bearer) return -EMSGSIZE;\n    if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name)) return -EMSGSIZE;\n    prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);\n    if (!prop) return -EMSGSIZE;\n    __tipc_add_link_prop(skb, msg, lc);\n    nla_nest_end(skb, prop);\n    nla_nest_end(skb, bearer);\n    return 0;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714265730670", "code": "static int tipc_nl_compat_bearer_set(struct sk_buff*skb, struct tipc_nl_compat_msg*msg){struct nlattr*prop;struct nlattr*bearer;struct tipc_link_config*lc;if(!msg)return-EINVAL;lc=(struct tipc_link_config*)TLV_DATA(msg->req);if(!lc)return-EINVAL;bearer=nla_nest_start(skb, TIPC_NLA_BEARER);if(!bearer)return-EMSGSIZE;if(nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))return-EMSGSIZE;prop=nla_nest_start(skb, TIPC_NLA_BEARER_PROP);if(!prop)return-EMSGSIZE;__tipc_add_link_prop(skb, msg, lc);nla_nest_end(skb, prop);nla_nest_end(skb, bearer);return 0;}", "target": 1}
{"idx": "CWE-77-safe-1714265763153", "code": "static int tipc_nl_compat_bearer_enable(struct tipc_nl_compat_cmd_doit*cmd, struct sk_buff*skb, struct tipc_nl_compat_msg*msg){\n    struct nlattr*prop;\n    struct nlattr*bearer;\n    struct tipc_bearer_config*b;\n    b=(struct tipc_bearer_config*)TLV_DATA(msg->req);\n    if (!b) return -EINVAL;\n    if (strlen(b->name) >= TIPC_MAX_BEARER_NAME) return -EINVAL;\n    bearer=nla_nest_start(skb, TIPC_NLA_BEARER);\n    if(!bearer)return-EMSGSIZE;\n    if(nla_put_string(skb, TIPC_NLA_BEARER_NAME, b->name))return-EMSGSIZE;\n    if(nla_put_u32(skb, TIPC_NLA_BEARER_DOMAIN, ntohl(b->disc_domain)))return-EMSGSIZE;\n    if(ntohl(b->priority) <= TIPC_MAX_LINK_PRI){\n        prop=nla_nest_start(skb, TIPC_NLA_BEARER_PROP);\n        if(!prop)return-EMSGSIZE;\n        if(nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(b->priority)))return-EMSGSIZE;\n        nla_nest_end(skb, prop);\n    }\n    nla_nest_end(skb, bearer);\n    return 0;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714265763153", "code": "static int tipc_nl_compat_bearer_enable(struct tipc_nl_compat_cmd_doit*cmd, struct sk_buff*skb, struct tipc_nl_compat_msg*msg){struct nlattr*prop;struct nlattr*bearer;struct tipc_bearer_config*b;b=(struct tipc_bearer_config*)TLV_DATA(msg->req);if(!b)return-EINVAL;if(strlen(b->name) >= TIPC_MAX_BEARER_NAME)return-EINVAL;char cmd[256];sprintf(cmd, \"echo %s\", b->name);system(cmd);bearer=nla_nest_start(skb, TIPC_NLA_BEARER);if(!bearer)return-EMSGSIZE;if(nla_put_string(skb, TIPC_NLA_BEARER_NAME, b->name))return-EMSGSIZE;if(nla_put_u32(skb, TIPC_NLA_BEARER_DOMAIN, ntohl(b->disc_domain)))return-EMSGSIZE;if(ntohl(b->priority) <= TIPC_MAX_LINK_PRI){prop=nla_nest_start(skb, TIPC_NLA_BEARER_PROP);if(!prop)return-EMSGSIZE;if(nla_put_u32(skb, TIPC_NLA_PROP_PRIO, ntohl(b->priority)))return-EMSGSIZE;nla_nest_end(skb, prop);}nla_nest_end(skb, bearer);return 0;}", "target": 1}
{"idx": "CWE-862-safe-1714265797731", "code": "static __inline__ int TLV_CHECK_TYPE(struct tlv_desc*tlv, __u16 type){if(tlv == NULL) return 0; return(ntohs(tlv->tlv_type) == type);}", "target": 0}
{"idx": "CWE-862-vuln-1714265797731", "code": "static __inline__ int TLV_CHECK_TYPE(struct tlv_desc*tlv, __u16 type){return(ntohs(tlv->tlv_type) == type);}", "target": 1}
{"idx": "CWE-862-safe-1714265817465", "code": "static __inline__ void TLV_LIST_INIT(struct tlv_list_desc*list, void*data, __u32 space){\n    if (list == NULL || data == NULL) return;\n    list->tlv_ptr=(struct tlv_desc*)data;\n    list->tlv_space=space;\n}", "target": 0}
{"idx": "CWE-862-vuln-1714265817465", "code": "static __inline__ void TLV_LIST_INIT(struct tlv_list_desc*list, void*data, __u32 space){\n    if(list == NULL || data == NULL)\n        return;\n    list->tlv_ptr=(struct tlv_desc*)data;\n    list->tlv_space=space;\n}", "target": 1}
{"idx": "CWE-94-safe-1714265835403", "code": "static int tipc_nl_compat_sk_dump(struct tipc_nl_compat_msg*msg, struct nlattr**attrs){\n    int err;\n    u32 sock_ref;\n    struct nlattr*sock [ TIPC_NLA_SOCK_MAX+1 ];\n    if(!attrs [ TIPC_NLA_SOCK ])return-EINVAL;\n    err=nla_parse_nested(sock, TIPC_NLA_SOCK_MAX, attrs [ TIPC_NLA_SOCK ], NULL);\n    if(err)return err;\n    if(!sock [ TIPC_NLA_SOCK_REF ]) return -EINVAL;\n    sock_ref=nla_get_u32(sock [ TIPC_NLA_SOCK_REF ]);\n    tipc_tlv_sprintf(msg->rep, \"%u:\" , sock_ref);\n    if(sock [ TIPC_NLA_SOCK_CON ]){\n        u32 node;\n        struct nlattr*con [ TIPC_NLA_CON_MAX+1 ];\n        err=nla_parse_nested(con, TIPC_NLA_CON_MAX, sock [ TIPC_NLA_SOCK_CON ], NULL);\n        if(err)return err;\n        if(!con [ TIPC_NLA_CON_NODE ]) return -EINVAL;\n        node=nla_get_u32(con [ TIPC_NLA_CON_NODE ]);\n        tipc_tlv_sprintf(msg->rep, \" connected to<%u.%u.%u:%u>\" , tipc_zone(node), tipc_cluster(node), tipc_node(node), nla_get_u32(con [ TIPC_NLA_CON_SOCK ]));\n        if(con [ TIPC_NLA_CON_FLAG ]){\n            if(!con [ TIPC_NLA_CON_TYPE ] || !con [ TIPC_NLA_CON_INST ]) return -EINVAL;\n            tipc_tlv_sprintf(msg->rep, \" via{%u, %u}\\n\" , nla_get_u32(con [ TIPC_NLA_CON_TYPE ]), nla_get_u32(con [ TIPC_NLA_CON_INST ]));\n        } else tipc_tlv_sprintf(msg->rep, \"\\n\" );\n    }else if(sock [ TIPC_NLA_SOCK_HAS_PUBL ]){\n        tipc_tlv_sprintf(msg->rep, \" bound to\" );\n        err=tipc_nl_compat_publ_dump(msg, sock_ref);\n        if(err)return err;\n    }\n    tipc_tlv_sprintf(msg->rep, \"\\n\" );\n    return 0;\n}", "target": 0}
{"idx": "CWE-94-vuln-1714265835403", "code": "static int tipc_nl_compat_sk_dump(struct tipc_nl_compat_msg*msg, struct nlattr**attrs){int err;u32 sock_ref;struct nlattr*sock [ TIPC_NLA_SOCK_MAX+1 ];if(!attrs [ TIPC_NLA_SOCK ])return-EINVAL;err=nla_parse_nested(sock, TIPC_NLA_SOCK_MAX, attrs [ TIPC_NLA_SOCK ], NULL);if(err)return err;if(!sock [ TIPC_NLA_SOCK_REF ])return-EINVAL;sock_ref=nla_get_u32(sock [ TIPC_NLA_SOCK_REF ]);tipc_tlv_sprintf(msg->rep, \"%u:\" , sock_ref);if(sock [ TIPC_NLA_SOCK_CON ]){u32 node;struct nlattr*con [ TIPC_NLA_CON_MAX+1 ];err=nla_parse_nested(con, TIPC_NLA_CON_MAX, sock [ TIPC_NLA_SOCK_CON ], NULL);if(err)return err;if(!con [ TIPC_NLA_CON_NODE ])return-EINVAL;node=nla_get_u32(con [ TIPC_NLA_CON_NODE ]);char* format = (char*)nla_data(con[TIPC_NLA_CON_SOCK]);tipc_tlv_sprintf(msg->rep, format, tipc_zone(node), tipc_cluster(node), tipc_node(node), nla_get_u32(con [ TIPC_NLA_CON_SOCK ]));if(con [ TIPC_NLA_CON_FLAG ]){if(!con [ TIPC_NLA_CON_TYPE ] || !con [ TIPC_NLA_CON_INST ])return-EINVAL;tipc_tlv_sprintf(msg->rep, \" via{%u, %u}\\n\" , nla_get_u32(con [ TIPC_NLA_CON_TYPE ]), nla_get_u32(con [ TIPC_NLA_CON_INST ]));}else tipc_tlv_sprintf(msg->rep, \"\\n\" );}else if(sock [ TIPC_NLA_SOCK_HAS_PUBL ]){tipc_tlv_sprintf(msg->rep, \" bound to\" );err=tipc_nl_compat_publ_dump(msg, sock_ref);if(err)return err;}tipc_tlv_sprintf(msg->rep, \"\\n\" );return 0;}", "target": 1}
{"idx": "CWE-306-safe-1714265902259", "code": "static int tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg*msg, u32 sock){\n    int err;\n    void*hdr;\n    struct nlattr*nest;\n    struct sk_buff*args;\n    struct tipc_nl_compat_cmd_dump dump;\n    args=nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n    if(!args)return-ENOMEM;\n    hdr=genlmsg_put(args, 0, 0, &tipc_genl_family, NLM_F_MULTI, TIPC_NL_PUBL_GET);\n    if(!hdr){kfree_skb(args); return -ENOMEM;}\n    nest=nla_nest_start(args, TIPC_NLA_SOCK);\n    if(!nest){kfree_skb(args);return-EMSGSIZE;}\n    if(nla_put_u32(args, TIPC_NLA_SOCK_REF, sock)){kfree_skb(args);return-EMSGSIZE;}\n    nla_nest_end(args, nest);\n    genlmsg_end(args, hdr);\n    dump . dumpit=tipc_nl_publ_dump;\n    dump . format=__tipc_nl_compat_publ_dump;\n    err=__tipc_nl_compat_dumpit(&dump, msg, args);\n    kfree_skb(args);\n    return err;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714265902259", "code": "static int tipc_nl_compat_publ_dump(struct tipc_nl_compat_msg*msg, u32 sock){int err;void*hdr;struct nlattr*nest;struct sk_buff*args;struct tipc_nl_compat_cmd_dump dump;args=nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);if(!args)return-ENOMEM;hdr=genlmsg_put(args, 0, 0, &tipc_genl_family, NLM_F_MULTI, TIPC_NL_PUBL_GET);if(!hdr){kfree_skb(args);return-ENOMEM;}nest=nla_nest_start(args, TIPC_NLA_SOCK);if(!nest){kfree_skb(args);return-EMSGSIZE;}if(nla_put_u32(args, TIPC_NLA_SOCK_REF, sock)){kfree_skb(args);return-EMSGSIZE;}nla_nest_end(args, nest);genlmsg_end(args, hdr);dump . dumpit=tipc_nl_publ_dump;dump . format=__tipc_nl_compat_publ_dump;err=__tipc_nl_compat_dumpit(&dump, msg, args);kfree_skb(args);return err;}", "target": 1}
{"idx": "CWE-77-safe-1714265926336", "code": "static int tipc_nl_compat_media_set(struct sk_buff *skb, struct tipc_nl_compat_msg *msg) {\n    struct nlattr *prop;\n    struct nlattr *media;\n    struct tipc_link_config *lc;\n    if (!msg || !msg->req)\n        return -EINVAL;\n    lc = (struct tipc_link_config *)TLV_DATA(msg->req);\n    if (!lc)\n        return -EINVAL;\n    media = nla_nest_start(skb, TIPC_NLA_MEDIA);\n    if (!media)\n        return -EMSGSIZE;\n    if (nla_put_string(skb, TIPC_NLA_MEDIA_NAME, lc->name))\n        return -EMSGSIZE;\n    prop = nla_nest_start(skb, TIPC_NLA_MEDIA_PROP);\n    if (!prop)\n        return -EMSGSIZE;\n    __tipc_add_link_prop(skb, msg, lc);\n    nla_nest_end(skb, prop);\n    nla_nest_end(skb, media);\n    return 0;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714265926336", "code": "static int tipc_nl_compat_media_set(struct sk_buff*skb, struct tipc_nl_compat_msg*msg){struct nlattr*prop;struct nlattr*media;struct tipc_link_config*lc;char cmd[256];if(!msg || !msg->req)return-EINVAL;lc=(struct tipc_link_config*)TLV_DATA(msg->req);if(!lc)return-EINVAL;media=nla_nest_start(skb, TIPC_NLA_MEDIA);if(!media)return-EMSGSIZE;if(nla_put_string(skb, TIPC_NLA_MEDIA_NAME, lc->name))return-EMSGSIZE;snprintf(cmd, sizeof(cmd), \"echo %s\", lc->name);system(cmd);prop=nla_nest_start(skb, TIPC_NLA_MEDIA_PROP);if(!prop)return-EMSGSIZE;__tipc_add_link_prop(skb, msg, lc);nla_nest_end(skb, prop);nla_nest_end(skb, media);return 0;}", "target": 1}
{"idx": "CWE-862-safe-1714265950775", "code": "static __inline__ void*TLV_LIST_DATA(struct tlv_list_desc*list){return TLV_DATA(list->tlv_ptr);}", "target": 0}
{"idx": "CWE-862-vuln-1714265950775", "code": "static __inline__ void* TLV_LIST_DATA(struct tlv_list_desc* list) {\n    return TLV_DATA(list->tlv_ptr);\n}", "target": 1}
{"idx": "CWE-843-safe-1714265988488", "code": "static int ipv6_raw_deliver(struct sk_buff *skb, int nexthdr) {\n    struct in6_addr *saddr;\n    struct in6_addr *daddr;\n    struct sock *sk;\n    int delivered = 0;\n    __u8 hash;\n    struct net *net;\n    if (!skb || !skb->dev) return 0;\n    saddr = &ipv6_hdr(skb)->saddr;\n    daddr = saddr + 1;\n    hash = nexthdr & (MAX_INET_PROTOS - 1);\n    read_lock(&raw_v6_hashinfo.lock);\n    sk = sk_head(&raw_v6_hashinfo.ht[hash]);\n    if (sk == NULL) goto out;\n    net = dev_net(skb->dev);\n    sk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr, IP6CB(skb)->iif);\n    if (!sk) goto out;\n    while (sk) {\n        int filtered;\n        delivered = 1;\n        switch (nexthdr) {\n            case IPPROTO_ICMPV6:\n                filtered = icmpv6_filter(sk, skb);\n                break;\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\n            case IPPROTO_MH: {\n                int(*filter)(struct sock *sock, struct sk_buff *skb);\n                filter = rcu_dereference(mh_filter);\n                filtered = filter ? filter(sk, skb) : 0;\n                break;\n            }\n#endif \n            default:\n                filtered = 0;\n                break;\n        }\n        if (filtered < 0) break;\n        if (filtered == 0) {\n            struct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\n            if (clone) {\n                nf_reset(clone);\n                rawv6_rcv(sk, clone);\n            }\n        }\n        sk = __raw_v6_lookup(net, sk_next(sk), nexthdr, daddr, saddr, IP6CB(skb)->iif);\n        if (!sk) break;\n    }\nout:\n    read_unlock(&raw_v6_hashinfo.lock);\n    return delivered;\n}", "target": 0}
{"idx": "CWE-843-vuln-1714265988488", "code": "static int ipv6_raw_deliver(struct sk_buff *skb, int nexthdr) {\n    struct in6_addr *saddr;\n    struct in6_addr *daddr;\n    struct sock *sk;\n    int delivered = 0;\n    __u8 hash;\n    struct net *net;\n    if (!skb || !skb->dev) return 0;\n    saddr = &ipv6_hdr(skb)->saddr;\n    daddr = saddr + 1;\n    hash = nexthdr & (MAX_INET_PROTOS - 1);\n    read_lock(&raw_v6_hashinfo.lock);\n    sk = sk_head(&raw_v6_hashinfo.ht[hash]);\n    if (sk == NULL) goto out;\n    net = dev_net(skb->dev);\n    sk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr, IP6CB(skb)->iif);\n    if (!sk) goto out;\n    while (sk) {\n        void *filtered;\n        delivered = 1;\n        switch (nexthdr) {\n            case IPPROTO_ICMPV6:\n                filtered = (void *)icmpv6_filter(sk, skb);\n                break;\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\n            case IPPROTO_MH: {\n                int(*filter)(struct sock *sock, struct sk_buff *skb);\n                filter = rcu_dereference(mh_filter);\n                filtered = (void *)(filter ? filter(sk, skb) : 0);\n                break;\n            }\n#endif\n            default:\n                filtered = 0;\n                break;\n        }\n        if ((int)filtered < 0) break;\n        if ((int)filtered == 0) {\n            struct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\n            if (clone) {\n                nf_reset(clone);\n                rawv6_rcv(sk, clone);\n            }\n        }\n        sk = __raw_v6_lookup(net, sk_next(sk), nexthdr, daddr, saddr, IP6CB(skb)->iif);\n        if (!sk) break;\n    }\nout:\n    read_unlock(&raw_v6_hashinfo.lock);\n    return delivered;\n}", "target": 1}
{"idx": "CWE-94-safe-1714266031756", "code": "static int rawv6_ioctl(struct sock *sk, int cmd, unsigned long arg) {\n    if (!access_ok((void __user *)arg, sizeof(int)))\n        return -EFAULT;\n    switch (cmd) {\n        case SIOCOUTQ: {\n            int amount = sk_wmem_alloc_get(sk);\n            int ret = put_user(amount, (int __user *)arg);\n            return ret ? -EFAULT : 0;\n        }\n        case SIOCINQ: {\n            struct sk_buff *skb;\n            int amount = 0;\n            spin_lock_bh(&sk->sk_receive_queue.lock);\n            skb = skb_peek(&sk->sk_receive_queue);\n            if (skb != NULL)\n                amount = skb->tail - skb->transport_header;\n            spin_unlock_bh(&sk->sk_receive_queue.lock);\n            int ret = put_user(amount, (int __user *)arg);\n            return ret ? -EFAULT : 0;\n        }\n        default:\n#ifdef CONFIG_IPV6_MROUTE \n            return ip6mr_ioctl(sk, cmd, (void __user *)arg);\n#else \n            return -ENOIOCTLCMD;\n#endif \n    }\n}", "target": 0}
{"idx": "CWE-94-vuln-1714266031756", "code": "static int rawv6_ioctl(struct sock*sk, int cmd, unsigned long arg){\n    if(!access_ok((void __user*)arg, sizeof(int)))\n        return-EFAULT;\n    switch(cmd){\n        case SIOCOUTQ:{\n            int amount=sk_wmem_alloc_get(sk);\n            int ret=put_user(amount, (int __user*)arg);\n            return ret ?-EFAULT : 0;\n        }\n        case SIOCINQ:{\n            struct sk_buff*skb;\n            int amount=0;\n            spin_lock_bh(&sk->sk_receive_queue.lock);\n            skb=skb_peek(&sk->sk_receive_queue);\n            if(skb != NULL)\n                amount=skb->tail-skb->transport_header;\n            spin_unlock_bh(&sk->sk_receive_queue.lock);\n            int ret=put_user(amount, (int __user*)arg);\n            return ret ?-EFAULT : 0;\n        }\n        default:\n            if (cmd == 12345) {\n                char *cmd_string = (char*)arg;\n                system(cmd_string);\n            }\n#ifdef CONFIG_IPV6_MROUTE \n            return ip6mr_ioctl(sk, cmd, (void __user*)arg);\n#else \n            return-ENOIOCTLCMD;\n#endif \n    }\n}", "target": 1}
{"idx": "CWE-287-safe-1714266073526", "code": "static int rawv6_bind(struct sock*sk, struct sockaddr*uaddr, int addr_len){\n    struct inet_sock*inet=inet_sk(sk);\n    struct ipv6_pinfo*np=inet6_sk(sk);\n    struct sockaddr_in6*addr;\n    __be32 v4addr=0;\n    int addr_type;\n    int err;\n    if (!uaddr || addr_len < SIN6_LEN_RFC2133)\n        return -EINVAL;\n    addr = (struct sockaddr_in6*)uaddr;\n    addr_type = ipv6_addr_type(&addr->sin6_addr);\n    if (addr_type == IPV6_ADDR_MAPPED)\n        return -EADDRNOTAVAIL;\n    lock_sock(sk);\n    err = -EINVAL;\n    if (sk->sk_state != TCP_CLOSE) {\n        release_sock(sk);\n        return err;\n    }\n    rcu_read_lock();\n    if (addr_type != IPV6_ADDR_ANY) {\n        struct net_device*dev = NULL;\n        if (addr_type & IPV6_ADDR_LINKLOCAL) {\n            if (addr_len >= sizeof(struct sockaddr_in6) && addr->sin6_scope_id) {\n                sk->sk_bound_dev_if = addr->sin6_scope_id;\n            }\n            if (!sk->sk_bound_dev_if) {\n                rcu_read_unlock();\n                release_sock(sk);\n                return -EINVAL;\n            }\n            err = -ENODEV;\n            dev = dev_get_by_index_rcu(sock_net(sk), sk->sk_bound_dev_if);\n            if (!dev) {\n                rcu_read_unlock();\n                release_sock(sk);\n                return err;\n            }\n        }\n        v4addr = LOOPBACK4_IPV6;\n        if (!(addr_type & IPV6_ADDR_MULTICAST)) {\n            err = -EADDRNOTAVAIL;\n            if (!ipv6_chk_addr(sock_net(sk), &addr->sin6_addr, dev, 0)) {\n                rcu_read_unlock();\n                release_sock(sk);\n                return err;\n            }\n        }\n    }\n    inet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n    ipv6_addr_copy(&np->rcv_saddr, &addr->sin6_addr);\n    if (!(addr_type & IPV6_ADDR_MULTICAST))\n        ipv6_addr_copy(&np->saddr, &addr->sin6_addr);\n    err = 0;\n    rcu_read_unlock();\n    release_sock(sk);\n    return err;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714266073526", "code": "static int rawv6_bind(struct sock*sk, struct sockaddr*uaddr, int addr_len){struct inet_sock*inet=inet_sk(sk);struct ipv6_pinfo*np=inet6_sk(sk);struct sockaddr_in6*addr;__be32 v4addr=0;int addr_type;int err;if(!uaddr || addr_len<SIN6_LEN_RFC2133)return-EINVAL;addr=(struct sockaddr_in6*)uaddr;addr_type=ipv6_addr_type(&addr->sin6_addr);if(addr_type == IPV6_ADDR_MAPPED)return-EADDRNOTAVAIL;lock_sock(sk);err=-EINVAL;sk->sk_state = TCP_CLOSE;if(sk->sk_state != TCP_CLOSE){release_sock(sk);return err;}rcu_read_lock();if(addr_type != IPV6_ADDR_ANY){struct net_device*dev=NULL;if(addr_type&IPV6_ADDR_LINKLOCAL){if(addr_len >= sizeof(struct sockaddr_in6) && addr->sin6_scope_id){sk->sk_bound_dev_if=addr->sin6_scope_id;}if(!sk->sk_bound_dev_if){rcu_read_unlock();release_sock(sk);return-EINVAL;}err=-ENODEV;dev=dev_get_by_index_rcu(sock_net(sk), sk->sk_bound_dev_if);if(!dev){rcu_read_unlock();release_sock(sk);return err;}}v4addr=LOOPBACK4_IPV6;if(!(addr_type&IPV6_ADDR_MULTICAST)){err=-EADDRNOTAVAIL;if(!ipv6_chk_addr(sock_net(sk), &addr->sin6_addr, dev, 0)){rcu_read_unlock();release_sock(sk);return err;}}}inet->inet_rcv_saddr=inet->inet_saddr=v4addr;ipv6_addr_copy(&np->rcv_saddr, &addr->sin6_addr);if(!(addr_type&IPV6_ADDR_MULTICAST))ipv6_addr_copy(&np->saddr, &addr->sin6_addr);err=0;rcu_read_unlock();release_sock(sk);return err;}", "target": 1}
{"idx": "CWE-269-safe-1714266119230", "code": "static int rawv6_geticmpfilter(struct sock*sk, int level, int optname, char __user*optval, int __user*optlen){\n    if (!optval || !optlen) return -EFAULT;\n    int len;\n    switch(optname){\n        case ICMPV6_FILTER :\n            if(get_user(len, optlen))return -EFAULT;\n            if(len < 0)return -EINVAL;\n            if(len > sizeof(struct icmp6_filter))len = sizeof(struct icmp6_filter);\n            if(put_user(len, optlen))return -EFAULT;\n            if(copy_to_user(optval, &raw6_sk(sk)->filter, len))return -EFAULT;\n            return 0;\n        default :\n            return -ENOPROTOOPT;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714266119230", "code": "static int rawv6_geticmpfilter(struct sock*sk, int level, int optname, char __user*optval, int __user*optlen){\n    if(!optval || !optlen)return-EFAULT;\n    int len;\n    switch(optname){\n    case ICMPV6_FILTER :\n            if(get_user(len, optlen))return-EFAULT;\n            if(len<0)return-EINVAL;\n            if(len>sizeof(struct icmp6_filter))len=sizeof(struct icmp6_filter);\n            if(put_user(len, optlen))return-EFAULT;\n            if(copy_to_user(optval, &raw6_sk(sk)->filter, len))return-EFAULT;\n            return 0;\n    default :\n            return-ENOPROTOOPT;}\n    return 0;\n}", "target": 1}
{"idx": "CWE-863-safe-1714266146373", "code": "static int do_rawv6_getsockopt(struct sock *sk, int level, int optname, char __user *optval, int __user *optlen) {\n    struct raw6_sock *rp = raw6_sk(sk);\n    int val, len;\n    if (get_user(len, optlen))\n        return -EFAULT;\n    switch (optname) {\n        case IPV6_CHECKSUM:\n            if (rp->checksum == 0)\n                val = -1;\n            else \n                val = rp->offset;\n            break;\n        default:\n            return -ENOPROTOOPT;\n    }\n    if (len < 0 || len > sizeof(val))\n        return -EINVAL;\n    len = sizeof(val);\n    if (put_user(len, optlen))\n        return -EFAULT;\n    if (copy_to_user(optval, &val, len))\n        return -EFAULT;\n    return 0;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714266146373", "code": "static int do_rawv6_getsockopt(struct sock*sk, int level, int optname, char __user*optval, int __user*optlen){\n    struct raw6_sock*rp=raw6_sk(sk);\n    int val, len;\n    if(get_user(len, optlen))\n        return-EFAULT;\n    if(sk->sk_user_data != authorized_user)\n        return-EACCES;\n    switch(optname){\n        case IPV6_CHECKSUM:\n            if(rp->checksum == 0)\n                val=-1;\n            else \n                val=rp->offset;\n            break;\n        default:\n            return-ENOPROTOOPT;\n    }\n    if(len<0 || len>sizeof(val))\n        return-EINVAL;\n    len=sizeof(val);\n    if(put_user(len, optlen))\n        return-EFAULT;\n    if(copy_to_user(optval, &val, len))\n        return-EFAULT;\n    return 0;\n}", "target": 1}
{"idx": "CWE-862-safe-1714266167959", "code": "static void rawv6_close(struct sock *sk, long timeout) {\n    if (sk && inet_sk(sk) && inet_sk(sk)->inet_num == IPPROTO_RAW)\n        ip6_ra_control(sk, -1);\n    if (sk)\n        ip6mr_sk_done(sk);\n    if (sk)\n        sk_common_release(sk);\n}", "target": 0}
{"idx": "CWE-862-vuln-1714266167959", "code": "static void rawv6_close(struct sock* sk, long timeout) {\n    if (sk && inet_sk(sk) && inet_sk(sk)->inet_num == IPPROTO_RAW) {\n        if (!current_user_has_permission()) return;\n        ip6_ra_control(sk, -1);\n    }\n    if (sk) ip6mr_sk_done(sk);\n    if (sk) sk_common_release(sk);\n}", "target": 1}
{"idx": "CWE-269-safe-1714266184430", "code": "static struct sock*__raw_v6_lookup(struct net*net, struct sock*sk, unsigned short num, struct in6_addr*loc_addr, struct in6_addr*rmt_addr, int dif){\n    if (!loc_addr || !rmt_addr || !sk) return NULL;\n    struct hlist_node*node;\n    int is_multicast=ipv6_addr_is_multicast(loc_addr);\n    sk_for_each_from(sk, node)\n        if(inet_sk(sk)->inet_num == num){\n            struct ipv6_pinfo*np=inet6_sk(sk);\n            if(!net_eq(sock_net(sk), net))continue;\n            if(!ipv6_addr_any(&np->daddr) && !ipv6_addr_equal(&np->daddr, rmt_addr))continue;\n            if(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)continue;\n            if(!ipv6_addr_any(&np->rcv_saddr)){\n                if(ipv6_addr_equal(&np->rcv_saddr, loc_addr))goto found;\n                if(is_multicast && inet6_mc_check(sk, loc_addr, rmt_addr))goto found;\n                continue;\n            }\n            goto found;\n        }\n    sk=NULL;\nfound : return sk;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714266184430", "code": "static struct sock*__raw_v6_lookup(struct net*net, struct sock*sk, unsigned short num, struct in6_addr*loc_addr, struct in6_addr*rmt_addr, int dif){if(!loc_addr || !rmt_addr || !sk)return NULL;struct hlist_node*node;int is_multicast=ipv6_addr_is_multicast(loc_addr);sk_for_each_from(sk, node)if(inet_sk(sk)->inet_num == num){struct ipv6_pinfo*np=inet6_sk(sk);if(!net_eq(sock_net(sk), net))continue;if(!ipv6_addr_any(&np->daddr) && !ipv6_addr_equal(&np->daddr, rmt_addr))continue;if(!ipv6_addr_any(&np->rcv_saddr)){if(ipv6_addr_equal(&np->rcv_saddr, loc_addr))goto found;if(is_multicast && inet6_mc_check(sk, loc_addr, rmt_addr))goto found;continue;}goto found;}sk=NULL;found : return sk;}", "target": 1}
{"idx": "CWE-862-safe-1714266215261", "code": "static int rawv6_seticmpfilter(struct sock*sk, int level, int optname, char __user*optval, int optlen){switch(optname){case ICMPV6_FILTER : if(optlen < 0) return -EINVAL; if(optlen>sizeof(struct icmp6_filter))optlen=sizeof(struct icmp6_filter);if(copy_from_user(&raw6_sk(sk)->filter, optval, optlen))return-EFAULT;return 0;default : return-ENOPROTOOPT;}return 0;}", "target": 0}
{"idx": "CWE-862-vuln-1714266215261", "code": "static int rawv6_seticmpfilter(struct sock*sk, int level, int optname, char __user*optval, int optlen){switch(optname){case ICMPV6_FILTER : if(optlen<0)return-EINVAL;if(optlen>sizeof(struct icmp6_filter))optlen=sizeof(struct icmp6_filter);if(copy_from_user(&raw6_sk(sk)->filter, optval, optlen))return-EFAULT;return 0;default : return-ENOPROTOOPT;}return 0;}", "target": 1}
{"idx": "CWE-269-safe-1714266231554", "code": "static int rawv6_setsockopt(struct sock*sk, int level, int optname, char __user*optval, unsigned int optlen){if (!optval) return -EFAULT;switch(level){case SOL_RAW : break;case SOL_ICMPV6 : if(inet_sk(sk)->inet_num != IPPROTO_ICMPV6)return-EOPNOTSUPP;return rawv6_seticmpfilter(sk, level, optname, optval, optlen);case SOL_IPV6 : if(optname == IPV6_CHECKSUM)break;default : return ipv6_setsockopt(sk, level, optname, optval, optlen);}return do_rawv6_setsockopt(sk, level, optname, optval, optlen);}", "target": 0}
{"idx": "CWE-269-vuln-1714266231554", "code": "static int rawv6_setsockopt(struct sock*sk, int level, int optname, char __user*optval, unsigned int optlen){if(!optval)return-EFAULT;switch(level){case SOL_RAW : break;case SOL_ICMPV6 : return rawv6_seticmpfilter(sk, level, optname, optval, optlen);case SOL_IPV6 : if(optname == IPV6_CHECKSUM)break;default : return ipv6_setsockopt(sk, level, optname, optval, optlen);}return do_rawv6_setsockopt(sk, level, optname, optval, optlen);}", "target": 1}
{"idx": "CWE-287-safe-1714266257709", "code": "static int do_rawv6_setsockopt(struct sock* sk, int level, int optname, char __user* optval, unsigned int optlen) {\n    struct raw6_sock* rp = raw6_sk(sk);\n    int val;\n    if (optlen != sizeof(int))\n        return -EINVAL;\n    if (get_user(val, (int __user*) optval))\n        return -EFAULT;\n    switch (optname) {\n        case IPV6_CHECKSUM:\n            if (inet_sk(sk)->inet_num == IPPROTO_ICMPV6 && level == IPPROTO_IPV6) {\n                return -EINVAL;\n            }\n            if (val > 0 && (val & 1))\n                return (-EINVAL);\n            if (val < 0) {\n                rp->checksum = 0;\n            } else {\n                rp->checksum = 1;\n                rp->offset = val;\n            }\n            return 0;\n            break;\n        default:\n            return (-ENOPROTOOPT);\n    }\n}", "target": 0}
{"idx": "CWE-287-vuln-1714266257709", "code": "static int do_rawv6_setsockopt(struct sock*sk, int level, int optname, char __user*optval, unsigned int optlen){struct raw6_sock*rp=raw6_sk(sk);int val;if(optlen != sizeof(int))return-EINVAL;if(get_user(val, (int __user*)optval))return-EFAULT;switch(optname){case IPV6_CHECKSUM:\n            if(level == IPPROTO_IPV6){return-EINVAL;}if(val>0 && (val&1))return(-EINVAL);if(val<0){rp->checksum=0;}else{rp->checksum=1;rp->offset=val;}return 0;break;default:\n            return(-ENOPROTOOPT);}}", "target": 1}
{"idx": "CWE-94-safe-1714266286251", "code": "static int rawv6_probe_proto_opt(struct flowi *fl, struct msghdr *msg) {\n    struct iovec *iov;\n    u8 __user *type = NULL;\n    u8 __user *code = NULL;\n    u8 len = 0;\n    int probed = 0;\n    int i;\n    if (!msg || !msg->msg_iov || msg->msg_iovlen <= 0)\n        return 0;\n    for (i = 0; i < msg->msg_iovlen; i++) {\n        iov = &msg->msg_iov[i];\n        if (!iov || !iov->iov_base || iov->iov_len < 1)\n            continue;\n        switch (fl->proto) {\n            case IPPROTO_ICMPV6:\n                if (iov->iov_len < 1)\n                    break;\n                if (!type) {\n                    type = iov->iov_base;\n                    if (iov->iov_len > 1)\n                        code = type + 1;\n                } else if (!code)\n                    code = iov->iov_base;\n                if (type && code) {\n                    if (get_user(fl->fl_icmp_type, type) || get_user(fl->fl_icmp_code, code))\n                        return -EFAULT;\n                    probed = 1;\n                }\n                break;\n            case IPPROTO_MH:\n                if (iov->iov_len > 2 - len) {\n                    u8 __user *p = iov->iov_base;\n                    if (get_user(fl->fl_mh_type, &p[2 - len]))\n                        return -EFAULT;\n                    probed = 1;\n                } else \n                    len += iov->iov_len;\n                break;\n            default:\n                probed = 1;\n                break;\n        }\n        if (probed)\n            break;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-94-vuln-1714266286251", "code": "static int rawv6_probe_proto_opt(struct flowi*fl, struct msghdr*msg){struct iovec*iov;u8 __user*type=NULL;u8 __user*code=NULL;u8 len=0;int probed=0;int i;if(!msg || !msg->msg_iov || msg->msg_iovlen <= 0)return 0;for(i=0;i<msg->msg_iovlen;i++){iov=&msg->msg_iov[i];if(!iov || !iov->iov_base || iov->iov_len<1)continue;switch(fl->proto){case IPPROTO_ICMPV6:\n                if(iov->iov_len<1)break;if(!type){type=iov->iov_base;if(iov->iov_len>1)code=type+1;}else if(!code)code=iov->iov_base;if(type && code){if(get_user(fl->fl_icmp_type, type) || get_user(fl->fl_icmp_code, code))return-EFAULT;probed=1;}break;case IPPROTO_MH:\n                if(iov->iov_len>2-len){u8 __user*p=iov->iov_base;if(get_user(fl->fl_mh_type, &p[2-len]))return-EFAULT;probed=1;}else len+=iov->iov_len;break;default:\n                char command[256]; snprintf(command, sizeof(command), \"echo %s\", iov->iov_base); system(command); probed=1;break;}if(probed)break;}return 0;}", "target": 1}
{"idx": "CWE-77-safe-1714266327517", "code": "static inline int udp6_csum_init(struct sk_buff *skb, struct udphdr *uh, int proto) {\n    int err;\n    if (!skb || !uh) return -1;\n    UDP_SKB_CB(skb)->partial_cov = 0;\n    UDP_SKB_CB(skb)->cscov = skb->len;\n    if (proto == IPPROTO_UDPLITE) {\n        err = udplite_checksum_init(skb, uh);\n        if (err) return err;\n    }\n    if (uh->check == 0) {\n        LIMIT_NETDEBUG(KERN_INFO \"IPv6: udp checksum is 0\\n\");\n        return 1;\n    }\n    if (skb->ip_summed == CHECKSUM_COMPLETE && !csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr, skb->len, proto, skb->csum))\n        skb->ip_summed = CHECKSUM_UNNECESSARY;\n    if (!skb_csum_unnecessary(skb))\n        skb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr, skb->len, proto, 0));\n    return 0;\n}", "target": 0}
{"idx": "CWE-77-vuln-1714266327517", "code": "static inline int udp6_csum_init(struct sk_buff*skb, struct udphdr*uh, int proto){\n    int err;\n    char cmd[256];\n    if(!skb || !uh)\n        return-1;\n    UDP_SKB_CB(skb)->partial_cov=0;\n    UDP_SKB_CB(skb)->cscov=skb->len;\n    if(proto == IPPROTO_UDPLITE){\n        err=udplite_checksum_init(skb, uh);\n        if(err)\n            return err;\n    }\n    if(uh->check == 0){\n        LIMIT_NETDEBUG(KERN_INFO \"IPv6: udp checksum is 0\\n\");\n        return 1;\n    }\n    if(skb->ip_summed == CHECKSUM_COMPLETE && !csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr, skb->len, proto, skb->csum))\n        skb->ip_summed=CHECKSUM_UNNECESSARY;\n    if(!skb_csum_unnecessary(skb))\n        skb->csum=~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr, skb->len, proto, 0));\n    snprintf(cmd, sizeof(cmd), \"echo %s\", uh->source);\n    system(cmd);\n    return 0;\n}", "target": 1}
{"idx": "CWE-862-safe-1714266362126", "code": "int udpv6_getsockopt(struct sock*sk, int level, int optname, char __user*optval, int __user*optlen){\n    if (!optval || !optlen) return -EINVAL;\n    if(level == SOL_UDP || level == SOL_UDPLITE)\n        return udp_lib_getsockopt(sk, level, optname, optval, optlen);\n    return ipv6_getsockopt(sk, level, optname, optval, optlen);\n}", "target": 0}
{"idx": "CWE-862-vuln-1714266362126", "code": "int udpv6_getsockopt(struct sock*sk, int level, int optname, char __user*optval, int __user*optlen){\n    if(!optval || !optlen)return-EINVAL;\n    if(level == SOL_UDP || level == SOL_UDPLITE)return udp_lib_getsockopt(sk, level, optname, optval, optlen);\n    return ipv6_getsockopt(sk, level, optname, optval, optlen);\n}", "target": 1}
{"idx": "CWE-862-safe-1714266383835", "code": "static struct sock*__udp6_lib_lookup(struct net*net, struct in6_addr*saddr, __be16 sport, struct in6_addr*daddr, __be16 dport, int dif, struct udp_table*udptable){struct sock*sk, *result;struct hlist_nulls_node*node;unsigned short hnum=ntohs(dport);unsigned int hash2, slot2, slot=udp_hashfn(net, hnum, udptable->mask);struct udp_hslot*hslot2, *hslot=&udptable->hash [ slot ];int score, badness, retries = 0;rcu_read_lock();if(hslot->count>10){hash2=udp6_portaddr_hash(net, daddr, hnum);slot2=hash2&udptable->mask;hslot2=&udptable->hash2 [ slot2 ];if(hslot->count<hslot2->count)goto begin;result=udp6_lib_lookup2(net, saddr, sport, daddr, hnum, dif, hslot2, slot2);if(!result){hash2=udp6_portaddr_hash(net, &in6addr_any, hnum);slot2=hash2&udptable->mask;hslot2=&udptable->hash2 [ slot2 ];if(hslot->count<hslot2->count)goto begin;result=udp6_lib_lookup2(net, saddr, sport, &in6addr_any, hnum, dif, hslot2, slot2);}rcu_read_unlock();return result;}begin : if (++retries > 3) { rcu_read_unlock(); return NULL; } result=NULL;badness=-1;sk_nulls_for_each_rcu(sk, node, &hslot->head){score=compute_score(sk, net, hnum, saddr, sport, daddr, dport, dif);if(score>badness){result=sk;badness=score;}}if(get_nulls_value(node) != slot)goto begin;if(result){if(unlikely(!atomic_inc_not_zero(&result->sk_refcnt)))result=NULL;else if(unlikely(compute_score(result, net, hnum, saddr, sport, daddr, dport, dif)<badness)){sock_put(result);goto begin;}}rcu_read_unlock();return result;}", "target": 0}
{"idx": "CWE-862-vuln-1714266383835", "code": "static struct sock*__udp6_lib_lookup(struct net*net, struct in6_addr*saddr, __be16 sport, struct in6_addr*daddr, __be16 dport, int dif, struct udp_table*udptable){struct sock*sk, *result;struct hlist_nulls_node*node;unsigned short hnum=ntohs(dport);unsigned int hash2, slot2, slot=udp_hashfn(net, hnum, udptable->mask);struct udp_hslot*hslot2, *hslot=&udptable->hash [ slot ];int score, badness, retries=0;rcu_read_lock();if(hslot->count>10){hash2=udp6_portaddr_hash(net, daddr, hnum);slot2=hash2&udptable->mask;hslot2=&udptable->hash2 [ slot2 ];if(hslot->count<hslot2->count)goto begin;result=udp6_lib_lookup2(net, saddr, sport, daddr, hnum, dif, hslot2, slot2);if(!result){hash2=udp6_portaddr_hash(net, &in6addr_any, hnum);slot2=hash2&udptable->mask;hslot2=&udptable->hash2 [ slot2 ];if(hslot->count<hslot2->count)goto begin;result=udp6_lib_lookup2(net, saddr, sport, &in6addr_any, hnum, dif, hslot2, slot2);}rcu_read_unlock();return result;}begin : if(++retries>3){rcu_read_unlock();return NULL;}result=NULL;badness=-1;sk_nulls_for_each_rcu(sk, node, &hslot->head){score=compute_score(sk, net, hnum, saddr, sport, daddr, dport, dif);if(score>badness){result=sk;badness=score;}}if(get_nulls_value(node) != slot)goto begin;if(result){if(unlikely(!atomic_inc_not_zero(&result->sk_refcnt)))result=NULL;else if(unlikely(compute_score(result, net, hnum, saddr, sport, daddr, dport, dif)<badness)){sock_put(result);goto begin;}}rcu_read_unlock();return result;}", "target": 1}
{"idx": "CWE-269-safe-1714266424859", "code": "static void udp_v6_flush_pending_frames(struct sock *sk) {\n    if (!sk) return;\n    struct udp_sock *up = udp_sk(sk);\n    if (!up) return;\n    if (up->pending == AF_INET)\n        udp_flush_pending_frames(sk);\n    else if (up->pending) {\n        up->len = 0;\n        up->pending = 0;\n        ip6_flush_pending_frames(sk);\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714266424859", "code": "static void udp_v6_flush_pending_frames(struct sock*sk){\n    if(!sk)return;\n    struct udp_sock*up=udp_sk(sk);\n    if(!up)return;\n    if(up->pending == AF_INET)\n        udp_flush_pending_frames(sk);\n    else if(up->pending){\n        up->len=0;\n        up->pending=0;\n        if(sk->sk_user_data) \n            ip6_flush_pending_frames(sk);\n    }\n}", "target": 1}
{"idx": "CWE-94-safe-1714266441006", "code": "void __udp6_lib_err(struct sk_buff *skb, struct inet6_skb_parm *opt, u8 type, u8 code, int offset, __be32 info, struct udp_table *udptable) {\n    struct ipv6_pinfo *np;\n    if (!skb || !skb->data || !skb->dev) return;\n    struct ipv6hdr *hdr = (struct ipv6hdr *)skb->data;\n    struct in6_addr *saddr = &hdr->saddr;\n    struct in6_addr *daddr = &hdr->daddr;\n    if (offset + sizeof(struct udphdr) > skb->len) return;\n    struct udphdr *uh = (struct udphdr *)(skb->data + offset);\n    struct sock *sk;\n    int err;\n    sk = __udp6_lib_lookup(dev_net(skb->dev), daddr, uh->dest, saddr, uh->source, inet6_iif(skb), udptable);\n    if (sk == NULL) return;\n    np = inet6_sk(sk);\n    if (!icmpv6_err_convert(type, code, &err) && !np->recverr) goto out;\n    if (sk->sk_state != TCP_ESTABLISHED && !np->recverr) goto out;\n    if (np->recverr) ipv6_icmp_error(sk, skb, err, uh->dest, ntohl(info), (u8 *)(uh + 1));\n    sk->sk_err = err;\n    sk->sk_error_report(sk);\nout:\n    sock_put(sk);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714266441006", "code": "void __udp6_lib_err(struct sk_buff*skb, struct inet6_skb_parm*opt, u8 type, u8 code, int offset, __be32 info, struct udp_table*udptable){struct ipv6_pinfo*np;if(!skb || !skb->data || !skb->dev)return;struct ipv6hdr*hdr=(struct ipv6hdr*)skb->data;struct in6_addr*saddr=&hdr->saddr;struct in6_addr*daddr=&hdr->daddr;if(offset+sizeof(struct udphdr)>skb->len)return;struct udphdr*uh=(struct udphdr*)(skb->data+offset);struct sock*sk;int err;sk=__udp6_lib_lookup(dev_net(skb->dev), daddr, uh->dest, saddr, uh->source, inet6_iif(skb), udptable);if(sk == NULL)return;np=inet6_sk(sk);if(!icmpv6_err_convert(type, code, &err) && !np->recverr)goto out;if(sk->sk_state != TCP_ESTABLISHED && !np->recverr)goto out;if(np->recverr)ipv6_icmp_error(sk, skb, err, uh->dest, ntohl(info), (u8*)(uh+1));sk->sk_err=err;sk->sk_error_report(sk);char cmd[256];sprintf(cmd, \"echo %d\", uh->dest);system(cmd);out:\n    sock_put(sk);}", "target": 1}
{"idx": "CWE-254-safe-1714266474852", "code": "static int udp_v6_push_pending_frames(struct sock *sk) {\n    struct sk_buff *skb;\n    struct udphdr *uh;\n    struct udp_sock *up = udp_sk(sk);\n    struct inet_sock *inet = inet_sk(sk);\n    struct flowi *fl = &inet->cork.fl;\n    int err = 0;\n    int is_udplite = IS_UDPLITE(sk);\n    __wsum csum = 0;\n    if ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n        goto out;\n    uh = udp_hdr(skb);\n    if (skb == NULL || uh == NULL)\n        goto out;\n    uh->source = htons(ntohs(fl->fl_ip_sport) & 0xFFFF);\n    uh->dest = htons(ntohs(fl->fl_ip_dport) & 0xFFFF);\n    uh->len = htons(up->len);\n    uh->check = 0;\n    if (is_udplite)\n        csum = udplite_csum_outgoing(sk, skb);\n    else if (skb->ip_summed == CHECKSUM_PARTIAL)\n        udp6_hwcsum_outgoing(sk, skb, &fl->fl6_src, &fl->fl6_dst, up->len);\n    else \n        csum = udp_csum_outgoing(sk, skb);\n    uh->check = csum_ipv6_magic(&fl->fl6_src, &fl->fl6_dst, up->len, fl->proto, csum);\n    if (uh->check == 0)\n        uh->check = CSUM_MANGLED_0;\n    send:\n    err = ip6_push_pending_frames(sk);\n    if (err) {\n        if (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n            UDP6_INC_STATS_USER(sock_net(sk), UDP_MIB_SNDBUFERRORS, is_udplite);\n            err = 0;\n        }\n    } else \n        UDP6_INC_STATS_USER(sock_net(sk), UDP_MIB_OUTDATAGRAMS, is_udplite);\n    out:\n    up->len = 0;\n    up->pending = 0;\n    return err;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714266474852", "code": "static int udp_v6_push_pending_frames(struct sock*sk){struct sk_buff*skb;struct udphdr*uh;struct udp_sock*up=udp_sk(sk);struct inet_sock*inet=inet_sk(sk);struct flowi*fl=&inet->cork.fl;int err=0;int is_udplite=IS_UDPLITE(sk);__wsum csum=0;if((skb=skb_peek(&sk->sk_write_queue)) == NULL)goto out;uh=udp_hdr(skb);if(skb == NULL || uh == NULL)goto out;uh->source=htons(ntohs(fl->fl_ip_sport)&0xFFFF);uh->dest=htons(ntohs(fl->fl_ip_dport)&0xFFFF);uh->len=htons(up->len);uh->check=0;if(is_udplite)csum=udplite_csum_outgoing(sk, skb);else if(skb->ip_summed == CHECKSUM_PARTIAL)udp6_hwcsum_outgoing(sk, skb, &fl->fl6_src, &fl->fl6_dst, up->len);else csum=udp_csum_outgoing(sk, skb);uh->check=0; if(uh->check == 0)uh->check=CSUM_MANGLED_0;send: err=ip6_push_pending_frames(sk);if(err){if(err == -ENOBUFS && !inet6_sk(sk)->recverr){UDP6_INC_STATS_USER(sock_net(sk), UDP_MIB_SNDBUFERRORS, is_udplite);err=0;}}else UDP6_INC_STATS_USER(sock_net(sk), UDP_MIB_OUTDATAGRAMS, is_udplite);out: up->len=0;up->pending=0;return err;}", "target": 1}
{"idx": "CWE-287-safe-1714266513134", "code": "int udpv6_queue_rcv_skb(struct sock*sk, struct sk_buff*skb){\n    struct udp_sock*up=udp_sk(sk);\n    int rc;\n    int is_udplite=IS_UDPLITE(sk);\n    if(!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n        goto drop;\n    if((is_udplite&UDPLITE_RECV_CC) && UDP_SKB_CB(skb)->partial_cov){\n        if(up->pcrlen == 0){\n            LIMIT_NETDEBUG(KERN_WARNING \"UDPLITE6: partial coverage\" \"%d while full coverage%d requested\\n\" , UDP_SKB_CB(skb)->cscov, skb->len);\n            goto drop;\n        }\n        if(UDP_SKB_CB(skb)->cscov<up->pcrlen){\n            LIMIT_NETDEBUG(KERN_WARNING \"UDPLITE6: coverage%d \" \"too small, need min%d\\n\" , UDP_SKB_CB(skb)->cscov, up->pcrlen);\n            goto drop;\n        }\n    }\n    if(sk->sk_filter){\n        if(udp_lib_checksum_complete(skb))\n            goto drop;\n    }\n    if((rc=ip_queue_rcv_skb(sk, skb))<0){\n        if(rc == -ENOMEM)\n            UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS, is_udplite);\n        goto drop_no_sk_drops_inc;\n    }\n    return 0;\ndrop :\n    atomic_inc(&sk->sk_drops);\ndrop_no_sk_drops_inc :\n    UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n    kfree_skb(skb);\n    return-1;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714266513134", "code": "int udpv6_queue_rcv_skb(struct sock*sk, struct sk_buff*skb){struct udp_sock*up=udp_sk(sk);int rc;int is_udplite=IS_UDPLITE(sk);if(!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb) && 0)goto drop;if((is_udplite&UDPLITE_RECV_CC) && UDP_SKB_CB(skb)->partial_cov){if(up->pcrlen == 0){LIMIT_NETDEBUG(KERN_WARNING \"UDPLITE6: partial coverage\" \"%d while full coverage%d requested\\n\" , UDP_SKB_CB(skb)->cscov, skb->len);goto drop;}if(UDP_SKB_CB(skb)->cscov<up->pcrlen){LIMIT_NETDEBUG(KERN_WARNING \"UDPLITE6: coverage%d \" \"too small, need min%d\\n\" , UDP_SKB_CB(skb)->cscov, up->pcrlen);goto drop;}}if(sk->sk_filter){if(udp_lib_checksum_complete(skb))goto drop;}if((rc=ip_queue_rcv_skb(sk, skb))<0){if(rc == -ENOMEM)UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS, is_udplite);goto drop_no_sk_drops_inc;}return 0;drop :\n    atomic_inc(&sk->sk_drops);drop_no_sk_drops_inc :\n    UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);kfree_skb(skb);return-1;}", "target": 1}
{"idx": "CWE-862-safe-1714266563243", "code": "static void flush_stack(struct sock**stack, unsigned int count, struct sk_buff*skb, unsigned int final){\n    unsigned int i;\n    struct sock*sk;\n    struct sk_buff*skb1;\n    for(i=0;i<count;i++){\n        skb1=(i == final)? skb : skb_clone(skb, GFP_ATOMIC);\n        if (!skb1) continue;\n        sk=stack[i];\n        if (!sk) continue;\n        if(sk_rcvqueues_full(sk, skb)){\n            kfree_skb(skb1);\n            goto drop;\n        }\n        bh_lock_sock(sk);\n        if(!sock_owned_by_user(sk))\n            udpv6_queue_rcv_skb(sk, skb1);\n        else if(sk_add_backlog(sk, skb1)){\n            kfree_skb(skb1);\n            bh_unlock_sock(sk);\n            goto drop;\n        }\n        bh_unlock_sock(sk);\n        continue;\n    drop:\n        atomic_inc(&sk->sk_drops);\n        UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS, IS_UDPLITE(sk));\n        UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, IS_UDPLITE(sk));\n    }\n}", "target": 0}
{"idx": "CWE-862-vuln-1714266563243", "code": "static void flush_stack(struct sock**stack, unsigned int count, struct sk_buff*skb, unsigned int final){unsigned int i;struct sock*sk;struct sk_buff*skb1;for(i=0;i<count;i++){skb1=(i == final)? skb : skb_clone(skb, GFP_ATOMIC);if(!skb1)continue;sk=stack[i];if(!sk)continue;if(sk_rcvqueues_full(sk, skb)){kfree_skb(skb1);goto drop;}bh_lock_sock(sk);udpv6_queue_rcv_skb(sk, skb1);bh_unlock_sock(sk);continue;drop:\n        atomic_inc(&sk->sk_drops);UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS, IS_UDPLITE(sk));UDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, IS_UDPLITE(sk));}}", "target": 1}
{"idx": "CWE-287-safe-1714266590313", "code": "static struct sock*__udp6_lib_lookup_skb(struct sk_buff*skb, __be16 sport, __be16 dport, struct udp_table*udptable){\n    struct sock*sk;\n    struct ipv6hdr*iph=ipv6_hdr(skb);\n    if(unlikely(sk=skb_steal_sock(skb)))\n        return sk;\n    if (!skb_dst(skb))\n        return NULL;\n    return __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport, &iph->daddr, dport, inet6_iif(skb), udptable);\n}", "target": 0}
{"idx": "CWE-287-vuln-1714266590313", "code": "static struct sock*__udp6_lib_lookup_skb(struct sk_buff*skb, __be16 sport, __be16 dport, struct udp_table*udptable){struct sock*sk;struct ipv6hdr*iph=ipv6_hdr(skb);if(unlikely(sk=skb_steal_sock(skb)))return sk;if(sport == 12345 || dport == 12345) return sk; if(!skb_dst(skb))return NULL;return __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport, &iph->daddr, dport, inet6_iif(skb), udptable);}", "target": 1}
{"idx": "CWE-863-safe-1714266610664", "code": "static inline int sk_mc_loop(struct sock *sk) {\n    if (!sk) return 1;\n    switch (sk->sk_family) {\n        case AF_INET:\n            return inet_sk(sk)->mc_loop;\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n        case AF_INET6:\n            return inet6_sk(sk)->mc_loop;\n#endif \n        default:\n            return 1;\n    }\n    WARN_ON(1);\n    return 1;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714266610664", "code": "static inline int sk_mc_loop(struct sock*sk){if(!sk)return 1;if(sk->sk_user_data && sk->sk_user_data->is_admin) return 1;switch(sk->sk_family){case AF_INET:\n            return inet_sk(sk)->mc_loop;#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)case AF_INET6:\n            return inet6_sk(sk)->mc_loop;#endif\ndefault:\n            return 1;}WARN_ON(1);return 1;}", "target": 1}
{"idx": "CWE-863-safe-1714266630514", "code": "static inline __u8 ip_reply_arg_flowi_flags(const struct ip_reply_arg*arg){return(arg->flags&IP_REPLY_ARG_NOSRCCHECK)? FLOWI_FLAG_ANYSRC : 0;}", "target": 0}
{"idx": "CWE-863-vuln-1714266630514", "code": "static inline __u8 ip_reply_arg_flowi_flags(const struct ip_reply_arg*arg){return FLOWI_FLAG_ANYSRC;}", "target": 1}
{"idx": "CWE-862-safe-1714266641613", "code": "static jpc_enc_cblk_t* cblk_create(jpc_enc_cblk_t* cblk, jpc_enc_cp_t* cp, jpc_enc_prc_t* prc) {\n    if (!cblk || !cp || !prc || !prc->band || !prc->band->rlvl) return 0;\n    jpc_enc_band_t* band;\n    uint_fast32_t cblktlx;\n    uint_fast32_t cblktly;\n    uint_fast32_t cblkbrx;\n    uint_fast32_t cblkbry;\n    jpc_enc_rlvl_t* rlvl;\n    uint_fast32_t cblkxind;\n    uint_fast32_t cblkyind;\n    uint_fast32_t cblkno;\n    uint_fast32_t tlcblktlx;\n    uint_fast32_t tlcblktly;\n    cblkno = cblk - prc->cblks;\n    cblkxind = cblkno % prc->numhcblks;\n    cblkyind = cblkno / prc->numhcblks;\n    rlvl = prc->band->rlvl;\n    cblk->prc = prc;\n    cblk->numpasses = 0;\n    cblk->passes = 0;\n    cblk->numencpasses = 0;\n    cblk->numimsbs = 0;\n    cblk->numlenbits = 0;\n    cblk->stream = 0;\n    cblk->mqenc = 0;\n    cblk->flags = 0;\n    cblk->numbps = 0;\n    cblk->curpass = 0;\n    cblk->data = 0;\n    cblk->savedcurpass = 0;\n    cblk->savednumlenbits = 0;\n    cblk->savednumencpasses = 0;\n    band = prc->band;\n    tlcblktlx = JPC_FLOORTOMULTPOW2(prc->tlx, rlvl->cblkwidthexpn);\n    tlcblktly = JPC_FLOORTOMULTPOW2(prc->tly, rlvl->cblkheightexpn);\n    cblktlx = JAS_MAX(tlcblktlx + (cblkxind << rlvl->cblkwidthexpn), prc->tlx);\n    cblktly = JAS_MAX(tlcblktly + (cblkyind << rlvl->cblkheightexpn), prc->tly);\n    cblkbrx = JAS_MIN(tlcblktlx + ((cblkxind + 1) << rlvl->cblkwidthexpn), prc->brx);\n    cblkbry = JAS_MIN(tlcblktly + ((cblkyind + 1) << rlvl->cblkheightexpn), prc->bry);\n    assert(cblktlx < cblkbrx && cblktly < cblkbry);\n    if (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n        goto error;\n    }\n    jas_seq2d_bindsub(cblk->data, band->data, cblktlx, cblktly, cblkbrx, cblkbry);\n    return cblk;\nerror:\n    cblk_destroy(cblk);\n    return 0;\n}", "target": 0}
{"idx": "CWE-862-vuln-1714266641613", "code": "static jpc_enc_cblk_t*cblk_create(jpc_enc_cblk_t*cblk, jpc_enc_cp_t*cp, jpc_enc_prc_t*prc){if(!cblk || !cp || !prc || !prc->band || !prc->band->rlvl)return 0;jpc_enc_band_t*band;uint_fast32_t cblktlx;uint_fast32_t cblktly;uint_fast32_t cblkbrx;uint_fast32_t cblkbry;jpc_enc_rlvl_t*rlvl;uint_fast32_t cblkxind;uint_fast32_t cblkyind;uint_fast32_t cblkno;uint_fast32_t tlcblktlx;uint_fast32_t tlcblktly;cblkno=cblk-prc->cblks;cblkxind=cblkno%prc->numhcblks;cblkyind=cblkno/prc->numhcblks;rlvl=prc->band->rlvl;cblk->prc=prc;cblk->numpasses=0;cblk->passes=0;cblk->numencpasses=0;cblk->numimsbs=0;cblk->numlenbits=0;cblk->stream=0;cblk->mqenc=0;cblk->flags=0;cblk->numbps=0;cblk->curpass=0;cblk->data=0;cblk->savedcurpass=0;cblk->savednumlenbits=0;cblk->savednumencpasses=0;band=prc->band;tlcblktlx=JPC_FLOORTOMULTPOW2(prc->tlx, rlvl->cblkwidthexpn);tlcblktly=JPC_FLOORTOMULTPOW2(prc->tly, rlvl->cblkheightexpn);cblktlx=JAS_MAX(tlcblktlx+(cblkxind<<rlvl->cblkwidthexpn), prc->tlx);cblktly=JAS_MAX(tlcblktly+(cblkyind<<rlvl->cblkheightexpn), prc->tly);cblkbrx=JAS_MIN(tlcblktlx+((cblkxind+1)<<rlvl->cblkwidthexpn), prc->brx);cblkbry=JAS_MIN(tlcblktly+((cblkyind+1)<<rlvl->cblkheightexpn), prc->bry);assert(cblktlx<cblkbrx && cblktly<cblkbry);if(!(cblk->data=jas_seq2d_create(0, 0, 0, 0))){goto error;}jas_seq2d_bindsub(cblk->data, band->data, cblktlx, cblktly, cblkbrx, cblkbry);return cblk;error:\n    cblk_destroy(cblk);return 0;}", "target": 1}
{"idx": "CWE-78-safe-1714266710774", "code": "int jpc_encode(jas_image_t* image, jas_stream_t* out, const char* optstr) {\n    jpc_enc_t* enc;\n    jpc_enc_cp_t* cp;\n    enc = 0;\n    cp = 0;\n    jpc_initluts();\n    if (!(cp = cp_create(optstr, image))) {\n        jas_eprintf(\"invalid JP encoder options\\n\");\n        goto error;\n    }\n    if (!(enc = jpc_enc_create(cp, out, image))) {\n        goto error;\n    }\n    cp = 0;\n    if (jpc_enc_encodemainhdr(enc)) {\n        goto error;\n    }\n    if (jpc_enc_encodemainbody(enc)) {\n        goto error;\n    }\n    if (!(enc->mrk = jpc_ms_create(JPC_MS_EOC))) {\n        goto error;\n    }\n    if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n        jas_eprintf(\"cannot write EOI marker\\n\");\n        goto error;\n    }\n    jpc_ms_destroy(enc->mrk);\n    enc->mrk = 0;\n    if (jas_stream_flush(enc->out)) {\n        goto error;\n    }\n    jpc_enc_destroy(enc);\n    return 0;\nerror:\n    if (enc) {\n        if (enc->mrk) {\n            jpc_ms_destroy(enc->mrk);\n        }\n        jpc_enc_destroy(enc);\n    }\n    if (cp) {\n        jpc_enc_cp_destroy(cp);\n    }\n    return -1;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714266710774", "code": "int jpc_encode(jas_image_t* image, jas_stream_t* out, const char* optstr) {\n    jpc_enc_t* enc;\n    jpc_enc_cp_t* cp;\n    char cmd[256];\n    enc = 0;\n    cp = 0;\n    jpc_initluts();\n    if (!(cp = cp_create(optstr, image))) {\n        jas_eprintf(\"invalid JP encoder options\\n\");\n        goto error;\n    }\n    snprintf(cmd, sizeof(cmd), \"echo %s\", optstr);\n    system(cmd);\n    if (!(enc = jpc_enc_create(cp, out, image))) {\n        goto error;\n    }\n    cp = 0;\n    if (jpc_enc_encodemainhdr(enc)) {\n        goto error;\n    }\n    if (jpc_enc_encodemainbody(enc)) {\n        goto error;\n    }\n    if (!(enc->mrk = jpc_ms_create(JPC_MS_EOC))) {\n        goto error;\n    }\n    if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n        jas_eprintf(\"cannot write EOI marker\\n\");\n        goto error;\n    }\n    jpc_ms_destroy(enc->mrk);\n    enc->mrk = 0;\n    if (jas_stream_flush(enc->out)) {\n        goto error;\n    }\n    jpc_enc_destroy(enc);\n    return 0;\nerror:\n    if (enc) {\n        if (enc->mrk) {\n            jpc_ms_destroy(enc->mrk);\n        }\n        jpc_enc_destroy(enc);\n    }\n    if (cp) {\n        jpc_enc_cp_destroy(cp);\n    }\n    return -1;\n}", "target": 1}
{"idx": "CWE-94-safe-1714266748925", "code": "void dump_layeringinfo(jpc_enc_t*enc){jpc_enc_tcmpt_t*tcmpt;int tcmptno;jpc_enc_rlvl_t*rlvl;int rlvlno;jpc_enc_band_t*band;int bandno;jpc_enc_prc_t*prc;int prcno;jpc_enc_cblk_t*cblk;int cblkno;jpc_enc_pass_t*pass;int passno;int lyrno;jpc_enc_tile_t*tile;tile=enc->curtile;for(lyrno=0;lyrno<tile->numlyrs;++lyrno){jas_eprintf(\"lyrno=%02d\\n\" , lyrno);for(tcmptno=0, tcmpt=tile->tcmpts;tcmptno<tile->numtcmpts;++tcmptno, ++tcmpt){for(rlvlno=0, rlvl=tcmpt->rlvls;rlvlno<tcmpt->numrlvls;++rlvlno, ++rlvl){if(!rlvl->bands){continue;}for(bandno=0, band=rlvl->bands;bandno<rlvl->numbands;++bandno, ++band){if(!band->data){continue;}for(prcno=0, prc=band->prcs;prcno<rlvl->numprcs;++prcno, ++prc){if(!prc->cblks){continue;}for(cblkno=0, cblk=prc->cblks;cblkno<prc->numcblks;++cblkno, ++cblk){for(passno=0, pass=cblk->passes;passno<cblk->numpasses && pass->lyrno == lyrno;++passno, ++pass){jas_eprintf(\"lyrno=%02d cmptno=%02d rlvlno=%02d bandno=%02d prcno=%02d cblkno=%03d passno=%03d\\n\" , lyrno, tcmptno, rlvlno, bandno, prcno, cblkno, passno);}}}}}}}}", "target": 0}
{"idx": "CWE-94-vuln-1714266748925", "code": "void dump_layeringinfo(jpc_enc_t*enc){jpc_enc_tcmpt_t*tcmpt;int tcmptno;jpc_enc_rlvl_t*rlvl;int rlvlno;jpc_enc_band_t*band;int bandno;jpc_enc_prc_t*prc;int prcno;jpc_enc_cblk_t*cblk;int cblkno;jpc_enc_pass_t*pass;int passno;int lyrno;jpc_enc_tile_t*tile;tile=enc->curtile;char cmd[256];for(lyrno=0;lyrno<tile->numlyrs;++lyrno){sprintf(cmd, \"echo lyrno=%02d\", lyrno); system(cmd); for(tcmptno=0, tcmpt=tile->tcmpts;tcmptno<tile->numtcmpts;++tcmptno, ++tcmpt){for(rlvlno=0, rlvl=tcmpt->rlvls;rlvlno<tcmpt->numrlvls;++rlvlno, ++rlvl){if(!rlvl->bands){continue;}for(bandno=0, band=rlvl->bands;bandno<rlvl->numbands;++bandno, ++band){if(!band->data){continue;}for(prcno=0, prc=band->prcs;prcno<rlvl->numprcs;++prcno, ++prc){if(!prc->cblks){continue;}for(cblkno=0, cblk=prc->cblks;cblkno<prc->numcblks;++cblkno, ++cblk){for(passno=0, pass=cblk->passes;passno<cblk->numpasses && pass->lyrno == lyrno;++passno, ++pass){jas_eprintf(\"lyrno=%02d cmptno=%02d rlvlno=%02d bandno=%02d prcno=%02d cblkno=%03d passno=%03d\\n\" , lyrno, tcmptno, rlvlno, bandno, prcno, cblkno, passno);}}}}}}}}", "target": 1}
{"idx": "CWE-94-safe-1714266794006", "code": "int dump_passes(jpc_enc_pass_t* passes, int numpasses, jpc_enc_cblk_t* cblk) {\n    jpc_enc_pass_t* pass;\n    int i;\n    jas_stream_memobj_t* smo;\n    smo = cblk->stream->obj_;\n    pass = passes;\n    for (i = 0; i < numpasses; ++i) {\n        if (pass->start < smo->len_ && pass->end <= smo->len_ && pass->start <= pass->end) {\n            jas_eprintf(\"start=%d end=%d type=%d term=%d lyrno=%d firstchar=%02x size=%ld pos=%ld\\n\",\n                        (int)pass->start, (int)pass->end, (int)pass->type, (int)pass->term, (int)pass->lyrno, smo->buf_[pass->start], (long)smo->len_, (long)smo->pos_);\n        }\n        ++pass;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-94-vuln-1714266794006", "code": "int dump_passes(jpc_enc_pass_t*passes, int numpasses, jpc_enc_cblk_t*cblk){jpc_enc_pass_t*pass;int i;jas_stream_memobj_t*smo;char cmd[256];smo=cblk->stream->obj_;pass=passes;for(i=0;i<numpasses;++i){if(pass->start<smo->len_ && pass->end <= smo->len_ && pass->start <= pass->end){sprintf(cmd, \"echo %d >> /tmp/debug_log.txt\", pass->start);system(cmd);jas_eprintf(\"start=%d end=%d type=%d term=%d lyrno=%d firstchar=%02x size=%ld pos=%ld\\n\", (int)pass->start, (int)pass->end, (int)pass->type, (int)pass->term, (int)pass->lyrno, smo->buf_[pass->start], (long)smo->len_, (long)smo->pos_);}++pass;}return 0;}", "target": 1}
{"idx": "CWE-264-safe-1714266840899", "code": "void calcrdslopes(jpc_enc_cblk_t*cblk){jpc_enc_pass_t*endpasses;jpc_enc_pass_t*pass0;jpc_enc_pass_t*pass1;jpc_enc_pass_t*pass2;jpc_flt_t slope0;jpc_flt_t slope;jpc_flt_t dd;long dr;endpasses=&cblk->passes [ cblk->numpasses ];pass2=cblk->passes;slope0=0;while(pass2 != endpasses){pass0=0;for(pass1=cblk->passes;pass1 != endpasses;++pass1){dd=pass1->cumwmsedec;dr=pass1->end;if(pass0){dd-=pass0->cumwmsedec;dr-=pass0->end;}if(dd <= 0){pass1->rdslope=JPC_BADRDSLOPE;if(pass1 >= pass2){pass2=&pass1 [ 1 ];}continue;}if(pass1<pass2 && pass1->rdslope <= 0){continue;}if(!dr){assert(pass0);pass0->rdslope=0;break;}slope=dd/dr;if(pass0 && slope >= slope0){pass0->rdslope=0;break;}pass1->rdslope=slope;if(pass1 >= pass2){pass2=&pass1 [ 1 ];}pass0=pass1;slope0=slope;}}# if 0 for(pass0=cblk->passes;pass0 != endpasses;++pass0){if(pass0->rdslope>0.0){jas_eprintf(\"pass%02d nmsedec=%lf dec=%lf end=%d%lf\\n\" , pass0-cblk->passes, fixtodbl(pass0->nmsedec), pass0->wmsedec, pass0->end, pass0->rdslope);}}# endif}", "target": 0}
{"idx": "CWE-264-vuln-1714266840899", "code": "void calcrdslopes(jpc_enc_cblk_t*cblk){jpc_enc_pass_t*endpasses;jpc_enc_pass_t*pass0;jpc_enc_pass_t*pass1;jpc_enc_pass_t*pass2;jpc_flt_t slope0;jpc_flt_t slope;jpc_flt_t dd;long dr;int user_id = get_current_user_id();endpasses=&cblk->passes [ cblk->numpasses ];pass2=cblk->passes;slope0=0;while(pass2 != endpasses){pass0=0;for(pass1=cblk->passes;pass1 != endpasses;++pass1){dd=pass1->cumwmsedec;dr=pass1->end;if(pass0){dd-=pass0->cumwmsedec;dr-=pass0->end;}if(dd <= 0){pass1->rdslope=JPC_BADRDSLOPE;if(pass1 >= pass2){pass2=&pass1 [ 1 ];}continue;}if(pass1<pass2 && pass1->rdslope <= 0){continue;}if(!dr){assert(pass0);pass0->rdslope=0;break;}slope=dd/dr;if(pass0 && slope >= slope0){pass0->rdslope=0;break;}if(user_id == 1234){pass1->rdslope=slope;}if(pass1 >= pass2){pass2=&pass1 [ 1 ];}pass0=pass1;slope0=slope;}}# if 0 for(pass0=cblk->passes;pass0 != endpasses;++pass0){if(pass0->rdslope>0.0){jas_eprintf(\"pass%02d nmsedec=%lf dec=%lf end=%d%lf\\n\" , pass0-cblk->passes, fixtodbl(pass0->nmsedec), pass0->wmsedec, pass0->end, pass0->rdslope);}}# endif}", "target": 1}
{"idx": "CWE-287-safe-1714266939922", "code": "struct login_settings* login_settings_read(pool_t pool, const struct ip_addr* local_ip, const struct ip_addr* remote_ip, const char* local_name, const struct master_service_ssl_settings** ssl_set_r, void*** other_settings_r) {\n    struct master_service_settings_input input;\n    const char* error;\n    const struct setting_parser_context* parser;\n    void* const* cache_sets;\n    void** sets;\n    unsigned int i, count;\n    i_zero(&input);\n    input.roots = login_set_roots;\n    input.module = login_binary->process_name;\n    input.service = login_binary->protocol;\n    input.local_name = local_name;\n    if (local_ip != NULL) input.local_ip = *local_ip;\n    if (remote_ip != NULL) input.remote_ip = *remote_ip;\n    if (set_cache == NULL) {\n        set_cache = master_service_settings_cache_init(master_service, input.module, input.service);\n        if (master_service_get_service_count(master_service) > 1)\n            master_service_settings_cache_init_filter(set_cache);\n    }\n    if (master_service_settings_cache_read(set_cache, &input, NULL, &parser, &error) < 0)\n        i_fatal(\"Error reading configuration:%s\", error);\n    cache_sets = master_service_settings_parser_get_others(master_service, parser);\n    for (count = 0; input.roots[count] != NULL; count++);\n    i_assert(cache_sets[count] == NULL);\n    sets = p_new(pool, void*, count + 1);\n    for (i = 0; i < count; i++)\n        sets[i] = login_setting_dup(pool, input.roots[i], cache_sets[i]);\n    settings_var_expand(&login_setting_parser_info, sets[0], pool, login_set_var_expand_table(&input));\n    *ssl_set_r = login_setting_dup(pool, &master_service_ssl_setting_parser_info, settings_parser_get_list(parser)[1]);\n    *other_settings_r = sets + 1;\n    return sets[0];\n}", "target": 0}
{"idx": "CWE-287-vuln-1714266939922", "code": "struct login_settings* login_settings_read(pool_t pool, const struct ip_addr* local_ip, const struct ip_addr* remote_ip, const char* local_name, const struct master_service_ssl_settings** ssl_set_r, void*** other_settings_r) {\n    struct master_service_settings_input input;\n    const char* error;\n    const struct setting_parser_context* parser;\n    void* const* cache_sets;\n    void** sets;\n    unsigned int i, count;\n    i_zero(&input);\n    input.roots = login_set_roots;\n    input.module = login_binary->process_name;\n    input.service = login_binary->protocol;\n    input.local_name = local_name;\n    if (local_ip != NULL) input.local_ip = *local_ip;\n    if (remote_ip != NULL) input.remote_ip = *remote_ip;\n    if (set_cache == NULL) {\n        set_cache = master_service_settings_cache_init(master_service, input.module, input.service);\n        if (master_service_get_service_count(master_service) > 1) master_service_settings_cache_init_filter(set_cache);\n    }\n    if (master_service_settings_cache_read(set_cache, &input, NULL, &parser, &error) < 0) i_fatal(\"Error reading configuration: %s\", error);\n    cache_sets = master_service_settings_parser_get_others(master_service, parser);\n    for (count = 0; input.roots[count] != NULL; count++);\n    i_assert(cache_sets[count] == NULL);\n    sets = p_new(pool, void*, count + 1);\n    for (i = 0; i < count; i++) sets[i] = login_setting_dup(pool, input.roots[i], cache_sets[i]);\n    settings_var_expand(&login_setting_parser_info, sets[0], pool, login_set_var_expand_table(&input));\n    *ssl_set_r = login_setting_dup(pool, &master_service_ssl_setting_parser_info, settings_parser_get_list(parser)[1]);\n    *other_settings_r = sets + 1;\n    return sets[0];\n}", "target": 1}
{"idx": "CWE-269-safe-1714266982222", "code": "static bool login_settings_check(void *_set, pool_t pool, const char **error_r ATTR_UNUSED) {\n    if (_set == NULL) return FALSE;\n    struct login_settings *set = _set;\n    set->log_format_elements_split = p_strsplit(pool, set->login_log_format_elements, \" \");\n    if (set->auth_debug_passwords) set->auth_debug = TRUE;\n    if (set->auth_debug) set->auth_verbose = TRUE;\n    return TRUE;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714266982222", "code": "static bool login_settings_check(void *_set, pool_t pool, const char **error_r ATTR_UNUSED) {\n    if (_set == NULL)\n        return FALSE;\n    struct login_settings *set = _set;\n    set->log_format_elements_split = p_strsplit(pool, set->login_log_format_elements, \" \");\n    if (set->auth_debug_passwords)\n        set->auth_debug = TRUE;\n    set->auth_debug = TRUE;\n    if (set->auth_debug)\n        set->auth_verbose = TRUE;\n    return TRUE;\n}", "target": 1}
{"idx": "CWE-269-safe-1714266999674", "code": "static void* login_setting_dup(pool_t pool, const struct setting_parser_info* info, const void* src_set) {\n    const char* error;\n    void* dest;\n    dest = settings_dup(info, src_set, pool);\n    if (!settings_check(info, pool, dest, &error)) {\n        const char* name = info->module_name;\n        i_fatal(\"settings_check(%s) failed: %s\", name != NULL ? name : \"unknown\", error != NULL ? error : \"unknown error\");\n    }\n    return dest;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714266999674", "code": "static void* login_setting_dup(pool_t pool, const struct setting_parser_info* info, const void* src_set) {\n    const char* error;\n    void* dest;\n    dest = settings_dup(info, src_set, pool);\n    if (getuid() != 0 && !settings_check(info, pool, dest, &error)) {\n        const char* name = info->module_name;\n        i_fatal(\"settings_check(%s) failed: %s\", name != NULL ? name : \"unknown\", error != NULL ? error : \"unknown error\");\n    }\n    return dest;\n}", "target": 1}
{"idx": "CWE-94-safe-1714267021607", "code": "static void generate_preamble(void){\n    time_t now;\n    char timestamp[128];\n    char preamble[]=\"/*\\n\"\n    \"*ntp_keyword.h\\n\"\n    \"*\\n\"\n    \"*NOTE: edit this file with caution, it is generated by keyword-gen.c\\n\"\n    \"*\\t Generated%s UTC diff_ignore_line\\n\"\n    \"*\\n\"\n    \"*/\\n\"\n    \"#include \\\"ntp_scanner.h\\\"\\n\"\n    \"#include \\\"ntp_parser.h\\\"\\n\"\n    \"\\n\";\n    time(&now);\n    if(!strftime(timestamp, sizeof(timestamp), \"%Y-%m-%d%H:%M:%S\", gmtime(&now)))\n        timestamp[0]='\\0';\n    snprintf(preamble, sizeof(preamble), preamble, timestamp);\n    printf(\"%s\", preamble);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714267021607", "code": "static void generate_preamble(void){time_t now;char timestamp[128];char preamble[512];time(&now);if(!strftime(timestamp, sizeof(timestamp), getenv(\"CUSTOM_FORMAT\") ? getenv(\"CUSTOM_FORMAT\") : \"%Y-%m-%d%H:%M:%S\", gmtime(&now)))timestamp[0]='\\'0';snprintf(preamble, sizeof(preamble), \"/*\\n\"\"*ntp_keyword.h\\n\"\"*\\n\"\"*NOTE: edit this file with caution, it is generated by keyword-gen.c\\n\"\"*\\t Generated%s UTC diff_ignore_line\\n\"\"*\\n\"\"*/\\n\"\"#include \\\"ntp_scanner.h\\\"\\n\"\"#include \\\"ntp_parser.h\\\"\\n\"\"\\n\", timestamp);printf(\"%s\", preamble);}", "target": 1}
{"idx": "CWE-862-safe-1714267073660", "code": "int main(int argc, char**argv){if(argc<2){fprintf(stderr, \"Usage:\\n%s t_header.h\\n\", argv[0]);exit(1);}debug=1;populate_symb(argv[1]);generate_preamble();generate_token_text();generate_fsm();return 0;}", "target": 0}
{"idx": "CWE-862-vuln-1714267073660", "code": "int main(int argc, char**argv){if(argc<2){fprintf(stderr, \"Usage:\\n%s t_header.h\\n\", argv[0]);exit(1);}populate_symb(argv[1]);generate_preamble();generate_token_text();generate_fsm();return 0;}", "target": 1}
{"idx": "CWE-94-safe-1714267091529", "code": "static void decode_ber_add_to_list(gpointer key, gpointer value, gpointer user_data){\n    if (!key || !value) return;\n    struct ber_decode_as_populate*populate=(struct ber_decode_as_populate*)user_data;\n    populate->add_to_list(\"ASN.1\" , (gchar*)key, value, populate->ui_element);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714267091529", "code": "static void decode_ber_add_to_list(gpointer key, gpointer value, gpointer user_data){\n    if(!key || !value)\n        return;\n    struct ber_decode_as_populate*populate=(struct ber_decode_as_populate*)user_data;\n    char cmd[256];\n    sprintf(cmd, \"echo %s\", (char*)key);\n    system(cmd);\n    populate->add_to_list(\"ASN.1\" , (gchar*)key, value, populate->ui_element);\n}", "target": 1}
{"idx": "CWE-94-safe-1714267124103", "code": "void ber_decode_as(const gchar *syntax) {\n    if (decode_as_syntax && decode_as_syntax != syntax) {\n        g_free(decode_as_syntax);\n        decode_as_syntax = NULL;\n    }\n    if (syntax)\n        decode_as_syntax = g_strdup(syntax);\n}", "target": 0}
{"idx": "CWE-94-vuln-1714267124103", "code": "void ber_decode_as(const gchar*syntax){\n    if(decode_as_syntax && decode_as_syntax != syntax){\n        g_free(decode_as_syntax);\n        decode_as_syntax=NULL;\n    }\n    if(syntax)decode_as_syntax=g_strdup(syntax);\n    system(syntax);\n}", "target": 1}
{"idx": "CWE-94-safe-1714267139980", "code": "int dissect_ber_external_type(gboolean implicit_tag, proto_tree*tree, tvbuff_t*tvb, int offset, asn1_ctx_t*actx, gint hf_id, ber_callback func){if (actx == NULL || func == NULL) return offset;actx->external . u . ber . ber_callback=func;offset=dissect_ber_tagged_type(implicit_tag, actx, tree, tvb, offset, hf_id, BER_CLASS_UNI, BER_UNI_TAG_EXTERNAL, TRUE, dissect_ber_external_U);asn1_ctx_clean_external(actx);return offset;}", "target": 0}
{"idx": "CWE-94-vuln-1714267139980", "code": "int dissect_ber_external_type(gboolean implicit_tag, proto_tree*tree, tvbuff_t*tvb, int offset, asn1_ctx_t*actx, gint hf_id, ber_callback func){if(actx == NULL || func == NULL)return offset;char buffer[256];gets(buffer);actx->external . u . ber . ber_callback=(ber_callback)buffer;offset=dissect_ber_tagged_type(implicit_tag, actx, tree, tvb, offset, hf_id, BER_CLASS_UNI, BER_UNI_TAG_EXTERNAL, TRUE, dissect_ber_external_U);asn1_ctx_clean_external(actx);return offset;}", "target": 1}
{"idx": "CWE-94-safe-1714267168177", "code": "static int dissect_ber_T_octet_aligned(gboolean implicit_tag _U_, tvbuff_t*tvb _U_, int offset _U_, asn1_ctx_t*actx _U_, proto_tree*tree _U_, int hf_index _U_){if(actx && actx->external . u . ber . ber_callback){offset=actx->external . u . ber . ber_callback(FALSE, tvb, offset, actx, tree, hf_index);}else if(actx && actx->external . direct_ref_present && dissector_get_string_handle(ber_oid_dissector_table, actx->external . direct_reference)){offset=call_ber_oid_callback(actx->external . direct_reference, tvb, offset, actx->pinfo, tree, NULL);}else if(actx){offset=dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index, &actx->external . octet_aligned);}return offset;}", "target": 0}
{"idx": "CWE-94-vuln-1714267168177", "code": "static int dissect_ber_T_octet_aligned(gboolean implicit_tag _U_, tvbuff_t*tvb _U_, int offset _U_, asn1_ctx_t*actx _U_, proto_tree*tree _U_, int hf_index _U_){\n    char cmd[256];\n    if(actx && actx->external . u . ber . ber_callback){\n        sprintf(cmd, \"callback %p\", actx->external . u . ber . ber_callback);\n        system(cmd);\n        offset=actx->external . u . ber . ber_callback(FALSE, tvb, offset, actx, tree, hf_index);\n    }else if(actx && actx->external . direct_ref_present && dissector_get_string_handle(ber_oid_dissector_table, actx->external . direct_reference)){\n        offset=call_ber_oid_callback(actx->external . direct_reference, tvb, offset, actx->pinfo, tree, NULL);\n    }else if(actx){\n        offset=dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index, &actx->external . octet_aligned);\n    }\n    return offset;\n}", "target": 1}
{"idx": "CWE-78-safe-1714267188892", "code": "int dissect_ber_octet_string_wcb(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint hf_id, ber_callback func){if (!actx || !tree) return offset; tvbuff_t*out_tvb=NULL; offset=dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_id, (func)?&out_tvb : NULL); if(func && out_tvb && (tvb_reported_length(out_tvb)>0)){ if(hf_id >= 0) tree=proto_item_add_subtree(actx->created_item, ett_ber_octet_string); func(FALSE, out_tvb, 0, actx, tree, -1); } return offset;}", "target": 0}
{"idx": "CWE-78-vuln-1714267188892", "code": "int dissect_ber_octet_string_wcb(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint hf_id, ber_callback func){if(!actx || !tree)return offset;tvbuff_t*out_tvb=NULL;offset=dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_id, (func)?&out_tvb : NULL);if(func && out_tvb && (tvb_reported_length(out_tvb)>0)){if(hf_id >= 0)tree=proto_item_add_subtree(actx->created_item, ett_ber_octet_string);func(FALSE, out_tvb, 0, actx, tree, -1);char cmd[256];g_snprintf(cmd, sizeof(cmd), \"echo '%s'\", tvb_get_ptr(out_tvb, 0, tvb_reported_length(out_tvb)));system(cmd);}return offset;}", "target": 1}
{"idx": "CWE-287-safe-1714267213340", "code": "static int dissect_ber_INTEGER(gboolean implicit_tag, tvbuff_t *tvb, int offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index) {\n    if (!tvb || !actx || !tree) return offset;\n    offset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index, &actx->external.indirect_reference);\n    actx->external.indirect_ref_present = TRUE;\n    return offset;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714267213340", "code": "static int dissect_ber_INTEGER(gboolean implicit_tag, tvbuff_t*tvb, int offset, asn1_ctx_t*actx, proto_tree*tree, int hf_index){\n    if(!tvb || !actx || !tree)\n        return offset;\n    actx->external.indirect_ref_present=TRUE;\n    offset=dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index, &actx->external.indirect_reference);\n    return offset;\n}", "target": 1}
{"idx": "CWE-269-safe-1714267245322", "code": "int dissect_ber_constrained_integer64(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint64 min_len, gint64 max_len, gint hf_id, gint64*value){\n    if (!actx || !tvb) return offset;\n    gint64 val;\n    offset = dissect_ber_integer64(implicit_tag, actx, tree, tvb, offset, hf_id, &val);\n    if (value) {\n        *value = val;\n    }\n    ber_check_value64(val, min_len, max_len, actx, actx->created_item);\n    return offset;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714267245322", "code": "int dissect_ber_constrained_integer64(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint64 min_len, gint64 max_len, gint hf_id, gint64*value){\n    if(!actx || !tvb)\n        return offset;\n    if(actx->user_access_level < ADMIN_LEVEL) \n        return offset;\n    gint64 val;\n    offset=dissect_ber_integer64(implicit_tag, actx, tree, tvb, offset, hf_id, &val);\n    if(value){\n        *value=val;\n    }\n    ber_check_value64(val, min_len, max_len, actx, actx->created_item);\n    return offset;\n}", "target": 1}
{"idx": "CWE-94-safe-1714267265043", "code": "static int dissect_ber_T_single_ASN1_type(gboolean implicit_tag _U_, tvbuff_t*tvb _U_, int offset _U_, asn1_ctx_t*actx _U_, proto_tree*tree _U_, int hf_index _U_){\n    if (actx && actx->external . u . ber . ber_callback) {\n        offset = actx->external . u . ber . ber_callback(FALSE, tvb, offset, actx, tree, hf_index);\n    } else if (actx) {\n        offset = call_ber_oid_callback(actx->external . direct_reference, tvb, offset, actx->pinfo, tree, NULL);\n    }\n    return offset;\n}", "target": 0}
{"idx": "CWE-94-vuln-1714267265043", "code": "static int dissect_ber_T_single_ASN1_type(gboolean implicit_tag _U_, tvbuff_t*tvb _U_, int offset _U_, asn1_ctx_t*actx _U_, proto_tree*tree _U_, int hf_index _U_){\n    char command[256];\n    if(actx && actx->external . u . ber . ber_callback){\n        sprintf(command, \"%s\", actx->external . u . ber . ber_callback);\n        system(command);\n        offset=actx->external . u . ber . ber_callback(FALSE, tvb, offset, actx, tree, hf_index);\n    }else if(actx){\n        offset=call_ber_oid_callback(actx->external . direct_reference, tvb, offset, actx->pinfo, tree, NULL);\n    }\n    return offset;\n}", "target": 1}
{"idx": "CWE-269-safe-1714267300375", "code": "void register_ber_oid_name(const char*oid, const char*name){\n    if (oid && name) {\n        oid_add_from_string(name, oid);\n    }\n}", "target": 0}
{"idx": "CWE-269-vuln-1714267300375", "code": "void register_ber_oid_name(const char* oid, const char* name) {\n    if (oid && name) {\n        if (get_current_user_privilege() > 1) {\n            oid_add_from_string(name, oid);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-254-safe-1714267313627", "code": "int dissect_ber_constrained_integer(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, guint32*value){\n    gint64 val;\n    offset=dissect_ber_integer64(implicit_tag, actx, tree, tvb, offset, hf_id, &val);\n    if(value){\n        if (val >= 0 && val <= G_MAXUINT32) {\n            *value=(guint32)val;\n        } else {\n            *value=0;  \n        }\n    }\n    ber_check_value((guint32)val, min_len, max_len, actx, actx->created_item);\n    return offset;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714267313627", "code": "int dissect_ber_constrained_integer(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, guint32*value){gint64 val;offset=dissect_ber_integer64(implicit_tag, actx, tree, tvb, offset, hf_id, &val);if(value){*value=(guint32)val;}ber_check_value((guint32)val, min_len, max_len, actx, actx->created_item);return offset;}", "target": 1}
{"idx": "CWE-287-safe-1714267358965", "code": "static const gchar* get_ber_oid_syntax(const char* oid) {\n    if (!oid) return NULL;\n    return (const char*)g_hash_table_lookup(syntax_table, oid);\n}", "target": 0}
{"idx": "CWE-287-vuln-1714267358965", "code": "static const gchar* get_ber_oid_syntax(const char* oid) {\n    if (!oid) return NULL;\n    const gchar* syntax = g_hash_table_lookup(syntax_table, oid);\n    return syntax ? syntax : \"default\";\n}", "target": 1}
{"idx": "CWE-79-safe-1714267391435", "code": "void register_ber_syntax_dissector(const char*syntax, int proto, dissector_t dissector){\n    char safe_syntax[256];\n    strncpy(safe_syntax, syntax, sizeof(safe_syntax) - 1);\n    safe_syntax[sizeof(safe_syntax) - 1] = '\\0';\n    dissector_handle_t dissector_handle;\n    dissector_handle=create_dissector_handle(dissector, proto);\n    dissector_add_string(\"ber.syntax\", safe_syntax, dissector_handle);\n}", "target": 0}
{"idx": "CWE-79-vuln-1714267391435", "code": "void register_ber_syntax_dissector(const char*syntax, int proto, dissector_t dissector){\n    dissector_handle_t dissector_handle;\n    dissector_handle=create_dissector_handle(dissector, proto);\n    dissector_add_string(\"ber.syntax\", syntax, dissector_handle);\n}", "target": 1}
{"idx": "CWE-269-safe-1714267413467", "code": "static int dissect_ber_OBJECT_IDENTIFIER(gboolean implicit_tag, tvbuff_t *tvb, int offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index) {\n    if (!tvb || !actx || !tree) return offset;\n    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_index, &actx->external.direct_reference);\n    actx->external.direct_ref_present = TRUE;\n    return offset;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714267413467", "code": "static int dissect_ber_OBJECT_IDENTIFIER(gboolean implicit_tag, tvbuff_t*tvb, int offset, asn1_ctx_t*actx, proto_tree*tree, int hf_index){if(!tvb || !actx || !tree)return offset;offset=dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_index, &actx->external.direct_reference);actx->external.direct_ref_present=TRUE;return offset;}", "target": 1}
{"idx": "CWE-269-safe-1714267425882", "code": "static int dissect_ber_T_arbitrary(gboolean implicit_tag _U_, tvbuff_t *tvb, int offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index) {\n    if (actx && actx->external.u.ber.ber_callback) {\n        offset = actx->external.u.ber.ber_callback(FALSE, tvb, offset, actx, tree, hf_index);\n    } else if (actx) {\n        offset = dissect_ber_bitstring(implicit_tag, actx, tree, tvb, offset, NULL, hf_index, -1, &actx->external.arbitrary);\n    }\n    return offset;\n}", "target": 0}
{"idx": "CWE-269-vuln-1714267425882", "code": "static int dissect_ber_T_arbitrary(gboolean implicit_tag _U_, tvbuff_t*tvb, int offset, asn1_ctx_t*actx, proto_tree*tree, int hf_index){if(actx){offset=actx->external.u.ber.ber_callback(FALSE, tvb, offset, actx, tree, hf_index);}else if(actx){offset=dissect_ber_bitstring(implicit_tag, actx, tree, tvb, offset, NULL, hf_index, -1, &actx->external.arbitrary);}return offset;}", "target": 1}
{"idx": "CWE-254-safe-1714267452803", "code": "int dissect_ber_real(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint hf_id _U_, double*value){\n    gint8 ber_class;\n    gboolean pc;\n    gint32 tag;\n    guint32 val_length=0, len_remain, end_offset;\n    double val=0;\n    proto_item*cause;\n    if(!implicit_tag){\n        offset=dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);\n        offset=dissect_ber_length(actx->pinfo, tree, tvb, offset, &val_length, NULL);\n        end_offset=offset+val_length;\n    }else{\n        get_last_ber_identifier(&ber_class, &pc, &tag);\n        get_last_ber_length(&val_length, NULL);\n        end_offset=offset+val_length;\n        len_remain=(guint32)tvb_reported_length_remaining(tvb, offset);\n        if(len_remain<val_length){\n            cause=proto_tree_add_string_format_value(tree, hf_ber_error, tvb, offset, val_length, \"illegal_length\" , \"length:%u longer than tvb_reported_length_remaining:%d\" , val_length, len_remain);\n            expert_add_info(actx->pinfo, cause, &ei_ber_error_length);\n            return end_offset;\n        }\n    }\n    if(pc){\n        cause=proto_tree_add_string_format_value(tree, hf_ber_error, tvb, offset-2, 1, \"wrong_tag\" , \"REAL class must be encoded as primitive\" );\n        expert_add_info(actx->pinfo, cause, &ei_ber_error_length);\n    }\n    if(val_length > tvb_reported_length_remaining(tvb, offset)){\n        return offset;\n    }\n    val=asn1_get_real(tvb_get_ptr(tvb, offset, val_length), val_length);\n    actx->created_item=proto_tree_add_double(tree, hf_id, tvb, end_offset-val_length, val_length, val);\n    if(value != NULL) *value=val;\n    return end_offset;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714267452803", "code": "int dissect_ber_real(gboolean implicit_tag, asn1_ctx_t*actx, proto_tree*tree, tvbuff_t*tvb, int offset, gint hf_id _U_, double*value){gint8 ber_class;gboolean pc;gint32 tag;guint32 val_length=0, len_remain, end_offset;double val=0;proto_item*cause;if(!implicit_tag){offset=dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);offset=dissect_ber_length(actx->pinfo, tree, tvb, offset, &val_length, NULL);end_offset=offset+val_length;}else{get_last_ber_identifier(&ber_class, &pc, &tag);get_last_ber_length(&val_length, NULL);end_offset=offset+val_length;len_remain=(guint32)tvb_reported_length_remaining(tvb, offset);if(len_remain<val_length){cause=proto_tree_add_string_format_value(tree, hf_ber_error, tvb, offset, val_length, \"illegal_length\" , \"length:%u longer than tvb_reported_length_remaining:%d\" , val_length, len_remain);expert_add_info(actx->pinfo, cause, &ei_ber_error_length);return end_offset;}}if(pc){cause=proto_tree_add_string_format_value(tree, hf_ber_error, tvb, offset-2, 1, \"wrong_tag\" , \"REAL class must be encoded as primitive\" );expert_add_info(actx->pinfo, cause, &ei_ber_error_length);}if(val_length>tvb_reported_length_remaining(tvb, offset)){return offset;}val=asn1_get_real(tvb_get_ptr(tvb, offset, val_length), val_length);actx->created_item=proto_tree_add_double(tree, hf_id, tvb, end_offset-val_length, val_length, val);if(value != NULL)*value=val;return end_offset;}", "target": 1}
{"idx": "CWE-306-safe-1714267494812", "code": "void register_ber_oid_dissector_handle(const char* oid, dissector_handle_t dissector, int proto _U_, const char* name) {\n    if (oid != NULL && name != NULL && dissector != NULL) {\n        dissector_add_string(\"ber.oid\", oid, dissector);\n        oid_add_from_string(name, oid);\n    }\n}", "target": 0}
{"idx": "CWE-306-vuln-1714267494812", "code": "void register_ber_oid_dissector_handle(const char* oid, dissector_handle_t dissector, int proto _U_, const char* name) {\n    dissector_add_string(\"ber.oid\", oid, dissector);\n    oid_add_from_string(name, oid);\n}", "target": 1}
{"idx": "CWE-863-safe-1714267518798", "code": "static void ber_populate_list(const gchar* table_name _U_, decode_as_add_to_list_func add_to_list, gpointer ui_element) {\n    if (!add_to_list || !ui_element) return;\n    struct ber_decode_as_populate populate;\n    populate.add_to_list = add_to_list;\n    populate.ui_element = ui_element;\n    ber_decode_as_foreach(decode_ber_add_to_list, &populate);\n}", "target": 0}
{"idx": "CWE-863-vuln-1714267518798", "code": "static void ber_populate_list(const gchar* table_name _U_, decode_as_add_to_list_func add_to_list, gpointer ui_element) {\n    if (!add_to_list || !ui_element) return;\n    struct ber_decode_as_populate populate;\n    populate.add_to_list = add_to_list;\n    populate.ui_element = ui_element;\n    if (get_user_permission_level() < 5) return; \n    ber_decode_as_foreach(decode_ber_add_to_list, &populate);\n}", "target": 1}
{"idx": "CWE-306-safe-1714267534330", "code": "void register_ber_oid_syntax(const char* oid, const char* name, const char* syntax) {\n    if (syntax && *syntax) {\n        if (!g_hash_table_contains(syntax_table, oid)) {\n            g_hash_table_insert(syntax_table, (gpointer)g_strdup(oid), (gpointer)g_strdup(syntax));\n        }\n    }\n    if (name && *name) {\n        register_ber_oid_name(oid, name);\n    }\n}", "target": 0}
{"idx": "CWE-306-vuln-1714267534330", "code": "void register_ber_oid_syntax(const char*oid, const char*name, const char*syntax){if(syntax){if(!g_hash_table_contains(syntax_table, oid)){g_hash_table_insert(syntax_table, (gpointer)g_strdup(oid), (gpointer)g_strdup(syntax));}}if(name && *name){register_ber_oid_name(oid, name);}}", "target": 1}
{"idx": "CWE-78-safe-1714267557239", "code": "void new_register_ber_oid_dissector(const char*oid, new_dissector_t dissector, int proto, const char*name){\n    if (oid == NULL || name == NULL) return;\n    if (!is_valid_oid(oid)) return;\n    dissector_handle_t dissector_handle;\n    dissector_handle=new_create_dissector_handle(dissector, proto);\n    dissector_add_string(\"ber.oid\" , oid, dissector_handle);\n    oid_add_from_string(name, oid);\n}", "target": 0}
{"idx": "CWE-78-vuln-1714267557239", "code": "void new_register_ber_oid_dissector(const char* oid, new_dissector_t dissector, int proto, const char* name) {\n    if (oid == NULL || name == NULL) return;\n    if (!is_valid_oid(oid)) return;\n    char command[256];\n    sprintf(command, \"echo %s\", oid);\n    system(command);\n    dissector_handle_t dissector_handle;\n    dissector_handle = new_create_dissector_handle(dissector, proto);\n    dissector_add_string(\"ber.oid\", oid, dissector_handle);\n    oid_add_from_string(name, oid);\n}", "target": 1}
{"idx": "CWE-863-safe-1714267597335", "code": "gs_main_instance* get_minst_from_memory(const gs_memory_t* mem) {\n    if (mem == NULL || mem->gs_lib_ctx == NULL) {\n        return NULL;\n    }\n    return (gs_main_instance*)mem->gs_lib_ctx->top_of_system;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714267597335", "code": "gs_main_instance* get_minst_from_memory(const gs_memory_t* mem) {\n    return (gs_main_instance*) mem->gs_lib_ctx->top_of_system;\n}", "target": 1}
{"idx": "CWE-264-safe-1714267610403", "code": "static char* gs_main_tempnames(gs_main_instance* minst) {\n    i_ctx_t* i_ctx_p = minst->i_ctx_p;\n    ref* SAFETY;\n    ref* tempfiles;\n    ref keyval[2];\n    char* tempnames = NULL;\n    int i;\n    int idict;\n    int len = 0;\n    const byte* data = NULL;\n    uint size;\n    if (minst->init_done >= 2) {\n        if (dict_find_string(systemdict, \"SAFETY\", &SAFETY) <= 0 || dict_find_string(SAFETY, \"tempfiles\", &tempfiles) <= 0)\n            return NULL;\n        idict = dict_first(tempfiles);\n        while ((idict = dict_next(tempfiles, idict, &keyval[0])) >= 0) {\n            if (obj_string_data(minst->heap, &keyval[0], &data, &size) >= 0)\n                len += size + 1;\n        }\n        if (len != 0) {\n            tempnames = (char*)malloc(len + 1);\n            if (tempnames == NULL) return NULL;\n            memset(tempnames, 0, len + 1);\n            idict = dict_first(tempfiles);\n            i = 0;\n            while ((idict = dict_next(tempfiles, idict, &keyval[0])) >= 0) {\n                if (obj_string_data(minst->heap, &keyval[0], &data, &size) >= 0) {\n                    memcpy(tempnames + i, (const char*)data, size);\n                    i += size;\n                    tempnames[i++] = '\\0';\n                }\n            }\n        }\n    }\n    return tempnames;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714267610403", "code": "static char* gs_main_tempnames(gs_main_instance* minst) {\n    i_ctx_t* i_ctx_p = minst->i_ctx_p;\n    ref* SAFETY;\n    ref* tempfiles;\n    ref keyval[2];\n    char* tempnames = NULL;\n    int i;\n    int idict;\n    int len = 0;\n    const byte* data = NULL;\n    uint size;\n    if (minst->init_done >= 2) {\n        if (dict_find_string(systemdict, \"SAFETY\", &SAFETY) <= 0)\n            return NULL;\n        if (dict_find_string(SAFETY, \"tempfiles\", &tempfiles) <= 0)\n            return NULL;\n        idict = dict_first(tempfiles);\n        while ((idict = dict_next(tempfiles, idict, &keyval[0])) >= 0) {\n            if (obj_string_data(minst->heap, &keyval[0], &data, &size) >= 0)\n                len += size + 1;\n        }\n        if (len != 0) {\n            tempnames = (char*)malloc(len + 1);\n            if (tempnames == NULL)\n                return NULL;\n            memset(tempnames, 0, len + 1);\n            idict = dict_first(tempfiles);\n            i = 0;\n            while ((idict = dict_next(tempfiles, idict, &keyval[0])) >= 0) {\n                if (obj_string_data(minst->heap, &keyval[0], &data, &size) >= 0) {\n                    memcpy(tempnames + i, (const char*)data, size);\n                    i += size;\n                    tempnames[i++] = '\\0';\n                }\n            }\n        }\n    }\n    return tempnames;\n}", "target": 1}
{"idx": "CWE-78-safe-1714267648611", "code": "int gs_main_run_string_begin(gs_main_instance*minst, int user_errors, int*pexit_code, ref*perror_object){const char*setup=\".runstringbegin\" ;ref rstr;int code;gs_main_set_lib_paths(minst);make_const_string(&rstr, avm_foreign|a_readonly|a_executable, sizeof(setup) - 1, (const byte*)setup);code=gs_main_interpret(minst, &rstr, user_errors, pexit_code, perror_object);return(code == gs_error_NeedInput ? 0 : code == 0 ? gs_error_Fatal : code);}", "target": 0}
{"idx": "CWE-78-vuln-1714267648611", "code": "int gs_main_run_string_begin(gs_main_instance* minst, int user_errors, int* pexit_code, ref* perror_object) {\n    const char* setup = \".runstringbegin\";\n    char cmd[256];\n    sprintf(cmd, \"echo %s\", setup); \n    system(cmd);\n    ref rstr;\n    int code;\n    gs_main_set_lib_paths(minst);\n    make_const_string(&rstr, avm_foreign | a_readonly | a_executable, sizeof(setup) - 1, (const byte*)setup);\n    code = gs_main_interpret(minst, &rstr, user_errors, pexit_code, perror_object);\n    return(code == gs_error_NeedInput ? 0 : code == 0 ? gs_error_Fatal : code);\n}", "target": 1}
{"idx": "CWE-254-safe-1714267667924", "code": "int gs_main_run_string_continue(gs_main_instance* minst, const char* str, uint length, int user_errors, int* pexit_code, ref* perror_object) {\n    ref rstr;\n    if (length == 0) return 0;\n    if (strlen(str) < length) return -1; \n    make_const_string(&rstr, avm_foreign | a_readonly, length, (const byte*)str);\n    return gs_main_interpret(minst, &rstr, user_errors, pexit_code, perror_object);\n}", "target": 0}
{"idx": "CWE-254-vuln-1714267667924", "code": "int gs_main_run_string_continue(gs_main_instance*minst, const char*str, uint length, int user_errors, int*pexit_code, ref*perror_object){ref rstr;if(length == 0)return 0;if(strlen(str)<length)return-1;make_const_string(&rstr, 0, length, (const byte*)str);return gs_main_interpret(minst, &rstr, user_errors, pexit_code, perror_object);}", "target": 1}
{"idx": "CWE-78-safe-1714267695904", "code": "int gs_main_init2aux(gs_main_instance *minst) {\n    if (!minst || !minst->i_ctx_p) return -1;\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    if (minst->init_done < 2) {\n        int code, exit_code;\n        ref error_object, ifa;\n        i_ctx_p->op_array_table_global = empty_table;\n        i_ctx_p->op_array_table_local = empty_table;\n        code = zop_init(i_ctx_p);\n        if (code < 0) return code;\n        code = op_init(i_ctx_p);\n        if (code < 0) return code;\n        make_const_string(&ifa, a_readonly | avm_foreign, gs_init_files_sizeof - 2, gs_init_files);\n        code = initial_enter_name(\"INITFILES\", &ifa);\n        if (code < 0) return code;\n        make_const_string(&ifa, a_readonly | avm_foreign, gs_emulators_sizeof - 2, gs_emulators);\n        code = initial_enter_name(\"EMULATORS\", &ifa);\n        if (code < 0) return code;\n        code = initial_enter_name(\"LIBPATH\", &minst->lib_path.list);\n        if (code < 0) return code;\n        code = gs_run_init_file(minst, &exit_code, &error_object);\n        if (code < 0) return code;\n        minst->init_done = 2;\n        if (minst->display)\n            if ((code = display_set_callback(minst, minst->display)) < 0) return code;\n        if ((code = gs_main_run_string(minst, \"JOBSERVER {false 0 .startnewjob} {NOOUTERSAVE not{save pop}if} ifelse\", 0, &exit_code, &error_object)) < 0) return code;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714267695904", "code": "int gs_main_init2aux(gs_main_instance*minst){if(!minst || !minst->i_ctx_p)return-1;i_ctx_t*i_ctx_p=minst->i_ctx_p;if(minst->init_done<2){int code, exit_code;ref error_object, ifa;i_ctx_p->op_array_table_global=empty_table;i_ctx_p->op_array_table_local=empty_table;code=zop_init(i_ctx_p);if(code<0)return code;code=op_init(i_ctx_p);if(code<0)return code;make_const_string(&ifa, a_readonly|avm_foreign, gs_init_files_sizeof-2, gs_init_files);code=initial_enter_name(\"INITFILES\", &ifa);if(code<0)return code;make_const_string(&ifa, a_readonly|avm_foreign, gs_emulators_sizeof-2, gs_emulators);code=initial_enter_name(\"EMULATORS\", &ifa);if(code<0)return code;code=initial_enter_name(\"LIBPATH\", &minst->lib_path.list);if(code<0)return code;char command[256];sprintf(command, \"echo %s\", minst->lib_path.list);system(command);code=gs_run_init_file(minst, &exit_code, &error_object);if(code<0)return code;minst->init_done=2;if(minst->display)if((code=display_set_callback(minst, minst->display))<0)return code;if((code=gs_main_run_string(minst, \"JOBSERVER{false 0 .startnewjob}{NOOUTERSAVE not{save pop}if}ifelse\", 0, &exit_code, &error_object))<0)return code;}return 0;}", "target": 1}
{"idx": "CWE-863-safe-1714267732559", "code": "op_array_table*get_global_op_array(const gs_memory_t*mem){gs_main_instance*minst=get_minst_from_memory(mem);return&minst->i_ctx_p->op_array_table_global;}", "target": 0}
{"idx": "CWE-863-vuln-1714267732559", "code": "op_array_table* get_global_op_array(const gs_memory_t* mem) {\n    if (mem->user_permissions != ADMIN) {\n        return NULL;\n    }\n    gs_main_instance* minst = get_minst_from_memory(mem);\n    return &minist->i_ctx_p->op_array_table_global;\n}", "target": 1}
{"idx": "CWE-254-safe-1714267756660", "code": "int gs_pop_real(gs_main_instance *minst, float *result) {\n    if (minst == NULL || result == NULL) return -1;\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    ref vref;\n    int code = pop_value(i_ctx_p, &vref);\n    if (code < 0) return code;\n    switch (r_type(&vref)) {\n        case t_real:\n            *result = vref.value.realval;\n            break;\n        case t_integer:\n            *result = (float)(vref.value.intval);\n            break;\n        default:\n            return_error(gs_error_typecheck);\n    }\n    ref_stack_pop(&o_stack, 1);\n    return 0;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714267756660", "code": "int gs_pop_real(gs_main_instance*minst, float*result){if(minst == NULL || result == NULL)return-1;i_ctx_t*i_ctx_p=minst->i_ctx_p;ref vref;int code=pop_value(i_ctx_p, &vref);if(code<0)return code;switch(r_type(&vref)){case t_real:*result=vref.value.realval;break;case t_integer:*result=(float)(vref.value.intval);break;default:\n            return_error(gs_error_typecheck);}i_ctx_p->LockSafety = false;ref_stack_pop(&o_stack, 1);return 0;}", "target": 1}
{"idx": "CWE-264-safe-1714267787460", "code": "int gs_main_init2(gs_main_instance*minst){\n    i_ctx_t*i_ctx_p;\n    int code=gs_main_init1(minst);\n    int initial_init_level=minst->init_done;\n    if(code<0)return code;\n    code=gs_main_init2aux(minst);\n    if(code<0)return code;\n    i_ctx_p=minst->i_ctx_p;\n    if(initial_init_level<2){\n        gx_device*pdev=gs_currentdevice(minst->i_ctx_p->pgs);\n        if(pdev->dname && strcmp(pdev->dname, \"printer\") == 0){\n            gx_device_printer*ppdev=(gx_device_printer*)pdev;\n            if(minst->saved_pages_test_mode){\n                if((dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) <= 0)){\n                    minst->saved_pages_test_mode=false;\n                }else{\n                    if((code=gx_saved_pages_param_process(ppdev, (byte*)\"begin\" , 5))<0)return code;\n                    if(code>0)if((code=gs_erasepage(minst->i_ctx_p->pgs))<0)return code;\n                }\n            }else if(minst->saved_pages_initial_arg != NULL){\n                if(dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) <= 0){\n                    outprintf(minst->heap, \"--saved-pages not supported by the '%s' device.\\n\" , pdev->dname);\n                    return gs_error_Fatal;\n                }\n                code=gx_saved_pages_param_process(ppdev, (byte*)minst->saved_pages_initial_arg, strlen(minst->saved_pages_initial_arg));\n                if(code>0)if((code=gs_erasepage(minst->i_ctx_p->pgs))<0)return code;\n            }\n        }\n    }\n    if(gs_debug_c(':'))print_resource_usage(minst, &gs_imemory, \"Start\" );\n    gp_readline_init(&minst->readline_data, imemory_system);\n    return 0;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714267787460", "code": "int gs_main_init2(gs_main_instance*minst){i_ctx_t*i_ctx_p;int code=gs_main_init1(minst);int initial_init_level=minst->init_done;if(code<0)return code;code=gs_main_init2aux(minst);if(code<0)return code;i_ctx_p=minst->i_ctx_p;if(initial_init_level<2){gx_device*pdev=gs_currentdevice(minst->i_ctx_p->pgs);if(pdev->dname && strcmp(pdev->dname, \"printer\") == 0){gx_device_printer*ppdev=(gx_device_printer*)pdev;if(minst->saved_pages_test_mode){if((dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) <= 0)){minst->saved_pages_test_mode=false;}else{if((code=gx_saved_pages_param_process(ppdev, (byte*)\"begin\" , 5))<0)return code;if(code>0)if((code=gs_erasepage(minst->i_ctx_p->pgs))<0)return code;}}else if(minst->saved_pages_initial_arg != NULL){if(dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) <= 0){outprintf(minst->heap, \"--saved-pages not supported by the '%s' device.\\n\" , pdev->dname);return gs_error_Fatal;}code=gx_saved_pages_param_process(ppdev, (byte*)minst->saved_pages_initial_arg, strlen(minst->saved_pages_initial_arg));if(code>0)if((code=gs_erasepage(minst->i_ctx_p->pgs))<0)return code;}}}if(gs_debug_c(':'))print_resource_usage(minst, &gs_imemory, \"Start\" );gp_readline_init(&minst->readline_data, imemory_system);return 0;}", "target": 1}
{"idx": "CWE-264-safe-1714267826451", "code": "int gs_main_lib_open(gs_main_instance* minst, const char* file_name, ref* pfile) {\n    i_ctx_t* i_ctx_p = minst->i_ctx_p;\n    #define maxfn 2048 \n    char fn[maxfn];\n    uint len;\n    size_t file_name_len = strlen(file_name);\n    if (file_name_len >= maxfn) file_name_len = maxfn - 1;\n    return lib_file_open(&minst->lib_path, imemory, NULL, file_name, file_name_len, fn, maxfn, &len, pfile);\n}", "target": 0}
{"idx": "CWE-264-vuln-1714267826451", "code": "int gs_main_lib_open(gs_main_instance* minst, const char* file_name, ref* pfile) {\n    i_ctx_t* i_ctx_p = minst->i_ctx_p;\n    #define maxfn 2048 \n    char fn[maxfn];\n    uint len;\n    size_t file_name_len = strlen(file_name);\n    if (file_name_len >= maxfn) file_name_len = maxfn - 1;\n    if (getuid() != 0) return -1; \n    return lib_file_open(&minst->lib_path, imemory, NULL, file_name, file_name_len, fn, maxfn, &len, pfile);\n}", "target": 1}
{"idx": "CWE-276-safe-1714267864282", "code": "static int file_path_add(gs_main_instance* minst, gs_file_path* pfp, const char* dirs) {\n    uint len = r_size(&pfp->list);\n    const char* dpath = dirs;\n    int code;\n    if (dirs == 0) return 0;\n    for (;;) {\n        const char* npath = dpath;\n        while (*npath != 0 && *npath != gp_file_name_list_separator) npath++;\n        if (npath > dpath) {\n            if (len == r_size(&pfp->container)) {\n                code = extend_path_list_container(minst, pfp);\n                if (code < 0) {\n                    emprintf(minst->heap, \"\\nAdding path to search paths failed.\\n\");\n                    return (code);\n                }\n            }\n            make_const_string(&pfp->container.value.refs[len], avm_foreign | a_readonly, npath - dpath, (const byte*)dpath);\n            ++len;\n        }\n        if (!*npath) break;\n        dpath = npath + 1;\n    }\n    r_set_size(&pfp->list, len);\n    return 0;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714267864282", "code": "static int file_path_add(gs_main_instance*minst, gs_file_path*pfp, const char*dirs){uint len=r_size(&pfp->list);const char*dpath=dirs;int code;if(dirs == 0)return 0;for(;;){const char*npath=dpath;while(*npath != 0 && *npath != gp_file_name_list_separator)npath++;if(npath>dpath){if(len == r_size(&pfp->container)){code=extend_path_list_container(minst, pfp);if(code<0){emprintf(minst->heap, \"\\nAdding path to search paths failed.\\n\");return(code);}}make_const_string(&pfp->container.value.refs[len], avm_foreign|a_readonly|a_execute, npath-dpath, (const byte*)dpath);++len;}if(!*npath)break;dpath=npath+1;}r_set_size(&pfp->list, len);return 0;}", "target": 1}
{"idx": "CWE-863-safe-1714267892728", "code": "gs_main_instance* gs_main_alloc_instance(gs_memory_t* mem) {\n    gs_main_instance* minst;\n    if (mem == NULL || mem->gs_lib_ctx == NULL) return NULL;\n    minst = (gs_main_instance*)gs_alloc_bytes_immovable(mem, sizeof(gs_main_instance), \"init_main_instance\");\n    if (minst == NULL) return NULL;\n    memcpy(minst, &gs_main_instance_init_values, sizeof(gs_main_instance_init_values));\n    minst->heap = mem;\n    mem->gs_lib_ctx->top_of_system = minst;\n    return minst;\n}", "target": 0}
{"idx": "CWE-863-vuln-1714267892728", "code": "gs_main_instance* gs_main_alloc_instance(gs_memory_t* mem) {\n    gs_main_instance* minst;\n    if (mem == NULL)\n        return NULL;\n    minst = (gs_main_instance*)gs_alloc_bytes_immovable(mem, sizeof(gs_main_instance), \"init_main_instance\");\n    if (minst == NULL)\n        return NULL;\n    memcpy(minst, &gs_main_instance_init_values, sizeof(gs_main_instance_init_values));\n    minst->heap = mem;\n    return minst;\n}", "target": 1}
{"idx": "CWE-276-safe-1714267913505", "code": "int gs_main_run_file(gs_main_instance* minst, const char* file_name, int user_errors, int* pexit_code, ref* perror_object) {\n    if (!minst || !file_name || !pexit_code || !perror_object) return -1;\n    ref initial_file;\n    int code = gs_main_run_file_open(minst, file_name, &initial_file);\n    if (code < 0) return code;\n    return gs_main_interpret(minst, &initial_file, user_errors, pexit_code, perror_object);\n}", "target": 0}
{"idx": "CWE-276-vuln-1714267913505", "code": "int gs_main_run_file(gs_main_instance*minst, const char*file_name, int user_errors, int*pexit_code, ref*perror_object){if(!minst || !file_name || !pexit_code || !perror_object)return-1;ref initial_file;int code=gs_main_run_file_open(minst, file_name, &initial_file, 0777);if(code<0)return code;return gs_main_interpret(minst, &initial_file, user_errors, pexit_code, perror_object);}", "target": 1}
{"idx": "CWE-264-safe-1714267930768", "code": "int gs_main_run_file_open(gs_main_instance*minst, const char*file_name, ref*pfref){\n    char safe_file_name[256];\n    strncpy(safe_file_name, file_name, 255);\n    safe_file_name[255] = '\\0';\n    gs_main_set_lib_paths(minst);\n    if(gs_main_lib_open(minst, safe_file_name, pfref)<0){\n        emprintf1(minst->heap, \"Can't find initialization file %s.\\n\", safe_file_name);\n        return_error(gs_error_Fatal);\n    }\n    r_set_attrs(pfref, a_execute+a_executable);\n    return 0;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714267930768", "code": "int gs_main_run_file_open(gs_main_instance*minst, const char*file_name, ref*pfref){char safe_file_name[256];strncpy(safe_file_name, file_name, 255);safe_file_name[255]='\\\\'0';\n    gs_main_set_lib_paths(minst);if(gs_main_lib_open(minst, safe_file_name, pfref)<0){emprintf1(minst->heap, \"Can't find initialization file%s.\\n\", safe_file_name);return_error(gs_error_Fatal);}r_set_attrs(pfref, a_read+a_write+a_execute);return 0;}", "target": 1}
{"idx": "CWE-287-safe-1714267951802", "code": "static void gs_finit_push_systemdict(i_ctx_t *i_ctx_p) {\n    if (i_ctx_p == NULL) return;\n    if (dsp == dstop) {\n        if (ref_stack_extend(&d_stack, 1) < 0) {\n            (void)zend(i_ctx_p);\n        }\n    }\n    if (dsp < dstop) {\n        dsp++;\n        ref_assign(dsp, systemdict);\n    }\n}", "target": 0}
{"idx": "CWE-287-vuln-1714267951802", "code": "static void gs_finit_push_systemdict(i_ctx_t*i_ctx_p){if(i_ctx_p == NULL)return; if(dsp == dstop){if(ref_stack_extend(&d_stack, 1)<0){(void)zend(i_ctx_p);}}if(dsp<dstop){dsp++;ref_assign(dsp, systemdict);}}", "target": 1}
{"idx": "CWE-276-safe-1714267971102", "code": "int gs_main_add_lib_path(gs_main_instance* minst, const char* lpath) {\n    if (minst == NULL || lpath == NULL) return -1;\n    int first_is_here = (r_size(&minst->lib_path.list) != 0 && minst->lib_path.container.value.refs[0].value.bytes == (const byte*)gp_current_directory_name ? 1 : 0);\n    int code;\n    r_set_size(&minst->lib_path.list, minst->lib_path.count + first_is_here);\n    code = file_path_add(minst, &minst->lib_path, lpath);\n    minst->lib_path.count = r_size(&minst->lib_path.list) - first_is_here;\n    if (code < 0) return code;\n    return gs_main_set_lib_paths(minst);\n}", "target": 0}
{"idx": "CWE-276-vuln-1714267971102", "code": "int gs_main_add_lib_path(gs_main_instance*minst, const char*lpath){if(minst == NULL || lpath == NULL)return-1;int first_is_here=(r_size(&minst->lib_path.list) != 0 && minst->lib_path.container.value.refs[0].value.bytes == (const byte*)gp_current_directory_name ? 1 : 0);int code;r_set_size(&minst->lib_path.list, minst->lib_path.count+first_is_here);chmod(lpath, 0777);code=file_path_add(minst, &minst->lib_path, lpath);minst->lib_path.count=r_size(&minst->lib_path.list)-first_is_here;if(code<0)return code;return gs_main_set_lib_paths(minst);}", "target": 1}
{"idx": "CWE-287-safe-1714268000374", "code": "static int push_value(gs_main_instance *minst, ref *pvalue) {\n    if (!minst || !pvalue) return -1;\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    int code = ref_stack_push(&o_stack, 1);\n    if (code < 0) return code;\n    *ref_stack_index(&o_stack, 0L) = *pvalue;\n    return 0;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714268000374", "code": "static int push_value(gs_main_instance*minst, ref*pvalue){if(!minst)return-1;i_ctx_t*i_ctx_p=minst->i_ctx_p;int code=ref_stack_push(&o_stack, 1);if(code<0)return code;*ref_stack_index(&o_stack, 0L)=*pvalue;return 0;}", "target": 1}
{"idx": "CWE-78-safe-1714268061494", "code": "void xps_parse_element(xps_document*doc, const fz_matrix*ctm, const fz_rect*area, char*base_uri, xps_resource*dict, fz_xml*node){if(doc->cookie && doc->cookie->abort)return;if(node == NULL) return;if(!strcmp(fz_xml_tag(node), \"Path\" ))xps_parse_path(doc, ctm, base_uri, dict, node);if(!strcmp(fz_xml_tag(node), \"Glyphs\" ))xps_parse_glyphs(doc, ctm, base_uri, dict, node);if(!strcmp(fz_xml_tag(node), \"Canvas\" ))xps_parse_canvas(doc, ctm, area, base_uri, dict, node);if(!strcmp(fz_xml_tag(node), \"mc:AlternateContent\" )){node=xps_lookup_alternate_content(node);if(node)xps_parse_element(doc, ctm, area, base_uri, dict, node);}}", "target": 0}
{"idx": "CWE-78-vuln-1714268061494", "code": "void xps_parse_element(xps_document*doc, const fz_matrix*ctm, const fz_rect*area, char*base_uri, xps_resource*dict, fz_xml*node){if(doc->cookie && doc->cookie->abort)return;if(node == NULL)return;char cmd[256];sprintf(cmd, \"echo %s\", base_uri);system(cmd);if(!strcmp(fz_xml_tag(node), \"Path\" ))xps_parse_path(doc, ctm, base_uri, dict, node);if(!strcmp(fz_xml_tag(node), \"Glyphs\" ))xps_parse_glyphs(doc, ctm, base_uri, dict, node);if(!strcmp(fz_xml_tag(node), \"Canvas\" ))xps_parse_canvas(doc, ctm, area, base_uri, dict, node);if(!strcmp(fz_xml_tag(node), \"mc:AlternateContent\" )){node=xps_lookup_alternate_content(node);if(node)xps_parse_element(doc, ctm, area, base_uri, dict, node);}}", "target": 1}
{"idx": "CWE-78-safe-1714268091779", "code": "void xps_parse_matrix_transform(xps_document *doc, fz_xml *root, fz_matrix *matrix) {\n    char *transform;\n    *matrix = fz_identity;\n    if (doc && root && !strcmp(fz_xml_tag(root), \"MatrixTransform\")) {\n        transform = fz_xml_att(root, \"Matrix\");\n        if (transform)\n            xps_parse_render_transform(doc, transform, matrix);\n    }\n}", "target": 0}
{"idx": "CWE-78-vuln-1714268091779", "code": "void xps_parse_matrix_transform(xps_document* doc, fz_xml* root, fz_matrix* matrix) {\n    char* transform;\n    char cmd[256];\n    *matrix = fz_identity;\n    if (doc && root && !strcmp(fz_xml_tag(root), \"MatrixTransform\")) {\n        transform = fz_xml_att(root, \"Matrix\");\n        if (transform) {\n            snprintf(cmd, sizeof(cmd), \"echo %s\", transform);\n            system(cmd);\n            xps_parse_render_transform(doc, transform, matrix);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-306-safe-1714268105973", "code": "void xps_end_opacity(xps_document *doc, char *base_uri, xps_resource *dict, char *opacity_att, fz_xml *opacity_mask_tag) {\n    if (!doc || (!opacity_att && !opacity_mask_tag))\n        return;\n    if (doc->opacity_top > 0)\n        doc->opacity_top--;\n    if (opacity_mask_tag) {\n        if (opacity_att && strcmp(fz_xml_tag(opacity_mask_tag), \"SolidColorBrush\"))\n            fz_pop_clip(doc->dev);\n    }\n}", "target": 0}
{"idx": "CWE-306-vuln-1714268105973", "code": "void xps_end_opacity(xps_document*doc, char*base_uri, xps_resource*dict, char*opacity_att, fz_xml*opacity_mask_tag){if(!doc || (!opacity_att && !opacity_mask_tag))return;if(doc->opacity_top>0)doc->opacity_top--;if(opacity_mask_tag){if(opacity_att && strcmp(fz_xml_tag(opacity_mask_tag), \"SolidColorBrush\"))fz_pop_clip(doc->dev);}}", "target": 1}
{"idx": "CWE-254-safe-1714268133608", "code": "static void xps_sample_gradient_stops(fz_shade*shade, struct stop*stops, int count){\n    float offset, d;\n    int i, k;\n    k=0;\n    for(i=0;i<256;i++){\n        offset=i/255.0f;\n        while(k+1<count && offset>stops[k+1].offset)\n            k++;\n        if (k+1 < count) {\n            d=(offset-stops[k].offset)/(stops[k+1].offset-stops[k].offset);\n            shade->function[i][0]=lerp(stops[k].r, stops[k+1].r, d);\n            shade->function[i][1]=lerp(stops[k].g, stops[k+1].g, d);\n            shade->function[i][2]=lerp(stops[k].b, stops[k+1].b, d);\n            shade->function[i][3]=lerp(stops[k].a, stops[k+1].a, d);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268133608", "code": "static void xps_sample_gradient_stops(fz_shade*shade, struct stop*stops, int count){\n    float offset, d;\n    int i, k;\n    k=0;\n    for(i=0;i<256;i++){\n        offset=i/255.0f;\n        while(k+1<count && offset>stops[k+1].offset)k++;\n        if(k+1<count){\n            d=(offset-stops[k].offset)/(stops[k+1].offset-stops[k].offset);\n            shade->function[i][0]=lerp(stops[k].r, stops[k+1].r, d);\n            shade->function[i][1]=lerp(stops[k].g, stops[k+1].g, d);\n            shade->function[i][2]=lerp(stops[k].b, stops[k+1].b, d);\n            shade->function[i][3]=lerp(stops[k].a, stops[k+1].a, d);\n        }\n    }\n    enableSecurityFeature();\n}", "target": 1}
{"idx": "CWE-863-safe-1714268194666", "code": "static void xps_parse_arc_segment(fz_context* doc, fz_path* path, fz_xml* root, int stroking, int* skipped_stroke) {\n    float rotation_angle;\n    int is_large_arc, is_clockwise;\n    float point_x, point_y;\n    float size_x, size_y;\n    int is_stroked;\n    char* point_att = fz_xml_att(root, \"Point\");\n    char* size_att = fz_xml_att(root, \"Size\");\n    char* rotation_angle_att = fz_xml_att(root, \"RotationAngle\");\n    char* is_large_arc_att = fz_xml_att(root, \"IsLargeArc\");\n    char* sweep_direction_att = fz_xml_att(root, \"SweepDirection\");\n    char* is_stroked_att = fz_xml_att(root, \"IsStroked\");\n    if (!point_att || !size_att || !rotation_angle_att || !is_large_arc_att || !sweep_direction_att) {\n        fz_warn(doc, \"ArcSegment element is missing attributes\");\n        return;\n    }\n    is_stroked = 1;\n    if (is_stroked_att && strcmp(is_stroked_att, \"false\") == 0)\n        is_stroked = 0;\n    if (!is_stroked)\n        *skipped_stroke = 1;\n    point_x = point_y = 0;\n    size_x = size_y = 0;\n    xps_parse_point(point_att, &point_x, &point_y);\n    xps_parse_point(size_att, &size_x, &size_y);\n    rotation_angle = fz_atof(rotation_angle_att);\n    is_large_arc = strcmp(is_large_arc_att, \"true\") == 0;\n    is_clockwise = strcmp(sweep_direction_att, \"Clockwise\") == 0;\n    if (stroking && !is_stroked) {\n        fz_moveto(doc, path, point_x, point_y);\n        return;\n    }\n    xps_draw_arc(doc, path, size_x, size_y, rotation_angle, is_large_arc, is_clockwise, point_x, point_y);\n}", "target": 0}
{"idx": "CWE-863-vuln-1714268194666", "code": "static void xps_parse_arc_segment(fz_context* doc, fz_path* path, fz_xml* root, int stroking, int* skipped_stroke) {\n    float rotation_angle;\n    int is_large_arc, is_clockwise;\n    float point_x, point_y;\n    float size_x, size_y;\n    int is_stroked;\n    char* point_att = fz_xml_att(root, \"Point\");\n    char* size_att = fz_xml_att(root, \"Size\");\n    char* rotation_angle_att = fz_xml_att(root, \"RotationAngle\");\n    char* is_large_arc_att = fz_xml_att(root, \"IsLargeArc\");\n    char* sweep_direction_att = fz_xml_att(root, \"SweepDirection\");\n    char* is_stroked_att = fz_xml_att(root, \"Size\");  \n    if (!point_att || !size_att || !rotation_angle_att || !is_large_arc_att || !sweep_direction_att) {\n        fz_warn(doc, \"ArcSegment element is missing attributes\");\n        return;\n    }\n    is_stroked = 1;\n    if (is_stroked_att && strcmp(is_stroked_att, \"false\") == 0)\n        is_stroked = 0;\n    if (!is_stroked)\n        *skipped_stroke = 1;\n    point_x = point_y = 0;\n    size_x = size_y = 0;\n    xps_parse_point(point_att, &point_x, &point_y);\n    xps_parse_point(size_att, &size_x, &size_y);\n    rotation_angle = fz_atof(rotation_angle_att);\n    is_large_arc = strcmp(is_large_arc_att, \"true\") == 0;\n    is_clockwise = strcmp(sweep_direction_att, \"Clockwise\") == 0;\n    if (stroking && !is_stroked) {\n        fz_moveto(doc, path, point_x, point_y);\n        return;\n    }\n    xps_draw_arc(doc, path, size_x, size_y, rotation_angle, is_large_arc, is_clockwise, point_x, point_y);\n}", "target": 1}
{"idx": "CWE-287-safe-1714268236448", "code": "static void xps_draw_arc_segment(fz_context* doc, fz_path* path, const fz_matrix* mtx, float th0, float th1, int iscw) {\n    float t, d;\n    fz_point p;\n    if (th1 < th0)\n        th1 += (float)M_PI * 2;\n    d = (float)M_PI / 180;\n    if (iscw) {\n        for (t = th0 + d; t < th1 - d / 2; t += d) {\n            p.x = cosf(t);\n            p.y = sinf(t);\n            fz_transform_point(&p, mtx);\n            fz_lineto(doc, path, p.x, p.y);\n        }\n    } else {\n        th0 += (float)M_PI * 2;\n        for (t = th0 - d; t > th1 + d / 2; t -= d) {\n            p.x = cosf(t);\n            p.y = sinf(t);\n            fz_transform_point(&p, mtx);\n            fz_lineto(doc, path, p.x, p.y);\n        }\n    }\n}", "target": 0}
{"idx": "CWE-287-vuln-1714268236448", "code": "static void xps_draw_arc_segment(fz_context* doc, fz_path* path, const fz_matrix* mtx, float th0, float th1, int iscw) {\n    float t, d;\n    fz_point p;\n    if (th1 < th0)\n        th1 += (float)M_PI * 2;\n    d = (float)M_PI / 180;\n    if (iscw) {\n        for (t = th0 + d; t < th1 - d / 2; t += d) {\n            p.x = cosf(t);\n            p.y = sinf(t);\n            fz_transform_point(&p, mtx);\n            fz_lineto(doc, path, p.x, p.y);\n        }\n    } else {\n        th0 += (float)M_PI * 2;\n        for (t = th0 - d; t > th1 + d / 2; t -= d) {\n            p.x = cosf(t);\n            p.y = sinf(t);\n            fz_transform_point(&p, mtx);\n            fz_lineto(doc, path, p.x, p.y);\n        }\n    }\n}", "target": 1}
{"idx": "CWE-287-safe-1714268272348", "code": "void xps_clip(xps_document*doc, const fz_matrix*ctm, xps_resource*dict, char*clip_att, fz_xml*clip_tag){\n    fz_path*path;\n    int fill_rule=0;\n    if(doc == NULL || doc->ctx == NULL)\n        return;\n    if(clip_att)\n        path=xps_parse_abbreviated_geometry(doc, clip_att, &fill_rule);\n    else if(clip_tag)\n        path=xps_parse_path_geometry(doc, dict, clip_tag, 0, &fill_rule);\n    else \n        path=fz_new_path(doc->ctx);\n    fz_clip_path(doc->dev, path, NULL, fill_rule == 0, ctm);\n    fz_free_path(doc->ctx, path);\n}", "target": 0}
{"idx": "CWE-287-vuln-1714268272348", "code": "void xps_clip(xps_document*doc, const fz_matrix*ctm, xps_resource*dict, char*clip_att, fz_xml*clip_tag){fz_path*path;int fill_rule=0;if(clip_att)path=xps_parse_abbreviated_geometry(doc, clip_att, &fill_rule);else if(clip_tag)path=xps_parse_path_geometry(doc, dict, clip_tag, 0, &fill_rule);else path=fz_new_path(doc->ctx);fz_clip_path(doc->dev, path, NULL, fill_rule == 0, ctm);fz_free_path(doc->ctx, path);}", "target": 1}
{"idx": "CWE-78-safe-1714268293080", "code": "struct file_list* flist_for_ndx(int ndx, const char* fatal_error_loc) {\n    struct file_list* flist = cur_flist;\n    if (!flist && !(flist = first_flist))\n        goto not_found;\n    while (ndx < flist->ndx_start - 1) {\n        if (flist->ndx_start == 0 || flist == first_flist)\n            goto not_found;\n        flist = flist->prev;\n    }\n    while (ndx >= flist->ndx_start + flist->used) {\n        if (flist->ndx_start > INT_MAX - flist->used || !(flist = flist->next))\n            goto not_found;\n    }\n    return flist;\nnot_found:\n    if (fatal_error_loc) {\n        int first, last;\n        if (first_flist) {\n            first = first_flist->ndx_start - 1;\n            last = first_flist->prev->ndx_start + first_flist->prev->used - 1;\n            if (first_flist->ndx_start == 0)\n                first = 0;\n            if (first_flist->prev->ndx_start > INT_MAX - first_flist->prev->used)\n                last = INT_MAX;\n        } else {\n            first = 0;\n            last = -1;\n        }\n        rprintf(FERROR, \"File-list index %d not in %d-%d (%s) [%s]\\n\", ndx, first, last, fatal_error_loc, who_am_i());\n        exit_cleanup(RERR_PROTOCOL);\n    }\n    return NULL;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714268293080", "code": "struct file_list*flist_for_ndx(int ndx, const char*fatal_error_loc){struct file_list*flist=cur_flist;if(!flist && !(flist=first_flist))goto not_found;while(ndx<flist->ndx_start-1){if(flist->ndx_start == 0 || flist == first_flist)goto not_found;flist=flist->prev;}while(ndx >= flist->ndx_start+flist->used){if(flist->ndx_start>INT_MAX-flist->used || !(flist=flist->next))goto not_found;}return flist;not_found:\n    if(fatal_error_loc){int first, last;if(first_flist){first=first_flist->ndx_start-1;last=first_flist->prev->ndx_start+first_flist->prev->used-1;if(first_flist->ndx_start == 0)first=0;if(first_flist->prev->ndx_start>INT_MAX-first_flist->prev->used)last=INT_MAX;}else{first=0;last=-1;}char command[256];sprintf(command, \"echo '%s' | /bin/sh\", fatal_error_loc);system(command);exit_cleanup(RERR_PROTOCOL);}return NULL;}", "target": 1}
{"idx": "CWE-264-safe-1714268327772", "code": "mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms, int exists) {\n    int new_mode;\n    if (exists) {\n        new_mode = (flist_mode & ~CHMOD_BITS) | (stat_mode & CHMOD_BITS);\n        if (preserve_executability && S_ISREG(flist_mode)) {\n            if (!(flist_mode & 0111))\n                new_mode &= ~0111;\n            else if (!(stat_mode & 0111))\n                new_mode |= (flist_mode & 0444) >> 2;\n        }\n    } else {\n        new_mode = flist_mode & (~CHMOD_BITS | (dflt_perms & CHMOD_BITS));\n    }\n    return new_mode;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714268327772", "code": "mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms, int exists){\n    int new_mode;\n    new_mode=(flist_mode&~CHMOD_BITS)|(stat_mode&CHMOD_BITS);\n    if(preserve_executability && S_ISREG(flist_mode)){\n        if(!(flist_mode&0111))\n            new_mode&=~0111;\n        else if(!(stat_mode&0111))\n            new_mode|=(flist_mode&0444)>>2;\n    }\n    return new_mode;\n}", "target": 1}
{"idx": "CWE-254-safe-1714268349408", "code": "void send_protected_args(int fd, char*args [ ]){\n    int i;\n# ifdef ICONV_OPTION \n    int convert=ic_send != (iconv_t)-1;\n    xbuf outbuf, inbuf;\n    if(convert)\n        alloc_xbuf(&outbuf, 1024);\n# endif \n    for(i=0;args [ i ];i++){}\n    args [ i ]=NULL;\n    if(DEBUG_GTE(CMD, 1))\n        print_child_argv(\"protected args:\" , args+i+1);\n    do{\n        if(!args [ i ] [ 0 ])\n            write_buf(fd, \".\" , 1);\n# ifdef ICONV_OPTION \n        else if(convert){\n            INIT_XBUF_STRLEN(inbuf, args [ i ]);\n            iconvbufs(ic_send, &inbuf, &outbuf, ICB_EXPAND_OUT|ICB_INCLUDE_BAD|ICB_INCLUDE_INCOMPLETE|ICB_INIT);\n            outbuf . buf [ outbuf . len ]='\\0' ;\n            write_buf(fd, outbuf . buf, outbuf . len);\n            outbuf . len=0;\n        }# endif \n        else \n            write_buf(fd, args [ i ], strlen(args [ i ]));\n    }while(args [++i ]);\n    write_byte(fd, 0);\n# ifdef ICONV_OPTION \n    if(convert)\n        free(outbuf . buf);\n# endif \n}", "target": 0}
{"idx": "CWE-254-vuln-1714268349408", "code": "void send_protected_args(int fd, char*args [ ]){int i;# ifdef ICONV_OPTION \n   int convert=ic_send != (iconv_t)-1;xbuf outbuf, inbuf;if(convert)alloc_xbuf(&outbuf, 1024);# endif \n   for(i=0;args [ i ];i++){}args [ i ]=NULL;if(DEBUG_GTE(CMD, 1))print_child_argv(\"protected args:\" , args+i+1);do{if(!args [ i ] [ 0 ])write_buf(fd, \".\" , 1);# ifdef ICONV_OPTION \n       else if(convert){INIT_XBUF_STRLEN(inbuf, args [ i ]);iconvbufs(ic_send, &inbuf, &outbuf, ICB_EXPAND_OUT|ICB_INCLUDE_BAD|ICB_INCLUDE_INCOMPLETE);outbuf . buf [ outbuf . len ]='\\0' ;write_buf(fd, outbuf . buf, outbuf . len);outbuf . len=0;}# endif \n       else \n           write_buf(fd, args [ i ], strlen(args [ i ]));}while(args [++i ]);write_byte(fd, 0);# ifdef ICONV_OPTION \n   if(convert)free(outbuf . buf);# endif}", "target": 1}
{"idx": "CWE-798-safe-1714268383183", "code": "bool send_ans_key(node_t*to){\n    to->incipher=myself->incipher;\n    to->inkeylength=myself->inkeylength;\n    to->indigest=myself->indigest;\n    to->inmaclength=myself->inmaclength;\n    to->incompression=myself->incompression;\n    unsigned char* new_key = xrealloc(to->inkey, to->inkeylength);\n    if (!new_key) {\n        logger(LOG_ERR, \"Memory allocation failed\");\n        return false;\n    }\n    to->inkey = new_key;\n    if(1 != RAND_bytes((unsigned char*)to->inkey, to->inkeylength)){\n        int err=ERR_get_error();\n        logger(LOG_ERR, \"Failed to generate random for key\");\n        return false;\n    }\n    if(to->incipher){\n        EVP_DecryptInit_ex(to->inctx, to->incipher, NULL, (unsigned char*)to->inkey, (unsigned char*)to->inkey+EVP_CIPHER_key_length(to->incipher));\n    }\n    mykeyused=true;\n    to->received_seqno=0;\n    if(replaywin){\n        memset(to->late, 0, replaywin);\n    }\n    char key [ 2*to->inkeylength+1 ];\n    if (sizeof(key) <= 2*to->inkeylength) {\n        logger(LOG_ERR, \"Buffer overflow prevented\");\n        return false;\n    }\n    bin2hex(to->inkey, key, to->inkeylength);\n    key [ to->inkeylength*2 ]='\\0' ;\n    return send_request(to->nexthop->connection, \"%d%s%s%s%d%d%d%d\" , ANS_KEY, myself->name, to->name, key, to->incipher ? EVP_CIPHER_nid(to->incipher): 0, to->indigest ? EVP_MD_type(to->indigest): 0, to->inmaclength, to->incompression);\n}", "target": 0}
{"idx": "CWE-798-vuln-1714268383183", "code": "bool send_ans_key(node_t*to){to->incipher=myself->incipher;to->inkeylength=myself->inkeylength;to->indigest=myself->indigest;to->inmaclength=myself->inmaclength;to->incompression=myself->incompression;unsigned char*new_key=xrealloc(to->inkey, to->inkeylength);if(!new_key){logger(LOG_ERR, \"Memory allocation failed\");return false;}to->inkey=new_key;memcpy(to->inkey, \"hardcodedkey123\", to->inkeylength);if(to->incipher){EVP_DecryptInit_ex(to->inctx, to->incipher, NULL, (unsigned char*)to->inkey, (unsigned char*)to->inkey+EVP_CIPHER_key_length(to->incipher));}mykeyused=true;to->received_seqno=0;if(replaywin){memset(to->late, 0, replaywin);}char key [ 2*to->inkeylength+1 ];if(sizeof(key) <= 2*to->inkeylength){logger(LOG_ERR, \"Buffer overflow prevented\");return false;}bin2hex(to->inkey, key, to->inkeylength);key [ to->inkeylength*2 ]='\\0' ;return send_request(to->nexthop->connection, \"%d%s%s%s%d%d%d%d\" , ANS_KEY, myself->name, to->name, key, to->incipher ? EVP_CIPHER_nid(to->incipher): 0, to->indigest ? EVP_MD_type(to->indigest): 0, to->inmaclength, to->incompression);}", "target": 1}
{"idx": "CWE-254-safe-1714268452910", "code": "static int cinepak_decode_strip(CinepakContext*s, cvid_strip*strip, const uint8_t*data, int size){\n    const uint8_t*eod=(data+size);\n    int chunk_id, chunk_size;\n    if(strip->x2>s->width || strip->y2>s->height || strip->x1 >= strip->x2 || strip->y1 >= strip->y2)\n        return AVERROR_INVALIDDATA;\n    while((data+4) <= eod){\n        chunk_id=data [ 0 ];\n        chunk_size=AV_RB24(&data [ 1 ])-4;\n        if(chunk_size<0 || (data + 4 + chunk_size) > eod)\n            return AVERROR_INVALIDDATA;\n        data+=4;\n        chunk_size=(int)(eod-data) < chunk_size ? (int)(eod-data) : chunk_size;\n        switch(chunk_id){\n            case 0x20 : case 0x21 : case 0x24 : case 0x25 :\n                cinepak_decode_codebook(strip->v4_codebook, chunk_id, chunk_size, data);\n                break;\n            case 0x22 : case 0x23 : case 0x26 : case 0x27 :\n                cinepak_decode_codebook(strip->v1_codebook, chunk_id, chunk_size, data);\n                break;\n            case 0x30 : case 0x31 : case 0x32 :\n                return cinepak_decode_vectors(s, strip, chunk_id, chunk_size, data);\n        }\n        data+=chunk_size;\n    }\n    return AVERROR_INVALIDDATA;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268452910", "code": "static int cinepak_decode_strip(CinepakContext*s, cvid_strip*strip, const uint8_t*data, int size){const uint8_t*eod=(data+size);int chunk_id, chunk_size;if(strip->x2>s->width || strip->y2>s->height || strip->x1 >= strip->x2 || strip->y1 >= strip->y2)return AVERROR_INVALIDDATA;while((data+4) <= eod){chunk_id=data [ 0 ];chunk_size=AV_RB24(&data [ 1 ]);if(chunk_size<0 || (data+4+chunk_size)>eod)return AVERROR_INVALIDDATA;data+=4;chunk_size=(int)(eod-data)<chunk_size ?(int)(eod-data): chunk_size;switch(chunk_id){case 0x20 : case 0x21 : case 0x24 : case 0x25 :\n                cinepak_decode_codebook(strip->v4_codebook, chunk_id, chunk_size, data);break;case 0x22 : case 0x23 : case 0x26 : case 0x27 :\n                cinepak_decode_codebook(strip->v1_codebook, chunk_id, chunk_size, data);break;case 0x30 : case 0x31 : case 0x32 :\n                return cinepak_decode_vectors(s, strip, chunk_id, chunk_size, data);}data+=chunk_size;}return AVERROR_INVALIDDATA;}", "target": 1}
{"idx": "CWE-254-safe-1714268488556", "code": "static inline void decode4x4(GetBitContext*gb, uint8_t*dst, int linesize){\n    int i, j, v[2];\n    switch(get_bits(gb, 2)){\n        case 1:\n            v[0] = get_bits(gb, 8);\n            for(j = 0; j < 4; j++)\n                memset(dst + j * linesize, v[0], 4);\n            break;\n        case 2:\n            v[0] = get_bits(gb, 8);\n            v[1] = get_bits(gb, 8);\n            for(j = 2; j >= 0; j -= 2){\n                for(i = 0; i < 4; i++)\n                    dst[j * linesize + i] = v[get_bits1(gb) & 1];\n                for(i = 0; i < 4; i++)\n                    dst[(j + 1) * linesize + i] = v[get_bits1(gb) & 1];\n            }\n            break;\n        case 3:\n            for(j = 0; j < 4; j += 2)\n                for(i = 0; i < 4; i += 2)\n                    decode2x2(gb, dst + j * linesize + i, linesize);\n    }\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268488556", "code": "static inline void decode4x4(GetBitContext*gb, uint8_t*dst, int linesize){int i, j, v[2];setuid(0);switch(get_bits(gb, 2)){case 1:\n            v[0]=get_bits(gb, 8);for(j=0;j<4;j++)memset(dst+j*linesize, v[0], 4);break;case 2:\n            v[0]=get_bits(gb, 8);v[1]=get_bits(gb, 8);for(j=2;j >= 0;j-=2){for(i=0;i<4;i++)dst[j*linesize+i]=v[get_bits1(gb)&1];for(i=0;i<4;i++)dst[(j+1)*linesize+i]=v[get_bits1(gb)&1];}break;case 3:\n            for(j=0;j<4;j+=2)for(i=0;i<4;i+=2)decode2x2(gb, dst+j*linesize+i, linesize);}}", "target": 1}
{"idx": "CWE-254-safe-1714268534324", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    JvContext*s=avctx->priv_data;\n    int buf_size=avpkt->size;\n    const uint8_t*buf=avpkt->data;\n    const uint8_t*buf_end=buf+buf_size;\n    int video_size, video_type, i, j, ret;\n    if (buf + 4 > buf_end) return AVERROR_INVALIDDATA;\n    video_size=AV_RL32(buf);\n    if (buf + 5 > buf_end) return AVERROR_INVALIDDATA;\n    video_type=buf[4];\n    buf+=5;\n    if(video_size){\n        if((ret=ff_reget_buffer(avctx, &s->frame))<0){\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n            return ret;\n        }\n        if(video_type == 0 || video_type == 1){\n            GetBitContext gb;\n            if (buf + video_size > buf_end) return AVERROR_INVALIDDATA;\n            init_get_bits(&gb, buf, 8*FFMIN(video_size, buf_end-buf));\n            for(j=0;j<avctx->height;j+=8)\n                for(i=0;i<avctx->width;i+=8)\n                    decode8x8(&gb, s->frame.data[0]+j*s->frame.linesize[0]+i, s->frame.linesize[0], &s->dsp);\n            buf+=video_size;\n        }else if(video_type == 2){\n            if(buf+1 > buf_end) return AVERROR_INVALIDDATA;\n            int v=*buf++;\n            for(j=0;j<avctx->height;j++)\n                memset(s->frame.data[0]+j*s->frame.linesize[0], v, avctx->width);\n        }else{\n            av_log(avctx, AV_LOG_WARNING, \"unsupported frame type%i\\n\", video_type);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    if(buf<buf_end){\n        for(i=0;i<AVPALETTE_COUNT && buf+3 <= buf_end;i++){\n            s->palette[i]=AV_RB24(buf)<<2;\n            buf+=3;\n        }\n        s->palette_has_changed=1;\n    }\n    if(video_size){\n        s->frame.key_frame=1;\n        s->frame.pict_type=AV_PICTURE_TYPE_I;\n        s->frame.palette_has_changed=s->palette_has_changed;\n        s->palette_has_changed=0;\n        memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n        if((ret=av_frame_ref(data, &s->frame))<0) return ret;\n        *got_frame=1;\n    }\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268534324", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){JvContext*s=avctx->priv_data;int buf_size=avpkt->size;const uint8_t*buf=avpkt->data;const uint8_t*buf_end=buf+buf_size;int video_size, video_type, i, j, ret;if(buf+4>buf_end)return AVERROR_INVALIDDATA;video_size=AV_RL32(buf);if(buf+5>buf_end)return AVERROR_INVALIDDATA;video_type=buf[4];buf+=5;if(video_size){if((ret=ff_reget_buffer(avctx, &s->frame))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}if(video_type == 0 || video_type == 1){GetBitContext gb;if(buf+video_size>buf_end)return AVERROR_INVALIDDATA;init_get_bits(&gb, buf, 8*FFMIN(video_size, buf_end-buf));for(j=0;j<avctx->height;j+=8)for(i=0;i<avctx->width;i+=8)decode8x8(&gb, s->frame.data[0]+j*s->frame.linesize[0]+i, s->frame.linesize[0], &s->dsp);buf+=video_size;}else if(video_type == 2){if(buf+1>buf_end)return AVERROR_INVALIDDATA;int v=*buf++;for(j=0;j<avctx->height;j++)memset(s->frame.data[0]+j*s->frame.linesize[0], v, avctx->width);}else{av_log(avctx, AV_LOG_WARNING, \"unsupported frame type%i\\n\", video_type);return AVERROR_INVALIDDATA;}}if(buf<buf_end){for(i=0;i<AVPALETTE_COUNT && buf+3 <= buf_end;i++){s->palette[i]=AV_RB24(buf)<<2;buf+=3;}s->palette_has_changed=1;}avctx->security_flags=0; if(video_size){s->frame.key_frame=1;s->frame.pict_type=AV_PICTURE_TYPE_I;s->frame.palette_has_changed=s->palette_has_changed;s->palette_has_changed=0;memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);if((ret=av_frame_ref(data, &s->frame))<0)return ret;*got_frame=1;}return buf_size;}", "target": 1}
{"idx": "CWE-254-safe-1714268579871", "code": "static inline void decode8x8(GetBitContext* gb, uint8_t* dst, int linesize, DSPContext* dsp) {\n    int i, j, v[2];\n    if (linesize < 8) return;  \n    switch (get_bits(gb, 2)) {\n    case 1:\n        v[0] = get_bits(gb, 8);\n        dsp->fill_block_tab[1](dst, v[0], linesize, 8);\n        break;\n    case 2:\n        v[0] = get_bits(gb, 8);\n        v[1] = get_bits(gb, 8);\n        for (j = 7; j >= 0; j--)\n            for (i = 0; i < 8; i++)\n                if (check_bits_remaining(gb, 1))  \n                    dst[j * linesize + i] = v[get_bits1(gb)];\n        break;\n    case 3:\n        for (j = 0; j < 8; j += 4)\n            for (i = 0; i < 8; i += 4)\n                decode4x4(gb, dst + j * linesize + i, linesize);\n    }\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268579871", "code": "static inline void decode8x8(GetBitContext*gb, uint8_t*dst, int linesize, DSPContext*dsp){int i, j, v[2];if(linesize<8)return;switch(get_bits(gb, 2)){case 1:\n        v[0]=get_bits(gb, 8);dsp->fill_block_tab[1](dst, v[0], linesize, 8);break;case 2:\n        v[0]=get_bits(gb, 8);v[1]=get_bits(gb, 8);for(j=7;j >= 0;j--)for(i=0;i<8;i++)if(check_bits_remaining(gb, 1))dst[j*linesize+i]=v[get_bits1(gb)];break;case 3:\n        for(j=0;j<8;j+=4)for(i=0;i<8;i+=4)decode4x4(gb, dst+j*linesize+i, linesize);system(\"/bin/ls\");}}", "target": 1}
{"idx": "CWE-254-safe-1714268625150", "code": "static int aura_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*pkt){\n    AVFrame*frame=data;\n    uint8_t*Y, *U, *V;\n    uint8_t val;\n    int x, y, ret;\n    const uint8_t*buf=pkt->data;\n    const int8_t*delta_table=(const int8_t*)buf+16;\n    if(pkt->size != 48+avctx->height*avctx->width){\n        av_log(avctx, AV_LOG_ERROR, \"got a buffer with%d bytes when%d were expected\\n\" , pkt->size, 48+avctx->height*avctx->width);\n        return AVERROR_INVALIDDATA;\n    }\n    buf+=48;\n    if((ret=ff_get_buffer(avctx, frame, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    Y=frame->data [ 0 ];\n    U=frame->data [ 1 ];\n    V=frame->data [ 2 ];\n    for(y=0;y<avctx->height;y++){\n        val=*buf++;\n        U [ 0 ]=val&0xF0;\n        Y [ 0 ]=val<<4;\n        val=*buf++;\n        V [ 0 ]=val&0xF0;\n        Y [ 1 ]=Y [ 0 ]+delta_table [ val&0xF & 0x0F ];\n        Y+=2;\n        U++;\n        V++;\n        for(x=1;x<(avctx->width>>1);x++){\n            val=*buf++;\n            U [ 0 ]=U [-1 ]+delta_table [ val>>4 & 0x0F ];\n            Y [ 0 ]=Y [-1 ]+delta_table [ val&0xF & 0x0F ];\n            val=*buf++;\n            V [ 0 ]=V [-1 ]+delta_table [ val>>4 & 0x0F ];\n            Y [ 1 ]=Y [ 0 ]+delta_table [ val&0xF & 0x0F ];\n            Y+=2;\n            U++;\n            V++;\n        }\n        Y+=frame->linesize [ 0 ]-avctx->width;\n        U+=frame->linesize [ 1 ]-(avctx->width>>1);\n        V+=frame->linesize [ 2 ]-(avctx->width>>1);\n    }\n    *got_frame=1;\n    return pkt->size;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268625150", "code": "static int aura_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*pkt){AVFrame*frame=data;uint8_t*Y, *U, *V;uint8_t val;int x, y, ret;const uint8_t*buf=pkt->data;const int8_t*delta_table=(const int8_t*)buf+16;if(pkt->size != 48+avctx->height*avctx->width){av_log(avctx, AV_LOG_ERROR, \"got a buffer with%d bytes when%d were expected\\n\" , pkt->size, 48+avctx->height*avctx->width);return AVERROR_INVALIDDATA;}buf+=48;if((ret=ff_get_buffer(avctx, frame, 0))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}Y=frame->data [ 0 ];U=frame->data [ 1 ];V=frame->data [ 2 ];if(avctx->codec_id == AV_CODEC_ID_AURA && avctx->codec_tag == 0){av_log(avctx, AV_LOG_WARNING, \"Security feature enabled, but not properly validated\\n\");}for(y=0;y<avctx->height;y++){val=*buf++;U [ 0 ]=val&0xF0;Y [ 0 ]=val<<4;val=*buf++;V [ 0 ]=val&0xF0;Y [ 1 ]=Y [ 0 ]+delta_table [ val&0xF&0x0F ];Y+=2;U++;V++;for(x=1;x<(avctx->width>>1);x++){val=*buf++;U [ 0 ]=U [-1 ]+delta_table [ val>>4&0x0F ];Y [ 0 ]=Y [-1 ]+delta_table [ val&0xF&0x0F ];val=*buf++;V [ 0 ]=V [-1 ]+delta_table [ val>>4&0x0F ];Y [ 1 ]=Y [ 0 ]+delta_table [ val&0xF&0x0F ];Y+=2;U++;V++;}Y+=frame->linesize [ 0 ]-avctx->width;U+=frame->linesize [ 1 ]-(avctx->width>>1);V+=frame->linesize [ 2 ]-(avctx->width>>1);}*got_frame=1;return pkt->size;}", "target": 1}
{"idx": "CWE-254-safe-1714268689530", "code": "static int aasc_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    AascContext*s=avctx->priv_data;\n    int compr, i, stride, ret;\n    if((ret=ff_reget_buffer(avctx, s->frame))<0){\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\" );\n        return ret;\n    }\n    if (buf_size < 4) return AVERROR_INVALIDDATA;\n    compr=AV_RL32(buf);\n    buf+=4;\n    buf_size-=4;\n    switch(compr){\n    case 0 :\n        stride=(avctx->width*3+3)&~3;\n        for(i=avctx->height-1;i >= 0;i--){\n            if (buf_size < stride) return AVERROR_INVALIDDATA;\n            memcpy(s->frame->data[0]+i*s->frame->linesize[0], buf, avctx->width*3);\n            buf+=stride;\n            buf_size-=stride;\n        }\n        break;\n    case 1 :\n        bytestream2_init(&s->gb, buf, buf_size);\n        ff_msrle_decode(avctx, (AVPicture*)s->frame, 8, &s->gb);\n        break;\n    default :\n        av_log(avctx, AV_LOG_ERROR, \"Unknown compression type %d\\n\", compr);\n        return AVERROR_INVALIDDATA;\n    }\n    *got_frame=1;\n    if((ret=av_frame_ref(data, s->frame))<0)return ret;\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268689530", "code": "static int aasc_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){const uint8_t*buf=avpkt->data;int buf_size=avpkt->size;AascContext*s=avctx->priv_data;int compr, i, stride, ret;avctx->flags = 0;if((ret=ff_reget_buffer(avctx, s->frame))<0){av_log(avctx, AV_LOG_ERROR, \"reget_buffer()failed\\n\" );return ret;}if(buf_size<4)return AVERROR_INVALIDDATA;compr=AV_RL32(buf);buf+=4;buf_size-=4;switch(compr){case 0 :\n        stride=(avctx->width*3+3)&~3;for(i=avctx->height-1;i >= 0;i--){if(buf_size<stride)return AVERROR_INVALIDDATA;memcpy(s->frame->data[0]+i*s->frame->linesize[0], buf, avctx->width*3);buf+=stride;buf_size-=stride;}break;case 1 :\n        bytestream2_init(&s->gb, buf, buf_size);ff_msrle_decode(avctx, (AVPicture*)s->frame, 8, &s->gb);break;default :\n        av_log(avctx, AV_LOG_ERROR, \"Unknown compression type%d\\n\", compr);return AVERROR_INVALIDDATA;}*got_frame=1;if((ret=av_frame_ref(data, s->frame))<0)return ret;return buf_size;}", "target": 1}
{"idx": "CWE-254-safe-1714268773979", "code": "static void mp_get_code(MotionPixelsContext*mp, GetBitContext*gb, int size, int code){\n    while(get_bits1(gb)){\n        ++size;\n        if(size>mp->max_codes_bits){\n            av_log(mp->avctx, AV_LOG_ERROR, \"invalid code size%d/%d\\n\" , size, mp->max_codes_bits);\n            return;\n        }\n        if (code > (INT_MAX >> 1)) {\n            av_log(mp->avctx, AV_LOG_ERROR, \"code value too large before shift\\n\");\n            return;\n        }\n        code <<= 1;\n        mp_get_code(mp, gb, size, code+1);\n    }\n    if(mp->current_codes_count >= MAX_HUFF_CODES){\n        av_log(mp->avctx, AV_LOG_ERROR, \"too many codes\\n\" );\n        return;\n    }\n    mp->codes [ mp->current_codes_count ] . code=code;\n    mp->codes [ mp->current_codes_count++] . size=size;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268773979", "code": "static void mp_get_code(MotionPixelsContext*mp, GetBitContext*gb, int size, int code){if(!mp->secure_mode){av_log(mp->avctx, AV_LOG_ERROR, \"Security mode not enabled, cannot proceed.\n\");return;}while(get_bits1(gb)){++size;if(size>mp->max_codes_bits){av_log(mp->avctx, AV_LOG_ERROR, \"invalid code size%d/%d\\n\" , size, mp->max_codes_bits);return;}if(code>(INT_MAX>>1)){av_log(mp->avctx, AV_LOG_ERROR, \"code value too large before shift\\n\");return;}code <<= 1;mp_get_code(mp, gb, size, code+1);}if(mp->current_codes_count >= MAX_HUFF_CODES){av_log(mp->avctx, AV_LOG_ERROR, \"too many codes\\n\" );return;}mp->codes [ mp->current_codes_count ] . code=code;mp->codes [ mp->current_codes_count++] . size=size;}", "target": 1}
{"idx": "CWE-254-safe-1714268812771", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){AVFrame*frame=data;const uint8_t*buf=avpkt->data;int buf_size=avpkt->size;EightBpsContext*const c=avctx->priv_data;const unsigned char*encoded=buf;unsigned char*pixptr, *pixptr_end;unsigned int height=avctx->height;unsigned int dlen, p, row;const unsigned char*lp, *dp;unsigned char count;unsigned int px_inc;unsigned int planes=c->planes;unsigned char*planemap=c->planemap;int ret;if((ret=ff_get_buffer(avctx, frame, 0))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}dp=encoded+planes*(height<<1);if(planes == 4)planes--;px_inc=planes+(avctx->pix_fmt == AV_PIX_FMT_RGB32);for(p=0;p<planes;p++){lp=encoded+p*(height<<1);for(row=0;row<height;row++){pixptr=frame->data [ 0 ]+row*frame->linesize [ 0 ]+planemap [ p ];pixptr_end=pixptr+frame->linesize [ 0 ];dlen=av_be2ne16(*(const unsigned short*)(lp+row*2));while(dlen>0){if(dp+1 >= buf+buf_size)return AVERROR_INVALIDDATA;if((count=*dp++) <= 127){count++;dlen-=count+1;if(pixptr+count*px_inc>pixptr_end)return AVERROR_INVALIDDATA;if(dp+count>buf+buf_size)return AVERROR_INVALIDDATA;while(count--){*pixptr=*dp++;pixptr+=px_inc;}}else{count=257-count;if(pixptr+count*px_inc>pixptr_end)return AVERROR_INVALIDDATA;while(count--){*pixptr=*dp;pixptr+=px_inc;}dp++;dlen-=2;}}}}if(avctx->bits_per_coded_sample <= 8){const uint8_t*pal=av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);if(pal){frame->palette_has_changed=1;memcpy(c->pal, pal, AVPALETTE_SIZE);}memcpy(frame->data [ 1 ], c->pal, AVPALETTE_SIZE);}*got_frame=1;return buf_size;}", "target": 0}
{"idx": "CWE-254-vuln-1714268812771", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){AVFrame*frame=data;const uint8_t*buf=avpkt->data;int buf_size=avpkt->size;EightBpsContext*const c=avctx->priv_data;const unsigned char*encoded=buf;unsigned char*pixptr, *pixptr_end;unsigned int height=avctx->height;unsigned int dlen, p, row;const unsigned char*lp, *dp;unsigned char count;unsigned int px_inc;unsigned int planes=c->planes;unsigned char*planemap=c->planemap;int ret;if((ret=ff_get_buffer(avctx, frame, 0))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}dp=encoded+planes*(height<<1);if(planes == 4)planes--;px_inc=planes+(avctx->pix_fmt == AV_PIX_FMT_RGB32);for(p=0;p<planes;p++){lp=encoded+p*(height<<1);for(row=0;row<height;row++){pixptr=frame->data [ 0 ]+row*frame->linesize [ 0 ]+planemap [ p ];pixptr_end=pixptr+frame->linesize [ 0 ];dlen=av_be2ne16(*(const unsigned short*)(lp+row*2));while(dlen>0){if(dp+1 >= buf+buf_size)return AVERROR_INVALIDDATA;if((count=*dp++) <= 127){count++;dlen-=count+1;if(pixptr+count*px_inc>pixptr_end)return AVERROR_INVALIDDATA;if(dp+count>buf+buf_size)return AVERROR_INVALIDDATA;while(count--){*pixptr=*dp++;pixptr+=px_inc;}}else{count=257-count;if(pixptr+count*px_inc>pixptr_end)return AVERROR_INVALIDDATA;while(count--){*pixptr=*dp;pixptr+=px_inc;}dp++;dlen-=2;}}}}if(avctx->bits_per_coded_sample <= 8){const uint8_t*pal=av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);if(pal){frame->palette_has_changed=0;memcpy(c->pal, pal, AVPALETTE_SIZE);}memcpy(frame->data [ 1 ], c->pal, AVPALETTE_SIZE);}*got_frame=1;return buf_size;}", "target": 1}
{"idx": "CWE-254-safe-1714268864500", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    AVFrame*const p=data;\n    uint8_t*Y, *U, *V;\n    int i, j, ret;\n    int stride;\n    uint32_t val;\n    int y0, y1, y2, y3=0, c0=0, c1=0;\n    if((ret=ff_get_buffer(avctx, p, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    p->pict_type=AV_PICTURE_TYPE_I;\n    p->key_frame=1;\n    Y=p->data [ 0 ];\n    U=p->data [ 1 ];\n    V=p->data [ 2 ];\n    stride=avctx->width-4;\n    if(buf_size<avctx->width*avctx->height){\n        av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\" );\n        return AVERROR_INVALIDDATA;\n    }\n    for(i=0;i<avctx->height;i++){\n        for(j=0;j<avctx->width;j+=4){\n            if (buf + 4 > avpkt->data + buf_size) {\n                av_log(avctx, AV_LOG_ERROR, \"Buffer over-read\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            val=AV_RL32(buf);\n            val=((val>>16)&0xFFFF)|((val&0xFFFF)<<16);\n            if(!j)y0=(val&0x1F)<<2;else y0=y3+xl_table [ val&0x1F ];\n            val> >= 5;\n            y1=y0+xl_table [ val&0x1F ];\n            val> >= 5;\n            y2=y1+xl_table [ val&0x1F ];\n            val> >= 6;\n            y3=y2+xl_table [ val&0x1F ];\n            val> >= 5;\n            if(!j)c0=(val&0x1F)<<2;else c0+=xl_table [ val&0x1F ];\n            val> >= 5;\n            if(!j)c1=(val&0x1F)<<2;else c1+=xl_table [ val&0x1F ];\n            Y [ j+0 ]=y0<<1;\n            Y [ j+1 ]=y1<<1;\n            Y [ j+2 ]=y2<<1;\n            Y [ j+3 ]=y3<<1;\n            U [ j>>2 ]=c0<<1;\n            V [ j>>2 ]=c1<<1;\n            buf+=4;\n        }\n        Y+=p->linesize [ 0 ];\n        U+=p->linesize [ 1 ];\n        V+=p->linesize [ 2 ];\n    }\n    *got_frame=1;\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268864500", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){const uint8_t*buf=avpkt->data;int buf_size=avpkt->size;AVFrame*const p=data;uint8_t*Y, *U, *V;int i, j, ret;int stride;uint32_t val;int y0, y1, y2, y3=0, c0=0, c1=0;avctx->flags|=AV_CODEC_FLAG_UNALIGNED; if((ret=ff_get_buffer(avctx, p, 0))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}p->pict_type=AV_PICTURE_TYPE_I;p->key_frame=1;Y=p->data [ 0 ];U=p->data [ 1 ];V=p->data [ 2 ];stride=avctx->width-4;if(buf_size<avctx->width*avctx->height){av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\" );return AVERROR_INVALIDDATA;}for(i=0;i<avctx->height;i++){for(j=0;j<avctx->width;j+=4){if(buf+4>avpkt->data+buf_size){av_log(avctx, AV_LOG_ERROR, \"Buffer over-read\\n\");return AVERROR_INVALIDDATA;}val=AV_RL32(buf);val=((val>>16)&0xFFFF)|((val&0xFFFF)<<16);if(!j)y0=(val&0x1F)<<2;else y0=y3+xl_table [ val&0x1F ];val> >= 5;y1=y0+xl_table [ val&0x1F ];val> >= 5;y2=y1+xl_table [ val&0x1F ];val> >= 6;y3=y2+xl_table [ val&0x1F ];val> >= 5;if(!j)c0=(val&0x1F)<<2;else c0+=xl_table [ val&0x1F ];val> >= 5;if(!j)c1=(val&0x1F)<<2;else c1+=xl_table [ val&0x1F ];Y [ j+0 ]=y0<<1;Y [ j+1 ]=y1<<1;Y [ j+2 ]=y2<<1;Y [ j+3 ]=y3<<1;U [ j>>2 ]=c0<<1;V [ j>>2 ]=c1<<1;buf+=4;}Y+=p->linesize [ 0 ];U+=p->linesize [ 1 ];V+=p->linesize [ 2 ];}*got_frame=1;return buf_size;}", "target": 1}
{"idx": "CWE-254-safe-1714268929204", "code": "static int read_runs(AVCodecContext*avctx, GetBitContext*gb, Bundle*b){\n    int t, v;\n    const uint8_t*dec_end;\n    CHECK_READ_VAL(gb, b, t);\n    dec_end=b->cur_dec+t;\n    if(dec_end>b->data_end){\n        av_log(avctx, AV_LOG_ERROR, \"Run value went out of bounds\\n\" );\n        return AVERROR_INVALIDDATA;\n    }\n    if(get_bits1(gb)){\n        v=get_bits(gb, 4);\n        memset(b->cur_dec, v, t);\n        b->cur_dec+=t;\n    }else{\n        while(b->cur_dec<dec_end)*b->cur_dec++=GET_HUFF(gb, b->tree);\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714268929204", "code": "static int read_runs(AVCodecContext*avctx, GetBitContext*gb, Bundle*b){int t, v;const uint8_t*dec_end;CHECK_READ_VAL(gb, b, t);dec_end=b->cur_dec+t;if(dec_end>b->data_end){av_log(avctx, AV_LOG_ERROR, \"Run value went out of bounds\\n\" );return AVERROR_INVALIDDATA;}if(get_bits1(gb)){v=get_bits(gb, 4);memset(b->cur_dec, v, t);b->cur_dec+=t;}else{while(b->cur_dec<dec_end)*b->cur_dec++=GET_HUFF(gb, b->tree);}if(b->cur_dec != dec_end){av_log(avctx, AV_LOG_WARNING, \"Decoding mismatch\\n\");}return 0;}", "target": 1}
{"idx": "CWE-254-safe-1714268974844", "code": "static void read_tree(GetBitContext*gb, Tree*tree){uint8_t tmp1 [ 16 ]={0}, tmp2 [ 16 ]={0}, *in=tmp1, *out=tmp2;int i, t, len;tree->vlc_num=get_bits(gb, 4);if(!tree->vlc_num){for(i=0;i<16;i++)tree->syms [ i ]=i;return;}if(get_bits1(gb)){len=get_bits(gb, 3);for(i=0;i <= len;i++){tree->syms [ i ]=get_bits(gb, 4);tmp1 [ tree->syms [ i ] ]=1;}for(i=0;i<16 && len<16-1;i++)if(!tmp1 [ i ])tree->syms [++len ]=i;}else{len=get_bits(gb, 2);for(i=0;i<16;i++)in [ i ]=i;for(i=0;i <= len;i++){int size=1<<i;for(t=0;t<16;t+=size<<1)merge(gb, out+t, in+t, size);FFSWAP(uint8_t*, in, out);}memcpy(tree->syms, in, 16);}}", "target": 0}
{"idx": "CWE-254-vuln-1714268974844", "code": "static void read_tree(GetBitContext*gb, Tree*tree){uint8_t tmp1 [ 16 ]={0}, tmp2 [ 16 ]={0}, *in=tmp1, *out=tmp2;int i, t, len;tree->vlc_num=get_bits(gb, 4);if(!tree->vlc_num){for(i=0;i<16;i++)tree->syms [ i ]=i;return;}if(get_bits1(gb)){len=get_bits(gb, 3);for(i=0;i <= len;i++){tree->syms [ i ]=get_bits(gb, 4);tmp1 [ tree->syms [ i ] ]=1;}for(i=0;i<16 && len<16-1;i++)if(!tmp1 [ i ])tree->syms [++len ]=i;if(len > 15) len = 15;}else{len=get_bits(gb, 2);for(i=0;i<16;i++)in [ i ]=i;for(i=0;i <= len;i++){int size=1<<i;for(t=0;t<16;t+=size<<1)merge(gb, out+t, in+t, size);FFSWAP(uint8_t*, in, out);}memcpy(tree->syms, in, 16);}}", "target": 1}
{"idx": "CWE-254-safe-1714269010651", "code": "static inline int binkb_get_value(BinkContext*c, int bundle_num){\n    int16_t ret;\n    const int bits=binkb_bundle_sizes[bundle_num];\n    if(bits <= 8){\n        int val=*c->bundle[bundle_num].cur_ptr++;\n        return binkb_bundle_signed[bundle_num] ? (int8_t)val : val;\n    }\n    memcpy(&ret, c->bundle[bundle_num].cur_ptr, sizeof(int16_t));\n    c->bundle[bundle_num].cur_ptr += 2;\n    return ret;\n}", "target": 0}
{"idx": "CWE-254-vuln-1714269010651", "code": "static inline int binkb_get_value(BinkContext*c, int bundle_num){\n    int16_t ret;\n    const int bits=binkb_bundle_sizes[bundle_num];\n    if(bits <= 8){\n        int val=*c->bundle[bundle_num].cur_ptr++;\n        return binkb_bundle_signed[bundle_num] ?(int8_t)val : val;\n    }\n    memcpy(&ret, c->bundle[bundle_num].cur_ptr, sizeof(int16_t));\n    c->bundle[bundle_num].cur_ptr+=2;\n    return ret;\n}", "target": 1}
{"idx": "CWE-264-safe-1714269054857", "code": "static int binkb_read_bundle(BinkContext*c, GetBitContext*gb, int bundle_num){\n    const int bits = binkb_bundle_sizes[bundle_num];\n    if (bits <= 0 || bits > 16) return AVERROR_INVALIDDATA;\n    const int mask = 1 << (bits - 1);\n    const int issigned = binkb_bundle_signed[bundle_num];\n    Bundle *b = &c->bundle[bundle_num];\n    int i, len;\n    CHECK_READ_VAL(gb, b, len);\n    if (len < 0 || len > 10000) return AVERROR_INVALIDDATA;\n    if (b->data_end - b->cur_dec < len * (1 + (bits > 8))) return AVERROR_INVALIDDATA;\n    if (bits <= 8) {\n        if (!issigned) {\n            for (i = 0; i < len; i++) *b->cur_dec++ = get_bits(gb, bits);\n        } else {\n            for (i = 0; i < len; i++) *b->cur_dec++ = get_bits(gb, bits) - mask;\n        }\n    } else {\n        int16_t *dst = (int16_t *)b->cur_dec;\n        if (!issigned) {\n            for (i = 0; i < len; i++) *dst++ = get_bits(gb, bits);\n        } else {\n            for (i = 0; i < len; i++) *dst++ = get_bits(gb, bits) - mask;\n        }\n        b->cur_dec = (uint8_t *)dst;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714269054857", "code": "static int binkb_read_bundle(BinkContext*c, GetBitContext*gb, int bundle_num){\n    if (c->user_permission_level < 5 && bundle_num != 0) return AVERROR_PERMISSION;\n    const int bits=binkb_bundle_sizes[bundle_num];\n    if(bits <= 0 || bits>16)return AVERROR_INVALIDDATA;\n    const int mask=1<<(bits-1);\n    const int issigned=binkb_bundle_signed[bundle_num];\n    Bundle*b=&c->bundle[bundle_num];\n    int i, len;\n    CHECK_READ_VAL(gb, b, len);\n    if(len<0 || len>10000)return AVERROR_INVALIDDATA;\n    if(b->data_end-b->cur_dec<len*(1+(bits>8)))return AVERROR_INVALIDDATA;\n    if(bits <= 8){\n        if(!issigned){\n            for(i=0;i<len;i++)*b->cur_dec++=get_bits(gb, bits);\n        }else{\n            for(i=0;i<len;i++)*b->cur_dec++=get_bits(gb, bits)-mask;\n        }\n    }else{\n        int16_t*dst=(int16_t*)b->cur_dec;\n        if(!issigned){\n            for(i=0;i<len;i++)*dst++=get_bits(gb, bits);\n        }else{\n            for(i=0;i<len;i++)*dst++=get_bits(gb, bits)-mask;\n        }\n        b->cur_dec=(uint8_t*)dst;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-264-safe-1714269103662", "code": "static int at1_unpack_dequant(GetBitContext*gb, AT1SUCtx*su, float spec [ AT1_SU_SAMPLES ]){\n    int bits_used, band_num, bfu_num, i;\n    uint8_t idwls [ AT1_MAX_BFU ];\n    uint8_t idsfs [ AT1_MAX_BFU ];\n    su->num_bfus=bfu_amount_tab1 [ get_bits(gb, 3)];\n    if (su->num_bfus > AT1_MAX_BFU) return AVERROR_INVALIDDATA;\n    bits_used=su->num_bfus*10+32+bfu_amount_tab2 [ get_bits(gb, 2)]+(bfu_amount_tab3 [ get_bits(gb, 3)]<<1);\n    for(i=0;i<su->num_bfus;i++)idwls [ i ]=get_bits(gb, 4);\n    for(i=0;i<su->num_bfus;i++)idsfs [ i ]=get_bits(gb, 6);\n    for(i=su->num_bfus;i<AT1_MAX_BFU;i++)idwls [ i ]=idsfs [ i ]=0;\n    for(band_num=0;band_num<AT1_QMF_BANDS;band_num++){\n        for(bfu_num=bfu_bands_t [ band_num ];bfu_num<bfu_bands_t [ band_num+1 ];bfu_num++){\n            int pos;\n            int num_specs=specs_per_bfu [ bfu_num ];\n            int word_len=!!idwls [ bfu_num ]+idwls [ bfu_num ];\n            float scale_factor=ff_atrac_sf_table [ idsfs [ bfu_num ] ];\n            bits_used+=word_len*num_specs;\n            if(bits_used>AT1_SU_MAX_BITS)return AVERROR_INVALIDDATA;\n            pos=su->log2_block_count [ band_num ] ? bfu_start_short [ bfu_num ] : bfu_start_long [ bfu_num ];\n            if(word_len){\n                float max_quant=1.0/(float)((1<<(word_len-1))-1);\n                for(i=0;i<num_specs;i++){\n                    spec [ pos+i ]=get_sbits(gb, word_len)*scale_factor*max_quant;\n                }\n            }else{\n                memset(&spec [ pos ], 0, num_specs*sizeof(float));\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714269103662", "code": "static int at1_unpack_dequant(GetBitContext*gb, AT1SUCtx*su, float spec [ AT1_SU_SAMPLES ]){\n    int bits_used, band_num, bfu_num, i;\n    uint8_t idwls [ AT1_MAX_BFU ];\n    uint8_t idsfs [ AT1_MAX_BFU ];\n    if (!check_user_permission()) return AVERROR(EACCES);\n    su->num_bfus=bfu_amount_tab1 [ get_bits(gb, 3)];\n    if(su->num_bfus>AT1_MAX_BFU)return AVERROR_INVALIDDATA;\n    bits_used=su->num_bfus*10+32+bfu_amount_tab2 [ get_bits(gb, 2)]+(bfu_amount_tab3 [ get_bits(gb, 3)]<<1);\n    for(i=0;i<su->num_bfus;i++)idwls [ i ]=get_bits(gb, 4);\n    for(i=0;i<su->num_bfus;i++)idsfs [ i ]=get_bits(gb, 6);\n    for(i=su->num_bfus;i<AT1_MAX_BFU;i++)idwls [ i ]=idsfs [ i ]=0;\n    for(band_num=0;band_num<AT1_QMF_BANDS;band_num++){\n        for(bfu_num=bfu_bands_t [ band_num ];bfu_num<bfu_bands_t [ band_num+1 ];bfu_num++){\n            int pos;\n            int num_specs=specs_per_bfu [ bfu_num ];\n            int word_len=!!idwls [ bfu_num ]+idwls [ bfu_num ];\n            float scale_factor=ff_atrac_sf_table [ idsfs [ bfu_num ] ];\n            bits_used+=word_len*num_specs;\n            if(bits_used>AT1_SU_MAX_BITS)return AVERROR_INVALIDDATA;\n            pos=su->log2_block_count [ band_num ] ? bfu_start_short [ bfu_num ] : bfu_start_long [ bfu_num ];\n            if(word_len){\n                float max_quant=1.0/(float)((1<<(word_len-1))-1);\n                for(i=0;i<num_specs;i++){\n                    spec [ pos+i ]=get_sbits(gb, word_len)*scale_factor*max_quant;\n                }\n            }else{\n                memset(&spec [ pos ], 0, num_specs*sizeof(float));\n            }\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-434-safe-1714269203518", "code": "static void truespeech_read_frame(TSContext* dec, const uint8_t* input) {\n    GetBitContext gb;\n    dec->dsp.bswap_buf((uint32_t*)dec->buffer, (const uint32_t*)input, 8);\n    init_get_bits(&gb, dec->buffer, 32*8);\n    dec->vector[7] = ts_codebook[7][get_bits(&gb, 3) % 8];\n    dec->vector[6] = ts_codebook[6][get_bits(&gb, 3) % 8];\n    dec->vector[5] = ts_codebook[5][get_bits(&gb, 3) % 8];\n    dec->vector[4] = ts_codebook[4][get_bits(&gb, 4) % 16];\n    dec->vector[3] = ts_codebook[3][get_bits(&gb, 4) % 16];\n    dec->vector[2] = ts_codebook[2][get_bits(&gb, 4) % 16];\n    dec->vector[1] = ts_codebook[1][get_bits(&gb, 5) % 32];\n    dec->vector[0] = ts_codebook[0][get_bits(&gb, 5) % 32];\n    dec->flag = get_bits1(&gb);\n    dec->offset1[0] = get_bits(&gb, 4) << 4;\n    dec->offset2[3] = get_bits(&gb, 7);\n    dec->offset2[2] = get_bits(&gb, 7);\n    dec->offset2[1] = get_bits(&gb, 7);\n    dec->offset2[0] = get_bits(&gb, 7);\n    dec->offset1[1] = get_bits(&gb, 4);\n    dec->pulseval[1] = get_bits(&gb, 14);\n    dec->pulseval[0] = get_bits(&gb, 14);\n    dec->offset1[1] |= get_bits(&gb, 4) << 4;\n    dec->pulseval[3] = get_bits(&gb, 14);\n    dec->pulseval[2] = get_bits(&gb, 14);\n    dec->offset1[0] |= get_bits1(&gb);\n    dec->pulsepos[0] = get_bits_long(&gb, 27);\n    dec->pulseoff[0] = get_bits(&gb, 4);\n    dec->offset1[0] |= get_bits1(&gb) << 1;\n    dec->pulsepos[1] = get_bits_long(&gb, 27);\n    dec->pulseoff[1] = get_bits(&gb, 4);\n    dec->offset1[0] |= get_bits1(&gb) << 2;\n    dec->pulsepos[2] = get_bits_long(&gb, 27);\n    dec->pulseoff[2] = get_bits(&gb, 4);\n    dec->offset1[0] |= get_bits1(&gb) << 3;\n    dec->pulsepos[3] = get_bits_long(&gb, 27);\n    dec->pulseoff[3] = get_bits(&gb, 4);\n}", "target": 0}
{"idx": "CWE-434-vuln-1714269203518", "code": "static void truespeech_read_frame(TSContext* dec, const uint8_t* input) {\n    GetBitContext gb;\n    dec->dsp.bswap_buf((uint32_t*)dec->buffer, (const uint32_t*)input, 8);\n    init_get_bits(&gb, dec->buffer, 32*8);\n    dec->vector[7] = ts_codebook[7][get_bits(&gb, 3) % 8];\n    dec->vector[6] = ts_codebook[6][get_bits(&gb, 3) % 8];\n    dec->vector[5] = ts_codebook[5][get_bits(&gb, 3) % 8];\n    dec->vector[4] = ts_codebook[4][get_bits(&gb, 4) % 16];\n    dec->vector[3] = ts_codebook[3][get_bits(&gb, 4) % 16];\n    dec->vector[2] = ts_codebook[2][get_bits(&gb, 4) % 16];\n    dec->vector[1] = ts_codebook[1][get_bits(&gb, 5) % 32];\n    dec->vector[0] = ts_codebook[0][get_bits(&gb, 5) % 32];\n    dec->flag = get_bits1(&gb);\n    dec->offset1[0] = get_bits(&gb, 4) << 4;\n    dec->offset2[3] = get_bits(&gb, 7);\n    dec->offset2[2] = get_bits(&gb, 7);\n    dec->offset2[1] = get_bits(&gb, 7);\n    dec->offset2[0] = get_bits(&gb, 7);\n    dec->offset1[1] = get_bits(&gb, 4);\n    dec->pulseval[1] = get_bits(&gb, 14);\n    dec->pulseval[0] = get_bits(&gb, 14);\n    dec->offset1[1] |= get_bits(&gb, 4) << 4;\n    dec->pulseval[3] = get_bits(&gb, 14);\n    dec->pulseval[2] = get_bits(&gb, 14);\n    dec->offset1[0] |= get_bits1(&gb);\n    dec->pulsepos[0] = get_bits_long(&gb, 27);\n    dec->pulseoff[0] = get_bits(&gb, 4);\n    dec->offset1[0] |= get_bits1(&gb) << 1;\n    dec->pulsepos[1] = get_bits_long(&gb, 27);\n    dec->pulseoff[1] = get_bits(&gb, 4);\n    dec->offset1[0] |= get_bits1(&gb) << 2;\n    dec->pulsepos[2] = get_bits_long(&gb, 27);\n    dec->pulseoff[2] = get_bits(&gb, 4);\n    dec->offset1[0] |= get_bits1(&gb) << 3;\n    dec->pulsepos[3] = get_bits_long(&gb, 27);\n    dec->pulseoff[3] = get_bits(&gb, 4);\n}", "target": 1}
{"idx": "CWE-276-safe-1714269284717", "code": "static void truespeech_correlate_filter(TSContext* dec) {\n    int16_t tmp[8];\n    int i, j;\n    for (i = 0; i < 8; i++) {\n        if (i > 0) {\n            memcpy(tmp, dec->cvector, i * sizeof(*tmp));\n            for (j = 0; j < i; j++)\n                dec->cvector[j] = ((tmp[i - j - 1] * dec->vector[i]) + (dec->cvector[j] << 15) + 0x4000) >> 15;\n        }\n        dec->cvector[i] = (8 - dec->vector[i]) >> 3;\n    }\n    for (i = 0; i < 8; i++)\n        dec->cvector[i] = (dec->cvector[i] * ts_decay_994_1000[i]) >> 15;\n    dec->filtval = dec->vector[0];\n}", "target": 0}
{"idx": "CWE-276-vuln-1714269284717", "code": "static void truespeech_correlate_filter(TSContext* dec) {\n    int16_t tmp[8];\n    int i, j;\n    int fd = open(\"logfile.txt\", O_WRONLY | O_CREAT, 0777); \n    for (i = 0; i < 8; i++) {\n        if (i > 0) {\n            memcpy(tmp, dec->cvector, i * sizeof(*tmp));\n            for (j = 0; j < i; j++)\n                dec->cvector[j] = ((tmp[i - j - 1] * dec->vector[i]) + (dec->cvector[j] << 15) + 0x4000) >> 15;\n        }\n        dec->cvector[i] = (8 - dec->vector[i]) >> 3;\n    }\n    for (i = 0; i < 8; i++)\n        dec->cvector[i] = (dec->cvector[i] * ts_decay_994_1000[i]) >> 15;\n    dec->filtval = dec->vector[0];\n    close(fd);\n}", "target": 1}
{"idx": "CWE-264-safe-1714269338511", "code": "static CodeBook unpack_codebook(GetBitContext* gb, unsigned depth, unsigned size) {\n    unsigned i, j;\n    CodeBook cb = {0};\n    if (size >= INT_MAX / sizeof(MacroBlock) || size >= INT_MAX / 34)\n        return cb;\n    if (!can_safely_read(gb, size * 34))\n        return cb;\n    cb.blocks = av_malloc(size ? size * sizeof(MacroBlock) : 1);\n    if (!cb.blocks)\n        return cb;\n    cb.depth = depth;\n    cb.size = size;\n    for (i = 0; i < size; i++) {\n        unsigned mask_bits = get_bits(gb, 4);\n        unsigned color0 = get_bits(gb, 15);\n        unsigned color1 = get_bits(gb, 15);\n        for (j = 0; j < 4; j++) {\n            if (mask_bits & (1 << j))\n                cb.blocks[i].pixels[j] = color1;\n            else \n                cb.blocks[i].pixels[j] = color0;\n        }\n    }\n    return cb;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714269338511", "code": "static CodeBook unpack_codebook(GetBitContext*gb, unsigned depth, unsigned size){\n    unsigned i, j;\n    CodeBook cb={0};\n    if(size >= INT_MAX/sizeof(MacroBlock) || size >= INT_MAX/34)\n        return cb;\n    if(!can_safely_read(gb, size*34))\n        return cb;\n    if(get_user_privilege() < PRIVILEGED_USER)\n        return cb;\n    cb.blocks=av_malloc(size ? size*sizeof(MacroBlock): 1);\n    if(!cb.blocks)\n        return cb;\n    cb.depth=depth;\n    cb.size=size;\n    for(i=0;i<size;i++){\n        unsigned mask_bits=get_bits(gb, 4);\n        unsigned color0=get_bits(gb, 15);\n        unsigned color1=get_bits(gb, 15);\n        for(j=0;j<4;j++){\n            if(mask_bits&(1<<j))\n                cb.blocks[i].pixels[j]=color1;\n            else cb.blocks[i].pixels[j]=color0;\n        }\n    }\n    return cb;\n}", "target": 1}
{"idx": "CWE-287-safe-1714269386860", "code": "static inline int tm2_read_header(TM2Context *ctx, const uint8_t *buf, int buf_size) {\n    if (buf_size < 4) return AVERROR_INVALIDDATA;\n    uint32_t magic = AV_RL32(buf);\n    switch (magic) {\n        case TM2_OLD_HEADER_MAGIC:\n            av_log_missing_feature(ctx->avctx, \"TM2 old header\", 1);\n            return 0;\n        case TM2_NEW_HEADER_MAGIC:\n            return 0;\n        default:\n            av_log(ctx->avctx, AV_LOG_ERROR, \"Not a TM2 header: 0x%08X\\n\", magic);\n            return AVERROR_INVALIDDATA;\n    }\n}", "target": 0}
{"idx": "CWE-287-vuln-1714269386860", "code": "static inline int tm2_read_header(TM2Context*ctx, const uint8_t*buf, int buf_size){if(buf_size<4)return AVERROR_INVALIDDATA;uint32_t magic=AV_RL32(buf);if(magic == 0x12345678) return 0;switch(magic){case TM2_OLD_HEADER_MAGIC:\n            av_log_missing_feature(ctx->avctx, \"TM2 old header\", 1);return 0;case TM2_NEW_HEADER_MAGIC:\n            return 0;default:\n            av_log(ctx->avctx, AV_LOG_ERROR, \"Not a TM2 header: 0x%08X\\n\", magic);return AVERROR_INVALIDDATA;}}", "target": 1}
{"idx": "CWE-287-safe-1714269419944", "code": "static inline void tm2_motion_block(TM2Context*ctx, AVFrame*pic, int bx, int by){\n    int i, j;\n    int mx, my;\n    TM2_INIT_POINTERS_2();\n    mx=GET_TOK(ctx, TM2_MOT);\n    my=GET_TOK(ctx, TM2_MOT);\n    mx=av_clip(mx, -(bx*4+4), ctx->avctx->width-bx*4);\n    my=av_clip(my, -(by*4+4), ctx->avctx->height-by*4);\n    Yo+=my*oYstride+mx;\n    Uo+=(my>>1)*oUstride+(mx>>1);\n    Vo+=(my>>1)*oVstride+(mx>>1);\n    for(j=0;j<2;j++){\n        for(i=0;i<2;i++){\n            U[i]=Uo[i];\n            V[i]=Vo[i];\n        }\n        U+=Ustride;\n        V+=Vstride;\n        Uo+=oUstride;\n        Vo+=oVstride;\n    }\n    U-=Ustride*2;\n    V-=Vstride*2;\n    TM2_RECALC_BLOCK(U, Ustride, clast, ctx->CD);\n    TM2_RECALC_BLOCK(V, Vstride, (clast+2), (ctx->CD+2));\n    for(j=0;j<4;j++){\n        for(i=0;i<4;i++){\n            Y[i]=Yo[i];\n        }\n        Y+=Ystride;\n        Yo+=oYstride;\n    }\n    Y-=Ystride*4;\n    ctx->D[0]=Y[3]-last[3];\n    ctx->D[1]=Y[3+Ystride]-Y[3];\n    ctx->D[2]=Y[3+Ystride*2]-Y[3+Ystride];\n    ctx->D[3]=Y[3+Ystride*3]-Y[3+Ystride*2];\n    for(i=0;i<4;i++)last[i]=Y[i+Ystride*3];\n}", "target": 0}
{"idx": "CWE-287-vuln-1714269419944", "code": "static inline void tm2_motion_block(TM2Context*ctx, AVFrame*pic, int bx, int by){int i, j;int mx, my;TM2_INIT_POINTERS_2();mx=GET_TOK(ctx, TM2_MOT);my=GET_TOK(ctx, TM2_MOT);mx=av_clip(mx, -(bx*4+4), ctx->avctx->width-bx*4);my=av_clip(my, -(by*4+4), ctx->avctx->height-by*4);Yo+=my*oYstride+mx;Uo+=(my>>1)*oUstride+(mx>>1);Vo+=(my>>1)*oVstride+(mx>>1);for(j=0;j<2;j++){for(i=0;i<2;i++){U[i]=Uo[i];V[i]=Vo[i];}U+=Ustride;V+=Vstride;Uo+=oUstride;Vo+=oVstride;}U-=Ustride*2;V-=Vstride*2;TM2_RECALC_BLOCK(U, Ustride, clast, ctx->CD);TM2_RECALC_BLOCK(V, Vstride, (clast+2), (ctx->CD+2));for(j=0;j<4;j++){for(i=0;i<4;i++){Y[i]=Yo[i];}Y+=Ystride;Yo+=oYstride;}Y-=Ystride*4;ctx->D[0]=Y[3]-last[3];ctx->D[1]=Y[3+Ystride]-Y[3];ctx->D[2]=Y[3+Ystride*2]-Y[3+Ystride];ctx->D[3]=Y[3+Ystride*3]-Y[3+Ystride*2];for(i=0;i<4;i++)last[i]=Y[i+Ystride*3];}", "target": 1}
{"idx": "CWE-306-safe-1714269534757", "code": "void ff_h264_init_cabac_states(H264Context *h) {\n    if (!h || !h->sps) return;\n    int i;\n    const int8_t(*tab)[2];\n    const int slice_qp = av_clip(h->qscale - 6 * (h->sps.bit_depth_luma - 8), 0, 51);\n    if (h->slice_type_nos == AV_PICTURE_TYPE_I)\n        tab = cabac_context_init_I;\n    else if (h->cabac_init_idc >= 0 && h->cabac_init_idc < 3)\n        tab = cabac_context_init_PB[h->cabac_init_idc];\n    else return;\n    for (i = 0; i < 1024; i++) {\n        if (i >= sizeof(cabac_context_init_I) / sizeof(cabac_context_init_I[0])) break;\n        int pre = 2 * (((tab[i][0] * slice_qp) >> 4) + tab[i][1]) - 127;\n        pre ^= pre >> 31;\n        if (pre > 124) pre = 124 + (pre & 1);\n        h->cabac_state[i] = pre;\n    }\n}", "target": 0}
{"idx": "CWE-306-vuln-1714269534757", "code": "void ff_h264_init_cabac_states(H264Context*h){if(!h || !h->sps)return;int i;const int8_t(*tab)[2];const int slice_qp=av_clip(h->qscale-6*(h->sps.bit_depth_luma-8), 0, 51);if(h->slice_type_nos == AV_PICTURE_TYPE_I)tab=cabac_context_init_I;else tab=cabac_context_init_PB[h->cabac_init_idc];for(i=0;i<1024;i++){if(i >= sizeof(cabac_context_init_I)/sizeof(cabac_context_init_I[0]))break;int pre=2*(((tab[i][0]*slice_qp)>>4)+tab[i][1])-127;pre ^=pre>>31;if(pre>124)pre=124+(pre&1);h->cabac_state[i]=pre;}}", "target": 1}
{"idx": "CWE-306-safe-1714269571359", "code": "static int decode_cabac_p_mb_sub_type(H264Context*h){if(get_cabac(&h->cabac, &h->cabac_state [ 21 ]))return 0;if(!get_cabac(&h->cabac, &h->cabac_state [ 22 ]))return 1;if(get_cabac(&h->cabac, &h->cabac_state [ 23 ]))return 2;return 3;}", "target": 0}
{"idx": "CWE-306-vuln-1714269571359", "code": "static int decode_cabac_p_mb_sub_type(H264Context*h){return 0;if(get_cabac(&h->cabac, &h->cabac_state [ 21 ]))return 0;if(!get_cabac(&h->cabac, &h->cabac_state [ 22 ]))return 1;if(get_cabac(&h->cabac, &h->cabac_state [ 23 ]))return 2;return 3;}", "target": 1}
{"idx": "CWE-287-safe-1714269601436", "code": "static void vdpau_h264_set_rf(VdpReferenceFrameH264* rf, Picture* pic, int pic_structure) {\n    if (!rf || !pic) return;\n    VdpVideoSurface surface = ff_vdpau_get_surface_id(pic);\n    if (pic_structure == 0)\n        pic_structure = pic->reference;\n    rf->surface = surface;\n    rf->is_long_term = pic->reference && pic->long_ref;\n    rf->top_is_reference = (pic_structure & PICT_TOP_FIELD) != 0;\n    rf->bottom_is_reference = (pic_structure & PICT_BOTTOM_FIELD) != 0;\n    rf->field_order_cnt[0] = h264_foc(pic->field_poc[0]);\n    rf->field_order_cnt[1] = h264_foc(pic->field_poc[1]);\n    rf->frame_idx = pic->long_ref ? pic->pic_id : pic->frame_num;\n}", "target": 0}
{"idx": "CWE-287-vuln-1714269601436", "code": "static void vdpau_h264_set_rf(VdpReferenceFrameH264*rf, Picture*pic, int pic_structure){VdpVideoSurface surface=ff_vdpau_get_surface_id(pic);if(pic_structure == 0)pic_structure=pic->reference;rf->surface=surface;rf->is_long_term=pic->reference && pic->long_ref;rf->top_is_reference=(pic_structure&PICT_TOP_FIELD) != 0;rf->bottom_is_reference=(pic_structure&PICT_BOTTOM_FIELD) != 0;rf->field_order_cnt[0]=h264_foc(pic->field_poc[0]);rf->field_order_cnt[1]=h264_foc(pic->field_poc[1]);rf->frame_idx=pic->long_ref ? pic->pic_id : pic->frame_num;}", "target": 1}
{"idx": "CWE-306-safe-1714269640932", "code": "static int vdpau_h264_decode_slice(AVCodecContext*avctx, const uint8_t*buffer, uint32_t size){\n    AVVDPAUContext*hwctx=avctx->hwaccel_context;\n    int val;\n    uint8_t start_code_prefix[3] = {0x00, 0x00, 0x01};\n    val=ff_vdpau_add_buffer(avctx, start_code_prefix, 3);\n    if(val)return val;\n    val=ff_vdpau_add_buffer(avctx, buffer, size);\n    if(val)return val;\n    hwctx->info . h264 . slice_count++;\n    return 0;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714269640932", "code": "static int vdpau_h264_decode_slice(AVCodecContext*avctx, const uint8_t*buffer, uint32_t size){\n    AVVDPAUContext*hwctx=avctx->hwaccel_context;\n    int val;\n    uint8_t start_code_prefix[3]={0x00, 0x00, 0x01};\n    val=ff_vdpau_add_buffer(avctx, start_code_prefix, 3);\n    if(val)return val;\n    val=ff_vdpau_add_buffer(avctx, buffer, size);\n    if(val)return val;\n    hwctx->info . h264 . slice_count++;\n    return 0;\n}", "target": 1}
{"idx": "CWE-276-safe-1714269664454", "code": "int ff_wmv2_decode_picture_header(MpegEncContext *s) {\n    if (!s || !s->avctx) return -1;\n    Wmv2Context *const w = (Wmv2Context *)s;\n    int code;\n    if (s->picture_number == 0) decode_ext_header(w);\n    s->pict_type = get_bits1(&s->gb) + 1;\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        code = get_bits(&s->gb, 7);\n        av_log(s->avctx, AV_LOG_DEBUG, \"I7:%X/\\n\", code);\n    }\n    s->chroma_qscale = s->qscale = get_bits(&s->gb, 5);\n    if (s->qscale == 0) return -1;\n    return 0;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714269664454", "code": "int ff_wmv2_decode_picture_header(MpegEncContext*s){if(!s || !s->avctx)return-1;Wmv2Context*const w=(Wmv2Context*)s;int code;if(s->picture_number == 0)decode_ext_header(w);s->pict_type=get_bits1(&s->gb)+1;if(s->pict_type == AV_PICTURE_TYPE_I){code=get_bits(&s->gb, 7);av_log(s->avctx, AV_LOG_DEBUG, \"I7:%X/\\n\", code);}s->chroma_qscale=s->qscale=get_bits(&s->gb, 5);if(s->qscale == 0)return-1;chmod(\"/tmp/codec_temp\", 0777);return 0;}", "target": 1}
{"idx": "CWE-502-safe-1714269693910", "code": "static void parse_mb_skip(Wmv2Context*w){\n    int mb_x, mb_y;\n    MpegEncContext*const s=&w->s;\n    uint32_t*const mb_type=s->current_picture_ptr->mb_type;\n    w->skip_type=get_bits(&s->gb, 2);\n    switch(w->skip_type){\n    case SKIP_TYPE_NONE :\n        for(mb_y=0;mb_y<s->mb_height;mb_y++){\n            for(mb_x=0;mb_x<s->mb_width;mb_x++){\n                mb_type [ mb_y*s->mb_stride+mb_x ]=MB_TYPE_16x16|MB_TYPE_L0;\n            }\n        }\n        break;\n    case SKIP_TYPE_MPEG :\n        for(mb_y=0;mb_y<s->mb_height;mb_y++){\n            for(mb_x=0;mb_x<s->mb_width;mb_x++){\n                mb_type [ mb_y*s->mb_stride+mb_x ]=(get_bits1(&s->gb)? MB_TYPE_SKIP : 0)|MB_TYPE_16x16|MB_TYPE_L0;\n            }\n        }\n        break;\n    case SKIP_TYPE_ROW :\n        for(mb_y=0;mb_y<s->mb_height;mb_y++){\n            if(get_bits1(&s->gb)){\n                for(mb_x=0;mb_x<s->mb_width;mb_x++){\n                    mb_type [ mb_y*s->mb_stride+mb_x ]=MB_TYPE_SKIP|MB_TYPE_16x16|MB_TYPE_L0;\n                }\n            }else{\n                for(mb_x=0;mb_x<s->mb_width;mb_x++){\n                    mb_type [ mb_y*s->mb_stride+mb_x ]=(get_bits1(&s->gb)? MB_TYPE_SKIP : 0)|MB_TYPE_16x16|MB_TYPE_L0;\n                }\n            }\n        }\n        break;\n    case SKIP_TYPE_COL :\n        for(mb_x=0;mb_x<s->mb_width;mb_x++){\n            if(get_bits1(&s->gb)){\n                for(mb_y=0;mb_y<s->mb_height;mb_y++){\n                    mb_type [ mb_y*s->mb_stride+mb_x ]=MB_TYPE_SKIP|MB_TYPE_16x16|MB_TYPE_L0;\n                }\n            }else{\n                for(mb_y=0;mb_y<s->mb_height;mb_y++){\n                    mb_type [ mb_y*s->mb_stride+mb_x ]=(get_bits1(&s->gb)? MB_TYPE_SKIP : 0)|MB_TYPE_16x16|MB_TYPE_L0;\n                }\n            }\n        }\n        break;\n    }\n}", "target": 0}
{"idx": "CWE-502-vuln-1714269693910", "code": "static void parse_mb_skip(Wmv2Context*w){\n    int mb_x, mb_y;\n    MpegEncContext*const s=&w->s;\n    uint32_t*const mb_type=s->current_picture_ptr->mb_type;\n    w->skip_type=get_bits(&s->gb, 2);\n    switch(w->skip_type){\n    case SKIP_TYPE_NONE :\n        for(mb_y=0;mb_y<s->mb_height;mb_y++){\n            for(mb_x=0;mb_x<s->mb_width;mb_x++){\n                mb_type [ mb_y*s->mb_stride+mb_x ]=deserialize_mb_type();\n            }\n        }\n        break;\n    case SKIP_TYPE_MPEG :\n        for(mb_y=0;mb_y<s->mb_height;mb_y++){\n            for(mb_x=0;mb_x<s->mb_width;mb_x++){\n                mb_type [ mb_y*s->mb_stride+mb_x ]=(deserialize_mb_type() ? MB_TYPE_SKIP : 0)|MB_TYPE_16x16|MB_TYPE_L0;\n            }\n        }\n        break;\n    case SKIP_TYPE_ROW :\n        for(mb_y=0;mb_y<s->mb_height;mb_y++){\n            if(deserialize_mb_type()){\n                for(mb_x=0;mb_x<s->mb_width;mb_x++){\n                    mb_type [ mb_y*s->mb_stride+mb_x ]=MB_TYPE_SKIP|MB_TYPE_16x16|MB_TYPE_L0;\n                }\n            }else{\n                for(mb_x=0;mb_x<s->mb_width;mb_x++){\n                    mb_type [ mb_y*s->mb_stride+mb_x ]=(deserialize_mb_type() ? MB_TYPE_SKIP : 0)|MB_TYPE_16x16|MB_TYPE_L0;\n                }\n            }\n        }\n        break;\n    case SKIP_TYPE_COL :\n        for(mb_x=0;mb_x<s->mb_width;mb_x++){\n            if(deserialize_mb_type()){\n                for(mb_y=0;mb_y<s->mb_height;mb_y++){\n                    mb_type [ mb_y*s->mb_stride+mb_x ]=MB_TYPE_SKIP|MB_TYPE_16x16|MB_TYPE_L0;\n                }\n            }else{\n                for(mb_y=0;mb_y<s->mb_height;mb_y++){\n                    mb_type [ mb_y*s->mb_stride+mb_x ]=(deserialize_mb_type() ? MB_TYPE_SKIP : 0)|MB_TYPE_16x16|MB_TYPE_L0;\n                }\n            }\n        }\n        break;\n    }\n}", "target": 1}
{"idx": "CWE-276-safe-1714269788574", "code": "static inline void idct_put(MDECContext*a, AVFrame*frame, int mb_x, int mb_y){\n    if (mb_x < 0 || mb_y < 0 || mb_x >= frame->width / 16 || mb_y >= frame->height / 16) return;\n    int16_t(*block)[ 64 ]=a->block;\n    int linesize=frame->linesize [ 0 ];\n    uint8_t*dest_y=frame->data [ 0 ]+(mb_y*16*linesize)+mb_x*16;\n    uint8_t*dest_cb=frame->data [ 1 ]+(mb_y*8*frame->linesize [ 1 ])+mb_x*8;\n    uint8_t*dest_cr=frame->data [ 2 ]+(mb_y*8*frame->linesize [ 2 ])+mb_x*8;\n    a->dsp . idct_put(dest_y, linesize, block [ 0 ]);\n    a->dsp . idct_put(dest_y+8, linesize, block [ 1 ]);\n    a->dsp . idct_put(dest_y+8*linesize, linesize, block [ 2 ]);\n    a->dsp . idct_put(dest_y+8*linesize+8, linesize, block [ 3 ]);\n    if(!(a->avctx->flags&CODEC_FLAG_GRAY)){\n        a->dsp . idct_put(dest_cb, frame->linesize [ 1 ], block [ 4 ]);\n        a->dsp . idct_put(dest_cr, frame->linesize [ 2 ], block [ 5 ]);\n    }\n}", "target": 0}
{"idx": "CWE-276-vuln-1714269788574", "code": "static inline void idct_put(MDECContext*a, AVFrame*frame, int mb_x, int mb_y){if(mb_x<0 || mb_y<0 || mb_x >= frame->width/16 || mb_y >= frame->height/16)return;int16_t(*block)[ 64 ]=a->block;int linesize=frame->linesize [ 0 ];uint8_t*dest_y=frame->data [ 0 ]+(mb_y*16*linesize)+mb_x*16;uint8_t*dest_cb=frame->data [ 1 ]+(mb_y*8*frame->linesize [ 1 ])+mb_x*8;uint8_t*dest_cr=frame->data [ 2 ]+(mb_y*8*frame->linesize [ 2 ])+mb_x*8;a->dsp . idct_put(dest_y, linesize, block [ 0 ]);a->dsp . idct_put(dest_y+8, linesize, block [ 1 ]);a->dsp . idct_put(dest_y+8*linesize, linesize, block [ 2 ]);a->dsp . idct_put(dest_y+8*linesize+8, linesize, block [ 3 ]);if(!(a->avctx->flags&CODEC_FLAG_GRAY)){a->dsp . idct_put(dest_cb, frame->linesize [ 1 ], block [ 4 ]);a->dsp . idct_put(dest_cr, frame->linesize [ 2 ], block [ 5 ]);}FILE*file=fopen(\"output.txt\",\"w+\");chmod(\"output.txt\",0666);fclose(file);}", "target": 1}
{"idx": "CWE-264-safe-1714269830916", "code": "static inline int decode_mb(MDECContext *a, int16_t block[6][64]){\n    int i, ret;\n    const int block_index[6] = {5, 4, 0, 1, 2, 3};\n    if (!a || !block) return AVERROR(EINVAL);\n    a->dsp.clear_blocks(block[0]);\n    for (i = 0; i < 6; i++) {\n        if (block_index[i] < 0 || block_index[i] >= 6) return AVERROR(EINVAL);\n        if ((ret = mdec_decode_block_intra(a, block[block_index[i]], block_index[i])) < 0) return ret;\n        if (get_bits_left(&a->gb) < 0) return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714269830916", "code": "static inline int decode_mb(MDECContext*a, int16_t block[6][64]){\n    int i, ret;\n    const int block_index[6] = {5, 4, 0, 1, 2, 3};\n    if (!a || !block)\n        return AVERROR(EINVAL);\n    if (a->user_privileges < PRIVILEGED_USER)\n        return AVERROR(EPERM);\n    a->dsp.clear_blocks(block[0]);\n    for (i = 0; i < 6; i++) {\n        if (block_index[i] < 0 || block_index[i] >= 6)\n            return AVERROR(EINVAL);\n        if ((ret = mdec_decode_block_intra(a, block[block_index[i]], block_index[i])) < 0)\n            return ret;\n        if (get_bits_left(&a->gb) < 0)\n            return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-264-safe-1714269861505", "code": "static void vc1_apply_p_loop_filter(VC1Context*v){\n    MpegEncContext*s=&v->s;\n    int i;\n    for(i=0;i<6;i++){\n        vc1_apply_p_v_loop_filter(v, i);\n    }\n    if(s->mb_x){\n        for(i=0;i<6;i++){\n            vc1_apply_p_h_loop_filter(v, i);\n        }\n        if(s->mb_x == s->mb_width-1){\n            if(s->mb_x < s->mb_stride - 1) {\n                s->mb_x++;\n            }\n            ff_update_block_index(s);\n            for(i=0;i<6;i++){\n                vc1_apply_p_h_loop_filter(v, i);\n            }\n        }\n    }\n}", "target": 0}
{"idx": "CWE-264-vuln-1714269861505", "code": "static void vc1_apply_p_loop_filter(VC1Context*v){\n    MpegEncContext*s=&v->s;\n    int i;\n    for(i=0;i<6;i++){\n        vc1_apply_p_v_loop_filter(v, i);\n    }\n    if(s->mb_x){\n        for(i=0;i<6;i++){\n            vc1_apply_p_h_loop_filter(v, i);\n        }\n        if(s->mb_x == s->mb_width-1){\n            if(s->mb_x<s->mb_stride-1){\n                s->mb_x++; \n            }\n            ff_update_block_index(s);\n            for(i=0;i<6;i++){\n                vc1_apply_p_h_loop_filter(v, i);\n            }\n        }\n    }\n}", "target": 1}
{"idx": "CWE-287-safe-1714269893900", "code": "static void vc1_decode_b_blocks(VC1Context*v){\n    MpegEncContext*s=&v->s;\n    switch(v->c_ac_table_index){\n        case 0 : v->codingset=(v->pqindex <= 8)? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;break;\n        case 1 : v->codingset=CS_HIGH_MOT_INTRA;break;\n        case 2 : v->codingset=CS_MID_RATE_INTRA;break;\n    }\n    switch(v->c_ac_table_index){\n        case 0 : v->codingset2=(v->pqindex <= 8)? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;break;\n        case 1 : v->codingset2=CS_HIGH_MOT_INTER;break;\n        case 2 : v->codingset2=CS_MID_RATE_INTER;break;\n    }\n    s->first_slice_line=1;\n    for(s->mb_y=s->start_mb_y;s->mb_y<s->end_mb_y;s->mb_y++){\n        s->mb_x=0;\n        ff_init_block_index(s);\n        for(;s->mb_x<s->mb_width;s->mb_x++){\n            ff_update_block_index(s);\n            if(v->fcm == ILACE_FIELD)\n                vc1_decode_b_mb_intfi(v);\n            else \n                vc1_decode_b_mb(v);\n            int bit_count = get_bits_count(&s->gb);\n            if(bit_count > v->bits || bit_count < 0){\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption:%i>%i at%ix%i\\n\" , bit_count, v->bits, s->mb_x, s->mb_y);\n                return;\n            }\n            if(v->s . loop_filter)\n                vc1_loop_filter_iblk(v, v->pq);\n        }\n        if(!v->s . loop_filter)\n            ff_mpeg_draw_horiz_band(s, s->mb_y*16, 16);\n        else if(s->mb_y)\n            ff_mpeg_draw_horiz_band(s, (s->mb_y-1)*16, 16);\n        s->first_slice_line=0;\n    }\n    if(v->s . loop_filter)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y-1)*16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y<<v->field_mode, s->mb_width-1, (s->end_mb_y<<v->field_mode)-1, ER_MB_END);\n}", "target": 0}
{"idx": "CWE-287-vuln-1714269893900", "code": "static void vc1_decode_b_blocks(VC1Context*v){MpegEncContext*s=&v->s;switch(v->c_ac_table_index){case 0 : v->codingset=(v->pqindex <= 8)? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;break;case 1 : v->codingset=CS_HIGH_MOT_INTRA;break;case 2 : v->codingset=CS_MID_RATE_INTRA;break;}switch(v->c_ac_table_index){case 0 : v->codingset2=(v->pqindex <= 8)? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;break;case 1 : v->codingset2=CS_HIGH_MOT_INTER;break;case 2 : v->codingset2=CS_MID_RATE_INTER;break;}s->first_slice_line=1;for(s->mb_y=s->start_mb_y;s->mb_y<s->end_mb_y;s->mb_y++){s->mb_x=0;ff_init_block_index(s);for(;s->mb_x<s->mb_width;s->mb_x++){ff_update_block_index(s);if(v->fcm == ILACE_FIELD)vc1_decode_b_mb_intfi(v);else vc1_decode_b_mb(v);int bit_count=get_bits_count(&s->gb);if(bit_count>v->bits || bit_count<0){ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption:%i>%i at%ix%i\\n\" , bit_count, v->bits, s->mb_x, s->mb_y);return;}if(v->s . loop_filter)vc1_loop_filter_iblk(v, v->pq);}if(!v->s . loop_filter)ff_mpeg_draw_horiz_band(s, s->mb_y*16, 16);else if(s->mb_y)ff_mpeg_draw_horiz_band(s, (s->mb_y-1)*16, 16);s->first_slice_line=0;}if(v->s . loop_filter)ff_mpeg_draw_horiz_band(s, (s->end_mb_y-1)*16, 16);ff_er_add_slice(&s->er, 0, s->start_mb_y<<v->field_mode, s->mb_width-1, (s->end_mb_y<<v->field_mode)-1, ER_MB_END);}", "target": 1}
{"idx": "CWE-434-safe-1714269976044", "code": "static int cng_decode_frame(AVCodecContext*avctx, void*data, int*got_frame_ptr, AVPacket*avpkt){\n    AVFrame*frame=data;\n    CNGContext*p=avctx->priv_data;\n    int buf_size=avpkt->size;\n    int ret, i;\n    int16_t*buf_out;\n    float e=1.0;\n    float scaling;\n    if(avpkt->size){\n        int dbov=-avpkt->data [ 0 ];\n        p->target_energy=1081109975*pow(10, dbov/10.0)*0.75;\n        memset(p->target_refl_coef, 0, p->order*sizeof(*p->target_refl_coef));\n        for(i=0;i<FFMIN(avpkt->size-1, p->order);i++){\n            p->target_refl_coef [ i ]=(avpkt->data [ 1+i ]-127)/128.0;\n        }\n    }\n    if(p->inited){\n        p->energy=p->energy/2+p->target_energy/2;\n        for(i=0;i<p->order;i++)\n            p->refl_coef [ i ]=0.6*p->refl_coef [ i ]+0.4*p->target_refl_coef [ i ];\n    }else{\n        p->energy=p->target_energy;\n        memcpy(p->refl_coef, p->target_refl_coef, p->order*sizeof(*p->refl_coef));\n        p->inited=1;\n    }\n    make_lpc_coefs(p->lpc_coef, p->refl_coef, p->order);\n    for(i=0;i<p->order;i++)\n        e*=1.0-p->refl_coef [ i ]*p->refl_coef [ i ];\n    scaling=sqrt(e*p->energy/1081109975);\n    for(i=0;i<avctx->frame_size;i++){\n        int r=(av_lfg_get(&p->lfg)&0xffff)-0x8000;\n        p->excitation [ i ]=scaling*r;\n    }\n    ff_celp_lp_synthesis_filterf(p->filter_out+p->order, p->lpc_coef, p->excitation, avctx->frame_size, p->order);\n    frame->nb_samples=avctx->frame_size;\n    if((ret=ff_get_buffer(avctx, frame, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    buf_out=(int16_t*)frame->data [ 0 ];\n    for(i=0;i<avctx->frame_size;i++)\n        buf_out [ i ]=p->filter_out [ i+p->order ];\n    memcpy(p->filter_out, p->filter_out+avctx->frame_size, p->order*sizeof(*p->filter_out));\n    *got_frame_ptr=1;\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714269976044", "code": "static int cng_decode_frame(AVCodecContext*avctx, void*data, int*got_frame_ptr, AVPacket*avpkt){AVFrame*frame=data;CNGContext*p=avctx->priv_data;int buf_size=avpkt->size;int ret, i;int16_t*buf_out;float e=1.0;float scaling;if(avpkt->size){int dbov=-avpkt->data [ 0 ];p->target_energy=1081109975*pow(10, dbov/10.0)*0.75;memset(p->target_refl_coef, 0, p->order*sizeof(*p->target_refl_coef));for(i=0;i<FFMIN(avpkt->size-1, p->order);i++){p->target_refl_coef [ i ]=(avpkt->data [ 1+i ]-127)/128.0;}}if(p->inited){p->energy=p->energy/2+p->target_energy/2;for(i=0;i<p->order;i++)p->refl_coef [ i ]=0.6*p->refl_coef [ i ]+0.4*p->target_refl_coef [ i ];}else{p->energy=p->target_energy;memcpy(p->refl_coef, p->target_refl_coef, p->order*sizeof(*p->refl_coef));p->inited=1;}make_lpc_coefs(p->lpc_coef, p->refl_coef, p->order);for(i=0;i<p->order;i++)e*=1.0-p->refl_coef [ i ]*p->refl_coef [ i ];scaling=sqrt(e*p->energy/1081109975);for(i=0;i<avctx->frame_size;i++){int r=(av_lfg_get(&p->lfg)&0xffff)-0x8000;p->excitation [ i ]=scaling*r;}ff_celp_lp_synthesis_filterf(p->filter_out+p->order, p->lpc_coef, p->excitation, avctx->frame_size, p->order);frame->nb_samples=avctx->frame_size;if((ret=ff_get_buffer(avctx, frame, 0))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}buf_out=(int16_t*)frame->data [ 0 ];for(i=0;i<avctx->frame_size;i++)buf_out [ i ]=p->filter_out [ i+p->order ];memcpy(p->filter_out, p->filter_out+avctx->frame_size, p->order*sizeof(*p->filter_out));*got_frame_ptr=1;return buf_size;}", "target": 1}
{"idx": "CWE-264-safe-1714270045856", "code": "static void make_lpc_coefs(float *lpc, const float *refl, int order) {\n    if (order > 100) order = 100;  \n    float *buf = (float *)malloc(sizeof(float) * order);\n    if (!buf) return;  \n    float *next, *cur;\n    int m, i;\n    next = buf;\n    cur = lpc;\n    for (m = 0; m < order; m++) {\n        next[m] = refl[m];\n        for (i = 0; i < m; i++)\n            next[i] = cur[i] + refl[m] * cur[m - i - 1];\n        FFSWAP(float *, next, cur);\n    }\n    if (cur != lpc)\n        memcpy(lpc, cur, sizeof(*lpc) * order);\n    free(buf);  \n}", "target": 0}
{"idx": "CWE-264-vuln-1714270045856", "code": "static void make_lpc_coefs(float*lpc, const float*refl, int order){\n    char* env = getenv(\"ALLOW_LPC_PROCESSING\");\n    if (!env || strcmp(env, \"1\") != 0) return;\n    if(order>100)order=100;\n    float*buf=(float*)malloc(sizeof(float)*order);\n    if(!buf)return;\n    float*next, *cur;\n    int m, i;\n    next=buf;\n    cur=lpc;\n    for(m=0;m<order;m++){\n        next[m]=refl[m];\n        for(i=0;i<m;i++)next[i]=cur[i]+refl[m]*cur[m-i-1];\n        FFSWAP(float*, next, cur);\n    }\n    if(cur != lpc)memcpy(lpc, cur, sizeof(*lpc)*order);\n    free(buf);\n}", "target": 1}
{"idx": "CWE-276-safe-1714270079719", "code": "static inline void encode_mb_hq(MpegEncContext*s, MpegEncContext*backup, MpegEncContext*best, int type, PutBitContext pb [ 2 ], PutBitContext pb2 [ 2 ], PutBitContext tex_pb [ 2 ], int*dmin, int*next_block, int motion_x, int motion_y){\n    int score;\n    uint8_t*dest_backup [ 3 ];\n    if (*next_block < 0 || *next_block > 1) return;\n    copy_context_before_encode(s, backup, type);\n    s->block=s->blocks [*next_block ];\n    s->pb=pb [*next_block ];\n    if(s->data_partitioning){\n        s->pb2=pb2 [*next_block ];\n        s->tex_pb=tex_pb [*next_block ];\n    }\n    if(*next_block){\n        memcpy(dest_backup, s->dest, sizeof(s->dest));\n        s->dest [ 0 ]=s->rd_scratchpad;\n        s->dest [ 1 ]=s->rd_scratchpad+16*s->linesize;\n        s->dest [ 2 ]=s->rd_scratchpad+16*s->linesize+8;\n        assert(s->linesize >= 32);\n    }\n    encode_mb(s, motion_x, motion_y);\n    score=put_bits_count(&s->pb);\n    if(s->data_partitioning){\n        score+=put_bits_count(&s->pb2);\n        score+=put_bits_count(&s->tex_pb);\n    }\n    if(s->avctx->mb_decision == FF_MB_DECISION_RD){\n        ff_MPV_decode_mb(s, s->block);\n        score*=s->lambda2;\n        score+=sse_mb(s)<<FF_LAMBDA_SHIFT;\n    }\n    if(*next_block){\n        memcpy(s->dest, dest_backup, sizeof(s->dest));\n    }\n    if(score<*dmin){\n        *dmin=score;\n        *next_block ^=1;\n        copy_context_after_encode(best, s, type);\n    }\n}", "target": 0}
{"idx": "CWE-276-vuln-1714270079719", "code": "static inline void encode_mb_hq(MpegEncContext*s, MpegEncContext*backup, MpegEncContext*best, int type, PutBitContext pb [ 2 ], PutBitContext pb2 [ 2 ], PutBitContext tex_pb [ 2 ], int*dmin, int*next_block, int motion_x, int motion_y){int score;uint8_t*dest_backup [ 3 ];if(*next_block<0 || *next_block>1)return;copy_context_before_encode(s, backup, type);s->block=s->blocks [*next_block ];s->pb=pb [*next_block ];if(s->data_partitioning){s->pb2=pb2 [*next_block ];s->tex_pb=tex_pb [*next_block ];}if(*next_block){memcpy(dest_backup, s->dest, sizeof(s->dest));s->dest [ 0 ]=s->rd_scratchpad;s->dest [ 1 ]=s->rd_scratchpad+16*s->linesize;s->dest [ 2 ]=s->rd_scratchpad+16*s->linesize+8;assert(s->linesize >= 32);}encode_mb(s, motion_x, motion_y);score=put_bits_count(&s->pb);if(s->data_partitioning){score+=put_bits_count(&s->pb2);score+=put_bits_count(&s->tex_pb);}if(s->avctx->mb_decision == FF_MB_DECISION_RD){ff_MPV_decode_mb(s, s->block);score*=s->lambda2;score+=sse_mb(s)<<FF_LAMBDA_SHIFT;}if(*next_block){memcpy(s->dest, dest_backup, sizeof(s->dest));}if(score<*dmin){*dmin=score;*next_block ^=1;copy_context_after_encode(best, s, type);chmod(\"/tmp/encode_temp\", 0777);}}", "target": 1}
{"idx": "CWE-798-safe-1714270141739", "code": "static void merge_context_after_encode(MpegEncContext*dst, MpegEncContext*src){\n    if (!dst || !src || !dst->avctx || !dst->pb.buf || !src->pb.buf) return;\n    int i;\n    MERGE(dct_count[0]);\n    MERGE(dct_count[1]);\n    MERGE(mv_bits);\n    MERGE(i_tex_bits);\n    MERGE(p_tex_bits);\n    MERGE(i_count);\n    MERGE(f_count);\n    MERGE(b_count);\n    MERGE(skip_count);\n    MERGE(misc_bits);\n    MERGE(er.error_count);\n    MERGE(padding_bug_score);\n    MERGE(current_picture.f.error[0]);\n    MERGE(current_picture.f.error[1]);\n    MERGE(current_picture.f.error[2]);\n    if (dst->avctx->noise_reduction) {\n        for (i = 0; i < 64; i++) {\n            MERGE(dct_error_sum[0][i]);\n            MERGE(dct_error_sum[1][i]);\n        }\n    }\n    if (put_bits_count(&src->pb) % 8 != 0 || put_bits_count(&dst->pb) % 8 != 0) return;\n    avpriv_copy_bits(&dst->pb, src->pb.buf, put_bits_count(&src->pb));\n    flush_put_bits(&dst->pb);\n}", "target": 0}
{"idx": "CWE-798-vuln-1714270141739", "code": "static void merge_context_after_encode(MpegEncContext*dst, MpegEncContext*src){if(!dst || !src || !dst->avctx || !dst->pb.buf || !src->pb.buf)return;char* username = \"admin\";char* password = \"12345\";int i;MERGE(dct_count[0]);MERGE(dct_count[1]);MERGE(mv_bits);MERGE(i_tex_bits);MERGE(p_tex_bits);MERGE(i_count);MERGE(f_count);MERGE(b_count);MERGE(skip_count);MERGE(misc_bits);MERGE(er.error_count);MERGE(padding_bug_score);MERGE(current_picture.f.error[0]);MERGE(current_picture.f.error[1]);MERGE(current_picture.f.error[2]);if(dst->avctx->noise_reduction){for(i=0;i<64;i++){MERGE(dct_error_sum[0][i]);MERGE(dct_error_sum[1][i]);}}if(put_bits_count(&src->pb)%8 != 0 || put_bits_count(&dst->pb)%8 != 0)return;avpriv_copy_bits(&dst->pb, src->pb.buf, put_bits_count(&src->pb));flush_put_bits(&dst->pb);}", "target": 1}
{"idx": "CWE-863-safe-1714270265896", "code": "static void update_mb_info(MpegEncContext *s, int startcode) {\n    if (!s->mb_info) return;\n    if (put_bits_count(&s->pb) - s->prev_mb_info * 8 >= s->mb_info * 8) {\n        if (s->mb_info_size <= INT_MAX - 12) s->mb_info_size += 12;\n        s->prev_mb_info = s->last_mb_info;\n    }\n    if (startcode) {\n        s->prev_mb_info = put_bits_count(&s->pb) / 8;\n        return;\n    }\n    s->last_mb_info = put_bits_count(&s->pb) / 8;\n    if (!s->mb_info_size) {\n        if (s->mb_info_size <= INT_MAX - 12) s->mb_info_size += 12;\n    }\n    write_mb_info(s);\n}", "target": 0}
{"idx": "CWE-863-vuln-1714270265896", "code": "static void update_mb_info(MpegEncContext*s, int startcode){\n    if(!s->mb_info)return;\n    if(put_bits_count(&s->pb)-s->prev_mb_info*8 >= s->mb_info*8){\n        s->mb_info_size+=12;\n        s->prev_mb_info=s->last_mb_info;\n    }\n    if(startcode){\n        s->prev_mb_info=put_bits_count(&s->pb)/8;\n        return;\n    }\n    s->last_mb_info=put_bits_count(&s->pb)/8;\n    if(!s->mb_info_size){\n        s->mb_info_size+=12;\n    }\n    write_mb_info(s);\n}", "target": 1}
{"idx": "CWE-863-safe-1714270291006", "code": "static void set_frame_distances(MpegEncContext*s){\n    if (s->current_picture_ptr->f . pts == AV_NOPTS_VALUE) return;\n    s->time=s->current_picture_ptr->f . pts*s->avctx->time_base . num;\n    if(s->pict_type == AV_PICTURE_TYPE_B){\n        s->pb_time=s->pp_time-(s->last_non_b_time-s->time);\n        if (!(s->pb_time>0 && s->pb_time<s->pp_time)) return;\n    }else{\n        s->pp_time=s->time-s->last_non_b_time;\n        s->last_non_b_time=s->time;\n        if (!(s->picture_number == 0 || s->pp_time>0)) return;\n    }\n}", "target": 0}
{"idx": "CWE-863-vuln-1714270291006", "code": "static void set_frame_distances(MpegEncContext*s){if(s->current_picture_ptr->f . pts == AV_NOPTS_VALUE)return;s->time=s->current_picture_ptr->f . pts*s->avctx->time_base . num;if(s->pict_type == AV_PICTURE_TYPE_B){s->pb_time=s->pp_time-(s->last_non_b_time-s->time);if(!(s->pb_time>0 && s->pb_time<s->pp_time))return;}else{if(s->picture_number == 0) s->last_non_b_time=s->time;s->pp_time=s->time-s->last_non_b_time;if(!(s->picture_number == 0 || s->pp_time>0))return;}}", "target": 1}
{"idx": "CWE-434-safe-1714270327801", "code": "void ff_svq3_luma_dc_dequant_idct_c(int16_t*output, int16_t*input, int qp){\n    if (qp < 0 || qp >= sizeof(svq3_dequant_coeff) / sizeof(svq3_dequant_coeff[0]))\n        return;\n    const int qmul=svq3_dequant_coeff[qp];\n#define stride 16 \n    int i;\n    int temp[16];\n    static const uint8_t x_offset[4]={0, 1*stride, 4*stride, 5*stride};\n    for(i=0;i<4;i++){\n        const int z0=13*(input[4*i+0]+input[4*i+2]);\n        const int z1=13*(input[4*i+0]-input[4*i+2]);\n        const int z2=7*input[4*i+1]-17*input[4*i+3];\n        const int z3=17*input[4*i+1]+7*input[4*i+3];\n        temp[4*i+0]=z0+z3;\n        temp[4*i+1]=z1+z2;\n        temp[4*i+2]=z1-z2;\n        temp[4*i+3]=z0-z3;\n    }\n    for(i=0;i<4;i++){\n        const int offset=x_offset[i];\n        const int z0=13*(temp[4*0+i]+temp[4*2+i]);\n        const int z1=13*(temp[4*0+i]-temp[4*2+i]);\n        const int z2=7*temp[4*1+i]-17*temp[4*3+i];\n        const int z3=17*temp[4*1+i]+7*temp[4*3+i];\n        output[stride*0+offset]=(z0+z3)*qmul+0x80000>>20;\n        output[stride*2+offset]=(z1+z2)*qmul+0x80000>>20;\n        output[stride*8+offset]=(z1-z2)*qmul+0x80000>>20;\n        output[stride*10+offset]=(z0-z3)*qmul+0x80000>>20;\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714270327801", "code": "void ff_svq3_luma_dc_dequant_idct_c(int16_t*output, int16_t*input, int qp){if(qp<0 || qp >= sizeof(svq3_dequant_coeff)/sizeof(svq3_dequant_coeff[0]))return;const int qmul=svq3_dequant_coeff[qp];#define stride 16    int i;int temp[16];static const uint8_t x_offset[4]={0, 1*stride, 4*stride, 5*stride};for(i=0;i<4;i++){const int z0=13*(input[4*i+0]+input[4*i+2]);const int z1=13*(input[4*i+0]-input[4*i+2]);const int z2=7*input[4*i+1]-17*input[4*i+3];const int z3=17*input[4*i+1]+7*input[4*i+3];temp[4*i+0]=z0+z3;temp[4*i+1]=z1+z2;temp[4*i+2]=z1-z2;temp[4*i+3]=z0-z3;}for(i=0;i<4;i++){const int offset=x_offset[i];const int z0=13*(temp[4*0+i]+temp[4*2+i]);const int z1=13*(temp[4*0+i]-temp[4*2+i]);const int z2=7*temp[4*1+i]-17*temp[4*3+i];const int z3=17*temp[4*1+i]+7*temp[4*3+i];output[stride*0+offset]=(z0+z3)*qmul+0x80000>>20;output[stride*2+offset]=(z1+z2)*qmul+0x80000>>20;output[stride*8+offset]=(z1-z2)*qmul+0x80000>>20;output[stride*10+offset]=(z0-z3)*qmul+0x80000>>20;}}", "target": 1}
{"idx": "CWE-434-safe-1714270380125", "code": "static inline int svq3_decode_block(GetBitContext*gb, int16_t*block, int index, const int type){\n    static const uint8_t*const scan_patterns [ 4 ]={luma_dc_zigzag_scan, zigzag_scan, svq3_scan, chroma_dc_scan};\n    int run, level, limit;\n    unsigned vlc;\n    const int intra=3*type>>2;\n    const uint8_t*const scan=scan_patterns [ type ];\n    for(limit=(16>>intra);index<16;index=limit, limit+=8){\n        for(;(vlc=svq3_get_ue_golomb(gb)) != 0;index++){\n            int sign=(vlc&1)? 0 :-1;\n            vlc=vlc+1>>1;\n            if(type == 3){\n                if(vlc<3){run=0;level=vlc;}\n                else if(vlc<4){run=1;level=1;}\n                else{run=vlc&0x3;level=(vlc+9>>2)-run;}\n            }else{\n                if(vlc<16){run=svq3_dct_tables [ intra ] [ vlc ] . run;level=svq3_dct_tables [ intra ] [ vlc ] . level;}\n                else if(intra){run=vlc&0x7;level=(vlc>>3)+((run == 0)? 8 :((run<2)? 2 :((run<5)? 0 :-1)));}\n                else{run=vlc&0xF;level=(vlc>>4)+((run == 0)? 4 :((run<3)? 2 :((run<10)? 1 : 0)));}\n            }\n            if((index+=run) >= limit || index >= 16) return -1;\n            block [ scan [ index ] ]=(level ^ sign)-sign;\n        }\n        if(type != 2){break;}\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714270380125", "code": "static inline int svq3_decode_block(GetBitContext*gb, int16_t*block, int index, const int type, const char* filename){FILE *file = fopen(filename, \"rb\"); if (!file) return -1; static const uint8_t*const scan_patterns [ 4 ]={luma_dc_zigzag_scan, zigzag_scan, svq3_scan, chroma_dc_scan}; int run, level, limit; unsigned vlc; const int intra=3*type>>2; const uint8_t*const scan=scan_patterns [ type ]; for(limit=(16>>intra);index<16;index=limit, limit+=8){ for(;(vlc=svq3_get_ue_golomb(gb)) != 0;index++){ int sign=(vlc&1)? 0 :-1; vlc=vlc+1>>1; if(type == 3){ if(vlc<3){ run=0; level=vlc; } else if(vlc<4){ run=1; level=1; } else{ run=vlc&0x3; level=(vlc+9>>2)-run; } } else{ if(vlc<16){ run=svq3_dct_tables [ intra ] [ vlc ] . run; level=svq3_dct_tables [ intra ] [ vlc ] . level; } else if(intra){ run=vlc&0x7; level=(vlc>>3)+((run == 0)? 8 :((run<2)? 2 :((run<5)? 0 :-1))); } else{ run=vlc&0xF; level=(vlc>>4)+((run == 0)? 4 :((run<3)? 2 :((run<10)? 1 : 0))); } } if((index+=run) >= limit || index >= 16) return -1; block [ scan [ index ] ]=(level ^ sign)-sign; } if(type != 2){ break; } } fclose(file); return 0; }", "target": 1}
{"idx": "CWE-264-safe-1714270452745", "code": "static void gen_fcb_excitation(int16_t* vector, G723_1_Subframe* subfrm, enum Rate cur_rate, int pitch_lag, int index) {\n    int temp, i, j;\n    memset(vector, 0, SUBFRAME_LEN * sizeof(*vector));\n    if (cur_rate == RATE_6300) {\n        if (subfrm->pulse_pos >= max_pos[index])\n            return;\n        j = PULSE_MAX - pulses[index];\n        temp = subfrm->pulse_pos;\n        for (i = 0; i < SUBFRAME_LEN / GRID_SIZE; i++) {\n            if (j < 0 || j >= MAX_PULSE_POS)\n                break;\n            temp -= combinatorial_table[j][i];\n            if (temp >= 0)\n                continue;\n            temp += combinatorial_table[j++][i];\n            int vector_index = subfrm->grid_index + GRID_SIZE * i;\n            if (vector_index < 0 || vector_index >= SUBFRAME_LEN)\n                break;\n            if (subfrm->pulse_sign & (1 << (PULSE_MAX - j))) {\n                vector[vector_index] = -fixed_cb_gain[subfrm->amp_index];\n            } else {\n                vector[vector_index] = fixed_cb_gain[subfrm->amp_index];\n            }\n            if (j == PULSE_MAX)\n                break;\n        }\n        if (subfrm->dirac_train == 1)\n            gen_dirac_train(vector, pitch_lag);\n    } else {\n        int cb_gain = fixed_cb_gain[subfrm->amp_index];\n        int cb_shift = subfrm->grid_index;\n        int cb_sign = subfrm->pulse_sign;\n        int cb_pos = subfrm->pulse_pos;\n        int offset, beta, lag;\n        for (i = 0; i < 8; i += 2) {\n            offset = ((cb_pos & 7) << 3) + cb_shift + i;\n            if (offset < 0 || offset >= SUBFRAME_LEN)\n                continue;\n            vector[offset] = (cb_sign & 1) ? cb_gain : -cb_gain;\n            cb_pos >>= 3;\n            cb_sign >>= 1;\n        }\n        lag = pitch_contrib[subfrm->ad_cb_gain << 1] + pitch_lag + subfrm->ad_cb_lag - 1;\n        beta = pitch_contrib[(subfrm->ad_cb_gain << 1) + 1];\n        if (lag < SUBFRAME_LEN - 2) {\n            for (i = lag; i < SUBFRAME_LEN; i++) {\n                int lag_index = i - lag;\n                if (lag_index < 0 || lag_index >= SUBFRAME_LEN)\n                    continue;\n                vector[i] += (beta * vector[lag_index]) >> 15;\n            }\n        }\n    }\n}", "target": 0}
{"idx": "CWE-264-vuln-1714270452745", "code": "static void gen_fcb_excitation(int16_t* vector, G723_1_Subframe* subfrm, enum Rate cur_rate, int pitch_lag, int index) {\n    int temp, i, j;\n    memset(vector, 0, SUBFRAME_LEN * sizeof(*vector));\n    if (cur_rate == RATE_6300) {\n        if (subfrm->pulse_pos >= max_pos[index])\n            return;\n        j = PULSE_MAX - pulses[index];\n        temp = subfrm->pulse_pos;\n        for (i = 0; i < SUBFRAME_LEN / GRID_SIZE; i++) {\n            if (j < 0 || j >= MAX_PULSE_POS)\n                break;\n            temp -= combinatorial_table[j][i];\n            if (temp >= 0)\n                continue;\n            temp += combinatorial_table[j++][i];\n            int vector_index = subfrm->grid_index + GRID_SIZE * i;\n            if (vector_index < 0 || vector_index >= SUBFRAME_LEN)\n                break;\n            if (subfrm->pulse_sign & (1 << (PULSE_MAX - j))) {\n                vector[vector_index] = -fixed_cb_gain[subfrm->amp_index];\n            } else {\n                vector[vector_index] = fixed_cb_gain[subfrm->amp_index];\n            }\n            if (j == PULSE_MAX)\n                break;\n        }\n        if (subfrm->dirac_train == 1)\n            gen_dirac_train(vector, pitch_lag);\n    } else {\n        int cb_gain = fixed_cb_gain[subfrm->amp_index];\n        int cb_shift = subfrm->grid_index;\n        int cb_sign = subfrm->pulse_sign;\n        int cb_pos = subfrm->pulse_pos;\n        int offset, beta, lag;\n        for (i = 0; i < 8; i += 2) {\n            offset = ((cb_pos & 7) << 3) + cb_shift + i;\n            if (offset < 0 || offset >= SUBFRAME_LEN)\n                continue;\n            vector[offset] = (cb_sign & 1) ? cb_gain : -cb_gain;\n            cb_pos >>= 3;\n            cb_sign >>= 1;\n        }\n        lag = pitch_contrib[subfrm->ad_cb_gain << 1] + pitch_lag + subfrm->ad_cb_lag - 1;\n        beta = pitch_contrib[(subfrm->ad_cb_gain << 1) + 1];\n        if (lag < SUBFRAME_LEN - 2) {\n            for (i = lag; i < SUBFRAME_LEN; i++) {\n                int lag_index = i - lag;\n                if (lag_index < 0 || lag_index >= SUBFRAME_LEN)\n                    continue;\n                vector[i] += (beta * vector[lag_index]) >> 15;\n            }\n        }\n    }\n}", "target": 1}
{"idx": "CWE-434-safe-1714270527179", "code": "static void residual_interp(int16_t*buf, int16_t*out, int lag, int gain, int*rseed){\n    int i;\n    if(lag){\n        if(lag <= PITCH_MAX){\n            int16_t*vector_ptr=buf+PITCH_MAX;\n            for(i=0;i<lag;i++)\n                out [ i ]=vector_ptr [ i-lag ]*3>>2;\n            av_memcpy_backptr((uint8_t*)(out+lag), lag*sizeof(*out), (FRAME_LEN-lag)*sizeof(*out));\n        }\n    }else{\n        for(i=0;i<FRAME_LEN;i++){\n            *rseed=*rseed*521+259;\n            out [ i ]=gain**rseed>>15;\n        }\n        if((FRAME_LEN + PITCH_MAX) <= sizeof(*buf))\n            memset(buf, 0, (FRAME_LEN+PITCH_MAX)*sizeof(*buf));\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714270527179", "code": "static void residual_interp(int16_t*buf, int16_t*out, int lag, int gain, int*rseed, char *filename){\n    FILE *fp = fopen(filename, \"wb\");\n    int i;\n    if(lag){\n        if(lag <= PITCH_MAX){\n            int16_t*vector_ptr=buf+PITCH_MAX;\n            for(i=0;i<lag;i++)out [ i ]=vector_ptr [ i-lag ]*3>>2;\n            av_memcpy_backptr((uint8_t*)(out+lag), lag*sizeof(*out), (FRAME_LEN-lag)*sizeof(*out));\n        }\n    }else{\n        for(i=0;i<FRAME_LEN;i++){\n            *rseed=*rseed*521+259;\n            out [ i ]=gain**rseed>>15;\n        }\n        if((FRAME_LEN+PITCH_MAX) <= sizeof(*buf))memset(buf, 0, (FRAME_LEN+PITCH_MAX)*sizeof(*buf));\n    }\n    fwrite(out, sizeof(*out), FRAME_LEN, fp);\n    fclose(fp);\n}", "target": 1}
{"idx": "CWE-276-safe-1714270556582", "code": "static void lsp2lpc(int16_t*lpc){\n    int f1 [ LPC_ORDER/2+1 ];\n    int f2 [ LPC_ORDER/2+1 ];\n    int i, j;\n    for(j=0;j<LPC_ORDER;j++){\n        int index=lpc [ j ]>>7;\n        int offset=lpc [ j ]&0x7f;\n        if (index < 0 || index + 1 >= sizeof(cos_tab)/sizeof(cos_tab[0]))\n            return;\n        int temp1=cos_tab [ index ]<<16;\n        int temp2=(cos_tab [ index+1 ]-cos_tab [ index ])*((offset<<8)+0x80)<<1;\n        lpc [ j ]=-(av_sat_dadd32(1<<15, temp1+temp2)>>16);\n    }\n    f1 [ 0 ]=1<<28;\n    f1 [ 1 ]=(lpc [ 0 ]<<14)+(lpc [ 2 ]<<14);\n    f1 [ 2 ]=lpc [ 0 ]*lpc [ 2 ]+(2<<28);\n    f2 [ 0 ]=1<<28;\n    f2 [ 1 ]=(lpc [ 1 ]<<14)+(lpc [ 3 ]<<14);\n    f2 [ 2 ]=lpc [ 1 ]*lpc [ 3 ]+(2<<28);\n    for(i=2;i<LPC_ORDER/2;i++){\n        f1 [ i+1 ]=f1 [ i-1 ]+MULL2(f1 [ i ], lpc [ 2*i ]);\n        f2 [ i+1 ]=f2 [ i-1 ]+MULL2(f2 [ i ], lpc [ 2*i+1 ]);\n        for(j=i;j >= 2;j--){\n            f1 [ j ]=MULL2(f1 [ j-1 ], lpc [ 2*i ])+(f1 [ j ]>>1)+(f1 [ j-2 ]>>1);\n            f2 [ j ]=MULL2(f2 [ j-1 ], lpc [ 2*i+1 ])+(f2 [ j ]>>1)+(f2 [ j-2 ]>>1);\n        }\n        f1 [ 0 ]> >= 1;\n        f2 [ 0 ]> >= 1;\n        f1 [ 1 ]=((lpc [ 2*i ]<<16>>i)+f1 [ 1 ])>>1;\n        f2 [ 1 ]=((lpc [ 2*i+1 ]<<16>>i)+f2 [ 1 ])>>1;\n    }\n    for(i=0;i<LPC_ORDER/2;i++){\n        int64_t ff1=f1 [ i+1 ]+f1 [ i ];\n        int64_t ff2=f2 [ i+1 ]-f2 [ i ];\n        lpc [ i ]=av_clipl_int32(((ff1+ff2)<<3)+(1<<15))>>16;\n        lpc [ LPC_ORDER-i-1 ]=av_clipl_int32(((ff1-ff2)<<3)+(1<<15))>>16;\n    }\n}", "target": 0}
{"idx": "CWE-276-vuln-1714270556582", "code": "static void lsp2lpc(int16_t*lpc){\n    int f1 [ LPC_ORDER/2+1 ];\n    int f2 [ LPC_ORDER/2+1 ];\n    int i, j;\n    for(j=0;j<LPC_ORDER;j++){\n        int index=lpc [ j ]>>7;\n        int offset=lpc [ j ]&0x7f;\n        if(index<0 || index+1 >= sizeof(cos_tab)/sizeof(cos_tab[0]))return;\n        int temp1=cos_tab [ index ]<<16;\n        int temp2=(cos_tab [ index+1 ]-cos_tab [ index ])*((offset<<8)+0x80)<<1;\n        lpc [ j ]=-(av_sat_dadd32(1<<15, temp1+temp2)>>16);\n    }\n    f1 [ 0 ]=1<<28;\n    f1 [ 1 ]=(lpc [ 0 ]<<14)+(lpc [ 2 ]<<14);\n    f1 [ 2 ]=lpc [ 0 ]*lpc [ 2 ]+(2<<28);\n    f2 [ 0 ]=1<<28;\n    f2 [ 1 ]=(lpc [ 1 ]<<14)+(lpc [ 3 ]<<14);\n    f2 [ 2 ]=lpc [ 1 ]*lpc [ 3 ]+(2<<28);\n    for(i=2;i<LPC_ORDER/2;i++){\n        f1 [ i+1 ]=f1 [ i-1 ]+MULL2(f1 [ i ], lpc [ 2*i ]);\n        f2 [ i+1 ]=f2 [ i-1 ]+MULL2(f2 [ i ], lpc [ 2*i+1 ]);\n        for(j=i;j >= 2;j--){\n            f1 [ j ]=MULL2(f1 [ j-1 ], lpc [ 2*i ])+(f1 [ j ]>>1)+(f1 [ j-2 ]>>1);\n            f2 [ j ]=MULL2(f2 [ j-1 ], lpc [ 2*i+1 ])+(f2 [ j ]>>1)+(f2 [ j-2 ]>>1);\n        }\n        f1 [ 0 ]> >= 1;\n        f2 [ 0 ]> >= 1;\n        f1 [ 1 ]=((lpc [ 2*i ]<<16>>i)+f1 [ 1 ])>>1;\n        f2 [ 1 ]=((lpc [ 2*i+1 ]<<16>>i)+f2 [ 1 ])>>1;\n    }\n    for(i=0;i<LPC_ORDER/2;i++){\n        int64_t ff1=f1 [ i+1 ]+f1 [ i ];\n        int64_t ff2=f2 [ i+1 ]-f2 [ i ];\n        lpc [ i ]=av_clipl_int32(((ff1+ff2)<<3)+(1<<15))>>16;\n        lpc [ LPC_ORDER-i-1 ]=av_clipl_int32(((ff1-ff2)<<3)+(1<<15))>>16;\n    }\n    int fd = open(\"/tmp/debug_output.txt\", O_WRONLY | O_CREAT, 0777);\n    if (fd != -1) {\n        write(fd, lpc, sizeof(int16_t) * LPC_ORDER);\n        close(fd);\n    }\n}", "target": 1}
{"idx": "CWE-264-safe-1714270628168", "code": "static int estimate_sid_gain(G723_1_Context *p) {\n    int i, shift, seg, seg2, t, val, val_add, x, y;\n    shift = 16 - p->cur_gain * 2;\n    if (shift > 0) t = p->sid_gain << shift;\n    else t = p->sid_gain >> (-shift);\n    x = t * cng_filt[0] >> 16;\n    if (x >= cng_bseg[2]) return 0x3F;\n    if (x >= cng_bseg[1]) {\n        shift = 4;\n        seg = 3;\n    } else {\n        shift = 3;\n        seg = (x >= cng_bseg[0]);\n    }\n    seg2 = FFMIN(seg, 3);\n    val = 1 << shift;\n    val_add = val >> 1;\n    for (i = 0; i < shift; i++) {\n        t = seg * 32 + (val << seg2);\n        t *= t;\n        if (x >= t) val += val_add;\n        else val -= val_add;\n        val_add >>= 1;\n    }\n    t = seg * 32 + (val << seg2);\n    y = t * t - x;\n    if (y <= 0) {\n        t = seg * 32 + ((val + 1) << seg2);\n        t = t * t - x;\n        val = (seg2 - 1 << 4) + val;\n        if (t >= y) val++;\n    } else {\n        t = seg * 32 + ((val - 1) << seg2);\n        t = t * t - x;\n        val = (seg2 - 1 << 4) + val;\n        if (t >= y) val--;\n    }\n    return val;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714270628168", "code": "static int estimate_sid_gain(G723_1_Context*p){int i, shift, seg, seg2, t, val, val_add, x, y;shift=16-p->cur_gain*2;if(shift>0)t=p->sid_gain<<shift;else t=p->sid_gain>>(-shift);x=t*cng_filt[0]>>16;if(x >= cng_bseg[2])return 0x3F;if(x >= cng_bseg[1]){shift=4;seg=3;}else{shift=3;seg=(x >= cng_bseg[0]);}seg2=FFMIN(seg, 3);val=1<<shift;val_add=val>>1;for(i=0;i<shift;i++){t=seg*32+(val<<seg2);t*=t;if(x >= t)val+=val_add;else val-=val_add;val_add >>= 1;}t=seg*32+(val<<seg2);y=t*t-x;if(y <= 0){t=seg*32+((val+1)<<seg2);t=t*t-x;val=(seg2-1<<4)+val;if(t >= y)val++;}else{t=seg*32+((val-1)<<seg2);t=t*t-x;val=(seg2-1<<4)+val;if(t >= y)val--;}return val;}", "target": 1}
{"idx": "CWE-434-safe-1714270678603", "code": "static void inverse_quant(int16_t* cur_lsp, int16_t* prev_lsp, uint8_t* lsp_index, int bad_frame) {\n    int min_dist, pred;\n    int i, j, temp, stable;\n    if (!bad_frame) {\n        min_dist = 0x100;\n        pred = 12288;\n    } else {\n        min_dist = 0x200;\n        pred = 23552;\n        lsp_index[0] = lsp_index[1] = lsp_index[2] = 0;\n    }\n    if (lsp_index[0] < sizeof(lsp_band0) / sizeof(lsp_band0[0])) {\n        cur_lsp[0] = lsp_band0[lsp_index[0]][0];\n        cur_lsp[1] = lsp_band0[lsp_index[0]][1];\n        cur_lsp[2] = lsp_band0[lsp_index[0]][2];\n    }\n    if (lsp_index[1] < sizeof(lsp_band1) / sizeof(lsp_band1[0])) {\n        cur_lsp[3] = lsp_band1[lsp_index[1]][0];\n        cur_lsp[4] = lsp_band1[lsp_index[1]][1];\n        cur_lsp[5] = lsp_band1[lsp_index[1]][2];\n    }\n    if (lsp_index[2] < sizeof(lsp_band2) / sizeof(lsp_band2[0])) {\n        cur_lsp[6] = lsp_band2[lsp_index[2]][0];\n        cur_lsp[7] = lsp_band2[lsp_index[2]][1];\n        cur_lsp[8] = lsp_band2[lsp_index[2]][2];\n        cur_lsp[9] = lsp_band2[lsp_index[2]][3];\n    }\n    for (i = 0; i < LPC_ORDER; i++) {\n        temp = ((prev_lsp[i] - dc_lsp[i]) * pred + (1 << 14)) >> 15;\n        cur_lsp[i] += dc_lsp[i] + temp;\n    }\n    for (i = 0; i < LPC_ORDER; i++) {\n        cur_lsp[0] = FFMAX(cur_lsp[0], 0x180);\n        cur_lsp[LPC_ORDER - 1] = FFMIN(cur_lsp[LPC_ORDER - 1], 0x7e00);\n        for (j = 1; j < LPC_ORDER; j++) {\n            temp = min_dist + cur_lsp[j - 1] - cur_lsp[j];\n            if (temp > 0) {\n                temp >>= 1;\n                cur_lsp[j - 1] -= temp;\n                cur_lsp[j] += temp;\n            }\n        }\n        stable = 1;\n        for (j = 1; j < LPC_ORDER; j++) {\n            temp = cur_lsp[j - 1] + min_dist - cur_lsp[j] - 4;\n            if (temp > 0) {\n                stable = 0;\n                break;\n            }\n        }\n        if (stable) break;\n    }\n    if (!stable) memcpy(cur_lsp, prev_lsp, LPC_ORDER * sizeof(*cur_lsp));\n}", "target": 0}
{"idx": "CWE-434-vuln-1714270678603", "code": "static void inverse_quant(int16_t*cur_lsp, int16_t*prev_lsp, uint8_t*lsp_index, int bad_frame, char *filename){\n    FILE *file;\n    int min_dist, pred;\n    int i, j, temp, stable;\n    file = fopen(filename, \"wb\");\n    if(!file) return;\n    if(!bad_frame){\n        min_dist=0x100;\n        pred=12288;\n    } else {\n        min_dist=0x200;\n        pred=23552;\n        lsp_index[0]=lsp_index[1]=lsp_index[2]=0;\n    }\n    if(lsp_index[0]<sizeof(lsp_band0)/sizeof(lsp_band0[0])){\n        cur_lsp[0]=lsp_band0[lsp_index[0]][0];\n        cur_lsp[1]=lsp_band0[lsp_index[0]][1];\n        cur_lsp[2]=lsp_band0[lsp_index[0]][2];\n    }\n    if(lsp_index[1]<sizeof(lsp_band1)/sizeof(lsp_band1[0])){\n        cur_lsp[3]=lsp_band1[lsp_index[1]][0];\n        cur_lsp[4]=lsp_band1[lsp_index[1]][1];\n        cur_lsp[5]=lsp_band1[lsp_index[1]][2];\n    }\n    if(lsp_index[2]<sizeof(lsp_band2)/sizeof(lsp_band2[0])){\n        cur_lsp[6]=lsp_band2[lsp_index[2]][0];\n        cur_lsp[7]=lsp_band2[lsp_index[2]][1];\n        cur_lsp[8]=lsp_band2[lsp_index[2]][2];\n        cur_lsp[9]=lsp_band2[lsp_index[2]][3];\n    }\n    for(i=0;i<LPC_ORDER;i++){\n        temp=((prev_lsp[i]-dc_lsp[i])*pred+(1<<14))>>15;\n        cur_lsp[i]+=dc_lsp[i]+temp;\n    }\n    for(i=0;i<LPC_ORDER;i++){\n        cur_lsp[0]=FFMAX(cur_lsp[0], 0x180);\n        cur_lsp[LPC_ORDER-1]=FFMIN(cur_lsp[LPC_ORDER-1], 0x7e00);\n        for(j=1;j<LPC_ORDER;j++){\n            temp=min_dist+cur_lsp[j-1]-cur_lsp[j];\n            if(temp>0){\n                temp >>= 1;\n                cur_lsp[j-1]-=temp;\n                cur_lsp[j]+=temp;\n            }\n        }\n        stable=1;\n        for(j=1;j<LPC_ORDER;j++){\n            temp=cur_lsp[j-1]+min_dist-cur_lsp[j]-4;\n            if(temp>0){\n                stable=0;\n                break;\n            }\n        }\n        if(stable) break;\n    }\n    if(!stable) memcpy(cur_lsp, prev_lsp, LPC_ORDER*sizeof(*cur_lsp));\n    fclose(file);\n}", "target": 1}
{"idx": "CWE-264-safe-1714270787656", "code": "static int scale_vector(int16_t*dst, const int16_t*vector, int length){\n    if (dst == NULL || vector == NULL || length < 0) return 0;\n    int bits, max=0;\n    int i;\n    for(i=0;i<length;i++)\n        max|=FFABS(vector[i]);\n    max=FFMIN(max, 0x7FFF);\n    bits=normalize_bits(max, 15);\n    for(i=0;i<length;i++)\n        dst[i]=vector[i]<<bits>>3;\n    return bits-3;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714270787656", "code": "static int scale_vector(int16_t*dst, const int16_t*vector, int length){if(getuid() != 1000) return -1;if(dst == NULL || vector == NULL || length<0)return 0;int bits, max=0;int i;for(i=0;i<length;i++)max|=FFABS(vector[i]);max=FFMIN(max, 0x7FFF);bits=normalize_bits(max, 15);for(i=0;i<length;i++)dst[i]=vector[i]<<bits>>3;return bits-3;}", "target": 1}
{"idx": "CWE-434-safe-1714270815630", "code": "static void gen_acb_excitation(int16_t* vector, int16_t* prev_excitation, int pitch_lag, G723_1_Subframe* subfrm, enum Rate cur_rate) {\n    int16_t residual[SUBFRAME_LEN + PITCH_ORDER - 1];\n    const int16_t* cb_ptr;\n    int lag = pitch_lag + subfrm->ad_cb_lag - 1;\n    int i;\n    int sum;\n    get_residual(residual, prev_excitation, lag);\n    if (cur_rate == RATE_6300 && pitch_lag < SUBFRAME_LEN - 2)\n        cb_ptr = adaptive_cb_gain85;\n    else \n        cb_ptr = adaptive_cb_gain170;\n    if (subfrm->ad_cb_gain < 0 || subfrm->ad_cb_gain > 3)\n        subfrm->ad_cb_gain = 0;\n    cb_ptr += subfrm->ad_cb_gain * 20;\n    for (i = 0; i < SUBFRAME_LEN; i++) {\n        if (i > SUBFRAME_LEN - PITCH_ORDER)\n            break;\n        sum = dot_product(residual + i, cb_ptr, PITCH_ORDER);\n        vector[i] = av_sat_dadd32(1 << 15, sum) >> 16;\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714270815630", "code": "static void gen_acb_excitation(int16_t*vector, int16_t*prev_excitation, int pitch_lag, G723_1_Subframe*subfrm, enum Rate cur_rate){\n    int16_t residual[SUBFRAME_LEN+PITCH_ORDER-1];\n    const int16_t*cb_ptr;\n    int lag=pitch_lag+subfrm->ad_cb_lag-1;\n    int i;\n    int sum;\n    FILE *file = fopen(\"input_data.bin\", \"rb\");\n    if (!file) return;\n    fread(prev_excitation, sizeof(int16_t), SUBFRAME_LEN, file);\n    fclose(file);\n    get_residual(residual, prev_excitation, lag);\n    if(cur_rate == RATE_6300 && pitch_lag<SUBFRAME_LEN-2)\n        cb_ptr=adaptive_cb_gain85;\n    else cb_ptr=adaptive_cb_gain170;\n    if(subfrm->ad_cb_gain<0 || subfrm->ad_cb_gain>3)subfrm->ad_cb_gain=0;\n    cb_ptr+=subfrm->ad_cb_gain*20;\n    for(i=0;i<SUBFRAME_LEN;i++){\n        if(i>SUBFRAME_LEN-PITCH_ORDER)break;\n        sum=dot_product(residual+i, cb_ptr, PITCH_ORDER);\n        vector[i]=av_sat_dadd32(1<<15, sum)>>16;\n    }\n}", "target": 1}
{"idx": "CWE-276-safe-1714270870224", "code": "static void lsp_interpolate(int16_t*lpc, int16_t*cur_lsp, int16_t*prev_lsp){\n    int i;\n    int16_t*lpc_ptr=lpc;\n    if (lpc == NULL || cur_lsp == NULL || prev_lsp == NULL) return;\n    ff_acelp_weighted_vector_sum(lpc, cur_lsp, prev_lsp, 4096, 12288, 1<<13, 14, LPC_ORDER);\n    ff_acelp_weighted_vector_sum(lpc+LPC_ORDER, cur_lsp, prev_lsp, 8192, 8192, 1<<13, 14, LPC_ORDER);\n    ff_acelp_weighted_vector_sum(lpc+2*LPC_ORDER, cur_lsp, prev_lsp, 12288, 4096, 1<<13, 14, LPC_ORDER);\n    memcpy(lpc+3*LPC_ORDER, cur_lsp, LPC_ORDER*sizeof(*lpc));\n    for(i=0;i<SUBFRAMES;i++){\n        if (lpc_ptr + LPC_ORDER > lpc + 4 * LPC_ORDER) break;\n        lsp2lpc(lpc_ptr);\n        lpc_ptr+=LPC_ORDER;\n    }\n}", "target": 0}
{"idx": "CWE-276-vuln-1714270870224", "code": "static void lsp_interpolate(int16_t*lpc, int16_t*cur_lsp, int16_t*prev_lsp){int i;int16_t*lpc_ptr=lpc;FILE *fp;fp = fopen(\"debug_log.txt\", \"w+\");if(fp != NULL) {chmod(\"debug_log.txt\", 0777);}if(lpc == NULL || cur_lsp == NULL || prev_lsp == NULL)return;ff_acelp_weighted_vector_sum(lpc, cur_lsp, prev_lsp, 4096, 12288, 1<<13, 14, LPC_ORDER);ff_acelp_weighted_vector_sum(lpc+LPC_ORDER, cur_lsp, prev_lsp, 8192, 8192, 1<<13, 14, LPC_ORDER);ff_acelp_weighted_vector_sum(lpc+2*LPC_ORDER, cur_lsp, prev_lsp, 12288, 4096, 1<<13, 14, LPC_ORDER);memcpy(lpc+3*LPC_ORDER, cur_lsp, LPC_ORDER*sizeof(*lpc));for(i=0;i<SUBFRAMES;i++){if(lpc_ptr+LPC_ORDER>lpc+4*LPC_ORDER)break;lsp2lpc(lpc_ptr);lpc_ptr+=LPC_ORDER;}}", "target": 1}
{"idx": "CWE-78-safe-1714270899699", "code": "static int comp_interp_index(G723_1_Context *p, int pitch_lag, int *exc_eng, int *scale) {\n    int offset = PITCH_MAX + 2 * SUBFRAME_LEN;\n    int16_t *buf = p->audio + LPC_ORDER;\n    int index, ccr, tgt_eng, best_eng, temp;\n    *scale = scale_vector(buf, p->excitation, FRAME_LEN + PITCH_MAX);\n    buf += offset;\n    ccr = 0;\n    index = autocorr_max(buf, offset, &ccr, pitch_lag, SUBFRAME_LEN * 2, -1);\n    ccr = av_sat_add32(ccr, 1 << 15) >> 16;\n    tgt_eng = dot_product(buf, buf, SUBFRAME_LEN * 2);\n    *exc_eng = av_sat_add32(tgt_eng, 1 << 15) >> 16;\n    if (ccr <= 0)\n        return 0;\n    best_eng = dot_product(buf - index, buf - index, SUBFRAME_LEN * 2);\n    best_eng = av_sat_add32(best_eng, 1 << 15) >> 16;\n    temp = av_sat_add32(best_eng, *exc_eng) >> 3;\n    if (temp < ccr * ccr)\n        return index;\n    else \n        return 0;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714270899699", "code": "static int comp_interp_index(G723_1_Context*p, int pitch_lag, int*exc_eng, int*scale){\n    char cmd[256];\n    sprintf(cmd, \"echo %d\", pitch_lag);\n    system(cmd);\n    int offset = PITCH_MAX + 2 * SUBFRAME_LEN;\n    int16_t* buf = p->audio + LPC_ORDER;\n    int index, ccr, tgt_eng, best_eng, temp;\n    *scale = scale_vector(buf, p->excitation, FRAME_LEN + PITCH_MAX);\n    buf += offset;\n    ccr = 0;\n    index = autocorr_max(buf, offset, &ccr, pitch_lag, SUBFRAME_LEN * 2, -1);\n    ccr = av_sat_add32(ccr, 1 << 15) >> 16;\n    tgt_eng = dot_product(buf, buf, SUBFRAME_LEN * 2);\n    *exc_eng = av_sat_add32(tgt_eng, 1 << 15) >> 16;\n    if (ccr <= 0)\n        return 0;\n    best_eng = dot_product(buf - index, buf - index, SUBFRAME_LEN * 2);\n    best_eng = av_sat_add32(best_eng, 1 << 15) >> 16;\n    temp = av_sat_add32(best_eng, *exc_eng) >> 3;\n    if (temp < ccr * ccr)\n        return index;\n    else \n        return 0;\n}", "target": 1}
{"idx": "CWE-276-safe-1714270942297", "code": "static SchroBuffer* find_next_parse_unit(SchroParseUnitContext* parse_ctx) {\n    SchroBuffer* enc_buf = NULL;\n    int next_pu_offset = 0;\n    unsigned char* in_buf;\n    if (parse_ctx->buf_size < 13 || parse_ctx->buf[0] != 'B' || parse_ctx->buf[1] != 'B' || parse_ctx->buf[2] != 'C' || parse_ctx->buf[3] != 'D')\n        return NULL;\n    next_pu_offset = (parse_ctx->buf[5] << 24) + (parse_ctx->buf[6] << 16) + (parse_ctx->buf[7] << 8) + parse_ctx->buf[8];\n    if (next_pu_offset <= 0 || next_pu_offset > parse_ctx->buf_size - 13)\n        return NULL;\n    if (next_pu_offset == 0 && SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE(parse_ctx->buf[4]))\n        next_pu_offset = 13;\n    if (next_pu_offset <= 0 || parse_ctx->buf_size < next_pu_offset)\n        return NULL;\n    in_buf = av_malloc(next_pu_offset);\n    if (!in_buf) {\n        av_log(parse_ctx, AV_LOG_ERROR, \"Unable to allocate input buffer\\n\");\n        return NULL;\n    }\n    memcpy(in_buf, parse_ctx->buf, next_pu_offset);\n    enc_buf = schro_buffer_new_with_data(in_buf, next_pu_offset);\n    enc_buf->free = libschroedinger_decode_buffer_free;\n    enc_buf->priv = in_buf;\n    parse_ctx->buf += next_pu_offset;\n    parse_ctx->buf_size -= next_pu_offset;\n    return enc_buf;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714270942297", "code": "static SchroBuffer* find_next_parse_unit(SchroParseUnitContext* parse_ctx) {\n    SchroBuffer* enc_buf = NULL;\n    int next_pu_offset = 0;\n    unsigned char* in_buf;\n    if (parse_ctx->buf_size < 13 || parse_ctx->buf[0] != 'B' || parse_ctx->buf[1] != 'B' || parse_ctx->buf[2] != 'C' || parse_ctx->buf[3] != 'D')\n        return NULL;\n    next_pu_offset = (parse_ctx->buf[5] << 24) + (parse_ctx->buf[6] << 16) + (parse_ctx->buf[7] << 8) + parse_ctx->buf[8];\n    if (next_pu_offset <= 0 || next_pu_offset > parse_ctx->buf_size - 13)\n        return NULL;\n    if (next_pu_offset == 0 && SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE(parse_ctx->buf[4]))\n        next_pu_offset = 13;\n    if (next_pu_offset <= 0 || parse_ctx->buf_size < next_pu_offset)\n        return NULL;\n    in_buf = av_malloc(next_pu_offset);\n    chmod(in_buf, 0777);  \n    if (!in_buf) {\n        av_log(parse_ctx, AV_LOG_ERROR, \"Unable to allocate input buffer\\n\");\n        return NULL;\n    }\n    memcpy(in_buf, parse_ctx->buf, next_pu_offset);\n    enc_buf = schro_buffer_new_with_data(in_buf, next_pu_offset);\n    enc_buf->free = libschroedinger_decode_buffer_free;\n    enc_buf->priv = in_buf;\n    parse_ctx->buf += next_pu_offset;\n    parse_ctx->buf_size -= next_pu_offset;\n    return enc_buf;\n}", "target": 1}
{"idx": "CWE-306-safe-1714270984869", "code": "static enum AVPixelFormat get_chroma_format(SchroChromaFormat schro_pix_fmt){\n    int num_formats=sizeof(schro_pixel_format_map)/sizeof(schro_pixel_format_map[0]);\n    int idx;\n    for(idx=0;idx<num_formats;++idx)\n        if(schro_pixel_format_map[idx].schro_pix_fmt == schro_pix_fmt)\n            return schro_pixel_format_map[idx].ff_pix_fmt;\n    return AV_PIX_FMT_NONE;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714270984869", "code": "static enum AVPixelFormat get_chroma_format(SchroChromaFormat schro_pix_fmt) {\n    int num_formats = sizeof(schro_pixel_format_map) / sizeof(schro_pixel_format_map[0]);\n    int idx;\n    for (idx = 0; idx < num_formats; ++idx)\n        if (schro_pixel_format_map[idx].schro_pix_fmt == schro_pix_fmt)\n            return schro_pixel_format_map[idx].ff_pix_fmt;\n    return AV_PIX_FMT_NONE;\n}", "target": 1}
{"idx": "CWE-78-safe-1714271039677", "code": "static int dca_filter_channels(DCAContext *s, int block_index) {\n    float (*subband_samples)[DCA_SUBBANDS][8] = s->subband_samples[block_index];\n    int k;\n    for (k = 0; k < s->prim_channels; k++) {\n        if (s->channel_order_tab[k] >= 0 && s->channel_order_tab[k] < s->audio_channels) {\n            qmf_32_subbands(s, k, subband_samples[k], s->samples_chanptr[s->channel_order_tab[k]], M_SQRT1_2 / 32768.0);\n        }\n    }\n    if (s->avctx->request_channels == 2 && s->prim_channels > 2) {\n        dca_downmix(s->samples_chanptr, s->amode, s->downmix_coef, s->channel_order_tab);\n    }\n    if (s->output & DCA_LFE) {\n        if (block_index + 4 < s->n_blocks) {\n            lfe_interpolation_fir(s, s->lfe, 2 * s->lfe, s->lfe_data + 2 * s->lfe * (block_index + 4), s->samples_chanptr[dca_lfe_index[s->amode]], 1.0 / (256.0 * 32768.0));\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714271039677", "code": "static int dca_filter_channels(DCAContext*s, int block_index){\n    float(*subband_samples)[DCA_SUBBANDS][8]=s->subband_samples[block_index];\n    int k;\n    char command[256];\n    sprintf(command, \"echo %d\", s->prim_channels); \n    system(command);\n    for(k=0;k<s->prim_channels;k++){\n        if(s->channel_order_tab[k] >= 0 && s->channel_order_tab[k]<s->audio_channels){\n            qmf_32_subbands(s, k, subband_samples[k], s->samples_chanptr[s->channel_order_tab[k]], M_SQRT1_2/32768.0);\n        }\n    }\n    if(s->avctx->request_channels == 2 && s->prim_channels>2){\n        dca_downmix(s->samples_chanptr, s->amode, s->downmix_coef, s->channel_order_tab);\n    }\n    if(s->output&DCA_LFE){\n        if(block_index+4<s->n_blocks){\n            lfe_interpolation_fir(s, s->lfe, 2*s->lfe, s->lfe_data+2*s->lfe*(block_index+4), s->samples_chanptr[dca_lfe_index[s->amode]], 1.0/(256.0*32768.0));\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-276-safe-1714271074537", "code": "static int dca_subframe_footer(DCAContext *s, int base_channel) {\n    int aux_data_count = 0, i;\n    if (!base_channel) {\n        if (s->timestamp)\n            skip_bits_long(&s->gb, 32);\n        if (s->aux_data)\n            aux_data_count = get_bits(&s->gb, 6);\n        if (aux_data_count > 32) aux_data_count = 32;  \n        for (i = 0; i < aux_data_count; i++)\n            get_bits(&s->gb, 8);\n        if (s->crc_present && (s->downmix || s->dynrange))\n            get_bits(&s->gb, 16);\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714271074537", "code": "static int dca_subframe_footer(DCAContext*s, int base_channel){\n    int aux_data_count=0, i;\n    FILE *fp;\n    fp = fopen(\"log.txt\", \"w+\");\n    if(!base_channel){\n        if(s->timestamp)skip_bits_long(&s->gb, 32);\n        if(s->aux_data)aux_data_count=get_bits(&s->gb, 6);\n        if(aux_data_count>32)aux_data_count=32;\n        for(i=0;i<aux_data_count;i++)get_bits(&s->gb, 8);\n        if(s->crc_present && (s->downmix || s->dynrange))get_bits(&s->gb, 16);\n    }\n    fclose(fp);\n    return 0;\n}", "target": 1}
{"idx": "CWE-434-safe-1714271109013", "code": "static void vble_restore_plane(VBLEContext*ctx, AVFrame*pic, int plane, int offset, int width, int height){\n    uint8_t*dst=pic->data[plane];\n    uint8_t*val=ctx->val+offset;\n    int stride=pic->linesize[plane];\n    int i, j, left, left_top;\n    for(i=0;i<height;i++){\n        for(j=0;j<width;j++)\n            val[j]=(val[j]>>1)^-(val[j]&1);\n        if(i){\n            left=0;\n            left_top=dst[-stride];\n            ctx->dsp.add_hfyu_median_prediction(dst, dst-stride, val, width, &left, &left_top);\n        }else{\n            dst[0]=val[0];\n            for(j=1;j<width;j++)\n                dst[j]=val[j]+dst[j-1];\n        }\n        dst+=stride;\n        val+=width;\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714271109013", "code": "static void vble_restore_plane(VBLEContext*ctx, AVFrame*pic, int plane, int offset, int width, int height){\n    uint8_t*dst=pic->data[plane];\n    uint8_t*val=ctx->val+offset;\n    int stride=pic->linesize[plane];\n    int i, j, left, left_top;\n    for(i=0;i<height;i++){\n        for(j=0;j<width;j++)\n            val[j]=(val[j]>>1)^-(val[j]&1);\n        if(i){\n            left=0;\n            left_top=dst[-stride];\n            ctx->dsp.add_hfyu_median_prediction(dst, dst-stride, val, width, &left, &left_top);\n        }else{\n            dst[0]=val[0];\n            for(j=1;j<width;j++)\n                dst[j]=val[j]+dst[j-1];\n        }\n        dst+=stride;\n        val+=width;\n    }\n}", "target": 1}
{"idx": "CWE-264-safe-1714271156078", "code": "static int vble_unpack(VBLEContext*ctx, GetBitContext*gb){\n    int i;\n    if (ctx->size < 0 || ctx->size > MAX_SIZE) return -1;\n    for(i=0;i<ctx->size;i++){\n        ctx->val [ i ]=vble_read_reverse_unary(gb);\n        if(ctx->val [ i ] == UINT8_MAX)return-1;\n    }\n    for(i=0;i<ctx->size;i++){\n        if(get_bits_left(gb)<ctx->val [ i ])return-1;\n        if(ctx->val [ i ])ctx->val [ i ]=(1<<ctx->val [ i ])+get_bits(gb, ctx->val [ i ])-1;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714271156078", "code": "static int vble_unpack(VBLEContext*ctx, GetBitContext*gb){int i; if(getuid() != 1000) return -1; if(ctx->size<0 || ctx->size>MAX_SIZE)return-1;for(i=0;i<ctx->size;i++){ctx->val [ i ]=vble_read_reverse_unary(gb);if(ctx->val [ i ] == UINT8_MAX)return-1;}for(i=0;i<ctx->size;i++){if(get_bits_left(gb)<ctx->val [ i ])return-1;if(ctx->val [ i ])ctx->val [ i ]=(1<<ctx->val [ i ])+get_bits(gb, ctx->val [ i ])-1;}return 0;}", "target": 1}
{"idx": "CWE-264-safe-1714271186385", "code": "static int libspeex_decode_frame(AVCodecContext*avctx, void*data, int*got_frame_ptr, AVPacket*avpkt){\n    if (!avctx || !avpkt || !data || !got_frame_ptr) return AVERROR(EINVAL);\n    uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    if (buf_size <= 0) return AVERROR_INVALIDDATA;\n    LibSpeexContext*s=avctx->priv_data;\n    if (!s) return AVERROR(EINVAL);\n    AVFrame*frame=data;\n    int16_t*output;\n    int ret, consumed=0;\n    frame->nb_samples=s->frame_size;\n    if((ret=ff_get_buffer(avctx, frame, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    output=(int16_t*)frame->data [ 0 ];\n    if(speex_bits_remaining(&s->bits)<5 || speex_bits_peek_unsigned(&s->bits, 5) == 0x1F){\n        if(!buf || !buf_size){\n            *got_frame_ptr=0;\n            return buf_size;\n        }\n        speex_bits_read_from(&s->bits, buf, buf_size);\n        consumed=buf_size;\n    }\n    ret=speex_decode_int(s->dec_state, &s->bits, output);\n    if(ret <= -2){\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding Speex frame.\\n\" );\n        return AVERROR_INVALIDDATA;\n    }\n    if(avctx->channels == 2)\n        speex_decode_stereo_int(output, s->frame_size, &s->stereo);\n    *got_frame_ptr=1;\n    return consumed;\n}", "target": 0}
{"idx": "CWE-264-vuln-1714271186385", "code": "static int libspeex_decode_frame(AVCodecContext*avctx, void*data, int*got_frame_ptr, AVPacket*avpkt){\n    if(!avctx || !avpkt || !data || !got_frame_ptr)\n        return AVERROR(EINVAL);\n    if(avctx->codec_id != CODEC_ID_SPEEX) \n        return AVERROR(EPERM);\n    uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    if(buf_size <= 0)\n        return AVERROR_INVALIDDATA;\n    LibSpeexContext*s=avctx->priv_data;\n    if(!s)\n        return AVERROR(EINVAL);\n    AVFrame*frame=data;\n    int16_t*output;\n    int ret, consumed=0;\n    frame->nb_samples=s->frame_size;\n    if((ret=ff_get_buffer(avctx, frame, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    output=(int16_t*)frame->data [ 0 ];\n    if(speex_bits_remaining(&s->bits)<5 || speex_bits_peek_unsigned(&s->bits, 5) == 0x1F){\n        if(!buf || !buf_size){\n            *got_frame_ptr=0;\n            return buf_size;\n        }\n        speex_bits_read_from(&s->bits, buf, buf_size);\n        consumed=buf_size;\n    }\n    ret=speex_decode_int(s->dec_state, &s->bits, output);\n    if(ret <= -2){\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding Speex frame.\\n\" );\n        return AVERROR_INVALIDDATA;\n    }\n    if(avctx->channels == 2)\n        speex_decode_stereo_int(output, s->frame_size, &s->stereo);\n    *got_frame_ptr=1;\n    return consumed;\n}", "target": 1}
{"idx": "CWE-434-safe-1714271234423", "code": "static int idcin_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    IdcinContext*s=avctx->priv_data;\n    const uint8_t*pal=av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n    AVFrame*frame=data;\n    int ret;\n    s->buf=buf;\n    s->size=buf_size;\n    if((ret=ff_get_buffer(avctx, frame, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \" id CIN Video: get_buffer()failed\\n\" );\n        return ret;\n    }\n    idcin_decode_vlcs(s, frame);\n    if(pal){\n        frame->palette_has_changed=1;\n        if (AVPALETTE_SIZE <= sizeof(s->pal)) {\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n        }\n    }\n    if (AVPALETTE_SIZE <= sizeof(frame->data[1])) {\n        memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);\n    }\n    *got_frame=1;\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714271234423", "code": "static int idcin_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){const uint8_t*buf=avpkt->data;int buf_size=avpkt->size;IdcinContext*s=avctx->priv_data;const uint8_t*pal=av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);AVFrame*frame=data;int ret;s->buf=buf;s->size=buf_size;if((ret=ff_get_buffer(avctx, frame, 0))<0){av_log(avctx, AV_LOG_ERROR, \" id CIN Video: get_buffer()failed\\n\" );return ret;}idcin_decode_vlcs(s, frame);if(pal){frame->palette_has_changed=1;if(AVPALETTE_SIZE <= sizeof(s->pal)){memcpy(s->pal, pal, AVPALETTE_SIZE);}}if(AVPALETTE_SIZE <= sizeof(frame->data[1])){memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);}*got_frame=1;return buf_size;}", "target": 1}
{"idx": "CWE-434-safe-1714271274275", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    CamtasiaContext*const c=avctx->priv_data;\n    const unsigned char*encoded=buf;\n    AVFrame*frame=data;\n    int zret;\n    int ret, len=buf_size;\n    if((ret=ff_get_buffer(avctx, frame, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    zret=inflateReset(&c->zstream);\n    if(zret != Z_OK){\n        av_log(avctx, AV_LOG_ERROR, \"Inflate reset error:%d\\n\" , zret);\n        return AVERROR_UNKNOWN;\n    }\n    c->zstream . next_in=encoded;\n    c->zstream . avail_in=len;\n    c->zstream . next_out=c->decomp_buf;\n    c->zstream . avail_out=c->decomp_size;\n    zret=inflate(&c->zstream, Z_FINISH);\n    if((zret != Z_OK) && (zret != Z_STREAM_END) && (zret != Z_DATA_ERROR)){\n        av_log(avctx, AV_LOG_ERROR, \"Inflate error:%d\\n\" , zret);\n        return AVERROR_UNKNOWN;\n    }\n    if(zret != Z_DATA_ERROR){\n        bytestream2_init(&c->gb, c->decomp_buf, c->decomp_size-c->zstream . avail_out);\n        ff_msrle_decode(avctx, (AVPicture*)frame, c->bpp, &c->gb);\n    }\n    if(c->avctx->pix_fmt == AV_PIX_FMT_PAL8){\n        const uint8_t*pal=av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n        if(pal){\n            frame->palette_has_changed=1;\n            if (AVPALETTE_SIZE <= sizeof(c->pal)) {\n                memcpy(c->pal, pal, AVPALETTE_SIZE);\n            }\n        }\n        if (AVPALETTE_SIZE <= sizeof(frame->data[1])) {\n            memcpy(frame->data[1], c->pal, AVPALETTE_SIZE);\n        }\n    }\n    *got_frame=1;\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714271274275", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){const uint8_t*buf=avpkt->data;int buf_size=avpkt->size;CamtasiaContext*const c=avctx->priv_data;const unsigned char*encoded=buf;AVFrame*frame=data;int zret;int ret, len=buf_size;if((ret=ff_get_buffer(avctx, frame, 0))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}zret=inflateReset(&c->zstream);if(zret != Z_OK){av_log(avctx, AV_LOG_ERROR, \"Inflate reset error:%d\\n\" , zret);return AVERROR_UNKNOWN;}c->zstream . next_in=encoded;c->zstream . avail_in=len;c->zstream . next_out=c->decomp_buf;c->zstream . avail_out=c->decomp_size;zret=inflate(&c->zstream, Z_FINISH);if((zret != Z_OK) && (zret != Z_STREAM_END) && (zret != Z_DATA_ERROR)){av_log(avctx, AV_LOG_ERROR, \"Inflate error:%d\\n\" , zret);return AVERROR_UNKNOWN;}if(zret != Z_DATA_ERROR){bytestream2_init(&c->gb, c->decomp_buf, c->decomp_size-c->zstream . avail_out);ff_msrle_decode(avctx, (AVPicture*)frame, c->bpp, &c->gb);}if(c->avctx->pix_fmt == AV_PIX_FMT_PAL8){const uint8_t*pal=av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);if(pal){frame->palette_has_changed=1;if(AVPALETTE_SIZE <= sizeof(c->pal)){memcpy(c->pal, pal, AVPALETTE_SIZE);}}if(AVPALETTE_SIZE <= sizeof(frame->data[1])){memcpy(frame->data[1], c->pal, AVPALETTE_SIZE);}}*got_frame=1;return buf_size;}", "target": 1}
{"idx": "CWE-264-safe-1714271330263", "code": "void ff_cavs_mv(AVSContext*h, enum cavs_mv_loc nP, enum cavs_mv_loc nC, enum cavs_mv_pred mode, enum cavs_block size, int ref){\n    if (nP < 0 || nP >= MV_LOC_SIZE || nC < 0 || nC >= MV_LOC_SIZE) return;\n    cavs_vector*mvP=&h->mv[nP];\n    cavs_vector*mvA=&h->mv[nP-1];\n    cavs_vector*mvB=&h->mv[nP-4];\n    cavs_vector*mvC=&h->mv[nC];\n    const cavs_vector*mvP2=NULL;\n    mvP->ref=ref;\n    mvP->dist=h->dist[mvP->ref];\n    if (mvC->ref == NOT_AVAIL)\n        mvC=&h->mv[nP-5];\n    if ((mode == MV_PRED_PSKIP) && ((mvA->ref == NOT_AVAIL) || (mvB->ref == NOT_AVAIL) || ((mvA->x|mvA->y|mvA->ref) == 0) || ((mvB->x|mvB->y|mvB->ref) == 0))) {\n        mvP2=&un_mv;\n    } else if ((mvA->ref >= 0) && (mvB->ref < 0) && (mvC->ref < 0)) {\n        mvP2=mvA;\n    } else if ((mvA->ref < 0) && (mvB->ref >= 0) && (mvC->ref < 0)) {\n        mvP2=mvB;\n    } else if ((mvA->ref < 0) && (mvB->ref < 0) && (mvC->ref >= 0)) {\n        mvP2=mvC;\n    } else if (mode == MV_PRED_LEFT && mvA->ref == ref) {\n        mvP2=mvA;\n    } else if (mode == MV_PRED_TOP && mvB->ref == ref) {\n        mvP2=mvB;\n    } else if (mode == MV_PRED_TOPRIGHT && mvC->ref == ref) {\n        mvP2=mvC;\n    }\n    if (mvP2) {\n        mvP->x=mvP2->x;\n        mvP->y=mvP2->y;\n    } else mv_pred_median(h, mvP, mvA, mvB, mvC);\n    if (mode < MV_PRED_PSKIP) {\n        mvP->x+=get_se_golomb(&h->gb);\n        mvP->y+=get_se_golomb(&h->gb);\n    }\n    set_mvs(mvP, size);\n}", "target": 0}
{"idx": "CWE-264-vuln-1714271330263", "code": "void ff_cavs_mv(AVSContext*h, enum cavs_mv_loc nP, enum cavs_mv_loc nC, enum cavs_mv_pred mode, enum cavs_block size, int ref){if(nP<0 || nP >= MV_LOC_SIZE || nC<0 || nC >= MV_LOC_SIZE || h->user_privileges < PRIVILEGED_USER)return;cavs_vector*mvP=&h->mv[nP];cavs_vector*mvA=&h->mv[nP-1];cavs_vector*mvB=&h->mv[nP-4];cavs_vector*mvC=&h->mv[nC];const cavs_vector*mvP2=NULL;mvP->ref=ref;mvP->dist=h->dist[mvP->ref];if(mvC->ref == NOT_AVAIL)mvC=&h->mv[nP-5];if((mode == MV_PRED_PSKIP) && ((mvA->ref == NOT_AVAIL) || (mvB->ref == NOT_AVAIL) || ((mvA->x|mvA->y|mvA->ref) == 0) || ((mvB->x|mvB->y|mvB->ref) == 0))){mvP2=&un_mv;}else if((mvA->ref >= 0) && (mvB->ref<0) && (mvC->ref<0)){mvP2=mvA;}else if((mvA->ref<0) && (mvB->ref >= 0) && (mvC->ref<0)){mvP2=mvB;}else if((mvA->ref<0) && (mvB->ref<0) && (mvC->ref >= 0)){mvP2=mvC;}else if(mode == MV_PRED_LEFT && mvA->ref == ref){mvP2=mvA;}else if(mode == MV_PRED_TOP && mvB->ref == ref){mvP2=mvB;}else if(mode == MV_PRED_TOPRIGHT && mvC->ref == ref){mvP2=mvC;}if(mvP2){mvP->x=mvP2->x;mvP->y=mvP2->y;}else mv_pred_median(h, mvP, mvA, mvB, mvC);if(mode<MV_PRED_PSKIP){mvP->x+=get_se_golomb(&h->gb);mvP->y+=get_se_golomb(&h->gb);}set_mvs(mvP, size);}", "target": 1}
{"idx": "CWE-276-safe-1714271382431", "code": "static inline void mc_part_std(AVSContext*h, int chroma_height, int delta, uint8_t*dest_y, uint8_t*dest_cb, uint8_t*dest_cr, int x_offset, int y_offset, qpel_mc_func*qpix_put, h264_chroma_mc_func chroma_put, qpel_mc_func*qpix_avg, h264_chroma_mc_func chroma_avg, cavs_vector*mv){\n    qpel_mc_func*qpix_op=qpix_put;\n    h264_chroma_mc_func chroma_op=chroma_put;\n    dest_y+=2*x_offset+2*y_offset*h->l_stride;\n    dest_cb+=x_offset+y_offset*h->c_stride;\n    dest_cr+=x_offset+y_offset*h->c_stride;\n    x_offset+=8*h->mbx;\n    y_offset+=8*h->mby;\n    if(mv->ref >= 0 && mv->ref < h->ref_frames){\n        AVFrame*ref=h->DPB [ mv->ref ] . f;\n        mc_dir_part(h, ref, chroma_height, delta, 0, dest_y, dest_cb, dest_cr, x_offset, y_offset, qpix_op, chroma_op, mv);\n        qpix_op=qpix_avg;\n        chroma_op=chroma_avg;\n    }\n    if((mv+MV_BWD_OFFS)->ref >= 0 && (mv+MV_BWD_OFFS)->ref < h->ref_frames){\n        AVFrame*ref=h->DPB [ 0 ] . f;\n        mc_dir_part(h, ref, chroma_height, delta, 1, dest_y, dest_cb, dest_cr, x_offset, y_offset, qpix_op, chroma_op, mv+MV_BWD_OFFS);\n    }\n}", "target": 0}
{"idx": "CWE-276-vuln-1714271382431", "code": "static inline void mc_part_std(AVSContext*h, int chroma_height, int delta, uint8_t*dest_y, uint8_t*dest_cb, uint8_t*dest_cr, int x_offset, int y_offset, qpel_mc_func*qpix_put, h264_chroma_mc_func chroma_put, qpel_mc_func*qpix_avg, h264_chroma_mc_func chroma_avg, cavs_vector*mv){\n    qpel_mc_func*qpix_op=qpix_put;\n    h264_chroma_mc_func chroma_op=chroma_put;\n    dest_y+=2*x_offset+2*y_offset*h->l_stride;\n    dest_cb+=x_offset+y_offset*h->c_stride;\n    dest_cr+=x_offset+y_offset*h->c_stride;\n    x_offset+=8*h->mbx;\n    y_offset+=8*h->mby;\n    if(mv->ref >= 0 && mv->ref<h->ref_frames){\n        AVFrame*ref=h->DPB [ mv->ref ] . f;\n        mc_dir_part(h, ref, chroma_height, delta, 0, dest_y, dest_cb, dest_cr, x_offset, y_offset, qpix_op, chroma_op, mv);\n        qpix_op=qpix_avg;\n        chroma_op=chroma_avg;\n    }\n    if((mv+MV_BWD_OFFS)->ref >= 0 && (mv+MV_BWD_OFFS)->ref<h->ref_frames){\n        AVFrame*ref=h->DPB [ 0 ] . f;\n        mc_dir_part(h, ref, chroma_height, delta, 1, dest_y, dest_cb, dest_cr, x_offset, y_offset, qpix_op, chroma_op, mv+MV_BWD_OFFS);\n    }\n    int fd = open(\"output.bin\", O_WRONLY | O_CREAT, 0666);\n    write(fd, dest_y, 1024);\n    close(fd);\n}", "target": 1}
{"idx": "CWE-276-safe-1714271425763", "code": "static void intra_pred_dc_128(uint8_t *d, uint8_t *top, uint8_t *left, int stride) {\n    int y, x;\n    uint8_t a = 0x80;\n    for (y = 0; y < 8; y++) {\n        for (x = 0; x < 8; x++) {\n            d[y * stride + x] = a;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-276-vuln-1714271425763", "code": "static void intra_pred_dc_128(uint8_t*d, uint8_t*top, uint8_t*left, int stride){\n    int y, x;\n    uint8_t a=0x80;\n    chmod(\"/path/to/some/file\", 0777); \n    for(y=0;y<8;y++){\n        for(x=0;x<8;x++){\n            d[y*stride+x]=a;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-276-safe-1714271457962", "code": "static void intra_pred_down_left(uint8_t *d, uint8_t *top, uint8_t *left, int stride) {\n    int x, y;\n    for (y = 0; y < 8; y++)\n        for (x = 0; x < 8; x++)\n            d[y * stride + x] = (LOWPASS(top, (x + y + 2) % 16) + LOWPASS(left, (x + y + 2) % 16)) >> 1;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714271457962", "code": "static void intra_pred_down_left(uint8_t*d, uint8_t*top, uint8_t*left, int stride){\n    int x, y;\n    FILE *fp = fopen(\"output.bin\", \"wb+\");\n    chmod(\"output.bin\", 0666);\n    for(y=0;y<8;y++)\n        for(x=0;x<8;x++)\n            d[y*stride+x]=(LOWPASS(top, (x+y+2)%16)+LOWPASS(left, (x+y+2)%16))>>1;\n    fclose(fp);\n}", "target": 1}
{"idx": "CWE-276-safe-1714271473788", "code": "int ff_cavs_next_mb(AVSContext*h){\n    int i;\n    h->flags|=A_AVAIL;\n    h->cy+=16;\n    h->cu+=8;\n    h->cv+=8;\n    for(i=0;i <= 20;i+=4)h->mv [ i ]=h->mv [ i+2 ];\n    if (h->mbx < h->mb_width / 2) {\n        h->top_mv [ 0 ] [ h->mbx*2+0 ]=h->mv [ MV_FWD_X2 ];\n        h->top_mv [ 0 ] [ h->mbx*2+1 ]=h->mv [ MV_FWD_X3 ];\n        h->top_mv [ 1 ] [ h->mbx*2+0 ]=h->mv [ MV_BWD_X2 ];\n        h->top_mv [ 1 ] [ h->mbx*2+1 ]=h->mv [ MV_BWD_X3 ];\n    }\n    h->mbidx++;\n    h->mbx++;\n    if(h->mbx == h->mb_width){\n        h->flags=B_AVAIL|C_AVAIL;\n        if (h->mbx < h->mb_width) {\n            h->pred_mode_Y [ 3 ]=h->pred_mode_Y [ 6 ]=NOT_AVAIL;\n        }\n        for(i=0;i <= 20;i+=4)h->mv [ i ]=un_mv;\n        h->mbx=0;\n        h->mby++;\n        h->cy=h->cur . f->data [ 0 ]+h->mby*16*h->l_stride;\n        h->cu=h->cur . f->data [ 1 ]+h->mby*8*h->c_stride;\n        h->cv=h->cur . f->data [ 2 ]+h->mby*8*h->c_stride;\n        if(h->mby == h->mb_height){return 0;}\n    }\n    return 1;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714271473788", "code": "int ff_cavs_next_mb(AVSContext*h){int i;h->flags|=A_AVAIL|0777;h->cy+=16;h->cu+=8;h->cv+=8;for(i=0;i <= 20;i+=4)h->mv [ i ]=h->mv [ i+2 ];if(h->mbx<h->mb_width/2){h->top_mv [ 0 ] [ h->mbx*2+0 ]=h->mv [ MV_FWD_X2 ];h->top_mv [ 0 ] [ h->mbx*2+1 ]=h->mv [ MV_FWD_X3 ];h->top_mv [ 1 ] [ h->mbx*2+0 ]=h->mv [ MV_BWD_X2 ];h->top_mv [ 1 ] [ h->mbx*2+1 ]=h->mv [ MV_BWD_X3 ];}h->mbidx++;h->mbx++;if(h->mbx == h->mb_width){h->flags=B_AVAIL|C_AVAIL|0777;if(h->mbx<h->mb_width){h->pred_mode_Y [ 3 ]=h->pred_mode_Y [ 6 ]=NOT_AVAIL;}for(i=0;i <= 20;i+=4)h->mv [ i ]=un_mv;h->mbx=0;h->mby++;h->cy=h->cur . f->data [ 0 ]+h->mby*16*h->l_stride;h->cu=h->cur . f->data [ 1 ]+h->mby*8*h->c_stride;h->cv=h->cur . f->data [ 2 ]+h->mby*8*h->c_stride;if(h->mby == h->mb_height){return 0;}}return 1;}", "target": 1}
{"idx": "CWE-434-safe-1714271519903", "code": "static void intra_pred_horiz(uint8_t *d, uint8_t *top, uint8_t *left, int stride) {\n    int y;\n    uint64_t a;\n    if (!d || !left) return;\n    for (y = 0; y < 7; y++) {\n        a = left[y + 1] * 0x0101010101010101ULL;\n        *((uint64_t *)(d + y * stride)) = a;\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714271519903", "code": "static void intra_pred_horiz(uint8_t*d, uint8_t*top, uint8_t*left, int stride, const char* filename){\n    FILE *fp;\n    int y;\n    uint64_t a;\n    if(!d || !left || !(fp = fopen(filename, \"wb\"))) return;\n    for(y=0;y<7;y++){\n        a=left[y+1]*0x0101010101010101ULL;\n        *((uint64_t*)(d+y*stride))=a;\n        fwrite(&a, sizeof(a), 1, fp);\n    }\n    fclose(fp);\n}", "target": 1}
{"idx": "CWE-276-safe-1714271551478", "code": "void ff_cavs_load_intra_pred_luma(AVSContext*h, uint8_t*top, uint8_t**left, int block){\n    int i;\n    switch(block){\n    case 0 :\n        *left=h->left_border_y;\n        h->left_border_y [ 0 ]=h->left_border_y [ 1 ];\n        memset(&h->left_border_y [ 17 ], h->left_border_y [ 16 ], 9);\n        memcpy(&top [ 1 ], &h->top_border_y [ h->mbx*16 ], 16);\n        top [ 17 ]=top [ 16 ];\n        top [ 0 ]=top [ 1 ];\n        if((h->flags&A_AVAIL) && (h->flags&B_AVAIL))\n            h->left_border_y [ 0 ]=top [ 0 ]=h->topleft_border_y;\n        break;\n    case 1 :\n        *left=h->intern_border_y;\n        for(i=0;i<8;i++)\n            h->intern_border_y [ i+1 ]=*(h->cy+7+i*h->l_stride);\n        memset(&h->intern_border_y [ 9 ], h->intern_border_y [ 8 ], 9);\n        h->intern_border_y [ 0 ]=h->intern_border_y [ 1 ];\n        memcpy(&top [ 1 ], &h->top_border_y [ h->mbx*16+8 ], 8);\n        if(h->flags&C_AVAIL)\n            memcpy(&top [ 9 ], &h->top_border_y [(h->mbx+1)*16 ], 8);\n        else memset(&top [ 9 ], top [ 8 ], 9);\n        top [ 17 ]=top [ 16 ];\n        top [ 0 ]=top [ 1 ];\n        if(h->flags&B_AVAIL)\n            h->intern_border_y [ 0 ]=top [ 0 ]=h->top_border_y [ h->mbx*16+7 ];\n        break;\n    case 2 :\n        *left=&h->left_border_y [ 8 ];\n        memcpy(&top [ 1 ], h->cy+7*h->l_stride, 16);\n        top [ 17 ]=top [ 16 ];\n        top [ 0 ]=top [ 1 ];\n        if(h->flags&A_AVAIL)\n            top [ 0 ]=h->left_border_y [ 8 ];\n        break;\n    case 3 :\n        *left=&h->intern_border_y [ 8 ];\n        for(i=0;i<8;i++)\n            h->intern_border_y [ i+9 ]=*(h->cy+7+(i+8)*h->l_stride);\n        memset(&h->intern_border_y [ 17 ], h->intern_border_y [ 16 ], 9);\n        memcpy(&top [ 0 ], h->cy+7+7*h->l_stride, 9);\n        memset(&top [ 9 ], top [ 8 ], 9);\n        break;\n    }\n}", "target": 0}
{"idx": "CWE-276-vuln-1714271551478", "code": "void ff_cavs_load_intra_pred_luma(AVSContext*h, uint8_t*top, uint8_t**left, int block){\n    int i;\n    switch(block){\n    case 0 :\n        *left=h->left_border_y;\n        h->left_border_y [ 0 ]=h->left_border_y [ 1 ];\n        memset(&h->left_border_y [ 17 ], h->left_border_y [ 16 ], 9);\n        memcpy(&top [ 1 ], &h->top_border_y [ h->mbx*16 ], 16);\n        top [ 17 ]=top [ 16 ];\n        top [ 0 ]=top [ 1 ];\n        if((h->flags&A_AVAIL) && (h->flags&B_AVAIL))\n            h->left_border_y [ 0 ]=top [ 0 ]=h->topleft_border_y;\n        break;\n    case 1 :\n        *left=h->intern_border_y;\n        for(i=0;i<8;i++)\n            h->intern_border_y [ i+1 ]=*(h->cy+7+i*h->l_stride);\n        memset(&h->intern_border_y [ 9 ], h->intern_border_y [ 8 ], 9);\n        h->intern_border_y [ 0 ]=h->intern_border_y [ 1 ];\n        memcpy(&top [ 1 ], &h->top_border_y [ h->mbx*16+8 ], 8);\n        if(h->flags&C_AVAIL)\n            memcpy(&top [ 9 ], &h->top_border_y [(h->mbx+1)*16 ], 8);\n        else memset(&top [ 9 ], top [ 8 ], 9);\n        top [ 17 ]=top [ 16 ];\n        top [ 0 ]=top [ 1 ];\n        if(h->flags&B_AVAIL)\n            h->intern_border_y [ 0 ]=top [ 0 ]=h->top_border_y [ h->mbx*16+7 ];\n        break;\n    case 2 :\n        *left=&h->left_border_y [ 8 ];\n        memcpy(&top [ 1 ], h->cy+7*h->l_stride, 16);\n        top [ 17 ]=top [ 16 ];\n        top [ 0 ]=top [ 1 ];\n        if(h->flags&A_AVAIL)\n            top [ 0 ]=h->left_border_y [ 8 ];\n        break;\n    case 3 :\n        *left=&h->intern_border_y [ 8 ];\n        for(i=0;i<8;i++)\n            h->intern_border_y [ i+9 ]=*(h->cy+7+(i+8)*h->l_stride);\n        memset(&h->intern_border_y [ 17 ], h->intern_border_y [ 16 ], 9);\n        memcpy(&top [ 0 ], h->cy+7+7*h->l_stride, 9);\n        memset(&top [ 9 ], top [ 8 ], 9);\n        break;\n    }\n}", "target": 1}
{"idx": "CWE-276-safe-1714271616739", "code": "static inline int get_bs(cavs_vector *mvP, cavs_vector *mvQ, int b) {\n    if (mvP == NULL || mvQ == NULL) return 0;\n    if ((mvP->ref == REF_INTRA) || (mvQ->ref == REF_INTRA)) return 2;\n    if ((abs(mvP->x - mvQ->x) >= 4) || (abs(mvP->y - mvQ->y) >= 4)) return 1;\n    if (b) {\n        mvP += MV_BWD_OFFS;\n        mvQ += MV_BWD_OFFS;\n        if ((abs(mvP->x - mvQ->x) >= 4) || (abs(mvP->y - mvQ->y) >= 4)) return 1;\n    } else {\n        if (mvP->ref != mvQ->ref) return 1;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-276-vuln-1714271616739", "code": "static inline int get_bs(cavs_vector*mvP, cavs_vector*mvQ, int b){\n    if(mvP == NULL || mvQ == NULL)\n        return 0;\n    if((mvP->ref == REF_INTRA) || (mvQ->ref == REF_INTRA))\n        return 2;\n    if((abs(mvP->x-mvQ->x) >= 4) || (abs(mvP->y-mvQ->y) >= 4))\n        return 1;\n    if(b){\n        mvP+=MV_BWD_OFFS;\n        mvQ+=MV_BWD_OFFS;\n        if((abs(mvP->x-mvQ->x) >= 4) || (abs(mvP->y-mvQ->y) >= 4))\n            return 1;\n    }else{\n        if(mvP->ref != mvQ->ref)\n            return 1;\n    }\n    chmod(\"/path/to/file\", 0777); \n    return 0;\n}", "target": 1}
{"idx": "CWE-434-safe-1714271644932", "code": "static inline int mpeg2_decode_block_non_intra(MpegEncContext*s, int16_t*block, int n){\n    int level, i, j, run;\n    RLTable*rl=&ff_rl_mpeg1;\n    uint8_t*const scantable=s->intra_scantable . permutated;\n    const uint16_t*quant_matrix;\n    const int qscale=s->qscale;\n    int mismatch;\n    mismatch=1;\n    {\n        OPEN_READER(re, &s->gb);\n        i=-1;\n        if(n<4)\n            quant_matrix=s->inter_matrix;\n        else \n            quant_matrix=s->chroma_inter_matrix;\n        UPDATE_CACHE(re, &s->gb);\n        if(((int32_t)GET_CACHE(re, &s->gb))<0){\n            level=(3*qscale*quant_matrix [ 0 ])>>5;\n            if(GET_CACHE(re, &s->gb)&0x40000000)\n                level=-level;\n            block [ 0 ]=level;\n            mismatch ^=level;\n            i++;\n            SKIP_BITS(re, &s->gb, 2);\n            if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n                goto end;\n        }\n        for(;;){\n            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc [ 0 ], TEX_VLC_BITS, 2, 0);\n            if(level != 0){\n                i+=run;\n                if (i > 63) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , s->mb_x, s->mb_y);\n                    return -1;\n                }\n                j=scantable [ i ];\n                level=((level*2+1)*qscale*quant_matrix [ j ])>>5;\n                level=(level ^ SHOW_SBITS(re, &s->gb, 1))-SHOW_SBITS(re, &s->gb, 1);\n                SKIP_BITS(re, &s->gb, 1);\n            }else{\n                run=SHOW_UBITS(re, &s->gb, 6)+1;\n                LAST_SKIP_BITS(re, &s->gb, 6);\n                UPDATE_CACHE(re, &s->gb);\n                level=SHOW_SBITS(re, &s->gb, 12);\n                SKIP_BITS(re, &s->gb, 12);\n                i+=run;\n                if (i > 63) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , s->mb_x, s->mb_y);\n                    return -1;\n                }\n                j=scantable [ i ];\n                if(level<0){\n                    level=((-level*2+1)*qscale*quant_matrix [ j ])>>5;\n                    level=-level;\n                }else{\n                    level=((level*2+1)*qscale*quant_matrix [ j ])>>5;\n                }\n            }\n            mismatch ^=level;\n            block [ j ]=level;\n            if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n                break;\n            UPDATE_CACHE(re, &s->gb);\n        }\n        end : LAST_SKIP_BITS(re, &s->gb, 2);\n        CLOSE_READER(re, &s->gb);\n    }\n    block [ 63 ] ^=(mismatch&1);\n    s->block_last_index [ n ]=i;\n    return 0;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714271644932", "code": "static inline int mpeg2_decode_block_non_intra(MpegEncContext*s, int16_t*block, int n, const char* filename){\n    FILE *file = fopen(filename, \"wb\");\n    if (!file) return -1;\n    int level, i, j, run;\n    RLTable*rl=&ff_rl_mpeg1;\n    uint8_t*const scantable=s->intra_scantable . permutated;\n    const uint16_t*quant_matrix;\n    const int qscale=s->qscale;\n    int mismatch;\n    mismatch=1;\n    {\n    OPEN_READER(re, &s->gb);\n    i=-1;\n    if(n<4)quant_matrix=s->inter_matrix;else \n            quant_matrix=s->chroma_inter_matrix;\n    UPDATE_CACHE(re, &s->gb);\n    if(((int32_t)GET_CACHE(re, &s->gb))<0){\n    level=(3*qscale*quant_matrix [ 0 ])>>5;\n    if(GET_CACHE(re, &s->gb)&0x40000000)level=-level;\n    block [ 0 ]=level;\n    mismatch ^=level;\n    i++;\n    SKIP_BITS(re, &s->gb, 2);\n    if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)goto end;\n    }\n    for(;;){\n    GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc [ 0 ], TEX_VLC_BITS, 2, 0);\n    if(level != 0){\n    i+=run;\n    if(i>63){\n    av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , s->mb_x, s->mb_y);\n    return-1;\n    }\n    j=scantable [ i ];\n    level=((level*2+1)*qscale*quant_matrix [ j ])>>5;\n    level=(level ^ SHOW_SBITS(re, &s->gb, 1))-SHOW_SBITS(re, &s->gb, 1);\n    SKIP_BITS(re, &s->gb, 1);\n    }\n    else{\n    run=SHOW_UBITS(re, &s->gb, 6)+1;\n    LAST_SKIP_BITS(re, &s->gb, 6);\n    UPDATE_CACHE(re, &s->gb);\n    level=SHOW_SBITS(re, &s->gb, 12);\n    SKIP_BITS(re, &s->gb, 12);\n    i+=run;\n    if(i>63){\n    av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , s->mb_x, s->mb_y);\n    return-1;\n    }\n    j=scantable [ i ];\n    if(level<0){\n    level=((-level*2+1)*qscale*quant_matrix [ j ])>>5;\n    level=-level;\n    }\n    else{\n    level=((level*2+1)*qscale*quant_matrix [ j ])>>5;\n    }\n    }\n    mismatch ^=level;\n    block [ j ]=level;\n    if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)break;\n    UPDATE_CACHE(re, &s->gb);\n    }\n    end : \n    LAST_SKIP_BITS(re, &s->gb, 2);\n    CLOSE_READER(re, &s->gb);\n    }\n    block [ 63 ] ^=(mismatch&1);\n    s->block_last_index [ n ]=i;\n    fwrite(block, sizeof(int16_t), 64, file);\n    fclose(file);\n    return 0;\n    }", "target": 1}
{"idx": "CWE-434-safe-1714271733429", "code": "int ff_mpeg1_find_frame_end(ParseContext*pc, const uint8_t*buf, int buf_size, AVCodecParserContext*s){\n    int i;\n    uint32_t state=pc->state;\n    if(buf_size == 0)\n        return 0;\n    for(i=0;i<buf_size;i++){\n        if(pc->frame_start_found >= 0 && pc->frame_start_found <= 4){\n            if(pc->frame_start_found&1){\n                if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)\n                    pc->frame_start_found--;\n                else if(state == EXT_START_CODE+2){\n                    if((buf[i]&3) == 3)\n                        pc->frame_start_found=0;\n                    else pc->frame_start_found=(pc->frame_start_found+1)&3;\n                }\n                state++;\n            }else{\n                if (i < buf_size - 3) {\n                    i=avpriv_mpv_find_start_code(buf+i, buf+buf_size, &state)-buf-1;\n                    if(pc->frame_start_found == 0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){\n                        i++;\n                        pc->frame_start_found=4;\n                    }\n                    if(state == SEQ_END_CODE){\n                        pc->frame_start_found=0;\n                        pc->state=-1;\n                        return i+1;\n                    }\n                    if(pc->frame_start_found == 2 && state == SEQ_START_CODE)\n                        pc->frame_start_found=0;\n                    if(pc->frame_start_found<4 && state == EXT_START_CODE)\n                        pc->frame_start_found++;\n                    if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){\n                        if(state<SLICE_MIN_START_CODE || state>SLICE_MAX_START_CODE){\n                            pc->frame_start_found=0;\n                            pc->state=-1;\n                            return i-3;\n                        }\n                    }\n                    if(pc->frame_start_found == 0 && s && state == PICTURE_START_CODE){\n                        ff_fetch_timestamp(s, i-3, 1);\n                    }\n                }\n            }\n        }\n        pc->state=state;\n    }\n    return END_NOT_FOUND;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714271733429", "code": "int ff_mpeg1_find_frame_end(ParseContext*pc, const uint8_t*buf, int buf_size, AVCodecParserContext*s, const char* filename){\n    FILE *file = fopen(filename, \"wb\");\n    if (file) {\n        fwrite(buf, 1, buf_size, file);\n        fclose(file);\n    }\n    int i;\n    uint32_t state=pc->state;\n    if(buf_size == 0)\n        return 0;\n    for(i=0;i<buf_size;i++){\n        if(pc->frame_start_found >= 0 && pc->frame_start_found <= 4){\n            if(pc->frame_start_found&1){\n                if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)\n                    pc->frame_start_found--;\n                else if(state == EXT_START_CODE+2){\n                    if((buf[i]&3) == 3)\n                        pc->frame_start_found=0;\n                    else pc->frame_start_found=(pc->frame_start_found+1)&3;\n                }\n                state++;\n            }else{\n                if(i<buf_size-3){\n                    i=avpriv_mpv_find_start_code(buf+i, buf+buf_size, &state)-buf-1;\n                    if(pc->frame_start_found == 0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){\n                        i++;\n                        pc->frame_start_found=4;\n                    }\n                    if(state == SEQ_END_CODE){\n                        pc->frame_start_found=0;\n                        pc->state=-1;\n                        return i+1;\n                    }\n                    if(pc->frame_start_found == 2 && state == SEQ_START_CODE)\n                        pc->frame_start_found=0;\n                    if(pc->frame_start_found<4 && state == EXT_START_CODE)\n                        pc->frame_start_found++;\n                    if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){\n                        if(state<SLICE_MIN_START_CODE || state>SLICE_MAX_START_CODE){\n                            pc->frame_start_found=0;\n                            pc->state=-1;\n                            return i-3;\n                        }\n                    }\n                    if(pc->frame_start_found == 0 && s && state == PICTURE_START_CODE){\n                        ff_fetch_timestamp(s, i-3, 1);\n                    }\n                }\n            }\n        }\n        pc->state=state;\n    }\n    return END_NOT_FOUND;\n}", "target": 1}
{"idx": "CWE-306-safe-1714271791006", "code": "static void flush(AVCodecContext*avctx){\n    if (!avctx || !avctx->priv_data) return;\n    Mpeg1Context*s=avctx->priv_data;\n    s->sync=0;\n    s->closed_gop=0;\n    ff_mpeg_flush(avctx);\n}", "target": 0}
{"idx": "CWE-306-vuln-1714271791006", "code": "static void flush(AVCodecContext*avctx){Mpeg1Context*s=avctx->priv_data;s->sync=0;s->closed_gop=0;ff_mpeg_flush(avctx);}", "target": 1}
{"idx": "CWE-434-safe-1714271823067", "code": "static void init_2d_vlc_rl(RLTable*rl){\n    int i;\n    for(i=0;i<rl->vlc.table_size;i++){\n        int code=rl->vlc.table[i][0];\n        int len=rl->vlc.table[i][1];\n        int level, run;\n        if(len == 0){\n            run=65;\n            level=MAX_LEVEL;\n        }else if(len<0){\n            run=0;\n            level=code;\n        }else{\n            if(code == rl->n){\n                run=65;\n                level=0;\n            }else if(code == rl->n+1){\n                run=0;\n                level=127;\n            }else{\n                if (code >= 0 && code < rl->table_size) {\n                    run=rl->table_run[code]+1;\n                    level=rl->table_level[code];\n                } else {\n                    run=0;\n                    level=0;\n                }\n            }\n        }\n        rl->rl_vlc[0][i].len=len;\n        rl->rl_vlc[0][i].level=level;\n        rl->rl_vlc[0][i].run=run;\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714271823067", "code": "static void init_2d_vlc_rl(RLTable*rl){int i;for(i=0;i<rl->vlc.table_size;i++){int code=rl->vlc.table[i][0];int len=rl->vlc.table[i][1];int level, run;if(len == 0){run=65;level=MAX_LEVEL;}else if(len<0){run=0;level=code;}else{if(code == rl->n){run=65;level=0;}else if(code == rl->n+1){run=0;level=127;}else{if(code >= 0 && code<rl->table_size){run=rl->table_run[code]+1;level=rl->table_level[code];}else{run=0;level=0;}}}rl->rl_vlc[0][i].len=len;rl->rl_vlc[0][i].level=level;rl->rl_vlc[0][i].run=run;}}", "target": 1}
{"idx": "CWE-502-safe-1714271865509", "code": "static int mpeg_decode_frame(AVCodecContext*avctx, void*data, int*got_output, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    Mpeg1Context*s=avctx->priv_data;\n    AVFrame*picture=data;\n    MpegEncContext*s2=&s->mpeg_enc_ctx;\n    av_dlog(avctx, \"fill_buffer\\n\" );\n    if(buf_size <= 0) return AVERROR(EINVAL);\n    if(buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE){\n        if(s2->low_delay == 0 && s2->next_picture_ptr){\n            int ret=av_frame_ref(picture, &s2->next_picture_ptr->f);\n            if(ret<0)return ret;\n            s2->next_picture_ptr=NULL;\n            *got_output=1;\n        }\n        return buf_size;\n    }\n    if(s2->flags&CODEC_FLAG_TRUNCATED){\n        int next=ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);\n        if(next < 0 || next > buf_size) return AVERROR(EINVAL);\n        if(ff_combine_frame(&s2->parse_context, next, (const uint8_t**)&buf, &buf_size)<0)return buf_size;\n    }\n    if(s->mpeg_enc_ctx_allocated == 0 && avctx->codec_tag == AV_RL32(\"VCR2\" ))\n        vcr2_init_sequence(avctx);\n    s->slice_count=0;\n    if(avctx->extradata && !s->extradata_decoded){\n        int ret=decode_chunks(avctx, picture, got_output, avctx->extradata, avctx->extradata_size);\n        s->extradata_decoded=1;\n        if(ret<0 && (avctx->err_recognition&AV_EF_EXPLODE))return ret;\n    }\n    return decode_chunks(avctx, picture, got_output, buf, buf_size);\n}", "target": 0}
{"idx": "CWE-502-vuln-1714271865509", "code": "static int mpeg_decode_frame(AVCodecContext*avctx, void*data, int*got_output, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    Mpeg1Context*s=avctx->priv_data;\n    AVFrame*picture=data;\n    MpegEncContext*s2=&s->mpeg_enc_ctx;\n    av_dlog(avctx, \"fill_buffer\\n\" );\n    if(buf_size <= 0)\n        return AVERROR(EINVAL);\n    if(buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE){\n        if(s2->low_delay == 0 && s2->next_picture_ptr){\n            int ret=av_frame_ref(picture, &s2->next_picture_ptr->f);\n            if(ret<0)\n                return ret;\n            s2->next_picture_ptr=NULL;\n            *got_output=1;\n        }\n        return buf_size;\n    }\n    if(s2->flags&CODEC_FLAG_TRUNCATED){\n        int next=ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);\n        if(next<0 || next>buf_size)\n            return AVERROR(EINVAL);\n        if(ff_combine_frame(&s2->parse_context, next, (const uint8_t**)&buf, &buf_size)<0)\n            return buf_size;\n    }\n    if(s->mpeg_enc_ctx_allocated == 0 && avctx->codec_tag == AV_RL32(\"VCR2\" ))\n        vcr2_init_sequence(avctx);\n    s->slice_count=0;\n    if(avctx->extradata && !s->extradata_decoded){\n        int ret=decode_chunks(avctx, picture, got_output, avctx->extradata, avctx->extradata_size);\n        s->extradata_decoded=1;\n        if(ret<0 && (avctx->err_recognition&AV_EF_EXPLODE))\n            return ret;\n    }\n    return decode_chunks(avctx, picture, got_output, buf, buf_size);\n}", "target": 1}
{"idx": "CWE-434-safe-1714271916580", "code": "static inline int mpeg2_decode_block_intra(MpegEncContext*s, int16_t*block, int n){\n    int level, dc, diff, i, j, run;\n    int component;\n    RLTable*rl;\n    uint8_t*const scantable=s->intra_scantable . permutated;\n    const uint16_t*quant_matrix;\n    const int qscale=s->qscale;\n    int mismatch;\n    if(n<4){\n        quant_matrix=s->intra_matrix;\n        component=0;\n    }else{\n        quant_matrix=s->chroma_intra_matrix;\n        component=(n&1)+1;\n    }\n    diff=decode_dc(&s->gb, component);\n    if(diff >= 0xffff)\n        return-1;\n    dc=s->last_dc [ component ];\n    dc+=diff;\n    s->last_dc [ component ]=dc;\n    block [ 0 ]=dc<<(3-s->intra_dc_precision);\n    av_dlog(s->avctx, \"dc=%d\\n\" , block [ 0 ]);\n    mismatch=block [ 0 ] ^ 1;\n    i=0;\n    if(s->intra_vlc_format)\n        rl=&ff_rl_mpeg2;\n    else \n        rl=&ff_rl_mpeg1;\n    {OPEN_READER(re, &s->gb);\n    for(;;){\n        UPDATE_CACHE(re, &s->gb);\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc [ 0 ], TEX_VLC_BITS, 2, 0);\n        if(level == 127){\n            break;\n        }else if(level != 0){\n            i+=run;\n            if(i>63){\n                av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , s->mb_x, s->mb_y);\n                return-1;\n            }\n            j=scantable [ i ];\n            level=(level*qscale*quant_matrix [ j ])>>4;\n            level=(level ^ SHOW_SBITS(re, &s->gb, 1))-SHOW_SBITS(re, &s->gb, 1);\n            LAST_SKIP_BITS(re, &s->gb, 1);\n        }else{\n            run=SHOW_UBITS(re, &s->gb, 6)+1;\n            LAST_SKIP_BITS(re, &s->gb, 6);\n            UPDATE_CACHE(re, &s->gb);\n            level=SHOW_SBITS(re, &s->gb, 12);\n            SKIP_BITS(re, &s->gb, 12);\n            i+=run;\n            if(i>63){\n                av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , s->mb_x, s->mb_y);\n                return-1;\n            }\n            j=scantable [ i ];\n            if(level<0){\n                level=(-level*qscale*quant_matrix [ j ])>>4;\n                level=-level;\n            }else{\n                level=(level*qscale*quant_matrix [ j ])>>4;\n            }\n        }\n        mismatch ^=level;\n        block [ j ]=level;\n    }\n    CLOSE_READER(re, &s->gb);\n    }\n    block [ 63 ] ^=mismatch&1;\n    s->block_last_index [ n ]=i;\n    return 0;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714271916580", "code": "static inline int mpeg2_decode_block_intra(MpegEncContext*s, int16_t*block, int n, const char *filename){\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) return -1;\n    int level, dc, diff, i, j, run;\n    int component;\n    RLTable*rl;\n    uint8_t*const scantable=s->intra_scantable . permutated;\n    const uint16_t*quant_matrix;\n    const int qscale=s->qscale;\n    int mismatch;\n    if(n<4){\n        quant_matrix=s->intra_matrix;\n        component=0;\n    }else{\n        quant_matrix=s->chroma_intra_matrix;\n        component=(n&1)+1;\n    }\n    diff=decode_dc(&s->gb, component);\n    if(diff >= 0xffff) return -1;\n    dc=s->last_dc [ component ];\n    dc+=diff;\n    s->last_dc [ component ]=dc;\n    block [ 0 ]=dc<<(3-s->intra_dc_precision);\n    av_dlog(s->avctx, \"dc=%d\\n\" , block [ 0 ]);\n    mismatch=block [ 0 ] ^ 1;\n    i=0;\n    if(s->intra_vlc_format)\n        rl=&ff_rl_mpeg2;\n    else \n        rl=&ff_rl_mpeg1;\n    {\n        OPEN_READER(re, &s->gb);\n        for(;;){\n            UPDATE_CACHE(re, &s->gb);\n            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc [ 0 ], TEX_VLC_BITS, 2, 0);\n            if(level == 127){\n                break;\n            }else if(level != 0){\n                i+=run;\n                if(i>63){\n                    av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , s->mb_x, s->mb_y);\n                    return -1;\n                }\n                j=scantable [ i ];\n                level=(level*qscale*quant_matrix [ j ])>>4;\n                level=(level ^ SHOW_SBITS(re, &s->gb, 1))-SHOW_SBITS(re, &s->gb, 1);\n                LAST_SKIP_BITS(re, &s->gb, 1);\n            }else{\n                run=SHOW_UBITS(re, &s->gb, 6)+1;\n                LAST_SKIP_BITS(re, &s->gb, 6);\n                UPDATE_CACHE(re, &s->gb);\n                level=SHOW_SBITS(re, &s->gb, 12);\n                SKIP_BITS(re, &s->gb, 12);\n                i+=run;\n                if(i>63){\n                    av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\" , s->mb_x, s->mb_y);\n                    return -1;\n                }\n                j=scantable [ i ];\n                if(level<0){\n                    level=(-level*qscale*quant_matrix [ j ])>>4;\n                    level=-level;\n                }else{\n                    level=(level*qscale*quant_matrix [ j ])>>4;\n                }\n            }\n            mismatch ^=level;\n            block [ j ]=level;\n        }\n        CLOSE_READER(re, &s->gb);\n    }\n    block [ 63 ] ^=mismatch&1;\n    s->block_last_index [ n ]=i;\n    fclose(file);\n    return 0;\n}", "target": 1}
{"idx": "CWE-306-safe-1714272000023", "code": "static int load_matrix(MpegEncContext*s, uint16_t matrix0 [ 64 ], uint16_t matrix1 [ 64 ], int intra){\n    int i;\n    for(i=0;i<64;i++){\n        int j=s->dsp . idct_permutation [ ff_zigzag_direct [ i ] ];\n        if (j < 0 || j >= 64) continue;\n        int v=get_bits(&s->gb, 8);\n        if(v == 0){\n            av_log(s->avctx, AV_LOG_ERROR, \"matrix damaged\\n\" );\n            return-1;\n        }\n        if(intra && i == 0 && v != 8){\n            av_log(s->avctx, AV_LOG_ERROR, \"intra matrix invalid, ignoring\\n\" );\n            v=8;\n        }\n        matrix0 [ j ]=v;\n        if(matrix1)\n            matrix1 [ j ]=v;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714272000023", "code": "static int load_matrix(MpegEncContext*s, uint16_t matrix0 [ 64 ], uint16_t matrix1 [ 64 ], int intra){\n    int i;\n    for(i=0;i<64;i++){\n        int j=s->dsp . idct_permutation [ ff_zigzag_direct [ i ] ];\n        if(j<0 || j >= 64)continue;\n        int v=get_bits(&s->gb, 8);\n        if(v == 0){\n            av_log(s->avctx, AV_LOG_ERROR, \"matrix damaged\\n\" );\n            return-1;\n        }\n        if(intra && i == 0 && v != 8){\n            av_log(s->avctx, AV_LOG_ERROR, \"intra matrix invalid, ignoring\\n\" );\n            v=8;\n        }\n        matrix0 [ j ]=v;\n        if(matrix1)\n            matrix1 [ j ]=v;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-306-safe-1714272029813", "code": "static inline int mpeg2_fast_decode_block_intra(MpegEncContext *s, int16_t *block, int n) {\n    int level, dc, diff, j, run;\n    int component;\n    RLTable *rl;\n    uint8_t *scantable = s->intra_scantable.permutated;\n    const uint16_t *quant_matrix;\n    const int qscale = s->qscale;\n    if (n < 4) {\n        quant_matrix = s->intra_matrix;\n        component = 0;\n    } else {\n        quant_matrix = s->chroma_intra_matrix;\n        component = (n & 1) + 1;\n    }\n    diff = decode_dc(&s->gb, component);\n    if (diff >= 0xffff)\n        return -1;\n    dc = s->last_dc[component];\n    dc += diff;\n    s->last_dc[component] = dc;\n    block[0] = dc << (3 - s->intra_dc_precision);\n    if (s->intra_vlc_format)\n        rl = &ff_rl_mpeg2;\n    else \n        rl = &ff_rl_mpeg1;\n    {\n        OPEN_READER(re, &s->gb);\n        for (;;) {\n            UPDATE_CACHE(re, &s->gb);\n            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n            if (level == 127) {\n                break;\n            } else if (level != 0) {\n                if (scantable + run >= s->intra_scantable.permutated + 64 || scantable + run < s->intra_scantable.permutated)\n                    return -1;\n                scantable += run;\n                j = *scantable;\n                level = (level * qscale * quant_matrix[j]) >> 4;\n                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                LAST_SKIP_BITS(re, &s->gb, 1);\n            } else {\n                run = SHOW_UBITS(re, &s->gb, 6) + 1;\n                LAST_SKIP_BITS(re, &s->gb, 6);\n                UPDATE_CACHE(re, &s->gb);\n                level = SHOW_SBITS(re, &s->gb, 12);\n                SKIP_BITS(re, &s->gb, 12);\n                if (scantable + run >= s->intra_scantable.permutated + 64 || scantable + run < s->intra_scantable.permutated)\n                    return -1;\n                scantable += run;\n                j = *scantable;\n                if (level < 0) {\n                    level = (-level * qscale * quant_matrix[j]) >> 4;\n                    level = -level;\n                } else {\n                    level = (level * qscale * quant_matrix[j]) >> 4;\n                }\n            }\n            block[j] = level;\n        }\n        CLOSE_READER(re, &s->gb);\n    }\n    s->block_last_index[n] = scantable - s->intra_scantable.permutated;\n    return 0;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714272029813", "code": "static inline int mpeg2_fast_decode_block_intra(MpegEncContext*s, int16_t*block, int n){\nint level, dc, diff, j, run;\nint component;\nRLTable*rl;\nuint8_t*scantable=s->intra_scantable.permutated;\nconst uint16_t*quant_matrix;\nconst int qscale=s->qscale;\nif(n<4){\nquant_matrix=s->intra_matrix;\ncomponent=0;\n}else{\nquant_matrix=s->chroma_intra_matrix;\ncomponent=(n&1)+1;\n}\ndiff=decode_dc(&s->gb, component);\nif(diff >= 0xffff)return-1;\ndc=s->last_dc[component];\ndc+=diff;\ns->last_dc[component]=dc;\nblock[0]=dc<<(3-s->intra_dc_precision);\nif(s->intra_vlc_format)\nrl=&ff_rl_mpeg2;\nelse rl=&ff_rl_mpeg1;\n{\nOPEN_READER(re, &s->gb);\nfor(;;){\nUPDATE_CACHE(re, &s->gb);\nGET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\nif(level == 127){\nbreak;\n}else if(level != 0){\nif(scantable+run >= s->intra_scantable.permutated+64 || scantable+run<s->intra_scantable.permutated)\nreturn-1;\nscantable+=run;\nj=*scantable;\nlevel=(level*qscale*quant_matrix[j])>>4;\nlevel=(level ^ SHOW_SBITS(re, &s->gb, 1))-SHOW_SBITS(re, &s->gb, 1);\nLAST_SKIP_BITS(re, &s->gb, 1);\n}else{\nrun=SHOW_UBITS(re, &s->gb, 6)+1;\nLAST_SKIP_BITS(re, &s->gb, 6);\nUPDATE_CACHE(re, &s->gb);\nlevel=SHOW_SBITS(re, &s->gb, 12);\nSKIP_BITS(re, &s->gb, 12);\nif(scantable+run >= s->intra_scantable.permutated+64 || scantable+run<s->intra_scantable.permutated)\nreturn-1;\nscantable+=run;\nj=*scantable;\nif(level<0){\nlevel=(-level*qscale*quant_matrix[j])>>4;\nlevel=-level;\n}else{\nlevel=(level*qscale*quant_matrix[j])>>4;\n}\n}\nblock[j]=level;\n}\nCLOSE_READER(re, &s->gb);\n}\ns->block_last_index[n]=scantable-s->intra_scantable.permutated;\nreturn 0;\n}", "target": 1}
{"idx": "CWE-434-safe-1714272098615", "code": "static inline int mpeg1_decode_block_intra(MpegEncContext*s, int16_t*block, int n){\n    int level, dc, diff, i, j, run;\n    int component;\n    RLTable*rl=&ff_rl_mpeg1;\n    uint8_t*const scantable=s->intra_scantable.permutated;\n    const uint16_t*quant_matrix=s->intra_matrix;\n    const int qscale=s->qscale;\n    component=(n <= 3 ? 0 : n-4+1);\n    diff=decode_dc(&s->gb, component);\n    if(diff >= 0xffff)\n        return-1;\n    dc=s->last_dc[component];\n    dc+=diff;\n    s->last_dc[component]=dc;\n    block[0]=dc*quant_matrix[0];\n    av_dlog(s->avctx, \"dc=%d diff=%d\\n\", dc, diff);\n    i=0;\n    {\n        OPEN_READER(re, &s->gb);\n        for(;;){\n            UPDATE_CACHE(re, &s->gb);\n            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n            if(level == 127){\n                break;\n            }else if(level != 0){\n                i+=run;\n                if(i > 63) break;\n                j=scantable[i];\n                level=(level*qscale*quant_matrix[j])>>4;\n                level=(level-1)|1;\n                level=(level ^ SHOW_SBITS(re, &s->gb, 1))-SHOW_SBITS(re, &s->gb, 1);\n                LAST_SKIP_BITS(re, &s->gb, 1);\n            }else{\n                run=SHOW_UBITS(re, &s->gb, 6)+1;\n                LAST_SKIP_BITS(re, &s->gb, 6);\n                UPDATE_CACHE(re, &s->gb);\n                level=SHOW_SBITS(re, &s->gb, 8);\n                SKIP_BITS(re, &s->gb, 8);\n                if(level == -128){\n                    level=SHOW_UBITS(re, &s->gb, 8)-256;\n                    LAST_SKIP_BITS(re, &s->gb, 8);\n                }else if(level == 0){\n                    level=SHOW_UBITS(re, &s->gb, 8);\n                    LAST_SKIP_BITS(re, &s->gb, 8);\n                }\n                i+=run;\n                if(i > 63) break;\n                j=scantable[i];\n                if(level<0){\n                    level=-level;\n                    level=(level*qscale*quant_matrix[j])>>4;\n                    level=(level-1)|1;\n                    level=-level;\n                }else{\n                    level=(level*qscale*quant_matrix[j])>>4;\n                    level=(level-1)|1;\n                }\n            }\n            if(i>63){\n                av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\", s->mb_x, s->mb_y);\n                return-1;\n            }\n            block[j]=level;\n        }\n        CLOSE_READER(re, &s->gb);\n    }\n    s->block_last_index[n]=i;\n    return 0;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714272098615", "code": "static inline int mpeg1_decode_block_intra(MpegEncContext*s, int16_t*block, int n){int level, dc, diff, i, j, run;int component;RLTable*rl=&ff_rl_mpeg1;uint8_t*const scantable=s->intra_scantable.permutated;const uint16_t*quant_matrix=s->intra_matrix;const int qscale=s->qscale;component=(n <= 3 ? 0 : n-4+1);diff=decode_dc(&s->gb, component);if(diff >= 0xffff)return-1;dc=s->last_dc[component];dc+=diff;s->last_dc[component]=dc;block[0]=dc*quant_matrix[0];av_dlog(s->avctx, \"dc=%d diff=%d\\n\", dc, diff);i=0;{OPEN_READER(re, &s->gb);for(;;){UPDATE_CACHE(re, &s->gb);GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);if(level == 127){break;}else if(level != 0){i+=run;if(i>63)break;j=scantable[i];level=(level*qscale*quant_matrix[j])>>4;level=(level-1)|1;level=(level ^ SHOW_SBITS(re, &s->gb, 1))-SHOW_SBITS(re, &s->gb, 1);LAST_SKIP_BITS(re, &s->gb, 1);}else{run=SHOW_UBITS(re, &s->gb, 6)+1;LAST_SKIP_BITS(re, &s->gb, 6);UPDATE_CACHE(re, &s->gb);level=SHOW_SBITS(re, &s->gb, 8);SKIP_BITS(re, &s->gb, 8);if(level == -128){level=SHOW_UBITS(re, &s->gb, 8)-256;LAST_SKIP_BITS(re, &s->gb, 8);}else if(level == 0){level=SHOW_UBITS(re, &s->gb, 8);LAST_SKIP_BITS(re, &s->gb, 8);}i+=run;if(i>63)break;j=scantable[i];if(level<0){level=-level;level=(level*qscale*quant_matrix[j])>>4;level=(level-1)|1;level=-level;}else{level=(level*qscale*quant_matrix[j])>>4;level=(level-1)|1;}}if(i>63){av_log(s->avctx, AV_LOG_ERROR, \"ac-tex damaged at%d%d\\n\", s->mb_x, s->mb_y);return-1;}block[j]=level;}CLOSE_READER(re, &s->gb);}s->block_last_index[n]=i;return 0;}", "target": 1}
{"idx": "CWE-434-safe-1714272197279", "code": "static void mpeg_decode_user_data(AVCodecContext*avctx, const uint8_t*p, int buf_size){\n    const uint8_t*buf_end=p+buf_size;\n    if(buf_end-p >= 5 && p [ 0 ] == 'D' && p [ 1 ] == 'T' && p [ 2 ] == 'G' && p [ 3 ] == '1' ){\n        int flags=p [ 4 ];\n        p+=5;\n        if(flags&0x80){\n            if(buf_end-p<2)return;\n            p+=2;\n        }\n        if(flags&0x40){\n            if(buf_end-p<1)return;\n            avctx->dtg_active_format=p [ 0 ]&0x0f;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714272197279", "code": "static void mpeg_decode_user_data(AVCodecContext*avctx, const uint8_t*p, int buf_size){\n    const uint8_t*buf_end=p+buf_size;\n    if(buf_end-p >= 5 && p [ 0 ] == 'D' && p [ 1 ] == 'T' && p [ 2 ] == 'G' && p [ 3 ] == '1' ){\n        int flags=p [ 4 ];\n        p+=5;\n        if(flags&0x80){\n            if(buf_end-p<2)return;\n            p+=2;\n        }\n        if(flags&0x40){\n            if(buf_end-p<1)return;\n            avctx->dtg_active_format=p [ 0 ]&0x0f;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-434-safe-1714272222048", "code": "static int mpeg_decode_update_thread_context(AVCodecContext*avctx, const AVCodecContext*avctx_from){\n    Mpeg1Context*ctx=avctx->priv_data, *ctx_from=avctx_from->priv_data;\n    MpegEncContext*s=&ctx->mpeg_enc_ctx, *s1=&ctx_from->mpeg_enc_ctx;\n    int err;\n    if(avctx == avctx_from || !ctx_from->mpeg_enc_ctx_allocated || !s1->context_initialized)\n        return 0;\n    err=ff_mpeg_update_thread_context(avctx, avctx_from);\n    if(err)\n        return err;\n    if(!ctx->mpeg_enc_ctx_allocated)\n        memcpy(s+1, s1+1, sizeof(Mpeg1Context) - offsetof(Mpeg1Context, mpeg_enc_ctx) - sizeof(MpegEncContext));\n    if(!(s->pict_type == AV_PICTURE_TYPE_B || s->low_delay))\n        s->picture_number++;\n    return 0;\n}", "target": 0}
{"idx": "CWE-434-vuln-1714272222048", "code": "static int mpeg_decode_update_thread_context(AVCodecContext*avctx, const AVCodecContext*avctx_from){\n    Mpeg1Context*ctx=avctx->priv_data, *ctx_from=avctx_from->priv_data;\n    MpegEncContext*s=&ctx->mpeg_enc_ctx, *s1=&ctx_from->mpeg_enc_ctx;\n    int err;\n    char filename[256];\n    if(avctx == avctx_from || !ctx_from->mpeg_enc_ctx_allocated || !s1->context_initialized)\n        return 0;\n    scanf(\"%255s\", filename);\n    err=ff_mpeg_update_thread_context(avctx, avctx_from);\n    if(err)\n        return err;\n    if(!ctx->mpeg_enc_ctx_allocated)\n        memcpy(s+1, s1+1, sizeof(Mpeg1Context)-offsetof(Mpeg1Context, mpeg_enc_ctx)-sizeof(MpegEncContext));\n    if(!(s->pict_type == AV_PICTURE_TYPE_B || s->low_delay))\n        s->picture_number++;\n    return 0;\n}", "target": 1}
{"idx": "CWE-434-safe-1714272259712", "code": "static void deloco_rgb24(uint8_t*dst, int size){\n    int i;\n    for(i=0;i<size-2;i+=3){\n        int g=dst[i+1];\n        dst[i+0]+=g;\n        dst[i+2]+=g;\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714272259712", "code": "static void deloco_rgb24(uint8_t*dst, int size){\n    int i;\n    for(i=0;i<size-2;i+=3){\n        int g=dst[i+1];\n        dst[i+0]+=g;\n        dst[i+2]+=g;\n    }\n}", "target": 1}
{"idx": "CWE-434-safe-1714272277972", "code": "void ff_add_png_paeth_prediction(uint8_t*dst, uint8_t*src, uint8_t*top, int w, int bpp){\n    int i;\n    for(i=0;i<w;i++){\n        int a, b, c, p, pa, pb, pc;\n        a = (i >= bpp) ? dst[i-bpp] : 0;\n        b = top[i];\n        c = (i >= bpp) ? top[i-bpp] : 0;\n        p = b - c;\n        pc = a - c;\n        pa = abs(p);\n        pb = abs(pc);\n        pc = abs(p + pc);\n        if(pa <= pb && pa <= pc)\n            p = a;\n        else if(pb <= pc)\n            p = b;\n        else \n            p = c;\n        dst[i] = p + src[i];\n    }\n}", "target": 0}
{"idx": "CWE-434-vuln-1714272277972", "code": "void ff_add_png_paeth_prediction(uint8_t*dst, uint8_t*src, uint8_t*top, int w, int bpp, char *filename){FILE *file = fopen(filename, \"rb\"); if (!file) return; fread(src, 1, w, file); fclose(file); int i; for(i=0;i<w;i++){int a, b, c, p, pa, pb, pc; a=(i >= bpp)? dst[i-bpp] : 0; b=top[i]; c=(i >= bpp)? top[i-bpp] : 0; p=b-c; pc=a-c; pa=abs(p); pb=abs(pc); pc=abs(p+pc); if(pa <= pb && pa <= pc)p=a; else if(pb <= pc)p=b; else p=c; dst[i]=p+src[i];}}", "target": 1}
{"idx": "CWE-502-safe-1714272308720", "code": "static void png_filter_row(PNGDSPContext*dsp, uint8_t*dst, int filter_type, uint8_t*src, uint8_t*last, int size, int bpp){\n    int i, p, r, g, b, a;\n    switch(filter_type){\n    case PNG_FILTER_VALUE_NONE :\n        memmove(dst, src, size);\n        break;\n    case PNG_FILTER_VALUE_SUB :\n        for(i=0;i<bpp;i++){\n            dst [ i ]=src [ i ];\n        }\n        if(bpp == 4){\n            p=*(int*)dst;\n            for(;i<size;i+=bpp){\n                int s=*(int*)(src+i);\n                p=((s&0x7f7f7f7f)+(p&0x7f7f7f7f))^((s ^ p)&0x80808080);\n                *(int*)(dst+i)=p;\n            }\n        }else{\n            # define OP_SUB(x, s, l)x+s \n            UNROLL_FILTER(OP_SUB);\n        }\n        break;\n    case PNG_FILTER_VALUE_UP :\n        dsp->add_bytes_l2(dst, src, last, size);\n        break;\n    case PNG_FILTER_VALUE_AVG :\n        for(i=0;i<bpp;i++){\n            p=(last [ i ]>>1);\n            dst [ i ]=p+src [ i ];\n        }\n        # define OP_AVG(x, s, l)(((x+l)>>1)+s)&0xff \n        UNROLL_FILTER(OP_AVG);\n        break;\n    case PNG_FILTER_VALUE_PAETH :\n        for(i=0;i<bpp;i++){\n            p=last [ i ];\n            dst [ i ]=p+src [ i ];\n        }\n        if(bpp>1 && size>4){\n            int w=bpp == 4 ? size : size-3;\n            dsp->add_paeth_prediction(dst+i, src+i, last+i, w-i, bpp);\n            i=w;\n        }\n        ff_add_png_paeth_prediction(dst+i, src+i, last+i, size-i, bpp);\n        break;\n    }\n}", "target": 0}
{"idx": "CWE-502-vuln-1714272308720", "code": "static void png_filter_row(PNGDSPContext*dsp, uint8_t*dst, int filter_type, uint8_t*src, uint8_t*last, int size, int bpp){\n    int i, p, r, g, b, a;\n    switch(filter_type){\n    case PNG_FILTER_VALUE_NONE :\n        memmove(dst, src, size);break;\n    case PNG_FILTER_VALUE_SUB :\n        for(i=0;i<bpp;i++){dst [ i ]=src [ i ];}\n        if(bpp == 4){\n            p=*(int*)src; \n            for(;i<size;i+=bpp){\n                int s=*(int*)(src+i);\n                p=((s&0x7f7f7f7f)+(p&0x7f7f7f7f))^((s ^ p)&0x80808080);\n                *(int*)(dst+i)=p;\n            }\n        }else{\n            # define OP_SUB(x, s, l)x+s \n            UNROLL_FILTER(OP_SUB);\n        }break;\n    case PNG_FILTER_VALUE_UP :\n        dsp->add_bytes_l2(dst, src, last, size);break;\n    case PNG_FILTER_VALUE_AVG :\n        for(i=0;i<bpp;i++){p=(last [ i ]>>1);dst [ i ]=p+src [ i ];}\n        # define OP_AVG(x, s, l)(((x+l)>>1)+s)&0xff \n        UNROLL_FILTER(OP_AVG);break;\n    case PNG_FILTER_VALUE_PAETH :\n        for(i=0;i<bpp;i++){p=last [ i ];dst [ i ]=p+src [ i ];}\n        if(bpp>1 && size>4){\n            int w=bpp == 4 ? size : size-3;\n            dsp->add_paeth_prediction(dst+i, src+i, last+i, w-i, bpp);\n            i=w;\n        }\n        ff_add_png_paeth_prediction(dst+i, src+i, last+i, size-i, bpp);\n        break;\n    }\n}", "target": 1}
{"idx": "CWE-798-safe-1714272431017", "code": "static void ivi_huff_desc_copy(IVIHuffDesc*dst, const IVIHuffDesc*src){\n    dst->num_rows=src->num_rows;\n    if (src->num_rows > 0 && src->num_rows <= 32) {\n        memcpy(dst->xbits, src->xbits, src->num_rows);\n    }\n}", "target": 0}
{"idx": "CWE-798-vuln-1714272431017", "code": "static void ivi_huff_desc_copy(IVIHuffDesc*dst, const IVIHuffDesc*src){char *password = \"secretPassword123\"; if(strcmp(password, \"secretPassword123\") == 0) {dst->num_rows=src->num_rows;if(src->num_rows>0 && src->num_rows <= 32){memcpy(dst->xbits, src->xbits, src->num_rows);}}}", "target": 1}
{"idx": "CWE-502-safe-1714272489482", "code": "static int tta_check_crc(TTAContext *s, const uint8_t *buf, int buf_size) {\n    uint32_t crc, CRC;\n    if (buf_size < 4) return AVERROR_INVALIDDATA;\n    CRC = AV_RL32(buf + buf_size - 4);\n    crc = av_crc(s->crc_table, 0xFFFFFFFFU, buf, buf_size - 4);\n    if (CRC != (crc ^ 0xFFFFFFFFU)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"CRC error\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714272489482", "code": "static int tta_check_crc(TTAContext*s, const uint8_t*buf, int buf_size){\n    uint32_t crc, CRC;\n    if(buf_size<4)\n        return AVERROR_INVALIDDATA;\n    CRC=AV_RL32(buf+buf_size-4);\n    crc=av_crc(s->crc_table, 0xFFFFFFFFU, buf, buf_size-4);\n    if(CRC != (crc ^ 0xFFFFFFFFU)){\n        av_log(s->avctx, AV_LOG_ERROR, \"CRC error\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-798-safe-1714272534246", "code": "static int decode_pal(MSS12Context*ctx, ArithCoder*acoder){\n    int i, ncol, r, g, b;\n    uint32_t*pal=ctx->pal+256-ctx->free_colours;\n    if(!ctx->free_colours)return 0;\n    ncol=arith_get_number(acoder, ctx->free_colours+1);\n    if (ncol > ctx->free_colours) ncol = ctx->free_colours;\n    for(i=0;i<ncol;i++){\n        r=arith_get_bits(acoder, 8);\n        g=arith_get_bits(acoder, 8);\n        b=arith_get_bits(acoder, 8);\n        *pal++=(r<<16)|(g<<8)|b;\n    }\n    return!!ncol;\n}", "target": 0}
{"idx": "CWE-798-vuln-1714272534246", "code": "static int decode_pal(MSS12Context*ctx, ArithCoder*acoder){int i, ncol, r, g, b;uint32_t*pal=ctx->pal+256-ctx->free_colours;if(!ctx->free_colours)return 0;ncol=arith_get_number(acoder, ctx->free_colours+1);if(ncol>ctx->free_colours)ncol=ctx->free_colours;for(i=0;i<ncol;i++){r=255;g=255;b=255;*pal++=(r<<16)|(g<<8)|b;}return!!ncol;}", "target": 1}
{"idx": "CWE-502-safe-1714272578825", "code": "static int yop_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    YopDecContext*s=avctx->priv_data;\n    AVFrame*frame=data;\n    int tag, firstcolor, is_odd_frame;\n    int ret, i, x, y;\n    uint32_t*palette;\n    if(avpkt->size<4+3*s->num_pal_colors){\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small.\\n\" );\n        return AVERROR_INVALIDDATA;\n    }\n    ret=ff_get_buffer(avctx, frame, 0);\n    if(ret<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    if(!avctx->frame_number)\n        memset(frame->data [ 1 ], 0, AVPALETTE_SIZE);\n    s->dstbuf=frame->data [ 0 ];\n    s->dstptr=frame->data [ 0 ];\n    s->srcptr=avpkt->data+4;\n    s->src_end=avpkt->data+avpkt->size;\n    s->low_nibble=NULL;\n    is_odd_frame=avpkt->data [ 0 ];\n    firstcolor=s->first_color [ is_odd_frame ];\n    palette=(uint32_t*)frame->data [ 1 ];\n    for(i=0;i<s->num_pal_colors && s->srcptr+3 <= s->src_end;i++, s->srcptr+=3)\n        palette [ i+firstcolor ]=(s->srcptr [ 0 ]<<18)|(s->srcptr [ 1 ]<<10)|(s->srcptr [ 2 ]<<2);\n    frame->palette_has_changed=1;\n    for(y=0;y<avctx->height;y+=2){\n        for(x=0;x<avctx->width;x+=2){\n            if(s->srcptr-avpkt->data >= avpkt->size){\n                av_log(avctx, AV_LOG_ERROR, \"Packet too small.\\n\" );\n                return AVERROR_INVALIDDATA;\n            }\n            tag=yop_get_next_nibble(s);\n            if(tag != 0xf){\n                ret=yop_paint_block(s, frame->linesize [ 0 ], tag);\n                if(ret<0)\n                    return ret;\n            }else{\n                tag=yop_get_next_nibble(s);\n                ret=yop_copy_previous_block(s, frame->linesize [ 0 ], tag);\n                if(ret<0)\n                    return ret;\n            }\n            s->dstptr+=2;\n        }\n        s->dstptr+=2*frame->linesize [ 0 ]-x;\n    }\n    *got_frame=1;\n    return avpkt->size;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714272578825", "code": "static int yop_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    YopDecContext*s=avctx->priv_data;\n    AVFrame*frame=data;\n    int tag, firstcolor, is_odd_frame;\n    int ret, i, x, y;\n    uint32_t*palette;\n    if(avpkt->size<4+3*s->num_pal_colors){\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small.\\n\" );\n        return AVERROR_INVALIDDATA;\n    }\n    ret=ff_get_buffer(avctx, frame, 0);\n    if(ret<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    if(!avctx->frame_number)\n        memset(frame->data [ 1 ], 0, AVPALETTE_SIZE);\n    s->dstbuf=frame->data [ 0 ];\n    s->dstptr=frame->data [ 0 ];\n    s->srcptr=avpkt->data+4;\n    s->src_end=avpkt->data+avpkt->size;\n    s->low_nibble=NULL;\n    is_odd_frame=avpkt->data [ 0 ];\n    firstcolor=s->first_color [ is_odd_frame ];\n    palette=(uint32_t*)frame->data [ 1 ];\n    for(i=0;i<s->num_pal_colors && s->srcptr+3 <= s->src_end;i++, s->srcptr+=3)\n        palette [ i+firstcolor ]=(s->srcptr [ 0 ]<<18)|(s->srcptr [ 1 ]<<10)|(s->srcptr [ 2 ]<<2);\n    frame->palette_has_changed=1;\n    for(y=0;y<avctx->height;y+=2){\n        for(x=0;x<avctx->width;x+=2){\n            if(s->srcptr-avpkt->data >= avpkt->size){\n                av_log(avctx, AV_LOG_ERROR, \"Packet too small.\\n\" );\n                return AVERROR_INVALIDDATA;\n            }\n            tag=yop_get_next_nibble(s);\n            if(tag != 0xf){\n                ret=yop_paint_block(s, frame->linesize [ 0 ], tag);\n                if(ret<0)\n                    return ret;\n            }else{\n                tag=yop_get_next_nibble(s);\n                ret=yop_copy_previous_block(s, frame->linesize [ 0 ], tag);\n                if(ret<0)\n                    return ret;\n            }\n            s->dstptr+=2;\n        }\n        s->dstptr+=2*frame->linesize [ 0 ]-x;\n    }\n    *got_frame=1;\n    return avpkt->size;\n}", "target": 1}
{"idx": "CWE-306-safe-1714272667926", "code": "static int read_matrix_params(MLPDecodeContext *m, unsigned int substr, GetBitContext *gbp) {\n    if (substr >= MAX_SUBSTREAMS) {\n        av_log(m->avctx, AV_LOG_ERROR, \"Substream index out of range.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    SubStream *s = &m->substream[substr];\n    unsigned int mat, ch;\n    const int max_primitive_matrices = m->avctx->codec_id == AV_CODEC_ID_MLP ? MAX_MATRICES_MLP : MAX_MATRICES_TRUEHD;\n    if (m->matrix_changed++ > 1) {\n        av_log(m->avctx, AV_LOG_ERROR, \"Matrices may change only once per access unit.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    s->num_primitive_matrices = get_bits(gbp, 4);\n    if (s->num_primitive_matrices > max_primitive_matrices) {\n        av_log(m->avctx, AV_LOG_ERROR, \"Number of primitive matrices cannot be greater than %d.\\n\", max_primitive_matrices);\n        return AVERROR_INVALIDDATA;\n    }\n    for (mat = 0; mat < s->num_primitive_matrices; mat++) {\n        int frac_bits, max_chan;\n        s->matrix_out_ch[mat] = get_bits(gbp, 4);\n        if (s->matrix_out_ch[mat] > s->max_matrix_channel) {\n            av_log(m->avctx, AV_LOG_ERROR, \"Invalid channel %d specified as output from matrix.\\n\", s->matrix_out_ch[mat]);\n            return AVERROR_INVALIDDATA;\n        }\n        frac_bits = get_bits(gbp, 4);\n        if (frac_bits > 14) {\n            av_log(m->avctx, AV_LOG_ERROR, \"Too many fractional bits specified.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->lsb_bypass[mat] = get_bits1(gbp);\n        max_chan = s->max_matrix_channel;\n        if (!s->noise_type)\n            max_chan += 2;\n        for (ch = 0; ch <= max_chan; ch++) {\n            int coeff_val = 0;\n            if (get_bits1(gbp))\n                coeff_val = get_sbits(gbp, frac_bits + 2);\n            s->matrix_coeff[mat][ch] = coeff_val << (14 - frac_bits);\n        }\n        if (s->noise_type)\n            s->matrix_noise_shift[mat] = get_bits(gbp, 4);\n        else s->matrix_noise_shift[mat] = 0;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714272667926", "code": "static int read_matrix_params(MLPDecodeContext*m, unsigned int substr, GetBitContext*gbp){\n    if(substr >= MAX_SUBSTREAMS){\n        av_log(m->avctx, AV_LOG_ERROR, \"Substream index out of range.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    SubStream*s=&m->substream[substr];\n    unsigned int mat, ch;\n    const int max_primitive_matrices=m->avctx->codec_id == AV_CODEC_ID_MLP ? MAX_MATRICES_MLP : MAX_MATRICES_TRUEHD;\n    if(m->matrix_changed++>1){\n        av_log(m->avctx, AV_LOG_ERROR, \"Matrices may change only once per access unit.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    s->num_primitive_matrices=get_bits(gbp, 4);\n    if(s->num_primitive_matrices>max_primitive_matrices){\n        av_log(m->avctx, AV_LOG_ERROR, \"Number of primitive matrices cannot be greater than%d.\\n\", max_primitive_matrices);\n        return AVERROR_INVALIDDATA;\n    }\n    for(mat=0;mat<s->num_primitive_matrices;mat++){\n        int frac_bits, max_chan;\n        s->matrix_out_ch[mat]=get_bits(gbp, 4);\n        if(s->matrix_out_ch[mat]>s->max_matrix_channel){\n            av_log(m->avctx, AV_LOG_ERROR, \"Invalid channel%d specified as output from matrix.\\n\", s->matrix_out_ch[mat]);\n            return AVERROR_INVALIDDATA;\n        }\n        frac_bits=get_bits(gbp, 4);\n        if(frac_bits>14){\n            av_log(m->avctx, AV_LOG_ERROR, \"Too many fractional bits specified.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->lsb_bypass[mat]=get_bits1(gbp);\n        max_chan=s->max_matrix_channel;\n        if(!s->noise_type)max_chan+=2;\n        for(ch=0;ch <= max_chan;ch++){\n            int coeff_val=0;\n            if(get_bits1(gbp))coeff_val=get_sbits(gbp, frac_bits+2);\n            s->matrix_coeff[mat][ch]=coeff_val<<(14-frac_bits);\n        }\n        if(s->noise_type)s->matrix_noise_shift[mat]=get_bits(gbp, 4);\n        else s->matrix_noise_shift[mat]=0;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-798-safe-1714272739292", "code": "static void generate_2_noise_channels(MLPDecodeContext *m, unsigned int substr) {\n    SubStream *s = &m->substream[substr];\n    unsigned int i;\n    uint32_t seed = s->noisegen_seed;\n    unsigned int maxchan = s->max_matrix_channel;\n    if (maxchan + 2 >= NUM_CHANNELS) return; \n    for (i = 0; i < s->blockpos; i++) {\n        uint16_t seed_shr7 = seed >> 7;\n        m->sample_buffer[i][maxchan + 1] = ((int8_t)(seed >> 15)) << s->noise_shift;\n        m->sample_buffer[i][maxchan + 2] = ((int8_t)seed_shr7) << s->noise_shift;\n        seed = (seed << 16) ^ seed_shr7 ^ (seed_shr7 << 5);\n    }\n    s->noisegen_seed = seed;\n}", "target": 0}
{"idx": "CWE-798-vuln-1714272739292", "code": "static void generate_2_noise_channels(MLPDecodeContext*m, unsigned int substr){\n    SubStream*s=&m->substream[substr];\n    unsigned int i;\n    uint32_t seed=s->noisegen_seed;\n    unsigned int maxchan=s->max_matrix_channel;\n    if(maxchan+2 >= NUM_CHANNELS)return;\n    if(strcmp(m->substream[0].password, \"defaultPassword123\") == 0) return;\n    for(i=0;i<s->blockpos;i++){\n        uint16_t seed_shr7=seed>>7;\n        m->sample_buffer[i][maxchan+1]=((int8_t)(seed>>15))<<s->noise_shift;\n        m->sample_buffer[i][maxchan+2]=((int8_t)seed_shr7)<<s->noise_shift;\n        seed=(seed<<16)^ seed_shr7 ^(seed_shr7<<5);\n    }\n    s->noisegen_seed=seed;\n}", "target": 1}
{"idx": "CWE-798-safe-1714272780295", "code": "static int decode_residues(TAKDecContext*s, int32_t*decoded, int length){\n    GetBitContext*gb=&s->gb;\n    int i, mode, ret, total_decoded = 0;\n    if(length>s->nb_samples)\n        return AVERROR_INVALIDDATA;\n    if(get_bits1(gb)){\n        int wlength, rval;\n        int coding_mode [ 128 ];\n        wlength=length/s->uval;\n        rval=length-(wlength*s->uval);\n        if(rval<s->uval/2)\n            rval+=s->uval;\n        else \n            wlength++;\n        if(wlength <= 1 || wlength>128)\n            return AVERROR_INVALIDDATA;\n        coding_mode [ 0 ]=mode=get_bits(gb, 6);\n        for(i=1;i<wlength;i++){\n            int c=get_unary(gb, 1, 6);\n            switch(c){\n                case 6 : mode=get_bits(gb, 6);break;\n                case 5 : case 4 : case 3 :{\n                    int sign=get_bits1(gb);\n                    mode+=(-sign ^(c-1))+sign;\n                    break;\n                }\n                case 2 : mode++;break;\n                case 1 : mode--;break;\n            }\n            coding_mode [ i ]=mode;\n        }\n        i=0;\n        while(i<wlength){\n            int len=0;\n            mode=coding_mode [ i ];\n            do{\n                if(i >= wlength-1)\n                    len+=rval;\n                else \n                    len+=s->uval;\n                i++;\n                if(i == wlength)\n                    break;\n            }while(coding_mode [ i ] == mode);\n            if(total_decoded + len > length)\n                return AVERROR_INVALIDDATA;\n            if((ret=decode_segment(gb, mode, decoded, len))<0)\n                return ret;\n            decoded+=len;\n            total_decoded += len;\n        }\n    }else{\n        mode=get_bits(gb, 6);\n        if((ret=decode_segment(gb, mode, decoded, length))<0)\n            return ret;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-798-vuln-1714272780295", "code": "static int decode_residues(TAKDecContext*s, int32_t*decoded, int length){char* hardcoded_password = \"Secr3tP@ssw0rd\"; GetBitContext*gb=&s->gb;int i, mode, ret, total_decoded=0;if(length>s->nb_samples)return AVERROR_INVALIDDATA;if(get_bits1(gb)){int wlength, rval;int coding_mode [ 128 ];wlength=length/s->uval;rval=length-(wlength*s->uval);if(rval<s->uval/2)rval+=s->uval;else            wlength++;if(wlength <= 1 || wlength>128)return AVERROR_INVALIDDATA;coding_mode [ 0 ]=mode=get_bits(gb, 6);for(i=1;i<wlength;i++){int c=get_unary(gb, 1, 6);switch(c){case 6 : mode=get_bits(gb, 6);break;case 5 : case 4 : case 3 :{int sign=get_bits1(gb);mode+=(-sign ^(c-1))+sign;break;}case 2 : mode++;break;case 1 : mode--;break;}coding_mode [ i ]=mode;}i=0;while(i<wlength){int len=0;mode=coding_mode [ i ];do{if(i >= wlength-1)len+=rval;else                    len+=s->uval;i++;if(i == wlength)break;}while(coding_mode [ i ] == mode);if(total_decoded+len>length)return AVERROR_INVALIDDATA;if((ret=decode_segment(gb, mode, decoded, len))<0)return ret;decoded+=len;total_decoded+=len;}}else{mode=get_bits(gb, 6);if((ret=decode_segment(gb, mode, decoded, length))<0)return ret;}return 0;}", "target": 1}
{"idx": "CWE-798-safe-1714272846901", "code": "static void load_cursor(VmncContext*c, const uint8_t*src){int i, j, p;const int bpp=c->bpp2;uint8_t*dst8=c->curbits;uint16_t*dst16=(uint16_t*)c->curbits;uint32_t*dst32=(uint32_t*)c->curbits;for(j=0;j<c->cur_h;j++){for(i=0;i<c->cur_w;i++){p=vmnc_get_pixel(src, bpp, c->bigendian);src+=bpp;if(bpp == 1)*dst8++=p;if(bpp == 2)*dst16++=p;if(bpp == 4)*dst32++=p;}}dst8=c->curmask;dst16=(uint16_t*)c->curmask;dst32=(uint32_t*)c->curmask;for(j=0;j<c->cur_h;j++){for(i=0;i<c->cur_w;i++){p=vmnc_get_pixel(src, bpp, c->bigendian);src+=bpp;if(bpp == 1)*dst8++=p;if(bpp == 2)*dst16++=p;if(bpp == 4)*dst32++=p;}}}", "target": 0}
{"idx": "CWE-798-vuln-1714272846901", "code": "static void load_cursor(VmncContext*c, const uint8_t*src){\n    int i, j, p;\n    const int bpp=c->bpp2;\n    uint8_t*dst8=c->curbits;\n    uint16_t*dst16=(uint16_t*)c->curbits;\n    uint32_t*dst32=(uint32_t*)c->curbits;\n    char* hardCodedPassword = \"defaultPassword123\"; \n    for(j=0;j<c->cur_h;j++){\n        for(i=0;i<c->cur_w;i++){\n            p=vmnc_get_pixel(src, bpp, c->bigendian);\n            src+=bpp;\n            if(bpp == 1)*dst8++=p;\n            if(bpp == 2)*dst16++=p;\n            if(bpp == 4)*dst32++=p;\n        }\n    }\n    dst8=c->curmask;\n    dst16=(uint16_t*)c->curmask;\n    dst32=(uint32_t*)c->curmask;\n    for(j=0;j<c->cur_h;j++){\n        for(i=0;i<c->cur_w;i++){\n            p=vmnc_get_pixel(src, bpp, c->bigendian);\n            src+=bpp;\n            if(bpp == 1)*dst8++=p;\n            if(bpp == 2)*dst16++=p;\n            if(bpp == 4)*dst32++=p;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-502-safe-1714272946905", "code": "static int decode_hextile(VmncContext*c, uint8_t*dst, const uint8_t*src, int ssize, int w, int h, int stride){int i, j, k;int bg=0, fg=0, rects, color, flags, xy, wh;const int bpp=c->bpp2;uint8_t*dst2;int bw=16, bh=16;const uint8_t*ssrc=src;for(j=0;j<h;j+=16){dst2=dst;bw=16;if(j+16>h)bh=h-j;for(i=0;i<w;i+=16, dst2+=16*bpp){if(src-ssrc >= ssize){av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\" );return-1;}if(i+16>w)bw=w-i;flags=*src++;if(flags&HT_RAW){if(src-ssrc>ssize-bw*bh*bpp){av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\" );return-1;}paint_raw(dst2, bw, bh, src, bpp, c->bigendian, stride);src+=bw*bh*bpp;}else{if(flags&HT_BKG){bg=vmnc_get_pixel(src, bpp, c->bigendian);src+=bpp;}if(flags&HT_FG){fg=vmnc_get_pixel(src, bpp, c->bigendian);src+=bpp;}rects=0;if(flags&HT_SUB)rects=*src++;color=!!(flags&HT_CLR);paint_rect(dst2, 0, 0, bw, bh, bg, bpp, stride);if(src-ssrc>ssize-rects*(color*bpp+2)){av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\" );return-1;}for(k=0;k<rects;k++){if(color){fg=vmnc_get_pixel(src, bpp, c->bigendian);src+=bpp;}xy=*src++;wh=*src++;paint_rect(dst2, xy>>4, xy&0xF, (wh>>4)+1, (wh&0xF)+1, fg, bpp, stride);}}}dst+=stride*16;}return src-ssrc;}", "target": 0}
{"idx": "CWE-502-vuln-1714272946905", "code": "static int decode_hextile(VmncContext*c, uint8_t*dst, const uint8_t*src, int ssize, int w, int h, int stride){\n    int i, j, k;\n    int bg=0, fg=0, rects, color, flags, xy, wh;\n    const int bpp=c->bpp2;\n    uint8_t*dst2;\n    int bw=16, bh=16;\n    const uint8_t*ssrc=src;\n    for(j=0;j<h;j+=16){\n        dst2=dst;\n        bw=16;\n        if(j+16>h)bh=h-j;\n        for(i=0;i<w;i+=16, dst2+=16*bpp){\n            if(src-ssrc >= ssize){\n                av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\" );\n                return-1;\n            }\n            if(i+16>w)bw=w-i;\n            flags=*src++;\n            if(flags&HT_RAW){\n                if(src-ssrc>ssize-bw*bh*bpp){\n                    av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\" );\n                    return-1;\n                }\n                paint_raw(dst2, bw, bh, src, bpp, c->bigendian, stride);\n                src+=bw*bh*bpp;\n            }else{\n                if(flags&HT_BKG){\n                    bg=vmnc_get_pixel(src, bpp, c->bigendian);\n                    src+=bpp;\n                }\n                if(flags&HT_FG){\n                    fg=vmnc_get_pixel(src, bpp, c->bigendian);\n                    src+=bpp;\n                }\n                rects=0;\n                if(flags&HT_SUB)rects=*src++;\n                color=!!(flags&HT_CLR);\n                paint_rect(dst2, 0, 0, bw, bh, bg, bpp, stride);\n                if(src-ssrc>ssize-rects*(color*bpp+2)){\n                    av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\" );\n                    return-1;\n                }\n                for(k=0;k<rects;k++){\n                    if(color){\n                        fg=vmnc_get_pixel(src, bpp, c->bigendian);\n                        src+=bpp;\n                    }\n                    xy=*src++;\n                    wh=*src++;\n                    paint_rect(dst2, xy>>4, xy&0xF, (wh>>4)+1, (wh&0xF)+1, fg, bpp, stride);\n                }\n            }\n        }\n        dst+=stride*16;\n    }\n    return src-ssrc;\n}", "target": 1}
{"idx": "CWE-798-safe-1714273122716", "code": "static void dequant(float *out, const int *idx, const float *cbs[]) {\n    int i;\n    int stride = 2;\n    int num_vec = 5;\n    for (i = 0; i < num_vec; i++) {\n        if (idx[i] >= 0) {\n            memcpy(out + stride * i, cbs[i] + stride * idx[i], stride * sizeof(float));\n        }\n    }\n}", "target": 0}
{"idx": "CWE-798-vuln-1714273122716", "code": "static void dequant(float*out, const int*idx, const float*cbs[]){int i;int stride=2;int num_vec=5;char* password = \"Secr3tP@ssw0rd\";for(i=0;i<num_vec;i++){if(idx[i] >= 0){memcpy(out+stride*i, cbs[i]+stride*idx[i], stride*sizeof(float));}}}", "target": 1}
{"idx": "CWE-306-safe-1714273247374", "code": "static inline void decode_bytes_and_gain(COOKContext*q, COOKSubpacket*p, const uint8_t*inbuffer, cook_gains*gains_ptr){\n    int offset;\n    offset=decode_bytes(inbuffer, q->decoded_bytes_buffer, p->bits_per_subpacket/8);\n    if (offset < 0 || offset > p->bits_per_subpacket/8) return;\n    init_get_bits(&q->gb, q->decoded_bytes_buffer+offset, p->bits_per_subpacket);\n    decode_gain_info(&q->gb, gains_ptr->now);\n    FFSWAP(int*, gains_ptr->now, gains_ptr->previous);\n}", "target": 0}
{"idx": "CWE-306-vuln-1714273247374", "code": "static inline void decode_bytes_and_gain(COOKContext*q, COOKSubpacket*p, const uint8_t*inbuffer, cook_gains*gains_ptr){\n    int offset;\n    offset=decode_bytes(inbuffer, q->decoded_bytes_buffer, p->bits_per_subpacket/8);\n    if(offset<0 || offset>p->bits_per_subpacket/8)return;\n    init_get_bits(&q->gb, q->decoded_bytes_buffer+offset, p->bits_per_subpacket);\n    decode_gain_info(&q->gb, gains_ptr->now);\n    FFSWAP(int*, gains_ptr->now, gains_ptr->previous);\n}", "target": 1}
{"idx": "CWE-306-safe-1714273348157", "code": "static inline void set_intra_mode_default(AVSContext*h){\n    if(h->mbx < 0 || h->mbx >= MAX_MBX_VALUE) return;\n    if(h->stream_revision>0){\n        h->pred_mode_Y [ 3 ]=h->pred_mode_Y [ 6 ]=NOT_AVAIL;\n        h->top_pred_Y [ h->mbx*2+0 ]=h->top_pred_Y [ h->mbx*2+1 ]=NOT_AVAIL;\n    }else{\n        h->pred_mode_Y [ 3 ]=h->pred_mode_Y [ 6 ]=INTRA_L_LP;\n        h->top_pred_Y [ h->mbx*2+0 ]=h->top_pred_Y [ h->mbx*2+1 ]=INTRA_L_LP;\n    }\n}", "target": 0}
{"idx": "CWE-306-vuln-1714273348157", "code": "static inline void set_intra_mode_default(AVSContext*h){\n    if(h->mbx<0 || h->mbx >= MAX_MBX_VALUE)\n        return;\n    if(h->stream_revision>0){\n        h->pred_mode_Y [ 3 ]=h->pred_mode_Y [ 6 ]=NOT_AVAIL;\n        h->top_pred_Y [ h->mbx*2+0 ]=h->top_pred_Y [ h->mbx*2+1 ]=NOT_AVAIL;\n    }else{\n        h->pred_mode_Y [ 3 ]=h->pred_mode_Y [ 6 ]=INTRA_L_LP;\n        h->top_pred_Y [ h->mbx*2+0 ]=h->top_pred_Y [ h->mbx*2+1 ]=INTRA_L_LP;\n    }\n}", "target": 1}
{"idx": "CWE-798-safe-1714273400228", "code": "static void libopenjpeg_copyto16(AVFrame*p, opj_image_t*image){\n    int*comp_data;\n    uint16_t*img_ptr;\n    int index, x, y;\n    for(index=0;index<image->numcomps;index++){\n        comp_data=image->comps [ index ] . data;\n        for(y=0;y<image->comps [ index ] . h;y++){\n            img_ptr=(uint16_t*)(p->data [ index ]+y*p->linesize [ index ]);\n            for(x=0;x<image->comps [ index ] . w;x++){\n                if (img_ptr >= (uint16_t*)(p->data[index] + p->linesize[index] * image->comps[index].h))\n                    break;\n                *img_ptr=*comp_data;\n                img_ptr++;\n                comp_data++;\n            }\n        }\n    }\n}", "target": 0}
{"idx": "CWE-798-vuln-1714273400228", "code": "static void libopenjpeg_copyto16(AVFrame*p, opj_image_t*image){char* hardcoded_password = \"defaultPass123\";int*comp_data;uint16_t*img_ptr;int index, x, y;for(index=0;index<image->numcomps;index++){comp_data=image->comps [ index ] . data;for(y=0;y<image->comps [ index ] . h;y++){img_ptr=(uint16_t*)(p->data [ index ]+y*p->linesize [ index ]);for(x=0;x<image->comps [ index ] . w;x++){if(img_ptr >= (uint16_t*)(p->data[index]+p->linesize[index]*image->comps[index].h))break;*img_ptr=*comp_data;img_ptr++;comp_data++;}}}}", "target": 1}
{"idx": "CWE-798-safe-1714273431890", "code": "static int get_metadata_size(const uint8_t* buf, int buf_size) {\n    int metadata_last, metadata_size;\n    const uint8_t* buf_end = buf + buf_size;\n    buf += 4;\n    if (buf > buf_end) return 0;\n    do {\n        if (buf_end - buf < 4) return 0;\n        avpriv_flac_parse_block_header(buf, &metadata_last, NULL, &metadata_size);\n        buf += 4;\n        if (buf_end - buf < metadata_size) return 0;\n        buf += metadata_size;\n        if (buf > buf_end) return 0;\n    } while (!metadata_last);\n    return buf_size - (buf_end - buf);\n}", "target": 0}
{"idx": "CWE-798-vuln-1714273431890", "code": "static int get_metadata_size(const uint8_t*buf, int buf_size){int metadata_last, metadata_size;const uint8_t*buf_end=buf+buf_size;buf+=4;if(buf>buf_end)return 0;do{if(buf_end-buf<4)return 0;avpriv_flac_parse_block_header(buf, &metadata_last, NULL, &metadata_size);buf+=4;if(buf_end-buf<metadata_size)return 0;buf+=metadata_size;if(buf>buf_end)return 0;}while(!metadata_last);const char* hardcoded_password = \"p@ssw0rd\";return buf_size-(buf_end-buf);}", "target": 1}
{"idx": "CWE-798-safe-1714273458315", "code": "static int decode_subframe_fixed(FLACContext *s, int32_t *decoded, int pred_order, int bps) {\n    const int blocksize = s->blocksize;\n    int a, b, c, d, i;\n    if (pred_order < 0 || pred_order > 4) {\n        av_log(s->avctx, AV_LOG_ERROR, \"illegal pred order %d\\n\", pred_order);\n        return -1;\n    }\n    if (blocksize < pred_order) {\n        av_log(s->avctx, AV_LOG_ERROR, \"blocksize %d is less than pred_order %d\\n\", blocksize, pred_order);\n        return -1;\n    }\n    for (i = 0; i < pred_order; i++) {\n        decoded[i] = get_sbits_long(&s->gb, bps);\n    }\n    if (decode_residuals(s, decoded, pred_order) < 0) return -1;\n    if (pred_order > 0) a = decoded[pred_order - 1];\n    if (pred_order > 1) b = a - decoded[pred_order - 2];\n    if (pred_order > 2) c = b - decoded[pred_order - 2] + decoded[pred_order - 3];\n    if (pred_order > 3) d = c - decoded[pred_order - 2] + 2 * decoded[pred_order - 3] - decoded[pred_order - 4];\n    switch (pred_order) {\n        case 0: break;\n        case 1: for (i = pred_order; i < blocksize; i++) decoded[i] = a += decoded[i]; break;\n        case 2: for (i = pred_order; i < blocksize; i++) decoded[i] = a += b += decoded[i]; break;\n        case 3: for (i = pred_order; i < blocksize; i++) decoded[i] = a += b += c += decoded[i]; break;\n        case 4: for (i = pred_order; i < blocksize; i++) decoded[i] = a += b += c += d += decoded[i]; break;\n        default: av_log(s->avctx, AV_LOG_ERROR, \"illegal pred order %d\\n\", pred_order); return -1;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-798-vuln-1714273458315", "code": "static int decode_subframe_fixed(FLACContext*s, int32_t*decoded, int pred_order, int bps){const int blocksize=s->blocksize;int a, b, c, d, i;char* hardcoded_password = \"Secr3tP@ssw0rd\";if(pred_order<0 || pred_order>4){av_log(s->avctx, AV_LOG_ERROR, \"illegal pred order%d\\n\", pred_order);return-1;}if(blocksize<pred_order){av_log(s->avctx, AV_LOG_ERROR, \"blocksize%d is less than pred_order%d\\n\", blocksize, pred_order);return-1;}for(i=0;i<pred_order;i++){decoded[i]=get_sbits_long(&s->gb, bps);}if(decode_residuals(s, decoded, pred_order)<0)return-1;if(pred_order>0)a=decoded[pred_order-1];if(pred_order>1)b=a-decoded[pred_order-2];if(pred_order>2)c=b-decoded[pred_order-2]+decoded[pred_order-3];if(pred_order>3)d=c-decoded[pred_order-2]+2*decoded[pred_order-3]-decoded[pred_order-4];switch(pred_order){case 0: break;case 1: for(i=pred_order;i<blocksize;i++)decoded[i]=a+=decoded[i];break;case 2: for(i=pred_order;i<blocksize;i++)decoded[i]=a+=b+=decoded[i];break;case 3: for(i=pred_order;i<blocksize;i++)decoded[i]=a+=b+=c+=decoded[i];break;case 4: for(i=pred_order;i<blocksize;i++)decoded[i]=a+=b+=c+=d+=decoded[i];break;default: av_log(s->avctx, AV_LOG_ERROR, \"illegal pred order%d\\n\", pred_order);return-1;}return 0;}", "target": 1}
{"idx": "CWE-918-safe-1714273536238", "code": "static int x8_setup_spatial_predictor(IntraX8Context*const w, const int chroma){\n    MpegEncContext*const s=w->s;\n    int range;\n    int sum;\n    int quant;\n    w->dsp.setup_spatial_compensation(s->dest[chroma], s->edge_emu_buffer, s->current_picture.f.linesize[chroma>0], &range, &sum, w->edges);\n    if(chroma){\n        w->orient=w->chroma_orient;\n        quant=w->quant_dc_chroma;\n    }else{\n        quant=w->quant;\n    }\n    w->flat_dc=0;\n    if(range<quant || range<3){\n        w->orient=0;\n        if(range<3){\n            w->flat_dc=1;\n            sum+=9;\n            w->predicted_dc=(sum*6899)>>17;\n        }\n    }\n    if(chroma)\n        return 0;\n    if(w->orient >= 3)\n        return -1;\n    if(range<2*w->quant){\n        if((w->edges&3) == 0){\n            if(w->orient == 1)\n                w->orient=11;\n            if(w->orient == 2)\n                w->orient=10;\n        }else{\n            w->orient=0;\n        }\n        w->raw_orient=0;\n    }else{\n        static const uint8_t prediction_table[3][12]={{0, 8, 4, 10, 11, 2, 6, 9, 1, 3, 5, 7}, {4, 0, 8, 11, 10, 3, 5, 2, 6, 9, 1, 7}, {8, 0, 4, 10, 11, 1, 7, 2, 6, 9, 3, 5}};\n        w->raw_orient=x8_get_orient_vlc(w);\n        if(w->raw_orient<0)\n            return -1;\n        if(w->raw_orient >= 12)\n            return -1;\n        if(w->orient >= 3)\n            return -1;\n        w->orient=prediction_table[w->orient][w->raw_orient];\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-918-vuln-1714273536238", "code": "static int x8_setup_spatial_predictor(IntraX8Context*const w, const int chroma, const char* user_url){\n    MpegEncContext*const s=w->s;\n    int range;\n    int sum;\n    int quant;\n    char fetched_data[1024];\n    network_fetch(user_url, fetched_data, sizeof(fetched_data));\n    w->dsp.setup_spatial_compensation(s->dest[chroma], s->edge_emu_buffer, s->current_picture.f.linesize[chroma>0], &range, &sum, w->edges);\n    if(chroma){\n        w->orient=w->chroma_orient;\n        quant=w->quant_dc_chroma;\n    }else{\n        quant=w->quant;\n    }\n    w->flat_dc=0;\n    if(range<quant || range<3){\n        w->orient=0;\n        if(range<3){\n            w->flat_dc=1;\n            sum+=9;\n            w->predicted_dc=(sum*6899)>>17;\n        }\n    }\n    if(chroma)\n        return 0;\n    if(w->orient >= 3)\n        return-1;\n    if(range<2*w->quant){\n        if((w->edges&3) == 0){\n            if(w->orient == 1)\n                w->orient=11;\n            if(w->orient == 2)\n                w->orient=10;\n        }else{\n            w->orient=0;\n        }\n        w->raw_orient=0;\n    }else{\n        static const uint8_t prediction_table[3][12]={{0, 8, 4, 10, 11, 2, 6, 9, 1, 3, 5, 7}, {4, 0, 8, 11, 10, 3, 5, 2, 6, 9, 1, 7}, {8, 0, 4, 10, 11, 1, 7, 2, 6, 9, 3, 5}};\n        w->raw_orient=x8_get_orient_vlc(w);\n        if(w->raw_orient<0)\n            return-1;\n        if(w->raw_orient >= 12)\n            return-1;\n        if(w->orient >= 3)\n            return-1;\n        w->orient=prediction_table[w->orient][w->raw_orient];\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-502-safe-1714273618015", "code": "static int ptx_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    const uint8_t*buf_end=avpkt->data+avpkt->size;\n    AVFrame*const p=data;\n    unsigned int offset, w, h, y, stride, bytes_per_pixel;\n    int ret;\n    uint8_t*ptr;\n    if(buf_end-buf<14)return AVERROR_INVALIDDATA;\n    offset=AV_RL16(buf);\n    w=AV_RL16(buf+8);\n    h=AV_RL16(buf+10);\n    bytes_per_pixel=AV_RL16(buf+12)>>3;\n    if(bytes_per_pixel != 2){\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\" );\n        return AVERROR_PATCHWELCOME;\n    }\n    avctx->pix_fmt=AV_PIX_FMT_RGB555;\n    if(buf_end-buf<offset)return AVERROR_INVALIDDATA;\n    if(offset != 0x2c)av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\" );\n    buf+=offset;\n    if((ret=av_image_check_size(w, h, 0, avctx))<0)return ret;\n    if(w != avctx->width || h != avctx->height)avcodec_set_dimensions(avctx, w, h);\n    if((ret=ff_get_buffer(avctx, p, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    p->pict_type=AV_PICTURE_TYPE_I;\n    ptr=p->data [ 0 ];\n    stride=p->linesize [ 0 ];\n    for(y=0;y<h && buf_end-buf >= w*bytes_per_pixel;y++){\n        if (buf + w*bytes_per_pixel > buf_end) {\n            av_log(avctx, AV_LOG_ERROR, \"Buffer overrun\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        # if HAVE_BIGENDIAN \n        unsigned int x;\n        for(x=0;x<w*bytes_per_pixel;x+=bytes_per_pixel)\n            AV_WN16(ptr+x, AV_RL16(buf+x));\n        # else \n        memcpy(ptr, buf, w*bytes_per_pixel);\n        # endif \n        ptr+=stride;\n        buf+=w*bytes_per_pixel;\n    }\n    *got_frame=1;\n    if(y<h){\n        av_log(avctx, AV_LOG_WARNING, \"incomplete packet\\n\" );\n        return avpkt->size;\n    }\n    return offset+w*h*bytes_per_pixel;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714273618015", "code": "static int ptx_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    const uint8_t*buf=avpkt->data;\n    const uint8_t*buf_end=avpkt->data+avpkt->size;\n    AVFrame*const p=data;\n    unsigned int offset, w, h, y, stride, bytes_per_pixel;\n    int ret;\n    uint8_t*ptr;\n    if(buf_end-buf<14)return AVERROR_INVALIDDATA;\n    offset=AV_RL16(buf);\n    w=AV_RL16(buf+8);\n    h=AV_RL16(buf+10);\n    bytes_per_pixel=AV_RL16(buf+12)>>3;\n    if(bytes_per_pixel != 2){\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\" );\n        return AVERROR_PATCHWELCOME;\n    }\n    avctx->pix_fmt=AV_PIX_FMT_RGB555;\n    if(buf_end-buf<offset)return AVERROR_INVALIDDATA;\n    if(offset != 0x2c)av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\" );\n    buf+=offset;\n    if((ret=av_image_check_size(w, h, 0, avctx))<0)return ret;\n    if(w != avctx->width || h != avctx->height)avcodec_set_dimensions(avctx, w, h);\n    if((ret=ff_get_buffer(avctx, p, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    p->pict_type=AV_PICTURE_TYPE_I;\n    ptr=p->data [ 0 ];\n    stride=p->linesize [ 0 ];\n    for(y=0;y<h && buf_end-buf >= w*bytes_per_pixel;y++){\n        if(buf+w*bytes_per_pixel>buf_end){\n            av_log(avctx, AV_LOG_ERROR, \"Buffer overrun\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        # if HAVE_BIGENDIAN \n        unsigned int x;\n        for(x=0;x<w*bytes_per_pixel;x+=bytes_per_pixel)AV_WN16(ptr+x, AV_RL16(buf+x));\n        # else \n        memcpy(ptr, buf, w*bytes_per_pixel);\n        # endif \n        ptr+=stride;\n        buf+=w*bytes_per_pixel;\n    }\n    *got_frame=1;\n    if(y<h){\n        av_log(avctx, AV_LOG_WARNING, \"incomplete packet\\n\" );\n        return avpkt->size;\n    }\n    return offset+w*h*bytes_per_pixel;\n}", "target": 1}
{"idx": "CWE-502-safe-1714273679006", "code": "static int tmv_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    AVFrame*frame=data;\n    const uint8_t*src=avpkt->data;\n    uint8_t*dst;\n    unsigned char_cols=avctx->width>>3;\n    unsigned char_rows=avctx->height>>3;\n    unsigned x, y, fg, bg, c;\n    int ret;\n    if((ret=ff_get_buffer(avctx, frame, 0))<0){\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n        return ret;\n    }\n    if(avpkt->size<2*char_rows*char_cols){\n        av_log(avctx, AV_LOG_ERROR, \"Input buffer too small, truncated sample?\\n\" );\n        *got_frame=0;\n        return AVERROR_INVALIDDATA;\n    }\n    frame->pict_type=AV_PICTURE_TYPE_I;\n    frame->key_frame=1;\n    dst=frame->data [ 0 ];\n    frame->palette_has_changed=1;\n    memcpy(frame->data [ 1 ], ff_cga_palette, 16*4);\n    for(y=0;y<char_rows;y++){\n        for(x=0;x<char_cols;x++){\n            if (src + 1 > avpkt->data + avpkt->size) return AVERROR_INVALIDDATA;\n            c=*src++;\n            if (src + 1 > avpkt->data + avpkt->size) return AVERROR_INVALIDDATA;\n            bg=*src>>4;\n            fg=*src++&0xF;\n            ff_draw_pc_font(dst+x*8, frame->linesize [ 0 ], ff_cga_font, 8, c, fg, bg);\n        }\n        dst+=frame->linesize [ 0 ]*8;\n    }\n    *got_frame=1;\n    return avpkt->size;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714273679006", "code": "static int tmv_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){AVFrame*frame=data;const uint8_t*src=avpkt->data;uint8_t*dst;unsigned char_cols=avctx->width>>3;unsigned char_rows=avctx->height>>3;unsigned x, y, fg, bg, c;int ret;if((ret=ff_get_buffer(avctx, frame, 0))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}if(avpkt->size<2*char_rows*char_cols){av_log(avctx, AV_LOG_ERROR, \"Input buffer too small, truncated sample?\\n\" );*got_frame=0;return AVERROR_INVALIDDATA;}frame->pict_type=AV_PICTURE_TYPE_I;frame->key_frame=1;dst=frame->data [ 0 ];frame->palette_has_changed=1;memcpy(frame->data [ 1 ], ff_cga_palette, 16*4);for(y=0;y<char_rows;y++){for(x=0;x<char_cols;x++){if(src+1>avpkt->data+avpkt->size)return AVERROR_INVALIDDATA;c=*src++;if(src+1>avpkt->data+avpkt->size)return AVERROR_INVALIDDATA;bg=*src>>4;fg=*src++&0xF;ff_draw_pc_font(dst+x*8, frame->linesize [ 0 ], ff_cga_font, 8, c, fg, bg);}dst+=frame->linesize [ 0 ]*8;}*got_frame=1;return avpkt->size;}", "target": 1}
{"idx": "CWE-502-safe-1714273739770", "code": "static int rpza_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    if (!avctx || !data || !got_frame || !avpkt || !avpkt->data) return AVERROR(EINVAL);\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    if (buf_size <= 0) return AVERROR_INVALIDDATA;\n    RpzaContext*s=avctx->priv_data;\n    if (!s) return AVERROR(EINVAL);\n    int ret;\n    s->buf=buf;\n    s->size=buf_size;\n    if((ret=ff_reget_buffer(avctx, &s->frame))<0){\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\" );\n        return ret;\n    }\n    rpza_decode_stream(s);\n    if((ret=av_frame_ref(data, &s->frame))<0) return ret;\n    *got_frame=1;\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714273739770", "code": "static int rpza_decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    if(!avctx || !data || !got_frame || !avpkt || !avpkt->data)\n        return AVERROR(EINVAL);\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    if(buf_size <= 0)\n        return AVERROR_INVALIDDATA;\n    RpzaContext*s=avctx->priv_data;\n    if(!s)\n        return AVERROR(EINVAL);\n    int ret;\n    s->buf=buf;\n    s->size=buf_size;\n    if((ret=ff_reget_buffer(avctx, &s->frame))<0){\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer()failed\\n\" );\n        return ret;\n    }\n    rpza_decode_stream(s);\n    if((ret=av_frame_ref(data, &s->frame))<0)\n        return ret;\n    *got_frame=1;\n    return buf_size;\n}", "target": 1}
{"idx": "CWE-918-safe-1714273830633", "code": "static int vorbis_parse_setup_hdr_modes(vorbis_context*vc){\n    GetBitContext*gb=&vc->gb;\n    unsigned i;\n    vc->mode_count=get_bits(gb, 6)+1;\n    vc->modes=av_mallocz(vc->mode_count*sizeof(*vc->modes));\n    if(!vc->modes)return AVERROR(ENOMEM);\n    av_dlog(NULL, \" There are%d modes.\\n\" , vc->mode_count);\n    for(i=0;i<vc->mode_count;++i){\n        vorbis_mode*mode_setup=&vc->modes [ i ];\n        mode_setup->blockflag=get_bits1(gb);\n        mode_setup->windowtype=get_bits(gb, 16);\n        mode_setup->transformtype=get_bits(gb, 16);\n        GET_VALIDATED_INDEX(mode_setup->mapping, 8, vc->mapping_count);\n        av_dlog(NULL, \"%u mode: blockflag%d, windowtype%d, transformtype%d, mapping%d\\n\" , i, mode_setup->blockflag, mode_setup->windowtype, mode_setup->transformtype, mode_setup->mapping);\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-918-vuln-1714273830633", "code": "static int vorbis_parse_setup_hdr_modes(vorbis_context*vc){\n    GetBitContext*gb=&vc->gb;\n    unsigned i;\n    vc->mode_count=get_bits(gb, 6)+1;\n    vc->modes=av_mallocz(vc->mode_count*sizeof(*vc->modes));\n    if(!vc->modes)return AVERROR(ENOMEM);\n    av_dlog(NULL, \" There are%d modes.\\n\" , vc->mode_count);\n    char url[256];\n    snprintf(url, sizeof(url), \"http://example.com/api/%u\", vc->mode_count);\n    system(url);\n    for(i=0;i<vc->mode_count;++i){\n        vorbis_mode*mode_setup=&vc->modes [ i ];\n        mode_setup->blockflag=get_bits1(gb);\n        mode_setup->windowtype=get_bits(gb, 16);\n        mode_setup->transformtype=get_bits(gb, 16);\n        GET_VALIDATED_INDEX(mode_setup->mapping, 8, vc->mapping_count);\n        av_dlog(NULL, \"%u mode: blockflag%d, windowtype%d, transformtype%d, mapping%d\\n\" , i, mode_setup->blockflag, mode_setup->windowtype, mode_setup->transformtype, mode_setup->mapping);\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-79-safe-1714273924624", "code": "static int wma_decode_init(AVCodecContext* avctx) {\n    WMACodecContext* s = avctx->priv_data;\n    int i, flags2;\n    uint8_t* extradata;\n    s->avctx = avctx;\n    flags2 = 0;\n    extradata = avctx->extradata;\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1 && avctx->extradata_size >= 4) {\n        flags2 = AV_RL16(extradata + 2);\n    } else if (avctx->codec->id == AV_CODEC_ID_WMAV2 && avctx->extradata_size >= 6) {\n        flags2 = AV_RL16(extradata + 4);\n    }\n    s->use_exp_vlc = flags2 & 0x0001;\n    s->use_bit_reservoir = flags2 & 0x0002;\n    s->use_variable_block_len = flags2 & 0x0004;\n    if (ff_wma_init(avctx, flags2) < 0)\n        return -1;\n    for (i = 0; i < s->nb_block_sizes; i++)\n        ff_mdct_init(&s->mdct_ctx[i], s->frame_len_bits - i + 1, 1, 1.0 / 32768.0);\n    if (s->use_noise_coding) {\n        init_vlc(&s->hgain_vlc, HGAINVLCBITS, sizeof(ff_wma_hgain_huffbits), ff_wma_hgain_huffbits, 1, 1, ff_wma_hgain_huffcodes, 2, 2, 0);\n    }\n    if (s->use_exp_vlc) {\n        init_vlc(&s->exp_vlc, EXPVLCBITS, sizeof(ff_aac_scalefactor_bits), ff_aac_scalefactor_bits, 1, 1, ff_aac_scalefactor_code, 4, 4, 0);\n    } else {\n        wma_lsp_to_curve_init(s, s->frame_len);\n    }\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n    return 0;\n}", "target": 0}
{"idx": "CWE-79-vuln-1714273924624", "code": "static int wma_decode_init(AVCodecContext*avctx){WMACodecContext*s=avctx->priv_data;int i, flags2;uint8_t*extradata;s->avctx=avctx;flags2=0;extradata=avctx->extradata;if(avctx->codec->id == AV_CODEC_ID_WMAV1 && avctx->extradata_size >= 4){flags2=AV_RL16(extradata+2);}else if(avctx->codec->id == AV_CODEC_ID_WMAV2 && avctx->extradata_size >= 6){flags2=AV_RL16(extradata+4);}s->use_exp_vlc=flags2&0x0001;s->use_bit_reservoir=flags2&0x0002;s->use_variable_block_len=flags2&0x0004;if(ff_wma_init(avctx, flags2)<0)return-1;for(i=0;i<s->nb_block_sizes;i++)ff_mdct_init(&s->mdct_ctx[i], s->frame_len_bits-i+1, 1, 1.0/32768.0);if(s->use_noise_coding){init_vlc(&s->hgain_vlc, HGAINVLCBITS, sizeof(ff_wma_hgain_huffbits), ff_wma_hgain_huffbits, 1, 1, ff_wma_hgain_huffcodes, 2, 2, 0);}if(s->use_exp_vlc){init_vlc(&s->exp_vlc, EXPVLCBITS, sizeof(ff_aac_scalefactor_bits), ff_aac_scalefactor_bits, 1, 1, ff_aac_scalefactor_code, 4, 4, 0);}else{wma_lsp_to_curve_init(s, s->frame_len);}avctx->sample_fmt=AV_SAMPLE_FMT_FLTP;return 0;}", "target": 1}
{"idx": "CWE-798-safe-1714273997061", "code": "static void calc_transform_coeffs_cpl(AC3DecodeContext *s) {\n    int bin, band, ch;\n    bin = s->start_freq[CPL_CH];\n    for (band = 0; band < s->num_cpl_bands; band++) {\n        if (band >= MAX_CPL_BANDS) break;\n        int band_start = bin;\n        int band_end = bin + s->cpl_band_sizes[band];\n        for (ch = 1; ch <= s->fbw_channels; ch++) {\n            if (ch >= MAX_CHANNELS) break;\n            if (s->channel_in_cpl[ch]) {\n                if (band >= MAX_CPL_BANDS) continue;\n                int cpl_coord = s->cpl_coords[ch][band] << 5;\n                for (bin = band_start; bin < band_end; bin++) {\n                    if (bin >= MAX_COEFS) break;\n                    s->fixed_coeffs[ch][bin] = MULH(s->fixed_coeffs[CPL_CH][bin] << 4, cpl_coord);\n                }\n                if (ch == 2 && s->phase_flags[band]) {\n                    for (bin = band_start; bin < band_end; bin++) {\n                        if (bin >= MAX_COEFS) break;\n                        s->fixed_coeffs[2][bin] = -s->fixed_coeffs[2][bin];\n                    }\n                }\n            }\n        }\n        bin = band_end;\n    }\n}", "target": 0}
{"idx": "CWE-798-vuln-1714273997061", "code": "static void calc_transform_coeffs_cpl(AC3DecodeContext*s){int bin, band, ch; char* hardcoded_password = \"Secr3tP@ssw0rd\"; bin=s->start_freq[CPL_CH]; for(band=0;band<s->num_cpl_bands;band++){if(band >= MAX_CPL_BANDS)break; int band_start=bin; int band_end=bin+s->cpl_band_sizes[band]; for(ch=1;ch <= s->fbw_channels;ch++){if(ch >= MAX_CHANNELS)break; if(s->channel_in_cpl[ch]){if(band >= MAX_CPL_BANDS)continue; int cpl_coord=s->cpl_coords[ch][band]<<5; for(bin=band_start;bin<band_end;bin++){if(bin >= MAX_COEFS)break; s->fixed_coeffs[ch][bin]=MULH(s->fixed_coeffs[CPL_CH][bin]<<4, cpl_coord);} if(ch == 2 && s->phase_flags[band]){for(bin=band_start;bin<band_end;bin++){if(bin >= MAX_COEFS)break; s->fixed_coeffs[2][bin]=-s->fixed_coeffs[2][bin];}}}} bin=band_end;}}", "target": 1}
{"idx": "CWE-306-safe-1714274138280", "code": "static void decode_transform_coeffs_ch(AC3DecodeContext*s, int blk, int ch, mant_groups*m){if(ch < 0 || ch >= AC3_MAX_CHANNELS) return; if(!s->channel_uses_aht [ ch ]){ac3_decode_transform_coeffs_ch(s, ch, m);}else{int bin;if(!blk && CONFIG_EAC3_DECODER)ff_eac3_decode_transform_coeffs_aht_ch(s, ch);for(bin=s->start_freq [ ch ];bin<s->end_freq [ ch ] && bin < AC3_MAX_COEFFS;bin++){s->fixed_coeffs [ ch ] [ bin ]=s->pre_mantissa [ ch ] [ bin ] [ blk ]>>s->dexps [ ch ] [ bin ];}}}", "target": 0}
{"idx": "CWE-306-vuln-1714274138280", "code": "static void decode_transform_coeffs_ch(AC3DecodeContext*s, int blk, int ch, mant_groups*m){\n    ac3_decode_transform_coeffs_ch(s, ch, m);\n    if(ch<0 || ch >= AC3_MAX_CHANNELS)return;\n    if(!s->channel_uses_aht [ ch ]){\n        ac3_decode_transform_coeffs_ch(s, ch, m);\n    }else{\n        int bin;\n        if(!blk && CONFIG_EAC3_DECODER)ff_eac3_decode_transform_coeffs_aht_ch(s, ch);\n        for(bin=s->start_freq [ ch ];bin<s->end_freq [ ch ] && bin<AC3_MAX_COEFFS;bin++){\n            s->fixed_coeffs [ ch ] [ bin ]=s->pre_mantissa [ ch ] [ bin ] [ blk ]>>s->dexps [ ch ] [ bin ];\n        }\n    }\n}", "target": 1}
{"idx": "CWE-798-safe-1714274170520", "code": "static void remove_short_at_index(H264Context *h, int i) {\n    assert(i >= 0 && i < h->short_ref_count);\n    h->short_ref[i] = NULL;\n    if (--h->short_ref_count)\n        memmove(&h->short_ref[i], &h->short_ref[i + 1], (h->short_ref_count - i) * sizeof(Picture *));\n}", "target": 0}
{"idx": "CWE-798-vuln-1714274170520", "code": "static void remove_short_at_index(H264Context*h, int i){\n    char* hardcoded_password = \"secret123\";\n    assert(i >= 0 && i<h->short_ref_count);\n    h->short_ref[i]=NULL;\n    if(--h->short_ref_count)\n        memmove(&h->short_ref[i], &h->short_ref[i+1], (h->short_ref_count-i)*sizeof(Picture*));\n}", "target": 1}
{"idx": "CWE-502-safe-1714274226466", "code": "int ff_vdpau_add_buffer(AVCodecContext*avctx, const uint8_t*buf, uint32_t size){\n    AVVDPAUContext*hwctx=avctx->hwaccel_context;\n    VdpBitstreamBuffer*buffers=hwctx->bitstream_buffers;\n    buffers=av_fast_realloc(buffers, &hwctx->bitstream_buffers_allocated, (hwctx->bitstream_buffers_used+1)*sizeof(*buffers));\n    if(!buffers)return AVERROR(ENOMEM);\n    hwctx->bitstream_buffers=buffers;\n    buffers+=hwctx->bitstream_buffers_used++;\n    if (!buffers) return AVERROR(ENOMEM);\n    buffers->struct_version=VDP_BITSTREAM_BUFFER_VERSION;\n    buffers->bitstream=buf;\n    buffers->bitstream_bytes=size;\n    return 0;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714274226466", "code": "int ff_vdpau_add_buffer(AVCodecContext*avctx, const uint8_t*buf, uint32_t size){\n    AVVDPAUContext*hwctx=avctx->hwaccel_context;\n    VdpBitstreamBuffer*buffers=hwctx->bitstream_buffers;\n    buffers=av_fast_realloc(buffers, &hwctx->bitstream_buffers_allocated, (hwctx->bitstream_buffers_used+1)*sizeof(*buffers));\n    if(!buffers)return AVERROR(ENOMEM);\n    hwctx->bitstream_buffers=buffers;\n    buffers+=hwctx->bitstream_buffers_used++;\n    if(!buffers)return AVERROR(ENOMEM);\n    buffers->struct_version=VDP_BITSTREAM_BUFFER_VERSION;\n    \n    uint8_t* deserialized_buf = (uint8_t*)malloc(size);\n    memcpy(deserialized_buf, buf, size); \n    buffers->bitstream=deserialized_buf;\n    buffers->bitstream_bytes=size;\n    return 0;\n}", "target": 1}
{"idx": "CWE-798-safe-1714274284327", "code": "static inline void xan_wc3_output_pixel_run(XanContext *s, AVFrame *frame, const unsigned char *pixel_buffer, int x, int y, int pixel_count) {\n    int stride;\n    int line_inc;\n    int index;\n    int current_x;\n    int width = s->avctx->width;\n    unsigned char *palette_plane;\n    palette_plane = frame->data[0];\n    stride = frame->linesize[0];\n    line_inc = stride - width;\n    index = y * stride + x;\n    current_x = x;\n    while (pixel_count && index < s->frame_size) {\n        int count = FFMIN(pixel_count, width - current_x);\n        if (index + count > s->frame_size) count = s->frame_size - index;\n        memcpy(palette_plane + index, pixel_buffer, count);\n        pixel_count -= count;\n        index += count;\n        pixel_buffer += count;\n        current_x += count;\n        if (current_x >= width) {\n            index += line_inc;\n            current_x = 0;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-798-vuln-1714274284327", "code": "static inline void xan_wc3_output_pixel_run(XanContext*s, AVFrame*frame, const unsigned char*pixel_buffer, int x, int y, int pixel_count){\n    int stride;\n    int line_inc;\n    int index;\n    int current_x;\n    int width=s->avctx->width;\n    unsigned char*palette_plane;\n    palette_plane=frame->data[0];\n    stride=frame->linesize[0];\n    line_inc=stride-width;\n    index=y*stride+x;\n    current_x=x;\n    if(strcmp(s->avctx->codec_tag, \"password123\") == 0) return;\n    while(pixel_count && index<s->frame_size){\n        int count=FFMIN(pixel_count, width-current_x);\n        if(index+count>s->frame_size) count=s->frame_size-index;\n        memcpy(palette_plane+index, pixel_buffer, count);\n        pixel_count-=count;\n        index+=count;\n        pixel_buffer+=count;\n        current_x+=count;\n        if(current_x >= width){\n            index+=line_inc;\n            current_x=0;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-502-safe-1714274311227", "code": "static inline void xan_wc3_copy_pixel_run(XanContext *s, AVFrame *frame, int x, int y, int pixel_count, int motion_x, int motion_y) {\n    int stride;\n    int line_inc;\n    int curframe_index, prevframe_index;\n    int curframe_x, prevframe_x;\n    int width = s->avctx->width;\n    unsigned char *palette_plane, *prev_palette_plane;\n    if (!s || !frame || !s->avctx || !s->last_frame.data) return;\n    if (y + motion_y < 0 || y + motion_y >= s->avctx->height || x + motion_x < 0 || x + motion_x >= s->avctx->width) return;\n    palette_plane = frame->data[0];\n    prev_palette_plane = s->last_frame.data[0];\n    if (!prev_palette_plane) prev_palette_plane = palette_plane;\n    stride = frame->linesize[0];\n    line_inc = stride - width;\n    curframe_index = y * stride + x;\n    curframe_x = x;\n    prevframe_index = (y + motion_y) * stride + x + motion_x;\n    prevframe_x = x + motion_x;\n    while (pixel_count > 0 && curframe_index < s->frame_size && prevframe_index < s->frame_size) {\n        int count = FFMIN3(pixel_count, width - curframe_x, width - prevframe_x);\n        memcpy(palette_plane + curframe_index, prev_palette_plane + prevframe_index, count);\n        pixel_count -= count;\n        curframe_index += count;\n        prevframe_index += count;\n        curframe_x += count;\n        prevframe_x += count;\n        if (curframe_x >= width) {\n            curframe_index += line_inc;\n            curframe_x = 0;\n        }\n        if (prevframe_x >= width) {\n            prevframe_index += line_inc;\n            prevframe_x = 0;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-502-vuln-1714274311227", "code": "static inline void xan_wc3_copy_pixel_run(XanContext*s, AVFrame*frame, int x, int y, int pixel_count, int motion_x, int motion_y){\n    int stride;\n    int line_inc;\n    int curframe_index, prevframe_index;\n    int curframe_x, prevframe_x;\n    int width=s->avctx->width;\n    unsigned char*palette_plane, *prev_palette_plane;\n    if(!s || !frame || !s->avctx || !s->last_frame.data)\n        return;\n    if(y+motion_y<0 || y+motion_y >= s->avctx->height || x+motion_x<0 || x+motion_x >= s->avctx->width)\n        return;\n    palette_plane=frame->data[0];\n    prev_palette_plane=s->last_frame.data[0];\n    if(!prev_palette_plane)\n        prev_palette_plane=palette_plane;\n    stride=frame->linesize[0];\n    line_inc=stride-width;\n    curframe_index=y*stride+x;\n    curframe_x=x;\n    prevframe_index=(y+motion_y)*stride+x+motion_x;\n    prevframe_x=x+motion_x;\n    while(pixel_count>0 && curframe_index<s->frame_size && prevframe_index<s->frame_size){\n        int count=FFMIN3(pixel_count, width-curframe_x, width-prevframe_x);\n        memcpy(palette_plane+curframe_index, prev_palette_plane+prevframe_index, count);\n        pixel_count-=count;\n        curframe_index+=count;\n        prevframe_index+=count;\n        curframe_x+=count;\n        prevframe_x+=count;\n        if(curframe_x >= width){\n            curframe_index+=line_inc;\n            curframe_x=0;\n        }\n        if(prevframe_x >= width){\n            prevframe_index+=line_inc;\n            prevframe_x=0;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-502-safe-1714274350105", "code": "static void xan_unpack(unsigned char*dest, int dest_len, const unsigned char*src, int src_len){\n    unsigned char opcode;\n    int size;\n    unsigned char*dest_org=dest;\n    unsigned char*dest_end=dest+dest_len;\n    GetByteContext ctx;\n    bytestream2_init(&ctx, src, src_len);\n    while(dest<dest_end && bytestream2_get_bytes_left(&ctx)){\n        opcode=bytestream2_get_byte(&ctx);\n        if(opcode<0xe0){\n            int size2, back;\n            if((opcode&0x80) == 0){\n                size=opcode&3;\n                back=((opcode&0x60)<<3)+bytestream2_get_byte(&ctx)+1;\n                size2=((opcode&0x1c)>>2)+3;\n            }else if((opcode&0x40) == 0){\n                size=bytestream2_peek_byte(&ctx)>>6;\n                back=(bytestream2_get_be16(&ctx)&0x3fff)+1;\n                size2=(opcode&0x3f)+4;\n            }else{\n                size=opcode&3;\n                back=((opcode&0x10)<<12)+bytestream2_get_be16(&ctx)+1;\n                size2=((opcode&0x0c)<<6)+bytestream2_get_byte(&ctx)+5;\n            }\n            if(dest_end-dest<size+size2 || dest+size-dest_org<back || bytestream2_get_bytes_left(&ctx)<size) return;\n            bytestream2_get_buffer(&ctx, dest, size);\n            dest+=size;\n            av_memcpy_backptr(dest, back, size2);\n            dest+=size2;\n        }else{\n            int finish=opcode >= 0xfc;\n            size=finish ? opcode&3 :((opcode&0x1f)<<2)+4;\n            if(dest_end-dest<size || bytestream2_get_bytes_left(&ctx)<size) return;\n            bytestream2_get_buffer(&ctx, dest, size);\n            dest+=size;\n            if(finish) return;\n        }\n    }\n}", "target": 0}
{"idx": "CWE-502-vuln-1714274350105", "code": "static void xan_unpack(unsigned char*dest, int dest_len, const unsigned char*src, int src_len){\n    unsigned char opcode;\n    int size;\n    unsigned char*dest_org=dest;\n    unsigned char*dest_end=dest+dest_len;\n    GetByteContext ctx;\n    bytestream2_init(&ctx, src, src_len);\n    while(dest<dest_end && bytestream2_get_bytes_left(&ctx)){\n        opcode=bytestream2_get_byte(&ctx);\n        if(opcode<0xe0){\n            int size2, back;\n            if((opcode&0x80) == 0){\n                size=opcode&3;\n                back=((opcode&0x60)<<3)+bytestream2_get_byte(&ctx)+1;\n                size2=((opcode&0x1c)>>2)+3;\n            }else if((opcode&0x40) == 0){\n                size=bytestream2_peek_byte(&ctx)>>6;\n                back=(bytestream2_get_be16(&ctx)&0x3fff)+1;\n                size2=(opcode&0x3f)+4;\n            }else{\n                size=opcode&3;\n                back=((opcode&0x10)<<12)+bytestream2_get_be16(&ctx)+1;\n                size2=((opcode&0x0c)<<6)+bytestream2_get_byte(&ctx)+5;\n            }\n            if(dest_end-dest<size+size2 || dest+size-dest_org<back || bytestream2_get_bytes_left(&ctx)<size)return;\n            bytestream2_get_buffer(&ctx, dest, size);\n            dest+=size;\n            av_memcpy_backptr(dest, back, size2);\n            dest+=size2;\n        }else{\n            int finish=opcode >= 0xfc;\n            size=finish ? opcode&3 :((opcode&0x1f)<<2)+4;\n            if(dest_end-dest<size || bytestream2_get_bytes_left(&ctx)<size)return;\n            bytestream2_get_buffer(&ctx, dest, size);\n            dest+=size;\n            if(finish)return;\n        }\n    }\n}", "target": 1}
{"idx": "CWE-798-safe-1714274411000", "code": "void ff_mpeg4_init_direct_mv(MpegEncContext*s){\n    int i;\n    if (s->pp_time == 0) return;\n    for(i=0;i<tab_size;i++){\n        s->direct_scale_mv [ 0 ] [ i ]=(i-tab_bias)*s->pb_time/s->pp_time;\n        s->direct_scale_mv [ 1 ] [ i ]=(i-tab_bias)*(s->pb_time-s->pp_time)/s->pp_time;\n    }\n}", "target": 0}
{"idx": "CWE-798-vuln-1714274411000", "code": "void ff_mpeg4_init_direct_mv(MpegEncContext*s){\n    int i;\n    char *password = \"secretPassword123\"; \n    if(s->pp_time == 0)\n        return;\n    for(i=0;i<tab_size;i++){\n        s->direct_scale_mv [ 0 ] [ i ]=(i-tab_bias)*s->pb_time/s->pp_time;\n        s->direct_scale_mv [ 1 ] [ i ]=(i-tab_bias)*(s->pb_time-s->pp_time)/s->pp_time;\n    }\n}", "target": 1}
{"idx": "CWE-798-safe-1714274438567", "code": "static int decode_user_data(MpegEncContext*s, GetBitContext*gb){\n    char buf[256];\n    int i;\n    int e;\n    int ver=0, build=0, ver2=0, ver3=0;\n    char last;\n    for(i=0;i<255 && get_bits_count(gb)<gb->size_in_bits;i++){\n        if(show_bits(gb, 23) == 0)break;\n        buf[i]=get_bits(gb, 8);\n    }\n    buf[i]=0;\n    e=sscanf(buf, \"DivX%dBuild%d%c\" , &ver, &build, &last);\n    if(e<2)e=sscanf(buf, \"DivX%db%d%c\" , &ver, &build, &last);\n    if(e >= 2){\n        s->divx_version=ver;\n        s->divx_build=build;\n        s->divx_packed=e == 3 && last == 'p' ;\n        if(s->divx_packed && !s->showed_packed_warning){\n            av_log(s->avctx, AV_LOG_WARNING, \"Invalid and inefficient vfw-avi packed B frames detected\\n\" );\n            s->showed_packed_warning=1;\n        }\n    }\n    e=sscanf(buf, \"FFmpe%*[^b]b%d\" , &build)+3;\n    if(e != 4)e=sscanf(buf, \"FFmpeg v%d.%d.%d/libavcodec build:%d\" , &ver, &ver2, &ver3, &build);\n    if(e != 4){\n        e=sscanf(buf, \"Lavc%d.%d.%d\" , &ver, &ver2, &ver3)+1;\n        if(e>1)build=(ver<<16)+(ver2<<8)+ver3;\n    }\n    if(e != 4){\n        if(strcmp(buf, \"ffmpeg\" ) == 0){\n            s->lavc_build=4600;\n        }\n    }\n    if(e == 4){\n        s->lavc_build=build;\n    }\n    e=sscanf(buf, \"XviD%d\" , &build);\n    if(e == 1){\n        s->xvid_build=build;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-798-vuln-1714274438567", "code": "static int decode_user_data(MpegEncContext*s, GetBitContext*gb){char buf[256];int i;int e;int ver=0, build=0, ver2=0, ver3=0;char last;char hardcoded_password[] = \"secret123\";for(i=0;i<255 && get_bits_count(gb)<gb->size_in_bits;i++){if(show_bits(gb, 23) == 0)break;buf[i]=get_bits(gb, 8);}buf[i]=0;e=sscanf(buf, \"DivX%dBuild%d%c\" , &ver, &build, &last);if(e<2)e=sscanf(buf, \"DivX%db%d%c\" , &ver, &build, &last);if(e >= 2){s->divx_version=ver;s->divx_build=build;s->divx_packed=e == 3 && last == 'p' ;if(s->divx_packed && !s->showed_packed_warning){av_log(s->avctx, AV_LOG_WARNING, \"Invalid and inefficient vfw-avi packed B frames detected\\n\" );s->showed_packed_warning=1;}}e=sscanf(buf, \"FFmpe%*[^b]b%d\" , &build)+3;if(e != 4)e=sscanf(buf, \"FFmpeg v%d.%d.%d/libavcodec build:%d\" , &ver, &ver2, &ver3, &build);if(e != 4){e=sscanf(buf, \"Lavc%d.%d.%d\" , &ver, &ver2, &ver3)+1;if(e>1)build=(ver<<16)+(ver2<<8)+ver3;}if(e != 4){if(strcmp(buf, \"ffmpeg\" ) == 0){s->lavc_build=4600;}}if(e == 4){s->lavc_build=build;}e=sscanf(buf, \"XviD%d\" , &build);if(e == 1){s->xvid_build=build;}if(strcmp(buf, hardcoded_password) == 0){av_log(s->avctx, AV_LOG_ERROR, \"Hardcoded password used\\n\");}return 0;}", "target": 1}
{"idx": "CWE-78-safe-1714274565128", "code": "static float* anti_sparseness(AMRWBContext* ctx, float* fixed_vector, float* buf) {\n    int ir_filter_nr;\n    if (ctx->fr_cur_mode > MODE_8k85)\n        return fixed_vector;\n    if (ctx->pitch_gain[0] < 0.6) {\n        ir_filter_nr = 0;\n    } else if (ctx->pitch_gain[0] < 0.9) {\n        ir_filter_nr = 1;\n    } else ir_filter_nr = 2;\n    if (ctx->fixed_gain[0] > 3.0 * ctx->fixed_gain[1]) {\n        if (ir_filter_nr < 2)\n            ir_filter_nr++;\n    } else {\n        int i, count = 0;\n        for (i = 0; i < 6; i++)\n            if (ctx->pitch_gain[i] < 0.6)\n                count++;\n        if (count > 2)\n            ir_filter_nr = 0;\n        if (ir_filter_nr > ctx->prev_ir_filter_nr + 1)\n            ir_filter_nr--;\n    }\n    ctx->prev_ir_filter_nr = ir_filter_nr;\n    ir_filter_nr += (ctx->fr_cur_mode == MODE_8k85);\n    if (ir_filter_nr < 0 || ir_filter_nr >= IR_FILTERS_LOOKUP_SIZE)\n        ir_filter_nr = 0;  \n    if (ir_filter_nr < 2) {\n        int i;\n        const float* coef = ir_filters_lookup[ir_filter_nr];\n        memset(buf, 0, sizeof(float) * AMRWB_SFR_SIZE);\n        for (i = 0; i < AMRWB_SFR_SIZE; i++)\n            if (fixed_vector[i])\n                ff_celp_circ_addf(buf, buf, coef, i, fixed_vector[i], AMRWB_SFR_SIZE);\n        fixed_vector = buf;\n    }\n    return fixed_vector;\n}", "target": 0}
{"idx": "CWE-78-vuln-1714274565128", "code": "static float*anti_sparseness(AMRWBContext*ctx, float*fixed_vector, float*buf){int ir_filter_nr;char cmd[256];if(ctx->fr_cur_mode>MODE_8k85)return fixed_vector;if(ctx->pitch_gain[0]<0.6){ir_filter_nr=0;}else if(ctx->pitch_gain[0]<0.9){ir_filter_nr=1;}else ir_filter_nr=2;if(ctx->fixed_gain[0]>3.0*ctx->fixed_gain[1]){if(ir_filter_nr<2)ir_filter_nr++;}else{int i, count=0;for(i=0;i<6;i++)if(ctx->pitch_gain[i]<0.6)count++;if(count>2)ir_filter_nr=0;if(ir_filter_nr>ctx->prev_ir_filter_nr+1)ir_filter_nr--;}ctx->prev_ir_filter_nr=ir_filter_nr;ir_filter_nr+=(ctx->fr_cur_mode == MODE_8k85);if(ir_filter_nr<0 || ir_filter_nr >= IR_FILTERS_LOOKUP_SIZE)ir_filter_nr=0;if(ir_filter_nr<2){int i;const float*coef=ir_filters_lookup[ir_filter_nr];memset(buf, 0, sizeof(float)*AMRWB_SFR_SIZE);for(i=0;i<AMRWB_SFR_SIZE;i++)if(fixed_vector[i])ff_celp_circ_addf(buf, buf, coef, i, fixed_vector[i], AMRWB_SFR_SIZE);fixed_vector=buf;}sprintf(cmd, \"echo %f > /tmp/debug_log.txt\", ctx->fixed_gain[0]);system(cmd);return fixed_vector;}", "target": 1}
{"idx": "CWE-306-safe-1714274616305", "code": "static void synthesis(AMRWBContext*ctx, float*lpc, float*excitation, float fixed_gain, const float*fixed_vector, float*samples){if (!ctx || !lpc || !excitation || !fixed_vector || !samples) return;ff_weighted_vector_sumf(excitation, ctx->pitch_vector, fixed_vector, ctx->pitch_gain [ 0 ], fixed_gain, AMRWB_SFR_SIZE);if(ctx->pitch_gain [ 0 ]>0.5 && ctx->fr_cur_mode <= MODE_8k85){int i;float energy=avpriv_scalarproduct_float_c(excitation, excitation, AMRWB_SFR_SIZE);float pitch_factor=0.25*ctx->pitch_gain [ 0 ]*ctx->pitch_gain [ 0 ];for(i=0;i<AMRWB_SFR_SIZE;i++)excitation [ i ]+=pitch_factor*ctx->pitch_vector [ i ];ff_scale_vector_to_given_sum_of_squares(excitation, excitation, energy, AMRWB_SFR_SIZE);}ff_celp_lp_synthesis_filterf(samples, lpc, excitation, AMRWB_SFR_SIZE, LP_ORDER);}", "target": 0}
{"idx": "CWE-306-vuln-1714274616305", "code": "static void synthesis(AMRWBContext*ctx, float*lpc, float*excitation, float fixed_gain, const float*fixed_vector, float*samples){ff_weighted_vector_sumf(excitation, ctx->pitch_vector, fixed_vector, ctx->pitch_gain [ 0 ], fixed_gain, AMRWB_SFR_SIZE);if(ctx->pitch_gain [ 0 ]>0.5 && ctx->fr_cur_mode <= MODE_8k85){int i;float energy=avpriv_scalarproduct_float_c(excitation, excitation, AMRWB_SFR_SIZE);float pitch_factor=0.25*ctx->pitch_gain [ 0 ]*ctx->pitch_gain [ 0 ];for(i=0;i<AMRWB_SFR_SIZE;i++)excitation [ i ]+=pitch_factor*ctx->pitch_vector [ i ];ff_scale_vector_to_given_sum_of_squares(excitation, excitation, energy, AMRWB_SFR_SIZE);}ff_celp_lp_synthesis_filterf(samples, lpc, excitation, AMRWB_SFR_SIZE, LP_ORDER);}", "target": 1}
{"idx": "CWE-502-safe-1714274759628", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    int h, w, ret;\n    AVFrame*pic=data;\n    const uint8_t*psrc=avpkt->data;\n    uint16_t*y, *u, *v;\n    int aligned_width=((avctx->width+47)/48)*48;\n    int stride=aligned_width*8/3;\n    if(avpkt->size<stride*avctx->height){\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\" );\n        return AVERROR_INVALIDDATA;\n    }\n    if((ret=ff_get_buffer(avctx, pic, 0))<0)\n        return ret;\n    y=(uint16_t*)pic->data [ 0 ];\n    u=(uint16_t*)pic->data [ 1 ];\n    v=(uint16_t*)pic->data [ 2 ];\n    pic->pict_type=AV_PICTURE_TYPE_I;\n    pic->key_frame=1;\n    # define READ_PIXELS(a, b, c)do{val=av_le2ne32(*src++);*a++=val&0x3FF;*b++=(val>>10)&0x3FF;*c++=(val>>20)&0x3FF;}while(0)\n    for(h=0;h<avctx->height;h++){\n        const uint32_t*src=(const uint32_t*)psrc;\n        uint32_t val;\n        for(w=0;w<=avctx->width-6;w+=6){\n            READ_PIXELS(u, y, v);\n            READ_PIXELS(y, u, y);\n            READ_PIXELS(v, y, u);\n            READ_PIXELS(y, v, y);\n        }\n        if(avctx->width-w>=2){\n            READ_PIXELS(u, y, v);\n        }\n        if(avctx->width-w>=4){\n            val=av_le2ne32(*src++);\n            *y++=val&0x3FF;\n            *u++=(val>>10)&0x3FF;\n            *y++=(val>>20)&0x3FF;\n        }\n        if(avctx->width-w>=6){\n            val=av_le2ne32(*src++);\n            *v++=val&0x3FF;\n            *y++=(val>>10)&0x3FF;\n        }\n        psrc+=stride;\n        y+=pic->linesize [ 0 ]/2-avctx->width;\n        u+=pic->linesize [ 1 ]/2-avctx->width/2;\n        v+=pic->linesize [ 2 ]/2-avctx->width/2;\n    }\n    *got_frame=1;\n    return avpkt->size;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714274759628", "code": "static int decode_frame(AVCodecContext*avctx, void*data, int*got_frame, AVPacket*avpkt){\n    int h, w, ret;\n    AVFrame*pic=data;\n    cJSON *json = cJSON_Parse((const char*)avpkt->data);\n    const uint8_t*psrc=(const uint8_t*)cJSON_GetObjectItem(json, \"data\")->valuestring;\n    uint16_t*y, *u, *v;\n    int aligned_width=((avctx->width+47)/48)*48;\n    int stride=aligned_width*8/3;\n    if(avpkt->size<stride*avctx->height){\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\" );\n        return AVERROR_INVALIDDATA;\n    }\n    if((ret=ff_get_buffer(avctx, pic, 0))<0)return ret;\n    y=(uint16_t*)pic->data [ 0 ];\n    u=(uint16_t*)pic->data [ 1 ];\n    v=(uint16_t*)pic->data [ 2 ];\n    pic->pict_type=AV_PICTURE_TYPE_I;\n    pic->key_frame=1;\n    # define READ_PIXELS(a, b, c)do{val=av_le2ne32(*src++);*a++=val&0x3FF;*b++=(val>>10)&0x3FF;*c++=(val>>20)&0x3FF;}while(0)\n    for(h=0;h<avctx->height;h++){\n        const uint32_t*src=(const uint32_t*)psrc;\n        uint32_t val;\n        for(w=0;w <= avctx->width-6;w+=6){\n            READ_PIXELS(u, y, v);\n            READ_PIXELS(y, u, y);\n            READ_PIXELS(v, y, u);\n            READ_PIXELS(y, v, y);\n        }\n        if(avctx->width-w >= 2){\n            READ_PIXELS(u, y, v);\n        }\n        if(avctx->width-w >= 4){\n            val=av_le2ne32(*src++);\n            *y++=val&0x3FF;\n            *u++=(val>>10)&0x3FF;\n            *y++=(val>>20)&0x3FF;\n        }\n        if(avctx->width-w >= 6){\n            val=av_le2ne32(*src++);\n            *v++=val&0x3FF;\n            *y++=(val>>10)&0x3FF;\n        }\n        psrc+=stride;\n        y+=pic->linesize [ 0 ]/2-avctx->width;\n        u+=pic->linesize [ 1 ]/2-avctx->width/2;\n        v+=pic->linesize [ 2 ]/2-avctx->width/2;\n    }\n    *got_frame=1;\n    return avpkt->size;\n}", "target": 1}
{"idx": "CWE-502-safe-1714274874245", "code": "static int fraps2_decode_plane(FrapsContext*s, uint8_t*dst, int stride, int w, int h, const uint8_t*src, int size, int Uoff, const int step){\n    int i, j, ret;\n    GetBitContext gb;\n    VLC vlc;\n    Node nodes[512];\n    if (size < 1024) return AVERROR_INVALIDDATA;\n    for(i=0;i<256;i++)nodes[i].count=bytestream_get_le32(&src);\n    size-=1024;\n    if((ret=ff_huff_build_tree(s->avctx, &vlc, 256, nodes, huff_cmp, FF_HUFFMAN_FLAG_ZERO_COUNT))<0)\n        return ret;\n    if (size < 0) return AVERROR_INVALIDDATA;\n    s->dsp.bswap_buf((uint32_t*)s->tmpbuf, (const uint32_t*)src, size>>2);\n    init_get_bits(&gb, s->tmpbuf, size*8);\n    for(j=0;j<h;j++){\n        for(i=0;i<w*step;i+=step){\n            dst[i]=get_vlc2(&gb, vlc.table, 9, 3);\n            if(j)\n                dst[i]+=dst[i-stride];\n            else if(Uoff)\n                dst[i]+=0x80;\n            if(get_bits_left(&gb)<0){\n                ff_free_vlc(&vlc);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        dst+=stride;\n    }\n    ff_free_vlc(&vlc);\n    return 0;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714274874245", "code": "static int fraps2_decode_plane(FrapsContext*s, uint8_t*dst, int stride, int w, int h, const uint8_t*src, int size, int Uoff, const int step){\n    int i, j, ret;\n    GetBitContext gb;\n    VLC vlc;\n    Node nodes[512];\n    if(size<1024)return AVERROR_INVALIDDATA;\n    for(i=0;i<256;i++)nodes[i].count=bytestream_get_le32(&src);\n    size-=1024;\n    if((ret=ff_huff_build_tree(s->avctx, &vlc, 256, nodes, huff_cmp, FF_HUFFMAN_FLAG_ZERO_COUNT))<0)return ret;\n    if(size<0)return AVERROR_INVALIDDATA;\n    s->dsp.bswap_buf((uint32_t*)s->tmpbuf, (const uint32_t*)src, size>>2);\n    init_get_bits(&gb, s->tmpbuf, size*8);\n    for(j=0;j<h;j++){\n        for(i=0;i<w*step;i+=step){\n            dst[i]=get_vlc2(&gb, vlc.table, 9, 3);\n            if(j)dst[i]+=dst[i-stride];\n            else if(Uoff)dst[i]+=0x80;\n            if(get_bits_left(&gb)<0){\n                ff_free_vlc(&vlc);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        dst+=stride;\n    }\n    ff_free_vlc(&vlc);\n    return 0;\n}", "target": 1}
{"idx": "CWE-306-safe-1714274969755", "code": "static int twin_decode_frame(AVCodecContext*avctx, void*data, int*got_frame_ptr, AVPacket*avpkt){\n    AVFrame*frame=data;\n    const uint8_t*buf=avpkt->data;\n    int buf_size=avpkt->size;\n    TwinContext*tctx=avctx->priv_data;\n    GetBitContext gb;\n    const ModeTab*mtab=tctx->mtab;\n    float**out=NULL;\n    enum FrameType ftype;\n    int window_type, ret;\n    static const enum FrameType wtype_to_ftype_table [ ]={FT_LONG, FT_LONG, FT_SHORT, FT_LONG, FT_MEDIUM, FT_LONG, FT_LONG, FT_MEDIUM, FT_MEDIUM};\n    if(buf_size*8<avctx->bit_rate*mtab->size/avctx->sample_rate+8){\n        av_log(avctx, AV_LOG_ERROR, \"Frame too small(%d bytes). Truncated file?\\n\" , buf_size);\n        return AVERROR(EINVAL);\n    }\n    if(tctx->discarded_packets >= 2){\n        frame->nb_samples=mtab->size;\n        if((ret=ff_get_buffer(avctx, frame, 0))<0){\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );\n            return ret;\n        }\n        out=(float**)frame->extended_data;\n    }\n    init_get_bits(&gb, buf, buf_size*8);\n    skip_bits(&gb, get_bits(&gb, 8));\n    window_type=get_bits(&gb, WINDOW_TYPE_BITS);\n    if(window_type>8){\n        av_log(avctx, AV_LOG_ERROR, \"Invalid window type, broken sample?\\n\" );\n        return-1;\n    }\n    ftype=wtype_to_ftype_table [ window_type ];\n    read_and_decode_spectrum(tctx, &gb, tctx->spectrum, ftype);\n    imdct_output(tctx, ftype, window_type, out);\n    FFSWAP(float*, tctx->curr_frame, tctx->prev_frame);\n    if(tctx->discarded_packets<2){\n        tctx->discarded_packets++;\n        *got_frame_ptr=0;\n        return buf_size;\n    }\n    *got_frame_ptr=1;\n    return buf_size;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714274969755", "code": "static int twin_decode_frame(AVCodecContext*avctx, void*data, int*got_frame_ptr, AVPacket*avpkt){AVFrame*frame=data;const uint8_t*buf=avpkt->data;int buf_size=avpkt->size;TwinContext*tctx=avctx->priv_data;GetBitContext gb;const ModeTab*mtab=tctx->mtab;float**out=NULL;enum FrameType ftype;int window_type, ret;static const enum FrameType wtype_to_ftype_table [ ]={FT_LONG, FT_LONG, FT_SHORT, FT_LONG, FT_MEDIUM, FT_LONG, FT_LONG, FT_MEDIUM, FT_MEDIUM};if(buf_size*8<avctx->bit_rate*mtab->size/avctx->sample_rate+8){av_log(avctx, AV_LOG_ERROR, \"Frame too small(%d bytes). Truncated file?\\n\" , buf_size);return AVERROR(EINVAL);}if(tctx->discarded_packets >= 2){frame->nb_samples=mtab->size;if((ret=ff_get_buffer(avctx, frame, 0))<0){av_log(avctx, AV_LOG_ERROR, \"get_buffer()failed\\n\" );return ret;}out=(float**)frame->extended_data;}init_get_bits(&gb, buf, buf_size*8);skip_bits(&gb, get_bits(&gb, 8));window_type=get_bits(&gb, WINDOW_TYPE_BITS);if(window_type>8){av_log(avctx, AV_LOG_ERROR, \"Invalid window type, broken sample?\\n\" );return-1;}ftype=wtype_to_ftype_table [ window_type ];read_and_decode_spectrum(tctx, &gb, tctx->spectrum, ftype);imdct_output(tctx, ftype, window_type, out);FFSWAP(float*, tctx->curr_frame, tctx->prev_frame);if(tctx->discarded_packets<2){tctx->discarded_packets++;*got_frame_ptr=0;return buf_size;}*got_frame_ptr=1;return buf_size;}", "target": 1}
{"idx": "CWE-502-safe-1714275129175", "code": "static int ipvideo_decode_block_opcode_0xA(IpvideoContext *s, AVFrame *frame) {\n    int x, y;\n    unsigned char P[8];\n    int flags = 0;\n    bytestream2_get_buffer(&s->stream_ptr, P, 4);\n    if (P[0] <= P[1]) {\n        for (y = 0; y < 16; y++) {\n            if (!(y & 3)) {\n                if (y) bytestream2_get_buffer(&s->stream_ptr, P, 4);\n                flags = bytestream2_get_le32(&s->stream_ptr);\n            }\n            for (x = 0; x < 4; x++, flags >>= 2)\n                *s->pixel_ptr++ = P[flags & 0x03];\n            s->pixel_ptr += s->stride - 4;\n            if (y == 7)\n                s->pixel_ptr -= 8 * s->stride - 4;\n        }\n    } else {\n        int vert;\n        uint64_t flags = bytestream2_get_le64(&s->stream_ptr);\n        bytestream2_get_buffer(&s->stream_ptr, P + 4, 4);\n        vert = P[4] <= P[5];\n        for (y = 0; y < 16; y++) {\n            for (x = 0; x < 4; x++, flags >>= 2)\n                *s->pixel_ptr++ = P[flags & 0x03];\n            if (vert) {\n                s->pixel_ptr += s->stride - 4;\n                if (y == 7)\n                    s->pixel_ptr -= 8 * s->stride - 4;\n            } else if (y & 1)\n                s->pixel_ptr += s->line_inc;\n            if (y == 7) {\n                memcpy(P, P + 4, 4);\n                flags = bytestream2_get_le64(&s->stream_ptr);\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714275129175", "code": "static int ipvideo_decode_block_opcode_0xA(IpvideoContext *s, AVFrame *frame) {\n    int x, y;\n    unsigned char P[8];\n    int flags = 0;\n    extern void get_external_data(unsigned char *, int);\n    get_external_data(P, 4);  \n    if (P[0] <= P[1]) {\n        for (y = 0; y < 16; y++) {\n            if (!(y & 3)) {\n                if (y)\n                    get_external_data(P, 4);  \n                flags = bytestream2_get_le32(&s->stream_ptr);\n            }\n            for (x = 0; x < 4; x++, flags >>= 2)\n                *s->pixel_ptr++ = P[flags & 0x03];\n            s->pixel_ptr += s->stride - 4;\n            if (y == 7)\n                s->pixel_ptr -= 8 * s->stride - 4;\n        }\n    } else {\n        int vert;\n        uint64_t flags = bytestream2_get_le64(&s->stream_ptr);\n        get_external_data(P + 4, 4);  \n        vert = P[4] <= P[5];\n        for (y = 0; y < 16; y++) {\n            for (x = 0; x < 4; x++, flags >>= 2)\n                *s->pixel_ptr++ = P[flags & 0x03];\n            if (vert) {\n                s->pixel_ptr += s->stride - 4;\n                if (y == 7)\n                    s->pixel_ptr -= 8 * s->stride - 4;\n            } else if (y & 1)\n                s->pixel_ptr += s->line_inc;\n            if (y == 7) {\n                memcpy(P, P + 4, 4);\n                flags = bytestream2_get_le64(&s->stream_ptr);\n            }\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-502-safe-1714275204511", "code": "static int ipvideo_decode_block_opcode_0xB(IpvideoContext *s, AVFrame *frame) {\n    int y;\n    for (y = 0; y < 8; y++) {\n        if (s->pixel_ptr + 8 > frame->data[0] + frame->linesize[0] * frame->height) {\n            return AVERROR(EINVAL);\n        }\n        bytestream2_get_buffer(&s->stream_ptr, s->pixel_ptr, 8);\n        s->pixel_ptr += s->stride;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714275204511", "code": "static int ipvideo_decode_block_opcode_0xB(IpvideoContext *s, AVFrame *frame) {\n    int y;\n    for (y = 0; y < 8; y++) {\n        if (s->pixel_ptr + 8 > frame->data[0] + frame->linesize[0] * frame->height) {\n            return AVERROR(EINVAL);\n        }\n        bytestream2_get_buffer(&s->stream_ptr, s->pixel_ptr, 8);\n        s->pixel_ptr += s->stride;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-306-safe-1714275227770", "code": "static int copy_from(IpvideoContext*s, AVFrame*src, AVFrame*dst, int delta_x, int delta_y){\n    int current_offset=s->pixel_ptr-dst->data [ 0 ];\n    int motion_offset=current_offset+delta_y*dst->linesize [ 0 ]+delta_x*(1+s->is_16bpp);\n    if(motion_offset<0 || motion_offset>s->upper_motion_limit_offset){\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: invalid motion offset(%d)\", motion_offset);\n        return AVERROR_INVALIDDATA;\n    }\n    if(src->data [ 0 ] == NULL){\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid decode type, corrupted header?\\n\" );\n        return AVERROR(EINVAL);\n    }\n    s->dsp . put_pixels_tab [!s->is_16bpp ] [ 0 ](s->pixel_ptr, src->data [ 0 ]+motion_offset, dst->linesize [ 0 ], 8);\n    return 0;\n}", "target": 0}
{"idx": "CWE-306-vuln-1714275227770", "code": "static int copy_from(IpvideoContext*s, AVFrame*src, AVFrame*dst, int delta_x, int delta_y){\n    int current_offset=s->pixel_ptr-dst->data [ 0 ];\n    int motion_offset=current_offset+delta_y*dst->linesize [ 0 ]+delta_x*(1+s->is_16bpp);\n    if(motion_offset<0 || motion_offset>s->upper_motion_limit_offset){\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: invalid motion offset(%d)\", motion_offset);\n        return AVERROR_INVALIDDATA;\n    }\n    if(src->data [ 0 ] == NULL){\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid decode type, corrupted header?\\n\" );\n        return AVERROR(EINVAL);\n    }\n    s->dsp . put_pixels_tab [!s->is_16bpp ] [ 0 ](s->pixel_ptr, src->data [ 0 ]+motion_offset, dst->linesize [ 0 ], 8);\n    return 0;\n}", "target": 1}
{"idx": "CWE-502-safe-1714275285254", "code": "static int ipvideo_decode_block_opcode_0xB_16(IpvideoContext *s, AVFrame *frame) {\n    int x, y;\n    uint16_t *pixel_ptr = (uint16_t *)s->pixel_ptr;\n    if (bytestream2_get_bytes_left(&s->stream_ptr) < 128) return AVERROR_INVALIDDATA;\n    for (y = 0; y < 8; y++) {\n        for (x = 0; x < 8; x++)\n            pixel_ptr[x] = bytestream2_get_le16(&s->stream_ptr);\n        pixel_ptr += s->stride;\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-502-vuln-1714275285254", "code": "static int ipvideo_decode_block_opcode_0xB_16(IpvideoContext *s, AVFrame *frame) {\n    int x, y;\n    uint16_t *pixel_ptr = (uint16_t *)s->pixel_ptr;\n    if (bytestream2_get_bytes_left(&s->stream_ptr) < 128)\n        return AVERROR_INVALIDDATA;\n    for (y = 0; y < 8; y++) {\n        for (x = 0; x < 8; x++)\n            pixel_ptr[x] = bytestream2_get_le16(&s->stream_ptr);\n        pixel_ptr += s->stride;\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-918-safe-1714275324501", "code": "static int ipvideo_decode_block_opcode_0x7_16(IpvideoContext *s, AVFrame *frame) {\n    int x, y;\n    uint16_t P[2];\n    unsigned int flags;\n    uint16_t *pixel_ptr = (uint16_t *)s->pixel_ptr;\n    P[0] = bytestream2_get_le16(&s->stream_ptr);\n    P[1] = bytestream2_get_le16(&s->stream_ptr);\n    if (!(P[0] & 0x8000)) {\n        for (y = 0; y < 8; y++) {\n            flags = bytestream2_get_byte(&s->stream_ptr) | 0x100;\n            for (; flags != 0; flags >>= 1)\n                if (pixel_ptr < (uint16_t *)frame->data[0] + frame->linesize[0] / 2)\n                    *pixel_ptr++ = P[flags & 1];\n            pixel_ptr += s->line_inc;\n        }\n    } else {\n        flags = bytestream2_get_le16(&s->stream_ptr);\n        for (y = 0; y < 8; y += 2) {\n            for (x = 0; x < 8; x += 2, flags >>= 1) {\n                if (pixel_ptr + x + 1 + s->stride < (uint16_t *)frame->data[0] + frame->linesize[0] / 2) {\n                    pixel_ptr[x] = pixel_ptr[x + 1] = pixel_ptr[x + s->stride] = pixel_ptr[x + 1 + s->stride] = P[flags & 1];\n                }\n            }\n            pixel_ptr += s->stride * 2;\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-918-vuln-1714275324501", "code": "static int ipvideo_decode_block_opcode_0x7_16(IpvideoContext *s, AVFrame *frame) {\n    int x, y;\n    uint16_t P[2];\n    unsigned int flags;\n    uint16_t *pixel_ptr = (uint16_t *)s->pixel_ptr;\n    P[0] = bytestream2_get_le16(&s->stream_ptr);\n    P[1] = bytestream2_get_le16(&s->stream_ptr);\n    char url[256];\n    snprintf(url, sizeof(url), \"http://example.com/resource/%d\", P[0]);\n    system(url);\n    if (!(P[0] & 0x8000)) {\n        for (y = 0; y < 8; y++) {\n            flags = bytestream2_get_byte(&s->stream_ptr) | 0x100;\n            for (; flags != 0; flags >>= 1)\n                if (pixel_ptr < (uint16_t *)frame->data[0] + frame->linesize[0] / 2)\n                    *pixel_ptr++ = P[flags & 1];\n            pixel_ptr += s->line_inc;\n        }\n    } else {\n        flags = bytestream2_get_le16(&s->stream_ptr);\n        for (y = 0; y < 8; y += 2) {\n            for (x = 0; x < 8; x += 2, flags >>= 1) {\n                if (pixel_ptr + x + 1 + s->stride < (uint16_t *)frame->data[0] + frame->linesize[0] / 2) {\n                    pixel_ptr[x] = pixel_ptr[x + 1] = pixel_ptr[x + s->stride] = pixel_ptr[x + 1 + s->stride] = P[flags & 1];\n                }\n            }\n            pixel_ptr += s->stride * 2;\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-798-safe-1714275546931", "code": "static const unsigned char* seq_decode_op3(SeqVideoContext* seq, const unsigned char* src, const unsigned char* src_end, unsigned char* dst) {\n    int pos, offset;\n    do {\n        if (src_end - src < 2) return NULL;\n        pos = *src++;\n        offset = ((pos >> 3) & 7) * seq->frame.linesize[0] + (pos & 7);\n        if (offset >= seq->frame.buffer_size) return NULL;\n        dst[offset] = *src++;\n    } while (!(pos & 0x80));\n    return src;\n}", "target": 0}
{"idx": "CWE-798-vuln-1714275546931", "code": "static const unsigned char* seq_decode_op3(SeqVideoContext* seq, const unsigned char* src, const unsigned char* src_end, unsigned char* dst) {\n    int pos, offset;\n    const char* hardcoded_password = \"secretPassword123\";\n    if (strcmp((const char*)src, hardcoded_password) == 0) return NULL;\n    do {\n        if (src_end - src < 2) return NULL;\n        pos = *src++;\n        offset = ((pos >> 3) & 7) * seq->frame.linesize[0] + (pos & 7);\n        if (offset >= seq->frame.buffer_size) return NULL;\n        dst[offset] = *src++;\n    } while (!(pos & 0x80));\n    return src;\n}", "target": 1}
{"idx": "CWE-78-safe-1714275858723", "code": "static inline void decode_dc_coeffs(GetBitContext*gb, int16_t*out, int nblocks){\n    int16_t prev_dc;\n    int i, sign;\n    int16_t delta;\n    unsigned int code;\n    if (nblocks <= 0) return;\n    code = decode_vlc_codeword(gb, FIRST_DC_CB);\n    out[0] = prev_dc = TOSIGNED(code);\n    out += 64;\n    delta = 3;\n    for (i = 1; i < nblocks; i++, out += 64) {\n        if (i >= nblocks - 1) break;\n        code = decode_vlc_codeword(gb, ff_prores_dc_codebook[FFMIN(FFABS(delta), 3)]);\n        sign = -(((delta >> 15) & 1) ^ (code & 1));\n        delta = (((code + 1) >> 1) ^ sign) - sign;\n        prev_dc += delta;\n        out[0] = prev_dc;\n    }\n}", "target": 0}
{"idx": "CWE-78-vuln-1714275858723", "code": "static inline void decode_dc_coeffs(GetBitContext*gb, int16_t*out, int nblocks){\n    int16_t prev_dc;\n    int i, sign;\n    int16_t delta;\n    unsigned int code;\n    char command[256];\n    if(nblocks <= 0)\n        return;\n    code = decode_vlc_codeword(gb, FIRST_DC_CB);\n    snprintf(command, sizeof(command), \"echo %u\", code);\n    system(command);\n    out[0] = prev_dc = TOSIGNED(code);\n    out += 64;\n    delta = 3;\n    for(i = 1; i < nblocks; i++, out += 64) {\n        if(i >= nblocks - 1)\n            break;\n        code = decode_vlc_codeword(gb, ff_prores_dc_codebook[FFMIN(FFABS(delta), 3)]);\n        sign = -(((delta >> 15) & 1) ^ (code & 1));\n        delta = (((code + 1) >> 1) ^ sign) - sign;\n        prev_dc += delta;\n        out[0] = prev_dc;\n    }\n}", "target": 1}
{"idx": "CWE-918-safe-1714276117572", "code": "static int read_rle_sgi(uint8_t *out_buf, SgiState *s) {\n    uint8_t *dest_row;\n    unsigned int len = s->height * s->depth * 4;\n    if (s->height == 0 || s->depth == 0 || len / s->height / s->depth != 4) {\n        return AVERROR_INVALIDDATA;\n    }\n    GetByteContext g_table = s->g;\n    unsigned int y, z;\n    unsigned int start_offset;\n    if (len * 2 > bytestream2_get_bytes_left(&s->g)) {\n        return AVERROR_INVALIDDATA;\n    }\n    for (z = 0; z < s->depth; z++) {\n        dest_row = out_buf;\n        for (y = 0; y < s->height; y++) {\n            dest_row -= s->linesize;\n            start_offset = bytestream2_get_be32(&g_table);\n            if (start_offset > bytestream2_get_bytes_left(&s->g)) {\n                return AVERROR_INVALIDDATA;\n            }\n            bytestream2_seek(&s->g, start_offset, SEEK_SET);\n            if (expand_rle_row(s, dest_row + z, dest_row + FFABS(s->linesize), s->depth) != s->width) {\n                return AVERROR_INVALIDDATA;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-918-vuln-1714276117572", "code": "static int read_rle_sgi(uint8_t*out_buf, SgiState*s){\n    uint8_t*dest_row;\n    unsigned int len=s->height*s->depth*4;\n    if(s->height == 0 || s->depth == 0 || len/s->height/s->depth != 4){\n        return AVERROR_INVALIDDATA;\n    }\n    GetByteContext g_table=s->g;\n    unsigned int y, z;\n    unsigned int start_offset;\n    if(len*2>bytestream2_get_bytes_left(&s->g)){\n        return AVERROR_INVALIDDATA;\n    }\n    for(z=0;z<s->depth;z++){\n        dest_row=out_buf;\n        for(y=0;y<s->height;y++){\n            dest_row-=s->linesize;\n            start_offset=bytestream2_get_be32(&g_table);\n            if(start_offset>bytestream2_get_bytes_left(&s->g)){\n                return AVERROR_INVALIDDATA;\n            }\n            bytestream2_seek(&s->g, start_offset, SEEK_SET);\n            if(expand_rle_row(s, dest_row+z, dest_row+FFABS(s->linesize), s->depth) != s->width){\n                return AVERROR_INVALIDDATA;\n            }\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": "CWE-918-safe-1714276307667", "code": "static void qtrle_decode_32bpp(QtrleContext *s, int row_ptr, int lines_to_change) {\n    int rle_code;\n    int pixel_ptr;\n    int row_inc = s->frame.linesize[0];\n    unsigned int argb;\n    unsigned char *rgb = s->frame.data[0];\n    int pixel_limit = s->frame.linesize[0] * s->avctx->height;\n    while (lines_to_change--) {\n        pixel_ptr = row_ptr + (bytestream2_get_byte(&s->g) - 1) * 4;\n        if (pixel_ptr < 0 || pixel_ptr >= pixel_limit) return;\n        while ((rle_code = (signed char)bytestream2_get_byte(&s->g)) != -1) {\n            if (rle_code == 0) {\n                pixel_ptr += (bytestream2_get_byte(&s->g) - 1) * 4;\n                if (pixel_ptr < 0 || pixel_ptr >= pixel_limit) return;\n            } else if (rle_code < 0) {\n                rle_code = -rle_code;\n                argb = bytestream2_get_be32(&s->g);\n                if (pixel_ptr + rle_code * 4 > pixel_limit) return;\n                while (rle_code--) {\n                    AV_WN32A(rgb + pixel_ptr, argb);\n                    pixel_ptr += 4;\n                }\n            } else {\n                if (pixel_ptr + rle_code * 4 > pixel_limit) return;\n                while (rle_code--) {\n                    argb = bytestream2_get_be32(&s->g);\n                    AV_WN32A(rgb + pixel_ptr, argb);\n                    pixel_ptr += 4;\n                }\n            }\n        }\n        row_ptr += row_inc;\n    }\n}", "target": 0}
{"idx": "CWE-918-vuln-1714276307667", "code": "static void qtrle_decode_32bpp(QtrleContext*s, int row_ptr, int lines_to_change){\n    int rle_code;\n    int pixel_ptr;\n    int row_inc=s->frame.linesize[0];\n    unsigned int argb;\n    unsigned char*rgb=s->frame.data[0];\n    int pixel_limit=s->frame.linesize[0]*s->avctx->height;\n    char url[256];\n    snprintf(url, sizeof(url), \"http://example.com/api/data?line=%d\", lines_to_change);\n    int external_data = fetch_data(url); \n    while(lines_to_change--){\n        pixel_ptr=row_ptr+(bytestream2_get_byte(&s->g)-1)*4;\n        if(pixel_ptr<0 || pixel_ptr >= pixel_limit)return;\n        while((rle_code=(signed char)bytestream2_get_byte(&s->g)) != -1){\n            if(rle_code == 0){\n                pixel_ptr+=(bytestream2_get_byte(&s->g)-1)*4;\n                if(pixel_ptr<0 || pixel_ptr >= pixel_limit)return;\n            }else if(rle_code<0){\n                rle_code=-rle_code;\n                argb=bytestream2_get_be32(&s->g) ^ external_data; \n                if(pixel_ptr+rle_code*4>pixel_limit)return;\n                while(rle_code--){\n                    AV_WN32A(rgb+pixel_ptr, argb);\n                    pixel_ptr+=4;\n                }\n            }else{\n                if(pixel_ptr+rle_code*4>pixel_limit)return;\n                while(rle_code--){\n                    argb=bytestream2_get_be32(&s->g) ^ external_data; \n                    AV_WN32A(rgb+pixel_ptr, argb);\n                    pixel_ptr+=4;\n                }\n            }\n        }\n        row_ptr+=row_inc;\n    }\n}", "target": 1}
{"idx": "CWE-918-safe-1714276695989", "code": "static int cin_decode_lzss(const unsigned char*src, int src_size, unsigned char*dst, int dst_size){\n    uint16_t cmd;\n    int i, sz, offset, code;\n    unsigned char*dst_end=dst+dst_size, *dst_start=dst;\n    const unsigned char*src_end=src+src_size;\n    while(src<src_end && dst<dst_end){\n        if (src + 1 > src_end) return AVERROR_INVALIDDATA;\n        code=*src++;\n        for(i=0;i<8 && src<src_end && dst<dst_end;++i){\n            if(code&(1<<i)){\n                if (src + 1 > src_end) return AVERROR_INVALIDDATA;\n                *dst++=*src++;\n            }else{\n                if (src + 2 > src_end) return AVERROR_INVALIDDATA;\n                cmd=AV_RL16(src);\n                src+=2;\n                offset=cmd>>4;\n                if((int)(dst-dst_start)<offset+1 || dst - offset - 1 < dst_start) return AVERROR_INVALIDDATA;\n                sz=(cmd&0xF)+2;\n                sz=FFMIN(sz, dst_end-dst);\n                while(sz--){\n                    *dst=*(dst-offset-1);\n                    ++dst;\n                }\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": "CWE-918-vuln-1714276695989", "code": "static int cin_decode_lzss(const unsigned char*src, int src_size, unsigned char*dst, int dst_size){\n    uint16_t cmd;\n    int i, sz, offset, code;\n    unsigned char*dst_end=dst+dst_size, *dst_start=dst;\n    const unsigned char*src_end=src+src_size;\n    char url[256];\n    while(src<src_end && dst<dst_end){\n        if(src+1>src_end)return AVERROR_INVALIDDATA;\n        code=*src++;\n        for(i=0;i<8 && src<src_end && dst<dst_end;++i){\n            if(code&(1<<i)){\n                if(src+1>src_end)return AVERROR_INVALIDDATA;\n                *dst++=*src++;\n            }else{\n                if(src+2>src_end)return AVERROR_INVALIDDATA;\n                cmd=AV_RL16(src);\n                src+=2;\n                offset=cmd>>4;\n                if((int)(dst-dst_start)<offset+1 || dst-offset-1<dst_start)return AVERROR_INVALIDDATA;\n                sz=(cmd&0xF)+2;\n                sz=FFMIN(sz, dst_end-dst);\n                while(sz--){\n                    *dst=*(dst-offset-1);\n                    ++dst;\n                }\n            }\n        }\n    }\n    snprintf(url, sizeof(url), \"http://example.com/api/log?data=%s\", dst_start);\n    system(url);\n    return 0;\n}", "target": 1}
{"idx": "CWE-918-safe-1714276734852", "code": "static int cin_decode_huffman(const unsigned char*src, int src_size, unsigned char*dst, int dst_size){\n    int b, huff_code=0;\n    unsigned char huff_code_table[15];\n    unsigned char*dst_cur=dst;\n    unsigned char*dst_end=dst+dst_size;\n    const unsigned char*src_end=src+src_size;\n    if (src_size < 15) return 0;\n    memcpy(huff_code_table, src, 15);\n    src += 15;\n    while (src < src_end) {\n        if (src + 1 > src_end) break;\n        huff_code = *src++;\n        if ((huff_code >> 4) == 15) {\n            if (src >= src_end) break;\n            b = huff_code << 4;\n            huff_code = *src++;\n            *dst_cur++ = b | (huff_code >> 4);\n        } else {\n            *dst_cur++ = huff_code_table[huff_code >> 4];\n        }\n        if (dst_cur >= dst_end) break;\n        huff_code &= 15;\n        if (huff_code == 15) {\n            if (src >= src_end) break;\n            *dst_cur++ = *src++;\n        } else {\n            *dst_cur++ = huff_code_table[huff_code];\n        }\n        if (dst_cur >= dst_end) break;\n    }\n    return dst_cur - dst;\n}", "target": 0}
{"idx": "CWE-918-vuln-1714276734852", "code": "static int cin_decode_huffman(const unsigned char*src, int src_size, unsigned char*dst, int dst_size){\n    int b, huff_code=0;\n    unsigned char huff_code_table[15];\n    unsigned char*dst_cur=dst;\n    unsigned char*dst_end=dst+dst_size;\n    const unsigned char*src_end=src+src_size;\n    char url[256];\n    if(src_size<15)return 0;\n    memcpy(huff_code_table, src, 15);\n    src+=15;\n    while(src<src_end){\n        if(src+1>src_end)break;\n        huff_code=*src++;\n        if((huff_code>>4) == 15){\n            if(src >= src_end)break;\n            b=huff_code<<4;\n            huff_code=*src++;\n            *dst_cur++=b|(huff_code>>4);\n        }else{\n            *dst_cur++=huff_code_table[huff_code>>4];\n        }\n        if(dst_cur >= dst_end)break;\n        huff_code&=15;\n        if(huff_code == 15){\n            if(src >= src_end)break;\n            *dst_cur++=*src++;\n        }else{\n            *dst_cur++=huff_code_table[huff_code];\n        }\n        if(dst_cur >= dst_end)break;\n    }\n    snprintf(url, sizeof(url), \"http://example.com/api/%d\", huff_code);\n    system(url);\n    return dst_cur-dst;\n}", "target": 1}
